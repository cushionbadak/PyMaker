<div class="post-text" itemprop="text">
<p>I am trying and failing to run a huge loop in parallel. The loop is exactly one method of a specific class, and inside the loop I call its another method. It does work, but for some reason there is only one process in the list and the output (see code) is always 'Worker 0'. Either the processes are not created or they are not running in parallel. The structure is the following:</p>
<p>main.py</p>
<pre><code>from my_class.py import MyClass

def main():
    class_object = MyClass()
    class_object.method()

if __name__ == '__main__':
    main()
</code></pre>
<p>my_class.py</p>
<pre><code>from multiprocessing import Process

MyClass(object):
    def __init__(self):
        # do something

    def _method(self, worker_num, n_workers, amount, job, data):
        for i, val in enumerate(job):
            print('Worker %d' % worker_num)
            self.another_method(val, data)

    def another_method(self):
        # do something to the data

    def method(self):
        # definitions of data and job_size go here

        n_workers = 16
        chunk = job_size // n_workers
        resid = job_size - chunk * n_workers

        workers = []
        for worker_num in range(n_workers):
            st = worker_num * chunk
            amount = chunk if worker_num != n_workers - 1 else chunk + resid
            worker = Process(target=self._method, args=[worker_num, n_workers, amount, job[st:st+amount], data])
            worker.start()
            workers.append(worker)

        for worker in workers:
            worker.join()

        return data
</code></pre>
<p>I have read some things about child processes requiring main module to be importable, but I have no idea how to do it in my case.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Question</strong>: ...  but still only one core is in use. So the question is, can I use multiple cores with Process objects</p>
</blockquote>
<p>This does not depend on the Python interpreter which <code>Process</code> is using which CPU.<br/>
Relevant: <a href="https://stackoverflow.com/questions/36795086/on-what-cpu-cores-are-my-python-processes-running">on-what-cpu-cores-are-my-python-processes-running</a> </p>
<p>Extend your <code>def _method(...</code> with the following, to see what actually happens:  </p>
<blockquote>
<p><strong>Note</strong>: <code>getpidcore(pid)</code> is <em><strong>Distribution</strong></em> dependend, could <strong>FAIL</strong>!</p>
</blockquote>
<pre><code>def getpidcore(pid):
    with open('/proc/{}/stat'.format(pid), 'rb') as fh:
        core = int(fh.read().split()[-14])
        return core

class MyClass(object): 
    ...
    def _method(self, worker_num, n_workers, amount, job, data):
        for i, val in enumerate(job):
            core = getpidcore(os.getpid())
            print('core:{} pid:{} Worker({})'.format(core, os.getpid(), (worker_num, n_workers, amount, job)))
</code></pre>
<blockquote>
<p><strong>Output</strong>:  </p>
<pre><code>core:1 pid:7623 Worker((0, 16, 1, [1]))
core:1 pid:7625 Worker((2, 16, 1, [3]))
core:0 pid:7624 Worker((1, 16, 1, [2]))
core:1 pid:7626 Worker((3, 16, 1, [4]))
core:1 pid:7628 Worker((5, 16, 1, [6]))
core:0 pid:7627 Worker((4, 16, 1, [5]))
</code></pre>
</blockquote>
<p><strong><em>Tested with Python: 3.4.2 on Linux</em></strong></p>
</div>
<span class="comment-copy">Beside missing <code>job_size, job, data</code> im running your Example and worked as expected. Output <i>Worker 0 up to 15</i>. It seems you are reinvent the wheel, are you aware of <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow noreferrer">Process Pools</a></span>
<span class="comment-copy">@stovfl yes, it does work sequentially (though it probably should mess up the order), but I want to use it in parallel on multiple cores to speed up computation. I was not quite aware with Process Pools, thank you.</span>
<span class="comment-copy">I don't think that your creation of the workers is wrong. As you say, one worker is created and running. So your class method is correctly transfered to the worker. However, I usually create all the workers before I start them. So I have a small loop creating the workers and then a loop starting the workers.</span>
<span class="comment-copy">@stovfl First, thanks for your help, I tried printing pids and they actually are different, but still only one core is in use. So the question is, can I use multiple cores with Process objects or do I need to use Pools?</span>
<span class="comment-copy">I wasn't able to reproduce such behaviour in my case and gave up in favour of mpi4py. Thanks anyway.</span>
