<div class="post-text" itemprop="text">
<p>I have to open several thousand files, but only read the first 3 lines.</p>
<p>Currently, I am doing this:</p>
<pre><code>def test_readline(filename):
    fid = open(filename, 'rb')
    lines = [fid.readline() for i in range(3)]
</code></pre>
<p>Which yields the result:</p>
<blockquote>
<p>The slowest run took 10.20 times longer than the fastest. This could
  mean that an intermediate result is being cached. 10000 loops, best of
  3: 59.2 µs per loop</p>
</blockquote>
<p>An alternate solution would be to convert the fid to a list:</p>
<pre><code>def test_list(filename):
    fid = open(filename, 'rb')
    lines = list(fid) 

%timeit test_list(MYFILE)
</code></pre>
<blockquote>
<p>The slowest run took 4.92 times longer than the fastest. This could
  mean that an intermediate result is being cached. 10000 loops, best of
  3: 374 µs per loop</p>
</blockquote>
<p>Yikes!! Is there a faster way to only read the first 3 lines of these files, or is readline() the best?  Can you respond with alternatives and timings please?  </p>
<p>But at the end-of-the-day I have to open thousands of individual files and they will not be cached.  Thus, does it even matter (looks like it does)? </p>
<p>(603µs uncached method readline vs. 1840µs list method)</p>
<p>Additionally, here is the readlines() method:</p>
<pre><code>def test_readlines(filename):
    fid = open(filename, 'rb')
    lines = fid.readlines() 
    return lines
</code></pre>
<blockquote>
<p>The slowest run took 7.17 times longer than the fastest. This could
  mean that an intermediate result is being cached. 10000 loops, best of
  3: 334 µs per loop</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can slice an iterable with <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>import itertools


def test_list(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        return list(itertools.islice(f, 3))
</code></pre>
<p>(I changed the <code>open</code> up a bit because it’s slightly unusual to read files in binary mode by line, but you can revert that.)</p>
</div>
<span class="comment-copy">600µs for 1000 files is still just 0.6 seconds. Not bad for operating on 1000 files I'd say. "Faster" is fine, but at what point is it <i>too slow</i>? How often do you have to do this and how fast does it need to be?</span>
<span class="comment-copy">If you know that the first three lines won’t ever exceed a certain size and you’re okay with overshooting, <code>.readlines()</code> also accepts a parameter with a maximum number of bytes or characters to read. Little weird for most situations though.</span>
<span class="comment-copy">600µs is per file.  So it does 'add up'.  And I am doing a lot of other things later in the code.  Every bit helps and trying to optimize.</span>
<span class="comment-copy">@Ryan You should add as an answer instead of a comment and I can time it. But from what I know of readlines() is that it would read the entire file first.</span>
<span class="comment-copy">@evanleeturner: It’s conditional on something you haven’t answered. Do the first three lines have a hard size limit?</span>
<span class="comment-copy">I had to modify this slightly to work.  I get a UTF-8 error when I run on my files because they are binary, so I removed encoding= and added back 'rb'.  on timeit this yields The slowest run took 35.51 times longer than the fastest. This could mean that an intermediate result is being cached. 10000 loops, best of 3: 53.6 µs per loop</span>
<span class="comment-copy">I've ran timeit multiple times:  ~824 µs is the total noncache time, so still not faster than readline  The slowest run took 15.32 times longer than the fastest. This could mean that an intermediate result is being cached. 10000 loops, best of 3: 53.8 µs per loop</span>
<span class="comment-copy">@evanleeturner: Yeah, this answer is just more Pythonic. It’s going to be the same speed as multiple <code>.readline()</code> calls, and you’re not going to get much faster than that.</span>
