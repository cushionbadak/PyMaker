<div class="post-text" itemprop="text">
<pre><code>if form.admirer_or_model == "model":
    model_form_css_style = None
</code></pre>
<p><strong>form</strong> might be None, and <strong>admirer_or_model</strong> might not exist in form.</p>
<p>What is the most elegant way to handle this situation ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a>, passing a sentinel value as default:</p>
<pre><code>if getattr(form, 'admirer_or_model', form) == "model":
    ...
</code></pre>
<p>The above will do until Python implements <a href="https://en.wikipedia.org/wiki/Safe_navigation_operator" rel="nofollow noreferrer"><em>safe navigation</em></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a multitude of possible choices. Which is the most convenient generally depends on how much your code flow is supposed to change if the error occurs.</p>
<ul>
<li><p><strong>If the flow is obliterated completely - i.e. the function just breaks</strong></p>
<ul>
<li><p>don't do anything and it will raise an <code>AttributeError</code> in both cases:</p>
<pre><code>if form.admirer_or_model == "model":  # will raise AttributeError in both cases
                                      #'cuz None has no such attribute, either
    &lt;...&gt;
</code></pre></li>
</ul></li>
<li><p><strong>If the flow changes drastically - i.e. there's some short error handling code that exits the function afterwards</strong></p>
<ul>
<li><p>Handle the <code>AttributeError</code> - especially if both cases are to be handled the same:</p>
<pre><code>try: if form.admirer_or_model == "model":
    &lt;...&gt;
except AttributeError as e:
    &lt;handle the error and quit, e.g.&gt;
    raise TypeError("`form': " + e.message)    # a common way to signal that
                                               #an argument failed a type and/or
                                               #a duck test
</code></pre></li>
<li><p>check as in the next suggestion, but without an <code>else</code> clause:</p>
<pre><code>if form is None or not hasattr(form,'admirer_or_model'):
    &lt;handle the error and quit&gt;
&lt;continue normally&gt;
</code></pre></li>
</ul></li>
<li><p><strong>If the flow changes, but the function still works - i.e. you provide an alternative code block to the "normal" one that then proceeds further</strong></p>
<ul>
<li><p>check <code>if(form)</code> or <code>if(form is (not) None)</code> (if a valid <code>form</code> can evaluate to <code>False</code>) and <code>hasattr(form,'admirer_or_model')</code>, with <code>else</code> clause containing the alternative block:</p>
<pre><code>if form and hasattr(form,'admirer_or_model'):
    &lt;normal case&gt;
else:
    &lt;alternate case&gt;
&lt;proceed further&gt;
</code></pre></li>
<li><p>Handle the error but don't quit - especially if the handling is common for both errors:</p>
<pre><code>try: if form.admirer_or_model == "model":
    &lt;processing on no error and the condition true&gt;
except AttributeError as e:
    &lt;processing only on error&gt;
&lt;continue normally&gt;
</code></pre></li>
</ul></li>
<li><p><strong>If the flow doesn't change at all, i.e. you just provide a default value</strong></p>
<ul>
<li><p>use a ternary/other default-providing construct - e.g. <code>form if form else &lt;default&gt;</code> and <code>getattr(form,'admirer_or_model',&lt;default&gt;)</code>:</p>
<pre><code>if getattr(
        (form if form else &lt;default&gt;),
        'admirer_or_model',&lt;default&gt;) == "model":
    &lt;...&gt;
</code></pre></li>
</ul></li>
</ul>
<hr/>
<p>Also note that some of these constructs place the error handling block before the <code>if</code> block with <code>== "model"</code> and some - after it. If the <code>if</code> block is large, this can make a difference in readability: an error handling block is best placed close to the line that triggers the error.</p>
</div>
<span class="comment-copy">That is, <i>if</i> Python ever implements safe navigation. And that is a big "if" 'cuz to fail "loudly" (raise an exception and disrupt the flow) and to fail "silently" (return an "empty value" and continue with the flow) are two different fundamental choices to make, and Python gravitates towards the former (Python Zen, koan 10: "Errors should never pass silently.").</span>
