<div class="post-text" itemprop="text">
<p>I have a dictionary of the following form:</p>
<pre><code>{
    "b":{
          "ba": {
                 "Score":3,
                 "N":500
                },
          "aa": {
                 "Score": 10,
                 "N":300
                },
        },
    "a":{
         "xy": {
                 "Score":199,
                 "N":7
               },
         "zz": {
                 "Score":222,
                 "N":55
               },
         }
}
</code></pre>
<p>I want the first dimension to be sorted alphabetically, but the second to be sorted by <code>Score</code>, such that when sorted it would look like:</p>
<pre><code>{
    "a":{
         "zz": {
                 "Score":222,
                 "N":55
               },
         "xy": {
                 "Score":199,
                 "N":7
               }
         },
    "b":{
          "aa": {
                 "Score": 10,
                 "N":300
                },
          "ba": {
                 "Score":3,
                 "N":500
                }
        }
}
</code></pre>
<p>I have searched for an answer to this for a while, but I have only found how to sort a single dimension in a dictionary. What would be the best pythonic way to go about doing this?</p>
<p>After sorting I need to dump it to a file which I was planning on using the <code>json</code> module for. So doing something like: </p>
<pre><code>with open("out.json", 'w') as fp:
    json.dump(my_dict, fp, sort_keys=True, indent=4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create an appropriate <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> using eg:</p>
<pre><code>ordered = OrderedDict(
    [(k, OrderedDict(
        sorted(v.items(), key=lambda pair: -pair[1]["Score"]))) 
     for k, v in sorted(data.items())])
</code></pre>
<p>Now dump it to json</p>
<pre><code>&gt;&gt;&gt; print(json.dumps(ordered, indent=2))
{
  "a": {
    "zz": {
      "Score": 222, 
      "N": 55
    }, 
    "xy": {
      "Score": 199, 
      "N": 7
    }
  }, 
  "b": {
    "aa": {
      "Score": 10, 
      "N": 300
    }, 
    "ba": {
      "Score": 3, 
      "N": 500
    }
  }
}
</code></pre>
<p><strong>NOTE:</strong> You could use <code>reverse=True</code> inside the inner sort instead of negating the score, depends how you feel ...</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> because plain dictionaries are unordered so putting the sorted dict in another plain dict would throw away the order again. </p>
<p>Then first sort the outer keys and then sort the inner dictionaries in-place:</p>
<pre><code>from collections import OrderedDict

d = {"b":{"ba": {"Score":3, "N":500},
          "aa": {"Score": 10, "N":300},},
    "a":{"xy": {"Score":199, "N":7},
         "zz": {"Score":222, "N":55},}}

d = OrderedDict(sorted(d.items()))  # sorts the outer keys
for k, v in d.items():
    # sort the inner keys by score
    d[k] = OrderedDict(sorted(v.items(), key=lambda x: x[1]['Score'], reverse=True))
</code></pre>
<p>Afterwards <code>d</code> looks like this:</p>
<pre><code>OrderedDict([('a',
              OrderedDict([('zz', {'N': 55, 'Score': 222}),
                           ('xy', {'N': 7, 'Score': 199})])),
             ('b',
              OrderedDict([('aa', {'N': 300, 'Score': 10}),
                           ('ba', {'N': 500, 'Score': 3})]))])
</code></pre>
</div>
<span class="comment-copy">Just a minor obstacle: dictionaries are unordered.</span>
<span class="comment-copy">@MSeifert I know dictionaries are unordered when stored in Python, but I need to output it sorted (as stated) into a json file, as per my edit.</span>
<span class="comment-copy">So using an <code>OrderedDict</code> would be fine?</span>
<span class="comment-copy">building an ordereddict containing other ordereddicts and dump them as json.</span>
