<div class="post-text" itemprop="text">
<p>i am trying to extract a specific line as variable in file.</p>
<p>this is content of my test.txt</p>
<pre><code>#first set
Task Identification Number: 210CT1
Task title: Assignment 1
Weight: 25
fullMark: 100
Description: Program and design and complexity running time.

#second set
Task Identification Number: 210CT2
Task title: Assignment 2
Weight: 25
fullMark: 100
Description: Shortest Path Algorithm

#third set
Task Identification Number: 210CT3
Task title: Final Examination
Weight: 50
fullMark: 100
Description: Close Book Examination
</code></pre>
<p>this is my code </p>
<pre><code>with open(home + '\\Desktop\\PADS Assignment\\test.txt', 'r') as mod:
    for line in mod:
        taskNumber , taskTile , weight, fullMark , desc = line.strip(' ').split(": ") 
        print(taskNumber)
        print(taskTile)
        print(weight)
        print(fullMark)
        print(description)
</code></pre>
<p>here is what i'm trying to do:</p>
<pre><code>taskNumber is 210CT1 
taskTitle is Assignment 1
weight is 25
fullMark is 100
desc is Program and design and complexity running time

and loop until the third set 
</code></pre>
<p>but there's an error occurred in the output</p>
<pre><code>ValueError: not enough values to unpack (expected 5, got 2)
</code></pre>
<p>Reponse for SwiftsNamesake</p>
<p>i tried out your code . i am still getting an error.</p>
<pre><code>ValueError: too many values to unpack (expected 5)
</code></pre>
<p>this is my attempt by using your code</p>
<pre><code> from itertools import zip_longest

 def chunks(iterable, n, fillvalue=None):
     args = [iter(iterable)] * n
     return zip_longest(*args, fillvalue=fillvalue)


with open(home + '\\Desktop\\PADS Assignment\\210CT.txt', 'r') as mod:
    for group in chunks(mod.readlines(), 5+2, fillvalue=''):
    # Choose the item after the colon, excluding the extraneous rows
    # that don't have one.
    # You could probably find a more elegant way of achieving the same thing
        l = [item.split(': ')[1].strip() for item in group if ':' in item]
    taskNumber , taskTile , weight, fullMark , desc = l
        print(taskNumber , taskTile , weight, fullMark , desc, sep='|')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As previously mentioned, you need some sort of chunking. To chunk it usefully we'd also need to ignore the irrelevant lines of the file. I've implemented such a function with some nice Python witchcraft below.</p>
<p>It might also suit you to use a namedtuple to store the values. A namedtuple is a pretty simple type of object, that just stores a number of different values - for example, a point in 2D space might be a namedtuple with an x and a y field. This is the example given in the <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">Python documentation</a>. You should refer to that link for more info on namedtuples and their uses, if you wish. I've taken the liberty of making a Task class with the fields <code>["number", "title", "weight", "fullMark", "desc"]</code>.</p>
<p>As your variables are all properties of a task, using a named tuple might make sense in the interest of brevity and clarity.</p>
<p>Aside from that, I've tried to generally stick to your approach, splitting by the colon. My code produces the output</p>
<pre><code>================================================================================
number is 210CT1
title is Assignment 1
weight is 25
fullMark is 100
desc is Program and design and complexity running time.
================================================================================
number is 210CT2
title is Assignment 2
weight is 25
fullMark is 100
desc is Shortest Path Algorithm
================================================================================
number is 210CT3
title is Final Examination
weight is 50
fullMark is 100
desc is Close Book Examination
</code></pre>
<p>which seems to be roughly what you're after - I'm not sure how strict your output requirements are. It should be relatively easy to modify to that end, though.</p>
<p>Here is my code, with some explanatory comments:</p>
<pre><code>from collections import namedtuple

#defines a simple class 'Task' which stores the given properties of a task
Task = namedtuple("Task", ["number", "title", "weight", "fullMark", "desc"])

#chunk a file (or any iterable) into groups of n (as an iterable of n-tuples)
def n_lines(n, read_file):
    return zip(*[iter(read_file)] * n)

#used to strip out empty lines and lines beginning with #, as those don't appear to contain any information
def line_is_relevant(line):
    return line.strip() and line[0] != '#'

with open("input.txt") as in_file:
    #filters the file for relevant lines, and then chunks into 5 lines
    for task_lines in n_lines(5, filter(line_is_relevant, in_file)):
        #for each line of the task, strip it, split it by the colon and take the second element
        #(ie the remainder of the string after the colon), and build a Task from this
        task = Task(*(line.strip().split(": ")[1] for line in task_lines))
        #just to separate each parsed task
        print("=" * 80)
        #iterate over the field names and values in the task, and print them
        for name, value in task._asdict().items():
            print("{} is {}".format(name, value))
</code></pre>
<p>You can also reference each field of the Task, like this:</p>
<pre><code>            print("The number is {}".format(task.number))
</code></pre>
<p>If the namedtuple approach is not desired, feel free to replace the content of the main for loop with </p>
<pre><code>        taskNumber, taskTitle, weight, fullMark, desc = (line.strip().split(": ")[1] for line in task_lines)
</code></pre>
<p>and then your code will be back to normal.</p>
<p>Some notes on other changes I've made:</p>
<p><code>filter</code> does what it says on the tin, only iterating over lines that meet the predicate (<code>line_is_relevant(line)</code> is <code>True</code>).</p>
<p>The <code>*</code> in the Task instantiation unpacks the iterator, so each parsed line is an argument to the Task constructor.</p>
<p>The expression <code>(line.strip().split(": ")[1] for line in task_lines)</code> is a generator. This is needed because we're doing multiple lines at once with <code>task_lines</code>, so for each line in our 'chunk' we strip it, split it by the colon and take the second element, which is the value.</p>
<p>The <code>n_lines</code> function works by passing a list of n references to the same iterator to the <code>zip</code> function (<a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">documentation</a>). <code>zip</code> then tries to yield the next element from each element of this list, but as each of the n elements is an iterator over the file, <code>zip</code> yields n lines of the file. This continues until the iterator is exhausted.</p>
<p>The <code>line_is_relevant</code> function uses the idea of "truthiness". A more verbose way to implement it might be</p>
<pre><code>def line_is_relevant(line):
    return len(line.strip()) &gt; 0 and line[0] != '#'
</code></pre>
<p>However, in Python, every object can implicitly be used in boolean logic expressions. An empty string (<code>""</code>) in such an expression acts as <code>False</code>, and a non-empty string acts as <code>True</code>, so conveniently, if <code>line.strip()</code> is empty it will act as <code>False</code> and <code>line_is_relevant</code> will therefore be <code>False</code>. The <code>and</code> operator will also short-circuit if the first operand is falsy, which means the second operand won't be evaluated and therefore, conveniently, the reference to <code>line[0]</code> will not cause an <code>IndexError</code>.</p>
<p>Ok, here's my attempt at a more extended explanation of the <code>n_lines function</code>:</p>
<p>Firstly, the <code>zip</code> function lets you iterate over more than one '<code>iterable</code>' at once. An iterable is something like a list or a file, that you can go over in a for loop, so the zip function can let you do something like this:</p>
<pre><code>&gt;&gt;&gt; for i in zip(["foo", "bar", "baz"], [1, 4, 9]):
...     print(i)
... 
('foo', 1)
('bar', 4)
('baz', 9)
</code></pre>
<p>The <code>zip</code> function returns a '<code>tuple</code>' of one element from each list at a time. A tuple is basically a list, except it's immutable, so you can't change it, as zip isn't expecting you to change any of the values it gives you, but to do something with them. A tuple can be used pretty much like a normal list apart from that. Now a useful trick here is using 'unpacking' to separate each of the bits of the tuple, like this:</p>
<pre><code>&gt;&gt;&gt; for a, b in zip(["foo", "bar", "baz"], [1, 4, 9]):
...     print("a is {} and b is {}".format(a, b))  
... 
a is foo and b is 1
a is bar and b is 4
a is baz and b is 9
</code></pre>
<p>A simpler unpacking example, which you may have seen before (Python also lets you omit the parentheses () here):</p>
<pre><code>&gt;&gt;&gt; a, b = (1, 2)
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
</code></pre>
<p>Although the <code>n-lines function</code> doesn't use this. Now <code>zip</code> can also work with more than one argument - you can zip three, four or as many lists (pretty much) as you like.</p>
<pre><code>&gt;&gt;&gt; for i in zip([1, 2, 3], [0.5, -2, 9], ["cat", "dog", "apple"], "ABC"):
...     print(i)
... 
(1, 0.5, 'cat', 'A')
(2, -2, 'dog', 'B')
(3, 9, 'apple', 'C')
</code></pre>
<p>Now the <code>n_lines</code> function passes <code>*[iter(read_file)] * n</code> to <code>zip</code>. There are a couple of things to cover here - I'll start with the second part. Note that the first <code>*</code> has lower precedence than everything after it, so it is equivalent to <code>*([iter(read_file)] * n)</code>. Now, what <code>iter(read_file)</code> does, is constructs an iterator object from <code>read_file</code> by calling <code>iter</code> on it. An iterator is kind of like a list, except you can't index it, like <code>it[0]</code>. All you can do is 'iterate over it', like going over it in a for loop. It then builds a list of length 1 with this iterator as its only element. It then 'multiplies' this list by <code>n</code>.</p>
<p>In Python, using the * operator with a list concatenates it to itself <code>n</code> times. If you think about it, this kind of makes sense as <code>+</code> is the concatenation operator. So, for example,</p>
<pre><code>&gt;&gt;&gt; [1, 2, 3] * 3 == [1, 2, 3] + [1, 2, 3] + [1, 2, 3] == [1, 2, 3, 1, 2, 3, 1, 2, 3]
True
</code></pre>
<p>By the way, this uses Python's chained comparison operators - <code>a == b == c</code> is equivalent to <code>a == b and b == c</code>, except b only has to be evaluated once,which shouldn't matter 99% of the time.</p>
<p>Anyway, we now know that the * operator copies a list n times. It also has one more property - it doesn't build any new objects. This can be a bit of a gotcha -</p>
<pre><code>&gt;&gt;&gt; l = [object()] * 3
&gt;&gt;&gt; id(l[0])
139954667810976
&gt;&gt;&gt; id(l[1])
139954667810976
&gt;&gt;&gt; id(l[2])
139954667810976
</code></pre>
<p>Here l is three <code>object</code>s - but they're all in reality the same object (you might think of this as three 'pointers' to the same object). If you were to build a list of more complex objects, such as lists, and perform an in place operation like sorting them, it would affect all elements of the list.</p>
<pre><code>&gt;&gt;&gt; l = [ [3, 2, 1] ] * 4
&gt;&gt;&gt; l
[[3, 2, 1], [3, 2, 1], [3, 2, 1], [3, 2, 1]]
&gt;&gt;&gt; l[0].sort()
&gt;&gt;&gt; l
[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]
</code></pre>
<p>So <code>[iter(read_file)] * n</code> is equivalent to</p>
<pre><code>it = iter(read_file)
l = [it, it, it, it... n times]
</code></pre>
<p>Now the very first <code>*</code>, the one with the low precedence, 'unpacks' this, again, but this time doesn't assign it to a variable, but to the arguments of <code>zip</code>. This means <code>zip</code> receives each element of the list as a separate argument, instead of just one argument that is the list. Here is an example of how unpacking works in a simpler case:</p>
<pre><code>&gt;&gt;&gt; def f(a, b):
...     print(a + b)
... 
&gt;&gt;&gt; f([1, 2]) #doesn't work
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: f() missing 1 required positional argument: 'b'
&gt;&gt;&gt; f(*[1, 2]) #works just like f(1, 2)
3
</code></pre>
<p>So in effect, now we have something like</p>
<pre><code>it = iter(read_file)
return zip(it, it, it... n times)
</code></pre>
<p>Remember that when you 'iterate' over a file object in a for loop, you iterate over each lines of the file, so when zip tries to 'go over' each of the n objects at once, it draws one line from each object - but because each object is the same iterator, this line is 'consumed' and the next line it draws is the next line from the file. One 'round' of iteration from each of its n arguments yields n lines, which is what we want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>line</code> variable gets only <code>Task Identification Number: 210CT1</code> as its first input. You're trying to extract 5 values from it by splitting it by <code>:</code>, but there are only 2 values there. </p>
<p>What you want is to divide your <code>for</code> loop into 5, read each set as 5 lines, and split each line by <code>:</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that you are spliting the lines by : and for each line there is only 1 : so there are 2 values. 
In this line:</p>
<pre><code>taskNumber , taskTile , weight, fullMark , desc = line.strip(' ').split(": ") 
</code></pre>
<p>you are telling it that there are 5 values but it only finds 2 so it gives you an error.</p>
<p>One way to fix this is to run multiple for loops one for each value since you are not allowed to change the format of the file. I would use the first word and sort the data into different </p>
<pre><code>import re
Identification=[]
title=[]
weight=[]
fullmark=[]
Description=[]
with open(home + '\\Desktop\\PADS Assignment\\test.txt', 'r') as mod::
    for line in mod:
        list_of_line=re.findall(r'\w+', line)
        if len(list_of_line)==0:
            pass
        else:
            if list_of_line[0]=='Task':
                if list_of_line[1]=='Identification':
                    Identification.append(line[28:-1])
                if list_of_line[1]=='title':
                    title.append(line[12:-1])
            if list_of_line[0]=='Weight':
                weight.append(line[8:-1])
            if list_of_line[0]=='fullMark':
                fullmark.append(line[10:-1])
            if list_of_line[0]=='Description':
                Description.append(line[13:-1])


print('taskNumber is %s' % Identification[0])
print('taskTitle is %s' % title[0])
print('Weight is %s' % weight[0])
print('fullMark is %s' %fullmark[0])
print('desc is %s' %Description[0])
print('\n')
print('taskNumber is %s' % Identification[1])
print('taskTitle is %s' % title[1])
print('Weight is %s' % weight[1])
print('fullMark is %s' %fullmark[1])
print('desc is %s' %Description[1])
print('\n')
print('taskNumber is %s' % Identification[2])
print('taskTitle is %s' % title[2])
print('Weight is %s' % weight[2])
print('fullMark is %s' %fullmark[2])
print('desc is %s' %Description[2])
print('\n')
</code></pre>
<p>of course you can use a loop for the prints but i was too lazy so i copy and pasted :).
IF YOU NEED ANY HELP OR HAVE ANY QUESTIONS PLEASE PLEASE ASK!!!
THIS CODE ASSUMES THAT YOU ARE NOT THAT ADVANCED IN CODING
Good Luck!!!</p>
</div>
<div class="post-text" itemprop="text">
<p>As another poster (@Cuber) has already stated, you're looping over the lines one-by-one, whereas the data sets are split across five lines. The error message is essentially stating that you're trying to unpack five values when all you have is two. Furthermore, it looks like you're only interested in the value on the right hand side of the colon, so you really only have <strong>one</strong> value.</p>
<p>There are multiple ways of resolving this issue, but the simplest is probably to group the data into fives (plus the padding, making it seven) and process it in one go.</p>
<p>First we'll define <code>chunks</code>, with which we'll turn this somewhat fiddly process into one elegant loop (from <a href="https://docs.python.org/3.6/library/itertools.html" rel="nofollow noreferrer">the <code>itertools</code> docs</a>).</p>
<pre><code>from itertools import zip_longest

def chunks(iterable, n, fillvalue=None):
  args = [iter(iterable)] * n
  return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>Now, we'll use it with your data. I've omitted the file boilerplate.</p>
<pre><code>for group in chunks(mod.readlines(), 5+2, fillvalue=''):
  # Choose the item after the colon, excluding the extraneous rows
  # that don't have one.
  # You could probably find a more elegant way of achieving the same thing
  l = [item.split(': ')[1].strip() for item in group if ':' in item]
  taskNumber , taskTile , weight, fullMark , desc = l
  print(taskNumber , taskTile , weight, fullMark , desc, sep='|')
</code></pre>
<p>The <code>2</code> in <code>5+2</code> is for the padding (the comment above and the empty line below).</p>
<hr/>
<p>The implementation of <code>chunks</code> may not make sense to you at the moment. If so, I'd suggest looking into Python generators (and the itertools documentation in particular, which is a marvellous resource). It's also a good idea to get your hands dirty and tinker with snippets inside the Python REPL.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can still read in lines one by one, but you will have to help the code understand what it's parsing.  We can use an <code>OrderedDict</code> to lookup the appropriate variable name.</p>
<pre><code>import os
import collections as ct


def printer(dict_, lookup):
    for k, v in lookup.items():
        print("{} is {}".format(v, dict_[k]))
    print()


names = ct.OrderedDict([
    ("Task Identification Number", "taskNumber"),
    ("Task title", "taskTitle"),
    ("Weight", "weight"),
    ("fullMark","fullMark"),
    ("Description", "desc"),
])

filepath = home + '\\Desktop\\PADS Assignment\\test.txt'
with open(filepath, "r") as f:
    for line in f.readlines():
        line = line.strip()
        if line.startswith("#"):
            header = line
            d = {}
            continue
        elif line:
            k, v = line.split(":")
            d[k] = v.strip(" ")
        else:
            printer(d, names)
    printer(d, names)
</code></pre>
<p>Output</p>
<pre><code>taskNumber is 210CT3
taskTitle is Final Examination
weight is 50
fullMark is 100
desc is Close Book Examination

taskNumber is 210CT1
taskTitle is Assignment 1
weight is 25
fullMark is 100
desc is Program and design and complexity running time.

taskNumber is 210CT2
taskTitle is Assignment 2
weight is 25
fullMark is 100
desc is Shortest Path Algorithm
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're trying to get more data than is present on one line; the five pieces of data are on separate lines.</p>
<p>As SwiftsNamesake suggested, you can use itertools to group the lines:</p>
<pre class="lang-python prettyprint-override"><code>import itertools

def keyfunc(line):
    # Ignores comments in the data file.
    if len(line) &gt; 0 and line[0] == "#":
        return True

    # The separator is an empty line between the data sets, so it returns
    # true when it finds this line.
    return line == "\n"

with open(home + '\\Desktop\\PADS Assignment\\test.txt', 'r') as mod:
    for k, g in itertools.groupby(mod, keyfunc):
        if not k: # Does not process lines that are separators.
            for line in g:
                data = line.strip().partition(": ")
                print(f"{data[0] is {data[2]}")
                # print(data[0] + " is " + data[2]) # If python &lt; 3.6

            print("") # Prints a newline to separate groups at the end of each group.
</code></pre>
<p>If you want to use the data in other functions, output it as a dictionary from a generator:</p>
<pre class="lang-python prettyprint-override"><code>from collections import OrderedDict
import itertools

def isSeparator(line):
    # Ignores comments in the data file.
    if len(line) &gt; 0 and line[0] == "#":
        return True

    # The separator is an empty line between the data sets, so it returns
    # true when it finds this line.
    return line == "\n"

def parseData(data):
    for line in data:
        k, s, v = line.strip().partition(": ")
        yield k, v

def readData(filePath):
    with open(filePath, "r") as mod:
        for key, g in itertools.groupby(mod, isSeparator):
            if not key: # Does not process lines that are separators.
                yield OrderedDict((k, v) for k, v in parseData(g))

def printData(data):
    for d in data:
        for k, v in d.items():
          print(f"{k} is {v}")
          # print(k + " is " + v) # If python &lt; 3.6

        print("") # Prints a newline to separate groups at the end of each group.

data = readData(home + '\\Desktop\\PADS Assignment\\test.txt')
printData(data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by itertools-related solutions, here is another using the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.grouper" rel="nofollow noreferrer"><code>more_itertools.grouper</code></a> tool from the <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more-itertools</code></a> library.  It behaves similarly to @SwiftsNamesake's <code>chunks</code> function.</p>
<pre><code>import collections as ct

import more_itertools as mit


names = dict([
    ("Task Identification Number", "taskNumber"),
    ("Task title", "taskTitle"),
    ("Weight", "weight"),
    ("fullMark","fullMark"),
    ("Description", "desc"),
])


filepath = home + '\\Desktop\\PADS Assignment\\test.txt'
with open(filepath, "r") as f:
    lines = (line.strip() for line in f.readlines())
    for group in mit.grouper(7, lines):
        for line in group[1:]:
            if not line: continue
            k, v = line.split(":")
            print("{} is {}".format(names[k], v.strip()))
        print()
</code></pre>
<p>Output</p>
<pre><code>taskNumber is 210CT1
taskTitle is Assignment 1
weight is 25
fullMark is 100
desc is Program and design and complexity running time.

taskNumber is 210CT2
taskTitle is Assignment 2
weight is 25
fullMark is 100
desc is Shortest Path Algorithm

taskNumber is 210CT3
taskTitle is Final Examination
weight is 50
fullMark is 100
desc is Close Book Examination
</code></pre>
<p>Care was taken to print the <strong>variable name</strong> with the corresponding value.</p>
</div>
<span class="comment-copy"><code>for line in mod:</code> reads just one line and you're trying to unpack data from 5 lines simultaneously!</span>
<span class="comment-copy">Gosh.. do i have to do for loop 5 time in the code?</span>
<span class="comment-copy">@JasperStaTham No,  you don't.</span>
<span class="comment-copy">can someone upvote everyanswer that works? i dont want to test all of them lol</span>
<span class="comment-copy">@SwiftsNamesake i am trying out all the code.  it's 3am here right now. Sorry guys. wish i can do this faster.</span>
<span class="comment-copy">Nice way to print the variable name.</span>
<span class="comment-copy">@Izaak van Dongen thank you for the detail explaination. i really grateful for this .</span>
<span class="comment-copy">in the def n_line(n, lines), what does  zip(*[iter(read_file)] * n) mean?</span>
<span class="comment-copy">No worries. I've tried to add a more in depth explanation of <code>n_lines</code> at the bottom of my answer. Let me know if it could be improved - or if anyone can improve it, please do.</span>
<span class="comment-copy">The OP could also use itertools to group the lines.</span>
<span class="comment-copy">@cuber can you put some code please? i am pretty new to python so i don't quite understand your answer.</span>
<span class="comment-copy">@Cuber turns out <code>itertools</code> doesn't define <code>chunks</code> (I keep expecting it to for some reason).</span>
<span class="comment-copy">@Cuber although there is a recipe for it in the docs</span>
<span class="comment-copy">thank you for assuming. you are correct. i'm a newbie to python.</span>
<span class="comment-copy">not in this code . your code is working but i want to store the content of the line  (eg.the value of weight in "Weight : 25") into a variable so i can use it in a function to do a calculation.</span>
<span class="comment-copy">what does that mean? the Identification is in a variable that you can see all of the identification numbers. In this example variable Identification contains the values of all 3 indentification numbers. If you want the ID of the first task it is Identification[0] and the second is Identification[1] and the third is Identification[2] give it a try.</span>
<span class="comment-copy">editted the comment :)</span>
<span class="comment-copy">oh dang, but thank you for the quick reply. enjoy commenting with u. i will study your code more intensely.</span>
<span class="comment-copy">there's an error : for group in chunks(mod.splitlines(), 5+2): AttributeError: '_io.TextIOWrapper' object has no attribute 'splitlines'.</span>
<span class="comment-copy">@SwiftNamesake thank you for taking your time to help me with this. i really appreciate it</span>
<span class="comment-copy">@JasperStaTham I'll fix it, Also, I fixed another bug by adding an argument to chunks.</span>
<span class="comment-copy">@JasperStaTham Done</span>
<span class="comment-copy">thank you for your help but i'm trying to save the right side of the split into a variable so i can use it in another function to get the content</span>
<span class="comment-copy">I've updated the code. However, if you want to store the values, I recommend using a dictionary. The answer by @pylang makes use of a dictionary. You can modify that code - put the parser in a function and make it return a list of ordered dictionaries.</span>
<span class="comment-copy">@JasperStaTham I've edited the answer to include a solution for outputting the data as a dictionary for use in other functions.</span>
<span class="comment-copy">thank you for this. it worked too</span>
