<div class="post-text" itemprop="text">
<p>I'm trying to create a python class for defining 2D geometry - mostly for 3D printing toolpath creation work, based on the <a href="https://christopherolah.wordpress.com/2011/11/06/manipulation-of-implicit-functions-with-an-eye-on-cad/" rel="nofollow noreferrer">work of Christopher Olah</a>. I'm having an issue with my union() function.</p>
<p>What I'm trying to do is pass it two functions, for example a circle-generating implicit function and a square-generating implicit function. These functions generate a surface that defines a geometric shape. For example, circle generates a surface that crosses Z=0 at a radius r. </p>
<p>I'd like to union shapes - so pass in two shape-functions, and then return a function that can be evaluated at an x,y ordered pair. My union() function doesn't seem to be working, and I think the issue is comes from trying to generate a lambda function which takes two lambda functions as arguments, and returns a result based on what those two lambda functions would return.</p>
<p>Is there a way to do this? I don't want to discretize my geometry - I'd like to be able to plug in ANY x,y point and get a value - where I plot, I generate an X,Y meshgrid and solve over that to plot, but I'd like continous boundaries for when it's time to create a toolpath.</p>
<pre><code>class geometer():
    def __init__(self):
        pass

    def circle(self, r, c):
        circ = lambda x, y: np.sqrt(np.power(x - c[0], 2) + np.power(y - c[1], 2)) - r

        return circ

    def rect(self, l, w, c):
        rect = lambda x, y: np.maximum(np.abs(x + c[0]) - w, np.abs(y + c[1]) - l)

        return rect 

    def union(self, A, B):
        return lambda A, B: np.minimum(A, B)

    def plot(self, geosym):
        root = Tk.Tk()
        root.wm_title("Embedding in TK")


        f = Figure(figsize=(5, 4), dpi=300)
        a = f.add_subplot(111)

        X, Y = np.meshgrid(np.linspace(-5, 5, 1000), np.linspace(-5, 5, 1000))

        z = geosym(X, Y)


        a.imshow(z)


        # a tk.DrawingArea
        canvas = FigureCanvasTkAgg(f, master=root)
        canvas.show()
        canvas.get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)

        toolbar = NavigationToolbar2TkAgg(canvas, root)
        toolbar.update()
        canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)

        Tk.mainloop()

def main():
    geo = geometer()

    circle = geo.circle(1, [0, 0])
    square = geo.rect(1, 1, [1, 1])

    shape = geo.union(circle, square)
    geo.plot(shape)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The union should be a function on x and y, not A and B, which are already local variables (parameters). So presumably union should look more likes this:</p>
<pre><code>def union(self, A, B):
    return lambda x, y: np.minimum(A(x, y), B(x, y))
</code></pre>
<p>Also, I'm not sure what the <code>geometer</code> class is actually for. It doesn't look like you're using the fact that everything is a method much - you have a bunch of instance methods taking a <code>self</code> argument, but I can't see any of them using the <code>self</code>, and <code>__init__</code> assigns nothing. You could probably get away quite easily with just bringing everything out of the class and into a global function. You could also consider implementing some of them as static methods, using @staticmethod - see <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer">the documentation</a></p>
</div>
<span class="comment-copy">Thanks! I don't know why it hadn't occurred to me to pass x and y into the functions - makes perfect sense. As for why 'geometer' is its own class - that was/is mostly just for clarity. Static methods seem like a great idea, and I'll give them a try.</span>
