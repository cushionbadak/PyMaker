<div class="post-text" itemprop="text">
<p>I'm playing around with Julia and I'm using Sympy to which I think uses PyCall to call Python.</p>
<p>When I run the script below, I get a long error.  It's too long to post all of it here, but here is the start of it:</p>
<pre><code>LoadError: PyError (ccall(@pysym(:PyObject_Call), PyPtr, (PyPtr, PyPtr, 

PyPtr), o, arg, C_NULL)) &lt;type 'exceptions.RuntimeError'&gt;
RuntimeError('maximum recursion depth exceeded while calling a Python object',)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\cache.py", line 93, in wrapper
    retval = cfunc(*args, **kwargs)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\compatibility.py", line 809, in wrapper
    result = user_function(*args, **kwds)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\function.py", line 427, in __new__
    result = super(Function, cls).__new__(cls, *args, **options)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\cache.py", line 93, in wrapper
    retval = cfunc(*args, **kwargs)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\compatibility.py", line 809, in wrapper
    result = user_function(*args, **kwds)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\function.py", line 250, in __new__
    evaluated = cls.eval(*args)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\functions\elementary\integers.py", line 25, in eval
    if arg.is_imaginary or (S.ImaginaryUnit*arg).is_real:
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\decorators.py", line 91, in __sympifyit_wrapper
    return func(a, b)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\decorators.py", line 132, in binary_op_wrapper
    return func(self, other)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\expr.py", line 140, in __mul__
    return Mul(self, other)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\cache.py", line 93, in wrapper
    retval = cfunc(*args, **kwargs)
  File "d:\Users\OEM\AppData\Local\JuliaPro-0.6.0.1\pkgs-0.6.0.1\v0.6\Conda\deps\usr\lib\site-packages\sympy\core\compatibility.py", line 809, in wrapper
    result = user_function(*args, **kwds)
</code></pre>
<p>And as you may be able to see, towards the end it repeats: see line 93 on the end, then line 140, then line 93...</p>
<p>Here is my code:</p>
<pre><code>function oddPeriodSquareRoots()
#=
  Get the length of the continued fraction for square root of for the number i.
  E.g. √7=[2;(1,1,1,4)]
=#


irrationalNumber, intPart, fractionalPart = symbols(string("irrationalNumber intPart fractionalPart"))

for i in [6451]

    # For perfect squares, the period is 0
    irrationalNumber = BigFloat(sqrt(BigFloat(i)))
    if irrationalNumber == floor(irrationalNumber)
        continue
    end

    # Get the continued fraction using symbolic programming
    irrationalNumber = sqrt(Sym(i))

    continuedFractionLength = 0
    while true

        intPart = Sym(BigInt(floor(irrationalNumber)))
        if continuedFractionLength == 0
            firstContinuedFractionTimes2 = intPart*2
        end

        continuedFractionLength += 1
        if intPart == firstContinuedFractionTimes2
            break
        end

        fractionalPart = irrationalNumber - intPart
        irrationalNumber = 1 / fractionalPart

    end

    continuedFractionLength -= 1 # We ignore the first term.


end


return continuedFractionLength
end
</code></pre>
<p>This routine calculates the length of a continued fraction for the square root of some number.  For the number 6451 it gives the error.</p>
<p>So my question is can this be resolved please?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm glad the recursionlimit solution was found. This hadn't been seen before. This comment is about how to streamline your SymPy code, as you seem to be confused about that. Basically, you just need to make your initial value symbolic, and then Julia's methods should (in most all cases) take care of the rest. Here is a slight rewrite:</p>
<pre><code>using SymPy
</code></pre>
<p>using PyCall
@pyimport sys
sys.setrecursionlimit(10000)</p>
<p>"""
Get the length of the continued fraction for square root of for the number i.
E.g. √7=[2;(1,1,1,4)]
"""
function oddPeriodSquareRoots(n)</p>
<pre><code>i = Sym(n)
# For perfect squares, the period is 0
continuedFractionLength = 0

irrationalNumber = sqrt(i)
if is_integer(irrationalNumber)
    return continuedFractionLength
end

# Get the continued fraction using symbolic programming

while true

    intPart = floor(irrationalNumber)
    if continuedFractionLength == 0
        firstContinuedFractionTimes2 = intPart*2
    end

        continuedFractionLength += 1
    if intPart == firstContinuedFractionTimes2
        break
    end

    fractionalPart = irrationalNumber - intPart
    irrationalNumber = 1 / fractionalPart

end

continuedFractionLength -= 1 # We ignore the first term.


return continuedFractionLength
</code></pre>
<p>end</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks very much for everyone's input.  I managed to solve this by putting these lines at the top of the file (in addition to the "Using Sympy" line which I had the whole time):</p>
<pre><code>using SymPy

using PyCall
@pyimport sys
sys.setrecursionlimit(10000)
</code></pre>
<p>This sets the recursion limit in Python.  Not sure why it has to be so large for this to work.</p>
<p>I did also remove some of my type conversions etc.  I thought this might help with the error and/or speed.  But it didn't really.</p>
<p>Also, removing the line where I declare the variables to by symbols doesn't stop the code from working.  </p>
<pre><code>irrationalNumber, intPart, fractionalPart = symbols(string("irrationalNumber intPart fractionalPart"))
</code></pre>
<p>Same in Python.  So not sure what the point of it is.</p>
<p>But in Julia, either way I have to have that Sym() wrapper around these 2 lines:</p>
<pre><code>irrationalNumber = sqrt(Sym(i))
...
intPart = Sym(floor(irrationalNumber))
</code></pre>
<p>By inspecting these types, with the use of typeof, I can see they are symbolic, not floats. Without them, everything turns into floats and so I'm not doing it symbolically.</p>
</div>
<span class="comment-copy">heh, <a href="https://projecteuler.net/problem=64" rel="nofollow noreferrer">projecteuler</a>?</span>
<span class="comment-copy">also i don't see any recursion in your code</span>
<span class="comment-copy">@AzatIbrakov  Yes it's a project Euler thing.  I changed it around a bit too!  No but there is a while loop.  So it goes around that 161 times and then I get the error.  The continued fraction is 162 long in this case.  Which makes me suspicious.</span>
<span class="comment-copy">unfortunately i'm not familiar with <code>julia</code> and couldn't google out how to increase recursion limit through it, maybe you can use <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow noreferrer"><code>sys.setrecursionlimit</code></a> for <code>Python</code> used by <code>julia</code>?</span>
<span class="comment-copy">Yes this was how I did it, see answer below.</span>
<span class="comment-copy">Well I thought that should be the case but I couldn't get it to work.  I think I really needed that line: i = Sym(n).  I kep i as an integer and so I had to keep applying Sym to the sqrt and the floor.</span>
<span class="comment-copy">Another thing is that the function is_integer you use is really handy.  One thing I find hard about Julia is that all these functions are global and so they're hard to find I reckon.  In Python I can use the dot after a variable or object to find out all the methods you can do with it, the data members you can access etc.  In Julia I have to have read somewhere that a certain function exists.</span>
<span class="comment-copy">Your solution works though.  Nice.  Both my solution and yours run considerably slower than the same code in Python.  Probably because of all the layers in between Julia and Python I guess.</span>
<span class="comment-copy">You might look at SymEngine.jl for this if you want speed.  I forget if it has an is_integer function like SymPy but otherwise the code will be nearly identical, save Basic(n) for Sym(n). I would guess you won't get the recursion limit either.</span>
