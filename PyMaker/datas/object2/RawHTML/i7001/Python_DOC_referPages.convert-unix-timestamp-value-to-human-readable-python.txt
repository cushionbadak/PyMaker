<div class="post-text" itemprop="text">
<p>I have a Unix timestamp which value is <code>1502878840</code>. This Unix timestamp value can be converted to human readable like <code>Aug 16, 2017 10:20:40</code>.
I have 2 following python code to convert <code>1502878840</code> to <code>Aug 16, 2017 10:20:40</code>. Both of them give a same result (<code>Aug 16, 2017 10:20:40</code>)</p>
<ol>
<li>First method<br/>
<code>utc = datetime.fromtimestamp(1502878840)</code></li>
<li>Second method<br/>
<code>utc = datetime(1970, 1, 1) + timedelta(seconds=1502878840)</code></li>
</ol>
<p>Could anyone answer me 2 following questions.<br/>
1. The result of 2 methods are same. But at the logic view point of Python code, is there any case that may cause the difference in result?<br/>
I ask this question because I see most of the python code use First method.<br/>
2. As I read <a href="https://en.wikipedia.org/wiki/Unix_time" rel="noreferrer" title="here">here</a>, the Unix time will have a problem on 19 January, 2038 03:14:08 GMT.<br/>
I run a timestamp which has a date after 19.Jan, 2038 (<code>2148632440</code>- <code>Feb 01, 2038 10:20:40</code>). The result is as follows<br/>
First method: <code>ValueError: timestamp out of range for platform time_t</code><br/>
Second method: <code>2038-02-01 10:20:40</code><br/>
Question is: Can I use Second method to overcome the problem of "Year 2038 problem"?</p>
</div>
<div class="post-text" itemprop="text">
<p>Quoting the <a href="https://docs.python.org/3/library/datetime.html" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>fromtimestamp() may raise OverflowError, if the timestamp is out of the range of values supported by the platform C localtime() or gmtime() functions, and OSError on localtime() or gmtime() failure. <strong>Itâ€™s common for this to be restricted to years in 1970 through 2038.</strong> Note that on non-POSIX systems that include leap seconds in their notion of a timestamp, <strong>leap seconds are ignored</strong> by fromtimestamp(), and then itâ€™s possible to have two timestamps differing by a second that yield identical datetime objects. See also utcfromtimestamp().</p>
</blockquote>
<p>The second solution solves your problem:</p>
<pre><code>utc = datetime(1970, 1, 1) + timedelta(seconds=1502878840)
</code></pre>
</div>
<span class="comment-copy">First method needs to be <code>utcfromtimestamp()</code>.</span>
<span class="comment-copy">@Mark Tolonen: Thank you so much for your suggestion. I read manual of datetime again. It is better if we use <code>utcfromtimestamp</code></span>
<span class="comment-copy">The <code>timedelta</code> documentation mentions a limit of <code>999999999</code> days. That's less than 3M years. The planet earth may last much longer than that.</span>
<span class="comment-copy">@Gribouillis Good news, and Python may survive to that ðŸ™‚</span>
<span class="comment-copy">@Laurent LAPORTE : Thank you for your answer. By this answer, I have a method to overcome the Year 2038 problem.</span>
<span class="comment-copy">@Gribouillis: Thank you for your information. Actually, my intention is to solve Year 2038 problem firstly. I know that <code>timedelta</code> has a limitation as your mention (3M years), but for a very far future like that, we can not sure anything. The hardware running python program can running until to the next 3M years? I see some RTC chip also limits their correct operation until 2099 :).</span>
