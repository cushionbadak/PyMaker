<div class="post-text" itemprop="text">
<p>I am practicing printing out items yielded by a generator function.</p>
<p>This works perfectly fine:</p>
<pre><code>def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b


sumfib = 0
for i in fibonacci():
    if i &gt;= 4000000:
        break
    elif i % 2 == 0:
        sumfib += i

print(sumfib)
</code></pre>
<p>But the following code is yielding: </p>
<pre><code>list1 = ['f', 'o', 'o', 'b', 'a', 'r']
list2 = ['hello', 'world']
list3 = ['1', '2', '3', '4']


def ziplike(*args):
    x = zip(*args)
    yield x


for item in ziplike(list1, list2, list3):
    print(item)
</code></pre>
<p>What I want to print is each item from each list sequentially, exhausted
when the shortest list is exhausted.  I have it working <em>without</em> a generator, but I am trying to wrap my hands around generators.</p>
<p>I want to print this:</p>
<pre><code>f
hello
1
o
world
2
</code></pre>
<p>The first element in each, followed by the second, etc., until the shortest list is exhausted.  I want to be able to feed in any number of iterables, hence my use of <code>*args</code>.</p>
<p><em>NOTE</em>  My working, non-generator variant uses itertools:</p>
<pre><code>newlist = list(zip(list1, list2, list3))

temp = list(itertools.chain(*newlist))
</code></pre>
<p>I was trying to avoid that, if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make your non-generator version work lazily too, just avoid the <code>list()</code> calls and use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a>:</p>
<pre><code>newlist = zip(list1, list2, list3)
temp = itertools.chain.from_iterable(newlist)
</code></pre>
<p>As for your implementation; you yielded the whole <code>zip()</code> result, not individual elements from that. Delegate to the <code>zip()</code> iterator with <code>yield from</code>:</p>
<pre><code>def ziplike(*args):
    x = zip(*args)
    yield from x
</code></pre>
<p>This still produces the row tuples from the <code>zip()</code> call; you'd need to loop over each contained tuple too:</p>
<pre><code>def ziplike(*args):
    x = zip(*args)
    for tup in x:
        yield from tup
</code></pre>
<p>to chain the tuple contents.</p>
<p>Demo of the latter:</p>
<pre><code>&gt;&gt;&gt; list1 = ['f', 'o', 'o', 'b', 'a', 'r']
&gt;&gt;&gt; list2 = ['hello', 'world']
&gt;&gt;&gt; list3 = ['1', '2', '3', '4']
&gt;&gt;&gt; def ziplike(*args):
...     x = zip(*args)
...     for tup in x:
...         yield from tup
...
&gt;&gt;&gt; for item in ziplike(list1, list2, list3):
...     print(item)
...
f
hello
1
o
world
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yielding <code>x</code> yields the entire iterable. You need to yield <em>from</em> <code>x</code>.</p>
<pre><code>yield from x
</code></pre>
</div>
