<div class="post-text" itemprop="text">
<p>If one changes a object attribute which refers to an internal method to an external function after the object is created, self is not passed to the new function, even if the attribute (which contains a function) is called like before.</p>
<pre><code>class Person:
    def greet(self):
        print("hello")

    do = greet

def wave(person):
    print("bye")

alice = Person()
alice.do() #prints 'hello'

#change do to point an external function
alice.do = wave
alice.do() #Error: Missing argument
</code></pre>
<p>The exact error which I get is:</p>
<pre><code>hello
Traceback (most recent call last):
  File "C:\Users\Owner\Desktop\miniLiveMethodSwitch.py", line 15, in &lt;module&gt;
    alice.do() #Error: Missing argument
TypeError: wave() missing 1 required positional argument: 'person'
</code></pre>
<p>If one move the external function into the class as a internal method, </p>
<pre><code>class Person:
    def greet(self):
        print("hello")

    def wave(person):
        print("bye")

    do = greet
</code></pre>
<p>Then the code works as expected. Why isn't self passed once the attribute is changed to refer to an external function? What is the proper way to call the function so that self is passed?</p>
</div>
<div class="post-text" itemprop="text">
<p>When Python finds <code>alice.do</code> in the class dict, it invokes the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer">descriptor protocol</a>, calling the function's <code>__get__</code> method to produce a bound method object that will be the result of the <code>alice.do</code> lookup. This bound method object knows what <code>self</code> should be and will automatically insert the <code>self</code> argument into the argument list when forwarding arguments to the underlying function. (This happens positionally, not by the <code>self</code> name.)</p>
<p>When Python finds <code>alice.do</code> in <code>alice</code>'s instance dict, the descriptor protocol is not invoked, and <code>alice.do</code> is just the raw function. <code>self</code> is not injected.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>class Person:
    def greet(self):
        print("hello")

    do = greet

def wave(person):
    print("bye")

alice = Person()
alice.do() #prints 'hello'
print(type(alice.do))

#change do to point an external function
alice.do = wave
print(type(alice.do))
</code></pre>
<p>The output is: <code>method</code> and then <code>function</code>:</p>
<pre><code>hello
&lt;class 'method'&gt;
&lt;class 'function'&gt;
</code></pre>
</div>
