<div class="post-text" itemprop="text">
<p>I got a list of strings from an REST API. I know from the documentation that  the item at index 0 and 2 are integers and item at 1 and 3 are floats.</p>
<p>To do any sort of computation with the data I need to cast it to the proper type. While it's possible to cast the values each time they're used I rather prefer to cast the list to correct type before starting the computations to keep the equations cleaner. The code below is working but is very ugly:</p>
<pre><code>rest_response = ['23', '1.45', '1', '1.54']
first_int = int(rest_response[0])
first_float = float(rest_response[1])
second_int = int(rest_response[2])
second_float = float(rest_response[3])
</code></pre>
<p>As I'm working with integers and floats in this particular example one possible solution is to cast each item to float. <code>float_response = map(float, rest_response)</code>. Then I can simply unpack the list to name the values accordingly in the equations.</p>
<pre><code>first_int, first_float, second_int, second_float = float_response
</code></pre>
<p>That is my current solution (but with better names) but while figuring that one out I became curious if there's any good pythonic solution to this kind of problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Define a second list that matches your type casts, zip it with your list of values.</p>
<pre><code>rest_response = ['23', '1.45', '1', '1,54']
casts = [int, float, int, float]
results = [cast(val) for cast, val in zip(casts, rest_response)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is a solution using <a href="https://docs.python.org/3/library/itertools.html?#itertools.cycle" rel="noreferrer"><code>itertools.cycle</code></a> in order to cycle through the cast functions:</p>
<pre><code>from itertools import cycle

first_int, first_float, second_int, second_float = [cast(f)
    for f, cast in zip(rest_response, cycle((int, float)))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The existing answer is perfect if you know the types you expect to be given. 
If however you don't know beforehand if your values are int or floats, then you can use the AST module to parse the string safely into the appropriate type:</p>
<pre><code>import ast
</code></pre>
<p>Then, you call:</p>
<pre><code>numbers = [ast.literal_eval(s) for s in strings]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your list is in that pattern of every other, you can use modulo:</p>
<pre><code>&gt;&gt;&gt; [int(x) if i % 2==0 else float(x) for i,x in enumerate(rest_response)]
[23, 1.45, 1, 1.54]
</code></pre>
<p>Or, if you want to take advantage of tuple assignment to named variables, you can slice and map by desired type:</p>
<pre><code>first_int, second_int=map(int, rest_response[0::2])
first_float, second_float=map(float, rest_response[1::2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think it is reasonably Pythonic to try to convert to an int, if this fails then use a float,</p>
<pre><code>rest_response = ['23', '1.45', '1', '1.54']
float_response = []
for r in rest_response:

    try:
        float_response.append(int(r))
    except ValueError:
        float_response.append(float(r))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>yep, given that all are strings, just write a regex that checks, if the string has a '.' in it and if yes, cast it to float. Otherwise to int</p>
<p><strong>edit:</strong> regex is redundant, simple <code>in string</code> is sufficient.</p>
<p>here is what I would do:</p>
<pre><code>import re

def convert_type(item):
    if re.match('^[^.]*$', item):
        item = int(item)
    else:
        item = float(item)
    return item
</code></pre>
<p>Simpler function:</p>
<pre><code>def convert_type(item):
    if '.' in item:
        return float(item)
    else:
        return int(item)

what = convert_type('2')
print(what, type(what))

convert_this = ['21.44', '12']

converted_list = list(map(convert_type, convert_this))
list(map(type, converted_list))
</code></pre>
<p>But I'm happy to hear simpler and more straightforward solution</p>
</div>
<div class="post-text" itemprop="text">
<p>Of all of the solutions offered, the one you provide in your question is the best. It has speed and clarity.</p>
<p>If you wanted to shorten the solution you provided, you could shorten it to one line:</p>
<pre><code>first, second, third, fourth = int(lst[0]), float(lst[1]), int(lst[2]), float(lst[3])
</code></pre>
<p>I don't know all of the possible formats to the incoming data, but if the float values will always have a decimal, then another solution would be:</p>
<pre><code>first, second, third, fourth = [float(i) if '.' in i else int(i) for i in rest_response]
</code></pre>
</div>
<span class="comment-copy">What if you don't know the response types and amount of values beforehand and need to cast them dynamically?</span>
<span class="comment-copy">@StefanK:  That wasn't the OP's question.  He says he knows the length of his initial list and the types of each index.</span>
<span class="comment-copy">Why involve regexes? And you have corner cases like "1e2"</span>
<span class="comment-copy">Why use regex if you're just checking for a single character? Why not <code>if '.' in item: return float(item)</code> ?</span>
<span class="comment-copy">That's true, the regex is overkill and the simpler solution didn't come to me immediately.</span>
<span class="comment-copy">That is my current solution but I'm doing the cast using map instead. <code>float_response = map(float, rest_response)</code></span>
<span class="comment-copy">I added a short bit to my answer about what I would use as the solution.</span>
