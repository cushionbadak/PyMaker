<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/36980992/asterisk-in-tuple-list-and-set-definitions-double-asterisk-in-dict-definition">asterisk in tuple, list and set definitions, double asterisk in dict definition</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
<li>
<a dir="ltr" href="/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters">What does ** (double star/asterisk) and * (star/asterisk) do for parameters?</a>
<span class="question-originals-answer-count">
                    18 answers
                </span>
</li>
</ul>
</div>
<p>I was watching <a href="https://www.youtube.com/watch?v=lyDLAutA88s" rel="nofollow noreferrer">a lecture from David Beazley</a>. At minute 23:20 he does some "magic" with unpacking that I am having hard time understanding.</p>
<p>The "magic line" is </p>
<pre><code>fail = [ { **row, 'DBA Name': row['DBA Name'].replace("'",'').upper() } for row in fail ]
</code></pre>
<p>I have searched for similar examples but I couldn't find any. Can you explain what is going on in this code? Can you point me to some similar examples?</p>
</div>
<div class="post-text" itemprop="text">
<p>The snippet is unpacking an already existing mapping <code>row</code> in a dictionary literal while adding a new element. A simplified example demonstrating this:</p>
<pre><code>&gt;&gt;&gt; r = {'a':1, 'b':2}    
&gt;&gt;&gt; {**r, 'Spam': 20}
{'Spam': 20, 'a': 1, 'b': 2}
</code></pre>
<p>This unpacking is only available in Pythons &gt;= 3.5 as introduced with <a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">PEP 448</a>; in previous versions it is a <code>SyntaxError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>{**row}</code> just unpacks the dictionary (which is allowed in literals in python-3.5+):</p>
<pre><code>&gt;&gt;&gt; row = {'DBA Name': "make 'this' now", 'b': 2}
&gt;&gt;&gt; {**row}
{'DBA Name': "make 'this' now", 'b': 2}
</code></pre>
<p>Essentially this just makes a copy of <code>row</code> because you unpack a dictionary into a dictionary.</p>
<p>The second part is normal dictionary literal syntax:</p>
<pre><code>&gt;&gt;&gt; {'DBA Name': row['DBA Name'].replace("'",'').upper() }
{'DBA Name': 'MAKE THIS NOW'}
</code></pre>
<p>The "magic" bit is that dictionaries map unique keys to some value, so this is essentially a copy the <code>row</code> dictionary and replaces the <code>'DBA Name'</code> key with the new value. That works because literals are interpreted from left to right:</p>
<pre><code>&gt;&gt;&gt; { **row, 'DBA Name': row['DBA Name'].replace("'",'').upper() }
{'DBA Name': 'MAKE THIS NOW', 'b': 2}
</code></pre>
<p>Normally you would just create a copy of the dictionary and replace the key:</p>
<pre><code>&gt;&gt;&gt; newrow = row.copy()
&gt;&gt;&gt; newrow['DBA Name'] = row['DBA Name'].replace("'",'').upper()
</code></pre>
<p>But that doesn't work in comprehensions (assignment inside comprehensions is a <code>SyntaxError</code>) so you need some "magic" (or invoke special methods). </p>
<hr/>
<p>But you could also do it with a nested comprehension (it's slower but maybe less magic):</p>
<pre><code>[        k: v.replace("'",'').upper() if key == 'DBA Name' else v 
 for row in fail 
     for k, v in row.items()]
</code></pre>
<p>The indentation may seem a bit off but I find it easier to visualize this way, you could also use just one line:</p>
<pre><code>[k: v.replace("'",'').upper() if key == 'DBA Name' else v for row in fail for k, v in row.items()]
</code></pre>
</div>
<span class="comment-copy">@JimFasarakisHilliard: the other post is the canonical 'what does <code>**</code> mean post, and has an answer specifically covering this case.</span>
<span class="comment-copy">@MSeifert: ditto for you; I stand by the duplicate.</span>
<span class="comment-copy">I'm okay with linking both, but the focus of the parameters question is very different, and you don't actually see <i>anything</i> about PEP 448 unpacking generalizations until nine answers and <i>many</i> pages of scrolling down (and that answer isn't even a good answer to the OP's question). <a href="https://stackoverflow.com/a/36908/364696">asterisk in tuple, list and set definitions, double asterisk in dict definition</a> is a much better target for the PEP 448 specific unpacking generalizations; the question and top answer are both about what the OP here is asking about.</span>
<span class="comment-copy">I didn't know that you can add a new element while unpacking. Is this in the official documentation? I can't find it :/</span>
<span class="comment-copy">@alec_djinn yes, PEP 448 describes it and so does the language reference, take a look at <a href="https://docs.python.org/3/reference/expressions.html#dictionary-displays" rel="nofollow noreferrer">Dictionary displays</a> (see the sentence on <code>**</code>).</span>
<span class="comment-copy">Thanks! I missed the Dictionary displays paragraph.</span>
<span class="comment-copy">@alec_djinn: The idea is to make unpacking something that just dumps additional definitions into a "normal" <code>dict</code> literal. It's not "adding a new element", because that assumes the new <code>dict</code> is directly tied to the old one, and that there is one and only one old <code>dict</code> that it's based on. But you could unpack multiple <code>dict</code>s, with key/value pairs before, in between or after them, and it follows the same rules as regular <code>dict</code> literals (order is based on when a key is <i>first</i> seen, but the value comes from the <i>last</i> appearance of a key).</span>
