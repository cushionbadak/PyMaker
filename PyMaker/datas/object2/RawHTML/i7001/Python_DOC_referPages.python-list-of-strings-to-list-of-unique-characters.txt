<div class="post-text" itemprop="text">
<p>I have a list of strings </p>
<pre><code>ll = ['abc', 'abd', 'xyz', 'xzk']
</code></pre>
<p>I want a list of unique characters across all strings in the given list. </p>
<p>For ll, output should be </p>
<pre><code>['a','b','c','d','x','y','z','k']
</code></pre>
<p>is there a clean way to do this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to produce a <em>set</em> of the letters:</p>
<pre><code>{l for word in ll for l in word}
</code></pre>
<p>You can always convert that back to a list:</p>
<pre><code>list({l for word in ll for l in word})
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; ll = ['abc', 'abd', 'xyz', 'xzk']
&gt;&gt;&gt; {l for word in ll for l in word}
{'b', 'a', 'x', 'k', 'd', 'c', 'z', 'y'}
</code></pre>
<p>You can also use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable()</code></a> to provide a single iterator over all the characters:</p>
<pre><code>from itertools import chain

set(chain.from_iterable(ll))
</code></pre>
<p>If you must have a list that reflects the order of the first occurrence of the characters, you can use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="noreferrer"><code>collections.OrderedDict()</code> object</a> instead of a set, then extract the keys with <code>list()</code>:</p>
<pre><code>from collections import OrderedDict
from itertools import chain

list(OrderedDict.fromkeys(chain.from_iterable(ll)))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; list(OrderedDict.fromkeys(chain.from_iterable(ll)))
['a', 'b', 'c', 'd', 'x', 'y', 'z', 'k']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an inefficient way that preserves the order. It's ok when the total number of chars is small, otherwise, you should use Martijn's <code>OrderedDict</code> approach.</p>
<pre><code>ll = ['abc', 'abd', 'xyz', 'xzk']
s = ''.join(ll)
print(sorted(set(s), key=s.index))
</code></pre>
<p><strong>output</strong></p>
<pre><code>['a', 'b', 'c', 'd', 'x', 'y', 'z', 'k']
</code></pre>
<hr/>
<p>Here's an alternative way to preserve the order which is less compact, but more efficient than the previous approach.</p>
<pre><code>ll = ['abc', 'abd', 'xyz', 'xzk']
d = {c: i for i, c in enumerate(reversed(''.join(ll)))}
print(sorted(d, reverse=True, key=d.get))   
</code></pre>
<p><strong>output</strong></p>
<pre><code>['a', 'b', 'c', 'd', 'x', 'y', 'z', 'k']
</code></pre>
<p>Using <code>s.index</code> as the key function is inefficient because it has to perform a linear scan on the <code>s</code> string for each character that it sorts, whereas my <code>d</code> dict can get the index of each character in <a href="https://en.wikipedia.org/wiki/Big_O_notation" rel="nofollow noreferrer">O(1)</a>. I use the <code>reversed</code> iterator because we want earlier chars to overwrite later duplicates of the same char, and using <code>reversed</code> is a little more efficient than building a new string with <code>[::-1]</code>.</p>
<p>Creating the <code>d</code> dict is only slightly slower than creating <code>set(s)</code>, and it may be a little faster than using <code>OrderedDict</code>, it certainly uses less RAM. </p>
</div>
<div class="post-text" itemprop="text">
<p>I do not know the simplest way to do this, but I know one way:</p>
<pre><code>list = ['abc', 'abd', 'xyz', 'xzk']
new=set()
for word in list:
    for letter in word:
        new.add(letter)
print(new)
</code></pre>
<p>This is an easy way for a beginner because it doesn't need any modules which you probably don't know how to use yet.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools</code> for that:</p>
<pre><code>import itertools
ll = ['abc', 'abd', 'xyz', 'xzk']
set(itertools.chain(*[list(x) for x in ll]))

{'a', 'b', 'c', 'd', 'k', 'x', 'y', 'z'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code> l2 =list()
 for i in ll:
    for j in i:
        l2.append(j)

 [''.join(i) for i in set(l2)]          
</code></pre>
<p>output:</p>
<pre><code>'a', 'c', 'b', 'd', 'k', 'y', 'x', 'z'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just another one...</p>
<pre><code>&gt;&gt;&gt; set().union(*ll)
{'d', 'a', 'y', 'k', 'c', 'x', 'b', 'z'}
</code></pre>
<p>Wrap <code>list(...)</code> around it if needed, though why would you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider using a <code>set()</code></p>
<pre><code>s = set()
 for word in ll:
   for letter in word:
     s.add(letter)
</code></pre>
<p>Now <code>s</code> should have all the unique letters. You can convert <code>s</code> to a list using <code>list(s)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a function you can call and give it the list and it will return all unique letters and I added it to print at the end</p>
<pre><code>lst = ['abc', 'abd', 'xyz', 'xzk']

def uniqueLetters(lst1):
    unique = set()
    for word in lst1:
        for letter in word:
                unique.add(letter)
    return unique

print(uniqueLetters(lst))
</code></pre>
<p>To get a variable with the unique variables call the function like so:</p>
<pre><code>uniqueLetters123 = uniqueLetters(lst)
</code></pre>
<p>And you can replace lst with your list name.</p>
</div>
<span class="comment-copy">Have you tried anything yet?</span>
<span class="comment-copy">This did not require deletion.</span>
<span class="comment-copy">@YvetteColomb: this was a borderline one; there is a blurry line between 'fix my code' and 'interesting algorithm question'. I answered because I did not think the other answers were good. It needed a better approach.</span>
<span class="comment-copy">You probably know this, but dicts are ordered in <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-compactdict" rel="nofollow noreferrer">Python 3.6</a></span>
<span class="comment-copy">@SwiftsNamesake: that's an implementation detail that is not yet part of the language specification.</span>
<span class="comment-copy">@MartijnPieters True, but interesting nonetheless</span>
<span class="comment-copy"><code>chain.from_iterable</code> would be cleaner. There is no need to convert the strings to lists, either.</span>
<span class="comment-copy">Or <code>set(''.join(ll))</code></span>
<span class="comment-copy">Yeah, that seems cleaner.</span>
