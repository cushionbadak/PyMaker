<div class="post-text" itemprop="text">
<p>Recently I've been experimenting with <a href="http://discordpy.readthedocs.io/en/latest/" rel="nofollow noreferrer">discord bots</a>, which use asyncio. I've been in the process of making a program that controls lots of other bots, opening and closing them on the fly, but I have a problem; I've experimented with subprocess.Popen, rpyc and multiprocessing, but I'm struggling to work out how to have communication between programs. I've tried using the following line of code to launch the subprocesses:</p>
<pre><code>Popen('python smallprogram.py', stdout=PIPE, stdin=PIPE)
</code></pre>
<p>but I'm still unable to communicate from the main program to the smaller programs, due to the smaller ones needing to run asyncio. This prevents me from using input() with Popen.communicate().
Ideally, I'd like a way to call a function on the smaller program when needed, with the small program still running asyncio. I don't mind having to paste the same block of code into each of the smaller programs, but I think this might also be solvable with some importations?</p>
<p>Can this be done? I've never made an API before, but it seems I might need to use API as a template. Thank you :)</p>
<p>Note: I only <em>need</em> to do big-&gt;small communication, but doing it the other way round would be nice too.</p>
</div>
<div class="post-text" itemprop="text">
<p>There <a href="https://en.wikipedia.org/wiki/Inter-process_communication#Approaches" rel="nofollow noreferrer">many ways</a> to deal with inter-process communication, and I think your use of <code>stdin/stdout</code> is a valid approach.</p>
<p>It turns out it's possible to read asynchronously from <code>stdin</code> in asyncio, though it's <a href="https://stackoverflow.com/a/29102047/2846140">quite tricky to do</a> using only the standard library.</p>
<p>Alternatively, you can use the <a href="https://github.com/vxgmichel/aioconsole" rel="nofollow noreferrer">aioconsole</a> helper <code>ainput</code>:</p>
<pre><code>import aioconsole

async def echo_child():
    data = await aioconsole.ainput()
    print(data, end='')
</code></pre>
<p>Or <code>get_standard_streams</code> for an interface similar to the <a href="https://docs.python.org/3/library/asyncio-stream.html#streams-coroutine-based-api" rel="nofollow noreferrer">stream API</a>:</p>
<pre><code>import aioconsole

async def echo_child():
    stdin, stdout = await aioconsole.get_standard_streams()
    data = await stdin.readline()
    stdout.write(data)
</code></pre>
<p>On the parent side:</p>
<pre><code>import asyncio

async def parent():
    proc = await asyncio.create_subprocess_exec(
        sys.executable, 'child.py',
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE)
    proc.stdin.write(b'Hello\n')
    data = await proc.stdout.readline()
    print(data.decode().strip())
    proc.terminate()
</code></pre>
</div>
<span class="comment-copy">Why not simply spawn new asyncio tasks instead of using subprocesses?</span>
<span class="comment-copy">@Vincent I'm not too familiar with how I'd go about doing this. The idea of the program is that I can modify the bots on the fly, meaning that I can modify one's code without restarting the others, as well as manually injecting code. Wouldn't this require having the bots pre-written beforehand?</span>
<span class="comment-copy">Yes it would. See my answer for more information.</span>
<span class="comment-copy">This looks perfect, thank you very much!</span>
