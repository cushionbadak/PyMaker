<div class="post-text" itemprop="text">
<p>I have a dict that looks like this:</p>
<pre><code>{'Item1': [{'Name1': 3}, {'Name2': 4}, {'Name1':7}],
 'Item2': [{'Name7': 44}, {'Name2': 3}, {'Name6':9}, {'Name6':2}]
}
</code></pre>
<p>I want to combine dictionaries in the list attached to the key such that if there are multiple dicts with the same key, I can combine them (sum) and leave the others as they are. </p>
<p>The output would look like:</p>
<pre><code>{'Item1': [{'Name1': 10}, {'Name2': 4}],
 'Item2': [{'Name7': 44}, {'Name2': 3}, {'Name6': 11}]
}
</code></pre>
<p>I can't figure out how to do this in Python elegantly with a list/dict comprehension. </p>
</div>
<div class="post-text" itemprop="text">
<p>This uses <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">collections.Counter</a>. It is about the most elegant I could come up with, because of the slightly convoluted structure of your input - a list of 1-length dictionaries would indeed be better implemented as a single dictionary, as the comments suggest. This is also what my code transforms it to, although I have provided some more possible tranformations if you really direly need the old data structure. If you do, I would recommend using tuples as your key-value pairs rather than just single-length dicts, as seen in <code>tuple_output</code>. I recommend you use <code>output</code> or <code>dict_output</code>.</p>
<pre><code>from collections import Counter

d = {'Item1': [{'Name1': 3}, {'Name2': 4}, {'Name1':7}], 'Item2': [{'Name7': 44}, {'Name2': 3}, {'Name6':9}, {'Name6':2}] }

output = {}
for k, v in d.items():
    c = Counter()
    for sub_dict in v:
        c.update(sub_dict)
    output[k] = c

dict_output = {k: dict(v) for k, v in output.items()}
tuple_output = {k: v.most_common() for k, v in output.items()}
dict_list_output = {k: [{a: b} for a, b in v.most_common()] for k, v in output.items()}

print(output)
#{'Item1': Counter({'Name1': 10, 'Name2': 4}), 'Item2': Counter({'Name7': 44, 'Name6': 11, 'Name2': 3})}

print(dict_output)
#{'Item1': {'Name1': 10, 'Name2': 4}, 'Item2': {'Name7': 44, 'Name2': 3, 'Name6': 11}}

print(tuple_output)
#{'Item1': [('Name1', 10), ('Name2', 4)], 'Item2': [('Name7', 44), ('Name6', 11), ('Name2', 3)]}

print(dict_list_output)
#{'Item1': [{'Name1': 10}, {'Name2': 4}], 'Item2': [{'Name7': 44}, {'Name6': 11}, {'Name2': 3}]}
</code></pre>
<p>Of course, if you change the starting data structure altogether, it will become a lot easier to manage. If you use a dictionary from strings to Counters, you can use the Counter interface to easily update it (refer to the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">link</a>)</p>
<p>Edit:</p>
<p>Just for fun, done in one line:</p>
<pre><code>results = {item: reduce(lambda a, b: [a, a.update(b)][0], names, Counter()) for item, names in d.items()}
</code></pre>
<p>It was inspired by yours, except this only builds one Counter instance (given as the initial value for reduce) per list. Also, a little bit of a golfy trick is required to reduce properly, as Counter.update is in place. If you're reading this, you probably shouldn't use it, and instead build a data structure with Counters or dicts from the start, as mentioned earlier.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you do want to collapse this into a single <code>dict</code> vs <code>list[dict]</code> then you can do this without any additional modules with a couple of simple <code>for</code> loops:</p>
<pre><code>In []:
r = {}
for k, ds in data.items():
    s = {}
    for d in ds:
        for v, c in d.items():
            s[v] = s.get(v, 0) + c
    r[k] = s
r

Out[]:
{'Item1': {'Name1': 10, 'Name2': 4}, 'Item2': {'Name2': 3, 'Name6': 11, 'Name7': 44}}
</code></pre>
<p>As some seem to be going for one liners:</p>
<pre><code>In []:
import itertools as it
from collections import Counter

{k: dict(Counter(v for v, c in it.chain.from_iterable(d.items() for d in ds))
                 for _ in range(c)) for k, ds in data.items()}

Out[]:
{'Item1': {'Name1': 10, 'Name2': 4}, 'Item2': {'Name2': 3, 'Name6': 11, 'Name7': 44}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It occurred to me just a few minutes after posting the question. </p>
<p>This is what I did: </p>
<pre><code>from operator import add
from collections import Counter
results = {}
for item, names in d.items():
        result[item] = (reduce(add, (Counter(name) for name in names)))
</code></pre>
<p>As the above comments and answers suggest, I am better off using a 1-length dictionary instead of having to combine several later. Still, leaving the answer out here for anyone that needs it. </p>
</div>
<div class="post-text" itemprop="text">
<p>Can also try with defaultdict</p>
<pre><code>from itertools import chain
from collections import defaultdict
d_new = {}
for k, v in d.items():
    d_dict = defaultdict(int)
    for k1, v1 in chain(*[ i.items() for i in v ]) :
        d_dict[k1]+= v1
    d_new[k] = dict(d_dict)

print (d_new)
</code></pre>
<p>Output:</p>
<pre><code>{'Item1': {'Name1': 10, 'Name2': 4}, 'Item2': {'Name7': 44, 'Name2': 3, 'Name6': 11}}
</code></pre>
<p>chain(*[ i.items() for i in v ]) will flatten the list of dicts into list of items</p>
<p>Converts</p>
<pre><code>[{'Name1': 3}, {'Name2': 4}, {'Name1':7}]
</code></pre>
<p>to</p>
<pre><code>[('Name1', 3), ('Name2', 4), ('Name1', 7)]
</code></pre>
<p>defaultdict(int) is used to add the values of dict with same keys</p>
</div>
<span class="comment-copy">Is there a reason why you have a list of dicts? Since you want to collapse multiple copies of a key into a single key, you might as well have a single dict. Abstractly that's what you have anyway, you're just doing in a clumsy manner.</span>
<span class="comment-copy">Thank you for showing examples of the different ways to do this. I do agree that tuple_output seems to be the best approach here and I'm restructuring my code to use it.</span>
<span class="comment-copy">Using list comprehension to generate side effects is an awful example of a one-liner. You can also do it without the side effects.</span>
<span class="comment-copy">My bad. It was probably a bad idea to include it. I tried to explain it wasn't intended for serious use, as in this case a one liner will probably impede clarity. You're right though. I'll leave it up for posterity.</span>
<span class="comment-copy">Probably easier to use <code>itertools.chain.from_iterable(i.items() for i in v)</code> than construct the list and unpack it into arguments for <code>chain()</code>.</span>
