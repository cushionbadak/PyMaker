<div class="post-text" itemprop="text">
<p>In Think Python by Allen Downey the excersise 13-2 asks to process any .txt file from gutenberg.org and skip the header information which end with something like "Produced by". This is the solution that author gives:</p>
<pre class="lang-py prettyprint-override"><code>def process_file(filename, skip_header):
    """Makes a dict that contains the words from a file.
    box  = temp storage unit to combine two following word in one string
    res = dict
    filename: string
    skip_header: boolean, whether to skip the Gutenberg header

    returns: map from string of two word from file to list of words that comes 
    after them
    Last two word in text maps to None"""
    res = {}

    fp = open(filename)

    if skip_header:
        skip_gutenberg_header(fp)

    for line in fp:
        process_line(line, res)


    return res

def process_line(line, res):

    for word in line.split():

        word = word.lower().strip(string.punctuation)
        if word.isalpha():
            res[word] = res.get(word, 0) + 1


def skip_gutenberg_header(fp):
    """Reads from fp until it finds the line that ends the header.

    fp: open file object
    """
    for line in fp:
        if line.startswith('Produced by'):
            break
</code></pre>
<p>I really don't understand the flaw of execution in this code. Once the code starts reading the file using skip_gutenberg_header(fp) which contains "for line in fp:"; it finds needed line and breaks. However next loop picks up right where break statement left. But why? My vision of it is that there are two independent iterations here both containing "for line in fp:",
so shouldn't second one start form the beginning?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, it shouldn't re-start from the beginning. An open file object maintains a file position indicator, which gets moved as you read (or write) the file. You can also move the position indicator via the file's <code>.seek</code> method, and query it via the <code>.tell</code> method.</p>
<p>So if you break out of a <code>for line in fp:</code> loop you can continue reading where you left off with another <code>for line in fp:</code> loop.</p>
<p>BTW, this behaviour of files isn't specific to Python: all modern languages that inherit C's notion of streams and files work like this.</p>
<hr/>
<p>The <code>.seek</code> and <code>.tell</code> methods are mentioned briefly in <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">the tutorial</a>. </p>
<p>For a more in-depth treatment of file / stream handling in Python, please see the docs for the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer">io</a> module. There's a <em>lot</em> of info in that document, and some of that information is mainly intended for advanced coders. You will probably need to read it several times and write a few test programs to absorb what it says, so feel free to skim through it the first time you try to read... or the first few times. ;)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>My vision of it is that there are two independent iterations here both containing "for line in fp:", so shouldn't second one start form the beginning?</p>
</blockquote>
<p>If <code>fp</code> were a list, then of course they would. However it's not -- it's just an iterable. In this case it's a file-like object that has methods like <code>seek</code>, <code>tell</code>, and <code>read</code>. In the case of file-like objects, they keep state. When you read a line from them, it changes the position of the read pointer in the file, so the next read starts a line below.</p>
<p>This is commonly used to skip the header of tabular data (when you're not using a <code>csv.reader</code>, at least)</p>
<pre><code>with open("/path/to/file") as f:
    headers = next(f).strip()  # first line
    for line in f:
        # iterate by-line for the rest of the file
        ...
</code></pre>
</div>
