<div class="post-text" itemprop="text">
<p>What I want to do is to compare two dictionaries:</p>
<pre><code>predict = {'eggs': [1,2],'ham': [1,2,3], 'sausage': [1,2,3]}
actual = {'eggs': [2], 'ham': [1,2]}
</code></pre>
<p>and return a new dictionary of the difference:</p>
<pre><code>difference = {'eggs': [1],'ham': [3], 'sausage': [1,2,3]}
</code></pre>
<p>What would be an efficient way (for large amount of data) to do this? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can combine <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.difference" rel="nofollow noreferrer"><code>set.difference()</code></a> and <code>dict</code> comprehension:</p>
<pre><code>&gt;&gt;&gt; predict = {'eggs': [1,2],'ham': [1,2,3]}
&gt;&gt;&gt; actual = {'eggs': [2], 'ham': [1,2]}
&gt;&gt;&gt; difference = {k: list(set(v).difference(actual[k])) if k in actual else v for k, v in predict.items()}
{'eggs': [1], 'ham': [3]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>You iterate over <code>predict</code> key-value pairs</li>
<li>The new <code>difference</code> dictionary will have the same keys as <code>predict</code> and <code>actual</code></li>
<li>But its values will be the <code>set difference</code> of the current lists</li>
<li><code>set(v).difference(actual[k])</code> - As the keys are the same, you can access <code>actual[k]</code> and find its difference with the current one (which is <code>v</code>)</li>
<li>Finally, you cast your result set with the difference to a list to have an output as requested.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This should do it:</p>
<pre><code>difference = {}
for key, value in predict.items():
    difference[key] = [el for el in predict[key] if (key not in actual) or (el not in actual[key])]

print(difference)
</code></pre>
<p><strong>edit:</strong>
code was update to handle missing categories in the actual list</p>
</div>
<span class="comment-copy">What's the way you're currently doing it, and what's the specific efficiency problem you're having?</span>
<span class="comment-copy">Then see <a href="https://sopython.com/wiki/What_tutorial_should_I_read%3F" rel="nofollow noreferrer">sopython.com/wiki/What_tutorial_should_I_read%3F</a>. Any basic tutorial will cover list and dictionary handling.</span>
<span class="comment-copy">@jonrsharpe thanks for the tips</span>
<span class="comment-copy">It works perfectly! Appreciate it.</span>
<span class="comment-copy">@ChrisLin You're welcome. If my answer helped you make sure to mark it as accepted.</span>
<span class="comment-copy">Just marked it as accepted.</span>
<span class="comment-copy">how about the slightly different scenario below:      predict = {'eggs': [1,2], 'ham': [1,2,3], 'sausage': [1,2]}     actual = {'eggs': [2], 'ham': [1,2]}  I want to return a new dictionary:      {'eggs': [1], 'ham': [3], 'sausage': [1,2]}</span>
<span class="comment-copy">@ChrisLin I've just edited my answer with a check for this scenario. Thanks for pointing it out, I haven't thought about it.</span>
<span class="comment-copy">How should the code be if there is a susage in predict dictionary? @Philip Blonde</span>
<span class="comment-copy">I have updated the code. Essentially the same, you just add a check for missing key values in actual.</span>
<span class="comment-copy">For large dictionaries, the code will take hours to run. Is there a faster way to do this? @Philip Blonde Thanks.</span>
