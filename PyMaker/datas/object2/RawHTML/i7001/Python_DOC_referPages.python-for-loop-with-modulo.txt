<div class="post-text" itemprop="text">
<p>Is it possible to create a python for-loop with a modulo operation? I have a ringbuffer in Python and I want to iterate the elements between the <code>startPos</code> and <code>endPos</code> indexes, where <code>startPos</code> can have a bigger value than <code>endPos</code>. In other programming languages, I would intuitively implement this with a modulo operator:</p>
<pre><code>int startPos = 6;
int endPos = 2;
int ringBufferSize = 8;
for(int i = startPos, i != endPos, i = (i+1) % ringBufferSize) {
    print buffer.getElementAt(i);
}
</code></pre>
<p>Is there a way to do this easily in Python? I only found the</p>
<pre><code>for i in list:
    print buffer[i]
</code></pre>
<p>Syntax but nothing which provides an equivalent solution to my problem.</p>
<p>My next approach would be to create the list in advance before iterate the indexes which are stored in the list. But is there a way to do this as a one-liner like in other programming languages by using the modulo operation directly in the for loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>You  have some ways of doing that:</p>
<p>As you do in "other programing languages" (i.e. C derived syntaxes), just that you basically have to write their <code>for</code> loop in a while form - and then you realize that C's for is just a <code>while</code> nonetheless:</p>
<pre><code>start_pos = 6
end_pos = 2
ring_buffer_size = 8
i = start_pos
while True:
    i = (i + 1) % ring_buffer_size
    if i &lt;= end_pos:
        break
    # your code here
</code></pre>
<p>Now, for the  <code>for</code> statement, Python only has what is called "for each" - which always walks an iterable or sequence. So you can create an iterable that will yield your values - </p>
<pre><code>def ring(start, end, buffer_size, increment=1):
    i = start
    while i != end:
       yield i
       i += 1
       i %= buffer_size

for slot in ring(6, 2, 8):
    # your code here
</code></pre>
<p>Note that while this second form is "bigger", it does abstract away your circular buffer logic, avoiding that hard code values get mixed with their meaning where you don't need to look at them - that is, inside the <code>for</code> body itself.</p>
<p>Note that the actual idea of <code>for</code> in Python is to iterate over the <em>buffer</em> contents itself, not and index that will lead to its contents.<br/>
So, the Python standard library includes a ready made circular buffer object already that always have its indexes normalized to 0 and (len - 1) - 
just import <code>deque</code> from the <code>collections</code> module.</p>
<p>If you want a circular buffer with changing start and end indexes taht will wrap around and work automatically in <code>for</code>statements, that is also relatively easy to do - if you don  need the full functionality, just subclass  <code>list</code>, add the <code>start</code> and <code>end</code> indexes, and make a custom implementation of its <code>__iter__</code> method: </p>
<pre><code>class Circular(list):

    def __init__(self, content, start, end):
        super(Circular, self).__init__( content)
        self.start = start
        self.end = end

    def __iter__(self):
        for i in range(self.start, self.start + len(self)):
            if i % len(self) == self.end: break
            yield self[i % len(self)]
</code></pre>
<p>And now you can use this custom container in your code:</p>
<pre><code>In [22]: mylist = Circular(range(8), 6 , 2)

In [23]: for i in mylist:
    ...:     print(i)
    ...:     
6
7
0
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For loops can take any iterable. As such you can create your own to do the work and drop it into the for loop. For example:</p>
<pre><code>for i in [i % ring_buffer for i in range(start_pos, end_pos)]:
    # Do stuff...
</code></pre>
<p>Or, to create an iterable directly:</p>
<pre><code>for i in (i % ring_buffer for i in range(start_pos, end_pos)):
    # Do stuff...
</code></pre>
<p>See <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">the docs</a> for more information about when you might want to create an iterator directly for this purpose.</p>
</div>
<div class="post-text" itemprop="text">
<p>use range</p>
<pre><code>for i in range(0,len(a)):
      #code
      i=i%x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe you should be able to use <code>while</code> instead of a <code>for</code> loop. This should work as long as you just want to increment <code>i</code> by 1 each time, then calculate the mod.</p>
<p>Try: </p>
<pre><code>i = startPos
while (i &lt;= endPos and i == (i+1) % ringBufferSize) :
    print buffer.getElementAt(x)
    i = i+1
</code></pre>
</div>
<span class="comment-copy">How is the C-style for loop supposed to work? Won't that stop immediately since <code>i</code> is <code>&gt; endpos</code>, too? Did you mean <code>...; i != endpos; ...</code>?</span>
<span class="comment-copy">I do not think, there is a standard procedure for this. If endPos &gt; 7 this loop will never end. why don't you use a normal while loop? Seems to me more intuitive than a "mutating" for loop</span>
<span class="comment-copy">Also, on an unrelated comment - from the <code>print</code> statements,I notice you are using Python 2 - you should be using Python 3 for any new project now, and specially for learning the language.</span>
<span class="comment-copy">Sorry you are right, I have to do this with <code>!=</code>. I will edit the question.</span>
<span class="comment-copy">Sorry, changed that, too.</span>
<span class="comment-copy">Any advantage over iter()?</span>
<span class="comment-copy">Yu dul d need a custom generator to use with <code>iter()</code> here anyway. The "advantage" is just that you  don't need an extra wrapping <code>iter</code></span>
<span class="comment-copy">What's "Yu dul d"?</span>
<span class="comment-copy">"You do need ... a custom generator... " when typed with enough hurry.</span>
<span class="comment-copy">You don't even need <code>iter</code>, I think. Just leave <code>for i in (i % ring_buffer for i in range(end_pos))</code>, which is already a lazy generator expression.</span>
<span class="comment-copy">You forgot to use startPos. And it's not trivial.</span>
<span class="comment-copy">@IzaakvanDongen  My mistake. Do You know if there is a difference between <code>iter( someIterator )</code> and just <code>( someIterator )</code>?</span>
<span class="comment-copy">Where <code>someIterator</code> is a generator object, there is no difference at all, as <code>someIterator</code> will already be a lazy iterator, and <code>iter</code> can't make it any more lazy. For some other types, there may be a difference. For example, <code>iter([1, 2, 3])</code> does not support indexing whereas <code>[1, 2, 3]</code> does. Here, <code>iter([1, 2, 3])</code> actually changes its type to <code>&lt;class 'list_iterator'&gt;</code>.</span>
<span class="comment-copy">Thanks for the answer! I replaced the <code>Do stuff</code> logic with a simple <code>print i</code> Unfortunately, the output is empty if <code>start_pos</code> has a bigger value than <code>end_pos</code>. E.g. if <code>ring_buffer = 8</code>, <code>start_pos = 6</code> and <code>end_pos = 3</code>, I get an empty output. If i swap the values for <code>start_pos</code> and <code>end_pos</code>, I get <code>3, 4, 5</code> for both variants.</span>
<span class="comment-copy">You can use <code>i%x</code> without parentheses, and <code>range(len(a))</code>.</span>
<span class="comment-copy">yes. sorry for the parentheses.</span>
<span class="comment-copy">What is your <code>x</code>?</span>
<span class="comment-copy">x is a variable(int here).</span>
<span class="comment-copy">But what is its value?</span>
<span class="comment-copy">"while" is the way to go, but your code won't work either. Please test in the interactive mode.</span>
