<div class="post-text" itemprop="text">
<p>Assuming Python version &gt;=3 and calling a list of functions.
I would like to write a lambda function that handles exceptions.
Thing is, it does not work, when there is an exception thrown in a function, the program returns and the call stack is not seeing the <code>executeFunction</code> in it.</p>
<p>How to do so?</p>
<pre><code>def executeFunction(x):
    try:
        x
    except:
        print('Exception caught')


executeFunction(func1())
executeFunction(func2())
executeFunction(func3())
executeFunction(func4())
executeFunction(func5())
executeFunction(func6())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>executeFunction</code> won't be called if the exception is raised by any of the function calls, that is, while the argument is still being evaluated. </p>
<p>You should consider passing the <em>callable</em> instead and calling it inside the <code>try/except</code> clause:</p>
<pre><code>def executeFunction(x):
    try:
        x()
    except SomeException:
        print('Exception caught')

executeFunction(func1)
</code></pre>
<p>Any errors raised from <code>x()</code> are now handled by the enclosing <code>try/except</code> clause.</p>
<p>For functions with arguments you can use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> (or a <code>lambda</code>) to defer the call using the arguments:</p>
<pre><code>from functools import partial

def executeFunction(x):
    try:
        x()
    except SomeException:
        print('Exception caught')

executeFunction(partial(func1, arg1, argn))
# executeFunction(lambda: func1(arg1, argn))
</code></pre>
<p>You could also exploit Python's decorator syntax to use calls to the functions themselves directly without having to <em>explicitly</em> call <code>executeFunction</code> directly, giving much cleaner code from the caller's side:</p>
<pre><code>def executeFunction(func):
    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except SomeException:
            print('Exception caught')
    return wrapper

@executeFunction
def func1(arg1, arg2):
    ...
@executeFunction
def func2(arg1):
    ...


func1(arg1, arg2) # -&gt; executeFunction(func1)(arg1, arg2)
func2(arg1)       # -&gt; executeFunction(func2)(arg1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is that you can not really handle exceptions inside within an expression.</p>
<p>A longer answer would be: you may achieve what you want by using some contrived tricks. Of course you should not do that for serious purposes, but what you can actually do inside an expression is:</p>
<ul>
<li><p>define "on the fly" new expressions by using tricky combinations of <code>type()</code> and of <code>setattr()</code>, like this:</p>
<pre><code>MyException = (lambda o:
                  setattr(o, '__init__',
                      lambda self: setattr(self,"test", 42))
               or setattr(o, 'my_funny_method', lambda self:True)
               or setattr(o, 'my_other_funny_method', lambda self:False)
               or o)(type("MyException", (BaseException,), {}))
e = MyException()
print(type(e), "with attribute test =", e.test)
print(e.my_funny_method())
raise e
</code></pre></li>
<li><p>raise any exception; not only by performing <em>ad hoc</em> operations but also in a more general manner if required:</p>
<pre><code>(_ for _ in ()).throw(ZeroDivisionError("Hello World"))
</code></pre></li>
<li><p>catch <em>some</em> exceptions by tricky uses of <em>ad hoc</em> features like the way <code>StopIteration</code> is handled by iterators:</p>
<pre><code>is_odd = lambda n: ((lambda l:
    (l and l.pop()) or "An exception was caught")
      (list((lambda: (yield from (n if n%2
         else (_ for _ in ()).throw(StopIteration) for _ in (None,))))())))
print(is_odd(5))
print(is_odd(8))
</code></pre></li>
</ul>
<p>You can read more about it at <a href="http://baruchel.github.io/python/2018/06/20/python-exceptions-in-lambda/" rel="nofollow noreferrer">http://baruchel.github.io/python/2018/06/20/python-exceptions-in-lambda/</a> .</p>
</div>
<span class="comment-copy">For functions with arguments, is there a way to add it cleaner than :  def executeFunction(x, arg1="", arg2=""):            if arg1 != "" and arg2 != "":              x(arg1, arg2)          elif arg1 != "":             x(arg1)          else:             x()      except:          print('Exception Caught in ' + x.__name__)</span>
<span class="comment-copy">@Rems I've updated the answer.</span>
<span class="comment-copy">Thanks it's perfect!</span>
<span class="comment-copy">@Rems You may accept the answer if it helped.</span>
<span class="comment-copy">I tried with the wrapper but it still gets me :</span>
