<div class="post-text" itemprop="text">
<p>Below is a generator function.</p>
<pre><code>def f():
   x=1
   while 1:
      y = yield x
      x += y
</code></pre>
<p>Does this generator function (<code>f</code>) get implemented, internally, as shown below?</p>
<pre><code>class f(collections.Iterable):
   def __init__(self):
      self.x = 1
   def __iter__(self):
      return iter(self)
   def __next__(self):
      return self.x
   def send(self, y):
      self.x += y
      return self.next()
</code></pre>
<p><strong>Edit:</strong></p>
<p><a href="https://stackoverflow.com/questions/45723893/how-does-a-generator-function-work-internally#comment78413677_45727729">This</a> is the answer for my question.</p>
</div>
<div class="post-text" itemprop="text">
<p>Internally, a generator works about the same as a regular function call. Under-the-hood, running generators and running functions use mostly the same machinery. </p>
<p>When you call either a function or a generator, a stackframe is created.  It has the local variables (including the arguments passed into the function), a code pointer to the active opcode, and a stack for pending try-blocks, with-blocks, or loops.</p>
<p>In a regular function, execution begins immediately.  When <a href="https://docs.python.org/3/reference/simple_stmts.html#return" rel="noreferrer"><code>return</code></a> is encountered, the final result is kept and the stackframe is freed along with everything it referenced.</p>
<p>In a <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer">generator</a> function, the stackframe is wrapped in a <a href="https://docs.python.org/3/glossary.html#term-generator-iterator" rel="noreferrer">generator-iterator</a> object and returned immediately.  The code in the generator function only runs when called by <code>next(g)</code> or <code>g.send(v)</code>.  Execution is suspended when <a href="https://docs.python.org/3/reference/simple_stmts.html#yield" rel="noreferrer"><code>yield</code></a> is encountered.</p>
<p>One way to think of generators is that they are like functions that can be paused with <code>yield</code> and resumed with <code>g.next()</code>.  The stackframe is kept alive, so resuming a running generator is <em>much</em> cheaper than making a new function call which has to build a new frame on every invocation.</p>
</div>
<span class="comment-copy">You can test whether they <i>behave</i> the same for yourself. Going into the internal implementation details seems too broad for a SO question.</span>
<span class="comment-copy">This post may provide some info: <a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" rel="nofollow noreferrer">aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html</a></span>
<span class="comment-copy">I doubt that those are equivelent... (they may behave the same) ... check out the <code>dis</code> module to see the bytecode implementation (as an aside as an implementation detail, the answer may change depending on the python interpretter being used)</span>
<span class="comment-copy">of course they aren't equivalent, one is a class and one is a function</span>
<span class="comment-copy">The short answer is that <b>generators are not implemented internally as shown in your pure python class</b>.  Instead, they share most of the same logic as regular functions.</span>
<span class="comment-copy">How <code>yield</code> pause/suspend the function internally?</span>
<span class="comment-copy">@overexchange Execution of both generators and functions involves running the current opcode and updating the code pointer.  Pausing just means to stop doing that.  Resuming means to continue doing that.  Count with me, 1, 2, 3, and now talk about something else, and continue couting 4, 5, 6, ...   All you need to know is the last count.  Likewise, the stackframe keeps the state of the function and you can resume stop updating it and resume updating it at any time.</span>
<span class="comment-copy">Building block for async is about task capable to suspend/resume. For server side programming, generally task is suspended on performing IO. When u say, pausing is to stop, are we not pausing because we are waiting for an IO(say http get request)?</span>
<span class="comment-copy">@overexchange I think you're imagining this to be more complex than it is.  The code for <code>next(g)</code> boils down to basically <code>PyEval_EvalFrameEx(gen-&gt;gi_frame, exc)</code>.  That's it, it just execs the current state of the frame (see <code>Objects/genobject.c</code> which is clear and simple in Python 2.7).  A <code>yield</code> simply returns from that call.  In contrast, a function call runs <code>PyEval_EvalCodeEx(...)</code> which creates a new frame and execs it as shown above.  See <code>Objects/funcobject.c</code>.</span>
