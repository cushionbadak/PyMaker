<div class="post-text" itemprop="text">
<p>I've been trying to merge/parse this list with multiple lists inside into one list only.</p>
<p>The list i want to parse/merge has this format :</p>
<pre><code>list_one = [ [['id1'],['value']], 
             [['id1'],['value1'],['value2'],['value3'],['value4'],['value5']], 
             [['id1'],['value6']],
             [['id1'],['value7'],['value8']],
             [['id2'],['value']], 
             [['id2'],['value1'],['value2'],['value3'],['value4'],['value5']], 
             [['id2'],['value6']],
             [['id2'],['value7'],['value8']]
]
</code></pre>
<p>I came up with this code after some googling :</p>
<pre><code>pre_info = list(set(i[0] for i in itertools.chain.from_iterable(list_one)))
final_info = list(map(lambda x: [x], sorted(pre_info, key=len)))
print final_info
</code></pre>
<p>But it only prints me the ID's</p>
<p>The disered output is :</p>
<pre><code>final_list = [
              [['id'],['value'],['value1'],['value2'],['value3'],['value4'],['value5'],['value6'],['value7'],['value8']],
              [['id2'],['value'],['value1'],['value2'],['value3'],['value4'],['value5'],['value6'],['value7'],['value8']]
]
</code></pre>
<p>The condition for each line is obviously the 'id' that is always the first position on each list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>import collections

list_one = [ [['id1'],['value']], 
         [['id1'],['value1'],['value2'],['value3'],['value4'],['value5']], 
         [['id1'],['value6']],
         [['id1'],['value7'],['value8']],
         [['id2'],['value']], 
         [['id2'],['value1'],['value2'],['value3'],['value4'],['value5']], 
         [['id2'],['value6']],
         [['id2'],['value7'],['value8']]
]

d = collections.defaultdict(list)
for row in list_one:
    d[row[0][0]].extend(row[1:])

final_output = sorted([[[a]]+b for a, b in d.items()], key = lambda x: int(x[0][0][-1]))
</code></pre>
<p>Final Output:</p>
<pre><code>[[['id1'], ['value'], ['value1'], ['value2'], ['value3'], ['value4'], ['value5'], ['value6'], ['value7'], ['value8']], [['id2'], ['value'], ['value1'], ['value2'], ['value3'], ['value4'], ['value5'], ['value6'], ['value7'], ['value8']]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to group your values per unique <code>id</code>, you can't just flatten things. You either have to use a dictionary to group lists by <code>id</code>, or, provided the lists for each unique <code>id</code> are consecutive, use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>.</p>
<p>Using a dictionary:</p>
<pre><code>by_id = {}
for id, *values in list_one:
    # unwrap values as we add them to the id group
    by_id.setdefault(id[0], []).extend(v[0] for v in values)

# extract all IDs an value lists into a new list
final_list = [[id] + values for id, values in sorted(by_id.items())]
</code></pre>
<p>or a Python 2 version:</p>
<pre><code>by_id = {}
for row in list_one:
    # unwrap values as we add them to the id group
    id, values = row[0][0], row[1:]
    by_id.setdefault(id, []).extend(v[0] for v in values)

# extract all IDs an value lists into a new list
final_list = [[id] + values for id, values in sorted(by_id.items())]
</code></pre>
<p>I sorted the output list by id; dictionaries have no inherent order. Note that I <em>removed</em> the wrapping singleton list objects; these are taking up memory you don't need to use and they complicate matters algorithmically.</p>
<p>You could use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict()</code> object</a> for <code>list_one</code> if you need to have these lists in order of first appearance.</p>
<p>As stated, if the <code>id</code> lists are already consecutive, you can use <code>itertools.groupby()</code> to do the grouping in one step:</p>
<pre><code>from itertools import groupby

[[id] + [value[0] for sublist in group for value in sublist[1:]]
 for id, group in groupby(list_one, lambda s: s[0][0])]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; by_id = {}
&gt;&gt;&gt; for id, *values in list_one:
...     # unwrap values as we add them to the id group
...     by_id.setdefault(id[0], []).extend(v[0] for v in values)
...
&gt;&gt;&gt; [[id] + values for id, values in sorted(by_id.items())]
[['id1', 'value', 'value1', 'value2', 'value3', 'value4', 'value5', 'value6', 'value7', 'value8'], ['id2', 'value', 'value1', 'value2', 'value3', 'value4', 'value5', 'value6', 'value7', 'value8']]
&gt;&gt;&gt;
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [[id] + [value[0] for sublist in group for value in sublist[1:]]
...  for id, group in groupby(list_one, lambda s: s[0][0])]
[['id1', 'value', 'value1', 'value2', 'value3', 'value4', 'value5', 'value6', 'value7', 'value8'], ['id2', 'value', 'value1', 'value2', 'value3', 'value4', 'value5', 'value6', 'value7', 'value8']]
</code></pre>
<p>If you feel you <strong>must</strong> have those singleton lists in your output, feel free to add them back in.</p>
</div>
<div class="post-text" itemprop="text">
<p>The above answer provide good solutions, here is another way to do it, but I agree with @ Martijn Pietersâ™¦ and his solution in terms of clear reading</p>
<pre><code>import itertools

chained = itertools.chain.from_iterable(list_one)

schain = set([tuple(c) for c in chained])

{('id',),
 ('value',),
 ('value1',),
 ('value2',),
 ('value3',),
 ('value4',),
 ('value5',),
 ('value6',),
 ('value7',),
 ('value8',)}


list(sorted([list(v) for v in schain]))

[['id'],
 ['value'],
 ['value1'],
 ['value2'],
 ['value3'],
 ['value4'],
 ['value5'],
 ['value6'],
 ['value7'],
 ['value8']]
</code></pre>
<p>Edited based on there being other values,</p>
<pre><code>temp = [list(v) for v in schain]

temp.pop(temp.index(['id']))

temp.sort()

temp.insert(0, ['id'])

[['id'],
 ['abc'],
 ['value'],
 ['value1'],
 ['value2'],
 ['value3'],
 ['value4'],
 ['value5'],
 ['value6'],
 ['value7'],
 ['value8']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have this solution but it work only if the ids are string or int and must be in the head of each list:</p>
<pre><code>l=[ [['id1'],['value']], 
             [['id1'],['value1'],['value2'],['value3'],['value4'],['value5']], 
             [['id1'],['value6']],
             [['id1'],['value7'],['value8']],
             [['id2'],['value']], 
             [['id2'],['value1'],['value2'],['value3'],['value4'],['value5']], 
             [['id2'],['value6']],
             [['id2'],['value7'],['value8']]
]
d={}

for ll in l:
    d[ll[0][0]]=[]
for i,ll in enumerate(l):
    for lll in ll[1:]:
        d[ll[0][0]].append(lll)
result=[]
for key,items in d.iteritems():
    result.append([[key]]+items)

print result
</code></pre>
<p>result:</p>
<pre><code>[[['id2'], ['value'], ['value1'], ['value2'], ['value3'], ['value4'], ['value5'], ['value6'], ['value7'], ['value8']], [['id1'], ['value'], ['value1'], ['value2'], ['value3'], ['value4'], ['value5'], ['value6'], ['value7'], ['value8']]]
</code></pre>
</div>
<span class="comment-copy">Why still stick to the nested lists with one element each? Why not <code>['id', 'value', 'value1', 'value2', 'value3', 'value4', 'value5', 'value6', 'value7', 'value8']</code>?</span>
<span class="comment-copy">Are those <code>id1</code> and <code>id2</code> always grouped together (so consecutive lists have the same id value, there is no mixing of ids)?</span>
<span class="comment-copy">Well .. on my tests it passed - give it a try on real data! Many thanks!</span>
<span class="comment-copy">@MartijnPieters it's giving me SyntaxError on the * for id, *values in list_one:  Thanks so much for you help</span>
<span class="comment-copy">@RicardoRibeiro: Are you using Python 2 perhaps? I added a version for older Pythons.</span>
<span class="comment-copy">@MartijnPieters, yes i'm using 2.0 version. Great post reply, with many details and great information. Many thanks!</span>
<span class="comment-copy">@RicardoRibeiro: glad to have been of help! Note that you can only mark one answer as the accepted post, not both. Pick the one that you feel helped you most (or none at all, the choice is entirely up to you).</span>
