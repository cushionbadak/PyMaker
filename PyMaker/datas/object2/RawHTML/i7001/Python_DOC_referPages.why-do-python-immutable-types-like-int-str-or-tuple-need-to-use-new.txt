<div class="post-text" itemprop="text">
<p>This question is related to, but not a duplicate of, <a href="https://stackoverflow.com/questions/45720451/subclassing-frozenset-with-multiple-init-parameters-and-strange-behavio?noredirect=1#comment78400260_45720451">this</a>, <a href="https://stackoverflow.com/questions/3120562/python-subclassing-immutable-types">this</a>, <a href="https://stackoverflow.com/questions/3131488/python-always-use-new-instead-of-init">this</a>, and <a href="https://stackoverflow.com/questions/30967743/why-do-we-need-to-use-new-when-extending-a-immutable-class-in-python">this</a>. Those links don't answer my question here. <a href="https://stackoverflow.com/questions/25901904/why-does-fraction-use-new-instead-of-init">This though</a>, almost answers my questions but doesn't, because the code in the answer doesn't run in Python 3.6 and in any case the question there isn't specifically about what I'm asking here. (See my own answer below.</p>
<p>From <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the Python documentation page</a>, I find the following text.</p>
<blockquote>
<p><code>__new__()</code> is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also
  commonly overridden in custom metaclasses in order to customize class
  creation.</p>
</blockquote>
<p>But <strong>why</strong>? Why can't we just override <code>__init__()</code> instead of having to override <code>__new__()</code>? Apparently, <code>frozenset</code>, for example, doesn't even implement <code>__init__()</code>; <strong>why is that</strong>? I understand from <a href="https://stackoverflow.com/questions/3131488/python-always-use-new-instead-of-init">here</a> that in some rare cases, <code>__new__()</code> and <code>__init__()</code> are required to do different things, but as far as I can see that's only during pickling and unpickling. What is it about <strong>immutable types in particular</strong> that requires the use of <code>__new__()</code> instead of <code>__init__()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm the question OP and I'm going to answer my own question because I think I found out the answer half-way through typing it. I'm not going to mark it as correct until others have confirmed it to be correct.</p>
<p><a href="https://stackoverflow.com/questions/25901904/why-does-fraction-use-new-instead-of-init">This question here</a> is particularly relevant, but the question wasn't the same as this question, and although the answer was very enlightening (though the comments turned into enlightening but esoteric arguments about C and Python and "pythonic"), it should be set out more clearly here to specifically address this question. I hope this will help future readers. The code in this answer has been verified in Python 3.6.1.</p>
<p>The thing about an immutable object, is that you don't want to set its members once it's been created, obviously. The way you do that in Python is to override the <code>__setattr__()</code> special method to <code>raise</code> an error (<code>AttributeError</code>), so that people can't do things like <code>my_immutable_object.x = 3</code>. Take the following custom immutable class for example.</p>
<pre><code>class Immutable(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __setattr__(self, key, value):
        raise AttributeError("LOL nope.")
</code></pre>
<p>Let's try using it.</p>
<pre><code>im = Immutable(2, 3)
print(im.a, im.b, sep=", ")
</code></pre>
<p>Output:</p>
<pre><code>AttributeError: LOL nope.
</code></pre>
<p>"But what!?", I hear you ask, "I didn't set any of its attributes after it's been created!" Ah but <strong>yes you did</strong>, in the <code>__init__()</code>. Since <code>__init__()</code> is called <em>after</em> the object is created, the lines <code>self.a = a</code> and <code>self.b = b</code> are setting the attributes <code>a</code> and <code>b</code> <em>after</em> the creation of <code>im</code>. What you really want is to set the attributes <code>a</code> and <code>b</code> <em>before</em> the immutable object is created. An obvious way to do that is to create a <em>mutable</em> type first (whose attributes you <em>are allowed</em> to set in <code>__init__()</code>), and then make the <em>immutable</em> type a <em>subclass</em> of it, and make sure you implement the <code>__new__()</code> method of the immutable child class to construct a mutable version first, and then make it immutable, like the following.</p>
<pre><code>class Mutable(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b


class ActuallyImmutable(Mutable):
    def __new__(cls, a, b):
        thing = Mutable(a, b)
        thing.__class__ = cls
        return thing

    def __setattr__(self, key, value):
        raise AttributeError("LOL nope srsly.")
</code></pre>
<p>Now let's try running it.</p>
<pre><code>im = ActuallyImmutable(2, 3)
print(im.a, im.b, sep=", ")
</code></pre>
<p>Output:</p>
<pre><code>AttributeError: LOL nope srsly.
</code></pre>
<p>"WTF!? When did <code>__setattr__()</code> get called this time?" The thing is, <code>ActuallyImmutable</code> is a subclass of <code>Mutable</code>, and without explicitly implementing its <code>__init__()</code>, the parent class's <code>__init__()</code> is automatically called <em>after</em> the creation of the <code>ActuallyImmutable</code> object, so in total the parent's <code>__init__()</code> is called twice, once before the creation of <code>im</code> (which is OK) and once <em>after</em> (which is <strong>not OK</strong>). So let's try again, this time overriding <code>AcutallyImmutable.__init__()</code>.</p>
<pre><code>class Mutable(object):
    def __init__(self, a, b):
        print("Mutable.__init__() called.")
        self.a = a
        self.b = b


class ActuallyImmutable(Mutable):
    def __new__(cls, a, b):
        thing = Mutable(a, b)
        thing.__class__ = cls
        return thing

    # noinspection PyMissingConstructor
    def __init__(self, *args, **kwargs):
        # Do nothing, to prevent it from calling parent's __init__().
        pass

    def __setattr__(self, key, value):
        raise AttributeError("LOL nope srsly.")
</code></pre>
<p>Now it should work.</p>
<pre><code>im = ActuallyImmutable(2, 3)
print(im.a, im.b, sep=", ")
</code></pre>
<p>Output:</p>
<pre><code>2, 3
</code></pre>
<p>Good, it worked. Oh, don't worry about the <code># noinspection PyMissingConstructor</code>, that's just a PyCharm hack to stop PyCharm from complaining that I didn't call the parent's <code>__init__()</code>, which obviously is what we intend here. And finally just to check that <code>im</code> really is immutable, verify that <code>im.a = 42</code> will give you <code>AttributeError: LOL nope srsly.</code>.</p>
</div>
<span class="comment-copy">Note that it's not really immutable, it's just "hard" to mutate. You can always override attributes of "immutable pure-Python classes" with <code>object.__setattr__</code>: <code>object.__setattr__(im, 'a', 10)</code> or in your case even with <code>Mutable.__setattr__(im, 'a', 10)</code>.</span>
