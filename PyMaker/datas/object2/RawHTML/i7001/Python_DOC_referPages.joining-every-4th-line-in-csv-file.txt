<div class="post-text" itemprop="text">
<p>I'd like to join every 4th line together so I thought something like this would work: </p>
<pre><code>import csv

filename = "mycsv.csv"
f = open(filename, "rb")

new_csv = []
count = 1

for i, line in enumerate(file(filename)):
    line = line.rstrip()
    print line
    if count % 4 == 0:
        new_csv.append(old_line_1 + old_line_2 + old_line_3+line)
    else:
        old_line_1 = line[i-2]
        old_line_2 = line[i-1]
        old_line_3 = line
    count += 1

print new_csv
</code></pre>
<p>But <code>line[i-1]</code> and <code>line[i-2]</code> does not take current line -1 and -2 as I thought. So how can I access current line -1 and -2? </p>
</div>
<div class="post-text" itemprop="text">
<p>The variable <code>line</code> contains only the line for the current iteration, so accessing <code>line[i-1]</code> will only give you one character within the current line. <a href="https://stackoverflow.com/a/45709203/1782792">The other answer</a> is probably the tersest way to put it but, building on your code, you could do something like this instead:</p>
<pre><code>import csv

filename = "mycsv.csv"
with open(filename, "rb") as f:
    reader = csv.reader(f)
    new_csv = []
    lines = []
    for i, line in enumerate(reader):
        line = line.rstrip()
        lines.append(line)
        if (i + 1) % 4 == 0:
            new_csv.append("".join(lines))
            lines = []

print new_csv
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should do as you require</p>
<pre><code>join_every_n = 4
all_lines = [line.rstrip() for line in file(filename)]  # note the OP uses some unknown func `file` here
transposed_lines = zip(*[all_lines[n::join_every_n] for n in range(join_every_n)])
joined = [''.join([l1,l2,l3,l4]) for (l1,l2,l3,l4) in transposed_lines]
</code></pre>
<p>likewise you could also do</p>
<pre><code>joined = map(''.join, transposed_lines)
</code></pre>
<h1>Explanation</h1>
<p>This will return every i'th element in a <code>your_list</code> with an offset of <code>n</code></p>
<pre><code>your_list[n::i]
</code></pre>
<p>Then you can combine this across a <code>range(4)</code> to generate for every 4 lines in a list such that you get</p>
<pre><code>[[line0, line3, ...], [line1, line4, ...], [line2, line6, ...], [line3, line7, ...]]
</code></pre>
<p>Then the <code>transposed_lines</code> is required to transpose this array so that it becomes like</p>
<pre><code>[[line0, line1, line2, line3], [line4, line5, line6, line7], ...]
</code></pre>
<p>Now you can simple unpack and join each individual list element</p>
<h1>Example</h1>
<pre><code>all_lines = map(str, range(100))
transposed_lines = zip(*[all_lines[n::4] for n in range(4)])
joined = [''.join([l1,l2,l3,l4]) for (l1,l2,l3,l4) in transposed_lines]
</code></pre>
<p>gives</p>
<pre><code>['0123',
 '4567',
 '891011',
...
</code></pre>
</div>
<span class="comment-copy">No, no, no. Don't use <code>enumerate</code> function. It can be very dangerous. At first, use <code>with</code> statement and then look at <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">csv built-in library</a>.</span>
<span class="comment-copy">@HonzaSedloň what's with the statement <i>Don't use enumerate function. It can be very dangerous</i> - it doesn't make much sense...?</span>
<span class="comment-copy">@HonzaSedloň How exactly is <code>enumerate()</code> dangerous (in itself)?</span>
<span class="comment-copy">There is always a better way then using <code>enumerate()</code>.</span>
<span class="comment-copy">@HonzaSedloň: that's the most <i>absurd</i> accusation I have yet to come across. Why is <code>enumerate()</code> <i>dangerous</i>? All it does is add an increasing counter to an iterable. Please provide some proof.</span>
<span class="comment-copy">Instead of enumerating from 0 and doing <code>(i + 1) % 4 == 0</code>, you could just start enumerating at 1: <code>enumerate(open(filename), 1)</code>.</span>
<span class="comment-copy">Do you mind explaining  <code>lines = []</code>on row 8 and then again on 14?</span>
<span class="comment-copy">@destinychoice Sure, and also I fixed a mistake. The first time you are just creating an empty list <i>before</i> even starting to read the file. Every line that you read you add it to this <code>lines</code> list. Then, when you reach a multiple of 4 you <a href="https://docs.python.org/2.7/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>join</code></a> the strings in the list and append the result to <code>new_csv</code>; then the list <code>lines</code> is cleared (made it empty again) so in the next iteration you start with the next block of four lines.</span>
<span class="comment-copy">@poke Umh, right, that was just copy/pasted from the OP but I've cleaned up the code a bit in that too anyway.</span>
<span class="comment-copy">@jdehesa Thank you!</span>
<span class="comment-copy"><code>TypeError: join() takes exactly one argument (4 given)</code></span>
<span class="comment-copy">@destinychoice I've fixed and explained</span>
<span class="comment-copy">The same one as the magic <code>file</code> function in the OP <code>for i, line in enumerate(file(filename)):</code> See the example for a non-magic <code>file</code> function - I'll add a note to clarify</span>
<span class="comment-copy">FWIW, the <code>file</code> callable is an ancient deprecated way of opening files. It's not a function, it's the constructor for <code>file</code> objects. You can read about it in <a href="https://docs.python.org/2.2/lib/bltin-file-objects.html#tex2html11" rel="nofollow noreferrer">the Python 2.2 docs</a>. The 2.2 docs recommend <code>file()</code> over <code>open()</code>, by 2.4 the recommendation was to use <code>open</code> for opening and <code>file</code> for type testing. And of course <code>file</code> no longer exists in Python 3.</span>
