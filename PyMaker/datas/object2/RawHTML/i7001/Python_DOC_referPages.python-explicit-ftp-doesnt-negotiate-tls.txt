<div class="post-text" itemprop="text">
<p>I'm trying to transfer a file to a host over FTP TLS explicit, but don't know how to handle the certificate.  A WinSCP log of the transaction shows that the TLS negotiation is handled and the certificate is verified.  But my Python script fails to do this.  I know the certificate fingerprint and the cipher, but don't know how to implement it.</p>
<p>My script:</p>
<pre><code>import ftplib
import ssl


def main():
    ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1_2)
    ftps = ftplib.FTP_TLS(context=ctx)

    try:
        ftps.set_debuglevel(2)
        print(ftps.connect(host))
        ftps.auth()
        print(ftps.login(username,password))
        print("1")
        ftps.prot_p()
        print("2")
        #ftps.cwd('/')
        print("3")
        print (ftps.retrlines('LIST'))
        print("4")
        ftps.storbinary("STOR test.csv", open('C:\\test.csv', 'rb'))
        print("5")
    except Exception as ex:
        print("error: ")
        print(ex)

    ftps.close()

    input('Hit &lt;ENTER&gt; to close...')


if __name__ == "__main__":
    main()
</code></pre>
<p>Here is my output, the last line is the Python error:</p>
<pre><code>*get* '220 Microsoft FTP Service\n'
*resp* '220 Microsoft FTP Service'
220 Microsoft FTP Service
*cmd* 'AUTH TLS'
*put* 'AUTH TLS\r\n'
*get* '234 AUTH command ok. Expecting TLS Negotiation.\n'
*resp* '234 AUTH command ok. Expecting TLS Negotiation.'
*cmd* 'USER xxx'
*put* 'USER xxx\r\n'
*get* '331 Password required\n'
*resp* '331 Password required'
*cmd* 'PASS ********'
*put* 'PASS ********\r\n'
*get* '230 User logged in.\n'
*resp* '230 User logged in.'
230 User logged in.
1
*cmd* 'PBSZ 0'
*put* 'PBSZ 0\r\n'
*get* '200 PBSZ command successful.\n'
*resp* '200 PBSZ command successful.'
*cmd* 'PROT P'
*put* 'PROT P\r\n'
*get* '200 PROT command successful.\n'
*resp* '200 PROT command successful.'
2
3
*cmd* 'TYPE A'
*put* 'TYPE A\r\n'
*get* '200 Type set to A.\n'
*resp* '200 Type set to A.'
*cmd* 'PASV'
*put* 'PASV\r\n'
*get* '227 Entering Passive Mode (x,x,x,x,4,4).\n'
*resp* '227 Entering Passive Mode (x,x,x,x,4,4).'
*cmd* 'LIST'
*put* 'LIST\r\n'
*get* '125 Data connection already open; Transfer starting.\n'
*resp* '125 Data connection already open; Transfer starting.'
*get* '226 Transfer complete.\n'
*resp* '226 Transfer complete.'
226 Transfer complete.
4
*cmd* 'TYPE I'
*put* 'TYPE I\r\n'
*get* '200 Type set to I.\n'
*resp* '200 Type set to I.'
*cmd* 'PASV'
*put* 'PASV\r\n'
*get* '227 Entering Passive Mode (x,x,x,x,4,3).\n'
*resp* '227 Entering Passive Mode (x,x,x,x,4,3).'
*cmd* 'STOR test.csv'
*put* 'STOR test.csv\r\n'
*get* '125 Data connection already open; Transfer starting.\n'
*resp* '125 Data connection already open; Transfer starting.'
error: 
The read operation timed out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>A WinSCP log of the transaction shows that the TLS negotiation is handled and the certificate is verified. But my Python script fails to do this. I know the certificate fingerprint and the cipher, but don't know how to implement it.</p>
</blockquote>
<p>Your Python script does not fail in the TLS negotiation as you assume.</p>
<p>An upgrade from a plain connection to TLS is requested by the client with the <code>AUTH TLS</code> command which is accepted by the server which can be seen in the log:</p>
<pre><code>*put* 'AUTH TLS\r\n'
*get* '234 AUTH command ok. Expecting TLS Negotiation.\n'
</code></pre>
<p>After that the TLS negotiation (i.e. TLS handshake) is done. If the handshake would fail the client would abort. But the handshake succeeds so that the client can continue with more command which also get accepted by the server:</p>
<pre><code>*put* 'USER xxx\r\n'
*get* '331 Password required\n'
</code></pre>
<p>Thus, there is no problem in the TLS negotiation. It is also not a problem with the data transfer itself which can be seen in that the client succeeds in transferring data from the server, i.e. the directory listing:</p>
<pre><code>*put* 'PASV\r\n'
*get* '227 Entering Passive Mode (x,x,x,x,4,4).\n'
*put* 'LIST\r\n'
*get* '125 Data connection already open; Transfer starting.\n'
*get* '226 Transfer complete.\n'
</code></pre>
<p>It only fails when transferring a file to the server because the server does not reply within the expected time:</p>
<pre><code>*put* 'STOR test.csv\r\n'
*get* '125 Data connection already open; Transfer starting.\n'
error: 
The read operation timed out
</code></pre>
<p>It is unclear why the server fails to respond. One possible reason might be that the file needs to be processed by some application (like an antivirus) before the server will respond with success and that this processing takes too long.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue turned out to be with the unwrapping of the socket after the file is transmitted.  More specifically, the shutdown() method appears to wait for the server to see if it's okay to close the socket.  In this case the server doesn't answer.  The file does indeed get transmitted, but the socket issue throws an error before a "File transfer complete" response can be received.</p>
<p>It seems to go like this (sending file to server):
1. Establish FTP TLS
2. Client issues STOR command
3. A secure socket is created
4. The file is transferred
5. The socket is unwrapped and disposed of.
6. The "transfer complete" response is received from the server.</p>
<p>But an issue with step 5 prevents 6 from happening.</p>
<p>I'm not sure if this is a bug or not.  A little bit of research shows that sockets can be closed instead of shutdown and that servers may not respond to socket shutdown requests.</p>
<p>My solution was to modify my local python libraries to deal with it.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Comment</strong>:<br/>
<code>ssl.create_default_context()</code> results in an error: "[SSL: CERTIFICATE_VERIFY_FAILED]"  </p>
</blockquote>
<hr/>
<blockquote>
<p><a href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" rel="nofollow noreferrer">ssl.create_default_context(purpose=Purpose.SERVER_AUTH,  cafile=None, capath=None, cadata=None)</a><br/>
  Return a new SSLContext object with default settings for the given purpose.  </p>
<p>cafile, capath, cadata represent optional CA certificates to trust for certificate verification, as in SSLContext.load_verify_locations(). If all three are None, this function can choose to trust the system’s default CA certificates instead.</p>
</blockquote>
<p>Use as follows:</p>
<pre><code>ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)
</code></pre>
<hr/>
<blockquote>
<p><strong>Question</strong>: don't know how to handle the certificate</p>
</blockquote>
<p>Use <code>ctx = ssl.load_cert_chain(certfile, keyfile=None, password=None)</code>,<br/>
you already have a <code>context=ctx</code>.</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/ftplib.html#ftplib.FTP_TLS" rel="nofollow noreferrer">class ftplib.FTP_TLS(host=”, user=”, passwd=”, acct=”, keyfile=None, certfile=None, context=None, timeout=None, source_address=None)</a> </p>
<p>A FTP subclass which adds TLS support to FTP as described in RFC 4217.<br/>
<code>context=</code> is a ssl.SSLContext object which allows bundling SSL configuration options, <strong>certificates</strong> and <strong>private keys</strong> into a single (potentially long-lived) structure.</p>
<p><code>keyfile=</code> and <code>certfile=</code> are a legacy alternative to context – they can point to PEM-formatted private key and certificate chain files (respectively) for the SSL connection.</p>
</blockquote>
<hr/>
<blockquote>
<p><strong>Deprecated since version 3.6</strong>:<br/>
<strong>keyfile and certfile are deprecated</strong> in favor of <code>context</code>. Please use <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_cert_chain" rel="nofollow noreferrer">ssl.SSLContext.load_cert_chain()</a> instead, or let ssl.create_default_context() select the system’s trusted CA certificates for you.</p>
</blockquote>
</div>
<span class="comment-copy">Please show any error messages you got.</span>
<span class="comment-copy">I edited my post to include a log with the error.</span>
<span class="comment-copy">According to the update there is no TLS negotiation problem at all as you claim. If there would be one you would not be able to even issue the USER command after AUTH TLS. The problem is instead a timeout of the data connection  during the second data transfer which might be caused by a firewall in between or some antivirus at the server or similar. But its not a TLS negotiation problem.</span>
<span class="comment-copy">But if I log a WinSCP session I can see certificate validation taking place that doesn't appear to happen with my Python script.  I'll ask our security person, though, about the firewall.</span>
<span class="comment-copy">Can't be a firewall issue, since the transfer works through WinSCP.</span>
<span class="comment-copy">Is there a workaround to this?  This seems strange, though, as a WinSCP transfer is done very quickly and the Python script takes a very long time before it times out.</span>
<span class="comment-copy">I assume that it has to do with certificate validation, since the WinSCP log shows that taking place and the Python debug output does not.  That cert validation was what I was including as "TLS negotiation".</span>
<span class="comment-copy">You might notice lots of other differences between the WinSCP log and the Python log. They log different things or log same things in a different way - and Python simply does not log that the TLS handshake takes place although it takes place. It also does not log how many data it transferred although it did transfer data.</span>
<span class="comment-copy"><i>Is there a workaround to this?</i> - Since I don't know the cause of the original problem it is hard to say what a workaround might be. Did you transfer exactly the same file, into the same folder, to the same system as with WinSCP?</span>
<span class="comment-copy">Yes.  Same file, same location, same system.</span>
<span class="comment-copy">I'm using Python 3.5.  To be clear, though, I don't have a cert file...I'm validating the host's cert.</span>
<span class="comment-copy">ssl.SSLContext.load_cert_chain() requires a certfile path, which I don't have...I'm not using a private certificate.</span>
<span class="comment-copy">And calling ssl.create_default_context() results in an error: "[SSL: CERTIFICATE_VERIFY_FAILED]"</span>
<span class="comment-copy">@Mike: I see your Point and it has to be <b>PEM</b> Format. For now I don't know if it's possible to build a PEM Certificat from your available <i>"certificate fingerprint and the cipher"</i>.</span>
<span class="comment-copy">If there would be a problem with the TLS handshake it would already fail in AUTH TLS. The logs show that it happily continues after that so it is not a TLS handshake problem - no matter what the OP claims.</span>
