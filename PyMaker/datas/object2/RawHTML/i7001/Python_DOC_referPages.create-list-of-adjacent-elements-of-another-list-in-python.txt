<div class="post-text" itemprop="text">
<p>I am looking to take as input a list and then create another list which contains tuples (or sub-lists) of adjacent elements from the original list, wrapping around for the beginning and ending elements. The input/output would look like this:</p>
<pre><code>l_in  = [0, 1, 2, 3]
l_out = [(3, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 0)]
</code></pre>
<p>My question is closely related to another titled <a href="https://stackoverflow.com/questions/25153034/getting-successive-adjacent-elements-of-a-list">getting successive adjacent elements of a list</a>, but this other question does not take into account wrapping around for the end elements and only handles pairs of elements rather than triplets.</p>
<p>I have a somewhat longer approach to do this involving rotating deques and zipping them together:</p>
<pre><code>from collections import deque
l_in = [0, 1, 2, 3]
deq = deque(l_in)
deq.rotate(1)
deq_prev = deque(deq)
deq.rotate(-2)
deq_next = deque(deq)
deq.rotate(1)
l_out = list(zip(deq_prev, deq, deq_next))
# l_out is [(3, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 0)]
</code></pre>
<p>However, I feel like there is probably a more elegant (and/or efficient) way to do this using other built-in Python functionality. If, for instance, the <code>rotate()</code> function of <code>deque</code> returned the rotated list instead of modifying it in place, this could be a one- or two-liner (though this approach of zipping together rotated lists is perhaps not the most efficient). How can I accomplish this more elegantly and/or efficiently?</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be done with slices:</p>
<pre><code>l_in  = [0, 1, 2, 3]

l_in = [l_in[-1]] + l_in + [l_in[0]]
l_out = [l_in[i:i+3] for i in range(len(l_in)-2)]
</code></pre>
<p>Well, or such a perversion:</p>
<pre><code>div = len(l_in)
n = 3
l_out = [l_in[i % div: i % div + 3]
         if len(l_in[i % div: i % div + 3]) == 3
         else l_in[i % div: i % div + 3] + l_in[:3 - len(l_in[i % div: i % div + 3])]
         for i in range(3, len(l_in) + 3 * n + 2)]
</code></pre>
<p>You can specify the number of iterations.</p>
</div>
<div class="post-text" itemprop="text">
<p>One approach may be to use <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> combined with <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.windowed" rel="nofollow noreferrer"><code>more_itertools.windowed</code></a>:</p>
<pre><code>import itertools as it

import more_itertools as mit


l_in  = [0, 1, 2, 3]
n = len(l_in)
list(it.islice(mit.windowed(it.cycle(l_in), 3), n-1, 2*n-1))
# [(3, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 0)]
</code></pre>
<p>Here we generated an infinite cycle of <a href="https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples">sliding windows</a> and sliced the desired subset.</p>
<hr/>
<p>FWIW, here is an abstraction of the latter code for a general, flexible solution given any iterable input e.g. <code>range(5)</code>, <code>"abcde"</code>, <code>iter([0, 1, 2, 3])</code>, etc.:</p>
<pre><code>def get_windows(iterable, size=3, offset=-1):
    """Return an iterable of windows including an optional offset."""
    it1, it2 = it.tee(iterable)
    n = mit.ilen(it1)
    return it.islice(mit.windowed(it.cycle(it2), size), n+offset, 2*n+offset)


list(get_windows(l_in))
# [(3, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 0)]

list(get_windows("abc", size=2))
# [('c', 'a'), ('a', 'b'), ('b', 'c')]

list(get_windows(range(5), size=2, offset=-2))
# [(3, 4), (4, 0), (0, 1), (1, 2), (2, 3)]
</code></pre>
<p>Note: <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more-itertools</code></a> is a separate library, easily installed via:</p>
<pre><code>&gt; pip install more_itertools
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I figured out a better solution as I was writing the question, but I already went through the work of writing it, so here goes. This solution is at least much more concise:</p>
<pre><code>l_out = list(zip(l_in[-1:] + l_in[:-1], l_in, l_in[1:] + l_in[:1]))
</code></pre>
<p>See <a href="https://stackoverflow.com/questions/9457832/python-list-rotation">this post</a> for different answers on how to rotate lists in Python.</p>
<p>The one-line solution above should be at least as efficient as the solution in the question (based on my understanding) since the slicing should not be more expensive than the rotating <em>and</em> copying of the deques (see <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">https://wiki.python.org/moin/TimeComplexity</a>).</p>
<p>Other answers with more efficient (or elegant) solutions are still welcome though.</p>
</div>
<div class="post-text" itemprop="text">
<p>as you found there is a list rotation slicing based idiom <code>lst[i:] + lst[:i]</code></p>
<p>using it inside a comprehension taking a variable <code>n</code> for the number of adjacent elements wanted is more general <code>[lst[i:] + lst[:i] for i in range(n)]</code></p>
<p>so everything can be parameterized, the number of adjacent elements <code>n</code> in the cyclic rotation and the 'phase' <code>p</code>, the starting point if not the 'natural' 0 base index, although the default <code>p=-1</code> is set to -1 to fit the apparant desired output</p>
<pre><code>tst = list(range(4))

def rot(lst, n, p=-1):
    return list(zip(*([lst[i+p:] + lst[:i+p] for i in range(n)])))

rot(tst, 3)
Out[2]: [(3, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 0)]    
</code></pre>
<p>showing the shortend code as per the comment</p>
</div>
<span class="comment-copy">The use of <code>more_itertools.windowed</code> seems like a great alternate way to do this that was made for this kind of problem. It should be noted though that the package <code>more_itertools</code> is not built-in (though it can be easily installed with <code>pip3 install more-itertools</code>).</span>
<span class="comment-copy">I think this can actually be simplified down to <code>list(mit.windowed(l_in[-1:] + l_in + l_in[:1], 3))</code>, which is probably the cleanest way of doing it I have seen so far.</span>
<span class="comment-copy">Updated. Thank you.  Yes, windowing is indeed a useful concept.  You are welcome to apply any technique you wish with it.  Your suggestion is concise, clear and will certainly work in this case, but it relies on concatenating lists (or tuples).  I attempted to give general solution that should work with any size iterable and window.  For example, your suggestion potentially gives an unexpected answer for  <code>range(5)</code>, window size of 2.</span>
<span class="comment-copy">I think the outer list comprehension is redundant. You should be able to simplify what is being returned down to <code>list(zip(*[lst[i+p:] + lst[:i+p] for i in range(n)]))</code>.</span>
<span class="comment-copy">It also seems like unexpected behavior that specifying an <code>n</code> such that <code>n &gt; len(lst)</code> will result in the first element being used as a filler value at the end of each tuple (as seen in the last case of <code>rot(txt, 6, 0)</code> that you show) rather than continuing to cycle through <code>lst</code>.</span>
