<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>For rounding to the nearest 0.05, I am just dividing it by 0.05 and then multiply by 0.05. As described in other similar questions.</p>
<pre><code>In [119]: (127.651//0.05)*0.05
Out[119]: 127.65

In [120]: (127.6501//0.05)*0.05
Out[120]: 127.65

In [121]: (127.65000001//0.05)*0.05
Out[121]: 127.65

In [122]: (127.65000000001//0.05)*0.05
Out[122]: 127.65

In [123]: (127.6500000000001//0.05)*0.05
Out[123]: 127.65
</code></pre>
<p>Till here its doing as expected.
However for this special case:</p>
<pre><code>In [124]: (127.650000000000000001//0.05)*0.05
Out[124]: 127.60000000000001
</code></pre>
<p>I would have expected 127.65 here.</p>
<p>Tried rounding off before dividing, but again.. strange.
Not only i am getting unexpected result(expecting 127.65), but also it is giving results that is beyond 2 decimal places, which will result into failure in my further processing functions.</p>
<pre><code>In [125]: (round(127.650000000000000001,5)//0.05)*0.05
Out[125]: 127.60000000000001
</code></pre>
<p>If i execute just the inner round,  o/p is 127.65... </p>
<pre><code>In [126]: round(127.650000000000000001,5)
Out[126]: 127.65
</code></pre>
<p>But on adding the divide and multiply logic.. the result becomes unexpected.</p>
<pre><code>In [125]: (round(127.650000000000000001,5)//0.05)*0.05
Out[125]: 127.60000000000001
</code></pre>
<p>Should there be any datatype issue? or internal precision limitations of python?</p>
<p>how do i overcome it in an elegant way?</p>
<p>PS: </p>
<p>1) I am using python 2.7</p>
<p>2) I am eventually using it in a function. Which is giving unexpected results for this special case. I cannot control the input data quality and its data precision, as it is coming from reading a csv file to dataframe.</p>
<pre><code>def RP(price):# Round down to the nearest price quotable ...i.e. multiple of 0.05
        return(round(price//0.05*0.05,2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Finally the scaling up logic mentioned in <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">is-floating-point-math-broken</a> worked for me.</p>
<pre><code>In [200]: (int(127.65*100)//5*5)/100.0
Out[200]: 127.65

In [201]:

In [201]: (int(127.65000000000000001*100)//5*5)/100.0
Out[201]: 127.65
</code></pre>
<p>or :</p>
<pre><code>In [286]: int(127.65*20)/20.0
Out[286]: 127.65

In [287]: int(127.6500000000000000000000001*20)/20.0
Out[287]: 127.65
</code></pre>
<p><strong>UPDATE:</strong></p>
<p>For my intended purpose, (rounding to the nearest 0.05 to get the price quote), so far below is the most closest solution that i can find after so many days of search and checking results on multiple values and iterations.</p>
<pre><code>def RP(price):# Round to the nearest price quotable ...i.e. multiple of 0.05
        return(round(price*20.0,0)/20.0)

def RP_down(price):# Round_Down to the price quotable ...i.e. multiple of 0.05
        return(int(price*20.0)/20.0)

def RP_up(price):# Round_UP to the price quotable ...i.e. multiple of 0.05
        return(0.05 + int(price*20.0)/20.0)
</code></pre>
<p>Why it works? The below explanation follows:</p>
<p>Multiply by 20.0 followed by round() or int(), changes the domain from floating point to integers.</p>
<p>And so, eliminates the precision problem, that led to the unexpected results.</p>
<p><strong>Note:</strong> That in the last step (divide by 20.0), we again move from integer to floating point, but with the correct expected value(no surprises so far after running in production from past one week). And you know it for sure that it has only 2 decimal places theoretically (an integer divide by 20), so if need be, you can handle it in the rest of your program by chopping off the rest, while printing.</p>
</div>
<span class="comment-copy">More classic <a href="https://stackoverflow.com/q/588004/3001761">Is floating point math broken?</a>. If you want exact representation, consider using <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>Decimal</code></a>.</span>
<span class="comment-copy">I'm very new to py, but I guess for floating points there will be issues. importing decimal will make it much precise I guess. Just <code>import decimal</code></span>
<span class="comment-copy">Hint: what does <code>127.6500000000000056 == 127.65</code> give you? Does the answer surprise you?</span>
<span class="comment-copy">Instead of surprising. It confused me further.        In [159]: 127.6500000000000056 == 127.65       Out[159]: True  After reading the duplicate answer link. I was expecting it to return False.</span>
<span class="comment-copy">@ihpar just adding import decimal isnt resolving.</span>
<span class="comment-copy">This is not a good solution. It may "work" for you for those couple of cases that you tested, but you'll eventually find other examples where things round the "wrong" way.</span>
<span class="comment-copy">@Mark Updated the answer. Unfortunately other ways like using 'Decimal' cant work for me because the data input is already in float and the precision is already lost. Surprisingly, there is a lot of documentation on this problem, but majority of it is about explaining the problem. Very few for solutions.  So the scaling-up logic was the best option(i may be wrong) that i could have used to handle this case.  Should you have any other solution, please convey.</span>
