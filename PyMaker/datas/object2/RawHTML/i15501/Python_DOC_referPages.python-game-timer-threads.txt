<div class="post-text" itemprop="text">
<p>I am designing a game in Python and would like to know how to make an efficient timer that can run along side my game.</p>
<p><strong>Note: I am using Pygame.</strong></p>
<p>I currently have a timer like so:</p>
<pre><code>import time

seconds = 60

def start_timer():
    global seconds
    while seconds &gt; 0:
        print seconds
        seconds -= 1
        time.sleep(1)
</code></pre>
<p>However, when run in my main game function my game hangs because of the <code>timer.sleep</code>.</p>
<pre><code>def main(self):
    Timer.start_timer()
</code></pre>
<p>I'm pretty sure my issue has something to do with not using threading, although I'm not 100% sure. Can somebody help explain to me what the proper solution is?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using PyGame, it has its own <a href="http://www.pygame.org/docs/ref/time.html" rel="nofollow">time functionality</a> that you should be using.</p>
<p>If you're using an event-loop or hybrid design, where you loop over <code>pygame.event.get()</code> or similar and call "event handlers" for different events like mouse-click or key-down, you can use <a href="http://www.pygame.org/docs/ref/time.html#pygame.time.set_timer" rel="nofollow"><code>set_timer</code></a> to create an event that fires every second. For example:</p>
<pre><code>TIMER1_EVENT = pygame.USEREVENT + 1

def start_timer1():
    global seconds
    seconds = 60
    pygame.time.set_timer(TIMER1_EVENT, 1000)

def on_timer1():
    global seconds
    print seconds
    seconds -= 1
    if seconds &lt; 0:
        pygame.time.set_timer(TIMER1_EVENT, 0)

# elsewhere, inside your main event loop
elif event.type == TIMER1_EVENT:
    on_timer1()
</code></pre>
<p>There are very simple example programs linked in the docs for each function; if you look at the examples for <code>set_timer</code> you'll see how easy it is to use.</p>
<p>If you're using a pure frame loop instead, you're presumably already calling <a href="http://www.pygame.org/docs/ref/time.html#pygame.time.Clock" rel="nofollow"><code>Clock.tick</code></a> or similar, and you're going to have to use the return value from that to count down milliseconds since the last time and decide whether you've passed another integral number of seconds and when you're passed 0.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using PyGame, or some other graphical library, and have built your game around an event loop or frame-rate loop, you want to use the functions that come with that library. If you're got an event loop, you can ask it to schedule an event to fire in 60 seconds. If you're got a frame-rate loop, you may be able to do the same thing, or need to check the remaining time once/frame.</p>
<p>But if you're <em>not</em> doing that, then yes, threading is the answer.</p>
<p>For simple timers, the simplest solution is the <a href="https://docs.python.org/3/library/threading.html#timer-objects" rel="nofollow"><code>Timer</code></a> class. However, this doesn't automatically do repeating timers, so you have to add that manually. For example, you can start a 1-second timer, and have it start another 1-second timer when it expires:</p>
<pre><code>def start_timer():
    global seconds
    if seconds &gt; 0:
        print seconds
        seconds -= 1
        threading.Timer(1, start_timer).start()

seconds = 60
threading.Timer(1, start_timer).start()
</code></pre>
<p>However, it's usually a lot easier to use a timer that knows how to do repeats for you. You can build one yourself (notice that the <code>threading</code> docs contain a link to the <a href="https://hg.python.org/cpython/file/3.4/Lib/threading.py#l1162" rel="nofollow">source</a>, and it's not hard to figure out how to add logic that makes it fire every <code>interval</code> seconds for <code>count</code> times, instead of just once). Or you can <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=timer&amp;submit=search" rel="nofollow">go search PyPI</a> and find dozens of people who've already implemented that for you.</p>
<p>Also keep in mind that once you use threads, you have to deal with threading issues. If you're using a GUI library, they often won't let you call GUI methods from a background thread. If you're accessing a variable that's shared between two threads, you often need a <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow"><code>Lock</code></a> or other synchronization object to protect it. And so on.</p>
</div>
<span class="comment-copy">Is this a graphical game using something like PyGame? If so, there's probably a <i>better</i> answer than threads. But threads will still work.</span>
<span class="comment-copy">Yes, it is a game using PyGame!</span>
<span class="comment-copy">Here is a pastebin of my main loop: <a href="http://pastebin.com/E3LYfYqf" rel="nofollow noreferrer">pastebin.com/E3LYfYqf</a>    I believe that it is a frame loop because I do have <code>clock.tick</code>. Could you give me an example using my code? I am fairly new to Pygame. Thanks!</span>
<span class="comment-copy">@test: You still have a loop around <code>pygame.event.get()</code> in there, which means you can still use <code>pygame.time.set_timer()</code>. You only need the manual counting code if you don't have an event loop at all. In your code, all you need to do is add this <code>elif</code> after line 61. And, under whatever conditions you want to start the timer, add a call to <code>start_timer1()</code> of course.</span>
<span class="comment-copy">Hmm, when I add the <code>elif: on_timer1()</code> the timer never starts, and when I remove the <code>elif</code> it just seems to run randomly, not once per second. I apoligize for not understanding this. As I said I'm new to Pygame.</span>
<span class="comment-copy">Nevermind, I got it! Thanks.</span>
<span class="comment-copy">I am using a frame-rate loop, however; your code seemed to work slightly. How would I do a timer that acts the same way as mine above? I would like to decrement every 1 second, this seems to start two-timers, while I only desire one. Thanks</span>
<span class="comment-copy">@test: This only starts one timerâ€”but that timer expires after one second, so you start a <i>second</i> timer, which expires after one second, so you start a <i>third</i> one, and so on, until the 60th timer expires and you don't hit the <code>if</code> and don't start a 61st. This is why the built-in <code>Timer</code> is clumsy to use, and why I suggested using another alternative.</span>
