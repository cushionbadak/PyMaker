<div class="post-text" itemprop="text">
<p>I'm trying to learn neat pythonic ways of doing things, and was wondering why my for loop cannot be refactored this way:</p>
<pre><code>q  = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
vm = [-1, -1, -1, -1]

for v in vm:
    if v in q:
        p.append(q.index(v))
    else:
        p.append(99999)

vm[p.index(max(p))] = i
</code></pre>
<p>I tried replacing the for loop with:</p>
<pre><code>[p.append(q.index(v)) if v in q else p.append(99999) for v in vm]
</code></pre>
<p>But it doesn't work. The <code>for v in vm:</code> loop evicts numbers from <code>vm</code> based on when they come next in <code>q</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are using is called a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a> in Python, not an inline for-loop (even though it is similar to one). You would write your loop as a list comprehension like so:</p>
<pre><code>p = [q.index(v) if v in q else 99999 for v in vm]
</code></pre>
<p>When using a list comprehension, you do not call <code>list.append</code> because the list is being constructed from the comprehension itself.  Each item in the list will be what is returned by the expression on the left of the <code>for</code> keyword, which in this case is <code>q.index(v) if v in q else 99999</code>.  Incidentially, if you do use <code>list.append</code> inside a comprehension, then you will get a list of <code>None</code> values because that is what the <code>append</code> method always returns.</p>
</div>
<div class="post-text" itemprop="text">
<p>your list comphresnion will, work but will return list of None because append return None:</p>
<p>demo:</p>
<pre><code>&gt;&gt;&gt; a=[]
&gt;&gt;&gt; [ a.append(x) for x in range(10) ]
[None, None, None, None, None, None, None, None, None, None]
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>better way to use it like this:</p>
<pre><code>&gt;&gt;&gt; a= [ x for x in range(10) ]
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow">enumerate</a> keeping the ind/index of the elements is in vm, if you make <code>vm</code> a <a href="https://docs.python.org/2/tutorial/datastructures.html#sets" rel="nofollow">set</a> you will also have <code>0(1)</code> lookups:</p>
<pre><code>vm = {-1, -1, -1, -1}

print([ind if q in vm else 9999 for ind,ele in enumerate(vm) ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>q  = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
vm = [-1, -1, -1, -1,1,2,3,1]

p = []
for v in vm:
    if v in q:
        p.append(q.index(v))
    else:
        p.append(99999)

print p
p = [q.index(v) if v in q else 99999 for v in vm]
print p
</code></pre>
<p>Output:</p>
<pre><code>[99999, 99999, 99999, 99999, 0, 1, 2, 0]
[99999, 99999, 99999, 99999, 0, 1, 2, 0]
</code></pre>
<p>Instead of using <code>append()</code> in the list comprehension you can reference the p as direct output, and use <code>q.index(v)</code> and <code>99999</code> in the LC.</p>
<p>Not sure if this is intentional but note that <code>q.index(v)</code> will find just the first occurrence of <code>v</code>, even tho you have several in <code>q</code>. If you want to get the index of all <code>v</code> in <code>q</code>, consider using a <code>enumerator</code> and a list of already visited <code>indexes</code></p>
<p>Something in those lines(pseudo-code):</p>
<pre><code>visited = []
for i, v in enumerator(vm):
   if i not in visited:
       p.append(q.index(v))
   else:
       p.append(q.index(v,max(visited))) # this line should only check for v in q after the index of max(visited)
   visited.append(i)
</code></pre>
</div>
<span class="comment-copy">You may want to use -1 instead of 99999 for a flagging an inexistent value (so it would work even for a list with 99999+ elements)</span>
<span class="comment-copy">you list comprehsnsion will work but it will return lists of None too</span>
<span class="comment-copy">I used 99999 instead of -1 because later I ran a max(p) and nonexistent values need to be selected.</span>
<span class="comment-copy">Thanks man, awesome!  +internets for answering in less than a minute.</span>
<span class="comment-copy">Cool fancy syntax, thanks for sharing this looks very useful!</span>
