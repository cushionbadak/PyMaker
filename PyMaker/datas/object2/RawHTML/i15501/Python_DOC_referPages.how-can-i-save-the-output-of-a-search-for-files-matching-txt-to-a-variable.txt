<div class="post-text" itemprop="text">
<p>I'm fairly new to python. I'd like to save the text that is printed by at this script as a variable. (The variable is meant to be written to a file later, if that matters.) How can I do that?</p>
<pre><code>import fnmatch
import os

for file in os.listdir("/Users/x/y"):
    if fnmatch.fnmatch(file, '*.txt'):
        print(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can store it in variable like this:</p>
<pre><code>import fnmatch
import os

for file in os.listdir("/Users/x/y"):
    if fnmatch.fnmatch(file, '*.txt'):
        print(file)
        my_var = file
        # do your stuff
</code></pre>
<p>or you can store it in list for later use:</p>
<pre><code>import fnmatch
import os
my_match = []

for file in os.listdir("/Users/x/y"):
    if fnmatch.fnmatch(file, '*.txt'):
        print(file)
        my_match.append(file)       # append insert the value at end of list
# do stuff with my_match list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can store it in a list:</p>
<pre><code>import fnmatch
import os

matches = []
for file in os.listdir("/Users/x/y"):
    if fnmatch.fnmatch(file, '*.txt'):
        matches.append(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both answers already provided are correct, but Python provides a nice alternative. Since iterating through an array and appending to a list is such a common pattern, the list comprehension was created as a one-stop shop for the process.</p>
<pre><code>import fnmatch
import os

matches = [filename for filename in os.listdir("/Users/x/y") if fnmatch.fnmatch(filename, "*.txt")]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While NSU's answer and the others are all perfectly good, there <em>may</em> be a simpler way to get what you want.</p>
<p>Just as <code>fnmatch</code> tests whether a certain file matches a shell-style wildcard, <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow"><code>glob</code></a> lists all files matching a shell-style wildcard. In fact:</p>
<blockquote>
<p>This is done by using the <code>os.listdir()</code> and <code>fnmatch.fnmatch()</code> functions in concert…</p>
</blockquote>
<p>So, you can do this:</p>
<pre><code>import glob
matches = glob.glob("/Users/x/y/*.txt")
</code></pre>
<p>But notice that in this case, you're going to get full pathnames like <code>'/Users/x/y/spam.txt'</code> rather than just <code>'spam.txt'</code>, which may not be what you want. Often, it's easier to keep the full pathnames around and <code>os.path.basename</code> them when you want to display them, than to keep just the base names around and <code>os.path.join</code> them when you want to open them… but "often" isn't "always".</p>
<p>Also notice that I had to manually paste the <code>"/Users/x/y/"</code> and <code>"*.txt"</code> together into a single string, the way you would at the command line. That's fine here, but if, say, the first one came from a variable, rather than hardcoded into the source, you'd have to use <code>os.path.join(basepath, "*.txt")</code>, which isn't quite as nice.</p>
<p>By the way, if you're using Python 3.4 or later, you can get the same thing out of the higher-level <a href="https://docs.python.org/3/library/pathlib.html#module-pathlib" rel="nofollow"><code>pathlib</code></a> library:</p>
<pre><code>import pathlib
matches = list(pathlib.Path("/Users/x/y/").glob("*.txt"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe defining an utility function is the right path to follow...</p>
<pre><code>def list_ext_in_dir(e,d):
    """e=extension, d= directory =&gt; list of matching filenames.
    If the directory d cannot be listed returns None."""

    from fnmatch import fnmatch
    from os import listdir

    try:
        dirlist = os.listdir(d)
    except OSError:
        return None

    return [fname for fname in dirlist if fnmatch(fname,e)]
</code></pre>
<ul>
<li><p>I have put the <code>dirlist</code> inside a <code>try</code> <code>except</code> clause to catch the
possibility that we cannot list the directory (non-existent, read
permission, etc). The treatment of errors is a bit simplistic, but...</p></li>
<li><p>the list of matching filenames is built using a so called <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow"><em>list comprehension</em></a>, that is something that you should investigate as soon as possible if you're going to use <code>python</code> for your programs.</p></li>
</ul>
<p>To close my post, an usage example</p>
<pre><code>l_txtfiles = list_ext_in_dir('*.txt','/Users/x/y;)
</code></pre>
</div>
<span class="comment-copy">output of which function ? <code>fnmatch.fnmatch</code></span>
<span class="comment-copy">I meant the text that is printed, perhaps it's better explained now</span>
<span class="comment-copy">Thanks! This is the one I'll use.</span>
<span class="comment-copy">This is exactly what I need for a script, I'm working on, except it doesn't go trough file recursively. Is this safe/robust to use?: "matches = glob.glob("/Users/x/y/*/*.txt)" It seems to work as a way to get all .txt files recursively (trough more than just one level of folders) or, in other words, as the same thing as the "find" command (plus grep) in coreutils.</span>
<span class="comment-copy">Hm, I guess this will not work if a txt file is in y/ (which could happen). I'll write a separate question about this.</span>
<span class="comment-copy">@Var87: Linking <a href="http://stackoverflow.com/q/27459579/908494">that separate question</a> for the benefit of future readers. But the quick answer is: it actually <i>can</i> be made to work… but it's not <i>documented</i> to work, so you should use <code>os.walk</code> as in <a href="http://stackoverflow.com/a/27459625/908494">falsetru's answer</a> to your new question.</span>
<span class="comment-copy">You've just written a more limited version of <code>glob.glob</code>. (Also, it's not normal style to import modules in the middle of a function definition. Sometimes there are good reason to do so—e.g., if you need to lazily link the module because it's very slow to import and not always used, or because there are circular dependencies—but if you don't have a good reason, you're kind of implying to the reader that you do.)</span>
