<div class="post-text" itemprop="text">
<p>When I would click a button on my Tkinter, Python program, the button would freeze and I wouldn't be able to do anything else on the program. The actual command for the button would still work, but the functionality of the entire program went away. To combat this issue, I implemented threading, which in turn fixed the problem. But after I implemented threading, the performance of the program slowed way down.</p>
<p>Does anyone know what causes this? And how I can fix it?</p>
<p>EDIT----------------------------------------EDIT</p>
<p>This is what I tried to do when using the multiprocessing module as opposed to the threading module.</p>
<pre><code>from multiprocessing import Process

def InitPlaylist(self):
  #code here
def PlayPlaylist(self):
  p = Process(target = InitPlaylist)
  p.start()
  p.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's hard to say for certain without actually seeing the code, but the most likely reason for the performance hit is the <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow">Global Interpreter Lock</a>, or GIL. The Python interpreter isn't thread-safe, so it uses the GIL to protect itself bugs and crashes caused by concurrency issues. The lock only allows a single thread to actually execute Python instructions a time, which means you don't get true parallelism across CPU cores the way you can in other, GIL-less languages. Effectively, one thread executes for a bit, it gets suspended, then another thread can start, then it gets suspended, etc. You still get concurrency, but not true parallelism.</p>
<p>The most common way to fix this is to use the <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow"><code>multiprocessing</code></a> module, instead of <code>threading</code>. The <code>multiprocessing</code> utilizes processes for concurrency instead of threads, thereby avoiding the limitations of the GIL. This has some drawbacks, though, since it's more difficult and more overhead to share state between processes than threads.</p>
</div>
<span class="comment-copy">The problem, as stated, is that the program either freezes if I don't use threading, or slows down tremendously if I do use threading. So I'm trying to find a way to prevent both issues. I think that the desired behavior is implied.</span>
<span class="comment-copy">What about some of the fairly recently added asynchronous functionality? (<a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a>, for instance.)</span>
<span class="comment-copy">@jpmc26 async libraries give mostly the same results as threading (without actually using threads), they let you reclaim processing time while an i/o bound operation is waiting.</span>
<span class="comment-copy">I tried using the multiprocessing module, but I when I would use that, it would actually freeze the program after it was initiated. I will edit my original post to show the code of what I was doing when trying to use multiprocessing - or at least the pseudo code, because the program is very long.</span>
<span class="comment-copy">@Hunter it's freezing because you're calling <code>p.join()</code>, which will make your main process block until the child has exited. Just call <code>p.start()</code> without the call to <code>p.join</code>.</span>
<span class="comment-copy">@jpmc As kalhartt said, asynchronous frameworks like <code>asyncio</code> or <code>tornado</code> are only helpful for I/O-bound workloads. CPU-bound operations still require <code>multiprocessing</code> for parallelism, or a C extension that can safely release the GIL during computations (like <code>numpy</code>, for example).</span>
