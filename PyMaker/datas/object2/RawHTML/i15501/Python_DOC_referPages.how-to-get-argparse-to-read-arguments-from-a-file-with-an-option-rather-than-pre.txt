<div class="post-text" itemprop="text">
<p>I would like to know how to use python's argparse module to read arguments both from the command line and possibly from text files. I know of argparse's <code>fromfile_prefix_chars</code> but that's not exactly what I want. I want the behavior, but I don't want the syntax. I want an interface that looks like this:</p>
<pre><code>$ python myprogram.py --foo 1 -A somefile.txt --bar 2
</code></pre>
<p>When argparse sees -A, it should stop reading from sys.argv or whatever I give it, and call a function I write that will read somefile.text and return a list of arguments. When the file is exhausted it should resume parsing sys.argv or whatever. It's important that the processing of the arguments in the file happen in order (ie: -foo should be processed, then the arguments in the file, then -bar, so that the arguments in the file may override --foo, and --bar might override what's in the file). </p>
<p>Is such a thing possible? Can I write a custom function that pushes new arguments onto argparse's stack, or something to that effect?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can solve this by using a custom <a href="https://docs.python.org/3/library/argparse.html#argparse.Action" rel="noreferrer"><code>argparse.Action</code></a> that opens the file, parses the file contents and then adds the arguments then.</p>
<p>For example this would be a very simple action:</p>
<pre><code>class LoadFromFile (argparse.Action):
    def __call__ (self, parser, namespace, values, option_string = None):
        with values as f:
            parser.parse_args(f.read().split(), namespace)
</code></pre>
<p>Which you can the use like this:</p>
<pre><code>parser = argparse.ArgumentParser()
# other arguments
parser.add_argument('--file', type=open, action=LoadFromFile)
args = parser.parse_args()
</code></pre>
<p>The resulting namespace in <code>args</code> will then also contain any configuration that was also loaded from the file.</p>
<p>If you need a more sophisticated parsing, you can also parse the in-file configuration separately first and then selectively choose which values should be taken over. For example, it might make sense to disallow specifying <em>another</em> file in the config file:</p>
<pre><code>def __call__ (self, parser, namespace, values, option_string=None):
    with values as f:
        contents = f.read()

    data = parser.parse_args(contents.split(), namespace=namespace)
    for k, v in vars(data).items():
        if v and k != option_string.lstrip('-'):
            setattr(namespace, k, v)
</code></pre>
<p>Of course, you could also make the file reading a bit more complicated, for example read from JSON first.</p>
</div>
<div class="post-text" itemprop="text">
<p>You commented that </p>
<blockquote>
<p>I need to be able to write my own function to read that file and return the arguments (it's not in a one-argument-per-line format) â€“ </p>
</blockquote>
<p>There is a provision in the existing prefix-file handler to change how the file is read.  The file is read by a 'private' method, <code>parser._read_args_from_files</code>, but it calls a simple public method that converts a line to strings, default one-argument-per-line action:</p>
<pre><code>def convert_arg_line_to_args(self, arg_line):
    return [arg_line]
</code></pre>
<p>It was written this way so you could easily customize it. 
<a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.convert_arg_line_to_args" rel="nofollow">https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.convert_arg_line_to_args</a></p>
<blockquote>
<p>A useful override of this method is one that treats each space-separated word as an argument:</p>
</blockquote>
<pre><code>def convert_arg_line_to_args(self, arg_line):
    for arg in arg_line.split():
        if not arg.strip():
            continue
        yield arg
</code></pre>
<p>In the <code>test_argparse.py</code> unittesting file there is a test case for this alternative.</p>
<hr/>
<p>But if you still want to trigger this read with an argument option, instead of a prefix character, then the custom Action approach is a good one.</p>
<p>You could though write your own function that processes <code>argv</code> before it is passed to the <code>parser</code>.  It could be modeled on <code>parser._read_args_from_files</code>.</p>
<p>So you could write a function like:</p>
<pre><code>def read_my_file(argv):
    # if there is a '-A' string in argv, replace it, and the following filename
    # with the contents of the file (as strings)
    # you can adapt code from _read_args_from_files
    new_argv = []
    for a in argv:
        ....
        # details left to user
    return new_argv
</code></pre>
<p>Then invoke your parser with:</p>
<pre><code>parser.parse_args(read_my_file(sys.argv[1:]))
</code></pre>
<p>And yes, this could be wrapped in a <code>ArgumentParser</code> subclass.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>Action</code>, when called, gets <code>parser</code> and <code>namespace</code> among its arguments.</p>
<p>So you can put your file through the former to update the latter:</p>
<pre><code>class ArgfileAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        extra_args = &lt;parse_the_file&gt;(values)
        #`namespace' is updated in-place when specified
        parser.parse_args(extra_args,namespace)
</code></pre>
</div>
<span class="comment-copy">In your version, what would trigger the special handling of an argument (instead of a prefix character)?</span>
<span class="comment-copy">@martineau: the "-A" option says "the next argument is a file to be read". I need to be able to write my own function to read that file and return the arguments (it's not in a one-argument-per-line format)</span>
<span class="comment-copy">Looking at the <a href="https://hg.python.org/cpython/file/3.4/Lib/argparse.py#l1769" rel="nofollow noreferrer">source of _parse_known_args</a>, it looks like argparse likes to know all of the arguments up front.  If you have @fromfile_prefix_chars set, then it looks at the arguments and builds a completely new list to parse (_read_args_from_files).  I think your best option is to parse sys.argv ahead of time to get the list of arguments.</span>
<span class="comment-copy">How do you tell the argument parser that you have an argument that should be handled in this way? I'm thinking perhaps you could subclass <code>argparse.ArgumentParser</code>.</span>
<span class="comment-copy">@mgilson: I never said I thought it was unreasonable...just trying to understand what the OP has in mind.</span>
<span class="comment-copy">Ah-ha! The key is realizing that the parser is passed to the custom action, and you can use that parser to process the contents of the file. Thank you.</span>
<span class="comment-copy">But if the parser had a different name in the global environment, it would still be available here.  So any parser could be used here.  There's nothing special about the <code>parser</code> passed as parameter.</span>
<span class="comment-copy">Alas, this fails if any of your parameters are set to Required.</span>
<span class="comment-copy">I believe that OP already knows about this feature as indicated by the statement "I know of argparse's fromfile_prefix_chars but that's not exactly what I want"</span>
