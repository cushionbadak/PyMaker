<div class="post-text" itemprop="text">
<p>I have a string like this:</p>
<pre><code>s = u'something extra BEGIN the unicode text I want with an é END some more extra stuff'
</code></pre>
<p>I want this text:</p>
<pre><code>result = 'the unicode text I want with an é'
</code></pre>
<p>I've tried to use this code:</p>
<pre><code>expr = r'(?&lt;=BEGIN)[\sa-zA-Z]+(?=END)'
result = re.search(expr, s)
result = re.sub(r'(^\s+)|(\s+$)', '', result)  # just to strip out leading/trailing white space
</code></pre>
<p>But as long as the <code>é</code> is in the string <code>s</code>, <code>re.search</code> always returns <code>None</code>.  </p>
<p>Note, I've tried using different combinations of <code>.*</code> instead of <code>[\sa-zA-Z]+</code> without success.</p>
</div>
<div class="post-text" itemprop="text">
<p>The character ranges <code>a-z</code> and <code>A-Z</code> only capture ASCII characters.  You can use <code>.</code> to capture Unicode characters:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = u'something extra BEGIN the unicode text I want with an é END some more extra stuff'
&gt;&gt;&gt; print re.search(r'BEGIN(.+?)END', s).group(1)
 the unicode text I want with an é
&gt;&gt;&gt;
</code></pre>
<p>Note too that I simplified your pattern a bit.  Here is what it does:</p>
<pre><code>BEGIN  # Matches BEGIN
(.+?)  # Captures one or more characters non-greedily
END    # Matches END
</code></pre>
<p>Also, you do not need Regex to remove whitespace from the ends of a string.  Just use <a href="https://docs.python.org/3/library/stdtypes.html#str.strip" rel="nofollow"><code>str.strip</code></a>:</p>
<pre><code>&gt;&gt;&gt; ' a '.strip()
'a'
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">This works for me, but what if <code>BEGIN</code> and <code>END</code> are on different lines.  Sorry I left out that detail!</span>
<span class="comment-copy">You just need to specify the dot-all flag in that case.  You could do: <code>re.search(r'BEGIN(.+?)END', s, re.DOTALL).group(1)</code> or <code>re.search(r'BEGIN(.+?)END', s, re.S).group(1)</code>.  This will have <code>.</code> match newlines.</span>
<span class="comment-copy">ahh, I had been trying to use <code>re.MULTILINE</code> without reading the documentation.  Thanks for this, you've been really helpful.</span>
