<div class="post-text" itemprop="text">
<p>The code is as below: </p>
<pre><code>reduce(lambda x, (y, z): x | (z &lt;&lt; y),
       enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata())),
       0)
</code></pre>
<p>What makes me confused is the first argument of <code>reduce()</code></p>
<pre><code>lambda x, (y, z): x | (z &lt;&lt; y)
</code></pre>
<p>I get the meaning of other two arguments:</p>
<pre><code>enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata())),
       0
</code></pre>
<p>Besides, I know that the lambda expression (the first argument of <code>reduce()</code>) is to turn a sequence of bits （0 or 1） into a integer. It seems we should do one bitwise right shift at one time, but here is <code>y</code>, what's that? </p>
<p>PS: my question is not the lambda expression itself, but how it works with the sequence which </p>
<pre><code>enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata()))
</code></pre>
<p>returns</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><code>y</code> is the index of the item.</li>
<li><code>z</code> is the current item from the iterable.</li>
<li><code>x</code> is the result so far(with initial value of 0).</li>
</ul>
<p><code>x, (y, z)</code> is taking the advantage of tuple argument unpacking(<a href="https://www.python.org/dev/peps/pep-3113/" rel="nofollow">supported in Python 2 only</a>), you can also write it as:</p>
<pre><code>x = 0
for y, ind_item in enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata()):
    x |= (z &lt;&lt; y)
</code></pre>
<p>Tuple argument unpacking in action:</p>
<pre><code>&gt;&gt;&gt; def func(x, (y, z)):
    print x, y, z
...     
&gt;&gt;&gt; func(0, (10, 20))
0 10 20
</code></pre>
<p>Note that this feature has been removed in Python 3 and PEP-3113 recommends doing something like this:</p>
<pre><code>def func(x, y_z):
    y, z = y_z
    print x, y, z
...     
&gt;&gt;&gt; func(0, (10, 20))
0 10 20
</code></pre>
<p>As <code>lambda</code>s don't allow assignment statements, you can use indexing to get the value of <code>y</code> and <code>z</code>:</p>
<pre><code>from functools import reduce
reduce(lambda x, y_z: x | (y_z[1] &lt;&lt; y_z[0]),
       enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata())),
       0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The signature is <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce(function, iterable[, initializer])</code></a>. From the doc:</p>
<blockquote>
<p>Apply <code>function</code> of two arguments cumulatively to the items of <code>sequence</code>, from left to right, so as to reduce the sequence to a single value.</p>
</blockquote>
<p>This translates to:</p>
<ul>
<li>Apply <code>lambda x, (y, z): x | (z &lt;&lt; y)</code></li>
<li>to the items of <code>enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata()))</code></li>
<li>from left to right, so as to reduce the sequence to a single value.</li>
</ul>
<p>Since your <code>lambda</code> is a function "of two arguments" that can be applied to the the items of the <code>enumerate</code>, everything looks fine.</p>
<p><strong>Edit</strong></p>
<p><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> returns a list of tuples:</p>
<pre><code>[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A bit late, </p>
<p>But here is the same code without the use of nested functions and lambdas:</p>
<pre><code>class Img:
    def __init__(self, data):
        self.data = data

    def getdata(self):
        return self.data

def function1(i):
    if i &lt; avg:
        print "function1(%i) == 0"%i
        return 0
    else:
        print "function1(%i) == 1" % i
        return 1

def function2(y,z):
    print "function2(%i,%i) == %i"%(y,z,z &lt;&lt; y)
    return z &lt;&lt; y


avg = 0
im = Img(list(range(-5,5)))

MAP = map(function1,im.getdata())
print "\nMAP of function1 with im.getdata() == %s"%MAP
ENUM = list(enumerate(MAP))
print "\nENUM of MAP == %s\n"%ENUM
a = 0
for y, z in ENUM:
    print "a == %i"%a
    value = function2(y,z)
    print "a += %i"%(value)
    a += value

print "\nResult is\na == %i"%a
</code></pre>
<p>Output:</p>
<pre><code>function1(-5) == 0
function1(-4) == 0
function1(-3) == 0
function1(-2) == 0
function1(-1) == 0
function1(0) == 1
function1(1) == 1
function1(2) == 1
function1(3) == 1
function1(4) == 1

MAP of function1 with im.getdata() == [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]

ENUM of MAP == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1)]

a == 0
function2(0,0) == 0
a += 0
a == 0
function2(1,0) == 0
a += 0
a == 0
function2(2,0) == 0
a += 0
a == 0
function2(3,0) == 0
a += 0
a == 0
function2(4,0) == 0
a += 0
a == 0
function2(5,1) == 32
a += 32
a == 32
function2(6,1) == 64
a += 64
a == 96
function2(7,1) == 128
a += 128
a == 224
function2(8,1) == 256
a += 256
a == 480
function2(9,1) == 512
a += 512

Result is
a == 992
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The entire statement is just turning a data image into a series of bits and then packing those bits into a single int.</p>
<p>A better, and more readable way of doing this might be to do something like.</p>
<pre><code>import array
import numpy

pixel_data = numpy.array(data)
truth_values = pixel_data &gt;= avg
byte_values = numpy.packbits(numpy.array(truth_values, dtype=int))
bit_string = array.array('B', byte_values).tobytes()
bit_int = int.from_bytes(bit_string, byteorder='big')
</code></pre>
</div>
<span class="comment-copy">It is saying <code>x XOR (z left-shifted y times)</code></span>
<span class="comment-copy">I know that, but how does it works with reduce()? @Cyber</span>
<span class="comment-copy">Could you clarify what exactly your confusion is? It might be easier if you split it up into more steps, so you could see exactly what each part is doing.</span>
<span class="comment-copy">What do you mean <i>how it works with <code>reduce</code></i>?</span>
<span class="comment-copy">That hasn't really clarified the question. Do you know what <code>reduce</code> does? What its arguments are? Please be precise about what you don't understand (e.g. by explaining clearly every part of it you <i>do</i> understand).</span>
<span class="comment-copy">Is there more info about tuple argument unpacking ?</span>
<span class="comment-copy">@simon_xia <a href="https://www.python.org/dev/peps/pep-3113/" rel="nofollow noreferrer">python.org/dev/peps/pep-3113</a></span>
<span class="comment-copy">yep, the lambda is a function "of two arguments", but how to initialize   the second arguments (y, z) ?</span>
<span class="comment-copy">@simon_xia <code>enumerate</code> produces a series of two-tuples <code>(index, element)</code>, which are then unpacked to the names <code>(y, z)</code> in the <code>lambda</code>.</span>
<span class="comment-copy"><code>im.getdata()</code> in the question is <i>probably</i> refering to PIL -- <a href="http://effbot.org/imagingbook/image.htm" rel="nofollow noreferrer">effbot.org/imagingbook/image.htm</a></span>
