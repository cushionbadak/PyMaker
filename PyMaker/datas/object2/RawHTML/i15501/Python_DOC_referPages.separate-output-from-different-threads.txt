<div class="post-text" itemprop="text">
<p>All my code is writing log via <em>say()</em> to <em>sys.stderr</em> and error redirect. In a multithreaded server I want each thread to write to a separate log file. Can I accomplish this without rewriting all code used by threads? </p>
<pre><code>from threading import Thread
from time import sleep

def say(*args):
    print(*args, file=sys.stderr)

def worker(num):
    for _ in range(5):
        say("worker", num, "working")
        sleep(.1)

for num in range(4):
    Thread(target=worker, args=(num,)).start()
</code></pre>
<p>Output is mixed in, the goal is to redirect it to a differnt log file for each thread:</p>
<pre><code>worker 0 working
worker 1 working
worker 2 working
worker 3 working
worker 0 working
worker 1 working
worker 3 working
worker 2 working
. . .
</code></pre>
<p>My understanding is that if I try to redirect stderr to a file inside thread the redirection will be shared by all threads:</p>
<pre><code>def worker(num):
    sys.stderr = open('worker{}.log'.format(num), 'w')
    for _ in range(5):
        say("worker", num, "working")
</code></pre>
<p>Result as expected:</p>
<pre><code>$ cat worker3.log
worker 1 working
worker 1 working
worker 1 working
worker 3 working
worker 3 working
worker 3 working
worker 3 working
worker 3 working
</code></pre>
<hr/>
<h1>Updates</h1>
<p>@Amber, I already have a unique identifier and can use it as a thread name:</p>
<pre><code>def say(*args, end='\n'):
    print(currentThread().getName(), *args, file=sys.stderr, end=end)
    sys.stderr.flush()

t_worker = Thread(name=str(num), target=worker, args=(num,))
</code></pre>
<p>I cannot dynamically choose logfile for each thread because <em>say()</em> is global -- would need to either put a semaphore on this global log file storage, or pass a logging object to every single function that logs progress.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use thread local storage (via the <code>threading.local</code> class) to store a separate file object for each thread. The <code>say</code> function could then look up the right file:</p>
<pre><code>local = threading.local()

def say(*args):
    if not hasattr(local, "logfile"):
        local.logfile = open("logfile{}".format(threading.get_ident()), "a")

    print(*args, file=local.logfile)
</code></pre>
<p>I'm using <code>threading.get_ident</code> to get a hopefully unique value to generate a log file name. If there's a more logical way to name the files in your program, I'd suggest you use it instead. You might even want to separate out the creation of the file from the <code>say</code> function. For instance, you could make it part of the thread's startup code:</p>
<pre><code>local = threading.local()

def say(*args):
    print(*args, filename=local.logfile)

def worker1():
    local.logfile = open("logfile_worker1", "a")

    # do stuff here, including calling `say()` as necessary
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could call <a href="https://docs.python.org/3/library/threading.html#threading.get_ident" rel="nofollow"><code>threading.get_ident()</code></a> in your <code>say()</code> function to decide where to write the line. It's not perfect (since thread ID numbers are allowed to be reused after a thread ends and another is created), but if your threads are long-running then it might work for your purposes.</p>
</div>
<span class="comment-copy">@Amber, I already have a unique identified and can use it as a thread name:</span>
<span class="comment-copy">muchas gracias , se√±or</span>
