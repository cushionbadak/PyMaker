<div class="post-text" itemprop="text">
<p>I'm trying to add together strings where each letter has been converted to ASCII and then added together accordingly. So for example, adding together the strings <code>"goodbye"</code> <code>"hello"</code> I'd like to convert each letter to ascii then add them together like so:</p>
<pre><code>103 + 104 (g + h) 
111 + 101 (o + e)
111 + 108 (o + l)
100 + 108 (d + l)
98 + 111  (b + o)
121 + 104 (y + h)
101 + 101 (e + e) 
</code></pre>
<p>In this instance, <code>"goodbye"</code> must be interchangeable, i.e. user inputted. This is the code I've generated so far:</p>
<pre><code>input1 = input("Enter word: ")
input2 = "goodbye"
l = len(upnumber)
count = 0

for i in (input1):
     x = (ord(i))
     while count &lt;= l:
         for j in (input2):
              y = (ord(j))
              total = (x + y)
              count = count + 1
              print (total)
</code></pre>
<p>This code doesn't work. It just seems to add the first character of <code>input1</code> to every character in <code>input2</code>, an innumerate amount of times.</p>
<p>The count is in there as I'd like the loop to stop after each character in <code>input1</code> has been added to the loop of <code>input2</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You are looping over all of <code>input2</code> <em>for each character in <code>input1</code></em>, because you nested the loops.</p>
<p>Use the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code> function</a> instead to pair up letters:</p>
<pre><code>input1 = input("Enter word: ")
input2 = "goodbye"
# make input1 at least as long as input2
while len(input1) &lt;= len(input2):
    input1 += input1
for x, y in zip(input1, input2):
    total = ord(x) + ord(y)
    print(total)
</code></pre>
<p>where <code>zip()</code> will stop iterating once the shortest of the two strings is done. Since <code>input1</code> has been extended to repeat until it is at least as long as <code>input2</code>, that means you end up processing all characters of <code>input2</code>, and no more, unless <code>input1</code> was longer to start with.</p>
<p>Instead of manually repeating <code>input2</code>, you can also use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle()</code></a> to cycle through all characters in <code>input1</code> indefinitely:</p>
<pre><code>from itertools import cycle

input1 = input("Enter word: ")
input2 = "goodbye"
for x, y in zip(cycle(input1), input2):
    total = ord(x) + ord(y)
    print(total)
</code></pre>
<p>Demo of the latter approach, with some extra formatting to illustrate what is going on:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; input1 = 'hello'
&gt;&gt;&gt; input2 = "goodbye"
&gt;&gt;&gt; for x, y in zip(cycle(input1), input2):
...     total = ord(x) + ord(y)
...     print('{!r} + {!r} = {:3d} + {:3d} = {:3d}'.format(x, y, ord(x), ord(y), total))
... 
'h' + 'g' = 104 + 103 = 207
'e' + 'o' = 101 + 111 = 212
'l' + 'o' = 108 + 111 = 219
'l' + 'd' = 108 + 100 = 208
'o' + 'b' = 111 +  98 = 209
'h' + 'y' = 104 + 121 = 225
'e' + 'e' = 101 + 101 = 202
</code></pre>
</div>
<span class="comment-copy">Your code appears to repeat <code>input2</code>, but your sample appears to repeat <code>input1</code> (the user input) instead. Should the <i>user input</i> or the hardcoded key (<code>goodbye</code>) be repeated here?</span>
<span class="comment-copy">That's my error there apologies, your answer below fits perfectly, thanks a lot!</span>
<span class="comment-copy">Many thanks for your input, do I have your permission to use this in my current university study please?</span>
<span class="comment-copy">@ajh: the whole post is licensed as <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="nofollow noreferrer">Creative Commons</a>; it means you already have my permission but you do need to abide by the attribution requirements.</span>
