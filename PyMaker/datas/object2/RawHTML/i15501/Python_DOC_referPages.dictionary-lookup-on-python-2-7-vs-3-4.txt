<div class="post-text" itemprop="text">
<p>This came up in a nitpick discussion about the prefered style for iterating over dictionary keys if you need to apply some test to the value. I was comparing the performance of <code>[k for k in d if d[k] == 1]</code> against <code>[k for k, v in d.items() if v == 1]</code>.</p>
<p>Looks like dictionary lookups are more expensive in Python 3.4:</p>
<pre><code>$ python -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k in d if d[k] == 1]'
1000000 loops, best of 3: 2.17 usec per loop

$ python -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k, v in d.items() if v == 1]'
1000000 loops, best of 3: 3.13 usec per loop

$ python3.4 -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k in d if d[k] == 1]'
1000000 loops, best of 3: 3.25 usec per loop

$ python3.4 -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k, v in d.items() if v == 1]'
1000000 loops, best of 3: 3.05 usec per loop
</code></pre>
<p>Are lookups more expensive in Python 3.4 compared to 2.7 and can you explain why?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not that lookups are more expensive<sup>1</sup> in Python 3.4 than 2.7, but that <code>dict.items()</code> is cheaper. That's because <code>dict.items()</code> is a rather different beast in the two versions of the language:</p>
<pre><code>$ python2.7
Python 2.7.9 (default, Dec 11 2014, 03:19:35) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; type({}.items())
&lt;type 'list'&gt;
&gt;&gt;&gt; 
</code></pre>
<pre><code>$ python3.4
Python 3.4.2 (default, Oct  8 2014, 08:07:42) 
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; type({}.items())
&lt;class 'dict_items'&gt;
&gt;&gt;&gt; 
</code></pre>
<p>In Python 2, <code>dict.items()</code> constructs and returns a list, whereas in Python 3 it returns a <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow">dictionary view</a>, and it turns out that iterating over this dynamic view into the dictionary is faster than constructing a list and then iterating over that.</p>
<p>Although <code>dict.items()</code> doesn't return a dictionary view in 2.7, it <em>is</em> possible to get one with <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewitems" rel="nofollow"><code>dict.viewitems()</code></a>, with similar performance benefits. Repeating your test, this time with <code>viewitems()</code> included, I get:</p>
<pre><code>$ python2.7 -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k in d if d[k] == 1]'
1000000 loops, best of 3: 3.38 usec per loop
</code></pre>
<pre><code>$ python2.7 -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k, v in d.items() if v == 1]'
1000000 loops, best of 3: 4.33 usec per loop
</code></pre>
<pre><code>$ python2.7 -m timeit -n 1000000 \
  -s 'd={k:v for v, k in enumerate("abcdefghijhklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")}' \
  '[k for k, v in d.viewitems() if v == 1]'
1000000 loops, best of 3: 3.27 usec per loop
</code></pre>
<p>As regards the discussion that prompted your investigation, I'd say that the <code>d.items()</code> or <code>d.viewitems()</code> approach is more explicit, and therefore more pythonic, but that's really more an aesthetic choice than anything else.</p>
<hr/>
<p><sup>1</sup> Except inasmuch as Python 3.x is, as a general rule, slower than 2.x, but that's the price of progress ...</p>
</div>
<span class="comment-copy">I can't reproduce similar results on my machine. If anything, the Python 3 <code>.items()</code> should be slightly faster as it doesn't build an intermediate list.</span>
<span class="comment-copy">Note that the types are significantly different: for Python 2 you've got a dictionary mapping bytestrings to fixed-width ints, while for Python 3 you're mapping Unicode strings to arbitrary-precision ints.  It could be that hashing a Unicode string is slower than hashing a bytestring, or that comparisons between long integers are slower than comparisons between fixed-width integers.  I couldn't say for sure that that's where the timing difference comes from, though.</span>
<span class="comment-copy">@SimeonVisser honest question: you can't reproduce because the test is flawed, because you don't have both versions or because you got different results? :-)</span>
<span class="comment-copy">Different numbers that don't suggest 3 is slower than 2 here.</span>
