<div class="post-text" itemprop="text">
<p>I am trying to get broadcast ip address coding in Java and Python for practice. Here is my code in java which gives me correct output:</p>
<pre><code>public IPv4Address getBroadcastAddress() throws IllegalArgumentException {
    long bits = 0;
    bits = this.address.decimalIP() ^ (~(0xffffffff ^ (1L &lt;&lt; 32 - getMaskLength()) - 1));
    IPv4Address broadcast = new IPv4Address(bits);

    return broadcast; 
}
</code></pre>
<p>Here <code>decimalIP</code> is the number representing IP address, <code>getMaskLength</code> - number representing its mask. Here I got expected broadcast address.
By in python using the same logic I got unexpected results:</p>
<pre><code>def broadcastaddress(self):
    return IPv4Address(self.address.decimalip ^ (~(0xffffffff ^ (1 &lt;&lt; 32 - self.mask) - 1)))
</code></pre>
<p>Here all components represent the same entries as in java. After debugging I got that number <code>(~(0xffffffff ^ (1 &lt;&lt; 32 - self.mask) - 1))</code> is negative. In documents operator <code>~</code> gives inversion in bits but I don't understand why this number is negative in Python and not in Java?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python integers are not bounded and are not signed, so <code>~</code> creates a negative number:</p>
<pre><code>&gt;&gt;&gt; hex(~(0xffffffff ^ (1 &lt;&lt; 32 - 24) - 1))
'-0xffffff01'
&gt;&gt;&gt; ~(0xffffffff ^ (1 &lt;&lt; 32 - 24) - 1)
-4294967041
</code></pre>
<p>However, <code>~</code> in Java would give you the <em>two's complement</em>, while the operation on the subnet mask requires a <em>one's complement</em>, which can be achieved by using <code>XOR</code> on the netmask. Since that'd <em>undo</em> the <em>other</em> <code>XOR</code> operation you already applied, you don't need to use the 1's complement here <strong>at all</strong>:</p>
<pre><code>return IPv4Address(self.address.decimalip ^ ((1 &lt;&lt; 32 - self.mask) - 1))
</code></pre>
<p>I suspect that you could just use <a href="https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network.broadcast_address" rel="nofollow"><code>IPv4Network.broadcast_address</code></a> here:</p>
<pre><code>network = IPv4Network('{}/{}'.format(self.address.decimalip, self.mask)
return network.broadcast_address`
</code></pre>
</div>
<span class="comment-copy">I would start off by simplifying things a lot - get rid of all the calls etc and hard-code the values into short but complete programs in each of Java and Python. Then make each step a separate statement, so you can see <i>exactly</i> which operation has different behaviour.</span>
<span class="comment-copy">In java you can simplify (~(0xffffffff ^ (1L &lt;&lt; 32 - getMaskLength()) - 1)) =&gt; (~(~(1L &lt;&lt; 32 - getMaskLength()) - 1))</span>
<span class="comment-copy">@sol4me: which returns the same thing as <code>(1L &lt;&lt; 32 - getMaskLength()) - 1)</code>. And one should use one's complement, not two's complement.</span>
<span class="comment-copy">@MartijnPieters you are right. Thanks</span>
<span class="comment-copy">I have a small doubt in your answer, As far as I suppose <code>~</code> is same in both languages (i.e. both give a negative number). The problem is only with <code>^</code> the reason being stated in your answer. Do correct me if I am wrong. Ty.</span>
<span class="comment-copy">@BhargavRao: I'm not entirely sure what you are asking there. I sidestepped the issue mostly because the calculation of the broadcast mask is a lot simpler.</span>
<span class="comment-copy">I'm not asking about the goal which is to calculate the broadcast mask. The OP asked the difference between <code>~</code> in Java and Python, With regard to his question and his line of code, what I think is that the problem lies in <code>0xffffffff</code> and not <code>~</code>. So I just asked you to clarify on this point.</span>
<span class="comment-copy">@BhargavRao: right, I don't think there is a difference other than that the Java type used for <code>getMaskLength</code> the must've been unsigned.</span>
<span class="comment-copy">@BhargavRao: but for a <code>/24</code> network, the network mask is <code>0xffffff00</code>, so <code>0xffffffff ^ 0xff</code> is the correct procedure to produce that. The broadcast mask is the one's complement of that, so <code>0x000000ff</code> again. Much easier to just produce that with <code>(1 &lt;&lt; 32 - self.mask) - 1</code> than complementing twice.</span>
