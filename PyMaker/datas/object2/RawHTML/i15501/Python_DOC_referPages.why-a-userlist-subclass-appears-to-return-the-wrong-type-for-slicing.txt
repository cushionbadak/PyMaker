<div class="post-text" itemprop="text">
<p>Let me start by saying I get why subclassing <code>list</code> doesn't work as you might expect (because <code>list</code> is a primitive built-in type and there are issues of performance, etc.). AFAIK collections.UserList is supposed to avoid all these problems and make subclassing UserList work completely as you might expect. For example,</p>
<pre><code>class DumbList(list):
  pass
d1 = DumbList([1,2,3])
d2 = DumbList([4,5])
type(d1 + d2)
</code></pre>
<p>returns <code>&lt;class 'list'&gt;</code>, but</p>
<pre><code>from collections import UserList
class DumbList(UserList):
  pass
d1 = DumbList([1,2,3])
d2 = DumbList([4,5])
type(d1 + d2)
</code></pre>
<p>returns <code>&lt;class '__main__.DumbList'&gt;</code> as expected. However, slicing appears to return the wrong type, even when using <code>UserList</code> instead of <code>list</code>:</p>
<pre><code>class DumbList(UserList):
  pass
d = DumbList([1,2,3])
type(d[:2])
</code></pre>
<p>returns <code>&lt;class 'list'&gt;</code>, not <code>&lt;class '__main__.DumbList'&gt;</code> as expected.</p>
<p>Two questions:</p>
<ul>
<li>Why is this?</li>
<li>What should I do to make slicing return the correct type? The simplest thing I can think of is something like:</li>
</ul>
<p>Â </p>
<pre><code>class DumbList(UserList):
  def __getitem__(self, item):
    result = UserList.__getitem__(self, item)
    try:
      return self.__class__(result)
    except TypeError:
      return result
</code></pre>
<p>...but it seems like this kind of boiler-plate code should be unnecessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, plain slicing (without a stride) would be handled by the <a href="https://docs.python.org/2/reference/datamodel.html#object.__getslice__" rel="nofollow"><code>__getslice__</code> method</a>. The <code>UserList</code> implementation predates the addition of extended slices (with stride) to the language and never added support for them, see <a href="http://bugs.python.org/issue491398" rel="nofollow">issue 491398</a>.</p>
<p>The Python 3 implementation simply took the Python 2 version, moved into <code>collections</code> and removed <code>__getslice__</code> and <code>__setslice__</code> as those are no longer supported in Python 3.</p>
<p>As such, the <code>__getitem__</code> implementation is still simply:</p>
<pre><code>def __getitem__(self, i): return self.data[i]
</code></pre>
<p>assuming that slicing would be handled elsewhere.</p>
<p>In Python 3, all slicing is handled by passing in the <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow"><code>slice()</code> built-in type</a> to <code>__getitem__</code>; simply test for that type and wrap the result in a <code>type(self)</code> call:</p>
<pre><code>def __getitem__(self, i):
    res = self.data[i]
    return type(self)(res) if isinstance(i, slice) else res
</code></pre>
</div>
<span class="comment-copy">Related: <a href="http://bugs.python.org/issue491398" rel="nofollow noreferrer">bugs.python.org/issue491398</a></span>
<span class="comment-copy">Well done! You've just discovered why I always <i>discourage</i> from inheriting from built-ins! It just <i>looks</i> easier, but it's a nice way to introduce bugs in your code. Also note that, to create a proper subclass, not only you have to reimplement <i>every</i> method of the original class, but you even have to implement the <code>__r*__</code> variants to make it work properly in every situation! In other words using delegation is <i>always</i> less work. Use inheritanche only if you really care to have a subclass and not simply something that acts like a class (e.g. to "fool" <code>isinstance</code> checks)</span>
<span class="comment-copy">BTW I'm using Python 3.4.2 for this.</span>
<span class="comment-copy">So... it's basically a bug? =)  I do like your <code>type(self)(res)</code> better than my <code>self.__class__(res)</code>.</span>
<span class="comment-copy">@KeenanPepper: well, you'll have to debate that with the Python devs. :-)</span>
