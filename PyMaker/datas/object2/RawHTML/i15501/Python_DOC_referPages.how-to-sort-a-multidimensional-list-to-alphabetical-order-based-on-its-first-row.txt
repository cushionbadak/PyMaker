<div class="post-text" itemprop="text">
<p>How do I sort a multidimensional list to alphabetical order based on its first row of data without using numpy nor other modules</p>
<p>For example I have a list:</p>
<pre><code>[['M', 'A', 'R', 'K']
[1,    3,   5,    4]
[2,    6,   7,    8]]
</code></pre>
<p>I want it to be like:</p>
<pre><code>[['A', 'K', 'M', 'R']
[3,    4,   1,    5]
[6,    8,   2,    7]]
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think there should be a better way; anyway, this would do the trick:</p>
<pre><code>&gt;&gt;&gt; l = [['M', 'A', 'R', 'K'], [1, 3, 5, 4], [2, 6, 7, 8]]
&gt;&gt;&gt; sorted_l = map(list, zip(*sorted(zip(*l))))
&gt;&gt;&gt; print(list(sorted_l))
[['A', 'K', 'M', 'R'], [3, 4, 1, 5], [6, 8, 2, 7]]
</code></pre>
<p>Edit:</p>
<ol>
<li><p><code>zip(*l)</code> gives you an iterator (in Python 3), if you do <code>[i for i in zip(*l)]</code>, you'll find it looks like <code>[('M', 1, 2), ('A', 3, 6), ('R', 5, 7), ('K', 4, 8)]</code></p></li>
<li><p><code>sorted(zip(*l))</code> sorts the list above (becomes <code>[('A', 3, 6), ('K', 4, 8), ('M', 1, 2), ('R', 5, 7)]</code> under the hood), I didn't specify the key, so it compares the elements directly</p></li>
<li><p>then, you zip again, and you get an iterator of what you wants (elements in <code>l</code> are <code>('A', 'K', 'M', 'R'), (3, 4, 1, 5), (6, 8, 2, 7)</code> if you print them out); however, you have to do <code>map()</code> so you can get <code>&lt;class 'list'&gt;</code> instead of <code>&lt;class 'tuple'&gt;</code></p></li>
<li><p>finally, <code>map()</code> also returns an iterator in Python3, to get a list, you simply use <code>list([iterable])</code> to construct the final list.</p></li>
</ol>
<p>Documentations: <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip</a>, <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow">sorted</a>, and <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">map</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Once you know the new "order" (or mapping) of the sorted indexes, you should be able to use <a href="https://docs.python.org/2/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">operator.itemgetter</a> to basically walk all the rows and get the items in the order that you just found.</p>
<p>In your case, you have <code>['M', 'A', 'R', 'K']</code>. In order to get those letters sorted, you should first get index <code>1</code>, then index <code>3</code>, then index <code>0</code> and finally index <code>2</code>: <code>(A K M R)</code>. Once you find that mapping, you can just call <code>itemgetter</code> to get you the items on each row in that order.</p>
<pre><code>import operator
a=[
    ['M', 'A', 'R', 'K'],
    [1,    3,   5,    4],
    [2,    6,   7,    8],
]
sorted_first = sorted(a[0])
sorted_indexes = [a[0].index(letter) for letter in sorted_first]
print "Mapping: %s" % sorted_indexes
new_sorted = [operator.itemgetter(* sorted_indexes)(line) for line in a]
print new_sorted
</code></pre>
<p>Which ouputs:</p>
<pre><code>Mapping: [1, 3, 0, 2]
[('A', 'K', 'M', 'R'),
 (3, 4, 1, 5),
 (6, 8, 2, 7)]
</code></pre>
<h2>EDIT:</h2>
<p><a href="https://stackoverflow.com/users/2726734/rpattiso">rpatisso</a> made me see (in comments to this answer) that there's more effective way to calculate the <code>sorted_indexes</code> variable than using <a href="http://www.tutorialspoint.com/python/list_index.htm" rel="nofollow noreferrer">list.index</a> which is <em>O(n<sup>2</sup>)</em>:</p>
<pre><code>sorted_indexes = sorted(range(len(a[0])), key=lambda i: a[0][i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try it with numpy.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([['M', 'A', 'R', 'K'],
... [1,    3,   5,    4],
... [2,    6,   7,    8]], dtype=object)
&gt;&gt;&gt; a[:,np.argsort(a[0])]
array([['A', 'K', 'M', 'R'],
       [3, 4, 1, 5],
       [6, 8, 2, 7]], dtype=object)
</code></pre>
<p>Without numpy:</p>
<pre><code>&gt;&gt;&gt; map(list,zip(*sorted(zip(*a))))
[['A', 'K', 'M', 'R'], [3, 4, 1, 5], [6, 8, 2, 7]]
</code></pre>
</div>
<span class="comment-copy">have you tried anything? Include what you tried</span>
<span class="comment-copy">I have tried using numy like the example below, but I haven't found a solution without using one.</span>
<span class="comment-copy">That should be a part of your question like you want without using "nummy"? That wil give the clear idea what you want?Thanks</span>
<span class="comment-copy">Thanks! Could you explain how this code works?</span>
<span class="comment-copy">searching for the location in the list of every element for <code>sorted_indexes</code> is not very efficient O(n^2).</span>
<span class="comment-copy">no, but it's a 4 items list...</span>
<span class="comment-copy">The 4 item list is only an example.</span>
<span class="comment-copy">How do you know? and, according to you, what would be a more efficient way then?</span>
<span class="comment-copy">The OP said "For example" and <code>sorted_indices = sorted(range(len(a[0])), key=lambda i: a[0][i])</code> would be O(nlog n), like the accepted answer.</span>
<span class="comment-copy">Is there a way to do it without using numpy?</span>
