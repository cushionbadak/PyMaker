<div class="post-text" itemprop="text">
<p>I have a class with a dict attribute, like this :</p>
<pre><code>class MyClass:

    def __init__(self):
        self.mydict = {'var1': 'value1', 'var2': 'value2', ...}
</code></pre>
<p>When I want to get the values, I have to do this :</p>
<pre><code>cls = MyClass()
print(cls.mydict['var1'])
print(cls.mydict['var2'])
</code></pre>
<p>What is the solution to get the values directly in attributes please :</p>
<pre><code>cls = MyClass()
print(cls.var1)
print(cls.var2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could add an additional function to the class that will be able to parse the dict and insert the relevant attributes:</p>
<pre><code>def assign_variables( self ):
  for key, val in self.mydict.items():
    setattr( self, key, val )
</code></pre>
<p>I'm using the built-in <a href="https://docs.python.org/2/library/functions.html#setattr" rel="nofollow"><code>setattr()</code> function</a> here to set attributes with dynamic names/values:</p>
<blockquote>
<p>This is the counterpart of <code>getattr()</code>. The arguments are an object, a string and an arbitrary value. The string may name an existing attribute or a new attribute. The function assigns the value to the attribute, provided the object allows it.<br/>
<strong>For example, <code>setattr(x, 'foobar', 123)</code> is equivalent to <code>x.foobar = 123</code></strong>.</p>
</blockquote>
<p>You can call this function inside your constructor after the <code>mydict</code> variable is defined or even just place the loop in the constructor. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow"><code>setattr</code></a>, you can set attribute dynamically:</p>
<pre><code>&gt;&gt;&gt; class MyClass:
...     def __init__(self):
...         mydict = {'var1': 'value1', 'var2': 'value2'}
...         for key, value in mydict.items():
...             setattr(self, key, value)
...
&gt;&gt;&gt; instance = MyClass()
&gt;&gt;&gt; instance.var1
'value1'
&gt;&gt;&gt; instance.var2
'value2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another solution is to implement <code>__getattr__</code>:</p>
<pre><code>class MyClass(object):
    def __init__(self):
        self.mydict = {'var1': 'value1', 'var2': 'value2', ...}

    def __getattr__(self, name):
        try:
            return self.mydict[name]
        except KeyError:
            raise AttributeError("object %s has no attribute '%s'" % (self, name))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can directly update the <code>__dict__</code> attribute of your object I believe:</p>
<pre><code>class MyClass:

    def __init__(self):
        self.mydict = {'var1': 'value1', 'var2': 'value2', ...}
        self.__dict__.update(self.mydict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way would be to override <code>__getattr__</code> and <code>__setattr__</code> together, which avoids having two object references to the same attribute in the class instance object (one O.R. to <code>value1</code> inside <code>myobj.mydict['var1']</code>, and another O.R. to <code>value1</code> in <code>myobj.__dict__['var1']</code>):</p>
<pre><code>class MyClass():
    def __init__(self):
        self.__dict__['_mydict'] = {'var1': 'value1', 'var2': 'value2'}
    #Note: using the @property (descriptor) is optional. I think it makes 
    #things more convenient.
    @property
    def mydict(self):
        return self._mydict
    #NOTE: __getattr__ won't get called if att is found in self.__dict__ first! 
    def __getattr__(self,att):
        if att in self.mydict:       # or without using @property: if att in self._mydict:
            return self.mydict[att]  #                                  return self._mydict[att]
        else:
            raise AttributeError("'{n}' object has no attribute '{a}'".format(n = type(self).__name__, a = att))
    def __setattr__(self,att,val):
        super().__setattr__(att, val)
        if att in self.mydict:
            self.mydict[att] = val   # or without using @property: self._mydict[att] = val
            self.__delattr__(att)    # remove duplicate copy of object reference to att
</code></pre>
<p>Note that doing it this way means you cannot add more key,value pairs to <code>mydict</code> unless you call the property directly, e.g.:</p>
<pre><code>myobj = MyClass()
myobj.x = 1
myobj.mydict #note that result does not contain an entry for 'x'
myobj.mydict['x'] = 2
myobj.mydict #now it does
</code></pre>
<p>Also note that <em>getting</em> and <em>deleting</em> the <code>mydict</code> members will be overridden by any existing attribute of the same name (not only that, but you can't delete <code>mydict</code> members <em>at all</em> unless you <strong>also</strong> override <code>__delattr__</code> to enable this behavior): </p>
<pre><code>#continuing the above code session
assert myobj.x == 1 #myobj.x is coming from self.x, not from self._mydict['x']
myobj.var1 = 'a new value'
myobj.var1 #results in 'a new value' as expected, but where is it coming from? 
assert myobj.mydict['var1'] == 'a new value' #Ah: it's coming from self._mydict as expected
assert myobj.__dict__['var1'] #ERROR, as expected
del myobj.x
assert myobj.x == 2 #now myobj.x is coming from self._mydict['x'], self.x having been deleted
del myobj.var1 #raises AttributeError; attributes in mydict can't be deleted (unless you also override __delattr__
</code></pre>
<p>If you want to change this behavior, you have to override <code>__getattribute__</code> (EDIT: which, as  bruno desthuilliers notes below, is usually not a good idea).</p>
</div>
<span class="comment-copy">In this case you now have two object references for each member of <code>mydict</code> stored in the class object instance. Seems like it would be better to only have one. This method could be changed in a very minor way to avoid this (just avoid <code>self.mydict</code> altogether by passing <code>mydict</code> to <code>assign_variables</code>).</span>
<span class="comment-copy">@RickTeachey - correct. One would then have to ask why the dict needs to exist as an attribute if it's pre-defined and not simply assign the class attributes as-is without this conversion code. But then we'd be getting into the <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>.</span>
<span class="comment-copy">I was assuming it is pre-defined as a simplification of the problem presentation. Can't think of a reason you'd actually want to do it this way in practice.</span>
<span class="comment-copy">Very interesting, thank you for this tip.</span>
<span class="comment-copy">Raising a new error within the <code>except</code> statement like this seems to mess up the traceback - there are two traces, which is pretty confusing. Isn't there a better way?</span>
<span class="comment-copy">@RickTeachey: not sure what python shell or python implementation you're using, but this code works as it should on all CPython versions I can remember (which means since 1.5.something).</span>
<span class="comment-copy">It works fine, but it produces the message <code>During handling of the above exception, another exception occurred:</code>. Might be my inexperience, but it doesn't seem very clean, and just doesn't seem like a very good way of doing things. <code>if name in self.mydict: return self.mydict[name]</code>, <code>else: raise AttributeError()</code> seems better. Or even: <code>try:</code> (etc etc), <code>except KeyError: pass</code>, <code>raise AttributeError()</code>.</span>
<span class="comment-copy">Must be either a Python 3.x thing or your shell. And catching an exception to raise another one (from the except clause) is a very common idiom.</span>
<span class="comment-copy"><i>Warning</i>: this solution totally bypasses <code>__setattr__()</code> and all descriptors (properties or else) and can break quit-e a few things.</span>
<span class="comment-copy">Is it not the case that object's <code>"__setattr__()"</code> basically assigns directly to <code>__dict__</code> anyway? (Genuine question, not being contrary). In this example the OP isn't inheriting anything so would this be any less safe than using <code>__setattr__()</code>?</span>
<span class="comment-copy"><code>object.__setattr__()</code> takes care of descriptors and slots - assigning to <code>__dict__</code> is only done if there's no binding descriptor by the same name AND if the class uses a <code>__dict__</code> (=&gt; doesn't use slots). Also you can have a customised <code>__setattr__</code> somewhere in the class hierarchy.  So yes, in this case (well, for what we can see of the code, that is)  you can say it's "safe" - until someone tries to add descriptors etc... To make a long story short: only use this solution if your class is of the brainless data-bag kind (iow a dict with dotted syntax).</span>
<span class="comment-copy">As others have noted: tons of pitfalls for this method, and there's really no reason to use it when you can just as easily use <code>for k, v in self.mydict.items(): self.__setattr__(k,v)</code>.</span>
<span class="comment-copy">Your implementation of <code>__setattr__</code> does not respect the descriptor protocol. As a general rule, overridding <code>__setattr__</code> and <code>__getattribute__</code> is seldom a good idea - it can be tricky and can lead to poor performances.</span>
<span class="comment-copy">First of all: I <i>didn't</i> override <code>__getattribute__</code>, but <code>__getattr__</code>. I only said you'd have to do that in order to look inside <code>mydict</code> first. If that's the primary reason for the downvote, I submit it's unwarranted. Second: How does it not respect the descriptor protocol? The get method is called using <code>[]</code>, and something is done with its return. That's what descriptors are for, is it not? If I'm wrong please point me somewhere so I can learn about what you mean. In any case, the descriptor is incidental, making things more convenient; it's still a useful solution to the OP's problem.</span>
<span class="comment-copy">In light of my inexperience, and trust in your judgment as an obviously much more experienced person, I have edited my answer to make it clear the descriptor is optional.</span>
<span class="comment-copy">I'm not talking about <code>__getattr__</code> - which is optional and only invoked (if defined) as a last resort, but about <code>__setattr__</code> which (together with <code>__getattribute__</code>) implement the attribute resolution rules. And I think you don't really get the point about descriptors - it's not about adding a <code>mydict</code> property, it's about looking the class and mro for binding descriptors (descriptors that implement <code>__set__</code>) and invoking them <i>before</i> falling back to instance storage.</span>
<span class="comment-copy">I thinks this is a good example of why overridding <code>__setattr__</code> is usually not a good idea - unless you have a really compelling reason to so, that is, and then you'd better do it right (which is still not the case in your last edit - if you have a binding descriptor by the same name as a key in <code>mydict</code>, you <i>DONT</i> want to update <code>mydict</code> nor <code>del</code> this attribute).</span>
