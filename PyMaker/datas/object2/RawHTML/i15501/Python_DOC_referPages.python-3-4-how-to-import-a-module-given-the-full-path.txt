<div class="post-text" itemprop="text">
<p>How can I load a Python module in Python 3.4 given its full path? </p>
<p>A similar question <a href="https://stackoverflow.com/questions/67631/how-to-import-a-module-given-the-full-path">How to import a module given the full path?</a> covers Python versions before 3.4, but the conclusion is that support in Python 3.4 is deprecated for the presented answers, so any solution for Python 3.4 is appreciated.</p>
<p>Note that this question is not a duplicate of <a href="https://stackoverflow.com/questions/19009932/import-abitrary-python-source-file-python-3-3">Import abitrary python source file. (Python 3.3+)</a>, since answers for this also use <code>loader.load_module()</code> which is deprecated in Python 3.4, as said in <a href="https://stackoverflow.com/a/67692/2352082">answer</a>, with details in <a href="http://bugs.python.org/issue21436" rel="noreferrer">Consider leaving importlib.abc.Loader.load_module()</a>, and documentation in <a href="https://docs.python.org/3/library/importlib.html?highlight=importlib#module-importlib" rel="noreferrer">importlib</a>.</p>
<p>So a supported solution for module import by full path in Python 3.4 is needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work for all python files, regardless of file extension:</p>
<pre><code>import importlib.machinery

modulename = importlib.machinery.SourceFileLoader('modulename','/Path/To/module.py').load_module()
</code></pre>
<p>This method was mentioned in the deprecation message in the <code>imp.load_module</code> <a href="https://docs.python.org/3/library/imp.html#imp.load_module">documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The already-given answer works, but is unnecessarily clunky. An easier method:</p>
<pre><code>import sys, os, importlib

sys.path.append(os.path.dirname(filename))
mname = os.path.splitext(os.path.basename(filename))[0]
imported = importlib.import_module(mname)                       
sys.path.pop()
</code></pre>
<p><code>imported</code> is the imported module; you can use it as normal, through <code>imported.method(arg)</code>. The final line isn't strictly necessary, but it's cleaner not to leave unnecessary entries in <code>sys.path</code> (particularly if you're going to run the code multiple times). This works in 3.4, and doesn't use anything marked as deprecated.</p>
</div>
<div class="post-text" itemprop="text">
<p>The supported and non-deprecated method according to the <a href="https://docs.python.org/3/library/importlib.html?highlight=import_module#importing-a-source-file-directly" rel="nofollow noreferrer">3.6 docs</a> is like this:</p>
<pre><code>def import_file(full_name, path):
    """Import a python module from a path. 3.4+ only.

    Does not call sys.modules[full_name] = path
    """
    from importlib import util

    spec = util.spec_from_file_location(full_name, path)
    mod = util.module_from_spec(spec)

    spec.loader.exec_module(mod)
    return mod
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function below works in Python 3.4 - it is used to load and run specific functions in modules, but you need to add the folder to the sys path.</p>
<pre><code>sys.path.append("path_to_your_file_to_import")
tool = {'file':'test_tool.py', 
    'function':'sum_even_numbers', 
    'args':['list'], 
    'return':['int']
}

args = [1,2,3]

def run(tool, args, silent='Y'):
        if silent == 'N':
            print('main called ' + tool['file'] + '-&gt;' + tool['function'] + ' with ', args, ' = ', tool['return'])
        mod = __import__( os.path.basename(tool['file']).split('.')[0])
        func = getattr(mod, tool['function'])
        tool['return'] = func(args)
        return tool['return']
</code></pre>
<p>Call it via </p>
<pre><code>run(tool, args)
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/19009932/import-abitrary-python-source-file-python-3-3">Import abitrary python source file. (Python 3.3+)</a></span>
<span class="comment-copy">Do not close. The answer given for 3.3+ doesn't work in 3.4 as stated by <a href="http://stackoverflow.com/a/67692">stackoverflow.com/a/67692</a></span>
<span class="comment-copy">Thanks for point this out, and it looks fully supported in current Python 3.4, so that must be the replacement, thus the answer :-)</span>
<span class="comment-copy">FYI: Deprecated since version 3.6: Use importlib.abc.Loader.exec_module() instead. <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">Source</a></span>
<span class="comment-copy">importlib.machinery.ExtensionFileLoader seems to work for C/C++ extension modules.</span>
<span class="comment-copy">If <code>mname</code> is "/my/own/dir/stat.py" then the code it will import the Python Standard Library module <code>stat</code>, and not the specified module, due to the accidental clash of name with a module in the Python Standard Library.  So this does not work in all cases.</span>
<span class="comment-copy">True. I think, but am not certain, that this can be fixed by doing <code>sys.path.insert(0, os.path.dirname(filename))</code> instead of <code>.append()</code> (and, of course, doing <code>.pop(0)</code> afterward). Depends on whether <code>sys.path</code> has standard search-path semantics. Of course, if you did this then removing the entry afterward is even more important, to prevent files in that directory from shadowing the standard library. (On a more fundamental level, it's probably a bad idea to name your modules the same as standard library modules anyway. But.)</span>
<span class="comment-copy">Yes, putting it first in the search list may help in the case, but other modules that happens to have name as a standard library may then shadow a standard library.  Agree that you should avoid using existing standard library module names.  But, I think that all these work-around considerations are symptoms that there is missing a simple way to just import a file as a module... just like it was possible in previous versions of Python.</span>
<span class="comment-copy">Be careful with sys.path.pop() or sys.path.pop(0). You are presuming that sys.path is not modified by your target imported modules. It would be prudent then to do a sys.remove(os.path.dirname(filename)) instead.</span>
<span class="comment-copy"><code>module_from_spec</code> is only available in Python 3.5 and later.</span>
<span class="comment-copy">This is just plain <code>import</code> based on name, like the statement <code>import test_tool</code>, and not import of a module at a given location (path).  Also, the <code>self</code> part makes it look like copy-paste from a class, thus the plain call of <code>run(tool, args)</code> will result in syntax error.</span>
<span class="comment-copy">@EquipDev you are right - the folder needs to be added to the sys path. I have edited to show this, and also removed the self param. It was from a class I am working on - <a href="https://github.com/acutesoftware/AIKIF/blob/master/aikif/tools.py" rel="nofollow noreferrer">github.com/acutesoftware/AIKIF/blob/master/aikif/tools.py</a></span>
<span class="comment-copy">Using the regular import (<b>import</b>) mechanish with <code>sys.path</code> won't let you import a module in filename "sys.py", since that will collide with the built-in <code>sys</code> module.</span>
<span class="comment-copy">So what exactly do you want to be able to import - are these standard python modules, or do you want to be able to run code from any definable path?  One way is to copy the file from its path to a known local path, rename it with a GUID and import that.</span>
<span class="comment-copy">Just want to import a file as a module based on path to the file.  It is not supposed to be rocket science.  It was easy before Python 3.3, possible in Python 3.3, but with 3.4 I can't figure how to do it a supported way.</span>
