<div class="post-text" itemprop="text">
<p>I've been developing a sudoku solver in Python and the following question came up while trying to improve performance:</p>
<p>Does python remember the result of a calculation if the same calculation has to be performed multiple times throughout the code? Example: compare the following 2 bits of code:</p>
<pre><code>if get_single(foo, bar) is not None:
    position = get_single(foo, bar)


single = get_single(foo, bar)
if single is not None:
    position = single
</code></pre>
<p>Are these 2 pieces of code equal in performance or does the second piece perform faster because the calculation is only performed once?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, Python does not remember function calls or other calculations automatically. In general, it would be very bad if it did—imagine if every call to, say, <code>random.randrange(6)</code> returned the same value as the first call.</p>
<hr/>
<p>However, it's not hard to explicitly make it remember calls for specific functions where it's useful. This is usually called "memoization".</p>
<p>See the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>lru_cache</code></a> decorator in the docs, for a nice example built into the stdlib.* All you have to do to make it remember every call to <code>get_single(foo, bar)</code> is change the definition of <code>get_single</code> like this;</p>
<pre><code>@functools.lru_cache(maxsize=None)
def get_single(foo, bar):
    # etc.
</code></pre>
<p>Or, if <code>get_single</code> is someone else's code that you're importing and can't touch, you can just wrap it:</p>
<pre><code>get_single = functools.lru_cache(maxsize=None)(othermod.get_single)
</code></pre>
<p>… and then call your wrapper instead of the module's version.</p>
<p><sub>* Note that <code>lru_cache</code> was added in Python 3.2. If you're using 2.7 (or, for some reason, 3.0-3.1), you can install <a href="https://pypi.python.org/pypi/backports.functools_lru_cache/" rel="nofollow">the backport from PyPI</a>, or find any of dozens of other memoizing caches on PyPI or ActiveState—or even, noticing that the <code>functools</code> docs link to the source, like many other stdlib modules meant to also serve as example code, copy <a href="https://hg.python.org/cpython/file/3.2/Lib/functools.py#l117" rel="nofollow">the source</a> to your own project. Although, IIRC, the 3.2 code needs a small change to work with 2.7 because it relies on <code>nonlocal</code> to hide its internals.</sub></p>
<hr/>
<p>That being said, even if you know <code>get_single</code> is memoized, it's still not very good style to call it twice. If you only need to do this once, just write the three lines of code. If you need to do it repeatedly, write a wrapper function that wraps up those three lines or code, and then calling that function will be shorter than even the two-line version.</p>
</div>
<span class="comment-copy">The second will be faster, unless you have specifically <code>memoize</code>d the function <code>get_single</code>. Python doesn't <i>"remember the result of an operation"</i> in general because there's no guarantee that an arbitrary function will always give the same output for the same inputs.</span>
<span class="comment-copy">The problem actually is that one cannot assign the result in the <code>if</code> clause to a variable, thus eliminating the need for additional lines or calls. There was <a href="https://www.python.org/dev/peps/pep-0379/" rel="nofollow noreferrer">PEP 379</a> long ago to introduce <code>as</code> clause but it was dropped by the champion without stating a reason. <code>as</code> has since crawled its way into a few constructs regardless.</span>
<span class="comment-copy">It was rejected on bugs.python.org: <a href="http://bugs.python.org/issue1714448#msg83622" rel="nofollow noreferrer">bugs.python.org/issue1714448#msg83622</a>. The major objections are listed here: <a href="https://mail.python.org/pipermail/python-ideas/2009-March/003440.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-ideas/2009-March/003440.html</a></span>
<span class="comment-copy">There's a deeper reason (which Nick has told me "feels wrong", but maybe I just haven't explained it right, because I think it underlies a lot of both his intuitive judgments and Guido's): every statement in Python mutates at most one thing, and it's the leftmost thing. Anything that mutates things but has a value (like an <code>as</code> expression) would break that. (Yes, you can write methods or functions that mutate things—but by convention, they return <code>None</code> if at all possible.) And I think that's one of the key reasons Python code tends to be more scannable than JS, Perl, or Ruby.</span>
