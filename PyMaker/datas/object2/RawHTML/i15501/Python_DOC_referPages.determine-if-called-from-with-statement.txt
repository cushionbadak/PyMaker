<div class="post-text" itemprop="text">
<p>I would have a function that can either be called directly or via a with statement, and it should behave differently depending on how it is called, returning a context manager if called via a with statement, otherwise doing what the context manager would do directly.</p>
<p>e.g.</p>
<pre><code>class Context(object):
    def __enter__(self):
        print('start')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('end')
        return False


def myfunc():
    if called_from_with:
        return Context()
    else:
        print('start')
        print('end')
</code></pre>
<p>When called from a with:</p>
<pre><code>&gt;&gt;&gt; with myfunc():
&gt;&gt;&gt;    print('foo')

start
foo
end
</code></pre>
<p>When called directly:</p>
<pre><code>&gt;&gt;&gt; myfunc()

start
end
</code></pre>
<p>Is there a way to do this?</p>
<p>Edit: My use case is for a tool I'm working on for writing html. I've put my initial code here: <a href="https://github.com/garyvdm/htmlwrite" rel="nofollow">https://github.com/garyvdm/htmlwrite</a> (please note it is currently a work in progress.)</p>
<p>I would like the user to be able to write this: </p>
<pre><code>writer = Writer(sys.stdout)

with writer(Tag('div')):
    writer('Hello world')

writer(Tag('div', c=("Hello world 2", )))
</code></pre>
<p>Instead of this: (note the call to <code>.wrapped</code>)</p>
<pre><code>writer = Writer(sys.stdout)

with writer.wrapped(Tag('div')):
    writer('Hello world')

writer(Tag('div', c=("Hello world 2", )))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Context managers are not limited to <code>with</code> statements. Apart from assigning the manager to a variable before using it with <code>with</code> (<code>cm = writer(Tag('div'))</code>, then <code>with cm:</code>), you can use context manager in an <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow"><code>ExitStack</code></a> or call the <code>__enter__</code> and <code>__exit__</code> methods separately.</p>
<p>The better option is to <em>always</em> return a context manager from your function. If that means that you'll also need to provide a <em>different</em> function to provide a non-contextmanager version of the behaviour, so be it.</p>
<p>That said, you could adapt behaviour based on the number of arguments; this is what <a href="https://docs.python.org/2/library/unittest.html#TestCase.assertRaises" rel="nofollow"><code>TestCase.assertRaises()</code></a> does. Internally you always create a context manager, but with more arguments you simply apply he context immediately:</p>
<pre><code>def __call__(self, tag, *args):
    # produce a context manager
    cm = WriterContext(self, tag)
    if args:
        with cm:
            for arg in args:
                self.write(arg)
    else:
        return cm
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming what you want to avoid is double context manager invocation, that is same context manager should not be doubled, I propose that you hack context manager to be reentrant.</p>
<p>Here's a simple example using transactions:</p>
<pre><code>@contextmanager()
def foo(self):
    # if object can be shared across threads,
    # make sure only one thread can enter at a time
    # alternatively, inherit from threading.Local
    with self.lock:
        if self._transaction:
            yield
        else:
            try:
                with real_transaction() as self._transaction:
                    yield
            finally:
                self._transaction = None
</code></pre>
</div>
<span class="comment-copy">Why would you want to do that? What if I wanted to do <code>context_manager = myfunc()</code>, then <code>with context_manager:</code>?</span>
<span class="comment-copy">There is <i>no need</i> to switch behaviour. Always return a context manager, and use it correctly.</span>
<span class="comment-copy"><i>"it should behave differently depending on how it is called"</i> - this sounds like a really bad idea.</span>
<span class="comment-copy">If you want different behavior, make different functions.</span>
<span class="comment-copy">Ok. You guys have convinced me to have 2 separate functions. If one of you want to put an answer in for such, I will accept it.</span>
<span class="comment-copy">Although some might say that this is not very pythonic, this still looks pretty cool, especially the <code>as self._transaction</code> part.</span>
<span class="comment-copy">@Rusty: re-entrant context managers are <a href="https://docs.python.org/3/library/contextlib.html#reentrant-cms" rel="nofollow noreferrer">very pythonic</a>.</span>
<span class="comment-copy">@MartijnPieters I actually meant the <code>as</code> assignment part, In my (very small) experience it is only used to define new names, rather than assigning to existing ones.</span>
<span class="comment-copy">@Rusty: it binds the return value of <code>__enter__</code> to a target; nothing says that that name should be <i>new</i>. :-) It essentially does the same as <code>target = &lt;return value of __enter__&gt;</code>; you can do the same in an <code>except</code> handler. Nothing un-pythonic about that either.</span>
<span class="comment-copy">@MartijnPieters oh I see, as I mentioned before, my current experience with python is limited (2-3 months) and I've never seen that kind of usage before, so it looked like a hack to me, but it's great if it isn't, might come in handy some time.</span>
