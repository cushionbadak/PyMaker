<div class="post-text" itemprop="text">
<p>I ran into some problems when using the <code>range()</code> function to create <code>list</code>s.<br/>
Doing some experimenting, I get the following:
</p>
<pre><code>&gt;&gt;&gt; isinstance([], list)
True
&gt;&gt;&gt; isinstance(range(10), list)
False
</code></pre>
<p>Also, reading its documentation:</p>
<pre><code>&gt;&gt;&gt; print(range.__doc__)
range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object

Return a virtual sequence of numbers from start to stop by step.
</code></pre>
<p>I currently do have a workaround using <code>list(range())</code>, but the question still remains. What is a virtual sequence of numbers?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>range()</code> object calculates numbers <em>on demand</em>, e.g. when iterated over or when you try to access specific indices:</p>
<pre><code>&gt;&gt;&gt; r = range(2, 80, 3)
&gt;&gt;&gt; len(r)
26
&gt;&gt;&gt; r[15]
47
&gt;&gt;&gt; 42 in r
False
&gt;&gt;&gt; r[:10]
range(2, 32, 3)
</code></pre>
<p>It is a sequence because the object supports membership testing, indexing, slicing and has a length, just like a list or a tuple. But, unlike a list or a tuple, it doesn't actually contain all integers in the sequence in memory, making it <em>virtual</em>.</p>
<p>When you call <code>list()</code> on a <code>range()</code> object, you are creating a new sequence containing all the integers that are in the range, but you are now storing all those integers:</p>
<pre><code>&gt;&gt;&gt; r_list = list(r)
&gt;&gt;&gt; r_list
[2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, 62, 65, 68, 71, 74, 77]
</code></pre>
<p>That's a sequence too, but it takes more memory as all integers are now produced up front, wether you'll use them or not. So a list or a tuple is a <em>concrete</em> sequence.</p>
<p>Using the <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer"><code>sys.getsizeof()</code> function</a>, we can calculate how much memory each object uses:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(r)
48
&gt;&gt;&gt; sys.getsizeof(r_list) + sum(sys.getsizeof(i) for i in r_list)
1072
</code></pre>
<p>The list object uses 22 times the memory; that's because it contains 26 integer objects.</p>
<p>And to address the comment on your question, <code>range()</code> objects are <strong>not</strong> <a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="nofollow noreferrer">iterators</a>. Iterators produce values one by one on demand, but cannot be indexed, they produce all values just <em>once</em> and they do not have a length. You can produce an iterator from a <code>range()</code> object with the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> function</a>:</p>
<pre><code>&gt;&gt;&gt; iter(r)
&lt;range_iterator object at 0x10aea23f0&gt;
&gt;&gt;&gt; r_iter = iter(r)
&gt;&gt;&gt; len(r_iter)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'range_iterator' has no len()
&gt;&gt;&gt; list(r_iter)
[2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, 62, 65, 68, 71, 74, 77]
&gt;&gt;&gt; list(r_iter)
[]
</code></pre>
<p>but once exhausted, the iterator won't produce the same range again.</p>
<p>All of the above applies mainly to Python 3; in Python 2 the type is called <a href="https://docs.python.org/2/library/stdtypes.html#xrange-type" rel="nofollow noreferrer"><code>xrange()</code></a>, where it is more limited in its abilities (it doesn't support slicing and can only handle integers &lt; <code>sys.maxint</code>).</p>
</div>
<span class="comment-copy">@tyteen4a03 - Not exactly.  <code>range</code> returns a lazy sequence of type <code>range</code>.  Its items are computed on-demand.  But you can reuse <code>range</code> objects while iterators are a one-time use (once you iterate over them, they are exhausted).</span>
<span class="comment-copy">@tyteen4a03: no, it does <b>not</b> return an iterator. It is iterable, but it is a <i>sequence</i>, not an iterator.</span>
<span class="comment-copy"><a href="https://docs.python.org/3.4/library/stdtypes.html#range" rel="nofollow noreferrer">docs.python.org/3.4/library/stdtypes.html#range</a></span>
