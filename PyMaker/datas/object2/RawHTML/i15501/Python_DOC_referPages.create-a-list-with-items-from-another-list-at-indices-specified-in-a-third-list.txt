<div class="post-text" itemprop="text">
<p>Consider two lists:</p>
<pre><code>a = [2, 4, 5]
b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>I want a resulting list <code>c</code> where</p>
<pre><code>c = [0, 0, 2, 0, 4, 5, 0 ,0 ,0 ,0]
</code></pre>
<p>is a list of length <code>len(b)</code> with values taken from <code>b</code> defined by indices specified in <code>a</code> and zeros elsewhere.</p>
<p>What is the most elegant way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3.4/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a> with the <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow">conditional expression</a> and <a href="https://docs.python.org/3.4/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>.</p>
<p>This LC will iterate over the index and the value of the list <code>b</code> and if the index <code>i</code> is found within <code>a</code> then it will set the element to <code>v</code>, otherwise it'll set it to 0.</p>
<pre><code>a = [2, 4, 5]
b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

c = [v if i in a else 0 for i, v in enumerate(b)]

print(c)
# [0, 0, 2, 0, 4, 5, 0, 0, 0, 0]
</code></pre>
<p>Note: If <code>a</code> is large then you may be best converting to a set first, before using <code>in</code>. The <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">time complexity</a> for using <code>in</code> with a list is O(n) whilst for a set it is O(1) (in the average case for both).</p>
<p>The list comprehension is roughly equivalent to the following code (for explanation):</p>
<pre><code>c = []
for i, v in enumerate(b):
    if i in a:
        c.append(v)
    else:
        c.append(0)
</code></pre>
<p>As you have the option of using <code>numpy</code> I've included a simple method below which uses initialises an array filled with zeros and then uses list indexing to replace the elements.</p>
<pre><code>import numpy as np

a2 = np.array(a)
b2 = np.array(b)

c = np.zeros(len(b2))
c[a2] = b[a2]
</code></pre>
<p>When timing the three methods (my list comp, my numpy, and Jon's method) the following results are given for <code>N = 1000</code>, <code>a = list(range(0, N, 10))</code>, and <code>b = list(range(N))</code>.</p>
<pre><code>In [170]: %timeit lc_func(a,b)
100 loops, best of 3: 3.56 ms per loop

In [171]: %timeit numpy_func(a2,b2)
100000 loops, best of 3: 14.8 µs per loop

In [172]: %timeit jon_func(a,b)
10000 loops, best of 3: 22.8 µs per loop
</code></pre>
<p>This is to be expected. The numpy function is fastest, but both Jon's function and the numpy are <strong>much faster</strong> than a list comprehension. If I increased the number of elements to 100,000 then the gap between numpy and Jon's method gets even larger. </p>
<p><em>Interestingly enough though, for small <code>N</code> Jon's function is the best!</em> I suspect this is to do with the overhead of creating numpy arrays being trumped by the overhead of lists. </p>
<p>Moral of the story: large N? Go with numpy. Small N? Go with Jon.</p>
</div>
<div class="post-text" itemprop="text">
<p>The other option is to pre-initialise the target list with <code>0</code>s - a fast operation, then over-write the value to the suitable index, eg:</p>
<pre><code>a = [2, 4, 5]
b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

c = [0] * len(b)
for el in a:
    c[el] = b[el]

# [0, 0, 2, 0, 4, 5, 0, 0, 0, 0]
</code></pre>
</div>
<span class="comment-copy">you missed <code>else: c.append(0)</code> in explanation. Awesome solution by the way.</span>
<span class="comment-copy">Looks good, although isn't <code>in</code> kind of expensive to be running for all <code>i</code> in <code>enumerate(b)</code>? Suppose <code>a</code> and <code>b</code> are very long.</span>
<span class="comment-copy">Indeed I do have the option for numpy.</span>
<span class="comment-copy">not necessarily numpy, but it wouldn't be nearly as "elegant" as list comprehension</span>
<span class="comment-copy">I may be mistaken, but python lists are not built like arrays. If they are not arrays, than it would be pretty expensive to replace an element inside of list.</span>
<span class="comment-copy">@Rusty accessing/settings element are O(1) (Python <code>list</code>'s are arrays (just needn't be of homogeneous types) - not linked lists like the name could possibly imply)</span>
