<div class="post-text" itemprop="text">
<p>I've posted a few times and I'm stuck once more, I tried using an if statement to calculate where the boundaries of the map are but its not working. Here are the two files I'm working in:</p>
<p>gui.py</p>
<pre><code>try:
    from tkinter import *

except ImportError as err:
    print('a', err)

from player import *

class SimpleGUI:
    def __init__(self):
        self.window = Tk()
        self.window.title('Final Project')
        self.window.protocol('WM_DELETE_WINDOW',self.exit)
        self.canvas = Canvas(self.window,
                             width = 245,
                             height = 550,
                             bg = 'white')
        self.canvas.pack()

        self.player = Player()

        self.canvas.focus_set()
        self.canvas.bind('w', self.w_key)
        self.canvas.bind('a', self.a_key)
        self.canvas.bind('s', self.s_key)
        self.canvas.bind('d', self.d_key)


        self.running = True
        self.menu = Menu

        self.bt1 = Button(self.window,
                         text = 'Start',
                         command = self.menu)
        self.bt1.pack()




        self.mainloop()
        self.window.mainloop()

    def mainloop(self):
        while self.running:
            self.canvas.delete(ALL)
            #boss square
            boss_start = self.canvas.create_rectangle(100,0,150,100, outline = 'black', fill = 'black', width = 2)
            #player start square
            ply_start = self.canvas.create_rectangle(100,500,150,550, outline = 'black', fill = 'black', width = 2)
            #row 9
            self.canvas.create_rectangle(0,50,50,100, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,50,100,100, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,50,150,100, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,50,200,100, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,50,250,100, outline = 'black', fill = 'black', width = 2)
            #row 8
            self.canvas.create_rectangle(0,100,50,150, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,100,100,150, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,100,150,150, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,100,200,150, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,100,250,150, outline = 'black', fill = 'black', width = 2)
            #row 7
            self.canvas.create_rectangle(0,150,50,200, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,150,100,200, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,150,150,200, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,150,200,200, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,150,250,200, outline = 'black', fill = 'black', width = 2)
            #row 6
            self.canvas.create_rectangle(0,200,50,250, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,200,100,250, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,200,150,250, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,200,200,250, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,200,250,250, outline = 'black', fill = 'black', width = 2)
            #row 5
            self.canvas.create_rectangle(0,250,50,300, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,250,100,300, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,250,150,300, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,250,200,300, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,250,250,300, outline = 'black', fill = 'black', width = 2)
            #row 4
            self.canvas.create_rectangle(0,300,50,350, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,300,100,350, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,300,150,350, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,300,200,350, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,300,250,350, outline = 'black', fill = 'black', width = 2)
            #row 3
            self.canvas.create_rectangle(0,350,50,400, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,350,100,400, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,350,150,400, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,350,200,400, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,350,250,400, outline = 'black', fill = 'black', width = 2)
            #row 2
            self.canvas.create_rectangle(0,400,50,450, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,400,100,450, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,400,150,450, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,400,200,450, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,400,250,450, outline = 'black', fill = 'black', width = 2)
            #row 1
            self.canvas.create_rectangle(0,450,50,500, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(50,450,100,500, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(100,450,150,500, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(150,450,200,500, outline = 'black', fill = 'black', width = 2)
            self.canvas.create_rectangle(200,450,250,500, outline = 'black', fill = 'black', width = 2)
            self.player.draw(self.canvas)

            self.canvas.after(30)
            self.canvas.update()

    def button1(self):
        print('working')

    def a_key(self, event):
        self.player.x -= self.player.speed

    def w_key(self, event):
        self.player.y -= self.player.speed

    def s_key(self, event):
        self.player.y += self.player.speed

    def d_key(self, event):
        self.player.x += self.player.speed

    def exit(self):
        self.running = False
        self.window.destroy()


if __name__ == '__main__':
    SimpleGUI()
</code></pre>
<p>player.py</p>
<pre><code>class Player:
    def __init__(self, hp = 100, defense = 10, strength = 10):
        self.hp = hp
        self.defense = defense
        self.strength = strength
        self.x = 100
        self.y = 500
        self.speed = 50
        if self.x &lt;= 100:
            if self.y &lt;= 500:
                self.x = 100
                self.y = 500

    def draw(self, canvas): 
        canvas.create_oval(self.x,self.y,self.x+50,self.y+50, fill='red') 

if __name__ == '__main__':
    player = Player()
</code></pre>
<p>Thank you for your time and help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've written some boundary-checking code in your <code>__init__</code> method:</p>
<pre><code>if self.x &lt;= 100:
    if self.y &lt;= 500:
        self.x = 100
        self.y = 500
</code></pre>
<p>But this only gets run <em>once</em>, at initialization time. It doesn't get run every time you change the <code>x</code> or <code>y</code> values in the future.</p>
<p>You could solve this by moving it into a method:</p>
<pre><code>def fit_in_bounds(self):
    if self.x &lt;= 100:
        if self.y &lt;= 500:
            self.x = 100
            self.y = 500
</code></pre>
<p>… and then, every time someone adjusts the value, they have to call that method:</p>
<pre><code>def a_key(self, event):
    self.player.x -= self.player.speed
    self.player.fit_in_bounds()
</code></pre>
<hr/>
<p>But that can be tedious—and error-prone, because it's pretty easy to forget to call <code>fit_in_bounds</code>. This kind of thing is exactly what <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>@property</code></a> is for: you can make it so that every time <code>x</code> or <code>y</code> gets set, <code>fit_in_bounds</code> gets called <em>automatically</em>.</p>
<pre><code>def __init__(self, –):
    # …
    self._x = 100 # notice the _ to make it "private"
    # …

@property
def x(self):
    return self._x

@x.setter
def x(self, x):
    self._x = x
    self.fit_in_bounds()
</code></pre>
<p>Now your <code>SimpleGUI</code> can just use <code>self.player.x</code> the same as before—but every time you do <code>self.player.x -= self.player.speed</code>, it will automatically make sure the player is still in bounds.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this:</p>
<pre><code>def a_key(self, event):
    self.player.x -= self.player.speed
    if self.player.x &lt; LEFT_EDGE:
        self.player.x = LEFT_EDGE

def w_key(self, event):
    self.player.y -= self.player.speed
    if self.player.y &lt; TOP_EDGE:
        self.player.y = TOP_EDGE

def s_key(self, event):
    self.player.y += self.player.speed
    if self.player.y &gt; BOTTOM_EDGE:
        self.player.y = BOTTOM_EDGE

def d_key(self, event):
    self.player.x += self.player.speed
    if self.player.x &gt; RIGHT_EDGE:
        self.player.x = RIGHT_EDGE
</code></pre>
<p>Where the edges represent the edges of the maps.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not complete but will give you a start.  You should place everything to do with a player in the class.  So movement, bounds checking, etc. should all be in the Player class.  There are some hard-wired numbers for bounds checking that will have to be passed to the Player class and some problems with hitting the actual edge, but this is all I have time for.  Also note that a loop replaces all of the create_rectangle statements in your code and only one function is used for a keypress, with the letter passed to the function.  And the "movement_dict" may be overkill as simple if statements would work as well.  HTH  </p>
<pre><code>from functools import partial

class SimpleGUI:
    def __init__(self):
        self.window = Tk()
        self.window.title('Final Project')
        self.window.protocol('WM_DELETE_WINDOW',self.exit)
        self.canvas = Canvas(self.window,
                             width = 245,
                             height = 550,
                             bg = 'white')
        self.canvas.pack()

        self.current_player=True
        self.player_list = []
        player = Player(canvas=self.canvas, color="red", x=100, y=500)
        self.player_list.append(player)
        player = Player(canvas=self.canvas, color="blue", x=150, y=475)
        self.player_list.append(player)

        self.canvas.focus_set()
        for ltr in ["w", "s", "a", "d"]:
            self.canvas.bind(ltr, partial(self.key_press, ltr))


        self.running = False
##        self.menu = Menu

        self.bt1 = Button(self.window,
                         text = 'Start',
                         command = self.start_it)
        self.bt1.pack()

        self.bt2 = Button(self.window,
                         text = 'Quit',
                         command = self.exit).pack()



        self.create_rects()
        self.window.mainloop()

    def create_rects(self):
            #boss square
            boss_start = self.canvas.create_rectangle(100,0,150,100,
                                      outline = 'black', width = 2)
            #player start square
            ply_start = self.canvas.create_rectangle(100,500,150,550, outline = 'black', width = 2)

            start_x = 0
            start_y = 50
            for ctr in range(9):
                x = start_x
                y = start_y + ctr*50
                for row in range(5):
                    print x,y
                    self.canvas.create_rectangle(x, y, x+50, y+50,
                                             outline = 'black', width = 2)
                    x += 50

    def button1(self):
        print('working')

    def key_press(self, ltr, event):
        """ player #1 --&gt; self.current_player==True
            player #2 --&gt; self.current_player==Flase
        """
        print "ltr", ltr
        if self.running:
            if self.current_player:
                self.player_list[0].adjust(ltr)
                print "player #1"
            else:
                self.player_list[1].adjust(ltr)
                print "     player #2"
            self.window.after(100, self.canvas.update)
            self.current_player = not self.current_player

    def start_it(self):
        self.running=True

    def exit(self):
        self.running = False
        self.window.destroy()


class Player:
    def __init__(self, canvas, color, hp = 100, defense = 10, strength = 10,
                 x=100, y=500):
        print "player"
        self.canvas=canvas
        self.hp = hp
        self.defense = defense
        self.strength = strength
        self.x = x
        self.y = y
        self.speed = 50
        self.draw(color)

    def draw(self, color): 
        self.circle=self.canvas.create_oval(self.x,self.y,self.x+50,self.y+50,
                                            fill=color) 
        print "draw"

    def adjust(self, ltr):
        print "adjust", ltr
        movement_dict = {"a": [-1, 0], "d": [1, 0], "w": [0, -1], "s":[0, 1]}
        if ltr in movement_dict:
            x_move = self.speed*movement_dict[ltr][0]
            y_move = self.speed*movement_dict[ltr][1]

            x_left=0
            x_right=245
            y_top=0
            y_bottom=550-25
            if self.x+x_move &lt; x_left:
                x_move=0
            if self.x+x_move &gt; x_right:
                x_move=0
            if (self.y+y_move &lt; y_top) or (self.y+y_move &gt; y_bottom):
                y_move=0

            self.canvas.move(self.circle, x_move, y_move)
            self.x += x_move
            self.y += y_move
            print self.x, self.y

if __name__ == '__main__':
    SimpleGUI()
</code></pre>
</div>
<span class="comment-copy">Having your own mainloop, and then calling the normal mainloop isn't going to do what you expect.</span>
