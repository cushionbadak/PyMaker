<div class="post-text" itemprop="text">
<p>I have created a program that uses recursion to solve simple mazes. In the event of a rather complex maze, I get a maximum recursion depth error. I have searched that error on this website and read threads, so I believe I have a general understanding of what is occurring.</p>
<p>Unlike the other threads I saw, I am not trying to increase the recursion limit. sys.setrecursionlimit() is not what I am looking for. I would like to be able handle the overflow, and instead of crashing have the program print a message (<code>print("Sorry but this maze solver was not able to finish analyzing the maze due to recursion limits)</code>) and close. </p>
<p>I am aware of using try and except to handle errors, but I'm not sure if I can incorporate that to handle a maximum recursion depth error.</p>
</div>
<div class="post-text" itemprop="text">
<p>A maximum recursion depth error is just another exception; you can catch the <a href="https://docs.python.org/3/library/exceptions.html#RecursionError" rel="nofollow noreferrer"><code>RecursionError</code> exception</a> (Python 3.5 or later):</p>
<pre><code>try:
    solveMaze(maze)
except RecursionError as re:
    print('Sorry but this maze solver was not able to finish '
          'analyzing the maze: {}'.format(re.args[0]))
</code></pre>
<p>I've incorporated the error message attached to the runtime exception; for a recursion error that's <code>maximum recursion depth exceeded</code>.</p>
<p>If you need to support Python versions earlier than 3.5, you can catch the base class, <a href="https://docs.python.org/3/library/exceptions.html#RuntimeError" rel="nofollow noreferrer"><code>RuntimeError</code></a>. If you are worried about catching runtime errors that are <em>not</em> recursion depth errors, you could introspect the <code>.args[0]</code> value:</p>
<pre><code>try:
    solveMaze(maze)
except RuntimeError as re:
    if re.args[0] != 'maximum recursion depth exceeded':
        # different type of runtime error
        raise
    print('Sorry but this maze solver was not able to finish '
          'analyzing the maze: {}'.format(re.args[0]))
</code></pre>
<p>Demo of the options:</p>
<pre><code>&gt;&gt;&gt; def infinity(): return infinity()
... 
&gt;&gt;&gt; try:
...     infinity()
... except RecursionError as re:
...     print('Oopsie: {}'.format(re.args[0]))
... 
Oopsie: maximum recursion depth exceeded
&gt;&gt;&gt; def alter_dict_size():
...     dct = {'foo': 'bar'}
...     for key in dct:
...         del dct['foo']
... 
&gt;&gt;&gt; try:
...     alter_dict_size()
... except RuntimeError as re:
...     print('Oopsie: {}'.format(re.args[0]))
... 
Oopsie: dictionary changed size during iteration
&gt;&gt;&gt; try:
...     infinity()
... except RuntimeError as re:
...     if re.args[0] != 'maximum recursion depth exceeded':
...         raise
...     print('Oopsie: {}'.format(re.args[0]))
... 
Oopsie: maximum recursion depth exceeded
&gt;&gt;&gt; try:
...     alter_dict_size()
... except RuntimeError as re:
...     if re.args[0] != 'maximum recursion depth exceeded':
...         raise
...     print('Oopsie: {}'.format(re.args[0]))
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in alter_dict_size
RuntimeError: dictionary changed size during iteration
</code></pre>
<p>Altering a dictionary size also raises a <code>RuntimeError</code> exception, but testing the resulting exception message allows you to differentiate.</p>
</div>
<span class="comment-copy">Note that you can generally implement any recursive algorithm as a non-recursive algorithm using a queue data structure. That's one way to get around recursion limits.</span>
<span class="comment-copy">Hi thank you for the information JME. I am required to use recursion for this assignment (it is a class problem)</span>
<span class="comment-copy">If you want to catch recursion errors, catch <code>RecursionError</code>!</span>
<span class="comment-copy">@SolomonUcko: Thanks for pointing that out. That's a <i>new</i> exception, added in Python 3.5, first released in September 2015. I've added it to my answer.</span>
