<div class="post-text" itemprop="text">
<p>What do the following expression actually does?</p>
<pre><code>list = [lambda n=n: lambda x: x+n for n in range(10)]
</code></pre>
<p>More specifically:</p>
<ol>
<li>What does <code>n=n</code> mean?</li>
<li>What will be the content of <code>'list'</code>?</li>
<li><p>What will be the output of </p>
<p><code>print(list[0](14))</code> and <code>print(list[0]()(14))</code></p></li>
</ol>
<p>and why?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<ol>
<li>What does <code>n=n</code> mean?</li>
</ol>
</blockquote>
<p><a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow"><code>lambda</code></a> lets you define functions that take parameters, just like <code>def</code>. And those parameters can have <a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow">default argument values</a>. So, <code>lambda n=n:</code> is the same as <code>def foo(n=n):</code>.</p>
<p>In fact, when faced with an expression that's too complicated for you to read, it's often worth unpacking into simple statements:</p>
<pre><code>list = []
for n in range(10):
    def spam(n=n):
        def eggs(x):
            return x+n
        return eggs
    list.append(spam)
</code></pre>
<hr/>
<p>Now, why would you want to create a parameter named <code>n</code> with default value <code>n</code>? Why not just <code>lambda:</code>? <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow">The official FAQ</a> explains this, but let's try to summarize.</p>
<p>If you just write this:</p>
<pre><code>funcs = [lambda: n for n in range(10)]
</code></pre>
<p>… what you get is 10 functions of no parameters, that are all closures over the same variable, <code>n</code>. Because <code>n</code> has the value 9 at the end of the loop, when called, they're all going to return 9. </p>
<p>But if you do this:</p>
<pre><code>funcs = [lambda n=n: n for n in range(10)]
</code></pre>
<p>… what you get is 10 functions of one optional parameter <code>n</code> (which hides the closure <code>n</code> from view), whose default value is the value of <code>n</code> at the time each function was defined. So, when called with no arguments, the first one will return 0, the second 1, and so on.</p>
<p>In your case, of course, the functions aren't just returning <code>n</code>, they're returning a function that takes a parameter, adds <code>n</code> to it, and returns the result. But the idea is the same; you want them to return different functions, which add 0, 1, … 9 to their arguments, not all return equal functions that all add 9.</p>
<hr/>
<blockquote>
<ol start="2">
<li>What will be the content of <code>list</code>?</li>
</ol>
</blockquote>
<p><code>list</code> will be 10 functions of one optional parameter whose default values range from 0 to 9, each of which returns a function of one parameter. That returned function is a closure over the value of <code>n</code> from the outer function. So, when it's called, it returns its argument, <code>x</code>, plus the <code>n</code> variable that ranges from 0 through 9.</p>
<hr/>
<blockquote>
<ol start="3">
<li>What will be the output of</li>
</ol>
</blockquote>
<pre><code>print(list[0](14))
</code></pre>
<p>Here, you're calling the first outer function, <code>list[0]</code>, with the argument 14. So, instead of its default value 0 for <code>n</code>, it's going to have 14. So, what you'll get is a function that takes one argument and adds 14 to it. But it will print out as something like:</p>
<pre><code>&lt;function &lt;listcomp&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt; at 0x105f21f28&gt;
</code></pre>
<p><sub>That long mess is Python 3.4+ trying to be helpful by telling you where to find the function definition. <em>Usually</em>, when a function is nested this deeply, most of the steps along the way have names. In this case, you've got three layers of anonymous functions, so none of the names are very useful…</sub></p>
<p>In order to see it do anything useful, you'll have to call it:</p>
<pre><code>print(list[0](14)(20))
</code></pre>
<p>And this will give you <code>34</code>.</p>
<p><sub>You could also use the <code>inspect</code> module, or just <code>dir</code>, to poke around inside the function. For example, <code>print(list[0](14).__code__.co_freevars[0], list[0](14).__closure__[0].cell_contents)</code> will tell you that it's stashed the number 14 under the name <code>n</code> for use by its internal function.</sub></p>
<blockquote>
<p>…</p>
</blockquote>
<pre><code>print(list[0]()(14))
</code></pre>
<p>Here, you're again calling <code>list[0]</code>, but this time with no argument, so its <code>n</code> gets the default value of <code>0</code>. So, it returns a function that adds <code>0</code> to its argument. You then call that function with <code>14</code>, so you get <code>14</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the last part first:</p>
<pre><code>In [1]: list = [lambda n=n: lambda x: x+n for n in range(10)]

In [2]: print(list[0](14))
&lt;function &lt;lambda&gt; at 0x7f47b5ca7cf8&gt;

In [3]: print(list[0]()(14))
14
</code></pre>
<p>Obtained by <strong>running</strong> the code. <code>list</code> <em>bad name by the way as list is a python builtin</em> gives you 10 lambda functions that don't do much - the first will return the original argument x, the second the argument + 1, ect. as n is stored as the index of the lambda by n=n local to that lambda.</p>
</div>
<span class="comment-copy">Rather than asking what the output will be, why don't you try it?</span>
<span class="comment-copy">Ran it. The "why?" is the real trouble...</span>
<span class="comment-copy">Perfecto! Thank you.</span>
