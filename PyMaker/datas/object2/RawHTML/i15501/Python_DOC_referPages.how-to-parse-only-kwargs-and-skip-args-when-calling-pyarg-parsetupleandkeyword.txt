<div class="post-text" itemprop="text">
<p>I am calling a function which takes a list of positional arguments followed by keyword arguments. I want to process args and kwargs both separately. Unfortunately, unlike PyArg_ParseTuple for positional arguments, there is no equivalent PyArg_ParseKeywords for keyword arguments. I tried to prevent parsing of positional arguments by passing Py_None (also NULL) in place of args:</p>
<pre><code>static PyObject* test_func(PyObject* self, PyObject* args, PyObject *kwargs)
{
    static const char *kwList[] = {"kw1", "kw2", NULL};
    const char* kw1_val = NULL;
    PyObject* kw2_val = NULL;

    if (! PyArg_ParseTupleAndKeywords(Py_None, 
                                      kwargs,
                                      "zO",
                                      const_cast&lt;char**&gt;(kwList),
                                      &amp;kw1_val,
                                      &amp;kw2_val))
    {
        return NULL;
    }
}
</code></pre>
<p>Having Py_None (or NULL) there leads to :</p>
<pre><code>Python/getargs.c:1390: bad argument to internal function
</code></pre>
<p>If I replace Py_None by args, I get following error:</p>
<pre><code>TypeError: function takes at most 2 arguments (4 given)
</code></pre>
<p>Above TypeError occurs as it unpacks 2 positional args and 2 keyword args I passed to test_func while there are only two variables, kw1_val and kw2_val to receive those 4 values in parsing method.</p>
<p>Is there a way to handle above scenario ? Note that positional argument can have any number of values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try passing an empty tuple instead of <code>Py_None</code>:</p>
<pre class="lang-c prettyprint-override"><code>static PyObject* test_func(PyObject* self, PyObject* args, PyObject *kwargs)
{
    static const char *kwList[] = {"kw1", "kw2", NULL};
    const char* kw1_val = NULL;
    PyObject* kw2_val = NULL;

    PyObject *retvalue = NULL;
    PyObject *empty = PyTuple_New(0);

    if (empty == NULL){
        goto out;
    }

    if (! PyArg_ParseTupleAndKeywords(empty, 
                                      kwargs,
                                      "zO",
                                      const_cast&lt;char**&gt;(kwList),
                                      &amp;kw1_val,
                                      &amp;kw2_val))
    {
        goto out;
    }

    // other code here

out:
    Py_XDECREF(empty);
    return retvalue;
}
</code></pre>
</div>
<span class="comment-copy">Thanks Kevin, this worked. However I am still wondering why we need to workaround for only keywords handling.</span>
<span class="comment-copy">You can make arguments keyword-only under Python 3 by <a href="https://docs.python.org/3/c-api/arg.html#other-objects" rel="nofollow noreferrer">prefixing the format string with <code>"|$"</code></a>, but that will also make them optional; you seem to want mandatory keyword-only arguments, which are currently unsupported.</span>
