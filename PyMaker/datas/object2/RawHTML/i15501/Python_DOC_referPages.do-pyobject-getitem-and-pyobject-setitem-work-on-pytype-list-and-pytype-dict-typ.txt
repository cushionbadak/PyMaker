<div class="post-text" itemprop="text">
<p>Documentation for PyObject_GetItem and PyObject_SetItem <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_GetItem" rel="nofollow">here</a> states:</p>
<blockquote>
<p>PyObject* <strong><em>PyObject_GetItem</em></strong>(PyObject *o, PyObject *key)
      Return value: New reference.</p>
<pre><code>Return element of o corresponding to the object key or NULL on failure. 
This is the equivalent of the Python expression o[key].
</code></pre>
<p>int <strong><em>PyObject_SetItem</em></strong>(PyObject *o, PyObject *key, PyObject *v)</p>
<pre><code>Map the object key to the value v. Returns -1 on failure. 
This is the equivalent of the Python statement o[key] = v.
</code></pre>
</blockquote>
<p>foo[key] syntax implies PyType_Dict</p>
<p>However, it doesn't state whether it also works on PyType_List, in which case key would be an index, i.e. a positive PyType_Long, or maybe a type converts into it, e.g. a PyType_Bytes containing "42".</p>
<p>Does this function work for both containers?</p>
<p>I would expect it to; such a design to be in keeping with Python's "<em>it does everything you would expect it to do</em>" philosophy.</p>
<p>Furthermore, the project I'm looking at has a comment forewarning:</p>
<pre><code>    // PyObject_SetItem is too weird to be using from C++
    // so it is intentionally omitted.
</code></pre>
<p>Should I be worried about this?  What could it possibly mean?  And has it been fixed for Python3?</p>
</div>
<div class="post-text" itemprop="text">
<p>Both functions work for all containers that support indexed accesses, be they dict, list, tuple, string, bytes, and so on.</p>
<p>I'm not sure why PyCXX has that comment; it may be due to the fact that Python's dynamic typing does not always mesh well with languages with static typing.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is that it supports both!</p>
<p>You can find from the source code:</p>
<blockquote>
<pre><code>pi@piBookAir.local ~ /Users/pi/Downloads/Python-3.4.2:
~ grep -R "PyObject_GetItem" .

: 
./Objects/abstract.c:PyObject_GetItem(PyObject *o, PyObject *key)
:
</code></pre>
</blockquote>
<p>And looking in abstract.c:</p>
<pre><code>    PyObject *
    PyObject_GetItem(PyObject *o, PyObject *key)
    {
        PyMappingMethods *m;

        if (o == NULL || key == NULL)
            return null_error();

        m = o-&gt;ob_type-&gt;tp_as_mapping;
        if (m &amp;&amp; m-&gt;mp_subscript)
            return m-&gt;mp_subscript(o, key);

        if (o-&gt;ob_type-&gt;tp_as_sequence) {
            if (PyIndex_Check(key)) {
                Py_ssize_t key_value;
                key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);
                if (key_value == -1 &amp;&amp; PyErr_Occurred())
                    return NULL;
                return PySequence_GetItem(o, key_value);
            }
            else if (o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item)
                return type_error("sequence index must "
                                  "be integer, not '%.200s'", key);
        }

        return type_error("'%.200s' object is not subscriptable", o);
    }
</code></pre>
</div>
<span class="comment-copy">This sounds reasonable, I'm attempting to rewrite PyCXX (which attempts to create a corresponding static type for each PyType_Foo) with a single dynamic Object type that will mirror a PyObject. It sounds like you have already walked a similar path...?</span>
