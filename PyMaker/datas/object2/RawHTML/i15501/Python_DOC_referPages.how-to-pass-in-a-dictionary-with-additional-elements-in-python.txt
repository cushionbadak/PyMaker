<div class="post-text" itemprop="text">
<p>I have a dictionary:</p>
<pre><code>big_dict = {1:"1",
            2:"2",
            ...
            1000:"1000"}
</code></pre>
<p>(Note: My dictionary isn't actually numbers to strings)</p>
<p>I am passing this dictionary into a function that calls for it. I use the dictionary often for different functions. However, on occasion I want to send in <code>big_dict</code> with an extra key:item pair such that the dictionary I want to send in would be equivalent to: </p>
<pre><code>big_dict[1001]="1001"
</code></pre>
<p>But I don't want to <em>actually</em> add the value to the dictionary. I could make a copy of the dictionary and add it there, but I'd like to avoid the memory + CPU cycles this would consume.</p>
<p>The code I currently have is:</p>
<pre><code>big_dict[1001]="1001"
function_that_uses_dict(big_dict)
del big_dict[1001]
</code></pre>
<p>While this works, it seems rather kludgy. </p>
<p>If this were a string I'd do:</p>
<pre><code>function_that_uses_string(myString + 'what I want to add on')
</code></pre>
<p>Is there any equivalent way of doing this with a dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out by <a href="https://stackoverflow.com/users/1763356/veedrac">Veedrac</a> in <a href="https://stackoverflow.com/a/27527606/2642204">his answer</a>, this problem has already been solved in Python 3.3+ in the form of the <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow noreferrer"><code>ChainMap</code></a> class:</p>
<pre><code>function_that_uses_dict(ChainMap({1001 : "1001"}, big_dict))
</code></pre>
<p>If you don't have Python 3.3 you should use a backport, and if for some reason you don't want to, then below you can see how to implement it by yourself :)</p>
<hr/>
<p>You can create a wrapper, similarly to this:</p>
<pre><code>class DictAdditionalValueWrapper:
    def __init__(self, baseDict, specialKey, specialValue):
        self.baseDict = baseDict
        self.specialKey = specialKey
        self.specialValue = specialValue

    def __getitem__(self, key):
        if key == self.specialKey:
            return self.specialValue

        return self.baseDict[key]

    # ...
</code></pre>
<p>You need to supply all other <code>dict</code> method of course, or use the <a href="https://docs.python.org/2/library/userdict.html" rel="nofollow noreferrer"><code>UserDict</code></a> as a base class, which should simplify this.</p>
<p>and then use it like this:</p>
<pre><code>function_that_uses_dict(DictAdditionalValueWrapper(big_dict, 1001, "1001"))
</code></pre>
<p>This can be easily extended to a whole additional dictionary of "special" keys and values, not just single additional element.</p>
<hr/>
<p>You can also extend this approach to reach something similar as in your string example:</p>
<pre><code>class AdditionalKeyValuePair:
    def __init__(self, specialKey, specialValue):
        self.specialKey = specialKey
        self.specialValue = specialValue

    def __add__(self, d):
        if not isinstance(d, dict):
            raise Exception("Not a dict in AdditionalKeyValuePair")

        return DictAdditionalValueWrapper(d, self.specialKey, self.specialValue)
</code></pre>
<p>and use it like this:</p>
<pre><code>function_that_uses_dict(AdditionalKeyValuePair(1001, "1001") + big_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're on 3.3+, just use <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow"><code>ChainMap</code></a>. Otherwise use a backport.</p>
<pre><code>new_dict = ChainMap({1001: "1001"}, old_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add the extra <strong>key-value</strong> pair leaving <strong>original dictionary</strong> as such like this:</p>
<pre><code>&gt;&gt;&gt; def function_that_uses_bdict(big_dict):
...    print big_dict[1001]
... 
&gt;&gt;&gt; dct = {1:'1', 2:'2'}
&gt;&gt;&gt; function_that_uses_bdict(dict(dct.items()+[(1001,'1001')]))
1001
&gt;&gt;&gt; dct  
{1: '1', 2: '2'}  # original unchanged
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit annoying too, but you could just have the function take two parameters, one of them being big_dict, and another being a temporary dictionary, created just for the function (so something like <code>fxn(big_dict, {1001,'1001'})</code> ).  Then you could access both dictionaries without changing your first one, and without copying <code>big_dict</code>.</p>
</div>
<span class="comment-copy">Is the extra key-value pair always the same?</span>
<span class="comment-copy">In this particular case, yes, but I'd like to know how to do it for the general case as well</span>
<span class="comment-copy">So in cases I want to use the 'altered' dict I'd use the <code>DictAdditional..</code> class and use the regular dict for everything else, yes?</span>
<span class="comment-copy">@musher Yes, exactly. The wrapper is imitating the original dict, slightly altering the behaviour for the special key/value pair. You could even create a <code>SpecialKeyValuePair</code> class, and override its <code>+</code> operator, so you could have almost the same notation as with string.</span>
<span class="comment-copy">Any clue where I'd find a backport of ChainMap for 3.1? Or in general</span>
<span class="comment-copy">@Mitch If you don't find something on PyPI, just <a href="https://github.com/python/cpython/blob/64c0b898c22d3e89ea03335c75580f37e606787d/Lib/collections/__init__.py#L814" rel="nofollow noreferrer">copy the code from 3.3/3.4</a>.</span>
<span class="comment-copy">This is cool. Can you do the same with <code>iteritems</code> without importing <code>itertools</code>?</span>
<span class="comment-copy">This makes a copy of the dict which the user is trying to avoid. Is it faster than dict.copy?</span>
