<div class="post-text" itemprop="text">
<p>I am writing production code that parses a large file, which itself contains many different cases. To unittest the production code, I want to write a test case for each case. My question case is what a good way is to set up the testing directory and the testing code. </p>
<p>The current directory structure is:</p>
<pre><code>root/
    src/
        parser.py
    test/
        test_parser.py
        raw/
            case_1.csv
            case_2.csv
            ...
</code></pre>
<p>The testing code looks like this:</p>
<pre><code>from parser import parse
import unittest import TestCase


class Test_Parser(TestCase):

   def setUp(self):
       raw_dir = 'raw'

   def test_case_1(self):
       filename = self.raw_dir + '/case_1.csv'
       actual = parse(filename)
       # assert actual == expected

   def test_case_2(self):
       filename = self.raw_dir + '/case_2.csv'
       actual = parser(filename)
       # assert actual == expected

   ...
</code></pre>
<p>Is there a more Pythonic way to factor the directory <code>self.raw_dir</code> out, so that the test case is cleaner and one only has to write <code>filename = 'case_1.csv'</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid writing the whole path in your test methods, which is understandable, you could isolate this in a separate method which doesn't begin with <code>_test</code> and therefore won't be called when executing the tests:</p>
<pre><code>import os
import parser
import unittest

class TestParser(unittest.TestCase):

    def setUp(self):
        self.raw_dir = "raw"

    def get_path(self, filename):
        path = os.path.join(self.raw_dir, filename)
        return path

    def file_parse(self, filename):
        # every method of this class being supposed to call
        # the parser, it makes sense to isolate these calls
        # into a specific method to avoid repetition
        # - won't be the same is the class is more general-purpose
        path = self.get_path(filename)
        actual = parser.parse(path)
        return actual

    def test_case_1(self):
        actual = self.file_parse(filename='case_1.csv')
        # assert actual == expected

    def test_case_2(self):
        actual = self.file_parse(filename='case_2.csv')
        # assert actual == expected
</code></pre>
<p>The main idea here is <strong>separation of concerns</strong>. One specific method to take care of the "putting dirs and filenames into a correct path" labour, another one to do the parsing and the test methods to do the actual tests (and only that).</p>
<p>Note that as suggested, you should use <code>os.path.join</code> (<a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow">documentation</a>) instead of hardcoding the slashes <code>/</code>.</p>
<p>Also, according to <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a>, <a href="https://www.python.org/dev/peps/pep-0008/#class-names" rel="nofollow">class names should be</a> <code>CamelCase</code>, not <code>under_score</code> or <code>A_Mix_Of_Both</code>.</p>
</div>
<span class="comment-copy">To start with, you should use <code>os.path.join</code></span>
<span class="comment-copy">Thank you for the tips and tricks. For documentation purposes, is it a good idea to move the call to the production code outside of the test cases and "hide" them in its own function?</span>
<span class="comment-copy">ok I misunderstood the question in your comment :) - in that case, it doesn't matter if you call your production code in a separate method. Because you are testing the result. The <code>assert actual == expected</code> is what you're testing, and you're calling your parser several times for that. Your class being a TestParser, it makes sense to isolate the calls to the <code>parser</code>. This won't be true if it's a more general-purpose testing class. Hope I make myself clear :)</span>
