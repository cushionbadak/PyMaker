<div class="post-text" itemprop="text">
<p>I'm new to python and currently playing with it.
I have a script which does some API Calls to an appliance. I would like to extend the functionality and call different functions based on the arguments given when calling the script.</p>
<p>Currently I have the following:</p>
<pre><code>parser = argparse.ArgumentParser()
parser.add_argument("--showtop20", help="list top 20 by app",
                    action="store_true")
parser.add_argument("--listapps", help="list all available apps",
                    action="store_true")
args = parser.parse_args()
</code></pre>
<p>I also have a </p>
<pre><code>def showtop20():
    .....
</code></pre>
<p>and</p>
<pre><code>def listapps():
....
</code></pre>
<p>How can I call the function (and only this) based on the argument given?
I don't want to run </p>
<pre><code>if args.showtop20:
   #code here

if args.listapps:
   #code here
</code></pre>
<p>as I want to move the different functions to a module later on keeping the main executable file clean and tidy.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since it seems like you want to run one, and only one, function depending on the arguments given, I would suggest you use a mandatory positional argument <code>./prog command</code>, instead of optional arguments (<code>./prog --command1</code> or <code>./prog --command2</code>).</p>
<p>so, something like this should do it:</p>
<pre><code>FUNCTION_MAP = {'top20' : my_top20_func,
                'listapps' : my_listapps_func }

parser.add_argument('command', choices=FUNCTION_MAP.keys())

args = parser.parse_args()

func = FUNCTION_MAP[args.command]
func()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are lots of ways of skinning this cat.  Here's one using <code>action='store_const'</code> (inspired by the documented subparser example):</p>
<pre><code>p=argparse.ArgumentParser()
p.add_argument('--cmd1', action='store_const', const=lambda:'cmd1', dest='cmd')
p.add_argument('--cmd2', action='store_const', const=lambda:'cmd2', dest='cmd')

args = p.parse_args(['--cmd1'])
# Out[21]: Namespace(cmd=&lt;function &lt;lambda&gt; at 0x9abf994&gt;)

p.parse_args(['--cmd2']).cmd()
# Out[19]: 'cmd2'
p.parse_args(['--cmd1']).cmd()
# Out[20]: 'cmd1'
</code></pre>
<p>With a shared <code>dest</code>, each action puts its function (<code>const</code>) in the same Namespace attribute.  The function is invoked by <code>args.cmd()</code>.  </p>
<p>And as in the documented subparsers example, those functions could be written so as to use other values from Namespace.</p>
<pre><code>args = parse_args()
args.cmd(args)
</code></pre>
<p>For sake of comparison, here's the equivalent subparsers case:</p>
<pre><code>p = argparse.ArgumentParser()
sp = p.add_subparsers(dest='cmdstr')
sp1 = sp.add_parser('cmd1')
sp1.set_defaults(cmd=lambda:'cmd1')
sp2 = sp.add_parser('cmd2')
sp2.set_defaults(cmd=lambda:'cmd2')

p.parse_args(['cmd1']).cmd()
# Out[25]: 'cmd1'
</code></pre>
<p>As illustrated in the documentation, subparsers lets you define different parameter arguments for each of the commands.</p>
<p>And of course all of these <code>add</code> argument or parser statements could be created in a loop over some list or dictionary that pairs a key with a function.</p>
<p>Another important consideration - what kind of usage and help do you want?  The different approaches generate very different help messages.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your functions are "simple enough" take adventage of <code>type</code> parameter <a href="https://docs.python.org/2.7/library/argparse.html#type" rel="noreferrer">https://docs.python.org/2.7/library/argparse.html#type</a> </p>
<blockquote>
<p>type= can take any callable that takes a single string argument and
  returns the converted value:</p>
</blockquote>
<p>In your example (even if you don't need a converted value):</p>
<pre><code>parser.add_argument("--listapps", help="list all available apps",
                    type=showtop20,
                    action="store")
</code></pre>
<p>This simple script:</p>
<pre><code>import argparse

def showtop20(dummy):
    print "{0}\n".format(dummy) * 5

parser = argparse.ArgumentParser()
parser.add_argument("--listapps", help="list all available apps",
                    type=showtop20,
                    action="store")
args = parser.parse_args()
</code></pre>
<p>Will give:</p>
<pre><code># ./test.py --listapps test
test
test
test
test
test
test
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>At least from what you have described, <code>--showtop20</code> and <code>--listapps</code> sound more like sub-commands than options. Assuming this is the case, we can use subparsers to achieve your desired result. Here is a proof of concept:</p>
<pre><code>import argparse
import sys

def showtop20():
    print('running showtop20')

def listapps():
    print('running listapps')

parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

# Create a showtop20 subcommand    
parser_showtop20 = subparsers.add_parser('showtop20', help='list top 20 by app')
parser_showtop20.set_defaults(func=showtop20)

# Create a listapps subcommand       
parser_listapps = subparsers.add_parser('listapps', help='list all available apps')
parser_listapps.set_defaults(func=listapps)

# Print usage message if no args are supplied.

# NOTE: Python 2 will error 'too few arguments' if no subcommand is supplied.
#       No such error occurs in Python 3, which makes it feasible to check
#       whether a subcommand was provided (displaying a help message if not).
#       argparse internals vary significantly over the major versions, so it's
#       much easier to just override the args passed to it.

if len(sys.argv) &lt;= 1:
    sys.argv.append('--help')

options = parser.parse_args()

# Run the appropriate function (in this case showtop20 or listapps)
options.func()

# If you add command-line options, consider passing them to the function,
# e.g. `options.func(options)`
</code></pre>
</div>
<span class="comment-copy">You could have a dictionary mapping arguments to functions <code>{'showtop20': showtop20, ...}</code> - you then update the dictionary if the functions are moved/renamed.</span>
<span class="comment-copy">I would use <code>store_const</code> instead, with a default empty function, and then call all functions in turn</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/argparse.html#sub-commands" rel="nofollow noreferrer">docs.python.org/3/library/argparse.html#sub-commands</a> - check the example that uses <code>add_subparsers</code> and <code>set_defaults</code> to link command and function.</span>
<span class="comment-copy">better to define <code>FUNCTION_MAP</code> first, and have <code>choices=list(FUNCTION_MAP)</code> to keep it dry</span>
<span class="comment-copy">Excellent idea! I changed my code. Although I prefer using <code>MAP.keys()</code> instead of <code>list(MAP)</code>, because I think that is more obvious.</span>
<span class="comment-copy"><code>choices</code> works fine with a dictionary.  It automatically uses its keys.</span>
<span class="comment-copy">Good to know. I still find it better to be explicit, but it's not a big issue :)</span>
<span class="comment-copy">@nitpick: Why? If an exception is raised in any of the functions its name (and offending linenumber) is clearly stated, e.g.: <code>File "argtest.py", line 4, in my_top20_func</code>. So I really don't see in what way debugging would be difficult, or how <code>docopt</code> would be better in that regard.</span>
<span class="comment-copy">@hpaulk, I know this has been a while and it won't specifically answer the original question, but I was looking for a way to pass multiple flags where each flag calls a specific function (rather than just a single function by overriding "dest" variables). I found the <code>action='append_const'</code> action which does just that. Would you mind adding that to your answer?</span>
<span class="comment-copy">Example gist here: <a href="https://gist.github.com/frenchtoast747/cdbdba055b649f44d0f86bc88d29b6b8" rel="nofollow noreferrer">gist.github.com/frenchtoast747/cdbdba055b649f44d0f86bc88d29b6b8</a></span>
<span class="comment-copy">Have you run this code?  <code>store_true</code> doesn't take any arguments, so <code>showtop20</code> shouldn't get executed.  It would run with the default 'store' action, but I don't think intertwining parsing and execution is a good idea.</span>
<span class="comment-copy">You're rigth 'store' action is needed, this method is a kind of hack but maybe the closest thing to the requirement.</span>
<span class="comment-copy">The important difference in your approach is that the function is executed while the parser is still active.  So multiple functions could be invoked sequentially.  In some cases that would be desirable, in others it could create debugging headaches.</span>
