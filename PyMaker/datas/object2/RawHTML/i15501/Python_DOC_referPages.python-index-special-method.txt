<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; class Thing(object):
...     def __index__(self):
...         return 1
... 
&gt;&gt;&gt; thing = Thing()
&gt;&gt;&gt; list_ = ['abc', 'def', 'ghi']
&gt;&gt;&gt; list_[thing]
'def'
&gt;&gt;&gt; dict_ = {1: 'potato'}
&gt;&gt;&gt; dict_[thing]
# KeyError
</code></pre>
<p>How does <code>thing</code> know to represent itself as 1 when accessed by a list, but not by a dict?  Don't both magic methods go through <code>__getitem__</code>?  The usage shown for lists could go through <code>__int__</code> instead so what is the <em>raison d'être</em> for <code>__index__</code> anyway?</p>
</div>
<div class="post-text" itemprop="text">
<p>Dict and List does not implement <code>__getitem__</code> the same way. Dict objects uses a comparison (<code>__eq__</code>) on <code>__hash__</code> of objects as key to use in <code>__getitem__</code>.</p>
<p>To make <code>Thing</code> usable for dict you have to implement both hash and eq.</p>
</div>
<div class="post-text" itemprop="text">
<p>@BenoîtLatinier was correct when he said:</p>
<blockquote>
<p>Dict and List does not implement <code>__getitem__</code> the same way.</p>
</blockquote>
<p>However, I'd like to add a little more information. According to the <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__">documentation</a>:</p>
<blockquote>
<p><code>object.__index__(self)</code></p>
<p>Called to implement <code>operator.index()</code>, and whenever Python needs to losslessly convert the numeric object to an integer object (<strong>such as
  in slicing</strong>, or in the built-in <code>bin()</code>, <code>hex()</code> and <code>oct()</code>
  functions). Presence of this method indicates that the numeric object
  is an integer type. Must return an integer.</p>
</blockquote>
<p>The part I bolded is important.   Indexing and slicing on a list are both handled by the same method (namely, <code>__getitem__</code>).  So, if <code>Thing.__index__</code> is called for slicing, it will likewise be called for indexing since we are using the same method.  This means that:</p>
<pre><code>list_[thing]
</code></pre>
<p>is roughly equivalent to:</p>
<pre><code>list_[thing.__index__()]
</code></pre>
<p>For the dictionary however, <code>Thing.__index__</code> is not being called (there is no reason to call it since you cannot slice a dictionary).  Instead, doing <code>dict_[thing]</code> is telling Python to find a key in the dictionary that is the <code>thing</code> instance itself.  Since this doesn't exist, a <code>KeyError</code> is raised.</p>
<p>Perhaps a demonstration will be helpful:</p>
<pre><code>&gt;&gt;&gt; class Thing(object):
...     def __index__(self):
...         print '__index__ called!'
...         return 1
...
&gt;&gt;&gt; thing = Thing()
&gt;&gt;&gt; list_ = ['abc', 'def', 'ghi']
&gt;&gt;&gt; list_[thing]  # __index__ is called
__index__ called!
'def'
&gt;&gt;&gt;
&gt;&gt;&gt; dict_ = {1: 'potato'}
&gt;&gt;&gt; dict_[thing]  # __index__ is not called
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: &lt;__main__.Thing object at 0x01ACFC70&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; dict_ = {thing: 'potato'} # Works if thing is a key
&gt;&gt;&gt; dict_[thing]
'potato'
&gt;&gt;&gt;
</code></pre>
<p>As for why <code>__index__</code> exists in the first place, the reason is thoroughly listed in <a href="https://www.python.org/dev/peps/pep-0357/">PEP 0375</a>.  I won't repeat all of it here, but basically it is so that you can allow arbitrary objects to serve as integers, which is needed in slicing as well as a few other applications.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another example to understand it further, here <a href="http://www.rdkit.org/Python_Docs/rdkit.Chem.Draw-module.html#_MolsToGridSVG" rel="nofollow noreferrer">_MolsToGridSVG</a> takes a list argument. I wanted to limit the list to some length. Now here for python list, slice indices have to be used. The following implementation solved it. Basically here index is getting used for Python List.</p>
<pre><code>def __index__(self):
    return 1

imagesInOneFile = int(len(smilesMolList) / noOfFiles)
svg = Draw._MolsToGridSVG(smilesMolList[:imagesInOneFile.__index__()], subImgSize=(400, 200), molsPerRow=2)
</code></pre>
<p>Also one needs to remember that <code>imagesInOneFile</code> has to be integer.</p>
</div>
<span class="comment-copy">For full reasoning for the <code>__index__</code> method, you can read <a href="https://www.python.org/dev/peps/pep-0357/" rel="nofollow noreferrer">PEP 357</a>. Basically, <code>__int__</code> coerces the result to an integer type. Imagine if you wrote something like <code>x[3.2:5.8]</code>. This should raise an error, and in Python it does. However, if the indexing logic used <code>__int__</code>, it would coerce the slice values to <code>3</code> and <code>5</code>, and the code would not raise an error.</span>
