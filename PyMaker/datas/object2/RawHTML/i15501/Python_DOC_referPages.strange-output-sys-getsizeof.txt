<div class="post-text" itemprop="text">
<p>I just ran these codes:</p>
<pre><code>v = [1,2,'kite',100**100]

for x,y in enumerate(v):
    print ("{} size is: {}".format(y,sys.getsizeof(v[x])))
print ("Total size is: {} ".format(sys.getsizeof(v)))
</code></pre>
<p>Output:</p>
<pre><code>1 size is: 14
2 size is: 14
kite size is: 29
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 size is: 102
Total size is: 52 
&gt;&gt;&gt;
</code></pre>
<p>The last element of v's size is 102, and total size is 52? Also even without the last element, still sum of the first 3 elements of the list is bigger than total size, my question is why? Python doing a zip process in lists ?</p>
<p>Another strange thing is, between this outputs; </p>
<pre><code>v = [""]

for x,y in enumerate(v):
    print ("{} size is: {}".format(y,sys.getsizeof(v[x])))
print ("Total size is: {} ".format(sys.getsizeof(v)))

v=[" "]
for x,y in enumerate(v):
    print ("{} size is: {}".format(y,sys.getsizeof(v[x])))
print ("Total size is: {} ".format(sys.getsizeof(v)))
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; 
 size is: 27
Total size is: 40 
  size is: 26
Total size is: 40 
&gt;&gt;&gt;
</code></pre>
<p>It is really strange, can anyone explain what's going on?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/sys.html" rel="nofollow">documentation</a> (my bold) <sup>(a)</sup>:</p>
<blockquote>
<p>Only the memory consumption <strong>directly attributed</strong> to the object is accounted for, <strong>not the memory consumption of objects it refers to.</strong></p>
</blockquote>
<p>So the size of <code>v</code> does <em>not</em> include the sizes of the elements it refers to.</p>
<p>If you change <code>kite</code> into <code>kites</code>, you'll <em>also</em> see that its size increases but <em>not</em> the size of <code>v</code> (I've replaced your big number with <code>100...00</code> in the output to ease formatting):</p>
<pre><code>1 size is: 12
2 size is: 12
kite size is: 25
100...00 size is: 102
Total size is: 48

1 size is: 12
2 size is: 12
kites size is: 26
100...00 size is: 102
Total size is: 48
</code></pre>
<p>Think of it like this:</p>
<pre><code>       /  +-----+
      | v | ref | -&gt; 1
Size  |   | ref | -&gt; 2
 of v |   | ref | -&gt; 'kite'
      |   | ref | -&gt; 100**100
       \  +-----+
                     \___________________________/
                      Size of things referred
                       to by v
</code></pre>
<hr/>
<p><sup>(a)</sup> That page also has a link to a recipe for doing recursive size calculations if you need that information. The link is duplicated <a href="http://code.activestate.com/recipes/577504/" rel="nofollow">here</a> for citation, and the code is duplicated below to make this answer more self-contained.</p>
<p>Plugging your structure into that code gives:</p>
<pre><code>48 &lt;type 'list'&gt; [1, 2, 'kites', 100...00L]
12 &lt;type 'int'&gt; 1
12 &lt;type 'int'&gt; 2
26 &lt;type 'str'&gt; 'kites'
102 &lt;type 'long'&gt; 100...00L
200
</code></pre>
<hr/>
<p>The code, with your structure, is shown below.</p>
<pre><code>from __future__ import print_function
from sys import getsizeof, stderr
from itertools import chain
from collections import deque
try:
    from reprlib import repr
except ImportError:
    pass

def total_size(o, handlers={}, verbose=False):
    """ Returns the approximate memory footprint an object and all of its contents.

    Automatically finds the contents of the following builtin containers and
    their subclasses:  tuple, list, deque, dict, set and frozenset.
    To search other containers, add handlers to iterate over their contents:

        handlers = {SomeContainerClass: iter,
                    OtherContainerClass: OtherContainerClass.get_elements}

    """
    dict_handler = lambda d: chain.from_iterable(d.items())
    all_handlers = {tuple: iter,
                    list: iter,
                    deque: iter,
                    dict: dict_handler,
                    set: iter,
                    frozenset: iter,
                   }
    all_handlers.update(handlers)     # user handlers take precedence
    seen = set()                      # track which object id's have already been seen
    default_size = getsizeof(0)       # estimate sizeof object without __sizeof__

    def sizeof(o):
        if id(o) in seen:       # do not double count the same object
            return 0
        seen.add(id(o))
        s = getsizeof(o, default_size)

        if verbose:
            print(s, type(o), repr(o), file=stderr)

        for typ, handler in all_handlers.items():
            if isinstance(o, typ):
                s += sum(map(sizeof, handler(o)))
                break
        return s

    return sizeof(o)


##### Example call #####

if __name__ == '__main__':
    v = [1,2,'kites',100**100]
    print(total_size(v, verbose=True))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This happens because your "Total size" is actually the size of the list structure without the contents.  So you can store an object of any size there and it won't change your "Total size."  You need a "recursive" getsizeof(), and for that, see here: <a href="https://stackoverflow.com/questions/2117255/python-deep-getsizeof-list-with-contents">Python deep getsizeof list with contents?</a> or here: <a href="https://stackoverflow.com/questions/14208410/deep-version-of-sys-getsizeof">Deep version of sys.getsizeof</a></p>
</div>
<span class="comment-copy">Someone else just asked the same question: <a href="http://stackoverflow.com/questions/27559730/memory-consume-by-a-list-and-its-element" title="memory consume by a list and its element">stackoverflow.com/questions/27559730/â€¦</a></span>
