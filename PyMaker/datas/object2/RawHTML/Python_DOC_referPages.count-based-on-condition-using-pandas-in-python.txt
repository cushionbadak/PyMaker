<div class="post-text" itemprop="text">
<p>I'm using <code>pandas</code>, and I want to count the number of rows that match certain condition, but I want to count in different levels. What I mean is that I have a table that looks more or less like this (simplified version, original one has many more columns):</p>
<pre><code>Value   ID    Method 
 CR     01    Basic
 CD     03    Advanced
 PD     03    Advanced
 PD     02    Advanced
 CR     02    Basic
</code></pre>
<p>Now, I want to group things by <code>ID</code>, as in my new Excel that I will create each column will correspond to it. So, I want to count how many rows have <code>Method</code> of <code>Basic</code> and how many <code>Advanced</code>, and then in turn I want to count how many of those <code>Basic</code> have value <code>CR</code>, <code>CD</code>, or <code>PD</code>. Simply, at the end I will create a new Excel sheet that looks like this:</p>
<pre><code>ID          01      02      03
Total       1       2       2
Basic       1       1       0
CR          1       1       0
CD          0       0       0
PD          0       0       0
Advanced    0       1       2
CR          0       0       0
CD          0       0       1
PD          0       1       1
</code></pre>
<p>I started simply as follows:</p>
<pre><code>import pandas as pd

df = pd.read_excel('./myfile.xlsx')

method = ['Basic', 'Advanced']
value = ['CR', 'CD', 'PD']

grouped = df.groupby(['ID'], as_index=False)

results = []
for _, g in grouped:
    values = []
    for m in method:
        values.append(sum(g['Method'] == m))
    results.append(values)
</code></pre>
<p>So, this groups everything by <code>ID</code> as I want, and then counts the rows for each grouped entry by the <code>Method</code>, I guess I can also include a third loop and also check for <code>Value</code> column. But, I guess this becomes a bit cumbersome at some point, also what if I have 4 levels afterwards? What's a better or recommended way to handle this in <code>pandas</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>As I said using <code>crosstab</code></p>
<pre><code>s1 = pd.crosstab(df.Method, [df.ID, df.Value]).stack().fillna(0)
s = pd.concat([y.sum(level=0).append(y) for x, y in s1.groupby(level=0)])
s=s.sum().div(2).to_frame('Total').T.append(s)
s
#s.index=[x[-1]if type(x)==tuple else x for x in s.index.tolist() ]
Out[913]: 
ID               01   02   03
Total           1.0  2.0  2.0
Advanced        0.0  1.0  2.0
(Advanced, CD)  0.0  0.0  1.0
(Advanced, CR)  0.0  0.0  0.0
(Advanced, PD)  0.0  1.0  1.0
Basic           1.0  1.0  0.0
(Basic, CD)     0.0  0.0  0.0
(Basic, CR)     1.0  1.0  0.0
(Basic, PD)     0.0  0.0  0.0
</code></pre>
</div>
<span class="comment-copy">this looks like a job for <code>pivot</code></span>
<span class="comment-copy">This is more like a <code>crosstab</code> problem , you just need base on the result create the result</span>
<span class="comment-copy">@Wen-Ben can you give an example code about it?</span>
<span class="comment-copy">Notice I did not remove the tuple in index , which will make it easier to tell the relation between set and subset .</span>
<span class="comment-copy">Thank you, this seems good, except the total value is wrong. What I see is that total is double the actual total. You should have 1, 2, 2 for totals, respectively. Total is simply, <code>Basic + Advanced</code>.</span>
<span class="comment-copy">Try <code>s.index=[x[-1]if type(x)==tuple else x for x in s.index.tolist() ]</code> @terett</span>
<span class="comment-copy">Thank you! It works nicely.</span>
