<div class="post-text" itemprop="text">
<p>What is H2O.ai data parsing doing exactly?</p>
<pre><code>Import h2o
h2o.init()
df = h2o.import_file(path=myfilepath)
</code></pre>
<p>When I run the above code I get the below output which takes a while ...</p>
<pre><code>Parse progress: [###################################] 100%
</code></pre>
<p>When I run this on 2GB of data, my memory increases by roughly 2GB.  I thought that H2O.ai was supposed to use lazy evaluation?  It almost seems like a lot of information is being stored in memory (maybe even the entire dataset) and clearly this is not a lazy evaluation because it take a while to run.  </p>
<p>The H2O.ai documentation is not very helpful either.</p>
<p><a href="http://docs.h2o.ai/h2o/latest-stable/h2o-py/docs/h2o.html#h2o.import_file" rel="nofollow noreferrer">http://docs.h2o.ai/h2o/latest-stable/h2o-py/docs/h2o.html#h2o.import_file</a></p>
<p><a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-munging/importing-data.html" rel="nofollow noreferrer">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-munging/importing-data.html</a></p>
<p>Does anyone understand exactly what is happening here?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not lazy evaluation.</p>
<p>It is reading in the data and storing the data in a column-compressed in-memory distributed key-value store.</p>
<p>Here is a good picture describing the overall process:</p>
<ul>
<li><a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/architecture.html#how-r-and-python-interacts-with-h2o" rel="nofollow noreferrer">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/architecture.html#how-r-and-python-interacts-with-h2o</a></li>
</ul>
</div>
<span class="comment-copy">If I'm running on a single node using data that's larger than my amount of memory, how is it handling this?  (I read the h2o doc you provided and I'm missing how it handles this situation).  Is it storing everything in memory just compressed?  Does it spill to disk?</span>
<span class="comment-copy">It does store data compressed in-memory.  It does not spill to disk.  If the java heap really fills up with live objects and GC does not free any, then the job will die and you need to add more physical memory and make the java heap bigger.  Or add nodes and operate in cluster mode.  (Or reduce data.)</span>
