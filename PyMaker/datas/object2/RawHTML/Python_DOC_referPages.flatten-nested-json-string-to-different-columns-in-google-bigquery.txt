<div class="post-text" itemprop="text">
<p>I have column in one of the BigQuery table which looks like this.</p>
<pre><code>{"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}}
</code></pre>
<p>Is there any was to get the output like this in GBQ ?? (basically flatten the entire column into different columns)</p>
<pre><code>name    last_delivered.push_id   last_delivered.time   session_id   source   properties.UserId

name1       push_id1                     time1         session_id1   SDK          uid1
</code></pre>
<p>Let's say </p>
<blockquote>
<p>a = {"name": "name1", "last_delivered": {"push_id": "push_id1",
  "time": "time1"}, "session_id": "session_id1", "source": "SDK",
  "properties": {"UserId": "u1"}}</p>
</blockquote>
<p>I have tried to get desired output in Pandas Python using <strong>json_normalize(a)</strong> , but every time I try get the following error </p>
<p><a href="https://i.stack.imgur.com/2s1Ye.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/2s1Ye.png"/></a></p>
<p>Does anyone has any idea how can I get my desired output. Am I missing something ??</p>
<p>Any help would be greatly appreciated!!</p>
</div>
<div class="post-text" itemprop="text">
<p>Below example is for BigQuery Standard SQL   </p>
<pre><code>#standardSQL
WITH `project.dataset.table` AS (
  SELECT '{"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}}' col
)
SELECT 
  JSON_EXTRACT_SCALAR(col, '$.name') name,
  STRUCT(
    JSON_EXTRACT_SCALAR(col, '$.last_delivered.push_id') AS push_id,
    JSON_EXTRACT_SCALAR(col, '$.last_delivered.time') AS time
  ) last_delivered,
  JSON_EXTRACT_SCALAR(col, '$.session_id') session_id,
  JSON_EXTRACT_SCALAR(col, '$.source') source,
  STRUCT(
    JSON_EXTRACT_SCALAR(col, '$.properties.UserId') AS UserId
  ) properties
FROM `project.dataset.table`   
</code></pre>
<p>and produces result as expected/asked  </p>
<pre><code>Row name    last_delivered.push_id  last_delivered.time session_id  source  properties.UserId    
1   name1   push_id1                time1               session_id1 SDK     u1     
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My guess as to why it's not working is that your json data is actually a string:</p>
<pre><code>from pandas.io.json import json_normalize 

a = '''{"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}}'''  

df = json_normalize(a)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>AttributeError: 'str' object has no attribute 'values'    
</code></pre>
<p>Versus:</p>
<pre><code>from pandas.io.json import json_normalize 

a = {"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}}  

df = json_normalize(a)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code> print(df.to_string())
  last_delivered.push_id last_delivered.time   name properties.UserId   session_id source
0               push_id1               time1  name1                u1  session_id1    SDK
</code></pre>
<p>If this is the case, you can use <code>json.loads()</code> right before normalize:</p>
<pre><code>import json
from pandas.io.json import json_normalize

a = '''{"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}}'''  

data = json.loads(a)
df = json_normalize(data)
</code></pre>
</div>
<span class="comment-copy">I copied your code into Spyder 3.6 and it works as you want it to: from pandas.io.json import json_normalize a = {"name": "name1", "last_delivered": {"push_id": "push_id1", "time": "time1"}, "session_id": "session_id1", "source": "SDK", "properties": {"UserId": "u1"}} b = json_normalize(a) b Out[5]:    last_delivered.push_id last_delivered.time  ...     session_id source 0               push_id1               time1  ...    session_id1    SDK</span>
<span class="comment-copy"><code>json_normalize</code> works for me.</span>
<span class="comment-copy">works fine for me as well</span>
<span class="comment-copy">You have a low rate. Important on SO - you can <code>mark accepted answer</code> by using the tick on the left of the posted answer, below the voting. See <a href="http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work#5235" title="how does accepting an answer work%235235">meta.stackexchange.com/questions/5234/â€¦</a> for why it is important! Also important to <code>vote on answer</code>. Vote up answers that are helpful. ... You can check about what to do when someone answers your question - <a href="http://stackoverflow.com/help/someone-answers">stackoverflow.com/help/someone-answers</a>. Following these simple rules you increase your own reputation score and at the same time you keep us motivated to answer your questions :o) please consider!</span>
<span class="comment-copy">I knew this solution, but I want the columns to be dynamic. Let's say for other rows there are more properties and for some of them there are less values. I didn't go for this because it's too manual I feel. Well, if nothing works this is the only solution I should go for. Thanks, anyways :)</span>
<span class="comment-copy">I've answered your current question. if you have new question - please post it as new question and we will see if we can help you. Meantime, consider at least voting up the answer.</span>
<span class="comment-copy">Thanks Mikhail. Any thought on whether it is possible in google big query ??...dynamic flatten.</span>
<span class="comment-copy">usually this type of things are done with client of your choice, like python. if you want this to be done purely in BQ - you will need to approach it in two steps - first to generate sql text and then execute it. I think this two-steps approach will be doable  - but because of limited json support for bq  - it will be over-complicated  - so I think using client approach - is the way to go</span>
<span class="comment-copy">This works fine, thanks mate!!....but, I have scaled down the problem here. Let's say we have a data frame with one column having such values. <b>json.loads()</b> accepts only a single string value. I know I can keep it in a <b>for</b> loop, but the problem is the data frame has millions of rows....I think it will take a lot of time if we go by this way. Any other way ??...have been trying from my side too.</span>
<span class="comment-copy">Just tested with 10k rows by keeping it in <b>for</b> loop...god! it took more than ~30 min. Well, the output is what I am expecting. There are more than million rows for each day and I wanted to do this on daily basis. With the computing power of BQ machines I strongly feel those machines can do a lot faster, provided the feasibility should be there.</span>
