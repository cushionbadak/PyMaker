<div class="post-text" itemprop="text">
<p>I'm trying to make a script that can be run from the command line that:</p>
<ol>
<li>Starts a RESTful service with a few endpoints.</li>
<li>Launches a bunch of remote scripts through ssh which send basic JSON data back to the python script. (I've no control over what these send or how they do it. They are REST clients, they send JSON.)</li>
<li>Once it has received certain data from those endpoints, the service bit shuts down and the script continues on to do non-REST stuff with the received data.</li>
<li>Script shuts down.</li>
</ol>
<p>All the examples I've seen re REST and python involve starting REST servers that stay alive. (For example Flask). While it looks like one could install a cherryPy framework over flask and then shutdown the server app I'm wondering if there's an easier way for something simple.</p>
<p>Are there any ways to do this? Preference for solutions that don't require installation of big frameworks to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well - no answers so I guess there isn't a pre-rolled way to do this. For posterity I rolled my own solution similar to this contrived version.</p>
<p>So here we go. Script that 1) starts a rest server, 2) would spawn external clients that do stuff and report back to (1), 3) shuts the server down when all data is received and continues.</p>
<p>Basically, since this script is going to be run on the command line, it should use the ephemeral port (otherwise multiple people running it simultaneously would port conflict.) The server is just an http.server in a thread that has a few callbacks to grab events, and uses a threadsafe queue.Queue to communicate events originating on the server to the main thread. That lets us know when to shut down the server.</p>
<pre><code>import json
import threading
import http.server
import logging
from queue import Queue
q = Queue()
EPHEMERAL_PORT = 0
num_events = 0
MAX_EVENTS = 3

class TinyRESTHandler(http.server.BaseHTTPRequestHandler):

    def __init__(self, service_map, *args):
        self.service_map = service_map
        http.server.BaseHTTPRequestHandler.__init__(self, *args)

    def respond(self, code, message):
        self.send_response(code)
        self.send_header("Content-Type", "text/ascii")
        self.send_header("Content-Length", str(len(message.encode())))
        self.end_headers()
        self.wfile.write(message.encode())

    def handle_POST(self, json_handler):
        """
        Route POST requests to the appropriate handler.
        """
        payload = self.rfile.read(int(self.headers['Content-Length']))
        try:
            json_payload = json.loads(payload)
            json_handler(self.path, json_payload)
        except json.decoder.JSONDecodeError as e:
            self.respond(400, "Bad Request: Invalid JSON")

        self.respond(200, "OK")

    def do_POST(self):
        if (self.path in self.service_map):
            self.handle_POST(self.service_map[self.path])
        else:
            self.respond(404, "Not Found")


class EphemeralHTTPServer(http.server.HTTPServer):
    """
    We cannot know the port used by an Ephemeral HTTP server until
    it has tried to bind a port (at which point the OS gives it a
    free port.) This adds a callback to the bind function that allows
    us to be notified as soon as a port has been obtained.
    """
    def __init__(self, hostname, port_notify_cb, *args, **kwargs):
        self.port_notify_cb = port_notify_cb
        super().__init__((hostname, EPHEMERAL_PORT), *args, **kwargs)


    def server_bind(self):
        """
        The server will notify port_notify_cb of its address
        once it has bound a port.
        """
        super().server_bind()
        if (self.port_notify_cb):
            self.port_notify_cb(self.server_address)


class TinyRESTServer():
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.service_map = dict()

    def register_service(self, path, callback):
        self.service_map[path] = callback

    def get_handler(self, *args):
        """
        HTTPServer creates a new handler for every request. This ensures
        that the TinyRESTHandlers are supplied with the service map.
        """
        return TinyRESTHandler(self.service_map, *args)

    def getHTTPServer(self):
        return http.server.HTTPServer((self.host, self.port), self.get_handler)

    def run(self):
        """
        The server_close call forces HTTPServer to relinquish its port.
        """
        self.server = self.getHTTPServer()
        try:
            self.server.serve_forever()
        finally:
            self.server.server_close()

    def shutdown(self):
        self.server.shutdown()        

class EphemeralRESTServer(TinyRESTServer):
    def __init__(self, host, address_cb):
        self.address_cb = address_cb
        super().__init__(host, 0)


    def getHTTPServer(self):
        return EphemeralHTTPServer(self.host, self.address_cb, self.get_handler)

class ServerEvent:

    def __init__(self, name):
        self.name = name

class PortAcquiredEvent(ServerEvent):
    def __init__(self, hostname, port):
        super().__init__("port acquired")
        self.hostname = hostname
        self.port = port

    def __str__(self):
        return f"{self.name}: (host, port) = ({self.hostname}, {self.port})"

class JSONEvent(ServerEvent):
    def __init__(self, json_content):
        super().__init__("JSON results")
        self.json_content = json_content

    def __str__(self):
        return f"{self.name}: {self.json_content}"



def get_server_address(server_address):
    """
    When the server binds an ephemeral port, it will call this
    function to tell us what port the OS provided. Using a queue
    ensures that the main prog doesn't try to get the port before
    the HTTP server in the thread has successfully obtained one.
    """
    q.put(PortAcquiredEvent(server_address[0], server_address[1]))


def add_to_queue(req_type, json_content):
    """
    Contrived REST service handler.
    """
    q.put(JSONEvent(json_content))

def check_if_we_should_stop_the_server(event):
    """
    Contrived function to test when we should stop the http server
    and do something with the received data.
    """
    global num_events
    global MAX_EVENTS
    print(event)
    num_events += 1
    return num_events &lt; MAX_EVENTS


# Start an HTTP server, in a thread, on port 0.
server = EphemeralRESTServer("localhost", get_server_address)
server.register_service('/post_server_info', add_to_queue)
server_thread = threading.Thread(None, server.run)
server_thread.start()

"""
Do something here to cause rest clients to start hitting this
server (for example invoking the clients via subprocess or
whatevs.)
"""

# Block until the queue obtains a value.
cur_val = q.get()
while check_if_we_should_stop_the_server(cur_val):
    cur_val = q.get()

# Stop the HTTP server.
server.shutdown()
server_thread.join()

# Do normal script stuff with the data...
</code></pre>
<p>It started out 'tiny' okay? Hence the name.</p>
</div>
<span class="comment-copy">How do you know that you have gotten all the data that you want? Would it be feasible to add this as part of your server's state, and then you can just add code to shutdown the server once the condition is met.</span>
<span class="comment-copy">Of course that would be the pattern. Was just wondering what options are out there to deal with this already. Currently I'm rolling a BaseHTTPServer to do it.</span>
<span class="comment-copy">Your "server" should not be part of a script. Spin up the server from your script and shut it down when you need to, but the server should be a server, not an all-encompassing script. Just my 2-cents</span>
<span class="comment-copy">Why? It's just a script that happens to want to wait for data from rest clients rather than, say, a file or something.</span>
<span class="comment-copy">I think that, if you're willing to install it, using Pyramid as a framework would simplify your code quite a bit (see <a href="https://trypyramid.com/" rel="nofollow noreferrer">trypyramid.com</a> )</span>
