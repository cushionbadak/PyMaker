<div class="post-text" itemprop="text">
<p>Can anybody explain me whats wrong i am doing here - </p>
<pre><code>multiArray = [
    ['one', 'two', 'three', 'four', 'five'],
    ['one', 'two', 'three', 'four', 'five'],
    ['one', 'two', 'three', 'four', 'five']
]
search ='four'
p1 = list(filter(lambda outerEle: search == outerEle, multiArray[0]))
p = list(filter(lambda multiArrayEle: list(filter(lambda innerArrayEle: search == innerArrayEle, multiArrayEle)), multiArray))
print (p1)
print (p)
</code></pre>
<p>The result i am getting here is </p>
<pre><code>['four']
[['one', 'two', 'three', 'four', 'five'], ['one', 'two', 'three', 'four', 'five'], ['one', 'two', 'three', 'four', 'five']]
</code></pre>
<p>while i am expecting </p>
<pre><code>[['four'],['four'],['four']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While @fuglede's answer is really the answer to your question, you can archive the result you want by changing your outer <code>filter</code> to <code>map</code>:</p>
<pre><code>p = list(map(lambda multiArrayEle: list(filter(lambda innerArrayEle: search == innerArrayEle, multiArrayEle)), multiArray))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your second <code>filter</code>, you are using a <code>list</code> as a predicate (as opposed to simply a <code>bool</code> as you do in the first <code>filter</code>); now, this implicitly applies the built-in method <code>bool</code> to each element <code>list</code>, and for a list <code>l</code>, <code>bool(l)</code> is true exactly when <code>l</code> is non-empty:</p>
<pre><code>In [4]: bool([])
Out[4]: False

In [5]: bool(['a'])
Out[5]: True
</code></pre>
<p>This allows you to pick out, for example, all the non-empty lists in a list of lists:</p>
<pre><code>In [6]: ls = [['a'], [], ['b']]

In [7]: list(filter(lambda l: l, ls))
Out[7]: [['a'], ['b']]
</code></pre>
<p>Thus, in your case, at the end of the day, your <code>filter</code> ends up giving you all lists for which <code>'four'</code> appears, which is all of them.</p>
<p>From your given example, it's not immediately obvious what you are trying to achieve as all the inputs are identical, but my guess is that it's something like the following:</p>
<pre><code>In [19]: multiArray = [
    ...:     ['one', 'two', 'three', 'four', 'five', 'four'],
    ...:     ['one', 'two', 'three', 'for', 'five'],
    ...:     ['one', 'two', 'three', 'four', 'five']
    ...: ]

In [20]: [list(filter(lambda x: x == search, l)) for l in multiArray]
Out[20]: [['four', 'four'], [], ['four']]
</code></pre>
</div>
<span class="comment-copy">You're trying to do <i>far</i> too much stuff in a single line. When you have a lambda in a lambda <i>and</i> your code doesn't work, that's a sign that you should split your code into more, shorter, readable lines.</span>
<span class="comment-copy">Thanks Bohdan. This is what i was looking for.</span>
<span class="comment-copy">Thanks for your quick reply. However what if i want to use lambda inside lambda. You might understood what i want to achieve. I want to search all lists inside a list for a particular word and want to get that searched list.</span>
