<div class="post-text" itemprop="text">
<p>First of all, I ask this question by pure curiosity to see some great one-liners skills. The <code>sum()</code> function remains the best function to sum objects in a list.</p>
<p>But as said, I ask by pure curiosity: Is there a way to sum objects from a <code>list</code> (obviously, without using <code>sum()</code>) in one line? Let's say the list would be <code>range(0, 100)</code></p>
<p>I have absolutely no idea how this could be achieved, but as Python is really great and flexible, so I have no doubt it is possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, here's a solution that needs no no built-in functions at all. It's basically a reimplentation of <code>reduce</code>, using a bit of lambda magic.</p>
<pre><code>&gt;&gt;&gt;&gt;(lambda f: lambda *args: f(f, *args))(lambda self, f, seq, d: d if not seq else f(seq[0], self(self, f, seq[1:], d)))(lambda a,b: a+b, range(100), 0)
4950
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can take a functional approach, using <a href="https://docs.python.org/2/library/functions.html#reduce" rel="noreferrer"><code>reduce</code></a> and an addition function (e.g. a <a href="https://docs.python.org/2/tutorial/controlflow.html#lambda-expressions" rel="noreferrer"><code>lamdba</code> expression</a> or <a href="https://docs.python.org/2/library/operator.html#operator.add" rel="noreferrer"><code>operator.add</code></a>):</p>
<pre><code>&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; reduce(add, range(0, 100))
4950
</code></pre>
<p><em>(Note that in 3.x you need to <code>from functools import reduce</code> first.)</em></p>
<p>Per the documentation, <code>reduce(function, iterable)</code> will</p>
<blockquote>
<p>Apply <code>function</code> of two arguments cumulatively to the items of <code>iterable</code>, from left to right, so as to reduce the <code>iterable</code> to a single value.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Python may not be the best language for recursive approaches because (1) it doesn't support tail-recursion (2) function calls are really expensive (3) the recursion limit prevents deep recursions and (4) slicing sequences scales with <code>O(n)</code> (where <code>n</code> is the number of elements in the slice).</p>
<p>However you can use them for one-liners! </p>
<p>One approach would be just to successivly pop and add the first element until the sequence is exhausted:</p>
<pre><code>&gt;&gt;&gt; sum_func = lambda x: x[0] + sum_func(x[1:]) if x else 0
&gt;&gt;&gt; sum_func(range(100))
4950
</code></pre>
<p>The first part is triggered as long as <code>if x</code> (<a href="https://stackoverflow.com/q/53513/5393381">that is to say <code>x</code> is not empty</a>). This approach shows all the shortcomings of using recusion in Python: It hits the recursion limit for sequences of length ~300, it scales with <code>O(n**2)</code> and it's really slow compared to the built-in <code>sum</code> and <code>reduce</code> approach.</p>
<p>One can mitigate one of the disadvantages by using a divide-and-conquer recursion approach:</p>
<pre><code>&gt;&gt;&gt; sum_func = lambda x: sum_func(x[:len(x)//2]) + sum_func(x[len(x)//2:]) if len(x) &gt; 1 else x[0]
&gt;&gt;&gt; sum_func(range(100))
4950
</code></pre>
<p>This time it recurses on both halfs of the list, thereby reducing the recusion depth from <code>n</code> to <code>log2(n)</code>, so it can handle even longer sequences. However it's not faster than the one above.</p>
<hr/>
<p>And of course there's always the cheat option:</p>
<pre><code>&gt;&gt;&gt; from numpy import sum
&gt;&gt;&gt; sum(range(100))
4950
</code></pre>
<p>In case you really want it really fast :-)</p>
</div>
<span class="comment-copy">Wow, That was the kind of thing I was thinking. I'll need my time to understand that one!</span>
<span class="comment-copy">Well, I didn't expected something so short, I'll let the thread open for some times to see some other proposals, even if this one is really KISS</span>
<span class="comment-copy">@CarlierRobin how long a <i>"one-line... implementation"</i> were you expecting?</span>
<span class="comment-copy">You can also replace <code>add</code> with <code>lambda x, y: x + y</code>, so that this does not even need imports in Python 2.</span>
<span class="comment-copy">@CarlierRobin maybe you should look at <a href="https://codegolf.stackexchange.com">codegolf.stackexchange.com</a>. You know, just for fun.</span>
<span class="comment-copy">@EricDuminil just moved; as I say in the question you can still import it from within the standard library. <a href="https://docs.python.org/3/whatsnew/3.0.html#builtins" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.0.html#builtins</a></span>
<span class="comment-copy">It looks fun, but it's <code>O(n**2)</code>, right?</span>
<span class="comment-copy">@EricDuminil yes, because slicing is <code>O(n)</code>. But that's not going to matter much because before that's significant the function hits the recursion limit. And the constant factor (repeatedly calling the function) is huge.</span>
