<div class="post-text" itemprop="text">
<p>Say I want to <code>print 1 + 1</code> on stdout (i.e. <strong>one-liner coding</strong>).</p>
<p>With <code>awk</code> I could do it simply with:</p>
<pre><code>$ echo | awk '{print 1+1}'
2
</code></pre>
<p>How to do this with python?</p>
</div>
<div class="post-text" itemprop="text">
<p>As ifLoop pointed out, what you're looking for here is <a href="https://docs.python.org/3/using/cmdline.html?highlight=command%20line#cmdoption-c" rel="nofollow"><code>-c</code></a>.</p>
<p>But, as yo've discovered, <code>python -c</code> often isn't as useful as the corresponding <code>awk</code> (or <code>sed</code> or <code>bash</code> or <code>perl</code> or even <code>ruby</code>) for one-liners.</p>
<p>Python is explicitly designed to value readability over brevity and explicitness over implicitness (along with some correlated tradeoffs, like vocabulary over syntax, as little magic as possible, etc.). See <a href="http://legacy.python.org/dev/peps/pep-0020/" rel="nofollow">the Zen of Python</a>. There are intentional limits to what you can cram onto one line, and things like looping over stdin and/or command-line args have to be done explicitly with, e.g., <code>sys.stdin</code> and <code>sys.argv</code>, or <code>fileinput.input()</code>.</p>
<p>That means that some very trivial scripts become less trivial to write in Python, but that's considered a good tradeoff for making even moderately non-trivial scripts easier to write, maintain, and understand.</p>
<p>The core developers understand this means you can't rewrite a lot of one-liners in Python. And if you asked them, most of them will ask why that's a problem at all. </p>
<p>If you know how to write something as a one-liner in a language like <code>sed</code> or <code>awk</code>, then you should be writing it as a one-liner in <code>sed</code> or <code>awk</code>. Those are perfectly good languages that are handy for all kinds of simple tasks, and there's no reason to avoid them just because Python is also a good language.</p>
<p>If you can't figure your way through the syntax to write that one-liner… well, it probably shouldn't be a one-liner. The only reason you want to try it in Python is that Python is generally easier to write and read, and the same reasons that's true are the same reasons Python won't let you write what you want without 3 lines. So just write the 3 lines. Python is great for that.</p>
<p>So, what you often <em>really</em> want is not <code>-c</code>, but a <a href="http://en.wikipedia.org/wiki/Here_document" rel="nofollow">heredoc</a>, or just a separate script that you run like any other program, or <code>awk</code> or <code>perl</code> instead of <code>python</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>you are looking for <a href="https://docs.python.org/3/using/cmdline.html?highlight=command%20line#cmdoption-c"><code>-c</code></a>:</p>
<pre><code>$ python -c 'print 1 + 1'
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you're in the shell, the next would basic integer math</p>
<pre><code>echo $((1+1))
echo $(( 100 / 5 ))
</code></pre>
<p>etc...</p>
<p>for floating point, yes, you should to use <code>awk</code>, or <code>bc</code>, or <code>dc</code>, or any other language what knows floating point math...</p>
<p>also, read this: <a href="https://stackoverflow.com/a/450853/632407">https://stackoverflow.com/a/450853/632407</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by the <a href="https://stackoverflow.com/a/25857370/17523">answer by IfLoop</a> I wondered about the handy <code>BEGIN</code> and <code>END</code> blocks in awk. I have found the <a href="https://pypi.python.org/pypi/pawk/0.5" rel="nofollow noreferrer">pawk module</a></p>
<pre><code>    ls -l | awk 'BEGIN {c = 0} {c += $5} END {print c}'
    ls -l | pawk -s -B 'c = 0' -E 'c' 'c += int(f[4])'
</code></pre>
<p>Looks promising, but I have never tried this (yet)</p>
</div>
<div class="post-text" itemprop="text">
<p>Like <a href="https://stackoverflow.com/a/25857370/2909897">SingleNegationElimination's</a> answer recommend's, the <code>-c</code> flag is the right tool for the job.</p>
<p>Here are some examples using awk, ruby, and python:</p>
<pre><code>echo foo bar baz | awk '{ split($0, arr, " "); print arr[NF] }'
baz
echo foo bar baz | ruby -e 'puts STDIN.read.chomp.split(" ")[-1]'
baz
echo foo bar baz | python -c 'import sys; print sys.stdin.read().rstrip().split(" ")[-1]'
baz
</code></pre>
</div>
<span class="comment-copy">With <code>awk</code> you don't need <code>echo</code>. Use <code>BEGIN</code>. <code>awk 'BEGIN{print 1+1}'</code></span>
<span class="comment-copy">Note that Python isn't nearly as useful for one-liners as <code>awk</code>… but it's a lot more useful for, e.g., 5-liners, so you tend to see it used with HEREdoc scripts more than with inline scripts. (But you <i>can</i> use it for inline scripts, as IfLoop's answer shows.)</span>
<span class="comment-copy">@chepner Can you please elaborate on why <code>END</code> is more efficient than <code>BEGIN</code>? AFAIK both runs exactly once, with former after the input has been read and former before the input has been read.</span>
<span class="comment-copy">@jaypal It isn't; I posted my comment before I saw yours appear, and just happened to use <code>END</code> instead of <code>BEGIN</code>. "More efficient" just refers to ignoring the (empty) standard input in place of starting a second process to provide input that is to be ignored anyway, not the choice between <code>BEGIN</code> and <code>END</code>.</span>
<span class="comment-copy">@Cawas: Python is explicitly designed to value readability over brevity and explicitness over implicitness. There are limits to what you can cram onto one line; things that would be syntax in awk (or sed or perl) are vocabulary in Python, possibly not even built-in; there is very little magic for things like stdin or command-line args; etc. So no, Python will never be as useful as awk for one-liners.</span>
<span class="comment-copy">I'd argue a lot of people don't care for learning more and more languages. The biggest reason for my question is my brother who works with cisco and stuff, so he knows how to shell but he's no programmer, nor he wants to be. He just wants to learn how to program to simplify his life and, as such, Python has this much higher potential over <code>awk</code> or <code>sed</code> (sed isn't even a language)... Anyway, this should probably go on to a forum or maybe just to another question! I'll link either once I figure it out. :P</span>
<span class="comment-copy">There you go: <a href="http://discuss.howtogeek.com/t/why-dont-we-have-an-one-liner-python/19528" rel="nofollow noreferrer">discuss.howtogeek.com/t/why-dont-we-have-an-one-liner-python/…</a></span>
<span class="comment-copy">@Cawas: One of the strengths of something like <code>awk</code> is that you can teach people to do simple things without making them realize they're learning programming… But yeah, I can see your point that it would be great if we had one language that was ideal for everything, or at least for everything non-professional-programmer types might want to do. Maybe build a shell on top of Python instead of making Python more usable from the shell? But I've seen people try to do that with C/Cint, emacs-lisp, Tcl, etc., and it generally hasn't been pretty… Anyway, I'll check the forum out when I get a chance…</span>
<span class="comment-copy">The <code>echo hello |</code> is unnecessary here.  <code>awk</code> only needs it because it operates on lines of input.</span>
<span class="comment-copy">@bgbg: Python doesn't do any magic with stdin; you have to explicitly call <code>input</code>, or loop over something like <code>sys.stdin</code> or <code>fileinput.input()</code>, if you want that.</span>
<span class="comment-copy">@bgbg <code>awk</code> implicitly loops over its standard input, so <code>BEGIN</code> and <code>END</code> are used to execute code before and after, respectively, the input is read. Python, conversely, ignores its standard input unless your code specifically reads from it.</span>
<span class="comment-copy">Reason I changed the accepted answer: this resolves exactly my example, but in reality it doesn't answer my question "python as if it were awk". At first I though it would be this simple, but it isn't: <a href="http://stackoverflow.com/questions/2043453/executing-python-multi-line-statements-in-the-one-line-command-line" title="executing python multi line statements in the one line command line">stackoverflow.com/questions/2043453/…</a></span>
<span class="comment-copy">That pawk looks interesting! I love Python, but I often find myself reverting to awk for little things because multi-line Python in the command line is rather tedious.</span>
<span class="comment-copy">@PM2Ring: Reverting to awk for little things is fine. Or sed, grep, bash itself… maybe even perl in some cases (as long as you don't tell anyone).</span>
<span class="comment-copy">Sometimes, bash makes more sense than Python, but it can be very annoying, especially when handling filenames with spaces &amp; other garbage in them. I frequently use grep, generally to do regex stuff on ls output, or to search my *.py files. Years ago, I wrote an HTML parser in awk (for very fixed format HTML), but I won't be doing that again in a hurry. :) When I was learning sed I wrote a sed script that increments integers, but it's not pretty. :)</span>
<span class="comment-copy">so, are you also telling us that this is now working? <a href="http://stackoverflow.com/questions/2043453/executing-python-multi-line-statements-in-the-one-line-command-line" title="executing python multi line statements in the one line command line">stackoverflow.com/questions/2043453/…</a></span>
