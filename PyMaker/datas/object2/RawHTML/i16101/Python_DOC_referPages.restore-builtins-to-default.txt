<div class="post-text" itemprop="text">
<p>If I code a mistake and I do something like this:</p>
<pre><code>__builtins__ = 'abcd'
</code></pre>
<p>and before I didn't code <code>import builtins</code> is there a way to restore <code>__builtins__</code> to its default value?</p>
</div>
<div class="post-text" itemprop="text">
<p>Congratulations, you managed to muck up your namespace good and proper! There is no easy escape from this mess, no. </p>
<p>You <em>can</em> grab the name from any <em>Python</em> module you perhaps have imported, or from an <em>imported</em> Python function:</p>
<pre><code>__builtins__ = some_python_module.__builtins__
</code></pre>
<p>or</p>
<pre><code>__builtins__ = some_python_function.__globals__['__builtins__']
</code></pre>
<p>The function has to be one you imported from elsewhere, so that the <code>__globals__</code> reference points to a different namespace that still has a reference to the <code>__builtins__</code> mapping.</p>
<p>One name that I found will almost always work is the <code>__loader__</code> reference in modules; it is an object with methods that will still give you access a module globals object:</p>
<pre><code>__builtins__ = __loader__.find_spec.__func__.__globals__['__builtins__']
</code></pre>
<p>Otherwise, restart your Python session, and start again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's assume even a worse case than the described situation: you completely ruin, nuke, destroy, annihilate and wipe out <code>__builtins__</code>:</p>
<pre><code>__builtins__.__dict__.clear()
</code></pre>
<p>@Matrtijn's method will fail since every module will have the very same <code>builtins</code> instance. </p>
<hr/>
<p>First, we will have to restore the basic types:</p>
<pre><code>__builtins__.object = "".__class__.__mro__[-1]
__builtins__.type = object.__class__
</code></pre>
<p>According to <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow noreferrer">python docs</a>, <code>__mro__</code> attribute: <em>is a tuple of classes that are considered when looking for base classes during method resolution</em>. Since every python modern class extends <code>object</code>, it allows us to gain instance of the <code>object</code> type.</p>
<p>Second, We will implement a class lookup. Given a class name we will return the class' type. For that we will use <a href="https://docs.python.org/3/library/stdtypes.html#class.__subclasses__" rel="nofollow noreferrer"><code>type.__subclasses__()</code></a> recursively (See <a href="https://stackoverflow.com/questions/3862310/how-can-i-find-all-subclasses-of-a-class-given-its-name">this question</a> for more information about that):</p>
<pre><code>def all_subclasses_of(cls):
    return type.__subclasses__(cls) + [g for s in type.__subclasses__(cls) for g in all_subclasses_of(s)]
def lookup(s):
    for cls in all_subclasses_of(object):
        if cls.__name__ == s:
            return cls
</code></pre>
<p>Third, We'll extract the already loaded modules using <a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.BuiltinImporter" rel="nofollow noreferrer"><code>BuiltinImporter</code></a>:</p>
<pre><code>bi = lookup('BuiltinImporter')
modules = bi.load_module.__globals__['sys'].modules
</code></pre>
<p>We take advantage of the fact that <code>BuiltinImporter</code> imports <code>sys</code> module and then we use <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a>: <em>a dictionary that maps module names to modules which have already been loaded</em>.</p>
<p>Then, We will patch <code>__builtins__</code> with the required methods and classes for the next step:</p>
<pre><code>__builtins__.hasattr = lambda obj, key: key in obj.__dict__
__builtins__.KeyError = lookup('KeyError')
</code></pre>
<p><strong>And now, for the magic to happen!</strong></p>
<pre><code>bi.load_module('builtins')
__builtins__ = bi.load_module.__globals__['module_from_spec'](modules['builtins'].__spec__)
</code></pre>
<p>We generate the <code>__spec__</code> to the <code>builtins</code> module using <a href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.load_module" rel="nofollow noreferrer"><code>builtinImporter.load_module</code></a>. Then, we load the module from the generated spec. <strong>AND IT WORKS!</strong> (I don't really know why, but it indeed works)</p>
<p>However, the freshly generated <code>builtins</code> module misses the method <code>open</code> and all of the exceptions. We will have to add them manually to get <code>import</code> working again:</p>
<pre><code>__builtins__.BaseException = lookup('BaseException')
__builtins__.open = lambda name, mode: modules['io'].FileIO(name, mode)
for error in all_subclasses_of(BaseException):
    __builtins__.__dict__[error.__name__] = error
</code></pre>
</div>
<span class="comment-copy">Why do you want to do this in the first place?</span>
<span class="comment-copy">Remove that line of code?</span>
<span class="comment-copy">@Tidb I don't want to do it. I don't know if I remember good, but I read somewhere that there is a variable in a module that reference the builtin module and I just can't remember it</span>
<span class="comment-copy">I'm getting the following error: <code>Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: string indices must be integers</code></span>
<span class="comment-copy">@YoavSternberg that means the name you used was not found. Python tried to find it in the <code>__builtins__</code> object by using subscription, after searching your globals first. You can make the error less confusing by using <code>__builtins__ = {}</code> first.</span>
<span class="comment-copy">OK. and what if I use <code>__builtins__.__dict__.clear()</code>? It will have the cleared builtins. I was able to restore it, but the <code>import</code> statement doesn't work after that:   <a href="https://pastebin.com/DxvVFBaz" rel="nofollow noreferrer">pastebin.com/DxvVFBaz</a>  I can only import modules that were already imported by the interpreter.</span>
<span class="comment-copy">@YoavSternberg yeah, that’s about the most complete method of making sure you can’t recover again. There <i>may</i> be modules that still have references to some of the builtins but you’d have to hunt through all the objects and the references they hold (recursively) to see what you could recover. Using subclasses of <code>obect</code> is helpful, but many will be instances (functions). It would be much, much easier to just restart Python.</span>
<span class="comment-copy">Actually, I've found a way to fix even that, see my answer below.</span>
<span class="comment-copy">Nice! Still, this is going to be pretty Python-version specific for some of these exceptions. Best not to clear your builtins.</span>
