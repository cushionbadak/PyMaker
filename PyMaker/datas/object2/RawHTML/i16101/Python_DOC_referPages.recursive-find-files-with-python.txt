<div class="post-text" itemprop="text">
<p>I found an <a href="https://stackoverflow.com/questions/7432197/python-recursive-find-files-and-move-to-one-destination-directory">example</a>
how to move all files recursively, but I would like to keep the same folder structure in the destination folder.</p>
<pre><code>import fnmatch
import os
import shutil

rootPath = '/Volumes/VoigtKampff/Temp/TEST/'
destDir = '/Volumes/VoigtKampff/Temp/TEST2/'


matches = []
for root, dirnames, filenames in os.walk(rootPath):
  for filename in fnmatch.filter(filenames, '*.mp4'):
      matches.append(os.path.join(root, filename))
      print(os.path.join(root, filename))
      shutil.move(os.path.join(root, filename), os.path.join(destDir, filename))
</code></pre>
<p>How is it possible to modify the above code to keep the same folder structure in the destination folder?</p>
</div>
<div class="post-text" itemprop="text">
<p>(This answer assumes you're working in Python 2.x)</p>
<p>You need to make the sub-directories as you go:</p>
<pre><code>import fnmatch
import os
import shutil

rootPath = '/Volumes/VoigtKampff/Temp/TEST/'
destDir = '/Volumes/VoigtKampff/Temp/TEST2/'

matches = []

for root, dirnames, filenames in os.walk(rootPath):
    for filename in fnmatch.filter(filenames, '*.mp4'):
        matches.append(os.path.join(root, filename))
        print(os.path.join(root, filename))
        targetDir = os.path.join(destDir, root[len(rootPath):])
        if not os.path.exists(targetDir):
            os.makedirs(targetDir)
        shutil.move(os.path.join(root, filename), os.path.join(targetDir, filename))
</code></pre>
<p>Also note that camelCase names are not standard practice in Python. Take a look at PEP8: <a href="http://legacy.python.org/dev/peps/pep-0008/" rel="nofollow">http://legacy.python.org/dev/peps/pep-0008/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>To move all <code>.mp4</code> files from <code>root_dir</code> directory to <code>dest_dir</code> directory recursively while preserving the directory structure relative to <code>root_dir</code>:</p>
<pre><code>#!/usr/bin/env python3
from pathlib import Path
from shutil import move

src = Path(root_dir)
dest = Path(dest_dir)
for file in src.rglob('*.mp4'):
    dest_file = dest / file.relative_to(src)
    try:
        dest_file.parent.mkdir(parents=True)
    except OSError:
        pass # ignore
    move(str(file), str(dest_file))
</code></pre>
<p>It uses <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow"><code>pathlib</code></a> library that is available in stdlib since Python 3.4. To install it on earlier versions: </p>
<pre><code>$ pip install pathlib
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not just do <code>os.system('your mv command')</code>?</p>
</div>
<span class="comment-copy">Is using mv out of the question?</span>
<span class="comment-copy">In python3, <code>os.makedirs</code> includes a flag <code>exist_ok</code> that bypasses the race condition present here</span>
<span class="comment-copy">@AdamSmith -- good point; I was assuming a Python 2.x scenario here.</span>
<span class="comment-copy">just noticed the print(), so I guess it should have been Python 3 after all!</span>
<span class="comment-copy">Maybe independent of OS?</span>
