<div class="post-text" itemprop="text">
<p>I have a file named example_dict.py</p>
<pre><code>#This is a valid comment
{
    'key1': 'value1',
    'key2': 'value2',
    'key3': 'value3',
}
</code></pre>
<p>Then I read this file and transform dict:</p>
<pre><code>from collections import OrderedDict
with open("example_dict.py") as fp:
    dict_from_file = OrderedDict( eval( fp.read() ) )
</code></pre>
<p>But this "dict_from_file" not have the same order key1, key2, key3.</p>
<p>How I can get this dict in same order.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write a custom parser using the <code>ast</code> module, for a starter:</p>
<pre><code>import ast
from collections import OrderedDict

with open('example_dict.py') as fin:
    parsed = ast.parse(fin.read())

first_dict = next(node for node in ast.walk(parsed) if isinstance(node, ast.Dict))
keys = (node.s for node in first_dict.keys)
vals = (node.s for node in first_dict.values)
od = OrderedDict(zip(keys, vals))
# OrderedDict([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')])
</code></pre>
<p>Note that although this works with your example data - this needs a bit more work to make it more robust, but should serve as a starting point.</p>
</div>
<div class="post-text" itemprop="text">
<p>@JonClements' solution is beautiful and simple—but, as he points out, it's not that robust, because you're depending on the fact that each element of the dictionary display will evaluate to itself—and that you've got some arbitrary code of which the first valid dict literal is the only thing you care about.</p>
<p>A related idea would be to use <a href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer" rel="nofollow"><code>ast.NodeTransformer</code></a> transform the dict literal AST into an OrderedDict constructor AST, then just <code>eval</code> that.</p>
<p>Pros:</p>
<ul>
<li>Once you get it working for trivial cases, it automatically works properly for more complex cases.</li>
<li>It's trivial to extend it from parsing single dict literals to converting all dict literals in an entire module (which you can then install as part of an import hook). </li>
<li>You get to learn more about how Python ASTs work.</li>
</ul>
<p>Cons:</p>
<ul>
<li>There's a lot more (and uglier) code to write to get it working for trivial cases.</li>
<li>Since you're not parsing the elements manually, it's not as easy to add in restrictions for, e.g., safely processing potentially malicious or incompetent input (e.g., by using <code>literal_eval</code> on each element).</li>
<li>You have to learn more about how Python ASTs work.</li>
</ul>
<p>However, it's worth stepping back and asking whether you really want to write and use all this code. You might be a lot happier using something like <a href="https://pypi.python.org/pypi/MacroPy" rel="nofollow"><code>MacroPy</code></a>, which automates a lot of the clunky stuff being done here, and a lot of the stuff I'm <em>not</em> doing here (like installing import hooks), to let you concentrate on just the part of the transformation that's interesting to you. (Actually, I think MacroPy even comes with an odict literal as one of its builtin examples…)</p>
<hr/>
<p>Anyway, the transformer looks like this:</p>
<pre><code>class DictToOrdered(ast.NodeTransformer):
    def visit_Dict(self, node):
        return ast.fix_missing_locations(ast.copy_location(
            ast.Call(
                func=ast.Attribute(
                    value=ast.Name(id='collections', ctx=ast.Load()),
                    attr='OrderedDict',
                    ctx=ast.Load()),
                args=[ast.Tuple(elts=
                        [ast.Tuple(elts=list(pair), ctx=ast.Load())
                         for pair in zip(node.keys, node.values)],
                        ctx=ast.Load())],
                keywords=[],
                starargs=None,
                kwargs=None),
            node))
</code></pre>
<p>This is a little uglier than usual, because dict literals don't have to have a context (because they can't be used as assignment targets), but tuples do (because they can), so we can't just copy the context the way we do the line numbers.</p>
<p>To use it:</p>
<pre><code>def parse_dict_as_odict(src):
    import collections
    parsed = ast.parse(src, '&lt;dynamic&gt;', 'eval')
    transformed = DictToOrdered().visit(parsed)
    compiled = compile(transformed, '&lt;dynamic&gt;', 'eval')
    return eval(compiled)
</code></pre>
<p>That assumes you want to evaluate exactly one expression at a time, and that you want to do so within the current global/local environment, and that you don't mind inserting the <code>collections</code> module into that environment; if you look at the docs for <code>compile</code>, <code>ast.parse</code>, and <code>eval</code> it should be obvious how to change any of those assumptions.</p>
<p>So:</p>
<pre><code>&gt;&gt;&gt; src = '''
... {
...     'key1': 'value1',
...     'key2': 'value2',
...     'key3': 'value3',
... }
... '''
&gt;&gt;&gt; parse_dict_as_odict(src)
OrderedDict([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')])
</code></pre>
<hr/>
<p>If you want to learn more, without digging through the source code yourself, <a href="http://greentreesnakes.readthedocs.org/" rel="nofollow">Green Tree Snakes</a> is a great resource for understanding Python's ASTs and its <code>ast</code> module that I wish had been written a few years earlier. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Python dictionaries do not have any inherent order. You probably already know this, since you're trying to put your data into an instance of <code>OrderedDict</code>, which does maintain the order its values are added in.</p>
<p>However, the problem you're having is that your <code>eval</code> expression is producing an ordinary <code>dict</code> instance first, and only after the order has already been lost does it get passed on to <code>OrderedDict</code>.</p>
<p>There's no direct way around this. If you use <code>eval</code> to parse a file with a dictionary literal in it, it's going to give you a regular <code>dict</code>.</p>
<p>There are other options though. You could write your own parsing code, and create the values to put in the <code>OrderedDict</code> directly without creating a regular <code>dict</code> first. This would be somewhat complicated, and you should probably pick a better file format if this is the approach you go for.</p>
<p>If in fact you can change the file's contents, you could simply have the <code>eval</code> call create some other data structure which you can pass to <code>OrderedDict</code> without losing the ordering information. A list of <code>(key,value)</code> 2-tuples would be a good option, requiring no other changes to your code:</p>
<pre><code>[
    ('key1', 'value1'),
    ('key2', 'value2'),
    ('key3', 'value3'),
]
</code></pre>
<p>Note that in some future version of Python, keyword arguments passed in function calls may get put into an <code>OrderedDict</code> rather than a <code>dict</code> (as described in <a href="http://legacy.python.org/dev/peps/pep-0468/" rel="nofollow">PEP 468</a>). If that happens, you could change your file contents to the following, and get an <code>OrderedDict</code> directly from <code>eval</code>:</p>
<pre><code>OrderedDict(
    key1='value1',
    key2='value2',
    key3='value3',
)
</code></pre>
<p>Alas, if you try this today you'll run into the same issue your current code does (the keyword arguments are packed into a regular <code>dict</code> which discards their ordering before the <code>OrderedDict</code> code gets a look at them). The keyword arguments to the <code>OrderedDict</code> constructor are not terribly useful.</p>
</div>
<span class="comment-copy">Eval will treat the data as an unordered dict which will scramble the keys. Casting to an Ordered Dict will be pointless. You may need to parse the data and feed  it in token-by-token.</span>
<span class="comment-copy">Possible duplicate of: <a href="http://stackoverflow.com/questions/6921699/can-i-get-json-to-load-into-an-ordereddict-in-python">Can I get JSON to load into an OrderedDict in Python?</a></span>
<span class="comment-copy">@Mr.Polywhirl: While that question is related, I don't think the answer it describes is appropriate here. The file in this question contains a Python literal, not JSON. It's true that the example data is almost valid JSON (just change the single quotes to double quotes and get rid of the last comma), but I don't know if that will be true for the real data.</span>
<span class="comment-copy">I was going to recommend using a parsing library like <a href="http://pyparsing.wikispaces.com/" rel="nofollow noreferrer"><code>pyparsing</code></a> until I saw Jon Clements' answer. Now I think his idea is probably better… but it's still worth looking at <code>pyparsing</code> and playing with it if you never have before. (Or, if you know a bit more about parsers, search PyPI for other parser and pgen libraries that might be in a more familiar style.)</span>
<span class="comment-copy">Clever solution! Although there might be a way to take advantage of even more of the <code>ast</code> machinery to make it more robust, by using a <code>NodeTransformer</code> to translating the dict literal into an <code>OrderedDict</code> constructor of tuples. Let me see if I can get that to work… But even if I can, yours will still probably be more readable and easier to understand as a starting point.</span>
<span class="comment-copy">@abarnert I don't have time to do so - like I said - this is a starting point... hopefully more inspirational than anything really :) But if you have time and can get the <code>NodeTransformer</code> approach working (which I think sounds quite feasible) then <b>please, please  share</b> - I'd be very keen to see it.</span>
<span class="comment-copy">I had feared it would be something like that :) But definitely +1 - great work</span>
<span class="comment-copy">On a side note: is there meant to be a "Cons:" there?</span>
<span class="comment-copy">Wao!, Excellent. This is work very very fine!!! Thank you very much.</span>
<span class="comment-copy">@JonClements: Yeah, thanks; the second half of the list is cons. Unless you think uglier and more verbose is a pro. :) I'll edit it.</span>
<span class="comment-copy">@abarnert :) Well, all I can say is if I was the OP of the question, I wouldn't hesitate to accept this very well researched, explained and detailed answer. In a toss up between "simple and meets the spec" (which we know normally doesn't turn out to be the <i>actual</i> spec :P) and this one for being more robust... I'd pick this one.</span>
<span class="comment-copy">Hello @Blckknght, thank for you reply. But this file is of other app. Then I don't have access to modify this file.</span>
<span class="comment-copy">The solution provided at the end wouldn't work even if it were possible, because <code>OrderedDict</code> takes a <code>**kwargs</code> dict, meaning it will get those keys and values in arbitrary order, leaving you right where you started.</span>
<span class="comment-copy">@abarnert: That's exactly what I said in the answer. It may become an option if PEP 468 is enacted, as that proposes to make all **kwargs dictionaries <code>OrderedDicts</code>, but it won't work today.</span>
