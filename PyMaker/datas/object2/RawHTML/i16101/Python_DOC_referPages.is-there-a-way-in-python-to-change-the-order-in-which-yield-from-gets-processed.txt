<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/23874228/breadth-first-version-of-itertools-chain">Breadth-first version of itertools.chain()</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>If I do:</p>
<pre><code>def foo():
    yield from range(0,10)
    yield from range(10,20)

for num in foo():
    print(num)
</code></pre>
<p>I get a ordered list from 0 to 19.
Without change the input of the range functions, is there an easy way to specify that I want a list that goes: 0,10,1,11,2,12...</p>
<p>Basically I first want the first element of every generator. Than I want the second element of every generator and then the third and so on.</p>
<p>Bonus points:
Is there a way to change it so that when the generators produce an unequal amount of results, the second generator yields the rest of it's results after the first one is finished?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to <code>zip()</code> your iterators; do so explicitly:</p>
<pre><code>from itertools import chain

def foo():
    yield from chain.from_iterable(zip(range(10), range(10, 20)))
</code></pre>
<p>The use of <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable()</code></a> lets you continue to use <code>yield from</code> here, flattening out the tuples <code>zip()</code> produces.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; def foo():
...     yield from chain.from_iterable(zip(range(10), range(10, 20)))
... 
&gt;&gt;&gt; list(foo())
[0, 10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19]
</code></pre>
<p>If you have generators of different lengths, you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>itertools.zip_longest()</code></a>:</p>
<pre><code>from itertools import zip_longest

def foo():
    yield from (i for pair in zip_longest(range(10), range(10, 22))
                  for i in pair if i is not None)
</code></pre>
<p>I used a different flattening technique here with a double loop in a generator expression.</p>
<p>This all does get tedious, and since you are not using <code>yield from</code> with another generator (so you don't need support for <code>generator.send()</code> and <code>generator.throw()</code> to be propagated), you may as well just make this a proper loop:</p>
<pre><code>def foo():
    for x, y in zip_longest(range(10), range(10, 22)):
        if x is not None:
            yield x
        if y is not None:
            yield y            
</code></pre>
<p>You can also use the <code>roundrobin()</code> recipe listed in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> documentation recipies section</a>:</p>
<pre><code>from itertools import cycle

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

def foo():
    yield from roundrobin(range(10), range(10, 22))
</code></pre>
</div>
<span class="comment-copy">What if the generators have different length? This solution seems to silently forget the rest of the chain. I would prefer that I still get the rest.</span>
<span class="comment-copy">@Christian: then use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a>, perhaps filtering out <code>None</code> values. But you'll have to do this <i>explicitly</i>.</span>
<span class="comment-copy">@MartijnPieters I think I've said this before¹, but... <code>roundrobin</code> from the docs, perhaps? ¹<a href="http://stackoverflow.com/a/23874310/1763356">stackoverflow.com/a/23874310/1763356</a></span>
<span class="comment-copy">@Veedrac: I do keep forgetting about roundrobin!</span>
