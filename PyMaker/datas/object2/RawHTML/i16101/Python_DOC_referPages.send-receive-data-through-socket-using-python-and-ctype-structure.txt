<div class="post-text" itemprop="text">
<p>I am trying to send and receive C structure data from a python client to server and vice-versa. Both clients and server work smoothly in connecting and exchanging data. Client sends a ctype structure to server and server sends it back again. The problem is that I don't know how to interpret the message received in the client and extract the data as it is in the structure format. My final Idea is to have a python server and C-client talking to each other and exchanging data in a predefined structure.</p>
<p>Here are the codes I have for client and server in Python:</p>
<p><strong>Client Code</strong></p>
<pre><code>import socket
import sys
import time

from ctypes import *

class payload_t(Structure):
    _fields_ = [("ms", c_ulong),
                ("counter", c_ulong),
                ("DHT_temperature", c_float),
                ("DHT_humidity", c_float),
                ("DS_temperature", c_float),
                ("temperature_setpoint", c_float),
                ("time_setpoint", c_float)]

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect the socket to the port where the server is listening
server_address = ('localhost', 10000)
print &gt;&gt;sys.stderr, 'connecting to %s port %s' % server_address
sock.connect(server_address)

try:
    for i in range(0,10):
        # Send data
        payload=payload_t(i*1000,i+1,25.2,45.7,25.8,33.22,3600.0)
        message = payload
        # 'This is the message.  It will be repeated.'
        print 'length of message %d' % sizeof(message)
        print 'sending "', message.ms, message.counter, message.DHT_temperature, message.DHT_humidity, message.DS_temperature, message.temperature_setpoint, message.time_setpoint, '"'
        sock.sendall(message)
        # time.sleep(0.1)
        # Look for the response
        amount_received = 0
        amount_expected = sizeof(message)

        while amount_received &lt; amount_expected:
            datap = sock.recv(sizeof(message))
            amount_received += len(datap)
        print &gt;&gt;sys.stderr, 'received "%s"' % datap
        print type(datap)
        payload=payload_t()
        datap.readinto(payload)
        data=datap.readinto(payload_t)
        data=struct.unpack(payload_t,datap)
            print 'Received "', data.ms, data.counter, data.DHT_temperature, data.DHT_humidity, data.DS_temperature, data.temperature_setpoint, data.time_setpoint, '"'

finally:
    print &gt;&gt;sys.stderr, 'closing socket'
    sock.close()
</code></pre>
<p><strong>Server Code</strong></p>
<pre><code>import socket
import sys
from ctypes import *

class payload_t(Structure):
    _fields_ = [("ms", c_ulong),
                ("counter", c_ulong),
                ("DHT_temperature", c_float),
                ("DHT_humidity", c_float),
                ("DS_temperature", c_float),
                ("temperature_setpoint", c_float),
                ("time_setpoint", c_float)]

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the port
server_address = ('localhost', 10000)
print &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)
payload=payload_t(0,0,0.0,0.0,0.0,0.0,0.0)
while True:
    # Wait for a connection
    print &gt;&gt;sys.stderr, 'waiting for a connection'
    connection, client_address = sock.accept()

    try:
        print &gt;&gt;sys.stderr, 'connection from', client_address

        # Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv(sizeof(payload))
            print &gt;&gt;sys.stderr, 'received "%s"' % data
            if data:
                print &gt;&gt;sys.stderr, 'sending data back to the client'
                connection.sendall(data)
            else:
                print &gt;&gt;sys.stderr, 'no more data from', client_address
                break

    finally:
        # Clean up the connection
        connection.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you are currently dumping the received data. You are reassigning the variable 'datap' in every loop iteration.</p>
<p>Do something like that instead:</p>
<pre><code>datap += sock.recv(sizeof(message) - amount_received)
</code></pre>
<p>(Of course it's not the most efficient code, but you get the idea.)</p>
<p>When you have your structure assembled in the 'datap' var, you load it into your ctype class using 'from_buffer' or 'from_buffer_copy' method.</p>
<pre><code>payload = payload_t.from_buffer_copy(datap)
</code></pre>
<p>The latter is better in your case, since your buffer may go away when you rebind the 'datap' var.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about providing an instance of ctypes.Structure directly with the call recv_into? </p>
<p>Here is a modified version of your Server code, hoping I did not remove a functionality you wanted to keep</p>
<pre><code>import socket
import sys
from ctypes import *

class payload_t(Structure):
    _fields_ = [("ms", c_ulong),
                ("counter", c_ulong),
                ("DHT_temperature", c_float),
                ("DHT_humidity", c_float),
                ("DS_temperature", c_float),
                ("temperature_setpoint", c_float),
                ("time_setpoint", c_float)]

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the port
server_address = ('localhost', 10000)
print &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)
payload=payload_t()
while True:
    # Wait for a connection
    print &gt;&gt;sys.stderr, 'waiting for a connection'
    connection, client_address = sock.accept()

    try:
        print &gt;&gt;sys.stderr, 'connection from', client_address

        # Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv_into(payload)
            print &gt;&gt;sys.stderr, 'received "%s"' % data
            if data:
                print &gt;&gt;sys.stderr, 'sending data back to the client'
                print &gt;&gt;sys.stderr, 'time_setpoint "%f"' % payload.time_setpoint
                connection.sendall(payload)
            else:
                print &gt;&gt;sys.stderr, 'no more data from', client_address
                break

    finally:
        # Clean up the connection
        connection.close()
</code></pre>
<p>So, basically, the only thing I did was using a socket.recv_into call directly into an instance of your structure:
<strong><a href="https://docs.python.org/3/library/socket.html#socket.recv_into" rel="nofollow noreferrer">https://docs.python.org/3/library/socket.html#socket.recv_into</a></strong></p>
<p>That gives me direct access to the structure attributes afterward.</p>
<p>I guess the structure is small enough (28 octets) so that data fits in a single recv_into call. If you need multiple calls to recv_into to get your full structure built up, then... </p>
<p>If you have python 3.7, you could make multiple calls to your structure with slicing memoryviews:</p>
<pre><code>mv = memoryview(payload).cast('B')
size = sizeof(payload)
while size &gt; 0:
    data = connection.recv_into(mv) 
    mv = mv[data:] 
    size -= data 
</code></pre>
<p>Nothing guaranteed to be honest. With earlier versions of Python, you could have an exception when trying to cast 'B' on your memoryview. Recall that memoryview on a ctypes.Structure is 0-dim, and then it is almost impossible slicing it without the cast...</p>
</div>
<span class="comment-copy">Thanks! It did work perfectly. Moreover, obviously, I just have to initialize the payload every step.</span>
<span class="comment-copy">Yeah, what about that? Can you explain further how this could solve the problem?</span>
<span class="comment-copy">Better...........? :)</span>
