<div class="post-text" itemprop="text">
<p>I have something akin to the following code:</p>
<pre><code>class thingy(object):
    def __init__(creds=get_credentials()):
        # does stuff
        pass

def get_credentials():
    # produces different values sometimes. Ie: retrieves values from a db
    return db.get(some_query)

dc.connect(credentials_and_stuff)
</code></pre>
<p>This fails on import, not runtime, defining the <code>__init__()</code>, saying 'the database has no connection'. This doesn't make sense to me, since the <code>__init__()</code> function hasn't even been run yet!</p>
</div>
<div class="post-text" itemprop="text">
<p>I found this: <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#mutable-default-arguments" rel="nofollow">http://docs.python-guide.org/en/latest/writing/gotchas/#mutable-default-arguments</a></p>
<p>Turns out, values for optional arguments are evaluated at their <em>definition</em>, <em>not</em> when executed. Here's an extreme example:</p>
<pre><code>def default_value():
    print("ERMAGERD DIS FUNCTION WAS RUN!")
    return False

def fake_function(an_arg=default_value()):
    pass
</code></pre>
<p>Before this discovery, I'd say this code would do nothing; no functions are run, just some definitions. Now I know (and have tested) that this code alone will print out <code>ERMAGERD DIS FUNCTION WAS RUN!</code>.</p>
<p>This means two things for the code in the above question:</p>
<ol>
<li>In order to <em>not crash</em>, the <code>db.connect()</code> would have to be run before the <code>class thingy(object)</code> definition happens.</li>
<li>The <code>get_credentials()</code> would  only get run once, and said db query would never get re-run (stale credentials!)</li>
</ol>
<p>So to make this <em>actually</em> do what it's intended to do (query the database for credentials when none are provided), you have to do something akin to this:</p>
<pre><code>class thingy(object):
    def __init__(creds=None):
        if creds is None:
            creds = get_credentials()
        # does stuff
        pass
</code></pre>
<p>This way <code>get_credentials()</code> is run at runtime, not at definition. This both allows the <code>db.connect()</code> to be done elsewhere (so long as it's before an instance of <code>thingy</code> is instantiated), <em>and</em> fixes the stale credentials issue.</p>
</div>
<span class="comment-copy">Just have a look at one of the early chapters in the tutorial (<a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">Default Argument Values</a>): "The default values are evaluated at the point of function definition in the <i>defining</i> scope". This looks like pretty basic knowledge.</span>
<span class="comment-copy">You can say it's basic knowledge, but I don't feel it's obvious enough to throw out as something that shouldn't be stated again. Until I ran into an issue this caused in a production environment, I had always thought of optional arguments as a sort of syntax sugar, something that was executed as part of the function body, and there was nothing in the syntax or documentation (outside tutorials like you mentioned, but not all tutorials cover this, personally I never used done that did) elsewhere to lead me to think I was wrong.</span>
