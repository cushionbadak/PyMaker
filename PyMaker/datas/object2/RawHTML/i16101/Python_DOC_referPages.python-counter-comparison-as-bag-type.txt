<div class="post-text" itemprop="text">
<p>I need a bag/multiset-like data type in Python. I understand collections.Counter is often used for this purpose. But the comparison operators don't seem to work:</p>
<pre><code>In [1]: from collections import Counter

In [2]: bag1 = Counter(a=1, b=2, c=3)

In [3]: bag2 = Counter(a=2, b=2)

In [4]: bag1 &gt; bag2
Out[4]: True
</code></pre>
<p>This seems like a bug to me. I expected the less-than and greater-than operators to perform set-like subset and superset comparisons. But if that were the case then <code>bag1 &gt; bag2</code> would be false because <code>bag2</code> contains an extra <code>'a'</code>. There also don't seem to be subset/superset methods on Counter objects. So I have two questions:</p>
<ol>
<li>What comparison logic is used for Counter objects?</li>
<li>How can I compare Counter objects for subset, superset, proper-subset, and proper-superset?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>On Python 2, the comparison falls back to the <a href="https://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow">default sort order for dictionaries</a> (<code>Counter</code> is a subclass of <code>dict</code>).</p>
<blockquote>
<p>Mappings (dictionaries) compare equal if and only if their sorted
  (key, value) lists compare equal. [5] Outcomes other than equality are
  resolved consistently, but are not otherwise defined. [6]</p>
</blockquote>
<p>On Python 3, <a href="https://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow">the comparison raises a <code>TypeError</code></a>:</p>
<blockquote>
<p>Mappings (dictionaries) compare equal if and only if they have the
  same (key, value) pairs. Order comparisons ('&lt;', '&lt;=', '&gt;=', '&gt;')
  raise <code>TypeError</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This unanswered question is of interest:</p>
<blockquote>
<p>How can I compare Counter objects for subset, superset, proper-subset, and proper-superset?</p>
</blockquote>
<p>By defining the missing â€œrich comparison methods". You could also use free functions instead, which will make client code more explicit.</p>
<pre><code>from collections import Counter

class PartiallyOrderedCounter(Counter):

    def __le__(self, other):
        """ Multiset inclusion """
        return all( v &lt;= other[k] for k,v in self.items() )


    def __lt__(self, other):
        """ Multiset strict inclusion """
        return self &lt;= other and self != other


    # TODO : __ge__ and __gt__
    # Beware : they CANNOT be written in terms of __le__ or __lt__


a = PartiallyOrderedCounter('abc')
b = PartiallyOrderedCounter('ab')
c = PartiallyOrderedCounter('abe')

assert a &lt;= a
assert not a &lt; a    
assert b &lt;= a
assert b &lt; a
assert not a &lt; b    
assert not c &lt;= a
assert not a &lt;= c
</code></pre>
</div>
<span class="comment-copy">Have you read the documentation?</span>
<span class="comment-copy">Yes, if you mean the ones here: <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/2/library/collections.html#collections.Counter</a> They describe it as a bag/multiset, I assumed that meant the comparison operators would be meaningful.</span>
<span class="comment-copy">I had not seen the linked question before and I see how it's related but it's got a couple issues: no description of how to implement proper-subset though I guess that <code>&lt;=</code> and <code>!=</code> though I don't know if there's a better way to implement and superset though I guess that's the inverse of subset. Also the accepted answer has a typo which a comment tries to call attention to. Not sure if someone can edit that.</span>
<span class="comment-copy"><code>set('abc')&gt;set('ab')</code> is also <code>True</code></span>
<span class="comment-copy">I'm Python 2.7, sorry forgot to mention.</span>
<span class="comment-copy">Also, comparison by memory address doesn't seem to happen here: id(bag1) is 4371127560 and id(bag2) is 4371127856. So <code>bag2</code> should be greater than <code>bag1</code>.</span>
<span class="comment-copy">@WilliamReed:  The ordering you are seeing is arbitrary.</span>
<span class="comment-copy">It doesn't fall back to the default ordering; it falls back to the <a href="http://hg.python.org/cpython/file/f17ab9fed3b0/Objects/dictobject.c#l1792" rel="nofollow noreferrer">dict implementation of <code>__cmp__</code></a>, because <code>Counter</code> inherits from <code>dict</code>.</span>
<span class="comment-copy">@WilliamReed:  user2357112 is certainly correct, but it's a small comfort.  What does it mean to say one dictionary is less than another?  In Python 2 the answer to that question is well defined, but was deemed so unuseful as to be done away with in Python 3.</span>
