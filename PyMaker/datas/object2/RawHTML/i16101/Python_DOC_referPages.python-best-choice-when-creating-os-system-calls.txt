<div class="post-text" itemprop="text">
<p>Im looking to connect to an SMB share using mount_smbfs (python on OSX). Im trying to find the most efficient way to do this. Below is what I am thinking, but I am not sure how to place the vairable names into the command line string correctly.</p>
<pre><code>def connect_creds(server,domain,username,password):
    dir = "/root/tmp"
    if not os.path.exists(dir): os.makedirs(dir)
    os.system("mount_smbfs //", domain, , ";", username, ":", password, "@", server, "/Share", " ", dir)
</code></pre>
<p>Any advice on the best way to move forward would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code won't actually work:</p>
<pre><code>os.system("mount_smbfs //", domain, , ";", username, ":", password, "@", server, "/Share", " ", dir)
</code></pre>
<p>You're calling <code>os.system</code> with a whole slew of separate arguments: <code>"mount_smbfs //"</code>, then <code>domain</code>, and so on. But it only takes one argument.</p>
<p>I think you're expecting it to work like <code>print</code>—but even if it did, <code>print</code> would stick spaces between each element, so you'd end up with <code>USER : PASS @ SERVER</code>, which isn't going to do much good.</p>
<p>If you want to concatenate them all together, you can do that by using the <code>+</code> operator, or, far better, <code>str.format</code>, like this:</p>
<pre><code>os.system("mount_smbfs //{};{}:{}@{}/Share {}".format(
    domain, username, password, server, dir)
</code></pre>
<p>But that's still not going to work, because the shell is going to misinterpret that <code>;</code> as a special character separating two statements. And, without quoting, it will also fail if there are spaces or other special characters in any of the strings.</p>
<p>All of that is fixable if you really want to fight with it, but there's no good reason to do so. As the docs for <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow"><code>os.system</code></a> say:</p>
<blockquote>
<p>The <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" rel="nofollow"><code>subprocess</code></a> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function.</p>
</blockquote>
<p>Here's how you'd do it with <code>subprocess</code>:</p>
<pre><code>subprocess.check_call(['mount_smbfs',
                       '//{};{}:{}@{}/Share'.format(domain, username, password, server),
                       dir])
</code></pre>
<p>This leaves the shell out of it entirely—which is marginally more efficient (not that it's likely to ever matter), but also a whole lot simpler, because you don't have to worry about escaping or quoting special shell characters. It's also more robust; if the call fails, instead of failing silently, it will raise an exception. Using <code>subprocess</code> also gives you the opportunity to capture the stdout or stderr, or do various other things, with only minor changes to your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>os.system</code>. Use the <a href="https://docs.python.org/2/library/subprocess.html" rel="nofollow"><code>subprocess</code> module</a> from the standard library.</p>
<p>The problem with <code>os.system</code> is that it passes your command line through the shell (e.g. <code>bash</code>, <code>csh</code>) which opens up a number of security risks as well as opportunities for the shell to mangle the command line, such as by erroneously detecting special characters, shell variables, quoted strings, spaces, or escapes.</p>
<p>With <code>subprocess</code> you can specify the exact individual command-line arguments that the external program receives.* You would probably use it something like this:</p>
<pre><code>subprocess.call(("mount_smbfs", "//%s;%s:%s@%s/Share" % (domain, username, password,
    server), dir))
</code></pre>
<p>Notice that there is no need to worry about, say, spaces or special characters that may appear in the parameters.</p>
<p>* This should work on MacOS and any other POSIX-y OS; it's pretty reliable on Windows but it's not 100% possible to map unambiguously between the POSIX model of a command line as an array of strings and the Windows/DOS model as a single string.</p>
</div>
<span class="comment-copy">First, what do you mean by "efficient"? Do you think some other mechanism will have better performance? Does the performance of the Python wrapper (which is likely to be microseconds, vs. the seconds for the actual <code>mount</code> call) actually matter for some reason?</span>
<span class="comment-copy">Second, have you looked at the documentation for <code>os.system</code>? It explains pretty clearly that the best way to use <code>os.system</code> is generally to not use <code>os.system</code>, and instead use the <code>subprocess</code> library.</span>
<span class="comment-copy">First, asking questions you know the answer to is inefficient ;). Second, a less pretentious answer would have been appreciated more but none the less thanks. I will take a look at using a subprocess call. Wana stick that in as an answer?</span>
<span class="comment-copy">I don't know the answer to those questions. If you think it's "pretentious" to assume that when people ask about efficiency they actually <i>mean something</i> by that, or that anyone who considers himself a programmer knows how to look things up in the documentation, I really don't know what to say. I try to assume people are not idiots, and most people seem to be happy with that.</span>
<span class="comment-copy">Awesome thanks @abarnert :) ill use the subprocess call with the string formating suggested above.</span>
<span class="comment-copy">This is <i>very nearly</i> possible on Windows. Python does have to generate a command line that will be parsed back into the arguments you gave it, but as long as (a) the program you're talking to uses the standard cmdline-parsing wrapper in MSVCRT or follows the same rules (which is nearly universal, but not quite) and (b) you don't hit any of those edge cases that are not actually possible to quote properly, you will get the right result (which is a huge pain to get right on your own).</span>
<span class="comment-copy">Right, it's almost always possible, but not 100% because of edge cases. I just wanted to mention it in case anyone reads this and decides to dive into <code>subprocess</code> under Windows.</span>
<span class="comment-copy">Yeah, it's good that you've mentioned it, especially since there are a lot of even very-experienced Python programmers who believe (and write answers claiming) you should always use a list on Windows because you get the same behavior as on POSIX, rather than the actual reason, because it usually makes a better effort than you could probably make yourself…</span>
<span class="comment-copy">Right on. I've hit edge cases here often enough that my personal policy is: don't use command-line arguments on Windows <b>at all</b> unless you generated them yourself and know they're sane.</span>
