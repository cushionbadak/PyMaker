<div class="post-text" itemprop="text">
<p>I've got a list of daily values ordered into a list of dicts like so:</p>
<pre><code>vals = [
    {'date': '1-1-2014', 'a': 10, 'b': 33.5, 'c': 82, 'notes': 'high repeat rate'},
    {'date': '2-1-2014', 'a': 5, 'b': 11.43, 'c': 182, 'notes': 'normal operations'},
    {'date': '3-1-2014', 'a': 0, 'b': 0.5, 'c': 2, 'notes': 'high failure rate'},
    ...]
</code></pre>
<p>What I'd like to do is get an average of a, b &amp; c for the month.</p>
<p>Is there a better way than doing something like:</p>
<pre><code>val_points = {}
val_len = len(vals)

for day in vals:
    for p in ['a', 'b', 'c']:
        if val_points.has_key(p):
            val_points += day[p]
        else:
            val_points = day[p]

val_avg = dict([(i, val_points[i] / val_len] for p in val_points])
</code></pre>
<p>I haven't run the code above, may have glitches but I hope I'm getting the idea across. I know there's probably a better way using some combination of operator, itertools and collections.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>{p:sum(map(lambda x:x[p],vals))/len(vals) for p in ['a','b','c']}
</code></pre>
<p><strong>output:</strong></p>
<pre><code>{'a': 5, 'c': 88, 'b': 15.143333333333333}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might be slightly longer than Elisha's answer, but there are less intermediate data structures, hence it <em>might</em> be faster:</p>
<pre><code>KEYS = ['a', 'b', 'c']

def sum_and_count(sums_and_counts, item, key):
    prev_sum, prev_count = sums_and_counts.get(key, (0,0)) # using get to have a fall-back if there is nothing in our sums_and_counts
    return (prev_sum+item.get(key, 0), prev_count+1) # using get to have a 0 default for a non-existing key in item

sums_and_counts = reduce(lambda sc, item: {key: sum_and_count(sc, item, key) for key in KEYS}, vals, {})

averages = {k:float(total)/no for (k,(total,no)) in sums_and_counts.iteritems()}
print averages
</code></pre>
<p><strong>output</strong>:</p>
<pre><code>{'a': 5.0, 'c': 88.66666666666667, 'b': 15.143333333333333}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you want to calculate average by month(Here  considering the date format in 'dd-mm-yyyy'):</p>
<pre><code>vals = [
    {'date': '1-1-2014', 'a': 10, 'b': 33.5, 'c': 82, 'notes': 'high repeat rate'},
    {'date': '2-1-2014', 'a': 5, 'b': 11.43, 'c': 182, 'notes': 'normal operations'},
    {'date': '3-1-2014', 'a': 20, 'b': 0.5, 'c': 2, 'notes': 'high failure rate'},
    {'date': '3-2-2014', 'a': 0, 'b': 0.5, 'c': 2, 'notes': 'high failure rate'},
    {'date': '4-2-2014', 'a': 20, 'b': 0.5, 'c': 2, 'notes': 'high failure rate'}
    ]

month = {}

for x in vals:
    newKey =  x['date'].split('-')[1]
    if newKey not in month:
        month[newKey] = {}   

    for k in 'abc':

        if k in month[newKey]:
             month[newKey][k].append(x[k])
        else:
             month[newKey][k] = [x[k]]


output = {}
for y in month:
    if y not in output:
        output[y] = {}
    for z in month[y]:
        output[y][z] = sum(month[y][z])/float(len(month[y][z]))

print output  
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{'1': {'a': 11.666666666666666, 'c': 88.66666666666667, 'b': 15.143333333333333}, 
 '2': {'a': 10.0, 'c': 2.0, 'b': 0.5}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have multiple month's data, Pandas will make your life a lot easier:</p>
<pre><code>df = pandas.DataFrame(vals)
df.date = [pandas.datetools.parse(d, dayfirst=True) for d in df.date]
df.set_index('date', inplace=True)
means = df.resample('m', how='mean')
</code></pre>
<p>Results in:</p>
<pre><code>            a          b          c
date                               
2014-01-31  5  15.143333  88.666667
</code></pre>
</div>
<span class="comment-copy">Have you actually read the documentation for the modules you mention? There are two obvious simplifications a pair of imports would enable.</span>
<span class="comment-copy">Off-topic: Don't use <code>dict.has_key</code>, it is deprecated and removed in Python3. Use: <code>if p in val_points:</code></span>
<span class="comment-copy">Also, take a look at <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow noreferrer">docs.python.org/3/library/statistics.html</a></span>
<span class="comment-copy">The code you've written won't actually work; <code>val_points = day[p]</code> will just replace the dict with a single value the first time, and then raise an exception the next time through because you're trying to use it as a dictâ€¦</span>
<span class="comment-copy">Actually, you don't need any modules here. There's a method on <code>dict</code> (try <code>help(dict)</code> to see if you can find it) that replaces that whole 4-line <code>if</code> mess you tried to write, but you don't even need that since you can just start off with <code>{'a': 0, 'b': 0, 'c': 0}</code> or <code>dict.from_keys('abc', value=0)</code>. And then there's no good reason not to just do separate loops as generator expressions passed to <code>sum</code>, which is a builtin. (<code>operator</code> could make that a little nicer, but it's not essential.)</span>
<span class="comment-copy">I don't think this is what OP asked for. He wants the "average of a, b &amp; c for the month" - sounds like one average per month to me.</span>
<span class="comment-copy">I thought he meant that each list of dicts is of one month, he didn't split to months in his own sample code which he asked the answer to do the same</span>
<span class="comment-copy">Hmm, I assumed 2-1-2014 meant Feb. 1st, 3-1-2014 March 1st, and so forth, but I see your point. We'll have to let OP enlighten us I suppose.</span>
<span class="comment-copy">Meant exactly that. Forgot about using map, been in rubyland for too long.</span>
<span class="comment-copy">where does <code>'d'</code> key came from?</span>
<span class="comment-copy">was for testing of non-existing keys. my mistake. I edited the output.</span>
