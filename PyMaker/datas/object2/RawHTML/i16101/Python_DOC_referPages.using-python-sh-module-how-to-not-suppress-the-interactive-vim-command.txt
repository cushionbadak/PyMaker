<div class="post-text" itemprop="text">
<pre><code>import sh
sh.vim("lalala")
</code></pre>
<p>does not show the vim editor in my console. Setting <code>_bg=False</code> kwarg makes no change (since that's already the default value)</p>
<p>If instead I use the <code>subprocess</code> module, it works:</p>
<pre><code>import subprocess
subprocess.call(["vim", "lalala"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>vim</code> expects its <code>stdin</code> to be a TTY, but the pipe created by <code>sh</code> is not a TTY, it's a pipe.</p>
<p>The solution is to not try to intercept <code>vim</code>'s standard I/O with pipes. Since intercepting stdio with pipes is the entire purpose of <a href="https://pypi.python.org/pypi/sh" rel="nofollow"><code>sh</code></a>, rather than trying to find a way to fight against it, you're better off not using it. Just use the stdlib's <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow"><code>subprocess</code></a> module, which only intercepts stdio if you go out of your way to ask it to:</p>
<pre><code>subprocess.check_call(['vim', 'lalala'])
</code></pre>
<hr/>
<p>But notice the <a href="http://amoffat.github.io/sh/#ttys" rel="nofollow">TTYs</a> section in the <code>sh</code> docs:</p>
<blockquote>
<p>Some applications behave differently depending on whether their standard file descriptors are attached to a TTY or not. For example, <code>git</code> will disable features intended for humans such as colored and paged output when STDOUT is not attached to a TTY. Other programs may disable interactive input if a TTY is not attached to STDIN. Still other programs, such as SSH (without <code>-n</code>), expect their input to come from a TTY/terminal.</p>
<p>By default, <code>sh</code> emulates a TTY for STDOUT but not for STDIN. You can change the default behavior by passing in extra special keyword arguments…</p>
</blockquote>
<p>So, if you pass <code>_tty_in=True</code>, then <code>vim</code>'s input will be an emulated TTY instead of a pipe.</p>
<p>But that still isn't going to do much good. It'll allow <code>vim</code> to run, but it'll run using the fake TTY created by <code>sh</code> for its input and output, which I'm pretty sure is not what you want. (If you were looking to send it control sequences and capture and process the control sequences it sends back, it would almost certainly be simpler to just script <code>ed</code>—or, better, <code>sed</code>—instead…)</p>
<hr/>
<p>So why aren't you getting some kind of error message or other sane behavior?</p>
<p>Really, that's down to <code>vim</code>. If you try the same thing with <code>emacs</code>, or any app that uses <code>curses</code>, and many other TTY apps, they'll write an error message to stderr and exit with 1, so you'll see something like this:</p>
<pre><code>ErrorReturnCode_1:

  RAN: '/usr/bin/emacs -nw'

  STDOUT:


  STDERR:
emacs: standard input is not a tty
</code></pre>
</div>
<span class="comment-copy">Using subprocess works. This seems to be an <a href="https://github.com/amoffat/sh/issues/92" rel="nofollow noreferrer">open issue on github</a></span>
<span class="comment-copy">@jameh: It looks like the open issue is that <code>_fg</code> doesn't work. (Is that the same as <code>_bg=False</code>? Not sure…) But I suspect that wouldn't be sufficient to help. <code>sh</code> by default returns the stdout of the program it runs; it doesn't let it pass through the controlling terminal's stdout. And likewise, the stdin comes from the <code>_in</code> argument, not the controlling terminal's stdin. So <code>vim</code> is not going to work anyway. But if you want to know for sure, try it with <code>pbs</code>, the predecessor to <code>sh</code>, which didn't have this issue.</span>
<span class="comment-copy">@jameh: After glancing at the docs… there <i>may</i> be an answer here. Although I don't think so, I'll edit the answer and you can try it out.</span>
<span class="comment-copy">I tried the <code>_tty_in=True</code> option, but that doesn't do what I want.</span>
<span class="comment-copy">@jameh: Yes, as I said in the answer, I don't think it's what you want. I assume your goal is to pass your stdin (your controlling terminal) straight through instead of redirecting, which isn't what <code>sh</code> is designed for.</span>
