<div class="post-text" itemprop="text">
<p>Say I have this piece of code:</p>
<pre><code>class Foo:
    def __init__(self, name):
        self.name = name

class Other:
    def __init__(self):
        str = input("Type a, b, c, or d: ")
        print(str.name)

a = Foo('apple')
b = Foo('bear')
c = Foo('chicken')
d = Foo('duck')
</code></pre>
<p>Obviously, this program won't work as <code>str</code> is a string and not an instance.
Is there any way to print the attribute <code>name</code> from the instances of the <code>Foo</code> class out using code in the <code>Other</code> class?
Or using code in the <code>Foo</code> class is the only way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're trying to access global variables using name. You can use <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow"><code>globals</code></a> to get a dictionary that map global variable names to objects:</p>
<pre><code>class Foo:
    def __init__(self, name):
        self.name = name

class Other:
    def __init__(self):
        v = input("Type a, b, c, or d: ")
        print(globals()[v].name)

a = Foo('apple')
b = Foo('bear')
c = Foo('chicken')
d = Foo('duck')

Other()
</code></pre>
<p><strong>UPDATE</strong></p>
<p>Using <code>globals</code> is a sign of bad design.</p>
<p>You'd better to use a sequence or mapping to store multiple objects.</p>
<pre><code>class Foo:
    def __init__(self, name):
        self.name = name

class Other:
    def __init__(self, mapping):
        v = input("Type a, b, c, or d: ")
        print(mapping[v].name)

foo_list = [Foo('apple'), Foo('bear'), Foo('chicken'), Foo('duck')]
mapping = {foo.name[0]: foo for foo in foo_list}  # dict comprehension
Other(mapping)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The actual way to fix this is to use <code>Other</code> class to create your <code>Foo</code> objects, and then keep these <code>Foo</code> objects as an attribute of the <code>Other</code> class.</p>
<p>Fiddling with <code>globals()</code> may do what you want, but it is not solving the bigger problem with the design:</p>
<pre><code>class Foo:
   def __init__(self, name):
      self.name = name

class Other:
   def __init__(self):
      self.foos = {'a': Foo('apple'), 'b': Foo('bear'),
                   'c': Foo('chicken'), 'd': Foo('duck')}

   def ask(self):
      i = input('Please enter a,b,c or d: ')
      obj = self.foos.get(i)
      if obj:
         print('You selected {0.name}'.format(obj))
      else:
         print('Sorry, {} is not a valid choice'.format(i))

z = Other()
z.ask()
</code></pre>
</div>
<span class="comment-copy">What are you really trying to achieve? As it stands, there is no point <code>Other</code> being a class at all.</span>
<span class="comment-copy">The alternative does not seem very practical when dealing with larger groups of objects.</span>
<span class="comment-copy">@user3774359, If that's the problem, you should use list, instead of individual variable: <code>foo_list = [Foo('apple'), Foo('bear'), Foo('chicken'), Foo('duck')] mapping = {foo.name[0]: foo for foo in foo_list}</code></span>
