<div class="post-text" itemprop="text">
<p>I would like to get the alphabetic parts of a file from some file paths.</p>
<pre><code>files = ['data/Conversion/201406/MM_CLD_Conversion_Advertiser_96337_Daily_140606.zip', 
         'data/Match/201406/MM_CLD_Match_Advertiser_111423_Daily_140608.csv.zip', 
         'data/AQlog/201406/orx140605.csv.zip',
         'data/AQlog/201406/orx140605.csv.zip/']
</code></pre>
<p>Currently I do this:</p>
<ol>
<li>strip end slashes</li>
<li>os.path.split()[1] to get filename</li>
<li>two <code>os.path.splitext()</code> to remove a possible 2 file extensions</li>
<li>lose the numbers</li>
<li>lose the underscores</li>
</ol>
<p>Code:</p>
<pre><code>for f in files:
    a = os.path.splitext(os.path.splitext(os.path.split(f.rstrip('/\\'))[1])[0])[0]
    b = re.sub('\d+', '', a).replace('_','')
</code></pre>
<p>Result:</p>
<pre><code>'MMCLDConversionAdvertiserDaily'
'MMCLDMatchAdvertiserDaily'
'orx'
'orx'
</code></pre>
<p>Is there a faster or more pythonic way, using a compiled regex function? Or is trying to use the library <code>os.path()</code> very reasonable? I also do not have to do this more than 100 times, so it's not a speed problem, this is just for clarity.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simplify this by using the appropriate functions from <code>os.path</code>.</p>
<p>First, f you call <a href="https://docs.python.org/3/library/os.path.html#os.path.normpath" rel="nofollow"><code>normpath</code></a> you no longer have to worry about both kinds of path separators, just <code>os.sep</code> (note that this is a <em>bad</em> thing if you're trying to, e.g., process Windows paths on Linux… but if you're trying to process native paths on any given platform, it's exactly what you want). And it also removes any trailing slashes.</p>
<p>Next, if you call <a href="https://docs.python.org/3/library/os.path.html#os.path.basename" rel="nofollow"><code>basename</code></a> instead of <code>split</code>, you no longer have to throw in those trailing <code>[1]</code>s.</p>
<p>Unfortunately, there's no equivalent of <code>basename</code> vs. <code>split</code> for <code>splitext</code>… but you can write one easily, which will make your code more readable in the exact same way as using <code>basename</code>.</p>
<p>As for the rest of it… regexp is the obvious way to strip out any digits (although you really don't need the <code>+</code> there). And, since you've already got a regexp, it might be simpler to toss the <code>_</code> in there instead of doing it separately.</p>
<p>So:</p>
<pre><code>def stripext(p):
    return os.path.splitext(p)[0]

for f in files:
    a = stripext(stripext(os.path.basename(os.path.normpath(f))))
    b = re.sub(r'[\d_]', '', a)
</code></pre>
<p>Of course the whole thing is probably more readable if you wrap if up as a function:</p>
<pre><code>def process_path(p):
    a = stripext(stripext(os.path.basename(os.path.normpath(f))))
    return re.sub(r'[\d_]', '', a)

for f in files:
    b = process_path(f)
</code></pre>
<p>Especially since you can now turn your loop into a list comprehension or generator expression or <code>map</code> call:</p>
<pre><code>processed_files = map(process_path, files)
</code></pre>
<hr/>
<blockquote>
<p>I'm simply curious about the speed, as I'm under the impression compiled regex functions are very fast.</p>
</blockquote>
<p>Well, yes, in general. However, uncompiled string patterns are also very fast.</p>
<p>When you use a string pattern instead of a compiled regexp object, what happens is this:</p>
<ul>
<li>The <code>re</code> module looks up the pattern in a cache of compiled regular expressions.</li>
<li>If not found, the string is compiled and the result added to the cache.</li>
</ul>
<p>So, assuming you don't use many dozens of regular expressions in your app, either way, your pattern gets compiled exactly once, and run as a compiled expression repeatedly. The only additional cost to using the uncompiled expressions is looking it up in that cache dictionary, which is incredibly cheap—especially when it's a string literal, so it's guaranteed to be the exact same string object every time, so its hash will be cached as well, so after the first time the dict lookup turns into just a <code>mod</code> and an array lookup.</p>
<p>For most apps, you can just assume the <code>re</code> cache is good enough, so the main reason for deciding whether to pre-compile regular expressions or not is readability. For example, when you've got, e.g., a function that runs a slew of complicated regular expressions whose purpose is hard to understand, it can definitely help to give each one of them a name, so you can write <code>for r in (r_phone_numbers, r_addresses, r_names): …</code>, in which case it would be almost silly not to compile them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without using regular expressions:</p>
<pre><code>import os
import string
trans = string.maketrans('_', ' ')
def get_filename(path):
    # If you need to keep the directory, use os.path.split
    filename = os.path.basename(path.rstrip('/'))
    try:
        # If the extension starts at the last period, use
        # os.path.splitext
        # If the extension starts at the 2nd to last period,
        # use os.path.splitext twice
        # Continuing this pattern (since it sounds like you
        # don't know how many extensions a filename may have,
        # it may be safer to assume the file extension starts
        # at the first period. In which case, use
        # filename.split('.', 1).
        filename_without_ext, extension = filename.split('.', 1)
    except ValueError:
        filename_without_ext = filename
        extension = ''
    filename_cleaned = filename_without_ext.translate(trans, string.digits)
    return filename_cleaned

&gt;&gt;&gt; path = 'data/Match/201406/MM_CLD_Match_Advertiser_111423_Daily_140608.csv.zip/'
&gt;&gt;&gt; get_filename(path)
'MM CLD Match Advertiser  Daily '
</code></pre>
<p>Do whatever approach is more readable. I usually avoid regular expressions if the problem doesn't require it. In this case, regular string operations can do everything you want to do.</p>
<p>If you want to remove extra spaces (as indicated in your Result), use <code>filename.replace(' ', '')</code>. If you are likely to have other kinds of whitespace, it can be removed by <code>''.join(filename.split())</code></p>
<p>Note: If you are using Python 3, replace <code>trans=string.maketrans('_', ' ')</code> with <code>trans=str.maketrans('_', ' ', string.digits)</code>, and <code>filename_without_ext.translate(trans, string.digits)</code> with <code>filename_without_ext.translate(trans)</code>. <a href="https://docs.python.org/3.1/library/stdtypes.html#bytes.maketrans" rel="nofollow noreferrer">This change</a> was made as part of improving unicode language support. See more: <a href="https://stackoverflow.com/questions/3031045/how-come-string-maketrans-does-not-work-in-python-3-1">How come string.maketrans does not work in Python 3.1?</a></p>
<p>Here's the Python 3 code:</p>
<pre><code>import os
import string
trans = string.maketrans('_', ' ', string,digits)
def get_filename(path):
    filename = os.path.basename(path.rstrip('/'))
    filename_without_ext = filename.split('.', 1)[0]
    filename_cleaned = filename_without_ext.translate(trans)
    return filename_cleaned
</code></pre>
</div>
<span class="comment-copy">Why do you ask "Is there a faster… way" when in the very next sentence you say "I also do not have to do this more than 100 times, so it's not a speed problem"? If speed isn't an issue, why ask for speed?</span>
<span class="comment-copy">Also, do you know how to find the docs? If so, why use, e.g., <a href="https://docs.python.org/3/library/os.path.html#os.path.split" rel="nofollow noreferrer"><code>os.path.split()[1]</code></a> instead of <a href="https://docs.python.org/3/library/os.path.html#os.path.basename" rel="nofollow noreferrer"><code>os.path.basename()</code></a>?</span>
<span class="comment-copy">hi @abarnert! I'm simply curious about the speed, as I'm under the impression compiled regex functions are very fast. And yep, missed <code>os.path.basename()</code>, as I've played around with os.path before and didn't look carefully at the docs this time around.</span>
<span class="comment-copy">I'll add something to my answer about compiled regexps…</span>
<span class="comment-copy">You're not stripping out the numbers, which the OP asked for, and is doing—and which is a perfect example of the kind of thing regexps are good for and regular string operations are not…</span>
<span class="comment-copy">Fixed using string translation's deletechars argument.</span>
<span class="comment-copy">OK, it now works—although it's also now more than 80 characters wide, and doesn't work in Python 3.x anymore. I'm not sure it's worth going to such extents to avoid regular expressions (any more than it's worth going to ridiculous extents to use them even when they're unnecessary, as so many people do…), but it's at least worth showing how to do so, so definitely +1. (But it would be better to be PEP8 compliant and not have a horizontal scrollbar, and to explain the 2.x-3.x difference you've added.)</span>
<span class="comment-copy">@abarnert Thanks for the help cleaning up this answer.</span>
<span class="comment-copy">Your last paragraph isn't what you want for Python 3. Your filenames are <code>str</code>, not <code>bytes</code>, so you can't use a <code>bytes.maketrans</code>. What you want is <code>str.maketrans</code>. But, more importantly, <code>str.translate</code> no longer takes a second argument; you want to pass the characters to be deleted as a third argument to <code>str.maketrans</code> instead. (Also, in both 2.x and 3.x, you might as well use <code>string.digits</code>.)</span>
