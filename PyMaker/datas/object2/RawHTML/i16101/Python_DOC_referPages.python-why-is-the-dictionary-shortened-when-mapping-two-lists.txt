<div class="post-text" itemprop="text">
<p>I have two large lists, equal lengths 0f 2574 items a piece. I want to map the items into a dictionary, because when mapped, I want to know which values are different from their keys. One value per key. When I map them however, I get a much shorter dictionary with length 76. </p>
<p>Here's a test:</p>
<pre><code>Python 2.7.6 (default, Mar 22 2014, 22:59:56) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; list1 = [1, 1, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 10]
&gt;&gt;&gt; list2 = [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 9, 10]
&gt;&gt;&gt; 
&gt;&gt;&gt; listdict = dict(zip(list1, list2))
&gt;&gt;&gt; print len(list1)
14
&gt;&gt;&gt; print len(list2)
14
&gt;&gt;&gt; print len(listdict)
8
&gt;&gt;&gt; print listdict
{1: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 9, 10: 10}
</code></pre>
<p>So why does using dict(zip()) remove the 1's that would map to one another and the 8's that would map to one another but keeps everything else? Basically, the two lists I ahve are equal length, and for each index I need to know if the item is different. Positions in each list for comparisons must match. So list1[0] to list2[0], and nowhere else. when I got the dictionary I figured something like this would work:</p>
<pre><code>for k,v in listdict:
if k != v:
print k, '\t', v
</code></pre>
<p>but they're not matching up...</p>
</div>
<div class="post-text" itemprop="text">
<p>As other answers clarify, <code>dict</code>s require the keys to be unique.</p>
<p>It sounds like you would prefer a list of tuples and not a dictionary.  So instead of <code>listdict = dict(zip(list1, list2))</code>, try this: <code>listtup = list(zip(list1, list2))</code></p>
<pre><code>&gt;&gt;&gt; list1 = [1, 1, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 10]
&gt;&gt;&gt; list2 = [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 9, 10]
&gt;&gt;&gt; listtup = list(zip(list1, list2))
&gt;&gt;&gt; listtup
[(1, 1), (1, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (8, 8), (8, 8), (8, 8), (8, 8), (8, 9), (10, 10)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary keys must be <em>unique</em>. Only the last <code>1</code> key survived, as did the last <code>8</code> key.</p>
<p>When you specify a key more than once, only one (the 'last one' processed) <em>wins</em>:</p>
<pre><code>&gt;&gt;&gt; {1: 1, 1: 2}
{1: 2}
</code></pre>
<p>If you wanted to find out what values differ from their key, don't use a dictionary, just collect the pairs that differ:</p>
<pre><code>different = [pair for pair in zip(list1, list2) if pair[0] != pair[1]]
</code></pre>
<p>You can add indices to this with <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a>:</p>
<pre><code>different = [(i, pair) for i, pair in enumerate(zip(list1, list2)) if pair[0] != pair[1]]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; list1 = [1, 1, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 10]
&gt;&gt;&gt; list2 = [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 9, 10]
&gt;&gt;&gt; [pair for pair in zip(list1, list2) if pair[0] != pair[1]]
[(1, 2), (8, 9)]
&gt;&gt;&gt; [(i, pair) for i, pair in enumerate(zip(list1, list2)) if pair[0] != pair[1]]
[(1, (1, 2)), (12, (8, 9))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A dict maps each key to exactly one value. If you set the same key multiple times to different values (or, of course, to the same values), each one overrides the previous one. So, for example:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d[1] = 23
&gt;&gt;&gt; d
{1: 23}
&gt;&gt;&gt; d[1] = 69105
&gt;&gt;&gt; d
{1: 69105}
</code></pre>
<p>If you want to store multiple values per key, what you want is a "multidict", not a dict. Python doesn't have such a thing built in, but it's pretty easy to simulate with <code>defaultdict</code>:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; d = collections.defaultdict(set)
&gt;&gt;&gt; d[1].add(23)
&gt;&gt;&gt; d
{1: {23}}
&gt;&gt;&gt; d[1].add(69105)
&gt;&gt;&gt; d
{1: {69105, 23}}
</code></pre>
<p>So, if you want a function that creates a multidict from an iterable of pairs, you can write it pretty easily:</p>
<pre><code>def make_multidict(pairs):
    d = collections.defaultdict(set)
    for k, v in pairs:
        d[k].add(v)
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In order to preserve both the item in <code>list1</code> and its position, use <code>enumerate</code>.</p>
<pre><code>&gt;&gt;&gt; listdict = dict(zip(enumerate(list1), list2))
&gt;&gt;&gt; listdict
{(0, 1): 1, (10, 8): 8, (6, 7): 7, (5, 6): 6, (7, 8): 8, (9, 8): 8, (13, 10): 10, (4, 5): 5, (8, 8): 8, (2, 3): 3, (11, 8): 8, (3, 4): 4, (1, 1): 2, (12, 8): 9}
</code></pre>
<p>Each key in <code>listdict</code> is a tuple consisting of an index from <code>list1</code> and the item at that position.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to preserve the length and order of elements as in the lists, use </p>
<pre><code>OrderedDict(zip(list1,list2))
</code></pre>
</div>
<span class="comment-copy">try <code>len(set(list1))</code> same issue -- you have uniquified list1</span>
<span class="comment-copy">Good answer demonstrating the issue and provide clear solution of what the questioner wanted, i.e '... because when mapped, I want to know which values are different from their keys'</span>
<span class="comment-copy">OK, that makes sense. Would using defaultdict do the same thing? How can I compare each item's position to the corresponding position in each list?</span>
<span class="comment-copy">@user3358205: Using <code>defaultdict</code> without changing anything else will do the same thingâ€¦ but you can easily change it to do what you want. I've edited the answer to demonstrate.</span>
<span class="comment-copy">@OllieFord I was referring to the positions in the lists, to perhaps avoid a dictionary key/value comparison.</span>
<span class="comment-copy">@user3358205: I don't understand the second question in your comment, even after the followup comment. You're <code>zip</code>ping the lists, so their corresponding elements are already matched up. Is there something else that needs to be matched up to something else?</span>
