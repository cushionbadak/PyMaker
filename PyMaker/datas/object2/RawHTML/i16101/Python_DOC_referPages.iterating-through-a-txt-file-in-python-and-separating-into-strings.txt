<div class="post-text" itemprop="text">
<p>I am trying to make a Python script that iterates through a .txt file. The files are generally 600-800 lines long and the format of them is as follows:</p>
<pre><code>==========
ID: 10001      Found:(4)
==========
MSG: ERR_ID  - ***ERROR*** _errortexthere_

==========
ID: 10002      Found:(26)
==========
MSG: ERR_ID  - ***ERROR*** _errortexthere_
line2
line3
line4
line5

==========
ID: 10003      Found:(15039)
==========
MSG: ERR_ID  - ***ERROR*** _errortexthere_
etc1
etc2
etc3
</code></pre>
<p>Basically, I want to read from 'ID:' to 'ID:' and store all of the text between them in a string (or array, dictionary, what have you). The problem is, the amount of lines varies greatly between the 'ID:'s thus managing them by line number wouldn't be much help. I am fairly new to Python and am not as familiar with the basic syntax as I am with other languages. I have done a fair amount of searching on SO and found many questions similar or close to what I need, but not precisely. Any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a <strong>very simple</strong> implementation that only detects lines that start with the <strong>exact string</strong> "<code>ID:</code>". It ignores blank lines and lines that exactly match <code>==========</code>.</p>
<p>It saves the lines following each <code>ID:</code> to a dictionary, with the keys of that dictionary being the ID strings.</p>
<pre><code>from io import BytesIO
from pprint import pprint

infile = BytesIO("""
==========
ID: 10001      Found:(4)
==========
MSG: ERR_ID  - ***ERROR*** _errortexthere_

==========
ID: 10002      Found:(26)
==========
MSG: ERR_ID  - ***ERROR*** _errortexthere_
line2
line3
line4
line5
""")


buffer = ""
d = {}
id = None

for line in infile:
    if line.rstrip() in ("==========",""):
        # skip blank lines or delimiting lines
        pass
    elif line.startswith("ID: "):
        # save the buffer we've been collecting to the dictionary...
        if id is not None:        
            d[id] = buffer

        # ... and start collecting new lines
        id = line.split()[1]
        buffer = ""
    else:
        buffer += line
else:
    # save whatever lines are leftover after the last `ID:`
    if id is not None:
        d[id] = buffer

pprint(d)
</code></pre>
<p>Output:</p>
<pre><code>{'10001': 'MSG: ERR_ID  - ***ERROR*** _errortexthere_\n',
 '10002': 'MSG: ERR_ID  - ***ERROR*** _errortexthere_\nline2\nline3\nline4\nline5\n'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should just read line by line and check to see if the first element in the line is <code>ID</code></p>
<pre><code>f = open('workfile', 'r')
for line in f:
    arr = line.split(" ")
    if(arr[0] == "ID:"):
       # do what you need too 
</code></pre>
</div>
<span class="comment-copy">What do you have so far? You can use <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open()</code></a> to open a file and <a href="https://docs.python.org/3/tutorial/inputoutput.html" rel="nofollow noreferrer"><code>.readlines()</code></a> to get the lines of the file.</span>
