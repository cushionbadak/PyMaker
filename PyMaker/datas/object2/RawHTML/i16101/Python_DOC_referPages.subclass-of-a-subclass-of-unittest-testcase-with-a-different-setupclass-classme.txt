<div class="post-text" itemprop="text">
<p>I currently have a subclass of unittest.TestCase which I use to run my selenium tests:</p>
<pre><code>class FunctionalTest(unittest.TestCase):

    @classmethod
    def setUpClass(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(1)

    @classmethod    
    def tearDownClass(self):
        self.browser.close()

    def method1(self):
        #some code here

    def method2(self):
        #some code here
</code></pre>
<p>I would like to subclass this class (FunctionalTest), where I would like to change the setUpClass method to disable javascript for the firefox browser, but still be able to use all the other methods of FunctionalTest :</p>
<pre><code>    @classmethod
    def setUpClass(self):
        profile = webdriver.FirefoxProfile()
        profile.set_preference("javascript.enabled", False);
        self.browser = webdriver.Firefox(profile)              
        self.browser.implicitly_wait(1)
</code></pre>
<p>Subclassing like the following is not working:</p>
<pre><code>FunctionalTestNoJS(FunctionalTest):
    @classmethod
    def setUpClass(self):
        profile = webdriver.FirefoxProfile()
        profile.set_preference("javascript.enabled", False);
        self.browser = webdriver.Firefox(profile)              
        self.browser.implicitly_wait(1)
</code></pre>
<p>Any ideas on how to effectively go about this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This worked for me, I'm not sure of the reason for having @classmethod, but here ya go.. </p>
<pre><code>import unittest
from selenium import webdriver
from datetime import datetime


class FunctionalTest(unittest.TestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(1)
        self.browser.maximize_window()

    def tearDown(self):
        self.browser.quit()

    def test_method1(self):
        self.browser.get("http://javatester.org/javascript.html")
        now = datetime.now().strftime('%Y-%m-%d_%H-%M-%S-%f')
        self.browser.get_screenshot_as_file('%s_%s.png' % (self.__class__.__name__, now))


class FunctionalTestNoJS(FunctionalTest):
    def setUp(self):
        profile = webdriver.FirefoxProfile()
        profile.set_preference("javascript.enabled", False);
        self.browser = webdriver.Firefox(profile)              
        self.browser.implicitly_wait(1)
        self.browser.maximize_window()

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">Define 'not working' in this case?</span>
<span class="comment-copy">Overriding the class method just works <i>normally</i>, see <a href="https://docs.python.org/3/library/unittest.html#setupclass-and-teardownclass" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">Try removing @classmethod? and isn't the method just supposed to be named setUp()?</span>
<span class="comment-copy">@d_rez90: no, it is a class method and it is run once per <code>TestCase</code> class.</span>
<span class="comment-copy">Actually, a recent upgrade of Firefox is the source of my broken Selenium tests; I though the new test was not working b/c I was subclassing incorrectly.</span>
<span class="comment-copy">Actually, a recent upgrade of Firefox is the source of my broken Selenium tests; I though the new test was not working b/c I was subclassing incorrectly.</span>
<span class="comment-copy">Thanks for the code, I was looking for something similar. It resolved my problem as well</span>
