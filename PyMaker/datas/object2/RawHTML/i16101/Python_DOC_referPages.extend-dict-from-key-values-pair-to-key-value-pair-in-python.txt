<div class="post-text" itemprop="text">
<pre><code>myDict = {'121': ['adrian', 'alex', 'peter'], '122': ['john', 'vic', 'bill']}
</code></pre>
<p>I want to 'extend' my dictionary so that each key/value pair consists of one value, instead of a list. Tried iterating with myDict.keys() and myDict.values() and construct a new dict, didnt work out (i'm quite new to python3). This is what I want to achieve:</p>
<pre><code>myNewDict = {'121': 'adrian', '121': 'alex', '121': 'peter', '122': 'john', '122': 'vic', '122':'bill'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on comments above, here's how to invert the dict and allow multiple values for each key:</p>
<pre><code>from collections import defaultdict
myNewDict = defaultdict(list)
for staff_id, names in myDict.items():
    for name in names:
        myNewDict[name].append(staff_id)
</code></pre>
<p>You might use a <code>defaultdict</code> of <code>set</code> and <code>add</code> instead of <code>list</code> and <code>append</code> if order doesn't matter:</p>
<pre><code>from collections import defaultdict
myNewDict = defaultdict(set)
for staff_id, names in myDict.items():
    for name in names:
        myNewDict[name].add(staff_id)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care about collisions being clobbered, here's a 1-line solution (plus import):</p>
<pre><code>import functools                                                                   
myDict = {'121': ['adrian', 'alex', 'peter'], '122': ['john', 'vic', 'bill']}   

print(functools.reduce( lambda x,y: dict(x, **y), (dict(map(lambda x: (x,i), myDict[i])) for i in myDict)))
</code></pre>
<hr/>
<p>To break apart what this is doing:</p>
<pre><code># This is a generator that creates a new dictionary out of each key/valuelist

(dict(map(lambda val: (val,key), myDict[key])) for key in myDict)

# =&gt; {'adrian': '121', 'alex': '121': 'peter': '121'}
# =&gt; {'john': '122', 'bill': '122', 'vic': '122'}
</code></pre>
<hr/>
<p>Once you have that,then call</p>
<pre><code>functools.reduce( lambda x,y: dict(x, **y), &lt;generator here&gt;)
</code></pre>
<p><a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow">Reduce</a> takes a function and applies it</p>
<blockquote>
<p>cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value.</p>
</blockquote>
<p><code>dict(mydict, **yourdict)</code> combines dictionaries by way of <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">argument unpacking</a>.</p>
<p>Which means that this takes the first dictionary from the list, and combines it with the next dictionary in the list, and so-on and so-forth until all the dictionaries in the list have been combined into one grand dictionary.</p>
<hr/>
<p>All that being said, I'd probably do something like this instead:</p>
<pre><code>inverted = dict((name, k) for k, v in myDict.items() for name in v) 
</code></pre>
<p>Alternate syntax using a dictionary comprehension:</p>
<pre><code>inverted = {name: k for k, v in myDict.items() for name in v}
</code></pre>
</div>
<span class="comment-copy">This is not possible as there cannot be multiple entries for the same key. You will overwrite the value over and over again. Just check what your posted code does.</span>
<span class="comment-copy">look at map operations</span>
<span class="comment-copy">As @Nras said you can't have multiple entries for one key. What are you trying to do once you have your (hypothetical) dictionary?</span>
<span class="comment-copy">As it stands, you're really asking how to build a tuple out of a dictionary.</span>
<span class="comment-copy">I see. Wat I eventually was trying to achieve is to do a swap of unique values. So each 'unique name' would get one or more 'numbers' as their value.  <code>myNewDict = {'adrian': '121', 'alex': '121'}</code>  if for example adrian will pop up again in myDict with number 130 or so. Then:  <code>myNewDict = {'adrian': ['121', 130'], 'alex': '121'}</code></span>
<span class="comment-copy">Throws an error:     <code>myNewDict[name].add(staff_id) TypeError: unhashable type: 'list'</code></span>
<span class="comment-copy">Oh right, fixing.</span>
<span class="comment-copy">Thanks a bunch!! got it now with datastructure set() since it lists only unique values.</span>
<span class="comment-copy">Unless I'm missing something, these preserve only one value if a name appears more than once. The OP clarifies in comments that collisions need to be maintained: " if for example adrian will pop up again in myDict with number 130 or so. Then:  <code>myNewDict = {'adrian': ['121', 130'], 'alex': '121'}</code>"</span>
<span class="comment-copy">indeed @PeterDeGlopper, that is what I want</span>
<span class="comment-copy">Are you sure that's what you want, @klabanus? Or do you want <code>{'adrian': ['121', '130'], 'alex': ['121']}</code>? Because those are pretty fundamentally different, in terms of what you can do with them.</span>
<span class="comment-copy">Good point @WayneWerner, eventually the id's need to be in a list, even if it's only one value.</span>
