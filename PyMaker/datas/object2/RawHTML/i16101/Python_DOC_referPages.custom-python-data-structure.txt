<div class="post-text" itemprop="text">
<p>I have a class that wraps around python <code>deque</code> from <code>collections</code>. When I go and create a deque <code>x=deque()</code>, I create a empty <code>deque</code> object. So if I fill it up: <code>x.append(0)</code> and simply type in <code>x</code> on the console, i get:</p>
<pre><code>In[78]: x
Out[78]: deque([0])
</code></pre>
<p>My question is how can I output the same thing as above when I have a wrapper for class <code>deque</code>. For example.</p>
<pre><code>class deque_wrapper:
    def __init__(self):
        self.data_structure = deque()

    def newCustomAddon(x):
        return len(self.data_structure)
</code></pre>
<p>Ie</p>
<pre><code>In[74]: x = deque_wrapper()
In[75]: x
Out[75]: &lt;__main__.deque_wrapperat 0x7e3d0f0&gt;
</code></pre>
<p>I want to customize what gets printed out as oppose to just a memory location. What can I do?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to customize what gets printed out as oppose to just a memory location. What can I do?</p>
</blockquote>
<p>This is exactly what <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow"><code>__repr__</code></a> is for:</p>
<blockquote>
<p>Called by the <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow"><code>repr()</code></a> built-in function to compute the “official” string representation of an object. If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form <code>&lt;...some useful description...&gt;</code> should be returned.</p>
</blockquote>
<p>Because you didn't define a <code>__repr__</code>, you're getting the default implementation from <code>object</code> (assuming Python 3… otherwise, you've written a classic class, which is a bad idea, and you don't want to learn how they get their defaults when you can just stop using them…), which just returns that string with the object's type name and address.</p>
<p>Note the <code>__str__</code> method below <code>__repr__</code> in the docs. If the most human-readable representation and the valid-Python-expression representation are not the same, define both methods. Otherwise, just define <code>__repr__</code>, and <code>__str__</code> will use it by default.</p>
<hr/>
<p>So, if you want to print the exact same thing as <code>deque</code>, just delegate <code>__repr__</code>:</p>
<pre><code>def __repr__(self):
    return repr(self.data_structure)
</code></pre>
<p>If you want to wrap it in something:</p>
<pre><code>def __repr__(self):
    return '{}({!r})'.format(type(self).__name__, self.data_structure)
</code></pre>
<p>Note that I didn't call <code>repr</code> in the second version, because that's exactly what <code>!r</code> means in a format string. But really, in this case, you don't need <em>either</em>; a <code>deque</code> has the same <code>str</code> and <code>repr</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Delegate the generation of the representation.</p>
<pre><code>class deque_wrapper:
   ...
  def __repr__(self):
    return repr(self.data_structure)
</code></pre>
</div>
<span class="comment-copy">One other issue tehre: in Python 2.x, you have to inherit from "object" - just inheriting from "nothing" will fail you in subtle and hard to debug ways.</span>
<span class="comment-copy"><code>deque</code> always has building in array like referencing. From my above example, how can I let my custom function use <code>x[0]</code>? Cause right now I can print it out all good, but I can using <code>x[n-th element]</code></span>
