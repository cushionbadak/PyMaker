<div class="post-text" itemprop="text">
<p>So I have modified the example of asyncio client and server (found here: <a href="https://docs.python.org/3/library/asyncio-protocol.html#protocol-example-tcp-echo-server-and-client" rel="nofollow">https://docs.python.org/3/library/asyncio-protocol.html#protocol-example-tcp-echo-server-and-client</a>) and all I want is for client.py to call serverone.py, and in turn for it to call servertwo.py.</p>
<p><strong>client.py</strong></p>
<pre><code>#!/usr/bin/env python3.4
import asyncio

class EchoClient(asyncio.Protocol):
    message = 'This is the Client'

    def connection_made(self, transport):
        transport.write(self.message.encode())

    def data_received(self, data):
        print('data received: {}'.format(data.decode()))

    def connection_lost(self, exc):
        asyncio.get_event_loop().stop()

loop = asyncio.get_event_loop()
coro = loop.create_connection(EchoClient, '127.0.0.1', 8888)
loop.run_until_complete(coro)
loop.run_forever()
loop.close()
</code></pre>
<p><strong>serverone.py</strong></p>
<pre><code>#!/usr/bin/env python3.4

import asyncio

class EchoClient(asyncio.Protocol):
    message = 'Server One sending message'

    def connection_made(self, transport):
        transport.write(self.message.encode())

    def data_received(self, data):
        print('data received: {}'.format(data.decode()))

    def connection_lost(self, exc):
        asyncio.get_event_loop().stop()

class EchoServer(asyncio.Protocol):
    def connection_made(self, transport):
        peername = transport.get_extra_info('peername')
        self.transport = transport

    def data_received(self, data):
        loop = asyncio.get_event_loop()
        coro = loop.create_connection(EchoClient, '127.0.0.1', 8889)
        loop.run_until_complete(coro)
        # close the socket
        self.transport.close()
        loop.close()

loop = asyncio.get_event_loop()
coro = loop.create_server(EchoServer, '127.0.0.1', 8888)
server = loop.run_until_complete(coro)
try:
    loop.run_forever()
except KeyboardInterrupt:
    print("exit")
finally:
    server.close()
    loop.close()
</code></pre>
<p><strong>servertwo.py</strong></p>
<pre><code>#!/usr/bin/env python3.4

import asyncio

class EchoServer(asyncio.Protocol):
    def connection_made(self, transport):
        peername = transport.get_extra_info('peername')
        self.transport = transport

    def data_received(self, data):
        print('data received: {}'.format(data.decode()))
        self.transport.write(data)
        # close the socket
        self.transport.close()

loop = asyncio.get_event_loop()
coro = loop.create_server(EchoServer, '127.0.0.1', 8889)
server = loop.run_until_complete(coro)
try:
    loop.run_forever()
except KeyboardInterrupt:
    print("exit")
finally:
    server.close()
    loop.close()
</code></pre>
<p>I launch <code>servertwo.py</code> and <code>serverone.py</code> in a terminal, then call <code>client.py</code>. Things partially work; the client does call serverone which does call servertwo, but then serverone fails with this error:</p>
<pre><code>Exception in callback &lt;bound method _SelectorSocketTransport._read_ready of &lt;asyncio.selector_events._SelectorSocketTransport object at 0x7fbf4453b048&gt;&gt;()
handle: Handle(&lt;bound method _SelectorSocketTransport._read_ready of &lt;asyncio.selector_events._SelectorSocketTransport object at 0x7fbf4453b048&gt;&gt;, ())
Traceback (most recent call last):
  File "/usr/lib64/python3.4/asyncio/events.py", line 39, in _run
    self._callback(*self._args)
  File "/usr/lib64/python3.4/asyncio/selector_events.py", line 458, in _read_ready
    self._protocol.data_received(data)
  File "./serverone.py", line 25, in data_received
    loop.run_until_complete(coro)
  File "/usr/lib64/python3.4/asyncio/base_events.py", line 203, in run_until_complete
    self.run_forever()
  File "/usr/lib64/python3.4/asyncio/base_events.py", line 179, in run_forever
    raise RuntimeError('Event loop is running.')
RuntimeError: Event loop is running.
</code></pre>
<p>The documentation doesn't cover a lot of odd use cases, so I'm a bit stuck. Should I be using <code>asyncio.async</code> to make the call? Am I approaching the problem correctly?</p>
<p>How do I fix or avoid the <code>RuntimeError</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.async" rel="nofollow"><code>asyncio.async</code></a> to schedule the coroutine returned by <code>create_connection</code> to be run by the event loop, and then use the <code>add_done_callback</code> method of the <code>asyncio.Future</code> (more specifically, an <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task" rel="nofollow"><code>asyncio.Task</code></a>) that <code>async</code> returns to shut down the loop once the coroutine is done:</p>
<pre><code>class EchoServer(asyncio.Protocol):
    def connection_made(self, transport):
        peername = transport.get_extra_info('peername')
        self.transport = transport

    def data_received(self, data):
        loop = asyncio.get_event_loop()
        coro = loop.create_connection(EchoClient, '127.0.0.1', 8890)
        fut = asyncio.async(coro)
        fut.add_done_callback(self.shutdown)

    def shutdown(self, *args):
        self.transport.close()
        loop.stop()
</code></pre>
</div>
<span class="comment-copy">I'd hardly call this an "odd" use case. Writing a server which needs to make outbound asynchronous calls in the course of serving an inbound request seems pretty usual to me. Came here looking for examples on how to do exactly that.</span>
<span class="comment-copy">That answer definitely gives me a leg up, but even without the <code>shutdown()</code> method, the server will stop once it runs the <code>async</code> call. I've tried adding <code>run_forever()</code> in the <code>data_recieved()</code> method but to no avail. I can't have the server stopping after it makes a call to the other server. But +1 for a call that doesn't end in an exception.</span>
<span class="comment-copy">I should explain. The question I asked was a simplified problem of what I was facing. My real problem was that I needed to communicate between multiple daemons (already forked). By adding in your solution, the daemons keep running and I can call the server multiple times without the loop dying on me, so that does solve my problem. However, in my example, <code>serverone.py</code> still exits its loop.</span>
<span class="comment-copy">@NuclearPeon That's because you stop the event loop in <code>EchoClient.connection_lost</code>. Don't do that! :)</span>
<span class="comment-copy">Aha! I also removed the <code>loop.stop()</code> in <code>shutdown()</code> and it all works as expected! Thank you so much @dano!</span>
