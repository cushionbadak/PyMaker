<div class="post-text" itemprop="text">
<p>Can somebody explain to me why, in the following code <code>ext</code> is reachable within the <code>MP3File</code> class, but not within its <code>play</code> method?  Sorry for the short question, that is all I need to know.</p>
<pre><code>class MP3File(AudioFile):
    ext = 'mp3'
    print(ext)

    def play(self):
        print(ext) #NameError: global name 'ext' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>ext</code> is not a global, it is <em>temporarily</em> a local when the class is being created. From the <a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow"><code>class</code> statement documentation</a>:</p>
<blockquote>
<p>The class’s suite is then executed in a new execution frame (see <a href="https://docs.python.org/3/reference/executionmodel.html#naming" rel="nofollow"><em>Naming and binding</em></a>), <strong>using a newly created local namespace</strong> and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved.</p>
</blockquote>
<p>Emphasis mine. The local namespace then forms the class attributes.</p>
<p>By the time your <code>MP3File.play()</code> method is being called, that local namespace is long since gone; you cannot just refer to <code>ext</code> as if it still exists. It is now a class attribute instead!</p>
<p>You can address that attribute via the <code>self</code> reference to an instance. Unless the instance <em>also</em> has an <code>ext</code> attribute, the class attribute is found and returned instead:</p>
<pre><code>def play(self):
    print(self.ext)
</code></pre>
<p>or you can find it on the class:</p>
<pre><code>def play(self):
    print(MP3File.ext)
</code></pre>
</div>
<span class="comment-copy">Because it's a class attribute, use <code>self.ext</code>.</span>
<span class="comment-copy"><b>"its execution frame is discarded but its local namespace is saved."</b>  To me this makes it sound like the variable would be deleted altogether.   Am I right that what is actually happening (strangely, to me) is that it transforms from a 'temporary local variable' to a class attribute with no sort of assignment necessary?</span>
<span class="comment-copy">@Startec: the local names created in the execution frame are used as the attributes on the class object. The assignment has already taken place; it is just a question of using transforming the local namespace into a dictionary; e.g. enumerate the local names as keys, and their values as the associated values in the dictionary.</span>
<span class="comment-copy">@Startec: if you want to know more about that process, read <a href="http://stackoverflow.com/q/100003">What is a metaclass in Python?</a></span>
