<div class="post-text" itemprop="text">
<p>I have a generator for a powerset of a list in python and I want do some calculations to the elements of these set using the multiprocessing module. My code looks like:</p>
<pre><code>def powerset(seq): 
  '''Returns all the subsets of the list. This is a generator.'''
  if len(seq) == 0:
    yield seq
  if len(seq) == 1:
    yield seq 
    yield []
  elif len(seq) &gt; 1: 
    for item in powerset(seq[1:]):
      yield [seq[0]]+item
      yield item

def job(l):
  # do some calculation with the list l
  return do_some_hard_work(l)

def calculate():
  pool_size = multiprocessing.cpu_count() * 2
  pool = multiprocessing.Pool(processes=pool_size, maxtasksperchild=2)
  pool_outputs = pool.map(job, powerset(list(range(1,10)))
  pool.close()
  pool.join()

  return sum(pool_outputs)
</code></pre>
<p>The problem is that the powerset-function is a generator and that will not work. But I can not replace the generator, because of generate the hole powerset before the calculation needs to much time and memory. Has anyone an idea how I can solve this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the issue is that you want to avoid having to put the whole powerset in a list, you can use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap" rel="nofollow"><code>pool.imap</code></a>, which will consume your iterator <code>chunksize</code> elements at a time, and send those off to the worker processes, rather than converting the whole thing into a list and chunking that up.</p>
<pre><code>pool_size = multiprocessing.cpu_count() * 2
pool = multiprocessing.Pool(processes=pool_size, maxtasksperchild=2)
pool_outputs = pool.imap(job, powerset(list(range(1,10))), chunksize=&lt;some chunksize&gt;)
pool.close()
pool.join()
</code></pre>
<p>If your powerset is very large, you'll want to specify a <code>chunksize</code> other than the default, which is 1:</p>
<blockquote>
<p>The chunksize argument is the same as the one used by the map()
  method. For very long iterables using a large value for chunksize can
  make the job complete much faster than using the default value of 1.</p>
</blockquote>
<p>The <code>map</code> function uses the following algorithm, to give you an idea of a good size:</p>
<pre><code>chunksize, extra = divmod(len(iterable), len(pool_size) * 4)
if extra:
    chunksize += 1
</code></pre>
</div>
<span class="comment-copy"><i>"a generator and that will not work"</i> From what I can see on a small list, it provides the desired answer. What is "not working" ?</span>
<span class="comment-copy">You're allowed to pass a generator to <code>pool.map</code>, just know that it will be converted to a list prior to any items being sent to worker processes.</span>
<span class="comment-copy">Thank you! This is exactly what I'm looking for!</span>
