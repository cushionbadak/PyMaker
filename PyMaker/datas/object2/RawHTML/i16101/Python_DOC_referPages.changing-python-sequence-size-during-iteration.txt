<div class="post-text" itemprop="text">
<p>Implementation of <code>bytes.join</code> method, implemented <a href="https://searchcode.com/codesearch/view/58086058/#l-8" rel="nofollow">here</a> includes code that protects from size changes during iteration:</p>
<pre><code>    if (seqlen != PySequence_Fast_GET_SIZE(seq)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "sequence changed size during iteration");
        goto error;
    }
</code></pre>
<p>How is it possible to modify an iterable sequence inside <code>bytes.join</code> call and why the above code is necessary? Or maybe it's not necessary and redundant?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you pass in a list object to <code>bytes.join()</code>, you could potentially add elements to the the list in another thread while the <code>bytes.join()</code> call is iterating.</p>
<p>The <code>bytes.join()</code> method has to make two passes over the sequence; once to calculate the total length of the <code>bytes</code> objects contained, a second time to then build the actual output <code>bytes</code> object. Changing the number of items while iterating over it would put a spanner in that calculation.</p>
<p>You normally couldn't do this to the list as the GIL is not released, but if any of the objects in the list are <em>not</em> <code>bytes</code> objects the <a href="https://docs.python.org/3/c-api/buffer.html">buffer protocol</a> is used instead. As the <a href="http://bugs.python.org/issue15958">a comment on the original patch states</a>:</p>
<blockquote>
<p>The problem with your approach is that the sequence could be mutated while another thread is running (<code>_getbuffer()</code> may release the GIL). Then the pre-computed size gets wrong.</p>
</blockquote>
</div>
<span class="comment-copy">Why do you want to change the size of the sequence while you iterate it? This is probably a bad idea. Show us your code, maybe there's a better way.</span>
<span class="comment-copy">I'm interested about why the mentioned code snippet is in the implementation of the 'join' method, that's all.</span>
<span class="comment-copy">Is this the underlying C-code for Python's <code>str.join</code>? How should the result of <code>join</code> look like if the sequence changes? Anyhow, strings are immutable, so their byte sequence should not change in the first place...</span>
<span class="comment-copy">Not <code>__getitem__</code> - the sequence is guaranteed to be a tuple or list thanks to PySequence_Fast. Threads that don't respect the GIL might be a problem, but most code assumes such threads won't interfere with their work. I'm inclined to blame the <code>_getbuffer</code> call; I believe that allows the sequence elements to run arbitrary code.</span>
<span class="comment-copy">@user2357112: Yeah, I was trying to build a case and discovered that arbitrary sequences are turned into a list first, and list subclasses have their <code>__getitem__</code> bypassed. The buffer interface is also not helping here, as that requires C API access.</span>
<span class="comment-copy">@user2357112: in other words, this is only a problem for C code mucking with the list object, or threading.</span>
<span class="comment-copy">The check seems to have gone in in <a href="http://hg.python.org/cpython/rev/16285c1b4dda" rel="nofollow noreferrer">the same change that added the use of <code>_getbuffer</code></a>.</span>
<span class="comment-copy">@user2357112: yes, but <code>_getbuffer</code> either takes the <code>bytes</code> content, or if it isn't a <code>bytes</code> object, uses the buffer protocol to access the items. See <a href="http://hg.python.org/cpython/file/d0ff527c53da/Objects/bytesobject.c#l15" rel="nofollow noreferrer">hg.python.org/cpython/file/d0ff527c53da/Objects/â€¦</a></span>
