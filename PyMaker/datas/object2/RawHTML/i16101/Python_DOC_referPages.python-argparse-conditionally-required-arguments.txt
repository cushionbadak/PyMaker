<div class="post-text" itemprop="text">
<p>I have done as much research as possible but I haven't found the best way to make certain cmdline arguments necessary only under certain conditions, in this case only if other arguments have been given. Here's what I want to do at a very basic level:</p>
<pre><code>p = argparse.ArgumentParser(description='...')
p.add_argument('--argument', required=False)
p.add_argument('-a', required=False) # only required if --argument is given
p.add_argument('-b', required=False) # only required if --argument is given
</code></pre>
<p>From what I have seen, other people seem to just add their own check at the end:</p>
<pre><code>if args.argument and (args.a is None or args.b is None):
    # raise argparse error here
</code></pre>
<p>Is there a way to do this natively within the argparse package?</p>
</div>
<div class="post-text" itemprop="text">
<p>I've been searching for a simple answer to this kind of question for some time. All you need to do is check if <code>'--argument'</code> is in <code>sys.argv</code>, so basically for your code sample you could just do:</p>
<pre><code>import argparse
import sys

if __name__ == '__main__':
    p = argparse.ArgumentParser(description='...')
    p.add_argument('--argument', required=False)
    p.add_argument('-a', required='--argument' in sys.argv) #only required if --argument is given
    p.add_argument('-b', required='--argument' in sys.argv) #only required if --argument is given
    args = p.parse_args()
</code></pre>
<p>This way <code>required</code> receives either <code>True</code> or <code>False</code> depending on whether the user as used <code>--argument</code>. Already tested it, seems to work and guarantees that <code>-a</code> and <code>-b</code> have an independent behavior between each other.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can implement a check by providing a custom action for <code>--argument</code>, which will take an additional keyword argument to specify which other action(s) should become required if <code>--argument</code> is used.</p>
<pre><code>import argparse

class CondAction(argparse.Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        x = kwargs.pop('to_be_required', [])
        super(CondAction, self).__init__(option_strings, dest, **kwargs)
        self.make_required = x

    def __call__(self, parser, namespace, values, option_string=None):
        for x in self.make_required:
            x.required = True
        try:
            return super(CondAction, self).__call__(parser, namespace, values, option_string)
        except NotImplementedError:
            pass

p = argparse.ArgumentParser()
x = p.add_argument("--a")
p.add_argument("--argument", action=CondAction, to_be_required=[x])
</code></pre>
<p>The exact definition of <code>CondAction</code> will depend on what, exactly, <code>--argument</code> should do. But, for example, if <code>--argument</code> is a regular, take-one-argument-and-save-it type of action, then just inheriting from <code>argparse._StoreAction</code> should be sufficient.</p>
<p>In the example parser, we save a reference to the <code>--a</code> option inside the <code>--argument</code> option, and when <code>--argument</code> is seen on the command line, it sets the <code>required</code> flag on <code>--a</code> to <code>True</code>. Once all the options are processed, <code>argparse</code> verifies that any option marked as required has been set.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your post parsing test is fine, especially if testing for defaults with <code>is None</code> suits your needs.</p>
<p><a href="http://bugs.python.org/issue11588" rel="nofollow">http://bugs.python.org/issue11588</a> <code>'Add "necessarily inclusive" groups to argparse'</code> looks into implementing tests like this using the <code>groups</code> mechanism (a generalization of mutuall_exclusive_groups).</p>
<p>I've written a set of <code>UsageGroups</code> that implement tests like <code>xor</code> (mutually exclusive), <code>and</code>, <code>or</code>, and <code>not</code>.  I thought those where comprehensive, but I haven't been able to express your case in terms of those operations. (looks like I need <code>nand</code> - not and, see below)</p>
<p>This script uses a custom <code>Test</code> class, that essentially implements your post-parsing test.  <code>seen_actions</code> is a list of Actions that the parse has seen.</p>
<pre><code>class Test(argparse.UsageGroup):
    def _add_test(self):
        self.usage = '(if --argument then -a and -b are required)'
        def testfn(parser, seen_actions, *vargs, **kwargs):
            "custom error"
            actions = self._group_actions
            if actions[0] in seen_actions:
                if actions[1] not in seen_actions or actions[2] not in seen_actions:
                    msg = '%s - 2nd and 3rd required with 1st'
                    self.raise_error(parser, msg)
            return True
        self.testfn = testfn
        self.dest = 'Test'
p = argparse.ArgumentParser(formatter_class=argparse.UsageGroupHelpFormatter)
g1 = p.add_usage_group(kind=Test)
g1.add_argument('--argument')
g1.add_argument('-a')
g1.add_argument('-b')
print(p.parse_args())
</code></pre>
<p>Sample output is:</p>
<pre><code>1646:~/mypy/argdev/usage_groups$ python3 issue25626109.py --arg=1 -a1
usage: issue25626109.py [-h] [--argument ARGUMENT] [-a A] [-b B]
                        (if --argument then -a and -b are required)
issue25626109.py: error: group Test: argument, a, b - 2nd and 3rd required with 1st
</code></pre>
<p><code>usage</code> and error messages still need work.  And it doesn't do anything that post-parsing test can't.</p>
<hr/>
<p>Your test raises an error if <code>(argument &amp; (!a or !b))</code>.  Conversely, what is allowed is <code>!(argument &amp; (!a or !b)) = !(argument &amp; !(a and b))</code>.  By adding a <code>nand</code> test to my <code>UsageGroup</code> classes, I can implement your case as:</p>
<pre><code>p = argparse.ArgumentParser(formatter_class=argparse.UsageGroupHelpFormatter)
g1 = p.add_usage_group(kind='nand', dest='nand1')
arg = g1.add_argument('--arg', metavar='C')
g11 = g1.add_usage_group(kind='nand', dest='nand2')
g11.add_argument('-a')
g11.add_argument('-b')
</code></pre>
<p>The usage is (using <code>!()</code> to mark a 'nand' test):</p>
<pre><code>usage: issue25626109.py [-h] !(--arg C &amp; !(-a A &amp; -b B))
</code></pre>
<p>I think this is the shortest and clearest way of expressing this problem using general purpose usage groups.</p>
<hr/>
<p>In my tests, inputs that parse successfully are:</p>
<pre><code>''
'-a1'
'-a1 -b2'
'--arg=3 -a1 -b2'
</code></pre>
<p>Ones that are supposed to raise errors are:</p>
<pre><code>'--arg=3'
'--arg=3 -a1'
'--arg=3 -b2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Until <a href="http://bugs.python.org/issue11588" rel="nofollow">http://bugs.python.org/issue11588</a> is solved, I'd just use <a href="https://docs.python.org/3/library/argparse.html?highlight=argumentparser#nargs" rel="nofollow"><code>nargs</code></a>:</p>
<pre><code>p = argparse.ArgumentParser(description='...')
p.add_argument('--arguments', required=False, nargs=2, metavar=('A', 'B'))
</code></pre>
<p>This way, if anybody supplies <code>--arguments</code>, it will have 2 values.</p>
<p>Maybe its CLI result is less readable, but code is much smaller. You can fix that with good docs/help.</p>
</div>
<div class="post-text" itemprop="text">
<p>For arguments I've come up with a quick-n-dirty solution like this. 
Assumptions:  (1) '--help' should display help and not complain about required argument and (2) we're parsing <code>sys.argv</code></p>
<pre><code>p = argparse.ArgumentParser(...)
p.add_argument('-required', ..., required = '--help' not in sys.argv )
</code></pre>
<p>This can easily be modified to match a specific setting.
For required positionals (which will become unrequired if e.g. '--help' is given on the command line) I've come up with the following: [positionals do not allow for a <code>required=...</code> keyword arg!]</p>
<pre><code>p.add_argument('pattern', ..., narg = '+' if '--help' not in sys.argv else '*' )
</code></pre>
<p>basically this turns the number of required occurrences of 'pattern' on the command line from one-or-more into zero-or-more in case '--help' is specified.</p>
</div>
<span class="comment-copy">Have you looked at <code>argparse</code> subparsers? They will allow you to do things like <code>$ git commit &lt;commit args only&gt;</code> or <code>$ git merge &lt;merge args only&gt;</code>.</span>
<span class="comment-copy">Joel, thanks for the comment. I have seen the subparser aspect of argparse but I was hoping to do this without positional arguments. If that's the only way though it's not a big deal</span>
<span class="comment-copy">Can <code>--a</code> and <code>--b</code> be given independently?</span>
<span class="comment-copy">As written it doesn't work because <code>Action.__call__</code> returns a <code>not implement</code> error.  But the basic idea of tweaking the <code>required</code> attribute of <code>x</code> should work.</span>
<span class="comment-copy">Good point. If you inherit from <code>argparse.Action</code>, then there's no need to call the (unimplemented) parent-class <code>__call__</code>. If you inherit from one of the other <code>Action</code> subclass's, you should. (As a compromise, I edited the answer to leave the superclass call in place, but catch and ignore the <code>NotImplementedError</code>.)</span>
<span class="comment-copy">I don't mind a downvote or two but I'd like to know why, especially since another answer <a href="https://stackoverflow.com/a/44210638/26083">stackoverflow.com/a/44210638/26083</a> (with upvote 5 at this point) basically does the same</span>
