<div class="post-text" itemprop="text">
<p>A callable object is supposed to be so by defining <code>__call__</code>. A class is supposed to be an object… or at least with some exceptions. This exception is what I'm failing to formally clarify, thus this question posted here.</p>
<p>Let <code>A</code> be a simple class:</p>
<pre><code>class A(object):

    def call(*args):
        return "In `call`"

    def __call__(*args):
        return "In `__call__`"
</code></pre>
<p>The first function is purposely named “call”, to make clear the purpose is the comparison with the other.</p>
<p>Let's instantiate it and forget about the expression it implies:</p>
<pre><code>a = A() # Think of it as `a = magic` and forget about `A()`
</code></pre>
<p>Now what's worth:</p>
<pre><code>print(A.call())
print(a.call())
print(A())
print(a())
</code></pre>
<p>Result in:</p>
<pre><code>&gt;&gt;&gt; In `call`
&gt;&gt;&gt; In `call`
&gt;&gt;&gt; &lt;__main__.A object at 0xNNNNNNNN&gt;
&gt;&gt;&gt; In `__call__`
</code></pre>
<p>The output (third statement not running <code>__call__</code>) does not come as a surprise, but when I think every where it is said “Python class are objects”…</p>
<p>This, more explicit, however run <code>__call__</code></p>
<pre><code>print(A.__call__())
print(a.__call__())

&gt;&gt;&gt; “In `__call__`”
&gt;&gt;&gt; “In `__call__`”
</code></pre>
<p>All of this is just to show how finally <code>A()</code> may looks strange.</p>
<p>There are exception in Python rules, but <a href="https://docs.python.org/3/reference/datamodel.html#object.__call__" rel="nofollow">the documentation about “object.<strong>call</strong>”</a> does not say a lot about <code>__call__</code>… not more than that:</p>
<blockquote>
<p>3.3.5. Emulating callable objects</p>
<pre><code>object.__call__(self[, args...])
</code></pre>
<p>Called when the instance is “called” as a function; […]</p>
</blockquote>
<p>But how do Python tell “it's called as a function” and honour or not the <code>object.__call__</code> rule?</p>
<p>This could be a matter of type, but even type has <code>object</code> as its base class.</p>
<p>Where can I learn more (and formally) about it?</p>
<p>By the way, is there any difference here between Python 2 and Python 3?</p>
<p>----- %&lt; ----- edit ----- &gt;% -----</p>
<h2>Conclusions and other experiments after one answer and one comment</h2>
<h3>Update #1</h3>
<p>After @Veedrac's answer and @chepner's comment, I came to this other test, which complete the comments from both:</p>
<pre><code>class M(type):

    def __call__(*args):
        return "In `M.__call__`"

class A(object, metaclass=M):

    def call(*args):
        return "In `call`"

    def __call__(*args):
        return "In `A.__call__`"

print(A())
</code></pre>
<p>The result is:</p>
<pre><code>&gt;&gt;&gt; In `M.__call__`
</code></pre>
<p>So it seems that's the meta‑class which drives the “call” operations. If I understand correctly, the meta‑class does not matter only with class, but also with classes instances.</p>
<h3>Update #2</h3>
<p>Another relevant test, which shows this is not an attribute of the object which matters, but an attribute of the type of the object:</p>
<pre><code>class A(object):

    def __call__(*args):
        return "In `A.__call__`"

def call2(*args):
    return "In `call2`"


a = A()

print(a())
</code></pre>
<p>As expected, it prints:</p>
<pre><code>&gt;&gt;&gt; In `A.__call__`
</code></pre>
<p>Now this:</p>
<pre><code>a.__call__ = call2

print(a())
</code></pre>
<p>It prints:</p>
<pre><code>&gt;&gt;&gt; In `A.__call__`
</code></pre>
<p>The same a before the attribute was assigned. It does not print <code>In call2</code>, it's still <code>In A.__call__</code>. That's important to note and also explain why that's the <code>__call__</code> of the meta‑class which was invoked (keep in mind the meta‑class is the type of the class object). The <code>__call__</code> used to call as function, is not from the object, it's from its type.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>x(*args, **kwargs)</code> is the same as <code>type(x).__call__(x, *args, **kwargs)</code>.</p>
<p>So you have</p>
<pre><code>&gt;&gt;&gt; type(A).__call__(A)
&lt;__main__.A object at 0x7f4d88245b50&gt;
</code></pre>
<p>and it all makes sense.</p>
<hr/>
<p>chepner points out in the comments that <code>type(A) == type</code>. This is kind-of wierd, because <code>type(A)(A)</code> just gives <code>type</code> again! But remember that we're instead using <code>type(A).__call__(A)</code> which is <strong>not the same</strong>.</p>
<p>So this resolves to <code>type.__call__(A)</code>. This is the constructor function for classes, which builds the data-structures and does all the construction magic.</p>
<hr/>
<p>The same is true of most dunder (double underscore) methods, such as <code>__eq__</code>. This is partially an optimisation in those cases.</p>
</div>
<span class="comment-copy"><code>A.__call__()</code> does <b>not</b> work the way you demonstrate. It will <b>not</b> print <code>In __call__</code>.</span>
<span class="comment-copy">That's at least what it do with Python 3.4 (are you using an older Python version?)</span>
<span class="comment-copy"><b>Instances</b> of <code>A</code> are callable; special methods are looked up on the type of an object; you cannot make <code>__call__</code> an attribute of an instance for example.</span>
<span class="comment-copy">Only because you used <code>*args</code> for the signature. Print out what <code>args</code> is and you'll see the difference there. You are accessing the <i>function object</i> there.</span>
<span class="comment-copy">And you know what? Functions are callables. It doesn't matter what you named them when you call them directly.</span>
<span class="comment-copy">Probably worth pointing out explicitly that <code>type(A)</code> is <code>type</code>.</span>
<span class="comment-copy">So that's because it has <code>type</code> as an ancestor? That would mean that's not just defining <code>__call__</code> which makes something callable and there is more involved.</span>
<span class="comment-copy">No, since <code>type</code> is itself a type, <code>type.__call__</code> is called when ever you attempt to call an <i>instance</i> of <code>type</code> as a function. Since the class <code>A</code> is an instance of <code>type</code>, <code>type.__call__</code> is what gets called when you write <code>A()</code> (specifically, it calls <code>A.__new__</code>). There's no special exception that makes classes callable; it's just a consequence of classes being instances of their metaclass.</span>
<span class="comment-copy">Another thing to keep in mind is that the metaclass of <code>A</code> (<code>type</code>) is distinct from the <i>parent</i> of <code>A</code> (<code>object</code>). (It gets a <i>little</i> confusing since <code>object</code> is the parent of <code>type</code> and <code>type</code> is the metaclass of <code>object</code>, and <code>type</code> has no metaclass and <code>object</code> has no parent. Perhaps it's best to ignore this parenthetical.)</span>
<span class="comment-copy">Annnnd.... one last comment. If <code>f</code> is a function, <code>f()</code> is not special, either. It's simply short for <code>type(f).__call__(f)</code>. There's no builtin name that references the type, but there is one in the <code>types</code> module: <code>import types; types.FunctionType.__call__(f)</code>.</span>
