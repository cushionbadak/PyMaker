<div class="post-text" itemprop="text">
<p>If I use a function to read the contents of a file in one module:</p>
<pre><code>def get_objectstore():

    with open(os.getcwd() + "\\data.store", "rb") as infile:
        objA = cPickle.load(infile)
        objectstore = eval((str(objA)).translate(string.maketrans(coder, alpha)))
    return objectstore 
</code></pre>
<p>and I call this function from my main program like this:</p>
<pre><code>from main_vars import get_objectstore

objectstore=get_objectstore()
</code></pre>
<p>now objectstore has all images and sound used by my program. How can I use</p>
<pre><code>objectstore
</code></pre>
<p>in all other modules loaded into the main program.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How can I use <code>objectstore</code> in all other modules loaded into the main program.</p>
</blockquote>
<p>This is one of those things that you <em>can</em> do, but almost certainly <em>shouldn't</em>… so first I'll explain how, then explain why not.</p>
<hr/>
<p>If you want something to be directly available in every module, without having to import it in each module, just as if it were a builtin… the answer is to add it to the builtins. So, how do you do that?</p>
<p>Well, technically, there's no guaranteed safe way to do it, but practically, I believe monkeypatching the <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code></a> module works in every version of every major implementation. So:</p>
<pre><code>import builtins
builtins.objectstore = objectstore
</code></pre>
<p>Note that in Python 2.x, the module is called <a href="https://docs.python.org/2/library/__builtin__.html" rel="nofollow"><code>__builtin__</code></a>, but works the same way.</p>
<hr/>
<p>This doesn't work in a few cases, e.g., inside code being run by an <code>exec</code> with a custom <code>globals</code> that provides a custom <code>__builtins__</code>. If you need to handle that… well, you can't handle it portably. But what if you only care about CPython (and I think PyPy, but not Jython, and I don't know about Iron…)? In CPython, it's guaranteed that every global environment, even the ones created for <code>compile</code>, <code>exec</code>, etc., will contain something named <code>__builtins__</code> that's either the builtin dict for that environment, or some object whose namespace is the builtin dict for the environment. If there are no builtins at all, or you're looking at the global environment for the builtins module itself, it may be missing. So, you can write this:</p>
<pre><code>try:
    __builtins__['objectstore'] = objectstore
except AttributeError:
    __builtins__.objectstore = objectstore
</code></pre>
<p>(That doesn't handle the case where you're running code inside the <code>builtins</code> namespace itself, because… I'm not sure what you'd want to do there, to be honest.)</p>
<p>Of course that's ugly. That's probably on purpose.</p>
<hr/>
<p>Now, why don't you want to do that?</p>
<p>Well, for one thing, it makes your code a lot harder to read. Anyone looking at your code can't tell where <code>objectstore</code> was defined, except by searching some completely unrelated module that isn't even referenced in the current module.</p>
<p>For another, it can lead to problems that are hard to debug. If you later change the list of which modules import which other modules, some module that depends on <code>objectstore</code> being patched in may run before it's been patched in and therefore fail.</p>
<p>Also, the fact that it's not actually documented that you can monkeypatch builtins, or that doing so affects the builtin environment, is a good sign that it's not something you should be relying on.</p>
<p>It's better to make what you're doing explicit. Have <code>objectstore</code> be a module global for some module that every other module imports from. Then it's immediately clear what's happening, on even a cursory glance.</p>
<p>For example, why not add that <code>objectstore = get_objectstore()</code> to <code>mainvars</code>, and then have every module do <code>from mainvars import objectstore</code>? Or maybe you even want to make it a singleton, so it's safe for anyone to call <code>get_objectstore()</code> and know that they'll all get back a single, shared value. Without knowing exactly what you're trying to accomplish, it's hard to suggest a best solution. All I can say for sure is that making <code>objectstore</code> a builtin-like cross-module global is very unlikely to be the best solution for almost anything you might be trying to accomplish.</p>
</div>
<span class="comment-copy">Thank you for that prompt reply. Let me elaborate a bit. I have all images and sound in a dictionary encrypted and dumped as a cpickle to a py file. the function to cpickle load the object dictionary is in a another py file. I call this function once at the start of the main program and load the entire images and sound dictionary to memory. Now I need to access this dictionary from any other part of the program including all other loaded files. Why is this bad and which is the best way to do this?</span>
<span class="comment-copy">@wookie: What part of this does my answer not explain? What's stopping you from making <code>objectstore</code> a member of some module, and having all of the other parts of the program import that module, as is normal for most other Python applications?</span>
<span class="comment-copy">I tried what you wrote above and found that what you say in the last para works best. You first answer accepted.</span>
