<div class="post-text" itemprop="text">
<p>I can't seem to find out how to do this, so it may not be that simple after all. I looked <a href="https://stackoverflow.com/questions/6076300/python-pack-4-byte-integer-with-bytes-in-bytearray-struct-pack">this post</a>, <a href="https://stackoverflow.com/questions/5302374/packing-4-integers-as-one-byte">this one</a>, and many others, but I can't get the type of answer I'm looking for. Most of the posts I read use the <code>struct.pack</code> or <code>struct.pack_into</code>, but the problem is that I don't really know a priory the size of the array I need, and I wouldn't like to create one to store temporarily the integer values. So I thought that I could use the <code>bytearray</code> instead, but I don't know how to add 4-byte integers to it.</p>
<pre><code>&gt;&gt;&gt; b = bytearray()
&gt;&gt;&gt; for i in range(100):
...   b.append(i)
... 
&gt;&gt;&gt; print(b)
bytearray(b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&amp;\'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc')
&gt;&gt;&gt; print(list(b))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(b)
161
</code></pre>
<p>So the byte array doesn't contain 4-byte integers (which is what I need). So then I would have to use some sort of padding with zeros in order to get 4-byte integers? Is there a function that I can use to convert the integer passed to append to the type of integer I want?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/array.html" rel="nofollow"><code>array</code> type</a> to store fixed-sized binary data, where the number of values is variable:</p>
<pre><code>import array

values = array.array('I')
values.fromlist([i for i in range(100)])
bytes = values.tobytes()
</code></pre>
<p>What C type you pick depends on your system architecture; you may have to pick one based on the <code>array.itemsize</code> attribute; on my 64-bit Mac <code>I</code> uses 4 bytes to store an unsigned integer:</p>
<pre><code>&gt;&gt;&gt; import array
&gt;&gt;&gt; values = array.array('I')
&gt;&gt;&gt; values.itemsize
4
&gt;&gt;&gt; values.fromlist([i for i in range(100)])
&gt;&gt;&gt; len(values.tobytes())
400
</code></pre>
<p>The byte order is also machine dependent; if you need to have big-endian bytes, but your machine uses a little-endian architecture, use <a href="https://docs.python.org/3/library/array.html#array.array.byteswap" rel="nofollow"><code>array.byteswap()</code></a> to swap the order before converting to bytes:</p>
<pre><code>import sys

if sys.byteorder == 'little':
    values.byteswap()  # convert to big-endian before writing to a file
values.tofile(fileobj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you want?</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; b = bytearray()
&gt;&gt;&gt; b = b""
&gt;&gt;&gt; for i in range(100):
...     b += struct.pack("&lt;i", i)
... 
&gt;&gt;&gt; len(b)
400
&gt;&gt;&gt; b
b'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&amp;\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00&lt;\x00\x00\x00=\x00\x00\x00&gt;\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'
</code></pre>
<p>For more info on the struct packing codes, see <a href="https://docs.python.org/3.4/library/struct.html" rel="nofollow">https://docs.python.org/3.4/library/struct.html</a>. My code uses <code>i</code> for int, and <code>&lt;</code> for little-endian.</p>
</div>
<span class="comment-copy">It seems though that you need to know <i>a priori</i> the size of the array for its construction, don't you?</span>
<span class="comment-copy">@aaragon: no, you don't. Arrays contain an arbitrary number of elements. You only need to know the target byte size.</span>
<span class="comment-copy">Great, I just saw the <code>append</code> method for the array class. Should I use <code>len(values) * values.itemsize</code> to get the total size stored, or is there a shortcut?</span>
<span class="comment-copy">There is no shortcut; multiplying the length by itemsize is how I'd do it.</span>
<span class="comment-copy">@aaragon: consider reversing, appending, the reversing again as an alternative.</span>
