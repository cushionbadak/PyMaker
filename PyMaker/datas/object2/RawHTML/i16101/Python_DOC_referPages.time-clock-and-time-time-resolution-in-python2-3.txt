<div class="post-text" itemprop="text">
<p>I'm getting really, really confused about the precision of the results of the functions above.<br/>
To me the documentation isn't clear at all, for example here are two sentences:</p>
<p>from <code>time</code> module documentation</p>
<blockquote>
<p>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. <strong>E.g. on most Unix systems, the clock “ticks” only 50 or 100 times a second.</strong></p>
</blockquote>
<p>from <code>timeit</code> module documentation</p>
<blockquote>
<p>Define a default timer, in a platform-specific manner. On Windows, time.clock() has microsecond granularity, but time.time()‘s granularity is 1/60th of a second. <strong>On Unix, time.clock() has 1/100th of a second granularity, and time.time() is much more precise.</strong> On either platform, default_timer() measures wall clock time, not the CPU time. This means that other processes running on the same computer may interfere with the timing.</p>
</blockquote>
<p>Now because real-time, in Unix, it is returned by <code>time.time()</code> and it has a resolution far better than 1/100 how can it just "ticks" 50 or 100 times a second?</p>
<p><br/>
Always about resolution, I can't understand what the exact resolution I get calling each function, so I tried the followings and I put my guesses in the comments:</p>
<pre><code>&gt;&gt;&gt; time.clock()
0.038955                            # a resolution of microsecond?
&gt;&gt;&gt; time.time()                     
1410633457.0955694                  # a resolution of 10-7 second?
&gt;&gt;&gt; time.perf_counter()
4548.103329075                      # a resolution of 10-9 second (i.e nanosecond)?
</code></pre>
<p><strong>P.S.</strong> This was tried on Python3.4.0, in Python2 for <code>time.clock()</code> and <code>time.time()</code> I always get 6 numbers after the dot, so 1us precision?</p>
</div>
<div class="post-text" itemprop="text">
<p>Precision relates to <em>how often the value changes</em>.</p>
<p>If you could call any of these functions infinitely fast, each of these functions would return a new value at different rates.</p>
<p>Because each returns a floating point value, which doesn't have absolute precision, you cannot tell anything from their return values as to what precision they have. You'll need to measure how the values change over time to see what their precision is.</p>
<p>To show the differences, run:</p>
<pre><code>import time

def average_deltas(*t):
    deltas = [t2 - t1 for t1, t2 in zip(t, t[1:])]
    return sum(deltas) / len(deltas)

for timer in time.clock, time.time, time.perf_counter:
    average = average_deltas(*(timer() for _ in range(1000))) * 10 ** 6
    print('{:&lt;12} {:.10f}'.format(timer.__name__, average))
</code></pre>
<p>On my Mac this prints:</p>
<pre><code>clock        0.6716716717
time         0.2892525704
perf_counter 0.1550070010
</code></pre>
<p>So <code>perf_counter</code> has the greatest precision on my architecture, because it changes more often per second, making the delta between values smaller.</p>
<p>You can use the <a href="https://docs.python.org/3/library/time.html#time.get_clock_info" rel="nofollow"><code>time.get_clock_info()</code> function</a> to query what precision each method offers:</p>
<pre><code>&gt;&gt;&gt; for timer in time.clock, time.time, time.perf_counter:
...     name = timer.__name__
...     print('{:&lt;12} {:.10f}'.format(name, time.get_clock_info(name).resolution))
... 
clock        0.0000010000
time         0.0000010000
perf_counter 0.0000000010
</code></pre>
</div>
<span class="comment-copy">I don't understand, so the documentation is wrong? If <code>time.pref_counter()</code> returns 9 numbers after the dot it means it has has a resulution till nanoseconds, because if it wasn't so why return 9 numbers and not 5 or 6?</span>
<span class="comment-copy">@antox: no, it means you misunderstand what the precision <i>means</i>. The floating point is just a fraction of seconds, but a floating point value is almost always imprecise (it is the sum of binary fractions, 1/2 + 1/4 + 1/8, etc, <i>approximating</i> a value).</span>
<span class="comment-copy">Also the <a href="http://pymotw.com/2/time/#processor-clock-time" rel="nofollow noreferrer">difference between <b>processor time</b> and <b>wall-clock time</b></a> is relevant - basically the processor clock is only advancing if your processs is doing work. So every time it ticks, its value may have a certain <i>precision</i>, but its <i>accuracy</i> is dependent on CPU load as well.</span>
<span class="comment-copy">@LukasGraf: which is where <code>time.perf_counter()</code> vs. <code>time.process_time()</code> comes in too, but the OP is misunderstanding what is meant by precision here.</span>
<span class="comment-copy">They actually edited the docs a few years ago to use words and phrases like "granularity" to avoid the common confusion between accuracy and precision, and between precision of the values vs. the data types… but I guess that didn't help; people now just have more terms to mix up instead of just two. :)</span>
