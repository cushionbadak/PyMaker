<div class="post-text" itemprop="text">
<p>EDIT: Probably this question is wrong. I was getting the thread id with threading.current_thread().ident and I got the same value for subsequent calls, which led me to think threads were being reused, but that does not seem to be the real thread id. With threading.current_thread().name I get different names for each request, so probably threads are not being reused. Besides the documentation I am attaching in the question refers to xmlrpc-c library, not python's. The thing is that I need to comunicate with a xmlrpc-c server from another xmlrpc-python server. My tests suggest that xmlrpc-c does reuse threads when requests come from the same connection (as I can take advantage of thread caches), but I am not totally sure.</p>
<hr/>
<p>Sorry if the title is a bit strange, but I didn't know how to make it clearer.</p>
<p>The thing is, when using a XMLRPC server with ThreadingMixIn it spawns a new thread to serve each request, but it leaves that connection open for some time, so it is always the same thread which serves all the requests that uses that connection. This has a limit, the default is 30 requests using the same connection. This can be read in the "Parameters" section of the documentation of ServerAbyss:</p>
<p><a href="http://xmlrpc-c.sourceforge.net/doc/libxmlrpc_server_abyss.html#server_abyss_run_server" rel="nofollow">http://xmlrpc-c.sourceforge.net/doc/libxmlrpc_server_abyss.html#server_abyss_run_server</a></p>
<p>The way to reuse a connection is to send the request to the XMLRPC server using the same ServerProxy object, and not creating a new one inmediately before the call, that I think it is the usual way of making a RPC call.</p>
<p>Well, this behaviour is very useful for me, as it permits me to take advantage of some thread caches. But the real improvement would be to have this kind of behaviour using ForkingMixIn instead of ThreadingMixIn. The problem is that it seems that ForkingMixIn always spawns a new process to handle the request, without taking in consideration if the request comes from a connection already opened or not.</p>
<p>So, is there a way in which ForkingMixIn could "reuse" a process in the same way that ThreadingMixIn reuses a thread to handle a request arriving from an already opened connection?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/socketserver.html#asynchronous-mixins" rel="nofollow"><code>socketserver.ForkingMixIn</code></a> cannot do this.</p>
<p>But then neither can <code>socketserver.ThreadingMixIn</code>, so your premise is wrong. So the first question is… you thought you have connection pooling on threads, you didn't have it, and you didn't notice a problem, so are you sure you actually need it?</p>
<hr/>
<p>If you do, you will have to write your own mixin. Fortunately, you can subclass <code>ForkingMixIn</code> to do the heavy lifting for launching and managing processes, and just add your own code on top of it, which should be able to sit comfortably within the only usefully-documented method, <a href="https://docs.python.org/3/library/socketserver.html#socketserver.BaseServer.process_request" rel="nofollow"><code>process_request</code></a>.</p>
<p>Also, not that, like many libraries in the stdlib, <code>socketserver</code> is meant to be readable and useful sample code as well as being a useful library, which is why the docs link to <a href="http://hg.python.org/cpython/file/default/Lib/socketserver.py#l529" rel="nofollow">the source</a> right at the top, which makes things a lot easier.</p>
<hr/>
<p>Unfortunately, while plugging your code into <code>ForkingMixIn</code> will be easy, designing and writing that code will not.</p>
<p>The basic concept is simple: you have a cache of child processes, keyed off the connection. For each request, you look up the connection in the cache, create a new child if needed, then pass the request to the appropriate child.</p>
<p>Unfortunately, every one of those steps is easier said than done.</p>
<p>Well, not the first. That's just a <a href="https://docs.python.org/3/library/weakref.html#weakref.WeakValueDictionary" rel="nofollow"><code>WeakValueDictionary</code></a>. But beyond that:</p>
<ul>
<li>What is a "connection"? XMLRPC is a pure stateless request-response protocol. If you assume every address is a connection you get false positives (running two clients at once, or just two users inside the same NAT); if you assume every socket is a connection you get false negatives (clients can, and will, close the socket and open a new one for any reason they want). The usual answer is to use an application-level session stored in an HTTP cookie (or an HTTP header or an XML element), so now you have to write or use an HTTP session manager (including handling reap-on-timeout).</li>
<li>How do you "pass the request" to the child? <code>ForkingMixIn</code> relies on the fact that the request is a local variable pre-<code>fork</code> and therefore still available as a local variable post-<code>fork</code>. That's not true for some object you pull out of a cache. So, you need to use a <code>multiprocessing.Queue</code> or <code>Pipe</code>, or some other IPC mechanism. And, while <code>Queue</code> makes things trivial for anything that can be pickled, a request object almost certainly can't be pickled, because it includes things like the socket files. So, you need to write code that bundles everything up into something that <em>can</em> be passed—which includes either doing fd migration (which Python doesn't handle for you) or reading all the request data to pass that instead (so the other side can then wrap it in, e.g., a <code>BytesIO</code> to stick in <code>self.rfile</code>).</li>
<li>How does the child respond? Again, <code>ForkingMixIn</code> relies on the fact that it's inherited the <code>wfile</code> file from its parent, but again, that obviously isn't going to work here. If you haven't done fd migration, then you need to pass the response back over IPC (e.g., another <code>Queue</code>). In which case your parent has to block on that IPC. So, you're going to need to use a <code>ThreadingMixIn</code> to create a thread per request just so they can wait on your child processes (or some alternative mechanism, like a child-service thread that loops over all the IPCs as composable futures or as <code>select</code>-able pipes or whatever).</li>
</ul>
<p>None of this is particularly hard conceptually (except the session-timeout issue), but it's all a whole lot of code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem here is to pass the data to the process. You can give the process the connection (so it can handle everything by itself) but then you'll never know when the connection is closed or not needed anymore. Also the child process can't easily create a new connection after N requests.</p>
<p>Or you can keep the connection in the parent process and just pipe the data to the child (for example via stdout -&gt; stdin pipe). But that means you have to copy each byte many times (take it out of the receiving buffer of the parent process, but it into the sending buffer of the parent's pipe, probably copy it a couple of times while the pipe does its magic, copy it into the child's input buffer, ...) and then everything again for each byte of result. Not an issue for small requests that take some time to process but probably something I'd keep an eye on.</p>
</div>
<span class="comment-copy">Are you talking about a <a href="https://docs.python.org/3/library/socketserver.html#asynchronous-mixins" rel="nofollow noreferrer"><code>socketserver.ThreadingMixIn</code></a>, or a similar class provided by a third-party library? Because I don't think the stdlib class reuses threads like that. If you look at <a href="http://hg.python.org/cpython/file/default/Lib/socketserver.py#l612" rel="nofollow noreferrer">the source</a>, each <code>process_request</code> spawns a new thread.</span>
<span class="comment-copy">Duplicate of <a href="http://stackoverflow.com/questions/11699471/is-there-any-pool-for-threadingmixin-and-forkingmixin-for-socketserver" title="is there any pool for threadingmixin and forkingmixin for socketserver">stackoverflow.com/questions/11699471/…</a> ?</span>
<span class="comment-copy">Anyway, if you are talking about the <code>socketserver</code> classes, you can subclass <code>ForkingMixin</code> and override its <a href="http://hg.python.org/cpython/file/default/Lib/socketserver.py#l587" rel="nofollow noreferrer"><code>process_request</code></a> to look up something appropriate about the <code>request</code> (e.g., if your XMLRPC library has the socket fd on the <code>request</code> object, you can use that) in a cache. The only trick is that you'll need some way to actually send the request information over to the child process, which presumably means giving a <code>multiprocessing.Queue</code> or <code>Pipe</code> to each one.</span>
<span class="comment-copy">@AaronDigulla: Nice find. Even if it's not a dup (I think it probably is, but I'm not sure about what the OP is asking…), the <code>concurrent.futures</code> answer there is exactly how I'd do this (except that I can't remember the last time I used <code>socketserver</code>, or anything built on top of it…), and very well explained.</span>
<span class="comment-copy">@abarnert: I think you are right, I was getting the thread id with threading.current_thread().ident and I got the same value for subsequent calls, but that does not seem to be the real thread id. With threading.current_thread().name I get different names for each request, so probably threads are not being reused. Besides the documentation I attached in the question refers to xmlrpc-c library, not python's. The thing is that I need to comunicate with a xmlrpc-c server from another xmlrpc-python server. My tests suggest that xmlrpc-c does reuse threads, but I am not totally sure.</span>
<span class="comment-copy">Very useful. Thank you. Finally the simplest way to solve my problem was to create a shared (between threads) list of connection objects and use them in a round robin way, checking first if they are being used.</span>
