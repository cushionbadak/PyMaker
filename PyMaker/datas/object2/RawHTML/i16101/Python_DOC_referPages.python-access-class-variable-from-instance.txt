<div class="post-text" itemprop="text">
<p>I have this class:</p>
<pre><code>class ReallyLongClassName:

    static_var = 5

    def instance_method(self):
        ReallyLongClassName.static_var += 1
</code></pre>
<p>Is there some way to access the static variable using the self variable?  I'd rather do something like <code>class(self).static_var += 1</code>, because long names are unreadable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>self.__class__.classAttr</code>. This should work for both old &amp; new style classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is "yes, butâ€¦"</p>
<p>The best way to understand is to actually try it:</p>
<pre><code>&gt;&gt;&gt; class RLCN:
...     static_var = 5
...     def method1(self):
...         RLCN.static_var += 1
...     def method2(self):
...         self.static_var += 1
&gt;&gt;&gt; rlcn = RLCN()
&gt;&gt;&gt; RLCN.static_var, rlcn.static_var
(5, 5)
&gt;&gt;&gt; rlcn.static_var
5
&gt;&gt;&gt; rlcn.method1()
&gt;&gt;&gt; RLCN.static_var, rlcn.static_var
(6, 6)
&gt;&gt;&gt; rlcn.method2()
&gt;&gt;&gt; RLCN.static_var, rlcn.static_var
(6, 7)
</code></pre>
<p>What happened?</p>
<p>Well, <em>accessing</em> a class attribute through <code>self</code> works just fine. If there is no instance attribute of the same name, you get the class attribute.</p>
<p>But <em>assigning</em> to it will hide the class attribute with a new instance attribute of the same name. Which is probably not what you wanted.</p>
<p>Note that this means you can use class attributes as "default values" or "initial values" for instance attributes. But I'm not sure it's very Pythonic to do so; what's actually happening, and what a novice (especially someone coming from, e.g., C++11 or Java) <em>thinks</em> is happening, are very different.</p>
<p>(Things get slightly more complicated when you deal with descriptors, like methods or <code>@property</code>s, but let's ignore that; in the simple case that you're discussing, it's not relevant.)</p>
<hr/>
<blockquote>
<p>I'd rather do something like class(self).static_var += 1, because long names are unreadable.</p>
</blockquote>
<p>You can, you just need to spell it right: <a href="https://docs.python.org/3/library/functions.html#type" rel="noreferrer"><code>type</code></a> is the function that returns the type of any object. So:</p>
<pre><code>type(self).static_var += 1
</code></pre>
<p>This has the added advantage of being dynamic (e.g., when you have multiple inheritance and don't know which side a <code>@property</code> comes from, you probably don't want to explicitly list a class name, for basically the same reason you want to use <code>super()</code> instead of explicitly calling a base class method).</p>
<p>This has the disadvantage of not working on old-style classes in Python 2.x, but then you shouldn't be using those anyway. Especially in classes that have a need for class attributes, because those are exactly the types you're often going to later want to add <code>@classmethod</code>s, <code>@property</code>s, etc. to, and none of that works with old-style classes (along with many other things). If you really need to handle old-style and new-style classes transparently for some reason, <code>self.__class__</code> is works with old-style classes. I'm not sure it's guaranteed to work with new-style classes; the docs say that the return value of <code>type(object)</code> is "generally the same object as returned by <code>object.__class__</code>", but doesn't say under what conditions that "generally" is untrue. It's also documented as a <a href="https://docs.python.org/3/library/stdtypes.html#special-attributes" rel="noreferrer">special attribute "added by the implementation" for "several object types"</a> in 3.x. In practice, I don't know of any cases where they're different in 3.x, and in 2.x, the most prominent case where they're different is old-style classes.</p>
</div>
<span class="comment-copy">This answer should be upvoted some more...it avoids the risk of typing  the whole class name especially if it is long just to get an attribute.</span>
<span class="comment-copy">Is this somehow better than <code>type(self)</code>?</span>
<span class="comment-copy">@Alexey see the comments on <a href="https://stackoverflow.com/a/25577642/5241481">stackoverflow.com/a/25577642/5241481</a></span>
<span class="comment-copy">Please don't get convinced by upvotes, <code>self.__class__</code> is very un-pythonic, and using <code>type(self)</code> should be the way to do it (if you don't want the classname hardcoded)  as illustrated by <a href="https://stackoverflow.com/a/25577642/860421">stackoverflow.com/a/25577642/860421</a>. The only case to be cautious in is when you're accessing superclass's attribute in an inherited class &amp; the attribute name starts (but not ends) with <code>__</code>, as name mangling will haunt you. In any case, using hardcoded classname is the safest approach.</span>
<span class="comment-copy">It seems that <code>type(self).static_var += 1</code> works only in Python3.</span>
<span class="comment-copy">@AntonSavin: No, it works in Python 2 just fine. See it <a href="http://repl.it/XrJ" rel="nofollow noreferrer">here</a> in Python 2.7.2.</span>
<span class="comment-copy">Ah, and <a href="http://repl.it/XrJ/1" rel="nofollow noreferrer">like this</a> it doesn't.</span>
<span class="comment-copy">@AntonSavin: If you're using old-style classes, sure, <code>type</code> doesn't work, and all of the relevant benefits become irrelevant anyway, since <code>super</code>, <code>@property</code>, multiple inheritance, etc. don't work on old-style classes anyway. But the answer to that is simple: don't use old-style classes. But I'll add a comment to that effect.</span>
<span class="comment-copy">Good explanation..the only drawback is see is if one changes the class name after creating the class, then all reference to the old class name in the class itself will need to be changed....</span>
