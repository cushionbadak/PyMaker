<div class="post-text" itemprop="text">
<p>I would like to have a function pointer <code>ptr</code> that can point to <em>either</em>: </p>
<ul>
<li><p>a function, </p></li>
<li><p>the method of an object instance, or </p></li>
<li><p>the constructor of the object. </p></li>
</ul>
<p>In the latter case, the execution of <code>ptr()</code> should instantiate the class.</p>
<pre><code>def function(argument) :
    print("Function called with argument: "+str(argument))

class C(object) :
    def __init__(self,argument) :
        print("C's __init__ method called with argument: "+str(argument))

    def m(self,argument) :
        print("C's method 'm' called with argument: "+str(argument))

## works
ptr = function
ptr('A')

## works
instance = C('asdf')
ptr = instance.m
ptr('A')

## fails
constructorPtr = C.__init__
constructorPtr('A')
</code></pre>
<p>This produces as output:</p>
<pre><code>Function called with argument: A

C's __init__ method called with argument: asdf

C's method 'm' called with argument: A

Traceback (most recent call last):   File "tmp.py", line 24, in &lt;module&gt;
    constructorPtr('A')

TypeError: unbound method __init__() must be called with C instance as first argument (got str instance instead)
</code></pre>
<p>showing that the first two ptr() calls worked, but the last did not.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason this doesn't work is that the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow"><code>__init__</code></a> method isn't a constructor, it's an initializer.*</p>
<p>Notice that its first argument is <code>self</code>—that <code>self</code> has to be already constructed before its <code>__init__</code> method gets called, otherwise, where would it come from.</p>
<p>In other words, it's a normal instance method, just like <code>instance.m</code> is, but you're trying to call it as an unbound method—exactly as if you'd tried to call <code>C.m</code> instead of <code>instance.m</code>.</p>
<hr/>
<p>Python <em>does</em> have a special method for constructors, <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow"><code>__new__</code></a> (although Python calls this a "creator" to avoid confusion with languages with single-stage construction). This is a static method that takes the class to construct as its first argument and the constructor arguments as its other arguments. The default implementation that you've inherited from <code>object</code> just creates an instance of that class and passes the arguments along to its initializer.** So:</p>
<pre><code>constructor = C.__new__
constructor(C, 'A')
</code></pre>
<p>Or, if you prefer:</p>
<pre><code>from functools import partial
constructor = partial(C.__new__, C)
constructor('A')
</code></pre>
<hr/>
<p>However, it's incredibly rare that you'll ever want to call <code>__new__</code> directly, except from a subclass's <code>__new__</code>. Classes themselves are callable, and act as their own constructors—effectively that means that they call the <code>__new__</code> method with the appropriate arguments, but there are some subtleties (and, in every case where they differ, <code>C()</code> is probably what you want, not <code>C.__new__(C)</code>).</p>
<p>So:</p>
<pre><code>constructor = C
constructor('A')
</code></pre>
<hr/>
<p>As user2357112 points out in a comment:</p>
<blockquote>
<p>In general, if you want a <code>ptr</code> that does <code>whatever_expression(foo)</code> when you call <code>ptr(foo)</code>, you should set <code>ptr = whatever_expression</code></p>
</blockquote>
<p>That's a great, simple rule of thumb, and Python has been carefully designed to make that rule of thumb work whenever possible.</p>
<hr/>
<p>Finally, as a side note, you can assign <code>ptr</code> to <em>anything</em> callable, not just the cases you described:</p>
<ul>
<li>a function,</li>
<li>a bound method (your <code>instance.m</code>),</li>
<li>a constructor (that is, a class),</li>
<li>an unbound method (e.g., <code>C.m</code>—which you can call just fine, but you'll have to pass <code>instance</code> as the first argument),</li>
<li>a bound classmethod (e.g., both <code>C.cm</code> and <code>instance.cm</code>, if you defined <code>cm</code> as a <code>@classmethod</code>),</li>
<li>an unbound classmethod (harder to construct, and less useful),</li>
<li>a staticmethod (e.g., both <code>C.sm</code> and <code>instance.sm</code>, if you defined <code>sm</code> as a <code>@staticmethod</code>),</li>
<li>various kinds of implementation-specific "builtin" types that simulate functions, methods, and classes.</li>
<li>an instance of any type with a <code>__call__</code> method,</li>
</ul>
<p>And in fact, all of these are just special cases of the last one—the <code>type</code> type has a <code>__call__</code> method, as do <code>types.FunctionType</code> and <code>types.MethodType</code>, and so on.</p>
<hr/>
<p><sub>* If you're familiar with other languages like Smalltalk or Objective-C, you may be thrown off by the fact that Python doesn't <em>look</em> like it has two-stage construction. In ObjC terms, you rarely implement <code>alloc</code>, but you call it all the time: <code>[[MyClass alloc] initWithArgument:a]</code>. In Python, you can pretend that <code>MyClass(a)</code> means the same thing (although really it's more like <code>[MyClass allocWithArgument:a]</code>, where <code>allocWithArgument:</code> automatically calls <code>initWithArgument:</code> for you).</sub></p>
<p><sub>** Actually, this isn't quite true; the default implementation just returns an instance of <code>C</code>, and Python automatically calls the <code>__init__</code> method if <code>isinstance(returnvalue, C)</code>.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I had a hard time finding the answer to this problem online, but I figured it out, so here is the solution.</p>
<p>Instead of pointing <code>constructorPtr</code> at <code>C.__init__</code>, you can just point it at <code>C</code>, like this.</p>
<pre><code>constructorPtr = C
constructorPtr('A')
</code></pre>
<p>which produces as output:</p>
<pre><code>C's __init__ method called with argument: A
</code></pre>
</div>
<span class="comment-copy"><code>__init__</code> is an <i>instance method</i>, just like <code>m</code>, so needs to be called the same way(s).</span>
<span class="comment-copy">As a side note, calling this a "pointer" is a little confusing. Functions, methods, classes, and everything else are values in Python; <code>ptr = function</code> is no more (or less) a pointer to a function than <code>ptr = 1</code> is a pointer to an int.</span>
<span class="comment-copy">Why the downvote here? Because I was confused about something? :/ I did my best to make the question clear as I could.</span>
<span class="comment-copy">Well, of course. You don't call <code>C.__init__</code> when you want a <code>C</code> instance; you call <code>C</code>. In general, if you want a <code>ptr</code> that does <code>whatever_expression(foo)</code> when you call <code>ptr(foo)</code>, you should set <code>ptr = whatever_expression</code>.</span>
<span class="comment-copy">@user2357112: That's a nice summary.</span>
