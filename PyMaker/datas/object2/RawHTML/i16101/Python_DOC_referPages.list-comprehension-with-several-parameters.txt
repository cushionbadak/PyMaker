<div class="post-text" itemprop="text">
<p>I have some <code>for</code> loop, like here:</p>
<pre><code>time1 = 0
timeDifference = []
for time2 in uniqueUserData['TIME']:
    timeDifference.append(time2 - time1)
    time1 = time2
</code></pre>
<p>I want use here the list comprehension, how I can put the second statement in the expression? I try</p>
<pre><code>[(timeDifference.append(time2 - time1), time1 = time2) for time2 in uniqueUserData['TIME']]
</code></pre>
<p>but got the error message <code>invalid syntax</code>. Probably <code>time1</code> is unknown....</p>
<p>Also important <code>uniqueUserData['TIME']</code> is not just a list, is a column of DF pandas, consequently Sequency... Followly I get Error message, when I use <code>df[columnName][someIndex]</code>. But ok, I probably will find some solution specific for DF according to zip (very nice idea). Thanks everybody.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a>:</p>
<pre><code>&gt;&gt;&gt; userdata = [1, 4, 5, 9]
&gt;&gt;&gt; zip(userdata, [0] + userdata)
[(1, 0), (4, 1), (5, 4), (9, 5)]
&gt;&gt;&gt; [time2 - time1 for time2, time1 in zip(userdata, [0] + userdata)]
[1, 3, 1, 4]
</code></pre>
<hr/>
<pre><code>timeDifference = [
    time2 - time1 for time2, time1 in
    zip(uniqueUserData['TIME'], [0] + uniqueUserData['TIME'])
]
</code></pre>
<p><strong>NOTE</strong> You should use <code>[0] + list(uniqueUserData['TIME'])</code> if <code>uniqueUserData['TIME']</code> is not a list object.</p>
<p>Alternatively you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain([0], uniqueUserData['TIME'])</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you looking for this?</p>
<pre><code>&gt;&gt;&gt; uniqueUserData = {'TIME' : [5,20,15]}
&gt;&gt;&gt; [ uniqueUserData['TIME'][idx-1] - uniqueUserData['TIME'][idx]
...   for idx in range(1,len(uniqueUserData['TIME']))
... ]
[-15, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't put a statement in an expression. Ever. That means you can't use a list comprehension if you can't think of a way to write the loop without assignments or other statements.</p>
<p>Which is fine—not everything should be a comprehension. There is nothing wrong with <code>for</code> statements.</p>
<p>But often, there's a way to rethink the problem so that it doesn't do any assignments, or any mutations at all, and often that design is better than the one you started with.</p>
<p>To make this work, you need some way to access both the current value and the previous value each time through the loop.</p>
<p>If you've got a <code>list</code>, and you can afford to waste enough memory for an extra lists of the same size, this is easy: as falsetru's answer shows, just zip the list with the same list offset by one, and you'll get each value paired with its predecessor. But if your list is too big, or if it may not be a list at all, just some kind of iterable (possibly even an iterator), you need an iterator that remembers the previous value for you. The easiest way to do that is with <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>tee</code></a>:</p>
<pre><code>a, b = itertools.tee(data)
return zip(a, itertools.chain([0], b))
</code></pre>
<p>And you could wrap that up in a function to make it reusable. In fact, you'll find a very similar function in the recipes section of the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code></a> docs (the difference being that it yields pairs in <code>(last, current)</code> order instead of <code>(current, last)</code>, and that it starts with <code>(a[0], a[1])</code> rather than <code>(0, a[0])</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this for example</p>
<pre><code>&gt;&gt;&gt; tim= [10,20,30,40,50,60]
&gt;&gt;&gt; [ t-tim[tim.index(t)-1] for r in tim[1:] ]
[10, 10, 10, 10, 10]
</code></pre>
</div>
<span class="comment-copy">I think <code>timeDifference</code> should be function that return object like int.</span>
<span class="comment-copy">In numpy there is a useful function <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html" rel="nofollow noreferrer"><code>np.diff</code></a>.</span>
<span class="comment-copy">You can't put a statement in an expression in Python, ever, period. That means you can't use a list comprehension if you can't think of a way to write the loop without assignments or other statements. Which is fine—not everything should be a comprehension. (That being said, often an immutable design that can be put into a comprehension is also a better design… but when that isn't the case, or you just can't figure it out, just use a <code>for</code> statement.)</span>
<span class="comment-copy">You have a typo in your final example: <code>for time2, time1</code> is missing</span>
<span class="comment-copy">Moreover, that doesn't work if <code>uniqueUserData['TIME']</code> is not a list.  You cannot concatenate (<code>+</code>) a list to a general iterable.</span>
<span class="comment-copy">@JuanCespedes, Thank you for point them. I updated the answer accordingly.</span>
<span class="comment-copy">The <code>chain</code> is probably better even if it <i>is</i> a list, because it avoids creating a whole duplicate copy of the list. But it still doesn't solve the problem of only working on sequences; if <code>userdata</code> is an iterator, that <code>zip</code> is going to advance by two each step, because you're advancing two references to the same iterator…</span>
<span class="comment-copy">ok, your answer helps a lot. Thank you very much once more ;-)</span>
<span class="comment-copy">That doesn't work if `uniqueUserData['TIME'] is not subscriptable</span>
<span class="comment-copy">Thanks, the main problem is, for-loops are to slow in Python, I just look for some optimisation ;-)</span>
<span class="comment-copy">@Guforu: Have you heard the phrase "premature optimization is the root of all evil"? If Python's for loops are too slow for you in general, you really shouldn't be using Python. That subtraction in your inner loop, besides interpreting a bytecode, has to look up both classes, check for a subclass, search the MRO for <code>__rsub__</code> or <code>__sub__</code>, do a slow Python function call to the descriptor's <code>__get__</code> method, then do a slow Python function call to the returned bound method object, and then interpret the bytecode in the function. Hundreds of times slower than C—and usually it doesn't matter.</span>
<span class="comment-copy">@Guforu: If you've profiled some particular code and found that a for loop is a bottleneck, and there's no algorithmic improvement you can make, then look at optimizing that particular for loop. (Or just rewrite it in Cython and not worry about it, which will typically get you a 6:1 improvement instead of the 1.2:1 improvement of a comprehension…)</span>
<span class="comment-copy">That doesn't work if the iterable <code>uniqueUserData['TIME']</code> is not subscriptable</span>
<span class="comment-copy">@JuanCespedes: To be fair, the other answers here assume that it's a sequence (xecgr's) or actually a list (falsetru's).</span>
