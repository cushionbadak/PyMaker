<div class="post-text" itemprop="text">
<p>Is this a bug?  It demonstrates what happens when you use libtiff to extract an image from an open tiff file handle.  It works in python 2.x and does not work in python 3.2.3</p>
<pre><code>import os

# any file will work here, since it's not actually loading the tiff
# assuming it's big enough for the seek
filename = "/home/kostrom/git/wiredfool-pillow/Tests/images/multipage.tiff"

def test():
    fp1 = open(filename, "rb")
    buf1 = fp1.read(8)
    fp1.seek(28)
    fp1.read(2)
    for x in range(16):
        fp1.read(12)
    fp1.read(4)

    fd = os.dup(fp1.fileno())
    os.lseek(fd, 28, os.SEEK_SET)
    os.close(fd)

    # this magically fixes it: fp1.tell()
    fp1.seek(284)
    expect_284 = fp1.tell()
    print ("expected 284, actual %d" % expect_284)

test()
</code></pre>
<p>The output which I feel is in error is:
expected 284, actual -504</p>
<p>Uncommenting the fp1.tell() does some ... side effect ... which stabilizes the py3 handle, and I don't know why.  I'd also appreciate if someone can test other versions of python3.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>os.dup</code> creates a duplicate file descriptor that refers to the same open file description. Therefore, <code>os.lseek(fd, 28, SEEK_SET)</code> changes the seek position of the file underlying <code>fp1</code>.</p>
<p>Python's file objects cache the file position to avoid repeated system calls. The side effect of this is that changing the file position without using the file object methods will desynchronize the cached position and the real position, leading to nonsense like you've observed. </p>
<p>Worse yet, because the files are internally buffered by Python, seeking outside the file methods could actually cause the returned file data to be incorrect, leading to corruption or other nasty stuff.</p>
<p>The documentation in <a href="http://hg.python.org/cpython/file/a3452677a386/Modules/_io/bufferedio.c#l282" rel="nofollow"><code>bufferedio.c</code></a> notes that <code>tell</code> can be used to reinitialize the cached value:</p>
<pre><code>* The absolute position of the raw stream is cached, if possible, in the
  `abs_pos` member. It must be updated every time an operation is done
  on the raw stream. If not sure, it can be reinitialized by calling
  _buffered_raw_tell(), which queries the raw stream (_buffered_raw_seek()
  also does it). To read it, use RAW_TELL().
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, this is not a bug. The Python 3 <a href="https://docs.python.org/3/library/io.html" rel="nofollow"><code>io</code> library</a>, which provides you with the file object from an <code>open()</code> call, gives you a <strong>buffered</strong> file object. For binary files, you are given a (subclass of) <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase" rel="nofollow"><code>io.BufferedIOBase</code></a>.</p>
<p>The Python 2 file object is far more primitive, although you <em>can</em> use the <a href="https://docs.python.org/2/library/io.html" rel="nofollow"><code>io</code> library</a> there too.</p>
<p>By seeking at the OS level you are bypassing the buffer and are mucking up the internal state. Generally speaking, as the doctor said to the patient complaining that pinching his skin hurts: <strong><em>don't do that</em></strong>.</p>
<p>If you have a pressing need to do this anyway, at the very least use the underlying raw file object (a subclass of the <a href="https://docs.python.org/3/library/io.html#io.RawIOBase" rel="nofollow"><code>io.RawIOBase</code> class</a>) via the <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase.raw" rel="nofollow"><code>io.BufferedIO.raw</code> attribute</a>:</p>
<pre><code>fp1 = open(filename, "rb").raw
</code></pre>
</div>
<span class="comment-copy">You haven't told us what is happening that isn't what you expect.</span>
<span class="comment-copy">That explains why tell fixed it, but something like flush didn't.  And thanks for not blowing off the need to call well established code libraries like libtiff (and many others).</span>
<span class="comment-copy">You can get the underlying <code>RawIOBase</code> object (in this case a <code>FileIO</code>) by accessing <code>f.raw</code> for binary files and <code>f.buffer.raw</code> for text files. Of course you still very definitely shouldn't mix methods on a <code>FileIO</code> object with <code>os</code> functions on its fd, but at least it will be less surprisingâ€¦</span>
