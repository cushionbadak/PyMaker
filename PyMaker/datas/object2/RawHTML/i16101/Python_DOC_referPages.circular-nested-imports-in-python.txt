<div class="post-text" itemprop="text">
<p>I'm having some real headaches right now trying to figure out how to import stuff properly.  I had my application structured like so:</p>
<pre><code>main.py
util_functions.py
widgets/
 - __init__.py
 - chooser.py
 - controller.py
</code></pre>
<p>I would always run my applications from the root directory, so most of my imports would be something like this</p>
<pre><code>from util_functions import *
from widgets.chooser import *
from widgets.controller import *
# ...
</code></pre>
<p>And my <code>widgets/__init__.py</code> was setup like this:</p>
<pre><code>from widgets.chooser import Chooser
from widgets.controller import MainPanel, Switch, Lever

__all__ = [
  'Chooser', 'MainPanel', 'Switch', 'Lever',
]
</code></pre>
<p>It was working all fine, except that <code>widgets/controller.py</code> was getting kind of lengthy, and I wanted it to split it up into multiple files:</p>
<pre><code>main.py
util_functions.py
widgets/
 - __init__.py
 - chooser.py
 - controller/
    - __init__.py
    - mainpanel.py
    - switch.py
    - lever.py
</code></pre>
<p>One of issues is that the <code>Switch</code> and <code>Lever</code> classes have static members where each class needs to access the other one.  Using imports with the <code>from ___ import ___</code> syntax that created circular imports.  So when I tried to run my re-factored application, everything broke at the imports.</p>
<p>My question is this:  How can I fix my imports so I can have this nice project structure?  I cannot remove the static dependencies of <code>Switch</code> and <code>Lever</code> on each other. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is covered in the official Python FAQ under <a href="https://docs.python.org/3/faq/programming.html#how-can-i-have-modules-that-mutually-import-each-other" rel="nofollow">How can I have modules that mutually import each other</a>.</p>
<p>As the FAQ makes clear, there's no silvery bullet that magically fixes the problem. The options described in the FAQ (with a little more detail than is in the FAQ) are:</p>
<ul>
<li>Never put anything at the top level except classes, functions, and variables initialized with constants or builtins, never <code>from spam import</code> anything, and then the circular import problems usually don't arise. Clean and simple, but there are cases where you can't follow those rules.</li>
<li>Refactor the modules to move the imports into the middle of the module, where each module defines the things that need to be exported before importing the other module. This can means splitting classes into two parts, an "interface" class that can go above the line, and an "implementation" subclass that goes below the line.</li>
<li>Refactor the modules in a similar way, but move the "export" code (with the "interface" classes) into a separate module, instead of moving them above the imports. Then each implementation module can import all of the interface modules. This has the same effect as the previous one, with the advantage that your code is idiomatic, and more readable by both humans and automated tools that expect imports at the top of a module, but the disadvantage that you have more modules.</li>
</ul>
<p>As the FAQ notes, "These solutions are not mutually exclusive." In particular, you can try to move as much top-level code as possible into function bodies, replace as many <code>from spam import …</code> statements with <code>import spam</code> as is reasonable… and then, if you still have circular dependencies, resolve them by refactoring into import-free export code above the line or in a separate module.</p>
<hr/>
<p>With the generalities out of the way, let's look at your specific problem.</p>
<p>Your <code>switch.Switch</code> and <code>lever.Lever</code> classes have "static members where each class needs to access the other one". I assume by this you mean they have class attributes that are initialized using class attributes or class or static methods from the other class?</p>
<hr/>
<p>Following the first solution, you could change things so that these values are initialized after import time. Let's assume your code looked like this:</p>
<pre><code>class Lever:
    switch_stuff = Switch.do_stuff()
    # ...
</code></pre>
<p>You could change that to:</p>
<pre><code>class Lever:
    @classmethod
    def init_class(cls):
        cls.switch_stuff = Switch.do_stuff()
</code></pre>
<p>Now, in the <code>__init__.py</code>, right after this:</p>
<pre><code>from lever import Lever
from switch import Switch
</code></pre>
<p>… you add:</p>
<pre><code>Lever.init_class()
Switch.init_class()
</code></pre>
<p>That's the trick: you're resolving the ambiguous initialization order by making the initialization explicit, and picking an explicit order.</p>
<hr/>
<p>Alternatively, following the second or third solution, you could split Lever up into <code>Lever</code> and <code>LeverImpl</code>. Then you do this (whether as separate <code>lever.py</code> and <code>leverimpl.py</code> files, or as one file with the imports in the middle):</p>
<pre><code>class Lever:
    @classmethod
    def get_switch_stuff(cls):
        return cls.switch_stuff

from switch import Swift

class LeverImpl(Lever):
    switch_stuff = Switch.do_stuff()
</code></pre>
<p>Now you don't need any kind of <code>init_class</code> method. Of course you do need to change the attribute to a method—but if you don't like that, with a bit of work, you can always change it into a "class <code>@property</code>" (either by writing a custom descriptor, or by using <code>@property</code> in a metaclass).</p>
<hr/>
<p>Note that you don't actually need to fix <em>both</em> classes to resolve the circularity, just one. In theory, it's cleaner to fix both, but in practice, if the fixes are ugly, it may be better to just fix the one that's less ugly to fix and leave the dependency in the opposite direction alone.</p>
</div>
<span class="comment-copy">Why can't you remove the static dependencies of <code>Switch</code> and <code>Lever</code> on each other? If nothing else, you can refactor one of them into, e.g., a <code>Switch</code> and <code>SwitchImpl</code>, where <code>SwitchImpl</code> inherits from <code>Switch</code> and adds all the code that depends on <code>Lever</code>, while <code>Lever</code> only depends on the interface in <code>Switch</code>, right?</span>
<span class="comment-copy">It's for some layout and sizing reasons.</span>
<span class="comment-copy">I mean, I could trying doing the prototype thing, where I have all of the static members listed, but I'd prefer not to do that.</span>
<span class="comment-copy">Isn't <a href="http://stackoverflow.com/questions/2386714/why-is-import-bad">import *</a> considered evil?</span>
<span class="comment-copy">@PM2Ring: In general, yes, but there are cases where it can be sensible. (Otherwise, it wouldn't be in the language). For example, if you're designing a framework, and developing an importer and importee together, the usual problems don't arise. And it allows you to, e.g., expose everything from a bunch of submodules directly from the parent package, which allows you to not document the submodules and refactor them later.</span>
<span class="comment-copy">You are Jesus.  I'll be trying this later when I get home.</span>
<span class="comment-copy">Thank you again so much!</span>
