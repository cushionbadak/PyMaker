<div class="post-text" itemprop="text">
<p>Languages such as C++ require that an array hold elements of a single type. As I understand it, knowing the size of each element allows for pointer arithmetic, making access of a particular element O(1) time.</p>
<p>What about <a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow">Python lists</a>?</p>
<p>Python lists allow for mixing element types. Surely the implementation doesn't involve a slow-access data structure, such as a linked lists – right? Is accessing an element even constant time? If so, how does Python achieve it with variable element types?</p>
</div>
<div class="post-text" itemprop="text">
<p>Its a simple indexed lookup. Python stores references to objects in its lists, not the objects themselves. Consider a C++ list of (void*) pointers. Each pointer is a known size and array lookup is fast, but the things it points to can vary in size.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, everything is an "object" (you can intuitively confirm that by something like <code>(1).__add__(2)</code>). So, roughly speaking, Python's list just contain references to the actual objects stored somewhere in memory. And if you look up an object via the list index - this is very, very simplified - it will redirect you to the actual object.</p>
<p><a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">Here</a> is a nice table that shows you the complexity (Big-Oh) of the different operations on lists.</p>
</div>
<span class="comment-copy">lists contain references (pointers in C/C++ terminology) to objects (which can be of any type).</span>
<span class="comment-copy"><a href="http://www.laurentluce.com/posts/python-list-implementation/" rel="nofollow noreferrer">laurentluce.com/posts/python-list-implementation</a></span>
<span class="comment-copy">While external storage has clear advantages over internal storage, it is good to know the slight disadvantages: more storage overall, worse locality of reference, and more complex memory management (data is allocated and deallocated separately from the list nodes).</span>
<span class="comment-copy">If you're interested in further details of exactly what the CPython implementation does, the list implementation is fully documented as part of the public C API. See <a href="https://docs.python.org/3/c-api/list.html" rel="nofollow noreferrer">here</a>. But basically, it's what you'd expect: there's a <code>PyListObject</code> struct that holds a pointer to an array of <code>PyObject *</code> pointers. If that sounds like lots of dereferencing… well, remember that <code>a[i]</code> is actually calling <code>a.__getitem__[i]</code>, which has to look up the name <code>__getitem__</code> in the dict of <code>a</code>, its type, or a superclass, and so on; this is hardly the slow part.</span>
<span class="comment-copy">Cool. When you say "this is very, very simplified", do you mean what @tdelaney stated in their answer? That the reference to the object is found by multiplying the index by the size of a pointer, then added to the base address of the list? Then just dereferenced to return the object? Or is there more?</span>
<span class="comment-copy">@sgarza62: What tdelaney wrote is specific to CPython; each implementation has a different way of representing its objects, and two of the four major implementations are written in languages that don't even have pointers—but still, they're all in some way or another storing an array of references in a way that's compact and reasonable for the language they're written in.</span>
<span class="comment-copy">I read about this once some time ago, and I have to admit that I forgot the gory details. But yes, that's right, standard Python (CPython) stores just the pointers to the objects in the list. So, the size of the list is not determined by the size of the actual objects, but the number of pointers it contains.</span>
