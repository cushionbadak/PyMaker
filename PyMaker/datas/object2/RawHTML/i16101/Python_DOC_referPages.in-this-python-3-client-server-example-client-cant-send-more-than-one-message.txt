<div class="post-text" itemprop="text">
<p>This is a simple client-server example where the server returns whatever the client sends, but reversed.</p>
<p>Server:</p>
<pre><code>import socketserver

class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024)
        print('RECEIVED: ' + str(self.data))
        self.request.sendall(str(self.data)[::-1].encode('utf-8'))

server = socketserver.TCPServer(('localhost', 9999), MyTCPHandler)
server.serve_forever()
</code></pre>
<p>Client:</p>
<pre><code>import socket
import threading

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('localhost',9999))

def readData():
    while True:
        data = s.recv(1024)
        if data:
            print('Received: ' + data.decode('utf-8'))

t1 = threading.Thread(target=readData)
t1.start()

def sendData():
    while True:
        intxt = input()
        s.send(intxt.encode('utf-8'))

t2 = threading.Thread(target=sendData)
t2.start()
</code></pre>
<p>I took the server from an example I found on Google, but the client was written from scratch. The idea was having a client that can keep sending and receiving data from the server indefinitely.</p>
<p>Sending the first message with the client works. But when I try to send a second message, I get this error:</p>
<blockquote>
<p>ConnectionAbortedError: [WinError 10053] An established connection was
  aborted by the software in your host machine</p>
</blockquote>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>For <code>TCPServer</code>, the <a href="https://docs.python.org/3/library/socketserver.html#socketserver.RequestHandler.handle" rel="nofollow"><code>handle</code></a> method of the handler gets called once to handle the entire session. This may not be entirely clear from the documentation, but <code>socketserver</code> is, like many libraries in the stdlib, meant to serve as clear sample code as well as to be used directly, which is why the docs link to <a href="http://hg.python.org/cpython/file/default/Lib/socketserver.py" rel="nofollow">the source</a>, where you can clearly see that it's only going to call <code>handle</code> once per connection (<a href="http://hg.python.org/cpython/file/default/Lib/socketserver.py#l480" rel="nofollow"><code>TCPServer.get_request</code></a> is defined as just calling <code>accept</code> on the socket).</p>
<p>So, your server receives one buffer, sends back a response, and then quits, closing the connection.</p>
<p>To fix this, you need to use a loop:</p>
<pre><code>def handle(self):
    while True:
        self.data = self.request.recv(1024)
        if not self.data:
            print('DISCONNECTED')
            break
        print('RECEIVED: ' + str(self.data))
        self.request.sendall(str(self.data)[::-1].encode('utf-8'))
</code></pre>
<hr/>
<p>A few side notes:</p>
<p>First, using <code>BaseRequestHandler</code> on its own only allows you to handle one client connection at a time. As the <a href="https://docs.python.org/3/library/socketserver.html" rel="nofollow">introduction in the docs</a> says:</p>
<blockquote>
<p>These four classes process requests <em>synchronously</em>; each request must be completed before the next request can be started. This isn’t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the <code>ForkingMixIn</code> and <code>ThreadingMixIn</code> mix-in classes can be used to support asynchronous behaviour.</p>
</blockquote>
<p>Those mixin classes are described further in the rest of the introduction, and <a href="https://docs.python.org/3/library/socketserver.html#server-creation-notes" rel="nofollow">farther down the page</a>, and <a href="https://docs.python.org/3/library/socketserver.html#asynchronous-mixins" rel="nofollow">at the bottom</a>, with a nice example at the end. The docs don't make it clear, but if you need to do any CPU-intensive work in your handler, you want <code>ForkingMixIn</code>; if you need to share data between handlers, you want <code>ThreadingMixIn</code>; otherwise it doesn't matter much which you choose.</p>
<p>Note that if you're trying to handle a large number of simultaneous clients (more than a couple dozen), neither forking nor threading is really appropriate—which means <code>TCPServer</code> isn't really appropriate. For that case, you probably want <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow"><code>asyncio</code></a>, or a third-party library (Twisted, gevent, etc.).</p>
<hr/>
<p>Calling <code>str(self.data)</code> is a bad idea. You're just going to get the source-code-compatible representation of the byte string, like <code>b'spam\n'</code>. What you want is to <em>decode</em> the byte string into the equivalent Unicode string: <code>self.data.decode('utf8')</code>.</p>
<hr/>
<p>There's no guarantee that each <code>sendall</code> on one side will match up with a single <code>recv</code> on the other side. TCP is a stream of bytes, not a stream of messages; it's perfectly possible to get half a message in one <code>recv</code>, and two and a half messages in the next one. When testing with a single connection on localhost with the system under light load, it will probably appear to "work", but as soon as you try to deploy any code that assumes that each <code>recv</code> gets exactly one message, your code will break. See <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow">Sockets are byte streams, not message streams</a> for more details. Note that if your messages are just lines of text (as they are in your example), using <code>StreamRequestHandler</code> and its <code>rfile</code> attribute, instead of <code>BaseRequestHandler</code> and its <code>request</code> attribute, solves this problem trivially.</p>
<hr/>
<p>You probably want to set <code>server.allow_reuse_address = True</code>. Otherwise, if you quit the server and re-launch it again too quickly, it'll fail with an error like <code>OSError: [Errno 48] Address already in use</code>.</p>
</div>
<span class="comment-copy">@vaultah: I'm not sure it's really a dup. The underlying problem is the same, but one of them is using low-level <code>socket</code> calls, and the other <code>TCPServer</code>, so the only way you'd know it's a dup is if you already knew how <code>TCPServer</code> worked.</span>
<span class="comment-copy">Is this server setup capable of accepting more than one client connection? If I understood it correctly, a new instance of the handler class is created for every new client. This solution worked for a single client, but it doesn't work when I try to connect a second client to the server.</span>
<span class="comment-copy">@DavidMcDavidson: It can accept more than one client connection <i>consecutively</i>, but not more than one <i>simultaneously</i>. This is explained in detail in the introduction to the linked docs page, and a nice example of fixing it with the <code>ThreadingMixin</code> is at the very bottom of the same page.</span>
<span class="comment-copy">Thanks for the sidenotes</span>
