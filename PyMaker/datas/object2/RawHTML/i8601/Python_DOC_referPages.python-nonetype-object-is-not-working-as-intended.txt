<div class="post-text" itemprop="text">
<p>I'm trying to <a href="http://effbot.org/zone/call-by-object.htm" rel="nofollow noreferrer">pass by object</a> a <code>None</code> value in hopes of reassigning it to an actual value. Can someone please explain why this isn't working? I thought since <code>None</code> is a <code>NoneType</code> that it would be passed in by reference and when I use the passed in variable, I would alter the original <code>None</code> object. Is this incorrect? I have provided a snippet below to demonstrate my case:</p>
<pre><code>class MyClass:
    def __init__(self):
        self.value = None

    def assign(self, object):
        object = OtherClass()

example = MyClass()
example.assign(example.value)
</code></pre>
<p>The result is that <code>example.value</code> is still <code>None</code>. Why is that? I have read a some <a href="https://stackoverflow.com/questions/11585768/python-how-does-passing-values-work">SO posts</a> but none of them are clear in explaining this.</p>
<p>EDIT: Not a duplicate because I wanted to know why it was behaving like pass by value when I thought it should be pass by reference. In the end, I have concluded that <strong><code>NoneType</code> objects are immutable</strong> and therefore always pass by value. I would need to use <code>list</code> type object or something mutable.</p>
<p>EDIT again: My example code is just a general case. I was trying to implement a BST and my initial root node was <code>None</code> and when I assigned the root node to be a <code>Node</code> object, it would still be <code>NoneType</code>, which caused me to be confused and was the cause of this question.</p>
<p>Last edit: answer below provides a very good tl;dr summary of pass by object. I was unable to understand just by searching/reading forums.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is precisely the case where call by object (Python rules) differs from call by reference (C++ reference semantics).</p>
<p>The difference is that assigning to an unqualified name rebinds the name, it has no effect whatsoever on whatever that name might previously have been bound to (aside from possibly destroying it, if no other references remain). The name has no connection to any other names that might reference the same object, so those other names aren't changed.</p>
<p>So in this case, <code>object</code> is initially set to point to the same object <code>example.value</code> points to. But on the next line, you rebind <code>object</code> (unqualified name assignment), and it points to a whole different object.</p>
<p>By contrast, if you had:</p>
<pre><code>def assign_value(self, object):
    object.value = OtherClass()
</code></pre>
<p>and called it with:</p>
<pre><code>example.assign(example)
</code></pre>
<p>then <code>example</code> and <code>object</code> would refer to the same object, and your assignment to a qualified name would replace <code>value</code> on that one object.</p>
<p>All that said, your use case here doesn't need any such changes. Calling <code>example.assign(example.value)</code> doesn't make any sense, because <code>self</code> is passed implicitly and would give you access to <code>value</code> (qualified access no less) automatically. Seems like what you really wanted is just lazy initialization when requested with no arguments at all:</p>
<pre><code>def assign(self):
    self.value = OtherClass()
</code></pre>
<p>called as:</p>
<pre><code>example.assign()
</code></pre>
<p>In response to your edits: Python <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">documents this call behavior explicitly</a>:</p>
<blockquote>
<p>The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object).[1]</p>
</blockquote>
<p>Where footnote 1 clarifies:</p>
<blockquote>
<p>[1]    Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list).</p>
</blockquote>
<p>This is intended; C++ reference semantics are unworkable when you don't have other calling semantics available, because there is no obvious way to opt-out, meaning every variable along a huge call chain ends up referencing the same object, causing tons of action-at-a-distance.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that function calls pass values, not references. Specifically, the reference passed to the function remains the same until it is rebound (it's value set) at which point a copy is created local to the function. Any line of the form <code>other = ...</code> will cause this to happen. If you want this behavior, you need to use a mutable object, such as a list. For example:</p>
<pre><code>class MyClass:
    def __init__(self):
        self.value = [None]

    def assign(self, object):
        object[0] = OtherClass()

example = MyClass()
example.assign(example.value)
</code></pre>
<p>Hope this helps!</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a></span>
<span class="comment-copy">"I thought since None is a NoneType that it would be passed in by reference" - could you explain why you thought that? What was the link in your mind between "None is a NoneType" and "therefore, it will be passed by reference"? Nothing in Python is passed by reference.</span>
<span class="comment-copy">Oh my understanding before this was that objects (typically mutable) are pass by reference in Python. I thought since None is a NoneType <i>object</i>, it must be pass by reference. My logic has failed me :p</span>
<span class="comment-copy">My mind is blown right now. Thank you!!  (also, confirmed that your "in contrast" snippet works)</span>
<span class="comment-copy">Oh I wasn't sure if NoneType object is mutable or not. I guess not in this case. I also wanted to reword my question to ask that but it felt like dumb question to ask.</span>
<span class="comment-copy">@Sticky: It doesn't matter if <code>None</code> is mutable or not. Assigning to an unqualified name replaces it; it doesn't matter what the old value was.</span>
<span class="comment-copy">Sometimes a quick google search can be the best coding advice.</span>
