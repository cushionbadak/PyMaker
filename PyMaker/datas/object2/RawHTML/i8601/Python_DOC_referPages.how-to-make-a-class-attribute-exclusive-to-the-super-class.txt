<div class="post-text" itemprop="text">
<p>I have a master class for a planet:</p>
<pre><code>class Planet:

    def __init__(self,name):
        self.name = name
        (...)

    def destroy(self):
        (...)
</code></pre>
<p>I also have a few classes that inherit from <code>Planet</code> and I want to make one of them unable to be destroyed (not to inherit the <code>destroy</code> function)</p>
<p>Example:</p>
<pre><code>class Undestroyable(Planet):

    def __init__(self,name):
        super().__init__(name)
        (...)

    #Now it shouldn't have the destroy(self) function
</code></pre>
<p>So when this is run,</p>
<pre><code>Undestroyable('This Planet').destroy()
</code></pre>
<p>it should produce an error like:</p>
<pre><code>AttributeError: Undestroyable has no attribute 'destroy'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The mixin approach in other answers is nice, and probably better for most cases. But nevertheless, it spoils part of the fun - maybe obliging you to have separate planet-hierarchies - like having to live with two abstract classes each ancestor of "destroyable" and "non-destroyable".</p>
<h1>First approach: descriptor decorator</h1>
<p>But Python has a powerful mechanism, called the "descriptor protocol", which is used to retrieve any attribute from a class or instance - it is even used to ordinarily retrieve methods from instances - so, it is possible to customize the method retrieval in a way it checks if it "should belong" to that class, and raise attribute error otherwise.</p>
<p>The descriptor protocol mandates that whenever you try to get any attribute from an instance object in Python, Python will check if the attribute exists in that object's class, and if so, if the attribute itself has a method named <code>__get__</code>. If it has, <code>__get__</code> is called (with the instance and class where it is defined as parameters) - and whatever it returns is the attribute. Python uses this to implement methods: functions in Python 3 have a <code>__get__</code> method that when called, will return another callable object that, in turn, when called will insert the <code>self</code> parameter in a call to the original function.  </p>
<p>So, it is possible to create a class whose <code>__get__</code> method will decide whether to return a function as a bound method or not depending on the outer class been marked as so - for example, it could check an specific flag <code>non_destrutible</code>. This could be done by using a decorator to wrap the method with this descriptor functionality</p>
<pre><code>class Muteable:
    def __init__(self, flag_attr):
        self.flag_attr = flag_attr

    def __call__(self, func):
        """Called when the decorator is applied"""
        self.func = func
        return self

    def __get__(self, instance, owner):
        if instance and getattr(instance, self.flag_attr, False):
            raise AttributeError('Objects of type {0} have no {1} method'.format(instance.__class__.__name__, self.func.__name__))
        return self.func.__get__(instance, owner)


class Planet:
    def __init__(self, name=""):
        pass

    @Muteable("undestroyable")
    def destroy(self):
        print("Destroyed")


class BorgWorld(Planet):
    undestroyable = True
</code></pre>
<p>And on the interactive prompt:         </p>
<pre><code>In [110]: Planet().destroy()
Destroyed

In [111]: BorgWorld().destroy()
...
AttributeError: Objects of type BorgWorld have no destroy method

In [112]: BorgWorld().destroy
AttributeError: Objects of type BorgWorld have no destroy method
</code></pre>
<p>Perceive that unlike simply overriding the method, this approach raises the error when the attribute is retrieved - and will even make <code>hasattr</code> work: </p>
<pre><code>In [113]: hasattr(BorgWorld(), "destroy")
Out[113]: False
</code></pre>
<p>Although, it won't work if one tries to retrieve the method directly from the class, instead of from an instance - in that case the <code>instance</code> parameter to  <code>__get__</code> is set to None, and we can't say from which class it was retrieved - just the <code>owner</code> class, where it was declared.</p>
<pre><code>In [114]: BorgWorld.destroy
Out[114]: &lt;function __main__.Planet.destroy&gt;
</code></pre>
<h1>Second approach: <code>__delattr__</code> on the metaclass:</h1>
<p>While writting the above, it occurred me that Pythn does have the  <code>__delattr__</code> special method. If the <code>Planet</code> class itself implements <code>__delattr__</code> and we'd try to delete the <code>destroy</code>  method on specifc derived classes, it wuld nt work: <code>__delattr__</code> gards the attribute deletion of attributes in instances - and if you'd try to <code>del</code> the "destroy" method in an instance, it would fail anyway, since the method is in the class.</p>
<p>However, in Python, the class itself is an instance - of its "metaclass". That is usually <code>type</code> . A proper <code>__delattr__</code> on the metaclass of "Planet" could make possible the "disinheitance" of the "destroy" method by issuing a `del UndestructiblePlanet.destroy" after class creation.</p>
<p>Again, we use the descriptor protocol to have a proper "deleted method on the subclass":</p>
<pre><code>class Deleted:
    def __init__(self, cls, name):
        self.cls = cls.__name__
        self.name = name
    def __get__(self, instance, owner):
          raise AttributeError("Objects of type '{0}' have no '{1}' method".format(self.cls, self.name))

class Deletable(type):
    def __delattr__(cls, attr):
        print("deleting from", cls)
        setattr(cls, attr, Deleted(cls, attr))


class Planet(metaclass=Deletable):
    def __init__(self, name=""):
        pass

    def destroy(self):
        print("Destroyed")


class BorgWorld(Planet):
    pass

del BorgWorld.destroy    
</code></pre>
<p>And with this method, even trying to retrieve or check for the method existense on the class itself will work:</p>
<pre><code>In [129]: BorgWorld.destroy
...
AttributeError: Objects of type 'BorgWorld' have no 'destroy' method

In [130]: hasattr(BorgWorld, "destroy")
Out[130]: False
</code></pre>
<h1>metaclass with a custom <code>__prepare__</code> method.</h1>
<p>Since metaclasses allow  one to customize the object that contains the class namespace, it is possible to have an object that responds to a <code>del</code> statement within the class body, adding a <code>Deleted</code> descriptor. </p>
<p>For the user (programmer) using this metaclass, it is almost the samething, but for the <code>del</code> statement been allowed into the class body itself:</p>
<pre><code>class Deleted:
    def __init__(self, name):
        self.name = name
    def __get__(self, instance, owner):
          raise AttributeError("No '{0}' method on  class '{1}'".format(self.name, owner.__name__))

class Deletable(type):
    def __prepare__(mcls,arg):

        class D(dict):
            def __delitem__(self, attr):
                self[attr] = Deleted(attr)

        return D()

class Planet(metaclass=Deletable):
    def destroy(self):
        print("destroyed")


class BorgPlanet(Planet):
    del destroy
</code></pre>
<p>(The 'deleted' descriptor is the correct form to mark a method as 'deleted' - in this method, though, it can't know the class name at class creation time)</p>
<h1>As a class decorator:</h1>
<p>And given the "deleted" descriptor, one could simply inform the methods to be removed as a class decorator - there is no need for a metaclass in this case:</p>
<pre><code>class Deleted:
    def __init__(self, cls, name):
        self.cls = cls.__name__
        self.name = name
    def __get__(self, instance, owner):
        raise AttributeError("Objects of type '{0}' have no '{1}' method".format(self.cls, self.name))


def mute(*methods):
    def decorator(cls):
        for method in methods:
            setattr(cls, method, Deleted(cls, method))
        return cls
    return decorator


class Planet:
    def destroy(self):
        print("destroyed")

@mute('destroy')
class BorgPlanet(Planet):
    pass
</code></pre>
<h1>Modifying the <code>__getattribute__</code> mechanism:</h1>
<p>For sake of completeness - what really makes Python reach methods and attributes on the super-class is what happens inside the <code>__getattribute__</code> call. n the <code>object</code> version of <code>__getattribute__</code> is where the algorithm with the priorities for "data-descriptor, instance, class, chain of base-classes, ..." for attribute retrieval is encoded.</p>
<p>So, changing that for the class is an easy an unique point to get a "legitimate" attribute error, without need for the "non-existent" descritor used on the previous methods.</p>
<p>The problem is that <code>object</code>'s <code>__getattribute__</code> does not make use of <code>type</code>'s one to search the attribute in the class - if it did so, just implementing the <code>__getattribute__</code> on the metaclass would suffice. One have to do that on the instance to avoid instance lookp of an method, and on the metaclass to avoid metaclass look-up. A metaclass can, of course, inject the needed code:</p>
<pre><code>def blocker_getattribute(target, attr, attr_base):
        try:
            muted = attr_base.__getattribute__(target, '__muted__')
        except AttributeError:
            muted = []
        if attr in muted:
            raise AttributeError("object {} has no attribute '{}'".format(target, attr))
        return attr_base.__getattribute__(target, attr)


def instance_getattribute(self, attr):
    return blocker_getattribute(self, attr, object)


class M(type):
    def __init__(cls, name, bases, namespace):
        cls.__getattribute__ = instance_getattribute

    def __getattribute__(cls, attr):
        return blocker_getattribute(cls, attr, type)



class Planet(metaclass=M):
    def destroy(self):
        print("destroyed")

class BorgPlanet(Planet):
    __muted__=['destroy']  #  or use a decorator to set this! :-)
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>Undestroyable</code> is a unique (or at least unusual) case, it's probably easiest to just redefine <code>destroy()</code>:</p>
<pre><code>class Undestroyable(Planet):

    # ...

    def destroy(self):
        cls_name = self.__class__.__name__
        raise AttributeError("%s has no attribute 'destroy'" % cls_name)
</code></pre>
<p>From the point of view of the user of the class, this will behave as though <code>Undestroyable.destroy()</code> doesn't exist … unless they go poking around with <code>hasattr(Undestroyable, 'destroy')</code>, which is always a possibility.</p>
<p>If it happens more often that you want subclasses to inherit some properties and not others, the mixin approach in <a href="https://stackoverflow.com/a/43022264">chepner's answer</a> is likely to be more maintainable. You can improve it further by making <code>Destructible</code> an <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">abstract base class</a>:</p>
<pre><code>from abc import abstractmethod, ABCMeta

class Destructible(metaclass=ABCMeta):

    @abstractmethod
    def destroy(self):
        pass

class BasePlanet:
    # ...
    pass

class Planet(BasePlanet, Destructible):

    def destroy(self):
        # ...
        pass

class IndestructiblePlanet(BasePlanet):
    # ...
    pass
</code></pre>
<p>This has the advantage that if you try to instantiate the abstract class <code>Destructible</code>, you'll get an error pointing you at the problem:</p>
<pre><code>&gt;&gt;&gt; Destructible()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class Destructible with abstract methods destroy
</code></pre>
<p>… similarly if you inherit from <code>Destructible</code> but forget to define <code>destroy()</code>:</p>
<pre><code>class InscrutablePlanet(BasePlanet, Destructible):
    pass
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; InscrutablePlanet()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class InscrutablePlanet with abstract methods destroy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than remove an attribute that is inherited, only inherit <code>destroy</code> in the subclasses where it is applicable, via a mix-in class. This preserves the correct "is-a" semantics of inheritance.</p>
<pre><code>class Destructible(object):
    def destroy(self):
        pass

class BasePlanet(object):
    ...

class Planet(BasePlanet, Destructible):
    ...

class IndestructiblePlanet(BasePlanet):  # Does *not* inherit from Destructible
    ...
</code></pre>
<p>You can provide suitable definitions for <code>destroy</code> in any of <code>Destructible</code>, <code>Planet</code>, or any class that inherits from <code>Planet</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Metaclasses and descriptor protocols are fun, but perhaps overkill.  Sometimes, for raw functionality, you can't beat good ole' <code>__slots__</code>.</p>
<pre><code>class Planet(object):

    def __init__(self, name):
        self.name = name

    def destroy(self):
        print("Boom!  %s is toast!\n" % self.name)


class Undestroyable(Planet):
    __slots__ = ['destroy']

    def __init__(self,name):
        super().__init__(name)

print()
x = Planet('Pluto')  # Small, easy to destroy
y = Undestroyable('Jupiter') # Too big to fail
x.destroy()
y.destroy()

Boom!  Pluto is toast!

Traceback (most recent call last):
  File "planets.py", line 95, in &lt;module&gt;
    y.destroy()
AttributeError: destroy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot inherit only a portion of a class. Its all or nothing.</p>
<p>What you can do is to put the destroy function in a second level of the class, such you have the Planet-class without the destry-function, and then you make a DestroyablePlanet-Class where you add the destroy-function, which all the destroyable planets use.</p>
<p>Or you can put a flag in the construct of the Planet-Class which determines if the destroy function will be able to succeed or not, which is then checked in the destroy-function.</p>
</div>
<span class="comment-copy">I wondered whether anyone would bother with something like this (ridiculously over-engineered, but great fun) descriptor/metaclass approach. Kudos, sir! +50 bounty if you add a <code>@mute('destroy')</code> class decorator to avoid the <code>del</code> statement ;-)</span>
<span class="comment-copy">@ZeroPiraeus: hmmm...class decorators - one does not even need a metaclass in this way, as the "deleted" descriptors can be set directly by it!</span>
<span class="comment-copy">Awesome :-) Your metaclass with a custom <code>__prepare__</code> isn't working (once the indentation error and incorrect <code>BorgPlanet</code> superclass are fixed, <code>del destroy</code> raises <code>NameError</code>), but the class decorator turned out very nicely :-) I'll apply the bounty once the 48 hour limit is up.</span>
<span class="comment-copy">Sorry - the <code>__prepare__</code> one was broken due to a bad signature in <code>Deleted.__init__</code> - it is one of those cases were Python translates the exceptions (in this case, from a TypeError on the call to a NameError due to <code>__delitem__</code> failing)</span>
<span class="comment-copy">Why is the <code>__init__</code> method necessary in <code>Undestroyable</code>? I tried to implement Undestroyable without <code>__init__</code> definition and the result was still the same. Any particular reason you included it?</span>
<span class="comment-copy">It says <a href="https://docs.python.org/3.5/reference/datamodel.html#notes-on-using-slots" rel="nofollow noreferrer">here</a> that while inheriting from a class without <code>__slots__</code> the <code>__dict__</code> of that class is always accessible so defining <code>__slots__</code> is not useful? Can you please explain why/how it is different in this case?</span>
<span class="comment-copy">@ShikharChauhan  This was just to show that the <code>__init__</code> method could be there (and used to initialize other stuff if necessary).  You are right that for the minimal example it is not required.</span>
<span class="comment-copy">@ShikharChauhan That statement about <code>__slots__</code> is correct, in that the object instance will still have a <code>__dict__</code>.  But the method attribute is in the class <code>__dict__</code>, not the instance <code>__dict__</code>.</span>
