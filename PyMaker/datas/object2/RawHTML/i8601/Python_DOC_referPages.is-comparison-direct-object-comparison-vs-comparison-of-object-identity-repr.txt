<div class="post-text" itemprop="text">
<p>So I am getting the following results:</p>
<ol>
<li><code>() is ()</code> returns <code>True</code> (comparison between two objects)</li>
<li><code>id(()) is id(())</code> returns <code>False</code>. (comparison between the representations of object identities)</li>
</ol>
<p>According to the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">python documentation</a>:</p>
<blockquote>
<p>The ‘is‘ operator compares the identity of two objects; the id() function returns an integer representing its identity.</p>
</blockquote>
<p>Given case (1), object <code>()</code> has the same identity (<em>memory address</em>) as object <code>()</code>; but in case (2), the representations of their identities are not identical to each other.</p>
<p>Why is that?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>id(..)</code> function returns <strong>an integer</strong> that represents the "identity" of an object so to speak. Although it is true that if two variables <code>x</code> and <code>y</code> refer to the <em>same</em> object, <code>x is y</code> succeed, and the result of <code>id(x)</code> is equal to <code>id(y)</code>, that <strong>does not mean those integers themeselves are the same object</strong>.</p>
<p>You thus should use:</p>
<pre><code>id(()) <b>==</b> id(())
#      ^ == not is</code></pre>
<p>In Python, even <code>int</code>s are objects, and although usually there is a <em>cache</em> such that small integers indeed refer to the same object, the following test will usually fail:</p>
<pre><code>&gt;&gt;&gt; 1234567890 is (1234567891-1)
False
&gt;&gt;&gt; 1234567890 == (1234567891-1)
True
</code></pre>
</div>
<span class="comment-copy">So you should compare the <code>id</code>s with <code>id(()) == id(())</code>... Use <code>==</code> not <code>is</code>.</span>
<span class="comment-copy">Because the ids are large integers that exist twice in memory. Only small integers are cached in CPython.</span>
<span class="comment-copy">@WillemVanOnsem yeah I understand that the <code>id()</code> returns integers but was confused about why they were different <i>objects</i> since they are the representations of the same object.</span>
<span class="comment-copy">@timgeb good to know. Thanks!</span>
<span class="comment-copy">@timgeb btw, can you add it in the answer below so I can vote it up? thanks! Also, I was curious how large is 'large', and <a href="http://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">answers from this question</a> say that anything &gt;256 counts as <i>large</i> and anything &lt;=256 is treated as literals</span>
<span class="comment-copy">"and therefore in some cases, the id(..) of an object could change between two calls". I'm fairly sure this is false: it would defeat the whole point of <code>id</code>. Do you have any references for this claim?</span>
<span class="comment-copy">@MarkDickinson: sorry I misread the documentation. The id is indeed guarnateed to be constant during an objects lifetime. (dowside of <i>speedreading</i> :( )</span>
<span class="comment-copy">The part about the memory address possibly changing <i>is</i> true, though, for some implementations (e.g., PyPy), which means that PyPy has to jump through hoops to have a constant <code>id</code> (which is of course <i>not</i> based on memory addresses). CPython never moves objects around in memory, so using the memory address for the <code>id</code> is safe.</span>
<span class="comment-copy">Cool. Thanks for the explanation!</span>
