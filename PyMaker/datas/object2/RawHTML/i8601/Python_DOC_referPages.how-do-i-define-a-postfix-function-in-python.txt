<div class="post-text" itemprop="text">
<p>I know that if you create your own object you can define your own methods on that object. </p>
<p><code>my_object_instance.mymethod()</code></p>
<p>I also know you can define infix functions with the <a href="https://pypi.python.org/pypi/infix/" rel="nofollow noreferrer">infix</a> package. </p>
<p><code>obj1 |func| obj2</code></p>
<p>What I want is the ability to define a function which accepts an existing type in postfix notation.</p>
<p>For example given a list <code>l</code> we may want to check if it is sorted. Defining a typical function might give us</p>
<pre><code>if is_sorted(l): #dosomething
</code></pre>
<p>but it might be more idiomatic if one could write</p>
<pre><code>if l.is_sorted(): #dosomething
</code></pre>
<p>Is this possible without creating a custom type?</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct way is inheritance, creating a custom type by inheriting <code>list</code> and adding the new functionality.  Monkeypatching is not a strength of Python.  But since you specifically asked:</p>
<blockquote>
<p>Is this possible without creating a custom type?</p>
</blockquote>
<p>What <a href="https://stackoverflow.com/a/42965291/674039">kindall mentioned</a> stands, Python does not allow it.  But since nothing in the implementation is truly read-only, you can approximate the result by hacking in the class dict.  </p>
<pre><code>&gt;&gt;&gt; def is_sorted(my_list):
...     return sorted(my_list) == my_list
... 
&gt;&gt;&gt; import gc
&gt;&gt;&gt; gc.get_referents(list.__dict__)[0]['is_sorted'] = is_sorted
&gt;&gt;&gt; [1,2,3].is_sorted()
True
&gt;&gt;&gt; [1,3,2].is_sorted()
False
</code></pre>
<p>The new "method" will appear in <code>vars(list)</code>, the name will be there in <code>dir([])</code>, and it will also be available/usable on instances which were created <em>before</em> the monkeypatch was applied.  </p>
<p>This approach uses the <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer">garbage collector interface</a> to obtain, via the class <a href="https://stackoverflow.com/q/32720492/674039"><code>mappingproxy</code></a>, a reference to the underlying dict.  And garbage collection by reference counting is a CPython implementation detail.  Suffice it to say, this is dangerous/fragile and you should not use it in any serious code.  </p>
<p>If you like this kind of feature, you might enjoy <a href="https://stackoverflow.com/questions/tagged/ruby"><kbd>ruby</kbd></a> as a programming language.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not generally allow monkey-patching of built-in types because the common built-in types aren't written in Python (but rather C) and do not allow the class dictionary to be modified. You have to subclass them to add methods as you want to.</p>
</div>
<span class="comment-copy">if what you want is a function that accepts a type as an argument, then you don't need to do anything; types are first class objects in python</span>
<span class="comment-copy">Postfix notation is something else.</span>
<span class="comment-copy">Thanks! This is perfect</span>
