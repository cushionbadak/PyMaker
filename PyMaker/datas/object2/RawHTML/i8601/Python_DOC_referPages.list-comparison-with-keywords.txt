<div class="post-text" itemprop="text">
<p>I'm trying to think of the best way to solve this issue.</p>
<p>I basically want to grab some text, and compare it against a keyword. </p>
<p>Of course, I could do:</p>
<pre><code>keyword = 'python 3.5'
title = 'python 3.5 is a programming language'
if keyword in title:
</code></pre>
<p>However, it has to be in that order. If the title text happened to be:</p>
<pre><code>title = 'my favourite version of python is 3.5!'
</code></pre>
<p>That would not work.</p>
<p>So, I have tried coming up with a way of splitting the the keyword with <code>.split()</code> and then checking if both items from the split keyword list are in the title variable, but have had no luck coming up with an efficient way.</p>
<p>If anyone knows a good way to do so, I'd be greatly appreciative.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will do the job:</p>
<pre><code>keyword = 'python 3.5'
title = 'python 3.5 is a programming language'
s=set(keyword.split(" "))
m=set(title.split(" "))
if(len(set.intersection(s,m)==len(s)): 
   print(True)
</code></pre>
<p>Assuming that you don't care about repetitions. That is, that you consider</p>
<pre><code>keyword = 'python 3.5 python'
title = 'python 3.5 is a programming language'
</code></pre>
<p>To be a pair in which all the keyword is indeed inside the title.</p>
</div>
<div class="post-text" itemprop="text">
<p>So you need to find each word of the key phrase, in order, in the title.  Try this: search for each word in order; resume the search in the remainder of the title.</p>
<pre><code>key_phrase = 'python 3.5'
title_list = ['python 3.5 is a programming language',
              'my favourite version of python is 3.5!']

key_word = key_phrase.split()

for title in title_list:
    remain = title.split()
    found = True
    for word in key_word:
        if word in remain:
            pos = remain.index(word)
            remain = remain[pos+1:]
        else:
            found = False

    print title, "\tfound=", found
</code></pre>
<p>Output:</p>
<pre><code>python 3.5 is a programming language    found= True
my favourite version of python is 3.5!  found= False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you need <code>all()</code> </p>
<pre><code>title = 'my favourite version of python is 3.5!'

keyword = 'python 3.5'
print all(n in title for n in keyword.split())

keyword = 'hello 3.5'
print all(n in title for n in keyword.split())

keyword = 'hello world'
print all(n in title for n in keyword.split())

keyword = 'python 2.0'
print all(n in title for n in keyword.split())
</code></pre>
<p>results in </p>
<pre><code>True
False
False
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short <em>one-liner</em> using built-in <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><strong><em>any()</em></strong></a> and <a href="https://docs.python.org/3/library/stdtypes.html?highlight=split#str.split" rel="nofollow noreferrer"><strong><em>str.split()</em></strong></a> functions:</p>
<pre><code>keyword = 'python 3.5'
title = 'my favourite version of python is 3.5!'

print(all(i in title for i in keyword.split()))
</code></pre>
<p>The output:</p>
<pre><code>True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this...if you want to customize the precision of match cases.</p>
<pre><code>keyword = 'python 3.5'
title = 'my favourite version of python is 3.5!'
precision = 100 # 100% precision (both python and 3.5 must exist in title)
if len([x for x in set(keyword.split(' ')) if x in title]) &gt;= round(len(set(keyword.split(' ')))*(precision/100)):
    print('Yes')
else:
    print('No')
</code></pre>
<p>output:</p>
<pre><code>'Yes'
</code></pre>
<p>if you change <code>title</code> to this:</p>
<pre><code>title = 'my favourite version of python is 3.4!'
</code></pre>
<p>output will be <code>'No'</code>
But...with some modification of <code>precision</code>:</p>
<pre><code>precision = 50
</code></pre>
<p>output will be <code>'Yes'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You don't want to compare lists (it's slow), you should compare sets. As a bonus, <code>issubset</code> is already defined :</p>
<pre><code>title = 'python 3.5 is a programming language'

def contains_all_keywords(sentence, keywords):
  keywords = set(keywords.split())
  return(keywords.issubset(set(sentence.split())))

print(contains_all_keywords(title, 'python 3.5'))
# True
print(contains_all_keywords(title, '3.5 python'))
# True
print(contains_all_keywords(title, 'python 2.7'))
# False
</code></pre>
</div>
<span class="comment-copy">How granular you want that to be ? Word based? i.e., you want to search if contains("python") &amp;&amp; contains("3.5") in order ? Or if keyword was "py 3.5" the above strings would also be valid ?</span>
<span class="comment-copy">Also in that order that you say is that python has to be before 3.5 ?</span>
<span class="comment-copy">@holandaGo I basically want to have a single keyword and search hundreds of strings for said keyword. As long as the string I am searching contains, from the given example, 'python' AND '3.5' it'd return a match, no matter the order.</span>
<span class="comment-copy">Then it's a no brainer, just split the keyword in words and check if all are contained</span>
<span class="comment-copy">@holandaGo of course, I stated this is what I needed doing in my initial question. It was just finding an efficient way of doing so, which thanks to the 6 kind people below I now have.</span>
