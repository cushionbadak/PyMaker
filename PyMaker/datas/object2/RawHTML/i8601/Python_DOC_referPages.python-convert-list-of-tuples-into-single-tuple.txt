<div class="post-text" itemprop="text">
<p>Is there a way to convert a list of tuples into a single tuple? I have received a list of tuples from cursor.fetchall() but would like to make this into a single tuple:</p>
<pre><code>curr_table_columns = cursor.fetchall()
</code></pre>
<p>For example:</p>
<pre><code>[(u'w_id',), (u'w_name',), (u'w_street',)]
</code></pre>
<p>becomes</p>
<pre><code>[(u'w_id', u'w_name', u'w_street')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">With <code>itertools.chain</code></a>, it's trivial. <code>from itertools import chain</code> and you can do either:</p>
<pre><code>[tuple(chain.from_iterable(curr_table_columns))]
</code></pre>
<p>or:</p>
<pre><code>[tuple(chain(*curr_table_columns))]
</code></pre>
<p>The former is preferred for long or unbounded iterable inputs (though don't wrap in <code>tuple</code> for unbounded!); for a small input (particularly one that's already a <code>list</code> or <code>tuple</code>), the latter is slightly slower, but fine. Either one is going to be significantly faster than a genexpr and indexing for inputs of any size at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>a=[(u'w_id',), (u'w_name',), (u'w_street',)]

print [tuple([i[0] for i in a])]
</code></pre>
<p>Output:</p>
<pre><code>[(u'w_id', u'w_name', u'w_street')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not efficient*, but it is simple:</p>
<pre><code>&gt;&gt;&gt; ts = [(u'w_id',), (u'w_name',), (u'w_street',)]
&gt;&gt;&gt; sum(ts, ())
('w_id', 'w_name', 'w_street')
</code></pre>
<p>So, just wrap it in a list if you must:</p>
<pre><code>&gt;&gt;&gt; result = [sum(ts, ())]
&gt;&gt;&gt; result
[('w_id', 'w_name', 'w_street')]
</code></pre>
<p>*Warning: scales quadratically. Some might be inclined to let is slide for joining some column names into a single container. Definitely don't try to process millions of tuples this way.</p>
<p>Use <code>itertools</code> solution for linear time.</p>
</div>
<div class="post-text" itemprop="text">
<p>This function can convert listWidgets item into single tuple and also convert multiple element of tuple into single element tuple : Used for Sqlite3 and data query from listwidgets.</p>
<pre><code>def tuple_converter(self,item):
        target = ''
        for i in item:
            target += i + " " 
        target = target.rstrip()
        target = tuple(target.split(","))
        return target
#syntax  name = tuple_converter(tuple((item).split()))
</code></pre>
<p>''' </p>
</div>
<span class="comment-copy">Thanks for your comment on my answer +1</span>
<span class="comment-copy">@bernie: I just figured you'd edit yours; only posted my own because you deleted. :-)</span>
<span class="comment-copy">No worries! :-)</span>
<span class="comment-copy">You can also use: sum(tupleVar, ())</span>
<span class="comment-copy">@shadow0359: Yeah, as mentioned, the scaling on <code>sum</code> for sequences is quadratic, where <code>chain</code> wrapped in <code>tuple</code> is linear scaling, so if you can't be 100% sure your inputs are tiny, you don't want to use <code>sum</code>. Even Python's <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">docs for <code>sum</code> basically say "I think you wanted <code>chain</code>"</a>.</span>
<span class="comment-copy">Note: <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">The <code>sum</code> docs</a> themselves discourage using <code>sum</code> for this purpose (recommending <code>itertools.chain</code> instead). It works, but the scaling is terrible when the inputs get larger (<code>sum</code> is a <a href="https://en.wikipedia.org/wiki/Joel_Spolsky#Schlemiel_the_Painter.27s_algorithm" rel="nofollow noreferrer">Schlemiel the Painter's algorithm</a> when used with sequences).</span>
