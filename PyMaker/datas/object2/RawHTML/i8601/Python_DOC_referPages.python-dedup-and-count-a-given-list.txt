<div class="post-text" itemprop="text">
<p>I am using the following code to dedup and count a given list: </p>
<pre><code>def my_dedup_count(l):
    l.append(None)
    new_l = []
    current_x = l[0]
    current_count = 1
    for x in l[1:]:
        if x == current_x:
            current_count += 1
        else:
            new_l.append((current_x, current_count))
            current_x = x
            current_count = 1

    return new_l
</code></pre>
<p>With my testing code:</p>
<pre><code>my_test_list = ['a','a','b','b','b','c','c','d']
my_dedup_count(my_test_list)
</code></pre>
<p>result is:</p>
<pre><code>[('a', 2), ('b', 3), ('c', 2), ('d', 1)]
</code></pre>
<p>The code is doing fine and the output is correct. However, I feel my code is quite lengthy and am wondering would anyone suggest a more elegant way to improve the above code? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, don't re-invent the wheel. Use the standard library instead; you want to use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code> class</a> here:</p>
<pre><code>from collections import Counter

def my_dedup_count(l):
    return Counter(l).items()
</code></pre>
<p>You may want to just return the counter itself and use all functionality it provides (such as giving you a key-count list sorted by counts).</p>
<p>If you expected only consecutive runs to be counted (so <code>['a', 'b', 'a']</code> results in <code>[('a', 1), ('b', 1), ('a', 1)]</code>, then use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>from itertools import groupby

def my_dedup_count(l):
    return [(k, sum(1 for _ in g)) for k, g in groupby(l)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote two versions of some shorter ways to write what you accomplished.</p>
<p>This first option ignores ordering, and all like values in the list will be deduplicated.  </p>
<pre><code>from collections import defaultdict

def my_dedup_count(test_list):
    foo = defaultdict(int)
    for el in test_list:
        foo[el] += 1

    return foo.items()

my_test_list = ['a','a','b','b','b','c','c','d', 'a', 'a', 'd']
&gt;&gt;&gt; [('a', 4), ('c', 2), ('b', 3), ('d', 2)]
</code></pre>
<p>This second option respects order and only deduplicates consecutive duplicate values. </p>
<pre><code>def my_dedup_count(my_test_list):
output = []
succession = 1
for idx, el in enumerate(my_test_list):
    if idx+1 &lt; len(my_test_list) and el == my_test_list[idx+1]:
        succession += 1
    else:
        output.append((el, succession))
        succession = 1

return output

my_test_list = ['a','a','b','b','b','c','c','d', 'a', 'a', 'd']
&gt;&gt;&gt; [('a', 2), ('b', 3), ('c', 2), ('d', 1), ('a', 2), ('d', 1)]
</code></pre>
</div>
<span class="comment-copy">A multiset viz. <code>collections.Counter</code> is what you're looking for.</span>
<span class="comment-copy">I'll leave this here as comment for the rare case where someone wants to avoid importing <code>collections</code>: <code>[(e,my_test_list.count(e)) for e in set(my_test_list)]</code></span>
<span class="comment-copy">@vmg: that's very, very inefficient, as that will fully traverse <code>my_test_list</code> K times (where K is the number of unique elements), making that a O(KN) algorithm (where N is the length of the input list). There are more efficient ways of doing this even without a <code>Counter()</code> (although the counting code in <code>collections.Counter</code> is highly optimised).</span>
<span class="comment-copy">@vmg this creates the set in every <i>iteration</i>. you can at least store it in a variable and use the variable in the comprehension</span>
<span class="comment-copy">@vmg: and <code>collections</code> is part of the standard library, why would you want to avoid importing from that?</span>
<span class="comment-copy">@Ev.Kounis: no, it only creates the set <b>once</b>.</span>
