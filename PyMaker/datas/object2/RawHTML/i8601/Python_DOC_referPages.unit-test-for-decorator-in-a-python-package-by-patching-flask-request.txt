<div class="post-text" itemprop="text">
<p>I have a python module <code>security.py</code> which defines a decorator <code>authorized()</code>. </p>
<p>I want to test the decorator. The decorator will receive a flask request header.
The decorator is sth like this:</p>
<pre><code>def authorized():
    def _authorized(wrapped_func):
        def _wrap(*args, **kwargs):
            if 'token' not in request.headers:
                LOG.warning("warning")
                abort(401)
                return None
            return wrapped_func(*args, **kwargs)
        return _wrap
    return _authorized
</code></pre>
<p>I want to mock the flask request header using a <code>@patch</code> decorator.The test I wrote is sth like this:</p>
<pre><code>@patch('security.request.headers', Mock(side_effect=lambda *args, **kwargs: MockHeaders({})))
def test_no_authorization_token_in_header(self):
    @security.authorized()
    def decorated_func(token='abc'):
        return access_token

    result = decorated_func()
    self.assertEqual(result, None)

class MockHeaders(object):
    def __init__(self, json_data):
        self.json_data=json_data
</code></pre>
<p>but I always get the following error:</p>
<pre><code>name = 'request'

def _lookup_req_object(name):
    top = _request_ctx_stack.top
    if top is None:
       raise RuntimeError(_request_ctx_err_msg)

       RuntimeError: Working outside of request context.

       This typically means that you attempted to use functionality that needed
       an active HTTP request.  Consult the documentation on testing for
       information about how to avoid this problem.
</code></pre>
<p>How should I do it right?</p>
</div>
<div class="post-text" itemprop="text">
<p>Mock the whole request object to avoid triggering the context lookup:</p>
<pre><code>@patch('security.request')
</code></pre>
<p>and build up the mock from there:</p>
<pre><code>@patch('security.request')
def test_no_authorization_token_in_header(self, mock_request):
    mock_request.headers= {}

    @security.authorized()
    def decorated_func(token='abc'):
        return token

    self.assertRaises(Abort):
        result = decorated_func()
</code></pre>
<p>Since a missing token results in an <code>Abort</code> exception being raised, you should explicitly test for that. Note that the <code>request.headers</code> attribute is not called anywhere, so <code>side_effect</code> or <code>return_value</code> attributes don't apply here.</p>
<p>I ignored <code>MockHeaders</code> altogether; your decorator is not using <code>json_data</code> and your implementation is lacking a <code>__contains__</code> method, so <code>in</code> tests wouldn't work on that. A plain dictionary suffices for the current code-under-test.</p>
<p>Side note: <code>authorized</code> is a decorator factory, but it doesn't take any parameters. It'd be clearer if you didn't use a factory there at all. You should also use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps()</code></a> to ensure that any metadata other decorators add are properly propagated:</p>
<pre><code>from functools import wraps

def authorized(wrapped_func):
    @wraps(wrapped_func)
    def _wrap(*args, **kwargs):
        if 'token' not in request.headers:
            LOG.warning("warning")
            abort(401)
            return None
        return wrapped_func(*args, **kwargs)
    return _wrap
</code></pre>
<p>then use the decorator directly (so no call):</p>
<pre><code>@security.authorized
def decorated_func(token='abc'):
    return access_token
</code></pre>
</div>
<span class="comment-copy">@MartijnPieters yes the class is right after the method decorated by patch</span>
<span class="comment-copy">Oops, missed that. Mea Culpa.</span>
