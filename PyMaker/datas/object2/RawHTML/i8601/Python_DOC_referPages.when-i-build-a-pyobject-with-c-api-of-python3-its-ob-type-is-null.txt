<div class="post-text" itemprop="text">
<p>I ran such code in C++11:</p>
<pre><code>PyObject* aa = PyLong_FromLong(7L);
</code></pre>
<p>Then I checked the value of <code>aa</code>, it's not <code>NULL</code>, but <code>aa-&gt;ob_type</code> was <code>NULL</code>.</p>
<p>However, when I ran:</p>
<pre><code>PyObject* aa = PyLong_FromLong(257L);
</code></pre>
<p><code>aa-&gt;ob_type</code> was <strong>not</strong> <code>NULL</code> anymore. I read the document of PyLong_FromLong, and found this:</p>
<pre><code>PyObject* PyLong_FromLong(long v)
Return value: New reference. 
Return a new PyLongObject object from v, or NULL on failure.

The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)
</code></pre>
<p>Seems that when building <code>PyLongObject</code> between -5 and 256 will meet this problem. But I don't understand the reason.</p>
<p>What's more, this problem doesn't appear in Python2. That's incredible!</p>
</div>
<div class="post-text" itemprop="text">
<p>You haven't initialized Python. Since these small objects are special-cased they are set up when Python is initialized.</p>
<pre><code>#include &lt;Python.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
  Py_Initialize();
  PyObject* aa = PyLong_FromLong(7L);
  printf("aa=%d\naa-&gt;ob_type=%p\n",PyLong_AsLong(aa),aa-&gt;ob_type);
  Py_Finalize();
  return 0;
}
</code></pre>
<p>correctly prints</p>
<blockquote>
<p><code>aa=7</code></p>
<p><code>aa-&gt;ob_type=0x7f380d6b5800</code> (note that this will vary from run to run)</p>
</blockquote>
<p>If I comment out <code>Py_Initialize()</code> and <code>Py_Finalize()</code> then I get a segmentation fault, but if I don't try reading the value with <code>PyLong_AsLong</code> then I get a null pointer for <code>ob_type</code>.</p>
<hr/>
<p><a href="https://docs.python.org/3/extending/embedding.html#very-high-level-embedding" rel="nofollow noreferrer">The documentation</a> does tell you to initialize the interpreter.</p>
<hr/>
<p>With respect to Python2 it has two integer types <code>PyInt</code> and <code>PyLong</code> with <code>PyInt</code> handling the small values and so having the special-cased table. You'll probably see the same issue if you use <code>PyInt</code> in Python2. Anything you do with Python before calling <code>Py_Initialize</code> is undefined though, so it could fail in different exciting ways.</p>
</div>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">“is” operator behaves unexpectedly with integers</a></span>
<span class="comment-copy">In Python2 there's two integer types. <code>PyInt</code> is the smaller type, so I think -5 -&gt; 256 will be defined there and not for <code>PyLong</code>.</span>
