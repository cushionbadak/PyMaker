<div class="post-text" itemprop="text">
<p>I'm learning the book named <em>Data Structures &amp; Algorithms in Python</em>. </p>
<p>On Page 12 that introduce the <strong>Logical Operators</strong>, it writes:</p>
<blockquote>
<p>The <strong>and</strong> and <strong>or</strong> operators <strong>short-circuit</strong>, (I thinks it should add <em>is called</em>), in that they do not evaluate the second operand if the result can be determined based on the value of the first operand.</p>
<p>This feature is useful when constructing Boolean expressions in which we first test that a certain condition holds (such as a reference not being None), and then test a condition that could have otherwise generated an error condition <strong>had the prior test not succeeded</strong>.</p>
</blockquote>
<p>I have some questions about this passage:</p>
<ul>
<li><p>I can't understand exact meaning of the second paragraph. In C, we can use the <strong>&amp;&amp;</strong>(logical <strong>and</strong>) as the following expression:
<code>(i  != 0) &amp;&amp; (j / i &gt; 0)</code> to prevent the error of a division by zero. So then, could I use the expression <code>(i != 0) and ( j / i &gt; 0)</code> in Python as C to get the same effect?　Is my understanding to the passage right? </p></li>
<li><p>What's the usage of <strong>or</strong> as a <strong>short-circuit</strong> to constructing Boolean expressions as said in the second paragraph ?  </p></li>
<li><p>The final question is about the grammar of <strong>had the prior test not succeeded</strong> in the second paragraph. I this it should be "an error condition that can had the prior test not succeeded", am I right?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>As I recall, short-circuit is referring to a compiler optimization.  As you are already aware, in an AND conditional, the second expression is not evaluated if the first condition is false.  After all, what is the point?  The overall expression CANNOT be true since the first condition is already false.  Similarly, with the OR logic, as soon as a single condition is true, the entire OR expression is true.  This boils down to runtime savings.  Expressions can be left unevaluated and thus not burn any CPU cycles.  </p>
<p>Incidentally, I use OR short-circuits all the time in bash programming.  For example, the following expression is useful for running a function if the preceeding condition is false:</p>
<pre><code>[ $# -ge 2 ] || errexit "You have not supplied enough parameters"
</code></pre>
<p>In the above example, errexit will be called only if the command line did not have 2 arguments or more.   Of course, in my example, I don't care about performance.  Rather, I'm using the || short circuit logic as syntactic sugar.</p>
<p>And that's what it boils down to:  In a tight loop, where performance matters, you can be somewhat certain that expressions will not be evaluated unnecessarily.  But in the example that you described for &amp;&amp; to avoid divide by zero, you could have just as easily written that with a nested IF statement.  Again, it's a style choice more often than a performance consideration. </p>
<p>All that said, let me answer your questions one at a time:</p>
<blockquote>
<p>I can't understand exact meaning of the second paragraph. In C, we can use the &amp;&amp;(logical and) as the following expression: (i  != 0) &amp;&amp;
  (j / i &gt; 0) to prevent the error of a division by zero. So then, could
  I use the expression (i != 0) and ( j / i &gt; 0) in Python as C to get
  the same effect?　Is my understanding to the passage right?</p>
</blockquote>
<p>You are correct.</p>
<blockquote>
<p>What's the usage of or as a short-circuit to constructing Boolean expressions as said in the second paragraph ?</p>
</blockquote>
<p>As I explained in detail above:  performance and syntax sugar ( that is, less typing and shorter expressions; idioms ).</p>
<blockquote>
<p>The final question is about the grammar of had the prior test not
  succeeded in the second paragraph. I this it should be "an error
  condition that can had the prior test not succeeded", am I right?</p>
</blockquote>
<p>I agree with you that the statement could be worded better.  But when you try to express it, you'll see that it is a difficult thing to do ( in fact, your suggestion is not valid ).  Basically, your example of avoiding divide by zero error is a perfect example of what the author is trying to say.  Here's my attempt to paraphrase:  Short-circuit logic is useful to check pre-conditions of expressions that may generate errors if those conditions are not met.    </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I can't understand exact meaning of the second paragraph. In C, we can
  use the &amp;&amp;(logical and) as the following expression: (i  != 0) &amp;&amp; (j /
  i &gt; 0) to prevent the error of a division by zero. So then, could I
  use the expression (i != 0) and ( j / i &gt; 0) in Python as C to get the
  same effect?　Is my understanding to the passage right?</p>
</blockquote>
<p>Yes</p>
<blockquote>
<p>What's the
  usage of or as a short-circuit to constructing Boolean expressions as
  said in the second paragraph ?</p>
</blockquote>
<p>As an example:</p>
<pre><code>if (y is None) or (x not in y):
</code></pre>
<p>where <code>y</code> is either a list of things or <code>None</code> which in this case we want to treat a bit like an empty list, but <code>x not in None</code> would be an error.</p>
<p>Or:</p>
<pre><code>(i  == 0) or (j / i &gt; 0)
</code></pre>
<blockquote>
<p>The final question is about the grammar
  of had the prior test not succeeded in the second paragraph. I this it
  should be "an error condition that can had the prior test not
  succeeded", am I right?</p>
</blockquote>
<p>No, your phrasing is not correct grammar.</p>
<p>If you have <code>X and/or Y</code>, <code>X</code> is the first or 'prior' test, <code>Y</code> is the second, and it's possible that <code>X</code> is false and trying to evaluate <code>Y</code> will cause an error.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; if 1 or 0:
...     print "I am learning"
... 
I am learning
&gt;&gt;&gt; if 1 and 0:
...     print "I am learning"
... 
&gt;&gt;&gt; if 0:
...     print "I am learning"
... 
&gt;&gt;&gt; if 1:
...     print "I am learning"
... 
I am learning
&gt;&gt;&gt; if None and 1:
...     print "be crazy"
... 
&gt;&gt;&gt; if None or 1:
...     print "be crazy"
be crazy
</code></pre>
<p>much like C implementation.</p>
<p>And the last line is read correct had the first condition was unsuccessful in returning the error the second condition checks for the error</p>
</div>
<div class="post-text" itemprop="text">
<p>There is another reason -- syntactic correctness -- to use short circuit.  Getting an item from a list for comparison without throwing an error on empty list condition is an important reason to use short circuiting as shown below.  There are other ways to handle empty list, but such code would be more complex (more lines of code).</p>
<p>In this example, the application requirement is to behave differently strictly when 'bob' is the last list item. Bob is required to not be last in our list! (Because Bob is the best, that's all.)</p>
<p>The three lines of code shown below that have conditional expressions with the "or" in them do not throw an error.</p>
<pre><code>&gt;&gt;&gt; a = []
&gt;&gt;&gt; a[-1] == 'bob'  # is the last one 'bob'?
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
&gt;&gt;&gt; a[-1:][0] == 'bob'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
&gt;&gt;&gt; len(a)
0
&gt;&gt;&gt; len(a)==0 or a[-1] != "bob"
True
&gt;&gt;&gt; a.append('bob')
&gt;&gt;&gt; len(a)==0 or a[-1] != "bob"  # the last one is bob. Act different.
False
&gt;&gt;&gt; a.append('news')
&gt;&gt;&gt; len(a)==0 or a[-1] != "bob"
True
</code></pre>
</div>
<span class="comment-copy">1. You can just test it out 2. It's the same as in C 3. Your "correction" doesn't make sense to me and I doubt there's anything wrong with the grammar here</span>
<span class="comment-copy">A note: Python's Boolean logical operators have <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">lower precedence</a> than most other operators, so you usually don't need parentheses around the expressions on either side. You can, for instance, just write <code>i != 0 and j / i &gt; 0</code>. Only <code>x if y else z</code> expressions and <code>lambda</code> functions have lower precedence, and I can't even think of a way to have those usefully show up within a term of a Boolean operator (it's possible, but will almost never happen in real-word code).</span>
<span class="comment-copy">Thanks for all your help. The answer to the third question is here :  <a href="http://english.stackexchange.com/questions/1308/conditional-sentences-not-starting-with-if">Conditional sentences not starting with “if”</a>.</span>
<span class="comment-copy">"performance and syntax sugar" is not complete because sometimes you require short circuit to avoid throwing an error.  Take the example of testing the last value in a list.  You need to first check if list is empty before comparing the last value in the list.  mylist[-1] will throw an error when list is empty.</span>
<span class="comment-copy">I think you and I could debate the terminology back and forth without a strict definition of syntax sugar.  To me, the example you give is syntax sugar in as much as it could be written as an if statement as well.   You may not agree with the term "syntax sugar" in this case, but you would have to agree that both the if statement and the boolean short circuit are two ways of expressing the same bit of code and it's more a matter of style than anything else.</span>
