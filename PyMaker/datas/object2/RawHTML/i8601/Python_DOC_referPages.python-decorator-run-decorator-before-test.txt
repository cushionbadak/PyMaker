<div class="post-text" itemprop="text">
<p>I'm looking to add a decorator that runs a video recorder on certain tests like so:</p>
<pre><code>@decorators.video(self)
def test_1234(self):
    ...
</code></pre>
<p>I'm having trouble passing the self variable into the decorator as it is need for some attributes. How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>theodox answer is generally good, but for decorators you should use <code>functools.wraps</code> function, like in an example below:</p>
<pre><code>from functools import wraps

def enable_video(fn)
    '''Decorate the function to start video, call the function, stop video.'''
    @wraps(fn)
    def inner(*args, **kwargs): 
    # could be just `def inner(self):` if only intended to use
    # with methods without arguments and keyword arguments
        do_stuff_before()
        fn(*args, **kwargs)
        do_stuff_after()
    return inner
</code></pre>
<p>It will persist original docstrings, original function name (and more). You can read more about it in <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">Python docs</a>.</p>
<p>Then, assuming that previous code is in <code>decorators</code> module, you should use it as follows:</p>
<pre><code>class MyTestCase(unittests.TestCase);
    @decorators.enable_video
    def testSomeVideoFunction(self):
        do_test_stuff()
</code></pre>
<p>Note that in the code example it's just <code>@decorators.enable_video</code>, <strong>not</strong> <code>@decorators.enable_video(self)</code>. As like in jonrsharpe's comment to your question, reference to a <code>self</code> is not present at a decoration time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure you need the <code>self</code> reference at all?  </p>
<p>More commonly you'd do something like this</p>
<pre><code>def enable_video(fn):
    '''decorate the test function so it starts the video, runs the test, and stop the video'''   
    def video_aware_test(self_refrence):
       start_video_recorder()
       try:
          fn()
       finally:
          stop_video_recorder()
    return video_aware_test
</code></pre>
<p>And you'd apply it like this:</p>
<pre><code> @enable_video
 def test_something(self)
</code></pre>
<p>If for some reason the decorator actually needed the self reference, you can see where you'd grab it.  This version doesn't include configuring the video recorder in any way, to that you'd use a class rather than a function decorator and pass the configuration as arguments.</p>
</div>
<span class="comment-copy">You're doing something <i>very</i> wrong here if you think you need this. Please show the code of the decorator though.</span>
<span class="comment-copy">At the time a method decorator is executed, the class has not yet been created so there's no way an instance has. However the first argument to the wrapper function when it gets called, as it's the first argument to the wrapped method, is the instance <code>self</code>. You have access to it at call time, not decoration time.</span>
