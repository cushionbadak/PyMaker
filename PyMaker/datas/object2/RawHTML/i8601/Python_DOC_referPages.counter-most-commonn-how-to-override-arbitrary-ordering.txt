<div class="post-text" itemprop="text">
<p>Can I accomplish a rank/sort using Counter.most_common() functionality, thus avoiding this line: <code>d = sorted(d.items(), key=lambda x: (-x[1],x[0]), reverse=False)</code> ??</p>
<p><strong>Challenge:</strong>
You are given a string.The string contains only lowercase English alphabet characters.Your task is to find the top three most common characters in the string.</p>
<p><strong>Output Format:</strong>
Print the three most common characters along with their occurrence count each on a separate line. Sort output in descending order of occurrence count. If the occurrence count is the same, sort the characters in ascending order.</p>
<p>In completing this I used dict, Counter, and sort in order to ensure "the occurrence count is the same, sort the characters in ascending order". The in-built Python <code>sorted</code> functionality ensures ordering by count, then alphabetical. <strong>I'm curious if there is a way to override <code>Counter.most_common()</code> default arbitrary sort/order logic as it seems to disregard the lexicographical order of the results when picking the top 3.</strong></p>
<pre><code>import sys
from collections import Counter

string = sys.stdin.readline().strip()
d = dict(Counter(string).most_common(3))
d = sorted(d.items(), key=lambda x: (-x[1],x[0]), reverse=False)

for letter, count in d[:3]:
    print letter, count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes the <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter" rel="nofollow noreferrer">doc explicitly says <code>Counter.most_common()</code>'s (tie-breaker) order for when counts are equal is arbitrary</a>.</p>
<ul>
<li>UPDATE: PM2Ring told me Counter inherits dict's ordering. The insertion order thing only happens in 3.6+, and is only guaranteed in 3.7. It's possible the doc is lagging.</li>
<li>In cPython 3.6+ they fall back on original insertion order (see bottom), but don't rely on that implementation because per the spec, it's not defined behavior. Best to do your own sort, as you say, if you want totally deterministic behavior.</li>
<li>I show at bottom how <strong>you can <a href="https://stackoverflow.com/questions/5626193/what-is-monkey-patching">monkey-patch</a> <code>Counter.most_common</code> with your own sort function</strong> like you show, but that's frowned on. (Code you write might accidentally rely on it and hence break when it wasn't patched.)</li>
<li>You could subclass <code>Counter</code> to <code>MyCounter</code> so you can override its <code>most_common</code>. Painful and not really portable.</li>
<li>Really the best approach is just to write code and tests that don't rely on the arbitrary tiebreaker order from <code>most_common()</code></li>
<li>I agree that <code>most_common()</code> should not have been hardwired and we should be able to pass a comparison key or sort function into <code>__init__()</code>.</li>
</ul>
<p>Monkey-patching <code>Counter.most_common()</code> :</p>
<pre><code>def patched_most_common(self):
    return sorted(self.items(), key=lambda x: (-x[1],x[0]))

collections.Counter.most_common = patched_most_common

collections.Counter('ccbaab')
Counter({'a': 2, 'b': 2, 'c': 2})
</code></pre>
<p>Demonstrating that in cPython 3.7, the arbitrary order is order of insertion (first insertion of each character):</p>
<pre><code>Counter('abccba').most_common()
[('a', 2), ('b', 2), ('c', 2)]

Counter('ccbaab').most_common()
[('c', 2), ('b', 2), ('a', 2)]
</code></pre>
</div>
<span class="comment-copy"><code>Counter</code> can count objects as long as they are hashable. But many objects are not orderable, so trying to order them generally doesn't make sense.</span>
<span class="comment-copy">The order of what <code>most_common()</code> returns is <b>not</b> arbitrary. It in the order of the counts, from most common to the least, of the items in it. You could probably <a href="http://stackoverflow.com/questions/5626193/what-is-a-monkey-patch">monkey patch</a> the module to change this, I suppose, but that seems ill-advised.</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter" rel="nofollow noreferrer">doc explicitly says <code>Counter.most_common()</code>'s tie-breaker order for when counts are equal is arbitrary</a>  (cc: @martineau). In cPython they fall back on original insertion order, but don't rely on that because it's not defined behavior. Best to sort, as you say, if you want totally deterministic behavior.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/35446015/">stackoverflow.com/questions/35446015</a></span>
<span class="comment-copy">Another question <a href="https://stackoverflow.com/questions/36807701/how-to-get-the-python-counter-output-ordered-by-order-of-inputs">How to get the python Counter output ordered by order of inputs?</a>.</span>
<span class="comment-copy">Good answer. Can you not reduce complexity by using <code>heapq</code> as per the <a href="https://stackoverflow.com/questions/29240807/python-collections-counter-most-common-complexity">current implementation</a>?</span>
<span class="comment-copy">@jpp: good point, I wasn't aware Counter maintained a heapq, hence can't accept arbitrary sort-function on-the-fly. But we can still apply whatever O(N log N) sort function we want later.</span>
<span class="comment-copy">Yep, I guess it's worth pointing out the increase in complexity, i.e. it's not a comparable change we're implementing.</span>
<span class="comment-copy">@jpp: No, Counter can still keep a heapq internally, just we apply whatever O(N log N) sort function we want later.</span>
<span class="comment-copy">Hmm, but I'm specifically talking about <code>most_common</code>. Your monkey-patched <code>most_common</code> will no longer <i>use</i> <code>heapq</code>. Or have I misunderstood something?</span>
