<div class="post-text" itemprop="text">
<p>So, I have a dictionary like: </p>
<pre><code>d = {'col1': [1,2,3,4,5], 'colnames':['a','b','d','e']}
list_of_ids = [1,2]
</code></pre>
<p>I am trying to create a DataFrame like:</p>
<pre><code>id, col1, colnames
1,  1,     a
1, 2,    b
1,3, c

...
2,1,a
2,1,b

.. and so on
</code></pre>
<p>So, basically, for each element in list, generate all the possible column entries.</p>
<p>How can I do this with Pandas?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you can just use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> directly.</p>
<pre><code>from itertools import product

df = pd.DataFrame(list(product(list_of_ids, d['col1'], d['colnames'])), 
                  columns=['id', 'col1', 'colnames'])

#     id col1  colnames
# 0    1    1         a
# 1    1    1         b
# 2    1    1         d
# 3    1    1         e
# 4    1    2         a
# ...
</code></pre>
<p>With your current input size, this approach seems reasonable enough. However, if you intend to perform this operation on a much much larger dataset, you'll want to use a NumPy solution like <a href="https://stackoverflow.com/a/42912804/4686625">piRSquared's</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong><em>using <code>numpy.repeat</code></em></strong> </p>
<pre><code># the data
d = {'col1': np.arange(1, 6), 'colnames':list('abde'), 'id': [1, 2]}

# calculate length of each sub-list
lengths = {k: len(v) for k, v in d.items()}

# calculate product of all lengths...
# ... then the product of all but current.
# this provides the value we must repeat by.
p = np.product(list(lengths.values()))
p_ = {k: p // v for k, v in lengths.items()}

# perform the repeat within a dictionary comprehension
# and pass to the dataframe constructor
pd.DataFrame({k: np.repeat(v, p_[k]) for k, v in d.items()})
</code></pre>
<hr/>
<pre><code>    col1 colnames  id
0      1        a   1
1      1        a   1
2      1        a   1
3      1        a   1
4      1        a   1
5      1        a   1
6      1        a   1
7      1        a   1
8      2        a   1
9      2        a   1
10     2        b   1
11     2        b   1
...
</code></pre>
<hr/>
<p><strong><em>timing with given data</em></strong> </p>
<p><a href="https://i.stack.imgur.com/mngpym.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/mngpym.png"/></a></p>
<p><strong><em>with much bigger data</em></strong> </p>
<p><a href="https://i.stack.imgur.com/Fhj9Q.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Fhj9Q.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Shorter ways to do this but</p>
<pre><code>import pandas as pd

out = []
for x in range(1,3):
    for y in range(1,6):
        for z in 'abde':
            out.append([x, y, z]) 
df = pd.DateFrame(out)
</code></pre>
<p>Substitute your lists/dictionary calls in the appropriate places and you should be good</p>
</div>
<span class="comment-copy">Great answer + 1</span>
<span class="comment-copy">Ah product can take more than one parameter. V nice</span>
<span class="comment-copy">@Mitch <code>True</code> I'll fix in a bit.  Working on better answer</span>
<span class="comment-copy">@Mitch there it is</span>
<span class="comment-copy">Can't benchmark now but that looks very nice, thanks for pinging me! +1</span>
<span class="comment-copy">@Mitch I've added some</span>
<span class="comment-copy">As I'd expect, yeah. Thanks!</span>
