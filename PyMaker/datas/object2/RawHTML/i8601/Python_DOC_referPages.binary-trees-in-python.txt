<div class="post-text" itemprop="text">
<p>I have to implement a binary tree in Python. One node of a tree have several attributes. One of my requirements is a minimum of memory usage, specifically the overhead of the data structures.</p>
<p>So my question is, how much overhead is produced by different ways of the implementation. I think about using a dictionary where one key is "left" and another is "right" for the child nodes. Another way would be by using a class with the attributes "left" and "right" for the children. </p>
<p>Are there any noticable advantages or disadvantages for these two options? Or are there any better options? </p>
<p>I'll have to use Pythons standard library and I'm using Python 3.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can use class, dictionary, and namedtuple to implement it.</p>
<p>if you want to use class:</p>
<pre><code>class BNode(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

import sys
b = BNode(5)
sys.getsizeof(b)
</code></pre>
<p>This will return 56 on my PC with python 3.5.2.
If we want to optimize it, we add __slot__ atrribute.</p>
<pre><code>class BNode(object):
    __slot__ = ('val','left','right')
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

b = BNode(5)
</code></pre>
<p>This will also return 56 on my PC.</p>
<p>If you want to use dictionary:</p>
<pre><code>node_dict = {'left':None, 'right':None, 'val':5}
sys.getsizeof(node_dict)
</code></pre>
<p>this will return 288 on my PC.</p>
<p>There is another option: using namedtuple</p>
<pre><code>from collections import namedtuple
BNode = namedtuple('BNode', ['val','left','right'])
b = BNode(5, None, None)
sys.getsizeof(b)
</code></pre>
<p>this will return 76 on my PC.</p>
<p>According to the code above, I think we should use __slot__ with class to implement your code for considerating memeory limitation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <code>dicts</code> are heavy, memory-wise. A class that doesn't require dynamic attributes can be comparitively light-weight if you take advantages of <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code></a>:</p>
<blockquote>
<p>By default, instances of classes have a dictionary for attribute
  storage. This wastes space for objects having very few instance
  variables. The space consumption can become acute when creating large
  numbers of instances.</p>
<p>The default can be overridden by defining <code>__slots__</code> in a class
  definition. The <code>__slots__</code> declaration takes a sequence of instance
  variables and reserves just enough space in each instance to hold a
  value for each variable. Space is saved because <code>__dict__</code> is not
  created for each instance.</p>
</blockquote>
<p>Consider:</p>
<pre><code>In [1]: class Node(object):
   ...:     __slots__ = ('left', 'right','data')
   ...:     def __init__(self, left, right, data):
   ...:         self.left = left
   ...:         self.right = right
   ...:         self.data = data
   ...:

In [2]: n = Node(None, None, None)

In [3]: d = {}

In [4]: import sys

In [5]: sys.getsizeof(n)
Out[5]: 64

In [6]: sys.getsizeof(d)
Out[6]: 288
</code></pre>
</div>
<span class="comment-copy">@PeterWood If so I'm sorry</span>
<span class="comment-copy">@PeterWood when referring other sites, it is often helpful to point that <a href="https://meta.stackexchange.com/tags/cross-posting/info">cross-posting is frowned upon</a></span>
<span class="comment-copy">To be clear, <code>namedtuple</code> is immutable compared to <code>class</code> and <code>dict</code></span>
<span class="comment-copy">@Peter Wood Thanks for your good complement.</span>
<span class="comment-copy">In the documentation of __slot__ it is described that attributes are stored in a dictionary. But in your first example the Node uses as much memory as the Node in your second example. Does Python there some sort of improvement? Is __slot__ always better than the dictionary solution? If so why is it using the dictionary anyways?</span>
<span class="comment-copy">@matthias-gilch  <a href="https://docs.python.org/3/reference/datamodel.html?highlight=slot#object.__slots__" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a>    The memory efficiency is outstanding when there are a lot of instances. currently, there is only one instance.</span>
<span class="comment-copy">@peter-wood Thanks for your good complement.</span>
