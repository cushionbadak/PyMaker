<div class="post-text" itemprop="text">
<p>I like to work with classes and methods instead of bare functions. I am wondering if there is a specific performance impact to do so (either in execution speed, or memory usage or in other aspects).</p>
<p>A quick test shows that both perform equally well:</p>
<pre><code>import timeit

class Hello:
    def hello(self):
        x = 9 * 8 + 3**5

def world():
    x = 9 * 8 + 3 ** 5

print(timeit.timeit(world, number=10000000))
h = Hello()
print(timeit.timeit(h.hello, number=10000000))
# 0.8460009839758439
# 0.8781686117747095
</code></pre>
<p>In other tests I did not see the RAM being used more in one case than in the other.</p>
<p><strong>Are there specific cases where performance will be degraded when using a class/method instead of a function?</strong></p>
<p>Note: I would like to focus exclusively on code performance, not aesthetical aspects</p>
</div>
<div class="post-text" itemprop="text">
<p>The overhead of method invocation is really just the transformation of the <code>function</code> object to a <code>method</code> object when attribute access (<code>.</code>) on a function attribute it made from an instance. </p>
<p>Apart from that, the calling of the function is similar, with one extra argument (<code>self</code>) inserted implicitly for the method.</p>
<p>So, no, there aren't really any concerns to have here, the overhead is small and can be completely eliminated by assigning the method to a local variable:</p>
<pre><code>meth = h.hello 
# use meth from now on
</code></pre>
<p>(Edit: In Python <code>3.7</code> <a href="http://bugs.python.org/issue26110" rel="nofollow noreferrer">new op-codes</a> where introduced that basically negate the benefit of assigning <code>h.hello</code> to a local name, the look-up for methods just got quite faster :-)</p>
<p>If you're looking for bottlenecks, you should be looking elsewhere. Python's dynamic interpretation really makes these sort of concerns pedantic.</p>
<hr/>
<p>As for the memory aspect, methods should be bit larger than the functions due to a method essentially containing a function as one of its members:</p>
<pre><code>meth.__func__ # original function object
</code></pre>
<p>Despite this, I can't imagine a scenario where your application would choke due to the slight memory overhead methods introduce.</p>
<p>In CPython, for example, approximately 64 bytes are are added for a bound method object according to <code>getsizeof</code>:</p>
<pre><code>&gt;&gt;&gt; getsizeof(Foo().foo)
64
</code></pre>
<p>This isn't counting the <code>__func__</code> attribute, which contains the <code>function</code> objects:</p>
<pre><code>&gt;&gt;&gt; getsizeof(Foo().foo.__func__)
136
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Calling a method <code>obj.method(...)</code> involves attribute access (the <code>obj.method</code> part) which can be a non-trivial and therefore quite costly operation. A brief description of a possible attribute access scenario is found in the <a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">documentation of the descriptor protocol</a>:</p>
<blockquote>
<p>The default behavior for attribute access is to get, set, or delete
  the attribute from an objectâ€™s dictionary. For instance, <code>a.x</code> has a
  lookup chain starting with <code>a.__dict__['x']</code>, then
  <code>type(a).__dict__['x']</code>, and continuing through the base classes of
  <code>type(a)</code> excluding metaclasses.</p>
<p>However, if the looked-up value is an object defining one of the
  descriptor methods, then Python may override the default behavior and
  invoke the descriptor method instead. Where this occurs in the
  precedence chain depends on which descriptor methods were defined and
  how they were called.</p>
</blockquote>
<p>Only after the attribute access is complete, invoking the resultant callable object is little different from calling a free function. Note, however, that in your benchmark the overhead of attribute access, i.e. the operations behind the seemingly innocuous expression <code>h.hello</code>, is not measured (though in your example it should be quite small).</p>
</div>
<span class="comment-copy">Try wrapping those in a lambda and testing again.</span>
