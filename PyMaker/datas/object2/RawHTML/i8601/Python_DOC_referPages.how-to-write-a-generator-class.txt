<div class="post-text" itemprop="text">
<p>I see lot of examples of generator functions, but I want to know how to write generators for classes. Lets say, I wanted to write Fibonacci series as a class. </p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1

    def __next__(self):
        yield self.a
        self.a, self.b = self.b, self.a+self.b

f = Fib()

for i in range(3):
    print(next(f))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>&lt;generator object __next__ at 0x000000000A3E4F68&gt;
&lt;generator object __next__ at 0x000000000A3E4F68&gt;
&lt;generator object __next__ at 0x000000000A3E4F68&gt;
</code></pre>
<p>Why is the value <code>self.a</code> not getting printed?  Also, how do I write <code>unittest</code> for generators?   </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>How to write a generator class?</h1>
</blockquote>
<p>You're almost there, writing an <em>Iterator</em> class (I show a Generator at the end of the answer), but <code>__next__</code> gets called every time you call the object with <code>next</code>, returning a generator object. Instead, use <code>__iter__</code>:</p>
<pre><code>&gt;&gt;&gt; class Fib:
...     def __init__(self):
...         self.a, self.b = 0, 1
...     def __iter__(self):
...         while True:
...             yield self.a
...             self.a, self.b = self.b, self.a+self.b
...
&gt;&gt;&gt; f = iter(Fib())
&gt;&gt;&gt; for i in range(3):
...     print(next(f))
...
0
1
1
</code></pre>
<p>To make the class itself an iterator:</p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1        
    def __next__(self):
        return_value = self.a
        self.a, self.b = self.b, self.a+self.b
        return return_value
    def __iter__(self):
        return self
</code></pre>
<p>And now:</p>
<pre><code>&gt;&gt;&gt; f = iter(Fib())
&gt;&gt;&gt; for i in range(3):
...     print(next(f))
...
0
1
1
</code></pre>
<blockquote>
<h2>Why is the value self.a not getting printed?</h2>
</blockquote>
<p>Here's your original code with my comments:</p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1

    def __next__(self):
        yield self.a          # yield makes .__next__() return a generator!
        self.a, self.b = self.b, self.a+self.b

f = Fib()

for i in range(3):
    print(next(f))
</code></pre>
<p>So every time you called <code>next(f)</code> you got the generator object that <code>__next__</code> returns:</p>
<pre class="lang-none prettyprint-override"><code>&lt;generator object __next__ at 0x000000000A3E4F68&gt;
&lt;generator object __next__ at 0x000000000A3E4F68&gt;
&lt;generator object __next__ at 0x000000000A3E4F68&gt;
</code></pre>
<blockquote>
<h2>Also, how do I write unittest for generators?</h2>
</blockquote>
<p>You still need to implement a send and throw method for a <code>Generator</code></p>
<pre><code>from collections import Iterator, Generator
import unittest

class Test(unittest.TestCase):
    def test_Fib(self):
        f = Fib()
        self.assertEqual(next(f), 0)
        self.assertEqual(next(f), 1)
        self.assertEqual(next(f), 1)
        self.assertEqual(next(f), 2) #etc...
    def test_Fib_is_iterator(self):
        f = Fib()
        self.assertIsInstance(f, Iterator)
    def test_Fib_is_generator(self):
        f = Fib()
        self.assertIsInstance(f, Generator)
</code></pre>
<p>And now:    </p>
<pre><code>&gt;&gt;&gt; unittest.main(exit=False)
..F
======================================================================
FAIL: test_Fib_is_generator (__main__.Test)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 7, in test_Fib_is_generator
AssertionError: &lt;__main__.Fib object at 0x00000000031A6320&gt; is not an instance of &lt;class 'collections.abc.Generator'&gt;

----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)
&lt;unittest.main.TestProgram object at 0x0000000002CAC780&gt;
</code></pre>
<p>So let's implement a generator object, and leverage the <code>Generator</code> abstract base class from the collections module (see the source for its <a href="https://github.com/python/cpython/blob/d5d3249e8a37936d32266fa06ac20017307a1f70/Lib/_collections_abc.py#L309" rel="noreferrer">implementation</a>), which means we only need to implement <code>send</code> and <code>throw</code> - giving us <code>close</code>, <code>__iter__</code> (returns self), and <code>__next__</code> (same as <code>.send(None)</code>) for free (see the <a href="https://docs.python.org/3/reference/datamodel.html#coroutine-objects" rel="noreferrer">Python data model on coroutines</a>):</p>
<pre><code>class Fib(Generator):
    def __init__(self):
        self.a, self.b = 0, 1        
    def send(self, ignored_arg):
        return_value = self.a
        self.a, self.b = self.b, self.a+self.b
        return return_value
    def throw(self, type=None, value=None, traceback=None):
        raise StopIteration
</code></pre>
<p>and using the same tests above:</p>
<pre><code>&gt;&gt;&gt; unittest.main(exit=False)
...
----------------------------------------------------------------------
Ran 3 tests in 0.002s

OK
&lt;unittest.main.TestProgram object at 0x00000000031F7CC0&gt;
</code></pre>
<h2>Python 2</h2>
<p>The ABC <code>Generator</code> is only in Python 3. To do this without <code>Generator</code>, we need to write at least <code>close</code>, <code>__iter__</code>, and <code>__next__</code> in addition to the methods we defined above.</p>
<pre><code>class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1        
    def send(self, ignored_arg):
        return_value = self.a
        self.a, self.b = self.b, self.a+self.b
        return return_value
    def throw(self, type=None, value=None, traceback=None):
        raise StopIteration
    def __iter__(self):
        return self
    def next(self):
        return self.send(None)
    def close(self):
        """Raise GeneratorExit inside generator.
        """
        try:
            self.throw(GeneratorExit)
        except (GeneratorExit, StopIteration):
            pass
        else:
            raise RuntimeError("generator ignored GeneratorExit")
</code></pre>
<p>Note that I copied <code>close</code> directly from the Python 3 <a href="https://github.com/python/cpython/blob/3.6/Lib/_collections_abc.py" rel="noreferrer">standard library</a>, without modification. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>__next__</code> should <em>return</em> an item, not yield it. </p>
<p>You can either write the following, in which <code>Fib.__iter__</code> returns a suitable iterator:</p>
<pre><code>class Fib:
    def __init__(self, n):
        self.n = n
        self.a, self.b = 0, 1

    def __iter__(self):
        for i in range(self.n):
            yield self.a
            self.a, self.b = self.b, self.a+self.b

f = Fib(10)

for i in f:
    print i
</code></pre>
<p>or make each instance itself an iterator by defining <code>__next__</code>.</p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        x = self.a
        self.a, self.b = self.b, self.a + self.b
        return x

f = Fib()

for i in range(10):
    print next(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do not use <code>yield</code> in <code>__next__</code> function and implement <code>next</code> also for compatibility with python2.7+</p>
<p><strong>Code</strong></p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1
    def __next__(self):
        a = self.a
        self.a, self.b = self.b, self.a+self.b
        return a
    def next(self):
        return self.__next__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you give the class an <code>__iter__()</code> method <a href="https://docs.python.org/3/library/stdtypes.html#generator-types" rel="nofollow noreferrer">implemented as a generator</a>, it will automatically return a generator object when called, so <em>that</em> object's <code>__iter__</code> and <code>__next__</code> methods will be the ones used.</p>
<p>Here's what I mean:</p>
<pre><code>class Fib:
    def __init__(self):
        self.a, self.b = 0, 1

    def __iter__(self):
        while True:
            value, self.a, self.b = self.a, self.b, self.a+self.b
            yield value

f = Fib()

for i, value in enumerate(f, 1):
    print(value)
    if i &gt; 5:
        break
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>0
1
1
2
3
5
</code></pre>
</div>
<span class="comment-copy">Hi Aaron, thank you so much for your response, this is exactly what I was looking for. What is the best way to learn more about iterators and generators ?</span>
<span class="comment-copy">@Pritam I expand a lot on that subject in this answer here: <a href="http://stackoverflow.com/a/31042491/541136">stackoverflow.com/a/31042491/541136</a></span>
<span class="comment-copy">This makes it an iterable, not a generator</span>
<span class="comment-copy">@Brian: Better?</span>
<span class="comment-copy">Yes this makes it a proper generator class</span>
