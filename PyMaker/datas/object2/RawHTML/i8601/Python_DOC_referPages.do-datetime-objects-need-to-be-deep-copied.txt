<div class="post-text" itemprop="text">
<p>So I noticed the other week through running an experiment, that, despite being a high-level language, while you can make copies of variables by just assigning them like this:</p>
<pre><code>a = 5    
b = a
print(b) # 5
b = 3
print(b) # 3
print(a) # 5
</code></pre>
<p>...if you treat dictionaries or possibly lists the same way, it comes unstuck! I created a bug in my code the other week thinking that dictionaries worked the same way.. Found out that to make a proper, deep copy you need to go: </p>
<pre><code>b = dict(a)
</code></pre>
<p>Anyway, I'm busy with datetime objects and I'm manipulating them around as if they were integers, now starting to get a bit nervous as to whether this is okay. It all seems a bit arbitrary where it works and where it doesn't, do I have to run an experiment every time just to check its behaviour? Can guess that strings probably work like integers but not sure where the behaviour changes.</p>
<p>Can see someone <a href="https://stackoverflow.com/questions/2579458/how-do-i-deep-copy-a-datetime-object">has asked about</a> this for PHP but for Python I'm inclined to think that any assignment of a datetime object would be a proper, deep copy and never mess accidentally with the original variable. Does anyone know for sure?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Since all <a href="https://docs.python.org/3/library/datetime.html#available-types" rel="noreferrer">available types in the <code>datetime</code> module</a> are documented as being <em>immutable</em> (right after the documentation of the classes it is stated):</p>
<blockquote>
<p>Objects of these types <strong>are immutable.</strong></p>
</blockquote>
<p>you shouldn't worry about this. </p>
<p>Operations on a datetime instance will return a new instance thereby not affecting any other names that refer to the previous one.</p>
<p>You might want to take a look at the link provided by PM 2Ring that explains <a href="https://nedbatchelder.com/text/names.html" rel="noreferrer">facts and myths about how names and values work</a>. That should shed some light on any confusions you have about names.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is nothing arbitrary about this.</p>
<p>All assignments in Python are references. No copying is ever done on assignment.</p>
<p>If you have the ability to mutate the object then any mutation will naturally affect all the references to that object.</p>
<p>The only reason you don't see this with integers or strings in your original code is that you're not mutating the objects, you're simply reassigning. Integers and strings, as well as datetimes, don't have any way of being mutated, so the only thing you can do is reassign them. If you reassigned a list, dict, or datetime, then you would not see the change propagated to other references, either. </p>
</div>
<span class="comment-copy">You may find this helpful: <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Other languages have "variables", Python has "names"</a>. For a more in-depth treatment of this important topic please see <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder.</span>
<span class="comment-copy">BTW, <code>b = dict(a)</code> is a shallow copy, you could also do <code>b = a.copy()</code>. <code>b = a</code> isn't copying, it's just binding the name <code>b</code> to the dict object that also happens to be bound to the name <code>a</code>. If the items in (the dict object bound to) <code>a</code> are immutable, a shallow copy is sufficient, but if they aren't you may need a deep copy, which you can do using the <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer"><code>deepcopy</code></a> function from the standard <code>copy</code> module.</span>
<span class="comment-copy">@PM2Ring if <code>b = dict(a)</code> is only a shallow copy equivalent to <code>b = a.copy()</code>, then not sure why one would ever need <code>b = copy.deepcopy(a)</code> Anyway, will get on with my datetime stuff for now, might need it one day. Thanks for the links, yes, variables vs names.</span>
<span class="comment-copy">@cardamom Try the following: <code>a = {1:'hi', 'u':[0,2]}</code> <code>b = dict(a)</code> <code>b['u'].append(77)</code> <code>c = copy.deepcopy(b)</code> <code>c['u'].append('oo')</code> <code>print(a, b, c)</code>. Result: <code>{1: 'hi', 'u': [0, 2, 77]} {1: 'hi', 'u': [0, 2, 77]} {1: 'hi', 'u': [0, 2, 77, 'oo']}</code></span>
<span class="comment-copy">@LucaCiti I just did - this proves that <code>b = dict(a)</code> was not enough to deep copy it, maybe that was halfway between deep and shallow. Needed to <code>import copy</code> to run that, but looks like that's the proper way to do it.</span>
<span class="comment-copy">Yes, you're right those magic 5 words are on the Python 3 docs page, I would not normally have looked for them or noticed them, but am now seeing why it matters - with this assignment vs deep copy thing.</span>
<span class="comment-copy">PS - went with this answer, although others were also very useful as was the most concise and reassuring.</span>
<span class="comment-copy">@cardamom thanks, I'd suggest you take a quick peek at the links PM 2Ring provided in the comments, they're illuminating on this subject</span>
<span class="comment-copy">Ok so only ints, floats, strings, bools can be treated with simple assigning? EVERYTHING else needs something more. Then to deep copy a dict you go <code>b = dict(a)</code> what do you do with datetime, <code>b=datetime(a)</code> ? There is also this function deepcopy. <code>from copy import deepcopy</code> just not sure if I should use it or not..</span>
<span class="comment-copy">No, you're not understanding what I said. There's no way to mutate a datetime, so there's no possibility of changing it - so no need to make a copy. My point is that reassigning is different from mutating, but that reassignment works in exactly the same way for all objects. There is nothing "more" involved.</span>
<span class="comment-copy">Oh! <i>Integers and strings, as well as datetimes, don't have any way of being mutated</i>  Not sure about this word "mutated" if you go <code>datetime + relativedelta(days=1)</code> what are you doing to it, you seem to be saying it's more like 3+5 than <code>{k1:v1, k2:v2}.update({k3:v3})</code></span>
<span class="comment-copy">@cardamom Please take a look at those links I posted in my 1st comment on your question. The Ned Batchelder link has a good explanation of mutable vs immutable. You really need to understand that to get a good grasp of how Python works.</span>
<span class="comment-copy">Absolutely correct. That returns a new datetime, rather than modifying the existing one; the new datetime won't have any other references but any other references will continue to point to the old one.</span>
