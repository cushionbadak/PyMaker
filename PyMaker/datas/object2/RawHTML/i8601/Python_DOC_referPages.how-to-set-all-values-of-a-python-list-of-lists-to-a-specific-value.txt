<div class="post-text" itemprop="text">
<p>Is it possible to set all values in a Python list of lists to 0 without iterating through the lists and values one by one? </p>
<p>I have a list of lists <code>[[0, 2, 4, 5], [0, 2, 4, 5]]</code> which I would like to change to <code>[[0, 0, 0, 0], [0, 0, 0, 0]]</code>. Is there a way to achieve this without looping through all the values and would that lead to performance improvements? What would be the fastest method to achieve this since this piece of code will be executed a large number of times? </p>
<p>It also does not matter whether the lists are modified in place or replaced altogether. The length of the outer list would be quite large while the length of the inner list would be small.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no way to avoid looping, because lists have an arbitrary size. You also want to avoid ending up with a shared single nested list, so multiplication of the outer list is out.</p>
<p>The following is reasonably efficient and produces a sane result:</p>
<pre><code>[[0] * len(inner) for inner in outer]
</code></pre>
<p>This'll produce the right result for any length of <code>outer</code>, and even if the lengths of the nested lists vary.</p>
<p>This is also the fastest method across different scenarios, as the following time trials show. First a setup to test with:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; import random
&gt;&gt;&gt; short_fixed = [[random.randint(0, 10) for _ in range(5)] for _ in range(10)]
&gt;&gt;&gt; long_fixed = [[random.randint(0, 10) for _ in range(5)] for _ in range(1000000)]
&gt;&gt;&gt; short_ranging = [[random.randint(0, 10) for _ in range(random.randrange(25))] for _ in range(10)]
&gt;&gt;&gt; long_ranging = [[random.randint(0, 10) for _ in range(random.randrange(25))] for _ in range(1000000)]
</code></pre>
<p>I'm testing with the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> on Python 3.6.1rc1, on a MacBook Pro (Retina, 15-inch, Mid 2015) running OS X 10.12.3</p>
<p>Then each scenario. Short fixed is a list of 10 nested lists each 5 elements long. The test times are the total for 1 million repetitions:</p>
<pre><code>&gt;&gt;&gt; timeit('list(map(lambda x:[0]*len(x),l))', 'from __main__ import short_fixed as l')
3.2795075319882017
&gt;&gt;&gt; timeit('list(map(lambda x: list(repeat(0, len(x))), l))', 'from __main__ import short_fixed as l; from itertools import repeat')
6.128518687008182
&gt;&gt;&gt; timeit('[[0] * len(inner) for inner in l]', 'from __main__ import short_fixed as l')
2.254983870021533
</code></pre>
<p>Long fixed tests 1 million elements, 10 repetitions to keep waiting manageable:</p>
<pre><code>&gt;&gt;&gt; timeit('list(map(lambda x:[0]*len(x),l))', 'from __main__ import long_fixed as l', number=10)
3.955955935991369
&gt;&gt;&gt; timeit('list(map(lambda x: list(repeat(0, len(x))), l))', 'from __main__ import long_fixed as l; from itertools import repeat', number=10)
6.772360901988577
&gt;&gt;&gt; timeit('[[0] * len(inner) for inner in l]', 'from __main__ import long_fixed as l', number=10)
3.302304288983578
</code></pre>
<p>Varying list sizes are between 0 and 25 elements long. Short lists:</p>
<pre><code>&gt;&gt;&gt; timeit('list(map(lambda x:[0]*len(x),l))', 'from __main__ import short_ranging as l')
3.155180420988472
&gt;&gt;&gt; timeit('list(map(lambda x: list(repeat(0, len(x))), l))', 'from __main__ import short_ranging as l; from itertools import repeat')
6.213294043001952
&gt;&gt;&gt; timeit('[[0] * len(inner) for inner in l]', 'from __main__ import short_ranging as l')
2.3255828430119436
</code></pre>
<p>and finally 1 million ranging lists:</p>
<pre><code>&gt;&gt;&gt; timeit('list(map(lambda x: list(repeat(0, len(x))), l))', 'from __main__ import long_ranging as l; from itertools import repeat', number=10)
8.005676712986315
&gt;&gt;&gt; timeit('list(map(lambda x: list(repeat(0, len(l[0]))), l))', 'from __main__ import long_ranging as l; from itertools import repeat', number=10)
8.49916388199199
&gt;&gt;&gt; timeit('[[0] * len(inner) for inner in l]', 'from __main__ import long_ranging as l', number=10)
3.8087494230130687
</code></pre>
<p>In all scenarios the explicit loop is <em>faster</em> (up to a factor of 2), because it doesn't have to use lambda functions.</p>
<p>If you are prepared to switch to numpy arrays, then that option blows everything out of the water, easily. Broadcasting a multiplication by 0 across all (native) values in an array moves all iteration to C without a need to call functions or execute Python bytecode at all:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; short_fixed_np = numpy.array(short_fixed)
&gt;&gt;&gt; long_fixed_np = numpy.array(long_fixed)
&gt;&gt;&gt; short_ranging_np = numpy.array(short_ranging)
&gt;&gt;&gt; long_ranging_np = numpy.array(long_ranging)
&gt;&gt;&gt; timeit('l = next(copies); l *= 0', 'from __main__ import short_fixed_np as arr, numpy; copies = iter([numpy.copy(arr) for _ in range(10**6)])')
0.8011195910221431
&gt;&gt;&gt; timeit('l = next(copies); l *= 0', 'from __main__ import long_fixed_np as arr, numpy; copies = iter([numpy.copy(arr) for _ in range(10)])', number=10)
0.04912398199667223
</code></pre>
<p>(Because this approach alters objects in-place you need to create enough copies for each individual repeated test to alter a unique array, hence the whole <code>next(copies)</code> dance).</p>
<p>To use numpy arrays to their full strength also means that you can only realistically use them for fixed-length sublists. For variable-length sublists you have to use single-dimension arrays of type object (meaning that they only are used to reference Python lists), at which point you can no longer broadcast the multiplication to all numeric elements anymore either.</p>
<p>Take into account that you'd have to retool your whole project to take advantage of numpy arrays in that case. If you need to access individual values from such an array a lot, then take into account that that'll be <em>slower</em> as accessing individual values requires boxing the C native value in a Python object each time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without explicitly looping, here is a functional approach using <code>itertools.repeat()</code> and <code>map()</code>:</p>
<pre><code>In [6]: lst = list(map(lambda x: list(repeat(0, len(x))), lst))
Out[6]: [[0, 0, 0, 0], [0, 0, 0, 0]]
</code></pre>
<p>Or if your sub-lists are all in same length you can just use two <code>repeat()</code>:</p>
<pre><code>In [24]: lst = list(repeat(list(repeat(0, len(lst[0]))), len(lst)))
Out[24]: [[0, 0, 0, 0], [0, 0, 0, 0]]
</code></pre>
<p>Note that this methods are using loops for creating the repeated objects and converting the generators to lists. This means that there is no way to create separate objects like this without a loop. </p>
<p>Another way to change the items in-place is using Numpy. You can do this with a simply multiplying with 0:</p>
<pre><code>In [18]: import numpy as np

In [19]: lst = np.array(lst)

In [21]: lst *= 0

In [22]: lst
Out[22]: 
array([[0, 0, 0, 0],
       [0, 0, 0, 0]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know,it's impossible to avoid looping, but you said <em>explicitly looping</em>  I suppose you want a way without <code>for</code> loop.</p>
<p>So you can try this:</p>
<pre><code>print map(lambda x:[0]*len(x),l)
</code></pre>
<p>Python 3.x,it should be:</p>
<pre><code>print (list(map(lambda x:[0]*len(x),l)))
</code></pre>
<p><a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer">Map</a>:</p>
<blockquote>
<p>Apply function to every item of iterable and return a list of the
  results.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You can update your list with the following approach (no explicit for-loops):</p>
<pre><code>list_of_lists = [[0] * 4] * 2
</code></pre>
<p>Let's try it:</p>
<pre><code>&gt;&gt;&gt; [[0] * 4] *2 
[[0, 0, 0, 0], [0, 0, 0, 0]]
</code></pre>
</div>
<span class="comment-copy">Will it always be 2 lists, each of 4 elements?</span>
<span class="comment-copy">If your lists were numpy arrays, you could do <code>yourlist = np.zeros_like(yourlist)</code>, but that doesn't answer the question asked, unless you want to include the overhead of creating the numpy array and making a list out of it at the end.</span>
<span class="comment-copy">@PeterWood No, the above is just an example</span>
<span class="comment-copy">@KaustabhaRay: then say <i>that</i>. Can you <a href="https://stackoverflow.com/posts/42898185/edit">edit</a> your question to a) mention that it doesn't matter if the list is altered in-place or replaced altogether and b) that you want to find the fastest method for this. Then we know to time trial results, not spar over what method allows you not to loop.</span>
<span class="comment-copy">@KaustabhaRay: also, can you give us an indication how large the lists are going to get (ball-park figures for the inner and outer lists). Some methods might be faster for short lists while losing ground rapidly for larger.</span>
<span class="comment-copy">I'm pretty sure the numpy solution fails if the inner lists do not have the same length (like my suggestion with <code>zero_like</code> also does). The problem is that <code>np.array</code> only creates an array of lists (dtype=object), if the inner lists' length are not equal, and <code>list*0 = []</code>. That means that <code>short_fixed</code> and <code>long_fixed</code> are ok, but <code>short_ranging</code> and 'long_ranging` are meaningless.</span>
<span class="comment-copy">@StefanS: Ah, indeed. I'll adjust, using numpy arrays for anything but fixed lists is useless.</span>
<span class="comment-copy">Which still uses looping, but those loops are executed by the <code>list</code> implementation. With the need for a <code>lambda</code>, you also pay a frame push performance hit for every function call made.</span>
<span class="comment-copy">@MartijnPieters Absolutely, this is just <i>Without explicitly looping</i> as OP requested.</span>
<span class="comment-copy">This doesn't modify the original list</span>
<span class="comment-copy">Your <code>numpy</code> solution wouldn't work (<i>would return empty lists</i>) if any of the inner lists do not match in length. It so happened to be favorable for the given sample.</span>
<span class="comment-copy">@DavidArenburg: done, as expected numpy is much faster. As long as in-place changes are fine, as well as retooling the rest of the project to use numpy arrays, that's obviously the better option.</span>
<span class="comment-copy">This is Python 2 specific; <code>map()</code> does the looping here. The <code>lambda</code> call slows things down as a new frame object has to be created and pushed to the stack for each iteration. For Python 3, you'd have to add a <code>list()</code> call.</span>
<span class="comment-copy">@MartijnPieters Sure,I think it's impossible to avoid looping,so I think maybe the OP just want a way without using <code>for</code> loop,I will update this.</span>
<span class="comment-copy">As it turns out, this is only marginally faster than Kasra's solution, but not by much. The function calls kill performance here.</span>
<span class="comment-copy">Are the <code>* 2</code> lists the same list?</span>
<span class="comment-copy">What do you mean by 'the same'? It will produce [[0,0,0,0],[0,0,0,0]].</span>
<span class="comment-copy">Yes, but if you then modify one sub-list will it modify both? i.e. if <code>A = [0, 0, 0, 0]</code> do you now have <code>[A, A]</code>?</span>
<span class="comment-copy">@CaptainTrunky: yes, and it'll produce two <b>references</b> to one <i>shared</i> list object. Try setting <code>result[0][0] = 1</code>.</span>
<span class="comment-copy">Ah, yes, that's true.</span>
