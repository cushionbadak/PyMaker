<div class="post-text" itemprop="text">
<p>I need a way to find all combinations from two different lists where each element may or may not be null. For example with the two lists I'd like to call a function that returns a list of all these combinations:</p>
<pre><code>a = ['A', 'S', 'B']
b = ['A', 'B']
find_combinations(a, b)
</code></pre>
<p>Should return:</p>
<pre><code>[['A', 'S', 'B'], ['A', 'S'], ['S', 'B'], ['S']]
</code></pre>
<p>I can do this trivial example but if the list is more complicated say <code>['A', 'B', 'S', 'A', 'A']</code> then the possible options are much more complicated:</p>
<pre><code>[['A', 'B', 'S', 'A', 'A'],
 ['A', 'B', 'S', 'A'],
 ['A', 'B', 'S', 'A'],
 ['B', 'S', 'A', 'A']
  ... etc.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will assume the <strong>elements of <code>b</code> are hashable</strong>. In that case you can use the following code:</p>
<pre><code>def without(a,i,bi,l):
    if i &gt;= len(a):
        yield tuple(l)
    else:
        l.append(a[i])
        for result in without(a,i+1,bi,l):
            yield result
        l.pop()
        if a[i] in bi:
            for result in without(a,i+1,bi,l):
                yield result

def find_combinations(a, b):
    for result in without(a,0,set(b),[]):
        yield result
</code></pre>
<p>Here we first convert the <code>b</code> into a set to boost performance. This is strictly speaking not necessary. Then we use a recursive algorithm where for each element <code>a[i]</code> in <code>a</code> that is in <code>b</code>, we have a decision point whether to or not to include it in the result (that's why we perform the recursion again when that element is popped). When we reach the end of the list, we convert our <em>running list <code>l</code></em> into a <code>tuple(..)</code>. You can also use <code>list(..)</code> to convert it into a list.</p>
<p>We use a running list to boost performance a bit since concatenating two lists is done in <em>O(n)</em> whereas the running list can <code>append(..)</code> and <code>pop(..)</code> in <em>O(1)</em> amortized cost.</p>
<p>This will produce a <strong>generator of <code>tuple</code>s</strong>. You can materialize the outcome of each generator with <code>list(..)</code> like:</p>
<pre><code>&gt;&gt;&gt; list(find_combinations(['A','S','B'],['A','B']))
[('A', 'S', 'B'), ('A', 'S'), ('S', 'B'), ('S',)]
&gt;&gt;&gt; list(find_combinations(['A', 'B', 'S', 'A', 'A'],['A','B']))
[('A', 'B', 'S', 'A', 'A'), ('A', 'B', 'S', 'A'), ('A', 'B', 'S', 'A'), ('A', 'B', 'S'), ('A', 'S', 'A', 'A'), ('A', 'S', 'A'), ('A', 'S', 'A'), ('A', 'S'), ('B', 'S', 'A', 'A'), ('B', 'S', 'A'), ('B', 'S', 'A'), ('B', 'S'), ('S', 'A', 'A'), ('S', 'A'), ('S', 'A'), ('S',)]
</code></pre>
<p>In case <code>list</code>s are required, you can use <code>map(list,..)</code> to convert them to lists, like:</p>
<pre><code>&gt;&gt;&gt; list(map(list,find_combinations(['A','S','B'],['A','B'])))
[['A', 'S', 'B'], ['A', 'S'], ['S', 'B'], ['S']]
&gt;&gt;&gt; list(map(list,find_combinations(['A', 'B', 'S', 'A', 'A'],['A','B'])))
[['A', 'B', 'S', 'A', 'A'], ['A', 'B', 'S', 'A'], ['A', 'B', 'S', 'A'], ['A', 'B', 'S'], ['A', 'S', 'A', 'A'], ['A', 'S', 'A'], ['A', 'S', 'A'], ['A', 'S'], ['B', 'S', 'A', 'A'], ['B', 'S', 'A'], ['B', 'S', 'A'], ['B', 'S'], ['S', 'A', 'A'], ['S', 'A'], ['S', 'A'], ['S']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After playing around I found an alternative way to Willem Van Onsem's answer. Not quite as clean but also works.</p>
<pre><code>def empty_derivations(rule, empty_list):
    returned = []
    returned.append(rule)
    for element in returned:
        for num, char in enumerate(element):
            temp = element[:]
            if char in empty_list:
                del temp[num]
                returned.append(temp)
    return_list = []
    for element in returned:
        if element not in return_list:
            return_list.append(element)
    return return_list
</code></pre>
<p>When called gives:</p>
<pre><code>&gt;&gt;&gt; a = empty_derivations(['A', 'B', 'S', 'A', 'A'], ['A', 'B'])
&gt;&gt;&gt; print(a)
[['A', 'B', 'S', 'A', 'A'], 
['B', 'S', 'A', 'A'], 
['A', 'S', 'A', 'A'], 
['A', 'B', 'S', 'A'], 
['S', 'A', 'A'], 
['B', 'S', 'A'], 
['A', 'S', 'A'], 
['A', 'B', 'S'], 
['S', 'A'], 
['B', 'S'], 
['A', 'S'], 
['S']]
</code></pre>
</div>
<span class="comment-copy">It's not clear to me what the logic from input to output is, but I suggest you look into <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>.</span>
<span class="comment-copy">So you want to iterate over combinations of <code>b</code> and remove theses from <code>a</code>?</span>
<span class="comment-copy">Say <code>a = ['A','A']</code> and <code>b = ['A']</code>. Is <code>[]</code> a valid result: can it result in deleting the element <i>multiple</i> times? Furthermore shoud <code>b</code> be ordered the same way as <code>a</code>? What happens if <code>a = ['A','S','B']</code> and <code>b = ['B',A']</code>?</span>
<span class="comment-copy">Shouldn't the first example also output <code>['A']</code> and <code>['B']</code></span>
<span class="comment-copy">@JuanT: based on the title and how I understand it, one generates the combinations for <code>b</code> and <i>removes</i> these from <code>a</code>...</span>
<span class="comment-copy">Great! Works perfectly on some test data I have. +1</span>
