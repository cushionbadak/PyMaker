<div class="post-text" itemprop="text">
<p>I have a lists of floats with some hidden "level" information encoded in the scale of the float, and I can split the "levels" of floats as such:</p>
<pre><code>import math
import numpy as np

all_scores = [1.0369411057174144e+22, 2.7997409854370188e+23, 1.296176382146768e+23,
6.7401171871631936e+22, 6.7401171871631936e+22, 2.022035156148958e+24, 8.65845823274041e+23,
1.6435516525621017e+24, 2.307193960221247e+24, 1.285806971089594e+24, 9603539.08653573,
17489013.841076534, 11806185.6660164, 16057293.564414097, 8546268.728385007, 53788629.47091801,
31828243.07349571, 51740168.15200098, 53788629.47091801, 22334836.315934014,
4354.0, 7474.0, 4354.0, 4030.0, 6859.0, 8635.0, 7474.0, 8635.0, 9623.0, 8479.0]

easy, med, hard = [], [], []

for i in all_scores:
    if i &gt; math.exp(50):
        easy.append(i)
    elif i &gt; math.exp(10):
        med.append(i)
    else:
        hard.append(i)

print ([easy, med, hard])
</code></pre>
<p>[out]:</p>
<pre><code>[[1.0369411057174144e+22, 2.7997409854370188e+23, 1.296176382146768e+23, 6.7401171871631936e+22, 6.7401171871631936e+22, 2.022035156148958e+24, 8.65845823274041e+23, 1.6435516525621017e+24, 2.307193960221247e+24, 1.285806971089594e+24], [9603539.08653573, 17489013.841076534, 11806185.6660164, 16057293.564414097, 8546268.728385007, 53788629.47091801, 31828243.07349571, 51740168.15200098, 53788629.47091801, 22334836.315934014], [4354.0, 7474.0, 4354.0, 4030.0, 6859.0, 8635.0, 7474.0, 8635.0, 9623.0, 8479.0]]
</code></pre>
<p>And I have another list that will correspond to the <code>all_scores</code> list:</p>
<pre><code>input_scores = [0.0, 2.7997409854370188e+23, 0.0, 6.7401171871631936e+22, 0.0, 0.0, 8.6584582327404103e+23, 0.0, 2.3071939602212471e+24, 0.0, 0.0, 17489013.841076534, 11806185.6660164, 0.0, 8546268.728385007, 0.0, 31828243.073495708, 51740168.152000979, 0.0, 22334836.315934014, 4354.0, 7474.0, 4354.0, 4030.0, 0.0, 8635.0, 0.0, 0.0, 0.0, 8479.0]
</code></pre>
<p>I need to check how many of the easy, med and hard matches the all scores, I could do this to get the boolean of whether there's a match on the flatten <code>all_scores</code> list as such:</p>
<pre><code>matches = [i == j for i, j in zip(input_scores, all_scores)]
print ([i == j for i, j in zip(input_scores, all_scores)])
</code></pre>
<p>[out]:</p>
<pre><code>[False, True, False, True, False, False, True, False, True, False, False, True, True, False, True, False, True, True, False, True, True, True, True, True, False, True, False, False, False, True]
</code></pre>
<p><strong>Is there a way to know how many easy/med/hard there are in the matches and the sum of the matches per level?</strong></p>
<p>I have tried this and it works:</p>
<pre><code>matches = [int(i == j) for i, j in zip(input_scores, all_scores)]

print(sum(matches[:len(easy)]) , len(easy), sum(np.array(easy) * matches[:len(easy)]) )
print(sum(matches[len(easy):len(easy)+len(med)]), len(med), sum(np.array(med) * matches[len(easy):len(easy)+len(med)]) )
print (sum(matches[len(easy)+len(med):]) , len(hard), sum(np.array(hard) * matches[len(easy)+len(med):]) )
</code></pre>
<p>[out]:</p>
<pre><code>4 10 3.52041505391e+24
6 10 143744715.777
6 10 37326.0
</code></pre>
<p>But there must be a less verbose way to achieve the same output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a numpy solution using <code>digitize</code> to create the categories and <code>bincount</code> to count and sum the matches. As a free bonus these stats are also created for the left-overs.</p>
<pre><code>categories = 'hard', 'med', 'easy'

# get group membership by splitting at e^10 and e^50
# the 'right' keyword tells digitize to include right boundaries
cat_map = np.digitize(all_scores, np.exp((10, 50)), right=True)
# cat_map has a zero in all the 'hard' places of all_scores
# a one in the 'med' places and a two in the 'easy' places

# add a fourth group to mark all non-matches
# we have to force at least one np.array for element-by-element
# comparison to work
cat_map[np.asanyarray(all_scores) != input_scores] = 3

# count
numbers = np.bincount(cat_map)
# count again, this time using all_scores as weights
sums = np.bincount(cat_map, all_scores)

# print
for c, n, s in zip(categories + ('unmatched',), numbers, sums):
    print('{:12}  {:2d}  {:6.4g}'.format(c, n, s))

# output:
#
# hard           6  3.733e+04
# med            6  1.437e+08
# easy           4  3.52e+24
# unmatched     14  5.159e+24
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sounds to me like a job for... <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter!</a></p>
<p>If you haven't come across it yet, <code>Counter</code> is like dict, but instead of new values replacing old values in methods like <code>.update()</code> they just get added onto them. So:</p>
<pre><code>from collections import Counter

counter = Counter({'a': 2})
counter.update({'a': 3})
counter['a']
&gt; 5
</code></pre>
<p>So you get your result above with the following code:</p>
<pre><code>from collections import Counter

matches, counts, scores = [
    Counter({'easy': 0, 'med': 0, 'hard': 0}) for _ in range(3)
]

for score, inp in zip(all_scores, input_scores):
    category = (
        'easy' if score &gt; math.exp(50) else
        'med' if score &gt; math.exp(10) else
        'hard'
    )
    matches.update({category: score == inp})
    counts.update({category: 1})
    scores.update({category: score if score == inp else 0})

for cat in ('easy', 'med', 'hard'):
    print(matches[cat], counts[cat], scores[cat])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can work around with <code>dict</code> :</p>
<pre><code>k = ('easy', 'meduim', 'hard')    
param = dict.fromkeys(k,0) ; outlist = []
for index,i in enumerate(range(0, len(matches), 10)):
    count = {k[index]:sum(matches[i:i + 10])}
    outlist.append(count)

print(outlist)
[{'easy': 4}, {'meduim': 6}, {'hard': 6}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a series of dicts as lookup tables:</p>
<pre class="lang-python prettyprint-override"><code>scores = defaultdict(list)  # Keeps track of which numbers belong to categories
values = defaultdict(int)  # Keeps count of the number seen
for i in all_scores:
    if i &gt; math.exp(50):
        values["easy"] += 1
        scores[i] = "easy"
    elif i &gt; math.exp(10):
        values["medium"] += 1
        scores[i] = "medium"
    else:
        values["hard"] += 1
        scores[i] = "hard"

input_scores = [0.0, 2.7997409854370188e+23, 0.0, 6.7401171871631936e+22, 0.0, 0.0, 8.6584582327404103e+23, 0.0, 2.3071939602212471e+24, 0.0, 0.0, 17489013.841076534, 11806185.6660164, 0.0, 8546268.728385007, 0.0, 31828243.073495708, 51740168.152000979, 0.0, 22334836.315934014, 4354.0, 7474.0, 4354.0, 4030.0, 0.0, 8635.0, 0.0, 0.0, 0.0, 8479.0]

# Find the catagories of your inputs
r = [(scores[i], i) for i in input_scores if i in scores]

# Join your catagories to get the counts
res = defaultdict(list)
for k, v in r:
    res[k].append(v)

for k, v in res.items():
    print k, len(v), values[k], sum(v)



&gt;&gt;&gt; medium 6 10 143744715.777
hard 6 10 37326.0
easy 4 10 3.52041505391e+24
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if this method is less verbose or not, but I would use <code>np.in1d</code> to match the scores:</p>
<pre><code># we need numpy arrays
easy = np.array(easy)
med = np.array(med)
hard = np.array(hard)

for level in [easy, med, hard]:
    matches = level[np.where(np.in1d(level, input_scores))]
    print(len(matches), len(level), np.sum(matches))
</code></pre>
<p>This code does not yield the same output as the one you have, but I think the data you provided has been corrupted somehow. For example, you have two copies of both <code>7474.0</code> and <code>4354.0</code> in your <code>hard</code>-array. Is this expected? There is also two <code>6.7401171871631936e+22</code> in the easy array.</p>
<p>Output with my method given the current data</p>
<pre><code>5 10 3.58781622578e+24
6 10 143744715.777
8 10 53435.0
</code></pre>
<p>Also, I'm not entirely sure how you do your summing, and so I simply do a sum over all the matched scores (and thus our values will be different).</p>
<hr/>
<p><strong>EDIT:</strong> Using matching <code>input_scores</code> with <code>all_scores</code> instead. The only thing that changes is that we'll have to do a double matching with <code>np.in1d</code> instead:</p>
<pre><code>scores = input_scores[np.where(np.in1d(input_scores, all_scores))]
for level in [easy, med, hard]:
    matches = scores[np.where(np.in1d(scores, level))]
    print(len(matches), len(level), np.sum(matches))
</code></pre>
<p>This removes the problem of duplicates before. Output:</p>
<pre><code>4 10 3.52041505391e+24
6 10 143744715.777
6 10 37326.0
</code></pre>
<hr/>
<p><strong>EDIT 2:</strong> I realised that my use of <code>np.where</code> is superfluous, and it's possible to remove them altogether.</p>
<pre><code>scores = input_scores[np.in1d(input_scores, all_scores)]
for level in [easy, med, hard]:
    matches = scores[np.in1d(scores, level)]
    print(len(matches), len(level), np.sum(matches))
</code></pre>
<p>Yields the same output as the first edit.</p>
<hr/>
<p><strong>EDIT 3:</strong> I put it all together in one program. It's also possible to use numpy to conveniently do the splitting of easy/medium/hard scores. It could probably be made more efficient, but this is quite readable:</p>
<pre><code>import math
import numpy as np

all_scores = np.array([1.0369411057174144e+22, 2.7997409854370188e+23, 1.296176382146768e+23,
6.7401171871631936e+22, 6.7401171871631936e+22, 2.022035156148958e+24, 8.65845823274041e+23,
1.6435516525621017e+24, 2.307193960221247e+24, 1.285806971089594e+24, 9603539.08653573,
17489013.841076534, 11806185.6660164, 16057293.564414097, 8546268.728385007, 53788629.47091801,
31828243.07349571, 51740168.15200098, 53788629.47091801, 22334836.315934014,
4354.0, 7474.0, 4354.0, 4030.0, 6859.0, 8635.0, 7474.0, 8635.0, 9623.0, 8479.0])

input_scores = np.array([0.0, 2.7997409854370188e+23, 0.0, 6.7401171871631936e+22, 0.0, 0.0, 8.6584582327404103e+23, 0.0, 2.3071939602212471e+24, 0.0, 0.0, 17489013.841076534, 11806185.6660164, 0.0, 8546268.728385007, 0.0, 31828243.073495708, 51740168.152000979, 0.0, 22334836.315934014, 4354.0, 7474.0, 4354.0, 4030.0, 0.0, 8635.0, 0.0, 0.0, 0.0, 8479.0])

easy = all_scores[math.exp(50) &lt; all_scores]
med = all_scores[(math.exp(10) &lt; all_scores)*(all_scores &lt; math.exp(50))] # * is boolean `and`
hard = all_scores[all_scores &lt; math.exp(10)]

scores = input_scores[np.in1d(input_scores, all_scores)]
for level in [easy, med, hard]:
    matches = scores[np.in1d(scores, level)]
    print(len(matches), len(level), np.sum(matches))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Though your question has been answered, I still wanted to give it a try (for practice sake). The function is giving the expected output but Paul Panzer's solution is by far the most optimal one. :)   </p>
</blockquote>
<pre><code>    def MatchesLenghtSums(L, lst):
        """
        Compares a list, lst with a list of lists, L. If elements of lst are in L 
        Returns matching elements of lst, lenght of unpacked L, sum of lst  
        Precondition: len(L) = 3"""

        # unpack L
        easy, medium, hard = L
        # traverse lst and find if there are matching elements between lst and 
        # unpacked lists
        easyA = [e for e in lst if e in easy]
        mediumB = [m for m in lst if m in medium]
        hardC = [h for h in lst if h in hard]

        return "(Easy Matches {} Lenght {} sum {}) (Medium Matches {} Length {} sum {}) (Hard Matches {} Lenght {} sum {})".format(
                len(easyA), len(easy), sum(easyA), len(mediumB), 
        len(medium), sum(mediumB), len(hardC), len(hard), sum(hardC))

L = [easy, med, hard]
lst = input_scores
MatchesLenghtSums(L, lst)

&gt;&gt;&gt;'(Easy Matches 4 Lenght 10 sum 3.520415053910622e+24) (Medium Matches 6 Length 10 sum 143744715.77690864) (Hard Matches 6 Lenght 10 sum 37326.0)'
</code></pre>
</div>
<span class="comment-copy">Cool, i haven't heard of <code>np.digitize</code>!!</span>
<span class="comment-copy">BTW, what's "unmatched"? Why would there be unmatched?</span>
<span class="comment-copy">@alvas I just mean those for which <code>input_scores</code> and <code>all_scores</code> don't match. They had to be moved to an extra group so they don't get counted with any of the three other groups.</span>
<span class="comment-copy">Ah, that makes sense. Thanks for the explanation!</span>
<span class="comment-copy">The values are for all_scores and input_scores are non unique the only thing binding them is the order and whether their values match</span>
<span class="comment-copy">@alvas I've updated the solution.</span>
