<div class="post-text" itemprop="text">
<p>I have a string <code>str = "abcd"</code></p>
<p>I want to replace the 1st char of str with "X", append to empty list,
replace the 2nd char with "X", append to list,
repeat until all elements have been replaced, resulting in the following list of lists:</p>
<pre><code>[['N', 'b', 'c', 'd'],
 ['a', 'N', 'c', 'd'],
 ['a', 'b', 'N', 'd'],
 ['a', 'b', 'c', 'N']]
</code></pre>
<p>I've tried:</p>
<pre><code>str = "abcd"
bla = list(str)
blabla = [bla]*len(bla)
for i,e in enumerate(blabla):
    e[i]="N"
</code></pre>
<p>I didnt "append" because I dont know how to in this situation. The unwanted result is:</p>
<pre><code>[['N', 'N', 'N', 'N'],
 ['N', 'N', 'N', 'N'],
 ['N', 'N', 'N', 'N'],
 ['N', 'N', 'N', 'N']]
</code></pre>
<p>What is the best solution in python 3.5?</p>
</div>
<div class="post-text" itemprop="text">
<p>The following line will create multiple references to same object instead of independent lists, which is why changing one of them will affect the others.</p>
<pre><code>blabla = [bla]*len(bla)
</code></pre>
<p>Also don't use python built-in type names and keywords as your argument names.</p>
<p>You don't need to create an empty list before appending your items. Instead you can just use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> within a nested list comprehension:</p>
<pre><code>In [42]: [['N' if ind==i else char for ind, char in enumerate(st)] for i in range(len(st))]
Out[42]: 
[['N', 'b', 'c', 'd'],
 ['a', 'N', 'c', 'd'],
 ['a', 'b', 'N', 'd'],
 ['a', 'b', 'c', 'N']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others point out, your problem is here: <code>blabla = [bla]*len(bla)</code></p>
<p><code>blabla</code> points to list <code>bla</code> 4 times. Changes to either element in <code>blabla</code> will change all elements.</p>
<p>If you want to continue with your method, define the list as <code>blabla = [list(bla) for _ in bla]</code>. Otherwise other answers are valid.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = 'abcd'

res = []
for i in range(len(s)):
    l = list(s) 
    l[i] = 'N'
    res.append(l)

print res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>string = "abcd"

ret = []
for l in range(len(string)):
    t = list(string)
    t[l] = 'X'
    ret.append(t)

print(ret)  # [['X', 'b', 'c', 'd'], ['a', 'X', 'c', 'd'], ['a', 'b', 'X', 'd'], ['a', 'b', 'c', 'X']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>mystr = "abcd"
bla = list(mystr)
old_d =  [bla]* 4

# As others pointed, old_d is list of list of same objects. You can see the memory address of each element

print("memory address for old_d's elements are {}, {}, {}, {}".format(id(old_d[0]), id(old_d[1]),id(old_d[2]),id(old_d[3])))

#call list function as many times as lenfth of the string using list comprehension. 

new_d =  [list(mystr) for i in list(mystr)]    
print("memory address for new_d's elements are {}, {}, {}, {}".format(id(new_d[0]), id(new_d[1]),id(new_d[2]),id(new_d[3])))

for i,_ in enumerate(bla):
    new_d[i][i] = "N"

print new_d
</code></pre>
<p>results in:</p>
<pre><code>memory address for old_d's elements is 66070248, 66070248, 66070248, 66070248
memory address for new_d's elements are 135819952, 135819912, 135819872, 135819752
[['N', 'b', 'c', 'd'], ['a', 'N', 'c', 'd'], ['a', 'b', 'N', 'd'], ['a', 'b', 'c', 'N']]
</code></pre>
</div>
<span class="comment-copy">very confusing...   If you do not print the expected result would be difficult to help</span>
<span class="comment-copy">See this question: <a href="http://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly" title="list of lists changes reflected across sublists unexpectedly">stackoverflow.com/questions/240178/â€¦</a></span>
<span class="comment-copy">Please, put your actual output.</span>
<span class="comment-copy">The expected results are printed at the beginning and the actual output was printed at the end.</span>
<span class="comment-copy">thank you @juanpa.arrivillaga</span>
<span class="comment-copy">Using keywords as argument names? Is that actually possible?</span>
<span class="comment-copy">@StefanPochmann Yes it's not possible to use them exactly the way they are, but in different cases like FALSE. It doesn't have an affection like using built-in type names that copies them but will make a confusion and in not pythonic in terms of coding style.</span>
<span class="comment-copy">Thank you @Kasramvd!</span>
