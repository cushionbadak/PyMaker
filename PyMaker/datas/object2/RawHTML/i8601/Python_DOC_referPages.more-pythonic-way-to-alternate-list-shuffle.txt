<div class="post-text" itemprop="text">
<p>Trying to 'shuffle' a list with even number of items. Splitting the list, <code>L</code> in half and alternating taking an element from each.</p>
<p>I've tried <code>pop</code>, but that approach was unable to get me to a one-liner. (<code>while</code> loop) and I know there is likely some more succinct way to move through it.</p>
<p>The <code>shuffle</code> from <code>random</code> isn't exactly what I need, either â€“ because that randomizes the entire order instead of alternating between the split list. </p>
<p>If a one-liner isn't possible, is that because it's more readable in a <code>while</code> loop?</p>
<pre><code>def shuffle(L):
    '''
    I apologize in advance for how wet the following code is... 
    Example:
    &gt;&gt;&gt; shuffle([1, 2, 3, 4, 5, 6])
    [1, 4, 2, 5, 3, 6]
    '''
    return [L[:(len(L)//2)][0], L[(len(L)//2):][0], L[:(len(L)//2)][1], L[(len(L)//2):][1], L[:(len(L)//2)][2], L[(len(L)//2):][2]]
</code></pre>
<p>other attempt:</p>
<pre><code>def shuffle(L):
    x, L_first, L_next, L = len(L), L[:(len(L)//2)], L[(len(L)//2):], []
    while len(L) != x:
        L.extend([L_first.pop(0), L_next.pop(0)])
    return L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use slice assignment with a step:</p>
<pre><code>def shuffle(l):
    result = [None] * len(l)

    # Put the first half of l in the even indices of result
    result[::2] = l[:len(l)//2]

    # Put the second half of l in the odd indices of result
    result[1::2] = l[len(l)//2:]

    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you could also opt for <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable</code></a> after zipping to get the alternating effect. </p>
<pre><code>from itertools import chain

def shuff(l):
    return list(chain.from_iterable(zip(l[:len(l)//2], l[len(l)//2:])))
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; shuff(list(range(1, 7))
[1, 4, 2, 5, 3, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One possibility (requires an external library but the recipe can also be found in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code>-recipes section</a>) is:</p>
<pre><code>from iteration_utilities import roundrobin

def shuffle(L):
    return list(roundrobin(L[:len(L)//2], L[len(L)//2:]))
</code></pre>
<p>This is probably slower than list assignment but it also works for arbitary amounts of iterables without problems and it doesn't require odd-sized-input handling:</p>
<pre><code>&gt;&gt;&gt; shuffle([1, 2, 3, 4, 5, 6, 7])
[1, 4, 2, 5, 3, 6, 7]
&gt;&gt;&gt; shuffle([1, 2, 3, 4, 5, 6])
[1, 4, 2, 5, 3, 6]
</code></pre>
<hr/>
<p>I did some <a href="https://gist.github.com/MSeifert04/c0dfd2c07ca2ffcd35f7384380f08a37" rel="nofollow noreferrer">timings</a> and @user2357112 definetly has the fastest solution but my solution is at least on the second place (note that this graph is in log-log, that means the difference in absolute terms may seem smaller than it really is!):</p>
<p><a href="https://i.stack.imgur.com/9z4X2.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/9z4X2.png"/></a></p>
<hr/>
<p><sup>Disclaimer: I'm the author of that <code>iteration_utilities</code> library.</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>list comprehension with index calculation using modulo and floor division</p>
<pre><code>[ L[(i + (i % 2)*len(L))//2] for i in range(len(L)) ] # for case of even len(L)
</code></pre>
<p>still one line for the general case</p>
<pre><code>[ L[i//2 + (i % 2)*len(L)//2] for i in range(2*(len(L)//2)) ] + [L[-1]]*(len(L) % 2)
</code></pre>
<p>the index calc <code>(i + (i % 2)*len(L))//2</code> </p>
<p>can be parsed as adding</p>
<p><code>i//2</code> which gives <code>0, 0, 1, 1, 2, 2 ...</code></p>
<p>and</p>
<p><code>(i % 2)*len(L)//2</code> where <code>(i % 2)</code> alternates 0, 1 for even/odd <code>i</code></p>
<p><code>0, len(L)//2, 0, len(L)//2, 0, len(L)//2 ...</code></p>
<p>sum:</p>
<p><code>0, len(L)//2, 1, 1 + len(L)//2, 2, 2 + len(L)//2 ...</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Found two solutions. First one is very unpythonic (using python 2.7)</p>
<pre><code>a = [1, 2, 3, 4, 5, 6] # intial array
</code></pre>
<p>Method One (using string magic):</p>
<pre><code>[int(p) for p in ' '.join([str(x) + ' ' + str(y) for x, y in zip(a[:len(a) / 2], a[len(a) / 2:])]).split(' ')]
</code></pre>
<p>Method Two:</p>
<pre><code>[i for Tuple in zip(a[:len(a) / 2], a[len(a) / 2:]) for i in Tuple]
</code></pre>
</div>
<span class="comment-copy">I haven't seen the <code>[None]</code> used before. Does this make an empyt list with <code>len(l)</code> empty spaces?</span>
<span class="comment-copy">@be-ns: It makes a list with <code>len(l)</code> references to the <code>None</code> object. These are not empty spaces, but <code>None</code> makes a good filler.</span>
<span class="comment-copy">that's clever. I'll have to start using that.</span>
<span class="comment-copy">I'll have to dig into this more to make sure I get this, but it works perfectly even on much longer lists. @Mitch</span>
<span class="comment-copy">how well does it hold up when the list is, say, 1000 items instead of 6? <code>roundrobin</code> looks like the perfect recipe, (like zip but to a list instead of two-tuples).</span>
<span class="comment-copy">@be-ns That will depend on which function you use (the one from <code>iteration_utilities</code> or the one from the <code>itertools</code> recipes section) and on which python version. I'll add some benchmarks :)</span>
<span class="comment-copy">@be-ns I've updated the answer and included the timings.</span>
<span class="comment-copy">@KingMak <a href="https://gist.github.com/MSeifert04/c0dfd2c07ca2ffcd35f7384380f08a37" rel="nofollow noreferrer">gist.github.com/MSeifert04/c0dfd2c07ca2ffcd35f7384380f08a37</a> (also linked inside the answer)</span>
<span class="comment-copy">No problem. However it requires matplotlib (for the plot) and ipython (for the magic <code>%timeit</code>):) And I probably forgot to include the code for creating the image (however if you want to display it, you can simply use <code>plt.show()</code> at the end).</span>
<span class="comment-copy">This is the best answer in my opinion</span>
<span class="comment-copy">Can you break it down a little bit? I can't understand what is happening</span>
<span class="comment-copy">@KingMak updated ans with explanation of indexing</span>
