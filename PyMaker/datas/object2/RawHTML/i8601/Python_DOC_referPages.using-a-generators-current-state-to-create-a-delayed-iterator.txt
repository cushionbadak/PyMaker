<div class="post-text" itemprop="text">
<p>I would like to understand how to iterate through a generator based on a condition, and to return only the current state without calling next() when that condition is not met.</p>
<p>For instance, given a repeating series of integers from 1 to n, how can I create an index starting at 0 that is frozen until a condition is met by the next value in the series? </p>
<p>My attempt is:</p>
<pre><code>def generator():
    number = 0
    while True:
        number +=1
        yield number
gen = generator()
start = gen.next()
def f(x):
    if x&gt;5:
        current = gen.next()
        return current
pd.Series(list(itertools.chain(np.arange(10),np.arange(10)))).apply(f)
</code></pre>
<p>which returns</p>
<pre><code>0     NaN
1     NaN
2     NaN
3     NaN
4     NaN
5     NaN
6     2.0
7     3.0
8     4.0
9     5.0
10    NaN
11    NaN
12    NaN
13    NaN
14    NaN
15    NaN
16    6.0
17    7.0
18    8.0
19    9.0
</code></pre>
<p>but the output should be</p>
<pre><code>0     0.0
1     0.0
2     0.0
3     0.0
4     0.0
5     0.0
6     1.0
7     2.0
8     3.0
9     4.0
10    5.0
11    5.0
12    5.0
13    5.0
14    5.0
15    5.0
16    6.0
17    7.0
18    8.0
19    9.0
</code></pre>
<p>however, an else condition in frozenIndex like current = start will always return the saved first generator value. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this sort of thing by sending data into the generator via its <a href="https://docs.python.org/3/reference/expressions.html#generator.send" rel="nofollow noreferrer"><code>.send</code></a> method. Here's a (relatively) simple example.</p>
<pre><code>def conditional_counter():
    ''' An infinite counter that freezes on the last value 
        if the sent-in value is False-ish
    '''
    yield
    value = 0
    while True:
        condition = yield value
        if condition:
            value += 1

counter = conditional_counter()
counter.send(None)

for s in 'abcdefghijklmnop':
    val = counter.send(s == 'c' or s &gt;= 'h')
    print(s, val)
</code></pre>
<p><strong>output</strong></p>
<pre><code>a 0
b 0
c 1
d 1
e 1
f 1
g 1
h 2
i 3
j 4
k 5
l 6
m 7
n 8
o 9
p 10
</code></pre>
<hr/>
<p>The first call to <code>.send()</code> <em>must</em> pass <code>None</code> as the arg, otherwise you get</p>
<pre><code>TypeError: can't send non-None value to a just-started generator
</code></pre>
<p>So we take care of that with</p>
<pre><code>counter.send(None)
</code></pre>
<p>and the first <code>yield</code> statement in the generator. FWIW, a "naked" <code>yield</code> yields <code>None</code>, just like a naked <code>return</code> returns <code>None</code>. </p>
<hr/>
<p>Here's a more complicated generator which can be passed any iterable.</p>
<pre><code>def conditional_counter(iterable):
    ''' An iterator that freezes on the last value 
        if the sent-in value is False-ish,
        or if the iterable runs out of items.
    '''
    it = iter(iterable)
    yield
    value = next(it)
    while True:
        condition = yield value
        if condition:
            try:
                value = next(it)
            except StopIteration:
                pass


counter = conditional_counter(range(9))
counter.send(None)

for s in 'abcdefghijklmnop':
    val = counter.send(s == 'c' or s &gt;= 'h')
    print(s, val)
</code></pre>
<p><strong>output</strong></p>
<pre><code>a 0
b 0
c 1
d 1
e 1
f 1
g 1
h 2
i 3
j 4
k 5
l 6
m 7
n 8
o 8
p 8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can initialize a <code>flag_val</code> with <strong>0.0</strong></p>
<pre><code>flag_val = 0.0

def frozenIndex(x):
    if x&gt;5:
        current = gen.next()
        flag_val = current
    else: 
        current = flag_val
    return current
</code></pre>
<p>This should solve what you are trying to do but you cannot traverse forward and backward on <strong>yield</strong>.</p>
</div>
<span class="comment-copy">Your functionality isn't clear to me, but why not use a class that implements the iterator protocol? <a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#typeiter</a></span>
<span class="comment-copy">Given a list [0,1,2,3,4,5,6,7,8,9] I would like to return [0,0,0,0,0,0,1,2,3,4] (i.e. do not call .next() on the generator until a value &gt; 5 is reached in the sequence.) I am not sure how to implement a wrapper on the generator that only starts it once, instead of every time the wrapper is called.</span>
<span class="comment-copy">But if you're not calling next how do you know when you get to 5?</span>
<span class="comment-copy">Well you start at 0, and if the function frozenIndex(x) sees an x&gt;5, it gives the signal to the generator to call next. So my function frozenIndex is a wrapper for gen.</span>
<span class="comment-copy">This feels like a lot like an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>.</span>
<span class="comment-copy">How does the .send() method know that the data it is being sent is the condition to check?</span>
<span class="comment-copy">@michel The <code>.send</code> method <i>doesn't</i> know what the data it sends is used for, it just sends it to the generator, and that data becomes the result of the <code>yield</code> expression, so in my scripts above it gets assigned to <code>condition</code>. Once the sent data arrives at the generator you can do what you like with it. <a href="http://stackoverflow.com/a/29193387/4014959">Here's</a> another small example. I wrote that one a couple of years ago, so it's for Python 2, but it's easy enough to convert to Python 3.</span>
<span class="comment-copy">Thanks a lot. This is really useful</span>
<span class="comment-copy">One more question, why is the first yield (None) statement necessary? Can we not go straight to the while True loop?</span>
<span class="comment-copy">@michel As I said in the answer, "The first call to <code>.send()</code> <b>must</b> pass None as the arg". So it's <i>impossible</i> to send the condition data in the first <code>.send()</code> call. That's why I have the <code>counter.send(None)</code> in the calling code and the "dummy" <code>yield</code> in the generator. I realise that this is a difficult topic, and I'm still only a beginner at using <code>.send</code> myself, but I suggest you experiment with it to become more familiar with how it behaves.</span>
<span class="comment-copy">This gives the error: "UnboundLocalError: local variable 'flag_val' referenced before assignment"</span>
