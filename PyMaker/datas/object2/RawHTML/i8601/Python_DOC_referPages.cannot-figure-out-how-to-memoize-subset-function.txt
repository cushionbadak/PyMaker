<div class="post-text" itemprop="text">
<p>My function is supposed to find whether or not the values of a number list add up to my target in any way shape or form.  My code is:</p>
<pre><code>def memoizedSubset(target, numberList, memo):
    ''' Returns True if there exists a subset of numberList that adds
        up to target and returns False otherwise.'''
    if target == 0:
        return True;
    elif numberList == ():
        return False;
    elif (target, numberList) in memo:
        return memo[(target, numberList)];
    elif numberList[0] &gt; target:
        solution = memoizedSubset(target, numberList[1:], memo);
        memo[(target, numberList)] = solution;
        return solution;
    else:
        useIt = memoizedSubset(target - numberList[0], numberList, memo);
        loseIt = memoizedSubset(target, numberList[1:], memo);
        solution = useIt or loseIt;
        memo[(target, numberList)] = solution;
        return solution;

numberTuple = tuple(range(2, 100, 2));
print(memoizedSubset(1234567, numberTuple, {}));
</code></pre>
<p>The logic seems flawless but when I try to run the function I get the maximum recursion depth reached error.  I used a dictionary to speed up the process because with the given values it would take a while to complete it without a dictionary.  I cannot for the life of me figure out what the problem is. </p>
<p>UPDATE: The code works for smaller values but not for a larger value like 1234567 above.  Isn't memoization supposed to get over the recursion limit hump?</p>
</div>
<div class="post-text" itemprop="text">
<p>Removing the memoization logic and adding <code>print(target, numberList[:5])</code> to the top of the function gives:</p>
<pre><code>(1234567, (2, 4, 6, 8, 10))
(1234565, (2, 4, 6, 8, 10))
(1234563, (2, 4, 6, 8, 10))
(1234561, (2, 4, 6, 8, 10))
(1234559, (2, 4, 6, 8, 10))
(1234557, (2, 4, 6, 8, 10))
(1234555, (2, 4, 6, 8, 10))
(1234553, (2, 4, 6, 8, 10))
...

Traceback (most recent call last):
  File "/Users/raymond/Documents/tmp3.py", line 22, in &lt;module&gt;
    print(memoizedSubset(1234, numberTuple, {}));
  File "/Users/raymond/Documents/tmp3.py", line 16, in memoizedSubset
    useIt = memoizedSubset(target - numberList[0], numberList, memo);
</code></pre>
<p>This shows that the recursion is proceeding much too slowly for this to ever work.</p>
<p>Even adding <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow noreferrer"><code>sys.setrecursionlimit(10000)</code></a> does not alleviate the problem.</p>
<p>Debugging code:</p>
<pre><code>import sys
sys.setrecursionlimit(10000)

def memoizedSubset(target, numberList, memo):
    ''' Returns True if there exists a subset of numberList that adds
        up to target and returns False otherwise.'''
    print(target, numberList[:5])
    if target == 0:
        return 0;
    elif numberList == ():
        return False;
    elif numberList[0] &gt; target:
        solution = memoizedSubset(target, numberList[1:], memo);
        return solution;
    else:
        useIt = memoizedSubset(target - numberList[0], numberList, memo);
        loseIt = memoizedSubset(target, numberList[1:], memo);
        solution = useIt or loseIt;
        return solution;

numberTuple = tuple(range(2, 100, 2));
print(memoizedSubset(1234567, numberTuple, {}));
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no problem in memoization itself. But you could use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> instead if you are using Python 3.4+ (no need to pass memo yourself).</p>
<ul>
<li><code>if target == 0: return 0</code> should be <code>if target == 0: return True</code>. Otherwise the function always return False (0 == False); edited in the question after I commented.</li>
<li><code>useIt = memoizedSubset(target - numberList[0], numberList, memo)</code> should be <code>useIt = memoizedSubset(target - numberList[0], numberList[1:], memo)</code>
<ul>
<li>numberList is never reduced.</li>
</ul></li>
<li>Assuming <code>numberList</code> is sorted, you can return <code>False</code> immediately in case of <code>numberList[0] &gt; target</code>.</li>
<li><p>You can combine following lines into one to take a benefit of short-circuit (even though <code>useIt</code> is True, <code>loseIt</code> part would be executed otherwise)</p>
<pre><code>useIt = memoizedSubset(target - numberList[0], numberList, memo);
loseIt = memoizedSubset(target, numberList[1:], memo);
solution = useIt or loseIt;
</code></pre></li>
</ul>
<hr/>
<pre><code>from functools import lru_cache

@lru_cache(None)
def solve(target, numbers):
    # assuming numbers is a sorted tuple of `int`s.
    if target == 0:
        return True
    elif (not numbers) or numbers[0] &gt; target:
        return False
    else:
        return solve(target - numbers[0], numbers[1:]) or \
               solve(target, numbers[1:])
</code></pre>
</div>
<span class="comment-copy">You're trying to use really, really deep recursion. You're hitting the recursion depth limit. Pick an algorithm that doesn't recurse so deep.</span>
<span class="comment-copy">It's not a problem with the memoization. Your memoization logic is fine.</span>
<span class="comment-copy">The first <code>if</code> statement should be: <code>if target == 0: return True</code>. Otherwise there's no <code>True</code> returned. (0 == False). Isn't it?</span>
<span class="comment-copy">@falsetru yea i just fixed that actually in my code il edit it here quick</span>
<span class="comment-copy">"Isn't memoization supposed to get over the recursion limit hump?" - no. Memoization is not intended to solve recursion limit issues. It decreases the number of redundant recursive calls a recursive function makes, but it is not guaranteed to make the call stack shallower.</span>
<span class="comment-copy">yes but the elif should only get triggered if the first element in the tuple array is greater than the target. if it's not, it should use the value hence the target-numberList[0]</span>
<span class="comment-copy">That looks fine to me. I'm pretty sleepy, so I might be thinking about it wrong, but the <code>elif</code> will get hit when the new target is small enough, right?</span>
<span class="comment-copy">@user2357112 yes and when it does it will simply not use that element and skip over it.</span>
<span class="comment-copy">"But adding sys.setrecursionlimit(10000) did not alleviate the problem" - it looks to me like the algorithm is simply trying to use a finite amount of recursion more than 10000 calls deep, but not infinite.</span>
<span class="comment-copy">You can see that it <a href="http://ideone.com/RUARND" rel="nofollow noreferrer">doesn't hit the recursion limit</a> for smaller inputs.</span>
