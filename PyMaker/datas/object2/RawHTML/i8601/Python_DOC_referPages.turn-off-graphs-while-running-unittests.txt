<div class="post-text" itemprop="text">
<p>I am testing out my module using the <code>unittest</code> library. This includes plotting some graphs using the <code>matplotlib</code> library. The issue at the moment is that the testing pauses every time a graph is plotted, and it only resumes after I close the graph. How can I avoid this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I will model my answer after the simple example code from the matplotlib tutorial: <a href="http://matplotlib.org/users/pyplot_tutorial.html" rel="nofollow noreferrer">http://matplotlib.org/users/pyplot_tutorial.html</a></p>
<p>Let's assume we have the following module, <code>plot_graph.py</code> to be tested:</p>
<pre><code>import matplotlib.pyplot as plt

def func_plot():
    plt.plot([1,2,3,4])
    plt.ylabel('some numbers')
    plt.show()

if __name__ == "__main__":
    func_plot()
</code></pre>
<p>The calls to <code>show</code> can be patched as follows:</p>
<pre><code>from plot_graph import func_plot
from unittest.mock import patch

@patch("plot_graph.plt.show")
def test_plot(mock_show):
    assert func_plot() == None
</code></pre>
<p>As you can see, you should patch the calls to <code>pyplot.show()</code>. You can find more about patching and mocking in the docs: <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html</a>. </p>
<p>Usually the section about where to patch is really useful: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#where-to-patch</a></p>
<p>Finally there are similar question already on the site: <a href="https://stackoverflow.com/questions/24343640/how-to-run-nosetests-without-showing-of-my-matplotlibs-graph">How to run nosetests without showing of my matplotlib's graph?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Don't call <code>pyplot.show()</code> if this is done in the tests. Also the <a href="http://matplotlib.org/api/pyplot_api.html?highlight=show#matplotlib.pyplot.show" rel="nofollow noreferrer">documentation</a> suggests using an experimental <code>block=False</code> keyword argument to the <code>show</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for completeness, I ran into a similar issue, but to fix it I had to mock out calls to <code>matplotlib.pyplot.figure</code> instead. I realize this isn't exactly what was asked, but this took me a while to figure out after coming across this thread, so I wanted to post it here.</p>
<p>If, for instance, your <code>plot_graph.py</code> looked like this:</p>
<pre><code>import matplotlib.pyplot as plt

def func_plot():
    fig = plt.figure()
    plt.plot([1,2,3,4])
    plt.ylabel('some numbers')
    plt.show()
</code></pre>
<p>then, at least in my case (running unit tests on a terminal that has no X11 forwarding and errors out when it tries to open a plot), I needed the following in <code>test_plot_graph.py</code> to run my test:</p>
<pre><code>from plot_graph import func_plot
from unittest.mock import patch

# unittest boilerplate...

@patch('matplotlib.pyplot.figure')
def test_func_plot(self, mock_fig):
    # whatever tests I want...
    mock_fig.assert_called()  # some assertion on the mock object
</code></pre>
</div>
<span class="comment-copy">I updated my previous answer with an example</span>
<span class="comment-copy"><code>pyplot.show()</code> is called in one of my modules, not in the tests. <code>block=False</code> doesn't work for me. I think its deprecated.</span>
<span class="comment-copy">Maybe calling pyplot.close("all") from your tests could do the trick.</span>
