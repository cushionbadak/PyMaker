<div class="post-text" itemprop="text">
<p>With Zapier I sent in a JSON object with the following data from the client:</p>
<pre><code>fields = {
    “data":[
        {
            "duration":4231,
            “description”:”text text text "
        },
        {
            "duration":283671,
            “description”:”text text text "
        },
        {
            "duration":233671,
            “description”:”text text text "
        },
        {
            "duration":293671,
            “description”:”text text text "
        }
    ]
}
</code></pre>
<p>When I send a send a JSON object similar to this it could receive an Array of maybe even 100+ elements. On the server side I need it to take this data in and go through the array of objects and set a timer to have the same amount of duration as the “duration” property. I have an example script in Python to illustrate what I mean.</p>
<pre><code>Server Side:
import requests
import json
import time

class Person(object):
    def __init__(self, url=None, duration=None):
        self.url = url
        self.duration = duration
string = input['data2']
output = [{'id': 123, 'hello': 'world'}]
print(input['data2'])
print(len(string))
holder = string.splitlines()
print(holder)
tempd = ""
insert = 0
for x in holder:
    if len(x) &gt; 0:
        if(x.find("duration") != -1):
            tempA = x.split(":")#its techincally reading the property as a string so its whatever I split it and get the number out
            timer = (float(tempA[1])/1000)#converting the miliseconds to seconds
            print(timer)
            print "Start : %s" % time.ctime()
            #time.sleep(timer)#based on the duration determines how long my timer will sleep for
            print "End : %s" % time.ctime()
</code></pre>
<p>When I execute this script I get timeout issues, but what I need the server to do is just send a response that it has received the request and is executing the script with desired JSON Object? I need this to go throughout the day is Im simply saying that this array could contain 100 elements with each at least 2 a min delay in between. would Heroku support this need or should I just build a server on Azure?</p>
</div>
<div class="post-text" itemprop="text">
<p>Heroku terminates requests <a href="https://devcenter.heroku.com/articles/request-timeout#long-polling-and-streaming-responses" rel="nofollow noreferrer">after 30 seconds</a>. But you can run a background task that updates a data store, then just check the data store on page load.
Here's a minimal example for local testing using <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a>, <a href="https://dataset.readthedocs.io/en/latest/index.html" rel="nofollow noreferrer">dataset</a> and <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">sqlite</a>. On heroku you'll have to replace the sqlite reference with a cloud data store like this <a href="https://elements.heroku.com/addons/heroku-postgresql" rel="nofollow noreferrer">postgres</a> service. And straight-up <a href="https://www.sqlalchemy.org/" rel="nofollow noreferrer">SQLAlchemy</a> is usually preferred over dataset.</p>
<pre><code>from flask import Flask, jsonify
import dataset
import threading
import time
import random

app = Flask(__name__)
DATABASE_URL = 'sqlite:///dev.db'

def add_person(name):
    """ Add a person to the db. """
    person = {'name': name, 'age': -1, 'status': 'processing'}
    db = dataset.connect(DATABASE_URL)
    db['people'].insert(person)
    return True

def update_person(name):
    """ Update person in db. """
    age = random.randint(1, 120)  # make your api call here
    time.sleep(10)  # simulate long running process
    person = {'name': name, 'age': age, 'status': 'finished'}
    db = dataset.connect(DATABASE_URL)
    db['people'].update(person, ['name'])
    return True

def get_person(name):
    """ Retrieve a person from the db. """
    db = dataset.connect(DATABASE_URL)
    person = db['people'].find_one(name=name)
    return person

@app.route('/&lt;name&gt;')
def index(name):
    """ If name not found, add_person to db and start update_person thread. 
    Return a person from db. """
    if not get_person(name):
        add_person(name)
        thread = threading.Thread(target=update_person, args=(name,))
        thread.start()
    person = get_person(name)
    return jsonify(person)

if __name__ == '__main__':
    app.run(debug=True)
</code></pre>
<p>Visit 127.0.0.1:5000/tom and while <code>thread</code> is running you get:</p>
<pre><code>{
    "age": -1,
    "id": 14,
    "name": "tom",
    "status": "processing"
}
</code></pre>
<p>Reloading after the <code>thread</code> is finished you see:</p>
<pre><code>{
    "age": 94,
    "id": 14,
    "name": "tom",
    "status": "finished"
}
</code></pre>
</div>
