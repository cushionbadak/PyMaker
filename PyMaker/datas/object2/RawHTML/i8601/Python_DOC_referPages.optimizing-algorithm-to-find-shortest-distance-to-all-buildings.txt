<div class="post-text" itemprop="text">
<p>The question is to find the shortest distance to all buildings for a 0 valued point given a grid. You are only allowed to move up, down, left, and right. You can encounter the following values:</p>
<p>0 - empty space
1 - building
2 - obstacle</p>
<p>My solution written in Python is below:</p>
<pre><code>import sys

class Solution(object):
    def shortestDistance(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        if grid is None:
            return -1

        tup = self.findPoints(grid)
        buildings = tup[0]
        zeroPoints = tup[1]
        distances = []
        for points in zeroPoints:
            dist = self.bfs(grid, points, buildings)
            distances += [dist]

        return self.select(distances)

    def findPoints(self, grid):
        buildings = 0
        zeroPoints = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    zeroPoints += [[i,j]]
                elif grid[i][j] == 1:
                    buildings += 1
        return (buildings, zeroPoints)

    def bfs(self, grid, root, targets):
        hits, sumDist = 0, 0
        targetsFound = []

        while hits &lt; targets:
            q = []
            q.append((root, 0))
            found = False
            visited = []
            while(len(q) &gt; 0):
                tup = q.pop(0)
                curr = tup[0]
                dist = tup[1]

                if grid[curr[0]][curr[1]] == 1 and curr not in targetsFound:
                    found = True
                    sumDist += dist
                    targetsFound += [curr]
                    break

                if grid[curr[0]][curr[1]] == 0:
                    if (curr[0] - 1) &gt;= 0 and grid[curr[0] -1][curr[1]] != 2 and [curr[0] - 1, curr[1]] not in visited:
                        q.append(([curr[0] - 1, curr[1]], dist + 1))
                        visited += [[curr[0] - 1, curr[1]]]
                    if (curr[0] + 1) &lt; len(grid) and grid[curr[0] + 1][curr[1]] != 2 and [curr[0] + 1, curr[1]] not in visited:
                        q.append(([curr[0] + 1, curr[1]], dist + 1))
                        visited += [[curr[0] + 1, curr[1]]]
                    if (curr[1] - 1) &gt;= 0 and grid[curr[0]][curr[1] - 1] != 2 and [curr[0], curr[1] - 1] not in visited:
                        q.append(([curr[0], curr[1] - 1], dist + 1))
                        visited += [[curr[0], curr[1] - 1]]
                    if (curr[1] + 1) &lt; len(grid[0]) and grid[curr[0]][curr[1] + 1] != 2 and [curr[0], curr[1] + 1] not in visited:
                        q.append(([curr[0], curr[1] + 1], dist +1))
                        visited += [[curr[0], curr[1] + 1]]

            if found:
                hits += 1
            else:
                return - 1

        return sumDist

    def select(self, distances):
        min = sys.maxsize
        for dist in distances:
            if dist &lt; min and dist != -1:
                min = dist

        if min == sys.maxsize:
            return -1
        else:
            return min
</code></pre>
<p>My question is:</p>
<p>How can I increase the efficiency of my solution? Right now I am exceeding a time limit on Leetcode on the following input but it is correct for all other test inputs:</p>
<pre><code>[[2,0,0,2,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,1,2,0,2,0,1,1,0],[0,1,0,1,1,2,0,0,2,0,0,2,0,2,2,0,2,0,2,0,0,0,0,0,0,0,0,0],[1,0,0,1,2,0,0,2,0,2,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,2],[0,0,2,2,2,1,0,0,2,0,0,0,0,0,0,0,0,0,2,2,2,2,1,0,0,0,0,0],[0,2,0,2,2,2,2,1,0,0,0,0,1,0,2,0,0,0,0,2,2,0,0,0,0,2,2,1],[0,0,2,1,2,0,2,0,0,0,2,2,0,2,0,2,2,2,2,2,0,0,0,0,2,0,2,0],[0,0,0,2,1,2,0,0,2,2,2,1,0,0,0,2,0,2,0,0,0,0,2,2,0,0,1,1],[0,0,0,2,2,0,0,2,2,0,0,0,2,0,2,2,0,0,0,2,2,0,0,0,0,2,0,0],[2,0,2,0,0,0,2,0,2,2,0,2,0,0,2,0,0,2,1,0,0,0,2,2,0,0,0,0],[0,0,0,0,0,2,0,2,2,2,0,0,0,0,0,0,2,1,0,2,0,0,2,2,0,0,2,2]]
</code></pre>
<p>Note: Changing visited and targetsFound improves efficiency but is not sufficient to pass all test cases.</p>
<p>Update:</p>
<p>By changing the algorithm to search from each building instead of each zero point, I was able to improve the algorithm by 96% on certain large inputs and pass all test cases. The updated algorithm is below. Thanks to Nether for his suggestions.</p>
<pre><code>def shortestDistanceWalk(grid):

    onePoints = findPointsWalk(grid)

    for point in onePoints:
        bfsWalk(grid, point)

    shortestDistance = sys.maxsize
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] &lt; 0 and shortestDistance &gt; (grid[i][j] * -1):
                shortestDistance = (grid[i][j] * -1)

    if shortestDistance == sys.maxsize:
        return -1
    else:
        return shortestDistance

def findPointsWalk(grid):
    onePoints = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                onePoints += [[i,j]]
    return onePoints

def bfsWalk(grid, root):
    q = []
    q.append((root, 0))
    found = False
    visited = set()
    while(len(q) &gt; 0):
        tup = q.pop(0)
        curr = tup[0]
        dist = tup[1]

        if grid[curr[0]][curr[1]] &lt;= 0:
            grid[curr[0]][curr[1]] += dist

        if (curr[0] - 1) &gt;= 0 and grid[curr[0] -1][curr[1]] &lt;= 0  and (curr[0] - 1, curr[1]) not in visited:
            q.append(([curr[0] - 1, curr[1]], dist - 1))
            visited.add((curr[0] - 1, curr[1]))
        if (curr[0] + 1) &lt; len(grid) and grid[curr[0] + 1][curr[1]] &lt;= 0 and (curr[0] + 1, curr[1]) not in visited:
            q.append(([curr[0] + 1, curr[1]], dist - 1))
            visited.add((curr[0] + 1, curr[1]))
        if (curr[1] - 1) &gt;= 0 and grid[curr[0]][curr[1] - 1] &lt;= 0 and (curr[0], curr[1] - 1) not in visited:
            q.append(([curr[0], curr[1] - 1], dist - 1))
            visited.add((curr[0], curr[1] - 1))
        if (curr[1] + 1) &lt; len(grid[0]) and grid[curr[0]][curr[1] + 1] &lt;= 0 and (curr[0], curr[1] + 1) not in visited:
            q.append(([curr[0], curr[1] + 1], dist - 1))
            visited.add((curr[0], curr[1] + 1))

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if (i, j) not in visited:
                grid[i][j] = 3

    return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Change your <code>targetsFound</code> variable to a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a>.
The reason you use that variable is to look up if a cell has been visited and lookups in lists are slow <strong>O(N)</strong> time. Sets support fast lookup <strong>O(1)</strong> and as such should drastically improve your algorithm's performance.</p>
<p>More information about what O(N) and O(1) mean: <a href="https://www.youtube.com/watch?v=v4cd1O4zkGw&amp;t=1s" rel="nofollow noreferrer">https://www.youtube.com/watch?v=v4cd1O4zkGw&amp;t=1s</a></p>
</div>
<span class="comment-copy">Thanks that helped but it is still not sufficient to pass all test cases. Can you think of a more powerful pruning?</span>
<span class="comment-copy">I think your approach might be bad, imagine you had 999 zero points and 1 building, you'd do 999 BFSes. In that case, doing a single BFS from the building would find the shortest paths from every zero point to it and would be 999 times more efficient, haha. Maybe you want to somehow compare the count of buildings/zero-points and in some case flip where you run the BFS from. Just an idea, not sure if it will work.</span>
<span class="comment-copy">I think you are right. Before I do that I'm going to modify the algorithm to search from each building, updating the distance at each zero to be the most negative. Then just return the least negative distance after k building searches, storing 3 at points that cannot reach all buildings.</span>
