<div class="post-text" itemprop="text">
<p>I have following string:</p>
<pre><code>BUCKET1:/dir1/dir2/BUCKET1:/dir3/dir4/BUCKET2:/dir5/dir6
</code></pre>
<p>I am trying to split it in a way I would get back the following dict / other data structure:</p>
<pre><code>BUCKET1 -&gt; /dir1/dir2/, BUCKET1 -&gt; /dir3/dir4/, BUCKET2 -&gt; /dir5/dir6/
</code></pre>
<p>I can somehow split it if I only have one BUCKET, not multiple, like this:</p>
<pre><code>res.split(res.split(':', 1)[0].replace('.', '').upper()) -&gt; it's not perfect 
</code></pre>
<hr/>
<p>Input: ADRIAN:/dir1/dir11/DANIEL:/dir2/ADI_BUCKET:/dir3/CULEA:/dir4/ADRIAN:/dir5/ADRIAN:/dir6/</p>
<p>Output: [(ADRIAN, /dir1/dir11), (DANIEL, /dir2/), (CULEA, /dir3/), (ADRIAN, /dir5/), (ADRIAN, /dir6/)</p>
<hr/>
<p>As per Wiktor Stribi≈ºew comments, the following regex does the job:</p>
<pre><code> r"(BUCKET1|BUCKET2):(.*?)(?=(?:BUCKET1|BUCKET2)|$)"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're experienced, I'd recommend learning Regex just as the others have suggested. However, if you're looking for an alternative, here's a way of doing such without Regex. It also produces the output you're looking for.</p>
<pre><code>string = input("Enter:") #Put your own input here.

tempList = string.replace("BUCKET",':').split(":")
outputList = []
for i in range(1,len(tempList)-1,2):
    someTuple = ("BUCKET"+tempList[i],tempList[i+1])
    outputList.append(someTuple)

print(outputList) #Put your own output here.
</code></pre>
<p>This will produce:</p>
<pre><code>[('BUCKET1', '/dir1/dir2/'), ('BUCKET1', '/dir3/dir4/'), ('BUCKET2', '/dir5/dir6')]
</code></pre>
<p>This code is hopefully easier to understand and manipulate if you're unfamiliar with Regex, although I'd still personally recommend Regex to solve this if you're familiar with how to use it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">re.findall()</a> function:</p>
<pre><code>s = "ADRIAN:/dir1/dir11/DANIEL:/dir2/ADI_BUCKET:/dir3/CULEA:/dir4/ADRIAN:/dir5/ADRIAN:/dir6/"
result = re.findall(r'(\w+):([^:]+\/)', s)

print(result)
</code></pre>
<p>The output:</p>
<pre><code>[('ADRIAN', '/dir1/dir11/'), ('DANIEL', '/dir2/'), ('ADI_BUCKET', '/dir3/'), ('CULEA', '/dir4/'), ('ADRIAN', '/dir5/'), ('ADRIAN', '/dir6/')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use regex instead?</p>
<pre><code>impore re
test = 'BUCKET1:/dir1/dir2/BUCKET1:/dir3/dir4/BUCKET2:/dir5/dir6'

output = re.findall(r'(?P&lt;bucket&gt;[A-Z0-9]+):(?P&lt;path&gt;[/a-z0-9]+)', test)
print(output)
</code></pre>
<p>Which gives</p>
<pre><code>[('BUCKET1', '/dir1/dir2/'), ('BUCKET1', '/dir3/dir4/'), ('BUCKET2', '/dir5/dir6')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It appears you have a list of predefined "buckets" that you want to use as boundaries for the records inside the string.</p>
<p>That means, the easiest way to match these key-value pairs is by matching one of the buckets, then a colon and then <em>any chars not starting a sequence of chars equal to those bucket names</em>.</p>
<p>You may use</p>
<pre><code>r"(BUCKET1|BUCKET2):(.*?)(?=(?:BUCKET1|BUCKET2)|$)"
</code></pre>
<p>Compile with <code>re.S</code> / <code>re.DOTALL</code> if your values span across multiple lines. See the <a href="https://regex101.com/r/L1lhr6/1" rel="nofollow noreferrer">regex demo</a>.</p>
<p><strong>Details</strong>:</p>
<ul>
<li><code>(BUCKET1|BUCKET2)</code> - capture group one that matches and stores in <code>.group(1)</code> any of the bucket names</li>
<li><code>:</code> - a colon</li>
<li><code>(.*?)</code> - any 0+ chars, as few as possible  (as <code>*?</code> is a lazy quantifier), up to the first occurrence of (but not inlcuding)...</li>
<li><code>(?=(?:BUCKET1|BUCKET2)|$)</code> - any of the bucket names or end of string.</li>
</ul>
<p>Build it dynamically while escaping bucket names (just to play it safe in case those names contain <code>*</code> or <code>+</code> or other special chars):</p>
<pre><code>import re
buckets = ['BUCKET1','BUCKET2']
rx = r"({0}):(.*?)(?=(?:{0})|$)".format("|".join([re.escape(bucket) for bucket in buckets]))
print(rx)
s = "BUCKET1:/dir1/dir2/BUCKET1:/dir3/dir4/BUCKET2:/dir5/dir6"
print(re.findall(rx, s))
# =&gt; (BUCKET1|BUCKET2):(.*?)(?=(?:BUCKET1|BUCKET2)|$)
     [('BUCKET1', '/dir1/dir2/'), ('BUCKET1', '/dir3/dir4/'), ('BUCKET2', '/dir5/dir6')]
</code></pre>
<p>See the <a href="https://ideone.com/oJohS0" rel="nofollow noreferrer">online Python demo</a>.</p>
</div>
<span class="comment-copy">You cant have a dict with 2 of the same key(BUCKET1)</span>
<span class="comment-copy">You should post the actual requirements, add the details about bucket names to the question. If you have them as a list, please provide the list in the question.</span>
<span class="comment-copy">You seem to need a regex like <a href="https://ideone.com/nHcn2d" rel="nofollow noreferrer"><code>r"(BUCKET1|BUCKET2):(.*?)(?=(?:BUCKET1|BUCKET2)|$)"</code> to use with <code>re.findall</code></a>.</span>
<span class="comment-copy">What if instead of BUCKET1, BUCKET2 etc, I have distinct names, such as: Adrian, Roman, etc? How would I be able to split it that way?</span>
<span class="comment-copy">@AdrianDanielCulea, you should specify the exact rules for <b>keys</b> and values. For ex.: keys should start with uppercase OR contain only uppercase letters, <b>values</b> should consist of lowercase letters or other characters. Define some rules</span>
<span class="comment-copy">Don't forget <code>import re</code>!</span>
<span class="comment-copy">I don't have control over this. All I know is that all the BUCKETS (whatever name they have) are before " : ", that's it. I would want to be able to split by whatever is before " : "</span>
<span class="comment-copy">@FelixBuechner, I never forget to import it. It's implied</span>
<span class="comment-copy">What if instead of BUCKET1, BUCKET2 etc, I have distinct names for these buckets, such as Adrian, Ashish etc. How would I be able to split it that way?</span>
<span class="comment-copy">You will have to modify the <code>[A-Z0-9]+</code> part to capture the bucket names correctly. You can use <a href="http://pythex.org" rel="nofollow noreferrer">pythex.org</a> for checking your regex.</span>
