<div class="post-text" itemprop="text">
<p>I want to lock part of the method (the part after "Waiting to acquire lock" should only run after the first thread has released the lock). What happens is that both threads run independently regardless of lock.acquire(). </p>
<p>I cant figure out why this doesn't work. The examples here in stackoverflow are similar but not quite like this one. Just a glimpse on why I need this: I don't have an explicit shared resource, I just want to prevent 2 python threads from running the same code since, in the system i'm working on, they could potentially put the system in an unstable state.</p>
<pre><code>import threading, time

def test(name):
    lock = threading.Lock()

    print(name + " - Starting thread")
    print(name + " - Waiting to acquire lock")
    lock.acquire(True)
    try:
        print(name + " - Lock acquired!")
        for i in range(10):

            print(name + " - " + str(i))
            print("")
            time.sleep(1)
    finally:
        lock.release()
        print(name + " - Lock released")

def main():

    t1 = threading.Thread(target=test, args=["#1_Thread"])
    t2 = threading.Thread(target=test, args=["#2_Thread"])

    t1.start()
    time.sleep(3)
    t2.start()

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The lock object you create, is local to your function so it is not shared : </p>
<pre><code>lock = threading.Lock()
</code></pre>
<p>Define your lock as global, and it will be shared</p>
<pre><code>import threading, time
lock = threading.Lock()

def test(name):
    global lock

    print(name + " - Starting thread")
    print(name + " - Waiting to acquire lock")
    lock.acquire(True)
    try:
        print(name + " - Lock acquired!")
        for i in range(10):

            print(name + " - " + str(i))
            print("")
            time.sleep(1)
    finally:
        lock.release()
        print(name + " - Lock released")

def main():

    t1 = threading.Thread(target=test, args=["#1_Thread"])
    t2 = threading.Thread(target=test, args=["#2_Thread"])

    t1.start()
    time.sleep(3)
    t2.start()

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your threads each create and lock their own independent lock:</p>
<pre><code>def test(name):
    lock = threading.Lock()
    ...
</code></pre>
<p>That won't provide mutual exclusion. Two threads can lock different locks at the same time without conflict; locks only do anything when two threads try to lock the <em>same</em> lock.</p>
<p>Create one lock and provide it to both threads. While you're at it, a <code>with</code> statement is usually a cleaner way to ensure cleanup than a <code>finally</code> block. <a href="https://docs.python.org/3/library/threading.html#with-locks" rel="nofollow noreferrer">That'll lock the lock when execution enters the <code>with</code> and unlock it when execution leaves</a>:</p>
<pre><code>import threading, time

def test(name, lock):
    print(name + " - Starting thread")
    print(name + " - Waiting to acquire lock")
    with lock:
        print(name + " - Lock acquired!")
        for i in range(10):

            print(name + " - " + str(i))
            print("")
            time.sleep(1)
    print(name + " - Lock released")

def main():
    lock = threading.Lock()

    t1 = threading.Thread(target=test, args=["#1_Thread", lock])
    t2 = threading.Thread(target=test, args=["#2_Thread", lock])

    t1.start()
    time.sleep(3)
    t2.start()

main()
</code></pre>
</div>
<span class="comment-copy">What is 'it doesn't work'? Describe what happens, what you expect to happen and how they're different.</span>
<span class="comment-copy">The lock is not "on the stack". Python as a language doesn't have a concept of objects being on the stack, and CPython as an implementation doesn't allocate objects on the stack.</span>
<span class="comment-copy">Rather than making the lock global, it would likely be better to provide the lock to the threads as an argument, to avoid global state.</span>
<span class="comment-copy">Two downvotes, i'd like to know at least why, as this works ?</span>
<span class="comment-copy">@user2357112, Python has reentrant functions with local variables that are stored in activation records, and the activation records within any single thread are created and destroyed in strict LIFO order.  Even if some particular implementation of Python does not happen to store the activation records on the processor's <i>hardware call stack</i>, they're still effectively on a stack.  When people say "on the stack" that's practically always a synonym for "in a (possibly hidden) local variable."</span>
<span class="comment-copy">@user2357112, avoiding global state generally is good advice, but there's a lot of value in keeping answers as simple as possible.  Global state makes programs difficult to test and difficult to re-use, but it's really easy for beginners to understand.</span>
<span class="comment-copy">downvoting the first answer to get credits after, it is kind of lame</span>
<span class="comment-copy">@loopingz: Wasn't me, and the downvotes certainly couldn't <i>both</i> have been me.</span>
<span class="comment-copy">agreed but one was, then using a global or an argument is just a matter of preference, at the end you should use object and store the lock somewhere else but the question was simply why it doesnt work</span>
<span class="comment-copy">@loopingz no, it's not a matter of preference. Your explanation was poor and the global thing is awful, especially when dealing with concurrency, but awful in general when parameter passing will do the job better. There are dozens of beginner questions on SO daily with needless convoluted global state, examples in answers that avoid it are useful to learners.</span>
