<div class="post-text" itemprop="text">
<p>In Python, I'd like to get the variable to which an object is being assigned to. Something like: </p>
<pre><code>class Parent(object):

    def __init__(self):
        print(???) # Print the variable to which the created instance of 
                   # Parent has been assigned to. 

p = Parent() # This should print 'p'. 
</code></pre>
<p>I have come up with this: </p>
<pre><code>import inspect


class Parent(object):

    def __init__(self):
        print((inspect.stack()[-1].code_context[-1].split()[0]))


p = Parent()
</code></pre>
<p>which, if I understand correctly, literally looks at the outermost call and there takes the left string part, which happens to be the variable - but to me this looks weird. Is there a better way? </p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you <em>can</em> do it, using both <code>inspect</code> and <code>ast</code> to parse the source code which you can find using <code>inspect.stack()</code>.</p>
<p>Note that your solution prints <code>"__main__",</code> for me, and I'm testing on Python 3.5.2, so the answer might be slightly different for other Python versions.</p>
<pre class="lang-python prettyprint-override"><code>import inspect
import ast

class Parent(object):

    def __init__(self):
        frame = inspect.stack()[1]
        # Parse python syntax of the assignment line
        st = ast.parse(frame.code_context[0].strip())
        stmt = st.body[0]
        # Assume class being instanced as simple assign statement
        assert(isinstance(stmt, ast.Assign))
        # Parse the target the class is assigned to
        target = stmt.targets[0]
        print(target.id) # prints "p"

p = Parent()
</code></pre>
<p>This only works for simple assign statements. If you have a more complex assign statement, say <code>p, n = Parent(), 0</code>, you will need to add more steps to parsing the AST. In principle, all valid statements involving <code>Parent()</code> can be parsed, but in some cases there is no assignment involved (e.g. <code>Parser()</code>).</p>
<p>The code listed above can therefore only serve as an example how to approach the problem, not as a complete solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot get the instance name within the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer"><code>__init__</code></a> method(in a regular way)<sup>1</sup>. Because the <code>__init__</code> method called right after the instance has been created by <code>__new__()</code> and then, python returned the created object to the caller. That means python maps the variable name to the object within the global namespace.</p>
<p>Nevertheless, one way to get around this problem is defining another method for your object in order to get the instance name after initialization. You can use <code>globals()</code> built-in function for this aim:</p>
<pre><code>In [5]: class Parent:
            def __init__(self):
                pass
            def get_instance_names(self):
                names = [i for i,j in globals().items() if isinstance(j, type(self))]
                if names:
                    return names
   ...:         
</code></pre>
<p>DEMO: </p>
<pre><code>In [6]: a = Parent()

In [7]: a.get_instance_names()
Out[7]: ['a']

In [8]: a = b = c = Parent()

In [9]: a.get_instance_names()
Out[9]: ['c', 'a', 'b']
</code></pre>
<hr/>
<p><sub>
1. Actually depends on the environment that you're executing your code in, it might be different, but you might be able to extract the variable by parsing the executed lines of the source code or maybe in lower levels like looking at the stack but it's not a proper and save way at all while you can simply get the names from an upper level like global namespace.
</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>For the various reasons presented, that is not ordinarily feasible. It is doubly unfeasible in the <code>__init__</code> or other class initialization method, since the object is not ready yet - only when it is initialization is complete, the new object will be returned to the calling context and (possibly) assigned to a variable.</p>
<p>But in Python, as you can see, "unfeasible" differs from "impossible" - you and some of the answers have ways to find it out that involve parsing teh source code file, to find where the assignment is taking place, and thus, guess the name.</p>
<p>You didn't tell <em>why</em> you want this, but this looks mostly <em>useless</em>  for anything I can think of.  The variable an object is assigned too is of little use at runtime - and either way, it is known.</p>
<p>So, if you check, in the stdlib itself you have namedtuple, and ohf course, class creation itself, both of which require one to pass the name explicitly on creation:</p>
<pre><code>myclass = type("myclass", (object, ), {})
mytuple = collections.namedtuple("mytuple", "a b c")
</code></pre>
<p>If you can know the name <em>after</em> the object has been created and assigned, there are ways that can retrieve it by inspecting either the calling frames or using the garbage collection mechanism - they would be a little better than your hack as they don't depend on the source code file being available. </p>
<p>But them, again, I'd recommend against that in "production" code.  Just to mention, the way using "gc" is to call "gc.get_referrers". You can put your "name finding" in a method, or even a property doing something along:</p>
<pre><code>import gc
class Parent(object):
    @property
    def get_names(self):
        names = []
        for referrer in gc.get_referrers(self):
            if not isinstance(referrer, dict):
                continue
            module = referrer.get("__name__", "")
            for key, value in referrer.items():
                if value is self:
                    names.append(".".join((module, key)))
        return names
</code></pre>
<p>The other way is checking the globals dict in the caller code-frame, but then, you'd get the name of "self" in the code that called <code>get_names</code> instead of where the instance was defined.</p>
<p>But again, I've ever only wanted something like this for class attributes - then you have three possible ways of assigning the name as an attribute on the instance of <code>Parent</code> itself: at the metaclass <code>__new__</code> or <code>__init__</code> methods, and, from Python 3.6 on, at the base class of classes containing instances of "Parent" as attributes <code>__init_subclass__</code> method,  or, if your <code>Parent</code> class is  a descriptor (i.e., does have a <code>__get__</code> method), in which case, also from Python 3.6 on, it can have a  <code>__set_name__</code> method that will be called at the (container) class creation time.</p>
</div>
<span class="comment-copy">What should the output be if you do <code>a = b = c = Parent()</code>? What should the output be if you do <code>Parent()</code> with no assignment?</span>
<span class="comment-copy">or a tuple assignment or code where's no assignment?  let's get back to the basics.. why on earth are you doing this?</span>
<span class="comment-copy">Unless this is for pure curiosity, why do you want to do that in the first place?</span>
<span class="comment-copy">Your solution prints <code>"__main__",</code>, not <code>"p"</code>, for my Python 3.5.2 interpreter.</span>
<span class="comment-copy">@KarolyHorvath answered "no assignment" in reply to Kevin; tuple assignment or something of the nature should likely return the relevant object, but I haven't really thought of this, so thanks for the comment!</span>
<span class="comment-copy">Yes, this works for me. Basically, I gather the simple answer is "parse it out of the source code". Thanks!</span>
<span class="comment-copy">@Zubo I can't think of any other way. For a partial explanation why this is so, see Noctis Skytower's answer: The information isn't really stored anywhere besides the source code at the time of calling the <code>__init__</code> method.</span>
<span class="comment-copy">Do you <i>want</i> the variable name?? What for? Or do you want to find assignments to attributes inside classes, (which would be far more useful)? If the later there are clean ways of getting it, instead of the hacks collection in the answers here.</span>
<span class="comment-copy">@jsbueno Maybe I'm misunderstanding it, but I think the OP's question was for the variable name, <code>p</code>. While the <i>attributes inside classes</i> thing might be useful to other people, it's clearly a totally different question. Why do you assume that it isn't useful just because you haven't found a use for it? Do you know how many answers I found on SO that I wouldn't have categorized as useful-as-is before encountering the underlaying problem? Sure it would be nice to know the underlying problem here, but then it likely won't be a clear question any more.</span>
<span class="comment-copy">@jsbueno You won't hear any complaints from me for adding a new answer with a new approach ;-)</span>
<span class="comment-copy">A call to <code>globals()</code> will return th e global variables of the module here the clas is created. The correct is <code>inspect.stack()[-1].frame.f_globals or rather, </code>sys._getframe().f_back.f_globals`  (way faster) instead of a call to <code>globals()</code></span>
<span class="comment-copy">This looks interesting, but 1) as you wrote, doesn't seem to work from <code>__init__</code> and 2) if I understand correctly, earlier instance names (if we instantiated the class earlier) will also be returned, which isn't what we were looking for.</span>
<span class="comment-copy">@jsbueno Yes, I think this not incorrect though. As I mentioned it depends on the way that OP is executing the code, like if it's in a terminal or a file.</span>
<span class="comment-copy">@Zubo Why do you want it to work in <code>__init__</code>?</span>
<span class="comment-copy">@Kasramvd I agree in it not being incorrect and it might be a useful answer for similar questions (plus, it's a different approach to the problem, which is great!). Yet the OP is pretty much right in that not being a real answer to the question due to not being callable in <code>__init__</code> plus the possible issue that you have to filter instances in some way.</span>
