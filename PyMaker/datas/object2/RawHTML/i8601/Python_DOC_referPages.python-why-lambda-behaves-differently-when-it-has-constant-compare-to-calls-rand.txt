<div class="post-text" itemprop="text">
<p>I probably don't understand python's lambda very much. So it confuses me evry time. For example if I have this simple lambda construction with constant, everything works perfect:</p>
<pre><code>&gt;&gt;&gt; f = lambda max,x=0:[ x for x in iter(lambda: x+0.5,max+1.) if x&lt;max ]
&gt;&gt;&gt; f(10)
[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5]
</code></pre>
<p>But if I substitute  random number generator instead of constant 0.5, it would stuck and never returns back....</p>
<pre><code>&gt;&gt;&gt; f = lambda max,x=0:[ x for x in iter(lambda: x+random.random(),max+1.) if x&lt;max ]
&gt;&gt;&gt; f(10)
</code></pre>
<p>Why?! And what to do to avoid it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are some ways to achieve what you want. First, some code-golf:</p>
<pre><code>def f(stop): 
    return itertools.takewhile(functools.partial(operator.gt, stop), itertools.accumulate(iter(random.random, object())))
</code></pre>
<p>I'll leave you to deciphering that as an exercise (a great way to explore itertools!). And also as a good lesson on why you shouldn't write cryptic one-liners...</p>
<p>However, I would probably just do:</p>
<pre><code>In [5]: def increase_random(stop, start=0):
    ...:     start += random.random()
    ...:     while start &lt; stop:
    ...:         yield start
    ...:         start += random.random()
    ...:
</code></pre>
<p>See how much more readable and straight-forward that is? 6 months from now, I'll re-read that and know exactly what I was trying to do.</p>
<p>Here it is in action:</p>
<pre><code>In [7]: list(increase_random(5))
Out[7]:
[0.442800767759875,
 1.4148173965715438,
 1.7683959590284435,
 2.116245564487893,
 2.832867264471769,
 3.684055219689638,
 3.986469894067608,
 4.617838198100095]

In [8]: list(increase_random(5))
Out[8]:
[0.5851100455307873,
 1.3248041125729781,
 2.275952338784795,
 2.539203591128045,
 2.7563520512088835,
 3.259124317278677,
 4.1641913798928805,
 4.77771351014472]

In [9]: list(increase_random(10))
Out[9]:
[0.4226041227598847,
 1.0816534967326379,
 1.1540685081566209,
 1.6987578052795809,
 2.118172344169681,
 2.5349681976516156,
 3.137101744986478,
 3.1436528694585766,
 3.455139268185562,
 3.7614777591407975,
 4.072603396579612,
 4.71137983138932,
 5.01309327918888,
 5.098769083492201,
 5.858553103139947,
 5.950601116127209,
 5.956983974085873,
 5.967975512928789,
 6.090114835094137,
 6.105296749316677,
 6.329459825745162,
 6.825175725633318,
 7.738665256248604,
 8.409407710225171,
 9.202163699315623,
 9.497148670699866,
 9.839990622387328,
 9.977297575005993]
</code></pre>
<p>OK, here is a reward for reading this far... the one-liner works thusly:</p>
<p><code>itertools.takewhile</code> takes a function and an iterable. The <code>takewhile</code> will yield from the iterable as long as the function returns <code>True</code>. The function I use is <code>functools.partial(operator.gt, stop)</code>, which is the partial-application of the <code>operator.gt</code>, <code>op.gt(a, b)</code> is equivalent to <code>a &gt; b</code>, so we take while <code>stop</code> is greater than the value returned by the iteterable. Finally, the iterable is <code>itertools.accumulate(iter(random.random, object())</code>. <code>accumulate</code> (only on Python 3) takes an iterable and keeps adding the iterables values to it... i.e. accumulating. So, e.g:</p>
<pre><code>In [10]: list(itertools.accumulate([1, 2, 3, 4]))
Out[10]: [1, 3, 6, 10]
</code></pre>
<p>The iterable I pass to <code>accumulate</code> is <code>iter(random.random, object())</code> which just calls random.random until the value is <code>== object()</code>, which is <em>never</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>iter(lambda: x+0.5,max+1.)</code> stops when the <code>lambda</code> function returns <strong>exactly</strong> <code>max+1.</code>. The function does return <code>max+1.</code>, so the iterator stops there, but that could have gone differently by a fluke of floating-point rounding.</p>
<p><code>iter(lambda: x+random.random(),max+1.)</code> only stops if the <code>lambda</code> function returns exactly <code>max+1.</code>, but this time, it is extremely unlikely that the function will ever return that value. Your list comprehension filters iterator elements forever.</p>
<hr/>
<p>Note that both of your code snippets rely on Python 2 list comprehension variable scope behavior, where the <code>x</code> in the comprehension's <code>for</code> clause is the same as the <code>x</code> from the function the comprehension appears in. That changed in Python 3, so neither of your code snippets work on Python 3.</p>
</div>
<span class="comment-copy">Because <code>iter(callable, sentinal)</code> will only stop if <code>sentinal</code> is returned <i>exactly</i>. Probably, in this case you <i>miss</i> and it keeps going on forever. This is dangerous to do with floating point numbers in general, let alone random ones. This has <i>nothing</i> to do with <code>lambda</code>, and indeed, you shouldn't be using a lambda function here at all.</span>
<span class="comment-copy">No need to wrap <code>random.random</code> in a <code>lambda</code>.</span>
<span class="comment-copy">And instead of the <code>partial</code> you could use <code>float(stop).__gt__</code>, though the fact that I had to convert to <code>float</code> somewhat shows that <code>partial</code> might be the better choice...</span>
<span class="comment-copy">@stefanpochmann Yeah good point about <code>random.random</code>. I think the lands wrapper was leftover from  a my earlier attempts. I don't like using dunder methods directly, so I use <code>operator</code></span>
<span class="comment-copy">@rth because  <code>iter(random.random, object())</code> is an infinite iterator. Just because the condition in the or statement of the comprehension is failing past a certain point doesn't mean the list comprehension will stop iterating over it. And stop wrapping things in <code>lambda</code>s like that. if you are going to assign the function to a name, e.g. <code>f = lambda...</code> then you should just use a full function definition. In fact, that is part of the official style guide, PEP8.</span>
<span class="comment-copy">@rth Yeah, it's only available on Python 3, but it's easy to implement. Indeed, the <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">Python 3 docs</a> have an equivalent Python implementation.</span>
<span class="comment-copy">Yeah, it's relying on the <code>x</code> from the <code>for</code> clause is being bound to the free-variable in the <code>lambda</code> in <code>iter</code>. Had to scratch my head for a bit.</span>
<span class="comment-copy">Thank you, Sorry if it is too unpythonian code. I'm just trying to work around the problem and nothing works. :(</span>
<span class="comment-copy">@rth use <code>lambda start, step, stop: itertools.takewhile(functools.partial(operator.gt, stop), itertools.count(start, step))</code></span>
<span class="comment-copy">@juanpa.arrivillaga That doesn't have randomness.</span>
<span class="comment-copy">@juanpa.arrivillaga I challenge you to actually do it :-). I had already tried that and came across a problem I couldn't easily fix.</span>
