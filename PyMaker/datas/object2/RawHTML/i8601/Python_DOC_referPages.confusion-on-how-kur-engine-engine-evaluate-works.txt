<div class="post-text" itemprop="text">
<p><strong>The problem</strong></p>
<p>There seems to be a conflict on the use of <code>kur.engine.Engine._evaluate</code>. </p>
<p>When I ran <code>kur dump mnist.yml</code> under <code>kur/example/</code> directory, and look inside the running details, I got: </p>
<p><a href="https://i.stack.imgur.com/a0ATH.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/a0ATH.png"/></a></p>
<p>However, when I ran <code>eng = kur.engine.Engine()</code> and then <code>eng._evaluate('mnist-defaults.yml')</code>, I got the following error: </p>
<p><a href="https://i.stack.imgur.com/sGh20.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/sGh20.png"/></a></p>
<p><strong>What does the source code say?</strong></p>
<p>My reading of this function doc:
1. take a string as arg named expression
2. return an python object or class</p>
<p>My reading of this code:
1. I give the function a string arg
2. it returns an error named 'Not Implemented Error'</p>
<pre><code>def _evaluate(self, expression):
    """ Evaluates a string expression in the current scope.

        # Arguments

        expression: str. The string to evaluate.

        # Return value

        The evaluated expression (some Python object/class)
    """
    # pdb.set_trace()
    raise NotImplementedError
</code></pre>
<p>However, in fact it works as the doc says when run in console <code>kur dump mnist.yml</code>. So, where my understanding went wrong?  Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Engine</code> is an <a href="https://docs.python.org/3/glossary.html#term-abstract-base-class" rel="nofollow noreferrer">abstract base class</a>. This means that it is <strong>not</strong> intended to be directly instantiated. Instead, its derived classes use the base class as a "template" (so-to-speak) for extending its functionality. This is a classic pattern in <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_concrete" rel="nofollow noreferrer">object-oriented programming</a>, especially in languages like Java and C++. Python is an extremely flexible language, though, and there are lots of ways to accomplish similar design patterns (e.g., the <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">abc</a> module, duck-typing, or classic inheritance plus good documentation and <code>NotImplementedError</code>).</p>
<p>In your particular case, when you actually run Kur, the instantiated (run-time) type of your engine is <em>not</em> <code>Engine</code>; it's <code>JinjaEngine</code>. So when the <code>_evaluate()</code> call is made, it is actually the <code>JinjaEngine</code> which is handling it, not the base class (which, as you correctly point out, raises an exception). Try instantiating a <code>JinjaEngine</code> instead, and you should get the expected results.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on @ajsyp comment above: </p>
<blockquote>
<p>You definitely are instantiating Engine, which, being an abstract base class, shouldn't be done. When Kur is actually running, or if you want to get the intended behavior, then instantiate a JinjaEngine instead. Abstract base classes are a way of saying, "This is how this type of objects acts" without actually creating one of the objects; instead, derived classes are responsible for implementing the behavior of the base class. It's a standard OOP pattern</p>
</blockquote>
<p>If I understand it correctly, when running <code>kur -vv build mnist.yml</code> and when I use logger to display the functions at work under <code>kur.Kurfile.parse_source</code>, I noticed a few things below:</p>
<pre><code>[INFO 2017-04-11 14:05:05,946 kur.kurfile parse:97] (self): after initialize Kurfile object, we parse it: 1. evaluate all section dicts in spec.data with scopes; 2. as a result, spec.data added section aliases (like training, testing);3. other uses here to be answered ....; 4. assign spec.data['templates'] to spec.templates; 3. convert spec.data['model'] into model as containers, and store the list of containers inside spec.contaienrs ; 5. return Nothing
[INFO 2017-04-11 14:05:05,946 kur.kurfile _parse_section:1006]
[DEBUG 2017-04-11 14:05:05,946 kur.kurfile _parse_section:1011] _parse_section(): Parsing Kurfile section: settings
[INFO 2017-04-11 14:05:05,947 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,947 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,947 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,947 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,947 kur.kurfile _parse_section:1006]
[DEBUG 2017-04-11 14:05:05,947 kur.kurfile _parse_section:1011] _parse_section(): Parsing Kurfile section: train
[INFO 2017-04-11 14:05:05,947 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,948 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,949 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,949 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,950 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,950 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,951 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,951 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,951 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,951 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,952 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,952 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
[INFO 2017-04-11 14:05:05,952 kur.engine.jinja_engine _evaluate:123] (self, expression): convert a yml expression (a string) to a python object
[INFO 2017-04-11 14:05:05,953 kur.engine.engine evaluate:209] (self, expression, recursive=False): Evaluates an string expression in the current scope, as itself: (how does scope help evaluate expression? Not sure how is scope used); if expression is not a string, then do some recursion.
</code></pre>
<ol>
<li>when codes run at <code>kur.Kurfile.parse</code>, it parses on different sections like <code>settings</code>, <code>train</code>, <code>validate</code> ...</li>
<li>when doing <code>kur.Kurfile._parse_section</code>, most section require to run a lot of <code>kur.engine.engine.Engine.evaluate</code> and a few if not none of <code>kur.engine.jinjiaEngine.JinjaEngine._evaluate</code></li>
</ol>
<p>Should I understand the comment and the observations in the following way: </p>
<ol>
<li><code>kur.engine.engine.Engine.evaluate</code>, <code>kur.engine.engine.Engine._evaluate</code> are base class methods, practically I don't need to understand the inside of them; is it right?</li>
<li><code>kur.engine.jinja_engine.JinjaEngine._evaluate</code> is the derived method from the base methods above, I need to understand its practical meaning for it; is it right?</li>
<li>my understanding of <code>kur.engine.jinja_engine.JinjaEngine._evaluate</code>: it is to convert a yaml string expression to a python object. Is it correct? </li>
</ol>
<p>If not, could you explain with an example? (don't have to be working code, just an example we can picture in the mind would be ok too)</p>
<p>Thanks</p>
<hr/>
<p>@ajsyp further answers and explanations are very helpful</p>
<blockquote>
<p>1.) All of the functions defined in the <code>Engine</code> class are, by definition, base-class methods. <em>This does <strong>not</strong> imply that they are not important.</em> They are incredibly important! To be specific, <code>Engine.evaluate()</code> actually does work, trying to figure out how to process your data, what types it is, if recursion is necessary, etc. And <code>Engine._evaluate</code> defines the API that the derived classes must implement (although, from a pure code standpoint, <code>Engine._evaluate()</code> does not <strong>do</strong> anything, since its job is to define the API, and all implementation is delegated to the derived classes).
  2.) Yes, <code>JinjaEngine._evaluate()</code> is a derived class method. In this particular case, it implements the logic defined by the parent class's API.
  3.) Kind of. <code>JinjaEngine._evaluate()</code> is responsible for using the current values of the Kurfile to evaluate a Jinja2 expression (not a YAML expression; the YAML parser already did that; in fact, you could have used a JSON Kurfile instead, and this entire answer is still true). The evaluated result of the Jinja2 expression is a string representation of a Python expression. So the function also needs to interpret that string, if necessary, to construct the underlying Python type (e.g., the integer 4 versus the string "4").</p>
</blockquote>
</div>
<span class="comment-copy">Can I understand it in the following practically, using the example I asked above?   1. when running from console, it is <code>kur.engine.Engine._evaluate()</code> working under the hood, return <code>mnist.yml</code>, even though in source it only has one line of code <code>raise NotImplementedError</code> (without understanding why so)  2. when running from ipython, I have to use <code>kur.engine.JinjaEngine()._evaluate()</code> to get result <code>mnist.yml</code>.</span>
<span class="comment-copy">Sort of, yes. You definitely are instantiating <code>Engine</code>, which, being an abstract base class, shouldn't be done. When Kur is actually running, or if you want to get the intended behavior, then instantiate a <code>JinjaEngine</code> instead. Abstract base classes are a way of saying, "This is how this type of objects acts" without actually creating one of the objects; instead, derived classes are responsible for implementing the behavior of the base class. It's a standard OOP pattern.</span>
