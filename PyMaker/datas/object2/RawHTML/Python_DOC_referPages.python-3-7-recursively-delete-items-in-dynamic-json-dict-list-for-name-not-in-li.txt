<div class="post-text" itemprop="text">
<p>Here's a sample of one file that I want to epurate some keys, I wanted to know what is the best way to remove the keys that are not in my "keep-list"</p>
<pre><code>{"address":"item/address","data":{"set1":{"sub_ref1":0,"sub_ref2":1550620800,"sub_ref3":false,"sub_ref4":false},"set2":[{"sub_ref1":1550534400,"sub_ref2":0,"sub_ref3":0.0,"sub_ref4":0.0,"sub_ref5":"D"}],"set3":[{"sub_ref1":1550534400,"sub_ref2":7,"sub_ref3":5}]},"info":"test","id":190800005945008523}
{"address":"item/address","data":{"set1":{"sub_ref1":0,"sub_ref2":1550620800,"sub_ref3":true,"sub_ref4":false},"set2":[{"sub_ref1":1550534400,"sub_ref2":0,"sub_ref3":0.0,"sub_ref4":0.0,"sub_ref5":"D"}],"set3":[{"sub_ref1":1550534400,"sub_ref2":8,"sub_ref3":6}]},"info":"test","id":190800005945008632}
</code></pre>
<p>The keys that I want to keep are referenced as follow:</p>
<pre><code>address
data.set1.sub_ref2
data.set1.sub_ref4
data.set3
id
</code></pre>
<p>As the different files have a complex JSON architecture what would be the best way to process ?</p>
<p>I've already done the part where I check that the keys match the one in the file and add the list length if there is one in the path.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this does what you want:</p>
<pre><code>import json

# Loads a JSON document keeping only the given keys
def load_json_with_keys(json_data, keys):
    # Load JSON document
    d = json.loads(json_data)
    # Make recursive call to delete unnecessary keys
    keys = [k.split('.') for k in keys]
    if isinstance(d, dict):
        _delete_extra_keys_rec(d, keys, [])
    if isinstance(d, list):
        for elem in d:
            _delete_extra_keys_rec(elem, keys, [])
    return d

# Recursively deletes unnecessary keys
def _delete_extra_keys_rec(d, keys, current):
    level = len(current) + 1
    # Iterates over list of keys
    # It is important to use list(...) to make a snapshot of the keys
    # before any deletion
    for k in list(d.keys()):
        # Add child key to current key
        current.append(k)
        # Look for a key to maintain matching the current partial key
        for ks in keys:
            if current != ks[:level]: continue
            # Maching key found - this child is kept
            # If the matching key is not complete
            if len(ks) &gt; level:
                # Delete recursively in child
                child = d[k]
                if isinstance(child, dict):
                    _delete_extra_keys_rec(child, keys, current)
                if isinstance(child, list):
                    for elem in child:
                        _delete_extra_keys_rec(elem, keys, current)
            break
        else:
            # No matching key found - this child is deleted
            del d[k]
        # Remove child key
        current.pop()

dict1 = '{"address":"item/address","data":{"set1":{"sub_ref1":0,"sub_ref2":1550620800,"sub_ref3":false,"sub_ref4":false},"set2":[{"sub_ref1":1550534400,"sub_ref2":0,"sub_ref3":0.0,"sub_ref4":0.0,"sub_ref5":"D"}],"set3":[{"sub_ref1":1550534400,"sub_ref2":7,"sub_ref3":5}]},"info":"test","id":190800005945008523}'
dict2 = '{"address":"item/address","data":{"set1":{"sub_ref1":0,"sub_ref2":1550620800,"sub_ref3":true,"sub_ref4":false},"set2":[{"sub_ref1":1550534400,"sub_ref2":0,"sub_ref3":0.0,"sub_ref4":0.0,"sub_ref5":"D"}],"set3":[{"sub_ref1":1550534400,"sub_ref2":8,"sub_ref3":6}]},"info":"test","id":190800005945008632}'
keys = [
    'address',
    'data.set1.sub_ref2',
    'data.set1.sub_ref4',
    'data.set3',
    'id',
    'data.set2.sub_ref2',
]

print(load_json_with_keys(dict1, keys))
# {'address': 'item/address', 'data': {'set1': {'sub_ref2': 1550620800, 'sub_ref4': False}, 'set2': [{'sub_ref2': 0}], 'set3': [{'sub_ref1': 1550534400, 'sub_ref2': 7, 'sub_ref3': 5}]}, 'id': 190800005945008523}
print(load_json_with_keys(dict2, keys))
# {'address': 'item/address', 'data': {'set1': {'sub_ref2': 1550620800, 'sub_ref4': False}, 'set2': [{'sub_ref2': 0}], 'set3': [{'sub_ref1': 1550534400, 'sub_ref2': 8, 'sub_ref3': 6}]}, 'id': 190800005945008632}
</code></pre>
<p>There are some potentially undesirable corner cases. For example, in you example, if the object contains a dict with key <code>data.set1</code> which does not contain a <code>sub_ref2</code> or <code>sub_ref4</code> key, that dict is still kept, even if there is no full match for any of the full keys it is part of. Depending on the case, this may be a the desired behavior or not.</p>
</div>
<span class="comment-copy">Hi, thanks for the answer, it is almost the exact way I want it to work, but if you try to add on the "keep-list": data.set2.sub_ref2 you will see that all the object is kept. FYI: the output json has to be the exact same architecture than the original one, so the fact that the empty dict is kept is perfect !</span>
<span class="comment-copy">@Inroma Right, I didn't realize about the lists, I changed that. The problem I'm noticing is that for example for <code>data.set3</code>, since there are no further subkeys, all of its children are deleted. I'm not sure if that is the desired behavior or that is supposed to mean "<code>data.set3</code> and all of its children".</span>
<span class="comment-copy">@Inroma I've changed it so <code>data.set3</code> is kept with all of its children which I think was the intended behavior.</span>
<span class="comment-copy">Thanks, that is the exact way it has to work, sorry for the lack of details, i'm still a newbie in Python, list comprehension are not extremly clear for me. After few edit to adapt to my code it works like a charm, thanks a lot !</span>
