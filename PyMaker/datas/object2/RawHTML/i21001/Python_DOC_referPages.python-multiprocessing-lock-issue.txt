<div class="post-text" itemprop="text">
<p>I want to add a list of dicts together with python multiprocessing module.</p>
<p>Here is a simplified version of my code:</p>
<pre><code>#!/usr/bin/python2.7
# -*- coding: utf-8 -*-

import multiprocessing
import functools
import time

def merge(lock, d1, d2):
    time.sleep(5) # some time consuming stuffs
    with lock:
        for key in d2.keys():
            if d1.has_key(key):
                d1[key] += d2[key]
            else:
                d1[key] = d2[key]

l = [{ x % 10 : x } for x in range(10000)]
lock = multiprocessing.Lock()
d = multiprocessing.Manager().dict()

partial_merge = functools.partial(merge, d1 = d, lock = lock)

pool_size = multiprocessing.cpu_count()
pool = multiprocessing.Pool(processes = pool_size)
pool.map(partial_merge, l)
pool.close()
pool.join()

print d
</code></pre>
<ol>
<li><p>I get this error when running this script. How shall I resolve this?</p>
<p><code>RuntimeError: Lock objects should only be shared between processes through inheritance</code> </p></li>
<li><p>is the <code>lock</code> in <code>merge</code> function needed in this condition? or python will take care of it?</p></li>
<li><p>I think what's <code>map</code> supposed to do is to map something from one list to another list, not dump all things in one list to a single object. So is there a more elegant way to do such things? </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The following should run cross-platform (i.e. on Windows, too) in both Python 2 and 3. It uses a process pool initializer to set the manager dict as a global in each child process. </p>
<p>FYI:</p>
<ul>
<li>Using a lock is unnecessary with a manager dict. </li>
<li>The number of processes in a <code>Pool</code> defaults to the CPU count. </li>
<li>If you're not interested in the result, you can use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" rel="nofollow"><code>apply_async</code></a> instead of <code>map</code>. </li>
</ul>
<pre class="lang-python prettyprint-override"><code>import multiprocessing
import time

def merge(d2):
    time.sleep(1) # some time consuming stuffs
    for key in d2.keys():
        if key in d1:
            d1[key] += d2[key]
        else:
            d1[key] = d2[key]

def init(d):
    global d1
    d1 = d

if __name__ == '__main__':

    d1 = multiprocessing.Manager().dict()
    pool = multiprocessing.Pool(initializer=init, initargs=(d1, ))

    l = [{ x % 5 : x } for x in range(10)]

    for item in l:
        pool.apply_async(merge, (item,))

    pool.close()
    pool.join()

    print(l)
    print(d1)
</code></pre>
</div>
