<div class="post-text" itemprop="text">
<p>How to do <code>assert almost equal</code> with py.test for floats without resorting to something like:</p>
<pre><code>assert x - 0.00001 &lt;= y &lt;= x + 0.00001
</code></pre>
<p>More specifically it will be useful to know a neat solution for quickly compare pairs of float, without unpacking them:</p>
<pre><code>assert (1.32, 2.4) == i_return_tuple_of_two_floats()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I noticed that this question specifically asked about py.test. py.test 3.0 includes an <code>approx()</code> function (well, really class) that is very useful for this purpose.</p>
<pre class="lang-py prettyprint-override"><code>import pytest

assert 2.2 == pytest.approx(2.3)
# fails, default is Â± 2.3e-06
assert 2.2 == pytest.approx(2.3, 0.1)
# passes

# also works the other way, in case you were worried:
assert pytest.approx(2.3, 0.1) == 2.2
# passes
</code></pre>
<p>The documentation is here: <a href="https://docs.pytest.org/en/latest/reference.html#pytest-approx" rel="noreferrer">https://docs.pytest.org/en/latest/reference.html#pytest-approx</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You will have to specify what is "almost" for you:</p>
<pre><code>assert abs(x-y) &lt; 0.0001
</code></pre>
<p>to apply to tuples (or any sequence):</p>
<pre><code>def almost_equal(x,y,threshold=0.0001):
  return abs(x-y) &lt; threshold

assert all(map(almost_equal, zip((1.32, 2.4), i_return_tuple_of_two_floats())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have access to NumPy it has great functions for floating point comparison that already do pairwise comparison with <a href="https://docs.scipy.org/doc/numpy/reference/routines.testing.html" rel="nofollow noreferrer"><code>numpy.testing</code></a>.</p>
<p>Then you can do something like:</p>
<pre><code>numpy.testing.assert_allclose(i_return_tuple_of_two_floats(), (1.32, 2.4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like</p>
<pre><code>assert round(x-y, 5) == 0
</code></pre>
<p>That is what <a href="http://docs.python.org/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="noreferrer">unittest</a> does</p>
<p>For the second part</p>
<pre><code>assert all(round(x-y, 5) == 0 for x,y in zip((1.32, 2.4), i_return_tuple_of_two_floats()))
</code></pre>
<p>Probably better to wrap that in a function</p>
<pre><code>def tuples_of_floats_are_almost_equal(X, Y):
    return all(round(x-y, 5) == 0 for x,y in zip(X, Y))

assert tuples_of_floats_are_almost_equal((1.32, 2.4), i_return_tuple_of_two_floats())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These answers have been around for a long time, but I think the easiest and also most readable way is to use unittest for it's <a href="https://docs.python.org/3.5/library/unittest.html#assert-methods" rel="noreferrer">many nice assertions</a> without using it for the testing structure.</p>
<h1>Get assertions, ignore rest of unittest.TestCase</h1>
<p>(based on <a href="https://stackoverflow.com/a/18084492/377366">this answer</a>)</p>
<pre><code>import unittest

assertions = unittest.TestCase('__init__')
</code></pre>
<h1>Make some assertions</h1>
<pre><code>x = 0.00000001
assertions.assertAlmostEqual(x, 0)  # pass
assertions.assertEqual(x, 0)  # fail
# AssertionError: 1e-08 != 0
</code></pre>
<h1>Implement original questions' auto-unpacking test</h1>
<p>Just use * to unpack your return value without needing to introduce new names.</p>
<pre><code>i_return_tuple_of_two_floats = lambda: (1.32, 2.4)
assertions.assertAlmostEqual(*i_return_tuple_of_two_floats())  # fail
# AssertionError: 1.32 != 2.4 within 7 places
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd use nose.tools. It plays well with py.test runner and have other equally useful asserts - assert_dict_equal(), assert_list_equal(), etc.</p>
<pre><code>from nose.tools import assert_almost_equals
assert_almost_equals(x, y, places=7) #default is 7 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want something that works not only with floats but for example Decimals you can use python's <code>math.isclose</code>:</p>
<pre class="lang-py prettyprint-override"><code>    # - rel_tol=0.01` is 1% difference tolerance.
    assert math.isclose(actual_value, expected_value, rel_tol=0.01)
</code></pre>
<p>Docs - <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="nofollow noreferrer">https://docs.python.org/3/library/math.html#math.isclose</a></p>
</div>
<span class="comment-copy">py.test now has a feature that does this.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/a/39623614/5353461">this answer</a> for a description of that feature</span>
<span class="comment-copy">Nice! Also found it works for sequences of numbers too e.g. <code>assert [0.1 + 0.2, 0.2 + 0.4] == pytest.approx([0.3, 0.6])</code></span>
<span class="comment-copy">@Mr Kriss And even for dicts: <code>assert {'a': 0.1+0.2} == pytest.approx({'a': 0.3})</code></span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">This doesn't work for lists of lists: for example, <code>assert [[0.1 + 0.2], [0.2 + 0.4]] == pytest.approx([[0.3], [0.6]])</code> leads to a <code>TypeError</code>. If found that Numpy's <code>np.testing.assert_allclose([[0.1 + 0.2], [0.2 + 0.4]], [[0.3], [0.6]])</code> (see answer below) did work for this case.</span>
<span class="comment-copy">The question asks how to do it "without resorting to something like" this</span>
<span class="comment-copy">I interpret "something like this" as a repetitive and awkward expression like <code>x - d &lt;= y &lt;= x+d</code>, seems like that's what OP meant as well. If you don't wish to explicitly specify the threshold for 'almost', see @jiffyclub's answer.</span>
<span class="comment-copy">py.test now has a feature that does this. I've added an answer discussing it.</span>
<span class="comment-copy">please delete this answer as it's out of date.</span>
<span class="comment-copy">@NeilG Why on earth should this be deleted?  If there's something obviously wrong with it please explain what it is.</span>
<span class="comment-copy">Besides pytest has an option for this I don't consider a good option add an extra depency (in this case, a whole testing framwork) only for this.</span>
<span class="comment-copy">Here relative tolerance (or percentage difference) is convenient to use in some use cases, e.g. scienfific.</span>
<span class="comment-copy">This is the best answer.</span>
