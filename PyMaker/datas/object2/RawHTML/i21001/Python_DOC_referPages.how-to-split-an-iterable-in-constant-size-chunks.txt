<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Possible Duplicate:</strong><br/>
<a href="https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python">How do you split a list into evenly sized chunks in Python?</a> </p>
</blockquote>
<p>I am surprised I could not find a "batch" function that would take as input an iterable and return an iterable of iterables.</p>
<p>For example:</p>
<pre><code>for i in batch(range(0,10), 1): print i
[0]
[1]
...
[9]
</code></pre>
<p>or:</p>
<pre><code>for i in batch(range(0,10), 3): print i
[0,1,2]
[3,4,5]
[6,7,8]
[9]
</code></pre>
<p>Now, I wrote what I thought was a pretty simple generator:</p>
<pre><code>def batch(iterable, n = 1):
   current_batch = []
   for item in iterable:
       current_batch.append(item)
       if len(current_batch) == n:
           yield current_batch
           current_batch = []
   if current_batch:
       yield current_batch
</code></pre>
<p>But the above does not give me what I would have expected:</p>
<pre><code>for x in   batch(range(0,10),3): print x
[0]
[0, 1]
[0, 1, 2]
[3]
[3, 4]
[3, 4, 5]
[6]
[6, 7]
[6, 7, 8]
[9]
</code></pre>
<p>So, I have missed something and this probably shows my complete lack of understanding of python generators. Anyone would care to point me in the right direction ?</p>
<p>[Edit: I eventually realized that the above behavior happens only when I run this within ipython rather than python itself]</p>
</div>
<div class="post-text" itemprop="text">
<p>This is probably more efficient (faster)</p>
<pre><code>def batch(iterable, n=1):
    l = len(iterable)
    for ndx in range(0, l, n):
        yield iterable[ndx:min(ndx + n, l)]

for x in batch(range(0, 10), 3):
    print x
</code></pre>
<p>It avoids building new lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>FWIW, the <a href="http://docs.python.org/library/itertools.html#recipes">recipes in the itertools module</a> provides this example:</p>
<pre><code>def grouper(n, iterable, fillvalue=None):
    "grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)
</code></pre>
<p>It works like this:</p>
<pre><code>&gt;&gt;&gt; list(grouper(3, range(10)))
[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have noted, the code you have given does exactly what you want.  For another approach using <code>itertools.islice</code> you could see an <a href="http://code.activestate.com/recipes/303279-getting-items-in-batches/" rel="noreferrer">example</a> of following recipe:</p>
<pre><code>from itertools import islice, chain

def batch(iterable, size):
    sourceiter = iter(iterable)
    while True:
        batchiter = islice(sourceiter, size)
        yield chain([batchiter.next()], batchiter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Weird, seems to work fine for me in Python 2.x</p>
<pre><code>&gt;&gt;&gt; def batch(iterable, n = 1):
...    current_batch = []
...    for item in iterable:
...        current_batch.append(item)
...        if len(current_batch) == n:
...            yield current_batch
...            current_batch = []
...    if current_batch:
...        yield current_batch
...
&gt;&gt;&gt; for x in batch(range(0, 10), 3):
...     print x
...
[0, 1, 2]
[3, 4, 5]
[6, 7, 8]
[9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what I use in my project. It handles iterables or lists as efficiently as possible.</p>
<pre class="lang-py prettyprint-override"><code>def chunker(iterable, size):
    if not hasattr(iterable, "__len__"):
        # generators don't have len, so fall back to slower
        # method that works with generators
        for chunk in chunker_gen(iterable, size):
            yield chunk
        return

    it = iter(iterable)
    for i in range(0, len(iterable), size):
        yield [k for k in islice(it, size)]


def chunker_gen(generator, size):
    iterator = iter(generator)
    for first in iterator:

        def chunk():
            yield first
            for more in islice(iterator, size - 1):
                yield more

        yield [k for k in chunk()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This would work for any iterable. </p>
<pre><code>from itertools import zip_longest, filterfalse

def batch_iterable(iterable, batch_size=2): 
    args = [iter(iterable)] * batch_size 
    return (tuple(filterfalse(lambda x: x is None, group)) for group in zip_longest(fillvalue=None, *args))
</code></pre>
<p>It would work like this:</p>
<pre><code>&gt;&gt;&gt;list(batch_iterable(range(0,5)), 2)
[(0, 1), (2, 3), (4,)]
</code></pre>
<p>PS: It would not work if iterable has None values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an approach using <code>reduce</code> function.</p>
<p>Oneliner:</p>
<pre><code>from functools import reduce
reduce(lambda cumulator,item: cumulator[-1].append(item) or cumulator if len(cumulator[-1]) &lt; batch_size else cumulator + [[item]], input_array, [[]])
</code></pre>
<p>Or more readable version:</p>
<pre><code>from functools import reduce
def batch(input_list, batch_size):
  def reducer(cumulator, item):
    if len(cumulator[-1]) &lt; batch_size:
      cumulator[-1].append(item)
      return cumulator
    else:
      cumulator.append([item])
    return cumulator
  return reduce(reducer, input_list, [[]])
</code></pre>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; batch([1,2,3,4,5,6,7], 3)
[[1, 2, 3], [4, 5, 6], [7]]
&gt;&gt;&gt; batch(a, 8)
[[1, 2, 3, 4, 5, 6, 7]]
&gt;&gt;&gt; batch([1,2,3,None,4], 3)
[[1, 2, 3], [None, 4]]
</code></pre>
</div>
<span class="comment-copy">Good question, well written, but it already exists and will solve your problem.</span>
<span class="comment-copy">IMO this isn't really a duplicate. The other question focuses on lists instead of iterators, and most of those answers require len() which is undesirable for iterators. But eh, the currently accepted answer here also requires len(), so...</span>
<span class="comment-copy">This is clearly not a duplicate. The other Q&amp;A <i>only works for lists</i>, and this question is about generalizing to all iterables, which is exactly the question I had in mind when I came here.</span>
<span class="comment-copy">@JoshSmeaton @casperOne this is not a duplicate and the accepted answer is not correct.  The linked duplicate question is for list and this is for iterable. list provides len() method but iterable does not provide a len() method and the answer would be different without using len()  This is the correct answer:  <code>batch = (tuple(filterfalse(lambda x: x is None, group)) for group in zip_longest(fillvalue=None, *[iter(iterable)] * n))</code></span>
<span class="comment-copy">@TrideepRath yep, I've voted to reopen.</span>
<span class="comment-copy">For the record, this is the fastest solution I found: mine = 4.5s, yours=0.43s, Donkopotamus = 14.8s</span>
<span class="comment-copy">your batch in fact accepts a list (with len()), not iterable (without len())</span>
<span class="comment-copy">This is faster because it isn't a solution to the problem. The grouper recipe by Raymond Hettinger - currently below this - is what you are looking for for a general solution that doesn't require the input object to have a <b>len</b> method.</span>
<span class="comment-copy">Why you use min()? Without <code>min()</code> code is completely correct!</span>
<span class="comment-copy"><a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">Iterables</a> don't have <code>len()</code>, <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">sequences</a> have <code>len()</code></span>
<span class="comment-copy">This is not exactly what I needed since it pads the last element with a set of None. i.e., None is a valid value in the data I actually use with my function so what I need instead is something that does not pad the last entry.</span>
<span class="comment-copy">@mathieu Replace <code>izip_longest</code> with <code>izip</code>, which will not pad the last entries, but instead cut off entries when some of the elements start running out.</span>
<span class="comment-copy">Should be zip_longest/zip in python 3</span>
<span class="comment-copy">@PeterGerdes Unless the input iterable already has some exploitable structure (i.e. reshaping a numpy array), this solution should be near optimal even for big chunk sizes.  It runs at C-speed calling the iterator to fill-in tuple elements as fast as possible, and it reuses the output tuple whenever possible.</span>
<span class="comment-copy">@GoogieK <code>for x, y in enumerate(grouper(3, xrange(10))): print(x,y)</code> does indeed not fill values, it just drops the incomplete segment altogether.</span>
<span class="comment-copy">Can we yield <code>batchiter</code> itself instead of a chain of it ?</span>
<span class="comment-copy">@abhilash No ... this code uses the call to <code>next()</code> to cause a <code>StopIteration</code> once <code>sourceiter</code> is exhausted, thus terminating the iterator.  Without the call to <code>next</code> it would continue to return empty iterators indefinitely.</span>
<span class="comment-copy">I had to replace <code>batchiter.next()</code> with <code>next(batchiter)</code> to make the above code work in Python 3.</span>
<span class="comment-copy">pointing out a comment from the linked article: "You should add a warning that a batch has to be entirely consumed before you can proceed to the next one." The output of this should be consumed with something like: <code>map(list, batch(xrange(10), 3))</code>. Doing: <code>list(batch(xrange(10), 3)</code> will produce unexpected results.</span>
<span class="comment-copy">This works in Python 3 as well.</span>
