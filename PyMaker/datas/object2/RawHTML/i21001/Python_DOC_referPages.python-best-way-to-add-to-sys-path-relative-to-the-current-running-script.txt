<div class="post-text" itemprop="text">
<p>I have a directory full of scripts (let's say <code>project/bin</code>). I also have a library located in <code>project/lib</code> and want the scripts to automatically load it. This is what I normally use at the top of each script:</p>
<pre><code>#!/usr/bin/python
from os.path import dirname, realpath, sep, pardir
import sys
sys.path.append(dirname(realpath(__file__)) + sep + pardir + sep + "lib")

# ... now the real code
import mylib
</code></pre>
<p>This is kind of cumbersome, ugly, and has to be pasted at the beginning of every file. Is there a better way to do this?</p>
<p>Really what I'm hoping for is something as smooth as this:</p>
<pre><code>#!/usr/bin/python
import sys.path
from os.path import pardir, sep
sys.path.append_relative(pardir + sep + "lib")

import mylib
</code></pre>
<p>Or even better, something that wouldn't break when my editor (or someone else who has commit access) decides to reorder the imports as part of its clean-up process:</p>
<pre><code>#!/usr/bin/python --relpath_append ../lib
import mylib
</code></pre>
<p>That wouldn't port directly to non-posix platforms, but it would keep things clean.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to edit each file</p>
<ul>
<li>Install you library like a normal python libray<br/>
or</li>
<li>Set <code>PYTHONPATH</code> to your <code>lib</code></li>
</ul>
<p>or if you are willing to add a single line to each file, add a import statement at top e.g.</p>
<pre><code>import import_my_lib
</code></pre>
<p>keep <code>import_my_lib.py</code> in bin and <code>import_my_lib</code> can correctly set the python path to whatever <code>lib</code> you want</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what I use:</p>
<pre><code>import os, sys
sys.path.append(os.path.join(os.path.dirname(__file__), "lib"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm using: </p>
<pre><code>import sys,os
sys.path.append(os.getcwd())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a wrapper module <code>project/bin/lib</code>, which contains this:</p>
<pre><code>import sys, os

sys.path.insert(0, os.path.join(
    os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'lib'))

import mylib

del sys.path[0], sys, os
</code></pre>
<p>Then you can replace all the cruft at the top of your scripts with:</p>
<pre><code>#!/usr/bin/python
from lib import mylib
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to change the script content in any ways, prepend the current working directory <code>.</code> to $PYTHONPATH (see example below)</p>
<pre><code>PYTHONPATH=.:$PYTHONPATH alembic revision --autogenerate -m "First revision"
</code></pre>
<p>And call it a day!</p>
</div>
<div class="post-text" itemprop="text">
<p>Using python 3.4+<br/>
<sub><em>Barring the use of cx_freeze or using in IDLE.</em> ðŸ˜ƒ </sub></p>
<pre><code>import sys
from pathlib import Path

sys.path.append(Path(__file__).parent / "lib")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a problem with every answer provided that can be summarized as "just add this magical incantation to the beginning of your script. See what you can do with just a line or two of code." <strong>They will not work in every possible situation!</strong></p>
<p>For example, one such magical incantation uses <strong>file</strong>. Unfortunately, if you package your script using cx_Freeze or you are using IDLE, this will result in an exception.</p>
<p>Another such magical incantation uses os.getcwd(). This will only work if you are running your script from the command prompt and the directory containing your script is the current working directory (that is you used the cd command to change into the directory prior to running the script). Eh gods! I hope I do not have to explain why this will not work if your Python script is in the PATH somewhere and you ran it by simply typing the name of your script file.</p>
<p>Fortunately, there is a magical incantation that will work in all the cases I have tested. Unfortunately, the magical incantation is more than just a line or two of code.</p>
<pre><code>import inspect
import os
import sys

# Add script directory to sys.path.
# This is complicated due to the fact that __file__ is not always defined.

def GetScriptDirectory():
    if hasattr(GetScriptDirectory, "dir"):
        return GetScriptDirectory.dir
    module_path = ""
    try:
        # The easy way. Just use __file__.
        # Unfortunately, __file__ is not available when cx_freeze is used or in IDLE.
        module_path = __file__
    except NameError:
        if len(sys.argv) &gt; 0 and len(sys.argv[0]) &gt; 0 and os.path.isabs(sys.argv[0]):
            module_path = sys.argv[0]
        else:
            module_path = os.path.abspath(inspect.getfile(GetScriptDirectory))
            if not os.path.exists(module_path):
                # If cx_freeze is used the value of the module_path variable at this point is in the following format.
                # {PathToExeFile}\{NameOfPythonSourceFile}. This makes it necessary to strip off the file name to get the correct
                # path.
                module_path = os.path.dirname(module_path)
    GetScriptDirectory.dir = os.path.dirname(module_path)
    return GetScriptDirectory.dir

sys.path.append(os.path.join(GetScriptDirectory(), "lib"))
print(GetScriptDirectory())
print(sys.path)
</code></pre>
<p>As you can see, this is no easy task!</p>
</div>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/2349991/python-how-to-import-other-python-files/20749411#20749411" title="python how to import other python files">stackoverflow.com/questions/2349991/â€¦</a></span>
<span class="comment-copy">I would do sys.path.insert(0, ..) so that it doesn't get overridden by other paths.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#the-module-search-path</a> says: " sys.path is initialized from these locations: -The directory containing the input script ". I think this is not true.</span>
