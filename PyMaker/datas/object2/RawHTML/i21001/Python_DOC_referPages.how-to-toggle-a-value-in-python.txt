<div class="post-text" itemprop="text">
<p>What is the most efficient way to toggle between <code>0</code> and <code>1</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Solution using NOT</h2>
<p>If the values are boolean, the fastest approach is to use the <em><a href="http://docs.python.org/reference/expressions.html#boolean-operations" rel="noreferrer">not</a></em> operator:</p>
<pre><code>&gt;&gt;&gt; x = True
&gt;&gt;&gt; x = not x        # toggle
&gt;&gt;&gt; x
False
&gt;&gt;&gt; x = not x        # toggle
&gt;&gt;&gt; x
True
&gt;&gt;&gt; x = not x        # toggle
&gt;&gt;&gt; x
False
</code></pre>
<h2>Solution using subtraction</h2>
<p>If the values are numerical, then subtraction from the total is a simple and fast way to toggle values:</p>
<pre><code>&gt;&gt;&gt; A = 5
&gt;&gt;&gt; B = 3
&gt;&gt;&gt; total = A + B
&gt;&gt;&gt; x = A
&gt;&gt;&gt; x = total - x    # toggle
&gt;&gt;&gt; x
3
&gt;&gt;&gt; x = total - x    # toggle
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = total - x    # toggle
&gt;&gt;&gt; x
3
</code></pre>
<h2>Solution using XOR</h2>
<p>If the value toggles between <em>0</em> and <em>1</em>, you can use a <a href="https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types" rel="noreferrer">bitwise exclusive-or</a>:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; x ^= 1
&gt;&gt;&gt; x
0
&gt;&gt;&gt; x ^= 1
&gt;&gt;&gt; x
1
</code></pre>
<p>The technique generalizes to any pair of integers.  The xor-by-one step is replaced with a xor-by-precomputed-constant:</p>
<pre><code>&gt;&gt;&gt; A = 205
&gt;&gt;&gt; B = -117
&gt;&gt;&gt; t = A ^ B        # precomputed toggle constant
&gt;&gt;&gt; x = A
&gt;&gt;&gt; x ^= t           # toggle
&gt;&gt;&gt; x
-117
&gt;&gt;&gt; x ^= t           # toggle
&gt;&gt;&gt; x
205
&gt;&gt;&gt; x ^= t           # toggle
&gt;&gt;&gt; x
-117
</code></pre>
<p>(This idea was submitted by Nick Coghlan and later generalized by @zxxc.)</p>
<h2>Solution using a dictionary</h2>
<p>If the values are hashable, you can use a dictionary:</p>
<pre><code>&gt;&gt;&gt; A = 'xyz'
&gt;&gt;&gt; B = 'pdq'
&gt;&gt;&gt; d = {A:B, B:A}
&gt;&gt;&gt; x = A
&gt;&gt;&gt; x = d[x]         # toggle
&gt;&gt;&gt; x
'pdq'
&gt;&gt;&gt; x = d[x]         # toggle
&gt;&gt;&gt; x
'xyz'
&gt;&gt;&gt; x = d[x]         # toggle
&gt;&gt;&gt; x
'pdq'
</code></pre>
<h2>Solution using a conditional expression</h2>
<p>The slowest way is to use a <a href="http://docs.python.org/reference/expressions.html#conditional-expressions" rel="noreferrer">conditional expression</a>:</p>
<pre><code>&gt;&gt;&gt; A = [1,2,3]
&gt;&gt;&gt; B = [4,5,6]
&gt;&gt;&gt; x = A
&gt;&gt;&gt; x = B if x == A else A
&gt;&gt;&gt; x
[4, 5, 6]
&gt;&gt;&gt; x = B if x == A else A
&gt;&gt;&gt; x
[1, 2, 3]
&gt;&gt;&gt; x = B if x == A else A
&gt;&gt;&gt; x
[4, 5, 6]
</code></pre>
<h2>Solution using itertools</h2>
<p>If you have more than two values, the <a href="http://docs.python.org/2.7/library/itertools.html#itertools.cycle" rel="noreferrer">itertools.cycle()</a> function provides a generic fast way to toggle between successive values:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; toggle = itertools.cycle(['red', 'green', 'blue']).next
&gt;&gt;&gt; toggle()
'red'
&gt;&gt;&gt; toggle()
'green'
&gt;&gt;&gt; toggle()
'blue'
&gt;&gt;&gt; toggle()
'red'
&gt;&gt;&gt; toggle()
'green'
&gt;&gt;&gt; toggle()
'blue'
</code></pre>
<p>Note that in Python 3 the <code>next()</code> method was changed to <code>__next__()</code>, so the first line would be now written as <code>toggle = itertools.cycle(['red', 'green', 'blue']).__next__</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I always use:</p>
<pre><code>p^=True
</code></pre>
<p>If p is a boolean, this switches between true and false.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another non intuitive way. The beauty is you can cycle over multiple values and not just two [0,1]</p>
<p>For Two values (toggling)</p>
<pre><code>&gt;&gt;&gt; x=[1,0]
&gt;&gt;&gt; toggle=x[toggle]
</code></pre>
<p>For Multiple Values (say 4)</p>
<pre><code>&gt;&gt;&gt; x=[1,2,3,0]
&gt;&gt;&gt; toggle=x[toggle]
</code></pre>
<p>I didn't expect this solution to be almost the fastest too</p>
<pre><code>&gt;&gt;&gt; stmt1="""
toggle=0
for i in xrange(0,100):
    toggle = 1 if toggle == 0 else 0
"""
&gt;&gt;&gt; stmt2="""
x=[1,0]
toggle=0
for i in xrange(0,100):
    toggle=x[toggle]
"""
&gt;&gt;&gt; t1=timeit.Timer(stmt=stmt1)
&gt;&gt;&gt; t2=timeit.Timer(stmt=stmt2)
&gt;&gt;&gt; print "%.2f usec/pass" % (1000000 * t1.timeit(number=100000)/100000)
7.07 usec/pass
&gt;&gt;&gt; print "%.2f usec/pass" % (1000000 * t2.timeit(number=100000)/100000)
6.19 usec/pass
stmt3="""
toggle = False
for i in xrange(0,100):
    toggle = (not toggle) &amp; 1
"""
&gt;&gt;&gt; t3=timeit.Timer(stmt=stmt3)
&gt;&gt;&gt; print "%.2f usec/pass" % (1000000 * t3.timeit(number=100000)/100000)
9.84 usec/pass
&gt;&gt;&gt; stmt4="""
x=0
for i in xrange(0,100):
    x=x-1
"""
&gt;&gt;&gt; t4=timeit.Timer(stmt=stmt4)
&gt;&gt;&gt; print "%.2f usec/pass" % (1000000 * t4.timeit(number=100000)/100000)
6.32 usec/pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>not</code> operator negates your variable (converting it into a boolean if it isn't already one). You can <em>probably</em> use <code>1</code> and <code>0</code> interchangeably with <code>True</code> and <code>False</code>, so just negate it:</p>
<pre><code>toggle = not toggle
</code></pre>
<p>But if you are using two arbitrary values, use an inline <code>if</code>:</p>
<pre><code>toggle = 'a' if toggle == 'b' else 'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just between 1 and 0, do this </p>
<pre><code>1-x 
</code></pre>
<p>x can take 1 or 0</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Trigonometric approach</strong>, just because <code>sin</code> and <code>cos</code> functions are cool.</p>
<p><a href="https://i.stack.imgur.com/XTxeJ.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/XTxeJ.png"/></a></p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; def generator01():
...     n=0
...     while True:
...         yield abs( int( math.cos( n * 0.5 * math.pi  ) ) )
...         n+=1
... 
&gt;&gt;&gt; g=generator01() 
&gt;&gt;&gt; g.next()
1
&gt;&gt;&gt; g.next()
0
&gt;&gt;&gt; g.next()
1
&gt;&gt;&gt; g.next()
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Surprisingly nobody mention good old division modulo 2:</p>
<pre><code>In : x = (x + 1)  % 2 ; x
Out: 1

In : x = (x + 1)  % 2 ; x
Out: 0

In : x = (x + 1)  % 2 ; x
Out: 1

In : x = (x + 1)  % 2 ; x
Out: 0
</code></pre>
<p>Note that it is equivalent to <code>x = x - 1</code>, but the advantage of modulo technique is that the size of the group or length of the interval can be bigger then just 2 elements, thus giving you a similar to round-robin interleaving scheme to loop over.</p>
<p>Now just for 2, toggling can be a bit shorter (using bit-wise operator): </p>
<pre><code>x = x ^ 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>one way to toggle is by using Multiple assignment</p>
<pre><code>&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = 3

&gt;&gt;&gt; t = a, b = b, a
&gt;&gt;&gt; t[0]
3

&gt;&gt;&gt; t = a, b = b, a
&gt;&gt;&gt; t[0]
5
</code></pre>
<p>Using itertools:</p>
<pre><code>In [12]: foo = itertools.cycle([1, 2, 3])

In [13]: next(foo)
Out[13]: 1

In [14]: next(foo)
Out[14]: 2

In [15]: next(foo)
Out[15]: 3

In [16]: next(foo)
Out[16]: 1

In [17]: next(foo)
Out[17]: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to toggle between 1 and 0 is to subtract from 1.</p>
<pre><code>def toggle(value):
    return 1 - value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Using exception handler</strong></p>
<pre><code>&gt;&gt;&gt; def toogle(x):
...     try:
...         return x/x-x/x
...     except  ZeroDivisionError:
...         return 1
... 
&gt;&gt;&gt; x=0
&gt;&gt;&gt; x=toogle(x)
&gt;&gt;&gt; x
1
&gt;&gt;&gt; x=toogle(x)
&gt;&gt;&gt; x
0
&gt;&gt;&gt; x=toogle(x)
&gt;&gt;&gt; x
1
&gt;&gt;&gt; x=toogle(x)
&gt;&gt;&gt; x
0
</code></pre>
<p>Ok, I'm the worst:</p>
<p><a href="https://i.stack.imgur.com/uKqgQ.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/uKqgQ.png"/></a></p>
<pre><code>import math
import sys

d={1:0,0:1}
l=[1,0]

def exception_approach(x):
    try:
        return x/x-x/x
    except  ZeroDivisionError:
        return 1

def cosinus_approach(x):
    return abs( int( math.cos( x * 0.5 * math.pi  ) ) )

def module_approach(x):
    return  (x + 1)  % 2

def subs_approach(x):
    return  x - 1

def if_approach(x):
    return 0 if x == 1 else 1

def list_approach(x):
    global l
    return l[x]

def dict_approach(x):
    global d
    return d[x]

def xor_approach(x):
    return x^1

def not_approach(x):
    b=bool(x)
    p=not b
    return int(p)

funcs=[ exception_approach, cosinus_approach, dict_approach, module_approach, subs_approach, if_approach, list_approach, xor_approach, not_approach ]

f=funcs[int(sys.argv[1])]
print "\n\n\n", f.func_name
x=0
for _ in range(0,100000000):
    x=f(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about an <em>imaginary</em> toggle that stores not only the current toggle, but a couple other values associated with it?</p>
<pre><code>toggle = complex.conjugate
</code></pre>
<p>Store any + or - value on the left, and any unsigned value on the right: </p>
<pre><code>&gt;&gt;&gt; x = 2 - 3j
&gt;&gt;&gt; toggle(x)
(2+3j)
</code></pre>
<p>Zero works, too:</p>
<pre><code>&gt;&gt;&gt; y = -2 - 0j
&gt;&gt;&gt; toggle(y)
(-2+0j)
</code></pre>
<p>Easily retrieve the current toggle value (<code>True</code> and <code>False</code> represent + and -), LHS (real) value, or RHS (imaginary) value:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; curr = lambda i: math.atan2(i.imag, -abs(i.imag)) &gt; 0
&gt;&gt;&gt; lhs = lambda i: i.real
&gt;&gt;&gt; rhs = lambda i: abs(i.imag)
&gt;&gt;&gt; x = toggle(x)
&gt;&gt;&gt; curr(x)
True
&gt;&gt;&gt; lhs(x)
2.0
&gt;&gt;&gt; rhs(x)
3.0
</code></pre>
<p>Easily swap LHS and RHS (but note that the sign of the both values must not be important):</p>
<pre><code>&gt;&gt;&gt; swap = lambda i: i/-1j
&gt;&gt;&gt; swap(2+0j)
2j
&gt;&gt;&gt; swap(3+2j)
(2+3j)
</code></pre>
<p>Easily swap LHS and RHS <em>and also</em> toggle at the same time:</p>
<pre><code>&gt;&gt;&gt; swaggle = lambda i: i/1j
&gt;&gt;&gt; swaggle(2+0j)
-2j
&gt;&gt;&gt; swaggle(3+2j)
(2-3j)
</code></pre>
<p>Guards against errors:</p>
<pre><code>&gt;&gt;&gt; toggle(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: descriptor 'conjugate' requires a 'complex' object but received a 'int'
</code></pre>
<p>Perform changes to LHS and RHS:</p>
<pre><code>&gt;&gt;&gt; x += 1+2j
&gt;&gt;&gt; x
(3+5j)
</code></pre>
<p>...but be careful manipulating the RHS:</p>
<pre><code>&gt;&gt;&gt; z = 1-1j
&gt;&gt;&gt; z += 2j
&gt;&gt;&gt; z
(1+1j) # whoops! toggled it!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use abs function, very useful on loops   </p>
<pre><code>x = 1
for y in range(0, 3):
    x = abs(x - 1)
</code></pre>
<p>x will be 0.</p>
</div>
<div class="post-text" itemprop="text">
<p>Variables a and b can be ANY two values, like 0 and 1, or 117 and 711, or "heads" and "tails".  No math is used, just a quick swap of the values each time a toggle is desired.</p>
<pre><code>a = True   
b = False   

a,b = b,a   # a is now False
a,b = b,a   # a is now True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's do some frame hacking. Toggle a variable by name. Note: This may not work with every Python runtime.</p>
<p>Say you have a variable "x"</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; def toggle(var_name):
&gt;&gt;&gt;     frame = inspect.currentframe().f_back
&gt;&gt;&gt;     vars = frame.f_locals
&gt;&gt;&gt;     vars[var_name] = 0 if vars[var_name] == 1 else 1

&gt;&gt;&gt; x = 0
&gt;&gt;&gt; toggle('x')
&gt;&gt;&gt; x
1
&gt;&gt;&gt; toggle('x')
&gt;&gt;&gt; x
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are dealing with an integer variable, you can increment 1 and limit your set to 0 and 1 (mod)</p>
<pre><code>X = 0  # or X = 1
X = (X + 1)%2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Switching between -1 and +1 can be obtained by inline multiplication; used for calculation of pi the 'Leibniz' way (or similar):</p>
<pre><code>sign = 1
result = 0
for i in range(100000):
    result += 1 / (2*i + 1) * sign
    sign *= -1
print("pi (estimate): ", result*4)
</code></pre>
</div>
<span class="comment-copy">The last example seems so slick and intuitive, but doesn't work in Python 3+ with the removal of .next().  Is there a way to make it work similarly in later version of python?</span>
<span class="comment-copy">@labarna In Python 3, the <code>.next()</code> has been replaced by a global <code>next()</code> function. The above example would be: <code>toggle = itertools.cycle(...); next(toggle)</code></span>
<span class="comment-copy"><code>toggle = itertools.cycle(['red', 'green', 'blue'])</code> <code>next(toggle)</code></span>
<span class="comment-copy">The XOR example can be generalised to toggle between values <code>a</code> and <code>b</code> using <code>x = x ^ (a ^ b)</code>.</span>
<span class="comment-copy"><code>int(not 0)</code> and <code>int(not 1)</code>...  hrmmm</span>
<span class="comment-copy">Perfect! <code>p</code> doesn't need to be referenced twice for this method to work!! Idea if you are toggling a value with a long long reference.</span>
<span class="comment-copy">what is this operator called?</span>
<span class="comment-copy">This is the XOR operator.</span>
<span class="comment-copy">@mix3d Precisely it is "bitwise exclusive or" (as opposed to "logical exclusive or") - <a href="https://wiki.python.org/moin/BitwiseOperators" rel="nofollow noreferrer">wiki.python.org/moin/BitwiseOperators</a>.  Logical XOR <a href="https://stackoverflow.com/q/432842/149428">doesn't have</a> a specific operator in Python in general but you can find it implemented <a href="https://docs.python.org/3/search.html?q=logical_xor" rel="nofollow noreferrer">in some special cases</a> like in the decimal module.</span>
<span class="comment-copy">yeah thats schweet as a nut. thanks everyone this is fun looking at how different people approach the problem (and informative.)</span>
<span class="comment-copy">Nice, it's a miniature state machine.</span>
<span class="comment-copy">well, your one is the most interesting, but its not what i personally need for the thing i was asking about, so ok, i think the simple math one then is probably the best for me, shouldnt that be 1-x there ?</span>
<span class="comment-copy">Yep, but that shouldn't make the speed any different.</span>
<span class="comment-copy">ai, but it would make it wrong though wouldnt it ? some great answers here, SO rocks!</span>
<span class="comment-copy">+1 but <code>toggle = 0 if toggle else 1</code> is shorter and more general</span>
<span class="comment-copy">Sorry, I'll swap variables to make it clearer. I was using the inline <code>if</code> to toggle between two <i>arbitrary</i> variables, not just <code>1</code> and <code>0</code>.</span>
<span class="comment-copy">ok thanks for clarification</span>
<span class="comment-copy">Since (in Python 2.x, anyway) <code>True</code> and <code>False</code> are actually integers, albeit ones with a surprisingly verbose <code>__str__()</code> method, <code>x</code> can also be <code>True</code> or <code>False</code> here. You'll get 1 or 0 back, though.</span>
<span class="comment-copy">Oh my god! I &lt;3 you.</span>
<span class="comment-copy">@RishabhAgrahari, yea man, I was the <a href="https://twitter.com/raymondh/status/887349008619810816" rel="nofollow noreferrer">Raymond Hettinger's challenge winner</a> ;)</span>
<span class="comment-copy">I am not sure how "pythonic" is this (C-like) modulo arithmetic (i,e, whether "pythonic" applies?). I guess it's just arithmetic, works everywhere else where you have binary.</span>
<span class="comment-copy">Obviously the finite-state-machine with tuple like x=(1,2,3,0); token=0;token=x[token] is extremely exciting, since it can be even more general than just group operation.</span>
