<div class="post-text" itemprop="text">
<p>If I have a list of strings for example:</p>
<pre><code>["car", "tree", "boy", "girl", "arc"...]
</code></pre>
<p>What should I do in order to find anagrams in that list? For example <code>(car, arc)</code>.
I tried using for loop for each string and I used <code>if</code> in order to ignore strings in different lengths but I can't get the right result. </p>
<p>How can I go over each letter in the string and compare it to others in the list in different order?</p>
<p>I have read several similar questions, but the answers were too advanced. I can't import anything and I can only use basic functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to do this for 2 strings you can do this:  </p>
<pre><code>def isAnagram(str1, str2):
    str1_list = list(str1)
    str1_list.sort()
    str2_list = list(str2)
    str2_list.sort()

    return (str1_list == str2_list)
</code></pre>
<p>As for the iteration on the list, it is pretty straight forward</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a dictionary of (sorted word, list of word). All the words that are in the same list are anagrams of each other.</p>
<pre><code>from collections import defaultdict

def load_words(filename='/usr/share/dict/american-english'):
    with open(filename) as f:
        for word in f:
            yield word.rstrip()

def get_anagrams(source):
    d = defaultdict(list)
    for word in source:
        key = "".join(sorted(word))
        d[key].append(word)
    return d

def print_anagrams(word_source):
    d = get_anagrams(word_source)
    for key, anagrams in d.iteritems():
        if len(anagrams) &gt; 1:
            print(key, anagrams)

word_source = load_words()
print_anagrams(word_source)
</code></pre>
<p>Or:</p>
<pre><code>word_source = ["car", "tree", "boy", "girl", "arc"]
print_anagrams(word_source)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to sort the word you're searching anagrams for (for example using <code>sorted</code>), sort the alternative and compare those.</p>
<p>So if you would be searching for anagrams of 'rac' in the list <code>['car', 'girl', 'tofu', 'rca']</code>, your code could look like this:</p>
<pre><code>word = sorted('rac')
alternatives = ['car', 'girl', 'tofu', 'rca']

for alt in alternatives:
    if word == sorted(alt):
        print alt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sort each element then look for duplicates. There's a built-in function for sorting so you do not need to import anything</p>
</div>
<div class="post-text" itemprop="text">
<p>There are multiple solutions to this problem:</p>
<ol>
<li><p><strong>Classic approach</strong></p>
<p>First, let's consider what defines an anagram: <strong><em>two words are anagrams of each other if they consist of the same set of letters and each letter appears exactly the same number or time in both words</em></strong>. This is basically a histogram of letters count of each word. This is a perfect use case for <code>collections.Counter</code> data structure (<a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">see docs</a>). The algorithms is as follows:</p>
<ul>
<li>Build a dictionary where keys would be histograms and values would be lists of words that have this histogram.</li>
<li>For each word build it's histogram and add it to the list that corresponds to this histogram.</li>
<li>Output list of dictionary values.</li>
</ul>
<p>Here is the code:</p>
<pre><code>from collections import Counter, defaultdict

def anagram(words):
    anagrams = defaultdict(list)
    for word in words:
        histogram = tuple(Counter(word).items()) # build a hashable histogram
        anagrams[histogram].append(word)
    return list(anagrams.values())

keywords = ("hi", "hello", "bye", "helol", "abc", "cab", 
                "bac", "silenced", "licensed", "declines")

print(anagram(keywords))
</code></pre>
<p>Note that constructing <code>Counter</code> is <code>O(l)</code>, while sorting each word is <code>O(n*log(l))</code> where l is the length of the word.</p></li>
<li><p><strong>Solving anagrams using prime numbers</strong></p>
<p>This is a more advanced solution, that relies on the "multiplicative uniqueness" of prime numbers. You can refer to this SO post: <a href="https://stackoverflow.com/q/13215789/2183102">Comparing anagrams using prime numbers</a>, and <a href="https://gist.github.com/icework/5223899" rel="nofollow noreferrer">here is a sample python implementation</a>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<pre><code>def findanagranfromlistofwords(li):
    dict = {}
    index=0
    for i in range(0,len(li)):
        originalfirst = li[index]
        sortedfirst = ''.join(sorted(str(li[index])))
        for j in range(index+1,len(li)):
            next = ''.join(sorted(str(li[j])))
            print next
            if sortedfirst == next:
                dict.update({originalfirst:li[j]})
                print "dict = ",dict
        index+=1

    print dict

findanagranfromlistofwords(["car", "tree", "boy", "girl", "arc"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solution in python can be as below:</p>
<pre><code>class Word:
    def __init__(self, data, index):
        self.data = data
        self.index = index

def printAnagrams(arr):
    dupArray = []
    size = len(arr)

    for i in range(size):
        dupArray.append(Word(arr[i], i))

    for i in range(size):
        dupArray[i].data = ''.join(sorted(dupArray[i].data))

    dupArray = sorted(dupArray, key=lambda x: x.data)

    for i in range(size):
        print arr[dupArray[i].index]

def main():
    arr = ["dog", "act", "cat", "god", "tac"]

    printAnagrams(arr)

if __name__== '__main__':
    main()
</code></pre>
<ol>
<li>First create a duplicate list of same words with indexes representing their position indexes.</li>
<li>Then sort the individual strings of the duplicate list </li>
<li>Then sort the duplicate list itself based on strings.</li>
<li>Finally print the original list with indexes used from duplicate array.</li>
</ol>
<p>The time complexity of above is O(NMLogN + NMLogM) = O(NMlogN)</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm using a dictionary to store each character of string one by one. Then iterate through second string and find the character in the dictionary, if it's present decrease the count of the corresponding key from dictionary.</p>
<pre><code>class Anagram:

    dict = {}

    def __init__(self):
        Anagram.dict = {}

    def is_anagram(self,s1, s2):
        print '***** starting *****'

        print '***** convert input strings to lowercase'
        s1 = s1.lower()
        s2 = s2.lower()

        for i in s1:
           if i not in Anagram.dict:
              Anagram.dict[i] = 1
           else:
              Anagram.dict[i] += 1

        print Anagram.dict

        for i in s2:
           if i not in Anagram.dict:
              return false
           else:
              Anagram.dict[i] -= 1

        print Anagram.dict

       for i in Anagram.dict.keys():
          if Anagram.dict.get(i) == 0:
              del Anagram.dict[i]

       if len(Anagram.dict) == 0:
         print Anagram.dict
         return True
       else:
         return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import collections

def find_anagrams(x):
    anagrams = [''.join(sorted(list(i))) for i in x]
    anagrams_counts = [item for item, count in collections.Counter(anagrams).items() if count &gt; 1]
    return [i for i in x if ''.join(sorted(list(i))) in anagrams_counts]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Simple Solution in Python</strong>:</p>
<pre><code>def anagram(s1,s2):

    # Remove spaces and lowercase letters
    s1 = s1.replace(' ','').lower()
    s2 = s2.replace(' ','').lower()

    # Return sorted match.
    return sorted(s1) == sorted(s2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This one is gonna help you:</p>
<p>Assuming input is given as comma separated strings</p>
<p>console input:
abc,bac,car,rac,pqr,acb,acr,abc</p>
<pre><code>in_list = list()
in_list = map(str, raw_input("Enter strings seperated by comma").split(','))
list_anagram = list()

for i in range(0, len(in_list) - 1):
    if sorted(in_list[i]) not in list_anagram:
        for j in range(i + 1, len(in_list)):
            isanagram = (sorted(in_list[i]) == sorted(in_list[j]))
            if isanagram:
                list_anagram.append(sorted(in_list[i]))
                print in_list[i], 'isanagram'
                break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most of previous answers are correct, here is another way to compare two strings.
The main benefit of using this strategy versus sort is space/time complexity which is <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">n log of n</a>. </p>
<p>1.Check the length of string</p>
<p>2.Build frequency Dictionary and compare if they both match then we have successfully identified anagram words</p>
<pre><code>def char_frequency(word):
    frequency  = {}
    for char in word:
        #if character  is in frequency then increment the value
        if char in frequency:
            frequency[char] += 1
        #else add character and set it to 1
        else:
            frequency[char] = 1
    return frequency 


a_word ='google'
b_word ='ooggle'
#check length of the words 
if (len(a_word) != len(b_word)):
   print ("not anagram")
else:
    #here we check the frequecy to see if we get the same
    if ( char_frequency(a_word) == char_frequency(b_word)):
        print("found anagram")
    else:
        print("no anagram")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works fine: </p>
<pre><code>
def find_ana(l):
    a=[]
    for i in range(len(l)):
        for j in range(len(l)): 
            if (l[i]!=l[j]) and (sorted(l[i])==sorted(l[j])):
                a.append(l[i])
                a.append(l[j])

    return list(set(a))

</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A set is an appropriate data structure for the output, since you presumably don't want redundancy in the output. A dictionary is ideal for looking up if a particular sequence of letters has been previously observed, and what word it originally came from. Taking advantage of the fact that we can add the same item to a set multiple times without expanding the set lets us get away with one for loop.</p>
<pre><code>def return_anagrams(word_list):
    d = {}
    out = set()
    for word in word_list:
        s = ''.join(sorted(word))
        try:
            out.add(d[s])
            out.add(word)
        except:
            d[s] = word
    return out
</code></pre>
<p>A faster way of doing it takes advantage of the commutative property of addition:</p>
<pre><code>import numpy as np

def vector_anagram(l):
    d, out = dict(), set()
    for word in l:
        s = np.zeros(26, dtype=int)
        for c in word:
            s[ord(c)-97] += 1
        s = tuple(s)
        try:
            out.add(d[s])
            out.add(word)
        except:
            d[s] = word
    return out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Calculate each word length. </li>
<li>Calculate each word ascii character sum.</li>
<li>Sort each word characters by their ascii values and set ordered word.</li>
<li>Group words according to their lengths.</li>
<li>For each group regroup list according to their ascii character sum.</li>
<li>For each small list check only words ordered. If ordered words same these words anagram.</li>
</ol>
<p>Here we have 1000.000 words list.
<a href="https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/10_million_password_list_top_1000000.txt" rel="nofollow">1000.000 words</a> </p>
<pre><code>    namespace WindowsFormsApplication2
    {
        public class WordDef
        {
            public string Word { get; set; }
            public int WordSum { get; set; }
            public int Length { get; set; }       
            public string AnagramWord { get; set; }
            public string Ordered { get; set; }
            public int GetAsciiSum(string word)
            {
                int sum = 0;
                foreach (char c in word)
                {
                    sum += (int)c;
                }
                return sum;
            }
        }
    }

    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Threading.Tasks;
    using System.Windows.Forms;

    namespace WindowsFormsApplication2
    {
        public partial class AngramTestForm : Form
        {
            private ConcurrentBag&lt;string&gt; m_Words;

            private ConcurrentBag&lt;string&gt; m_CacheWords;

            private ConcurrentBag&lt;WordDef&gt; m_Anagramlist;
            public AngramTestForm()
            {
                InitializeComponent();
                m_CacheWords = new ConcurrentBag&lt;string&gt;();
            }

            private void button1_Click(object sender, EventArgs e)
            {
                m_Words = null;
                m_Anagramlist = null;

                m_Words = new ConcurrentBag&lt;string&gt;();
                m_Anagramlist = new ConcurrentBag&lt;WordDef&gt;();

                if (m_CacheWords.Count == 0)
                {
                    foreach (var s in GetWords())
                    {
                        m_CacheWords.Add(s);
                    }
                }

                m_Words = m_CacheWords;

                Stopwatch sw = new Stopwatch();

                sw.Start();

                //DirectCalculation();

                AsciiCalculation();

                sw.Stop();

                Console.WriteLine("The End! {0}", sw.ElapsedMilliseconds);

                this.Invoke((MethodInvoker)delegate
                {
                    lbResult.Text = string.Concat(sw.ElapsedMilliseconds.ToString(), " Miliseconds");
                });

                StringBuilder sb = new StringBuilder();
                foreach (var w in m_Anagramlist)
                {
                    if (w != null)
                    {
                        sb.Append(string.Concat(w.Word, " - ", w.AnagramWord, Environment.NewLine));
                    }
                }

                txResult.Text = sb.ToString();
            }

            private void DirectCalculation()
            {
                List&lt;WordDef&gt; wordDef = new List&lt;WordDef&gt;();

                foreach (var w in m_Words)
                {
                    WordDef wd = new WordDef();
                    wd.Word = w;
                    wd.WordSum = wd.GetAsciiSum(w);
                    wd.Length = w.Length;
                    wd.Ordered = String.Concat(w.OrderBy(c =&gt; c));

                    wordDef.Add(wd);
                }

                foreach (var w in wordDef)
                {
                    foreach (var t in wordDef)
                    {
                        if (w.Word != t.Word)
                        {
                            if (w.Ordered == t.Ordered)
                            {
                                t.AnagramWord = w.Word;
                                m_Anagramlist.Add(new WordDef() { Word = w.Word, AnagramWord = t.Word });
                            }
                        }
                    }
                }
            }

            private void AsciiCalculation()
            {
                ConcurrentBag&lt;WordDef&gt; wordDef = new ConcurrentBag&lt;WordDef&gt;();

                Parallel.ForEach(m_Words, w =&gt;
                    {
                        WordDef wd = new WordDef();
                        wd.Word = w;
                        wd.WordSum = wd.GetAsciiSum(w);
                        wd.Length = w.Length;
                        wd.Ordered = String.Concat(w.OrderBy(c =&gt; c));

                        wordDef.Add(wd);                    
                    });

                var tempWordByLength = from w in wordDef
                                       group w by w.Length into newGroup
                                       orderby newGroup.Key
                                       select newGroup;

                foreach (var wList in tempWordByLength)
                {
                    List&lt;WordDef&gt; wd = wList.ToList&lt;WordDef&gt;();

                    var tempWordsBySum = from w in wd
                                         group w by w.WordSum into newGroup
                                         orderby newGroup.Key
                                         select newGroup;

                    Parallel.ForEach(tempWordsBySum, ws =&gt;
                        {
                            List&lt;WordDef&gt; we = ws.ToList&lt;WordDef&gt;();

                            if (we.Count &gt; 1)
                            {
                                CheckCandidates(we);
                            }
                        });
                }
            }

            private void CheckCandidates(List&lt;WordDef&gt; we)
            {
                for (int i = 0; i &lt; we.Count; i++)
                {
                    for (int j = i + 1; j &lt; we.Count; j++)
                    {
                        if (we[i].Word != we[j].Word)
                        {
                            if (we[i].Ordered == we[j].Ordered)
                            {
                                we[j].AnagramWord = we[i].Word;
                                m_Anagramlist.Add(new WordDef() { Word = we[i].Word, AnagramWord = we[j].Word });
                            }
                        }
                    }
                }
            }

            private static string[] GetWords()
            {
                string htmlCode = string.Empty;

                using (WebClient client = new WebClient())
                {
                    htmlCode = client.DownloadString("https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/10_million_password_list_top_1000000.txt");
                }

                string[] words = htmlCode.Split(new string[] { "\n" }, StringSplitOptions.RemoveEmptyEntries);

                return words;
            }
        }
    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is the impressive solution.</p>
<p>funct alphabet_count_mapper:</p>
<p>for each word in the file/list</p>
<p>1.create a dictionary of alphabets/characters with initial count as 0.</p>
<p>2.keep count of all the alphabets in the word and increment the count in the above alphabet dict.</p>
<p>3.create alphabet count dict and return the tuple of the values of alphabet dict.</p>
<p>funct anagram_counter:</p>
<p>1.create a dictionary with alphabet count tuple as key and the count of the number of occurences against it.</p>
<p>2.iterate over the above dict and if the value &gt; 1, add the value to the anagram count.</p>
<pre><code>    import sys
    words_count_map_dict = {}
    fobj = open(sys.argv[1],"r")
    words = fobj.read().split('\n')[:-1]

    def alphabet_count_mapper(word):
        alpha_count_dict = dict(zip('abcdefghijklmnopqrstuvwxyz',[0]*26))
        for alpha in word:
            if alpha in alpha_count_dict.keys():
                alpha_count_dict[alpha] += 1
            else:
                alpha_count_dict.update(dict(alpha=0))
        return tuple(alpha_count_dict.values())

    def anagram_counter(words):
        anagram_count = 0
        for word in words:
            temp_mapper = alphabet_count_mapper(word)
            if temp_mapper in words_count_map_dict.keys():
                words_count_map_dict[temp_mapper] += 1
            else:
                words_count_map_dict.update({temp_mapper:1})
        for val in words_count_map_dict.values():
            if val &gt; 1:
                anagram_count += val
        return anagram_count


    print anagram_counter(words)
</code></pre>
<p>run it with file path as command line argument</p>
</div>
<div class="post-text" itemprop="text">
<p>You convert each of the character in a word into a number (by <strong>ord()</strong> function), add them up for the word. If two words have the same sum, then they are anagrams. Then filter for the sums that occur more than twice in the list.</p>
<pre><code>def sumLet(w):
    return sum([ord(c) for c in w])

def find_anagrams(l):
    num_l = map(sumLet,l)
    return [l[i] for i,num in enumerate(num_l) if num_l.count(num) &gt; 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; words = ["car", "race", "rac", "ecar", "me", "em"]
&gt;&gt;&gt; anagrams = {}
... for word in words:
...     reverse_word=word[::-1]
...     if reverse_word in words:
...         anagrams[word] = (words.pop(words.index(reverse_word)))
&gt;&gt;&gt; anagrams
20: {'car': 'rac', 'me': 'em', 'race': 'ecar'}
</code></pre>
<p><strong>Logic:</strong></p>
<ol>
<li>Start from first word and reverse the word.</li>
<li>Check the reversed word is present in the list.</li>
<li>If present, find the index and pop the item and store it in the dictionary, word as key and reversed word as value.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you want a solution in java, </p>
<pre class="lang-java prettyprint-override"><code>public List&lt;String&gt; findAnagrams(List&lt;String&gt; dictionary) {

    // TODO do null check and other basic validations.
    Map&lt;String, List&lt;String&gt;&gt; wordMap = new HashMap&lt;String, List&lt;String&gt;&gt;();

    for(String word : dictionary) {

        // ignore if word is null
        char[] tempWord = word.tocharArray();
        Arrays.sort(tempWord);
        String newWord = new String(tempWord);

        if(wordMap.containsKey(newWord)) {
            wordMap.put(newWord, wordMap.get(word).add(word));
        } else {
            wordMap.put(newWord, new ArrayList&lt;&gt;() {word});
        }

    }

    List&lt;String&gt; anagrams = new ArrayList&lt;&gt;();

    for(String key : wordMap.keySet()) {

        if(wordMap.get(key).size() &gt; 1) {
            anagrams.addAll(wordMap.get(key));
        }

    }

    return anagrams;
}
</code></pre>
</div>
<span class="comment-copy">before comparing, try sorting each string.</span>
<span class="comment-copy">I don't really understand what you want to do if you find an anagram? Do you want another list, only with the one that has anagrams? is one anagram enough? Or do you want to know if one word has an anagram in that list?</span>
<span class="comment-copy">Are you trying to find all tthe combinations that you can make with a set of letters or the actual anagrams? For the former, look at itertools.combinations(). For the latter, try my code.</span>
<span class="comment-copy">Don't you mean a palindrome?</span>
<span class="comment-copy">Thank you Ofir (toda)</span>
<span class="comment-copy">The body of this function can be reduced to <code>return sorted(str1) == sorted(str2)</code></span>
<span class="comment-copy">In addition to <code>return sorted(str1) == sorted(str2)</code> being less code to type, it should also be slightly more efficient. But sorting is still O(n lg n), you can find anagrams in O(n) with a dictionary.</span>
<span class="comment-copy">@Dennis Yea but it depends on the constraints. A dictionary would also use O(n) space. There are almost always tradeoffs to be made.</span>
<span class="comment-copy">The solution is incomplete.  Because you are not considering phrases.  This link: <a href="https://en.wikipedia.org/wiki/Anagram" rel="nofollow noreferrer">en.wikipedia.org/wiki/Anagram</a>  puts this point clear.  E.G : "ANAGRAM" could be transform in  "NAG A RAM"  with the code provided you wont it.  You need to :  1) Remove spaces 2) Check that Str1 !== Str2</span>
<span class="comment-copy">The <code>defaultdict</code> instance must typically be frozen after it has been fully populated. This can be done by setting its <code>default_factory = None</code>. Failing this, the dict will be updated by mere lookups - this is not what most users want.</span>
<span class="comment-copy">I was going through this post and this was very easy and cleanest way of finding an anagram</span>
<span class="comment-copy">Thank you, never thought about sorting its much easier this way</span>
<span class="comment-copy">You should include an explanation as to why this solves the issue</span>
<span class="comment-copy">Using <code>vector_anagram</code> doesn't work, if only because 26 is not sufficient to represent non-[a-z] characters, and there are too large a number of them. The solution must most definitely be generic enough to work with non-[a-z] characters as well.</span>
<span class="comment-copy">It wouldn't be hard to expand the function to include all ASCII characters. The array would need a length of 256 and subtraction of 97 would be dropped. Beyond that (ie: Unicode), I wonder what point running that vector through the hash function becomes too slow.</span>
<span class="comment-copy">This will fail for <code>['bat', 'bat', 'rats', 'god', 'dog', 'cat', 'arts', 'star', 'rats']</code>, returning <code>bat</code> as part of the result.</span>
<span class="comment-copy">This is known as the texas sharpshooter fallacy. Anyway, if we're playing by your rules, why not input a set?</span>
<span class="comment-copy">Any solution that works only for the letters a-z is a bad solution because it is not sufficiently generic at all. There are many other characters that exist besides a-z, and they must most definitely be supported.</span>
<span class="comment-copy">The answer is totally wrong and abominable. Consider: <code>ord('a') + ord('d') == ord('b') + ord('c')</code></span>
<span class="comment-copy">I haven't used reversed() because it yields generator.</span>
<span class="comment-copy">This looks for palindromes, not anagrams.</span>
<span class="comment-copy">Very (very!) old question... also, you're giving a <code>java</code> solution for a <code>python</code> question... Recommended reading -&gt; <a href="http://stackoverflow.com/help/how-to-answer">stackoverflow.com/help/how-to-answer</a></span>
