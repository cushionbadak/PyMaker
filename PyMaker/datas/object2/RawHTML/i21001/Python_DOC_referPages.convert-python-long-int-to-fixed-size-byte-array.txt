<div class="post-text" itemprop="text">
<p>I'm trying to implement RC4 and DH key exchange in python. Problem is that I have no idea about how to convert the python long/int from the key exchange to the byte array I need for the RC4 implementation. Is there a simple way to convert a long to the required length byte array?</p>
<p><strong>Update</strong>: forgot to mention that the numbers I'm dealing with are 768 bit unsigned integers.</p>
</div>
<div class="post-text" itemprop="text">
<p>I haven't done any benchmarks, but this recipe "works for me".</p>
<p>The short version: use <code>'%x' % val</code>, then <code>unhexlify</code> the result. The devil is in the details, though, as <code>unhexlify</code> requires an even number of hex digits, which <code>%x</code> doesn't guarantee. See the docstring, and the liberal inline comments for details.</p>
<pre class="lang-py prettyprint-override"><code>from binascii import unhexlify

def long_to_bytes (val, endianness='big'):
    """
    Use :ref:`string formatting` and :func:`~binascii.unhexlify` to
    convert ``val``, a :func:`long`, to a byte :func:`str`.

    :param long val: The value to pack

    :param str endianness: The endianness of the result. ``'big'`` for
      big-endian, ``'little'`` for little-endian.

    If you want byte- and word-ordering to differ, you're on your own.

    Using :ref:`string formatting` lets us use Python's C innards.
    """

    # one (1) hex digit per four (4) bits
    width = val.bit_length()

    # unhexlify wants an even multiple of eight (8) bits, but we don't
    # want more digits than we need (hence the ternary-ish 'or')
    width += 8 - ((width % 8) or 8)

    # format width specifier: four (4) bits per hex digit
    fmt = '%%0%dx' % (width // 4)

    # prepend zero (0) to the width, to zero-pad the output
    s = unhexlify(fmt % val)

    if endianness == 'little':
        # see http://stackoverflow.com/a/931095/309233
        s = s[::-1]

    return s
</code></pre>
<p>...and my <a href="https://nose.readthedocs.org/en/latest/" rel="noreferrer">nosetest</a> unit tests ;-)</p>
<pre class="lang-py prettyprint-override"><code>class TestHelpers (object):
    def test_long_to_bytes_big_endian_small_even (self):
        s = long_to_bytes(0x42)
        assert s == '\x42'

        s = long_to_bytes(0xFF)
        assert s == '\xff'

    def test_long_to_bytes_big_endian_small_odd (self):
        s = long_to_bytes(0x1FF)
        assert s == '\x01\xff'

        s = long_to_bytes(0x201FF)
        assert s == '\x02\x01\xff'

    def test_long_to_bytes_big_endian_large_even (self):
        s = long_to_bytes(0xab23456c8901234567)
        assert s == '\xab\x23\x45\x6c\x89\x01\x23\x45\x67'

    def test_long_to_bytes_big_endian_large_odd (self):
        s = long_to_bytes(0x12345678901234567)
        assert s == '\x01\x23\x45\x67\x89\x01\x23\x45\x67'

    def test_long_to_bytes_little_endian_small_even (self):
        s = long_to_bytes(0x42, 'little')
        assert s == '\x42'

        s = long_to_bytes(0xFF, 'little')
        assert s == '\xff'

    def test_long_to_bytes_little_endian_small_odd (self):
        s = long_to_bytes(0x1FF, 'little')
        assert s == '\xff\x01'

        s = long_to_bytes(0x201FF, 'little')
        assert s == '\xff\x01\x02'

    def test_long_to_bytes_little_endian_large_even (self):
        s = long_to_bytes(0xab23456c8901234567, 'little')
        assert s == '\x67\x45\x23\x01\x89\x6c\x45\x23\xab'

    def test_long_to_bytes_little_endian_large_odd (self):
        s = long_to_bytes(0x12345678901234567, 'little')
        assert s == '\x67\x45\x23\x01\x89\x67\x45\x23\x01'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3.2 and later, you can use <code>int.to_bytes</code> and <code>int.from_bytes</code>: <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="noreferrer">https://docs.python.org/3/library/stdtypes.html#int.to_bytes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Everyone has overcomplicated this answer:</p>
<pre><code>some_int = &lt;256 bit integer&gt;
some_bytes = some_int.to_bytes(32, sys.byteorder)
my_bytearray = bytearray(some_bytes)
</code></pre>
<p>You just need to know the number of bytes that you are trying to convert. In my use cases, normally I only use this large of numbers for crypto, and at that point I have to worry about modulus and what-not, so I don't think this is a big problem to be required to know the max number of bytes to return.</p>
<p>Since you are doing it as 768-bit math, then instead of 32 as the argument it would be 96.</p>
</div>
<div class="post-text" itemprop="text">
<p>One-liner:</p>
<pre><code>bytearray.fromhex('{:0192x}'.format(big_int))
</code></pre>
<p>The 192 is 768 / 4, because OP wanted 768-bit numbers and there are 4 bits in a hex digit. If you need a bigger <code>bytearray</code> use a format string with a higher number. Example:</p>
<pre><code>&gt;&gt;&gt; big_int = 911085911092802609795174074963333909087482261102921406113936886764014693975052768158290106460018649707059449553895568111944093294751504971131180816868149233377773327312327573120920667381269572962606994373889233844814776702037586419
&gt;&gt;&gt; bytearray.fromhex('{:0192x}'.format(big_int))
bytearray(b'\x96;h^\xdbJ\x8f3obL\x9c\xc2\xb0-\x9e\xa4Sj-\xf6i\xc1\x9e\x97\x94\x85M\x1d\x93\x10\\\x81\xc2\x89\xcd\xe0a\xc0D\x81v\xdf\xed\xa9\xc1\x83p\xdbU\xf1\xd0\xfeR)\xce\x07\xdepM\x88\xcc\x7fv\\\x1c\x8di\x87N\x00\x8d\xa8\xbd[&lt;\xdf\xaf\x13z:H\xed\xc2)\xa4\x1e\x0f\xa7\x92\xa7\xc6\x16\x86\xf1\xf3')
&gt;&gt;&gt; lepi_int = 0x963b685edb4a8f336f624c9cc2b02d9ea4536a2df669c19e9794854d1d93105c81c289cde061c0448176dfeda9c18370db55f1d0fe5229ce07de704d88cc7f765c1c8d69874e008da8bd5b3cdfaf137a3a48edc229a41e0fa792a7c61686f1f
&gt;&gt;&gt; bytearray.fromhex('{:0192x}'.format(lepi_int))
bytearray(b'\tc\xb6\x85\xed\xb4\xa8\xf36\xf6$\xc9\xcc+\x02\xd9\xeaE6\xa2\xdff\x9c\x19\xe9yHT\xd1\xd91\x05\xc8\x1c(\x9c\xde\x06\x1c\x04H\x17m\xfe\xda\x9c\x187\r\xb5_\x1d\x0f\xe5"\x9c\xe0}\xe7\x04\xd8\x8c\xc7\xf7e\xc1\xc8\xd6\x98t\xe0\x08\xda\x8b\xd5\xb3\xcd\xfa\xf17\xa3\xa4\x8e\xdc"\x9aA\xe0\xfay*|aho\x1f')
</code></pre>
<p>[My answer had used <code>hex()</code> before. I corrected it with <code>format()</code> in order to handle ints with odd-sized byte expressions. This fixes previous complaints about <code>ValueError</code>.]</p>
</div>
<div class="post-text" itemprop="text">
<p><em>long/int to the byte array</em> looks like exact purpose of <code>struct.pack</code>.  For long integers that exceed 4(8) bytes, you can come up with something like the next:</p>
<pre><code>&gt;&gt;&gt; limit = 256*256*256*256 - 1
&gt;&gt;&gt; i = 1234567890987654321
&gt;&gt;&gt; parts = []
&gt;&gt;&gt; while i:
        parts.append(i &amp; limit)
        i &gt;&gt;= 32

&gt;&gt;&gt; struct.pack('&gt;' + 'L'*len(parts), *parts )
'\xb1l\x1c\xb1\x11"\x10\xf4'

&gt;&gt;&gt; struct.unpack('&gt;LL', '\xb1l\x1c\xb1\x11"\x10\xf4')
(2976652465L, 287445236)
&gt;&gt;&gt; (287445236L &lt;&lt; 32) + 2976652465L
1234567890987654321L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try using <a href="http://docs.python.org/library/struct.html#format-characters">struct</a>:</p>
<pre><code>import struct
struct.pack('L',longvalue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Little-endian, reverse the result or the range if you want Big-endian:</p>
<pre><code>def int_to_bytes(val, num_bytes):
    return [(val &amp; (0xff &lt;&lt; pos*8)) &gt;&gt; pos*8 for pos in range(num_bytes)]
</code></pre>
<p>Big-endian:</p>
<pre><code>def int_to_bytes(val, num_bytes):
    return [(val &amp; (0xff &lt;&lt; pos*8)) &gt;&gt; pos*8 for pos in reversed(range(num_bytes))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Basically what you need to do is convert the int/long into its base 256 representation -- i.e. a number whose "digits" range from 0-255. Here's a fairly efficient way to do something like that:</p>
<pre><code>def base256_encode(n, minwidth=0): # int/long to byte array
    if n &gt; 0:
        arr = []
        while n:
            n, rem = divmod(n, 256)
            arr.append(rem)
        b = bytearray(reversed(arr))
    elif n == 0:
        b = bytearray(b'\x00')
    else:
        raise ValueError

    if minwidth &gt; 0 and len(b) &lt; minwidth: # zero padding needed?
        b = (minwidth-len(b)) * '\x00' + b
    return b
</code></pre>
<p>You many not need the<code>reversed()</code>call depending on the endian-ness desired (doing so would require the padding to be done differently as well). Also note that as written it doesn't handle negative numbers.</p>
<p>You might also want to take a look at the similar but highly optimized <code>long_to_bytes()</code> function in the<code>number.py</code>module which is part of the open source <a href="https://pypi.python.org/pypi/pycrypto" rel="nofollow">Python Cryptography Toolkit</a>. It actually converts the number into a string, not a byte array, but that's a minor issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 2.7 does not implement the int.to- very slow_bytes() method.</p>
<p>I tried 3 methods:</p>
<ol>
<li>hex unpack/pack : very slow</li>
<li>byte shifting 8 bits at a time: significantly faster.</li>
<li>using a "C" module and packing into the lower (7 ia64 or 3 i32) bytes.
This was about twice as fast as 2/ . It is the fastest option, but still too slow.</li>
</ol>
<p>All these methods are very inefficient for two reasons: </p>
<ul>
<li>Python 2.7 does not support this useful operation.</li>
<li>c does not support extended precision arithmetic using the carry/borrow/overflow flags available on most platforms.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>i = 0x12345678
s = struct.pack('&lt;I',i)
b = struct.unpack('BBBB',s)
</code></pre>
</div>
<span class="comment-copy">not sure if it'll help but check the <code>struct</code> module: <a href="http://docs.python.org/library/struct.html" rel="nofollow noreferrer">docs.python.org/library/struct.html</a></span>
<span class="comment-copy">How big are your numbers?</span>
<span class="comment-copy">I encountered problems when the value is 0 (Python 3.5) <code>binascii.Error: Odd-length string</code>, quick fix for this: replace <code>s = unhexlify(fmt % val)</code> with <code>s = unhexlify('00') if fmt % val == '0' else unhexlify(fmt % val)</code></span>
<span class="comment-copy">In Python 3 this solution worked really well for 2048 bit integer. It Python 2.7 it works only for int (2048 bit integer is long in Python 2.7).</span>
<span class="comment-copy">In Python 2.7 <code>some_bytes = some_int.to_bytes(32, sys.byteorder)</code> produces error <code>AttributeError: 'int' object has no attribute 'to_bytes'</code> ðŸ˜ž</span>
<span class="comment-copy">it does not work if you don't produce a Long though. I think smt like  bytearray.fromhex(hex(2**61-1).strip('0x').strip('L')) is safer</span>
<span class="comment-copy">@MarioAlemi the code in your comment is wrong. <code>strip('0x')</code> will also strip the trailing zeros, which will result bad result (and sometimes <code>ValueError</code>)!</span>
<span class="comment-copy">@Jess Austin: Your solution is totally wrong, because it works only when x consists of even number of hex-digits.  Example: <code>x=0x963b685edb4a8f336f624c9cc2b02d9ea4536a2df669c19e9794854d1d93105c81c289cde061c0448176dfeda9c18370db55f1d0fe5229ce07de704d88cc7f765c1c8d69874e008da8bd5b3cdfaf137a3a48edc229a41e0fa792a7c61686f1fL</code></span>
<span class="comment-copy">@lepi can you make an example?</span>
<span class="comment-copy">@MarioAlemi bytearray.fromhex(hex(0x11000000).strip('0x').strip('L'))  It won't just strip the '0x' character sequence from the beginning, it will remove <b>all</b> the '0' and <b>all</b> the 'x' characters from <b>both</b> side. When the number is not a Long and has tailing zeros, those will be also removed.</span>
<span class="comment-copy">But it won't help with big numbers (&gt; 8 bytes), which will usually be used for cryptographic applications.</span>
<span class="comment-copy">it's written not to be generic but more like fixed size solution to common problem of representing all possible ip's or similar...</span>
<span class="comment-copy">Sadly no, error: integer out of range for 'L' format code. It's a 768 bit long, which is quite a bit bigger than the 4 byte unsigned int.</span>
<span class="comment-copy">Downvoted because Python long int are arbitrarily long integers. Think of it like an array of 32 (or whatever) bits integers. A C long is a size defined datatype. With this response, you are confusing both.</span>
