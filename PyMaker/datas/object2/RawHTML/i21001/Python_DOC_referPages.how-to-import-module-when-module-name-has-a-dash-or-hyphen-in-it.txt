<div class="post-text" itemprop="text">
<p>I want to import foo-bar.py. This works:</p>
<pre><code>foobar = __import__("foo-bar")
</code></pre>
<p>This does not:</p>
<pre><code>from "foo-bar" import *
</code></pre>
<p>My question: Is there any way that I can use the above format i.e., <code>from "foo-bar" import *</code> to import a module that has a <code>-</code> in it?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can't.  <code>foo-bar</code> is not an identifier.  rename the file to <code>foo_bar.py</code></p>
<p><strong>Edit:</strong> If <code>import</code> is not your goal (as in: you don't care what happens with <code>sys.modules</code>, you don't need it to import itself), just getting all of the file's globals into your own scope, you can use <code>execfile</code></p>
<pre><code># contents of foo-bar.py
baz = 'quux'
</code></pre>
<pre><code>&gt;&gt;&gt; execfile('foo-bar.py')
&gt;&gt;&gt; baz
'quux'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can't rename the module to match Python naming conventions, create a new module to act as an intermediary:</p>
<pre><code> ---- foo_proxy.py ----
 tmp = __import__('foo-bar')
 globals().update(vars(tmp))

 ---- main.py ----
 from foo_proxy import * 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can't rename the original file, you could also use a symlink:</p>
<pre><code>ln -s foo-bar.py foo_bar.py
</code></pre>
<p>Then you can just:</p>
<pre><code>from foo_bar import *
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Starting from Python 3.1, you can use importlib :</p>
<pre><code>import importlib  
foobar = importlib.import_module("foo-bar")
</code></pre>
<p>( <a href="https://docs.python.org/3/library/importlib.html" rel="noreferrer">https://docs.python.org/3/library/importlib.html</a> )</p>
</div>
<span class="comment-copy">Why do you have a module with a dash in its name?</span>
<span class="comment-copy">I'm guessing it was originally written as a script rather than as a module.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/7583652/python-module-with-a-dash-or-hyphen-in-its-name">Python Module with a dash, or hyphen (-) in its name</a></span>
<span class="comment-copy">@MattiVirkkunen makepy.py of win32com will generate module with dash in it. too bad. comtypes solved this by converting it to underscore</span>
<span class="comment-copy">@MattiVirkkunen I think Python should not limit the names I can give my directories. It is not its responsibility to do so.</span>
<span class="comment-copy">Python 3.x <a href="https://docs.python.org/3/whatsnew/3.0.html" rel="nofollow noreferrer">Whatâ€™s New In Python 3.0</a> Removed execfile(). Instead of <code>execfile(fn)</code> use <code>exec(open(fn).read())</code> Also there is package importlib.</span>
<span class="comment-copy">I would never implement this. But I can't not give +1 for the sheer brilliance of this hack</span>
<span class="comment-copy">you could actually do this without the <code>foo_proxy.py</code> file,  assign the output of <code>__import__(...)</code> to <code>sys.modules['foo_proxy']</code>.  Actually, don't do that, it's a terrible idea.</span>
<span class="comment-copy">Cool just what I was looking for. There is a usecase, if one uses native libraries which are shipped with a distribution.</span>
<span class="comment-copy">@SingleNegationElimination, idea adopted, thanks.</span>
<span class="comment-copy">This should be the accepted answer.</span>
