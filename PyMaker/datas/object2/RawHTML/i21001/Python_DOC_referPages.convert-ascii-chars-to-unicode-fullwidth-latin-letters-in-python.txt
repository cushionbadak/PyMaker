<div class="post-text" itemprop="text">
<p>Can you easily convert between ASCII characters and their Asian full-width Unicode wide characters?
Like:</p>
<pre><code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~
</code></pre>
<p>to</p>
<pre><code>０１２３４５６７８９ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ！゛＃＄％＆（）＊＋、ー。／：；〈＝＝〉？＠［\\］＾＿‘｛｜｝～
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Those "wide" characters are named <code>FULLWIDTH LATIN LETTER</code>: <a href="http://www.unicodemap.org/range/87/Halfwidth%20and%20Fullwidth%20Forms/">http://www.unicodemap.org/range/87/Halfwidth%20and%20Fullwidth%20Forms/</a></p>
<p>They have range 0xFF00 - -0xFFEF. You can make look-up table or just add 0xFEE0 to ASCII code.</p>
</div>
<div class="post-text" itemprop="text">
<p>The range of fullwidth ASCII replacements starts at U+FF01, not U+FF00. U+FF00 is (strangely) not defined. To get a fullwidth SPACE, you need to use U+3000 IDEOGRAPHIC SPACE. Don't rely on typing what <em>appears</em> to be what you want followed by visual inspection of characters to check your mapping -- <code>unicodedata.name</code> is your friend. This code:</p>
<pre><code># coding: utf-8
from unicodedata import name as ucname

# OP
normal = u"""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"""
wide = u"""０１２３４５６７８９ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ！゛＃＄％＆（）＊＋、ー。／：；〈＝〉？＠［\\］＾＿‘｛｜｝～"""
# above after editing (had = twice)
widemapOP = dict((ord(x[0]), x[1]) for x in zip(normal, wide))

# Ingacio V
normal = u' 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'
wide = u'　０１２３４５６７８９ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ！゛＃＄％＆（）＊＋、ー。／：；〈＝〉？＠［\\］＾＿‘｛｜｝～'
widemapIV = dict((ord(x[0]), x[1]) for x in zip(normal, wide))

# JM
widemapJM = dict((i, i + 0xFF00 - 0x20) for i in xrange(0x21, 0x7F))
widemapJM[0x20] = 0x3000 # IDEOGRAPHIC SPACE

maps = {'OP': widemapOP, 'IV': widemapIV, 'JM': widemapJM}.items()

for i in xrange(0x20, 0x7F):
    a = unichr(i)
    na = ucname(a, '?')
    for tag, widemap in maps:
        w = a.translate(widemap)
        nw = ucname(w, '?')
        if nw != "FULLWIDTH " + na:
            print "%s: %04X %s =&gt; %04X %s" % (tag, i, na, ord(w), nw)
</code></pre>
<p>when run shows what you have <em>really</em> got: some missing mappings and some idiosyncratic mappings:</p>
<pre><code>JM: 0020 SPACE =&gt; 3000 IDEOGRAPHIC SPACE
IV: 0020 SPACE =&gt; 3000 IDEOGRAPHIC SPACE
OP: 0020 SPACE =&gt; 0020 SPACE
IV: 0022 QUOTATION MARK =&gt; 309B KATAKANA-HIRAGANA VOICED SOUND MARK
OP: 0022 QUOTATION MARK =&gt; 309B KATAKANA-HIRAGANA VOICED SOUND MARK
IV: 0027 APOSTROPHE =&gt; 0027 APOSTROPHE
OP: 0027 APOSTROPHE =&gt; 0027 APOSTROPHE
IV: 002C COMMA =&gt; 3001 IDEOGRAPHIC COMMA
OP: 002C COMMA =&gt; 3001 IDEOGRAPHIC COMMA
IV: 002D HYPHEN-MINUS =&gt; 30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK
OP: 002D HYPHEN-MINUS =&gt; 30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK
IV: 002E FULL STOP =&gt; 3002 IDEOGRAPHIC FULL STOP
OP: 002E FULL STOP =&gt; 3002 IDEOGRAPHIC FULL STOP
IV: 003C LESS-THAN SIGN =&gt; 3008 LEFT ANGLE BRACKET
OP: 003C LESS-THAN SIGN =&gt; 3008 LEFT ANGLE BRACKET
IV: 003E GREATER-THAN SIGN =&gt; 3009 RIGHT ANGLE BRACKET
OP: 003E GREATER-THAN SIGN =&gt; 3009 RIGHT ANGLE BRACKET
IV: 005C REVERSE SOLIDUS =&gt; 005C REVERSE SOLIDUS
OP: 005C REVERSE SOLIDUS =&gt; 005C REVERSE SOLIDUS
IV: 0060 GRAVE ACCENT =&gt; 2018 LEFT SINGLE QUOTATION MARK
OP: 0060 GRAVE ACCENT =&gt; 2018 LEFT SINGLE QUOTATION MARK
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes.</p>
<pre><code>&gt;&gt;&gt; normal = u' 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'
&gt;&gt;&gt; wide = u'　０１２３４５６７８９ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ！゛＃＄％＆（）＊＋、ー。／：；〈＝〉？＠［\\］＾＿‘｛｜｝～'
&gt;&gt;&gt; widemap = dict((ord(x[0]), x[1]) for x in zip(normal, wide))
&gt;&gt;&gt; print u'Hello, world!'.translate(widemap)
Ｈｅｌｌｏ、　ｗｏｒｌｄ！
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes; in Python 3, cleanest is to use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow">str.translate</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow">str.maketrans</a>:</p>
<pre><code>HALFWIDTH_TO_FULLWIDTH = str.maketrans(
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_`{|}~',
    '０１２３４５６７８９ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ！゛＃＄％＆（）＊＋、ー。／：；〈＝〉？＠［］＾＿‘｛｜｝～')

def halfwidth_to_fullwidth(s):
    return s.translate(HALFWIDTH_TO_FULLWIDTH)
</code></pre>
<p>In Python 2, str.maketrans is instead <a href="https://docs.python.org/2/library/string.html#string.maketrans" rel="nofollow">string.maketrans</a> and doesn’t work with Unicode characters, so you need to make a dictionary, as Ignacio Vazquez notes above.</p>
</div>
<div class="post-text" itemprop="text">
<p>This goes one way:</p>
<pre><code>#!/usr/bin/env perl
# uniwide
use utf8;
use strict;
use warnings;
use open qw(:std :utf8);

while (&lt;&gt;) {    
    s/\s/\x{A0}\x{A0}/g if tr
      &lt;!"#$%&amp;´()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¢£&gt;
      &lt;！＂＃＄％＆＇（）＊＋，－．／０１２３４５６７８９：；＜＝＞？＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ［＼］＾＿｀ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ｛｜｝～￠￡&gt;;;    
} continue {
      print;   
} 

close(STDOUT) || die "can't close stdout: $!";
</code></pre>
<p>And this goes the other:</p>
<pre><code>#!/usr/bin/env perl
# uninarrow
use utf8;
use strict;
use warnings;
use open qw(:std :utf8);

while (&lt;&gt;) {     
    s/  / /g if tr
      &lt;！＂＃＄％＆＇（）＊＋，－．／０１２３４５６７８９：；＜＝＞？＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ［＼］＾＿｀ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ｛｜｝～￠￡&gt;
      &lt;!"#$%&amp;´()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¢£&gt;    
} continue {
      print;    
} 

close(STDOUT) || die "can't close stdout: $!";
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>UTF-8 Unicode codes for ASCII are exactly the same. For UTF-16 add a zero before/after (LE/BE)</p>
<p>Or in python <code>mystr.encode("utf-8")</code></p>
</div>
<span class="comment-copy">This may be related: <a href="http://stackoverflow.com/questions/2422177/python-how-can-i-replace-full-width-characters-with-half-width-characters" title="python how can i replace full width characters with half width characters">stackoverflow.com/questions/2422177/…</a></span>
<span class="comment-copy">@Mark Don't call something stupid unless you understand it. It's used in Asian writing to embed latin scripts among "double wide" asian characters because it's more natural to read, especially in vertical text and grid-style blocks. E.g.: これはＰｙｔｈｏｎの質問だぞ。</span>
<span class="comment-copy">@deceze, thanks for explaining that, perhaps I was a bit rash in calling it stupid. It does seem like there should be better ways of handling that problem though.</span>
<span class="comment-copy">Nice. Bit of a noob here, how to get the ASCII char's hex value, add that to the 0xff20 hex value, and convert the hex back to string?</span>
<span class="comment-copy">This doesn't work: <code>hex(int('0xFF20', 16) + ord(asciichar))</code></span>
<span class="comment-copy">simply <code>chr(0xFF20 + ord(asciichar))</code> :)</span>
<span class="comment-copy">Are you sure? <code>ValueError: chr() arg not in range(256)</code></span>
<span class="comment-copy">Oh, sorry. I made error, calculating offset. We should use <code>unichr(0xFEE0 + ord(asciichar))</code>. Now it works fine. I fixed answer.</span>
<span class="comment-copy">+1 clever! But I keep getting <code>Ｇｅｌｌｏ＋　 ｏｒｌｄＺ</code> as a translating of <code>Hello world!</code></span>
<span class="comment-copy">@julio.alegria: Then you have a missing or extra character somewhere.</span>
<span class="comment-copy">Then become sure.</span>
<span class="comment-copy">How does one become sure?</span>
<span class="comment-copy">-1 Solution requires laborious typing and is thus brittle as evidenced by above comments.</span>
<span class="comment-copy">This answer seems better to me than the others. It's a cleaner and shorter solution and works exactly as it should. I'm assuming it wasn't available back in 2011 though.</span>
<span class="comment-copy">what programming language is this?</span>
<span class="comment-copy">For some reason the <code>python</code> tag really is too small on this one... :o)</span>
<span class="comment-copy">I'm not sure about that. I think in unicode you have normal "width" ascii characters which indeed are the same, but there are wider versions (like above) which have another code.</span>
<span class="comment-copy"><code>0123456789a</code> != <code>０１２３４５６７８９ａ</code>.</span>
<span class="comment-copy">@glglgl the question was improperly put, I had to edit it to clean it.</span>
