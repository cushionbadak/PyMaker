<div class="post-text" itemprop="text">
<p>I'm building a photo gallery in Python and want to be able to quickly generate thumbnails for the high resolution images.</p>
<p>What's the fastest way to generate high quality thumbnails for a variety of image sources?</p>
<p>Should I be using an external library like imagemagick, or is there an efficient internal way to do this?</p>
<p>The dimensions of the resized images will be (max size):</p>
<pre><code>120x120
720x720
1600x1600
</code></pre>
<p>Quality is an issue, as I want to preserve as many of the original colors as possible and minimize compression artifacts.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want PIL it does this with ease</p>
<pre><code>from PIL import Image
sizes = [(120,120), (720,720), (1600,1600)]
files = ['a.jpg','b.jpg','c.jpg']

for image in files:
    for size in sizes:
        im = Image.open(image)
        im.thumbnail(size)
        im.save("thumbnail_%s_%s" % (image, "_".join(size)))
</code></pre>
<p>If you desperately need speed. Then thread it, multiprocess it or get another language.</p>
</div>
<div class="post-text" itemprop="text">
<p>A little late to the question (only a year!), but I'll piggy backing on the "multiprocess it" part of @JakobBowyer's answer. </p>
<p>This is a good example of an <a href="http://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="nofollow noreferrer">embarrassingly parallel</a> problem, as the main bit of code doesn't mutate any state external to itself. It simply reads an input, performs its computation and saves the result.</p>
<p>Python is actually pretty good at these kinds of problems thanks to the map function provided by <code>multiprocessing.Pool</code>. </p>
<pre><code>from PIL import Image
from multiprocessing import Pool 

def thumbnail(image_details): 
    size, filename = image_details
    try:
        im = Image.open(filename)
        im.thumbnail(size)
        im.save("thumbnail_%s" % filename)
        return 'OK'
    except Exception as e: 
        return e 

sizes = [(120,120), (720,720), (1600,1600)]
files = ['a.jpg','b.jpg','c.jpg']

pool = Pool(number_of_cores_to_use)
results = pool.map(thumbnail, zip(sizes, files))
</code></pre>
<p>The core of the code is exactly the same as @JakobBowyer, but instead of running it in a loop in a single thread, we wrapped it in a function spread it out across multiple cores via the multiprocessing map function. </p>
</div>
<div class="post-text" itemprop="text">
<p>I fancied some fun so I did some benchmarking on the various methods suggested above and a few ideas of my own.</p>
<p>I collected together 1000 high resolution 12MP iPhone 6s images, each 4032x3024 pixels and use an 8-core iMac.</p>
<p>Here are the techniques and results - each in its own section.</p>
<hr/>
<p><strong>Method 1 - Sequential ImageMagick</strong></p>
<p>This is simplistic, unoptimised code. Each image is read and thumbnail is produced. Then it is read again and a different sized thumbnail is produced.</p>
<pre><code>#!/bin/bash

start=$SECONDS
# Loop over all files
for f in image*.jpg; do
   # Loop over all sizes
   for s in 1600 720 120; do
      echo Reducing $f to ${s}x${s}
      convert "$f" -resize ${s}x${s} t-$f-$s.jpg
   done
done
echo Time: $((SECONDS-start))
</code></pre>
<p><strong>Result: 170 seconds</strong></p>
<hr/>
<p><strong>Method 2 - Sequential ImageMagick with single load and successive resizing</strong></p>
<p>This is still sequential but slightly smarter. Each image is only read one time and the loaded image is then resized down three and saved at three resolutions. The improvement is that each image is read just once, not 3 times.</p>
<pre><code>#!/bin/bash

start=$SECONDS
# Loop over all files
N=1
for f in image*.jpg; do
   echo Resizing $f
   # Load once and successively scale down
   convert "$f"                              \
      -resize 1600x1600 -write t-$N-1600.jpg \
      -resize 720x720   -write t-$N-720.jpg  \
      -resize 120x120          t-$N-120.jpg
   ((N=N+1))
done
echo Time: $((SECONDS-start))
</code></pre>
<p><strong>Result: 76 seconds</strong></p>
<hr/>
<p><strong>Method 3 - GNU Parallel + ImageMagick</strong></p>
<p>This builds on the previous method, by using <strong>GNU Parallel</strong> to process <code>N</code> images in parallel, where <code>N</code> is the number of CPU cores on your machine.</p>
<pre><code>#!/bin/bash

start=$SECONDS

doit() {
   file=$1
   index=$2
   convert "$file"                               \
      -resize 1600x1600 -write t-$index-1600.jpg \
      -resize 720x720   -write t-$index-720.jpg  \
      -resize 120x120          t-$index-120.jpg
}

# Export doit() to subshells for GNU Parallel   
export -f doit

# Use GNU Parallel to do them all in parallel
parallel doit {} {#} ::: *.jpg

echo Time: $((SECONDS-start))
</code></pre>
<p><strong>Result: 18 seconds</strong></p>
<hr/>
<p><strong>Method 4 - GNU Parallel + vips</strong></p>
<p>This is the same as the previous method, but it uses <code>vips</code> at the command-line instead of <strong>ImageMagick</strong>.</p>
<pre><code>#!/bin/bash

start=$SECONDS

doit() {
   file=$1
   index=$2
   r0=t-$index-1600.jpg
   r1=t-$index-720.jpg
   r2=t-$index-120.jpg
   vipsthumbnail "$file"  -s 1600 -o "$r0"
   vipsthumbnail "$r0"    -s 720  -o "$r1"
   vipsthumbnail "$r1"    -s 120  -o "$r2"
}

# Export doit() to subshells for GNU Parallel   
export -f doit

# Use GNU Parallel to do them all in parallel
parallel doit {} {#} ::: *.jpg

echo Time: $((SECONDS-start))
</code></pre>
<p><strong>Result: 8 seconds</strong></p>
<hr/>
<p><strong>Method 5 - Sequential PIL</strong></p>
<p>This is intended to correspond to Jakob's answer.</p>
<pre><code>#!/usr/local/bin/python3

import glob
from PIL import Image

sizes = [(120,120), (720,720), (1600,1600)]
files = glob.glob('image*.jpg')

N=0
for image in files:
    for size in sizes:
      im=Image.open(image)
      im.thumbnail(size)
      im.save("t-%d-%s.jpg" % (N,size[0]))
    N=N+1
</code></pre>
<p><strong>Result: 38 seconds</strong></p>
<hr/>
<p><strong>Method 6 - Sequential PIL with single load &amp; successive resize</strong></p>
<p>This is intended as an improvement to Jakob's answer, wherein the image is loaded just once and then resized down three times instead of re-loading each time to produce each new resolution.</p>
<pre><code>#!/usr/local/bin/python3

import glob
from PIL import Image

sizes = [(120,120), (720,720), (1600,1600)]
files = glob.glob('image*.jpg')

N=0
for image in files:
   # Load just once, then successively scale down
   im=Image.open(image)
   im.thumbnail((1600,1600))
   im.save("t-%d-1600.jpg" % (N))
   im.thumbnail((720,720))
   im.save("t-%d-720.jpg"  % (N))
   im.thumbnail((120,120))
   im.save("t-%d-120.jpg"  % (N))
   N=N+1
</code></pre>
<p><strong>Result: 27 seconds</strong></p>
<hr/>
<p><strong>Method 7 - Parallel PIL</strong></p>
<p>This is intended to correspond to Audionautics' answer, insofar as it uses Python's multiprocessing. It also obviates the need to re-load the image for each thumbnail size.</p>
<pre><code>#!/usr/local/bin/python3

import glob
from PIL import Image
from multiprocessing import Pool 

def thumbnail(params): 
    filename, N = params
    try:
        # Load just once, then successively scale down
        im=Image.open(filename)
        im.thumbnail((1600,1600))
        im.save("t-%d-1600.jpg" % (N))
        im.thumbnail((720,720))
        im.save("t-%d-720.jpg"  % (N))
        im.thumbnail((120,120))
        im.save("t-%d-120.jpg"  % (N))
        return 'OK'
    except Exception as e: 
        return e 


files = glob.glob('image*.jpg')
pool = Pool(8)
results = pool.map(thumbnail, zip(files,range((len(files)))))
</code></pre>
<p><strong>Result: 6 seconds</strong></p>
<hr/>
<p><strong>Method 8 - Parallel OpenCV</strong></p>
<p>This is intended to be an improvement on bcattle's answer, insofar as it uses OpenCV but it also obviates the need to re-load the image to generate each new resolution output.</p>
<pre><code>#!/usr/local/bin/python3

import cv2
import glob
from multiprocessing import Pool 

def thumbnail(params): 
    filename, N = params
    try:
        # Load just once, then successively scale down
        im = cv2.imread(filename)
        im = cv2.resize(im, (1600,1600))
        cv2.imwrite("t-%d-1600.jpg" % N, im) 
        im = cv2.resize(im, (720,720))
        cv2.imwrite("t-%d-720.jpg" % N, im) 
        im = cv2.resize(im, (120,120))
        cv2.imwrite("t-%d-120.jpg" % N, im) 
        return 'OK'
    except Exception as e: 
        return e 


files = glob.glob('image*.jpg')
pool = Pool(8)
results = pool.map(thumbnail, zip(files,range((len(files)))))
</code></pre>
<p><strong>Result: 5 seconds</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use the <a href="http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html" rel="nofollow">python bindings</a> to <a href="http://opencv.org/" rel="nofollow">OpenCV</a>. This may be faster than PIL or Imagemagick. </p>
<pre><code>import cv2

sizes = [(120, 120), (720, 720), (1600, 1600)]
image = cv2.imread("input.jpg")
for size in sizes:
    resized_image = cv2.resize(image, size)
    cv2.imwrite("thumbnail_%d.jpg" % size[0], resized_image) 
</code></pre>
<p>There's a more complete walkthrough <a href="http://www.pyimagesearch.com/2014/01/20/basic-image-manipulations-in-python-and-opencv-resizing-scaling-rotating-and-cropping/" rel="nofollow">here</a>.</p>
<p>If you want to run it in parallel, use <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow"><code>concurrent.futures</code></a> on Py3 or the <a href="https://pypi.python.org/pypi/futures" rel="nofollow"><code>futures</code></a> package on Py2.7:</p>
<pre><code>import concurrent.futures
import cv2

def resize(input_filename, size):
    image = cv2.imread(input_filename)
    resized_image = cv2.resize(image, size)
    cv2.imwrite("thumbnail_%s%d.jpg" % (input_filename.split('.')[0], size[0]), resized_image)

executor = concurrent.futures.ThreadPoolExecutor(max_workers=3)
sizes = [(120, 120), (720, 720), (1600, 1600)]
for size in sizes:
    executor.submit(resize, "input.jpg", size)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are already familiar with imagemagick, why not stick with the python-bindings?</p>
<p><a href="http://www.imagemagick.org/script/api.php#python" rel="nofollow">PythonMagick</a></p>
</div>
<div class="post-text" itemprop="text">
<h2><strong>Python 2.7, Windows, x64 users</strong></h2>
<p>In addition to <a href="https://stackoverflow.com/a/8631924/3191896">@JakobBowyer</a> &amp; <a href="https://stackoverflow.com/a/19731584/3191896">@Audionautics</a>, <code>PIL</code> is quite old and you can find yourself troubleshooting and looking for the right version... instead, use <code>Pillow</code> from <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow" rel="nofollow noreferrer">here</a> (<a href="https://stackoverflow.com/a/4579917/3191896">source</a>)</p>
<p><strong>the updated snippet will look like this:</strong></p>
<pre><code>im = Image.open(full_path)
im.thumbnail(thumbnail_size)
im.save(new_path, "JPEG")
</code></pre>
<p>full enumeration script for thumbnail creation:</p>
<pre><code>import os
from PIL import Image

output_dir = '.\\output'
thumbnail_size = (200,200)

if not os.path.exists(output_dir):
    os.makedirs(output_dir)

for dirpath, dnames, fnames in os.walk(".\\input"):
    for f in fnames:
        full_path = os.path.join(dirpath, f)
        if f.endswith(".jpg"):
            filename = 'thubmnail_{0}'.format(f) 
            new_path = os.path.join(output_dir, filename)

            if os.path.exists(new_path):
                os.remove(new_path)

            im = Image.open(full_path)
            im.thumbnail(thumbnail_size)
            im.save(new_path, "JPEG")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I stumbled upon <a href="https://www.kaggle.com/vfdev5/pil-vs-opencv" rel="nofollow noreferrer">this</a> when trying to figure out which library I should use:</p>
<p>It seems like <strong>OpenCV is clearly faster than PIL</strong>.</p>
<p>That said, I'm working with spreadsheets and it turns out that the module I was using <a href="https://openpyxl.readthedocs.io/en/stable/_modules/openpyxl/drawing/image.html" rel="nofollow noreferrer">openpyxl already requires me to import PIL to insert images</a>.</p>
</div>
<span class="comment-copy">You can use Python Wand, which calls Imagemagick to do that. I cannot say if it is the fastest. Python OpenCV may be faster.</span>
<span class="comment-copy">Latest version of PIL no longer supports <code>import Image</code> you should instead use <code>from PIL import Image</code></span>
<span class="comment-copy">Also, this code will only save 3 thumbnails although it will generate all 9 thumbnails (you probably have to use <code>thumbnail_%s_%s-%s" % (image, size[0], size[1])</code>).</span>
<span class="comment-copy">Seems odd to load the same high-res image 3 times from disk to generate 3 thumbnails. Why not load the high-res image once, scale down to 1600, write, scale down to 720, write, scale down to 120 and write? Surely has to be faster.</span>
<span class="comment-copy">Don't you want a Cartesian product rather than <code>zip</code> though?</span>
<span class="comment-copy">The <code>zip</code> refers to <a href="http://docs.python.org/2.7/library/functions.html#zip" rel="nofollow noreferrer">this function</a>, not the compressed file format.</span>
<span class="comment-copy">does this above script add any benefit if numbers of cores is set to one?</span>
<span class="comment-copy">@Nick lookup Cartesian product.  This will generate the thumbnail for the first image at 120x120, for the second at 720x720, and for the last image at 1600x1600</span>
<span class="comment-copy">Nice comparison, Mark</span>
<span class="comment-copy">This answer is vastly superior to all of the above (and accepted) answers</span>
<span class="comment-copy">Thanks -- is this faster than some of the builtin Python methods?</span>
<span class="comment-copy">Which builtin methods? If you mean PIL, i can't say for sure, but ImageMagick is more the swiss-army-knife then a racing horse. Nevertheless i could never complain about the performance, but just relish the incredible features. I don't know about any other library with similar capabilities.</span>
<span class="comment-copy">On windows you have to build from source to get JPEG support...</span>
