<div class="post-text" itemprop="text">
<p>Sometimes I need to call a gtk/gobject function that only exists in C, but returns an object that has a python wrapper. Previously I used a solution based on ctypes that worked well:</p>
<p><a href="http://faq.pygtk.org/index.py?req=show&amp;file=faq23.041.htp" rel="noreferrer">http://faq.pygtk.org/index.py?req=show&amp;file=faq23.041.htp</a></p>
<p>Now that I swiched from PyGtk ("import gtk") to GObject-introspection ("from gi.repository import Gtk"), what can I use instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>_PyGObject_API</code> interface has changed at some point. I needed to drop the <code>register_sinkfunc</code> function. The following works:</p>
<pre><code>from gi.repository import Gio, GLib
import gi
import ctypes

class _PyGObject_Functions(ctypes.Structure):
   _fields_ = [
       ('register_class',
        ctypes.PYFUNCTYPE(ctypes.c_void_p, ctypes.c_char_p,
                          ctypes.c_int, ctypes.py_object,
                          ctypes.py_object)),
       ('register_wrapper',
        ctypes.PYFUNCTYPE(ctypes.c_void_p, ctypes.py_object)),
       ('lookup_class',
        ctypes.PYFUNCTYPE(ctypes.py_object, ctypes.c_int)),
       ('newgobj',
        ctypes.PYFUNCTYPE(ctypes.py_object, ctypes.c_void_p)),
       ]

class PyGObjectCPAI(object):
   def __init__(self):
       PyCObject_AsVoidPtr = ctypes.pythonapi.PyCObject_AsVoidPtr
       PyCObject_AsVoidPtr.restype = ctypes.c_void_p
       PyCObject_AsVoidPtr.argtypes = [ctypes.py_object]
       addr = PyCObject_AsVoidPtr(ctypes.py_object(
           gi._gobject._PyGObject_API))
       self._api = _PyGObject_Functions.from_address(addr)

   def pygobject_new(self, addr):
       return self._api.newgobj(addr)

capi = PyGObjectCPAI()
</code></pre>
<p>To get an object from a pointer:</p>
<pre><code>obj = capi.pygobject_new(pointer)
</code></pre>
<p>to get a pointer from a (g)object:</p>
<pre><code>pointer = hash(obj)
</code></pre>
<p>I have to add, in my case this didn't help me solve my actual problem. I was trying to interface with dconf, but dconf returns values of type GVariant, which does not inherit from GObject. It seems PyGI/GObject unfortunately does not expose the neccessary functions to turn a C (*GVariant) into a Python GLib.Variant. I guess it's of those times when you have to throw away your initial approach and try something different.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code in <a href="/a/8713841">jdm's answer</a> isn't compatible with Python 3. Since <a href="https://docs.python.org/2/c-api/cobject.html" rel="nofollow"><code>CObject</code></a> is <a href="https://docs.python.org/2/howto/cporting.html#cobject-replaced-with-capsule" rel="nofollow">deprecated</a> in Python 2.7 and 3.1, and removed starting with 3.2, I tweaked the code to use <a href="https://docs.python.org/3/c-api/capsule.html" rel="nofollow"><code>Capsule</code></a> (<a href="https://docs.python.org/2/howto/cporting.html#cobject-replaced-with-capsule" rel="nofollow">available</a> in 2.7 and since 3.1):</p>
<pre><code>import ctypes, gi

class _PyGObject_Functions(ctypes.Structure):
    _fields_ = [
        ('register_class',
            ctypes.PYFUNCTYPE(ctypes.c_void_p, ctypes.c_char_p,
                ctypes.c_int, ctypes.py_object, ctypes.py_object)),
        ('register_wrapper',
            ctypes.PYFUNCTYPE(ctypes.c_void_p, ctypes.py_object)),
        ('lookup_class',
            ctypes.PYFUNCTYPE(ctypes.py_object, ctypes.c_int)),
        ('newgobj',
            ctypes.PYFUNCTYPE(ctypes.py_object, ctypes.c_void_p)),
        ]

class PyGObjectCAPI(object):
    def __init__(self):
        self._as_void_ptr.restype = ctypes.c_void_p
        self._as_void_ptr.argtypes = [ctypes.py_object]
        addr = self._as_void_ptr(ctypes.py_object(
            gi._gobject._PyGObject_API))
        self._api = _PyGObject_Functions.from_address(addr)

    @staticmethod
    def _as_void_ptr(obj):
        name = ctypes.pythonapi.PyCapsule_GetName(obj)
        return ctypes.pythonapi.PyCapsule_GetPointer(obj, name)

    def pygobject_new(self, addr):
        return self._api.newgobj(addr)

capi = PyGObjectCAPI()
</code></pre>
<p>(I also renamed it to PyGobjectC<strong>API</strong> -- not sure if CPAI stood for something, but it made more sense to me this way.)</p>
</div>
<div class="post-text" itemprop="text">
<p>PyGOject api changed since <a href="https://stackoverflow.com/a/31913291/1279503">AlliedEnvy update</a></p>
<pre><code>import gi
import ctypes
from ctypes import pythonapi

class _PyGObject_Functions(ctypes.Structure):
    _fields_ = [
        ('pygobject_register_class',
            ctypes.PYFUNCTYPE(ctypes.c_void_p)),
        ('pygobject_register_wrapper',
            ctypes.PYFUNCTYPE(ctypes.c_void_p)),
        ('pygobject_lookup_class',
            ctypes.PYFUNCTYPE(ctypes.c_void_p)),
        ('pygobject_new',
            ctypes.PYFUNCTYPE(ctypes.py_object, ctypes.c_void_p)),
        ]

  class PyGObjectCAPI(object):
    def __init__(self):
        addr = self._as_void_ptr(gi._gobject._PyGObject_API)
        self._api = _PyGObject_Functions.from_address(addr)

    @classmethod
    def _capsule_name(cls, capsule):
        pythonapi.PyCapsule_GetName.restype = ctypes.c_char_p
        pythonapi.PyCapsule_GetName.argtypes = [ctypes.py_object]
        return pythonapi.PyCapsule_GetName(capsule)

    @classmethod
    def _as_void_ptr(cls, capsule):
        name = cls._capsule_name(capsule)
        pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p
        pythonapi.PyCapsule_GetPointer.argtypes = [
            ctypes.py_object, ctypes.c_char_p]
        return pythonapi.PyCapsule_GetPointer(capsule, name)

    def to_object(self, addr):
        return self._api.pygobject_new(addr)

capi = PyGObjectCAPI()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the advent of instrospection files (<code>.typelib</code>, <code>.gir</code>), the same API should be available regardless of the language being used, that is, if you're using a C function not in the API, you're probably using a function intended to be used only internally.</p>
</div>
<span class="comment-copy">In theory that is true. However I wanted to use a function from libdconf, and there is currently no binding for that on my OS (Ubuntu Oneric). Also, it is thinkable that one has to deal with a custom library (not part of Gtk &amp; co.) that returns a pointer to a GObject, so in niche cases this still might be useful.</span>
<span class="comment-copy">@jdm I see, thanks for your feedback.</span>
