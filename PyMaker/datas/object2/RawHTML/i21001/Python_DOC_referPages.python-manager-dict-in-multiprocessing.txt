<div class="post-text" itemprop="text">
<p>Here is a simple multiprocessing code:</p>
<pre><code>from multiprocessing import Process, Manager

manager = Manager()
d = manager.dict()

def f():
    d[1].append(4)
    print d

if __name__ == '__main__':
    d[1] = []
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
<p>Output I get is:</p>
<pre><code>{1: []}
</code></pre>
<p>Why don't I get <code>{1: [4]}</code> as the output?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is what you wrote:</p>
<pre><code># from here code executes in main process and all child processes
# every process makes all these imports
from multiprocessing import Process, Manager

# every process creates own 'manager' and 'd'
manager = Manager() 
# BTW, Manager is also child process, and 
# in its initialization it creates new Manager, and new Manager
# creates new and new and new
# Did you checked how many python processes were in your system? - a lot!
d = manager.dict()

def f():
    # 'd' - is that 'd', that is defined in globals in this, current process 
    d[1].append(4)
    print d

if __name__ == '__main__':
# from here code executes ONLY in main process 
    d[1] = []
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
<p>Here is what you should have written:</p>
<pre><code>from multiprocessing import Process, Manager
def f(d):
    d[1] = d[1] + [4]
    print d

if __name__ == '__main__':
    manager = Manager() # create only 1 mgr
    d = manager.dict() # create only 1 dict
    d[1] = []
    p = Process(target=f,args=(d,)) # say to 'f', in which 'd' it should append
    p.start()
    p.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a bug in manager proxy calls. You can circumvent avoiding call methods of shared list, like:</p>
<pre><code>from multiprocessing import Process, Manager

manager = Manager()
d = manager.dict()

def f():
    # get the shared list
    shared_list = d[1]

    shared_list.append(4)

    # forces the shared list to 
    # be serialized back to manager
    d[1] = shared_list

    print d

if __name__ == '__main__':
    d[1] = []
    p = Process(target=f)
    p.start()
    p.join()

    print d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason that the new item appended to <code>d[1]</code> is not printed is stated in <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.managers.SyncManager.list" rel="noreferrer"><em>Python</em>'s official documentation</a>:</p>
<blockquote>
<p>Modifications to mutable values or items in dict and list proxies will
  not be propagated through the manager, because the proxy has no way of
  knowing when its values or items are modified. To modify such an item,
  you can re-assign the modified object to the container proxy.</p>
</blockquote>
<p>Therefore, this is actually what happens:</p>
<pre><code>from multiprocessing import Process, Manager

manager = Manager()
d = manager.dict()

def f():
    # invoke d.__getitem__(), returning a local copy of the empty list assigned by the main process,
    # (consider that a KeyError exception wasn't raised, so a list was definitely returned),
    # and append 4 to it, however this change is not propagated through the manager,
    # as it's performed on an ordinary list with which the manager has no interaction
    d[1].append(4)
    # convert d to string via d.__str__() (see https://docs.python.org/2/reference/datamodel.html#object.__str__),
    # returning the "remote" string representation of the object (see https://docs.python.org/2/library/multiprocessing.html#multiprocessing.managers.SyncManager.list),
    # to which the change above was not propagated
    print d

if __name__ == '__main__':
    # invoke d.__setitem__(), propagating this assignment (mapping 1 to an empty list) through the manager
    d[1] = []
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
<p>Reassigning <code>d[1]</code> with a new list, or even with the same list once again, after it was updated, triggers the manager to propagate the change:</p>
<pre><code>from multiprocessing import Process, Manager

manager = Manager()
d = manager.dict()

def f():
    # perform the exact same steps, as explained in the comments to the previous code snippet above,
    # but in addition, invoke d.__setitem__() with the changed item in order to propagate the change
    l = d[1]
    l.append(4)
    d[1] = l
    print d

if __name__ == '__main__':
    d[1] = []
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
<p>The line <code>d[1] += [4]</code> would have worked as well.</p>
<hr/>
<p>Alternatively, <a href="https://docs.python.org/3/whatsnew/3.6.html#multiprocessing" rel="noreferrer">Since <em>Python 3.6</em></a>, per <a href="https://hg.python.org/cpython/rev/39e7307f9aee" rel="noreferrer">this changeset</a> following <a href="https://bugs.python.org/issue6766" rel="noreferrer">this issue</a>, it's also possible to <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager.list" rel="noreferrer">use nested Proxy Objects</a> which automatically propagate any changes performed on them to the containing Proxy Object. Thus, replacing the line <code>d[1] = []</code> with <code>d[1] = manager.list()</code> would correct the issue as well:</p>
<pre><code>from multiprocessing import Process, Manager

manager = Manager()
d = manager.dict()

def f():
    d[1].append(4)
    # the __str__() method of a dict object invokes __repr__() on each of its items,
    # so explicitly invoking __str__() is required in order to print the actual list items
    print({k: str(v) for k, v in d.items()}

if __name__ == '__main__':
    d[1] = manager.list()
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
<p>Unfortunately, this bug fix was not ported to <em>Python 2.7</em> (as of <em>Python 2.7.13</em>).</p>
<hr/>
<h2>NOTE (running under the <em>Windows</em> operating system):</h2>
<p>Although the described behaviour applies to the <em>Windows</em> operating system as well, the attached code snippets would fail when executed under <em>Windows</em>  due to the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="noreferrer">different process creation mechanism</a>, that relies on the <a href="https://stackoverflow.com/q/13839935/3903832"><code>CreateProcess()</code> API rather than the <code>fork()</code> system call</a>, which isn't supported.</p>
<p>Whenever a new process is created via the <em>multiprocessing</em> module, <em>Windows</em> creates a fresh <em>Python</em> interpreter process that imports the main module, with potentially hazardous side effects. In order to circumvent this issue, the following programming guideline is <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="noreferrer">recommended</a>:</p>
<blockquote>
<p>Make sure that the main module can be safely imported by a new <em>Python</em> interpreter without causing unintended side effects (such a starting a new process).</p>
</blockquote>
<p>Therefore, executing the attached code snippets as is under <em>Windows</em> would try to create an infinite number of processes due to the <code>manager = Manager()</code> line. This can be easily fixed by creating the <code>Manager</code> and <code>Manager.dict</code> objects inside the <code>if __name__ == '__main__'</code> clause and passing the <code>Manager.dict</code> object as an argument to <code>f()</code>, as done in <a href="https://stackoverflow.com/a/9536888/3903832">this answer</a>.</p>
<p>More details on the issue may be found in <a href="https://stackoverflow.com/a/38236445/3903832">this answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from multiprocessing import Process, Manager
manager = Manager()
d = manager.dict()
l=manager.list()

def f():
    l.append(4)
    d[1]=l
    print d

if __name__ == '__main__':
    d[1]=[]
    p = Process(target=f)
    p.start()
    p.join()
</code></pre>
</div>
<span class="comment-copy">I found this: <a href="http://bugs.python.org/issue6766" rel="nofollow noreferrer">bugs.python.org/issue6766</a>. Is there a patch available?</span>
<span class="comment-copy">d[1]+=[4] works!!</span>
<span class="comment-copy"><a href="http://ideone.com/aviB2" rel="nofollow noreferrer"><code>manager.list()</code> doesn't help</a></span>
<span class="comment-copy">That doesn't actually work, you get: <code>{1: []}</code> instead of <code>{1: [4]}</code></span>
<span class="comment-copy">@crysis405 I fixed that. Looks like manager's dict is not fully dumped while transfering between processes, so we need to replace original value with other list with another id.</span>
<span class="comment-copy">@akaRem, you saved my day, this should be stated very clearly somewhere that Manager() should be single global object for the whole application</span>
<span class="comment-copy">Welcome to Stack Overflow! While this might solve the askers problem it doesn't explain why. It would be good to add some explanation.</span>
