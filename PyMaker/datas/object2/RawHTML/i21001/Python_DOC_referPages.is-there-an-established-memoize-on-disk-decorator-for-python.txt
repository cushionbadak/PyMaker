<div class="post-text" itemprop="text">
<p>I have been searching a bit for a python module that offers a memoize decorator with the following capabilities:</p>
<ul>
<li>Stores cache on disk to be reused among subsequent program runs.</li>
<li>Works for any pickle-able arguments, most importantly numpy arrays.</li>
<li>(Bonus) checks whether arguments are mutated in function calls.</li>
</ul>
<p>I found a few small code snippets for this task and could probably implement one myself, but I would prefer having an established package for this task. I also found <a href="http://www.stanford.edu/~pgbovine/incpy.html">incpy</a>, but that does not seem to work with the standard python interpreter.</p>
<p>Ideally, I would like to have something like <a href="http://docs.python.org/dev/library/functools.html#functools.lru_cache"><code>functools.lru_cache</code></a> plus cache storage on disk. Can someone point me to a suitable package for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know of any memoize decorator that takes care of all that, but you might want to have a look at <a href="http://www.zodb.org/" rel="nofollow">ZODB</a>. It's a persistence system built on top of <code>pickle</code> that provides some additional features including being able move objects from memory to disk when they aren't being used and the ability to save only objects that have been modified.</p>
<p>Edit: As a follow-up for the comment. A memoization decorator isn't supported out of the box by ZODB. However, I think you can:</p>
<ul>
<li>Implement your own <a href="http://www.zodb.org/documentation/guide/prog-zodb.html#writing-a-persistent-class" rel="nofollow">persistent class</a></li>
<li>Use a memoization decorator in the methods you need (any standard implementation should work, but it probably needs to be modified to make sure that the <a href="http://www.zodb.org/documentation/guide/prog-zodb.html#rules-for-writing-persistent-classes" rel="nofollow">dirty bit</a> is set)</li>
</ul>
<p>After that, if you create an object of that class and add it to a ZODB database, when you execute one of the memoized methods, the object will be marked as dirty and changes will be saved to the database in the next transaction commit operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>I realize this is a 2-year-old question, and that this wouldn't count as an "established" decorator, but…</p>
<p>This is simple enough that you really don't need to worry about only using established code. The module's <a href="http://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">docs</a> link to the <a href="http://hg.python.org/cpython/file/3.3/Lib/functools.py#l192" rel="nofollow noreferrer">source</a> because, in addition to being useful in its own right, it works as sample code.</p>
<p>So, what do you need to add? Add a <code>filename</code> parameter. At run time, <code>pickle.load</code> the filename into the <code>cache</code>, using <code>{}</code> if it fails. Add a <code>cache_save</code> function that just <code>pickle.save</code>s the cache to the file under the lock. Attach that function to <code>wrapper</code> the same as the existing ones (<code>cache_info</code>, etc.).</p>
<p>If you want to save the cache automatically, instead of leaving it up to the caller, that's easy; it's just a matter of when to do so. Any option you come up with—<code>atexit.register</code>, adding a <code>save_every</code> argument so it saves every <code>save_every</code> misses, …—is trivial to implement. In <a href="https://stackoverflow.com/a/20085884/908494">this answer</a> I showed how little work it takes. Or you can get a complete working version (to customize, or to use as-is) <a href="https://github.com/abarnert/persistent-lru-cache" rel="nofollow noreferrer">on GitHub</a>.</p>
<p>There are other ways you could extend it—put some save-related statistics (last save time, hits and misses since last save, …) in the <code>cache_info</code>, copy the cache and save it in a background thread instead of saving it inline, etc. But I can't think of anything that would be worth doing that wouldn't be easy.</p>
</div>
<span class="comment-copy">Thanks for the hint. So it seems that ZODB is quite good when it comes to flexibly storing data in memory or on disk. But what would be the significant advantages in the context of memoization?</span>
<span class="comment-copy">So I guess the persistent class should be the class where the memoization decorator is defined, and the memoization cache would be an attribute of that class. I'll try this in the near future...</span>
