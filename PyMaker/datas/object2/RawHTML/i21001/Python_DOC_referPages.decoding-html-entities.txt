<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2087370/decode-html-entities-in-python-string">Decode HTML entities in Python string?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I'm doing some web scraping and sites frequently use HTML entities to represent non ascii characters. Does Python have a utility that takes a string with HTML entities and returns a unicode type?</p>
<p>For example:</p>
<p>I get back:</p>
<pre><code>&amp;#x01ce;
</code></pre>
<p>which represents an "ǎ" with a tone mark.  In binary, this is represented as the 16 bit 01ce.  I want to convert the html entity into the value  <code>u'\u01ce'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Python has the <a href="https://docs.python.org/2/library/htmllib.html#module-htmlentitydefs" rel="noreferrer">htmlentitydefs</a> module, but this doesn't include a function to unescape HTML entities.</p>
<p>Python developer Fredrik Lundh (author of elementtree, among other things) has  such a function <a href="http://effbot.org/zone/re-sub.htm#unescape-html" rel="noreferrer">on his website</a>, which works with decimal, hex and named entities:</p>
<pre><code>import re, htmlentitydefs

##
# Removes HTML or XML character references and entities from a text string.
#
# @param text The HTML (or XML) source text.
# @return The plain text, as a Unicode string, if necessary.

def unescape(text):
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&amp;#":
            # character reference
            try:
                if text[:3] == "&amp;#x":
                    return unichr(int(text[3:-1], 16))
                else:
                    return unichr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            # named entity
            try:
                text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text # leave as is
    return re.sub("&amp;#?\w+;", fixup, text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The standard lib’s very own HTMLParser has an undocumented function unescape() which does exactly what you think it does:</p>
<pre><code>import HTMLParser
h = HTMLParser.HTMLParser()
h.unescape('&amp;copy; 2010') # u'\xa9 2010'
h.unescape('&amp;#169; 2010') # u'\xa9 2010'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the builtin <code>unichr</code> -- BeautifulSoup isn't necessary:</p>
<pre><code>&gt;&gt;&gt; entity = '&amp;#x01ce'
&gt;&gt;&gt; unichr(int(entity[3:],16))
u'\u01ce'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative, if you have lxml:</p>
<pre><code>&gt;&gt;&gt; import lxml.html
&gt;&gt;&gt; lxml.html.fromstring('&amp;#x01ce').text
u'\u01ce'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are on Python 3.4 or newer, you can simply use the <a href="https://docs.python.org/3.4/library/html.html#html.unescape" rel="nofollow noreferrer"><code>html.unescape</code></a>:</p>
<pre><code>import html

s = html.unescape(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could find an answer here -- <a href="https://stackoverflow.com/questions/53224/getting-international-characters-from-a-web-page#53246">Getting international characters from a web page?</a></p>
<p><strong>EDIT</strong>: It seems like <code>BeautifulSoup</code> doesn't convert entities written in hexadecimal form. It can be fixed:</p>
<pre><code>import copy, re
from BeautifulSoup import BeautifulSoup

hexentityMassage = copy.copy(BeautifulSoup.MARKUP_MASSAGE)
# replace hexadecimal character reference by decimal one
hexentityMassage += [(re.compile('&amp;#x([^;]+);'), 
                     lambda m: '&amp;#%d;' % int(m.group(1), 16))]

def convert(html):
    return BeautifulSoup(html,
        convertEntities=BeautifulSoup.HTML_ENTITIES,
        markupMassage=hexentityMassage).contents[0].string

html = '&lt;html&gt;&amp;#x01ce;&amp;#462;&lt;/html&gt;'
print repr(convert(html))
# u'\u01ce\u01ce'
</code></pre>
<p><strong>EDIT</strong>: </p>
<p><a href="http://effbot.org/zone/re-sub.htm#unescape-html" rel="nofollow noreferrer"><code>unescape()</code></a> function mentioned by <a href="https://stackoverflow.com/questions/57708/convert-xml-html-entities-into-unicode-string-in-python/58125#58125">@dF</a> which uses  <code>htmlentitydefs</code> standard module and <code>unichr()</code> might be more appropriate in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a function which should help you to get it right and convert entities back to utf-8 characters.</p>
<pre><code>def unescape(text):
   """Removes HTML or XML character references 
      and entities from a text string.
   @param text The HTML (or XML) source text.
   @return The plain text, as a Unicode string, if necessary.
   from Fredrik Lundh
   2008-01-03: input only unicode characters string.
   http://effbot.org/zone/re-sub.htm#unescape-html
   """
   def fixup(m):
      text = m.group(0)
      if text[:2] == "&amp;#":
         # character reference
         try:
            if text[:3] == "&amp;#x":
               return unichr(int(text[3:-1], 16))
            else:
               return unichr(int(text[2:-1]))
         except ValueError:
            print "Value Error"
            pass
      else:
         # named entity
         # reescape the reserved characters.
         try:
            if text[1:-1] == "amp":
               text = "&amp;amp;amp;"
            elif text[1:-1] == "gt":
               text = "&amp;amp;gt;"
            elif text[1:-1] == "lt":
               text = "&amp;amp;lt;"
            else:
               print text[1:-1]
               text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
         except KeyError:
            print "keyerror"
            pass
      return text # leave as is
   return re.sub("&amp;#?\w+;", fixup, text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure why the Stack Overflow thread does not include the ';' in the search/replace (i.e. lambda m: '&amp;#%d*<em>;</em>*') If you don't, BeautifulSoup can barf because the adjacent character can be interpreted as part of the HTML code (i.e. &amp;#39B for &amp;#39Blackout).                                                                                                                                                                                                                                                                                     </p>
<p>This worked better for me:</p>
<pre><code>import re
from BeautifulSoup import BeautifulSoup

html_string='&lt;a href="/cgi-bin/article.cgi?f=/c/a/2010/12/13/BA3V1GQ1CI.DTL"title=""&gt;&amp;#x27;Blackout in a can; on some shelves despite ban&lt;/a&gt;'

hexentityMassage = [(re.compile('&amp;#x([^;]+);'), 
lambda m: '&amp;#%d;' % int(m.group(1), 16))]

soup = BeautifulSoup(html_string, 
convertEntities=BeautifulSoup.HTML_ENTITIES, 
markupMassage=hexentityMassage)
</code></pre>
<ol>
<li>The int(m.group(1), 16) converts the number (specified in base-16) format back to an integer.                                                                             </li>
<li>m.group(0) returns the entire match, m.group(1) returns the regexp capturing group                                                                                   </li>
<li>Basically using markupMessage is the same as:<br/>
html_string = re.sub('&amp;#x([^;]+);', lambda m: '&amp;#%d;' % int(m.group(1), 16), html_string)                                                                            </li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Another solution is the builtin library xml.sax.saxutils (both for html and xml). However, it will convert only &amp;gt, &amp;amp and &amp;lt.</p>
<pre><code>from xml.sax.saxutils import unescape

escaped_text = unescape(text_to_escape)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the Python 3 version of <a href="https://stackoverflow.com/a/58125/2086547">dF's answer</a>:</p>
<pre><code>import re
import html.entities

def unescape(text):
    """
    Removes HTML or XML character references and entities from a text string.

    :param text:    The HTML (or XML) source text.
    :return:        The plain text, as a Unicode string, if necessary.
    """
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&amp;#":
            # character reference
            try:
                if text[:3] == "&amp;#x":
                    return chr(int(text[3:-1], 16))
                else:
                    return chr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            # named entity
            try:
                text = chr(html.entities.name2codepoint[text[1:-1]])
            except KeyError:
                pass
        return text # leave as is
    return re.sub("&amp;#?\w+;", fixup, text)
</code></pre>
<p>The main changes concern <code>htmlentitydefs</code> that is now <code>html.entities</code> and <code>unichr</code> that is now <code>chr</code>. See this <a href="http://docs.pythonsprints.com/python3_porting/py-porting.html#reorganization" rel="nofollow noreferrer">Python 3 porting guide</a>.</p>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/2087370/4279">Decode HTML entities in Python string?</a></span>
<span class="comment-copy">Absolutely. Why is not in stdlib?</span>
<span class="comment-copy">Looking at its code, it doesn't seem to work with <code>&amp;amp;</code> and such, does it?</span>
<span class="comment-copy">Just tested successfully for &amp;amp;</span>
<span class="comment-copy"><a href="http://ideone.com/u60Fz" rel="nofollow noreferrer">it also works for hex entities</a>. The <a href="http://hg.python.org/cpython/file/60c831305e73/Lib/HTMLParser.py#l444" rel="nofollow noreferrer">implementation is very similar</a> to unescape() function from <a href="http://stackoverflow.com/a/58125/4279">@dF.'s answer</a>.</span>
<span class="comment-copy">This method isn't documented in Python's HTMLParser documentation, and there's a comment in the source stating it's intended for internal use. However, it works like treat in Python 2.6 through 2.7, and is probably the best solution out there. Prior to version 2.6, it would only decode named entities like <code>&amp;amp;</code> or <code>&amp;gt;</code>.</span>
<span class="comment-copy">It is exposed as <code>html.unescape()</code> function in Python 3.4+</span>
<span class="comment-copy">This raise <code>UnicodeDecodeError</code> with utf-8 strings. You must either <code>decode('utf-8')</code> it first or use <code>xml.sax.saxutils.unescape</code>.</span>
<span class="comment-copy">But that requires you to automatically and unambiguously know where in the string the encoded Unicode character is/are - which you can't know. And you need to <code>try...catch</code> the resulting exception for when you get it wrong.</span>
<span class="comment-copy"><code>unichar</code> was removed in python3. Any suggestion for that version?</span>
<span class="comment-copy">Be careful though, because this can also return an object of type <code>str</code> if there is no special character.</span>
<span class="comment-copy">best solution when everything fails, only lxml comes to rescue. :)</span>
<span class="comment-copy">This solution doesn't work with the example:  print BeautifulSoup('&lt;html&gt;&amp;#x01ce;&lt;/html&gt;', convertEntities=BeautifulSoup.HTML_ENTITIES)  This returns the same HTML entity</span>
<span class="comment-copy">I've edited the answer</span>
<span class="comment-copy">Note: this only applied to BeautifulSoup 3, deprecated and considered legacy since 2012. BeautifulSoup 4 handles HTML entities like these automatically.</span>
<span class="comment-copy">@MartijnPieters: correct. <a href="https://stackoverflow.com/questions/57708/convert-xml-html-entities-into-unicode-string-in-python/58125#comment41165970_12614706"><code>html.unescape()</code></a> is a better option on the modern Python.</span>
<span class="comment-copy">Absolutely. If all you wanted was to decode HTML entities there is no need to use BeatifulSoup at all.</span>
<span class="comment-copy">Why is this answer modded down? It seems useful to me.</span>
<span class="comment-copy">because the person wanted the character in unicode instead of utf-8 characters. I guess :)</span>
<span class="comment-copy">thanks for spotting the bug. I've edited <a href="http://stackoverflow.com/questions/57708/convert-xml-html-entities-into-unicode-string-in-python/57745#57745">my answer</a>.</span>
<span class="comment-copy">In Python 3, you'd just use <code>html.unescape()</code>; why have a dog and bark yourself?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/html.entities.html#html.entities.entitydefs" rel="nofollow noreferrer"><code>html.entities.entitydefs["apos"]</code></a> does not exist, and <a href="https://docs.python.org/3/library/html.html#html.unescape" rel="nofollow noreferrer"><code>html.unescape('can&amp;apos;t')</code></a> produces <code>"can't"</code> which uses the U+0027 (<code>'</code>) instead of the proper U+2019 (<code>’</code>) (or U+02BC, depending on which argument you follow.). But I guess that’s intended according to the <a href="https://dev.w3.org/html5/html-author/charref" rel="nofollow noreferrer">character entity reference</a>.</span>
