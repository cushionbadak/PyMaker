<div class="post-text" itemprop="text">
<p>The following code prints 123:</p>
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; def f():
...     print a
...
&gt;&gt;&gt; f()
123
&gt;&gt;&gt;
</code></pre>
<p>But the following fails:</p>
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; def f():
...     print a
...     a = 456
...     print a
...
&gt;&gt;&gt; f()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in f
UnboundLocalError: local variable 'a' referenced before assignment
&gt;&gt;&gt;
</code></pre>
<p>I would have expected this to print:</p>
<pre><code>123
456
</code></pre>
<p>What am I missing here?</p>
<p>P.S. I'm using Python 2.6.6 if that matters.</p>
</div>
<div class="post-text" itemprop="text">
<p>If a function only reads from a variable, it's assumed to be global. If the function writes to  it ever, it's assumed to be local. In your second function, a is written to, so it's assumed to be local. Then the line above (where it's read from) isn't valid.</p>
<p>Here's a link to the Python FAQ: <a href="http://docs.python.org/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python">http://docs.python.org/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a></p>
</div>
<div class="post-text" itemprop="text">
<p>What you are using is named a <a href="http://ynniv.com/blog/2007/08/closures-in-python.html" rel="nofollow">closure</a>: you take a variable from the outter scope and enclose in a function block.</p>
<p>Your code is perfectly alright, and would work in javascript.</p>
<p>Unfortunatly, in Python, closures are read-only.</p>
<p>And the error is always <code>UnboundLocalError: local variable 'var_name' referenced before assignment</code> which is completly misleading.</p>
<p>En short, <strong>this is not you, it's a language limitation combined a bad error message</strong>.</p>
<p>EDIT:</p>
<p>I can see several persons here advocating the use of <code>global</code>, <strong>which has dangerous side effects</strong>: you would get access to variables with the same name several scopes above the current one, which is not what you want with closures.</p>
<p>The solution has been added in Python 3, with the <code>nonlocal</code> keyword which does exactly that: rebind a variable from the outer scope in the inner scope.</p>
<p>There is a way to <a href="http://davidchambersdesign.com/simulating-nonlocal-in-python-2.x/" rel="nofollow">simulate nonlocal for python 2.x</a>, but really you are better off just just not assign anything to your variable: copy values, return values, modify in place only mutable types and you will be fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's becouse Python automatically acts like the variable is global unless you define or try to modify it in function. Try adding <code>global a</code> to your code.</p>
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; def f():
...     global a
...     print a
...     a = 456
...     print a
... 
&gt;&gt;&gt; f()
123
456
&gt;&gt;&gt; a
456
</code></pre>
<p>In the first example you did not define and did not modify, so it was a global one. But if you would like to, for example, add 20 to a, you also have to use <code>global a</code>.</p>
<p>Also be aware, that the a in f function is a global and it's value will differ after the run of f function.</p>
<p>If you want to create a local variable, then remember, that declaration always go before the reading, so <code>print a</code> can not be done before <code>a = 456</code>.</p>
<p>EDIT:
Ok, while we're talking about closures and dangerous of using global there's other possibility.</p>
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; def f():
...     b = a
...     print b
...     b = 456
...     print b
... 
&gt;&gt;&gt; f()
123
456
&gt;&gt;&gt; a
123
&gt;&gt;&gt; 
</code></pre>
<p>Here we use a closure read-only ability to make a copy of a and than modify this copy, without modifing the outside <code>a</code> variable AS LONG AS IT'S INTEGER. Remember, that <code>b</code> keeps a reference to <code>a</code>. If <code>a</code> is, for example, a list and the <code>f</code> operation is like <code>b.append(3)</code>, then both <code>a</code> and <code>b</code> will be available and modified outside the scope.</p>
<p>The choice of method is different due to needs.</p>
</div>
<div class="post-text" itemprop="text">
<p>The comment space is too small to fit the quotes below, so I post a new answer here.</p>
<p>I think this is variable scope problem. In the <a href="http://docs.python.org/3/reference/executionmodel.html" rel="nofollow">Execution Model</a> of Python doc it says:</p>
<blockquote>
<p>If a name binding operation occurs anywhere within a code block, all
  uses of the name within the block are treated as references to the
  current block. This can lead to errors when a name is used within a
  block before it is bound. This rule is subtle. Python lacks
  declarations and allows name binding operations to occur anywhere
  within a code block. The local variables of a code block can be
  determined by scanning the entire text of the block for name binding
  operations.</p>
</blockquote>
</div>
<span class="comment-copy">Without a parameter to supply your variable reference to the method, you're going to have to rely on <code>a</code> to be declared in the code, before the call to function <code>f()</code> just to <code>print a</code> in the first place. Side effects abound.</span>
<span class="comment-copy">I added a solution to your problem, but usally you just want to avoid writting the close. Just make an intermediary variable and returns the result.</span>
<span class="comment-copy">OK, but isn't Python interpreted? I would expect the print to work then fail when I try the assignment (since I would be assigning to a global variable without the <code>global</code> declaration being present). Why does it fail on the print and not the assigment?</span>
<span class="comment-copy">Python is compiled. It's just it compiles to bytecode, to run over a virtual machine (ie. exactly like Java)</span>
<span class="comment-copy">Python is compiled to byte-code at runtime. When a function is compiled, the compiler determines which names are locals are which globals (and other stuff, like if the function is actually a generator when it contains yield statements).</span>
<span class="comment-copy">No it's not. Create a class and a method, then copy/paste his complete code inside the method. You'll see the same problem. You could not use global from here: it could accidently take a variable from outside the class, when what you want is just the one outside the current scope.</span>
<span class="comment-copy">@e-satis python 3's <code>nonlocal</code> solves exactly this problem, causing the compiler to look for bindings of the name in outer, nonglobal scope</span>
<span class="comment-copy">Didn't know closures were read-only. Are there any other limitations to Python closures? Where could I find more info? (on the limitations that is)</span>
<span class="comment-copy">+1 for mentioning read-only closures.</span>
<span class="comment-copy">If the error was that the closure was read-only, wouldn't the error occur on the assignment line rather than the print statement?</span>
<span class="comment-copy">I know it doesn't make sense, but this behavior depends of the implementation. I'd be curious to see what happens in Jython or IronPython. @ElenaT: there is absolutely nothing in the documentation about it, you can find blog post from frustrated people here and there. I put a link in my answer. This sucks because you do use closure a lotwhen you create decorator.</span>
<span class="comment-copy">the problem here looks more like variable scope problem than read-only closure problem. local <code>a</code> scope in cpython starts at the beginning of the function (and probably other blocks that can have their own locals) instead of at first assignment, which is very counter-intuitive IMO.</span>
<span class="comment-copy">Not it's not. You would have the same problem if you would do the same code within a method. Using global would then be dangerous, you would get the variable ouside of the class if it exists.</span>
<span class="comment-copy">I've applied your leads in my edit of the answer.</span>
<span class="comment-copy">Thanks, switching the -1 to a +1</span>
<span class="comment-copy">The "we use a closure read-only [...]" makes no sense here. <code>b = xxx</code> makes <code>b</code> reference something new, and won't affect <code>a</code> in any way, even if you do it in the same scope where <code>a</code> is defined.</span>
<span class="comment-copy">Well both of us made a mistake. Me in saying, that this way you won't modify the variable outside the scope. You in saying, that <code>b</code> won't affect <code>a</code> in any way. That depends on the type of <code>a</code>. If you want to check it, simply define <code>a</code> as a list <code>b</code> as a reference to <code>a</code> and then append anything to <code>b</code>. After running the function both <code>a</code> and <code>b</code> will be the same, what means that actually they were affected. <code>b</code> is a reference to <code>a</code>, not a copy of <code>a</code>.</span>
