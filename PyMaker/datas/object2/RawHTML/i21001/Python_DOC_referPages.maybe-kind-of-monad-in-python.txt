<div class="post-text" itemprop="text">
<p>Trying to find a way to clean up some of my code.</p>
<p>So, I have something like this in my Python code:</p>
<pre class="lang-py prettyprint-override"><code>company = None
country = None

person = Person.find(id=12345)
if person is not None: # found        
    company = Company.find(person.companyId)

    if company is not None:
         country = Country.find(company.countryId)

return (person, company, country)
</code></pre>
<p>Having read a tutorial on Haskell's monads (in particular <em>Maybe</em>), I was wondering if it's possible to write it in another way.</p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>company = country = None
try:
    person  =  Person.find(id=12345)
    company = Company.find(person.companyId)
    country = Country.find(company.countryId)
except AttributeError:
    pass # `person` or `company` might be None
</code></pre>
<p><a href="http://docs.python.org/glossary.html#term-eafp">EAFP</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Exploit the short-circuit behavior and that a custom object is true by default and <code>None</code> is false:</p>
<pre><code>person  = Person.find(id=12345)
company = person and person.company
country = company and company.country
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python does not have a particularly nice syntax for monads. That being said, if you want to limit yourself to using something like the <code>Maybe</code> monad (Meaning that you'll only be able to use <code>Maybe</code>; you won't be able to make generic functions that deal with any monad), you can use the following approach:</p>
<pre class="lang-py prettyprint-override"><code>class Maybe():
    def andThen(self, action): # equivalent to Haskell's &gt;&gt;=
        if self.__class__ == _Maybe__Nothing:
            return Nothing
        elif self.__class__ == Just:
            return action(self.value)

    def followedBy(self, action): # equivalent to Haskell's &gt;&gt;
        return self.andThen(lambda _: action)

class _Maybe__Nothing(Maybe):
    def __repr__(self):
        return "Nothing"

Nothing = _Maybe__Nothing()

class Just(Maybe):
    def __init__(self, v):
        self.value = v
    def __repr__(self):
        return "Just(%r)" % self.value
</code></pre>
<p>Then, make all of the methods that currently return <code>None</code> return either <code>Just(value)</code> or <code>Nothing</code> instead. This allows you to write this code:</p>
<pre class="lang-py prettyprint-override"><code>Person.find(id=12345).andThen(lambda person: Company.find(person.companyId)).andThen(lambda company: Country.find(company.countryId))
</code></pre>
<p>You can of course adapt the lambdas to store the intermediate results in variables; it's up to you how to do that properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you checked PyMonad ?</p>
<p><a href="https://pypi.python.org/pypi/PyMonad/" rel="nofollow noreferrer">https://pypi.python.org/pypi/PyMonad/</a></p>
<p>It not only includes a Maybe monad, but also a list monad, a Functor and Applicative functor classes. Monoids and more.</p>
<p>In your case it would be something like:</p>
<pre><code>country = Person.find(id=12345)          &gt;&gt; (lambda person: 
          Company.find(person.companyId) &gt;&gt; (lambda company: 
          Country.find(company.countryId))
</code></pre>
<p>Easier to understand and cleaner than EAFP.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>person = Person.find(id=12345)
company = None if person is None else Company.find(person.companyId)
country = None if company is None else Country.find(company.countryId)

return (person, company, country)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a perfect fit for:</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">getattr(object, name[, default])</a></p>
</blockquote>
<p>I find <code>getattr</code> essential when working with objects and attributes. It's pretty much the equivalent to <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get(key[, default])</code></a>.</p>
<pre><code>person  = Person.find(id=12345)
company = person and getattr(person, 'company', None)
country = company and getattr(company, 'country', None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>More "Pythonic" than trying to implement a different paradigm (not that it is not interesting and cool) would be to add intelligence to your objects so that they can find their attributes (and whether they exist at all), by themselves.</p>
<p>Bellow is an example of a base class that uses your "find" method and the correlation of the Id  attribute names and class names to work with your example - I put in  minimal Person and Company classes for a search for the company to work:</p>
<pre><code>class Base(object):
    def __getattr__(self, attr):
        if hasattr(self, attr + "Id"):
            return globals()[attr.title()].find(getattr(self, attr + "Id"))
        return None
    @classmethod
    def find(cls, id):
        return "id %d " % id

class Person(Base):
    companyId=5

class Company(Base):
    pass
</code></pre>
<p>And on the console, after pasting the code above:</p>
<pre><code>&gt;&gt;&gt; p = Person()
&gt;&gt;&gt; p.company
'id 5 '
</code></pre>
<p>With this <code>Base</code> your code above could just be:</p>
<pre><code>person = Person.find(id=12345)
company = person.company
country = company and company.country
</code></pre>
</div>
<span class="comment-copy">This is unequivocally the correct answer for this specific case. The entire purpose of <code>Maybe</code> as a monad is to model the EAFP approach explicitly as a first-class entity. In Python, it's both implicit and idiomatic in this form, so use it!</span>
<span class="comment-copy">@drozzy: If you need to conditionally execute different pieces of code depending on which variables are <code>None</code>, then self-evidently you need conditionals.</span>
<span class="comment-copy">Why is Person.find inside the try except block?</span>
<span class="comment-copy">The problem with using exceptions (EAFP) is that you cannot distinguish between errors (function call cannot complete) and empty result (function call completed correctly and returned nothing). The word "exception" means "something that normally should not happen" (probably an error). Using exceptions to model the normal flow of control is misleading. Maybe it would be less bad if they were called throwables.</span>
<span class="comment-copy">@Giorgio: good point about <code>AttributeError</code> catching too much (though normally, it would indicate a bug in the code if <code>AttributeError</code> is raised unintentionally). There is a precedent in Python to use exceptions for control flow: <code>StopIteration</code> is used to stop a <code>for</code>-loop, <code>GeneratorExit</code> for <code>generator.close()</code>, even <code>sys.exit()</code> is just <code>SystemExit</code> exception. <a href="http://stackoverflow.com/a/8507638/4279">Without <code>AttributeError</code> it looks less elegant</a>.</span>
<span class="comment-copy">Also, another problem I ran into here, is that I don't get the "intermediate" values - like "person", and "company" in the end. This only gives me a Maybe of country.</span>
<span class="comment-copy">If you want to get all the results, you have to wrap your lambdas like this: <code>Person.find(id=12345).andThen(lambda person: Company.find(person.companyId).andThen(lambda company: Country.find(company.countryId).andThen(lambda country: Just((person, company, country)))))</code>. Note the ridiculous amount of parens; they can't be avoided if you want to program in a functional style like this.</span>
<span class="comment-copy">@dflemstr So the last "andThen" is essentially there just to return the result? Interesting.</span>
<span class="comment-copy">I'd actually write that the other way round <code>company = Company.find(person.companyID) if person else None</code>. It removes the <code>is None</code> and the normal case is first, rather than the exceptional one.</span>
<span class="comment-copy">Hm... I think you misunderstood me. Find is actually supposed to return a "Person" object, with attributes like "firstName, lastName" etc... It's not supposed to just return the id. Or maybe I am missing the point?</span>
<span class="comment-copy">I did understand you -  it is just my implementation of <code>find</code>that returns the string, to differeniate it from the id number (hardcoded as 5) - what is new here is the <code>__getattr__</code>- you would keep the exact same find method you have now.</span>
<span class="comment-copy">Sorry, but I have no idea what this line does: <code>globals()[attr.title()].find(getattr(self, attr + "Id"))</code></span>
<span class="comment-copy">@drozzy: it converts <code>person.company</code> into <code>Person.find(person.companyId)</code>. Your actual issue <code>person is None</code> is not addressed. <code>company is None</code> is addressed using <a href="http://stackoverflow.com/a/8507638/4279">the <code>and</code> operator's short-circuit behavior as in my answer</a></span>
