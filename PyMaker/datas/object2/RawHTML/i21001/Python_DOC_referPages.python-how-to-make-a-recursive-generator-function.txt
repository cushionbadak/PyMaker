<div class="post-text" itemprop="text">
<p>I have been working on generating all possible submodels for a biological problem. I have a working recursion for generating a big list of all the submodels I want. However, the lists get unmanageably large pretty fast (N=12 is just possible in the example below, N&gt;12 uses too much memory). So I wanted to convert it to a generator function using yield instead, but I'm stuck.</p>
<p>My working recursive function looks like this:</p>
<pre><code>def submodel_list(result, pat, current, maxn):
    ''' result is a list to append to
        pat is the current pattern (starts as empty list)
        current is the current number of the pattern
        maxn is the number of items in the pattern
    '''
    if pat:
        curmax = max(pat)
    else: 
        curmax = 0
    for i in range(current):
        if i-1 &lt;= curmax:
            newpat = pat[:]
            newpat.append(i)
            if current == maxn:
                result.append(newpat)
            else:
                submodel_generator(result, newpat, current+1, maxn)

result = []
submodel_list(result, [], 1, 5)
</code></pre>
<p>That gives me the expected list of submodels for my purposes.</p>
<p>Now, I want to get that same list using a recursion. Naively, I thought I could just switch out my result.append() for a yield function, and the rest would work OK. So I tried this:</p>
<pre><code>def submodel_generator(pat, current, maxn):
    '''same as submodel_list but yields instead'''
    if pat:
        curmax = max(pat)
    else: 
        curmax = 0
    for i in range(current):
        print i, current, maxn
        if i-1 &lt;= curmax:
            print curmax

            newpat = pat[:]
            newpat.append(i)
            if current == maxn:
                yield newpat
            else:
                submodel_generator(newpat, current+1, maxn)

b = submodel_generator([], 1, 5)
for model in b: print model
</code></pre>
<p>But now I get nothing. A (very dumb) bit of digging tells me the function gets to the final else statement once, then stops - i.e. the recursion no longer works. </p>
<p>Is there a way to turn my first, clunky, list-making function into a nice neat generator function? Is there something silly I've missed here? All help hugely appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You should change this:</p>
<pre><code>submodel_generator(newpat, current+1, maxn)
</code></pre>
<p>to this:</p>
<pre><code>for b in submodel_generator(newpat, current+1, maxn):
    yield b
</code></pre>
<p>This will recursively yield the value from successive calls to the function.</p>
<p><strong>[Update]:</strong> Note that as of Python 3.3, you can use the new <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380">yield from</a> syntax:</p>
<pre><code>yield from submodel_generator(newpat, current+1, maxn)
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/248830/python-using-a-recursive-algorithm-as-a-generator">Python: using a recursive algorithm as a generator</a></span>
<span class="comment-copy">In Python 3.3 you can use <code>yield from submodel_generator(...)</code>.  Coming soon...</span>
<span class="comment-copy">@DietrichEpp, ah, that got accepted? Cool.</span>
<span class="comment-copy">@senderle I agree it's very similar in nature to that post, but unfortunately I'm not good enough at Python to be able to understand what it was that made that one work, so I thought I'd post my similar example anyway, in the hopes of some much needed help!</span>
<span class="comment-copy">The cool thing about <code>yield from</code> is that unlike <code>for ... yield</code> it properly handles generator's <code>.send()</code> and <code>.throw()</code> methods.</span>
