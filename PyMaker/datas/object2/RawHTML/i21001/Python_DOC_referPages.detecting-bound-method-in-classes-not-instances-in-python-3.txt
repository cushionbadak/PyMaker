<div class="post-text" itemprop="text">
<p>Given a class <code>C</code> with a function or method <code>f</code>, I use <code>inspect.ismethod(obj.f)</code> (where <code>obj</code> is an instance of <code>C</code>) to find out if <code>f</code> is bound method or not. Is there a way to do the same directly at the class level (without creating an object)? </p>
<p>inspect.ismethod does not work as this:</p>
<pre><code>class C(object):

    @staticmethod
    def st(x):
        pass

    def me(self):
        pass

obj = C()
</code></pre>
<p>results in this (in Python 3):</p>
<pre><code>&gt;&gt;&gt; inspect.ismethod(C.st) 
False
&gt;&gt;&gt; inspect.ismethod(C.me)
False
&gt;&gt;&gt; inspect.ismethod(obj.st) 
False
&gt;&gt;&gt; inspect.ismethod(obj.me)
True
</code></pre>
<p>I guess I need to check if the function/method is member of a class and not static but I was not able to do it easily. I guess it could be done using <code>classify_class_attrs</code> as shown here 
<a href="https://stackoverflow.com/questions/484890/how-would-you-determine-where-each-property-and-method-of-a-python-class-is-defi">How would you determine where each property and method of a Python class is defined?</a>
but I was hoping there was another more direct way.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are no unbound methods in Python 3, so you cannot detect them either. All you have is regular functions. At most you can see if they have a <a href="https://docs.python.org/3/glossary.html#term-qualified-name" rel="nofollow">qualified name with a dot</a>, indicating that they are <em>nested</em>, and their first argument name is <code>self</code>:</p>
<pre><code>if '.' in method.__qualname__ and inspect.getargspec(method).args[0] == 'self':
    # regular method. *Probably*
</code></pre>
<p>This of course fails entirely for static methods and nested functions that happen to have <code>self</code> as a first argument, as well as regular methods that do not use <code>self</code> as a first argument (flying in the face of convention).</p>
<p>For static methods and class methods, you'd have to look at the <em>class dictionary</em> instead:</p>
<pre><code>&gt;&gt;&gt; isinstance(vars(C)['st'], staticmethod)
True
</code></pre>
<p>That's because <code>C.__dict__['st']</code> is the actual <code>staticmethod</code> instance, before <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">binding to the class</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Could you use <code>inspect.isroutine(...)</code>? Running it with your class <code>C</code> I get:</p>
<pre><code>&gt;&gt;&gt; inspect.isroutine(C.st)
True
&gt;&gt;&gt; inspect.isroutine(C.me)
True
&gt;&gt;&gt; inspect.isroutine(obj.st)
True
&gt;&gt;&gt; inspect.isroutine(obj.me)
True
</code></pre>
<p>Combining the results of <code>inspect.isroutine(...)</code> with the results of <code>inspect.ismethod(...)</code> may enable you to infer what you need to know.</p>
<p><strong>Edit:</strong> dm03514's answer suggests you might also try <code>inspect.isfunction()</code>:</p>
<pre><code>&gt;&gt;&gt; inspect.isfunction(obj.me)
False
&gt;&gt;&gt; inspect.isfunction(obj.st)
True
&gt;&gt;&gt; inspect.isfunction(C.st)
True
&gt;&gt;&gt; inspect.isfunction(C.me)
False
</code></pre>
<p>Though as Hernan has pointed out, the results of <code>inspect.isfunction(...)</code> change in python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since inspect.ismethod returns True for both bound and unbound methods in Python 2.7 (ie., is broken), I'm using:</p>
<pre><code>def is_bound_method(obj):
    return hasattr(obj, '__self__') and obj.__self__ is not None
</code></pre>
<p>It also works for methods of classes implemented in C, e.g., int:</p>
<pre><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; is_bound_method(a.__add__)
True
&gt;&gt;&gt; is_bound_method(int.__add__)
False
</code></pre>
<p>But is not very useful in that case because inspect.getargspec does not work for functions implemented in C.</p>
<p>is_bound_method works unchanged in Python 3, but in Python 3, inspect.ismethod properly distinguishes between bound and unbound methods, so it is not necessary.</p>
</div>
<span class="comment-copy">This is only useful for Python <b>two</b>, while the question specifically asks about Python <b>three</b>, where there are no unbound methods.</span>
