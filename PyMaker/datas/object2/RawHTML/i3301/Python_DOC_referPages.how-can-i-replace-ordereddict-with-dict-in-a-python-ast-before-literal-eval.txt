<div class="post-text" itemprop="text">
<p>I have a string with Python code in it that I could evaluate as Python with <code>literal_eval</code> if it only had instances of <code>OrderedDict</code> replaced with <code>{}</code>.</p>
<p>I am trying to use <code>ast.parse</code> and <code>ast.NodeTransformer</code> to do the replacement, but when I catch the node with <code>nodetype == 'Name' and node.id == 'OrderedDict'</code>, I can't find the list that is the argument in the node object so that I can replace it with a <code>Dict</code> node.</p>
<p>Is this even the right approach?</p>
<p>Some code:</p>
<pre><code>from ast import NodeTransformer, parse

py_str = "[OrderedDict([('a', 1)])]"

class Transformer(NodeTransformer):
    def generic_visit(self, node):
        nodetype = type(node).__name__

        if nodetype == 'Name' and node.id == 'OrderedDict':
            pass # ???

        return NodeTransformer.generic_visit(self, node)

t = Transformer()

tree = parse(py_str)

t.visit(tree)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The idea is to replace all <code>OrderedDict</code> nodes, represented as <code>ast.Call</code> having specific attributes (which can be seen from <code>ordered_dict_conditions</code> below), with <code>ast.Dict</code> nodes whose <code>key</code> / <code>value</code> arguments are extracted from the <code>ast.Call</code> arguments.</p>
<pre><code>import ast


class Transformer(ast.NodeTransformer):
    def generic_visit(self, node):
        # Need to call super() in any case to visit child nodes of the current one.
        super().generic_visit(node)
        ordered_dict_conditions = (
            isinstance(node, ast.Call)
            and isinstance(node.func, ast.Name)
            and node.func.id == 'OrderedDict'
            and len(node.args) == 1
            and isinstance(node.args[0], ast.List)
        )
        if ordered_dict_conditions:
            return ast.Dict(
                [x.elts[0] for x in node.args[0].elts],
                [x.elts[1] for x in node.args[0].elts]
            )
        return node


def transform_eval(py_str):
    return ast.literal_eval(Transformer().visit(ast.parse(py_str, mode='eval')).body)


print(transform_eval("[OrderedDict([('a', 1)]), {'k': 'v'}]"))  # [{'a': 1}, {'k': 'v'}]
print(transform_eval("OrderedDict([('a', OrderedDict([('b', 1)]))])"))  # {'a': {'b': 1}}
</code></pre>
<h2>Notes</h2>
<p>Because we want to replace the innermost node first, we place a call to <code>super()</code> at the beginning of the function.</p>
<p>Whenever an <code>OrderedDict</code> node is encountered, the following things are used:</p>
<ul>
<li><code>node.args</code> is a list containing the arguments to the <code>OrderedDict(...)</code> call.</li>
<li>This call has a single argument, namely a list containing key-value pairs as tuples, which is accessible by <code>node.args[0]</code> (<code>ast.List</code>) and <code>node.args[0].elts</code> are the tuples wrapped in a <code>list</code>.</li>
<li>So <code>node.args[0].elts[i]</code> are the different <code>ast.Tuple</code>s (<code>for i in range(len(node.args[0].elts))</code>) whose elements are accessible again via the <code>.elts</code> attribute.</li>
<li>Finally <code>node.args[0].elts[i].elts[0]</code> are the keys and <code>node.args[0].elts[i].elts[1]</code> are the values which are used in the <code>OrderedDict</code> call.</li>
</ul>
<p>The latter keys and values are then used to create a fresh <code>ast.Dict</code> instance which is then used to replace the current node (which was <code>ast.Call</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/ast.html#ast.NodeVisitor" rel="nofollow noreferrer"><code>ast.NodeVisitor</code></a> class to observe the <code>OrderedDict</code> tree in order to build the <code>{}</code> tree manually from the encountered nodes, using the parsed nodes from an empty dict as a basis.</p>
<pre><code>import ast
from collections import deque


class Builder(ast.NodeVisitor):
    def __init__(self):
        super().__init__()
        self._tree = ast.parse('[{}]')
        self._list_node = self._tree.body[0].value
        self._dict_node = self._list_node.elts[0]
        self._new_item = False

    def visit_Tuple(self, node):
        self._new_item = True
        self.generic_visit(node)

    def visit_Str(self, node):
        if self._new_item:
            self._dict_node.keys.append(node)
        self.generic_visit(node)

    def visit_Num(self, node):
        if self._new_item:
            self._dict_node.values.append(node)
            self._new_item = False
        self.generic_visit(node)

    def literal_eval(self):
        return ast.literal_eval(self._list_node)


builder = Builder()
builder.visit(ast.parse("[OrderedDict([('a', 1)])]"))
print(builder.literal_eval())
</code></pre>
<p>Note that this only works for the simple structure of your example which uses <code>str</code> as keys and <code>int</code> as values. However extensions to more complex structures should be possible in a similar fashion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using <code>ast</code> for parsing and transforming the expression you could also use a regular expression for doing that. For example:</p>
<pre><code>&gt;&gt;&gt; re.sub(
...     r"OrderedDict\(\[((\(('[a-z]+'), (\d+)\)),?\s*)+\]\)",
...     r'{\3: \4}',
...     "[OrderedDict([('a', 1)])]"
... )
"[{'a': 1}]"
</code></pre>
<p>The above expression is based on the example string of the OP and considers single quoted strings as keys and positive integers as values, but of course it can be extended to more complex cases.</p>
</div>
<span class="comment-copy">can you share a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> ?</span>
<span class="comment-copy">From that page: "When asking a question about a problem caused by your code". This is not a question about a problem caused by my code. I don't think my code is the right approach and would like to know, at a high level, what the right approach is.</span>
<span class="comment-copy">It's not like I have written "what have you tried ?". I think showing a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> would help others to answer by fixing your existing (small) code.</span>
<span class="comment-copy">I edited the above. There IS no code. I don't know what code to write to solve this problem! That's why I'm asking.</span>
<span class="comment-copy">@JimHunziker Can you add the string in question? How is the <code>OrderedDict</code> used? What about <code>.replace('OrderedDict', 'dict')</code>?</span>
<span class="comment-copy">Making a detour to built-in Python objects such as <code>dict</code> and then returning back to <code>ast</code> via <code>ast.parse</code> feels a bit awkward as opposed to just staying within <code>ast</code>. What about returning <code>return ast.Dict(node.args[0].elts[0].elts[:1], node.args[0].elts[0].elts[1:])</code> after a node has been identified as <code>OrderedDict</code> node? That way everything stays within <code>ast</code>. Also you could replace the bunch of <code>assert</code>ions within <code>try / except</code> with a few <code>if</code> conditions, i.m.o. that'd make the code a lot cleaner.</span>
<span class="comment-copy">@a_guest: you are right and I said so in my own notes. This was just the first thing that worked. I didn't dig too much into it, but I think the array-of-tuples that is the arg to dict/OrderedDict needs to be transformed before you give it to ast.Dict() - the latter takes two lists: keys and values. Definitely possible - on the other hand, now that I think of it, doing partial evals might be a way to convert the input into an actual OrderedDict while staying safe, as well as extend it to other constructor calls.</span>
<span class="comment-copy">Yes you are right, for more than one key-value pair the transformation needs to done properly such as <code>ast.Dict([x.elts[0] for x in node.args[0].elts], [x.elts[1] for x in node.args[0].elts])</code>. But there is no need to transform anything since the child nodes have been parsed into the tree already (i.e. <code>node.args[0].elts[0].elts[0]</code> is already an <code>ast.Str</code> object). I didn't really get your last comment about partial evals. When traversing the tree I think you shouldn't evaluate anything but just replace the appropriate nodes (i.e. stay within <code>ast</code>; each <code>eval</code> takes you back to Python).</span>
<span class="comment-copy">It seems that there are a few solutions that handle the "minimal" test case I posted (and was reluctant to provide!). I had thought this would be easier to solve than it is! This case doesn't work for any solutions so far: "OrderedDict([('a', OrderedDict([('a', 1)]))])"</span>
<span class="comment-copy">Updated to allow for nested structs. This is becoming interesting as a possible way to handle safe parsing of "enhanced" literals. Calling on @a_guest and other experienced folks to edit or post suggestions for improvement - and turn this into a Wiki topic.</span>
<span class="comment-copy">Text-level transform is definitely an alternative (and possibly a better one than AST tree), but RegExp won't work for the general case - they are finite-state automaton, and FSA cannot handle nesting - a stack automaton is required for this. IIRC, there was a library out there that can do this (text_balanced or something like that). Might be worth a look as an alternative.</span>
