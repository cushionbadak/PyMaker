<div class="post-text" itemprop="text">
<p>I have a sorted list with duplicate elements like</p>
<pre><code>&gt;&gt;&gt; randList = [1, 2, 2, 3, 4, 4, 5]
&gt;&gt;&gt; randList
[1, 2, 2, 3, 4, 4, 5]
</code></pre>
<p>I need to create a list that removes the adjacent duplicate elements. I can do it like:</p>
<pre><code>&gt;&gt;&gt;&gt; dupList = []
     for num in nums:
       if num not in dupList:
         dupList.append(num)
</code></pre>
<p>But I want to do it with list comprehension. I tried the following code:</p>
<pre><code>&gt;&gt;&gt; newList = []
&gt;&gt;&gt; newList = [num for num in randList if num not in newList]
</code></pre>
<p>But I get the result like the if condition isn't working.</p>
<pre><code>&gt;&gt;&gt; newList
[1, 2, 2, 3, 4, 4, 5]
</code></pre>
<p>Any help would be appreciated. 
Thanks!! </p>
<p>Edit 1: The wording of the question does seem to be confusing given the data I have provided. The for loop that I am using will remove <em>all</em> duplicates but since I am sorting the list beforehand, that shouldn't a problem when removing adjacent duplicates.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> is the simplest approach to remove <strong>adjacent</strong> (and only adjacent) duplicates, even for unsorted input:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [k for k, _ in groupby(randList)]
[1, 2, 3, 4, 5]
</code></pre>
<p>Removing <strong>all</strong> duplicates while maintaining the order of occurence can be efficiently achieved with an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a>. This, as well, works for ordered and unordered input:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; list(OrderedDict.fromkeys(randList))
[1, 2, 3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I need to create a list that removes the adjacent duplicate elements</p>
</blockquote>
<p>Note that your <code>for</code> loop based solution will remove ALL duplicates, not only adjacent ones. Test it with this:</p>
<pre><code>rand_list = [1, 2, 2, 3, 4, 4, 2, 5, 1]
</code></pre>
<p>according to your spec the result should be:</p>
<pre><code>[1, 2, 3, 4, 2, 5, 1]
</code></pre>
<p>but you'll get </p>
<pre><code>[1, 2, 3, 4, 5]
</code></pre>
<p>instead.</p>
<p>A working solution to only remove <em>adjacent</em> duplicates is to use a generator:</p>
<pre><code>def dedup_adjacent(seq):
    prev = seq[0]
    yield prev
    for current in seq[1:]:
        if current == prev:
            continue
        yield current
        prev = current

rand_list = [1, 2, 2, 3, 4, 4, 2, 5, 1]
list(dedup_adjacent(rand_list))
</code></pre>
<p>=&gt; [1, 2, 3, 4, 2, 5, 1]</p>
</div>
<div class="post-text" itemprop="text">
<p>Python first evaluates the list comprehension and then assigns it to <strong>newList</strong>, so you cannot refer to it during execution of the list comprehension.  </p>
<p>You can remove dublicates in two ways:-<br/>
1. Using for loop</p>
<pre><code>rand_list = [1,2,2,3,3,4,5]
new_list=[]
for i in rand_list:
    if i not in new_list:
        new_list.append(i)
</code></pre>
<ol start="2">
<li><p>Convert list to set,then again convert set to list,and at last sort the new list.<br/>
Since set stores values in any order so when we convert set into list you need to sort the list so that you get the item in ascending order     </p>
<p><code>rand_list = [1,2,2,3,3,4,5]
 sets = set(rand_list)
 new_list = list(sets)
 new_list.sort()</code></p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<h1>Update: Comparison of different Approaches</h1>
<p>There have been three ways of achieving the goal of removing adjacent duplicate elements in a sorted list, i.e. removing all duplicates:</p>
<ul>
<li>using <code>groupby</code> (only adjacent elements, requires initial sorting)</li>
<li>using <code>OrderedDict</code> (all duplicates removed)</li>
<li>using <code>sorted(list(set(_)))</code> (all duplicaties removed, ordering restored by sorting).</li>
</ul>
<p>I compared the running times of the different solutions using:</p>
<pre><code>from timeit import timeit

print('groupby:', timeit('from itertools import groupby; l = [x // 5 for x in range(1000)]; [k for k, _ in groupby(l)]'))
print('OrderedDict:', timeit('from collections import OrderedDict; l = [x // 5 for x in range(1000)]; list(OrderedDict.fromkeys(l))'))
print('Set:', timeit('l = [x // 5 for x in range(1000)]; sorted(list(set(l)))'))

&gt; groupby: 78.83623623599942
&gt; OrderedDict: 94.54144410200024
&gt; Set: 65.60372123999969
</code></pre>
<p>Note that the <code>set</code> approach is the fastest among all alternatives.</p>
<h1>Old Answer</h1>
<p>Python first evaluates the list comprehension and then assigns it to <code>newList</code>, so you cannot refer to it during execution of the list comprehension. To illustrate, consider the following code:</p>
<pre><code>randList = [1, 2, 2, 3, 4, 4, 5]

newList = []
newList = [num for num in randList if print(newList)]

&gt; []
&gt; []
&gt; []
&gt; â€¦
</code></pre>
<p>This becomes even more evident if you try:</p>
<pre><code># Do not initialize newList2
newList2 = [num for num in randList if print(newList2)]

&gt; NameError: name 'newList2' is not defined
</code></pre>
<p>You can remove duplicates by turning randList into a set:</p>
<pre><code>sorted(list(set(randlist)))

&gt; [1, 2, 3, 4, 5]
</code></pre>
<p>Be aware that <strong>this does remove <em>all</em> duplicates</strong> (not just adjacent ones) and ordering is not preserved. The former also holds true for your proposed solution with the loop.</p>
<p><em>edit</em>: added a <code>sorted</code> clause as to specification of required ordering.</p>
</div>
<div class="post-text" itemprop="text">
<p>In this line <code>newList = [num for num in randList if num not in newList]</code>, at first the <code>list</code> will be created in right side then then it will be assigned to newList. That's why every time you check <code>if num not in newList</code> returns True. Becasue <code>newList</code> remains empty till the assignment.</p>
<p>You can try this:</p>
<pre><code>randList = [1, 2, 2, 3, 4, 4, 5]
new_list=[]
for i in randList:
    if i not in new_list:
        new_list.append(i)

print(new_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot access the items in a list comprehension as you go along. The items in a list comprehension are only accessible once the comprehension is completed.</p>
<p>For large lists, checking for membership in a list will be expensive, albeit with minimal memory requirements. Instead, you can append to a <code>set</code>:</p>
<pre><code>randList = [1, 2, 2, 3, 4, 4, 5]

def gen_values(L):
    seen = set()
    for i in L:
        if i not in seen:
            seen.add(i)
            yield i

print(list(gen_values(randList)))

[1, 2, 3, 4, 5]
</code></pre>
<p>This algorithm has been implemented in the 3rd party <code>toolz</code> library. It's also known as the <code>unique_everseen</code> recipe in the <code>itertools</code> docs:</p>
<pre><code>from toolz import unique

res = list(unique(randList))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your list is sorted, using <code>set</code> will be the fasted way to achieve your goal, as follows:</p>
<pre><code>&gt;&gt;&gt; randList = [1, 2, 2, 3, 4, 4, 5]
&gt;&gt;&gt; randList
[1, 2, 2, 3, 4, 4, 5]
&gt;&gt;&gt; remove_dup_list = list(set(randList))
&gt;&gt;&gt; remove_dup_list
[1, 2, 3, 4, 5]
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Note that your <code>for</code> loop based solution will remove ALL duplicates, not only adjacent ones.</span>
<span class="comment-copy">@brunodesthuilliers You're right. But since the list is sorted anyway, will it have any impact?</span>
<span class="comment-copy">Well if your list is sorted, duplicates are by definition adjacent indeed.</span>
<span class="comment-copy">In a sorted list, all duplicates are adjacent. There's really no need to emphasize this point.</span>
<span class="comment-copy">@jpp When the OP explicitly calls them adjacent despite their sorted data, I shall feel free to cover the general case and mention the distinction.</span>
<span class="comment-copy">OP hasn't defined what he wants with non-sorted lists. I think that's an assumption rather than a generalisation.</span>
<span class="comment-copy">@jpp Hence the attempt to make to make things as clear as possible by pointing out the dfiference between all/adjacent sorted/unsorted. The answer covers the OP's concrete use case while making it clear what the two options do for various input. I don't see how such a generalization harms the answer.</span>
<span class="comment-copy">I've updated <a href="https://stackoverflow.com/a/51190265/4210388">my answer</a> with a comparison of evaluation time. It turned out that this approach is slower than the set approach. However, this solution is indeed closer to the original question (without the sorting restriction).</span>
<span class="comment-copy">@schwobaseggl, Since the list is sorted as per OP, this shouldn't make a difference.</span>
<span class="comment-copy">@schwobaseggl I missed this part of the spec indeed (but note that the OP's code did remove all duplicates). Answer changed base on your observation.</span>
<span class="comment-copy">Jup, the sample data and the code did not really match the wording of the question.</span>
<span class="comment-copy">@schwobaseggl, Since the list is sorted as per OP, this shouldn't make a difference. The main point is <code>set</code> is unordered, and it appears OP wants ordering maintained.</span>
<span class="comment-copy">@schwobaseggl I pointed that out in the last sentence of my answer. Furthermore, the code given by the OP also has this effect. Also @ jpp: It seems unclear what the OP wants since the 'working code' reaches a different goal than he describes.</span>
<span class="comment-copy">@schwobaseggl I updated my answer with a comparison of the three solutions</span>
<span class="comment-copy">This is already in the OP's post, is inefficient for large lists (O(N) lookup time), and will remove all duplicates, not only adjencent ones.</span>
<span class="comment-copy"><code>set</code> is defined as an <b>unordered</b> collection (at least until python 3.7), so this might loose the ordering. Also, it will removfe all duplicates, not only adjacent ones.</span>
<span class="comment-copy">He is mentioning that the list is sorted so the elements will always be in order, right?</span>
<span class="comment-copy">I repeat: <code>set</code> are NOT ordered (at least until py3.7) so the fact that the list is initially sorted is irrelevant (wrt/ keeping the original order at least).  Try this in python 2 or python 3 &lt; 3.7 with <code>"aaaabbbccc"</code> as the source sequence, you'll get either <code>['a', 'c', 'b']</code> (py2.7.6) or <code>['c', 'b', 'a']</code> (py3.4.3).</span>
