<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/31915018/re-findall-behaves-weird">re.findall behaves weird</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<pre><code>import re
name = 'propane'
a = []
Alkane = re.findall('(\d+\W+)*(methyl|ethyl|propyl|butyl)*(meth|eth|prop|but|pent|hex)(ane)', name)
if Alkane != a:
    print(Alkane)
</code></pre>
<p>As you can see when the regular express takes in propane it will output two empty strings. </p>
<pre><code>[('', '', 'prop', 'ane')]
</code></pre>
<p>For these types of inputs, I want to remove the empty strings from the output. I don't know what kind of form this output is in though, it doesn't look like a regular list. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>filter</code> to remove empty strings:</p>
<pre><code>import re
name = 'propane'
a = []
Alkane = list(map(lambda m: tuple(filter(bool, m)), re.findall('(\d+\W+)*(methyl|ethyl|propyl|butyl)*(meth|eth|prop|but|pent|hex)(ane)', name)))
if Alkane != a:
    print(Alkane)
</code></pre>
<p>Or you can use list/tuple comprehension:</p>
<pre><code>import re
name = 'propane'
a = []
Alkane = [tuple(i for i in m if i) for m in re.findall('(\d+\W+)*(methyl|ethyl|propyl|butyl)*(meth|eth|prop|but|pent|hex)(ane)', name)]
if Alkane != a:
    print(Alkane)
</code></pre>
<p>Both output:</p>
<pre><code>[('prop', 'ane')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>str.split()</code> and <code>str.join()</code> to remove empty strings from your output:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; name = 'propane'
&gt;&gt;&gt; Alkane = re.findall('(\d+\W+)*(methyl|ethyl|propyl|butyl)*(meth|eth|prop|but|pent|hex)(ane)', name)
&gt;&gt;&gt; Alkane
[('', '', 'prop', 'ane')]
&gt;&gt;&gt; [tuple(' '.join(x).split()) for x in Alkane]
[('prop', 'ane')]
</code></pre>
<p>Or using <code>filter()</code>:</p>
<pre><code>[tuple(filter(None, x)) for x in Alkane]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is stated in the <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">doc</a> that empty match are included.</p>
<blockquote>
<p>If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result.</p>
</blockquote>
<p>This means you will need to filter out empty compounds yourself. Use falsiness of the empty string for that.</p>
<pre><code>import re
name = 'propane'
alkanes = re.findall(r'(\d+\W+)*(methyl|ethyl|propyl|butyl)*(meth|eth|prop|but|pent|hex)(ane)', name)

alkanes = [tuple(comp for comp in a if comp) for a in alkanes]

print(alkanes) # [('prop', 'ane')]
</code></pre>
<p>Also, avoid using capitalized variable names as those are generally reserved for class names.</p>
</div>
<span class="comment-copy">Would you mind if you explain how the second method works? Or even give me a link to where I can learn to interpret this sort of logic? It is completely incomprehensible to me.</span>
<span class="comment-copy">You can read about list comprehension <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">here</a>. Basically since <code>re.findall</code> returns a list of tuples, we first iterate through the list, and then for each tuple in the list, we iterate through each item in the tuple to test if the item evaluates to True, which an empty string is not.</span>
