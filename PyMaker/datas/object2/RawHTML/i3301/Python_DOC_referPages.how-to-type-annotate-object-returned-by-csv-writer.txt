<div class="post-text" itemprop="text">
<p>I want to apply type annotation to the returned object of <a href="https://docs.python.org/3.6/library/csv.html#csv.writer" rel="noreferrer"><code>csv.writer</code></a> in order to comply with a larger codebase. Unfortunately I can not figure out the fitting return type.</p>
<pre><code>&gt;&gt;&gt; import csv
&gt;&gt;&gt; writer = csv.writer(open('outfile.csv', 'w'))
&gt;&gt;&gt; type(writer)
&lt;class '_csv.writer'&gt;
</code></pre>
<p>If I try to use this classname:</p>
<pre><code>&gt;&gt;&gt; import _csv
&gt;&gt;&gt; writer: _csv.writer = csv.writer(open('outfile.csv', 'w'))
</code></pre>
<p>I get the following mypy error:</p>
<pre><code>Invalid type "_csv.writer"
</code></pre>
<p>Does someone know which type to use in this case. Of course I could use <code>typing.Any</code> but this nullify the sense of a type annotation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Often when things are acting weird it's a sign typeshed doesn't exactly map to runtime. If you look at _csv <a href="https://github.com/python/typeshed/blob/master/stdlib/2and3/_csv.pyi" rel="nofollow noreferrer">in typeshed</a> you will see the type is named <code>_writer</code>. It also is re-exported in <a href="https://github.com/python/typeshed/blob/master/stdlib/2and3/csv.pyi" rel="nofollow noreferrer">csv</a>. So you should change the annotation to <code>csv._writer</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer is there is no way to directly access the type. Reading the <a href="https://github.com/python/cpython/blob/master/Modules/_csv.c" rel="nofollow noreferrer">C source of the _csv module</a> will show that the types of <code>reader</code> and <code>writer</code> are not exposed. Even in <a href="https://bitbucket.org/pypy/pypy/src/default/lib_pypy/_csv.py" rel="nofollow noreferrer">Pypy</a> where the _csv module is implemented in Python, doesn't expose the types.</p>
<p>Therefore, if you need to use it, you will need to use a work-around, by instantiating a temporary instance of the writer and getting it's type.</p>
<pre><code>import csv
# We'll need a temporary file-like object, so use a tempfile
from tempfile import TemporaryFile

with TemporaryFile() as t:
    CSVReader = type(csv.reader(t))
    CSVWriter = type(csv.writer(t))

w: CSVWriter = csv.writer('path/to/data.csv')
</code></pre>
<p>If you want keep this logic separate, I would suggest creating the types in a separate module</p>
<pre><code>from csv_types import CSVReader, CSVWriter
</code></pre>
<p>The other solution (which also involves writing your own module of types), is to follow the example of the <a href="https://github.com/python/cpython/blob/master/Lib/typing.py" rel="nofollow noreferrer"><code>typing</code></a> module in it's definition of types for <code>io</code> and <code>re</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to write an abstract class that represents the type. This is also how it is done for some classes in the <a href="https://github.com/python/cpython/blob/master/Lib/typing.py" rel="nofollow noreferrer">typing</a> module. For the <a href="https://docs.python.org/3/library/csv.html#writer-objects" rel="nofollow noreferrer"><code>csv.writer()</code></a> function that is the following:</p>
<pre><code>class _CSVWriter:

    @abstractmethod
    def writerow(self, row: List[str]) -&gt; None:
        pass

    @abstractmethod
    def writerows(self, rows: List[List[str]]) -&gt; None:
        pass

    @abstractproperty
    def dialect(self) -&gt; csv.Dialect:
        pass
</code></pre>
<p>Now this class can be used in the type-annotation for the <code>writer</code> object. As the typename of the returned object is still <code>_csv.writer</code> you will still get a type error. To avoid that you need to cast it to a <code>_CSVWriter</code> object.</p>
<pre><code>from typing import cast
writer: _CSVWriter = cast(_CSVWriter, csv.writer(open('test', 'w'))
</code></pre>
<p>That solution is a bit verbose but it does the job.</p>
</div>
<span class="comment-copy">The workaround works well on the Python console. However it will not work with a static type-checker like mypy. There will be an <code>InvalidType</code> error. I think this is because mypy does not actually execute the code. However thanks to your hint with the second solution. That one actually put me on the right track.</span>
