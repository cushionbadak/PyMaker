<div class="post-text" itemprop="text">
<p>I'd like to be able to say</p>
<pre><code>def f(param) -&gt; type(param): return param
</code></pre>
<p>but I get the <code>NameError: name 'param' is not defined</code>. Key thing here is that the return type is a function of a function parameter.  I have glanced through the <a href="https://www.python.org/dev/peps/pep-3107/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-3107/</a>, but I don't see any precise description of what comprises a valid annotation expression.</p>
<p>I would accept an answer which explains why <em>exactly</em> is this not possible at the moment, i.e., does it not fit into current annotation paradigm or is there a technical problem with this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's take a glance at <a href="https://www.python.org/dev/peps/pep-0484/#acceptable-type-hints" rel="nofollow noreferrer">PEP-484 - Type Hints # Acceptable type hints</a>.</p>
<blockquote>
<p>Annotations must be valid expressions that evaluate without raising exceptions <strong>at the time the function is defined</strong> (but see below for forward references).</p>
<p>Annotations should be kept simple or static analysis tools may not be able to interpret the values. For example, dynamically computed types are unlikely to be understood. (This is an intentionally somewhat vague requirement, specific inclusions and exclusions may be added to future versions of this PEP as warranted by the discussion.)</p>
</blockquote>
<p>I'd say that your approach is quite interesting and may be useful for static analysis. But if we accept PEPs as a source of an explanation for the current annotation paradigm, the highlighted text explains why return type can't be defined dynamically at the time the function is <strong>called</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few issues with the <code>type(param)</code> method.</p>
<p>First off, as Oleh mentioned in his answer, all annotations must be valid at the time of the <strong>function's definition</strong>. In an example like yours, you could potentially have problems due to <a href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="nofollow noreferrer">variable shadowing</a>.</p>
<pre><code>param = 10

def f(param) -&gt; type(param):
    return param

f('a')
</code></pre>
<p>Since <strong>the variable</strong> <code>param</code> is of type <code>int</code>, the function's annotation is essentially read as <code>f(param: Any) -&gt; int</code>. So when you pass in <strong>the argument</strong> <code>param</code> with the value <code>'a'</code>, which means <code>f</code> will return a <code>str</code>, this makes it inconsistent with the annotation. Admittedly this example is contrived, but from a language design stand point, it is something to be careful.</p>
<p>Instead, as jonrsharpe mentioned, often the best way to reference the <a href="https://docs.python.org/3/library/typing.html#user-defined-generic-types" rel="nofollow noreferrer">generic types</a> of parameters (as jonrsharpe) mentioned is with <a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="nofollow noreferrer">type variables</a>.</p>
<p>This can be done using the <code>typing.TypeVar</code> class.</p>
<pre><code>from typing import TypeVar

def f(param: T) -&gt; T:
    return param
</code></pre>
<p>This means that static checkers won't need to actually access the type of <code>param</code>, just check that at check-time that there is a way to consider both <code>param</code> and the return value of the same type. I say consider the same type because you will sometimes only assert that they both implement the same <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">abstract base class</a>/interface, like <a href="https://www.python.org/3/library/numbers.html#Real" rel="nofollow noreferrer"><code>numbers.Real</code></a>.</p>
<p>And then can use typevars in generic types</p>
<pre><code>from typing import List, TypeVar

T = TypeVar('T')

def total(items: List[T]) -&gt; List[T]:
    return [f(item) for item in items]
</code></pre>
<p>Using type variables and generics can be better because it adds additional information and allows for a little bit more flexibility (as explained in the example with <code>numbers.Real</code>). For instance, the ability to use <code>List[T]</code> is really important. In your case of using <code>type(param)</code>, it would only return <code>list</code>, not <strong>list of </strong> like <code>List[T]</code> would. So using <code>type(param)</code> would actually <em>lose information</em>, not add it.</p>
<p>Therefore, it is a better idea to stick to using <a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="nofollow noreferrer">type variables</a> and <a href="https://docs.python.org/3/library/typing.html#user-defined-generic-types" rel="nofollow noreferrer">generic types</a> instead.</p>
<p><strong>TL;DR</strong>:</p>
<ol>
<li>Due to <a href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="nofollow noreferrer">variable shadowing</a>, <code>type(param)</code> could lead to inconsistent annotations.</li>
<li>Since sometimes when thinking of the types of your system you are thinking in terms of <strong>interfaces</strong> (<a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">abstract base classes</a> in Python) instead of concrete types, it can be better to rely on ABC's and <a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="nofollow noreferrer">type variables</a> </li>
<li>Using <code>type(param)</code> could <strong>lose information</strong> that would be provided by generics.</li>
</ol>
</div>
<span class="comment-copy">That name <i>isn't</i> defined; it can't be, function annotations are evaluated in the scope in which the function is defined, not the scope of the function itself. This may be possible with <a href="https://www.python.org/dev/peps/pep-0563/" rel="nofollow noreferrer">postponed evaluation</a>, but in general these things are better solved with <a href="https://docs.python.org/3/library/typing.html#generics" rel="nofollow noreferrer"><i>generic types</i></a> - <code>f</code> takes a parameter of type <code>T</code> and returns type <code>T</code>.</span>
