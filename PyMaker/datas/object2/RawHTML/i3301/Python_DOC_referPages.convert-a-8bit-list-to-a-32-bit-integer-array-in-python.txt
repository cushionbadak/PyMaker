<div class="post-text" itemprop="text">
<p>what I have :</p>
<pre><code>textdata = "this is my test data"
DataArray = [ord(c) for c in textdata]
</code></pre>
<p>now I want to transform this is into x 32 bit integer by combining 4 elements of the list together</p>
<p>Ex : DataArray[0:4] would become a 32 bit integer, and then iterate to the next 4 elements and do the same. In the end, I would have a 32-bit array with all my results in it.</p>
<p>How can I do this in python whitout iterating over the whole string. Is there a simple way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using numpy:</p>
<pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; a = np.frombuffer(b'this is my test data', dtype=np.int32)
&gt;&gt;&gt; a
array([1936287860,  544434464, 1948285293,  544502629, 1635017060], dtype=int32)
&gt;&gt;&gt; a.tobytes()
b'this is my test data'
</code></pre>
<p>Use <code>'&lt;i4'</code> or similar as dtype for endianness that's portable between machines.</p>
<p>I'm assuming that you can keep your initial data as <code>bytes</code> rather than <code>unicode</code>, because you really should try hard to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>As long as your string is an integer multiple of 4, you can use NumPy in a very efficient way:</p>
<pre><code>import numpy as np
data = np.fromstring(textdata, dtype='&gt;u4')
# array([1952999795,  543781664, 1836654708, 1702065184, 1684108385])
</code></pre>
<p><code>'&gt;u4'</code> means 'big-endian unsigned 4-byte integer'.</p>
<p><strong>Edit</strong>: If you use NumPy &gt;= 1.14, then <code>np.fromstring</code> is deprecated, and the right way to process your text is by calling <code>np.frombuffer(textdata.encode(), dtype='&gt;u4')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use something like the following, which uses bit manipulation (big-endian):</p>
<pre><code>def chunk2int(chunk):
    """ Converts a chunk (string) into an int, 8 bits per character """
    val = 0
    for c in chunk:
        val = (val &lt;&lt; 8) | (ord(c) &amp; 0xFF)
    return val

def int2chunk(val):
    """ Converts an int into a chunk, consuming 8 bits per character """
    rchunk = []
    while val:
        rchunk.append(val &amp; 0xFF)
        val &gt;&gt;= 8

    return ''.join(chr(c) for c in reversed(rchunk))

textdata = "this is my test data"

chunks = [textdata[i:i + 4] for i in range(0, len(textdata), 4)]
print(chunks)

data = [chunk2int(c) for c in chunks]
print(data)

chunks = [int2chunk(d) for d in data]
print(chunks)
</code></pre>
<p>Produces:</p>
<pre><code>['this', ' is ', 'my t', 'est ', 'data']
[1952999795, 543781664, 1836654708, 1702065184, 1684108385]
['this', ' is ', 'my t', 'est ', 'data']
</code></pre>
<p>If you're using characters with <code>1 &lt;= ord(c) &lt;= 255</code> in your input text, this will work.  If there are null bytes in your string, the <code>int2chunk</code> method may terminate early, in which case you'd have to pad the chunks.</p>
<p>There's also the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer">struct</a> module, which may be worth looking into, and where you can change the endianness much more simply.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3.6/library/struct.html" rel="nofollow noreferrer">struct</a> built-in python module:</p>
<pre><code>from struct import unpack

textdata = "this is my test data"
data = list(unpack('i'*(len(textdata)//4), textdata))
</code></pre>
<p>Result:</p>
<pre><code>[1936287860, 544434464, 1948285293, 544502629, 1635017060]
</code></pre>
<p>You won't need to iterate over the string and you can find other <a href="https://docs.python.org/3.6/library/struct.html#format-characters" rel="nofollow noreferrer">Format Characters</a> if you want to use unsigned integers for example. </p>
</div>
<span class="comment-copy">Whenever you are using arrays in python, the answer is <i>always</i> "use numpy"</span>
<span class="comment-copy">Do you have a preferred endianness?</span>
<span class="comment-copy">Your <code>[.. for .. in ..]</code> also iterates over the whole string. But you can simply use <a href="https://docs.python.org/3/library/struct.html" rel="nofollow noreferrer"><code>struct unpack</code></a> as it's, well, <i>made</i> to do this. Do note that the string length always must be a multiple of 4 (your example is, but I don't get the impression that was intentional).</span>
<span class="comment-copy">No preference, as long as I am able to retrieve the original data with reverse process</span>
<span class="comment-copy">Are you using 8bit data, or strings? they are different! Can you pl.ease specify?</span>
<span class="comment-copy">this seems to works, but from a python begginer standpoint, how would I replace the b<code>string</code> with an actual string variable?</span>
<span class="comment-copy">can I just pass textdatavariable.encode() ?</span>
<span class="comment-copy">@AntoineLev You <i>can</i>, but you should probably guarantee that it stayed as <code>bytes</code> in the first place.</span>
<span class="comment-copy"><code>fromstring</code> is deprecated since 1.14 for good reason ... OP probably shouldn't touch strings at all.</span>
<span class="comment-copy">Unless you use Python-2.7, <code>'i'*(len(textdata)/4)</code> raises an error.</span>
<span class="comment-copy">Are you sure? I just tried it with python 2.7. you can cast it to int to avoid the <code>TypeError</code>, I'll update it.</span>
<span class="comment-copy">I could see it raising an error since <code>str * float</code> isn't defined.  <code>//</code> would "solve" it though (but it'd still be at the risk of truncating characters in <code>textdata</code>).</span>
<span class="comment-copy">@abdelhalimresu That's what I said. It works in 2.7, but not in 3.x.</span>
<span class="comment-copy">@jedwards I see.. but the data length must be a multiple of 4, otherwise the reverse operation will output a different string from the original.</span>
