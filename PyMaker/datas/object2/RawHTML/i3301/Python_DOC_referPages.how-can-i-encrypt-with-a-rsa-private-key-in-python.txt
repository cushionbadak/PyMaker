<div class="post-text" itemprop="text">
<p>Is it possible to encrypt a message with a private key in python using pycryptodome or any other library? I know that you are not supposed to encrypt with the private key and decrypt with the public key, but my purpose is to encrypt with the private one so the receiver could be sure that the message was send by the real author. More than secure encryption I'm looking for some kind of obfuscation. I want to do an app where the message is public but it can only be seen if you have the public key.
I've tried to do this:</p>
<pre><code>from Crypto import Random
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64


def generate_keys():
    modulus_lenght = 256 * 4
    private_key = RSA.generate(modulus_lenght, Random.new().read)
    public_key = private_key.publickey()
    return private_key, public_key

def encrypt_private_key(a_message, private_key):
    encryptor = PKCS1_OAEP.new(private_key)
    encrypted_msg = encryptor.encrypt(a_message)
    encoded_encrypted_msg = base64.b64encode(encrypted_msg)
   return encoded_encrypted_msg

def decrypt_public_key(encoded_encrypted_msg, public_key):
    encryptor = PKCS1_OAEP.new(public_key)
    decoded_encrypted_msg = base64.b64decode(encoded_encrypted_msg)
    decoded_decrypted_msg = encryptor.decrypt(decoded_encrypted_msg)
    return decoded_decrypted_msg

private_key, public_key = generate_keys()

message = "Hello world"

encoded = encrypt_private_key(message, private_key)
decoded = decrypt_public_key(encoded, public_key)

print decoded
</code></pre>
<p>But it raises the next error: TypeError: This is not a private key.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer</strong></p>
<ul>
<li>the code that you are using doesn't allow you to do that for security reasons</li>
<li>alternative code below</li>
</ul>
<p><strong>Long answer</strong> </p>
<p>I was curious about your problem and then I started to try to code</p>
<p>After a while I realized that if you run this snippet you will see that it correctly works:</p>
<pre><code>#!/usr/bin/env python

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64

def generate_keys():
    modulus_length = 1024

    key = RSA.generate(modulus_length)
    #print (key.exportKey())

    pub_key = key.publickey()
    #print (pub_key.exportKey())

    return key, pub_key

def encrypt_private_key(a_message, private_key):
    encryptor = PKCS1_OAEP.new(private_key)
    encrypted_msg = encryptor.encrypt(a_message)
    print(encrypted_msg)
    encoded_encrypted_msg = base64.b64encode(encrypted_msg)
    print(encoded_encrypted_msg)
    return encoded_encrypted_msg

def decrypt_public_key(encoded_encrypted_msg, public_key):
    encryptor = PKCS1_OAEP.new(public_key)
    decoded_encrypted_msg = base64.b64decode(encoded_encrypted_msg)
    print(decoded_encrypted_msg)
    decoded_decrypted_msg = encryptor.decrypt(decoded_encrypted_msg)
    print(decoded_decrypted_msg)
    #return decoded_decrypted_msg

def main():
  private, public = generate_keys()
  print (private)
  message = b'Hello world'
  encoded = encrypt_private_key(message, public)
  decrypt_public_key(encoded, private)

if __name__== "__main__":
  main()
</code></pre>
<p>but if you now change two of the final lines [i.e. the role of the keys] into:</p>
<pre><code>    encoded = encrypt_private_key(message, private)
    decrypt_public_key(encoded, public)
</code></pre>
<p>and rerun the program you will get the <code>TypeError: No private key</code></p>
<p>Let me quote from <a href="https://stackoverflow.com/a/10970540/4092588">this great answer</a>: </p>
<p>"As it turns out, PyCrypto is only trying to prevent you from mistaking one for the other here, OpenSSL or Ruby OpenSSL allow you for example to do both: public_encrypt/public_decrypt and private_encrypt/private_decrypt</p>
<p>[...]</p>
<p>Additional things need to be taken care of to make the result usable in practice. And that's why there is a dedicated <a href="https://www.dlitz.net/software/pycrypto/api/current/Crypto.Signature.PKCS1_PSS-module.html" rel="nofollow noreferrer">signature package</a> in PyCrypto - this effectively does what you described, but also additionally takes care of the things I mentioned"</p>
<p>Adapting <a href="https://gist.github.com/dennislwy/0194036234445776d48ad2fb594457d4" rel="nofollow noreferrer">this link</a> I came to the following code that should solve your question:</p>
<pre><code># RSA helper class for pycrypto
# Copyright (c) Dennis Lee
# Date 21 Mar 2017

# Description:
# Python helper class to perform RSA encryption, decryption, 
# signing, verifying signatures &amp; keys generation

# Dependencies Packages:
# pycrypto 

# Documentation:
# https://www.dlitz.net/software/pycrypto/api/2.6/

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA512, SHA384, SHA256, SHA, MD5
from Crypto import Random
from base64 import b64encode, b64decode
import rsa

hash = "SHA-256"

def newkeys(keysize):
    random_generator = Random.new().read
    key = RSA.generate(keysize, random_generator)
    private, public = key, key.publickey()
    return public, private

def importKey(externKey):
    return RSA.importKey(externKey)

def getpublickey(priv_key):
    return priv_key.publickey()

def encrypt(message, pub_key):
    #RSA encryption protocol according to PKCS#1 OAEP
    cipher = PKCS1_OAEP.new(pub_key)
    return cipher.encrypt(message)

def decrypt(ciphertext, priv_key):
    #RSA encryption protocol according to PKCS#1 OAEP
    cipher = PKCS1_OAEP.new(priv_key)
    return cipher.decrypt(ciphertext)

def sign(message, priv_key, hashAlg="SHA-256"):
    global hash
    hash = hashAlg
    signer = PKCS1_v1_5.new(priv_key)
    if (hash == "SHA-512"):
        digest = SHA512.new()
    elif (hash == "SHA-384"):
        digest = SHA384.new()
    elif (hash == "SHA-256"):
        digest = SHA256.new()
    elif (hash == "SHA-1"):
        digest = SHA.new()
    else:
        digest = MD5.new()
    digest.update(message)
    return signer.sign(digest)

def verify(message, signature, pub_key):
    signer = PKCS1_v1_5.new(pub_key)
    if (hash == "SHA-512"):
        digest = SHA512.new()
    elif (hash == "SHA-384"):
        digest = SHA384.new()
    elif (hash == "SHA-256"):
        digest = SHA256.new()
    elif (hash == "SHA-1"):
        digest = SHA.new()
    else:
        digest = MD5.new()
    digest.update(message)
    return signer.verify(digest, signature)

def main():
    msg1 = b"Hello Tony, I am Jarvis!"
    msg2 = b"Hello Toni, I am Jarvis!"

    keysize = 2048

    (public, private) = rsa.newkeys(keysize)

    # https://docs.python.org/3/library/base64.html
    # encodes the bytes-like object s
    # returns bytes
    encrypted = b64encode(rsa.encrypt(msg1, private))
    # decodes the Base64 encoded bytes-like object or ASCII string s
    # returns the decoded bytes
    decrypted = rsa.decrypt(b64decode(encrypted), private)
    signature = b64encode(rsa.sign(msg1, private, "SHA-512"))

    verify = rsa.verify(msg1, b64decode(signature), public)

    #print(private.exportKey('PEM'))
    #print(public.exportKey('PEM'))
    print("Encrypted: " + encrypted.decode('ascii'))
    print("Decrypted: '%s'" % (decrypted))
    print("Signature: " + signature.decode('ascii'))
    print("Verify: %s" % verify)
    rsa.verify(msg2, b64decode(signature), public)

if __name__== "__main__":
    main()
</code></pre>
<p>Final notes: </p>
<ul>
<li>the last <code>print</code>s have <code>ascii</code> because as stated <a href="https://stackoverflow.com/a/45151058/4092588">here</a> "In case of base64 however, all characters are valid ASCII characters"</li>
<li>in this case we are using the same key - the private one - both for encrypting and decrypting, so yes: we would end up to be symmetric but...</li>
<li>but - as stated <a href="https://stackoverflow.com/a/20059249/4092588">here</a> - "The public key is PUBLIC - it's something you would readily share and thus would be easily disseminated. There's no added value in that case compared to using a symmetric cipher and a shared key" plus "Conceptually, "encrypting" with the private key is more useful for signing a message whereas the "decryption" using the public key is used for verifying the message"</li>
<li>the same identical last principle is expressed in <a href="https://crypto.stackexchange.com/a/2124">this answer</a> - "Typically [...] we say sign with the private key and verify with the public key"</li>
</ul>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/38045324/how-to-encrypt-data-with-rsa-private-key-in-python">How to encrypt data with RSA private key in python?</a></span>
<span class="comment-copy">Take a look here: <a href="https://stackoverflow.com/questions/38045324/how-to-encrypt-data-with-rsa-private-key-in-python" title="how to encrypt data with rsa private key in python">stackoverflow.com/questions/38045324/â€¦</a></span>
<span class="comment-copy">Thanks a lot Antonino, this was very helpful! Just one question: in the code I need to use the private key both for encryption and decryption, does that mean that the creator of the message needs to send the private key to the receiver so he/she can decrypt it? Wouldn't that make the encryption symetric?</span>
<span class="comment-copy">ciao @CesarCabrera, I just updated the final part of my answer with new details. Btw I had the same doubt as yours when I read the GitHub solution and I had already searched the reason. Hopefully now it's clearer. Have a good day</span>
