<div class="post-text" itemprop="text">
<p>I have some working code to track the 'changes' between elements of a list - such that any two consecutive elements that are not identical constitute a change. The code is probably just as easy to understand here.</p>
<pre><code>testlist = ['red','red','blue','red','red','black','yellow','black','yellow','blue']
</code></pre>
<p>The first <code>red</code> to <code>red</code> would trigger no change, however the next <code>red</code> to <code>blue</code> would. <strong>I also want to tally up the changes to each color.</strong></p>
<pre><code># Set Tally counters to 0 and a unique key
red = 0
blue = 0
black = 0
yellow = 0
key = 40006

for i in range(len(testlist)-1):
    if (testlist[i] == (testlist[i+1])):
        print("No Change")
    else:
        print("Change to: " + str(testlist[i+1]))
        if testlist[i+1] == 'red':
            red = red + 1
        elif testlist[i+1] == 'blue':
            blue = blue + 1
        elif testlist[i+1] == 'black':
            black = black + 1
        elif testlist[i+1] == 'yellow':
            yellow = yellow + 1
dictfordf = {'key':key, 'red':red,'blue':blue,'black':black,'yellow':yellow}
</code></pre>
<p><strong>This works</strong> and outputs <code>{'black': 2, 'blue': 2, 'key': 40006, 'red': 1, 'yellow': 2}</code> correctly.</p>
<p>When the number of unique elements grows (only 4 unique colors in this example) to 10 the <code>if/elif</code> becomes very verbose.</p>
<p>My two questions are:</p>
<ul>
<li>Is there a more concise way to accomplish this?</li>
<li>Is there a faster way to execute this task?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>First, since your goal is to build a dict, just build the dict on the fly, instead of building a bunch of separate variables and then putting them in a dict at the end.</p>
<p>You can also use a <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">Counter</a> instead of a plain dict so you don't need to worry about checking whether the color is already there.</p>
<p>While we're at it, there's no need to call <code>str</code> on something that's already a string, and you've got a bunch of unnecessary parens all over the place.</p>
<p>So:</p>
<pre><code>from collections import Counter
dictfordf = Counter()
dictfordf['key'] = 40006
for i in range(len(testlist)-1):
    if testlist[i] == testlist[i+1]:
        print("No Change")
    else:
        print("Change to: " + testlist[i+1])
        dictfordf[testlist[i+1]] += 1
</code></pre>
<p>It's a <em>little</em> hacky to store a value for <code>'key'</code> that really isn't a count, so you might want to consider using a <code>defaultdict</code>, or <code>setdefault</code> on a normal dict, instead. But I don't think it's too bad.</p>
<p>Of course if <code>'key'</code> could be one of the elements in <code>testlist</code>, this is going to increment the key. But then if that's possible, it's not clear what <em>should</em> happen in that case, so it's not clear how you'd want to fix it.</p>
<hr/>
<p>Meanwhile, you can make things a little concise by iterating over adjacent pairs. See the <code>pairwise</code> recipe in the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> docs. But of course this adds the definition of <code>pairwise</code> to your code (or you can import it from a third-party lib like <code>more-itertools</code> or <code>toolz</code>).</p>
<p>So:</p>
<pre><code>from collections import Counter
from itertools import tee

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

dictfordf = Counter()
dictfordf['key'] = 40006
for prev, current in pairwise(testlist):
    if prev == current:
        print("No Change")
    else:
        print("Change to: " + current)
        dictfordf[current] += 1
</code></pre>
<hr/>
<p>You can abstract things further by using either <code>groupby</code>, or the <code>unique_justseen</code> recipe from <code>itertools</code>. I think this will obscure rather than clarify where you <code>print</code> the outputs—but, assuming you understand the <code>pairwise</code> version, it's worth reading up on both of them, and trying to write both alternatives, at least as an exercise.</p>
</div>
<div class="post-text" itemprop="text">
<p>My take on the problem:</p>
<pre><code>from collections import Counter

testlist = ['red','red','blue','red','red','black','yellow','black','yellow','blue']

def changes(data):
    last = data[0]
    for i in data:
        if last != i:
            yield i
        last = i

c = Counter(changes(testlist))
c['key'] = 40006
print(dict(c))
</code></pre>
<p>Output:</p>
<pre><code>{'yellow': 2, 'red': 1, 'key': 40006, 'blue': 2, 'black': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My take uses <code>zip</code> to walk through the list by pairs, and is fairly terse. Like the others, it uses <code>Counter</code>, which I agree is the right tool for the job.</p>
<pre><code>from collections import Counter

testlist = ['red','red','blue','red','red','black','yellow','black','yellow','blue']

def count_changes(data):
    c = Counter()
    c['key'] = 40006
    for item1, item2 in zip(data, data[1:]):
        if item1 != item2:
            c[item2] += 1
    return c

print(count_changes(testlist))
</code></pre>
<p>Output:</p>
<pre><code>Counter({'key': 40006, 'blue': 2, 'black': 2, 'yellow': 2, 'red': 1})
</code></pre>
<p>It's unclear what the correct behavior should be if <code>"key"</code> appears in the testlist, but it would be straightforward to modify this code to handle that.</p>
</div>
<span class="comment-copy"><code>[x for x,y in itertools.groupby(list_of_colors)]</code> something like?</span>
<span class="comment-copy">Looks like you want a modified version of the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_justseen</code> function from <code>itertools</code> recipes</a> in order to get the counts as well. Something like <code>from collections import Counter; Counter(unique_justseen(...))</code>.</span>
<span class="comment-copy">Are those <code>print</code> outputs part of the requirements, or did you just add them for debugging? If you need that output, looping explicitly is probably the simplest answer, and the most efficient. If you don't, then you could use a more abstract solution like <code>groupby</code> or <code>unique_justseen</code>.</span>
<span class="comment-copy">@JoranBeasley close, but need to skip the first one, e.g. <code>Counter(k for k, v in itertools.islice(itertools.groupby(testlist), 1, None))</code></span>
<span class="comment-copy">print is purely to debug @abarnert</span>
<span class="comment-copy">Might also want to add a test for if <code>key</code> is in <code>testlist</code>. Unclear what the expected behavior should be in that case.</span>
<span class="comment-copy">@AlexReinking The problem doesn't really make sense, or at least is underspecified, if that's a possibility… but I added to a comment to that effect.</span>
<span class="comment-copy">Thanks for the reply, will digest it now. The problem is a subsample of a bigger picture like you grok'd. I will be encasing this in an outer loop to loop over multiple lists (that each have their own unique key in the outer loop) - The unique key is then used for form the index of the eventual <code>pd.DataFrame</code> construction.</span>
<span class="comment-copy">Also to note - <code>key</code> will never appear in <code>testlist</code>.</span>
