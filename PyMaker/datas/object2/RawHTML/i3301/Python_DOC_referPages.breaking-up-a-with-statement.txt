<div class="post-text" itemprop="text">
<p>Originally, I have been opening and simultaneously reading through two files with something like this:</p>
<pre><code>with open(file1, 'r') as R1:
    with open(file2, 'r') as R2:
        ### my code
</code></pre>
<p>But now the input file names may sometimes be gzipped. So, I thought to split up the <code>with</code> statement and use an <code>if</code> statement to handle the two scenarios with something like this:</p>
<pre><code>if zipped:
    R1 = gzip.open(file1, 'r')
    R2 = gzip.open(file2, 'r')
else:
    R1 = open(file1, 'r')
    R2 = open(file2, 'r')

with R1:
    with R2:
        ### my code
</code></pre>
<p>Does the second code function like the first? Or is there even a better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're doing <em>mostly</em> makes sense, but it has one problem.</p>
<hr/>
<p>File objects are context managers that <code>close</code> themselves on <code>__exit__</code>. As the <a href="https://docs.python.org/3/library/gzip.html#gzip.GzipFile" rel="noreferrer"><code>gzip</code></a> docs make clear, that includes the <code>GzipFile</code> objects returned by <code>gzip.open</code>:</p>
<blockquote>
<p><code>GzipFile</code> supports the <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase" rel="noreferrer"><code>io.BufferedIOBase</code></a> interface, including iteration and the <code>with</code> statement. </p>
</blockquote>
<p>So, if you write <code>with f:</code> on an opened regular file or <code>GzipFile</code>, that guarantees that <code>close</code> will be called after the <code>with</code> statement.</p>
<p>In Python 2.7, the details are slightly different, but it works the same way. In Python 2.6, a <code>GzipFile</code> was <em>not</em> a context manager. But there's a very easy solution (that's worth knowing about for other types, even if you don't care about Python 2.6): you can wrap anything with a <code>close</code> method in <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="noreferrer"><code>closing</code></a> to get a context manager that calls that <code>close</code> on <code>__exit__</code>. So, you could write:</p>
<pre><code>with contextlib.closing(R1):
</code></pre>
<p>… and it would work on <code>R1</code> whether it's a file object, or some other kind of thing (like a 2.6 <code>GzipFile</code>) that doesn't know how to be a context manager.</p>
<hr/>
<p>However, what happens if <code>R1</code> opens successfully, but <code>R2</code> fails? Then you haven't even gotten into the <code>with R1:</code> when the exception is raised, so you never close <code>R1</code>.</p>
<p>You could fix this by doing the <code>with R1</code> before opening <code>R2</code>:</p>
<pre><code>if zipped:
    R1 = gzip.open(file1, 'r')
else:
    R1 = open(file1, 'r')
with R1:
    if zipped:
        R2 = gzip.open(file2, 'r')
    else:
        R2 = open(file2, 'r')
    with R2:
</code></pre>
<p>Or you could use an <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>ExitStack</code></a>.</p>
<p>But there's a much simpler solution here: Both <code>gzip.open</code> and <code>open</code> are callable objects, so you can store them in a variable, and call it later. Since they have the same signature, and you want to call them with the exact same arguments, using that variable is trivial:</p>
<pre><code>if zipped:
    zopen = gzip.open
else:
    zopen = open
with zopen(file1, 'r') as R1:
    with zopen(file2, 'r') as R2:
</code></pre>
<p>And notice that you can make this a lot more concise without making it any less readable:</p>
<pre><code>zopen = gzip.open if zipped else open
with zopen(file1, 'r') as R1, zopen(file2, 'r') as R2:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it your original way by creating a function that checks what kind of file it is.</p>
<pre><code>def open_or_gzip_open(file_name, permissions='r'):
    if file_name.endswith('gz'):
        R1 = gzip.open(file_name, 'r')
    else:
        R1 = open(file_name, 'r')
    return R1
</code></pre>
<p>You can open both files on one line:    </p>
<pre><code>with open_or_gzip_open('text.txt') as p1, open_or_gzip_open('text2.txt') as p2:
    print(p1, p2)
</code></pre>
<p>~                                  </p>
</div>
<div class="post-text" itemprop="text">
<p>The second code does work like the first, as long as <code>zipped</code> is <code>False</code>.</p>
<p>One important thing to note, though, is that you don't have to nest your with statements. Instead you can do something like:</p>
<pre><code>with open(file1) as R1, open(file2) as R2:
    ###code
</code></pre>
<p>(Also, the function <code>open</code> has the <code>'r'</code> parameter by default, so you don't have to include it.)</p>
</div>
<span class="comment-copy">You could wrap the <code>zipped</code> predicate in a function that wraps <code>gzip.open</code> or <code>open</code> invoked on the function's file name argument.</span>
<span class="comment-copy">@dfri: thus making the file type transparent to the <code>open</code> (well, at least if the data, zipped or not, is exactly the same). I'd sure like to see that as a full how-to answer!</span>
<span class="comment-copy">Where does <code>zipped</code> come from? If it's dependent on the filename of <code>file1</code>, or the magic header, or something like that, then you probably do want a wrapper function that transparently figures it out—but, given that <code>zipped</code> seems to be always either true for both <code>file1</code> and <code>file2</code>, or for neither, I'm not sure that makes sense here.</span>
<span class="comment-copy">@usr2564301 abarnerts solution of using the predicate to store a callable and invoke as part of the <code>with</code> expression is better.</span>
<span class="comment-copy">@dfri I think the major difference between using a wrapper or just store the function in a variable is whether the <code>zipped</code> flag is some external information (which we'd have to pass into the wrapper function, making it more verbose without being any more readable) or something we can figure out from <code>file1</code> and <code>file2</code> (and know they'll always be consistent) (in which case the wrapper could be transparent, which I think is nicer).</span>
<span class="comment-copy">this was a really helpful explanation, thanks.</span>
<span class="comment-copy">The code works the same if <code>zipped</code> is <code>True</code>.</span>
