<div class="post-text" itemprop="text">
<p>I have the following list of words:</p>
<pre><code>x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga','Lam']
</code></pre>
<p>I need to remove the words that appear only once, and return there indices, or positions.</p>
<pre><code>y = ['Gaga', 'Gaga', 'Lam', 'Gaga', 'Lam']

loc = [0, 0, 0, 1, 1, 0, 0]
</code></pre>
<p>Any simple function to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Alternative <em>one-liner</em> with <strong><code>pandas</code></strong> module and its <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.duplicated.html" rel="nofollow noreferrer"><code>pd.Series.duplicated()</code></a> function:</p>
<pre><code>In [80]: x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga','Lam']

In [81]: (~pd.Series(x).duplicated(keep=False)).astype(int).tolist()
Out[81]: [0, 0, 0, 1, 1, 0, 0]
</code></pre>
<hr/>
<p>To remove all non-duplicates:</p>
<pre><code>In [85]: s = pd.Series(x)

In [86]: s[s.duplicated(keep=False)].tolist()
Out[86]: ['Gaga', 'Gaga', 'Lam', 'Gaga', 'Lam']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>Counter</code> class for exactly this purpose:</p>
<pre><code>from collections import Counter

x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga','Lam']

c = Counter(x)

new_values = [item for item in x if c[item] &gt; 1]
indexes = [1 if c[item] == 1 else 0 for item in x]

print(new_values)
print(indexes)
</code></pre>
<p>Output is:</p>
<pre><code>['Gaga', 'Gaga', 'Lam', 'Gaga', 'Lam']
[0, 0, 0, 1, 1, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and isolate items appearing only once. then use list comprehensions for your desired results. The solution is O(n) overall, although it involves 3 passes.</p>
<pre><code>x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga','Lam']

from collections import Counter

singles = {k for k, v in Counter(x).items() if v == 1}

y = [i for i in x if i not in singles]
loc = [int(i in singles) for i in x]

print(y, loc, sep='\n')

['Gaga', 'Gaga', 'Lam', 'Gaga', 'Lam']
[0, 0, 0, 1, 1, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could you create a new list, and work with that?</p>
<pre><code>x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga','Lam']
loc = []
new_x = []

for name in x:
    if x.count(name) == 1:
        loc.append(1)
    else:
        loc.append(0)
        new_x.append(name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use list comprehension</p>
<pre><code>x = ['Gaga', 'Gaga', 'Lam', 'Reem', 'Pal', 'Gaga', 'Lam'] 
y = [name for name in x if x.count(name) != 1]
</code></pre>
<h1>output</h1>
<p>['Gaga', 'Gaga', 'Lam', 'Gaga', 'Lam']</p>
</div>
<span class="comment-copy">Did you try anything?</span>
<span class="comment-copy">Minor point, even better would be to calculate <code>s.duplicated(keep=False)</code> as an initial step and use it in both your calculations. But still +1 for a nice Panda solution.</span>
<span class="comment-copy">@jpp, of course, when combining those 2 in one common block, <code>s = pd.Series(x)</code> and <code>dups = s.duplicated(keep=False)</code> should be calculated beforehand. I separated them for demonstration <code>pandas</code> one-liners</span>
<span class="comment-copy">To note, O(n) as well. But not a big fan of the ternary vs <code>int(c['item'] == 1)</code>. Also, less efficient than mine since you test <code>c[item] == 1</code> in both list comprehensions.</span>
<span class="comment-copy">this solution has a quadratic complexity in the number of elements of the list, which is not the best one</span>
