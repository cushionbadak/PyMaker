<div class="post-text" itemprop="text">
<p>I have an array like this: <code>['a', ['e', 'r', 't'], 'c']</code>.</p>
<p>I want to use some sort of processing to make the array neat:
<code>[['a', 'e', 'c'], ['a', 'r', 'c'], ['a', 't', 'c']]</code>.</p>
<p>If the array is: <code>['a', ['e', 'r', 't'], ['c', 'd']]</code>.</p>
<p>The result is:
<code>[['a', 'e', 'c'], ['a', 'e', 'd'], ['a', 'r', 'c'], ['a', 'r', 'd'], ['a', 't', 'c'], ['a', 't', 'd']]</code>.</p>
<p>And the length of the array is not fixed to 3, other examples:</p>
<pre><code>['a', 'b'] = &gt; ['a', 'b']
['a', ['b', 'c']] =&gt; [['a', 'b'], ['a', 'c']]
['ab', ['b', 'c']] =&gt; [['ab', 'b'], ['ab', 'c']]
[[1, 2], 3, 4] =&gt; [[1, 3, 4], [2, 3, 4]]
</code></pre>
<p>So what should I do? Is there a solution in Numpy?</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless I misunderstand the question, you just want the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> of the sub-lists, although you have to wrap any single elements into lists first.</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; arr = ['a', ['e', 'r', 't'], ['c', 'd']]
&gt;&gt;&gt; listified = [x if isinstance(x, list) else [x] for x in arr]
&gt;&gt;&gt; listified
[['a'], ['e', 'r', 't'], ['c', 'd']]
&gt;&gt;&gt; list(product(*listified))
[('a', 'e', 'c'),
 ('a', 'e', 'd'),
 ('a', 'r', 'c'),
 ('a', 'r', 'd'),
 ('a', 't', 'c'),
 ('a', 't', 'd')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have a recursive solution:</p>
<pre><code>inlist1 = ['ab', ['e', 'r', 't'], ['c', 'd']]
inlist2 = [['a', 'b'], ['e', 'r', 't'], ['c', 'd']]
inlist3 = [['a', 'b'], 'e', ['c', 'd']]


def jagged(inlist):
    a = [None] * len(inlist)

    def _jagged(index):
        if index == 0:
            print(a)
            return
        v = inlist[index - 1]
        if isinstance(v, list):
            for i in v:
                a[index - 1] = i
                _jagged(index - 1, )
        else:
            a[index - 1] = v
            _jagged(index - 1)

    _jagged(len(inlist))


jagged(inlist3)
</code></pre>
</div>
<span class="comment-copy">What's the expected output for - <code>['a', ['e', 'r', 't'], ['b', 'c']]</code>?</span>
<span class="comment-copy">Is the depth consistent ? What about <code>['a', ['e', 'r', ['t', 'y']], 'c']</code></span>
<span class="comment-copy">did you mean that you want to convert some elements to a list and add to them things later?</span>
<span class="comment-copy">Thanks, I modified my question, the highest depth is 2.@Divakar @Bck</span>
<span class="comment-copy">Can you explain how you arrived at the expected output?</span>
<span class="comment-copy">Yes, I think this is <b>neat</b> way to do it.</span>
