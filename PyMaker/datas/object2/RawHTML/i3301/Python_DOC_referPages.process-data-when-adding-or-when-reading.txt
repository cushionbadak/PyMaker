<div class="post-text" itemprop="text">
<p>Which way is more fitting python style:</p>
<pre><code>class Foo:
    def __init__(self):
        self.sorted_elements = []

    def add_element(self, element):
        self.sorted_elements.append(element)
        self.sorted_elements.sort()

    def read_elements(self):
        for element in self.sorted_elements:
            do_something(element)
</code></pre>
<p>or</p>
<pre><code>class Foo:
    def __init__(self):
        self.elements = []

    def add_element(self, element):
        self.elements.append(element)

    def read_elements(self):
        for element in sorted(self.elements):
            do_something(element)
</code></pre>
<p>When should we proces our data? When we collect it or when we do something with it? Of course one can make a statement it depends on what we do more, adding or reading. But if we would have to make rule of the thumb, what it would be?
IMHO I lean towards second way because it guarantess correct order without depening on some external state.</p>
</div>
<div class="post-text" itemprop="text">
<p>None of those solutions is more nor less pythonic than the other, and both have pros and cons, depending on your typical use case. And both have a couple issues...</p>
<ul>
<li><p>the first solution is highly inefficient if you add thousands of data in a row</p></li>
<li><p>the second keeps on sorting a list that is, most of the time, already sorted. Given Python's builtin sort algorithm behaviour this should not be a huge issue but that's still a few function calls and they don't come for free.</p></li>
<li><p>and in both cases, <code>elements</code> being exposed as a public attribute breaks encapsulation and make the whole question moot since anyone can either add to <code>.elements</code> without sorting it after or read from <code>.elements</code> without sorting it before...</p></li>
</ul>
<p>So the very first thing to do is actually to make <code>elements</code> private. Then you want to keep track of wether <code>_elements</code> needs sorting:</p>
<pre><code>class Foo:

    def __init__(self):
        self._elements = []
        self._sorted = True

    def add_element(self, element):
        self._elements.append(element)
        self._sorted = False

    def read_elements(self):
        if not self._sorted:
            self._elements.sort() 
            self._sorted = True

        for element in self._elements:
            do_something(element)
</code></pre>
<p>Now you have a properly encapsulated implementation that only sorts when necessary...</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>When should we process our data? When we collect it or when we do
  something with it?</p>
</blockquote>
<p>It depends.</p>
<p>If collection of the data is more intensive than processing it, then you should sort your data just before it is processed and vise versa.</p>
<p>Why?</p>
<p>Suppose that you are appending 1000 elements/s to <code>sorted_elements</code> array but you only call <code>read_elements</code> 10 times in a minute. If you sort your data upon collection, you will be wasting too much CPU resource and time.</p>
</div>
<span class="comment-copy">Second is better I think, you donot need to sort the list every time you add something else into it (Because sort takes at least O(N) and by doing so you are likely have a time complexity of at least O(N2))....The 2nd way only sort once and saves a lot of time.</span>
<span class="comment-copy">@Marcus.Aurelianus Yes, but counter argument could be made that often we have multiple functions doing something with data and we have to code sorting (or whatever processing we need) in every single one of them.</span>
<span class="comment-copy">I agree with @Marcus.Aurelianus, but we do not know your exact scenario. How many times do you read an element? If you add element rarely and read many times then 1st might be better. I would also consider using Binary Search Tree.</span>
<span class="comment-copy">Generally, the 2nd way will be more efficient, unless you rarely append but read a lot. However, Timsort, (which is O(n log n)) is very good at handling data containing sorted subsequences, so your 1st option may be ok if appends aren't too frequent. But also consider a data structure that can maintain sorted order, like some kind of tree, even the standard library's <code>heapq</code> may be useful, depending on your actual use case.</span>
<span class="comment-copy">Another thing worth looking at is the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> module, which provides support for maintaining a list in sorted order without having to sort the list after each insertion. However, you still have the expense of moving the list items after the insertion point to make room for the new item, so it can be slower than a tree if you need to do lots of insertions near the front of the list.</span>
<span class="comment-copy">This is nice improvement. Certainly more efficient. But correct me if I'm wrong, this has some significant disadvantage - any function will return incorrect result if state of the object was not maintained carefuly. So we force everyone who will for example inherit from this class to keep checking and updating _sorted in every subclass function they wrote.</span>
<span class="comment-copy">indeed - but only if subclasses mess with <code>_elements</code>. This is the contract in Python: if you bypass the public api and access implementation attributes then you are responsible for what happens, including having to rewrite your code when implementation changes. If you don't want to assume this responsibility then only use the public api. This is called encapsulation and is a fundamental concept in OO.</span>
