<div class="post-text" itemprop="text">
<p>I have written some code in python to delete unique numbers from a list so given the input:</p>
<p><code>[1,2,3,2,1]</code></p>
<p>It should return</p>
<p><code>[1,2,2,1]</code></p>
<p>But my program returns</p>
<p><code>[1,2,1]</code></p>
<p>My code is:</p>
<pre><code>for i in data:
    if data.count(i) == 1:
        data.pop(i)
</code></pre>
<p>I found the error occurs at the <code>if data.count(i) == 1:</code>. It says <code>data.count(2) == 1</code> when clearly there are 2 occurrences of the number 2 in the list. I do not understand why this is giving the wrong answer</p>
</div>
<div class="post-text" itemprop="text">
<p>Try appending to a new list rather than changing your old one:</p>
<pre><code>res = []
data = [1,2,3,2,1]

for i in data:
    if data.count(i) &gt; 1:
        res.append(i)
</code></pre>
<p>It's bad practice to change list size during iteration, and <code>pop</code> will do that. This returns <code>res = [1, 2, 2, 1]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you have a long list, you should put all numbers into a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer">Counter(iterable) - dictionary</a>.</p>
<pre><code>from collections import Counter
data = [1,2,3,2,1]
c = Counter(data)

cleaned = [x for x in data if c[x] &gt; 1]

print(cleaned)
</code></pre>
<p>This will count all occurences with one pass of your list (<code>O(n)</code>) and the lookup how often it occurs inside the created dictionary is <code>O(1)</code>. Together this is much faster then use a list comprehension like  </p>
<pre><code>result = [x for x in data if data.count(x) &gt; 1]
</code></pre>
<p>for a list of 100 values it will go through your 100 values 100 times, to count each single one of them wich is O(n^2) - bad thing to have.</p>
<p>Output:</p>
<pre><code>[1,2,2,1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Solution using list comprehension</h2>
<p>I <em>believe</em> a more pythonic answer could be, using list comprehension:</p>
<pre><code>result = [x for x in data if data.count(x) &gt; 1]
</code></pre>
<h2>Solutions time comparison for example list</h2>
<p>I have moved <a href="https://stackoverflow.com/users/7867968/c-nivs">C.Nivis</a> and <a href="https://stackoverflow.com/users/7505395/patrick-artner">Patrick Artner</a> answers inside a function to run timeit more easily on it.</p>
<p>To account for the time required to call the function, I have also wrapper the list comprehension into a function call.</p>
<h3>Setup</h3>
<pre><code>def remove_singletons(data):
    """Return list with no singleton using for loops."""
    res = []
    for i in data:
        if data.count(i) &gt; 1:
            res.append(i)
    return res

def remove_singletons_lc(data):
    """Return list with no singleton using for list comprehension."""
    return [x for x in data if data.count(x)&gt;1]

from collections import Counter

def remove_singletons_counter(data):
     c = Counter(data)
     return [x for x in data if c[x] &gt; 1]

import numpy as np

def remove_singletons_numpy(data):
     a = np.array(data)
     _, ids, counts = np.unique(a, return_counts=True, return_inverse=True)
    return a[counts[ids] != 1]

l = [1,2,3,2,1]
</code></pre>
<h3>Solution with loops</h3>
<pre><code>%timeit remove_singletons(l)
&gt;&gt;&gt; 1.42 µs ± 46.1 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<h3>Solution with list comprehension</h3>
<pre><code>%timeit remove_singletons_lc(l)
&gt;&gt;&gt; 1.2 µs ± 17.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<h3>Solution with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a></h3>
<pre><code>%timeit remove_singletons_counter(l)
&gt;&gt;&gt; 6.55 µs ± 143 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<h3>Solution with <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.unique.html" rel="nofollow noreferrer"><code>numpy.unique</code></a></h3>
<pre><code>%timeit remove_singletons_numpy(l)
&gt;&gt;&gt; 53.8 µs ± 3.07 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) 
</code></pre>
<h3>Conclusions</h3>
<p>It appears that list comprehension is <em>slightly</em> but consistently faster than looping and quite faster than <code>Counter</code> with small lists. Numpy, for small lists, is the slower one.</p>
<h2>Solutions time comparison for large lists</h2>
<p>Suppose that we have a large list of <em>n</em> random elements, from <em>[0, n]</em></p>
<pre><code>import random
n = 10000
l = [random.randint(0, n) for i in range(n)]
</code></pre>
<h3>Solution with loops</h3>
<pre><code>%timeit remove_singletons(l)
&gt;&gt;&gt; 1.5 s ± 64.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<h3>Solution with list comprehension</h3>
<pre><code>%timeit remove_singletons_lc(l)
&gt;&gt;&gt; 1.51 s ± 33.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<h3>Solution with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a></h3>
<pre><code>%timeit remove_singletons_counter(l)
&gt;&gt;&gt; 2.65 ms ± 228 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<h3>Solution with <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.unique.html" rel="nofollow noreferrer"><code>numpy.unique</code></a></h3>
<pre><code>%timeit remove_singletons_numpy(l)
&gt;&gt;&gt; 1.75 ms ± 38.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<h3>Conclusions for large lists</h3>
<p>For large lists the undisputed winner is <code>numpy.unique</code>, followed just behind by <code>Counter</code>.</p>
<h2>Final conclusions</h2>
<p>For small lists <strong>list comprehension</strong> seems to do the trick, but for larger lists the <strong><code>numpy.unique</code></strong> approach works best.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a recursive problem. You misunderstood <a href="https://docs.python.org/3.7/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>list.pop()</code></a>. It takes an index not a specific element. Therefore, <strong>you're not removing what you expect.</strong></p>
<p>the thing to do here is to use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>,</p>
<pre><code>data = [1,2,3,2,1]

#You could use dup_list = data[:] for python 3.2 and below
dup_list = data.copy()

for index,item in enumerate(dup_list):
    if dup_list.count(item) == 1:
        data.pop(index)
</code></pre>
<p>this way you're popping the item a the right index.</p>
<p><strong>EDIT</strong></p>
<p>I edited, thanks to @wim for his comment. I'm now iterating over a copy (<code>dup_list</code>) of the original list not to iterate and mutate the original list at the same time.</p>
<p>Also, I created a copy explicity for the sake of explanation. But you could use a shorter version of the code, </p>
<pre><code>data = [1,2,3,2,1]

#using data[:] to iterate over a copy
for index,item in enumerate(data[:]):
    if data.count(item) == 1:
        data.pop(index)
</code></pre>
<p>Note that I added a comment because this syntax can be confusing for some people.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Do not <em>modify</em> a list while iterating over it. Behavior will most likely not be the desired one.</p>
<h3><code>numpy.unique</code> with <code>return_counts=True</code></h3>
<p>One more option is to use <code>numpy</code></p>
<pre><code>a = np.array([1,2,2,3,2,1])
_, ids, counts = np.unique(a, return_counts=True, return_inverse=True)
a[counts[ids] != 1]
</code></pre>
<p>For big arrays this is <strong>way faster</strong> than list comprehension and <code>Counter</code></p>
<pre><code>a = np.array([1,2,2,3,2,1]*1000) #numpy array
b = list(a) # list
</code></pre>
<p>Then</p>
<pre><code>%timeit _, ids, c = np.unique(a, return_counts=True, return_inverse=True);a[c[ids] != 1]
225 µs ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%timeit [x for x in a if b.count(x) &gt; 1]
885 ms ± 23.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit [x for x in a if c[x] &gt; 1]
1.53 ms ± 58.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use list comprehension to build a new list:</p>
<pre><code>[ x for x in data if data.count(x)&gt;1 ]
</code></pre>
<p>Also, the <a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow noreferrer"><code>pop()</code></a> method takes the index of the element as an argument, not the value.</p>
</div>
<span class="comment-copy">I agree that this is probably the most pythonic</span>
<span class="comment-copy">.. unless you have a list of 1 million numbers and the algo has to <code>.count()</code> each single one and go through the whole list for each single number to get its count from it ....</span>
<span class="comment-copy">I can test that! Give me 5 minutes :) I'll also add the counter approach.</span>
<span class="comment-copy">@LucaCappelletti numpy is still faster :)</span>
<span class="comment-copy">Adding test with your version too ASAP!</span>
<span class="comment-copy">You're right about the <code>list.pop</code> part.  But the proposed alternative still mutates the list while iterating over it, which can produce crazy results.</span>
<span class="comment-copy">@wim I added a duplicate list.</span>
<span class="comment-copy">Just iterating over the data slice :<code>for i, item in enumerate(data[:]):</code> should work as well. It would be the shortest code (no need to declare a copy), but I am not sure if that would be recommended practice.</span>
<span class="comment-copy">Remember that multiplying a list multiplies the object pointer.</span>
<span class="comment-copy">@LucaCappelletti What? How is this relevant here?</span>
<span class="comment-copy">faster then Counter nice - got my +1 already. Any idea why faster? numpy using C under the hood?</span>
<span class="comment-copy">You are right, in this case it is not relevant as the fact that in my example the list has an extremely greater variance, while in yours there are no singletons. The results are here: <a href="https://imgur.com/a/3o3hq7R" rel="nofollow noreferrer">imgur.com/a/3o3hq7R</a></span>
