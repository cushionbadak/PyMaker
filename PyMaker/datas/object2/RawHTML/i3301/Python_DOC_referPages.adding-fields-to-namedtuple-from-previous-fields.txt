<div class="post-text" itemprop="text">
<p>Let's say I want to store some information about a conference schedule with a presentation time and a pause time. I can do this in a <code>NamedTuple</code>.</p>
<pre><code>from typing import NamedTuple

class BlockTime(NamedTuple):
    t_present: float
    t_pause: float
</code></pre>
<p>However, if I also want to store how much each block would take such that <code>t_each = t_pause + t_present</code>, I can't just add it as an attribute:</p>
<pre><code>class BlockTime(NamedTuple):
    t_present: float
    t_pause: float
    # this causes an error
    t_each = t_present + t_pause
</code></pre>
<p>What is the correct way to do this in Python? If I make an <code>__init__(self)</code> method and store it as an instance variable there, but it would then be mutable.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case it would be okay that it's not really stored but calculated dynamically you could use a simple <code>property</code> for it.</p>
<pre><code>from typing import NamedTuple

class BlockTime(NamedTuple):
    t_present: float
    t_pause: float
    @property
    def t_each(self):
        return self.t_present + self.t_pause

&gt;&gt;&gt; b = BlockTime(10, 20)
&gt;&gt;&gt; b.t_each  # only available as property, not in the representation nor by indexing or iterating
30
</code></pre>
<p>That has the advantage that you can never (not even accidentally) store a wrong value for it. However at the expense of not actually storing it at all. So in order to appear as if it were stored you'd have to at least override <code>__getitem__</code>, <code>__iter__</code>, <code>__repr__</code> which is likely too much trouble.</p>
<p>For example the <code>NamedTuple</code> approach given by Patrick Haugh has the downside that it's still possible to create inconsistent <code>BlockTime</code>s or lose parts of the <code>namedtuple</code> convenience:  </p>
<pre><code>&gt;&gt;&gt; b = BlockTime.factory(1.0, 2.0)
&gt;&gt;&gt; b._replace(t_present=20)
BlockTime(t_present=20, t_pause=2.0, t_each=3.0)

&gt;&gt;&gt; b._make([1, 2])
TypeError: Expected 3 arguments, got 2
</code></pre>
<p>The fact that you actually have a "computed" field that has to be in sync with other fields already indicates that you probably shouldn't store it at all to avoid inconsistent state.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make a <code>classmethod</code> that builds <code>BlockTime</code> objects</p>
<pre><code>class BlockTime(NamedTuple):
    t_present: float
    t_pause: float
    t_each: float
    @classmethod
    def factory(cls, present, pause):
        return cls(present, pause, present+pause)

print(BlockTime.factory(1.0, 2.0))
# BlockTime(t_present=1.0, t_pause=2.0, t_each=3.0)
</code></pre>
<p>EDIT:</p>
<p>Here's a solution using the new Python 3.7 <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass" rel="nofollow noreferrer"><code>dataclass</code></a></p>
<pre><code>from dataclasses import dataclass, field

@dataclass(frozen=True)
class BlockTime:
    t_present: float
    t_pause: float
    t_each: float = field(init=False)
    def __post_init__(self):
        object.__setattr__(self, 't_each', self.t_present + self.t_pause)
</code></pre>
<p><a href="https://docs.python.org/3/library/dataclasses.html#frozen-instances" rel="nofollow noreferrer">Frozen <code>dataclass</code>es aren't totally immutable</a> but they're pretty close, and this lets you have natural looking instance creation <code>BlockTime(1.0, 2.0)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Well.. You cant override <code>__new__</code> or <code>__init__</code> of a class whose parent is NamedTuple. But you can overide <code>__new__</code> of a class, inherited from another class whose parent is NamedTuple.</p>
<p>So you can do something like this</p>
<pre><code>from typing import NamedTuple

class BlockTimeParent(NamedTuple):
    t_present: float
    t_pause: float
    t_each: float

class BlockTime(BlockTimeParent):
    def __new__(cls, t_present, t_pause):
        return super().__new__(cls, t_present, t_pause, t_present+ t_pause)

b = BlockTime(1,2)
print (b)
# BlockTime(t_present=1, t_pause=2, t_each=3)
</code></pre>
</div>
<span class="comment-copy">Note that the dataclass instance isn't a sequence, while the namedtuple would be (<code>BlockTime(1.0, 2.0)[-1]</code> works, as does <code>list(BlockTime(1.0, 2.0))</code>). That can be addressed; see <a href="https://stackoverflow.com/questions/44287623/a-way-to-subclass-namedtuple-for-purposes-of-typechecking/50369898#50369898">an answer of mine on NamedTuple subclassing</a> for an example.</span>
