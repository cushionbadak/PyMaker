<div class="post-text" itemprop="text">
<p>Consider the following:</p>
<pre><code>&gt;&gt;&gt; import numbers
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; a = numpy.int_(0)
&gt;&gt;&gt; isinstance(a, int)
False
&gt;&gt;&gt; isinstance(a, numbers.Integral)
True
&gt;&gt;&gt; b = numpy.float_(0)
&gt;&gt;&gt; isinstance(b, float)
True
&gt;&gt;&gt; isinstance(b, numbers.Real)
True
</code></pre>
<p>NumPy's <code>numpy.int_</code> and <code>numpy.float_</code> types are both in Python's <a href="https://docs.python.org/3/library/numbers.html" rel="noreferrer">numeric abstract base class hierarchy</a>, but it is strange to me that a <code>np.int_</code> object <em>is not</em> an instance of the built-in <code>int</code> class, while a <code>np.float_</code> object <em>is</em> an instance of the built-in <code>float</code> type.</p>
<p>Why is this the case?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python integers can be arbitrary length: <code>type(10**1000)</code> is still <code>int</code>, and will print out a one and then a thousand zeros on your screen if you output it.</p>
<p>Numpy <code>int64</code> (which is what <code>int_</code> is on my machine) are integers represented by 8 bytes (64 bits), and anything over that cannot be represented. For example, <code>np.int_(10)**1000</code> will give you a wrong answer - but quickly ;).</p>
<p>Thus, they are different kinds of numbers; subclassing one under the other makes as much sense as subclassing <code>int</code> under <code>float</code> would, is what I assume <code>numpy</code> people thought. It is best to keep them separate, so that no-one is confused about the fact that it would be unwise to confuse them.</p>
<p>The split is done because arbitrary-size integers are slow, while <code>numpy</code> tries to speed up computation by sticking to machine-friendly types.</p>
<p>On the other hand, floating point is the standard IEEE floating point, both in Python and in <code>numpy</code>, supported out-of-the-box by our processors.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>numpy.int_()</code> is actually 64-bit, and <code>int</code> can have an arbitrary size, it uses about 4 extra bytes for every 2^30 worth of bits you put in. <code>int64</code> has constant size:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.int_(0)
&gt;&gt;&gt; type(a)
&lt;type 'numpy.int64'&gt;
&gt;&gt;&gt; b = 0
&gt;&gt;&gt; type(b)
&lt;type 'int'&gt;
</code></pre>
</div>
<span class="comment-copy">(+1) Thanks! This is a compelling argument (at least to me). I'll wait a while for potential other answers before accepting.</span>
<span class="comment-copy">This doesn't answer my question. The type of <code>a = np.float_(0)</code> is <code>numpy.float64</code>, but it is still an instance of <code>float</code>. My question can be rephrased as "why is <code>numpy.float64</code> a subclass of <code>float</code> but <code>numpy.int64</code> is not a subclass of <code>int</code>?"</span>
<span class="comment-copy">@ArtemMavrin <code>int</code> can have an arbitrary size, it uses about 4 extra bytes for every 2^30 worth of bits you put in. <code>int64</code> has constant size.</span>
<span class="comment-copy">thank you, this reasoning makes more sense and agrees with the other answer so far.</span>
