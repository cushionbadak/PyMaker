<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1327369/extract-part-of-a-regex-match">Extract part of a regex match</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>I've written a script in python in combnation with <code>re</code> module to get the title of different questions from a webpage. My intention here is not to use <code>BeautifulSoup</code> and still to be able to parse the titles. The way I've used a pattern can do it. However, the output doesn't look so nice. How can I get only the question titles and nothing else.</p>
<p>Here is my try (using <code>re.search()</code>):</p>
<pre><code>import requests
import re

link = "https://stackoverflow.com/questions/tagged/web-scraping"

res = requests.get(link).text
for item in res.splitlines():
    matchitem = re.search(r'hyperlink"&gt;(How.+)&lt;/a&gt;',item)
    if matchitem:
        print(matchitem.group())
</code></pre>
<p>Output I'm getting like (out of several):</p>
<pre><code>hyperlink"&gt;How to use Selenium check the checkbox lists?&lt;/a&gt;
</code></pre>
<p>What I wish to get is like:</p>
<pre><code>How to use Selenium check the checkbox lists?
</code></pre>
<p>I'm very new to regex. So, I seek apology in advance, If my question doesn't fit to be a question.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just need to use <code>group(1)</code>, which gets the first captured subgroup, instead of <code>group()</code>, which gets the entire match.</p>
<p>From <a href="https://docs.python.org/3/library/re.html#re.Match.group" rel="nofollow noreferrer"><code>the docs</code></a>:</p>
<blockquote>
<p>Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned).</p>
</blockquote>
<p>So:</p>
<pre><code>&gt;&gt;&gt; item = 'blah blah hyperlink"&gt;How to use Selenium check the checkbox lists?&lt;/a&gt; stuff'
&gt;&gt;&gt; matchitem = re.search(r'hyperlink"&gt;(How.+)&lt;/a&gt;',item)
&gt;&gt;&gt; matchitem
&lt;_sre.SRE_Match object; span=(10, 70), match='hyperlink"&gt;How to use Selenium check the checkbox&gt;
&gt;&gt;&gt; matchitem.group()
'hyperlink"&gt;How to use Selenium check the checkbox lists?&lt;/a&gt;'
&gt;&gt;&gt; matchitem.group(1)
'How to use Selenium check the checkbox lists?'
</code></pre>
<p>As a side note:</p>
<blockquote>
<p>My intention here is not to use BeautifulSoup and still to be able to parse the titles. The way I've used a pattern can do it. </p>
</blockquote>
<p>Really? I can easily construct examples where your regex will do the wrong thing. Even without semi-pathological data, if they push a new minor release of the website on Tuesday that doesn't even touch this part of the code, given that attributes are arbitrarily ordered, the attributes of that <code>a</code> could show up in a different order, and suddenly your search fails, while a trivial BeautifulSoup search still works.</p>
<p>If you're doing this for the purpose of learning regular expressions, that may be fine (although really, HTML is not a great example to use for that), but if you're trying to get actual work done, you're better off using a parser.</p>
</div>
<span class="comment-copy">Using regex to parse HTML code is initially bad idea. Why you don't want to use BeautifulSoup? You might also check IMHO better option - <a href="https://lxml.de/lxmlhtml.html" rel="nofollow noreferrer">lxml.html</a></span>
<span class="comment-copy">I've to wait 7 minutes to accept your answer @abarnert.</span>
<span class="comment-copy">This was my first try using any pattern to parse titles. However, could you tell me why it failed (using negative lookbehind and positive lookahead) <code>'(?&lt;!hyperlink"&gt;)How.+(?=&lt;/a&gt;)'</code>?</span>
<span class="comment-copy">@asmitu <code>(?&lt;!hyperlink"&gt;)</code> matches a location that isn't immediately preceded with <code>hyperlink"&gt;</code>. You wanted to use a positive lookbehind <code>(?&lt;=hyperlink"&gt;)</code>. But you do not need as it is easy to capture a part of a string and get its value via <code>.group(n)</code>.</span>
<span class="comment-copy">Thanks a lot @Wiktor Stribi≈ºew. You just saved me from creating another post by providing with that answer.</span>
