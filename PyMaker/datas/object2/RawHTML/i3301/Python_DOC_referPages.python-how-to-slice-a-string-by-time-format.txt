<div class="post-text" itemprop="text">
<p>I have this string:</p>
<pre><code>"01:00 AM ART  Partly Cloudy 14C 01:00 PM ART  Mostly Sunny 25C 06:00 PM ART  Mostly Cloudy 23C"
</code></pre>
<p>And I want to split it by time format (<code>01:00 AM</code>, <code>01:00 PM</code> and <code>06:00 PM</code>) which can be different each time.
So, I tried to convert it to a list in order to loop through:
So, I get this list:</p>
<pre><code>[u'', u'01:00', u'AM', u'ART', u'', u'Partly', u'Cloudy', u'14C', u'01:00', u'PM', u'ART', u'', u'Mostly', u'Sunny', u'25C', u'06:00', u'PM', u'ART', u'', u'Mostly', u'Cloudy', u'23C', u'']
</code></pre>
<p>I want to remove space and empty char (but it doesn't work as you can see), and get from all that list another list with another three items:</p>
<ul>
<li>First item: <code>"01:00 AM ART  Partly Cloudy 14C"</code></li>
<li>Second item: <code>"01:00 PM ART  Mostly Sunny 25C"</code></li>
<li>Third item: <code>"06:00 PM ART  Mostly Cloudy 23C"</code></li>
</ul>
<p>Of course there can be one, none or even more that three items, depending on the time "word" found in string.
This is what I tried to do until now:</p>
<pre><code>w_table = soup.find("table", border="0", width="650", cellspacing="0", cellpadding="0")
w_text = w_table.text.split(" ")
refined_w = ""
for word_w in w_text:
    if word_w != " " or word_w != "":
        refined_w += word_w.strip() + " "
print refined_w
w_list = refined_w.split(" ")
print w_list
found_w = []
for element_w in w_list:
    if validate_date(element_w):
        for index in range(len(w_list)):
            if w_list[index] == element_w and index not in found_w:
                print index
                found_w.append(index)
print found_w
for i in found_w:
    print w_list[i:]
</code></pre>
<p>Thank you in advance !</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if this is the best solution, but it gets the job done.</p>
<pre><code>import re

try:
    from itertools import zip_longest
except ImportError:
    from itertools import izip_longest as zip_longest

def grouper(n, iterable, fillvalue=None):
    args = [iter(iterable)] * n
    return zip_longest(fillvalue=fillvalue, *args)

def split_by_date(input_data):
    splitted = re.split(r'([0-9]{2}:[0-9]{2} (AM|PM))', input_data)
    splitted.remove('')

    return ['{}{}'.format(a, c).strip() for a, _, c in grouper(3, splitted)]
</code></pre>
<p>Sample usage:</p>
<pre><code>&gt;&gt;&gt; split_by_date('01:00 AM ART  Partly Cloudy 14C 01:00 PM ART  Mostly Sunny 25C 06:00 PM ART  Mostly Cloudy 23C')
['01:00 AM ART  Partly Cloudy 14C', '01:00 PM ART  Mostly Sunny 25C', '06:00 PM ART  Mostly Cloudy 23C']
&gt;&gt;&gt; split_by_date('01:35 PM some very random string 16:65 AM Yet another string')
['01:35 PM some very random string', '16:65 AM Yet another string']
</code></pre>
<p>The <code>try</code> block is just to ensure python2/3 compatibility. The <code>grouper</code> function is a recipe from the <code>itertools</code> module documentation (<a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools-recipes</a>).</p>
<p>Edit</p>
<p>I was able to get rid of the <code>grouper</code> function by changing the regex a little and using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>. I hope it makes the code more legible.</p>
<pre><code>import re
from itertools import islice


def split_by_date(input_data):
    splitted = re.split(r'([0-9]{2}:[0-9]{2} AM|[0-9]{2}:[0-9]{2} PM)', input_data)
    splitted.remove('')

    iter_a = islice(splitted, 0, None, 2)
    iter_b = islice(splitted, 1, None, 2)

    return ['{}{}'.format(a, b).strip() for a, b in zip(iter_a, iter_b)]
</code></pre>
<p>Usage is the same.</p>
</div>
<span class="comment-copy">Could you explain, please, what is that number 3 from here: grouper(3, splitted) ? Thank you very much in advance !</span>
<span class="comment-copy">It is to iterate over 3 elements each time. The <code>re.split</code> call return a list in the form of <code>['', '01:35 PM', 'PM', ' some very random string ', '16:65 AM', 'AM', ' Yet another string']</code> (for the second example). And, after the empty strings are removed we still need to join the elements to get the desired output.</span>
