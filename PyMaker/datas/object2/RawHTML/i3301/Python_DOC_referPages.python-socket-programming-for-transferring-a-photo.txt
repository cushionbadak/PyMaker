<div class="post-text" itemprop="text">
<p>I'm new to socket programming in python. Here is an example of opening a TCP socket in a Mininet host and sending a photo from one host to another. In fact I changed the code that I had used to send a simple message to another host (<a href="https://stackoverflow.com/questions/51265502/writing-the-received-data-to-a-text-file">writing the received data to a text file</a>) in order to meet my requirements. Although when I implement this revised code, there is no error and it seems to transfer correctly, I am not sure whether this is a correct way to do this transmission or not. Since I'm running both hosts on the same machine, I thought it may have an influence on the result. I wanted to ask you to check whether this is a correct way to transfer or I should add or remove something. </p>
<p>mininetSocketTest.py
    #!/usr/bin/python</p>
<pre><code>from mininet.topo import Topo, SingleSwitchTopo
from mininet.net import Mininet
from mininet.log import lg, info
from mininet.cli import CLI

def main():
    lg.setLogLevel('info')

    net = Mininet(SingleSwitchTopo(k=2))
    net.start()

    h1 = net.get('h1')
    p1 = h1.popen('python myClient2.py')

    h2 = net.get('h2')
    h2.cmd('python myServer2.py')

    CLI( net )
    #p1.terminate()
    net.stop()

if __name__ == '__main__':
     main()
</code></pre>
<p>myServer2.py</p>
<pre><code>import socket
import sys

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(('10.0.0.1', 12345))

buf = 1024
f = open("2.jpg",'wb')

s.listen(1)
conn , addr = s.accept()
while 1:
    data = conn.recv(buf)
    print(data[:10])
    #print "PACKAGE RECEIVED..."
    f.write(data)   
    if not data: break
    #conn.send(data)
conn.close()
s.close()
</code></pre>
<p>myClient2.py:</p>
<pre><code>import socket
import sys

f=open ("1.jpg", "rb")
print sys.getsizeof(f)
buf = 1024
data = f.read(buf)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('10.0.0.1',12345))


while (data):
    if(s.sendall(data)):
        #print "sending ..."
        data = f.read(buf)
        print(f.tell(), data[:10])
    else:
         s.close()
s.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This loop in <code>client2</code> is wrong:</p>
<pre><code>while (data):
    if(s.send(data)):
        print "sending ..."
        data = f.read(buf)
</code></pre>
<p>As the <a href="https://docs.python.org/3/library/socket.html#socket.socket.send" rel="nofollow noreferrer"><code>send</code></a> 
docs say:</p>
<blockquote>
<p>Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this topic, consult the <a href="https://docs.python.org/3/howto/sockets.html#socket-howto" rel="nofollow noreferrer">Socket Programming HOWTO</a>.</p>
</blockquote>
<p>You're not even attempting to do this. So, while it probably works on localhost, on a lightly-loaded machine, with smallish files, it's going to break as soon as you try to use it for real.</p>
<p>As the help says, you need to do something to deliver the rest of the buffer. Since there's probably no good reason you can't just block until it's all sent, the simplest thing to do is to call <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendall" rel="nofollow noreferrer"><code>sendall</code></a>:</p>
<blockquote>
<p>Unlike send(), this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised…</p>
</blockquote>
<hr/>
<p>And this brings up the next problem: You're not doing any exception handling anywhere. Maybe that's OK, but usually it isn't. For example, if one of your sockets goes down, but the other one is still up, do you want to abort the whole program and hard-drop your connection, or do you maybe want to finish sending whatever you have first?</p>
<p>You should at least probably use a <code>with</code> clause of a <code>finally</code>, to make sure you <code>close</code> your sockets cleanly, so the other side will get a nice EOF instead of an exception.</p>
<hr/>
<p>Also, your server code just serves a single client and then quits. Is that actually what you wanted? Usually, even if you don't need concurrent clients, you at least want to loop around accepting and servicing them one by one.</p>
<hr/>
<p>Finally, a server almost always wants to do this:</p>
<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
</code></pre>
<p>Without this, if you try to run the server again within a few seconds after it finished (a platform-specific number of seconds, which may even depend whether it finished with an exception instead of a clean shutdown), the <code>bind</code> will fail, in the same way as if you tried to bind a socket that's actually in use by another program.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you should use TCP and not UDP. TCP will ensure that your client/server has received the whole photo properly. UDP is more used for content streaming. 
Absolutely not your use case.</p>
</div>
<span class="comment-copy">"My code works, please look it over" is probably a question for Code Review, not for Stack Overflow.</span>
<span class="comment-copy">Thanks for your reply. I changed send to sendall, but then I have an infinite loop in server side, printing PACKAGE RECEIVED...PACKAGE RECEIVED...PACKAGE RECEIVED... .... And my new file (2.jpg) is corrupted</span>
<span class="comment-copy">About the 3rd case, since I'm just testing socket programming, my server accepts only one client at this time, but in fact you're right. It can accept more clients. And about the last case I added s.setsockopt(socket.SOL_SOCKET, socket, SO_REUSEADDR, 1) after this line: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) but I faced an error stating that SO_REUSEADDR is not defined</span>
<span class="comment-copy">@helen Sorry; it's <code>socket.SO_REUSEADDR</code>, not <code>socket, SO.REUSEADDR</code>. (That's what I get for editing on a tablet…) As for the infinite loop… If <code>if not data: break</code> is never happening, that implies that the <code>data = conn.recv(buf)</code> keeps returning non-empty buffers. Which should only happen if the client keeps sending forever. But the client keeps doing <code>data = f.read(buf)</code> until it's empty, and you haven't opened an infinite-size pseudofile like <code>/dev/zero</code>, so that doesn't make sense.</span>
<span class="comment-copy">@helen: Can you edit the code to have the server <code>print(data[:10])</code> and the client <code>print(f.tell(), data[:10])</code> or something?</span>
<span class="comment-copy">@helen It's worth noting that, for a moderately-sized JPEG, you're going to get hundreds or even thousands of <code>PACKAGE RECEIVED…</code> messages, because you're printing that for every 1KB , but it will eventually end.</span>
<span class="comment-copy">yes , you're right. however this is just a sample case and if I know what the problem of this code is, it would also be much easier to implement this using TCP :)</span>
<span class="comment-copy">Dear Jonathan, I tried to change my code so that it can use TCP instead of UDP. I edited my code. Would you please take a look at it to see whether it is correct now?</span>
<span class="comment-copy">I think this was at least a partial answer to the original version of the question, but it's been edited since then, so the question no longer has this problem, but still has a couple of others.</span>
