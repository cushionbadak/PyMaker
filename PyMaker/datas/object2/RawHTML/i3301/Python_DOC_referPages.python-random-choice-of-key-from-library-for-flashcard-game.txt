<div class="post-text" itemprop="text">
<p>I'm fairly new to python and programming in general, and am trying to create some simple programs. 
I have decided to build a small flashcard program to aid in my study of русский, and have used a dictionary with english definitions as the key, and the русский equivalent as the value. The program runs but I am struggling to figure how I can randomise the word that gets called. I have tried random.choice(vocabulary) but with little success. I have also tried to turn the dictionary key/value pairs into lists but then struggle to call them using the format I have so far used.</p>
<p>Is there a way to randomise the key that gets called using a variation on this script? Further, would a different object type be more useful for such a program? Thanks</p>
<pre><code>import random

vocabulary = {
    "to study (imperfective)": "изучать",
     "to begin (imperfective)": "начинать",
     "to begin (perfective)": "начать"
}

n = 0
while n &lt; 1:
for english, russian in vocabulary.items():
    print("Translate:\n" + english + "\n")
    answer = input("Answer:\n" )
    if answer == russian:
        print("Correct!\n")
    else:
        print("Incorrect! Correct answer: \n" + russian + "\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer"><code>random.choice</code></a> can:</p>
<blockquote>
<p>Return a random element from the non-empty sequence <em>seq</em>.</p>
</blockquote>
<p>The only problem is that you don't have a sequence here, you have a dictionary.</p>
<p>But a dictionary is an iterable of its keys, so you can directly construct a tuple (or list, or most other kinds of sequences) of its keys:</p>
<pre><code>english = random.choice(tuple(vocabulary))
russian = vocabulary[english]
</code></pre>
<p>Or, since its items view is an iterable of key-value pairs:</p>
<pre><code>english, russian = random.choice(tuple(vocabulary.items())
</code></pre>
<p>For a huge dictionary, this is a bit wasteful, because it copies the keys or items into a tuple just to pick one. But when you're talking about only 3 keys, or even 50000, that isn't going to be a problem, so keep it simple.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>random</code> module's <code>choice</code> function: </p>
<pre><code>from random import choice
numbers = [1, 2, 3, 4, 5]
random_element = choice(numbers)
</code></pre>
<p>You can call this on a dictionary's <code>.keys()</code> to get a random key in python2, or as abarnert says, change your items to a <code>tuple</code> (or the keys to a <code>list</code>) before using <code>choice</code> in python3. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random

vocabulary = {
  "to study (imperfective)": "изучать",
  "to begin (imperfective)": "начинать",
  "to begin (perfective)": "начать"
}
randomChoice = random.randint(0, len(vocabulary)-1)
randomChoice = list(vocabulary.keys())[randomChoice]
print randomChoice
print vocabulary[randomChoice]
</code></pre>
<p>prints:</p>
<blockquote>
<p>either: "to study (imperfective)" ,"to begin (imperfective)" or "to begin (perfective)"</p>
<p>and: "изучать", "начинать" and "начать"</p>
</blockquote>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer">random.choice(iterable)</a> comes into mind ....</span>
<span class="comment-copy">@PatrickArtner, the answer is literally in the first three words :)</span>
<span class="comment-copy">Actually, you <i>can't</i> call it on the key view, or on the dict itself. <code>choice</code> requires a <i>sequence</i>, not just an iterable.</span>
<span class="comment-copy">The simplest solution (which is fine for a dict this small) is <code>choice(tuple(vocabulary))</code>.</span>
<span class="comment-copy">@abarnert in python 3, right. It's true that the choice function requires an indexed thing, I'll update to reflect that.</span>
<span class="comment-copy">It requires a sequence in Python 2 as well, it just doesn't <i>check</i> it, so if you do, say, <code>choice({0: "spam", 2: "eggs"})</code> it'll return <code>"spam"</code> half the time and <code>KeyError: 1</code> the other half the time. It doesn't actually <i>work</i> unless your keys happen to be exactly <code>range(0, len(d))</code>. The only reason it works on <code>keys()</code> in 2.x is that <code>keys()</code> is already copying the keys into a list.</span>
