<div class="post-text" itemprop="text">
<p>I thought the "for in" statement takes in iterables not iterators, but somehow the following codes works fine. I am confused. Actually, I was looking at the generator example at :
<a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0289/</a></p>
<pre><code>&gt;&gt;&gt; for i in range(10):
    print(i)


0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt; for i in iter(range(10)):
    print(i)


0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt;
</code></pre>
<p>Anyone can explain what happened when using iter(range(10)) in the for loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterators <em>are iterables too</em>. <code>for</code> calls <code>iter()</code> on the object it iterates over, and if you already have an iterator, then that produces a reference to the same object. This is by design.</p>
<p>From the <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer"><code>iterator</code> entry in the Python glossary</a>:</p>
<blockquote>
<p>Iterators are required to have an <code>__iter__()</code> method that returns the iterator object itself <strong>so every iterator is also iterable</strong> and may be used in most places where other iterables are accepted.</p>
</blockquote>
<p><em>Bold emphasis mine</em>.</p>
<p>From the same document, on the term <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer"><code>iterable</code></a>:</p>
<blockquote>
<p>When using iterables, it is usually not necessary to call <code>iter()</code> or deal with iterator objects yourself. The <code>for</code> statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop.</p>
</blockquote>
<p>and from the <a href="https://docs.python.org/3/library/stdtypes.html#typeiter" rel="nofollow noreferrer"><em>Iterator types</em> section of the standard types document</a>:</p>
<blockquote>
<p>The iterator objects themselves are required to support the following two methods, which together form the <em>iterator protocol</em>:</p>
<pre><code>iterator.__iter__()
</code></pre>
<p>Return the iterator object itself. <strong>This is required to allow both containers and iterators to be used with the <code>for</code> and <code>in</code> statements.</strong> </p>
</blockquote>
<p><em>Bold emphasis mine</em>.</p>
<p>So when you use <code>for ... in iter(range(...))</code> instead of <code>for ... in range()</code>, you make an extra call to <code>iter()</code> that's basically redundant, as <code>for</code> already makes that call itself.</p>
<p>But you <em>can</em> use <code>iter()</code> <em>before</em> you use a <code>for</code> loop to keep a reference to the iterator; so you could use it to advance to the next value <em>elsewhere</em>, in coordination with the <code>for</code> loop:</p>
<pre><code>&gt;&gt;&gt; range_iter = iter(range(10))
&gt;&gt;&gt; for i in range_iter:
...     print('for loop produced', i)
...     if i % 4 == 0:
...         j = next(range_iter)
...         print('But we can advance the iterator manually, too:', j)
...
for loop produced 0
But we can advance the iterator manually, too: 1
for loop produced 2
for loop produced 3
for loop produced 4
But we can advance the iterator manually, too: 5
for loop produced 6
for loop produced 7
for loop produced 8
But we can advance the iterator manually, too: 9
</code></pre>
<p>In the PEP, in the <a href="https://www.python.org/dev/peps/pep-0289/#the-details" rel="nofollow noreferrer">detail section</a>, the code example there uses an <code>iter()</code> call <em>before</em> calling the generator function, because that <code>iter()</code> call could potentially raise an exception. You'd want that exception to be raised when defining the generator expression, not later on when you try to iterate over the generator expression.</p>
<p>Or put concretely, the following code fails on the first line, not during looping:</p>
<pre><code>gen = (x ** 2 for x in 1)  # 1 is not an iterable
for i in gen: print(i)
</code></pre>
<p>If the implementation did not call <code>iter()</code> <em>first</em>, then only when the <code>for</code> loop executes would there be an exception, and that would be confusing because the <code>gen</code> reference could have been created in any number of places in the code, really.</p>
</div>
<span class="comment-copy">iterators <i>are iterables</i>.</span>
<span class="comment-copy">then why bother using iter(range(10)) in the generator example in the hyperlink?</span>
<span class="comment-copy">@OpticalDataScience: because the PEP documents that the internal workings of the generator expression implementation will create an iterator <i>before</i> calling the generator function object. The actual implementation doesn't use a <code>for</code> loop, it generates bytecode that is roughly equivalent.</span>
<span class="comment-copy">@OpticalDataScience: this matters when you use that generator expression at a later point in your code. If the <code>iter()</code> call fails, it'll fail at the point where the generator expression is defined, not where you eventually iterate over it.</span>
