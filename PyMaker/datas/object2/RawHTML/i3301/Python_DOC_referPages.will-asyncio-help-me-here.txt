<div class="post-text" itemprop="text">
<p>I have a little python application that I have developed using wxpython4.0.3 that performs a fairly simple ETL type task of:</p>
<ul>
<li>Takes user input to select a parent directory containing several
sub-directories full of CSV files (time series data.)</li>
<li>Transforms the data in each of those files to comply with formatting
required by a third party recipient and writes them out to new
files.</li>
<li>Zips each of the new files into a file named after the original
file's parent directory</li>
<li>At the user's initiative the application then FTPs the zip files to
the third party to be loaded into a data store.</li>
</ul>
<p>The application works well enough, but the time required to process through several thousand CSV files is pretty extreme and mostly IO bound from what I can tell.</p>
<p>Is asyncio a reasonable option to pursue or are there other recommendations that anyone can make? I originally wrote this as a CLI and saw significant performance gains by using pypy, but I was reluctant to combine pypy with wxpython when I developed the UI for others.</p>
<p>Thanks for your guidance.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you saw a significant speedup by using PyPy instead of CPython, that implies that your code probably <em>isn't</em> I/O-bound. Which means that making the I/O asynchronous isn't going to help very much. Plus, it'll be extra work, as well, because you'll have to restructure all of your CPU-heavy tasks into small pieces that can <code>await</code> repeatedly so they don't block the other tasks.</p>
<p>So, you probably want to use multiple processes here.</p>
<p>The simplest solution is to use a <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.futures.ProcessPoolExecutor</code></a>: just toss tasks at the executor, and it'll run them on the child processes and return you a <code>Future</code>.</p>
<p>Unlike using <code>asyncio</code>, you won't have to change those tasks at all. They can read a file just by looping over the <code>csv</code> module, process it all in one big chunk, and even use the synchronous <code>ftplib</code> module, without needing to worry about anyone blocking anyone else. Only your top-level code needs to change.</p>
<p>However, you may want to consider splitting the code into a <code>wx</code> GUI that you run in CPython, and a multiprocessing engine that you run via <code>subprocess</code> in PyPy, which then spins off the <code>ProcessPoolExecutor</code> in PyPy as well. This would take a bit more work, but it means you'll get the CPU benefits of using PyPy, the well-tested-with-wx benefits of using CPython, and the parallelism of multiprocessing.</p>
<p>Another option to consider is pulling in a library like NumPy or Pandas that can do the slow parts (whether that's reading and processing the CSV, or doing some kind of elementwise computation on thousands of rows, or whatever) more quickly (and possibly even releasing the GIL, meaning you don't need multiprocessing).</p>
<hr/>
<p>If your code really <em>is</em> I/O-bound code, and primarily bound on the FTP requests, <code>asyncio</code> would help. But it would require rewriting a lot of code. You'd need to find or write an <code>asyncio</code>-driven FTP client library. And, if the file reading takes any significant part of your time, converting that to async is even more work. </p>
<p>There's also the problem of integrating the <code>wx</code> event loop with the <code>asyncio</code> event loop. You might be able to get away with running the <code>asyncio</code> loop in a second thread, but then you need to come up with some way of communicating between the <code>wx</code> event loop in the main thread and the <code>asyncio</code> loop in the background thread. Alternatively, you might be able to drive one loop from the other (or there might even be third-party libraries that do that for you). But this might be a lot easier to do with (or have better third-party libraries to help with) something like <code>twisted</code> instead of <code>asyncio</code>.</p>
<p>But, unless you need massive concurrency (which you probably don't, unless you've got hundreds of different FTP servers to talk to), threads should work just as well, with a lot fewer changes to your code. Just use a <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.futures.ThreadPoolExecutor</code></a>, which is nearly identical to using a <code>ProcessPoolExecutor</code> as explained above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you will probably benefit from using asynchronous library. Since most of your time is spent waiting for IO, a well-written asynchronous program will use that time to do something else, without the overhead of extra threads/processes. It will scale really well.</p>
</div>
<span class="comment-copy">Why do you think it's mostly I/O bound? The fact that PyPy speeds it up significantly implies that there's probably a lot of CPU-bound work to be sped up.</span>
<span class="comment-copy">But why ThreadPoolExecutor? If bottleneck is data processing it won't help due to GIL. ProcessPoolExecutor then?</span>
<span class="comment-copy">@MikhailGerasimov The OP says the code is I/O-bound. If he's right, then the GIL isn't an issue, and threads will work fine. If he's wrongâ€¦ well, that's what the entire first half of my answer is about.</span>
<span class="comment-copy">@MikhailGerasimov Ah, just realized that my links and text were backward. Was that confusing you? (Even if not, I'm sure it would confuse other readers, so I fixed it, and thanks for making me see it.)</span>
