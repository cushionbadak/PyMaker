<div class="post-text" itemprop="text">
<p>How can i create an IPv4 address 0.0.0.0 and increment it so it gives me the output from 0-255 as 0.0.0.255 then 0.0.255.255,0.255.255.255,255.255.255.255?</p>
</div>
<div class="post-text" itemprop="text">
<p>Avoid using custom functions and go with the <code>netaddr</code> package. Just create a <code>netaddr.IPNetwork</code> object for network <code>0.0.0.0/0</code> and you should be able to get the nth address by referring it as <code>netaddr.IPNetwork('0.0.0.0/0')[n]</code> or you can create an iterator as <code>netaddr.IPNetwork('0.0.0.0/0').iter_hosts()</code></p>
<p>You should be able to get it by doing <code>pip install netaddr</code></p>
<pre><code>&gt;&gt;&gt; from netaddr import IPNetwork
&gt;&gt;&gt; net = IPNetwork('0.0.0.0/0') 
&gt;&gt;&gt; net[1]                       
IPAddress('0.0.0.1')
&gt;&gt;&gt; str(net[1])
'0.0.0.1' 
</code></pre>
<p>More examples</p>
<pre><code>&gt;&gt;&gt; str(net[255])  
'0.0.0.255'        
&gt;&gt;&gt; str(net[256])  
'0.0.1.0'          
&gt;&gt;&gt; str(net[65535])
'0.0.255.255'      
&gt;&gt;&gt; str(net[65536])
'0.1.0.0'          
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>struct</code> lib.</p>
<pre><code>import struct

n = 257

y1, y2, y3, y4 = struct.Struct('&lt;I').pack(n &amp; 0xFFFFFFFF)

print("{0}.{1}.{2}.{3}".format(y4,y3,y2,y1)) # OUTPUT: 0.0.1.1
</code></pre>
<p><code>I</code> stands for big integer (4 bytes), <code>&lt;</code> stands for big endian (bytes position).<br/>
Then you format the bytes in the right order. Increase or decrease <code>n</code> for having different ip addresses</p>
</div>
<div class="post-text" itemprop="text">
<p>Range from 0 to 16777216 (which is 2 ** 24, as your title requesting for <code>0.255.255.255</code>, or 4294967296 which is 2 ** 32 as your question body requesting for <code>255.255.255.255</code>), then bitwise AND <code>0xff</code>, <code>0xff00</code>, <code>0xff0000</code>, <code>0xff000000</code> to extract the corresponding bits, and shift them right to print with format.</p>
<pre><code>for i in range(0, 2 ** 24): # modify to 2 ** 32 if you want to generate output to 255.255.255.255
    byte3 = i &amp; 0xff
    byte2 = i &amp; 0xff00
    byte1 = i &amp; 0xff0000
    byte0 = i &amp; 0xff000000
    print('%d.%d.%d.%d' % (byte0 &gt;&gt; 24, byte1 &gt;&gt; 16, byte2 &gt;&gt; 8, byte3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code></a> module in the standard library lets you do arithmetic on IP addresses in the obvious way, and conversion to and from integers, and to and from dotted-quad strings.</p>
<p>I'm not sure what you're trying to do, but whatever it is, it's easy.</p>
<p>For example, here's an iterator over all 4 billion IPv4 addresses:</p>
<pre><code>def all_addrs():
    for i in range(0, 1&lt;&lt;32):
        yield ipaddress.IPv4Address(i)
</code></pre>
<p>Or, if you prefer:</p>
<pre><code>def all_addrs():
    addr = ipaddress.IPv4Address(0)
    while True:
        yield addr
        try:
            addr += 1
        except ValueError:
            return
</code></pre>
<p>Or, if you want to iterate the first 256, then do three special addresses after that:</p>
<pre><code>def weird_259():
    for i in range(256):
        yield ipaddress.IPv4Address(i)
    yield ipaddress.IPv4Address('0.0.255.255')
    yield ipaddress.IPv4Address('0.255.255.255')
    yield ipaddress.IPv4Address('255.255.255.255')
</code></pre>
<hr/>
<p>If you want to do other things, read the docs for <code>IPv4Address</code>. Notice that you can construct an address from:</p>
<ol>
<li>A string in decimal-dot notation…</li>
<li>An integer…</li>
<li>An integer packed into a <code>bytes</code> object of length 4 (most significant octet first).</li>
</ol>
<p>So, let's say you want to make one out the octets 0, 127, 255, 255. How could you do that? First, you create a bytes with those values:</p>
<pre><code>bytes([0, 127, 255, 255])
</code></pre>
<p>… and then you create an address with those bytes:</p>
<pre><code>ipaddress.IPv4Address(bytes([0, 127, 255, 255]))
</code></pre>
<p>If you want to, you can wrap that up in a function:</p>
<pre><code>def makeaddr(a, b, c, d):
    return ipaddress.IPv4Address(bytes([a, b, c, d]))
</code></pre>
<p>So, if you wanted the 256 addresses of the form <code>0.0.0.x</code>, and the 256 of the form <code>0.0.x.255</code>, and <code>0.x.255.255</code>, and <code>x.255.255.255</code>, that's trivial:</p>
<pre><code>def make_1024():
    for x in range(256):
        yield makeaddr(0, 0, 0, x)
    for x in range(256):
        yield makeaddr(0, 0, x, 255)
    for x in range(256):
        yield makeaddr(0, x, 255, 255)
    for x in range(256):
        yield makeaddr(x, 255, 255, 255)
</code></pre>
<p>And if you want to print them out in the default (decimal-dot) notation, just <code>print</code> them:</p>
<pre><code>for addr in make_1024():
    print(addr)
</code></pre>
</div>
<span class="comment-copy">So you want only 259 addresses, the first 256, then those three extras? Or you want to iterate over all 4 billion? Or…?</span>
<span class="comment-copy">@abarnert just the first 256 and then those three extras</span>
<span class="comment-copy">Then take the code in my answer and either <code>for addr in weird_259(): print(addr)</code>, or just change the <code>yield</code> to a <code>print</code>.</span>
<span class="comment-copy">Why go with a third-party library instead of the one that comes in the stdlib and is even easier to use?</span>
<span class="comment-copy">Yes!! This is what i meant to do but do you know some other way of doing this like using some module for it?</span>
<span class="comment-copy">@TheCharismaticSid What do you mean of "module"? I think the top vote answer (yes, I top vote that, too) which uses <code>netaddr</code> package is "using some module", however you commented that you need a built-in package?</span>
<span class="comment-copy">@TheCharismaticSid Are you looking for a built-in package which can achieve this?</span>
<span class="comment-copy">for i in range(0, 2 ** 24): # modify to 2 ** 32 if you want to generate output to 255.255.255.255     byte3 = i &amp; 0xff     byte2 = i &amp; 0xff00     byte1 = i &amp; 0xff0000     byte0 = i &amp; 0xff000000     print('%d.%d.%d.%d' % (byte0 &gt;&gt; 24, byte1 &gt;&gt; 16, byte2 &gt;&gt; 8, byte3)) # this is what i wanna do but i want to use the ipaddress module or some easier way of doing this compared to the above one.</span>
<span class="comment-copy">@TheCharismaticSid I don’t understand what you mean by that comment. What does my answer not explain that you need to do?</span>
<span class="comment-copy">sir, i used your def weird_259() code and was able to iterate the last octet of 0.0.0.0 how do i iterate the other octets in the same manner?</span>
<span class="comment-copy">Your comment on the question says you want "just the first 256 and then those three extras". That's exactly what the code gives you. I don't understand what you're trying to do here. I tried asking for clarification, made sure my code did what you said you wanted after you clarified, and apparently that isn't what you actually wanted, so… I don't know how to help you.</span>
<span class="comment-copy">@abarnet ok let's do this again forget everything you have read about my posts till this point and kindly read what I am about to type so there's no ambiguity left:- I used your code and it iterated the last octet "<b>0.0.0.This</b>" one by one till 255 which i wanted now my query is, can i iterate the other octets like this as well "<b>0.0.This.255</b>" "<b>0.This.255.255</b>" "<b>This.255.255.255</b>" so in the end i get <b>255.255.255.255</b> by iterating each one from 0 to 255. Hope that made it clear.</span>
