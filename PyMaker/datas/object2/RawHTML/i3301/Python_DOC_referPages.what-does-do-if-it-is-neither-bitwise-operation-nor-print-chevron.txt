<div class="post-text" itemprop="text">
<p>Is there anyone who could help figure out what the double greater-than symbol (i.e. <code>Drug &gt;&gt; float</code> in line 10 and <code>Drug &gt;&gt; int</code> in line 13) means in the following python scripts? </p>
<pre><code> 1  from owlready2 import *
 2
 3  onto = get_ontology("http://test.org/onto.owl")
 4
 5  with onto:
 6      class Drug(Thing):
 7          def get_per_tablet_cost(self):
 8              return self.cost / self.number_of_tablets
 9
10      class has_for_cost(Drug &gt;&gt; float, FunctionalProperty):
11          python_name = "cost"
12
13      class has_for_number_of_tablets(Drug &gt;&gt; int, FunctionalProperty):
14          python_name = "number_of_tablets"
15
16  my_drug = Drug(cost = 10.0, number_of_tablets = 5)
17  print(my_drug.get_per_tablet_cost())

--- Below is the printing outcome. ---
2.0
</code></pre>
<p>The code is copied from <a href="https://owlready2.readthedocs.io/en/latest/mixing_python_owl.html#adding-python-methods-to-an-owl-class" rel="nofollow noreferrer">here</a> and runs in python 3.  </p>
<p>The <code>&gt;&gt;</code> symbol here is not bitwise operator. <a href="https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types" rel="nofollow noreferrer">Python's bitwise operation</a>, say <code>x &gt;&gt; y</code>, requires <code>y</code> to be an integer. It is clear that the code here (<code>Drug &gt;&gt; float</code>) is not shifting <code>Drug</code> right by <code>float</code> bits. </p>
<p>Although similar questions were asked before (see <a href="https://stackoverflow.com/questions/22832615/what-do-and-mean-in-python">here</a> and <a href="https://stackoverflow.com/questions/34385674/what-does-print-do-in-python">here</a>), their answers mostly pointed to the so-called <a href="https://docs.python.org/2/reference/simple_stmts.html#the-print-statement" rel="nofollow noreferrer">"print chevron"</a> in python 2, where the <code>&gt;&gt;</code> redirects the to-be-printed messages to the file-like object specified right after the <code>&gt;&gt;</code>. They do not apply to my question because here is not a case of print statement.  </p>
<p>To trace the <code>&gt;&gt;</code> in the code above, I revised the script in line 10 as <code>class has_for_cost(Drug &gt;&gt; list, FunctionalProperty)</code> (namely replace <code>&gt;&gt; float</code> with <code>&gt;&gt; list</code>) and ran the code again. It raised an AttributeError as follows:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
&lt;ipython-input-1-1be374b27b04&gt; in &lt;module&gt;()
      8             return self.cost / self.number_of_tablets
      9 
---&gt; 10     class has_for_cost(Drug &gt;&gt; list, FunctionalProperty):
     11         python_name = "cost"
     12 

~/anaconda3/lib/python3.6/site-packages/owlready2/prop.py in __init__(Prop, name, bases, obj_dict)
    254 class ReasoningPropertyClass(PropertyClass):
    255   def __init__(Prop, name, bases, obj_dict):
--&gt; 256     super().__init__(name, bases, obj_dict)
    257 
    258     if (not Prop.namespace.world is owl_world):

~/anaconda3/lib/python3.6/site-packages/owlready2/prop.py in __init__(Prop, name, bases, obj_dict)
     78 
     79       if not range is False:
---&gt; 80         Prop.range.extend(range)
     81 
     82       if not inverse_property is False:

~/anaconda3/lib/python3.6/site-packages/owlready2/util.py in extend(self, l)
     58   def append(self, x):          old = list(self); super().append(x)         ; self._callback(self._obj, old)
     59   def insert(self, i, x):       old = list(self); super().insert(i, x)      ; self._callback(self._obj, old)
---&gt; 60   def extend(self, l):          old = list(self); super().extend(l)         ; self._callback(self._obj, old)
     61   def remove(self, x):          old = list(self); super().remove(x)         ; self._callback(self._obj, old)
     62   def __delitem__(self, i):     old = list(self); super().__delitem__(i)    ; self._callback(self._obj, old)

~/anaconda3/lib/python3.6/site-packages/owlready2/prop.py in _range_changed(Prop, old)
    143     for x in new - old:
    144       if isinstance(x, ClassConstruct): x._set_ontology(Prop.namespace.ontology)
--&gt; 145       x2 = _universal_datatype_2_abbrev.get(x) or x.storid
    146       Prop.namespace.ontology.add_triple(Prop.storid, rdf_range, x2)
    147 

AttributeError: type object 'list' has no attribute 'storid'
</code></pre>
<p>With the traceback info, though, I still could not find the answer. I would be very thankful if anyone could help figure out what the <code>&gt;&gt;</code> does in the code. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>Drug &gt;&gt; float</code> calls <code>Drug</code>'s <a href="https://docs.python.org/3/reference/datamodel.html#object.__rshift__" rel="nofollow noreferrer"><code>__rshift__</code></a> method. That method can do whatever it wants; it doesn't have to be a binary shift operation.</p>
<p>Reading <a href="https://owlready2.readthedocs.io/en/latest/properties.html" rel="nofollow noreferrer">the owlready2 documentation</a> reveals that <code>domain &gt;&gt; range</code> is a fancy way of creating an <code>ObjectProperty</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/51181373/10033543">Aran-Fey</a> has answered the question in brief. Below is just to save time for those who don't want to download and parse the source codes of <a href="https://bitbucket.org/jibalamy/owlready2/src" rel="nofollow noreferrer">owlready2</a> but still want to trace how it works in the actual codes.  </p>
<ol>
<li><code>Drug</code> is an object created on the basis of another object <code>ThingClass</code>, as defined in /owlready2/entity.py.</li>
<li><code>Drug &gt;&gt; float</code> calls <code>Drug.__rshift__(self, float)</code> [<a href="https://docs.python.org/3/reference/datamodel.html#object.__rshift__" rel="nofollow noreferrer">explained</a>].</li>
<li><p>It is not <code>Drug</code> but its base object <code>ThingClass</code> that has a <code>__rshift__</code> method, which reads in the entity.py:  </p>
<pre><code>class ThingClass(EntityClass):
    ...
    def __rshift__(Domain, Range):
        import owlready2.prop
        owlready2.prop._next_domain_range = (Domain, Range)
        if isinstance(Range, ThingClass) or isinstance(Range, ClassConstruct):
            return owlready2.prop.ObjectProperty
        else:
            return owlready2.prop.DataProperty
</code></pre></li>
<li><p><code>Drug &gt;&gt; float</code> is equivalent to <code>__rshift__(Domain=Drug, Range=float)</code>, which is in fact <strong><em>not</em></strong> doing a binary arithmetic operation but returns/creates either a DataProperty or an ObjectProperty, depending on the type of Range.</p></li>
</ol>
</div>
<span class="comment-copy">Classes can implement the bitshift operator however they choose, some less intuitively than others.  The magic method you should be looking for in the class definition is <code>__rshift__(self, other)</code>, <code>__rrshift__(self, other)</code>, or <code>__irshift__(self, other)</code></span>
<span class="comment-copy">@jedwards is right. It is <code>__rshift__()</code>  defined in a base object, <code>ThingClass</code>, do the trick. Details can be found <a href="https://stackoverflow.com/a/51184773/10033543">here</a>.</span>
