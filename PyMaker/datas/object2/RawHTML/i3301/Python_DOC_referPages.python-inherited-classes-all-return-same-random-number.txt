<div class="post-text" itemprop="text">
<p>I have a few classes with almost identical contents, so I tried two methods to copy the classes and their attributes over. The classes copy correctly, but the randint function is only invoked in the main class, so the same number is output every time. Is there any way to recalculate the random number for each class?</p>
<pre><code>class a:
    exampleData = random.randint(1,100)

b = type('b', a.__bases__, dict(a.__dict__))

class c(a):
    pass
</code></pre>
<p>For example if a.exampleData = 50, b.exampleData and c.exampleData would be the same. Is there any way around this?</p>
<p>Edit --  Part of my program displays characters with random stats each time, and the class contains the stats associated with each character. The random numbers pick the stats out of a list, but the same stats are being chosen, instead of being random in each class. I may not be explaining this right, so basically:</p>
<pre><code>data = [stat1,stat2,stat3,ect,,]
data[random.randint(1,3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While <a href="https://stackoverflow.com/a/51181508/908494">my other answer</a> covers the question as asked, I suspect it's all completely unnecessary to the OP's actual problem.</p>
<p>If you just want to create a bunch of separate objects, which each have a separate value for <code>exampleData</code>, you just want a bunch of instances of a single class, not a bunch of separate classes.</p>
<p>A class is a special kind of object that, in addition to doing all the normal object stuff, also works as a factory for other objects, which are instances of that class. You don't need <code>a</code>, <code>b</code>, and <code>c</code> to all be factories for for different kinds of objects, you just need them to be different objects of the same type. So:</p>
<pre><code>class RandomThing:
    def __init__(self):
        self.exampleData = random.randint(1,100)

a = RandomThing()
b = RandomThing() 
</code></pre>
<p>… or, if you want to make sure <code>b</code> is the same type of thing as <code>a</code> but don't know what type that is:</p>
<pre><code>b = type(a)()
</code></pre>
<p>That's as fancy as you need to get here.</p>
<p>See <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">the official tutorial on Classes</a> (or maybe search for a friendlier tutorial, because there are probably better ones out there).</p>
</div>
<div class="post-text" itemprop="text">
<p>When you write this:</p>
<pre><code>b = type('b', a.__bases__, dict(a.__dict__))
</code></pre>
<p>… you're just copying  <code>a.__dict__</code>. Since <code>a.__dict__</code> is just <code>{'exampleData': 50}</code>, the new copy that ends up as <code>b.__dict__</code> is also going to be <code>{'exampleData': 50}</code>.</p>
<p>There are many ways you could get a new random number. The simplest is to just create a new random number for <code>b</code> explicitly:</p>
<pre><code>bdict = dict(a.__dict__)
b['exampleData'] = random.randint(1,100)
b = type('b', a.__bases__, bdict)
</code></pre>
<hr/>
<p>If you want to create a bunch of classes this way, you can wrap that up in a function:</p>
<pre><code>def make_clone(proto, name):
    clonedict = dict(proto.__dict__)
    clonedict['exampleData'] = random.randint(1,100)
    return type(name, proto.__bases__, clonedict)
</code></pre>
<p>You can make that factory function more complicated if you want to be (see <a href="https://github.com/python/cpython/blob/3.7/Lib/collections/__init__.py#L310" rel="nofollow noreferrer"><code>namedtuple</code></a> for a pretty extreme example).</p>
<hr/>
<p>You could wrap that behavior up in a decorator:</p>
<pre><code>def randomize(cls):
    cls.exampleData = random.randint(1,100)

@randomize
class a:
    pass

b = randomize(type('b', a.__bases__, dict(a.__dict__)))
</code></pre>
<p>Notice that I had to call the decorator with normal function-call syntax here, because there's no declaration statement to attach an <code>@decorator</code> to.</p>
<hr/>
<p>Or you can wrap it up in a metaclass:</p>
<pre><code>class RandomMeta(type):
    def __new__(mcls, name, bases, namespace):
        d = dict(namespace)
        d['exampleData'] = random.randint(1,100)
        return type.__new__(mcls, name, bases, d)

class a(metaclass=RandomMeta):
    pass

b = type(a)('b', a.__bases__, dict(a.__dict__))
</code></pre>
<p>Notice that we have to call <code>type(a)</code> here, the same way a <code>class</code> definition statement does, not the base metaclass <code>type</code>.</p>
<p>Also notice that I'm not taking <code>**kwds</code> in the <code>__new__</code> method, and I'm calling <code>type.__new__</code> directly. This means that if you try to use <code>RandomMeta</code> together with another metaclass (besides <code>type</code>), you should get an immediate <code>TypeError</code>, rather than something that may or may not be correct.</p>
<hr/>
<p>Meanwhile, I have a suspicion that what you're really trying to do here is build a prototype-based inheritance system, a la Self or JavaScript on top of Python's class-based system. While you <em>can</em> do that by using a special <code>Prototype</code> metaclass and a bunch of class objects, it's a whole lot simpler to just have a <code>Prototype</code> class and a bunch of instance objects. The only advantage to the metaclass approach is that you can use <code>class</code> statements (misleadingly, but conveniently) to clone prototypes, and you're explicitly not doing that here.</p>
</div>
<span class="comment-copy">A custom metaclass would solve the specific issue you're asking about, but if you can elaborate on the <i>purpose</i> of this sort of thing, there may be an easier/more intuitive way.</span>
<span class="comment-copy">After your edit, i don't understand why you need separate classes rather than just separate instances of a single class here.</span>
<span class="comment-copy">Are you trying to reproduce Self/JavaScript/etc.-style prototype inheritance, by any chance? If so, I can probably find you some links to cleaner ways to do that (although of course the cleanest way is usually to not do it, and use what your language supports instead of fighting it).</span>
<span class="comment-copy">@abarnert I have a feeling instances would solve the problem, though I haven’t encountered them before so I was trying to work around using them, if they solve the problem I’ll research them, though</span>
<span class="comment-copy">@zeroraptor Instances are the whole <i>point</i> of classes. If you haven't learned how to create and use instances of classes, you shouldn't be messing with things like directly calling metaclasses. Go work through a basic tutorial before reading the advanced reference docs.</span>
