<div class="post-text" itemprop="text">
<p>I want to create a child class from a parent class. This is to reduce redundancy in code. For instance,</p>
<pre><code>class Parent():
   def __init__(self, a, b, c, d, e, f, g):
       self.a = a
       self.b = b
       ...
       self.g = g

class Child1(Parent):
   def __init__(self, a, b, c, d, e, f, g, h, i, j, k):
          super().__init__(a, b, c d, e, f, g)
          self.i = i
          self.j = j
          self.k = k

class Child2(Parent):
   def __init__(self, a, b, c, d, e, f, g, h, x, y, z):
          super().__init__(a, b, c d, e, f, g)
          self.x = x
          self.y = y
          self.z = z
</code></pre>
<p>I don't want to pass parameters again and again for all child classes. Is there a way I could make Child1 and Child2 from Parent class?</p>
<p>I have 30+ parameters and many child classes. It seems very redundant to write out all parameters. Plus, they all share the same parameters as parents.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're looking to do here has nothing to do with instantiation. That word means to create an instance of a class. You can't "instantiate a child class from parent class", because a class object is not (except in very unusual circumstances) an instance of its base class.</p>
<p>What you're trying to do is to eliminate some boilerplate.</p>
<p>Python is very flexible—instances can define attributes wherever they want, classes can have any signature they want for methods like <code>__init__</code> and <code>__repr__</code>, etc. This is very powerful, but it also means that when you have a very repetitive class hierarchy, you have to repeat yourself a lot. But—because Python is very flexible—you can write tools to generate all that repetitive stuff for you, or you can just use tools that come with the language, like <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>@dataclass</code></a>:<sup>1</sup></p>
<pre><code>from dataclasses import dataclass

@dataclass
class Parent:
    a: int
    b: int
    c: int
    d: int
    e: int
    f: int
    g: int
    h: int

@dataclass
class Child1(Parent):
    i: int
    j: int
    k: int

@dataclass
class Child2(Parent):
    x: int
    y: int
    z: int
</code></pre>
<p>That's all it takes to define your classes, including automatically generating <code>__init__</code> methods that can handle both positional and keyword arguments and forward the right things to base classes, and <code>__repr__</code> methods that display things in some useful way, and static type hints that Mypy can check for you, and so on, without any repetition:</p>
<pre><code>&gt;&gt;&gt; c1 = Child1(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
&gt;&gt;&gt; c1
Child1(a=1, b=2, c=3, d=4, e=5, f=6, g=7, h=8, i=9, j=10, k=11)
&gt;&gt;&gt; c1b = Child1(1, 2, 3, 4, 5, 6, 7, k=11, j=10, h=8, i=9)
&gt;&gt;&gt; c1 == c1b
True
&gt;&gt;&gt; c2 = Child2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
&gt;&gt;&gt; c1 == c2
False
</code></pre>
<p>If you read the docs, you'll see that there's a lot more flexibility there (and even more in <code>attrs</code>), but the defaults give you what you want 80% of the time.</p>
<hr/>
<p><sub> <code>@dataclass</code> was added in Python 3.7. There's <a href="https://pypi.org/project/dataclasses/" rel="nofollow noreferrer">a backport for 3.6</a> that you can install with just <code>pip install dataclasses</code>, but if you need to work with 3.5 or 2.7, you'll need a third-party library like <a href="https://pypi.org/project/attrs/" rel="nofollow noreferrer"><code>attrs</code></a> instead. Also look at <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> for very simple cases, which works all the way back to 2.6 and 3.1.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass all parameters to the subclass's <code>__init__</code> as a list, pass as many as necessary to the superclass, and use the rest in the subclass itself:</p>
<pre><code>class Parent():
    def __init__(self,a,b,c):
        print(a,b,c)

class Child1(Parent):
    def __init__(self, *args):
        super().__init__(*args[:3]) # 3 for the parent
        self.x, self.y = args[3:] # 2 for myself
        print(self.x, self.y)

Child1(1,2,3,4,5)
#1 2 3
#4 5
#&lt;__main__.Child1 object at 0x7f5d70c3c9e8&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not clear from your example whether inheritance is appropriate here. Does the child satisfy the <a href="https://en.wikipedia.org/wiki/Is-a" rel="nofollow noreferrer"><em>is a</em></a> relationship, i.e., is the child really a subclass of the parent? If it does not then you should consider using <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="nofollow noreferrer">composition</a> rather than inheritance.</p>
<p>I suggest composition because you mention, in a comment, <em>instantiating</em> the parent class and using that <em>instance</em> in the "child" classes. So you could create an instance of the parent and pass it to <code>__init__()</code> of the "child" classes, thereby using composition.</p>
<pre><code>class Parent():
   def __init__(self, a, b, c, d, e, f, g):
       self.a = a
       self.b = b
       ...
       self.g = g

class Child1:
    def __init__(self, parent, h, i, j, k):
        self.parent = parent
        self.h = h
        self.i = i
        self.j = j
        self.k = k
</code></pre>
<p>Within the child classes you would access parent attributes via <code>self.parent.a</code> for example.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/6381590/simple-python-inheritance">Simple python inheritance</a></span>
<span class="comment-copy">You must specify the parent class when defining a child class: <code>Child1(Parent)</code>.</span>
<span class="comment-copy">@DyZ ah yes that was a typo</span>
<span class="comment-copy">If you have 30+ parameters, there must be something wrong with your code design. Have you considered passing a dictionary?</span>
<span class="comment-copy">Well it's bunch of hyperparameters I need to tune for deep learning stuff...</span>
<span class="comment-copy">i prefer not using *args for project specific reasons. It seems there is no way to instantiate a child from parent in python</span>
<span class="comment-copy">@MoneyBall Is what you’re asking “How do I do the same thing as <code>*args</code> without using <code>*args</code>? If so, that’s not possible, but similar things are. For example, if you want a function that takes a fixed number of ages, but that fixed number is specified by a variable at function creation time, you can write a function that creates the function.</span>
