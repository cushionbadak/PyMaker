<div class="post-text" itemprop="text">
<p>I want to get only <code>['bar']</code> here:</p>
<pre><code>&gt;&gt;&gt; re.findall(r"(?&lt;!\bdef )([a-zA-Z0-9.]+?)\(", "def foo(): bar()")
['oo', 'bar']
</code></pre>
<p>Is that possible in a single regex? If not, i'll use this first: <code>re.sub(r"\bdef [a-zA-Z0-9.]+", "", "def foo(): bar()")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The current regex matches <code>oo</code> in <code>foo</code> because <code>oo(</code> is not preceded with <code>"def "</code>.</p>
<p>To stop the pattern from matching inside a word, you may use a a word boundary, <code>\b</code> and the fix might look like <a href="https://regex101.com/r/Tu4qjJ/1" rel="nofollow noreferrer"><code>r"\b(?&lt;!\bdef )([a-zA-Z0-9.]+?)\("</code></a>.</p>
<p>Note that identifiers can be matched with <code>[a-zA-Z_][a-zA-Z0-9_]</code>, so your pattern can be enhanced like</p>
<pre><code>re.findall(r'\b(?&lt;!\bdef\s)([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)\(', s, re.A)
</code></pre>
<p>Note that <a href="https://docs.python.org/3/library/re.html#re.A" rel="nofollow noreferrer"><code>re.A</code> or <code>re.ASCII</code></a> will make <code>\w</code> match ASCII only letters, digits and <code>_</code>.</p>
<p>See the <a href="https://regex101.com/r/rMkcXs/2" rel="nofollow noreferrer">regex demo</a>.</p>
<p><strong>Details</strong></p>
<ul>
<li><code>\b</code> - a word boundary</li>
<li><code>(?&lt;!\bdef\s)</code> - no <code>def</code> + space allowed immediately to the left of the current location</li>
<li><code>([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)</code> - Capturing group 1 (its value will be the result of <code>re.findall</code> call): 

<ul>
<li><code>[a-zA-Z_]</code> - an ASCII letter or <code>_</code></li>
<li><code>\w*</code> - 1+ word chars</li>
<li><code>(?:</code> - start of a non-capturing group matching a sequence of... 

<ul>
<li><code>\.</code> - a dot</li>
<li><code>[a-zA-Z_]</code> - an ASCII letter or <code>_</code></li>
<li><code>\w*</code> - 1+ word chars</li>
</ul></li>
</ul></li>
<li><code>)*</code> - ... zero or more times</li>
<li><code>\(</code> - a <code>(</code> char.</li>
</ul>
</div>
<span class="comment-copy">Use <a href="https://regex101.com/r/pgW4RC/2" rel="nofollow noreferrer"><code>\b(?&lt;!\bdef )([a-zA-Z_][\w.]*)\(</code></a>. A word boundary will make matching inside a word impossible.</span>
<span class="comment-copy">Add a <code>\b</code> after the lookbehind.</span>
<span class="comment-copy">@Aran-Fey It is better if <code>\b</code> is placed before the lookbehind so that it is executed only after word boundary positions.</span>
