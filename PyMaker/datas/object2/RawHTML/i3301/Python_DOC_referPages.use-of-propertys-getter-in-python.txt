<div class="post-text" itemprop="text">
<p>i was looking into properties and could not understand the use of getter.</p>
<p>Code :</p>
<pre><code>class A:
    def __init__(self,p):
        self._p = p
    @property
    def p(self):
        return self._p
    @p.setter
    def p(self, value):
        self._p = value
    @p.getter
    def p(self):
        return self._p
</code></pre>
<p>so,i did the following</p>
<pre><code>obj = A(10)
print(obj.p)
</code></pre>
<p>i got the following output:</p>
<blockquote>
<p>10</p>
</blockquote>
<p>So, i thought, @p.getter is called and the value of _q is returned.</p>
<p>But, i tried without @p.getter as below</p>
<pre><code>class A:
    def __init__(self,p):
        self._p = p
    @property
    def p(self):
        return self._p
    @p.setter
    def p(self, value):
        self._p = value
</code></pre>
<p>And did the following</p>
<pre><code>obj = A(10)
print(obj.p)
</code></pre>
<p>and even then i got the following output:</p>
<blockquote>
<p>10</p>
</blockquote>
<p>So, i was wondering, what is the actual use of @p.getter here, when @property it self was able to give us the value of _q</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>@property</code> decorator on a function creates a new <code>property</code> object and sets the decorated function as the getter. So within <em>the same class</em>, the <code>@p.getter</code> decorator is not very useful, no.</p>
<p>However, the decorator is <em>very</em> useful if you wanted to override the getter in a subclass, or a reuse just the setter of the property on, but on a different class altogether:</p>
<pre><code>class Foo(object):
    @property
    def p(self):
        return self._p

    @p.setter
    def p(self, value):
        self._p = value

class Bar(Foo):
    @Foo.p.getter
    def p(self):
        return self._p + 10
</code></pre>
<p>or by copying the property object across to a different class:</p>
<pre><code>class NotASubclass(object):
    @Foo.p.getter
    def p(self):
        return self._p * 10
</code></pre>
<p>Now <code>Bar()</code>and <code>NotASubclass</code> have a different getter for their property <code>p</code>, but both reuse the setter defined on the property for <code>Foo()</code>.</p>
<p>In both cases the <code>@p.getter</code> decorator creates a new <code>property</code> instance to store as an attribute of the class object, but their <code>fset</code> attributes all point to the same, single function object that acts as the setter.  This is why it is enough to just reference <code>@Foo.p.getter</code> in either case; you only need the single <code>property</code> instance in the class namespace.</p>
<p>Also see <a href="https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work">How does the @property decorator work?</a> and <a href="https://stackoverflow.com/questions/15785982/python-overriding-getter-without-setter">Python overriding getter without setter</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>@property.getter</code> decorator can be useful if you want to override a getter from a parent class in a subclass. It allows you to easily "copy" a property from the parent class and override only the getter, keeping the setter and deleter intact.</p>
<p>Example:</p>
<pre><code>class Parent:
    @property
    def p(self):
        return 'parent'

    @p.setter
    def p(self, value):
        print('setting p to', value)

    @p.deleter
    def p(self):
        print('deleting p')

class Child(Parent):
    @Parent.p.getter
    def p(self):
        return 'child'

print(Parent().p)  # output: parent
print(Child().p)   # output: child
Child().p = 3      # output: setting p to 3
del Child().p      # output: deleting p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you've noticed, in this case, it's totally useless since you already passed the getter here </p>
<pre><code>@property
def p(self):
    return self._p
</code></pre>
<p>but it might be useful for a couple corner cases at least, like dynamically redefining the getter for an existing property. I have to say I never had such a use case actually but well... </p>
</div>
<span class="comment-copy">Closely related: <a href="//stackoverflow.com/q/15785982">Python overriding getter without setter</a>.</span>
<span class="comment-copy">Thanks, second  example is great</span>
<span class="comment-copy">property by default return themselves because in the actual implementation <code>def __get__(self, obj, objtype=None):         if obj is None:             return self         if self.fget is None:             raise AttributeError("unreadable attribute")         return self.fget(obj)</code> , if the getter is not defined, it return's itself.Because of that i was able to get the value of _p Am i right?</span>
<span class="comment-copy">@InAFlash: no, if the getter is not defined, an <code>AttributeError</code> exception is raised. <code>obj</code> is the instance to which to bind, if that's <code>None</code> the access was on the class. So <code>ClassObj.property_name</code> gives you the property object itself (because the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a> then calls <code>ClassObj.__dict__['property_name'].__get__(None, ClassObj)</code>), and <code>instance.property_name</code> gives you the result of the getter function (because then  <code>ClassObj.__dict__['property_name'].__get__(instance, ClassObj)</code>)` is called).</span>
<span class="comment-copy">Exactly what i needed . thanks</span>
<span class="comment-copy">so, p.getter is not used often? is that what you are saying?</span>
<span class="comment-copy">@InAFlash cf Aran-Fey's answer which is much better than mine</span>
