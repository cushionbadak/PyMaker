<div class="post-text" itemprop="text">
<pre><code>tools = {"Wooden_Sword1" : 10, "Bronze_Helmet1 : 20}
</code></pre>
<p>I have code written to add items, i'm adding an item like so:</p>
<pre><code>tools[key_to_find] = int(b)
</code></pre>
<p>the <code>key_to_find</code> is the tool and the <code>b</code> is the durability and i need to find a way so if i'm adding and <code>Wooden_Sword1</code> already exists it adds a <code>Wooden_Sword2</code> instead. This has to work with other items as well</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/users/3483203/user3483203">user3483203</a> and <a href="https://stackoverflow.com/users/364696/shadowranger">ShadowRanger</a> commented, it's probably a bad idea to use numbers in your key string as part of the data. Manipulating those numbers will be awkward, and there are better alternatives. For instance, rather than storing a single value for each numbered key, use simple keys and store a list. The index into the list will take the place of the number in the key.</p>
<p>Here's how you could implement it:</p>
<pre><code>tools = {"Wooden_Sword" : [10], "Bronze_Helmet" : [20]}
</code></pre>
<p>Add a new wooden sword with durability 10:</p>
<pre><code>tools.setdefault("Wooden_Sword", []).append(10)
</code></pre>
<p>Find how many bronze helmets we have:</p>
<pre><code>helmets = tools.get("Bronze_Helmet", [])
print("we have {} helmets".format(len(helmets)))
</code></pre>
<p>Find the first bronze helmet with a non-zero durability, and reduce it by 1:</p>
<pre><code>helmets = tools.get("Bronze_Helmet", [])
for i, durability in helmets:
    if durability &gt; 0:
         helmets[i] -= 1
         break
else: # this runs if the break statement was never reached and the loop ran to completion
    take_extra_damage() # or whatever
</code></pre>
<p>You could simplify some of this code by using a <code>collections.defaultdict</code> instead of a regular dictionary, but if you learn how to use <code>get</code> and <code>setdefault</code> it's not too hard to get by with the regular <code>dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To ensure a key name is not taken yet, and add a number if it is, create the new name and test. Then increment the number if it is already in your list. Just repeat until none is found.</p>
<p>In code:</p>
<pre><code>def next_name(basename, lookup):
    if basename not in lookup:
        return basename
    number = 1
    while basename+str(number) in lookup:
        number += 1
    return basename+str(number)
</code></pre>
<p>While this code does what you ask, you may want to look at other methods. A possible drawback is that there is no <em>association</em> between, say, <code>WoodenShoe1</code> and <code>WoodenShoe55</code> â€“ if 'all wooden shoes' need their price increased, you'd have to iterate over all <em>possible</em> names between <code>1</code> and <code>55</code>, just in case these existed at some time.</p>
</div>
<div class="post-text" itemprop="text">
<p>From what I understand of the question, your keys have 2 parts: "Name" and "ID". The ID is just an integer that starts at 1, so you can initialize a counter for every name:</p>
<pre><code>numOfWoodenSwords = 0
</code></pre>
<p>And to add to the array:</p>
<pre><code>numOfWoodenSwords += 1
tools["wodden_sword" + str(numOfWoodenSwords)] = int(b)
</code></pre>
<p>If you need to have an unknown amount of tools, I recommend looking at the re module: <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html</a>.</p>
<p>Or you could iterate over <code>tools.keys</code> to see if the entry exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could write a function that determines if a character is a letter:</p>
<pre><code>def is_letter(char):
    return 65 &lt;= ord(char) &lt;= 90 or 97 &lt;= ord(char) &lt;= 122
</code></pre>
<p>Then when you are looking at a key in your dictionary, simply:</p>
<pre><code>if is_letter(key[-1]):
    ...
</code></pre>
</div>
<span class="comment-copy">To make this easier to extend (and create in the first place), why not have a single <code>Wooden_Sword</code> key, then have a list of tuples with <code>(id, durability)</code> as the values.  You could very quickly have a large number of very similar keys that are hard to keep track of.</span>
<span class="comment-copy">@user3483203: Or just skip the <code>id</code>; the position of the <code>durability</code> in the <code>list</code> is its ID. New unique IDs are generated with a simple <code>append</code> to the <code>list</code>.</span>
<span class="comment-copy">Yep that too, pretty much anything to avoid keys <code>Wooden_Sword1-Wooden_Sword9999</code> :P</span>
<span class="comment-copy">any reason I haven't seen anyone mention that dictionary.keys() returns a list of the keys in a dictionary?</span>
<span class="comment-copy">@tgikal: It's almost never necessary to use <code>keys()</code>. The dictionary is iterable, yielding its keys directly (and the <code>in</code> operator checks for keys in the dictionary as well). You're also not quite right that <code>keys</code> returns a list (that used to be true in Python 2, but is not any more). These days it returns a dictionary view object, which has some of the <code>set</code> API but doesn't need to copy any data (it just looks it up in the dictionary object).</span>
