<div class="post-text" itemprop="text">
<p>I'm very new to Python and I'm trying to put together a small program which does seem to work, however I get the below error every so often when running the code.</p>
<p>The end goal is slightly more complex than the current code, however the idea is the program reads from 2 separate CSV files, picks a random row from each, then concatenates specific values from those rows and prints the result. </p>
<p><strong>Error Seen:</strong></p>
<pre><code>    Traceback (most recent call last):
  File ".\SimulationScript.py", line 57, in &lt;module&gt;
    counter(10)
  File ".\SimulationScript.py", line 45, in counter
    indicatorDefinition(indicator_file)
  File ".\SimulationScript.py", line 17, in indicatorDefinition
    chosen_row = next(row for row_number, row in enumerate(reader)
StopIteration
</code></pre>
<p><strong>Code:</strong></p>
<pre><code>from sys import argv
import random
import csv

script, file1, file2 = argv
f1 = ''
f2 = ''

def iDefinition(i):
    with open(i) as file:
        lines = sum(1 for line in file)
        line_number = random.randrange(lines)

    with open(i) as file:
        reader = csv.DictReader(file)
        chosen_row = next(row for row_number, row in enumerate(reader)
            if row_number == line_number)

        global f1
        f1 = chosen_row['field_1']+'":"'+chosen_row['value_1']+'"'

def nDefinition(n):
    with open(n) as file:
        lines = sum(1 for line in file)
        line_number = random.randrange(lines)

    with open(n) as file:
        reader = csv.DictReader(file)
        chosen_row = next(row for row_number, row in enumerate(reader)
            if row_number == line_number)

        global f2
        f2 = '"code":"'+chosen_row['Node code']+'","'



def counter():
    count = 0

    while count &lt; 6:
        nDefinition(file2)
        iDefinition(file1)
        print(f2+f1)

        count += 1

counter()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned - <code>StopIteration</code> gets raised when attempting to consume an element from an exhausted iterable.</p>
<pre><code>it = iter([1, 2])
next(it)
# 1
next(it)
# 2
next(it)
# raises StopIteration as nothing to return
# however you can use the default argument to return a default value when exhausted
# next(it, 'cabbage!')
# cabbage!
</code></pre>
<p>However, since you only want to be taking a random line from a file, instead of counting the lines and picking a line number, then scanning the file and extracting that line, you can use a <code>min</code> with a random key and do it in one pass, eg:</p>
<pre><code>import heapq, random

with open('your_file') as fin:
    random_line = min(fin, key=lambda L: random.random())
</code></pre>
<p>If you want to take more than 1, then you can use <code>heapq</code> as such:</p>
<pre><code>with open('your_file') as fin:
    random_50 = heapq.nlargest(50, fin, key=lambda L: random.random())
</code></pre>
<p>If the files aren't going to blow up system memory and you're going to be wanting to take a random line a lot, then you can load them into a <code>list</code> and then use <code>random.choice</code>, eg:</p>
<pre><code>with open('your_file') as fin:
    data = list(fin)

r1 = random.choice(data)
r2 = random.choice(data)
# ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>StopIterationError gets thrown by next when the iterable object is completely iterated over. This should not happen randomly but everytime you run the code after he the iteration ran through the whole iterable object. </p>
<p>Either you make a try/except block for it or you use a for loop instead of next. (The for loop in python automatically catches and "ignores" the stopiteration error after the loop is done).  </p>
<pre><code>    row for row_number, row in enumerate(reader):
        if row_number == line_number:
            chosen_row = row
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As taken from <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">https://docs.python.org/3/glossary.html#term-iterator</a>:</p>
<blockquote>
<p>When no more data are available a StopIteration exception is raised instead. At this point, the iterator object is exhausted and any further calls to its <code>__next__()</code> method just raise StopIteration again.</p>
</blockquote>
<p><code>enumerate()</code> returns an Iterator object, so the above mentioned is the case. Presumably your script has reached the last row in the CSV and your call to <code>next()</code>  requires the Iterator to return another one (which is, of course, not possible).</p>
<p>As this exception is expected, you may want to surround the expression in a try-except block, catch the StopIteration exception and then continue with execution of your method.</p>
<p>Another option would be to use a for-loop, which simply stops after the last element is iterated over. <code>next()</code> calls are usually only used when you need to control when the next element is to be fetched but not if you want to iterate over everything in one go.</p>
</div>
<span class="comment-copy">When you selected the random line number may be it got last line. and then chosen_row = next(), there is no next.</span>
<span class="comment-copy">How large are those files and how often do you want to take one line from 'em?</span>
<span class="comment-copy">I've altered my code to use the heapq method :) I need to look into that method to understand it fully, not entirely sure what all the arguments relate too.</span>
<span class="comment-copy">@RTSecurity the <code>heapq</code> documentation explains it fairly well... I tend to think of it as a fixed size list where once it's full, if the element to be added has a larger key than any of the existing elements, the lowest keyed element gets moved out and the new element gets moved in...</span>
<span class="comment-copy">@RTSecurity I've updated the post to use <code>min</code> for where you only want a single line - it'll be more efficient than a <code>heapq</code>... Use the later where you want more than one.</span>
<span class="comment-copy">I don't suppose you could help explain the arguments used? 1 is the iteration? fin is the list/file being read, however I'm not understanding the key or the L: ?</span>
<span class="comment-copy">@RTSecurity <code>1</code> is the number of items to have at most (I've changed the heapq example to be 50), <code>fin</code> is the iterable (it could be anything - in this case a file object) and <code>key</code> describes how to compare the elements... So in this case, we say the key is a random number for each line, and then it takes the largest 50 keys seen... In the case of <code>min</code>: <code>fin</code> is the same, and each line gets a random number, and <code>min</code> returns the line which had the <i>lowest</i> random number.</span>
