<div class="post-text" itemprop="text">
<p>I have the following DataFrame:</p>
<pre><code>item    response
1       A       
1       A       
1       B       
2       A       
2       A   
</code></pre>
<p>I want to add a column with the most given response for an item. which should result in:</p>
<pre><code>item    response  mostGivenResponse
1       A          A
1       A          A      
1       B          A       
2       C          C
2       C          C
</code></pre>
<p>I tried something like this: </p>
<pre><code>df["responseCount"] = df.groupby(["ItemCode", "Response"])["Response"].transform("count")

df["mostGivenResponse"] = df.groupby(['ItemCode'])['responseCount'].transform(max)
</code></pre>
<p>But mostGivenResponse is now the count of the response in stead of the response itself. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.value_counts.html" rel="nofollow noreferrer"><code>value_counts</code></a> and return first index value:</p>
<pre><code>df["responseCount"] = (df.groupby("item")["response"]
                        .transform(lambda x: x.value_counts().index[0]))

print (df)
   item response responseCount
0     1        A             A
1     1        A             A
2     1        B             A
3     2        C             C
4     2        C             C
</code></pre>
<p>Or <a href="https://docs.python.org/3.6/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>collections.Counter.most_common</code></a>:</p>
<pre><code>from collections import Counter

df["responseCount"] = (df.groupby("item")["response"]
                         .transform(lambda x: Counter(x).most_common(1)[0][0]))

print (df)
   item response responseCount
0     1        A             A
1     1        A             A
2     1        B             A
3     2        C             C
4     2        C             C
</code></pre>
<p>EDIT:</p>
<p>Problem is with one or multiple <code>NaN</code>s only groups, solution is filter with <code>if-else</code>:</p>
<pre><code>print (df)
   item response
0     1        A
1     1        A
2     2      NaN
3     2      NaN
4     3      NaN

def f(x):
    s = x.value_counts()
    print (s)

    A    2
    Name: 1, dtype: int64
    Series([], Name: 2, dtype: int64)
    Series([], Name: 3, dtype: int64)

    #return np.nan if s.empty else s.index[0]
    return np.nan if len(s) == 0 else s.index[0]

df["responseCount"] = df.groupby("item")["response"].transform(f)
print (df)
   item response responseCount
0     1        A             A
1     1        A             A
2     2      NaN           NaN
3     2      NaN           NaN
4     3      NaN           NaN
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.Series.mode.html" rel="nofollow noreferrer"><code>pd.Series.mode</code></a>:</p>
<pre><code>df.groupby('item').response.transform(pd.Series.mode)
Out[28]: 
0    A
1    A
2    A
3    C
4    C
Name: response, dtype: object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/statistics.html#statistics.mode" rel="nofollow noreferrer"><code>statistics.mode</code></a> from standard library:</p>
<pre><code>from statistics import mode

df['mode'] = df.groupby('item')['response'].transform(mode)

print(df)

   item response mode
0     1        A    A
1     1        A    A
2     1        B    A
3     2        C    C
4     2        C    C
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/15222754/group-by-pandas-dataframe-and-select-most-common-string-factor">Group by pandas dataframe and select most common string factor</a></span>
<span class="comment-copy">Thanks! I tried df['mostGivenResponse'] = df.groupby('item').response.transform(pd.Series.mode) but then it says: ValueError: Length of passed values is 1, index implies 162 (sorry I started learning Python today)</span>
<span class="comment-copy">@MarcelHoekstra <code>df.groupby('item').response.transform(lambda x : x.mode().iloc[0])</code> you have multiple value have the same frequency  within in one group</span>
<span class="comment-copy">I get: IndexError: single positional indexer is out-of-bound</span>
<span class="comment-copy">@MarcelHoekstra working fine on my side</span>
<span class="comment-copy">probably to do with my whole dataset. Maybe null values of the response or something. The only suggested answer that works on my whole set is: .transform(lambda x: Counter(x).most_common(1)[0][0])) do you have any idea what can cause the error using your solution.</span>
