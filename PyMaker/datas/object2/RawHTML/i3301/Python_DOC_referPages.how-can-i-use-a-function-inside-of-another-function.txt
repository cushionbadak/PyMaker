<div class="post-text" itemprop="text">
<p>I am currently playing around with classes and functions since i am not familiar with python and i would like to know how i can get <code>addy(self, addx)</code> to call addx.</p>
<pre><code>class test:

    def __init__(self, x):
        self.x = x

    def addx(self):
        y = self.x + 10
        return y

    def addy(self, addx):
        z = addx() + 10
        return z

one = test(1)
print(one.addy())
</code></pre>
<blockquote>
<p>line 15, in  print(one.addy()) TypeError: addy() missing 1
  required positional argument: 'addx' Process finished with exit code 1</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You need to call <code>self</code> from within a class method.
<code>self.addx()</code></p>
<p>Also the <code>addx</code> parameter on this line shouldn't be there:
<code>def addy(self, addx):</code></p>
<p>I think this is what you are going for:</p>
<pre><code>class test:
  def __init__(self, x):
    self.x = x

  def addx(self):
    y = self.x + 10
    return y

  def addy(self):
    z = self.addx() + 10
    return z

one = test(1)
print(one.addy())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've overcomplicated things by wrapping it in a class. Take it out and it'll work (mostly) the way you expect.</p>
<pre><code>def add10(x):
    return x+10

def add20(x):
    return add10(add10(x))
</code></pre>
<p>Since you've wrapped it in the class you've complicated the namespace. It's no longer called <code>addx</code> or <code>addy</code>, so using those names throws a <code>NameError</code>. You have to use the qualified name instead.</p>
<pre><code>class FooBar():
    def __init__(self):
        self.x = 10

    def addx(self):
        return self.x + 10  # Note the `self.` before the attribute...

    def addy(self):
        return self.addx() + 10  # ...and also before the method name.
</code></pre>
<p>Methods are always passed their owning object as a first argument when called, which is why we've got <code>def addx(self):</code> but then call with <code>self.addx()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you are attempting to relate <code>addx</code> in the signature of <code>addy</code> to the method <code>addx</code>, you can pass the string name of the method and use <code>getattr</code>:</p>
<pre><code>class Test:
  def __init__(self, x):
    self.x = x
  def addx(self):
    y = self.x + 10
    return y
  def addy(self, func):
    z = getattr(self, func)() + 10
    return z

s = Test(3)
print(s.addy('addx'))
</code></pre>
</div>
<span class="comment-copy">What output would you expect? 21?</span>
<span class="comment-copy">Why does <code>addy</code> have a <code>addx</code> parameter but you're not passing any arguments to it when you call it?</span>
<span class="comment-copy">lol, thanks for the edit help.  And yeah, it's not clear whether OP just made a mistake in his original question.</span>
<span class="comment-copy">As is explicitly mentioned in <a href="https://docs.python.org/3/tutorial/classes.html#random-remarks" rel="nofollow noreferrer">the official Tutorial</a> - the last paragraphs of "9.4 Random Remarks": "Methods may call other methods by using method attributes of the <code>self</code> argument:..."</span>
