<div class="post-text" itemprop="text">
<p>I have two lists of dicts like this : </p>
<pre><code>list1 =[{doc:1,pos_ini:5,pos_fin:10},{doc:1,pos_ini:7,pos_fin:12},{doc:2,pos_ini:5,pos_fin:10},**{doc:7,pos_ini:5,pos_fin:10}**]

list2 =
[{doc:1,pos_ini:5,pos_fin:10},**{doc:1,pos_ini:6,pos_fin:7}**,{doc:1,pos_ini:7,pos_fin:12},{doc:2,pos_ini:5,pos_fin:10},**{doc:2,pos_ini:25,pos_fin:30}**]
</code></pre>
<p><code>list2</code> has two elements that <code>list1</code> does not have and <code>list1</code> has one element that <code>list2</code> does not have.</p>
<p>I need a <code>list_result</code> with all the elements merged : </p>
<pre><code>list_result =[{doc:1,pos_ini:5,pos_fin:10},**{doc:1,pos_ini:6,pos_fin:7}**,{doc:1,pos_ini:7,pos_fin:12},{doc:2,pos_ini:5,pos_fin:10},
**{doc:2,pos_ini:25,pos_fin:30}**,**{doc:7,pos_ini:5,pos_fin:10}**]
</code></pre>
<p>Whats the best way to do that in Python ? thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset()</code></a> to hash each dictionaries <code>items()</code> to a dictionary, then simply take the assigned values:</p>
<pre><code>list({frozenset(x.items()): x for x in list1 + list2}.values())
</code></pre>
<p>Or using <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> applied to a set comprehension:</p>
<pre><code>list(map(dict, {frozenset(x.items()) for x in list1 + list2}))
</code></pre>
<p>Or even using just a list comprehension:</p>
<pre><code>[dict(d) for d in {frozenset(x.items()) for x in list1 + list2}]
</code></pre>
<p>Which will give an <em>unordered</em> result:</p>
<pre><code>[{'doc': 1, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 1, 'pos_fin': 12, 'pos_ini': 7},
 {'doc': 2, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 7, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 1, 'pos_fin': 7, 'pos_ini': 6},
 {'doc': 2, 'pos_fin': 30, 'pos_ini': 25}]
</code></pre>
<p><strong>Note:</strong> If <em>order</em> is needed, you can use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict()</code></a> instead here:</p>
<pre><code>from collections import OrderedDict

list(OrderedDict((frozenset(x.items()), x) for x in list1 + list2).values())
</code></pre>
<p>Which gives this <em>ordered</em> result:</p>
<pre><code>[{'doc': 1, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 1, 'pos_fin': 12, 'pos_ini': 7},
 {'doc': 2, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 7, 'pos_fin': 10, 'pos_ini': 5},
 {'doc': 1, 'pos_fin': 7, 'pos_ini': 6},
 {'doc': 2, 'pos_fin': 30, 'pos_ini': 25}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python there is the builtin <code>set</code> collection that is perfect for this. The problem is that sets need <code>hashable</code> elements so you must convert the dict to a set of tuples:</p>
<pre><code>[dict(items) for items in set(tuple(sorted(d.items())) for d in (list1 + list2))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a set out of these values, instead of the dictionaries it would require to be converted into a hashable object like tuple:</p>
<pre><code>unique_list = set(tuple(dictionary.items())) for dictionary in list1 + list2)
</code></pre>
<p>and then can be converted back to dictionaries and list format again:</p>
<pre><code>l = []
for item in unique_list:
    l.append(dict(item))
</code></pre>
<p>Something like above should work.</p>
</div>
<span class="comment-copy">In 3.6.1: <code>TypeError: unhashable type: 'dict_items'</code></span>
<span class="comment-copy">@PauloScardine, thanks for pointing out. Fixed.</span>
