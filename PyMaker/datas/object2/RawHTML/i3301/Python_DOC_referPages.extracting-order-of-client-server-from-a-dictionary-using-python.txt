<div class="post-text" itemprop="text">
<p>I have a dictionary like below which for example, for the first item means 5 is the customer of 2. and in the last item, as you can see, 2 is the customer of 4 and  4 is also the customer of item 3.</p>
<pre><code>customer_provider_dic= {'2':['5'],'1':['2'],'3':['4'],'4':['2']}
</code></pre>
<p>I am trying to extract all chains of customer of these items. The output will be like this:</p>
<pre><code>[2,5]
[1,2,5]
[3,4,2,5]
[4,2,5]
</code></pre>
<p>I really confused how can I extracts these chains. Any suggestion for the flowchart or the steps I should follow. </p>
</div>
<div class="post-text" itemprop="text">
<p>First, here's a solution that works if all the lists contain exactly one item.</p>
<pre><code>def simple_chain(graph, key):
    chain = [key]
    while True:
        lst = graph.get(key)
        if lst is None:
            # There's nothing left to add to the chain
            break
        key = lst[0]
        if key in chain:
            # We've found a loop
            break
        chain.append(key)
    return chain

customer_provider = {
    '2': ['5'], '1': ['2'], '3': ['4'], '4': ['2'],
}

data = customer_provider
for k in data:
    print(simple_chain(data, k))
</code></pre>
<p><strong>output</strong></p>
<pre><code>['2', '5']
['1', '2', '5']
['3', '4', '2', '5']
['4', '2', '5']
</code></pre>
<hr/>
<p>The general solution is a little harder. We can create all the chains using a recursive generator. The code below works, but it's not very efficient, since it makes the same sub-chains multiple times.</p>
<p>The basic strategy is similar to the previous version, but we need to loop over all the keys in each list, and make a new chain for each one. </p>
<p>To fully understand how this code works you need to be familiar with <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" rel="nofollow noreferrer">recursion</a> and with Python <a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow noreferrer">generators</a>. You may also find this page helpful: <a href="https://stackoverflow.com/q/1756096/4014959">Understanding Generators in Python</a>; there are also various Python generators tutorials available online.</p>
<pre><code>def make_chains(graph, key, chain):
    ''' Generate all chains in graph that start at key.
        Stop a chain when graph[key] doesn't exist, or if
        a loop is encountered.
    '''
    lst = graph.get(key)
    if lst is None:
        yield chain
        return
    for k in lst:
        if k in chain:
            # End this chain here because there's a loop
            yield chain
        else:
            # Add k to the end of this chain and
            # recurse to continue the chain
            yield from make_chains(graph, k, chain + [k])

customer_provider = {
    '2': ['5'], '1': ['2'], '3': ['4'], '4': ['2'],
}

pm_data = {
    '2': ['5'], '1': ['2'], '3': ['4', '6'], 
    '4': ['2'], '6': ['1', '5'],
}

#data = customer_provider
data = pm_data

for k in data:
    for chain in make_chains(data, k, [k]):
        print(chain)
</code></pre>
<p>If we run that code with <code>data = customer_provider</code> it produces the same output as the previous version. Here's the output when run with <code>data = pm_data</code>.</p>
<pre><code>['2', '5']
['1', '2', '5']
['3', '4', '2', '5']
['3', '6', '1', '2', '5']
['3', '6', '5']
['4', '2', '5']
['6', '1', '2', '5']
['6', '5']
</code></pre>
<hr/>
<p>The <code>yield from</code> syntax is a Python 3 feature. To run this code on Python 2, change</p>
<pre><code>yield from make_chains(graph, k, chain + [k])
</code></pre>
<p>to</p>
<pre><code>for ch in make_chains(graph, k, chain + [k]):
    yield ch 
</code></pre>
<p>Prior to Python 3.6 <code>dict</code> does not retain the insertion order of keys, so <code>for k in data</code> can loop over the keys of <code>data</code> in any order. The output lists will still be correct, though. You may wish to replace that loop with</p>
<pre><code>for k in sorted(data):
</code></pre>
<p>to get the chains in order.</p>
</div>
<span class="comment-copy">Are you sure this is the correct output? Because <code>[2,5]</code> and <code>[3,4]</code> are clearly going from server to customer, but <code>[1,2,4,3]</code> is going the opposite direction, and <code>[4,2,1]</code> seems to be reversing direction in the middle. So, if that <i>is</i> the right output, you're going to have to explain what "chain" means here, because it's not obvious.</span>
<span class="comment-copy">Why do you have [1,2,4,3]  ??</span>
<span class="comment-copy">You need to implement topological sort to get what you are looking for.</span>
<span class="comment-copy">you are right. I will edit my question. thank you</span>
<span class="comment-copy">Why are the dict values lists? Will there ever be more than 1 item in those lists?</span>
<span class="comment-copy">thank you for your answer. the simple_chain function is fine, I tried to use make_chains function, I am getting this error yield from make_chains(graph, k, chain + [k])              ^ SyntaxError: invalid syntax</span>
<span class="comment-copy">@ShahroozPooryousef I guess you're still using Python 2, since <code>yield from</code> only works in Python 3. But it's very easy to adapt that code to Python 2, I'll update my answer in a few minutes.</span>
<span class="comment-copy">Thanks man, this is a huge improvement!</span>
