<div class="post-text" itemprop="text">
<p>Why isn't this error trap working well? I wanted to make it where if someone types a word or a number over 1, it error traps and repeats the question until you type in the correct corresponding input. Any suggestions??    </p>
<pre><code>valid = 0
    while valid ==0:
        x = input('Enter 4 digits for X(0 or 1): ')
        while len(x)!=4:
            print('Try Again. Remember 4 digits and only use binary 1 or 0')
            x = input('Enter 4 digits for X: ')
        valid = 1
        for i in x:
            if i !='1' and i !='0':
                print('Try Again. Remember 4 digits and only use binary 1 or 0')
                valid=0



    valid = 0
    while valid ==0:
        y = input('Enter 4 digits for Y(0 or 1): ')
        while len(y)!=4:
            print('Try Again. Remember 4 digits and only use binary 1 or 0')
            y = input('Enter 4 digits for y: ')
        valid = 1
        for i in y: 
            if i !='1' and i !='0':
                print('Try Again. Remember 4 digits and only use binary 1 or 0')
                valid=0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should test the length of the input with an <code>if</code> statement instead of a <code>while</code> loop. You can also use <code>all(map('01'.__contains__, value))</code> to test if a string consists of just either '0' or '1' characters. And you can make <code>x</code> and <code>y</code> a tuple of variable names and iterate through the same code to ask for their values with the same logic, and assign the value either as a global variable or as values of a dict.</p>
<pre><code>for variable in 'x', 'y':
    while True:
        value = input('Enter 4 digits for %s (0 or 1): ' % variable)
        if len(value) == 4 and all(map('01'.__contains__, value)):
            globals()[variable] = value
            break
        print('Try Again. Remember 4 digits and only use binary 1 or 0')
print(x, y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest putting your code in functions to help split things up into smaller pieces and use a regex to test to see if there are characters other than 1 or 0. Here is a suggestion based on the code you provided (The code here is for Python3+):</p>
<pre><code>import re

def check_input(input_str):
    # Regex for function, look for any single char not 1 or 0
    regex = r"[^10]"

    # Check if input is 4 bits
    if len(input_str) != 4:
        print('Sorry, input must only be 4 bits')
        return False

    # Check if characters are only 1 or 0
    if re.search(regex, input_str):
        print('Sorry, input must be composed of only 1s or 0s')
        return False

    return True

def get_binary_input():
    good_input = False
    input_str = ""
    while not good_input:
        input_str = input('Enter 4 digits for X(0 or 1): ')
        good_input = check_input(input_str)
    return input_str

def main():
    binary_str = get_binary_input()
    print('Got binary string: {}'.format(binary_str))
    return

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">what does the <b>contains</b>  special methods class to in this instance?? Just to fully understand it</span>
<span class="comment-copy"><code>'01'.__contains__('1')</code>, for example, is equivalent to <code>'1' in '01'</code>. <code>__contains__</code> tests if an item is a member of the object it's invoked from. In this case it tests if each character of <code>value</code> is either one of '0' or '1', when the string <code>value</code> is mapped as a sequence to the <code>__contains__</code> method of the sequence '01', since string in Python is a sequence type. You can read more about <code>__contains__</code> <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">thank you, thank you so much!! @blhsing</span>
<span class="comment-copy">Glad to be of help. Can you mark this answer as accepted if you think it's correct?</span>
<span class="comment-copy">Yes of course! Thanks again! I was reading on this in my text book. Glad to see it in use.</span>
