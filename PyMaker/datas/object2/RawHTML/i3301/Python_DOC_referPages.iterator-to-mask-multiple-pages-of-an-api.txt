<div class="post-text" itemprop="text">
<p>I am building an API client in python for some api which provides the following layout of data, when it comes in multiple pages:</p>
<pre><code>{
    "data":["some","pieces","of","data],
    "results_per_page=2500,
    "total_results": 10000
    "next_url": "http://fullyqualifiedurl.com/results_after=5000"
    "previous_url": "http://fullyqualifiedurl.com/results_after=2500
}
</code></pre>
<p>I want to have an iterator which a client can call like this: </p>
<pre><code>&gt;&gt;&gt; results = client.results()
&gt;&gt;&gt; result_count = 0
&gt;&gt;&gt; for result in results:
&gt;&gt;&gt;     result_count += 1
&gt;&gt;&gt; print(result_count)
10000
</code></pre>
<p>In which the iterator silently requests new page data as it reaches the end of its current page. </p>
<p>I have developed something which yields pages, but on subsequent calls, I want to not have to re-fetch the data. Here is what I have: </p>
<pre><code>Class Iterator:
    def __init__(self, current_page, max_results=None):
        self.current_page = current_page
        self.max_results = max_results
        self.yielded_count = 0

    def _iter_items(self):
        for page in self._iter_page():
            for item in page:
                # early break from page if we have set a limit.
                if self._limit_reached():
                    raise StopIteration
                self.yielded_count += 1
                yield item

    def _iter_page(self):
        while self.current_page is not None:
            yield self.current_page
            if self._has_next_page():
                self.current_page = self._get_next_page()
            else:
                self.current_page = None

    def __iter__(self):
        return self._iter_items()

    def __next__(self):
        return next(self._iter_items())

    def _iter_page(self):
        while self.current_page is not None:
            yield self.current_page
            if self._has_next_page():
                self.current_page = self._get_next_page()
            else:
                self.current_page = None

    def _get_next_page(self):
        if self.current_page.next_page_url:
            return self.api_request(self.current_page.next_page_url)
        else:
            return None

    def _keep_iterating(self):
        return (
            self.current_page is not None
            and self.max_results
            and self.yielded_count &gt;= self.max_results
    )

    def _limit_reached(self):
        return self.max_results and self.yielded_count &gt;= self.max_results

class Page:

    def __init__(self, json_data, *args, **kwargs):
        self.client = kwargs.get("client")
        self.next_page_url = json_data["pages"]["next_url"]
        self.previous_page_url = json_data["pages"]["previous_url"]
        self.total_count = json_data["total_count"]
        self._data_iterator = iter(datum for datum in json_data["data"])

    def __iter__(self):
        return self

    def __next__(self):
        item = next(self._data_iterator)
        return item
</code></pre>
<p>What's happening right now is i can successfully iterate over it once, but upon second iteration, the iterator is empty. I would like it to cache the results upon first search, and allow subsequent iterations. Am I going about this the entirely wrong way? I feel like there should be an established pattern for this, but can't really find anything.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure whether you're talking about the <code>Page</code> type or the <code>Iterator</code> type here, because they're both iterators, and both have the same issues, and you've only given us a vague description of what you're doing with whichever one you're doing it with. But all of the following will apply just as well to either of them (except for one note), so I'll talk about <code>Page</code>, because it's the simpler one.</p>
<hr/>
<p>An iterator can only be used once. That's inherent in what it means to be an iterator.</p>
<p>You <em>can</em> use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>tee</code></a> to split off a second iterator, which caches the values from the first one.</p>
<p>But if your goal is to iterate over the same values over and over, there's a much simpler solution: just copy the iterator into a sequence, like a <code>list</code> or <code>tuple</code> Then you can iterate that as many times as you want.</p>
<pre><code>page = list(Page(data, …))
for thing in page:
    print(thing)
for thing in page:
    print(thing)
</code></pre>
<hr/>
<p>While we're at it, your <code>Iterator</code> is not a valid iterator:</p>
<pre><code>def __iter__(self):
    return self._iter_items()

def __next__(self):
    return next(self._iter_items())
</code></pre>
<p>An iterator must return <code>self</code> from <code>__iter__</code>, the way your <code>Page</code> does. Python doesn't enforce that rule, so if you get this wrong, you often end up with something that seems to work in one test, but then does the wrong thing somewhere else.</p>
<hr/>
<p>Alternatively… are you sure you want <code>Page</code> to be an iterator, rather than a reusable, non-iterator iterable?</p>
<pre><code>class Page:

    def __init__(self, json_data, *args, **kwargs):
        self.client = kwargs.get("client")
        self.next_page_url = json_data["pages"]["next_url"]
        self.previous_page_url = json_data["pages"]["previous_url"]
        self.total_count = json_data["total_count"]

    def __iter__(self):
        return iter(datum for datum in json_data["data"])
</code></pre>
<p>Now, you don't need to copy the data into a <code>list</code> unless you want to do list-y things like indexing it in random order:</p>
<pre><code>page = Page(data, …)
for thing in page:
    print(thing)
for thing in page:
    print(thing)
</code></pre>
<hr/>
<p>As a side note, this is repetitive:</p>
<pre><code>iter(datum for datum in json_data["data"])
</code></pre>
<p>That <code>(datum for datum in json_data["data"])</code> is just the same things as <code>json_data["data"]</code>, wrapped in a generator expression. Since a generator expression is already an iterator, you can just return it:</p>
<pre><code>return (datum for datum in json_data["data"])
</code></pre>
<p>Or, even simpler, you can just return an iterator over the data:</p>
<pre><code>return iter(json_data["data"])
</code></pre>
<hr/>
<p>And if you actually want list-y sequence behavior, you can even make it a full-fledged <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer"><code>Sequence</code></a> pretty easily:</p>
<pre><code>class Page:

    def __init__(self, json_data, *args, **kwargs):
        self.client = kwargs.get("client")
        self.next_page_url = json_data["pages"]["next_url"]
        self.previous_page_url = json_data["pages"]["previous_url"]
        self.total_count = json_data["total_count"]

    def __len__(self):
        return len(json_data["data"])

    def __getitem__(self, index):
        return json_data["data"][index]
</code></pre>
<p>And now:</p>
<pre><code>page = Page(data, …)
for thing in page:
    print(thing)
for thing in reversed(page):
    print(thing)
for thing in page[-6:-2]:
    print(thing)
</code></pre>
</div>
<span class="comment-copy">Thanks fort all the information! Regarding the invalidity of an Iterator not returning <code>self</code> in <code>__iter__()</code>, I actually was following something I found in google's core API: <a href="https://github.com/GoogleCloudPlatform/google-cloud-python/blob/master/api_core/google/api_core/page_iterator.py#L216" rel="nofollow noreferrer">github.com/GoogleCloudPlatform/google-cloud-python/blob/master/…</a> . Is the invalidity due to the fact that I didn't check if has started? Or is what google has done here considered poor practice?</span>
<span class="comment-copy">@Tadgh That class doesn't have a <code>__next__</code> method, so it's not an iterator. Which makes the name <code>Iterator</code> pretty weird, and more than a little misleading, but it's not technically wrong.</span>
