<div class="post-text" itemprop="text">
<pre><code>import sys
def worker(a):
    try:
        return 1 / a
    except ZeroDivisionError:
        return None


def master():
    res = worker(0)
    if not res:
        print(sys.exc_info())
        raise sys.exc_info()[0]
</code></pre>
<p>As code piece above, I have a bunch of functions like worker. They already have their own try-except block to handle exceptions. And then one master function will call each worker. Right now, sys.exc_info() return all None to 3 elements, how to re-raise the exceptions in the master function? 
I am using Python 2.7</p>
<p>One update:
  I have more than 1000 workers and some worker has very complex logic, they may deal multiple types of exceptions at same time. So my question is can I just raise those exceptions from master rather than edit works?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're trying to do won't work. Once you handle an exception (without re-raising it), the exception, and the accompanying state, is cleared, so there's no way to access it. If you want the exception to stay alive, you have to either not handle it, or keep it alive manually.</p>
<p>This isn't that easy to find in the docs (the underlying implementation details about CPython are a bit easier, but ideally we want to know what Python the language defines), but it's there, buried in the <a href="https://docs.python.org/3/reference/compound_stmts.html#except" rel="nofollow noreferrer"><code>except</code></a> reference:</p>
<blockquote>
<p>… This means the exception must be assigned to a different name to be able to refer to it after the except clause. Exceptions are cleared because with the traceback attached to them, they form a reference cycle with the stack frame, keeping all locals in that frame alive until the next garbage collection occurs.</p>
<p>Before an except clause’s suite is executed, details about the exception are stored in the <code>sys</code> module and can be accessed via <code>sys.exc_info()</code>. <code>sys.exc_info()</code> returns a 3-tuple consisting of the exception class, the exception instance and a traceback object (see section The standard type hierarchy) identifying the point in the program where the exception occurred. <code>sys.exc_info()</code> values are restored to their previous values (before the call) when returning from a function that handled an exception.</p>
</blockquote>
<p>Also, this is really the point of exception handlers: when a function handles an exception, to the world outside that function, it looks like no exception happened. This is even more important in Python than in many other languages, because Python uses exceptions so promiscuously—every <code>for</code> loop, every <code>hasattr</code> call, etc. is raising and handling an exception, and you don't want to see them.</p>
<hr/>
<p>So, the simplest way to do this is to just change the workers to not handle the exceptions (or to log and then re-raise them, or whatever), and let exception handling work the way it's meant to.</p>
<p>There are a few cases where you can't do this. For example, if your actual code is running the workers in background threads, the caller won't see the exception. In that case, you need to pass it back manually. For a simple example, let's change the API of your worker functions to return a value and an exception:</p>
<pre><code>def worker(a):
    try:
        return 1 / a, None
    except ZeroDivisionError as e:
        return None, e

def master():
    res, e = worker(0)
    if e:
        print(e)
        raise e
</code></pre>
<p>Obviously you can extend this farther to return the whole <code>exc_info</code> triple, or whatever else you want; I'm just keeping this as simple as possible for the example.</p>
<p>If you look inside the covers of things like <code>concurrent.futures</code>, this is how they handle passing exceptions from tasks running on a thread or process pool back to the parent (e.g., when you wait on a <code>Future</code>).</p>
<hr/>
<p>If you can't modify the workers, you're basically out of luck. Sure, you could write some horrible code to patch the workers at runtime (by using <code>inspect</code> to get their source and then using <code>ast</code> to parse, transform, and re-compile it, or by diving right down into the bytecode), but this is almost never going to be a good idea for any kind of production code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not tested, but I suspect you could do something like this. Depending on the scope of the variable you'd have to change it, but I think you'll get the idea</p>
<pre><code>try:
    something
except Exception as e:
    variable_to_make_exception = e
</code></pre>
<p>.....later on use variable</p>
<p>an example of using this way of handling errors:</p>
<pre><code>errors = {}
try:
    print(foo)
except Exception as e:
    errors['foo'] = e
try:
    print(bar)
except Exception as e:
    errors['bar'] = e


print(errors)
raise errors['foo']
</code></pre>
<p>output..</p>
<pre><code>{'foo': NameError("name 'foo' is not defined",), 'bar': NameError("name 'bar' is not defined",)}
Traceback (most recent call last):
  File "&lt;input&gt;", line 13, in &lt;module&gt;
  File "&lt;input&gt;", line 3, in &lt;module&gt;
NameError: name 'foo' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your case, the exception in <code>worker</code> returns <code>None</code>. Once that happens, there's no getting the exception back. If your master function knows what the return values should be for each function (for example, <code>ZeroDivisionError</code> in <code>worker</code> reutrns <code>None</code>, you can manually reraise an exception.</p>
<p>If you're not able to edit the worker functions themselves, I don't think there's too much you can do. You might be able to use <a href="https://stackoverflow.com/questions/15605925/how-to-get-the-last-exception-object-after-an-error-is-raised-at-a-python-prompt">some of the solutions from this answer</a>, if they work in code as well as on the console.</p>
<p>krflol's code above is kind of like how C handled exceptions - there was a global variable that, whenever an exception happened, was assigned a number which could later be cross-referenced to figure out what the exception was. That is also a possible solution.</p>
<p>If you're willing to edit the worker functions, though, then escalating an exception to the code that called the function is actually really simple:</p>
<pre><code>try: 
    # some code
except:
    # some response
    raise
</code></pre>
<p>If you use a blank <code>raise</code> at the end of a <code>catch</code> block, it'll reraise the same exception it just caught. Alternatively, you can name the exception if you need to debug print, and do the same thing, or even raise a different exception.</p>
<pre><code>except Exception as e:
    # some code
    raise e
</code></pre>
</div>
<span class="comment-copy">I don't think this is a dup of that question. The OP here clearly knows how to use <code>raise</code>, and nothing in the answers to that question does anything to explain how to raise an exception that was already handled and dismissed.</span>
<span class="comment-copy">I know this one will work. But like I said, I have a bunch of works, which are more than 1000, and some worker may have very complex logic two deal with multiple exceptions. So, my question is, is there any way to control all stuff from master rather than edit works one by one?</span>
<span class="comment-copy">That's why I mentioned scope. You could even have a dictionary of {worker:exception} using the above method of assigning a variable to the actual exception that was raised.</span>
<span class="comment-copy">I've added an example to my answer</span>
