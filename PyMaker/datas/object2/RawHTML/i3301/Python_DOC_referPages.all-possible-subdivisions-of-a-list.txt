<div class="post-text" itemprop="text">
<p>I've just written a small recursive programme to generate all the possible subdivisions of a list:</p>
<pre><code>def subdivisions(ls):
    yield [ls]
    if len(ls) &gt; 1:
        for i in range(1, len(ls)):
            for lhs in subdivisions(ls[:i]):
                yield lhs + [ls[i:]]

&gt;&gt;&gt; for x in subdivisions('abcd'): print x
... 
['abcd']
['a', 'bcd']
['ab', 'cd']
['a', 'b', 'cd']
['abc', 'd']
['a', 'bc', 'd']
['ab', 'c', 'd']
['a', 'b', 'c', 'd']
</code></pre>
<p>I've brute forced this and it's taken me a long time to figure out.  I'm wondering what this is called, as I'm sure there is a name for it.</p>
<p>In general I'm wondering how to learn this stuff from a mathematical point of view and whether there are good well known programming libraries that cover useful algorithms like this (I know of <a href="https://docs.python.org/3/library/itertools.html" rel="noreferrer">https://docs.python.org/3/library/itertools.html</a> )</p>
<hr/>
<p>[Edit] the question that this is marked as duplicate of - <a href="https://stackoverflow.com/questions/33000320/get-all-possible-partitions-of-a-set">get all possible partitions of a set</a>
- gets a different answer.</p>
<p>It is looking for <code>{ {{1,2,3},{}} , {{1},{2,3}} , {{1,2},{3}} , {{1,3},{2}}, {{1},{2},{3}}}</code>
while a correct answer for me (in it's terminology) would be <code>{ {{1,2,3}} , {{1},{2,3}} , {{1,2},{3}} , {{1},{2},{3}}}</code></p>
<p>Also, the point of asking the question was to figure out what the terminology of this is; I'm calling it 'subdivisions'; that answer is calling it 'partitions'.  I'm looking for a good resource which enumerates all of these patterns, so that people don't go reinventing the wheel.</p>
</div>
<div class="post-text" itemprop="text">
<p>Finding all <a href="https://en.m.wikipedia.org/wiki/Partition_of_a_set" rel="nofollow noreferrer">partitions</a> of a list is equivalent to finding all sets of indices at which to slice the list.</p>
<p>By example, given the list <code>l = [1, 2, 3, 4]</code>, we can represent the partition <code>[[1, 2], [3], [4]]</code> by the list of indices <code>[2, 3]</code>. In particular, there is a one-to-one correspondence between such list of indices and partitions.</p>
<p>This means, given a list <code>l</code> we can find the <a href="https://en.m.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">powerset</a> of <code>range(1, len(l))</code> and find each corresponding partition.</p>
<h2>Code</h2>
<p>This solution uses the <code>powerset</code> function from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a>. Using generators is more efficient than using recursion.</p>
<pre><code>from itertools import chain, combinations

def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def partitions(lst):
    for indices in powerset(range(1, len(lst))):
        partition = []
        i = 0
        for j in indices:
            partition.append(lst[i:j])
            i = j
        partition.append(lst[i:])

        yield partition
</code></pre>
<h2>Example</h2>
<pre><code>print(*partitions([1, 2, 3]))
# [[1, 2, 3]] [[1], [2, 3]] [[1, 2], [3]] [[1], [2], [3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let me give some mathematical interpretation of this problem.</p>
<p>Imagine: you have list <code>abcd</code>. If you put some separators in it - like <code>a|bc|d</code> - you'll divide it into sublists. All the possible separators are <code>a|b|c|d</code> (their count is <code>N-1</code>, where <code>N</code> is a size of list). Let's call them (separators) <code>1</code>, <code>2</code>, <code>3</code>. </p>
<p>Then all the subdivisions of your list will be generated by all the <a href="https://en.wikipedia.org/wiki/Combination" rel="nofollow noreferrer">combinations</a> of set <code>{1, 2, 3}</code>. There will be <code>2**3 = 8</code> of them: each element can be in combination or not. (All these combinations are called <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">powerset</a>).</p>
<p>That can help you to list all the subdivisions without recursion: you just to iterate binary numbers from <code>0b000</code> to <code>0b111</code> inclusive (<code>range(0, 2**(N-1))</code>):</p>
<pre><code>from itertools import zip_longest, chain

def yield_possible_splits(string):
    N = len(string)
    for i in range(2 ** (N-1)):
        spaces_bitmask = bin(i).replace('0b', '').rjust(N, '0')
        spaces = [' ' if bit == '1' else '' for bit in spaces_bitmask]
        yield ''.join(chain(*zip_longest(spaces, string, fillvalue='')))
</code></pre>
<p>Or equivalent variant using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product</a> instead of binary manipulations:</p>
<pre><code>from itertools import zip_longest, chain, product

def yield_possible_splits(string):
    N = len(string)
    for spaces in product(['', ' '], repeat=N-1):
        yield ''.join(chain(*zip_longest(string, spaces, fillvalue='')))
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code>print(list(yield_possible_splits('abcd')))
# ['abcd', 'abc d', 'ab cd', 'ab c d', 'a bcd', 'a bc d', 'a b cd', 'a b c d']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My solution:</p>
<pre><code>from itertools import chain, product
def p(l):
    return {(l,)} | {tuple(chain(*s)) for i in range(1, len(l)) for s in product(p(l[:i]), p(l[i:]))}
</code></pre>
<p><code>p('abcd')</code> returns:</p>
<pre><code>{('a', 'bcd'), ('abcd',), ('abc', 'd'), ('ab', 'c', 'd'), ('ab', 'cd'), ('a', 'b', 'cd'), ('a', 'bc', 'd'), ('a', 'b', 'c', 'd')}
</code></pre>
</div>
<span class="comment-copy">permutation perhaps.</span>
<span class="comment-copy">This is different; there are 24 permutations of 'abcd' and they don't preserve order. Similarly combinations do something different as you get subsets of the list of a single size.</span>
<span class="comment-copy"><a href="https://en.wikipedia.org/wiki/Partition_of_a_set" rel="nofollow noreferrer">en.wikipedia.org/wiki/Partition_of_a_set</a></span>
<span class="comment-copy">@Prune I don't understand how is this Python question a duplicate of the Java question you proposed?</span>
<span class="comment-copy">@pylang: Thanks for the heads-up; I see the difference.  Question is reopened.</span>
<span class="comment-copy">Marking as the accepted answer because of the link to <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools-recipes</a> which is what I missed when looking up itertools to find an existing solution for this problem.</span>
<span class="comment-copy">I think it's <code>range(0b000, 0b1000)</code>? I'm missing the step about how to use the binary value of each separator to split the list!</span>
<span class="comment-copy">@EoghanM Yes, I meant "inclusive". Updated my answer.</span>
<span class="comment-copy">I prefer your second solution, but it gives me <code>['abcd', 'ab cd', 'a bcd', 'a b cd', ' abcd', ' ab cd', ' a bcd', ' a b cd']</code> (note the space before <code>a</code> and that there never is a space between <code>cd</code>). I think you need to swap the arguments to <code>zip_longest</code>. I think it is also clearer to use the <code>repeat</code> argument in <code>product</code>, as in <code>product(['', ' '], repeat=N-1)</code>.</span>
<span class="comment-copy">@BasSwinckels Thanks a lot! It was my typo when refactoring the code :( Concerning <code>repeat</code> - you are right, it looks much better now.</span>
<span class="comment-copy">Lovely concise solution - Python3 only right? Unfortunately doesn't work when a list is passed in: &gt;&gt;&gt; p(['a', 'b', 'c', 'd']) TypeError: unhashable type: 'list'</span>
<span class="comment-copy">Thanks. It works in Python 2.7 too. But you're right that passing a list to it wouldn't work because this solution relies on using set to eliminate duplicates, and a sequence needs to be hashable in order to be added to a set, which a list is not. You can always cast the list to a tuple before passing in though.</span>
<span class="comment-copy">Cool, generating duplicates and then discarding them seems less efficient than other solutions.</span>
