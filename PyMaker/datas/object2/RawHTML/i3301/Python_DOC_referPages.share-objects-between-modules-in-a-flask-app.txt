<div class="post-text" itemprop="text">
<p>I've laid out my stuff in a DDD sort of way. There are Repositories to hold my objects, Services to add external functionality, etc.  </p>
<p>However what's not clear is what's the best way to share these between controllers? In C#, I'd have a dependency injection framework, and a single instance for the server. Python, being duck typed, doesn't seem to have a need for much DI. However there's still the question of how to get shared objects, that will persist between requests.</p>
<p>So far I've been hanging them off my app object, but seems there should be a more elegant and standard way to do so.</p>
<p>I'm specifically asking about sharing objects that add behavior to the app and could be called upon in different places in the app, <em>not</em> about sharing or changing <em>data</em> between requests.</p>
</div>
<div class="post-text" itemprop="text">
<p>The common way seems to be</p>
<ul>
<li>initialise your objects in a single module</li>
<li>have all other modules import the same object from that module</li>
</ul>
<p>eg define <code>repositories.py</code></p>
<pre><code>customer_repository = CustomerRepository(options)
...
</code></pre>
<p>and in <code>service.py</code></p>
<pre><code>from repositories import customer_repository
customer_repository.find(id==5)
</code></pre>
<p>In general <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer">imports are cached</a>, so all the modules should import the same instance of the object. Regardless, since you're doing DDD, those objects should probably be stateless anyway.</p>
<p>You should never do this for shared <em>data</em> that will change, as <a href="https://stackoverflow.com/questions/32815451/are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests">global data is not thread safe in web applications</a>. If you want to share <em>data</em> between requests, use a database or other external data store.</p>
</div>
<span class="comment-copy">Do you have an example?</span>
<span class="comment-copy">@PaxVobiscum - it's a small job service, with typed endpoints for creation request for clarity.  Celery would be overkill here, and deployment of services such as it are non-trivial.  For job DoFoo, there's an endpoint called /foo that accepts POST, and a payload of a FooJobRequest.  It returns a JobStatus, with the ID of the job started.  There's also a /jobs/{id} endpoint, that on GET will return the current status of the job (waiting, started, failed, complete, etc).    For this to work, with an in-memory store, the same instance needs to be used by Foo to store the new job, and jobs</span>
<span class="comment-copy">Ahhhhh ok, that makes quite a bit of sense - for quick demo purposes I'm using an in-memory repository, and didn't want it recreated on each request.  Having it in the module would take care of that, as it's basically a Repository factory in that case.</span>
<span class="comment-copy">One clarification - would that be in the same file as the CustomerRepository definition, or in the module <b>init.py</b> file for the Repositories module if I'm holding it there?</span>
<span class="comment-copy">@Mathieson: not sure what you mean. The <i>instance</i> should be imported from the same module, so that it's guaranteed to be the same instance. Whether that instance is initialised in the same file as the class definition, or imports its class definition from another module, doesn't matter</span>
<span class="comment-copy">this is an odd case, as it doesn't use persistent data storage for the initial release.  It's a feature that might be added quickly.  One of the strengths of the repository pattern is to allow a very quick in-memory implementation of storage to exist as scaffolding until a permanent solution is more appropriate.</span>
