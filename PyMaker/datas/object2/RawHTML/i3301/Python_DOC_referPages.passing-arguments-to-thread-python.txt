<div class="post-text" itemprop="text">
<p>I have this method in my class called "interaction":</p>
<pre><code>class Interaction:

    def PreparaThreadBrowser(self, User, Password):
       t = ThreadBrowser(args=(User, Password), )
       t.start()
</code></pre>
<p>that ivokes a thread with User and Pass as parameters.</p>
<p>Then I have the class called "ThreadBrowser" with this "run" method:</p>
<pre><code>class ThreadBrowser(threading.Thread):

    def run (self, user, password):

        self.User = user
        self.Pass = password
        print(self.User, self.Pass)
</code></pre>
<p>but it turns out that I'm certainly struggling sending the arguments to the thread function because it gives an execution error:</p>
<p><code>TypeError: run() missing 2 required positional arguments: 'user' and 'password'</code></p>
<p>Any idea how to solve this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>args</code> constructor argument can't provide additional arguments to <code>run</code>. It provides the arguments to <em>target</em>, which you aren't specifying. Specifically:</p>
<ul>
<li><p>the default implementation of <code>run()</code> invokes <code>self.target(*self._args, **self._kwargs)</code>, where <code>_args</code> and <code>_kwargs</code> are provided by the constructor, and default to empty tuple and dict respectively.</p></li>
<li><p>by implementing <code>run</code> you opted out of Python invoking <code>target(*args)</code> automatically. It is then up to your code to store the state that your <code>run</code> will pick up. The idiomatic option is to store it in the constructor, much like your <code>run</code> method does now.</p></li>
</ul>
<p>For example:</p>
<pre><code>class ThreadBrowser(threading.Thread):
    def __init__(self, user, password):
        super(ThreadBrowser, self).__init__()
        self.User = user
        self.Pass = password

    def run(self):
        print(self.User, self.Pass)
</code></pre>
<p>The <code>ThreadBrowser</code> can then be constructed naturally as <code>ThreadBrowser(username, password)</code> and started with <code>t.start()</code> as before.</p>
</div>
<div class="post-text" itemprop="text">
<p>Run takes 2 arguments user, pass </p>
<pre><code>import threading



class Interaction:
    def PreparaThreadBrowser(self, User, Password):
        t = ThreadBrowser(args=(User, Pass), )
        t.start()



class ThreadBrowser(threading.Thread):

    def run (self, user, password):
        self.User = user
        self.Pass = password
        print(self.User, self.Pass)



t = ThreadBrowser()
t.run("user", "pass")
</code></pre>
</div>
<span class="comment-copy">Could you fix your indentation and add the code where you actually call <code>ThreadBrowser.run()</code>?</span>
<span class="comment-copy">@Primusa <code>Thread.run</code> is automatically invoked by <a href="https://docs.python.org/3/library/threading.html#threading.Thread.start" rel="nofollow noreferrer"><code>Thread.start</code></a>.</span>
<span class="comment-copy">That makes sense however it's giving a compiling error: <a href="https://imgur.com/a/F0SPLME" rel="nofollow noreferrer">imgur.com/a/F0SPLME</a></span>
<span class="comment-copy">@Gon√ßaloBaptista The error appears like an unrelated issue of mixing tabs and spaces. The code in the answer consistently uses spaces; did you copy/paste it?</span>
<span class="comment-copy">yes, didn't know couldn't copy paste. Sorry. It worked :D Thank you so much</span>
<span class="comment-copy">If i use like you told me too, the paramaters arrive correctly in the run method but the thread isn't invoked !</span>
<span class="comment-copy">Invoking <code>run</code> directly is wrong, the thread must always be invoked using the <code>start()</code> method.</span>
