<div class="post-text" itemprop="text">
<p>I've got a file that has a header row with a fixed number of labels and rows of variable length. The last column has a field that should really be a sublist of items, but this list is treated as a continuum of columns.</p>
<p>Example:</p>
<pre><code>Name, Address, Telephone
"Bob Smith", "123 main st", "111-111-1111"
"Jon Smith", "123 main st", "111-111-1111", "222-222-2222"
</code></pre>
<p>I ultimately want to iterate over the sublist, in this case telephone #'s. </p>
<p>I've tried using csv dictreader but it drops the extra columns. </p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need <code>DictReader</code>.  Use the standard <code>reader</code> and tuple assignment syntax:</p>
<p>Code:</p>
<pre><code>import csv

with open('test.csv') as f:
    r = csv.reader(f)
    next(r) # skip header

    # Note this assigns the 3rd and remaining columns to 'telephone' as a list.
    for name,addr,*telephone in r:
        print(f'name:     {name}')
        print(f'address:  {addr}')
        for i,phone in enumerate(telephone,1):
            print(f'Phone #{i}: {phone}')
        print()
</code></pre>
<p>test.csv:</p>
<pre><code>Name,Address,Telephone
"Bob Smith","123 main st","111-111-1111"
"Jon Smith","123 main st","111-111-1111","222-222-2222"
</code></pre>
<p>Output:</p>
<pre><code>name:     Bob Smith
address:  123 main st
Phone #1: 111-111-1111

name:     Jon Smith
address:  123 main st
Phone #1: 111-111-1111
Phone #2: 222-222-2222
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you can see in <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow noreferrer"><code>DictReader</code> docs</a>:</p>
<blockquote>
<p>If a row has more fields than <code>fieldnames</code>, the remaining data is put in a list and stored with the fieldname specified by <code>restkey</code> (which defaults to <code>None</code>).</p>
</blockquote>
<p>All you must do is pass the <code>restkey</code> parameter and all your extra values will go there.</p>
<pre><code>with open('yourfile.csv') as f:
    cf = csv.DictReader(f, restkey='extra')
    for row in cf:
        print(row)
</code></pre>
<p>will print</p>
<pre><code>{"Name": "Bob Smith", "Address": "123 main st", "Telephone": "111-111-1111"}
{"Name": "Jon Smith", "Address": "123 main st", "Telephone": "111-111-1111", "extra": ["222-222-2222"]}
</code></pre>
</div>
<span class="comment-copy">Always good to post code to show an attempt. Pandas has awesome excel tools.</span>
<span class="comment-copy">use some other delimiter instead of a comma in a value. as soon as csv encounters a comma, it splits. that's' the way it works!</span>
<span class="comment-copy">This looks great, however I get an error on the asterisk *telephone.</span>
<span class="comment-copy">@yanir the code works fine for me</span>
<span class="comment-copy">@yanir FYI I used Python 3.6, but I have Python 3.3 installed and it also has the feature.  I'm not sure when it was added.</span>
<span class="comment-copy">@yanir <a href="https://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">PEP 3132</a> describes the feature and it was implemented in Python 3.0.</span>
<span class="comment-copy">@yanir If that tripped you up, you'll also want Python 3.6 for the <a href="https://www.python.org/dev/peps/pep-0498" rel="nofollow noreferrer">f-strings (See PEP 0498)</a> in the example.</span>
