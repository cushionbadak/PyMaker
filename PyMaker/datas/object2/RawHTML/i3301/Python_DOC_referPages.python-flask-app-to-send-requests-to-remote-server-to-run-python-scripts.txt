<div class="post-text" itemprop="text">
<p>I'm writing a script to automate some command line commands in Python. At the moment I'm doing calls thus:</p>
<pre><code>cmd = "some unix command"
retcode = subprocess.call(cmd,shell=True)
</code></pre>
<p>However I need to run some commands on a remote machine. Manually, I would log in using ssh and then run the commands. How would I automate this in Python? I need to log in with a (known) password to the remote machine, so I can't just use <code>cmd = ssh user@remotehost</code>, I'm wondering if there's a module I should be using?</p>
</div>
<div class="post-text" itemprop="text">
<p>I will refer you to <a href="http://www.paramiko.org/" rel="noreferrer">paramiko</a></p>
<p>see <a href="https://stackoverflow.com/questions/373639/running-interactive-commands-in-paramiko">this question</a></p>
<pre><code>ssh = paramiko.SSHClient()
ssh.connect(server, username=username, password=password)
ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command(cmd_to_execute)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or you can just use <a href="https://docs.python.org/2/library/commands.html#commands.getstatusoutput" rel="noreferrer">commands.getstatusoutput</a>:</p>
<pre class="lang-py prettyprint-override"><code>   commands.getstatusoutput("ssh machine 1 'your script'")
</code></pre>
<p>I used it extensively and it works great.</p>
<p>In Python 2.6+, use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="noreferrer"><code>subprocess.check_output</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you had a look at <a href="http://www.fabfile.org" rel="noreferrer">Fabric</a>? It allows you to do all sorts of remote stuff over SSH using python.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found paramiko to be a bit too low-level, and Fabric not especially well-suited to being used as a library, so I put together my own library called <a href="http://pypi.python.org/pypi/spur" rel="noreferrer">spur</a> that uses paramiko to implement a slightly nicer interface:</p>
<pre><code>import spur

shell = spur.SshShell(hostname="localhost", username="bob", password="password1")
result = shell.run(["echo", "-n", "hello"])
print result.output # prints hello
</code></pre>
<p>If you need to run inside a shell:</p>
<pre><code>shell.run(["sh", "-c", "echo -n hello"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All have already stated (recommended) using <strong>paramiko</strong> and I am just sharing a python code (API one may say) that will allow you to execute multiple commands in one go.</p>
<p>to execute commands on different node use : <code>Commands().run_cmd(host_ip, list_of_commands)</code></p>
<blockquote>
<p>You will see one TODO, which I have kept to stop the execution if any of the commands fails to execute, I don't know how to do it. please share your knowledge</p>
</blockquote>
<pre><code>#!/usr/bin/python

import os
import sys
import select
import paramiko
import time


class Commands:
    def __init__(self, retry_time=0):
        self.retry_time = retry_time
        pass

    def run_cmd(self, host_ip, cmd_list):
        i = 0
        while True:
        # print("Trying to connect to %s (%i/%i)" % (self.host, i, self.retry_time))
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(host_ip)
            break
        except paramiko.AuthenticationException:
            print("Authentication failed when connecting to %s" % host_ip)
            sys.exit(1)
        except:
            print("Could not SSH to %s, waiting for it to start" % host_ip)
            i += 1
            time.sleep(2)

        # If we could not connect within time limit
        if i &gt;= self.retry_time:
            print("Could not connect to %s. Giving up" % host_ip)
            sys.exit(1)
        # After connection is successful
        # Send the command
        for command in cmd_list:
            # print command
            print "&gt; " + command
            # execute commands
            stdin, stdout, stderr = ssh.exec_command(command)
            # TODO() : if an error is thrown, stop further rules and revert back changes
            # Wait for the command to terminate
            while not stdout.channel.exit_status_ready():
                # Only print data if there is data to read in the channel
                if stdout.channel.recv_ready():
                    rl, wl, xl = select.select([ stdout.channel ], [ ], [ ], 0.0)
                    if len(rl) &gt; 0:
                        tmp = stdout.channel.recv(1024)
                        output = tmp.decode()
                        print output

        # Close SSH connection
        ssh.close()
        return

def main(args=None):
    if args is None:
        print "arguments expected"
    else:
        # args = {'&lt;ip_address&gt;', &lt;list_of_commands&gt;}
        mytest = Commands()
        mytest.run_cmd(host_ip=args[0], cmd_list=args[1])
    return


if __name__ == "__main__":
    main(sys.argv[1:])
</code></pre>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>I have used <a href="http://www.lag.net/paramiko/" rel="nofollow noreferrer">paramiko</a> a bunch (nice) and <a href="http://pexpect.sourceforge.net/pxssh.html" rel="nofollow noreferrer">pxssh</a> (also nice).  I would recommend either.  They work a little differently but have a relatively large overlap in usage.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at <code>spurplus</code>, a wrapper we developed around <code>spur</code> that provides type annotations and some minor gimmicks (reconnecting SFTP, md5 <em>etc</em>.): <a href="https://pypi.org/project/spurplus/" rel="nofollow noreferrer">https://pypi.org/project/spurplus/</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>paramiko</strong> finally worked for me after adding additional line, which is really important one (line 3):</p>
<pre><code>import paramiko

p = paramiko.SSHClient()
p.set_missing_host_key_policy(paramiko.AutoAddPolicy())   # This script doesn't work for me unless this line is added!
p.connect("server", port=22, username="username", password="password")
stdin, stdout, stderr = p.exec_command("your command")
opt = stdout.readlines()
opt = "".join(opt)
print(opt)
</code></pre>
<p>Make sure that paramiko package is installed.
Original source of the solution: <a href="https://www.youtube.com/watch?v=sHHYnQBm9V8" rel="nofollow noreferrer">Source</a></p>
</div>
<span class="comment-copy">The assumption here is that paramiko is as secure as (open)ssh.  Is it?</span>
<span class="comment-copy">what if the ssh-keys are exchanged?</span>
<span class="comment-copy">If you're using SSH keys, first prepare the keyfile using EITHER: <code>k = paramiko.RSAKey.from_private_key_file(keyfilename)</code> OR <code>k = paramiko.DSSKey.from_private_key_file(keyfilename)</code> THEN <code>ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</code> and finally <code>ssh..connect(hostname=host, username=user, pkey=k)</code>.</span>
<span class="comment-copy">As a long-time user of Paramiko (but not an expert), I can suggest using Paramiko but you should consider your use cases and how much you're willing to learn. Paramiko is very low-level, and you can easily fall into a trap where you create a "command running helper function" without fully understanding the code you're using. That means you might design say a <code>def run_cmd(host, cmd):</code> which does what you want at first, but your needs evolve. You end up changing the helper for the new use case, which changes behavior of the older existing usage. Plan accordingly.</span>
<span class="comment-copy">For unknown host error, do: ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) before</span>
<span class="comment-copy">+1 for a nice simple built-in method.  In my current setup I do not want to be adding Python libraries so your suggestion is valuable, very straightforward too.</span>
<span class="comment-copy">just make sure your remote host is setup for passwordless ssh, if not, you have to do other things for managing authentication</span>
<span class="comment-copy">subprocess.check_output -- great solution!</span>
<span class="comment-copy">@powerrox what are those "other things?"</span>
<span class="comment-copy">@TimS. you may have to include handling for authentication by whatever means is appropriate for your setup. I used expect to enter password at the prompt. then there is this thread with other solutions: <a href="http://unix.stackexchange.com/questions/147329/answer-password-prompt-programmatically-via-shell-script" title="answer password prompt programmatically via shell script">unix.stackexchange.com/questions/147329/â€¦</a></span>
<span class="comment-copy">I decided to try <code>spur</code>. You generate additional shell commands and you end up with: which 'mkdir' &gt; /dev/null 2&gt;&amp;1 ; echo $?; exec 'mkdir' '-p' '/data/rpmupdate/20130207142923'. I would like to have also access to a plain <code>exec_command</code>. Also missing ability to run background tasks: <code>nohup ./bin/rpmbuildpackages &lt; /dev/null &gt;&amp; /dev/null &amp;</code>. E.g., I generate a zsh script (rpmbuildpackages) using template and then I just to leave it running on the machine. Maybe ability to monitor such background jobs also would be nice (saving PIDs in some ~/.spur).</span>
<span class="comment-copy"><code>spur</code> apparently only works on unix systems cause it has a dependency on <a href="http://docs.python.org/2/library/termios.html" rel="nofollow noreferrer"><code>termios</code></a>.  Does anybody know a good library for Windows?</span>
<span class="comment-copy">Not entirely true: if you use a <a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto" rel="nofollow noreferrer">precompiled installer</a>, you will be able to install paramiko and spur. I just did it myself...</span>
<span class="comment-copy">@Gabriel: one of the recent releases should have improved support on Windows. If it's still not working, please feel free to open an issue.</span>
<span class="comment-copy">@davidlt: when constructing an <code>SshShell</code>, there is now the option to set the shell type. If a minimal shell is used by passing in <code>shell_type=spur.ssh.ShellTypes.minimal</code>, then only the raw command is sent. Implementing background tasks directly feels a bit out of scope for Spur, but you should be able to run the command you've described by invoking a shell e.g. <code>shell.run(["sh", "-c", "nohup ./bin/rpmbuildpackages &lt; /dev/null &gt;&amp; /dev/null &amp;"]</code>).</span>
<span class="comment-copy">The link to pxssh is a nice journey back in time.</span>
