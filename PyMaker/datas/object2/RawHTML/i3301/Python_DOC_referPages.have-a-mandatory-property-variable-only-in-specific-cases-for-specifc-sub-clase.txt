<div class="post-text" itemprop="text">
<p>I have an abstract class with a 'mandatory' property:</p>
<pre><code>class PMixin(ABC):

    @property
    @abstractmethod
    def progressbar_step(self):
        raise NotImplementedError
</code></pre>
<p>It is possible to have a mandatory property only in specific cases, and not for all sub-clases.</p>
<p>I use multiple inheritance, so if class A</p>
<pre><code>class A(PMixin, B)
</code></pre>
<p>inherits also from B not to be mandatory, otherwise to be mandatory.</p>
<p>A inherits all from PMixin if is not a subclass of B.</p>
<p>If it inherits also from B, progressbar_step is not necessary. </p>
<p>I can declare: <code>progressbar_step=None</code>, in the <code>PMixin</code>
and overwrite only if is not inheriting from B, and solve the issue, like</p>
<pre><code>class PMixin(ABC):
  progressbar_step = None

class A(PMixin)
  progressbar_step = 5

class A2(PMixin, B)
 ....
</code></pre>
<p>but I want to get a warning, where is the case to have a value, in example A;
It is just a coding 'safety' mechanism</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution using <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer"><code>__init__subclass__</code></a>, made available in Python 3.6.  This is called whenever <code>PMixin</code> is subclassed, and we can use it to remove the <code>abstractmethod</code> from subclasses that meet our criteria.</p>
<pre><code>from abc import ABC, abstractmethod

class B:
    pass

class PMixin(ABC):
    @property
    @abstractmethod
    def progressbar_step(self):
        raise NotImplementedError
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        if issubclass(cls, B):
            print('is subclass')
            print(cls.progressbar_step)
            cls.progressbar_step = None

class A(PMixin):  # Will raise error
        pass

class C(PMixin, B):  # No error
    pass
</code></pre>
<p>If you want the warning when you subclass <code>PMixin</code>, rather than when you try to instantiate an object of that subclass, you can check <code>cls.progressbar_step.__isabstractmethod__</code> in <code>__init_subclass__</code> and raise warnings appropriately. </p>
</div>
<div class="post-text" itemprop="text">
<p>for python versions that are &lt; 3.6 you can define a custom meta class to <code>PMixin</code>:</p>
<pre><code>class PMixinMeta(type):
    def __new__(mcs, names, bases, body):
        klass = super().__new__(mcs, names, bases, body)
        if issubclass(klass, B):  # 'if B in bases' is also ok 
            klass.progressbar_step = None
        return klass
</code></pre>
<p>however since <code>ABC</code> also uses a custom meta class, you will get a metaclass conflict if you define <code>PMixinMeta</code> as the meta of <code>PMixin</code> and inherit from <code>ABC</code>.</p>
<p>so you need to create an intermediate metaclass to resolve the conflict.</p>
<pre><code>from abc import ABCMeta

class PMixinAbcMeta(ABCMeta, PMixinMeta):
    pass
</code></pre>
<p>and then define <code>PMixinAbcMeta</code> as the metaclass of <code>PMixin</code></p>
<pre><code>from abc import abstractmethod

class PMixin():
    __metaclass__ = PMixinAbcMeta
    @property
    @abstractmethod
    def progressbar_step(self):
        raise NotImplementedError
</code></pre>
<p><strong>Note</strong>: you will only get an exception once you initiate (use <code>__init__</code>) an instance of a subclass of <code>PMixin</code>.</p>
<p>If you want to receive an exception during build time, <code>PMixinMeta</code> should look like this:</p>
<pre><code>class PMixinMeta(type):
    def __new__(mcs, names, bases, body):
        klass = super().__new__(mcs, names, bases, body)
        if issubclass(klass, B):
            klass.progressbar_step = None
        else:
            if 'progressbar_step' not in body:
                raise ValueError('must have a progressbar_step method')
        return klass
</code></pre>
<p>meaning that now this:</p>
<pre><code>class A(PMixin):
    pass
</code></pre>
<p>will raise an exception, and not only this:</p>
<pre><code>A()
</code></pre>
</div>
<span class="comment-copy">is class <code>B</code> a subclass of <code>PMixin</code>. If it is a sub class just put it before <code>PMixin</code> in <code>class (PMixin, B)</code>.</span>
<span class="comment-copy">no class B is not a subclass of PMixin</span>
<span class="comment-copy">Should you not have two (base) classes? Or the other way around really provide the interfaces as defined? I am just wondering how much of an abstraction it is, if its interface would be a chameleon with extra heuristics. -&gt; And would it not cause confusion/mistakes later on.</span>
<span class="comment-copy">So in <code>so if class A inherits also from B not to be mandatory</code>, what do you want to check if it inherits what from B?</span>
<span class="comment-copy">@ShashankSingh    if isinstance(self, B) ; also I updated the question to explain better</span>
