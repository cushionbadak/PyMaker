<div class="post-text" itemprop="text">
<p>Let's say I have the following:</p>
<pre><code>src = itertools.chain(*map(lambda t: map(lambda u: ((t[0], ) + os.path.splitext(u)), t[2]), os.walk(src_folder)))
dst = itertools.chain(*map(lambda t: map(lambda u: ((t[0], ) + os.path.splitext(u)), t[2]), os.walk(dst_folder)))
</code></pre>
<p>This creates two lists of the format <code>[(folder, base name, ext)]</code> for two directories.</p>
<p>I want to be able to find the files that are common in <code>src</code> and <code>dst</code>. I can do this with <code>set(src) &amp; set(dst)</code> as <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">documented</a>. But, what if I want to do it only by the folder and base name, and not by the extension? In other words, what if I want to do set intersection by a custom rule/function? How do I go about doing this?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In other words, what if I want to do set intersection by a custom rule/function? How do I go about doing this?</p>
</blockquote>
<p>You can't. The whole reason set intersection is so fast and simple is that Python can immediately check whether a value is an element of a set, without having to compare it to all of the elements of the set.</p>
<p>But what you <em>can</em> do is transform the sets as you build them, then intersect those:</p>
<pre><code>{os.path.basename(path) for path in src} &amp; {os.path.basename(path) for path in dst}
</code></pre>
<p>The problem is, this doesn't give you the full names whose basenames are in the intersection, it only gives you the basenames that are in the intersection. How can you fix that?</p>
<p>The easiest solution is to use a dict instead of a set. You can then use its keys view as a set, and then go back and get the corresponding values:</p>
<pre><code>srcmap = {os.path.basename(path): path for path in src}
srcisect = srcmap.keys() &amp; {os.path.basename(path) for path in dst}
result = {srcmap[key] for key in srcisect}
</code></pre>
<p>This may look like a lot more work, but it's really just 4 linear passes instead of 3 (and the extra one is just over the intersection rather than one of the original lists), so at worst the performance will only be worse by a small constant factor.</p>
</div>
<span class="comment-copy">You can create a custom class which contains these fields <code>(folder, base name, ext)</code> and then define a custom comparator for this class. You might even be able to turn this into a general utility. Have a look at <a href="https://stackoverflow.com/questions/16306844/custom-comparison-functions-for-built-in-types-in-python" title="custom comparison functions for built in types in python">stackoverflow.com/questions/16306844/â€¦</a></span>
<span class="comment-copy">@LakshayGarg A custom <code>__lt__</code> isn't going to do any good; the key is a custom <code>__hash__</code> (and of course an <code>__eq__</code> that matches). Which is doable, but it's probably more work than you'd want to do just for this case. Although maybe with 3.7 and <code>@dataclass</code> it isn't.</span>
<span class="comment-copy">I agree. I am not familiar with how python sets work. But how about doing something like using the same <code>__hash__</code> and <code>__eq__</code> as of <code>(folder, base_name)</code>. What I'm trying to say is that you won't have a hard time defining those functions if you decide to make this into a reusable utility. But again, I'm no expert ;)</span>
