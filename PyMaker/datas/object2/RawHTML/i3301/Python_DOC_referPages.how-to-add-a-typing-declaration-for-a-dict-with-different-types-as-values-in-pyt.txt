<div class="post-text" itemprop="text">
<p>I have a dictionary as follows</p>
<pre><code>my_dict = {
   "key_1": "value_1",
   "key_2": {
       "key_1": True,
           "key_2": 1200
       }
   "key_3": True,
}
</code></pre>
<p>and in my class</p>
<pre><code>@dataclass
class TestClass:
    my_dict: typing.Dict[{str, str}, {str, typing.Dict[{str, bool}, {str, int}]}]
</code></pre>
<p>The above declaration is incorrect.</p>
<p>If I want to add typing for my_dict what it should be and how to write the structure since I am having different types as values?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use a <a href="https://docs.python.org/3/library/typing.html#typing.Union" rel="nofollow noreferrer"><code>Union</code></a> as the value for the dictionary:</p>
<pre><code>from typing import Dict, Union

@dataclass
class TestClass:
    my_dict: Dict[str, Union[str, bool, int]]
</code></pre>
<p>The union informs the typechecker that values in the dictionary must be either <code>str</code>s, <code>bool</code>s, or <code>int</code>s. When getting values, you'll want to use <code>isinstance</code> to determine what to do with a value:</p>
<pre><code>if isinstance(self.my_dict['a'], str):
    return self.my_dict['a'].encode('utf-8')
else isinstance(self.my_dict['a'], bool):
    return not self.my_dict['a']
else:
    return self.my_dict['a'] / 10
</code></pre>
<p>If you know that a key will contain a specific type, you can avoid the typechecker's complaints by using <code>cast</code>:</p>
<pre><code>from typing import cast

value = cast(bool, self.my_dict['some_bool'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'll take a stab it it. So, the type of the values looks to be pretty distinct and easy to determine at runtime. The code that accesses the dictionary data and performs some action on it dependent on its type can use <em>instanceof()</em> in an if/elif/else block.</p>
<pre><code>def some_method(self, key):
    val = self.my_dict[key]
    if isinstance(val, str): # fixed from instanceof to isinstance...
        print val
    elif isinstance(val, dict):
        print "it was a dictionary"
    else:
        print "Guess it must have been an int or bool."
</code></pre>
<p>or you could test for type like so: if type(val) is str: dosomething()</p>
</div>
<span class="comment-copy">Are you allowing all types or a narrow subset?</span>
<span class="comment-copy">I want to allow strings, bool and int values for value</span>
<span class="comment-copy">You should mention that in the question. It's very important.</span>
<span class="comment-copy">Those three types are distinct enough that the type of the value could be determined at runtime; however, if you want to include typing information in the dictionary, you could make the values of each dictionary key be a two item list with the value and type. The type could be represented as an integer, or specifying its class. - Actually on a second look there are four value types: strings, bool, int and dict values.</span>
<span class="comment-copy">f you want to just use the typing built into the values at runtime, whatever code needs to determine the type can use <i>instanceof()</i> to test for it before executing the block that handles the specific type.</span>
<span class="comment-copy"><code>instanceof</code> could be <code>isinstance</code></span>
<span class="comment-copy"><code>if type(val) is str: dosomething()</code> could be <code>if type(val) == str: dosomething()</code></span>
<span class="comment-copy">ugghh.. right. sorry about that. it's <i>isinstance()</i>. thanks U9 =)</span>
<span class="comment-copy">the test for equality could be alternatively <i>is</i> or <i>==</i>.</span>
<span class="comment-copy">There appears to be some Python 3+ feature set that maybe we need to learn more about - or maybe it's just me (I'm looking at Bailey's answer). Or maybe some more review of the <i>typing</i> module.</span>
