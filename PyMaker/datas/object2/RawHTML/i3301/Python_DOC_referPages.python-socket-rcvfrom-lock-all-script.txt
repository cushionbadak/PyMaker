<div class="post-text" itemprop="text">
<p>I have a simple code in python 3 using schedule and socket:</p>
<pre><code>import schedule
import socket
from time import sleep

def readDataFromFile():
    data = []
    with open("/tmp/tmp.txt", "r") as f:
        for singleLine in f.readlines():
            data.append(str(singleLine))

    if(len(data)&gt;0):
        writeToBuffer(data)

def readDataFromUDP():
    udpData = []
    rcvData, addr = sock.recvfrom(256)
    udpData.append(rcvData.decode('ascii'))

    if(len(udpData)&gt;0):
        writeToBuffer(udpData)

.
.
.

def main():
    schedule.every().second.do(readDataFromFile)
    schedule.every().second.do(readDataFromUDP)

    while(1):
        schedule.run_pending()
        sleep(1)



UDP_IP = "192.xxx.xxx.xxx"
UDP_PORT = xxxx

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))

main()
</code></pre>
<p>The problem is, script hung up on the sock.rcvfrom() instruction, and wait until data come.
How force python to run this job independently? Better idea is to run this in threads?</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>can</em> use threads here, and it'll work fine, but it will require a few changes. First, the scheduler on your background thread is going to try to kick off a new <code>recvfrom</code> every second, no matter how long the last one took. Second, since both threads are apparently trying to call the same <code>writeToBuffer</code> function, you're probably going to need a <code>Lock</code> or something else to synchronize them.</p>
<p>Rewriting the whole program around an asynchronous event loop is almost certainly overkill here.</p>
<p>Just changing the socket to be nonblocking and doing a hybrid is probably the simplest change, e.g., by using <a href="https://docs.python.org/3/library/socket.html#socket.socket.setblocking" rel="nofollow noreferrer"><code>settimeout</code></a>:</p>
<pre><code># wherever you create your socket
sock.settimeout(0.8)

# ...

def readDataFromUDP():
    udpData = []
    try:
        rcvData, addr = sock.recvfrom(256)
    except socket.timeout:
        return
    udpData.append(rcvData.decode('ascii'))

    if(len(udpData)&gt;0):
        writeToBuffer(udpData)
</code></pre>
<p>Now, every time you call <code>recvfrom</code>, if there's data available, you'll handle it immediately; if not, it'll wait up to 0.8 seconds, and then raise an exception, which means you have no data to process, so go back and wait for the next loop. (There's nothing magical about that 0.8; I just figured something a little less than 1 second would be a good idea, so there's time left to do all the other work before the next schedule time hits.)</p>
<p>Under the covers, this works by setting the OS-level socket to non-blocking mode and doing some implementation-specific thing to wait with a timeout. You could do the same yourself by using <code>setblocking(False)</code> and using the <code>select</code> or <code>selectors</code> module to wait up to 0.8 seconds for the socket to be ready, but it's easier to just let Python take care of that for you.</p>
</div>
