<div class="post-text" itemprop="text">
<p>I have a text file which I read in. This is a log file so it follows a particular pattern. I need to create a JSON ultimately, but from researching this problem, once it is in a dict it will be a matter of using <code>json.loads()</code> or <code>json.dumps()</code>. </p>
<p>A sample of the text file is below. </p>
<pre><code>INFO:20180606_141527:submit:is_test=False
INFO:20180606_141527:submit:username=Mary
INFO:20180606_141527:env:sys.platform=linux2
INFO:20180606_141527:env:os.name=ubuntu
</code></pre>
<p>The dict structure which I am ultimatly looking for is </p>
<pre><code>{
  "INFO": {
    "submit": {
      "is_test": false,
      "username": "Mary"
    },
    "env": {
      "sys.platform": "linux2",
      "os.name": "ubuntu"
    }
  }
}
</code></pre>
<p>I am ignoring the timestamp information in each list for now. </p>
<p>This is a snippet of the code I am using, </p>
<pre><code>import csv
tree_dict = {}
with open('file.log') as file:
    for row in file:
        for key in reversed(row.split(":")):
            tree_dict = {key: tree_dict}
</code></pre>
<p>Which results in an undesired output, </p>
<pre><code>{'INFO': {'20180606_141527': {'submit': {'os.name=posix\n': {'INFO': {'20180606_141527': {'submit': {'sys.platform=linux2\n': {'INFO': {'20180606_141527': {'submit': {'username=a227874\n': {'INFO': {'20180606_141527': {'submit': {'is_test=False\n': {}}}}}}}}}}}}}}}}}
</code></pre>
<p>I need to dynamically populate the dict because I don't know the actual field/key names. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open('demo.txt') as f:
    lines = f.readlines()

dct = {}

for line in lines:
    # param1 == INFO
    # param2 == submit or env
    # params3 == is_test=False etc.
    param1, _, param2, params3 = line.strip().split(':')

    # create dct[param1] = {} if it is not created
    dct.setdefault(param1, {})

    # create dct[param1][param2] = {} if it is no created
    dct[param1].setdefault(param2, {})

    # for example params3 == is_test=False
    # split it by '=' and now we unpack it
    # k == is_test
    # v == False
    k, v = params3.split('=')

    # and update our `dict` with the new values
    dct[param1][param2].update({k: v})

print(dct)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>{
'INFO': {
    'submit': {
        'is_test': 'False', 'username': 'Mary'
        }, 
    'env': {
        'sys.platform': 'linux2', 'os.name': 'ubuntu'
        }
    }
}  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one of the rare cases where recursion in Python seems to be appropriate and helpful. The following function adds a <code>value</code> to the hierarchical dictionary <code>d</code> specified by the list of <code>keys</code>:</p>
<pre><code>def add_to_dict(d, keys, value): 
    if len(keys) == 1: # The last key
        d[keys[0]] = value
        return
    if keys[0] not in d:
        d[keys[0]] = {} # Create a new subdict
    add_to_dict(d[keys[0]], keys[1:], value)
</code></pre>
<p>The function works with the dictionaries of arbitrary depth. The rest is just the matter of calling the function:</p>
<pre><code>d = {}
for line in file:
    keys, value = line.split("=")
    keys = keys.split(":")
    add_to_dict(d, keys, value.strip())
</code></pre>
<p>Result:</p>
<pre><code>{'INFO': {'20180606_141527': {
                       'submit': {'is_test': 'False', 
                                  'username': 'Mary'}, 
                       'env': {'sys.platform': 'linux2', 
                               'os.name': 'ubuntu'}}}}
</code></pre>
<p>You can modify the code to exclude certain levels (like the timestamp).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a nested <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a> here:</p>
<pre><code>from collections import defaultdict
from pprint import pprint

d = defaultdict(lambda: defaultdict(dict))
with open('sample.txt') as in_file:
    for line in in_file:
        info, _, category, pair = line.strip().split(':')
        props, value = pair.split('=')
        d[info][category][props] = value

pprint(d)
</code></pre>
<p>Which gives the following:</p>
<pre><code>defaultdict(&lt;function &lt;lambda&gt; at 0x7ff8a341aea0&gt;,
            {'INFO': defaultdict(&lt;class 'dict'&gt;,
                                 {'env': {'os.name': 'ubuntu',
                                          'sys.platform': 'linux2'},
                                  'submit': {'is_test': 'False',
                                             'username': 'Mary'}})})
</code></pre>
<p><strong>Note:</strong> <code>defaultdict()</code> is a subclass of the builtin <code>dict</code>, so their is not reason to convert it to <code>dict</code> in the end result. Additionally, <code>defaultdict()</code> can also be serialized to JSON with <a href="https://docs.python.org/3/library/json.html#json.dumps" rel="nofollow noreferrer"><code>json.dumps()</code></a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>import itertools, re
content = [re.split('\=|:', i.strip('\n')) for i in open('filename.txt')]
new_content = [[a, *c] for a, _, *c in content]
def group_vals(d):
  new_d = [[a, [c for _, *c in b]] for a, b in itertools.groupby(sorted(d, key=lambda x:x[0]), key=lambda x:x[0])]
  return {a:b[0][0] if len(b) ==1 else group_vals(b) for a, b in new_d}
</code></pre>
<hr/>
<pre><code>import json
print(json.dumps(group_vals(new_content), indent=4))
</code></pre>
<p>Output:</p>
<pre><code>{
 "INFO": {
     "env": {
        "os.name": "ubuntu",
        "sys.platform": "linux2"
     },
     "submit": {
         "is_test": "False",
         "username": "Mary"
     }
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check for the presence of keys:</p>
<pre><code>import csv
import json

tree_dict = {}
with open('file.log') as file:
    tree_dict = {}
    for row in file:
        keys = row.split(":")

        if keys[0] not in tree_dict:
            tree_dict[keys[0]] = {}

        if keys[-2] not in tree_dict[keys[0]]:
            tree_dict[keys[0]][keys[-2]] = {}

        key, value = keys[-1].split("=")

        if value == "False":
            value = False
        if value == "True":
            value = True

        tree_dict[keys[0]][keys[-2]][key] = value

dumped = json.dumps(tree_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
from functools import reduce

with open('file.txt') as f:
    lines = f.readlines()

def rec_merge(d1, d2):
    for k, v in d1.items():
        if k in d2:
            d2[k] = rec_merge(v, d2[k])
    d3 = d1.copy()
    d3.update(d2)
    return d3

lst_of_tup = re.findall(r'^([^:]*):[\d_]+:([^:]*):([^=]*)=(.*)$', lines, re.MULTILINE)
lst_of_dct = [reduce(lambda x,y: {y:x}, reversed(t)) for t in lst_of_tup]

dct = reduce(rec_merge, lst_of_dct)

pprint(dct)
# {'INFO': {'env': {'os.name': 'ubuntu', 'sys.platform': 'linux2'},
#           'submit': {'is_test': 'False', 'username': 'Mary'}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Source : </p>
<pre><code>import os

with open('file.log') as file:
    tree_dict = {}
    is_test = False
    username = ""              
    sysplatform = ""
    osname = ""
    for row in file: 
        row = row.rstrip('\n')
        for key in reversed(row.split(":")):            
            if not key.find('is_test'):
                is_test = key.split('=')[1]
            elif not key.find('username'):
                username =key.split('=')[1]
            elif not key.find('sys.platform'):
                sysplatform = key.split('=')[1]
            elif not key.find('os.name'):
                osname = key.split('=')[1]    

     tree_dict = {
         "INFO": {
              "submit": {
                       "is_test": is_test,
                        "username": username
              },
              "env": {
                      "sys.platform":  sysplatform,
                      "os.name": osname
             }
        }
    }
    print(tree_dict)
</code></pre>
<p>Result : </p>
<pre><code> {'INFO': {'submit': {'is_test': 'False', 'username': 'Mary'}, 'env': {'sys.platform': 'linux2', 'os.name': 'ubuntu'}}}
</code></pre>
</div>
<span class="comment-copy">how do you want to handle multiple logs/dicts? give us an example with at least 2 logs</span>
<span class="comment-copy">The question seems unrelated to the title</span>
<span class="comment-copy">You could use <code>setdefault</code> to get rid of the two <code>if</code> checks.</span>
<span class="comment-copy">i change it, thanks! i forgot about <code>setdefault</code></span>
<span class="comment-copy">You might add that for all practial purposes a <code>defaultdict</code> behaves like a normal <code>dict</code> and in particular can also be serialized to JSON.</span>
<span class="comment-copy">@tobias_k Very good point, I'll add that now.</span>
