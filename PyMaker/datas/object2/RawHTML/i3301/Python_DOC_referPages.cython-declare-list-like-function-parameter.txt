<div class="post-text" itemprop="text">
<p>I'm trying to create a simple cython module and have the following problem. I would like to create a function like:</p>
<pre><code>cdef float calc(float[:] a1, float[:] a2):
    cdef float res = 0
    cdef int l = len(a2)
    cdef float item_a2
    cdef float item_a1

    for idx in range(l):
        if a2[idx] &gt; 0:
            item_a2 = a2[idx]
            item_a1 = a1[idx]
            res += item_a2 * item_a1

    return res
</code></pre>
<p>When the function is being executed, a1 and a2 params are python lists. Therefore I get the error:</p>
<blockquote>
<p>TypeError: a bytes-like object is required, not 'list'</p>
</blockquote>
<p>I just need to make such calculations and nothing more. But how shall I define input params <code>float[:] a1</code> and <code>float[:] a2</code> if I need to maximize speed up using C?
Probably it's necessary to convert lists to arrays manually?</p>
<p>P.S. would appreciate also if you can also explain to me whether it's necessary  to declare <code>cdef float item_a2</code> explicitly to perform multiplication (in terms of performance) or it is equally to <code>result += a2[idx] * a1[idx]</code></p>
</div>
<div class="post-text" itemprop="text">
<h3>Cython answer</h3>
<p>One way you can do this (if you're open to using numpy):</p>
<pre><code>import numpy as np
cimport numpy as np

ctypedef np.npy_float FLOAT
ctypedef np.npy_intp INTP

cdef FLOAT calc(np.ndarray[FLOAT, ndim=1, mode='c'] a1, 
                np.ndarray[FLOAT, ndim=1, mode='c'] a2):
    cdef FLOAT res = 0
    cdef INTP l = a2.shape[0]
    cdef FLOAT item_a2
    cdef FLOAT item_a1

    for idx in range(l):
        if a2[idx] &gt; 0:
            item_a2 = a2[idx]
            item_a1 = a1[idx]
            res += item_a2 * item_a1

    return res
</code></pre>
<p>This will require a <code>np.float32</code> dtype for your array. If you wanted a <code>np.float64</code>, you can redefine <code>FLOAT</code> as <code>np.float64_t</code>.</p>
<p>One unsolicited piece of advice... <code>l</code> is a bad name for a variable, since it looks like a digit. Consider renaming it <code>length</code>, or something of the like.</p>
<h3>Pure python with Numpy</h3>
<p>Finally, it looks like you're trying to compute the dot product between two vectors where elements in one array are positive. You could use Numpy here pretty efficiently to get the same result.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a1 = np.array([0, 1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; a2 = np.array([1, 2, 0, 3, -1])
&gt;&gt;&gt; a1[:a2.shape[0]].dot(np.maximum(a2, 0))
11
</code></pre>
<p>Note, I added the <code>a1</code> slice since you didn't check for length equality in your Cython function, but used <code>a2</code>'s length. So I assumed the lengths may differ. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>cdef float calc(float[:] a1, float[:] a2):
</code></pre>
<p><code>a1</code> and <code>a2</code> can be any object that <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">supports the buffer protocol</a> and has a <code>float</code> type. The most common examples would be either a numpy array or the <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">standard library <code>array</code> module</a>. They will not accept Python lists because a Python list is not a single homogeneous C type packed efficiently into memory, but instead a collection of Python objects.</p>
<p>To create a suitable object from a Python list you can do either:</p>
<pre><code>numpy.array([1.0,2.0],dtype=numpy.float32)
array.array('f',[1.0,2.0])
</code></pre>
<p>(You may want to consider using <code>double</code>/<code>float64</code> instead of <code>float</code> for extra precision, but that's your choice)</p>
<p>If you don't want to create array objects like this then Cython will not help you much since there is not much speed up possible with plain lists.</p>
<p>The <code>np.ndarray[FLOAT, ndim=1] a1</code> syntax suggested in the other answer an outdated version of the memoryview syntax you're already using. There are no advantages (and a few small disadvantages) to using it.</p>
<hr/>
<pre><code>result += a2[idx] * a1[idx]
</code></pre>
<p>is fine - Cython knows the types of <code>a1</code> and <code>a2</code> so there is no need to create temporary intermediate variables. You can get a html highlighted file with <code>cython -a filename.pyx</code> to inspect that will help indicate where the non-accelerated parts are.</p>
</div>
<span class="comment-copy">There are some similar questions around: <a href="https://stackoverflow.com/q/47005382/5769463">stackoverflow.com/q/47005382/5769463</a> or <a href="https://stackoverflow.com/q/11689967/5769463">stackoverflow.com/q/11689967/5769463</a></span>
<span class="comment-copy">I don't think (the first part of) this is useful advice. You've changed the newer, more general typed memoryview syntax to the old numpy syntax. This won't change the speed meaningfully, but means that the code actually works with <i>fewer</i> input types.</span>
<span class="comment-copy">@DavidW, could you show how it could be represented in memoryview syntax, please?</span>
<span class="comment-copy">@Tgsmith61591, thanks for the detailed answer. Could you explain why did you use <code>cimport numpy as np</code> right after python import, please? What's the reason for that?</span>
<span class="comment-copy">@user1820686 The <code>float[:] a1</code> that OP uses in the question is memoryview syntax. (To match your <code>mode="C"</code> you can change it to <code>float[::1]</code>) This will accept a range of types including numpy arrays, the standard library <code>array</code> library, and any other type that follows the Python "buffer protocol".</span>
<span class="comment-copy">Thanks @DavidW. The memory view syntax is new to me. I've always written Cython with (what is apparently) the old syntax. I appreciate your clarification!</span>
