<div class="post-text" itemprop="text">
<p>I have a list of tuples as below. The tuple in itself is a nested tuple with 3 sub-elements (tuples) inside it.</p>
<pre><code>[(('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('e', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('a', 'apple'), ('d', 'mango'), ('c', 'peach')),
 (('e', 'apple'), ('d', 'mango'), ('f', 'grapes')),
 (('f', 'grapes'), ('e', 'apple'), ('d', 'mango')),
 (('f', 'peach'), ('e', 'apple'), ('e', 'mango')),
 (('f', 'grapes'), ('c', 'apple'), ('d', 'mango')), 
 (('e', 'apple'), ('f', 'grapes'), ('d', 'mango')),
 (('a', 'apple'), ('c', 'grapes'), ('b', 'mango')),
 ]
</code></pre>
<p>I want to group these tuples by matching the positions of two of its elements viz. apple and mango (which is fixed and known beforehand) inside the tuples!</p>
<p>Desired output:</p>
<pre><code>[
# apple and mango at positions 1 and 2.
[(('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('e', 'apple'), ('b', 'mango'), ('c', 'grapes')),
 (('a', 'apple'), ('d', 'mango'), ('c', 'peach')),
 (('e', 'apple'), ('d', 'mango'), ('f', 'grapes'))],

# apple and mango at positions 2 and 3.
 [(('f', 'grapes'), ('e', 'apple'), ('d', 'mango')),
 (('f', 'peach'), ('e', 'apple'), ('e', 'mango')),
 (('f', 'grapes'), ('c', 'apple'), ('d', 'mango'))], 

# apple and mango at positions 1 and 3.
 [(('e', 'apple'), ('f', 'grapes'), ('d', 'mango')),
 (('a', 'apple'), ('c', 'grapes'), ('b', 'mango'))]
 ]
</code></pre>
<p>I tried using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> and also checked some other examples but couldn't succeed in coming close the desired output. As such, any help or pointers would be really appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>My go-to solution for grouping tasks like this is <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>. I've written a lengthy answer about grouping things, which you can read <a href="https://stackoverflow.com/a/50086453/1222951">here</a>. Picking out the relevant snippets from that answer gives us this piece of code:</p>
<pre><code>import collections

groupdict = collections.defaultdict(list)
for value in your_list_of_tuples:  # input
    group = ???  # group identifier
    groupdict[group].append(value)

result = list(groupdict.values())  # output
</code></pre>
<p>Where all that's left is to find a way to uniquely represent each group with a hashable value (that is, we need to fill in the <code>group = ???</code> line).</p>
<p>The easiest solution is probably to extract the <code>apple</code> and <code>mango</code> values from the nested tuples and replace all other values with <code>None</code>:</p>
<pre><code>&gt;&gt;&gt; tup = (('a', 'apple'), ('c', 'grapes'), ('b', 'mango'))
&gt;&gt;&gt; tuple((t[1] if t[1] in {'apple','mango'} else None) for t in tup)
('apple', None, 'mango')
</code></pre>
<p>Add that in and we're done:</p>
<pre><code>import collections

groupdict = collections.defaultdict(list)
for value in your_list_of_tuples:
    group = tuple((t[1] if t[1] in {'apple','mango'} else None) for t in value)
    groupdict[group].append(value)

result = list(groupdict.values())

# result:
# [[(('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
#   (('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
#   (('e', 'apple'), ('b', 'mango'), ('c', 'grapes')),
#   (('a', 'apple'), ('d', 'mango'), ('c', 'peach')),
#   (('e', 'apple'), ('d', 'mango'), ('f', 'grapes'))],
#  [(('f', 'grapes'), ('e', 'apple'), ('d', 'mango')),
#   (('f', 'peach'), ('e', 'apple'), ('e', 'mango')),
#   (('f', 'grapes'), ('c', 'apple'), ('d', 'mango'))],
#  [(('e', 'apple'), ('f', 'grapes'), ('d', 'mango')),
#   (('a', 'apple'),('c', 'grapes'), ('b', 'mango'))]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another approach is to make a dictionary using the positions for each pair of sub-items as keys.</p>
<p><strong>Given</strong></p>
<pre><code>import more_itertools as mit

iterables = [
     (("a", "apple"),  ("b", "mango"),  ("c", "grapes")),
     (("a", "apple"),  ("b", "mango"),  ("c", "grapes")),
     (("e", "apple"),  ("b", "mango"),  ("c", "grapes")),
     (("a", "apple"),  ("d", "mango"),  ("c", "peach")),
     (("e", "apple"),  ("d", "mango"),  ("f", "grapes")),
     (("f", "grapes"), ("e", "apple"),  ("d", "mango")),
     (("f", "peach"),  ("e", "apple"),  ("e", "mango")),
     (("f", "grapes"), ("c", "apple"),  ("d", "mango")), 
     (("e", "apple"),  ("f", "grapes"), ("d", "mango")),
     (("a", "apple"),  ("c", "grapes"), ("b", "mango")),
]

whitelisted = "apple mango".split()
</code></pre>
<p><strong>Code</strong></p>
<p>First, we build a list of indices to <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate" rel="nofollow noreferrer"><code>locate</code></a> occurrences of <code>whitelisted</code> sub-items in <code>iterables</code>. </p>
<pre><code>pred = lambda x: x[1] in set(whitelisted)
indices = [tuple(mit.locate(t, pred=pred)) for t in iterables]
print(indices)
# [(0, 1), (0, 1), (0, 1), (0, 1), (0, 1), (1, 2), (1, 2), (1, 2), (0, 2), (0, 2)]
</code></pre>
<p>Finally, <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.map_reduce" rel="nofollow noreferrer"><code>map_reduce</code></a> is one way to make a <code>defaultdict</code> with custom keys and values.</p>
<pre><code>result = mit.map_reduce(zip(indices, iterable), keyfunc=lambda x: x[0], valuefunc=lambda x: x[1])
result
</code></pre>
<p>Output</p>
<pre><code>defaultdict(None,
            {(0, 1): [(('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
              (('a', 'apple'), ('b', 'mango'), ('c', 'grapes')),
              (('e', 'apple'), ('b', 'mango'), ('c', 'grapes')),
              (('a', 'apple'), ('d', 'mango'), ('c', 'peach')),
              (('e', 'apple'), ('d', 'mango'), ('f', 'grapes'))],
             (1, 2): [(('f', 'grapes'), ('e', 'apple'), ('d', 'mango')),
              (('f', 'peach'), ('e', 'apple'), ('e', 'mango')),
              (('f', 'grapes'), ('c', 'apple'), ('d', 'mango'))],
             (0, 2): [(('e', 'apple'), ('f', 'grapes'), ('d', 'mango')),
              (('a', 'apple'), ('c', 'grapes'), ('b', 'mango'))]})
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>For each tuple in <code>iterables</code>, <code>locate</code> is used to yield the indices for items belonging to the set of <code>whitelisted</code> items.  These results are sufficient for grouping items together.  However, it is easier to see the actual items returned, so next we build a dictionary with <code>map_reduce</code>.</p>
<p>We iterate a zip of <code>(indices, iterables)</code> pairs. <code>keyfunc</code> transforms the <code>indices</code> as keys.  Likewise, <code>valuefunc</code> transforms <code>iterables</code> as values.  The result is a <code>defaultdict</code> with values grouped by sub-positions of <code>whitelisted</code> items <code>apple</code> and <code>mango</code>.</p>
</div>
<span class="comment-copy">If you have two tuples where <code>apple</code> and <code>mango</code> are swapped like <code>(('a', 'apple'), ('m', 'mango'))</code> and <code>(('m', 'mango'), ('a', 'apple'))</code>, should those two be grouped together?</span>
<span class="comment-copy">They should be placed in separate groups then, because the position for apple and mango is 1 and 2 in the first tuple and in the second it is 2 and 1 !</span>
<span class="comment-copy">Thank you so much for the detailed explanation of your approach and solution. It really helped me as the example, I had highlighted was a basic one so that anyone who wanted to help could understand it.  But, your approach helped me tweak the 'else part' for an advanced grouping on other tuple elements inside this list of nested tuples as an example below!  group = tuple((t[1] if t[1] in {'apple','mango'} else t[0]) for t in value)  Lastly, I value and appreciate your knowledge sharing ability for the good of the larger Python developers community! :)</span>
<span class="comment-copy">Thank you! :)  This is also an interesting way to approach the problem, although I had already used the solution mentioned by @aran as it gave me the ability to tweak on the other tuple elements for an advanced grouping.</span>
<span class="comment-copy">That's fine.  Just note that any tweaking to the final result can likely be accomplished with the keyword parameters of <code>map_reduce</code>, i.e. <code>keyfunc</code>, <code>valuefunc</code> and <code>reducefunc.</code></span>
<span class="comment-copy">Yes, definitely! Map_reduce is another alternative. :)</span>
