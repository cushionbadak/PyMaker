<div class="post-text" itemprop="text">
<p>EDIT: I've gotten a lot of useful feedback on how <em>not</em> to do this and how to find alternatives, but making that useful depends on idiosyncrasies of my use case that would make this question less useful to others. At this point, <strong>I'm not looking for alternatives to using data structured like this</strong>. I'm looking for <strong>why it seems to be impossible to do this in numpy</strong> (or how to do it if it's not impossible)</p>
<p>I have a numpy array, which looks like</p>
<pre><code>a = array([list([1]), list([4, 5])], dtype=object)
</code></pre>
<p>I want to append a list like</p>
<pre><code>b = [2, 3, 4]
</code></pre>
<p>To get a result like</p>
<pre><code>array([list([1]), list([4, 5]), list([2, 3, 4])], dtype=object)
</code></pre>
<p>However, every method I've tried has produced:</p>
<pre><code>array([list([1]), list([4, 5]), 2, 3, 4], dtype=object)
</code></pre>
<p>I've tried vstack, concatenate, and append, as well as wrapping things in lists or ndarrays.</p>
<p>Why am I doing this? Basically, I have a lot of data in an ndarray that's going to get fed into sklearn. I want to have a 3d ndarray (data sets x data points x features) but incoming data is bad and certain things have different lengths, so the innermost dimension has to be lists. I'm trying to append a derived feature, which keeps failing. I've managed to reorder the operations to avoid needing to do this appending, but I still want to know how to do it. This seems like an odd failure for numpy.
edit: In short, <strong>the outer array must be an ndarray</strong> because it's actually 2d, and complex slicing is frequently used, while the append operation occurs very few times.</p>
</div>
<div class="post-text" itemprop="text">
<p>Appending to an array in the first place is an expensive and generally smelly operation. The thing is that the contents of the array may be mutable, but the address of the underlying buffer is not. Every time you append an element, the whole thing gets reallocated and copied. As far as I'm aware, there isn't even  an attempt at amortization, as with <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list</code></a>.</p>
<p>If you are up for a slightly different approach, I would recommend maintaining your data in a <code>list</code> as you have now. You just transform your list into an array whenever you actually need the array. Remember that this is cheaper than reallocating to a new array every time, and you probably won't have to do it often compared to the number of appends:</p>
<pre><code>stack = [[1], [4, 5]]
a = np.array(stack, dtype=np.object)
# do stuff to the array

...

stack.append([2, 3, 4])
a = np.array(stack, dtype=np.object)
</code></pre>
<p><strong>Update Now that I Understand Your Question</strong></p>
<p>If your goal is just to figure out how to append an element to an object array without having the fact that it is a list get in your way, you have to first create an array or element that is empty. Rather than trying to coerce the type with fake elements as some of the comments suggest, I recommend just creating empty elements and setting them to your list explicitly. You can wrap the operation in a function if you want to have a clean interface.</p>
<p>Here is an example:</p>
<pre><code>b = [2, 3, 4]
c = np.empty(1, dtype=np.object)
c[0] = b
a = np.concatenate((a, c))
</code></pre>
<p>OR</p>
<pre><code>a = np.append(a, c)
</code></pre>
<p>Of course this is not as clean as <code>np.array([b], dtype=np.object)</code>, but that's just an artifact of how numpy processes arrays. The reason you pretty much have to do it like this is that numpy treats anything that is a list or tuple as a special item that you want to convert into an array at the outer level.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really must have an <code>np.ndarray</code> with <code>dtype=object</code>, you can do this:</p>
<pre><code>a = np.array([list([1]), list([4, 5])], dtype=object)
b = [2, 3, 4]
a = np.hstack((a, np.empty(1)))
a[-1] = b
</code></pre>
<p>(Or of course remove <code>np.</code> in your case where you fully imported numpy.)<br/>
But I recommend not using <code>np.ndarray</code>s of <code>dtype=object</code>. Instead use <code>list</code>s with:</p>
<pre><code>a = [[list([1]), list([4, 5])]]
b = [2, 3, 4]
a.append(b)
</code></pre>
<p>Now if you really want to have <code>a</code> as an <code>np.ndarray</code>, you can then do the following:</p>
<pre><code>a = np.array(a)
</code></pre>
</div>
<span class="comment-copy">I can do it by a.append("temp"); a[-1]=b, but that seems hacky and bad. It feels like there should be a way to do this.</span>
<span class="comment-copy">In a one liner, you could do: <code>arr = np.array(a.tolist()+[b])</code></span>
<span class="comment-copy">@Brenlla That would work, even with the outer ndarray being 2d. However, I'm a bit concerned about the speed of the double conversion, given that these arrays actually have thousands of elements. It also seems kind of ugly and unfortunate. I was really hoping for a numpy method to do this, or an explanation of why the builtins fail. I'd definitely upvote this as an answer though.</span>
<span class="comment-copy">@OwenGray. Appending to an array is a bad idea. Don't worry about hackishness and cost.</span>
<span class="comment-copy">Agree with @MadPhysicist. If you're concerned about performance, don't use NumPy arrays for mismatched-length lists. If you <i>must</i>, use padding and create a normal <code>m x n</code> array.</span>
<span class="comment-copy">This could work for many cases, but in my situation the outer ndarray is 2d, and the overall data structure is 3d. I'm also only appending once, and slicing by the second index many more times. I don't think this approach would work for me. I'm also concerned about the efficiency of this approach: I think list -&gt; ndarray conversion is at least O(n). I've also edited my question to clarify that I'm more trying to make the question useful for others than trying to find the best way to handle my situation.</span>
<span class="comment-copy">@OwenGray. I hope my update answers your actual question.</span>
<span class="comment-copy">The update here answers the 'why cant I'. <code>concatenate</code> joins arrays. The new piece has to be in an array of the right dtype and shape - object and (1,).  Starting with <code>np.empty</code> is best if not only way to do this.</span>
<span class="comment-copy">@hpaulj. Well, you could technically use <code>np.zeros</code> or <code>np.ones</code>, but that would just be wasteful.</span>
<span class="comment-copy">Object empty fills with <code>None</code> so isn't as cheap as the numeric version.  But  I like that fill.</span>
<span class="comment-copy">Why the down votes?  This works as well as @Mad's update.</span>
<span class="comment-copy">As well as things like unaccepting a correct answer after some time (days or weeks), because some follow up problems show up, which are not described in the initial question and which are not directly connected to the initial problem. Like <a href="https://stackoverflow.com/questions/50328737/access-column-with-in-another-column-header/50329298#50329298">here</a>.</span>
<span class="comment-copy">I would guess the downvotes are because the first solution you gave was already in a comment I left on the question (before you answered), and the other option you suggested is pretty obvious.</span>
<span class="comment-copy">No, that is not true. You do realize that the solution you provided in your first example raises <code>AttributeError: 'numpy.ndarray' object has no attribute 'append'</code>? Thus the solution in your comment does not work for the case you provided. And thus I added my first solution <b>which avoids the AttributeError</b>. Furthermore imho it is not ok to downvote a solution, just because it is obvious. It is a solution, it works and it was not in the minimum working example. If downvoting obvious solutions was the way to go on SO, 99% of the answers would be downvoted.</span>
<span class="comment-copy">Besides that Mad Physicist <b>did not get a downvote</b>, even though it was <b>also featuring the "obvious" solution</b>, and even though he posted his solution after mine. Imho both should be upvoted, because they <b>both solve the question</b>. Downvoting only one of them (and especially the one which solved it in the first place, while the second answer is more or less a copy of it) seems kind of strange to me. Would you like it if someone downvoted your answer, even though it solves the question? I am really sorry if I do not understand your motivation, but I will willingly listen to your opinion.</span>
