<div class="post-text" itemprop="text">
<p>I wrote a simple program to test if two words are anagrams(can be rearranged into another word). It seems to work at first, when I tested very different words, like "julio" and "cesar"(Those are my names) and it returned "false", but then I tested words with a difference of only one letter, like "julio" and "julis", but it returned "true". I would like to know what I did wrong. thanks in advance.
Sorry for not being too specific in the title, I don't know how to get much more specific than that</p>
<p>PS: The code is written in python if that helps</p>
<pre><code>import time, os

def detector():

    os.system('cls')
    input_1 = input("Enter the First word: \n")
    print("=" * 3 * len(input_1))
    input_2 = input("Enter the second word: \n")
    print("=" * 3 * len(input_1))

    win_index = 0

    input_1 = input_1.lower()
    input_2 = input_2.lower()

    if len(input_1) &lt; len(input_2):
        print("This is not a anagram")
        return False
    else:
        print("\nLoading...\n")
        time.sleep(1)
        for i in range(len(input_1)):
            if input_1[letter_index] in input_2:
                letter_index += 1
                print("This is a anagram")
                return True
                break
            else:
                print("This is not a anagram")
                return False

detector()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your biggest problem is here:</p>
<pre><code>if input_1[letter_index] in input_2:
    letter_index += 1
    print("This is a anagram")
    return True
    break
</code></pre>
<p>As soon as any letter in <code>input_1</code> is found in <code>input_2</code>, you're going to print out <code>This is an anagram</code> and then <code>return True</code>, without checking the rest of the letters. So, <code>julio</code> and <code>julis</code> match because <code>j</code> is in <code>julis</code>. In fact, <code>jordan</code> and <code>julis</code> also match because <code>j</code> is in <code>julis</code>.</p>
<p>The right logic here is that the words are only anagrams if, after you've checked <em>all</em> of them, <em>none</em> of them failed. Since you're going to <code>return False</code> on the first failure, you can just move that to the end of the loop—the only way you'll get past the loop is if you didn't <code>return False</code>.</p>
<p>Also, <code>letter_index</code> isn't defined anywhere. You probably wanted to use <code>i</code>?</p>
<p>So, replace your loop with this:</p>
<pre><code>for i in range(len(input_1)):
    if input_1[i] not in input_2:
        print("This is not a anagram")
        return False
print("This is an anagram")
return True
</code></pre>
<p>… or, better:</p>
<pre><code>for letter in input_1:
    if letter not in input_2:
        print("This is not a anagram")
        return False
print("This is an anagram")
return True
</code></pre>
<hr/>
<p>However, this still isn't right. For example, consider what happens if there are duplicate letters?</p>
<p>If you check <code>apple</code> against <code>aple</code>, it's going to pass. After all, <code>apple</code> isn't shorter than <code>aple</code>, and every letter in <code>apple</code> is also in <code>aple</code>. To fix that, you need to replace the <code>&lt;</code> check with a <code>!=</code> check:</p>
<pre><code>if len(input_1) != len(input_2):
</code></pre>
<hr/>
<p>But this still isn't right. What if you try <code>apple</code> vs. <code>aplee</code>? They're the same length, and every letter in <code>apple</code> is in <code>aplee</code>, and yet they aren't anagrams.</p>
<p>The only way around this is to make sure you only use each letter from <code>input_2</code> once.</p>
<p>You could do that by removing one copy of <code>letter</code> each time you use it:</p>
<pre><code>for letter in input_1:
    if letter not in input_2:
        print("This is not a anagram")
        return False
    else:
        input_2 = input_2.replace(letter, '', 1)
print("This is an anagram")
return True
</code></pre>
<hr/>
<p>This now works. But it's pretty clunky. It would be a lot better if you used a better data structure, like a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>, that's designed for looking up values and decrementing counts:</p>
<pre><code>from collections import Counter

counts = Counter(input_2)
for letter in input_1:
    if not counts[letter]:
        print("This is not an anagram")
        return False
    else:
        counts[letter] -= 1
</code></pre>
<p>But once you're using a <code>Counter</code>, you can make this even simpler:</p>
<pre><code>counts_1 = Counter(input_1)
counts_2 = Counter(input_2)
if counts_1 == counts_2:
    print("This is an anagram")
    return True
else:
    print("This is not an anagram")
    return False
</code></pre>
</div>
<span class="comment-copy">Where do you initialize <code>letter_index</code>?</span>
<span class="comment-copy">The easiest way to test for anagrams is <code>sorted(input_1)==sorted(input_2)</code>.</span>
<span class="comment-copy">The main problem is that you're doing <code>print("This is an anagram")</code> and <code>return True:</code> as soon as a single letter matches. What you want to do is take that out of the loop, and only do it at the end—you'll only get out of the loop if you never found a mismatch and hit the <code>return False</code>, so at that point, you know it was OK.</span>
<span class="comment-copy"><code>if len(input_1) &lt; len(input_2)</code> must be <code>if len(input_1) != len(input_2)</code>.</span>
<span class="comment-copy">But there are other problems here. For example, consider what happens if there are duplicate letters. Then, every letter in <code>input_1</code> might be in <code>input_2</code>, even though they aren't anagrams (and <code>input_1</code> isn't shorter). For example, it will tell you that <code>apple</code> and <code>aplee</code> are anagrams, or even <code>appleapple</code> and <code>elpa</code>.</span>
