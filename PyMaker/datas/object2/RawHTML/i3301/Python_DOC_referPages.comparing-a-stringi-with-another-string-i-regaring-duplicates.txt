<div class="post-text" itemprop="text">
<p>so the program asks for two strings then. the program should return text1 where each letter of the secret has been put in brackets.  So that if you read out only the letters of text1 that are in brackets you get the secret text.</p>
<p><strong>Examples</strong> </p>
<pre><code>enter text: qmweortnasdftzxcvyqwer
enter secret: monty
q[m]we[o]rt[n]asdf[t]zxcv[y]qwer

enter text: amaoa
enter secret: monty python
a[m]a[o]a

enter text: abcmasoaasnaataayas aspasyastashasoasnas
enter secret:monty
abc[m]as[o]aas[n]aa[t]aa[y]as aspas[y]astashasoasnas
</code></pre>
<hr/>
<p><strong>code</strong></p>
<pre><code>text = input("enter text: ")
secret = input("enter secret text: ")
len_text = len(text)
len_secret = len(secret)
final_answer = ""

for i in range(len_text):

    for k in range(len_secret):
        if secret[k] == text[i] and secret[k] not in final_answer:
            final_answer += "[" + secret[k] + "]"

    if text [i] not in final_answer: 
        final_answer += text[i]


print(final_answer)
</code></pre>
<hr/>
<p>error in code </p>
<p>I've tried a couple different ways but this is the closest code I can come up with that gets me closer to the answer. all the others I have tried end up with more letters or repeats. </p>
<pre><code>enter text: monty python
enter secret: monty python

 [m][o][n][t][y][ ][p][h]&lt;&lt;&lt;my output
 [m][o][n][t][y][ ][p][y][t][h][o][n]&lt;&lt;&lt;expected output

enter text:   aamaonataayaa paaayatahaaaoaanaaaaapp
enter secret text:  monty python

a[m][o][n][t][y][ ][p][h]&lt;&lt;&lt;my output
aa[m]a[o][n]a[t]aa[y]aa[ ][p]aaa[y]a[t]a[h]aaa[o]aa[n]aaaaapp&lt;&lt;&lt;expected output

enter text: abcmasoaasnaataayas aspasyastashasoasnas
enter secret:monty

abc[m]as[o]aas[n]aa[t]aa[y]as aspasyastashasoasnas&lt;&lt;&lt;your output
abc[m]as[o]aas[n]aa[t]aa[y]as aspas[y]astashasoasnas&lt;&lt;&lt;expected output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The root problem here is that you're thinking in terms of sets.</p>
<p>First, either a letter is a member of <code>secret</code>, or it isn't. So, each letter that's in <code>secret</code> is a member of <code>secret</code> no matter how many times it appears, so you end up with too many duplicates—<code>hello</code> and <code>lo</code> will give you <code>he[l][l][o]</code> instead of just <code>he[l]l[o]</code>.</p>
<p>You attempt to fix that by using <em>another</em> set, the set of letters used so far, but that has the same problem: either a letter has been used so far, or it hasn't. So now you end up using each letter only once, even if it appears multiple times in <code>secret</code>, and you have no duplicates at all: <code>hello</code> and <code>hello</code> gives you <code>[h][e][l]l[o]</code> instead of <code>[h][e][l][l][o]</code>.</p>
<p>The key is that <code>secret</code> is not a set, it's a <em>multiset</em>: letters don't just appear or not appear, they appear <em>a certain number of times</em>. You want to use each letter in <code>secret</code> as many times as it appears—not infinite times, not just once. The only way to do this is to keep track of how many times it appears, and how many times you've used it.</p>
<hr/>
<p>The smallest change that would fix this is to just remove each letter as you find it. Like this:</p>
<pre><code>for letter in text:
    if letter in secret:
        secret = secret.remove(letter, 1) # use it up
        final_answer += "[" + letter + "]"
    else:
        final_answer += letter
</code></pre>
<hr/>
<p>But a much nicer solution is to actually store the secret letters as a multiset. That's exactly what <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> does:</p>
<pre><code>from collections import Counter
secret = Counter(secret)
for letter in text:
    if secret[letter]:
        secret[letter] -= 1 # use it up
        final_answer += "[" + letter + "]"
    else:
        final_answer += letter
</code></pre>
<p>This doesn't look much different on the surface, but if you look at what's happening under the covers, it's a lot simpler.</p>
<p>When <code>secret</code> is a string, <code>if letter in secret</code> actually has to search every character of the string and compare it to <code>letter</code>. And then, <code>secret.remove(letter, 1)</code> has to search the string all over again to find the same letter, and then it has to copy the whole string minus that letter into a new string to return to you.</p>
<p>When <code>secret</code> is a Counter, <code>if letter in secret</code> just looks up <code>letter</code> in the hash table and checks the number there. And then, <code>secret[letter] -= 1</code> just decrements the number. Instead of two linear searches and a linear copy, we're just doing a direct lookup and subtraction.</p>
<p>Of course the performance is unlikely to matter in this case. And Python wraps up all that linear searching and copying so it looks easy, even if what happens under the covers isn't. So, if you're having a hard time understanding how Counter works, or what a multiset is, don't feel too bad about sticking with the string, but make a note to come back later and see if you can see the differences once you've learned a bit more.</p>
<hr/>
<p>However, although this solves all of your examples correctly, I'm still not sure you're describing the problem correctly. You can only "read out the secret text" if all of the letters in <code>secret</code> happen to appear in the same order as in <code>text</code>. That happens to be true in all of your examples, but what's the right answer for, say, <code>abcdeabcde</code> and <code>db</code>? Should it be <code>a[b]c[d]eabcde</code>, or should it be <code>abc[d]ea[b]cde</code>? </p>
<p>If it's the latter, and the order of <code>secret</code> matters, then we don't want a set, or a multiset, we want a list. And we only want to check the first letter of it each time.</p>
<p>The smallest change, then, is:</p>
<pre><code>for letter in text:
    if secret and secret[0] == letter:
        secret = secret[1:] # use it up
        final_answer += "[" + letter + "]"
    else:
        final_answer += letter
</code></pre>
<p>Notice that I'm checking <code>secret</code> before checking <code>secret[0] == letter</code>. This is because, after we've used up all the letters in <code>secret</code>, there is no more <code>secret[0]</code>, so that would give us an <code>IndexError</code>.</p>
<hr/>
<p>There's no more double-linear-searching, of course, but we're still copying the string each time. A cleaner solution would be to use a list, where just popping the last value off is instantaneous:</p>
<pre><code>secret = list(secret)[::-1]
for letter in text:
    if secret and secret[-1] == letter:
        secret.pop() # use it up
        final_answer += "[" + letter + "]"
    else:
        final_answer += letter
</code></pre>
</div>
<span class="comment-copy">It looks like your code implements exactly what you say it should, but your expected output doesn't have duplicates removed. So presumably that wasn't actually part of the assignment, and you shouldn't have added it. If you just remove the code that does that part (the <code>not in final_answer</code> checks), it'll work.</span>
<span class="comment-copy">if i remove the not in final part i end up with dulicates of the same letter because of the for loop in regards to k  @abarnert</span>
<span class="comment-copy">Yes, exactly. And the expected output <i>has</i> duplicates of the same letter. That's what it's complaining about.</span>
<span class="comment-copy">i have updated with a more accurate example @abarnert</span>
<span class="comment-copy">I think your examples are still incomplete. If I type <code>abcdeabcde</code> and <code>db</code>, should I get <code>a[b]c[d]eabcde</code>, or <code>abc[d]ea[b]cde</code>? In other words, do I have to use up the letters of <code>secret</code> in the order given?</span>
<span class="comment-copy">after reading the assignment I believe it has to be in the order of secret and it also seems like the last letter of secret continues to be counted all the way through. I have updated examples to reflect this</span>
<span class="comment-copy">@AngelValenzuela If you're doing one of those online course things, they tend to give you examples that only cover a few of the rules in the assignment, and then keep the tests that cover all the other rules secret. So you need to figure out how to come up with tests for all the other rules first. You can go too far with that methodology (unless you're applying to be a Ruby programmer at a hardcore Rails shop, in which case you should probably spend your entire interview writing test for your code to fail and not actually coding anything that works), but in moderation it's a good habit.</span>
