<div class="post-text" itemprop="text">
<p>I am a bit of a Python newbie regarding classes. I have seen that some scripts include lines which appear to "multiply" instances of classes together. For example:</p>
<pre><code>Z = X * Y
</code></pre>
<p>where X and Y are instances of two different classes. </p>
<p>What does the * symbol mean and how is it applied to classes (or instances of classes) in Python?</p>
<p>In most cases * pertains to multiplication, but I don't understand what it means to "multiply" classes.</p>
<p>Any info is appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>*</code> operator just means "multiply".</p>
<p>But what it means for two objects to be multiplied is up to those objects' types to decide.</p>
<p>For all of the builtin and stdlib types, it means multiplication if that makes sense, or it's a <code>TypeError</code> if that doesn't make sense. For example:</p>
<pre><code>&gt;&gt;&gt; 2 * 3
6
&gt;&gt;&gt; (1, 2, 3) * 3
(1, 2, 3, 1, 2, 3, 1, 2, 3)
&gt;&gt;&gt; "abc" * "def"
TypeError: can't multiply sequence by non-int of type 'str'
</code></pre>
<p>Since multiplication doesn't make sense for class objects, they're one of the kinds of things where it's a <code>TypeError</code>:</p>
<pre><code>&gt;&gt;&gt; class C: pass
&gt;&gt;&gt; C * 2
TypeError: unsupported operand type(s) for *: 'type' and 'int'
</code></pre>
<hr/>
<p>If you (or a third-party library author) create a new type, you can decide what multiplication means. The way you do this is covered under <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">Emulating numeric types</a> in the documentation, but the short version is that you define a <code>__mul__</code> method:</p>
<pre><code>class MyNumberyThing:
    def __init__(self, n):
        self.n = n
    def __repr__(self):
        return f'MyNumberyType({self.n})'
    def __mul__(self, other):
        if isinstance(other, MyNumberyThing):
            return MyNumberyThing(self.n * other.n)
        elif isinstance(other, int):
            return MyNumberyThing(self.n * other)
        elif isinstance(other, float):
            raise TypeError("sorry, can't multiply by float because of precision issues")
        else:
            raise TypeError(f"sorry, don't know how to multiply by {type(other).__name__}")
</code></pre>
<p>Notice that this makes <em>instances of</em> <code>MyNumberyThing</code> multiplicable. It doesn't make <code>MyNumberyThing</code> itself multiplicable (<code>MyNumberyThing</code> isn't a <code>MyNumberyThing</code>, it's a <code>type</code>):</p>
<pre><code>&gt;&gt;&gt; n = MyNumberyThing(2)
&gt;&gt;&gt; n * 3
MyNumberyType(6)
&gt;&gt;&gt; MyNumberyThing * 3
TypeError: unsupported operand type(s) for *: 'type' and 'int'
</code></pre>
<hr/>
<p>Of course nothing's stopping you from defining something ridiculous:</p>
<pre><code>class MySillyThing:
    def __mul__(self, other):
        self.storage = -other
        print(f'I took your {other}')

&gt;&gt;&gt; silly = MySillyThing()
&gt;&gt;&gt; silly * 3
I took your 3
&gt;&gt;&gt; silly.storage
-3
</code></pre>
<p>… except, of course, for the fact that nobody would understand your code. (And that "nobody" includes you, 6 months later trying to debug something you thought you were done with…)</p>
<hr/>
<p>As a side note, Python actually has two ways to spell "multiply": <code>*</code> and <code>@</code>.</p>
<p>The builtin types all ignore <code>@</code>, so you'll just get a <code>TypeError</code> if you try to use it. What it's there for is, basically, so NumPy can use <code>*</code> for elementwise multiplication, and <code>@</code> for matrix multiplication. (The <code>@</code> operator's magic method is even called <code>__matmul__</code>.) But of course other third-party libraries that similarly needed to do two different kinds of multiplication could use <code>@</code> for the second kind.</p>
</div>
<span class="comment-copy">See also <a href="https://stackoverflow.com/questions/6892616/python-multiplication-override" title="python multiplication override">stackoverflow.com/questions/6892616/…</a></span>
<span class="comment-copy">Classes and instances of classes are completely different concepts. The terms are not interchangeable.</span>
<span class="comment-copy">It's up to the class itself to determine what it means to multiply instances, by defining the <a href="https://docs.python.org/3/reference/datamodel.html#object.__mul__" rel="nofollow noreferrer"><code>__mul__</code></a> method.</span>
<span class="comment-copy">It's just convenient syntax for a binary operation taking two operands. You can make it mean whatever you like. It's good to make it make sense though and can improve the readability of code. If it isn't a good abstraction it can make code more difficult to understand as well, so use wisely.</span>
