<div class="post-text" itemprop="text">
<p>I need help to get a random 4 digit long number with no repeated digits inside the number so I have </p>
<pre><code>import random
numbers = random.sample(range(10), 4)
</code></pre>
<p>Would this be the best way to go at it?
I also need help with making sure the first digit is not 0, how could I do that? Cheers for the input</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to extend your solution to make sure the leading digit isn't 0, there's probably no super-concise way to write it; just be explicit:</p>
<pre><code>first = random.choice(range(1, 10))
leftover = set(range(10)) - {first}
rest = random.sample(leftover, 3)
digits = [first] + rest
</code></pre>
<hr/>
<p>Notice that I'm taking advantage of the fact that <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>sample</code></a> takes a sequence or set. In older versions of Python, it required a sequence. According to <a href="https://docs.python.org/2/library/random.html#random.sample" rel="nofollow noreferrer">the 2.7 docs</a>, this includes 2.7—but CPython and PyPy 2.7 both take a set anyway. Anyway, if this is a problem, you can just do <code>leftover = [val for val in range(10) if val != first]</code>.</p>
<hr/>
<p>One more thing to consider, if performance matters. A nondeterminstic solution like <a href="https://stackoverflow.com/a/51251570/908494">noskio's answer</a> obviously has unbounded worst-case time, but it could be significantly faster in almost every case. There's a 90% chance you'll get your answer the first time, and a 99.9999999% within the first ten loops, and it's at least plausible that a single call to <code>sample</code> could be about an order of magnitude faster than multiple set operations, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you allow the first digit to be zero (such as 0123 instead of 123), then you will need your result to be a string. To do this, I would suggest <code>random.sample(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], 4)</code>. Alternatively, <code>random.sample([str(x) for x in range(10)], 4)</code>.</p>
<p>Otherwise, abarnert's answer works.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following code does the job:</p>
<pre><code>import random

a = random.sample(range(10),3)
number = int(str(random.randint(1,9)) + str(a[0]) + str(a[1]) + str(a[2]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>random.sample()</code> makes sure you get no repeated digits, but the first digit can be zero, so can re-randomize in this case</p>
<pre><code>while True:
    number = ''.join(str(x) for x in random.sample(range(10), 4))
    if not number.startswith('0'):
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>permutations</code> from <code>itertools</code>:</p>
<pre><code>from random import choice
from itertools import permutations

while True:
    v = choice(list(permutations('0123456789', 4)))
    if v[0] != '0':
        break
print(''.join(v))
</code></pre>
<p>Sample output:</p>
<pre><code>3597
</code></pre>
<p>Edit: <code>permutations</code>, no <code>product</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You should import the random library first on python IDE.</p>
<pre><code>import random
a = random.randint(1000,9999)
print(a)
</code></pre>
</div>
<span class="comment-copy">Sample output: 3664. This does nothing to avoid duplicates, and it generally just a much more complicated and wasteful way to do what some of the other incomplete answers already do.</span>
<span class="comment-copy">@abarnert I corrected the answer, using permutations, no product</span>
<span class="comment-copy">OK, now it's not <i>incorrect</i>, but it's still just an overcomplicated and wasteful way to do what noskio's answer does. Why generate and store 5040 values when you only need one of them? The only possible advantage is the fact that you could filter out the leading-0 values before choice, so you don't have infinite worst-case time like noskio's answer, but you don't even take that advantage.</span>
<span class="comment-copy">@abarnert I know It's not speed-wise ideal way to do it, but for inspiration It could be useful.</span>
<span class="comment-copy">Not just speed-wise; this is also conceptually more complicated than noskio's answer—and the OP's original code—and it misleadingly seems like it might be better in some way, but isn't. In fact, speed-wise is the only real justification you could give for this answer—again, if you changed it to filter out the 0s before choice instead of looping, you'd be trading much worse average-case performance for eliminating the unbounded worst-case, and that might be worth explaining, but without that, you're just trading much worse average-case performance for even worse unbounded worst-case…</span>
<span class="comment-copy">This does not meet the criteria of the question. There's nothing stopping you getting <code>1777</code>, for example, which the OP has said they don't want (repeated digits). There's also a perfectly good answer.</span>
<span class="comment-copy">Exactly as said above, this answer can still print repeated digits, which is not the requirement.</span>
