<div class="post-text" itemprop="text">
<p>I'm trying to implement a simple actor system in Python to develop some insight regarding concurrent programming.</p>
<p>My main concern has been around the generic task of composing futures in Python, using the <code>asyncio</code> module.</p>
<p>Let's say I have an event loop running on a separate Thread.</p>
<pre><code>import asyncio

from threading import Thread

loop = asyncio.new_event_loop()


def run_event_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()


t = Thread(target=run_event_loop, args=(loop,))
t.start()
</code></pre>
<p>In order to avoid synchronous communication, I need to be able to compose the <code>Futures</code> somehow. As a simple example suppose I wanted to combine the results of two <code>async</code> coroutines.</p>
<p>My first (obviously wrong) attempt:</p>
<pre><code>async def f(x):
    fut = asyncio.run_coroutine_threadsafe(g(x / 2), loop)
    return fut

async def g(x):
    return x * 2
</code></pre>
<p><code>f(x) = x / 2</code></p>
<p><code>g(x) = x * 2</code></p>
<p><code>f(g(x)) = x</code></p>
<p>I'm not being able to derive a clean solution to deal the following general problem:</p>
<pre><code>x = 10

future = asyncio.run_coroutine_threadsafe(f(x), loop)

print(future)                    # &lt;Future at 0x106f797f0 state=pending&gt;

print(future.result())           # &lt;Future at 0x10677c780 state=finished returned float&gt;

print(future.result().result())  # 10.0
</code></pre>
<p>Ideally, I should combine the futures and perform a single <code>future.result()</code> at the end. Or perhaps I'm thinking about all of this wrongly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The root problem here is:</p>
<pre><code>fut = asyncio.run_coroutine_threadsafe(g(x / 2), loop)
</code></pre>
<p>You're inside an <code>async</code> function, and trying to run another async function in the same event loop in the same thread. You don't need <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>run_coroutine_threadsafe</code></a> for that; just <code>await</code> it.</p>
<p>What happens if you call <code>run_coroutine_threadsafe</code> anyway? Then what you get back is a <code>concurrent.futures.Future</code>. As explained at the top of the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> docs, this is not the same thing as an <code>asnycio.Future</code>—which is designed to <em>mimic</em> a concurrent future, but under the covers it's a different thing. You can compose two asyncio futures (from the same event loop), you can compose two concurrent futures, but you can't compose a concurrent future with an asyncio future.</p>
<p>You can wrap a concurrent future in an async future (directly with <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wrap_future" rel="nofollow noreferrer"><code>wrap_future</code></a>, or, more commonly, indirectly through <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executor" rel="nofollow noreferrer"><code>run_in_executor</code></a>). But then what you're going to end up with is a concurrent future holding an async future wrapping a concurrent future, which still can't be composed.</p>
</div>
<span class="comment-copy">Are you asking about the futures from <code>concurrent.futures</code>, as your title and tags and description imply, or the ones from <code>asyncio</code>, as your sample code implies? As the docs make clear, they are not the same type; the one in <code>asyncio</code> mimics the one in <code>futures</code> as closely as is reasonable, but they can't be used interchangeably. (And notice that there's an <code>asyncio.Executor</code> that wraps concurrent futures in asyncio futures; you should never be using a concurrent future directly in asyncio code.)</span>
<span class="comment-copy">I edited the title. <code>type(future)</code> gives <code>&lt;class 'concurrent.futures._base.Future'&gt;</code>, so I wrongly assumed they were the same</span>
<span class="comment-copy">No, this <i>is</i> a concurrent future here, because you're using <code>run_coroutine_threadsafe</code> and getting the result back in a different thread. Mixing the two is confusing.</span>
<span class="comment-copy">Anyway, does <code>f</code> actually need to run <code>g</code> thread-safe like that, even though it's actually running <code>g</code> on the same event loop in the same thread? If so, you can't directly compose the resulting concurrent future with an asyncio future, and I think that's the problem you're trying to solve. If you don't need that, then your problem goes away.</span>
<span class="comment-copy">You're right I just need to do <code>res = await g(x / 2)</code></span>
<span class="comment-copy">I think the last sentence has it backward: if one wrapped the concurrent future in an async future, they'd end up with an async future (that wraps a concurrent future that wraps an async future). I was half-expecting that awaiting such a future would deadlock due to at least one of <code>wrap_future</code> and <code>run_coroutine_threadsafe</code> expecting the futures to run in a separate thread, but <a href="https://pastebin.com/9mcv4RFZ" rel="nofollow noreferrer">it seems to work</a>. The rest of your answer is of course completely correct.</span>
<span class="comment-copy">@user4815162342 You’re got two calls to <code>run_coroutine_threadsafe</code>, so you inherently have an outer concurrent future, and an inner one; if you wrap the inner one first, you have a concurrent wrapping and async wrapping a concurrent. And you can’t have another async one outside the top level, because you don’t have an event loop in the main thread.</span>
<span class="comment-copy">You're right, I missed the specifics of the question, which indeed don't make much sense. (But your answer is great at clearing away the confusion.) I took the last paragraph to refer to the general case of using <code>wrap_future</code> on a concurrent future obtained with <code>run_coroutine_threadsafe</code>, which actually seems to work, even if wasteful and unnecessary.</span>
<span class="comment-copy">@user4815162342 Anyway, I was surprised at first that there’s no deadlock, but consider this: You have a chat server running on a pool of threads each running an event loop. The coro for user X wants to wait on something for user Y, so it does a threadsafe run on whichever loop Y is on. If that deadlocked when X and Y were on the same loop, you’d need to write extra code to distinguish that case. If Guido thought of that, and put the extra code in the library to support waiting on a concurrent future from your own thread, it would handle this case as well.</span>
