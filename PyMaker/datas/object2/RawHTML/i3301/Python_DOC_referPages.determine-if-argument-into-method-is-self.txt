<div class="post-text" itemprop="text">
<p>In the question <a href="https://stackoverflow.com/q/847936/1079075">How can I find the number of arguments of a Python function?</a> code is given showing how to using <code>inspect.getfullargspec</code> to get information of a function. However, is there any way to verify whether one of the arguments for the function is <code>self</code>? In Python 3, <code>inspect.signature</code> automatically removes the <code>self</code> argument for you. Is it possible to accomplish the same thing Python 2, by somehow check if the first argument of a given function is a reference to the method's object?</p>
<p>For example, the first argument in the function <code>step</code> is technically <code>self</code> even though someone has decided to be evil and rename <code>self</code> to <code>what</code>.</p>
<pre><code>class TestNode(object):

    def __init__(what, bias=0):
        what.bias = bias

    def update(what, t, x):
        return t / x * what.bias
</code></pre>
<p>However, the first argument in the function <code>lambda self: self+1</code> despite someone being evil and naming an argument <code>self</code> is not actually the <code>self</code> using in Python objects. </p>
</div>
<div class="post-text" itemprop="text">
<p>If we take a step back from argument inspection and think of this question as a question of determining if a function is a method or not. We can do this with the <a href="https://docs.python.org/3.7/library/inspect.html#inspect.ismethod" rel="nofollow noreferrer"><code>inspect.ismethod</code></a> function:</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; class Foo:
...     def bar(self):
...         pass
...
&gt;&gt;&gt; inspect.ismethod(Foo().bar)
True
</code></pre>
<p>If the function is a bound method we can safely assume that the first passed argument to this method will be <code>self</code>.</p>
<p>Note that in Python 2.X, this will return True for unbound methods (e.g. <code>Foo.bar</code>) whereas in 3.X it will return True only if the method is bound.</p>
<p>We can take this one step further by using <a href="https://docs.python.org/3.7/library/inspect.html#types-and-members" rel="nofollow noreferrer">getmembers</a> and actually determine what the value of <code>self</code> is for this bound method:</p>
<pre><code>&gt;&gt;&gt; dict(inspect.getmembers(Foo()))["bar"].__self__
&lt;__main__.Foo object at 0x7f601eb50a58&gt;
</code></pre>
<p>Which returns the <code>Foo()</code> instance that this <code>bar</code> method is bound to. In Python 2.X, <code>__self__</code> will be <code>None</code> if the instance is unbound, which is how you differentiate between bound and unbound methods.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self</code> is not a special argument. The name <code>self</code> has nothing special at all - It is a normal argument just like the others, the only reason it is named <code>self</code> is convention between the programmers.</p>
<p>There is no way you can differentiate a <code>self</code> argument from other arguments, because it is not different at all!</p>
<p>What you can do is check if the function is member of a class - then it becomes a method and will get the instance as first parameter automatically - this is done by the <strong>metaclass descriptors</strong> as you can see <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">here in the documentation</a>.</p>
<p>if <code>inspect.ismethod()</code> returns <code>True</code> then the first parameter passed to the function will be the instance, regardless of the name.</p>
</div>
