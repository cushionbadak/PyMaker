<div class="post-text" itemprop="text">
<p>My hope is to make attributes case-insensitive. But overwriting <code>__getattr__</code> and <code>__setattr__</code> are somewhat different, as indicated by the following toy example:</p>
<pre><code>class A(object):

    x = 10

    def __getattr__(self, attribute):
        return getattr(self, attribute.lower())

    ## following alternatives don't work ##

#    def __getattr__(self, attribute):
#        return self.__getattr__(attribute.lower()) 

#    def __getattr__(self, attribute):
#        return super().__getattr__(attribute.lower()) 

    def __setattr__(self, attribute, value):
        return super().__setattr__(attribute.lower(), value)

    ## following alternative doesn't work ##

#    def __setattr__(self, attribute, value):
#        return setattr(self, attribute.lower(), value)

a = A()
print(a.x) ## output is 10
a.X = 2
print(a.X) ## output is 2
</code></pre>
<p>I am confused by two points.</p>
<ol>
<li>I assume <code>getattr()</code> is a syntactic sugar for <code>__getattr__</code>, but they behave differently.</li>
<li>Why does <code>__setattr__</code> need to call <code>super()</code>, while <code>__getattr__</code> doesn't?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I assume <code>getattr()</code> is a syntactic sugar for <code>__getattr__</code>, but they behave differently.</p>
</blockquote>
<p>That's because the assumption is <em>incorrect</em>. <code>getattr()</code> goes through the entire attribute lookup process, of which <code>__getattr__</code> is only a part. </p>
<p>Attribute lookup first invokes a <em>different</em> hook, namely the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code> method</a>, which by default performs the familiar search through the instance dict and class hierarchy. <code>__getattr__</code> will be called only if the attribute hasn't been found by <code>__getattribute__</code>. From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code> documentation</a>:</p>
<blockquote>
<p>Called when the default attribute access fails with an <code>AttributeError</code> (either <code>__getattribute__()</code> raises an <code>AttributeError</code> because <em>name</em> is not an instance attribute or an attribute in the class tree for <code>self</code>; or <code>__get__()</code> of a <em>name</em> property raises <code>AttributeError</code>).</p>
</blockquote>
<p>In other words, <code>__getattr__</code> is an <em>extra</em> hook to access attributes that don't exist, and would otherwise raise <code>AttributeError</code>.</p>
<p>Also, functions like <code>getattr()</code> or <code>len()</code> are <em>not syntactic sugar for a dunder method</em>. They almost always do more work, with the dunder method a <em>hook</em> for that process to call. Sometimes there are multiple hooks involved, such as here, or when creating an instance of a class by calling the class. Sometimes the connection is fairly direct, such as in <code>len()</code>, but even in the simple cases there are additional checks being made that the hook itself is not responsible for.</p>
<blockquote>
<p>Why does <code>__setattr__</code> need to call <code>super()</code>, while <code>__getattr__</code> doesn't?</p>
</blockquote>
<p><code>__getattr__</code> is an <em>optional</em> hook. There is no default implementation, which is why <code>super().__getattr__()</code> doesn't work. <code>__setattr__</code> is <em>not</em> optional, so <code>object</code> provides you with a default implementation.</p>
<p>Note that by using <code>getattr()</code> you created an infinite loop! <code>instance.non_existing</code> will call <code>__getattribute__('non_existing')</code> and then <code>__getattr__('non_existing')</code>, at which point you use <code>getattr(..., 'non_existing')</code> which calls <code>__getattribute__()</code> and then <code>__getattr__</code>, etc.</p>
<p>In this case, you should override <code>__getattribute__</code> instead:</p>
<pre><code>class A(object):
    x = 10

    def __getattribute__(self, attribute):
        return super().__getattribute__(attribute.lower())

    def __setattr__(self, attribute, value):
        return super().__setattr__(attribute.lower(), value)
</code></pre>
</div>
<span class="comment-copy"><code>__getattr__</code> is called for any attribute that doesn't exist; you don't want to create an infinite loop by using <code>getattr()</code> on a non-existing attribute!</span>
<span class="comment-copy">As a side note, you’re missing <code>__delattr__</code> here. And that also implies that you’re trying to learn how to do this without reading the Data Model docs on customizing attribute access, which explains a lot of your confusion. There’s not that much to it (although the interactions with things like descriptors, type objects, etc. can get complex, you don’t need to worry about that yet), and the docs explain it nicely, while it’s not the kind of thing where you can just guess how it might work and go from there.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer">Here's a link</a>. Notice that it directly explains the "an intentional asymmetry between <code>__getattr__()</code> and <code>__setattr__()</code>" that you're asking about, and also explains how <code>__setattr__</code> should use a base class method, and so on.</span>
<span class="comment-copy">It might also be worth explaining that <code>spam(x)</code> is <i>never</i> syntactic sugar for <code>x.__spam__()</code>, rather than just in the case of <code>__getattr__</code>. For example, <code>bool(x)</code> tries <code>x.__bool__</code> then <code>x.__len__</code>; <code>iter(x)</code> tries <code>x.__iter__</code> then <code>__len__</code> and <code>__getitem__</code>; <code>x+y</code> tries <code>x.__add__(y)</code> and <code>y.__radd__(x)</code> (in order depending on the type relationship); etc. Calling the dunder methods directly is not something you want to do except in specific special cases (like calling your super's <code>__setattr__</code>).</span>
<span class="comment-copy">@abarnert: yes, and even in the simple cases such as <code>len()</code> calling <code>__len__</code> there are type and boundary checks you don't necessarily want to bypass.</span>
<span class="comment-copy">I'm sure you remember the question from the guy who wanted to call <code>__len__</code> as an optimization, to avoid all that wasted time converting <code>AttributeError</code> to <code>TypeError</code>, and insisted <code>timeit</code> must be broken because it said his code was slower instead of faster, and refused to accept that it takes time to look up, build, and call a bound method…</span>
