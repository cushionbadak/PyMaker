<div class="post-text" itemprop="text">
<p>Suppose I have something like:</p>
<pre><code>a = "Gżegżółka"
a = bytes(a, 'utf-8')
a = str(a)
</code></pre>
<p>which returns string in form:</p>
<pre><code>b'G\xc5\xbceg\xc5\xbc\xc3\xb3\xc5\x82ka'
</code></pre>
<p>Now it's send as simple string (I get it as assertion from <code>eval</code> function). How the heck can I now get normal UTF-8 form of starting word? If there is some better compression than <code>str(bytes(x))</code> then I would be glad to hear.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to encode and decode text, that's what the <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>encode</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer"><code>decode</code></a> methods are for:</p>
<pre><code>&gt;&gt;&gt; a = "Gżegżółka"
&gt;&gt;&gt; b = a.encode('utf-8')
&gt;&gt;&gt; b
b'G\xc5\xbceg\xc5\xbc\xc3\xb3\xc5\x82ka'
&gt;&gt;&gt; c = b.decode('utf-8')
&gt;&gt;&gt; c
'Gżegżółka'
</code></pre>
<p>Also, notice that UTF-8 is already the default, so you can just do this:</p>
<pre><code>&gt;&gt;&gt; b = a.encode()
&gt;&gt;&gt; c = b.decode()
</code></pre>
<p>The only reason you need to specify arguments is:</p>
<ul>
<li>You need to use some other encoding instead of UTF-8,</li>
<li>You need to specify a specific error handler, like <code>'surrogatereplace'</code> instead of <code>'strict'</code>, or</li>
<li>Your code has to run in Python 3.0-3.1 (which almost nobody used).</li>
</ul>
<hr/>
<p>However, if you really want to, you <em>can</em> do what you were already doing; you just need to explicitly specify the encoding in the <code>str</code> call, just as you did in the <code>bytes</code> call:</p>
<pre><code>&gt;&gt;&gt; a = "Gżegżółka"
&gt;&gt;&gt; b = bytes(a, 'utf-8')
&gt;&gt;&gt; b
b'G\xc5\xbceg\xc5\xbc\xc3\xb3\xc5\x82ka'
&gt;&gt;&gt; c = str(b, 'utf-8')
&gt;&gt;&gt; c
</code></pre>
<p>Calling <code>str</code> on a <code>bytes</code> object without an encoding, as you were doing, doesn't decode it, and doesn't raise an exception like calling <code>bytes</code> on a <code>str</code> without an encoding, because the main job of <code>str</code> is to give you a string representation of the object—and the best string representation of a <code>bytes</code> object is that <code>b'…'</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found it. The simplest way to convert string representation of bytes to bytes again is through the <code>eval</code> statement:</p>
<pre><code>a = "Gżegżółka"
a = bytes(a, 'utf-8')
a = str(a) #this is the input we deal with

a = eval(a) #that's how we transform a into bytes
a = str(a, 'utf-8') #...and now we convert it into string

print(a)
</code></pre>
</div>
<span class="comment-copy">I don't know what you mean by "I get it as assertion from <code>eval</code> function", but that sounds like you're doing something that's a very bad idea in code right outside the code that you showed us…</span>
<span class="comment-copy">As @abarnert commented it looks like you are trying to fix the wrong code but if you are going to do this at least use <code>ast.literal_eval</code> instaed of <code>eval</code>.</span>
<span class="comment-copy">Welp, now I found that I just load script without utf-8 encoding. But still, I think that trying to decipher str(bytes(x)) is interesting problem :)</span>
<span class="comment-copy">I don't know what you are talking about, there is nothing like that in your question. As you found out you can reconstruct a bytes object from its string representation but you cannot do that with arbitrary objects so I would say a more interesting problem is how you managed to paint yourself into that corner and how to avoid it.</span>
