<div class="post-text" itemprop="text">
<p>I am writing a script that uses a queue to track the last six numbers of a list of length N. In other words, as I iterate over the list of length N, I want to track the last six numbers. I thought a queue would be a good structure to do this because it would automatically push out the last 6th number as I push in a new number. My code is below:</p>
<pre><code>if __name__ == '__main__':

    data = [1,23,45,5,43,2,54,2,34,32]
    scub = DataScrubber(data)
    scub.scrub_zeros(0.01)

    print "TEST"


def scrub_zeros(self,upperzero_range):
        scrubbed_data = [] 
        last_6_data_points = Queue.Queue(6)

        for data in self.data:
            print last_6_data_points
            print scrubbed_data
            last_6_data_points.put(data)
            scrubbed_data.append(data)  
        self.data = scrubbed_data
</code></pre>
<p>When I run this script I get the following output:</p>
<pre><code>&lt;Queue.Queue instance at 0x03E25D00&gt;
[]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1, 23]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1, 23, 45]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1, 23, 45, 5]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1, 23, 45, 5, 43]
&lt;Queue.Queue instance at 0x03E25D00&gt;
[1, 23, 45, 5, 43, 2]
</code></pre>
<p>However, this script never stops running. It freezes and I have to break out using ctrl+break. So after thinking, I figured out the reason why it is freezing. It freezes because when I <strong>"put"</strong> data into the queue, is doesn't automatically push ot the older data at the other end of the queue. So I guess that the queue is stuck. Am I missing something, is that not suppose to be the point of how a queue works? Do I have to call "get"? Is there anyway around having to call another function for the queue, where it will automatically push out the oldest data when new data is pushed into the queue?</p>
<p>My second question:</p>
<p>How can I view the entire queue like a list? So:</p>
<pre><code>print my_queue
</code></pre>
<p>Results in:</p>
<pre><code>[null,1, 23, 45, 5, 43]
</code></pre>
<p>after pushing in 5 numbers into 6 line queue.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Queue</code>s don't evict entries when they hit their maximum size, they block when you try to <code>put</code> an entry in that would exceed their maximum size (that's why your program stalls). They're designed for atomic interthread communication, so viewing their contents isn't a design goal, it's to allow <code>get</code>-ing and <code>put</code>-ing in a thread-safe way (with blocking when appropriate).</p>
<p>Since you're not using the interthread hand-off with blocking features of <code>Queue</code>, you don't really want a <code>Queue</code> at all, you want <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow"><code>collections.deque</code></a> with a <code>maxlen</code>.</p>
<pre><code>from collections import deque

...

def scrub_zeros(self,upperzero_range):
    scrubbed_data = [] 
    last_6_data_points = deque([None]*6, maxlen=6)

    for data in self.data:
        print last_6_data_points
        print scrubbed_data
        last_6_data_points.append(data)
        scrubbed_data.append(data)  
    self.data = scrubbed_data
</code></pre>
<p>The stringification of a <code>deque</code> will show the elements but it will include extra kruft; if you want it to look <code>list</code>-like w/o the kruft, change the <code>print</code> to <code>print list(last_6_data_points)</code>.</p>
</div>
<span class="comment-copy">This will print <code>None</code>, not <code>null</code> for the unfilled entries, but I'm assuming that's okay. You could change it to the <code>str</code>, <code>"null"</code> if you want (though that will print with quotes around it); if that's not acceptable, you'd need to format the output yourself instead of relying of the <code>list</code> <code>repr</code> to do it for you.</span>
<span class="comment-copy">null was pseudo code. I will take a closer look at your code. Thanks.</span>
<span class="comment-copy">@budder: Okay. Usually, I'd omit the initializer and just have a <code>maxlen</code>, because having filler entries doesn't really gain you anything, but your example showed filler so I provided it. If you don't need the filler, just initialize with: <code>last_6_data_points = deque(maxlen=6)</code></span>
<span class="comment-copy">Reviewed your code. It works well however I would make one modification. Eventually I will need to access the last_6_data_points and therefore, I want the actual list of data: list(last_6_data_points).</span>
<span class="comment-copy">@budder: You can access the values from <code>last_6_data_points</code> without converting to a <code>list</code>. <code>deque</code>s iterate the same as a <code>list</code>, <code>for item in mydeque:</code> works the same as <code>for item in mylist:</code> (because they're both sequences). Since the <code>deque</code> is so short, it doesn't even have the negatives normally associated with <code>deque</code>s (that indexing near the middle of the <code>deque</code> is linear access time), so you can index it as needed, <code>mydeque[4]</code> for a short <code>deque</code> will be just fine. Converting back to a <code>list</code> isn't bad, it's just not necessary to access the data; <code>deque</code>s give full access.</span>
