<div class="post-text" itemprop="text">
<p>This came up in the context of answering <a href="https://stackoverflow.com/questions/32856252/how-to-deal-with-circular-cyclic-imports">another question</a> today.</p>
<p>Assume the following files, where the comments denote the filenames:</p>
<pre><code># level1/__init__.py
    import level1.level2
    answer = level1.level2.answer

# level1/level2/__init__.py
    from .b import answer

# level1/level2/b.py
    from .a import answer
    from ..level2.a import answer
    from level1.level2.a import answer
    import level1.level2.a

    if answer != 42:
        answer = level1.level2.a.answer  # &lt;-- Fails here

#level1/level2/a.py
    answer = 42
</code></pre>
<p>With this code, <code>python -c "import level1"</code> works fine (in both 2.7 and 3.4) as-is.  But change the answer to anything besides 42, and it fails with <code>AttributeError: 'module' object has no attribute 'level2'</code> at the designated location.</p>
<p>It appears that from/import can import a sub-module of a package and pull variables out of its namespace before all the parent namespaces are set up, but (obviously) the parent namespaces must be set up before the attributes of sub-namespaces can be traversed via normal attribute accesses.</p>
<p>Sometimes, though, the namespace is set up "well enough" for the import to work.  For example, the code below, with the top level stripped off, always works with <code>python -c "import level2"</code>, even though we still haven't finished initializing the <code>level2</code> namespace when we <code>import level2.a</code> from <code>level2.b</code>.</p>
<pre><code># level2/__init__.py
    from .b import answer

# level2/b.py
    from .a import answer
    import level2.a

    if answer != 42:
        answer = level2.a.answer  # &lt;-- Works here

#level1/level2/a.py
    answer = 41
</code></pre>
<p><strong>EDIT</strong></p>
<p>It appears that <code>import x.y.z</code> will insert a reference to z into y, but will not insert a reference to y into x.  For example, when I change <code>level1/level2/b.py</code> from my first example:</p>
<pre><code># level1/level2/b.py
    from sys import modules

    def dump():
        print '\n Dumping...'
        for key, value in sorted(modules.items()):
            if key.startswith('level'):
                print key, [ x for x in dir(value) if not x.startswith('_')]

    dump()
    import level1.level2.a
    dump()

    from .a import answer
    from ..level2.a import answer
    from level1.level2.a import answer

    if answer != 42:
        answer = level1.level2.a.answer
</code></pre>
<p>I get the following results before the traceback:</p>
<pre><code> Dumping...
level1 []
level1.level2 []
level1.level2.b ['dump', 'modules']
level1.level2.sys []

 Dumping...
level1 []
level1.level2 ['a']
level1.level2.a ['answer']
level1.level2.b ['dump', 'level1', 'modules']
level1.level2.level1 []
level1.level2.sys []
</code></pre>
<p>However, if, right after the second call to <code>dump()</code>, I add the line:</p>
<pre><code>setattr(modules['level1'], 'level2', modules['level1.level2'])
</code></pre>
<p>then it will not fail, because I have bound <code>level2</code> into <code>level1</code> before accessing it via attribute lookup.  However, it seems that if the interpreter can bind <code>a</code> into <code>level1</code> on that import, it might also be able to do the binding of <code>level2</code> into <code>level</code> in exactly the same fashion.</p>
<p>Is there a good reason for why only the lowest-level package is updated during the import statement, or is it a bug (or perhaps, rather, a feature that was added for a single package that should be extended to nested packages)?</p>
<p><strong>NOTE</strong> According to the Python documentation, <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow noreferrer">When a submodule is loaded using <em>any</em> mechanism ... a binding is placed in the parent moduleâ€™s namespace to the submodule object.</a>.</p>
<p>I believe this happens.  But not soon enough in all cases.  Also, the documentation for it may be <a href="https://bugs.python.org/issue24029" rel="nofollow noreferrer">relatively new</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have filed <a href="http://bugs.python.org/issue25294" rel="nofollow">an issue</a> against Python.  The text of this issue is reproduced below:</p>
<p>PEP 8 recommends absolute imports over relative imports, and section 5.4.2 of the import documentation says that an import will cause a binding to be placed in the imported module's parent's namespace.</p>
<p>However, since (with all current Python versions) this binding is not made until <em>after</em> the module body has been executed, there are cases where relative imports will work fine but absolute imports will fail.  Consider the simple case of these five files:</p>
<pre><code>xyz.py: import x
x/__init__.py:  import x.y
x/y/__init__.py:  import x.y.a
x/y/a/__init__.py:  import x.y.b; foo = x.y.b.foo
x/y/b/__init__.py:  foo = 1
</code></pre>
<p>This will fail in a fashion that may be very surprising to the uninitiated.  It will not fail on any of the import statements; rather it will fail with an AttributeError on the assignment statement in x.y.a, because the import of y has not yet finished, so y has not yet been bound into x.</p>
<p>This could conceivably be fixed in the import machinery by performing the binding before performing the exec.  Whether it can be done cleanly, so as not to cause compatibility issues with existing loaders, is a question for core maintainers.</p>
<p>But if it is decided that the current behavior is acceptable, then at a minimum both the PEP 8 and the import documentation should have an explanation of this corner case and how it can be solved with relative imports.</p>
</div>
<span class="comment-copy">Can you be more specific about "fails with an import error at the designated location"?  I get that it fails during an <code>import</code> (that's all we're doing), but the traceback says <code>AttributeError: 'module' object has no attribute 'level2'</code>, which is true: it doesn't. I guess "you can't automagically access sub<i>packages</i> when you've imported the parent" is my plain English explanation. In the latter, you're accessing a module, not trying to get into another package. I can write that up more formally with reference to the grammar, but I get the feeling I'm missing something, so commented first...</span>
<span class="comment-copy">@JRichardSnape -- Sorry, you're right about the error.  Was thinking AttributeError and writing ImportError.  Copied verbatim now.  <b>But...</b>  That doesn't directly explain to me why I don't get the same issue for the second example -- in that case, why can <code>a</code> be pulled out of <code>level2</code> before we've finished building <code>level2</code>?  FWIW, I don't think this can be explained by the grammar -- I think it's essentially the same in both cases -- but I could be wrong, of course.</span>
<span class="comment-copy">Hmm - I'll think a bit more.  I assumed you'd been through the grammar (and, as a corollary, that I'd missed something) and you've now edited in some nice debugging results along the lines I was thinking of testing next, so need to get my head round them.</span>
<span class="comment-copy">@JRichardSnape -- One more thing.  If, right after the second dump, I add the line <code>setattr(modules['level1'], 'level2', modules['level1.level2'])</code> then it works fine.  This seems like something the import statement could set up itself.</span>
<span class="comment-copy">Interesting.  Do a <code>dump()</code> after the whole thing when it works (i.e. <code>answer == 42</code>).  Also interesting...</span>
