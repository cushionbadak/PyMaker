<div class="post-text" itemprop="text">
<p>I'm trying to code a dictionary inside my class:</p>
<pre><code>data = {element:eval("self.%s" %element) for element in key}   
</code></pre>
<p>and I've got this error:</p>
<pre><code>data = {element:eval("self.%s" %element) for element in key}
        File "&lt;string&gt;", line 1, in &lt;module&gt;
        NameError: name 'self' is not defined
</code></pre>
<p>If I do:</p>
<pre><code> for element in key:
     data[element]=eval("self.%s" %element)
</code></pre>
<p>No error here.</p>
<p>How come?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL:DR</strong> Summary -</p>
<p>As stated correctly by @CoryKramer , partially this is because dictionary comprehension/list comprehension/generator expressions/nested funcions all are evaluated in their own scope. But other half of the reason for this issue is because of the use of <code>eval()</code> , which executes its expressions in the environment in which it is called , but it does not have access to enclosing namespaces.</p>
<p>Alternatively ,I believe you should not use <code>eval()</code> (<a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow">its pretty dangerous</a>) . For getting attributes from <code>self</code> , you should use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr()</code></a> function -</p>
<pre><code>data = {element:getattr(self,element) for element in key}
</code></pre>
<hr/>
<p>My findings about the issue for those who are interested -</p>
<p>Partially this is because dictionary comprehension/list comprehension/generator expressions/nested funcions all are evaluated in their own scope. But other half of the reason for this issue is because of the use of <code>eval()</code> .</p>
<p>As given in the documentation for <a href="https://docs.python.org/2/library/functions.html#eval" rel="nofollow"><code>eval()</code> -</a></p>
<blockquote>
<p><code>eval(expression[, globals[, locals]])</code></p>
<p><strong>If both dictionaries are omitted, the expression is executed in the environment where eval() is called.</strong> The return value is the result of the evaluated expression. Syntax errors are reported as exceptions.</p>
</blockquote>
<p>(Emphasis mine)</p>
<p>Normally inside a class , when you use dictionary comprehension you can use <code>self</code> and etc in that dictionary comprehension. Example -</p>
<pre><code>&gt;&gt;&gt; class CA:
...     def __init__(self):
...             self.a = "Hello"
...             print({k:self.a for k in range(2)})
...
&gt;&gt;&gt; CA()
{0: 'Hello', 1: 'Hello'}
&lt;__main__.CA object at 0x008B22D0&gt;
</code></pre>
<p>As you can see it was possible to access <code>self.a</code> within the dictionary comprehension. So now lets check what is the <code>locals()</code> (local namespace) for the dictionary comprehension -</p>
<pre><code>... #same as above, just change the print function call.
print({k:locals() if k &lt; 2 else self.a for k in range(2)})
</code></pre>
<p>Result -</p>
<pre><code>{0: {'.0': &lt;range_iterator object at 0x02373998&gt;, 'self': &lt;__main__.CA object at 0x008B22D0&gt;, 'k': 1}, 
1: {'.0': &lt;range_iterator object at 0x02373998&gt;, 'self': &lt;__main__.CA object at 0x008B22D0&gt;, 'k': 1}}
</code></pre>
<p>As can be seen <code>'self'</code> is accessible inside the dictionary comprehension (as its a <a href="https://docs.python.org/2/reference/executionmodel.html#naming-and-binding" rel="nofollow"><em>free variable</em></a> , and this only occured because I used <code>self.a</code> directly inside the dictionary comprehension , if I did not add that it wouldn't be a free variable there. Lets explain <em>free variables</em> a bit -</p>
<blockquote>
<p>If a name is bound in a block, it is a local variable of that block. If a name is bound at the module level, it is a global variable. (The variables of the module code block are local and global.) If a variable is used in a code block but not defined there, it is a <em>free variable</em>.</p>
</blockquote>
<p>But when you use <code>eval()</code> to execute the expression, Python does not know about any names (beforehand, before executing the expression) that are used inside the <code>eval()</code> , hence it cannot bind the <code>self</code> as a free variable to the dicitonary comprehension. Example of print of <code>locals()</code> , when using <code>eval</code> to get <code>self.a</code> -</p>
<pre><code>...
print({k:locals() if k &lt; 2 else eval('self.a') for k in range(2)})
</code></pre>
<p>Result -</p>
<pre><code>{0: {'.0': &lt;range_iterator object at 0x023739B0&gt;, 'k': 1}, 1: {'.0': &lt;range_iterator object at 0x023739B0&gt;, 'k': 1}}
</code></pre>
<p>Hence, when the expression is evaluated inside the eval it does not have the <code>self</code> variable defined in the environment it is executed. If you were to use <code>self</code> anywhere inside the dictionary comprehension , you would not end up with this error -</p>
<pre><code>...
print({k:eval('self.a') if k &lt; 2 else self for k in range(2)})
</code></pre>
<p>Result -</p>
<pre><code>{0: 'Hello', 1: 'Hello'}
</code></pre>
<p>Because then the environment in which <code>eval</code> expression is getting executed has knows about the name binding <code>self</code> .</p>
<p>The exact same issue can be replicated using nested functions as well -</p>
<pre><code>&gt;&gt;&gt; def a():
...     localb = 10
...     def c():
...             print(locals())
...             print(eval('localb + 20'))
...     c()
...
&gt;&gt;&gt; a()
{}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 7, in a
  File "&lt;stdin&gt;", line 5, in c
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name 'localb' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Avoid using <code>eval</code>. A better practice is to use <code>getattr</code>:</p>
<pre><code>data = {element: getattr(self, element) for element in key}
</code></pre>
</div>
<span class="comment-copy">List comprehensions, dict comprehensions, generator expressions, etc have their own scope. See <a href="https://stackoverflow.com/questions/31162886/cant-call-parents-method-in-list-comprehension-in-childs-intializer-but-expl">here</a> and <a href="https://stackoverflow.com/questions/22692227/why-is-one-class-variable-not-defined-in-list-comprehension-but-another-is">here</a></span>
<span class="comment-copy">I do not think the the duplicate question completely answers this case . This is a bit related to <code>eval()</code> as well.</span>
<span class="comment-copy">Why are you doing this (<code>eval</code>)?</span>
<span class="comment-copy">Are you aware of <code>getattr(self, element)</code>, which would be easier?</span>
