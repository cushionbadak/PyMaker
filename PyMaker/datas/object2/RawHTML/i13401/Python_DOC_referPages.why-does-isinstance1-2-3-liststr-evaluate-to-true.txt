<div class="post-text" itemprop="text">
<p>I was playing around a bit with the new type hinting / typing module with python3.5 trying to find a way to confirm if the hinted type is equal to the actual type of the variable and came across something that rather surprised me.</p>
<pre><code>&gt;&gt;&gt; from typing import List
&gt;&gt;&gt; someList = [1, 2, 3]
&gt;&gt;&gt; isinstance(someList, List[str])
True
</code></pre>
<p>Continuing my search for finding a way to compare a variable to it's hinted type I've also tried this:</p>
<pre><code>&gt;&gt;&gt; anotherList = ["foo", "bar"]
&gt;&gt;&gt; type(anotherList) is List[str]
False
</code></pre>
<p>Would anyone be able to explain why exactly the former evaluates to True?</p>
<p>And continuing onwards, is there a sound way to check if a variable's type is equal to a type coming from the typing module?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow"><code>isinstance</code></a> does not do real <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow">PEP 484</a> type checking. <a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="nofollow">The documentation</a> notes this in passing:</p>
<blockquote>
<p>In general, <code>isinstance()</code> and <code>issubclass()</code> should not be used with types.</p>
</blockquote>
<p>The <code>typing</code> module, as well as the <code>collections.abc</code> and <code>abc</code> modules it’s based on, use extensive <a href="https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks" rel="nofollow"><code>__instancecheck__</code> and <code>__subclasscheck__</code></a> magic to make <code>isinstance</code> and <code>issubclass</code> behave reasonably. But they’re not doing enough to support your case. Nor is it their goal to support it.</p>
<blockquote>
<p>is there a sound way to check if a variable's type is equal to a type coming from the typing module?</p>
</blockquote>
<p>You’re not looking for type <em>equality</em>. As you have noted yourself, the type of <code>[1, 2, 3]</code> is <code>list</code>, which is not <em>equal</em> to <code>List[str]</code>, nor to <code>List[int]</code>. You’re looking for type <em>checking</em>, which is much more complicated.</p>
<p>Consider this:</p>
<pre><code>def my_function():
    # ... 1000 lines of very complicated code ...

print(isinstance(my_function, Callable[[], int]))
</code></pre>
<p>What would you expect this program to print? You can’t expect <code>isinstance</code> to dig into <code>my_function</code> at runtime and infer that it always returns <code>int</code>. This is not feasible in Python. You need either a “compile” time type checker that has access to the structure of <code>my_function</code>, or explicit type annotations, or—most likely—both.</p>
</div>
<span class="comment-copy">Well, for one thing, <code>type(x) is a</code> and <code>isinstance(x, a)</code> are definitely not the same thing.  An object can be an instance of many types (with an inheritance hierarchy), but <code>type(x)</code> only gives you its single most specific type.</span>
<span class="comment-copy">Yup, I'm aware of that after having done some testing with it. Still felt like including it in my question as it's often being given as the go-to when asking anything about type comparisons in Python.</span>
<span class="comment-copy">What does <code>type(['foo', 'bar']) == List[str]</code> evaluate to?</span>
<span class="comment-copy">As expected, it evaluates to <code>False</code> since <code>type(['foo', 'bar'])</code> evaluates to just <code>list</code></span>
<span class="comment-copy">Thanks a lot for your clear and concise answer. I most certainly understand why you can't expect a function to figure out if another function always returns a variable of a certain type, but I'd imagine that it would somehow be possible to <i>check</i> if a single variable corresponds to a type coming from the typing module. Although that might require manually checking if each item in a list is of a certain type which would in situations dealing with large lists or nested types(List[Dict[str, List[int]]) simply take too long to be feasible. Yet again, thanks a bunch for your answer!</span>
<span class="comment-copy">@McMuffinton My point is that <code>my_function</code> is “a single variable” just as well as your <code>someList</code>. If you don’t expect to infer the type of <code>my_function</code> at runtime, there’s no reason to expect that of <code>someList</code>, either.</span>
<span class="comment-copy">What <i>are</i> <code>isinstance</code> and <code>issubclass</code> supposed to do then?</span>
<span class="comment-copy">@remus Their main purpose is to let you introspect Python’s dynamic typing, which is based on a simple idea: every object is an instance of one class, which is a subclass of zero or more base classes. Thus, <code>someList</code> is an instance of <code>list</code>, which is a subclass of <code>object</code>. These relations dictate method resolution, so they are readily available to the runtime. Later, though, PEP 3119 introduced ABCs and a way to override <code>isinstance</code> / <code>issubclass</code>, which is what’s confusing you know.</span>
