<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/509211/understanding-slice-notation">Understanding slice notation</a>
<span class="question-originals-answer-count">
                    31 answers
                </span>
</li>
</ul>
</div>
<p>This is the Code I am looking at <a href="https://github.com/Katee/quietnet" rel="nofollow">https://github.com/Katee/quietnet</a></p>
<p>In this project, there is a file named quitenet.py</p>
<p>In this file, there it is.</p>
<pre><code>def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]
</code></pre>
<p>I have no idea how I can understand the meaning <code>l[i:i+n]</code> .</p>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way is to try it on some data. For example, let's make a list:</p>
<pre><code>&gt;&gt;&gt; l = list("abcdefghijklmnopqrstuvwxyz")
&gt;&gt;&gt; l
['a', 'b', 'c', 'd', 'e', 'f', ... 'x', 'y', 'z']
</code></pre>
<p>I shortened the list, but it's all the letters you expect. Now try it:</p>
<pre><code>&gt;&gt;&gt; list(chunks(l, 3))
[['a', 'b', 'c'],
 ['d', 'e', 'f'],
 ['g', 'h', 'i'],
 ['j', 'k', 'l'],
 ['m', 'n', 'o'],
 ['p', 'q', 'r'],
 ['s', 't', 'u'],
 ['v', 'w', 'x'],
 ['y', 'z']]
</code></pre>
<p>So what's happening here is that as <code>i</code> increments through the loop (skipping <code>n</code> elements at a time), the routine yields out the next <code>n</code> elements of the original list. This return strategy is called a "generator," and it's signaled by the <code>yield</code> statement. Yield is like <code>return</code>, but if the routine is called again, it will "keep going from where it last left off."</p>
<p>Another way to exercise this is in a loop:</p>
<pre><code>&gt;&gt;&gt; for c in chunks(l, 4):
&gt;&gt;&gt;     print c
['a', 'b', 'c', 'd']
['e', 'f', 'g', 'h']
['i', 'j', 'k', 'l']
['m', 'n', 'o', 'p']
['q', 'r', 's', 't']
['u', 'v', 'w', 'x']
['y', 'z']
</code></pre>
<p>Every time through the loop, <code>c</code> becomes the next "chunk" of the original iterable. What's yielded from <code>chunks</code> to the loop is a slice of the original list <code>l[i:i+n]</code>. In this case, I asked for <code>n=4</code> so you can see the difference.</p>
<p>As you learn how to use <code>enumerate</code>, <code>chunks</code>, and similar generators, you'll find them <em>enormously</em> helpful. See e.g. the <a href="https://docs.python.org/3.5/library/itertools.html" rel="nofollow">itertools</a> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's slicing. So, in that part, it slices the list <code>l</code> from <code>i</code> to <code>i+n-1</code> (includes element in index <code>i</code>, until index <code>i+n-1</code>, but exclude element in index <code>i+n</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>l[i:i+n]</code> is <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow">slicing syntax</a>, and it gets a subsequence from index <code>i</code> (inclusive) to index <code>i+n</code> (exclusive). Unlike indexing, it never raises exceptions; if the slice goes outside the sequence, the slice is just shorter than you'd expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>The expression <code>l[i:i+n]</code> returns a slice of array <code>l</code>, specifically the elements from <code>i</code> to <code>i+n-1</code>.  This is a generator expression and each call will return the next <code>n</code> elements from the array since the last time it was called.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a form of string formatting called <code>slicing</code>. It involves sectioning a part of the string using slicing notation, <code>:</code>. Here is how it works:</p>
<pre><code>[starting_point:ending_point]
&gt;&gt;&gt;l = [1,2,3,4,5]
&gt;&gt;&gt;a = l[1:3]
&gt;&gt;&gt;print a
[2,3,4]
</code></pre>
<p>Once you know this the code becomes easy to read. You are slicing the string from the section <code>i</code> to whatever <code>n</code> is supposed to be. <code>n</code> is also apparently the interval that the range jumps with each iteration. </p>
<p>You can read more on slicing here: <a href="https://pythonhosted.org/bitstring/slicing.html" rel="nofollow">https://pythonhosted.org/bitstring/slicing.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>:</code> is a slicing operator for lists.</p>
<p>From this <a href="https://stackoverflow.com/a/509295/1539655">answer</a></p>
<blockquote>
<pre><code>a[start:end] # items start through end-1
a[start:]    # items start through the rest of the array
a[:end]      # items from the beginning through end-1
a[:]         # a copy of the whole array
</code></pre>
</blockquote>
<p>So, there is an example</p>
<pre><code>l = [1,2,3,4,5] 
print l[1:3]
&gt;&gt; [2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function is a generator that returns incremental slices of <code>l</code> that are <code>n</code> elements long.</p>
<p>Consider the following:</p>
<pre><code>def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

a_list = [1,2,3,4,5,6,7,9,10,11,12,13,14]

for slice in chunks(a_list, 4):
    print(slice)
</code></pre>
<p>Produces:</p>
<pre><code>[1, 2, 3, 4]
[5, 6, 7, 9]
[10, 11, 12, 13]
[14]
</code></pre>
<p>Which are non-overlapping slices. The trick to this is that the slice notation extracts elements from the starting index to the (ending index -1).</p>
</div>
