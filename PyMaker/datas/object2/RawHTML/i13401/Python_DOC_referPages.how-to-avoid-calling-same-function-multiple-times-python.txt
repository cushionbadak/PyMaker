<div class="post-text" itemprop="text">
<p>I would like to simulate my problem in python, I'm new to python programming. Just wanted to check whether if there is a way to avoid calling same function(return same value every time) multiple times.</p>
<p>Eg: </p>
<pre><code>def fun():
    return calling_another_fun()# return always same value say eg: 200

var = fun()  var1 = fun() var2 = fun()

print "calling first time"+str(var) print "calling second time"+str(var1) print "calling third time"+str(var2)
</code></pre>
<p>Is there is a way to call fun() at one place and</p>
</div>
<div class="post-text" itemprop="text">
<p>Assignment can bind the same object to multiple names.</p>
<pre><code>a = b = c = 42
</code></pre>
<p>Note that all names point to the <strong>same object</strong>, so if the object is mutable then it will appear to change for each of the names.</p>
<pre><code>&gt;&gt;&gt; a = b = []
&gt;&gt;&gt; a.append(None)
&gt;&gt;&gt; b
[None]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A very simple method to manually cache return values is this:</p>
<pre><code>def my_func():
  if my_func._retval is None:
    my_func._retval = ... # compute your return value here
  return my_func._retval
my_func._retval = None
</code></pre>
<p>Generally, what you are looking for is memoization. There are <a href="http://www.python-course.eu/python3_memoization.php" rel="nofollow">different approaches</a> to do this, depending on the complexity of your queries; python 3 has the quite useful <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">lru_cache</a>.</p>
</div>
<span class="comment-copy">You can use memoize python decorator!!. It will cache you method or function, next time call it will give from cache</span>
<span class="comment-copy">You only need to call the function once in this situation. <code>var = fun()</code> once and then use <code>var</code> everytime you need it, it doesn't call the function again.</span>
<span class="comment-copy">Your last sentence kind of ended right in the middle, which is why it lacks that certain distinction of whether you want to reuse the return value or want the function to return the same value without calling <code>calling_another_fun</code>.</span>
