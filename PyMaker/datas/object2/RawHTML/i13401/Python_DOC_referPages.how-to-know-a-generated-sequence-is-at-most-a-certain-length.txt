<div class="post-text" itemprop="text">
<p>I want to know whether a generated sequence has fewer than 2 entries.</p>
<pre><code>&gt;&gt;&gt; def sequence():
...     for i in xrange(secret):
...         yield i
</code></pre>
<p>My inefficient method is to create a list, and measure its length:</p>
<pre><code>&gt;&gt;&gt; secret = 5
&gt;&gt;&gt; len(list(sequence())) &lt; 2
True
</code></pre>
<p>Obviously, this consumes the whole generator.</p>
<p>In my real case the generator could be traversing a large network. I want to do the check without consuming the whole generator, or building a large list.</p>
<p>There's a <a href="https://docs.python.org/2/library/itertools.html">recipe in the itertools documentation</a>:</p>
<pre><code>def take(n, iterable):
    "Return first n items of the iterable as a list"
    return list(islice(iterable, n))
</code></pre>
<p>This only builds a list of max length <code>n</code>, which is better.</p>
<p>So I could say:</p>
<pre><code>&gt;&gt;&gt; len(take(2, sequence()) &lt; 2
</code></pre>
<p>Is there an even more pythonic, efficient way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.4, generators can implement a <a href="http://www.python.org/dev/peps/pep-0424/" rel="nofollow noreferrer">length hint</a>. If a generator implements this it'll be exposed through the <a href="https://docs.python.org/3/reference/datamodel.html#object.__length_hint__" rel="nofollow noreferrer"><code>object.__length_hint__()</code> method</a>.</p>
<p>You can test for it with the <a href="https://docs.python.org/3/library/operator.html#operator.length_hint" rel="nofollow noreferrer"><code>operator.length_hint()</code> function</a>.</p>
<p>If it is <em>not</em> available, your only option is to consume elements, and your use of the <code>take()</code> recipe is the most efficient way to do that:</p>
<pre><code>from operator import length_hint
from itertools import chain

elements = []
length = length_hint(gen, None)
if length is None:
    elements = list(take(2, gen))
    length = len(elements)
if length &gt;= 2:
    # raise an error
# use elements, then gen
gen = chain(elements, gen)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution using <code>take</code> uses <code>islice</code>, builds a list and takes the length of it:</p>
<pre><code>&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; len(list(islice(sequence(), 2))
2
</code></pre>
<p>To avoid creating the list we can use <code>sum</code>:</p>
<pre><code>&gt;&gt;&gt; sum(1 for _ in islice(sequence(), 2)
2
</code></pre>
<p>This takes about 70% of the time:</p>
<pre><code>&gt;&gt;&gt; timeit('len(list(islice(xrange(1000), 2)))', 'from itertools import islice')
 1.089650974650752

&gt;&gt;&gt; timeit('sum(1 for _ in islice(xrange(1000), 2))', 'from itertools import islice')
0.7579448552500647
</code></pre>
<p>Wrapping it up:</p>
<pre><code>&gt;&gt;&gt; def at_most(n, elements):
...     return sum(1 for _ in islice(elements, n + 1)) &lt;= n

&gt;&gt;&gt; at_most(5, xrange(5))
True

&gt;&gt;&gt; at_most(2, xrange(5))
False
</code></pre>
</div>
<span class="comment-copy">This is a great question Peter Wood - My naive approach would be to yield a tentative two elements and store them, but there has to be a better way. I am curious about it. I doubt a generator can know its own size before being consumed.</span>
<span class="comment-copy">Silghtly unrelated but as general rule beware with <code>list(iterator)</code> , iterators can be infinite...</span>
<span class="comment-copy">Surely the key question is - how would you know, <i>without</i> consuming the iterator, if it's going to be long enough (or short enough? Your title seems to conflict with the question)? Do you have any other information that could allow you to determine this?</span>
<span class="comment-copy">@jonrsharpe It's not that I don't want to consume the generator, it's just I don't want to consume more than needed. The function producing the sequence could take a function to keep count and break the traversal. Thanks.</span>
<span class="comment-copy">Very interesting, thank you - I am curious about the inner workings of this __length_hint__() now... :)</span>
<span class="comment-copy">@ReblochonMasque: many generators can pre-compute the length or at least produce an estimate. It depends entirely on the generator involved, though.</span>
<span class="comment-copy">I did not know that, thank you.</span>
<span class="comment-copy">According to the documentation, <code>__length_hint__</code> gives no  guarantees. Itâ€™s only a hint, so maybe the safer route is to <i>still</i> always consume <code>n</code> elements (in fact, in many cases correctness constraints will <i>require</i> the safe route).</span>
<span class="comment-copy">@KonradRudolph: That's why it is called a <i>hint</i>. It is aimed at optimisations, if the value is likely to be wildly off there is no point implementing the hook.</span>
