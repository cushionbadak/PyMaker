<div class="post-text" itemprop="text">
<p>I am new to python unit testing framework and lot of confusion in mocking dependency.</p>
<p>I am trying to write unit tests for below member function of a class, (<code>check_something()</code>):</p>
<pre><code>class Validations:    
    def check_something(self):
        abc = os.environ['PLATFORM']
        xyz = Node()
        no_of_nodes = len(xyz.some_type_var)
        if abc != "X_PLATFORM" or no_of_nodes != 1:
            raise someException()
</code></pre>
<p>How do we eliminate dependency ?</p>
<ol>
<li>Need to mock <code>Node()</code> ?</li>
<li>How do we make sure <code>abc</code> is assigned with <code>X_PLATFORM</code> ?</li>
<li><p>How to assign value <code>1</code> to variable <code>no_of_nodes</code>? which is in turn derived from <code>Node()</code> object.</p>
<pre><code>class Node(object):
    def __init__(self):
        self.nodes = DEF()
        self.some_type_var = someclass().getType()
        self.localnode = os.environ['HOSTNAME']
        self.peertype = self.get_peer_type()

    def get_peer_type(self):
        return node
</code></pre></li>
</ol>
<p>I tried writing below unit test. I am unable to check for fail and pass condition. I am not sure whether it is correct or not. </p>
<pre><code>class TestValidation(unittest.TestCase):

    @mock.patch.object(Node, "get_peer_type")
    @mock.patch('somefile.Node', spec=True)
    def test_1(self, mock_object1, mock_object2):
        os.environ['PLATFORM'] = 'X_PLATFORM'
        obj = Validations()
        self.assertRaises(someException, obj.check_something)
</code></pre>
<p>Validation class uses <code>Node()</code> Class object and Node class uses some other class.</p>
<ol>
<li>How to make sure exception is raised or not depending on the condition?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you'd mock anything external to the unit of code under test. Here that means the <code>os.environ</code> dictionary and the <code>Node()</code> class.</p>
<p>The patch needs to be applied to the module your code is in; <code>@mock.patch('somefile.Node', spec=True)</code> is correct if <code>somefile</code> is the same module as <code>Validations</code>; see the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow"><em>Where to patch</em> section</a> as to why that is.</p>
<p>I'm not sure that using <code>spec=True</code> is all that helpful here; your <code>Node</code> attributes are all instance attributes created in <code>Node.__init__</code>, so they are not available on the <em>class</em>, which is what informs the spec. See the section on <a href="https://docs.python.org/3/library/unittest.mock.html#auto-speccing" rel="nofollow">autospeccing</a> on how to overcome that if you really want to set a spec.</p>
<p><code>abc</code> is set from <code>os.environ</code>, you can use the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.dict" rel="nofollow"><code>patch.dict()</code> object</a> to patch that dictionary for your needs.</p>
<p>The <code>xyz = len(xyz.some_type_var)</code> is simply handled by either setting the <code>some_type_var</code> attribute to an object with the right length, <em>or</em> by setting <code>xyz.some_type_var.__len__.return_value</code>, since it is the <code>xyz.some_type_var.__len__()</code> method that is called for the <code>len()</code> function.</p>
<p>So, to test, you'd do:</p>
<pre><code>class TestValidation(unittest.TestCase):
    @mock.patch('somefile.Node')
    def test_1(self, mock_node):
        # set up the Node() instance, with the correct length
        node_instance = mock_node.return_value
        node_instance.some_type_var.__len__ = 2
        # or, alternatively, node_instance.some_type_var = (1, 2)

        # set up os.environ['PLATFORM']
        with mock.patch.dict('os.environ', PLATFORM='X_PLATFORM'):
            obj = Validations()
            with self.assertRaises(someException):
                obj.check_something()
</code></pre>
</div>
