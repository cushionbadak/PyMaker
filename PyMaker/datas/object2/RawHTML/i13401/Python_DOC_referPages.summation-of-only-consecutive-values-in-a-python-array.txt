<div class="post-text" itemprop="text">
<p>I am new on python (and even programing!), so I will try to be as clear as I can to explain my question. For you guys it could be easy, but I have not found a satisfactory result on this yet.</p>
<p>Here is the problem:</p>
<p>I have an array with both negative and positive values, say:</p>
<pre><code>x = numpy.array([1, 4, 2, 3, -1, -6, -6, 5, 6, 7, 3, 1, -5, 4, 9, -5, -2, -1, -4])
</code></pre>
<p>I would like to sum ONLY the <strong>negative</strong> values that are <strong>continuous</strong>, i.e. only <em>sum</em>(-1, -6, -6), <em>sum</em>(-5, -2, -1, -4) and so on. I have tried using <em>numpy.where</em>, as well as <em>numpy.split</em> based on the condition.</p>
<p>For example: </p>
<pre><code> for i in range(len(x)):
     if x[i] &lt; 0.:
         y[i] = sum(x[i])
</code></pre>
<p>However, as you can expect, I just got the summation of all negative values in the array instead. In this case  <strong>sum</strong>(-1, -6, -6, -5, -5, -2, -1, -4)
Could guys share with me an aesthetic and efficient way to solve this problem? I will appreciate any response on this.</p>
<p>Thank you very much  </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a vectorized NumPythonic solution -</p>
<pre><code># Mask of negative numbers
mask = x&lt;0

# Differentiation between Consecutive mask elements. We would look for 
# 1s and -1s to detect rising and falling edges in the mask corresponding 
# to the islands of negative numbers.
diffs = np.diff(mask.astype(int))

# Mask with 1s at start of negative islands
start_mask = np.append(True,diffs==1) 

# Mask of negative numbers with islands of one isolated negative numbers removed
mask1 = mask &amp; ~(start_mask &amp; np.append(diffs==-1,True))

# ID array for IDing islands of negative numbers
id = (start_mask &amp; mask1).cumsum()

# Finally use bincount to sum elements within their own IDs
out = np.bincount(id[mask1]-1,x[mask1])
</code></pre>
<p>You can also use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html" rel="nofollow"><code>np.convolve</code></a> to get <code>mask1</code>, like so -</p>
<pre><code>mask1 = np.convolve(mask.astype(int),np.ones(3),'same')&gt;1
</code></pre>
<p>You can also get the count of negative numbers in each "island" with a little tweak to existing code -</p>
<pre><code>counts = np.bincount(id[mask1]-1)
</code></pre>
<p>Sample run -</p>
<pre><code>In [395]: x
Out[395]: 
array([ 1,  4,  2,  3, -1, -6, -6,  5,  6,  7,  3,  1, -5,  4,  9, -5, -2,
       -1, -4])

In [396]: out
Out[396]: array([-13., -12.])

In [397]: counts
Out[397]: array([3, 4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> module, here with using <code>groupby</code> you can grouping your items based on those sign then check if it meet the condition in <code>key</code> function so it is contains negative numbers then yield the sum else yield it and at last you can use <code>chain.from_iterable</code> function to chain the result :</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby,tee,chain
&gt;&gt;&gt; def summ_neg(li):
...     for k,g in groupby(li,key=lambda i:i&lt;0) :
...           if k:
...              yield [sum(g)]
...           yield g
... 
&gt;&gt;&gt; list(chain.from_iterable(summ_neg(x)))
[1, 4, 2, 3, -13, 5, 6, 7, 3, 1, -5, 4, 9, -12]
</code></pre>
<p>Or as a more pythonic way use a list comprehension :</p>
<pre><code> list(chain.from_iterable([[sum(g)] if k else list(g) for k,g in groupby(x,key=lambda i:i&lt;0)]))
[1, 4, 2, 3, -13, 5, 6, 7, 3, 1, -5, 4, 9, -12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can flag negative values .... and do this with plain python</p>
<pre><code>prev = False

    for i,v in enumerate(a):
            j = i + 1     
            if j &lt; len(a):
                if a[i] &lt; 0 and  a[j] &lt; 0:
                    temp.append(v)
                    prev = True
                elif a[i] &lt; 0 and prev:
                    temp.append(v)
                    prev = True
                elif a[i] &gt; 0:
                    prev = False
            else:
                if prev and v &lt; 0:
                    temp.append(v)
</code></pre>
<p><strong>output</strong></p>
<p>print(temp)</p>
<p>[-1, -6, -6, -5, -2, -1, -4]</p>
<p>with intertools i would do just that</p>
<pre><code>def sum_conseq_negative(li):
    neglistAll = []
    for k, g in groupby(li, key=lambda i:i&lt;0):
        negList = list(g)
        if k and len(negList) &gt; 1:
            neglistAll.extend(negList)
    return sum(negList), len(negList)

 sumOf, numOf = sum_conseq_negative(li)

print("sum of negatives {} number of summed {}".format(sumOf,numOf))
</code></pre>
<p>sum of negatives -25 number of summed 7</p>
</div>
<span class="comment-copy">What's the expected output?</span>
<span class="comment-copy">Are you looking for a <code>numpy</code> solution only or pure python solution too?</span>
<span class="comment-copy">For me it is fine with a pythonic solution. I am trying to follow the advice Kasramvd. However, if you recommend me an other option besides using itertools, that would be fine too.</span>
<span class="comment-copy">@AshwiniChaudhary, the results expected should be like Kasramvd have showed. But I am open to try with other options besides itertools as well. Thank you!</span>
<span class="comment-copy">@hurrdrought if any of these answers resolved your question, you should mark it as accepted</span>
<span class="comment-copy">Thank you very much! I am also trying this option with good results too. It is good because I can see how many numbers I have added (i.e. counts).</span>
<span class="comment-copy">I wanted to let you know that, thanks to your post, I have (almost) finished my program. I really like this simple but efficient way to do this. Thank you very much.</span>
<span class="comment-copy">@hurrdrought Awesome! I would think this solution to be efficient in terms of performance as this avoids loops and that's where NumPy based solutions shine. Were you also able to time these approaches for your dataset?</span>
<span class="comment-copy">Yes, I got the expected results from my datasets using your recommended code. Now, I am trying to do the same but using a larger dataset instead (&gt;1000 of single data). Thanks!</span>
<span class="comment-copy">@hurrdrought So did it work for your 1000&gt; data?</span>
<span class="comment-copy">You don't need two iterators, simply check if the value of <code>_</code>(i.e key) is <code>True</code> or <code>False</code>. If it's <code>True</code> then it's a group of positive numbers.</span>
<span class="comment-copy">@AshwiniChaudhary Ooo yeah sure, as I always use <code>_</code> instead of <code>k</code> I just forgot it's use ;-) thanks for reminding that!</span>
<span class="comment-copy">@Kasramvd, thank you very much for this option. It is working as expected. Also, do you know a way to know the sum of those negative values but knowing how many numbers (i.e. the shape of those chunks) were added? I know this could be complex. Thanks in advance.</span>
<span class="comment-copy">@hurrdrought Welcome! in that case you can convert <code>g</code> to a list and put it in a variable after the <code>for</code> loop and after the condition you can just yield it and its length using <code>len(var)</code>.</span>
