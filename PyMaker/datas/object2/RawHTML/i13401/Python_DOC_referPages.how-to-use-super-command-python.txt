<div class="post-text" itemprop="text">
<p>I'm having problem using super command</p>
<pre><code>class s:
    def __init__(self,a):
        self.a=a

    def show(self):
        print self.a


class t:
    def __init__(self,b):
        self.b=b

    def show2(self):
        print self.b


class w(s):
    def __init__(self,a,b,c):
        super(w,self).__init__()
        self.b=b
        self.c=c

    def show3(self):
        super(w,self).show()
        print self.b
        print self.c
</code></pre>
<p>whenever i make an object it gives the following error</p>
<pre><code>x=w(1,2,3)

Traceback (most recent call last):
    File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt;
x=w(1,2,3)
File "C:\Users\GURSAHEJ\Desktop\k.py", line 13, in __init__
super(w,self).__init__()
TypeError: must be type, not classobj
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code> function</a> will Return a proxy object that delegates method calls to a parent or sibling class of type so  when you want to use it you need to pass the parent name to it,and since here your <code>w</code> class inherit from <code>s</code> you might want to pass <code>s</code> to <code>super</code>:</p>
<pre><code>class w(s):
    def __init__(self,a,b,c):
        super(s,self).__init__()
        self.b=b
        self.c=c
</code></pre>
<p>Also don't forget to pass the <a href="https://docs.python.org/2/library/functions.html#object" rel="nofollow noreferrer"><code>object</code></a> to your parent class to make it a <a href="https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">new style class</a> :</p>
<pre><code>class s(object):
        def __init__(self,a):
            self.a=a
        def show(self):
            print self.a
</code></pre>
<p>Read about <em>new style and classic classes</em> it in python documentation <a href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes" rel="nofollow noreferrer">https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Because you are using <code>super</code> on an <a href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes" rel="nofollow noreferrer">old-style class</a></p>
<p>In Python 2.x (&gt;= 2.2), there are two type of classes. Old style classes and new-style classes. In python 3.x, old-style classes are removed and all classes are new-style class. </p>
<p>Python's <em>build-in function</em> <code>super</code> works properly on new-style classes.</p>
<p>Simply, new-style classes extends <code>object</code> while old style classes not. </p>
<h2>Old Sytle Class</h2>
<pre><code>class s:
    def __init__(self,a):
        self.a=a
</code></pre>
<h2>New Style Class</h2>
<pre><code>class s(object):
    def __init__(self,a):
        self.a=a
</code></pre>
<p>So, your classes which is not inherited from another class should be inherited from <code>object</code> to be a new style class.</p>
<p>You can either use <em>new-style</em> or use old-skool inheritance <code>__init__</code></p>
<pre><code>class w(s):
    def __init__(self,a,b,c):
        s.__init__(self, a)
</code></pre>
<p>This is an example of <a href="https://stackoverflow.com/questions/11527921/python-inheriting-from-old-style-classes">old-style solution</a>, but I do not flag this question as a duplicate because new-style class usage is encouraged and you should avoid using old-style classes.</p>
</div>
