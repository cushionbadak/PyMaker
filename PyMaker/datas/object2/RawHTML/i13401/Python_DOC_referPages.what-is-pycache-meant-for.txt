<div class="post-text" itemprop="text">
<p>From what I understand, a cache is an encrypted file of similar files.</p>
<p>What do we do with the <code>__pycache__</code> folder? Is it what we give to people instead of our source code? Is it just my input data? This folder keeps getting created, what it is for? </p>
</div>
<div class="post-text" itemprop="text">
<p>When you run a program in python, the interpreter compiles it to bytecode first (this is an oversimplification) and stores it in the <code>__pycache__</code> folder. If you look in there you will find a bunch of files sharing the names of the .py files in your project's folder, only their extensions will be either .pyc or .pyo. These are bytecode-compiled and optimized bytecode-compiled versions of your program's files, respectively.</p>
<p>As a programmer, you can largely just ignore it... All it does is make your program start a little faster. When your scripts change, they will be recompiled, and if you delete the files or the whole folder and run your program again, they will reappear (unless you specifically suppress that behavior)</p>
<p>If you are using cpython (which is the most common, as it's the reference implementation) and you don't want that folder, then you can suppress it by starting the interpreter with the -B flag, for example </p>
<pre><code>python -B foo.py
</code></pre>
<p>Another option, as noted by tcaswell, is to set the environment variable <code>PYTHONDONTWRITEBYTECODE</code> to any value (according to python's man page, any "non-empty string").</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__pycache__</code> is a folder containing <strong>Python 3 bytecode compiled and ready to be executed</strong>.</p>
<p>Don't bother deleting these files nor suppress creation as it will hurt performance. Just have a recursive command ready (see below) to clean up when needed as bytecode can become stale in edge cases (see comments).</p>
<p>Python programmers usually ignore bytecode. Indeed <code>__pycache__</code> and <code>*.pyc</code> are common lines to see in <code>.gitignore</code> files. Bytecode is not meant for distribution and can be disassembled using <a href="https://docs.python.org/3.5/library/dis.html" rel="noreferrer"><code>dis</code> module</a>. </p>
<hr/>
<p>If you are using OS X you can easily hide all of these folders in your project by running following command from the root folder of your project.</p>
<pre><code>find . -name '__pycache__' -exec chflags hidden {} \;
</code></pre>
<p>Replace <code>__pycache__</code> with <code>*.pyc</code> for Python 2.</p>
<p>This sets a flag on all those directories (.pyc files) telling  Finder/Textmate 2 to exclude them from listings. Importantly the bytecode is there, it's just hidden.</p>
<p>Rerun the command if you create new modules and wish to hide new bytecode or if you delete the hidden bytecode files.</p>
<hr/>
<p>On Windows the equivalent command might be (not tested, batch script welcome):</p>
<pre><code>dir * /s/b | findstr __pycache__ | attrib +h +s +r
</code></pre>
<p>Which is same as going through the project hiding folders using right-click &gt; hide...</p>
<hr/>
<p>Running unit tests is one scenario (more in comments) where deleting the <code>*.pyc</code> files and <code>__pycache__</code> folders is indeed useful. I use the following lines in my <code>~/.bash_profile</code> and just run <code>cl</code> to clean up when needed. </p>
<pre><code>alias cpy='find . -name "__pycache__" -delete'
alias cpc='find . -name "*.pyc"       -delete'
...
alias cl='cpy &amp;&amp; cpc &amp;&amp; ...'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A __pycache__folder is created when you use the line </p>
<pre><code>import file_name
</code></pre>
<p>or try to get information from another file you have created. This makes it a little faster when running the program your second time to open the other file.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__pycache__</code> is a directory that contains bytecode cache files that are automatically generated by python, namely compiled python, or <code>.pyc</code>, files. You might be wondering why Python, an "interpreted" language, has any compiled files at all. <a href="https://stackoverflow.com/questions/2998215/if-python-is-interpreted-what-are-pyc-files">This SO question</a> addresses that (and it's definitely worth reading <a href="https://stackoverflow.com/a/2998544/5610569">this answer</a>).</p>
<p>The python docs go into more depth about exactly how it works and why it exists:</p>
<ul>
<li><a href="https://docs.python.org/3/whatsnew/3.2.html?highlight=__pycache__#pep-3147-pyc-repository-directories" rel="nofollow noreferrer">It was added in python 3.2</a> because the existing system of maintaining <code>.pyc</code> files in the same directory caused various problems, such as when a program was run with Python interpreters of different versions. For the full feature spec, see <a href="https://www.python.org/dev/peps/pep-3147/" rel="nofollow noreferrer">PEP 3174</a>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The python interpreter compiles the *.py script file and saves the results of the compilation to the <code>__pycache__</code> directory.</p>
<p>When the project is executed again, if the interpreter identifies that the *.py script has not been modified, it skips the compile step and runs the previously generated *.pyc file stored in the <code>__pycache__</code> folder.</p>
<p>When the project is complex, you can make the preparation time before the project is run shorter. If the program is too small, you can ignore that by using <code>python -B abc.py</code> with the <code>B</code> option.</p>
</div>
<div class="post-text" itemprop="text">
<p>from the official python tutorial <a href="https://docs.python.org/3/tutorial/modules.html#compiled-python-files" rel="nofollow noreferrer">Modules</a></p>
<blockquote>
<p>To speed up loading modules, Python caches the compiled version of each module in the <code>__pycache__</code> directory under the name <code>module.version.pyc</code>, where the version encodes the format of the compiled file; it generally contains the Python version number. For example, in CPython release 3.6 the compiled version of spam.py would be cached as <code>__pycache__/spam.cpython-36.pyc</code>.</p>
</blockquote>
<p>from Python doc <a href="https://docs.python.org/3/faq/programming.html?highlight=__pycache__#how-do-i-create-a-pyc-file" rel="nofollow noreferrer">Programming FAQs</a></p>
<blockquote>
<p>When a module is imported for the first time (or when the source file has changed since the current compiled file was created) a .pyc file containing the compiled code should be created in a <code>__pycache__</code> subdirectory of the directory containing the <code>.py</code> file. The <code>.pyc</code> file will have a filename that starts with the same name as the <code>.py</code> file, and ends with <code>.pyc</code>, with a middle component that depends on the particular python binary that created it. </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In 3.2 and later, Python saves .pyc compiled byte code files in a sub-directory named <code>__pycache__</code> located in the directory where your source files reside with filenames that identify the Python version that created them (e.g. script.cpython-33.pyc)</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>pycache</strong> =  Byte code compiled files of python</p>
</div>
<div class="post-text" itemprop="text">
<p>python interpreter compiles your code into those cached files and saves them to those folders, any time you will use </p>
<pre><code>import something 
</code></pre>
<p>it will appear  </p>
</div>
<span class="comment-copy">"Is it what we give people instead of our source code?" - No, you give them the source code in a nice installable package so it's easy to use.</span>
<span class="comment-copy">Nobody mentioned yet, but your definition of cache is bizarre. Cache is quite simply a <a href="https://en.wikipedia.org/wiki/Cache_(computing)" rel="nofollow noreferrer">component that stores data so future requests for that data can be served faster</a>.</span>
<span class="comment-copy">See: <a href="https://www.python.org/dev/peps/pep-3147/" rel="nofollow noreferrer">python.org/dev/peps/pep-3147</a></span>
<span class="comment-copy">You can also add the environment variable <code>PYTHONDONTWRITEBYTECODE=&lt;any_value&gt;</code> to suppress it permanently.</span>
<span class="comment-copy">Just to clarify, this is for Python 3 only, correct?</span>
<span class="comment-copy">@JoeJ yes, I think that's true. <code>python2</code> puts the compiled files in the same directory as the originals, if I'm not mistaken.</span>
<span class="comment-copy">One IMPORTANT caveat is that the cached .pyc file will be used instead of the .py file if the .py file is missing. In practice, this only happens if you delete (or rename) modules, so it's not a common occurance, but if some stuff keeps up being "there", after scratching your head, running find . -name *.pyc | xargs rm o n your source is probably a good first reaction.</span>
<span class="comment-copy"><code>find . -name '*.pyc' -delete</code> Yes, find has a flag for deleting the found files, so you don't have to use any xargs shananigans</span>
<span class="comment-copy">Wouldn't this be undone every time you run the code?</span>
<span class="comment-copy">@DoTheEvo: it simply doesn't get created, so there's no speedup next time the module is loaded. No error is raised.</span>
<span class="comment-copy">This isn't a good answer. The asker wants to know what these files are for. This answer says "don't worry about it" and then makes them disappear.</span>
<span class="comment-copy"><b><i>Absolutely</i></b> bother deleting these</span>
<span class="comment-copy">I would disagree with this advice to "not bother deleting these files" - have seen this recommended many times, most recently by <a href="http://howtopython.org/en/latest/the-interpreter/#bytecode-trick" rel="nofollow noreferrer">Kenneth Reitz's "How To Python"</a> ("the bytecode trick")</span>
