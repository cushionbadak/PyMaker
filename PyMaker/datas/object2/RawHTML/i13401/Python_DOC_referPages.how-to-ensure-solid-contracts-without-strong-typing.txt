<div class="post-text" itemprop="text">
<p><code>get_min_length()</code> takes an argument that must match the possible return values of <code>get_pkt_type()</code>:</p>
<pre><code>def get_pkt_type(some_val):
    """Determine the type of an XCP packet.

    :return:
        'CMD' if "Command" packet,
        'RES' if "Command Response" packet,
        'ERR' if "Error" packet,
        'CMD/RES' if uncertain whether a CONNECT CMD or a
            RES packet, as their frame bytes can look identical.
    :rtype: str
    """
    if something:
        return 'CMD'
    elif something_else2:
        return 'RES'
    elif something_else3:
        return 'ERR'
    elif something_else4:
        return 'CMD/RES'

def get_min_length(packet_type):
    if packet_type in ['CMD', 'RES']:
        return 4
    elif packet_type in ['ERR', 'CMD/RES']:
        return 6

packet_type = get_pkt_type(some_val)
length = get_min_length(packet_type)
</code></pre>
<p>How do I ensure that, if a programmer adds a new packet type return value to <code>get_pkt_type()</code>, that he also doesn't forget to add the value to <code>get_min_length()</code>. In a strong-typed language <code>packet_type</code> would be a defined type that is returned and passed, so I would have safety that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally, in Python, if you have an extensible set of values, it makes sense to make a shallow inheritance hierarchy instead. This is less prone to forgetfulness. Enums are better for fixed sets of values.</p>
<p>That said, the first thing you should be doing is trailing</p>
<pre><code>raise ValueError("Unexpected enum value")
</code></pre>
<p>to your functions.</p>
<p>Another thing you might consider is using dictionaries to represent such mappings:</p>
<pre><code>pkt_lengths = {
    'CMD': 4,
    'RES': 4,
    'ERR': 6,
    'CMD/RES': 6,
}

get_min_length = pkt_lengths.__getitem__
</code></pre>
<p>You can then add a simple test</p>
<pre><code>packet_types = {'CMD', 'RES', 'ERR', 'CMD/RES'}
assert not packet_types.symmetric_difference(pkt_lengths)
</code></pre>
<p>If you're doing this a lot, build a function:</p>
<pre><code>def enum_mapper(enum, mapper):
    assert not enum.symmetric_difference(mapper)
    return mapper.__getitem__
</code></pre>
<p>which lets you do</p>
<pre><code>get_min_length = enum_mapper(packet_types, pkt_lengths)
</code></pre>
<p>and get checks at startup.</p>
<p>Also, consider using a proper <code>enum.Enum</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't do it, even if you could. 
Python is a <code>Duck-Typed</code> language, in <code>duck-typed</code> language we don't restrict variables on the basis of their type. Consider as case that I define an custom <code>packet_type</code> as follows:-</p>
<pre><code>class SpecialPacket(object):

    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return self.value == other

special_packet = SpecialPacket('CMD')

print(get_min_length(special_packet))
# 6
</code></pre>
<p>That is the beauty of <code>duck-typing</code>, you added a new packet and you didn't have to change your code at all.</p>
<p>Answer to your question - <strong>Write tests</strong></p>
<p>That is why testing is considered very important in dynamic and weakly-typed languages. We don't rely on strong-typing and ended up writing much more code  than we need to, but instead we heavily test our code at all stages. The individual who adds a new packet is responsible to ensure that his code works, and he doesn't ends up breaking yours.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can actually create your own types in python - types are just classes.</p>
<pre><code>class packet_type(object):
  def __init__(self, name, length):
    self.name = name
    self.length = length

CMD = packet_type("CMD", 4)
</code></pre>
<p>Sometimes, this may seem somewhat heavy. A simpler alternative is dumping attributes into a primitive data structure, as in Veedrac's answer.
A very nice middle ground if you just want a struct-like container are <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow">namedtuples</a>.</p>
<pre><code>from collections import namedtuple
packet_type = namedtuple('packet_type', ['name', 'length']
CMD = packet_type("CMD", 4)
</code></pre>
<p>All of these options have the advantage that parameters are defined on the objects directly, where they actually belong. This means there is only a single point where new parameters need to be defined (on the new instance), not several as in your setup. It also plays much better with duck-typing, as any class with <code>name</code> and <code>length</code>, regardless of extensions, can be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to ensure that a programmer does not forget anything. Programmers are human and human tend to forget things. </p>
<p>However you can add some code to your <code>get_min_length(packet_type)</code> and thus remind a programmer to add the new value to this function.</p>
<pre><code>else:
    print "Unknown packet type. Please add new value to the list."
    return some_int_value
</code></pre>
<p>Or you can even raise an exception, so the programmer immedaately sees an error.</p>
<p>PS. In Python you have to define your function before calling them. </p>
</div>
<span class="comment-copy">In Python you can't. However, if you have a full list of valid packets, you can add a unittest that makes sure that all your functions accept valid packet types.</span>
<span class="comment-copy">Many thanks for your insightful answer. I wonder why you suggest an <code>Enum</code> rather than a set or tuple. I assume the <code>Enum</code> will hold all the packet types 'CMD', 'RES', etc. But Enum's have an associated value for each item (but no such value exists in my context). So why then is an Enum suited for this?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer"><code>Enum</code></a> will generate true singletons for <code>packet_types</code>, will give you a less stringly-typed interface and will let you check things like uniqueness and get a list of valid values. You don't need to care about the associated values if you don't want to use them.</span>
<span class="comment-copy">FWIW, your <code>SpecialPacket</code> should probably also implement <code>__hash__</code>.</span>
<span class="comment-copy">@Veedrac It was just an example to illustrate the point. It is no way exhaustive implementation bro</span>
<span class="comment-copy">One should <code>raise ValueError</code> here.</span>
