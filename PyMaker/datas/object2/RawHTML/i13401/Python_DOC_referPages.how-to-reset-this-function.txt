<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a>
<span class="question-originals-answer-count">
                    32 answers
                </span>
</li>
</ul>
</div>
<p>Some days ago I ask for some function that retrieve the repetitive motif from some string (<a href="https://stackoverflow.com/questions/29955135/a-more-complex-version-of-how-can-i-tell-if-a-string-repeats-itself-in-python">Here the link to the ask</a>). The user @Kasramvd posted a nice function based on regex:</p>
<pre><code>import re
def finder(st,past_ind=0,l=[]):
    m=re.search(r'(.+)\1+',st)
    if m:
        i,j=m.span()
        sub=st[i:j]
        ind = (sub+sub).find(sub, 1)
        sub=sub[:ind]
        if len(sub)&gt;1:
            l.append([sub,(i+past_ind+1,j+past_ind+1)])
        past_ind+=j
        return finder(st[j:],past_ind)
    else:
        return l
</code></pre>
<p>This function, in fact, catch the repetitive motifs and also show the from/until where it take place:</p>
<pre><code>&gt;&gt;&gt; finder('123.123.123.')
[['123.', (1, 13)]] #the 123. motif take place from position 1 to position 13
</code></pre>
<p>However, looks like this function has memory. When I used it again with other string, it show also the previous result:</p>
<pre><code>&gt;&gt;&gt; finder('abc.abc.abc.')
[['123.', (1, 13)], ['abc.', (1, 13)]]
</code></pre>
<p>So, someone know how to avoid this? How to reset the function?</p>
<p>Thanks in advance guys. =)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects" rel="nofollow">Don't use mutable types for function defaults.</a></p>
<p>When you declare <code>def finder(st,past_ind=0,l=[])</code>, the default value is a single <code>list</code> which is shared between all invocations of the function that don't override the default (and returned to the caller to boot), so any mutations made to the list within the function or by the caller will change the default for future calls. Changing to:</p>
<pre><code>def finder(st,past_ind=0,l=None):
    if l is None:
        l = []
    ... rest of function ...
</code></pre>
<p>avoids this problem; the assignment to <code>l</code> within the function body creates a new <code>list</code> each time.</p>
</div>
<span class="comment-copy">See linked dupe. You need to change <code>l=[]</code> to <code>l=None</code> and then create a new empty list each time.</span>
<span class="comment-copy">Hi @tzaman , Change <code>l</code> was easy. But what you mean with create a new empty list each time? Where?</span>
<span class="comment-copy"><code>if l is None: l = []</code></span>
<span class="comment-copy">This is more of a comment than an answer.</span>
<span class="comment-copy">You rock, dude! But also it is important to say that the line <code>return finder(st[j:],past_ind)</code> must be changed to <code>return finder(st[j:],past_ind, l=l)</code></span>
