<div class="post-text" itemprop="text">
<p>So, let's say I have an arbitrarily long list of numbers. I'd like to get a list of every number in that list multiplied by every number in that list. I'd do that by nesting <code>for</code> loops like this:</p>
<pre><code>for x in numbers:
    for y in numbers:
        print(x*y)
</code></pre>
<p>Now if I'd like to multiply every number in that list times every number in that list times every number in that list <em>again</em>, I'd do this:</p>
<pre><code>for x in numbers:
    for y in numbers:
        for z in numbers:
            print(x*y*z)
</code></pre>
<p>My issue is that I'm searching a graph for a subgraph, and I need to allow for arbitrarily large subgraphs. To do this I have to construct every subgraph with <em>n</em> edges from the edges in the main graph - and I have to allow for arbitrary values of <em>n</em>. How?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> with an iterative product computing function (I favor <code>reduce(mul, ...)</code>). If you need <code>n</code>-way products (in both senses of the word "product"):</p>
<pre><code>from functools import reduce
from operator import mul

for numset in itertools.product(numbers, repeat=n):
    print(reduce(mul, numset))
</code></pre>
<p>The above is simple, but it will needlessly recompute partial products when the set of values is large and <code>n &gt;= 3</code>. A recursive function could be used to avoid that:</p>
<pre><code>def compute_products(numbers, repeat):
    if repeat == 1:
        yield from numbers
        return
    numbers = tuple(numbers)  # Only needed if you want to handle iterator/generator inputs
    for prod in compute_products(numbers, repeat-1):
        yield from (prod * x for x in numbers)

for prod in compute_products(numbers, n):
    print(prod)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think a recursive function of some kind would probably help you. This is just untested pseudocode typed into the Stack Overflow editor, so beware of using this verbatim, but something like this:</p>
<pre><code>def one_dimension(numbers, n):
    if (n &lt; 1):
        return
    for num in numbers:
        for next_num in one_dimension(numbers, n-1):
            yield num*next_num
</code></pre>
<p>The basic idea is that each "level" of the function calls the next one, and then deals with what the next one produces. I don't know how familiar you are with Python's <code>yield</code> keyword, but if you know what it does, then you should be able to adapt the code above.</p>
<p><strong>Update:</strong> Or just use <code>itertools.product</code> like ShadowRanger suggested in his answer; that's probably a better solution to your problem.</p>
</div>
<span class="comment-copy">FYI, in Py2, the <code>functools</code> import for <code>reduce</code> isn't necessary, but <code>Py3</code> moved <code>reduce</code> out of the built-in namespace.</span>
<span class="comment-copy">Of course the multiplication example was just an example, but I get the idea.</span>
<span class="comment-copy">you should measure the time performance to check whether the recursive solution is actually slower for a given type of input.</span>
<span class="comment-copy">@J.F.Sebastian: I did some timing tests, and it's definitely not cut and dry. The recursive solution <i>will</i> be slower for many inputs, simply because it's executing more Python byte code along with incurring the cost of setting up Python stack frames. For the simple case addressed here, the <code>itertools.product</code> solution moves 99% of the work to the C layer (in CPython anyway; PyPy and others don't benefit from stuff like this), which gives it a lower fixed multiplier on compute cost, even if the big-O cost is higher.</span>
<span class="comment-copy">What are the big-O costs here?</span>
