<div class="post-text" itemprop="text">
<p>So, If i would like to calculate the value of 6^8 mod 5 using the pow function, what should I put in a line??</p>
<p>In the assumption that You don't need to import it first</p>
<p>I know that pow is used like pow (x, y) = pow (6, 8) = 6^8
and </p>
<p>My guess is </p>
<pre><code>mod.pow(6,8)
</code></pre>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>It's simple: <code>pow</code> takes an optional 3rd argument for the modulus. </p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#pow" rel="noreferrer">docs</a>:</p>
<blockquote>
<p><code>pow(x, y[, z])</code></p>
<p>Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than <code>pow(x, y) % z)</code>. The
  two-argument form pow(x, y) is equivalent to using the power operator:
  <code>x**y</code>.</p>
</blockquote>
<p>So you want:</p>
<pre><code>pow(6, 8, 5)
</code></pre>
<p>Not only is <code>pow(x, y, z)</code> faster &amp; more efficient than <code>(x ** y) % z</code> it can easily handle large values of <code>y</code> without using arbitrary precision arithmetic, assuming <code>z</code> is a simple machine integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>check the docs of <a href="https://docs.python.org/2/library/functions.html#pow" rel="nofollow"><code>pow</code></a>:</p>
<pre><code>pow(6, 8, 5)
</code></pre>
<p>does what you want. </p>
<p>do <em>not</em> use <code>a ** b % n</code>! while this will give the correct result it will be by orders of magnitude slower if you do calculations for bigger numbers. <code>pow</code> will do the modulo operation in every step while <code>**</code> will first do the exponentiation in the integers (which may result in a <em>huge</em> number) and take the modulus only at the end.</p>
<p>now if you are interested in numbers that are bigger than 32 bit you may want to have a look at <a href="https://gmpy2.readthedocs.org/en/latest/" rel="nofollow">gmpy2</a> for even more speed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use '%' character to get the modulo value. For example <code>print(pow(6,8) % 5)</code> or <code>print(6**8 % 5)</code>.</p>
</div>
<span class="comment-copy"><code>pow</code> is usually used as the <code>**</code> operator. And modulo is <code>%</code>: <code>6**8%5</code></span>
<span class="comment-copy">Two way, <code>pow(x, y)</code> or <code>x**y</code></span>
<span class="comment-copy">didn't know  that, great to know.</span>
<span class="comment-copy">"Not only is <code>pow(x, y, z)</code> faster &amp; more efficient than <code>(x ** y) % z</code>" ~  This answer's a few years old so maybe it's been optimized since then, but I consistently get the opposite results:  best <code>timeit</code> result on my machine for <code>a,b,c=600,800,500;x=pow(a,b,c)</code> is 0.183 µsec per loop (0.876 µsec with Python 3!); while for <code>x=a**b%c</code> it's only 0.085 µsec per loop, nearly twice as fast.  No significant difference with <code>x=(a**b)%c</code> either.  (N.b. the tuple unpack is to avert constant folding.)</span>
<span class="comment-copy">@criptych Interesting. There may have been some relevant optimizations, but try it with a large power, eg <code>pow(1000000,1000001,1001)</code> returns instantly (with a value of 1) on Python 3.6, whereas I had to kill <code>1000000**1000001%1001</code>. I haven't done proper <code>timeit</code> tests on <code>pow</code>, but I know that <code>2**n</code> is still significantly slower than <code>1&lt;&lt;n</code>.</span>
<span class="comment-copy">@criptych: I consistently get a <a href="http://ideone.com/Ilnb2L" rel="nofollow noreferrer">far, far, worse time</a> with <code>a**b%c</code> than with <code>pow(a, b, c)</code> with those inputs.</span>
<span class="comment-copy">@criptych: Maybe you mixed up microseconds and nanoseconds.</span>
<span class="comment-copy">Thanks for mentioning gmpy2. Another arbitrary precision package worth looking at is <a href="http://mpmath.org" rel="nofollow noreferrer">mpmath</a>, if you want fancy functions, root solving, integrals, etc. FWIW, mpmath will use gmpy, if it's available.</span>
<span class="comment-copy">yes, thanks. forgot to mention that...</span>
