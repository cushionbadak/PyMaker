<div class="post-text" itemprop="text">
<p>Let us say from function perspective. Thanks.</p>
<pre><code>def binarySearch(array, beginIndex, endIndex, value):
    while (beginIndex &lt; endIndex):
        mid = (beginIndex + endIndex) // 2
        if array[mid] &lt; value:
            beginIndex = mid + 1
        elif array[mid] &gt; value:
            endIndex = mid - 1
        else: #equal
            return mid

    if array[beginIndex] == value:
        return beginIndex
    else:
        return -1
</code></pre>
<p>Here are cases where I tested,</p>
<pre><code>print binarySearch([2,3], 0, 1, 2)
print binarySearch([2,3], 0, 1, 3)
print binarySearch([2,3], 0, 1, -1)
print binarySearch([2,3,3,3,4,5], 0, 5, 3)
</code></pre>
<p>thanks in advance,
Lin</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, the first thing "wrong" with it (if this is production code rather than a class assignment or personal exercise) is that you're reinventing the wheel. Python already provides binary search as part of the included batteries through the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code> module</a> (and yes, it's on Python 2 as well).</p>
<p>Beyond that, it definitely doesn't work for all cases. For example, I just tried:</p>
<pre><code>binarySearch(list(range(1000)), 0, 1000, 6) # And again with 999 in case end index was inclusive
</code></pre>
<p>and got no hit. This is because your loop never actually loops; presumably you need to dedent the final <code>if/else</code> so it's not part of the <code>while</code> loop, because as is, you never make it more than one (and a half, counting the <code>if/else</code>) set of tests in before succeeding or giving up.</p>
<p>Fixing that indent issue (and if you're on Python 3 or using the <code>__future__</code> <code>division</code> import on Python 2, changing <code>/ 2</code> to <code>// 2</code>) makes it work, and it seems to be a fairly standard implementation of the algorithm.</p>
<p>A couple suggestions:</p>
<ol>
<li>Python tends to use half-open ranges; you accept <code>beginIndex</code> and <code>endIndex</code> as inclusive values, where typically Python functions accept <code>start</code> and <code>end</code>, where <code>start</code> is inclusive, and <code>end</code> is exclusive (the way <code>range</code> behaves).</li>
<li><p>Moving the <code>beginIndex/</code>endIndex` arguments to the end of the profile would allow you to give them useful defaults, so in the common case (searching the whole sequence), users wouldn't have to manually specify the bounds. For example:</p>
<p>def binarySearch(array, value, beginIndex=0, endIndex=None):
    if endIndex is None:
        endIndex = len(array) - 1  # Or just len(array) if you rewrite as half-open
    ...</p></li>
</ol>
<p>would make it much simpler to call in the standard case (and not coincidentally, that's the profile used by <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect" rel="nofollow"><code>bisect.bisect</code></a>).</p>
<p>On fixing the indent issue (per your request in the comments), I'm saying that the following four lines (which are currently indented to the level of the <code>while</code> loop's body), should be dedented a level, so they're only run when the <code>while</code> loop exits without <code>return</code>-ing, instead of every execution of the <code>while</code> loop (which, since there is a return on either path, means the <code>while</code> loop never actually loops):</p>
<pre><code>if array[beginIndex] == value:
    return beginIndex
else:
    return -1
</code></pre>
</div>
<span class="comment-copy">you need to tell us <i>if anything is wrong with your code</i> . Are you getting error? Unexpected output? if so what input are you giving, what are you getting, what did you expect to get?</span>
<span class="comment-copy">@AnandSKumar, I do not get any errors and just want to experts here to see if any bugs I have not tested. :)</span>
<span class="comment-copy">@LinMa You should probably post this on CodeReview if you think it works, and ask for ways to improve it.</span>
<span class="comment-copy">@helloB, CodeReview? Where is it?</span>
<span class="comment-copy">I would take @helloB suggestion and post on CodeReview in that case: <a href="http://codereview.stackexchange.com/">codereview.stackexchange.com</a></span>
<span class="comment-copy">To be clear, not trying to dump on you. I'm saying "wrong" because reinventing the wheel is bad for production code, but the only way you learn in the first place.</span>
<span class="comment-copy">thanks a lot. I am using Python 2.7.8, and what is the issue you mentioned, by "Fixing that indent issue"? Appreciate if you could point out more clearly. BTW, fully agree with you using built-in API is good, I am just doing some exercise. :)</span>
<span class="comment-copy">@LinMa: I've added an explanation of the indent issue in the answer.</span>
<span class="comment-copy">Thanks ShadowRanger, thanks a lot to point it out. What is the benefit of using // comparing to using /? Maybe I see too many old-style code and rare see // used. Please feel free to correct me if I am wrong.</span>
<span class="comment-copy">In Py2 and 3, <code>//</code> means floor division (for positive numbers, this means truncating division like in C, so <code>5 // 2</code> produces <code>2</code>, not <code>2.5</code>). In Python 2 without <code>from __future__ import division</code>, <code>/</code> is type dependent; two <code>int</code>s do truncating integer division, but mixed <code>int</code> and <code>float</code> produce a <code>float</code>, while in Python 3 (and Python 2 with <code>from __future__ import division</code>) <code>/</code> is "true division", producing <code>float</code> from <code>int</code> division, so <code>5 / 2</code> would produce <code>2.5</code> (which is not at all correct for this algorithm). In general, if you want to do integer division, using <code>//</code> is safest.</span>
