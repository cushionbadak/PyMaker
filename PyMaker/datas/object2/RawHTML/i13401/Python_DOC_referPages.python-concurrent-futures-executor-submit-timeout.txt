<div class="post-text" itemprop="text">
<p>I want to use many thread with a timeout by thread.
I already use the following code : </p>
<pre><code>import concurrent.futures

class Action:

    def __init(self):
        self.name = 'initial'

    def define_name(self):
        # In my real code this method is executed during 30-60 seconds
        self.name = 'name'

action_list = [
    Action(),
    Action(),
]

with concurrent.futures.ThreadPoolExecutor(
    max_workers = 20
) as executor:
    for action_item in action_list:
        # without timeout arg, it works !
        executor.submit(action_item.define_name, timeout=1)

for action_item in action_list:
    print(action_item.name)
</code></pre>
<p>I already seen this post <a href="https://stackoverflow.com/questions/6509261/how-to-use-concurrent-futures-with-timeouts">How to use concurrent.futures with timeouts?</a> but I don't need to use result method</p>
<p>Python documentation don't help me (<a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">https://docs.python.org/3/library/concurrent.futures.html</a>). It shows how to define timeout with <strong>map</strong> method but not with submit.</p>
<p>Do you know a way to define timeout with <strong>executor.submit</strong> method ?</p>
<p><strong>Edit</strong> : This example is very simple. In my real case, I have a list of 15000+ items. Each action run by <strong>executor.submit()</strong> during 30 - 60 secondes. But some items action during more of 5 minutes, I want execpt Tiemout with these items.</p>
<p><strong>Edit 2</strong> : I want to stop a Thread after a timeout. But I don't want use Thread object. So this post (<a href="https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python">Is there any way to kill a Thread in Python?</a>) don't resolve my problem. I want to use only <strong>concurrent.futures</strong> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to async execution with timeout, you can pack your future inside another future so the last one can wait for main future and whole thing will be non-blocking. Like this:</p>
<p><code>executor.submit(lambda: executor.submit(func, arg).result(timeout=50))</code></p>
<p>But this is quite <em>sloppy and ineffective</em>.</p>
</div>
<span class="comment-copy">What is the <code>submit()</code> timeout supposed to do? <code>ThreadPoolExecutor</code> puts submitted items into a queue, this means <code>submit()</code> is not really a blocking operation. Blocking can only happen when the queue is full and the default queue has no limit.</span>
<span class="comment-copy">Yes this example is very easy. I had completed the post with more details.</span>
<span class="comment-copy">This does not add up with your code. Even with several thousand items, <code>submit()</code> should be practically instantaneous. <code>submit()</code> does only schedule a task for (later) execution it does not wait for the tasks to finish. There is nothing in this code that should make <code>submit()</code> take 30+ seconds.</span>
<span class="comment-copy">Yes, I agree with you. Can you imagine that Action.define_name() method takes 30+ seconds ? I can't post the real code of my company. I posted a simple use case.</span>
<span class="comment-copy">In that case you want to <i>interrupt</i> the thread <i>when</i> it is already running, not await its submission. <code>submit()</code> returns a <code>Future</code> object that has a <code>wait()</code> method with a timeout. You might be able to use that. But it might be more elegant to write the worker code so that it stops by itself when the timeout is reached. Simply killing a thread is usually not a good idea.</span>
