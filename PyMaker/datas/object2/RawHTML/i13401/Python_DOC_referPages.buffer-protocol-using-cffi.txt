<div class="post-text" itemprop="text">
<p>I want to expose a buffer protocol for a object, just like <a href="http://docs.cython.org/src/userguide/buffer.html" rel="nofollow">in this example</a> of the Cython documentation, however I need to do this using <a href="https://cffi.readthedocs.org/en/latest/" rel="nofollow">CFFI</a> and I wasn't able to find any examples to expose a buffer protocol.</p>
</div>
<div class="post-text" itemprop="text">
<p>My reading of the question is that you have some data you've got from a CFFI interface and want to expose it using the standard Python buffer protocol (which lots of C extensions use for quick access to array data).</p>
<p>The good news <code>ffi.buffer()</code> command (which, in fairness, I didn't know about until OP mentioned it!) exposes both a Python interface and the C-API side buffer protocol. It is restricted to viewing the data as an unsigned char/byte array though. Fortunately, using other Python objects (e.g. a <code>memoryview</code> it's possible to view it as other types).</p>
<p>Remainder of the post is an illustrative example:</p>
<pre><code># buf_test.pyx
# This is just using Cython to define a couple of functions that expect
# objects with the buffer protocol of different types, as an easy way
# to prove it works. Cython isn't needed to use ffi.buffer()!
def test_uchar(unsigned char[:] contents):
    print(contents.shape[0])
    for i in range(contents.shape[0]):
        contents[i]=b'a'

def test_double(double[:] contents):
    print(contents.shape[0])
    for i in range(contents.shape[0]):
        contents[i]=1.0
</code></pre>
<p>... and the Python file using cffi</p>
<pre><code>import cffi
ffi = cffi.FFI()

data = ffi.buffer(ffi.new("double[20]")) # allocate some space to store data
         # alternatively, this could have been returned by a function wrapped
         # using ffi

# now use the Cython file to test the buffer interface
import pyximport; pyximport.install()
import buf_test

# next line DOESN'T WORK - complains about the data type of the buffer
# buf_test.test_double(obj.data) 

buf_test.test_uchar(obj.data) # works fine - but interprets as unsigned char

# we can also use casts and the Python
# standard memoryview object to get it as a double array
buf_test.test_double(memoryview(obj.data).cast('d'))
</code></pre>
</div>
<span class="comment-copy">I don't think this makes sense. Implementing the buffer protocol ultimately involves <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">writing some C functions yourself</a>, and <a href="https://docs.python.org/3/c-api/typeobj.html#buffer-structs" rel="nofollow noreferrer">adding them to a type defined using the Python C-API</a>. (As an aside, Cython provides a way to do this from "Python-like code). CFFI is a way of calling existing C libraries from Python, but not of writing new C code.</span>
<span class="comment-copy">Not exacly, see the <code>set_source</code> method in these <a href="https://cffi.readthedocs.org/en/latest/overview.html#purely-for-performance-api-level-out-of-line" rel="nofollow noreferrer">docs</a>. They also provide a <code>ffi.buffer()</code> method to return buffer objects, however these objects do not expose a buffer protocol.</span>
<span class="comment-copy">Ah - fair enough. My mistake (I think). A quick look through the source code for cffi (<a href="https://bitbucket.org/cffi/cffi/src/059aca3cb3dc5faa3d54ce4560b28215c686216e/c/minibuffer.h?at=default&amp;fileviewer=file-view-default#minibuffer.h-123" rel="nofollow noreferrer">bitbucket.org/cffi/cffi/src/â€¦</a>) suggests that the buffer should expose the Python buffer protocol. I'm not really sure I understand your question very well, but I'll have a little poke around...</span>
<span class="comment-copy">You're right, the cffi buffer is already exposing buffer protocol, thanks for the help. Please add this as an answer to this question and then I can accept it as the answer.</span>
<span class="comment-copy">Thanks a lot David.</span>
