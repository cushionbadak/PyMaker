<div class="post-text" itemprop="text">
<p>It plots when I do (in Python 3):</p>
<pre><code>import matplotlib.pyplot as plt

a = [1,2,3,4,5]

plt.plot(range(5), a)
plt.show()
</code></pre>
<p>As far as I know, in Python 3, <code>range()</code> returns an iterator so my code above pretty much plots over an iterator. Now my question is, why am I not able to do:</p>
<pre><code>def myGen(iterable):
    for i in iterable:
        yield i
a = myGen([1,2,3,4,5])
plt.plot(range(5),a)
plt.show()
</code></pre>
<p>When I try this, I get <code>ValueError: x and y must have same first dimension</code></p>
<p>When you think about it, it makes sense wanting to plot over two generators. Just plot point after point. Is this possible in <code>matplotlib</code>?</p>
<p>I am aware that <a href="https://stackoverflow.com/questions/28098342/plotting-in-matplotlib-from-a-generator">there is a similar thread</a>, unfortunately unanswered.</p>
</div>
<div class="post-text" itemprop="text">
<p>The thing is that even though <code>range</code> in Python 3 is not a real list, it still provides a lot more functionality than your custom generator.  In particular, it provides <code>__len__</code>.  This is crucial because matplotlib converts everything to numpy arrays under the hood, and numpy arrays requre their size to be known up front.  Python 3 range objects also provide item access, so they really are pretty much like ordinary sequences.  You can see in <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow">the documentation</a> that they are not simple generators.</p>
<p>I'm not sure exactly what all you'd need to do to make your own custom class work here, but it's probably more trouble than it's worth.  Matplotlib needs to be able to convert your data into a numpy array, and numpy in turn needs much more information than simple "this object is iterable".  It needs to be able to know how much data there is and get it all at once.</p>
</div>
<span class="comment-copy">range is not an iterator,it is an  <i>immutable sequence</i> , <code>plt.plot(range(5), (i for i in (1,2,3,4,5)))</code> would fail the same way, you cannot pass a generator to plot</span>
<span class="comment-copy">@PadraicCunningham: That has nothing to do with it.  It will fail not because of <code>range</code> but because of the generator expression.</span>
<span class="comment-copy">@BrenBarn, that is exactly what I just said.</span>
<span class="comment-copy">@PadraicCunningham: But that is exactly what he asking: why can't he pass a generator to plot?</span>
<span class="comment-copy">@BrenBarn, no there are asking why range works but the generator fails, the OP thinks they are comparable which they are not</span>
<span class="comment-copy">If matplotlib will convert whatever suitable I put in there as an argument into a numpy array, then I'd rather just pass in a numpy array in the first place. I was hoping that matplotlib had an algorithm that takes two generators and sort of calls <code>__next__()</code> on them and repeatedly draws the plot point after point and then when I call <code>show()</code> on the plot, it just renders and somehow gets all the points drawn on the figure. But yeah, apparently I'm just gonna pass arrays in.</span>
<span class="comment-copy">@Deniz: No, it doesn't do that.  Like I said, it converts the entire dataset into numpy arrays at the beginning.</span>
