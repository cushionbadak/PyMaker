<div class="post-text" itemprop="text">
<p>First I want to clarify, I'm NOT asking what is "iterator".</p>
<p>This is how the term "iterable" is defined in Python's <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">doc</a>:</p>
<blockquote>
<p><strong>iterable</strong><br/>
<strong>An object capable of returning its members one at a time.</strong>
  Examples of iterables include all sequence types (such as list, str,
  and tuple) and some non-sequence types like dict, file objects, and
  objects of any classes you define with an <strong>__iter__() or __getitem__()</strong>
  method. Iterables can be used in a for loop and in many other places
  where a sequence is needed (zip(), map(), ...). When an iterable
  object is passed as an argument to the built-in function iter(), it
  returns an iterator for the object. This iterator is good for one pass
  over the set of values. When using iterables, it is usually not
  necessary to call iter() or deal with iterator objects yourself. The
  for statement does that automatically for you, creating a temporary
  unnamed variable to hold the iterator for the duration of the loop.
  See also iterator, sequence, and generator.</p>
</blockquote>
<p>As <a href="https://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-an-object-is-iterable?lq=1">other people suggested</a>, using <code>isinstance(e, collections.Iterable)</code> is the most pythonic way to check if an object is iterable.<br/>
So I did some test with Python 3.4.3:</p>
<pre><code>from collections.abc import Iterable

class MyTrain:
    def __getitem__(self, index):
        if index &gt; 3:
            raise IndexError("that's enough!")

        return index

for name in MyTrain():
    print(name)  # 0, 1, 2, 3

print(isinstance(MyTrain(), Iterable))  # False
</code></pre>
<p>The result is quite strange: <code>MyTrain</code> has defined <code>__getitem__</code> method, but it is not considered as an iterable object, not to mention it's capable of returning one number at a time.</p>
<p>Then I removed <code>__getitem__</code> and added the <code>__iter__</code> method:</p>
<pre><code>from collections.abc import Iterable

class MyTrain:    
    def __iter__(self):
        print("__iter__ called")
        pass

print(isinstance(MyTrain(), Iterable))  # True

for name in MyTrain():
    print(name)  # TypeError: iter() returned non-iterator of type 'NoneType'
</code></pre>
<p>It is now considered as a "true" iterable object in spite of it cannot produce anything while iterating.</p>
<p>So did I misunderstand something or is the documentation incorrect?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the point of confusion here is that, although implementing <code>__getitem__</code> <em>does</em> allow you to iterate over an object, it <em>isn't part of the interface defined by <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow"><code>Iterable</code></a></em>. </p>
<p>The <a href="https://docs.python.org/3/glossary.html#term-abstract-base-class" rel="nofollow">abstract base classes</a> allow a form of virtual subclassing, where classes that implement the specified methods (in the case of <code>Iterable</code>, only <code>__iter__</code>) are considered by <code>isinstance</code> and <code>issubclass</code> to be subclasses of the ABCs <em>even if they don't explicitly inherit from them</em>. It doesn't check whether the method implementation <em>actually works</em>, though, just whether or not it's provided.</p>
<p>For more information, see <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow">PEP-3119</a>, which introduced ABCs.</p>
<hr/>
<blockquote>
<p>using <code>isinstance(e, collections.Iterable)</code> is the most pythonic way
  to check if an object is iterable</p>
</blockquote>
<p>I disagree; I would use <a href="https://docs.python.org/3/glossary.html#term-duck-typing" rel="nofollow">duck-typing</a> and just <strong>attempt to iterate over the object</strong>. If the object isn't iterable a <code>TypeError</code> will be raised, which you can catch in your function if you want to deal with non-iterable inputs, or allow to percolate up to the caller if not. This completely side-steps how the object has decided to implement iteration, and just finds out whether or not it does at the most appropriate time.</p>
<hr/>
<p>To add a little more, I think the docs you've quoted are <em>slightly</em> misleading. To quote the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter</code> docs</a>, which perhaps clear this up:</p>
<blockquote>
<p><em>object</em> must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence
  protocol (the <code>__getitem__()</code> method with integer arguments starting
  at <code>0</code>).</p>
</blockquote>
<p>This makes it clear that, although both protocols make the object iterable, only one is the actual <em>"iteration protocol"</em>, and it is this that <code>isinstance(thing, Iterable)</code> tests for. Therefore we could conclude that one way to check for <em>"things you can iterate over"</em> in the most general case would be:</p>
<pre><code>isinstance(thing, (Iterable, Sequence))
</code></pre>
<p>although this does also require you to implement <code>__len__</code> along with <code>__getitem__</code> to <em>"virtually sub-class"</em> <code>Sequence</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It <em>is</em> an iterable. However you haven't inherited from <code>abc.Iterable</code>, so naturally Python won't report it as being descended from that class. The two things -being an iterable, and descending from that base class - are quite separate.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>Iterable</code> is something(collection anything) that allows some kind of iteration on its elements. But what is the generic way of iteration in python? That is using - <code>in</code> keyword, which uses <code>__iter__</code> method of an object. So, in that terms any object that defines <code>__iter__</code> can be used with <code>in</code>, and is an Iterable.</p>
<p>So, most 'duck-typish' way to check if an object is iterable is if an object is this, (Yeah, I know implicitly that is what's happening in <code>isinstance</code> case as well, due to virtual classes)</p>
<pre><code>hasattr(train, '__iter__')
</code></pre>
<p>because according to duck-typing, we care about behavior provided by an object instead of its ancestory.</p>
<p>If you have a faulty implementation of <code>__iter__</code> that doesn't means object is not iterable, it just means that you have bug in your code.</p>
<p>Note:- Those objects that don't define <code>__iter__</code> can still be iterable in general sense, by using some other method, it's just they can't be used with <code>in</code> keyword.
E.g.:- <code>NumberList</code> instance is iterable over <code>each</code> method, but isn't iterable in python sense.</p>
<pre><code>class NumberList:

     def __init__(self, values):
         self.values = values

     def each(self):
         return self.values
</code></pre>
</div>
<span class="comment-copy"><code>isinstance</code> won't check that the interface is implemented correctly, that doesn't get found out until you actually try to iterate over it, just that the appropriate method(s) (in this case <a href="https://docs.python.org/2/library/collections.html#collections.Iterable" rel="nofollow noreferrer">only <code>__iter__</code></a>) are available.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy"><i>"using <code>isinstance(e, collections.Iterable)</code> is the most pythonic way to check if an object is iterable"</i> - no, I would say that <b>trying to iterate over it</b> is the most Pythonic way!</span>
<span class="comment-copy">to test if something is an iterable, I do a try / except block where I try var = iter(var), if it throws and exception, then it's not an iterable</span>
<span class="comment-copy">@jonrsharpe. But that might be self-defeating, since it could consume the iterable. Maybe a better check would be to try <code>iter(x)</code> and see if it raises a <code>TypeError</code>.</span>
<span class="comment-copy">Thx jorsharpe, your answer is of great help. For now, I really think the doc I quoted is misleading. The glossary "iterable" in the glossary doc means "can be iterated" no matter how it's done, while Python's <code>collections.abc.Iterable</code> represents valid iteration container(I made this word up), that is whatever object that defines the <code>__iter__</code> method.</span>
<span class="comment-copy">So <code>collections.abc.Iterable</code> is not necessarily "iterable" since it could return an invalid iterator which does not implement <code>__next__</code>. Meanwhile , an "iterable" object could have no relation with <code>collections.abc.Iterable</code> by only defining <code>__getitem__</code>. What do you think?</span>
<span class="comment-copy">@laike9m that's right, but then simply defining a <code>__getitem__</code> method is also no guarantee that it actually <i>works</i>! This is why I prefer the duck typing <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer"><i>"EAFP"</i></a> approach - given that you can't truly know if an object is <i>actually iterable</i> until you do it, then that's the most appropriate time to deal with it not being. Ideally the documentation should say something like <i>"an object is iterable if it implements the iterator or sequence protocols"</i>, perhaps, although it seems that <code>__len__</code> isn't needed in practice.</span>
<span class="comment-copy">I think what's confused the OP is that classes implementing <code>__iter__</code> are virtual subclasses of <code>Iterable</code> even if they don't explicitly inherit from it.</span>
<span class="comment-copy">1. That's <b>not</b> duck typing. 2. <code>hasattr(train, '__iter__')</code> is roughly what <code>isinstance(train, Iterable)</code> already does.</span>
<span class="comment-copy">@jonrshare I know, but that is bit misleading. Don't you think isinstance should check inheritance instead</span>
<span class="comment-copy">If an object provides '<b>iter</b>' method, we don't care whether it's instance of Iterable or not. Isn't that what duck typing means</span>
<span class="comment-copy"><i>"Don't you think isinstance should check inheritance instead"</i> - no, I think it should do what it's documented to: <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><i>"Return true if the object argument is an instance of the classinfo argument, or of a (direct, indirect or virtual) subclass thereof."</i></a> (where for virtual see <a href="https://docs.python.org/3/glossary.html#term-abstract-base-class" rel="nofollow noreferrer">docs.python.org/3/glossary.html#term-abstract-base-class</a>)</span>
<span class="comment-copy"><a href="https://docs.python.org/3/glossary.html#term-duck-typing" rel="nofollow noreferrer">Duck typing</a> means not using <code>hasattr</code> at all, just writing <code>for thing in train:</code> and either dealing with the error in the function or letting the caller catch it.</span>
