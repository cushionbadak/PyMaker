<div class="post-text" itemprop="text">
<p>I need to encrypt / decrypt a file using xor with Python 3, I have a code that works fine in Python 2, but when trying to adapt it to Python 3, gives me some errors that I can't solve.</p>
<p>This code works fine in Python 2.7:</p>
<pre><code>from itertools import cycle


def xore(data, key):
    return ''.join(chr(ord(a) ^ ord(b)) for (a, b) in zip(data, cycle(key)))

with open('inputfile.jpg', 'rb') as encry, open('outputfile.jpg', 'wb') as decry:
    decry.write(xore(encry.read(), 'anykey'))
</code></pre>
<p>The error when trying to run unchanged in python 3:</p>
<pre><code>Traceback (most recent call last):
  File "ask.py", line 8, in &lt;module&gt;
    decry.write(xore(encry.read(), 'anykey'))
  File "ask.py", line 5, in xore
    return ''.join(chr(ord(a) ^ ord(b)) for (a, b) in zip(data, cycle(key)))
  File "ask.py", line 5, in &lt;genexpr&gt;
    return ''.join(chr(ord(a) ^ ord(b)) for (a, b) in zip(data, cycle(key)))
TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>Please if someone could explain and help me adapt this code to Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>a</code> is already an <code>int</code> so you would need to remove the call to <code>ord(a)</code>:</p>
<pre><code>def xore(data, key):
    return ''.join(chr(a ^ ord(b)) for (a, b) in zip(data, cycle(key)))
</code></pre>
<p>You will not be able to write the joined string to your outfile without a  <code>.encode("utf-8")</code> which will not give you any usable output so not sure what you are actually trying to achieve.</p>
<p>You can see when you index a byte string you get an int in python3:</p>
<pre><code>n [1]: s = b"foo"

In [2]: s[0]
Out[2]: 102  # f
</code></pre>
<p>Where in python2 you get the str/char:</p>
<pre><code>In [1]: s = b"foo"
In [2]: s[0]
Out[2]: 'f'
</code></pre>
<p>iterating or calling next also gives you the integer value:</p>
<pre><code>In [12]: it = iter(s)   
In [13]: next(it)
Out[13]: 102
In [14]: for ele in s:
         print(ele)
   ....:     
102
111
111
</code></pre>
<p>In python2 you would just get each character.  So in your code as you iterate over the bytes objects returned from <code>encry.read()</code> you are getting the integer values so <code>ord(some_int)</code> obviously fails. </p>
<p>There is a thorough explanation <a href="https://docs.python.org/3/howto/pyporting.html#text-versus-binary-data" rel="nofollow">text-versus-binary-data</a> which explains the differences between python2 and python3 a snippet of which is:</p>
<blockquote>
<p>As part of this dichotomy you also need to be careful about opening files. Unless you have been working on Windows, there is a chance you have not always bothered to add the b mode when opening a binary file (e.g., rb for binary reading). 
  Under Python 3, binary files and text files are clearly distinct and mutually incompatible; see the io module for details. Therefore, you must make a decision of whether a file will be used for binary access (allowing to read and/or write binary data) or text access (allowing to read and/or write text data). You should also use io.open() for opening files instead of the built-in open() function as the io module is consistent from Python 2 to 3 while the built-in open() function is not (in Python 3 itâ€™s actually io.open()).</p>
<p>The constructors of both str and bytes have different semantics for the same arguments between Python 2 &amp; 3. Passing an integer to bytes in Python 2 will give you the string representation of the integer: <code>bytes(3) == '3'</code>. But in Python 3, an integer argument to bytes will give you a bytes object as long as the integer specified, filled with null bytes: <code>bytes(3) == b'\x00\x00\x00'</code>. A similar worry is necessary when passing a bytes object to str. In Python 2 you just get the bytes object back: <code>str(b'3') == b'3'</code>. But in Python 3 you get the string representation of the bytes object: <code>str(b'3') == "b'3'"</code>.</p>
<p>Finally, the indexing of binary data requires careful handling (slicing does not require any special handling). <strong>In Python 2, <code>b'123'[1] == b'2'</code> while in Python 3 <code>b'123'[1] == 50</code>. Because binary data is simply a collection of binary numbers, Python 3 returns the integer value for the byte you index on. But in Python 2 because bytes == str, indexing returns a one-item slice of bytes.</strong> The six project has a function named six.indexbytes() which will return an integer like in Python 3: six.indexbytes(b'123', 1).</p>
</blockquote>
</div>
<span class="comment-copy">Try this - <code>return ''.join(chr(ord(str(a)) ^ ord(str(b))) for (a, b) in zip(data, cycle(key)))</code></span>
<span class="comment-copy">You are opening the file with <code>b</code> so <code>a</code> is an int each time, <code>''.join(chr(a ^ ord(b)) for (a, b) in zip(data, cycle(key)))</code></span>
<span class="comment-copy">If they're already ints, couldn't you just remove the call to <code>ord</code>?</span>
