<div class="post-text" itemprop="text">
<pre><code>NumberTextSet3 = {"ten": 10, 
                  "hundred": 100,
                  "thousand": 1000,
                  "million": 1000000,
                  "billion": 1000000000,
                  "trillion": 1000000000000}
</code></pre>
<p>In this dictionary, I can access the number <code>1000000000000</code> by using <code>NumberTextSet3["trillion"]</code> .
But how would I access the the last word in the dictionary, maybe like: <code>NumberTextSet3[-1]</code> and have it return <code>"trillion"</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no last word in a dictionary.</p>
<p>To check it, try,</p>
<pre><code>print NumberTextSet3
</code></pre>
<p>You will get different ordered result in different time.</p>
<p>You can slightly modify your data structure to <code>[("ten",10),("hundred",100),...]</code></p>
<p>Now, you can use it with index.</p>
<p>For example,</p>
<pre><code>a=[("ten",10),("hundred",100)]

print a[0][0]
print a[1][1]
</code></pre>
<p>Output: </p>
<pre><code>ten
100
</code></pre>
<p>You can use an <code>OrderedDict</code> too</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a OrderedDict like this:</p>
<pre><code>from collections import OrderedDict

NumberTextSet3 = OrderedDict([("ten", 10),
                              ("hundred", 100),
                              ("thousand", 1000),
                              ("million", 1000000),
                              ("billion", 1000000000),
                              ("trillion", 1000000000000)])
# On Python2 this will work:
print NumberTextSet3.keys()[-1]
# This is a little bit longer but will work in Python2 and Python3:
print list(NumberTextSet3.keys())[-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A dictionary is not ordered so it has no such thing as "first" or "last" entry. You <em>can</em> access a specific key as follows:</p>
<pre><code>NumberTextSet3["trillion"]
</code></pre>
<p>or:</p>
<pre><code>NumberTextSet3.get("trillion")
</code></pre>
<p>If you want to access the list of keys you can do:</p>
<pre><code>NumberTextSet3.keys()
</code></pre>
<p>which return on my computer: <code>['billion', 'trillion', 'ten', 'thousand', 'million', 'hundred']</code></p>
<p>and as you can see - there is no "order" here.</p>
</div>
<div class="post-text" itemprop="text">
<p>You would need to extract all of the entries and then sort them:</p>
<pre><code>import operator

NumberTextSet3 = {"ten": 10, 
                  "hundred": 100,
                  "thousand": 1000,
                  "million": 1000000,
                  "billion": 1000000000,
                  "trillion": 1000000000000}

values = sorted(NumberTextSet3.items(), key=operator.itemgetter(1))

print values[-1][0]
</code></pre>
<p>Giving:</p>
<pre><code>trillion
</code></pre>
<p>If you wanted to do the reverse lookup, then you could create the inverse mapping as follows, and use that:</p>
<pre><code>InverseNumberTextSet3 = {v: k for k, v in NumberTextSet3.items()}
print InverseNumberTextSet3[1000000000000]
</code></pre>
<p>Giving: </p>
<pre><code>trillion
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can work although it's not guaranteed since dictionaries are not ordered.</p>
<pre><code>NumberTextSet3.items()[-1][0]
</code></pre>
<p>Edit: You may want to use a list of tuples (below) instead; in which case the same technique would work since <code>items()</code> gives the dict in key/value pairs [tuple].</p>
<pre><code>NumberTextSet3 = (("ten", 10), 
                  ("hundred", 100),
                  ("thousand", 1000),
                  ("million", 1000000),
                  ("billion", 1000000000),
                  ("trillion", 1000000000000))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python dictionaries have no ordering guarantee. </p>
<p>Implementation-wise this stems from the fact that the dictionary is a hash map and the hashmap has its key ordering determined by the hash function (which is supposed to be pseudo-random).</p>
<p>So, while you can access the <em>first</em> and <em>last</em> items in your dictionary (<code>NumberTextSet3.items()[0]</code> and <code>NumberTextSet3.items()[-1]</code>, respectively) these probably do not correspond the order in which you created the dictionary.</p>
<p>However, the standard library provides <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a>, which <em>preserves insertion order</em>, hence</p>
<pre><code>from collections import OrderedDict

NumberTextSet3 = OrderedDict((
    ("ten", 10),
    ("hundred", 100),
    ("thousand", 1000),
    ("million", 1000000),
    ("billion", 1000000000),
    ("trillion", 1000000000000)
))

print(list(NumberTextSet3.keys())) 
=&gt; ['ten', 'hundred', 'thousand', 'million', 'billion', 'trillion']
print(list(dict(NumberTextSet3).keys()))
=&gt; ['million', 'hundred', 'ten', 'billion', 'thousand', 'trillion']
</code></pre>
<p>Be aware of the fact that I change the dictionary literal to a tuple list. Using a dictionary literal would not work, since this would create a temporary, unordered dictionary and than pass that to <code>OrderedDict</code>, which would freeze the (quasi-random) order.</p>
</div>
<span class="comment-copy">You can see my updated answer. Hope, this is what you want.</span>
<span class="comment-copy">So this question is about: <b>Get the last value in a dictionary</b>. What does <b>How to access first type of data</b> mean?</span>
<span class="comment-copy">this is exaclty what i wanted. thanks!</span>
<span class="comment-copy"><code>TypeError: 'KeysView' object does not support indexing</code></span>
<span class="comment-copy">Ok doesn't happen for me on Python 2.7.10</span>
<span class="comment-copy">if you construct list before indexing, it should work always: <code>print list(NumberTextSet3.keys())[-1]</code> - is this working for you @KevinGuan ?</span>
<span class="comment-copy">Well, I forgot you're on Python 2, I'm sorry for that. And <code>list(NumberTextSet3.keys())[-1]</code> will work on Python 3 :P</span>
<span class="comment-copy">@KevinGuan Thanks for trying :)  I updated the answer.</span>
<span class="comment-copy">So would I need 2 lists? One for "trillion" and one for "1000000000000"?</span>
