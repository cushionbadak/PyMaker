<div class="post-text" itemprop="text">
<p>I'm attempting to use <a href="https://docs.python.org/2/reference/datamodel.html#customizing-attribute-access" rel="nofollow"><code>__getattr__</code></a> to handle undefined method calls on an object.  I want the end result to act much like the <a href="http://perldoc.perl.org/perlsub.html#Autoloading" rel="nofollow"><code>AUTOLOAD</code></a> function in Perl.</p>
<p>This can be done with the following code.</p>
<hr/>
<p><strong>test.py:</strong></p>
<pre><code>#!/usr/bin/python
import Object

# Create an object
object = Object.Object()

# Try and access the "thing" attribute
object.thing

# Try and call the "thing" method
object.thing()

# Call the "thing" method with arguments
object.thing("arg1", "arg2")
</code></pre>
<p><strong>Object.py:</strong></p>
<pre><code>class test(object):
"""Class for testing purposes!"""

    def __getattr__(self, name):
        """Handle undefined method calls!"""

        def __AUTOLOAD(*args):
            """Hack to simulate Perl's AUTOLOAD function."""

            # Do something with the args!
            return self.f(name, *args)
        return __AUTOLOAD

    # Simply print the args (as an example)
    def f(self, name, *args):
    """Do something with the args!"""

        print args
        return
</code></pre>
<p><strong>output:</strong></p>
<pre><code>&gt;test.py
()
('arg1', 'arg2')
</code></pre>
<hr/>
<p>The problem is,  I only want this to work for method calls.  If it attempts to access an attribute that doesn't exist I want the script to throw an exception.</p>
<p>This means that when I try and access the "thing" attribute I want this to fail, but it should work in the other two situations.</p>
<hr/>
<h2>What I think could work:</h2>
<p>If I could find a way for Python to differentiate an empty <a href="https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow">tuple</a> <code>()</code> and a completely empty variable this might be doable.  As you can see, the <code>object.thing</code> call did not print anything because the <code>args</code> variable did not contain anything.</p>
<p>Is there a way to trap on this in Python and raise an exception if the <code>args</code> variable is COMPLETELY empty and is not just an empty tuple?</p>
</div>
<div class="post-text" itemprop="text">
<p>As a hacky AUTOLOAD proxy, you can do something like:</p>
<pre><code>class Thing(object):
    def __init__(self, default):
        self.default = default

    def __getattr__(self, name):
        try:
            return getattr(self.default, name)
        except AttributeError:
            return self.default    
</code></pre>
<p>Then use like:</p>
<p>First define a default function:</p>
<pre><code>&gt;&gt;&gt; def auto(*args, **kwargs):
&gt;&gt;&gt;     print 'default', args, kwargs
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; Thing(auto).not_defined()
default () {}
&gt;&gt;&gt; Thing(auto).not_defined(123)
default (123,) {}
&gt;&gt;&gt; Thing(auto).not_defined(123, mu=345)
default (123,) {'mu': 345}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>len(args)</code> to count the number of arguments:</p>
<pre><code>def f(self, name, *args):
    if len(args) == 0:
        print "No args"
    else:
        print "%d args" % len(args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If args is completely empty, then </p>
<pre><code>args is None == True
</code></pre>
<p>So you just need to compare </p>
<pre><code>args == (). 
</code></pre>
<p>It will return true if args is an empty tuple, false if args is None, since </p>
<pre><code>() is None == False
</code></pre>
</div>
<span class="comment-copy">Your premise is incorrect.  <code>object.thing</code> is a reference to the method, but does not actually call <code>object.thing()</code>.  That's why it did not print anything.</span>
<span class="comment-copy">List of slightly unintuitive False things: <a href="https://docs.python.org/3/library/stdtypes.html#truth" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#truth</a>. This is why you'll hear "False-ish" or "False-like" around Python.</span>
<span class="comment-copy">why are you trying to reproduce perl autoload? it's python</span>
<span class="comment-copy">also, maybe you should have a look to the inspect module. It has isclass, ismethod, and plenty of other useful tools for introspection  <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">docs.python.org/2/library/inspect.html</a></span>
<span class="comment-copy">@Apero, I'm trying to write a WinCVS API in Python, and instead of defining each and every CVS function (I don't even know what they all are) if I define a simple AUTOLOAD routine to pass unidentified methods to CVS.  Doing this will allow the API to handle any CVS command and will allow CVS itself to deal with any error handling.  It would be complete overkill to try and define all of the individual CVS commands.</span>
<span class="comment-copy">I want it to work with no args though, so that wouldn't work either.  Basically I want a way to differentiate between <code>object.thing</code> and <code>object.thing()</code>... <code>object.thing</code> should fail while <code>object.thing()</code> should call <code>__AUTOLOAD</code> and then <code>f()</code></span>
<span class="comment-copy"><code>object.thing</code> does not call the method, it simply returns a reference to it:  <code>foo = object.thing; foo()</code></span>
<span class="comment-copy">The more idiomatic expression is <code>args is None</code>.</span>
<span class="comment-copy">Thanks. Fixed code based on your suggestion.</span>
