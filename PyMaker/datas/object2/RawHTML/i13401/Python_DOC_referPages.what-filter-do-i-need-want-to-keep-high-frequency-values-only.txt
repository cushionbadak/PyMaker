<div class="post-text" itemprop="text">
<p>I am asking this question because I am not quite sure which filter I should be using. </p>
<p>Mine is simply a signal made up of discrete values as such <code>s = [1 2 2 2 3 4 2 4 3 4 5 3 2 3 3]</code>. Then I would like, per window size, a filtered signal. So e.g. if I use a window size of 5 for <code>s</code> then I would get; <code>s_filtered = [2 2 2 2 2 4 4 4 4 4 3 3 3 3 3]</code>. Hence I want to keep the values that are of the highest frequency in each block. For indices 0:4 (window size 5) the values of highest frequency is 2, so I want my "filtered" signal (if that is indeed the correct terminology) to have 2 in all indices 0:4 for the "filtered" signal.</p>
<p>Currently I am using just a median filter, but I do no think this is the correct approach. </p>
<p>Here is some python code to demonstrate what I am doing (but as said, which I think is wrong).</p>
<pre><code>import numpy as np
import pylab *
from scipy.signal import medfilt

test = np.random.randint(10, size=1000)

fig, ax1 = plt.subplots(1,sharey=True, sharex=True, figsize=(15,5))
ax1.plot(test)
ax1.plot(medfilt(test,[99]),'r')
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/9Nd0N.png" rel="nofollow noreferrer"><img alt="Random data with median filtered signal in red." src="https://i.stack.imgur.com/9Nd0N.png"/></a></p>
<p>Where the red line is the filtered signal for a window size of 99.</p>
<p><strong>SOLUTION:</strong></p>
<pre><code>import itertools
import collections

def grouper(iterable, n, fillvalue=None):
    args = [iter(iterable)] * n
    return itertools.izip_longest(*args, fillvalue=fillvalue)

s = [1, 2, 2, 2, 3, 4, 2, 4, 3, 4, 5, 3, 2, 3, 3]

list(chain.from_iterable(repeat(collections.Counter(x).most_common(1)[0][0],5) for x in grouper(s,5)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>grouper</code> function from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><em>itertools recipes</em></a> to group your array based on a specified length and then find the most common item using <code>collections.Counter.most_common()</code> method and use <code>itertools.repeat</code> to repeat your item 5 time and at last chain the repeated objects with <code>itertools.chain.from_iterable</code> : </p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>Demo :</p>
<pre><code>&gt;&gt;&gt; list(chain.from_iterable(repeat(Counter(x).most_common(1)[0][0],5) for x in grouper(s,5)))
[2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3]
</code></pre>
</div>
<span class="comment-copy">How is this a programming question?</span>
<span class="comment-copy">Can you explain more that how you want to get <code>s_filtered</code>?</span>
<span class="comment-copy">I just wrote that down as that is what I would ideally like from a given signal such as <code>s</code>. It is not calculated in any way or fashion.</span>
<span class="comment-copy">@Astrid So whats the logic behind it? why you don't preserve the 1 or 5???</span>
<span class="comment-copy">The most common value in a sample is called the "mode", and yes it's a kind of "average". See <a href="https://en.wikipedia.org/wiki/Mode_%28statistics%29#Comparison_of_mean.2C_median_and_mode" rel="nofollow noreferrer">this</a> on wikipedia.</span>
<span class="comment-copy">That works nicely thanks.</span>
