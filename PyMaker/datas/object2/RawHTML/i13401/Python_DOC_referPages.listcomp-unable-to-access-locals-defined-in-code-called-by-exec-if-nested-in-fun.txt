<div class="post-text" itemprop="text">
<p>Are there any python gurus out there able to explain why this code doesn't work : </p>
<pre><code>def f(code_str):
    exec(code_str)

code = """
g = 5
x = [g for i in range(5)]
"""

f(code)
</code></pre>
<p>Error: </p>
<pre><code>Traceback (most recent call last):
  File "py_exec_test.py", line 9, in &lt;module&gt;
    f(code)
  File "py_exec_test.py", line 2, in f
    exec(code_str)
  File "&lt;string&gt;", line 3, in &lt;module&gt;
  File "&lt;string&gt;", line 3, in &lt;listcomp&gt;
NameError: name 'g' is not defined
</code></pre>
<p>while this one works fine: </p>
<pre><code>code = """
g = 5
x = [g for i in range(5)]
"""

exec(code)
</code></pre>
<p>I know it has something to do with locals and globals, as if I pass the exec function the locals and globals from my main scope it works fine, but I don't exactly understand what is going on. </p>
<p>Could it be a bug with Cython?</p>
<p>EDIT: Tried this with python 3.4.0 and python 3.4.3</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is because the list comprehension is closureless in the <code>exec()</code>.</p>
<p>When you make a function (in this case a list comprehension) outside of an <code>exec()</code>, the parser builds a tuple with the free variables (the variables used by a code block but not defined by it, ie. <code>g</code> in your case). This tuple is called the function's closure. It is kept in the <code>__closure__</code> member of the function.</p>
<p>When in the <code>exec()</code>, the parser won't build a closure on the list comprehension and instead tries by default to look into the <code>globals()</code> dictionary. This is why adding <code>global g</code> at the beginning of the code will work (as well as <code>globals().update(locals())</code>).</p>
<p>Using the <code>exec()</code> in its two parameter version will also solve the problem: Python will merge the globals() and locals() dictionary in a single one (as per <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow">the documentation</a>). When an assignation is performed, it is done in the globals <em>and</em> locals at the same time. Since Python will check in the globals, this approach will work.</p>
<p>Here's another view on the problem:</p>
<pre><code>import dis

code = """
g = 5
x = [g for i in range(5)]
"""

a = compile(code, '&lt;test_module&gt;', 'exec')
dis.dis(a)
print("###")
dis.dis(a.co_consts[1])
</code></pre>
<p>This code produces this bytecode:</p>
<pre><code>  2           0 LOAD_CONST               0 (5)
              3 STORE_NAME               0 (g)

  3           6 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x7fb1b22ceb70, file "&lt;boum&gt;", line 3&gt;)
              9 LOAD_CONST               2 ('&lt;listcomp&gt;')
             12 MAKE_FUNCTION            0
             15 LOAD_NAME                1 (range)
             18 LOAD_CONST               0 (5)
             21 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             24 GET_ITER
             25 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             28 STORE_NAME               2 (x)
             31 LOAD_CONST               3 (None)
             34 RETURN_VALUE
###
  3           0 BUILD_LIST               0
              3 LOAD_FAST                0 (.0)
        &gt;&gt;    6 FOR_ITER                12 (to 21)
              9 STORE_FAST               1 (i)
             12 LOAD_GLOBAL              0 (g)      &lt;---- THIS LINE
             15 LIST_APPEND              2
             18 JUMP_ABSOLUTE            6
        &gt;&gt;   21 RETURN_VALUE
</code></pre>
<p>Notice how it performs a <code>LOAD_GLOBAL</code> to load <code>g</code> at the end.</p>
<p>Now, if you have this code instead:</p>
<pre><code>def Foo():
    a = compile(code, '&lt;boum&gt;', 'exec')
    dis.dis(a)
    print("###")
    dis.dis(a.co_consts[1])
    exec(code)

Foo()
</code></pre>
<p>This will provide exactly the same bytecode, which is problematic: since we're in a function, <code>g</code> won't be declared in the global variable, but in the locals of the function. But Python tries to search it in the global variables (with <code>LOAD_GLOBAL</code>)!</p>
<p>This is what the interpreter does outside of <code>exec()</code>:</p>
<pre><code>def Bar():
    g = 5
    x = [g for i in range(5)]

dis.dis(Bar)
print("###")
dis.dis(Bar.__code__.co_consts[2])
</code></pre>
<p>This code gives us this bytecode:</p>
<pre><code>30           0 LOAD_CONST               1 (5)
             3 STORE_DEREF              0 (g)

31           6 LOAD_CLOSURE             0 (g)
              9 BUILD_TUPLE              1
             12 LOAD_CONST               2 (&lt;code object &lt;listcomp&gt; at 0x7fb1b22ae030, file "test.py", line 31&gt;)
             15 LOAD_CONST               3 ('Bar.&lt;locals&gt;.&lt;listcomp&gt;')
             18 MAKE_CLOSURE             0
             21 LOAD_GLOBAL              0 (range)
             24 LOAD_CONST               1 (5)
             27 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             30 GET_ITER
             31 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             34 STORE_FAST               0 (x)
             37 LOAD_CONST               0 (None)
             40 RETURN_VALUE
###
 31           0 BUILD_LIST               0
              3 LOAD_FAST                0 (.0)
        &gt;&gt;    6 FOR_ITER                12 (to 21)
              9 STORE_FAST               1 (i)
             12 LOAD_DEREF               0 (g)      &lt;---- THIS LINE
             15 LIST_APPEND              2
             18 JUMP_ABSOLUTE            6
        &gt;&gt;   21 RETURN_VALUE
</code></pre>
<p>As you can see, <code>g</code> is loaded using <code>LOAD_DEREF</code>, available in the tuple generated in the <code>BUILD_TUPLE</code>, that loaded the variable <code>g</code> using <code>LOAD_CLOSURE</code>. The <code>MAKE_CLOSURE</code> statement creates a function, just like <code>MAKE_FUNCTION</code> seen earlier, but with a closure.</p>
<p>Here's my guess on the reason it is this this way: The closures are created when needed when the module is read the first time. When <code>exec()</code> is executed, it is not able to realize the functions defined within its executed code needs closure. For him, the code in its string that doesn't begin with an indentation is in the global scope. The only way to know if he was invoked in a way that requires a closure would require <code>exec()</code> to inspect the current scope (which seems pretty hackish to me).</p>
<p>This is indeed an obscure behavior which may be explained but certainly raises some eyebrows when it happens. It is a side-effect well explained in <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures" rel="nofollow">the Python guide</a>, though it is hard to understand why it applies to this particular case.</p>
<p>All my analysis was made on Python 3, I have not tried anything on Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT 2</strong></p>
<p>As other commenters have noticed, you appear to have found a bug in Python 3 (doesn't happen for me in 2.7).</p>
<p>As discussed in the comments below this answer, the original code:</p>
<pre><code>def f(code_str):
    exec(code_str)
</code></pre>
<p>is functionally equivalent to:</p>
<pre><code>def f(code_str):
    exec(code_str, globals(), locals())
</code></pre>
<p>On my machine, running 3.4 it is functionally equivalent to the extent that it will blow up just the same.  The bug here has to do with running the list comprehension while having two mapping objects.  For example:</p>
<pre><code>def f(code_str):
    exec(code_str, globals(), {})
</code></pre>
<p>will also fail with the same exception.</p>
<p>To avoid provoking this bug, you have to pass exactly one mapping object (because not passing any is equivalent to passing two), and to insure that it works under all cases, you should never pass a function's <code>locals()</code> as that mapping object.</p>
<p>The rest of this answer was written before I realized behavior was different under 3.  I'm leaving it, because it's still good advice and gives some insights into exec behavior.</p>
<p>You should <em>never</em> directly alter a function's <code>locals()</code> dictionary.  That messes with optimized lookups.  See, e.g. <a href="https://stackoverflow.com/questions/4997184/why-is-it-bad-idea-to-modify-locals-in-python">this question and its answers</a></p>
<p>In particular, as the <a href="https://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer">Python doc explains</a>:</p>
<blockquote>
<p>The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.</p>
</blockquote>
<p>Because you called <code>exec()</code> from within a function and didn't explicitly pass in <code>locals()</code>, you modified the <strong>function's</strong> locals, and as the doc explains, that doesn't always work.</p>
<p>So the Pythonic way, as others have pointed out, is to explicitly pass mapping objects to exec().</p>
<p><strong>Python 2.7</strong></p>
<p>When is it OK to modify <code>locals()</code>?  One answer is when you are building a class -- at that point it is merely another dictionary:</p>
<pre><code>code = """
g = 5
x = [g for i in range(5)]
"""

class Foo(object):
    exec(code)

print Foo.x, Foo.g
</code></pre>
<blockquote>
<p>[5, 5, 5, 5, 5] 5</p>
</blockquote>
<p><strong>EDIT -- Python 3</strong> As others point out, there appears to be a bug with the <code>locals()</code> here, independent of whether you are inside a function.  You can work around this by <em>only</em> passing a single parameter for the globals.  The Python documentation explains that if you only pass a single dict, that will be used for both global and local accesses (it's really the same thing as if your code is not executing in a function or class definition -- there <em>is</em> no <code>locals()</code>).  So the bug related to <code>locals()</code> does not appear in this case.</p>
<p>The class example above would be:</p>
<pre><code>code = """
g = 5
x = [g for i in range(5)]
"""

class Foo(object):
    exec(code, vars())

print(Foo.x, Foo.g)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok! Did some looking about, and it looks like your line <code>x = [g for i in range(5)]</code> is trying to create a new and uninitialized value <code>g</code> rather than using the one you defined earlier. </p>
<p>The pythonic fix is to pass in your scope to your <code>exec()</code> like so:</p>
<pre><code>def f(code,globals,locals):
    exec(code,globals,locals)

code = """
g = 5
x = [g for i in range(5)]
print(x)
"""

f(code,globals(),locals())
</code></pre>
<p>That was a very good question. I learned a lot from answering it.</p>
<p>Reference this for more info on <code>exec()</code>: <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow">https://docs.python.org/3/library/functions.html#exec</a></p>
<p>A shortened version was suggested by @Pynchia and defines the <code>globals()</code> when calling <code>exec()</code> within the function.</p>
<pre><code>def f(code):
    exec(code,globals())

code = """
g = 5
x = [g for i in range(5)]
print(x)
"""

f(code)
</code></pre>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/4198906/python-list-comprehension-rebind-names-even-after-scope-of-comprehension-is-thi" title="python list comprehension rebind names even after scope of comprehension is thi">stackoverflow.com/questions/4198906/â€¦</a></span>
<span class="comment-copy">I'm not having that problem in python 3.4</span>
<span class="comment-copy">I do have the same problem with python 3.4.3 on CPython</span>
<span class="comment-copy">I have the issue with python 3.4.0 and python 3.4.3</span>
<span class="comment-copy">it's definitely due to the list comprehension. If you use <code>x = [g]*5</code> it works fine</span>
<span class="comment-copy">Excellent analysis.  AFAICT it works correctly in Python 2, though.</span>
<span class="comment-copy">If we take the same <code>code</code> str, and call <code>exec(code, {}, {})</code> we get the same error as presented in the question, no matter where we call it. Perhaps we are using a different version of python? (I tested this with Python 3.4.3)</span>
<span class="comment-copy">Also, I just tested your variant and I still get the same error, so I'd say we are most definitely not using the same Python.</span>
<span class="comment-copy">@PatrickMaupin Your solution works with Python 2, but not on Python 3 (even after adding parentheses to the print function). It still crashes. Passing an empty locals dictionary to exec still won't work. The bytecodes is also problematic, it never displays a LOAD_NAME in the problematic case, whereas it issues a LOAD_CLOSURE when it works. Putting <code>global g</code> just before <code>g = 5</code> solves the problem.</span>
<span class="comment-copy">Yes, I was using 2.7.  Could be a bug in 3.  However, your function works with 3 if you only pass the globals, and not locals.</span>
<span class="comment-copy">@levesque -- The documentation is clear that if you only pass <code>globals()</code> all variables (local and global) will use that dict.  So ISTM (or maybe I don't understand your question), the question is not "why it works with <code>globals()</code> only" but "why it doesn't work when <code>locals()</code> added."  Appears to be a bug in Python.</span>
<span class="comment-copy">are you sure you need to pass those as parameters to the function <code>f</code>? It can do it by itself calling <code>exec(code, globals(), locals())</code>. I have tried it before, see my comment above, and the OP included such solution already.</span>
<span class="comment-copy">Simply didn't see that comment while writing the answer. I like it though, I'll update my codeblock.</span>
<span class="comment-copy">Just tested prior to updating, throws the same error if <code>exec(code,globals(),locals())</code> is used. The scope has to be passed when calling <code>f()</code></span>
<span class="comment-copy">Sorry, remove <code>locals()</code>. I had tried with <code>exec(code_str, globals())</code>, since there would be no point in providing the same locals within the function</span>
<span class="comment-copy">While this works (even with just <code>globals()</code>, I'm still at a loss as to why...</span>
