<div class="post-text" itemprop="text">
<p>Suppose I have two lists:</p>
<pre><code>a = [0.1,0.2,0.4,0.5]
b = [0.5,0.6,0.7, 0.8]

c = [all the sums of a and b]

c = []
for a_ in a:
   for b_ in b:
      c.append(a_+b_)
</code></pre>
<p>Now, c will contain values of the sum of a_ and b_
Get the 5 largest elements in c</p>
<p>And then return what a_ and b_ indices generated those largest sums.</p>
<p>My idea was to track something like <code>c[index_of_a][index_of_b] = a_+b_</code></p>
<p>So, the question is to what indices of a_ and b_ returns the k largest a_+b_.</p>
<p>And then search for largest a_+b_
But I am wondering if there is a better way to do this.
Thanks</p>
<p>Edit: The answer to above is:</p>
<pre><code>c = [0.6, 0.7, 0.7999999999999999, 0.9, 0.7, 0.8, 0.8999999999999999, 1.0, 0.9, 1.0, 1.1, 1.2000000000000002, 1.0, 1.1, 1.2, 1.3]
</code></pre>
<p>5 <code>largest = sorted(c, reverse=True)[:5]</code></p>
<pre><code>largest = [1.3, 1.2000000000000002, 1.2, 1.1, 1.1]
And then corresponding indices in a and b list are:
a_index = 3, b_index = 3 (1.3)
a_index = 2, b_index = 3 (1.2)
</code></pre>
<p>and so on</p>
</div>
<div class="post-text" itemprop="text">
<p>A brute force method</p>
<pre class="lang-python prettyprint-override"><code>a = [0.1,0.2,0.4,0.5]
b = [0.5,0.6,0.7, 0.8]

# find all of the possible sums
# - store with the sum the item indices that were used
# - enumerate will give us the index and the item
c = [(x + y, x_i, y_i) for x_i, x in enumerate(a) 
                       for y_i, y in enumerate(b)]

# sort this list
# - as we are sorting tuples, it will sort on the first 
#   tuple item initially (ie the sum), and then the others
# - then just take the list five items
indices = [(x_i, y_i) for _, x_i, y_i in sorted(c)[-5:]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>enumerate</code>, you can keep the original indices of each element.  You would then need to specify the key to be the result of the sum.</p>
<p>The below will generate a list of tuples, which contains a's index, b's index, and the sum in that order.</p>
<pre><code>sorted([(x[0], y[0], x[1]+y[1]) for x in enumerate(a)
                                for y in enumerate(b)],
       key=lambda x: x[2], reverse=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on @donkopotamus's code, but should require far less memory, and less CPU time as well if the inputs lists <code>a</code> and <code>b</code> are sufficiently large. It's just using generator expressions and <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow"><code>heapq.nlargest</code></a> for the purpose they were made for:</p>
<pre><code>import heapq

a = [0.1,0.2,0.4,0.5]
b = [0.5,0.6,0.7, 0.8]

# Change: generator expression for all of the possible sums (not realized yet)
# - store with the sum the item indices that were used
# - enumerate will give us the index and the item
c = ((x + y, x_i, y_i) for x_i, x in enumerate(a) 
                       for y_i, y in enumerate(b))

# Use heapq.nlargest to get the indices that produce the largest sums
# without storing all sums in memory (it maintains a heap internally that
# contains only the five largest values seen to date at once)
# - as we are sorting tuples, it will sort on the first 
#   tuple item initially (ie the sum), and then the others
# - then just take the list five items
indices = [(x_i, y_i) for _, x_i, y_i in heapq.nlargest(5, c)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>largest, a_index, b_index = [0] * 3
for i, n1 in enumerate(a):
    for j, n2 in enumerate(b):
        if n1 + n2 &gt; largest:
            largest = n1 + n2
            a_index = i
            b_index = j
</code></pre>
</div>
<span class="comment-copy">What is the expected output for the case shown in the question</span>
<span class="comment-copy">I would upvote this answer if you explained what you are doing and why it is useful.</span>
<span class="comment-copy">Under the hood the <code>heapq</code> is just sorting (maintaining a heap) out of the collection.  If you slurp in the whole collection and heapify it ... that's the same runtime/space complexity (O(n*log(n))) as sorting it.  If you establish the heap with five items (arbitrarily grabbing the first five) and then use <code>heappushpop()</code> method over the rest then you're solving it in constant space and linear time.</span>
<span class="comment-copy">@JimDennis: <code>heapq.nlargest</code> maintains a heap of the request size, so it's only five elements being stored at any given time with smaller elements getting evicted and freed as larger elements come in. The complexity of <code>heappushpop</code> is <code>O(log(n))</code>, but the <code>n</code> in this case is <code>5</code>, <i>not</i> the total number of inputs to the function. So the overall cost is proportionate to <code>log(5) * len(inputs)</code>, not <code>log(len(inputs)) * len(inputs)</code>, which is what sorting costs.</span>
<span class="comment-copy">@ShadoRanger: Hmmm.  I wasn't aware that nlargest() would work that way.  I'd assumed from the docs that it was necessary to call it on a list after heapify() (of the entire list).  (My use-case has always been to maintain top-K of a continuous stream anyway).</span>
<span class="comment-copy">The <code>heapq</code> module is a little weird. It's got the "low level" heap manipulation functions, plus a bunch of utility functions that are built from the heap primitives. A lot of people make the same mistake. I'll note, if memory isn't an issue, <code>sorted</code> can win anyway, solely because <code>sorted</code> is implemented in C, while <code>heapq</code> only implements the primitives in C; the utility functions are written in Python, so they incur a lot of overhead that <code>sorted</code> avoids. Even so, for a test case of 10,000 random elements, selecting 5 largest, on my Py 3.5 install, <code>sorted</code> took ~6x longer than <code>nlargest</code>.</span>
<span class="comment-copy">@shadowranger I considered the heapq alternative, but as you note, <code>sorted</code> is far faster over small lists.  But when I was thinking about <code>heapq</code>, I was considering the possibility of getting the top 5 members of each list <code>a</code> and <code>b</code> separately, and using the fact that we know the maximum element must be made up of the maximums of <code>a</code> and <code>b</code> etc.</span>
