<div class="post-text" itemprop="text">
<p>I am writing a Python script that enumerates all processes running on the computer. My current code does this but prints this out in a large block of text that is hard to read. How can I improve my script to have the output text in a vertical list for each process and all?</p>
<pre><code>import subprocess
print(subprocess.check_output('set',shell=True)
</code></pre>
<p>*Edit: Here is the output text from the above script
<a href="https://i.stack.imgur.com/cKx3N.jpg" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/cKx3N.jpg"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>set</code> should already print with newlines, so if they're not showing up, something is more wrong than you're telling us. You could always double up the newlines if you want to split the settings apart, e.g.:</p>
<pre><code>import subprocess
print(subprocess.check_output('set',shell=True).replace('\n', '\n\n'))
</code></pre>
<p>If the problem is that you're running on Python 3 and the <code>bytes</code> object is a big blob, you can make <code>subprocess</code> decode it to a friendly printable string for you:</p>
<pre><code>print(subprocess.check_output('set',shell=True, universal_newlines=True))
# Yes, the name of the keyword is dumb; it sounds like it handles different
# line ending conventions, but on Python 3, it also decodes from `bytes`
# to `str` for you.
</code></pre>
<p>For the general case of line wrapping nicely (though it does nothing for paragraphs of text that are just "too big"), you might want to look at the <a href="https://docs.python.org/3/library/textwrap.html" rel="nofollow"><code>textwrap</code> module</a>; it splits a block of text up into a <code>list</code> of lines wrapped nicely at word boundaries so you don't have words split across lines.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://ss64.com/nt/set.html" rel="nofollow"><code>set</code> is an internal command</a> that displays <code>cmd.exe</code> environment variables in your case.</p>
<p>To get environment variables in Python, use <code>os.environ</code> instead.</p>
<p>If you want to get the output of <code>set</code> command as a list of strings (not tested):</p>
<pre><code>#!/usr/bin/env python3
import os
from subprocess import check_output

lines = check_output('cmd.exe /U /c set').decode('utf-16').split(os.linesep)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Disclaimer: I have not done what you are doing before but this might work. </p>
<pre><code>import subprocess

processes = subprocess.check_output('set',shell=True)

processes = processes.decode('UTF-8').split('\n') # convert bytes to unicodes and split 

for process in processes:
    print(process)
</code></pre>
</div>
<span class="comment-copy">Give an example how your output should look like. I find that the output is already quite readable.</span>
<span class="comment-copy"><code>subprocess.check_output</code> returns a string. You can do anything you want with it, for instance split it by newlines with <code>split</code>, that will create a list.</span>
<span class="comment-copy">@user38034 that will split by whitespace.  maybe you meant splitlines.</span>
<span class="comment-copy">@wim I meant <code>s.split('\n')</code> ;-)</span>
<span class="comment-copy">That said, <code>splitlines</code> is strictly better (it doesn't end the resulting list with an empty <code>str</code> when the file happens to end with a newline, which many text editors insert automatically), and offers the option to split while keeping the newlines.</span>
<span class="comment-copy"><code>.replace('\n', '\n\n')</code> is incorrect; the output shows that OP uses Python 3. <code>universal_newlines=True</code> uses <code>locale.getpreferredencoding(False)</code> that may return something like <code>cp1252</code> while <code>set</code> may use cmd.exe OEM encoding such as <code>cp437</code>. If you don't want to use <code>os.environ</code> (that probably uses Unicode API on Windows) for some reason then you could try to <a href="http://stackoverflow.com/a/32902728/4279">force <code>set</code> to use utf-16 encoding, to support non-ascii paths</a></span>
<span class="comment-copy">This worked as well as @ShadowRanger's answer</span>
<span class="comment-copy">@DylanF: it is unlikely that <code>set</code> uses utf-8 here; it is probably <code>cp437</code> i.e., expect failure if there are non-ascii paths. The output in your question clearly shows that the newline is <code>b'\r\n'</code>, not <code>'\n'</code></span>
