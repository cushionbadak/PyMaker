<div class="post-text" itemprop="text">
<p>The assignment is about how to deal with duplicates in a dictionary.
They ask to return a list of keys that maps the values that are unique in a dictionary and sort them in increasing order.</p>
<p>This is my code:</p>
<pre><code>def uniqueValues(aDict):
    unique = []
    s =[]
    if len(aDict) == 1:
        s.append(aDict.keys()[0])
    else:
        for i in range(0, len(aDict)): 
            for j in range(0,len(aDict)):
                if (i !=j) and (aDict.values()[i] != aDict.values()[j]) :  # check all values that are not equal to each other and store the key value in the unique list.
                    unique.append(aDict.keys()[i])   
        for i in unique: #Take away all duplicates of the key values
            if i not in s:
                s.append(i)
        s.sort()
    return s
</code></pre>
<p>This gives me wrong key values:</p>
<pre><code>&gt;&gt;&gt; uniqueValues({8: 3, 1: 3, 2: 2})
[1, 2, 8]
</code></pre>
<p>This is correct:</p>
<pre><code>&gt;&gt;&gt; uniqueValues({0: 9, 1: 1, 2: 7, 3: 3, 5: 2, 6: 5, 7: 8, 9: 10, 10: 0})
[0, 1, 2, 3, 5, 6, 7, 9, 10]
</code></pre>
<p>What is wrong? I have used several tools online to visualize what's going on, but I still don't get it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your function is that you put a key in the <code>unique</code> set as soon as its value is different from <em>one</em> other value. You have to check against <em>all others</em>! For the same reason, you put the keys into <code>unique</code> multiple times, hence the need for <code>s</code>.</p>
<p>You can fix your method like this:</p>
<pre><code>def uniqueValues(aDict):
    unique = []
    if len(aDict) == 1:
        return list(aDict.keys())
    else:
        values = aDict.values()
        for i in range(0, len(aDict)): 
            for j in range(0,len(aDict)):
                if i != j and (values[i] == values[j]) :
                    break # found duplicate, skip to next i
            else: # loop completed without break -&gt; add to list
                unique.append(aDict.keys()[i])   
        return sorted(unique)
</code></pre>
<p>But you can also make it way shorter using a list comprehension and the <code>all</code> builtin function.</p>
<pre><code>def uniqueValues(aDict):
    return sorted([k for k in aDict if all(aDict[k] != aDict[o] for o in aDict if o != k)])
</code></pre>
<p>But this still has quadratic complexity, as you have to compare each value with each other. If your values are <a href="https://docs.python.org/3/glossary.html" rel="nofollow">hashable</a> (and <em>only</em> then), you can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a>, making the whole thing a lot more efficient, as you just have to look up the value in another dictionary.</p>
<pre><code>import collections
def uniqueValues(aDict):
    counter = collections.Counter(aDict.values())
    return sorted([k for k, v in aDict.items() if counter[v] == 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should give you a sorted list of keys, for which values in the dictionary appear only once</p>
<pre><code>l = aDict.values()
uniqueKeys = sorted([x for x in aDict if l.count(aDict[x]) == 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a Counter dict to count the occurrences and keep values that have only appear once:</p>
<pre><code>from collections import Counter

def unique_values(a_dict):
    cn = Counter(a_dict.values())
    return sorted(k for k, v in cn.items() if v == 1)
</code></pre>
<p>The Counter dict counts the frequency of each subelement in your dict values, <code>if v == 1</code> is True the value was only seen once.</p>
<p>Output:</p>
<pre><code>In [3]: unique_values({8: 3, 1: 3, 2: 2})
Out[3]: [2]

In [4]: unique_values({0: 9, 1: 1, 2: 7, 3: 3, 5: 2, 6: 5, 7: 8, 9: 10, 10: 0})
Out[4]: [0, 1, 2, 3, 5, 7, 8, 9, 10]
</code></pre>
<p>If you want the keys associated with the unique values and not the actual values:</p>
<pre><code> return sorted(k for k,v in a_dict.items() if cn[v] == 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you could <code>count</code> to establish that a value occurs once and only once in the entire dictionary, that is, it is unique, you can then easily collect the associated key in a list, as follows:</p>
<pre><code>def uniqueValues(aDict):
    '''
    aDict: a dictionary
    output: returns a list of dictionary keys with unique values
    '''
    value_list = []
    key_list = []

    for value in aDict.values():
        value_list.append(value)

    for key, value in aDict.items():
        if value_list.count(value) == 1:
            key_list.append(key)
    return key_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since we're giving answers away...This method avoids having to use any ifs.</p>
<pre><code>a = {1: 3, 2: 3, 3: 4}
b = {v: k for k,v in a.items()} # store values as keys in new dictionary gets rid of dupes
b.values.sort() # get the values from b which are the keys from a
&gt; [2, 3] # or could be [1, 3] since dicts are not sorted
</code></pre>
<p>Which could be made to a one liner:</p>
<pre><code>def uniqueValues(aDict):
    return sorted({v: k for k,v in a.items()}.values())
</code></pre>
</div>
<span class="comment-copy">Why do you think <code>[1, 2, 8]</code> is wrong? You sorted the keys, that's the result you should expect If you want to sort the keys by their corresponding value, consider <code>collections.Counter</code>, which has a <code>most_common</code> method.</span>
<span class="comment-copy">Do you just wan to find a way to get the <code>list</code> of keys with unique <code>values</code> in a <code>dictionary</code>? If so, there is a much simpler way to do it.</span>
<span class="comment-copy">You should read up on list and dictionary comprehensions which give you a way iterate and perform actions in a concise manner.  Also should read up on for each loops.  A hint would be to think of what data type would get rid of duplicate values but still maintain a relationship between the key.</span>
<span class="comment-copy">Yea...I was think in those term that instead I should look for duplicate values and then compare it the orginal list and create annothe loop for that...but I see my misstake...learning programming is gonna be a pain I see..Thanks m8</span>
<span class="comment-copy">This is quadratic when a Counter dict can do it in O(n), you  also don't need to create a list for sorted you can pass a generator expression</span>
<span class="comment-copy">why the downvote?  Is this wrong?</span>
<span class="comment-copy">Not the downvoter, because the question was not very clearly worded in the first place, but yes, I think this is wrong. This will return one key for each set of equal values, but instead OP seems to want just the keys with unique values, i.e. if two keys have the same value it should return neither of those.</span>
<span class="comment-copy">ah you may be right.  OP's correct example doesn't include any duplicate values, so not sure what the expected behavior is.</span>
