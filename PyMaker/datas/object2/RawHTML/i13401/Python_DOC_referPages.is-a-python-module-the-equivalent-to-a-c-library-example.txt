<div class="post-text" itemprop="text">
<p>Im New to Python coming form a C++  background, Im getting used to it by writing some programs, and this question came to my mind after reading this <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow">itertools python module</a> </p>
<p>Along the help of some other users in this page, we ended up using the permutations and combinations function in this program </p>
<pre><code>from itertools import permutations, combinations 

A = (1,2,3,4)
B = (4,3,2,1)
n = len(A)      

print("Starter point")
print(A)
print("Final Point")
print(B)

def permutaciones(inicio, objetivo):
    perms = list(permutations(inicio)) 
    perms2 = list(combinations(A, n)) 
    if tuple(objetivo) not in perms:
            return []
    Var = perms[: perms.index(tuple(objetivo)) + 1]
    return Var

print permutaciones(A, B)
print("--------------")
</code></pre>
<p>As far as i understand Im calling the functions permutations and combinations from the library (module) itertools</p>
<p>Where bot functions are described as the 2 following blocks of code, citing from the <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow">itertools page</a> combinations can be described as </p>
<pre><code>def combinations(iterable, r):
    pool = tuple(iterable)
    n = len(pool)
    for indices in permutations(range(n), r):
        if sorted(indices) == list(indices):
            yield tuple(pool[i] for i in indices)
</code></pre>
<p>The code for permutations() can be also expressed as a subsequence of product(), filtered to exclude entries with repeated elements (those from the same position in the input pool):</p>
<pre><code>def permutations(iterable, r=None):
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    for indices in product(range(n), repeat=r):
        if len(set(indices)) == r:
            yield tuple(pool[i] for i in indices)
</code></pre>
<p>So is its possible for me to just take out both functions and apply them to my code without having the need to import them from itertools?</p>
<ol>
<li>Are the modules actually libraries?</li>
<li>Can i do a product fuction (Used in the permutations fuction) without a math module?</li>
<li>How can i actually implement those lines in my main code (without using the itertools module, an example might be useful ) ?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Are the modules actually libraries?</p>
<p>Yes, you can think of them that way. There isn't a 1:1 correspondence between the C notion of library (which is a linking and loading construct) and Python modules and packages (which are directly supported by the language, not just the runtime environment). That said, they serve similar purposes of separating code bases along functional lines, allowing some components to be compiled (and tested, distributed, etc.) independent of the others. Packages (which are "modules plus") also allow a hierarchical structure, such as <code>os.path</code>, whereas C tends to have a much flatter namespace for its libraries.</p>
<p>Interesting side-note: All Python programs are usable as modules. That is why you often see <code>if __name__ == '__main__':</code> towards the bottom, specifying what to run if and when the code is run like a main program. That section will not run when the code is imported by some other program.</p></li>
<li><p>Can i do a product fuction (Used in the permutations fuction) without a math module?</p>
<p>Yes, the <code>product</code> from <code>itertools</code> is a combinatorial concept (the "Cartesian product") and not a math concept. <code>from itertools import product</code> is sufficient; no math functions are required. </p></li>
<li><p>How can i actually implement those lines in my main code (without using the itertools module, an example might be useful ) ?</p>
<p>Not clear what you want to do there. In general, you'd have a line like:</p>
<pre><code>from itertools import product, combinations, permutations 
</code></pre>
<p>In your code (your main module, or whatever module uses those functions). Or, if you wish to copy and paste the definition of those functions into your code, you may do so and only import the <code>product</code> function they depend on. There is no great advantage to this cut and paste, however. If you want just the <code>combinations</code> and <code>permutations</code> functions from <code>itertools</code>, feel free to import them directly, without cut and paste.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you could write the equivalent in your own code, but note that 'product' is the itertools version, not anything from the math module.</p>
<p>But also note that the reason they say "equivalent" is that the itertools module is written in C.  So in this particular instance, you would take a big performance hit if you used the equivalent Python.</p>
<p>Some of the standard library and many add-on packages are pure Python, and you can cut and paste from there, as well.</p>
<p>To use the equivalent example code in your own code, just cut and paste.  For example, here I took the <code>product()</code> code and just executed it in the interpreter:</p>
<pre><code>&gt;&gt;&gt; def product(*args, **kwds):
...     # product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy
...     # product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111
...     pools = map(tuple, args) * kwds.get('repeat', 1)
...     result = [[]]
...     for pool in pools:
...         result = [x+[y] for x in result for y in pool]
...     for prod in result:
...         yield tuple(prod)
... 
&gt;&gt;&gt; list(product('abc', 'def'))
[('a', 'd'), ('a', 'e'), ('a', 'f'), ('b', 'd'), ('b', 'e'), ('b', 'f'), ('c', 'd'), ('c', 'e'), ('c', 'f')]
</code></pre>
<p>The interpreter (or an IDE) is great for simply trying stuff like this out.</p>
</div>
<div class="post-text" itemprop="text">
<p>While the implementation of python modules is very different from a C library, they largely play the same role.</p>
<p>A c include directive replaces the include with source code of the included file, which is then compiled into the source. A python module on the other hand, is dynamically loaded at run time, and can actually be accessed as an object (like a variable with global scope). One big upside of this difference is that function and classes imported from a module are name spaced, meaning there is little risk of name collisions.</p>
<p>Most of the time, you use modules much like libraries.</p>
<p>Yes, you could just copy paste library functions into your source, but there is really no reason to. It won't meaningfully improve performance, and will make your code less portable, maintainable, and readable. We use modules for a reason.</p>
</div>
<span class="comment-copy">The performance hit isn't just because it's written in C; in this case, the "equivalent" code is pre-computing all the results up front, in memory, and only pretending to generate them live. For even moderate <code>product</code>s, it will easily consume all your memory before it <code>yield</code>s even a single result.</span>
<span class="comment-copy">That's an excellent point for this particular function.  Obviously it could be rewritten in Python to not do this; almost as obviously, it would then be even slower (assuming this doesn't fill up memory and start paging).</span>
