<div class="post-text" itemprop="text">
<p>How to test a function in Python which creates a directory? Can you give an example <code>make_directory_test()</code> function?</p>
<pre><code>def make_directory(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A good practice here would be to learn how to use testing frameworks like <a href="https://pypi.python.org/pypi/mock" rel="nofollow">mock</a> or <a href="https://has207.github.io/flexmock/" rel="nofollow">flexmock</a></p>
<p>Furthermore, you should use Python's <a href="https://docs.python.org/2/library/unittest.html" rel="nofollow">unittest</a> Framework.</p>
<p>Your objective here is not necessarily to make sure that something gets created, but rather that it gets called. So what you would want to do is mock out the external calls to help test the proper flow of your method. So in this case you should mock exists and makedirs. Then ensure that it gets called. That would be an acceptable unit test. You would do something like this: </p>
<p>Let us assume your main code is being housed in a module called my_module.py. So you would want to create a test file, let's call it test.py to keep it simple and do something like this in your unit test:</p>
<pre><code>from mock import patch
import my_module
import unittest


class MyTest(unittest.TestCase):
    @patch('my_module.exists')
    @patch('my_module.makedirs')
    def test_create_dir(self, mock_make_dirs, mock_exists):
        mock_exists.return_value = True

        make_directory('thing_to_create')

        mock_make_dirs.assert_called_with('thing_to_create')
</code></pre>
<p>So, what's happening here is that you are telling the mock that you want to mock out the makedirs and exists. You are making exists return with a True as specified with the <code>mock_exists.return_value</code>. Then you are making your actual call, your mocks will take effect in that method call. The last line with <code>mock_make_dirs.assert_called_with</code> will ensure that your method for making the dir will actually be called.</p>
<p><strong>If you want to still test that something does actually get created</strong></p>
<p>What you can do in this case, is maybe venture down the path of using a context manager and create a temporary folder to test in, do your work to test your method and anything else you have to do, and once you are done your work, the context manager will destroy itself. </p>
<p>For information on context managers, check out <a href="https://docs.python.org/2/library/contextlib.html" rel="nofollow">contextlib</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just test that directory exists</p>
<pre><code>def test_make_directory(self):
    directory_path = '...' # somepath

    make_directory(directory_path)

    self.assertTrue(os.path.exists(directory_path))
</code></pre>
<p>And do ensure that any directories created in unit tests are deleted after each tests in <code>tearDown</code> or <code>setUp</code>, to ensure independency of tests</p>
</div>
<span class="comment-copy">shouldnt the patch functions use <code>@patch('os.path.exists')</code> etc. ?</span>
<span class="comment-copy">Hi @VinceMiller. The rule of thumb with mock patching is you mock with respect to where you are testing and not where the module is defined. The docs actually explain this really well <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">Missing a ) on assert true.</span>
<span class="comment-copy">@marsh oops... thanks</span>
<span class="comment-copy">I think a <code>self.assertFalse(os.path.exists(directory_path))</code> before the <code>make_directory</code> would improve things.</span>
<span class="comment-copy">I think that would be unnecessary, as I mentioned all unit tests should be independent. So something like that should always be written in tearDown of any test that uses file system.</span>
