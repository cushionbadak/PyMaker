<div class="post-text" itemprop="text">
<p>I am trying to use mock library for testing a piece of the code. In this code, the user raw input is accepted in a for loop as shown below. I have written the test case <code>test_apple_record</code> that can feed a single user input value for the tray number. </p>
<p>But, for every iteration within the for loop, it just takes this same value (5) as expected.  </p>
<p>Question is: How to feed different values for each iteration? for example, specific values of 5, 6, and 7 for the tray numbers for i=0, 1 and 2 respectively. </p>
<pre><code>class SomeClass(unittest.TestCase):    
    def apple_counter(self):
        apple_record = {}
        for i in range(3):
            apple_tray = input("enter tray number:")
            apple_record[apple_tray]  =  (i+1)*10
            print("i=%d, apple_record=%s"%(i, apple_record))

    def test_apple_record(self):
        with mock.patch('builtins.input', return_value='5'):
            self.apple_counter()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>side_effect</code> parameter with an iterable to provide return values:</p>
<pre><code>with mock.patch('builtins.input', side_effect=[5, 6, 7]):
    self.apple_counter()
</code></pre>
<p>See the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow">docs</a>:</p>
<blockquote>
<p>If <em>side_effect</em> is an iterable then each call to the mock will return the next value from the iterable.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h2>Turns out I was reinventing the wheel. Use the <code>side_effect</code> parameter instead. Leaving a modified version of this here anyway, in case somebody wants to do something fancy.</h2>
<p>To use a different function instead use the <code>new_callable</code> keyword argument of <code>patch</code></p>
<pre><code>with mock.patch('builtins.input', new_callable=lambda *x: random.randrange(0,10)):
    do_stuff()
</code></pre>
<p>however this means that values are entirely random, which is not desirable for a test because it means the test is not deterministic and can fail or not entirely by chance. Additionally you may want the input() function to emit generated non-random values, such as a sequence of commands or similar. For this, I think the easiest way would be a generator function.</p>
<pre><code>def input_generator(): # generate squares as an example
    a = 0
    while True:
        yield a**2
        a += 1

g = input_generator()

with mock.patch('builtins.input', lambda *x: next(g)):
    do_stuff()
</code></pre>
</div>
<span class="comment-copy">Thanks! it worked!</span>
