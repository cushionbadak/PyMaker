<div class="post-text" itemprop="text">
<p>What is the best possible way to check if a string can be represented as a number in Python? </p>
<p>The function I currently have right now is:</p>
<pre><code>def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False
</code></pre>
<p>Which, not only is ugly and slow, seems clunky. However I haven't found a better method because calling <code>float</code> in the main function is even worse. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Which, not only is ugly and slow</p>
</blockquote>
<p>I'd dispute both.</p>
<p>A regex or other string parsing would be uglier and slower.  </p>
<p>I'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames.</p>
<p>The issue is that any numeric conversion function has two kinds of results</p>
<ul>
<li>A number, if the number is valid</li>
<li>A status code (e.g., via errno) or exception to show that no valid number could be parsed.</li>
</ul>
<p>C (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.</p>
<p>I think your code for doing this is perfect.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case you are looking for parsing (positive, unsigned) integers instead of floats, you can use the <a href="https://docs.python.org/2/library/stdtypes.html#str.isdigit" rel="noreferrer" title="str.isdigit"><code>isdigit()</code></a> function for string objects.</p>
<pre><code>&gt;&gt;&gt; a = "03523"
&gt;&gt;&gt; a.isdigit()
True
&gt;&gt;&gt; b = "963spam"
&gt;&gt;&gt; b.isdigit()
False
</code></pre>
<p><a href="https://docs.python.org/2/library/stdtypes.html#string-methods" rel="noreferrer" title="string-methods">String Methods - <code>isdigit()</code></a></p>
<p>There's also something on Unicode strings, which I'm not too familiar with
<a href="https://docs.python.org/2/library/stdtypes.html#unicode.isnumeric" rel="noreferrer" title="unicode.isnumeric">Unicode - Is decimal/decimal</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong> The best solution is <code>s.replace('.','',1).isdigit()</code></p>
<p>I did some <a href="http://nbviewer.ipython.org/github/rasbt/One-Python-benchmark-per-day/blob/master/ipython_nbs/day6_string_is_number.ipynb?create=1" rel="noreferrer">benchmarks</a> comparing the different approaches</p>
<pre><code>def is_number_tryexcept(s):
    """ Returns True is string is a number. """
    try:
        float(s)
        return True
    except ValueError:
        return False

import re    
def is_number_regex(s):
    """ Returns True is string is a number. """
    if re.match("^\d+?\.\d+?$", s) is None:
        return s.isdigit()
    return True


def is_number_repl_isdigit(s):
    """ Returns True is string is a number. """
    return s.replace('.','',1).isdigit()
</code></pre>
<p>If the string is not a number, the except-block is quite slow. But more importantly, the try-except method is the only approach that handles scientific notations correctly.</p>
<pre><code>funcs = [
          is_number_tryexcept, 
          is_number_regex,
          is_number_repl_isdigit
          ]

a_float = '.1234'

print('Float notation ".1234" is not supported by:')
for f in funcs:
    if not f(a_float):
        print('\t -', f.__name__)
</code></pre>
<p>Float notation ".1234" is not supported by:<br/>
- is_number_regex  </p>
<pre><code>scientific1 = '1.000000e+50'
scientific2 = '1e50'


print('Scientific notation "1.000000e+50" is not supported by:')
for f in funcs:
    if not f(scientific1):
        print('\t -', f.__name__)




print('Scientific notation "1e50" is not supported by:')
for f in funcs:
    if not f(scientific2):
        print('\t -', f.__name__)
</code></pre>
<p>Scientific notation "1.000000e+50" is not supported by:<br/>
- is_number_regex<br/>
- is_number_repl_isdigit<br/>
Scientific notation "1e50" is not supported by:<br/>
- is_number_regex<br/>
- is_number_repl_isdigit  </p>
<h2>EDIT: The benchmark results</h2>
<pre><code>import timeit

test_cases = ['1.12345', '1.12.345', 'abc12345', '12345']
times_n = {f.__name__:[] for f in funcs}

for t in test_cases:
    for f in funcs:
        f = f.__name__
        times_n[f].append(min(timeit.Timer('%s(t)' %f, 
                      'from __main__ import %s, t' %f)
                              .repeat(repeat=3, number=1000000)))
</code></pre>
<p>where the following functions were tested</p>
<pre><code>from re import match as re_match
from re import compile as re_compile

def is_number_tryexcept(s):
    """ Returns True is string is a number. """
    try:
        float(s)
        return True
    except ValueError:
        return False

def is_number_regex(s):
    """ Returns True is string is a number. """
    if re_match("^\d+?\.\d+?$", s) is None:
        return s.isdigit()
    return True


comp = re_compile("^\d+?\.\d+?$")    

def compiled_regex(s):
    """ Returns True is string is a number. """
    if comp.match(s) is None:
        return s.isdigit()
    return True


def is_number_repl_isdigit(s):
    """ Returns True is string is a number. """
    return s.replace('.','',1).isdigit()
</code></pre>
<p><a href="https://i.stack.imgur.com/DFoK6.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/DFoK6.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>There is one exception that you may want to take into account: the string 'NaN'</p>
<p>If you want is_number to return FALSE for 'NaN' this code will not work as Python converts it to its representation of a number that is not a number (talk about identity issues):</p>
<pre><code>&gt;&gt;&gt; float('NaN')
nan
</code></pre>
<p>Otherwise, I should actually thank you for the piece of code I now use extensively. :)</p>
<p>G.</p>
</div>
<div class="post-text" itemprop="text">
<p>how about this:</p>
<pre><code>'3.14'.replace('.','',1).isdigit()
</code></pre>
<p>which will return true only if there is one or no '.' in the string of digits.</p>
<pre><code>'3.14.5'.replace('.','',1).isdigit()
</code></pre>
<p>will return false</p>
<p>edit: just saw another comment ...
adding a <code>.replace(badstuff,'',maxnum_badstuff)</code> for other cases can be done. if you are passing salt and not arbitrary condiments (ref:<a href="http://xkcd.com/974/" rel="noreferrer">xkcd#974</a>) this will do fine :P</p>
</div>
<div class="post-text" itemprop="text">
<p>Updated after Alfe pointed out you don't need to check for float separately as complex handles both:</p>
<pre><code>def is_number(s):
    try:
        complex(s) # for int, long, float and complex
    except ValueError:
        return False

    return True
</code></pre>
<hr/>
<p>Previously said: Is some rare cases you might also need to check for complex numbers (e.g. 1+2i), which can not be represented by a float:</p>
<pre><code>def is_number(s):
    try:
        float(s) # for int, long and float
    except ValueError:
        try:
            complex(s) # for complex
        except ValueError:
            return False

    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Which, not only is ugly and slow, seems clunky.</p>
</blockquote>
<p>It may take some getting used to, but this is the pythonic way of doing it.  As has been already pointed out, the alternatives are worse.  But there is one other advantage of doing things this way:  polymorphism.</p>
<p>The central idea behind duck typing is that "if it walks and talks like a duck, then it's a duck."  What if you decide that you need to subclass string so that you can change how you determine if something can be converted into a float?  Or what if you decide to test some other object entirely?  You can do these things without having to change the above code.</p>
<p>Other languages solve these problems by using interfaces.  I'll save the analysis of which solution is better for another thread.  The point, though, is that python is decidedly on the duck typing side of the equation, and you're probably going to have to get used to syntax like this if you plan on doing much programming in Python (but that doesn't mean you have to like it of course).</p>
<p>One other thing you might want to take into consideration: Python is pretty fast in throwing and catching exceptions compared to a lot of other languages (30x faster than .Net for instance).  Heck, the language itself even throws exceptions to communicate non-exceptional, normal program conditions (every time you use a for loop).  Thus, I wouldn't worry too much about the performance aspects of this code until you notice a significant problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>For <code>int</code> use this:</p>
<pre><code>&gt;&gt;&gt; "1221323".isdigit()
True
</code></pre>
<p>But for <code>float</code> we need some tricks ;-). Every float number has one point...</p>
<pre><code>&gt;&gt;&gt; "12.34".isdigit()
False
&gt;&gt;&gt; "12.34".replace('.','',1).isdigit()
True
&gt;&gt;&gt; "12.3.4".replace('.','',1).isdigit()
False
</code></pre>
<p>Also for negative numbers just add <code>lstrip()</code>:</p>
<pre><code>&gt;&gt;&gt; '-12'.lstrip('-')
'12'
</code></pre>
<p>And now we get a universal way:</p>
<pre><code>&gt;&gt;&gt; '-12.34'.lstrip('-').replace('.','',1).isdigit()
True
&gt;&gt;&gt; '.-234'.lstrip('-').replace('.','',1).isdigit()
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Just Mimic C#</h2>
<p><strong>In C# there are two different functions that handle parsing of scalar values:</strong></p>
<ul>
<li>Float.Parse()</li>
<li>Float.TryParse()</li>
</ul>
<p><strong>float.parse():</strong></p>
<pre><code>def parse(string):
    try:
        return float(string)
    except Exception:
        throw TypeError
</code></pre>
<p><em>Note: If you're wondering why I changed the exception to a TypeError, <a href="http://docs.python.org/library/exceptions.html">here's the documentation</a>.</em></p>
<p><strong>float.try_parse():</strong></p>
<pre><code>def try_parse(string, fail=None):
    try:
        return float(string)
    except Exception:
        return fail;
</code></pre>
<p><em>Note: You don't want to return the boolean 'False' because that's still a value type. None is better because it indicates failure. Of course, if you want something different you can change the fail parameter to whatever you want.</em></p>
<p>To extend float to include the 'parse()' and 'try_parse()' you'll need to monkeypatch the 'float' class to add these methods.</p>
<p>If you want respect pre-existing functions the code should be something like:</p>
<pre><code>def monkey_patch():
    if(!hasattr(float, 'parse')):
        float.parse = parse
    if(!hasattr(float, 'try_parse')):
        float.try_parse = try_parse
</code></pre>
<p><em>SideNote: I personally prefer to call it Monkey Punching because it feels like I'm abusing the language when I do this but YMMV.</em></p>
<p><strong>Usage:</strong></p>
<pre><code>float.parse('giggity') // throws TypeException
float.parse('54.3') // returns the scalar value 54.3
float.tryParse('twank') // returns None
float.tryParse('32.2') // returns the scalar value 32.2
</code></pre>
<p><em>And the great Sage Pythonas said to the Holy See Sharpisus, "Anything you can do I can do better; I can do anything better than you."</em></p>
</div>
<div class="post-text" itemprop="text">
<p>For strings of non-numbers, <code>try: except:</code> is actually slower than regular expressions.  For strings of valid numbers, regex is slower.  So, the appropriate method depends on your input. </p>
<p>If you find that you are in a performance bind, you can use a new third-party module called <a href="https://pypi.org/project/fastnumbers" rel="nofollow noreferrer">fastnumbers</a> that provides a function called <a href="http://fastnumbers.readthedocs.io/en/master/api.html#fastnumbers.isfloat" rel="nofollow noreferrer">isfloat</a>.  Full disclosure, I am the author.  I have included its results in the timings below.</p>
<hr/>
<pre><code>from __future__ import print_function
import timeit

prep_base = '''\
x = 'invalid'
y = '5402'
z = '4.754e3'
'''

prep_try_method = '''\
def is_number_try(val):
    try:
        float(val)
        return True
    except ValueError:
        return False

'''

prep_re_method = '''\
import re
float_match = re.compile(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?$').match
def is_number_re(val):
    return bool(float_match(val))

'''

fn_method = '''\
from fastnumbers import isfloat

'''

print('Try with non-number strings', timeit.timeit('is_number_try(x)',
    prep_base + prep_try_method), 'seconds')
print('Try with integer strings', timeit.timeit('is_number_try(y)',
    prep_base + prep_try_method), 'seconds')
print('Try with float strings', timeit.timeit('is_number_try(z)',
    prep_base + prep_try_method), 'seconds')
print()
print('Regex with non-number strings', timeit.timeit('is_number_re(x)',
    prep_base + prep_re_method), 'seconds')
print('Regex with integer strings', timeit.timeit('is_number_re(y)',
    prep_base + prep_re_method), 'seconds')
print('Regex with float strings', timeit.timeit('is_number_re(z)',
    prep_base + prep_re_method), 'seconds')
print()
print('fastnumbers with non-number strings', timeit.timeit('isfloat(x)',
    prep_base + 'from fastnumbers import isfloat'), 'seconds')
print('fastnumbers with integer strings', timeit.timeit('isfloat(y)',
    prep_base + 'from fastnumbers import isfloat'), 'seconds')
print('fastnumbers with float strings', timeit.timeit('isfloat(z)',
    prep_base + 'from fastnumbers import isfloat'), 'seconds')
print()
</code></pre>
<hr/>
<pre><code>Try with non-number strings 2.39108395576 seconds
Try with integer strings 0.375686168671 seconds
Try with float strings 0.369210958481 seconds

Regex with non-number strings 0.748660802841 seconds
Regex with integer strings 1.02021503448 seconds
Regex with float strings 1.08564686775 seconds

fastnumbers with non-number strings 0.174362897873 seconds
fastnumbers with integer strings 0.179651021957 seconds
fastnumbers with float strings 0.20222902298 seconds
</code></pre>
<p>As you can see</p>
<ul>
<li><code>try: except:</code> was fast for numeric input but very slow for an invalid input</li>
<li>regex is very efficient when the input is invalid</li>
<li><code>fastnumbers</code> wins in both cases</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I know this is particularly old but I would add an answer I believe covers the information missing from the highest voted answer that could be very valuable to any who find this:</p>
<p>For each of the following methods connect them with a count if you need any input to be accepted. (Assuming we are using vocal definitions of integers rather than 0-255, etc.)</p>
<p><code>x.isdigit()</code>
works well for checking if x is an integer.</p>
<p><code>x.replace('-','').isdigit()</code>
works well for checking if x is a negative.(Check - in first position)</p>
<p><code>x.replace('.','').isdigit()</code>
works well for checking if x is a decimal.</p>
<p><code>x.replace(':','').isdigit()</code>
works well for checking if x is a ratio.</p>
<p><code>x.replace('/','',1).isdigit()</code>
works well for checking if x is a fraction.</p>
</div>
<div class="post-text" itemprop="text">
<p>Casting to float and catching ValueError is probably the fastest way, since float() is specifically meant for just that. Anything else that requires string parsing (regex, etc) will likely be slower due to the fact that it's not tuned for this operation. My $0.02.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Unicode strings, they have a method to do just what you want:</p>
<pre><code>&gt;&gt;&gt; s = u"345"
&gt;&gt;&gt; s.isnumeric()
True
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt;&gt; s = "345"
&gt;&gt;&gt; u = unicode(s)
&gt;&gt;&gt; u.isnumeric()
True
</code></pre>
<p><a href="http://www.tutorialspoint.com/python/string_isnumeric.htm">http://www.tutorialspoint.com/python/string_isnumeric.htm</a></p>
<p><a href="http://docs.python.org/2/howto/unicode.html">http://docs.python.org/2/howto/unicode.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I wanted to see which method is fastest. Overall the best and most consistent results were given by the <code>check_replace</code> function. The fastest results were given by the <code>check_exception</code> function, but only if there was no exception fired - meaning its code is the most efficient, but the overhead of throwing an exception is quite large.</p>
<p>Please note that checking for a successful cast is the only method which is accurate, for example, this works with <code>check_exception</code> but the other two test functions will return False for a valid float:</p>
<pre><code>huge_number = float('1e+100')
</code></pre>
<p>Here is the benchmark code:</p>
<pre><code>import time, re, random, string

ITERATIONS = 10000000

class Timer:    
    def __enter__(self):
        self.start = time.clock()
        return self
    def __exit__(self, *args):
        self.end = time.clock()
        self.interval = self.end - self.start

def check_regexp(x):
    return re.compile("^\d*\.?\d*$").match(x) is not None

def check_replace(x):
    return x.replace('.','',1).isdigit()

def check_exception(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

to_check = [check_regexp, check_replace, check_exception]

print('preparing data...')
good_numbers = [
    str(random.random() / random.random()) 
    for x in range(ITERATIONS)]

bad_numbers = ['.' + x for x in good_numbers]

strings = [
    ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randint(1,10)))
    for x in range(ITERATIONS)]

print('running test...')
for func in to_check:
    with Timer() as t:
        for x in good_numbers:
            res = func(x)
    print('%s with good floats: %s' % (func.__name__, t.interval))
    with Timer() as t:
        for x in bad_numbers:
            res = func(x)
    print('%s with bad floats: %s' % (func.__name__, t.interval))
    with Timer() as t:
        for x in strings:
            res = func(x)
    print('%s with strings: %s' % (func.__name__, t.interval))
</code></pre>
<p>Here are the results with Python 2.7.10 on a 2017 MacBook Pro 13:</p>
<pre><code>check_regexp with good floats: 12.688639
check_regexp with bad floats: 11.624862
check_regexp with strings: 11.349414
check_replace with good floats: 4.419841
check_replace with bad floats: 4.294909
check_replace with strings: 4.086358
check_exception with good floats: 3.276668
check_exception with bad floats: 13.843092
check_exception with strings: 15.786169
</code></pre>
<p>Here are the results with Python 3.6.5 on a 2017 MacBook Pro 13:</p>
<pre><code>check_regexp with good floats: 13.472906000000009
check_regexp with bad floats: 12.977665000000016
check_regexp with strings: 12.417542999999995
check_replace with good floats: 6.011045999999993
check_replace with bad floats: 4.849356
check_replace with strings: 4.282754000000011
check_exception with good floats: 6.039081999999979
check_exception with bad floats: 9.322753000000006
check_exception with strings: 9.952595000000002
</code></pre>
<p>Here are the results with PyPy 2.7.13 on a 2017 MacBook Pro 13:</p>
<pre><code>check_regexp with good floats: 2.693217
check_regexp with bad floats: 2.744819
check_regexp with strings: 2.532414
check_replace with good floats: 0.604367
check_replace with bad floats: 0.538169
check_replace with strings: 0.598664
check_exception with good floats: 1.944103
check_exception with bad floats: 2.449182
check_exception with strings: 2.200056
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This answer provides step by step guide having function with examples to find the string is:</p>
<ul>
<li><em>Positive integer</em></li>
<li><em>Positive/negative - integer/float</em></li>
<li><em>How to discard "NaN" (not a number) strings while checking for number?</em></li>
</ul>
<h1>Check if string is <em>positive</em> integer</h1>
<p>You may use <a href="https://docs.python.org/2/library/stdtypes.html#str.isdigit" rel="noreferrer"><strong><code>str.isdigit()</code></strong></a> to check whether given string is <em>positive</em> integer. </p>
<p>Sample Results:</p>
<pre><code># For digit
&gt;&gt;&gt; '1'.isdigit()
True
&gt;&gt;&gt; '1'.isalpha()
False
</code></pre>
<h1>Check for string as positive/negative - integer/float</h1>
<p><code>str.isdigit()</code> returns <code>False</code> if the string is a <em>negative</em> number or a float number. For example:</p>
<pre><code># returns `False` for float
&gt;&gt;&gt; '123.3'.isdigit()
False
# returns `False` for negative number
&gt;&gt;&gt; '-123'.isdigit()
False
</code></pre>
<p>If you want to <strong>also check for the <em>negative</em> integers and <a href="https://docs.python.org/3/library/functions.html#float" rel="noreferrer"><code>float</code></a></strong>, then you may write a custom function to check for it as:</p>
<pre><code>def is_number(n):
    try:
        float(n)   # Type-casting the string to `float`.
                   # If string is not a valid `float`, 
                   # it'll raise `ValueError` exception
    except ValueError:
        return False
    return True
</code></pre>
<p>Sample Run:</p>
<pre><code>&gt;&gt;&gt; is_number('123')    # positive integer number
True

&gt;&gt;&gt; is_number('123.4')  # positive float number
True

&gt;&gt;&gt; is_number('-123')   # negative integer number
True

&gt;&gt;&gt; is_number('-123.4') # negative `float` number
True

&gt;&gt;&gt; is_number('abc')    # `False` for "some random" string
False
</code></pre>
<h1>Discard "NaN" (not a number) strings while checking for number</h1>
<p>The above functions will return <code>True</code> for the "NAN" (Not a number) string because for Python it is valid float representing it is not a number. For example:</p>
<pre><code>&gt;&gt;&gt; is_number('NaN')
True
</code></pre>
<p>In order to check whether the number is "NaN", you may use <a href="https://docs.python.org/2/library/math.html#math.isnan" rel="noreferrer"><strong><code>math.isnan()</code></strong></a> as:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; nan_num = float('nan')

&gt;&gt;&gt; math.isnan(nan_num)
True
</code></pre>
<p>Or if you don't want to import additional library to check this, then you may simply check it via comparing it with itself using <code>==</code>. Python returns <code>False</code> when <code>nan</code> float is compared with itself. For example:</p>
<pre><code># `nan_num` variable is taken from above example
&gt;&gt;&gt; nan_num == nan_num
False
</code></pre>
<p>Hence, above <strong>function <code>is_number</code> can be updated to return <code>False</code> for <code>"NaN"</code></strong> as:</p>
<pre><code>def is_number(n):
    is_number = True
    try:
        num = float(n)
        # check for "nan" floats
        is_number = num == num   # or use `math.isnan(num)`
    except ValueError:
        is_number = False
    return is_number
</code></pre>
<p>Sample Run:</p>
<pre><code>&gt;&gt;&gt; is_number('Nan')   # not a number "Nan" string
False

&gt;&gt;&gt; is_number('nan')   # not a number string "nan" with all lower cased
False

&gt;&gt;&gt; is_number('123')   # positive integer
True

&gt;&gt;&gt; is_number('-123')  # negative integer
True

&gt;&gt;&gt; is_number('-1.12') # negative `float`
True

&gt;&gt;&gt; is_number('abc')   # "some random" string
False
</code></pre>
<p><strong><em>PS: Each operation for each check depending on the type of number comes with additional overhead. Choose the version of <code>is_number</code> function which fits your requirement.</em></strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Lets say you have digits in string.
str = "100949"
and you would like to check if it has only numbers</p>
<pre><code>if str.isdigit():
returns TRUE or FALSE 
</code></pre>
<p><a href="http://docs.python.org/2/library/stdtypes.html#str.isdigit" rel="noreferrer">isdigit docs</a></p>
<p>otherwise your method works great to find the occurrence of a digit in a string. </p>
</div>
<div class="post-text" itemprop="text">
<p>So to put it all together, checking for Nan, infinity and complex numbers (it would seem they are specified with j, not i, i.e. 1+2j) it results in:</p>
<pre><code>def is_number(s):
    try:
        n=str(float(s))
        if n == "nan" or n=="inf" or n=="-inf" : return False
    except ValueError:
        try:
            complex(s) # for complex
        except ValueError:
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code looks fine to me.</p>
<p>Perhaps you think the code is "clunky" because of using exceptions?  Note that Python programmers tend to use exceptions liberally when it improves code readability, thanks to its low performance penalty.</p>
</div>
<div class="post-text" itemprop="text">
<p>I did some speed test. Lets say that if the string is <strong>likely</strong> to be a number the <em>try/except</em> strategy is the fastest possible.If the string is <strong>not likely</strong> to be a number <strong>and</strong> you are interested in <strong>Integer</strong> check, it worths to do some test (isdigit plus heading '-'). 
If you are interested to check float number, you have to use the <em>try/except</em> code whitout escape.</p>
</div>
<div class="post-text" itemprop="text">
<p>I needed to determine if a string cast into basic types (float,int,str,bool). After not finding anything on the internet I created this:</p>
<pre><code>def str_to_type (s):
    """ Get possible cast type for a string

    Parameters
    ----------
    s : string

    Returns
    -------
    float,int,str,bool : type
        Depending on what it can be cast to

    """    
    try:                
        f = float(s)        
        if "." not in s:
            return int
        return float
    except ValueError:
        value = s.upper()
        if value == "TRUE" or value == "FALSE":
            return bool
        return type(s)
</code></pre>
<p>Example</p>
<pre><code>str_to_type("true") # bool
str_to_type("6.0") # float
str_to_type("6") # int
str_to_type("6abc") # str
str_to_type(u"6abc") # unicode       
</code></pre>
<p>You can capture the type and use it </p>
<pre><code>s = "6.0"
type_ = str_to_type(s) # float
f = type_(s) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The input may be as follows:</p>
<p><code>a="50"</code>
<code>b=50</code>
<code>c=50.1</code>
<code>d="50.1"</code></p>
<hr/>
<h2><strong>1-General input:</strong></h2>
<p>The input of this function can be everything!</p>
<p>Finds whether the given variable is numeric. Numeric strings consist of optional sign, any number of digits, optional decimal part and optional exponential part. Thus +0123.45e6 is a valid numeric value. Hexadecimal (e.g. 0xf4c3b00c) and binary (e.g. 0b10100111001) notation is not allowed.</p>
<p><strong>is_numeric</strong> function</p>
<pre><code>import ast
import numbers              
def is_numeric(obj):
    if isinstance(obj, numbers.Number):
        return True
    elif isinstance(obj, str):
        nodes = list(ast.walk(ast.parse(obj)))[1:]
        if not isinstance(nodes[0], ast.Expr):
            return False
        if not isinstance(nodes[-1], ast.Num):
            return False
        nodes = nodes[1:-1]
        for i in range(len(nodes)):
            #if used + or - in digit :
            if i % 2 == 0:
                if not isinstance(nodes[i], ast.UnaryOp):
                    return False
            else:
                if not isinstance(nodes[i], (ast.USub, ast.UAdd)):
                    return False
        return True
    else:
        return False
</code></pre>
<p>test:</p>
<pre><code>&gt;&gt;&gt; is_numeric("54")
True
&gt;&gt;&gt; is_numeric("54.545")
True
&gt;&gt;&gt; is_numeric("0x45")
True
</code></pre>
<p><strong>is_float</strong> function</p>
<p>Finds whether the given variable is float. float strings consist of optional sign, any number of digits, ...</p>
<pre><code>import ast

def is_float(obj):
    if isinstance(obj, float):
        return True
    if isinstance(obj, int):
        return False
    elif isinstance(obj, str):
        nodes = list(ast.walk(ast.parse(obj)))[1:]
        if not isinstance(nodes[0], ast.Expr):
            return False
        if not isinstance(nodes[-1], ast.Num):
            return False
        if not isinstance(nodes[-1].n, float):
            return False
        nodes = nodes[1:-1]
        for i in range(len(nodes)):
            if i % 2 == 0:
                if not isinstance(nodes[i], ast.UnaryOp):
                    return False
            else:
                if not isinstance(nodes[i], (ast.USub, ast.UAdd)):
                    return False
        return True
    else:
        return False
</code></pre>
<p>test:</p>
<pre><code>&gt;&gt;&gt; is_float("5.4")
True
&gt;&gt;&gt; is_float("5")
False
&gt;&gt;&gt; is_float(5)
False
&gt;&gt;&gt; is_float("5")
False
&gt;&gt;&gt; is_float("+5.4")
True
</code></pre>
<p>what is <a href="https://docs.python.org/2/library/ast.html" rel="nofollow noreferrer">ast</a>?</p>
<hr/>
<h2>2- If you are confident that the variable content is <strong>String</strong>:</h2>
<p>use <a href="https://docs.python.org/2/library/stdtypes.html#str.isdigit" rel="nofollow noreferrer">str.isdigit()</a> method</p>
<pre><code>&gt;&gt;&gt; a=454
&gt;&gt;&gt; a.isdigit()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'int' object has no attribute 'isdigit'
&gt;&gt;&gt; a="454"
&gt;&gt;&gt; a.isdigit()
True
</code></pre>
<hr/>
<h2>3-Numerical input:</h2>
<p><strong>detect int value:</strong></p>
<pre><code>&gt;&gt;&gt; isinstance("54", int)
False
&gt;&gt;&gt; isinstance(54, int)
True
&gt;&gt;&gt; 
</code></pre>
<p><strong>detect float:</strong></p>
<pre><code>&gt;&gt;&gt; isinstance("45.1", float)
False
&gt;&gt;&gt; isinstance(45.1, float)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>RyanN suggests</p>
<blockquote>
<p>If you want to return False for a NaN and Inf, change line to x = float(s); return (x == x) and (x - 1 != x). This should return True for all floats except Inf and NaN</p>
</blockquote>
<p>But this doesn't quite work, because for sufficiently large floats, <code>x-1 == x</code> returns true. For example, <code>2.0**54 - 1 == 2.0**54</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I also used the function you mentioned, but soon I notice that strings as "Nan", "Inf" and it's variation are considered as number. So I propose you improved version of your function, that will return false on those type of input and will not fail "1e3" variants:</p>
<pre><code>def is_float(text):
    try:
        float(text)
        # check for nan/infinity etc.
        if text.isalpha():
            return False
        return True
    except ValueError:
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to know if the <em>entire</em> string can be represented as a number you'll want to use a regexp (or maybe convert the float back to a string and compare it to the source string, but I'm guessing that's not very fast).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my simple way of doing it. Let's say that I'm looping through some strings and I want to add them to an array if they turn out to be numbers.</p>
<pre><code>try:
    myvar.append( float(string_to_check) )
except:
    continue
</code></pre>
<p>Replace the myvar.apppend with whatever operation you want to do with the string if it turns out to be a number. The idea is to try to use a float() operation and use the returned error to determine whether or not the string is a number.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can generalize the exception technique in a useful way by returning more useful values than True and False.  For example this function puts quotes round strings but leaves numbers alone.  Which is just what I needed for a quick and dirty filter to make some variable definitions for R. </p>
<pre><code>import sys

def fix_quotes(s):
    try:
        float(s)
        return s
    except ValueError:
        return '"{0}"'.format(s)

for line in sys.stdin:
    input = line.split()
    print input[0], '&lt;- c(', ','.join(fix_quotes(c) for c in input[1:]), ')'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was working on a problem that led me to this thread, namely how to convert a collection of data to strings and numbers in the most intuitive way.  I realized after reading the original code that what I needed was different in two ways:</p>
<p>1 - I wanted an integer result if the string represented an integer</p>
<p>2 - I wanted a number or a string result to stick into a data structure</p>
<p>so I adapted the original code to produce this derivative:</p>
<pre><code>def string_or_number(s):
    try:
        z = int(s)
        return z
    except ValueError:
        try:
            z = float(s)
            return z
        except ValueError:
            return s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this.</p>
<pre><code> def is_number(var):
    try:
       if var == int(var):
            return True
    except Exception:
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code handles the exponents, floats, and integers, wihtout using regex.</p>
<pre><code>return True if str1.lstrip('-').replace('.','',1).isdigit() or float(str1) else False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use following it handles all cases:-</p>
<pre><code>import re
a=re.match('((\d+[\.]\d*$)|(\.)\d+$)' ,  '2.3') 
a=re.match('((\d+[\.]\d*$)|(\.)\d+$)' ,  '2.')
a=re.match('((\d+[\.]\d*$)|(\.)\d+$)' ,  '.3')
a=re.match('((\d+[\.]\d*$)|(\.)\d+$)' ,  '2.3sd')
a=re.match('((\d+[\.]\d*$)|(\.)\d+$)' ,  '2.3')
</code></pre>
</div>
<span class="comment-copy">What's wrong with what your current solution? It's short, fast and readable.</span>
<span class="comment-copy">And you don't just have to return True or False.  You can return the value suitably modified instead - for example you could use this to put non-numbers in quotes.</span>
<span class="comment-copy">Wouldn't it better to return the result of float(s) in the case of a successful conversion?  You still have the check for success (result is False) and you actually HAVE the conversion, which you are likely to want anyway.</span>
<span class="comment-copy">Even though this question is older, I just wanted to say that this is an elegant way which is documented as <a href="http://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a>. So probably the best solution for this kind of problem.</span>
<span class="comment-copy"><i>Don't</i> return the result of float(s) or None on fail.   if you then use it as <code>x = float('0.00'); if x: use_float(x);</code> you've now got a bug in your code. Truthy values are the reason these functions raise an exception rather than returning <code>None</code> in the first place. A better solution is just to avoid the utility function and surround the call to float in a <code>try catch</code> when you want to use it.</span>
<span class="comment-copy">I don't think that the code is perfect (but I think it's very close): it is more usual to put <i>only</i> the part being "tested" in the <code>try</code> clause, so I would put the <code>return True</code> in an <code>else</code> clause of the <code>try</code>.  One of the reasons is that with the code in the question, if I had to review it, I would have to check that the second statement in the <code>try</code> clause cannot raise a ValueError: granted, this does not require too much time or brain power, but why use any when none is needed?</span>
<span class="comment-copy">The answer seems compelling, but makes me wonder why it's not provided out-of-the-box...   I'll copy this and use it in any case.</span>
<span class="comment-copy">How awful. How about if I don't care what the number <i>is</i> just that it's a number (which is what brought me here)? Instead of a 1-line <code>IsNumeric()</code> I either end up with a try/catch or another wrapping a try/catch. Ugh</span>
<span class="comment-copy">It's not provided 'out of the box' because <code>if is_number(s): x = float(x) else: // fail</code> is the same number of lines of code as the <code>try: x = float(x) catch TypeError: # fail</code>. This utility function is an entirely unecessary abstraction.</span>
<span class="comment-copy">But abstraction is the whole point of libraries. Having an 'isNumber' function (in any language) helps a huge amount because you can build it straight into if statements and have far more readable and maintainable code that relying on try - catch blocks. Also, if you need to use the code more than once in more than one class/module, you have then used more lines of code than a built in function would have.</span>
<span class="comment-copy">However, this won't work for Hexadecimal.</span>
<span class="comment-copy">Nor does it work for numbers with decimal places like 1.2</span>
<span class="comment-copy">That's a negative on negatives as well</span>
<span class="comment-copy">Fails with exponentials too: '1e3'.isdigit() --&gt; False</span>
<span class="comment-copy">While Number != Digit, people who are looking for ways to test if a string contains an integer may very well stumble across this question, and the isDigit approach may very well be perfectly suitable for their application.</span>
<span class="comment-copy">for nice charts +1. I saw benchmark and saw  graph, all the TL;DR thing became clear and intuitive.</span>
<span class="comment-copy">I agree with @JCChuks: the graph helps a lot to get all the TL;DR quickly. But I think a TL;DR (like : <b>TL;DR</b> :  the best solution is  <code>s.replace('.','',1).isdigit()</code>) should appear at the beginning of this anwser. In any case it should be the accepted one. Thanks!</span>
<span class="comment-copy">I apologise if this is out of place but what did you use to generate the chart/graph?</span>
<span class="comment-copy">just plain matplotlib</span>
<span class="comment-copy">The TLDR is misleading and disingenuous.  Being "best" doesn't correlate with any performance benchmark.  For example, I usually value readability much more than micro-optimizations, so benchmarks have almost no weight in determining a best solution for my context.  TLDR would be more accurate of it stated: "best if ranked by execution time from a small set of arbitrary benchmarks"</span>
<span class="comment-copy">Actually, <code>NaN</code> might be a good value to return (rather than <code>False</code>) if the text passed is not in fact a representation of a number. Checking for it is kind of a pain (Python's <code>float</code> type really needs a method for it) but you can use it in calculations without producing an error, and only need to check the result.</span>
<span class="comment-copy">Another exception is the string <code>'inf'</code>. Either <code>inf</code> or <code>NaN</code> can also be prefixed with a <code>+</code> or <code>-</code> and still be accepted.</span>
<span class="comment-copy">If you want to return False for a NaN and Inf, change line to x = float(s); return (x == x) and (x - 1 != x). This should return True for all floats except Inf and NaN</span>
<span class="comment-copy"><code>x-1 == x</code> is true for large floats smaller than <code>inf</code>. From Python 3.2 you can use <code>math.isfinite</code> to test for numbers that are neither NaN nor infinite, or check both <code>math.isnan</code> and <code>math.isinf</code> prior to that.</span>
<span class="comment-copy">This doesn't however account for negative numbers.</span>
<span class="comment-copy">Or hexadecimal.</span>
<span class="comment-copy">Or numbers with exponents like <code>1.234e56</code> (which might also be written as <code>+1.234E+56</code> and several more variants).</span>
<span class="comment-copy"><code>re.match(r'^[+-]*(0[xbo])?[0-9A-Fa-f]*\.?[0-9A-Fa-f]*(E[+-]*[0-9A-Fa-f]+)$', 'str')</code> should do a better job of determining a number (but not all, I'm not claiming that).  I don't recommend using this, far better to use the Questioner's original code.</span>
<span class="comment-copy">if you dont like this solution, read <a href="https://stackoverflow.com/a/23639915/1248177">this</a> before downvoting!</span>
<span class="comment-copy">I disagree.  That's VERY unlikely in normal use, and you would be better building an is_complex_number() call for when you are using them, rather than burden a call with extra operation for a 0.0001% chance of misoperation.</span>
<span class="comment-copy">You can strip the <code>float()</code> stuff completely and just check for the <code>complex()</code> call to succeed.  Everything parsed by <code>float()</code> can be parsed by <code>complex()</code>.</span>
<span class="comment-copy">This function will return Pandas's NaNs and Inf values as numeric values.</span>
<span class="comment-copy"><code>complex('(01989)')</code> will return <code>(1989+0j)</code>. But <code>float('(01989)')</code> will fail. So I think using <code>complex</code> is not good idea.</span>
<span class="comment-copy">Another common place where Python uses exceptions for basic functions is in <code>hasattr()</code> which is just a <code>getattr()</code> call wrapped in a <code>try/except</code>. Still, exception handling is slower than normal flow control, so using it for something that is going to be true <i>most of the time</i> can result in a performance penalty.</span>
<span class="comment-copy">It seems that if you want a one-liner, you're SOL</span>
<span class="comment-copy">Also pythonic is the idea that it's "better to ask forgiveness than permission", regarding the impact of having cheap exceptions.</span>
<span class="comment-copy">Doesn't handle things like <code>1.234e56</code> and similar.  Also, I'd be interested how you'd find out that <code>99999999999999999999e99999999999999999999</code> is not a number.  Trying to parse it finds out quickly.</span>
<span class="comment-copy">This runs ~30% faster than the accepted solution on a list of 50m strings, and 150% faster on a list of 5k strings.  👏</span>
<span class="comment-copy">This soved my problem, thanks</span>
<span class="comment-copy">I have been coding in mostly JS lately and didn't actually test this so there may be some minor errors. If you see any, feel free to correct my mistakes.</span>
<span class="comment-copy">To add support for complex numbers see the answer by @Matthew Wilcoxson. <a href="http://stackoverflow.com/a/3335060/290340">stackoverflow.com/a/3335060/290340</a>.</span>
<span class="comment-copy">Using <code>!</code> instead of <code>not</code> might be a minor error, but you definitely can't assign attributes to the built-in <code>float</code> in CPython.</span>
<span class="comment-copy">I stand corrected :-}  it just didn't look like it was doing this.  Maybe using names like <code>prep_code_basis</code> and <code>prep_code_re_method</code> would have prevented my mistake.</span>
<span class="comment-copy">Do you mind explaining how your module works, at least for the <code>isfloat</code> function?</span>
<span class="comment-copy">@SolomonUcko Here is a link to the source code for the string checking part: <a href="https://github.com/SethMMorton/fastnumbers/blob/v1.0.0/src/string_contains_float.c" rel="nofollow noreferrer">github.com/SethMMorton/fastnumbers/blob/v1.0.0/src/…</a>. Basically, it walks across each character in the string in order and validates that it follows a pattern for a valid float.  If the input is already a number, it just uses the fast <a href="https://docs.python.org/3/c-api/float.html" rel="nofollow noreferrer">PyFloat_Check</a>.</span>
<span class="comment-copy">Tested against the best alternatives in this thread I confirm this solution is <b>by far</b> the fastest. The second fastest method is <code>str(s).strip('-').replace('.','',1).isdigit()</code> which is approximately 10x slower!</span>
<span class="comment-copy">Though for fractions, you probably need to do <code>x.replace('/','',1).isdigit()</code> or otherwise dates such as 4/7/2017 would be misinterpreted as numbers.</span>
<span class="comment-copy">For the best ways to chain the conditions: <a href="https://stackoverflow.com/q/3411771/5922329">stackoverflow.com/q/3411771/5922329</a></span>
<span class="comment-copy">Your "2e-2" dollars are a float too (an additional argument for using float :)</span>
<span class="comment-copy">@tzot NEVER use a float to represent a monetary value.</span>
<span class="comment-copy">@Luke: I totally agree with you, although I never suggested using floats to represent monetary values; I just said that monetary values <i>can</i> be represented as floats :)</span>
<span class="comment-copy">Ahh!!!! Forget it, it only checks if all the characters are numbers.  Sorry.</span>
<span class="comment-copy">how about float?</span>
<span class="comment-copy">for non-negative ints it is ok ;-)</span>
<span class="comment-copy"><code>s.isdecimal()</code> checks if <code>s</code> string is a non-negative integer. <code>s.isnumeric()</code> includes characters that <code>int()</code> rejects.</span>
<span class="comment-copy">Why does it have to be unicode?</span>
<span class="comment-copy">You should also test performance for invalid cases. No exception is raised with these numbers, which is exactly the "slow" part.</span>
<span class="comment-copy">@UgoMéda i took your advice from 2013 and did it :)</span>
<span class="comment-copy">Isn't this the same answer as <a href="http://stackoverflow.com/a/354073/2541501">the answer by</a> @Zoomulator from six years ago?</span>
<span class="comment-copy">Mind posting the results?</span>
<span class="comment-copy">what is "<code>ast</code>"?</span>
<span class="comment-copy">You should move the append part of that function into an else statement to avoid accidentally triggering the exception should there be something wrong with the array.</span>
<span class="comment-copy">Fails to respond with <code>is_number('10')</code></span>
<span class="comment-copy">@geotheory, what do you mean "fails to respond"?</span>
<span class="comment-copy">Returns nothing</span>
