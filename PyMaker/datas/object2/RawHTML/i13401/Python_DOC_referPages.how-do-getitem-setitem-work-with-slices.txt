<div class="post-text" itemprop="text">
<p>I'm running Python 2.7.10.</p>
<p>I need to intercept changes in a list. By "change" I mean anything that modifies the list in the shallow sense (the list is not changed if it consists of the same objects in the same order, regardless of the state of those objects; otherwise, it is). I don't need to find out <strong>how</strong> the list has changed, only that it has. So I just make sure I can detect that, and let the base method do its work. This is my test program:</p>
<pre><code>class List(list):
    def __init__(self, data):
        list.__init__(self, data)
        print '__init__(', data, '):', self

    def __getitem__(self, key):
        print 'calling __getitem__(', self, ',', key, ')',
        r = list.__getitem__(self, key)
        print '--&gt;', r
        return r

    def __setitem__(self, key, data):
        print 'before __setitem__:', self
        list.__setitem__(self, key, data)
        print 'after  __setitem__(', key, ',', data, '):', self

    def __delitem__(self, key):
        print 'before __delitem__:', self
        list.__delitem__(self, key)
        print 'after  __delitem__(', key, '):', self

l = List([0,1,2,3,4,5,6,7]) #1
x = l[5]                    #2
l[3] = 33                   #3
x = l[3:7]                  #4
del l[3]                    #5
l[0:4]=[55,66,77,88]        #6
l.append(8)                 #7
</code></pre>
<p>Cases #1, #2, #3, and #5 work as I expected; #4, #6, and #7 don't. The program prints:</p>
<pre><code>__init__( [0, 1, 2, 3, 4, 5, 6, 7] ): [0, 1, 2, 3, 4, 5, 6, 7]
calling __getitem__( [0, 1, 2, 3, 4, 5, 6, 7] , 5 ) --&gt; 5
before __setitem__: [0, 1, 2, 3, 4, 5, 6, 7]
after  __setitem__( 3 , 33 ): [0, 1, 2, 33, 4, 5, 6, 7]
before __delitem__: [0, 1, 2, 33, 4, 5, 6, 7]
after  __delitem__( 3 ): [0, 1, 2, 4, 5, 6, 7]
</code></pre>
<p>I'm not terribly surprised by #7: <code>append</code> is probably implemented in an ad-hoc way. But for #4 and #6 I am confused. The <code>__getitem__</code> documentation says: <em>"Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and <strong>slice</strong> objects."</em> (my emphasys). And for <code>__setitem__</code>: <em>" Same note as for <code>__getitem__</code>()"</em>, which I take to mean that <code>key</code> can also be a slice.</p>
<p>What's wrong with my reasoning? I'm prepared, if necessary, to override every list-modifying method (append, extend, insert, pop, etc.), but what should override to catch something like #6?</p>
<p>I am aware of the existence of <code>__setslice__</code>, etc. But those methods are deprecated since 2.0 ...</p>
<p>Hmmm. I read again the docs for <code>__getslice__</code>, <code>__setslice__</code>, etc., and I find this bone-chilling statement:</p>
<p><em>"(However, built-in types in CPython currently still implement <code>__getslice__()</code>. Therefore, you have to override it in derived classes when implementing slicing.)"</em></p>
<p>Is this the explanation? Is this saying "Well, the methods <strong>are</strong> deprecated, but in order to achieve the same functionality in 2.7.10 as you had in 2.0 you still have to override them"? Alas, then why did you deprecate them? How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience?  What do I really need to override to make sure I catch every list-modifying operation?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that you are subclassing a builtin, and so have to deal with a few wrinkles.  Before I delve into the issue, I'll go straight to the "better" answer:</p>
<blockquote>
<p>How will things work in the future? Is there a "list" class - that I am not aware of - that I could extend and would not present this inconvenience? </p>
</blockquote>
<p>Yes, the modern way to do this is to use python's <a href="https://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="nofollow noreferrer">Abstract Base Classes</a>.  You can avoid these ugly complications you are seeing when subclassing builtin <code>list</code>, by using the ABCs instead.  For something list-like, try subclassing <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow noreferrer"><code>MutableSequence</code></a>:</p>
<pre><code>from collections import MutableSequence

class MyList(MutableSequence):
    ...
</code></pre>
<p>Now you should only need to deal with <code>__getitem__</code> and friends for slicing behaviour.  </p>
<hr/>
<p>If you want to push ahead with subclassing the builtin <code>list</code>, read on...</p>
<p>Your guess is correct, you will need to override <code>__getslice__</code> and <code>__setslice__</code>.  The <a href="https://docs.python.org/2/reference/datamodel.html#object.__getslice__" rel="nofollow noreferrer">language reference explains why</a> and you already saw that:</p>
<blockquote>
<p>However, built-in types in CPython currently still implement <code>__getslice__()</code>. Therefore, you have to override it in derived classes when implementing slicing.</p>
</blockquote>
<p>Note that <code>l[3:7]</code> will hook into <code>__getslice__</code>, whereas the otherwise equivalent <code>l[3:7:]</code> will hook into <code>__getitem__</code>.  So you have to handle slices in both... groan!</p>
</div>
<span class="comment-copy">what new subtype?</span>
<span class="comment-copy">The class created..</span>
<span class="comment-copy">The deprecation of <code>__getslice__</code> and <code>__setslice__</code> was announced in the 2s, but not removed until Python 3. In Python 3, all indexing and slicing goes through <code>__XXXitem__</code>, where slicing passes <code>slice</code> objects (in Python 2, only extended slicing, including a step, goes to <code>__getitem__</code> ignoring <code>__getslice__</code>); <code>someobj[a:b]</code> is equivalent to <code>someobj.__getitem__(slice(a, b))</code> in Python 3, where in Python 2 it tries <code>someobj.__getslice__(a, b)</code> if it exists.</span>
