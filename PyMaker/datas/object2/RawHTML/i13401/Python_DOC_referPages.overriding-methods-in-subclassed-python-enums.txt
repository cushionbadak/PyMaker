<div class="post-text" itemprop="text">
<p>From <a href="https://www.python.org/dev/peps/pep-0435/#restricted-subclassing-of-enumerations" rel="nofollow">PEP 435</a> on subclassing enums the following is allowed:</p>
<pre><code>&gt;&gt;&gt; class Foo(Enum):
...   def some_behavior(self):
...     pass
...
&gt;&gt;&gt; class Bar(Foo):
...   happy = 1
...   sad = 2
...
</code></pre>
<p>Say I want to define <code>some_behavior</code> in a different manner for the <code>happy</code> and <code>sad</code> enums.</p>
<p>Is there a better way to do that than something like:</p>
<pre><code>&gt;&gt;&gt; class Bar(Foo):
...   happy = 1
...   sad = 2
...   def some_behavior(self):
...       if self is Bar.happy:
...           # happy behavior
...       elif self is Bar.sad:
...           # sad behavior
</code></pre>
<p>That looks clunky to me. </p>
</div>
<div class="post-text" itemprop="text">
<p>No, there isn't.</p>
<p>I mean, you might be able to do something like this:</p>
<pre><code>def some_behavior(self):
    return {Bar.happy: some_function
            Bar.sad: some_other_function}[self](arguments?)
</code></pre>
<p>Or like this:</p>
<pre><code>def some_behavior(self):
    custom_thing = {Bar.happy: some_function
                    Bar.sad: some_other_function}[self]
    # do something which is the same for both
    custom_thing()
    # do something else the same for both
</code></pre>
<p>But unless <code>some_function</code> etc. already exist, this may not be significantly better than what you have now (though you might be able to save a level or two of indentation, I suppose).  You can use lambdas here, but that gets ugly quite fast, and I don't recommend it except in the simplest of cases (which can often be handled with <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> anyway).</p>
<p>As discussed in the comments, you <em>can</em> do something like this:</p>
<pre><code>class Foo(Enum):
    happy = 1
    sad = 2

def happy_behavior():  # No self argument!
    self = Foo.happy  # only if you need self
    ...

def sad_behavior():
    self = Foo.sad
    ...

Foo.happy.some_behavior = happy_behavior
Foo.sad.some_behavior = sad_behavior
</code></pre>
<p>This is rather ugly, in my opinion, but it should work in all reasonable situations, including expressions like <code>Foo(1).some_behavior()</code> or <code>Foo['sad'].some_behavior()</code>.  However, it may confuse static type checkers and/or linters.</p>
</div>
<span class="comment-copy">The standard way to test an enum's identity is with <code>is</code> (e.g. <code>self is Bar.happy</code>).  Is there a reason you're not using that?</span>
<span class="comment-copy">Edited. My bad.</span>
<span class="comment-copy">You are right. Lambdas wouldn't be beneficial in the long run. Some Javascript like syntax: <code>happy.some_behavior = def() { # do happy stuff }</code>, would have been useful here, which degenerates to Python not having anonymous functions except lambdas.</span>
<span class="comment-copy">You can manually assign functions like that, actually, but it's not idiomatic IMHO.  All Python functions are first-class, not just lambdas.</span>
