<div class="post-text" itemprop="text">
<p>How can I automatically extract part of a string that has a .csv extension. The following example shows the complex string that I am trying to extract <code>2010_USACE_VA_minmax.csv</code> from. A simple slice won't work in my case, instead I need some sort of pattern matching.</p>
<pre><code>sample = "1001        15707 May 08 23:01 2010_USACE_VA_metadata.xml\r\n-rw-rw-r--    1 311      1001         1784 May 08 23:01 2010_USACE_VA_minmax.csv\r\ndrwxrwxr-x    2 311      2013"
</code></pre>
<p><strong>Intended output</strong></p>
<pre><code>2010_USACE_VA_minmax.csv
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you know these are white-space separated and the names themselves do not contain any white space themselves, and you're trying to find a token that ends with <code>.csv</code>, you could also do</p>
<pre><code>&gt;&gt;&gt; tokens = sample.split()
&gt;&gt;&gt; matches = [ i for i in tokens if i.endswith('.csv') ]
&gt;&gt;&gt; matches
['2010_USACE_VA_minmax.csv']
</code></pre>
<hr/>
<p>The same behaviour is achievable with the regular expression <code>\S+\.csv(?!\S)</code>, which is not quite so readable:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'\S+\.csv(?!\S)', sample)
['2010_USACE_VA_minmax.csv']
</code></pre>
<p>Here <code>\S+</code> means at least 1 consecutive non-whitespace characters, <code>\.</code> is the literal <code>.</code> character, and <code>(?!\S)</code> means that the <code>.csv</code> cannot be succeeded by a non-whitespace character (negative zero-width lookahead assertion).</p>
<hr/>
<p>However, it looks like you're parsing the output of the <code>ls</code> *nix command - yet another way would be to find matching files with the <code>glob</code> module:</p>
<pre><code>&gt;&gt;&gt; from glob import glob
&gt;&gt;&gt; glob('*.csv')
['2010_USACE_VA_minmax.csv']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This regex extracted the csv file. There might be a more robust regex, I'm not perfect at it. But this works:</p>
<p>FYI: I used this to test: <a href="http://pythex.org" rel="nofollow">Pythex</a> </p>
<p>The circle brackets are important as they are your capture group to extract what you are looking for.</p>
<p><code>(\s\w+\.csv)</code></p>
<p>If you want to handle spaces in the filename, I believe this should work: </p>
<p><code>(\s[\w,\s-]+\.csv)</code></p>
<p>Here is infrmation on regex in Python: 
<a href="https://docs.python.org/3/library/re.html" rel="nofollow">https://docs.python.org/3/library/re.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If there were no spaces in the  path:</p>
<pre><code>print(sample[:sample.find(".csv")+4].rsplit(None, 1)[1])
2010_USACE_VA_minmax.csv
</code></pre>
<p>The output also looks like it comes from a unix command so might be an idea to use a linux tool to parse it, if it is a unix command the format is most probably consistent so you can split the lines to get the filenames:</p>
<pre><code>sample = "1001        15707 May 08 23:01 2010_USACE_VA_metadata.xml\r\n-rw-rw-r--    1 311      1001         1784 May 08 23:01 2010_USACE_VA_minmax.csv\r\ndrwxrwxr-x    2 311      2013"


for line in sample.splitlines():
    f  = line.rsplit(None, 1)[1]
    print(f)
2010_USACE_VA_metadata.xml
2010_USACE_VA_minmax.csv
2013
</code></pre>
<p>I presume 2013 comes from you having truncated some of the output.</p>
<p>If you are using subprocess to run the command and you didn't need any of the other data, <code>ls</code> can take a wildcard:</p>
<pre><code>from subprocess import check_output
f = check_output(["ls","*.csv"])
</code></pre>
<p>Or to get the permissions etc.. as per you own command:</p>
<pre><code>data = check_output(["ls","-l","*.csv"])
</code></pre>
<p>That will give you just the .csv files and their permissions so you just need to iterate over the output again with splitlines and every file at the end will be a csv file.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
mobj = re.search(r'\s\d{4}_[^ ]*csv',sample)          
print(mobj.group())
</code></pre>
<hr/>
<h3>output</h3>
<pre><code>2010_USACE_VA_minmax.csv
</code></pre>
</div>
<span class="comment-copy">What does your code look like? This looks like a job for regex.</span>
<span class="comment-copy">Go here: <a href="http://www.pythex.org" rel="nofollow noreferrer">pythex.org</a>. Play around with some regex with the string you want to test. Should give you the regex formula you are looking for.</span>
<span class="comment-copy">why use regex and not <a href="https://docs.python.org/2/library/csv.html" rel="nofollow noreferrer">csv</a>?</span>
<span class="comment-copy">What is the format of the file names? In particular, is it possible for them to contain spaces?</span>
<span class="comment-copy">@idjaw Sorry, I misread the question. Your approach is the right one.</span>
<span class="comment-copy">Why would you split every part of the line when the file is always at the end?</span>
<span class="comment-copy">How do I know it :P If it is the output of the <code>ls</code> then the proper way to do it is not to parse it at all, but to use <code>glob</code>.</span>
<span class="comment-copy">Well if I were using ls just to get the filename would be  <code>ls *.csv</code> then no parsing needed at all</span>
<span class="comment-copy">or <code>ls -1 *.csv</code></span>
<span class="comment-copy">Just added something similar, not sure the OP only wants a single match so won't include 1, the OP must actually care about the other data or else they don't really know you can use <code>ls</code> by itself!</span>
