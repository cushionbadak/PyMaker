<div class="post-text" itemprop="text">
<p>I have a dataframe, <code>memory</code> that looks like this:</p>
<pre><code>&gt;&gt;&gt; memory
  input             action result
      1   2   3   4 action      1   2   3   4
0    11  22  33  44      a     10  20  30  40
1    10  20  30  40      b     90  90  90  90
2    90  90  90  90      c     91  91  91  91
&gt;&gt;&gt; type(memory)
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre>
<p>I have a dataframe, <code>bla</code> that looks like this:</p>
<pre><code>&gt;&gt;&gt; bla
    1   2   3   4
0  11  22  33  44
&gt;&gt;&gt; type(bla)
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre>
<p>I want a daraframe made of <code>memory</code> where <code>bla</code> is taken out:</p>
<pre><code>&gt;&gt;&gt; minus_bla
  input             action result
      1   2   3   4 action      1   2   3   4
1    10  20  30  40      b     90  90  90  90
2    90  90  90  90      c     91  91  91  91
</code></pre>
<p>and one where <code>bla</code> is selected for:</p>
<pre><code>&gt;&gt;&gt; memory_bla
  input             action result
      1   2   3   4 action      1   2   3   4
0    11  22  33  44      a     10  20  30  40
</code></pre>
<p>I tried to do this with filtering but that's just silly:</p>
<pre><code>memory[memory.loc[:,'input'] == bla]
</code></pre>
<p>I got this error:</p>
<pre><code>ValueError: Can only compare identically-labeled DataFrame objects
</code></pre>
<p>Anyway, maybe I can do this with a <code>merge</code> but so far I've had no luck.</p>
<p>The way I'm solving this right now is a huge workaround of producing a slicing conditional that looks like this:</p>
<pre><code>&gt;&gt;&gt; memory[
    (memory[('input', 1)]==bla.loc[0, 1]) &amp; 
    (memory[('input', 2)]==bla.loc[0, 2]) &amp; 
    (memory[('input', 3)]==bla.loc[0, 3]) &amp;
    (memory[('input', 4)]==bla.loc[0, 4])]
  input             action result
      1   2   3   4 action      1   2   3   4
0    11  22  33  44      a     10  20  30  40
</code></pre>
<p>Isn't that just sad? Especially in my case where I could have a variable number of <code>inputs</code> (not just 4).</p>
<p>Surely there's a better way to select for and against a sub dataframe (even when the larger dataframe has multiple column levels), probably involving <code>merge</code>? can you point me in the right direction?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>merge</code> </p>
<pre><code>idx=df.loc[:,'input'].merge(bla,indicator =True).index
df1=df.loc[df.index.difference(idx),:]
df2=df.loc[idx]
df1
Out[683]: 
  input             action result            
      1   2   3   4 action      1   2   3   4
1    10  20  30  40      b     90  90  90  90
2    90  90  90  90      c     91  91  91  91
df2
Out[684]: 
  input             action result            
      1   2   3   4 action      1   2   3   4
0    11  22  33  44      a     10  20  30  40
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without having your data, you can achieve this by first doing a <code>left merge</code> and including <code>indicator=True</code> and after that filter on <code>left_only</code>:</p>
<pre><code># Example data
np.random.seed(0)
left = pd.DataFrame({'key': ['A', 'B', 'C', 'D'], 'value': np.random.randn(4)})    
right = pd.DataFrame({'key': ['B', 'D', 'E', 'F'], 'value': np.random.randn(4)})

print(left)
print(right)
  key     value
0   A  1.764052
1   B  0.400157
2   C  0.978738
3   D  2.240893
  key     value
0   B  1.867558
1   D -0.977278
2   E  0.950088
3   F -0.151357
</code></pre>
<p>Perfom a left join</p>
<pre><code>df_join = pd.merge(left, right, on='key', how='left', indicator=True)
print(df_join)
  key   value_x   value_y     _merge
0   A  1.764052       NaN  left_only
1   B  0.400157  1.867558       both
2   C  0.978738       NaN  left_only
3   D  2.240893 -0.977278       both
</code></pre>
<p>Filter on only left</p>
<pre><code>unmatch = df_join[df_join['_merge'] == 'left_only']
print(unmatch)
  key   value_x  value_y     _merge
0   A  1.764052      NaN  left_only
2   C  0.978738      NaN  left_only
</code></pre>
</div>
<span class="comment-copy">Is there another way you could share your data? <code>MultiIndex</code> is not copy-able with <code>pd.read_clipboard</code></span>
<span class="comment-copy">after further testing this doesn't seem to work - it seems to be merging on the indices instead of on the values of the columns. in order to fix this I will have to dynamically create a list of column names (under the first level) that I want it to merge on. including the <code>on</code>, in the merge seems to solve the problem: <code>idx = memory.loc[:, 'input'].merge(b, on=[1,2,3,4], indicator=True).index</code> thanks! and to make it dynamic: <code>idx = memory.loc[:, 'input'].merge(b, on=memory['input'].columns.tolist(), indicator=True).index</code></span>
<span class="comment-copy">@LegitStack thanks for the improvement (based on you real data), happy coding :-)</span>
