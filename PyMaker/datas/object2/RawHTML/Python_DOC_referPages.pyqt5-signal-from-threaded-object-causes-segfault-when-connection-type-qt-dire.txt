<div class="post-text" itemprop="text">
<p>I have some PyQt5 python code which downloads a set of files.  I am using multiprocessing.dummy, as a wrapper for threading, using apply_async to obtain simultaneous downloads.
From my threaded function I want to update a progress bar in the main gui, but when I do this, QT selects a queued connection for the signal and the function in the main thread that plays with the downloaded files starts (the files having been downloaded), and then, all of a sudden, the progress bar updates reporting the files as downloading, even though they have downloaded some time before.</p>
<p>If I create the signal with Qt.DirectConnection, I get the desired behaviour but after the files have downloaded I get a segfault, and the main thread quits.  I am sure there must be someway of dealing with this issue, since it is not an unusual task, but having tried mutexes, signals to signals, and a number of other attempts, I am almost tearing my hair out.  I'm sure the answer is obvious.</p>
<p>I've read the other answers here, to similar problems but there is nothing particularly enlightening.</p>
<p><a href="https://stackoverflow.com/questions/40537026/pyqt5-signals-and-threading">PyQt5 Signals and Threading</a></p>
<p>suggests to connect from inside the created thread, but I'm loathe to try this since the thread is created in a class that is composited into a custom object in the main thread, and I don't really want to pass a reference down the hierarchy.  If I have to I suppose, but I tried instead connecting a signal inside the threaded function to call method inside the class that then called the signal, but with no luck, just the same results.</p>
<p>Many thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I eventually discovered that the segfault was being caused by my joining the threadpool from the main thread after calling the thread_pool.apply_async.  I removed the close and join statements and the directconnection on the signal worked fine, as expected.  I continued to get the warning:</p>
<pre><code>QObject::setParent: Cannot set parent, new parent is in a different thread
</code></pre>
<p>But the program worked as expected.
Thanks!</p>
</div>
<span class="comment-copy">Please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">the code is over at github under the dependencies branch.  I'll work on creating a minimal example now but in the meantime here is the link - the code in question is in the file packages.py, and the function is download_packages. <a href="https://github.com/millerthegorilla/fedkx/tree/dependencies" rel="nofollow noreferrer">github.com/millerthegorilla/fedkx/tree/dependencies</a></span>
<span class="comment-copy">The connection is made at line 67 of kxfed.py.  The problem occurs if I add 'type=Qt.DirectConnection' to the connection code</span>
<span class="comment-copy">I can't really make a minimal, complete and verifiable example with pyqt.  I'd have to create a new main window using pyuic, and then code the rest of it, and it certainly isn't going to be minimal.</span>
<span class="comment-copy">That warning is significant so please don't simply ignore it.  Your program may appear to function correctly but there is still a potential problem.</span>
