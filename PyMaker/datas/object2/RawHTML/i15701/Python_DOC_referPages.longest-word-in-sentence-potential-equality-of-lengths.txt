<div class="post-text" itemprop="text">
<pre><code>sentence = 'Cunning fox peels apples.'.strip('.')
def longest_word(target):
    set = max(target.split(), key=len)
    temp = [x for x in set]
    count = 0
    for i in range(len(temp)):
        if temp[i].isalpha() == True:
            count += 1
    return set,count
print(longest_word(sentence))
</code></pre>
<p>The code works if the longest word in a sentence is strictly longer in symbols than any other, however, how should I adjust the code if the sentence is something like:</p>
<pre><code>sentence = 'Black bananas and green tomatos are red.'
</code></pre>
<p>How can I return that there are n words that are equally long? Obviously it's enough to count the symbols in one of the words, but the:</p>
<pre><code>set = max(sentence.split(),key=len)
</code></pre>
<p>returns only the first of the longest words.</p>
</div>
<div class="post-text" itemprop="text">
<p>You probably need to make two passes along the list of targets, once to get the maximum length, and then to select all words whose length matches the maximum:</p>
<pre><code>def longest_words(targets):
    targets = targets.split()
    max_len = max(len(item) for item in targets)
    return set(item for item in targets if len(item) == max_len)
</code></pre>
<p>Quick test:</p>
<pre><code>In [17]: sentence = 'Black bananas and green tomatos are red.'

In [18]: longest_words(sentence.strip('.'))
Out[18]: {'bananas', 'tomatos'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code> module</a>. It has a <code>groupby()</code> function that can be used to group an iterator based on a custom-defined function, in this case <code>len()</code>:</p>
<pre><code>&gt;&gt;&gt; sentence = 'Black bananas and green tomatos are red.'
&gt;&gt;&gt; words = sorted(sentence.strip(".").split(), key=len)
&gt;&gt;&gt; groups = [list(g) for k,g in itertools.groupby(words, len)]
&gt;&gt;&gt; groups
[['and', 'are', 'red'], ['Black', 'green'], ['bananas', 'tomatos']]
&gt;&gt;&gt; groups[-1]
['bananas', 'tomatos']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can first get maximum length, and check and fetch each word of the same length:</p>
<pre><code>sentence = 'Black bananas and green tomatos are red.'.strip('.')
def longest_word(target):
    words = target.split()
    max_len = max([len(w) for w in words])
    return max_len, [w for w in words if len(w)==max_len]
print(longest_word(sentence))
</code></pre>
<p>You can also define a customized <code>len</code> function to count only characters,</p>
<pre><code>def word_len(word):
    return len([c for c in word if c.isalpha()])
</code></pre>
<p>and replace <code>len</code> with <code>word_len</code> in the previous example.</p>
</div>
<div class="post-text" itemprop="text">
<p>My function returns a list with the longest word or words. </p>
<pre><code>def longest(sentence):
    ordered = sorted(sentence.split(), key=len)
    l = len(ordered[-1]) # the last, longest element
    m = [ordered[-1]]
    for elt in ordered[-2::-1]:
        if len(elt) &lt; l : return m
        m.append(elt)
    return m
</code></pre>
</div>
<span class="comment-copy">This code is as un-Pythonic as it can get. You should use <code>list(set)</code> instead of a list-comprehension in this case. <code>max(...)</code> will only give you one item of the passed list. Python for-loops can already iterate over the list <code>temp</code>, no need for the <code>range()</code>. You should also prefer not to compare with <code>True</code></span>
<span class="comment-copy">Some small comments to your code: 1) you should never compare to <code>True</code>, just do <code>if temp[i].isalpha(): ...</code>. 2) Instead of iterating over the length of <code>temp</code>, you can directly iterate over the letters of temp, so do <code>for letter in temp: if letter.isalpha(): ...</code>. 3) You don't even have to use a for-loop: <code>count = sum(1 for letter in temp if letter.isalpha())</code></span>
<span class="comment-copy">Thank you for pointing out the un-pythonic style. I will improve on it, I have only recently begun using python.</span>
<span class="comment-copy">Much appreciated :)</span>
<span class="comment-copy">+1 , exactly what i wanted to post ! ;)</span>
<span class="comment-copy">This is a nice generalisation of the problem, much appreciated.</span>
<span class="comment-copy">Thank you, as well.</span>
