<div class="post-text" itemprop="text">
<p>I just worked through the [bottle tutorial[<a href="http://bottlepy.org/docs/0.12/tutorial.html#request-data" rel="nofollow">1</a> and found the below helpful table (I hope I get the format right) of where what types of request attributes can be accessed</p>
<pre><code>Attribute           GET Form fields     POST Form fields    File Uploads
BaseRequest.query   yes                 no                  no
BaseRequest.forms   no                  yes                 no
BaseRequest.files   no                  no                  yes
BaseRequest.params  yes                 yes                 no
BaseRequest.GET     yes                 no                  no
BaseRequest.POST    no                  yes                 yes
</code></pre>
<p>Of course I want to try it out myself, but because Bottle data structures are special thread-safe versions, and I wanted to use json to print it in a sensible format, I wrote the following (working) test program</p>
<pre><code>from bottle import run, route, request, response, template, Bottle
import uuid
import json
import os

ondersoek = Bottle()

@ondersoek.get('/x')
@ondersoek.post('/x')
def show_everything():
   PythonDict={}
   PythonDict['forms']={}
   for item in request.forms:
      PythonDict['forms'][item]=request.forms.get(item)

   PythonDict['query']={}
   for item in request.forms:
      PythonDict['query'][item]=request.query.get(item)

   #The below does not work - multipart/form-data doesn't serialize in json
   #PythonDict['files']={}
   #for item in request.files:
      #PythonDict['files'][item]=request.files.get(item)

   PythonDict['GET']={}
   for item in request.GET:
      PythonDict['GET'][item]=request.GET.get(item)

   PythonDict['POST']={}
   for item in request.POST:
      PythonDict['POST'][item]=request.POST.get(item)

   PythonDict['params']={}
   for item in request.params:
      PythonDict['params'][item]=request.params.get(item)

   return json.dumps(PythonDict, indent=3)+"\n"

ondersoek.run(host='localhost', port=8080, reloader=True)
</code></pre>
<p>This works, I get:</p>
<pre><code>tahaan@Komputer:~/Projects$ curl -G -d dd=dddd http://localhost:8080/x?q=qqq
{
   "files": {}, 
   "GET": {
      "q": "qqq", 
      "dd": "dddd"
   }, 
   "forms": {}, 
   "params": {
      "q": "qqq", 
      "dd": "dddd"
   }, 
   "query": {}, 
   "POST": {}
}
</code></pre>
<p>And</p>
<pre><code>tahaan@Komputer:~/Projects$ curl -X POST -d dd=dddd http://localhost:8080/x?q=qqq
{
   "files": {}, 
   "GET": {
      "q": "qqq"
   }, 
   "forms": {
      "dd": "dddd"
   }, 
   "params": {
      "q": "qqq", 
      "dd": "dddd"
   }, 
   "query": {
      "dd": null
   }, 
   "POST": {
      "dd": "dddd"
   }
}
</code></pre>
<p>I'm quite sure that this is not thread safe because I'm copying the data one item at a time from the Bottle data structure into a Python native data structure.  Right now I'm still using the default non-threaded server, but for performance reasons I would want to use a threaded server like CherryPy at some point in the future.  The question therefore is How do I get data out of Bottle, or any other similar thread-safe dict into something that can be converted to JSON (easily)?  Does Bottle by any chance expose a FormsDict-To-Json function somewhere?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code <em>is</em> thread safe. I.e., if you ran it in a multithreaded server, it'd work just fine.</p>
<p>This is because a multithreaded server still only assigns one request per thread.  You have no global data; all the data in your code is contained within a single request, which means it's within a single thread.</p>
<p>For example, the Bottle docs for the <a href="http://bottlepy.org/docs/dev/api.html#bottle.LocalRequest" rel="nofollow">Request object</a> say (emphasis mine):</p>
<blockquote>
<p>A thread-local subclass of
  BaseRequest with a different set of attributes for each thread. There
  is usually only one global instance of this class (request). If
  accessed during a request/response cycle, <strong>this instance always refers
  to the current request (even on a multithreaded server)</strong>.</p>
</blockquote>
<p>In other words, every time you access <code>request</code> in your code, Bottle does a bit of "magic" to give you a thread-local Request object.  This object is <em>not</em> global; it is distinct from all other Request objects that may exist concurrently, e.g. in other threads.  As such, it is thread safe.</p>
<hr/>
<p><strong>Edit</strong> in response to your question about PythonDict in particular: This line makes your code thread-safe:</p>
<pre><code>PythonDict={}
</code></pre>
<p>It's safe because you're creating a <em>new</em> dict every time a thread hits that line of code; and each dict you're creating is local to the thread that created it.  (In somewhat more technical terms: it's on the stack.)</p>
<p>This is in contrast to the case where your threads were sharing a <em>global</em> dict; in that case, your suspicion would be right: it would not be thread-safe.  But in your code the dict is local, so no thread-safety issues apply.</p>
<p>Hope that helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I can see there's no reason to believe that there's a problem with threads, because your request is being served by Bottle in a single thread. Also there are no asynchronous calls in your own code that could spawn new threads that access shared variables. </p>
</div>
<span class="comment-copy">While I don't know Bottle in particular, your question is a bit confusing. You say that <b>the Bottle data structures <i>are</i> thread safe</b>, and thus you think that using accessing them <b>will <i>not</i> be thread safe</b>? I would think that being thread safe would mean that accesses are thread safe.</span>
<span class="comment-copy">I'm sure there are other interesting and/or better ways to achieve the same thing as your code, but if everything's working for you... maybe it's not "too good to be true"?</span>
<span class="comment-copy">I should clarify my question, though I did say I'm asking "for future reference". Yes, It is working and I don't have a threading issue TODAY.  But tomorrow I may not be using Bottle behind CherryPy.  And the Non-thread-safe part is the itteration through the bottle data type outside of Bottle, slowly copying the data from a threadsafe structure into a non-thread-safe structure.</span>
<span class="comment-copy">Which part of that do you feel is not thread safe? The copying out or the copying in?</span>
<span class="comment-copy">Ok, then with all due respect, you have a misunderstanding of the basics of how code is executed in most programming languages. A tutorial might help. I don't have a quick link to one for that, but some of the same concepts are covered in <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="nofollow noreferrer">this section of the Python Language Reference</a></span>
<span class="comment-copy">I'm concerned that another thread could step on <code>PythonDict</code> - in other words two threads copying from two safe, distinct "instances" of the request object, adding data to a single Python dictionary variable.</span>
<span class="comment-copy">But there's no shared PythonDict in the question.  Every time <code>show_everything</code> is called, new (local) PythonDicts are created.  Do you agree?</span>
<span class="comment-copy">OK, I see the distinction now.  How could I intentionally create a cross thread shared object, eg to use as a DB connection pool?</span>
<span class="comment-copy">Cool.  That's a new question--but in a nutshell: create a <i>global</i> object.</span>
<span class="comment-copy">And if you found this answer helpful, please don't forget to accept or upvote it.  Thank you!</span>
<span class="comment-copy">When using Bottle with CherryPy it is trivial to demonstrate that multiple instances can run concurrently.  However I failed in my tests to produce a result where the instances overwrite each other's variables.</span>
