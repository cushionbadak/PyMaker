<div class="post-text" itemprop="text">
<p>I'm trying to find and replace a multiline  pattern in a JSON feed. Basically, I'm looking for a line ending "}," followed by a line with just "}".</p>
<p>Example input would be:</p>
<pre><code>s = """
              "essSurfaceFreezePoint":    "1001",
              "essSurfaceBlackIceSignal": "4"
              },
            }
          }
"""
</code></pre>
<p>and I want to find:</p>
<pre><code>"""
              },
            }
"""
</code></pre>
<p>and replace it with:</p>
<pre><code>"""
              }
            }
"""
</code></pre>
<p>I've tried the following:</p>
<pre><code>pattern = re.compile(r'^ *},\n^ *}$',flags=re.MULTILINE)
pattern.findall(feedStr)
</code></pre>
<p>This works in the python shell. However, when I do the same search in my python program, it finds nothing. I'm using the full JSON feed in the program. Perhaps it's getting a different line termination when reading the feed.</p>
<p>The feed is at:</p>
<p><a href="http://hardhat.ahmct.ucdavis.edu/tmp/test.json" rel="nofollow">http://hardhat.ahmct.ucdavis.edu/tmp/test.json</a></p>
<p>If anyone can point out why this is working in the shell, but not in the program, I'd greatly appreciate it. Is there a better way to formulate the regular expression, so it would work in both?</p>
<p>Thanks for any advice.</p>
<p>=====================================================================================</p>
<p>To make this clearer, I'm adding my test code here. Note that I'm now including the regular expression provided by Ahosan Karim Asik. This regex works in the live demo link below, but doesn't quite work for me in a python shell. It also doesn't work against the real feed.</p>
<p>Thanks again for any assistance.</p>
<pre><code>import urllib2
import json
import re

if __name__ == "__main__":
    # wget version of real feed:
    # url = "http://hardhat.ahmct.ucdavis.edu/tmp/test.json"
    # Short text, for milepost and brace substitution test:
    url = "http://hardhat.ahmct.ucdavis.edu/tmp/test.txt"
    request = urllib2.urlopen(url)
    rawResponse = request.read()
    # print("Raw response:")
    # print(rawResponse)

    # Find extra comma after end of records:
    p1 = re.compile('(}),(\r?\n *})')
    l1 = p1.findall(rawResponse)
    print("Brace matches found:")
    print(l1)

    # Check milepost:
    #p2 = re.compile('( *\"milepost\": *\")')
    p2 = re.compile('( *\"milepost\": *\")([0-9]*\.?[0-9]*)\r?\n')
    l2 = p2.findall(rawResponse)
    print("Milepost matches found:")
    print(l2)

    # Do brace substitutions:
    subst = "\1\2"
    response = re.sub(p1, subst, rawResponse)

    # Do milepost substitutions:
    subst = "\1\2\""
    response = re.sub(p2, subst, response)
    print(response)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>try this:</strong></p>
<pre><code> import re
    p = re.compile(ur'(^ *}),(\n^ *})$', re.MULTILINE)
    test_str = u" \"essSurfaceFreezePoint\": \"1001\",\n \"essSurfaceBlackIceSignal\": \"4\"\n },\n }\n }"
    subst = u"$1$2"

    result = re.sub(p, subst, test_str)
</code></pre>
<p><a href="http://regex101.com/r/pE9bV5/6" rel="nofollow">live demo</a></p>
</div>
<span class="comment-copy">could you post the code you tried?</span>
<span class="comment-copy">Might be better off to yell at the DOT and tell them to fix their feed. If they're pushing out invalid JSON, they should fix it, not force you to compensate for it.</span>
<span class="comment-copy">Marc, I'm definitely working with (not yelling at...) the DOT to fix the feed.</span>
<span class="comment-copy">You should test both versions of the regex on <i>identical</i> data.  No other comparison of shell-vs-script output is valid.  And since you mentioned line endings, isn't <code>\n^</code> in the middle of your regex exactly the same as just `\n' in <a href="https://docs.python.org/3/library/re.html#re.MULTILINE" rel="nofollow noreferrer">re.MULTILINE</a> mode?</span>
<span class="comment-copy">Avinash, I've added some test code (which doesn't work for me). Thanks.</span>
<span class="comment-copy">Ahosan, this looks like it should work. It definitely does in the live demo link for the regex test. However, when I try it in the python shell, I get back the string: result = u' "essSurfaceFreezePoint": "1001",\n "essSurfaceBlackIceSignal": "4"\n\x01\x02\n }'. I don't understand where the \x01\x02 is coming from. Does this make sense to you? Also, when I try your pattern in my code, but with a test using p.findall(), I get back no results.</span>
<span class="comment-copy">this come from regex101.com . you can assign your string into <code>test_str</code> var . do u see live demo?</span>
<span class="comment-copy">Ahosan, I do see the live demo, and it does work just as you provided it. But that same code does not work in shell for me. It looks like it should.</span>
<span class="comment-copy">I'm marking this correct. However, I'm still having a bit of trouble in that result contains "\x01\x02" and seems to be missing a couple of braces. However, it does look correct, and has gotten me much further along. Thanks all.</span>
