<div class="post-text" itemprop="text">
<p>I am using pyaudio in callback mode with <code>paFloat32</code> format, 2 channels, 1024 frames per buffer, and I am interested in a more efficient input/output audio buffer data exchange.</p>
<p>To unpack an input audio buffer and get the list of float samples, I use:</p>
<pre><code>fmt       = str( N_CHANNELS * BUFFER_SIZE ) + 'f'
in_floats = struct.unpack( fmt, in_data )
</code></pre>
<p>Using <code>struct.pack()</code> and <code>struct.unpack()</code> is quite inefficient and it takes significant CPU resources, almost the same as the audio signal processing itself. Since most sound cards are 16 bit, I also tried to use the <code>paInt16</code> format, but the results are almost identical.</p>
<p>What would be the most efficient format and pack/unpack method to use in callback mode (of course maintaining full resolution)?</p>
<p>Edit: PyAudio exchanges data using binary streams or buffers similar to the C data structures used with Portaudio. I need to unpack the <code>in_data</code> input buffer to get the float samples and analyze them. Everyting is OK, except the unpack is a bit slow.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using either <a href="http://www.numpy.org/" rel="nofollow">NumPy</a> or the stdlib's <a href="https://docs.python.org/3/library/array.html" rel="nofollow"><code>array</code></a> module is going to be much faster, because most of the cost of <code>struct.unpack</code> isn't the unpacking, it's the boxing up of each float value in a Python <code>float</code> object.</p>
<p>For example:</p>
<pre><code>In [1177]: f = [random.random() for _ in range(65536)]

In [1178]: b = struct.pack('65536f', *f)

In [1179]: %timeit struct.unpack('65536f', b)
1000 loops, best of 3: 1.61 ms per loop

In [1180]: %timeit array.array('f', b)
100000 loops, best of 3: 17.7 µs per loop
</code></pre>
<p>That's 100x as fast. And you've got an iterable of floats either way, it's just that it's an <code>array</code> instead of a <code>tuple</code>.</p>
<p>However, if you're planning to actually do any arithmetic on these values, you're still going to have to iterate those values—and <code>array</code> will have to unbox each of them as you do so, which is going to add back in a good chunk of the time you've saved.</p>
<p>That's where NumPy comes in; I doubt <code>np.frombuffer(b, dtype=np.float32)</code> is going to be hugely faster than <code>array.array('f', b)</code> to create, but it will allow you to do vectorized arithmetic directly on the unboxed values. For example:</p>
<pre><code>In [1186]: a1 = array.array('f', b)

In [1187]: a2 = np.frombuffer(b, dtype=np.float32)

In [1189]: %timeit sum(f)
1000 loops, best of 3: 586 µs per loop

In [1189]: %timeit sum(a1)
1000 loops, best of 3: 907 µs per loop

In [1190]: %timeit a2.sum()
10000 loops, best of 3: 80.3 µs per loop
</code></pre>
<p>As you can see, using the <code>array.array</code> makes this twice as slow (I used <code>sum</code> because the actual iteration and arithmetic are done in C), but using <code>np.array</code> instead makes it 5x as fast.</p>
</div>
<span class="comment-copy"><code>struct</code> is relatively fast. If you need something faster, you probably don't want to use python for the job. You can try to write the callback in C, or avoid unpacking altogether</span>
<span class="comment-copy">You can also try <code>numpy</code>, but since you're dealing with relatively small buffers, the overhead may be big enough to negate the benefit</span>
<span class="comment-copy">Why do you need to pack and unpack the data?  Anyway, numpy's <code>frombuffer</code> might be useful to you here.. <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.frombuffer.html#numpy.frombuffer" rel="nofollow noreferrer">docs.scipy.org/doc/numpy/reference/generated/…</a>   If you want to follow up, please post some minimal but functional code so we can see what you're trying to do.</span>
<span class="comment-copy">The packing/unpacking processing is tolerable, I was just curious if something more efficient is available, as it takes significant time. I edited the question to be more clear. Thank you for your answers.</span>
