<div class="post-text" itemprop="text">
<p>How can access to elements generated in list-comprehension while iteratin
usually we access to last element added via <code>list[-1]</code>.</p>
<p>In case of generator or comprehension list, how can get the element while iterating it</p>
<pre><code>[&lt;access to last element&gt; added for i,item in enumerate(range(10))]
</code></pre>
<p>to build something similar to :</p>
<pre><code>    i=0
    l=[0]
    while i&lt;10:
        newItem= 2*l[-1]
        l+=[newItem]
        i+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions do not provide this feature. For the sake of simplicity, they only support a small subset of what you can do with a real <code>for</code> statement, and this feature is not in that subset. If you really want to, you can use ugly hacks like</p>
<pre><code>prev = [None]
l = [(prev.__setitem__(0, do_something_with(prev[0])), prev[0])[1] for i in thing]
</code></pre>
<p>but they're all far less readable than a <code>for</code> loop.</p>
<p>In Python 3, there's <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a>, which is to the feature you want what <code>map</code> and <code>filter</code> are to <code>for</code> and <code>if</code> clauses in a list comprehension. The first item of the output is the first item of the input, and items after that are produced by passing the previous output item and the next input item to a function you specify.</p>
<pre><code>import itertools
def do_something_with(prev_output, next_input):
    return prev_output * next_input

input_list = [1, 4, 2, 5, 3]
l = list(itertools.accumulate(input_list, do_something_with))
# l == [1, 4, 8, 40, 120]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>what i understand this from your question: I am not sure though</p>
<pre><code>l=[1]
[ l.append(l[-1]*2) for i,x in enumerate(l,start=1) if i&lt;10 ]
[None, None, None, None, None, None, None, None, None]
&gt;&gt;&gt; l
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
</code></pre>
<p>this will update the list but it will return <code>None</code> though</p>
<p>without using l[-1]:</p>
<pre><code>l=[1]
[ l.append(l[i]*2) for i,x in enumerate(l) if i&lt;10 ]
[None, None, None, None, None, None, None, None, None, None]
&gt;&gt;&gt; l
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
</code></pre>
</div>
<span class="comment-copy">You're aware this code will just give you a list of zero's right?</span>
<span class="comment-copy">you question  not clear</span>
<span class="comment-copy">you want to build some function similar to list comprehension right???</span>
<span class="comment-copy">yes! that's right! @IanAuld this is just a quick example, what matter is how to make such thing!</span>
<span class="comment-copy">@user3378649 check the code, this is what you wanted???</span>
<span class="comment-copy">Very convenient answer. Thanks!</span>
<span class="comment-copy">This doesn't answer his question (as far as I can tell). I believe he is asking how to add an element to a list based off of the previous element. For example if  <code>l = [1]</code> the comprehension would multiply the last element of the list, in this case 1, by 2 and then add the result to the list which would now be <code>[1, 2]</code> and then repeat that by multiplying the last element, now 2, by 2 and appending the result.</span>
