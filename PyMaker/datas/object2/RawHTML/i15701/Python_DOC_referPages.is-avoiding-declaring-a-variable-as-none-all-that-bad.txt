<div class="post-text" itemprop="text">
<p>I'm working on one of those classic student problems in Python, finding the maximum and minimum values in a series of entries. Normally, I would want to do this by putting all the valid user entries in a list, but instead we're supposed to be evaluating each entry one by one as it comes from the user. (In this class, we're covering loops before lists.)</p>
<p>Since I'm not using a list, I am balking at declaring a variable to be None and then evaluating "largest is None or largest &lt; new" since the former case will only happen once. Instead, I mucked around with min() and max() until I fell upon the following solution, which seems to me to be elegant but my peers have dismissed as an abomination. </p>
<p>So here's the question: Is this a valid use of try/except? Is it less pythonic than the commented alternative? (Granted, the most pythonic way would be min([list]) but here I am.)</p>
<pre><code>#smallest = None

while True:
    num = raw_input("Enter a number: ")
    if num == "done" : break
    try:
        num = int(num)
    except:
        print 'Invalid input'
        continue

    try:
        smallest = min(num,smallest)
    except NameError:
        smallest = num

#    if num &lt; smallest or smallest is None:
#        smallest = num    

print "Minimum is", smallest
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, that's a pretty ridiculous use of try/except.</p>
<p>Declare it upfront and define it as <code>None</code>, and then update it as</p>
<pre><code>smallest = num if smallest is None else min(num, smallest)
</code></pre>
<hr/>
<p>Alternatively, you could initialize it as <code>smallest = []</code>, and then update it as</p>
<pre><code>smallest = [min(smallest + [num])]
</code></pre>
<p>then finish it off with</p>
<pre><code>print("Minimum is {}".format(smallest) if smallest else "No numbers!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While trying and handling exception is, in general, a fundamental principle of Python—<a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP, or Easier to Ask Forgiveness than Permission</a>—it isn't <em>always</em> appropriate.</p>
<p>At the very least, a <code>NameError</code> is the kind of thing that's generally more of a logic error in your code that needs to be fixed than an exceptional situation to be handled, so there's a pretty bad "code smell" here.</p>
<p>Also, consider what should happen if the user never enters any numbers. If you've initialized <code>smallest = None</code>, it'll print out <code>Minimum is None</code>, which is not too unreasonable. If you've left it uninitialized, it'll print out a stack trace from an unhandled <code>NameError</code>, which is a lot less user-friendly.</p>
<hr/>
<p>But there's a simple alternative: just pick a start value that's larger than any valid input, and then you don't need the check (whether via EAFP or LBYL): <code>smallest = min(num, smallest)</code> will always be the right answer.</p>
<p>What value can you use for that? Well, infinity is obviously bigger than any integer, so you can just start with <code>float('inf')</code>.</p>
<p>(I'm not sure whether <code>Minimum is inf</code> is better or worse than <code>Minimum is None</code> for the no-values case, but it's definitely better than the traceback.)</p>
<hr/>
<p>Meanwhile, it's worth noting that there's a much cleaner design for this that avoids the problem in the first place. Just factor out your code to generate a stream of integers, and then you can do whatever you want with the resulting iterable. For example:</p>
<pre><code>def numbers():
    while True:
        num = raw_input("Enter a number: ")
        if num == "done" : break
        try:
            yield int(num)
        except:
            print 'Invalid input'

smallest = min(numbers())
</code></pre>
<p>This has all the advantages of building a list (you can just call <code>min</code> on it) without the disadvantages (you don't have to actually build a list up in memory).</p>
<p>You can simplify this even further by using the two-argument <code>iter</code> around <code>raw_input</code> to yield a generator of strings, then transforming that in two steps to a generator of integers, then just passing that to <code>min</code>. But I think it's easier for a novice to understand this way.</p>
</div>
<span class="comment-copy">Rule: exceptions should be <i>exceptional</i>, not to cover for coding; there are only a few cases when using them is more applicable than performing a check first (and please, bind local variables before any point of use!)</span>
<span class="comment-copy">First, if you're talking about "declaring a variable", that's usually a sign that you're not thinking properly about Python. Technically, you could say that a variable is "declared" by its name being used anywhere in the current compilation unit, but that's more misleading than helpful.</span>
<span class="comment-copy">@user2864740: That happens to be at least arguable in <i>this</i> case, but in general that's not at all true, and it goes directly against the fundamental EAFP principle in Python.</span>
<span class="comment-copy">@abarnert I consider EAFP (esp. with dictionary keys) to be more of an accepted special case, much like trying to coerce strings to integers. (And invalid input <i>does</i> fall under the case "exceptional" in many cases.) Again, it should not be to cover code.</span>
<span class="comment-copy">"exceptions should be to handle exceptional cases" - Somebody should tell that to <code>StopIteration</code> and <code>GeneratorExit</code>.</span>
<span class="comment-copy">+1 for the first option. As OP stated they're not allowed to use lists, the second answer is no good.</span>
<span class="comment-copy">I assume that means they're supposed to avoid storing the entire collection of numbers in memory, not that they shouldn't use lists for any reason. But if you really wanted to avoid <code>list</code> using the second option, you could trivially swap in <code>tuple</code> or <code>set</code> instead.</span>
<span class="comment-copy">@ChrisMartin: I think that last option of using a set because they're not allowed to use a list wouldn't fly…</span>
<span class="comment-copy">Again, I very much doubt that's the point.</span>
<span class="comment-copy">@ChrisMartin: I agree, the actual wording in the question is "instead we're supposed to be evaluating each entry one by one as it comes from the user", and evaluating "two by two" as you do instead of "one by one" isn't a problem; it's still O(1) rather than O(N), which I think is what the teacher is ultimately after (even if he obviously isn't going to explain it that way to the students). Just that the second half of your comment I don't think adds anything; I can't imagine any teacher that would fail you for using <code>list</code> but pass you for using <code>set</code>…</span>
<span class="comment-copy">If his class hasn't done lists yet, I doubt they've done functions, let alone iterators.</span>
<span class="comment-copy">@whereswalden: Yeah, but the fact that he's writing a <code>try:</code>/<code>except NameError:</code> implies that he's gone pretty hard ahead of the class, so…</span>
<span class="comment-copy">@whereswalden: Also, the OP himself clearly understands lists, and the reason he can't use one here is not that he was told they're not allowed, but that "we're supposed to be evaluating each entry one by one as it comes from the user". Which a generator does. Of course he'd have to understand how that works and be able to explain it to his teacher, but he seems like a smart guy.</span>
<span class="comment-copy">@Rache: No, <code>inf</code> is built in to the language. There's no builtin symbol for it, but you can create it (among other ways) by using <code>float('inf')</code>, exactly as shown in the answer. (Well, technically, at least in 2.7, I think it's only guaranteed to exist on platforms where the C <code>double</code> type is an IEEE float type, but practically, you can count on it. If you need something actually guaranteed by the language, there's always <code>decimal.Decimal('inf')</code>.)</span>
<span class="comment-copy">@pbhj: Good insight there—and that's exactly what iterators are for. If you want something you can iterate over like a list, but have no reason to waste memory on a list (and only need to iterate once), they're the best of both worlds. But I put that at the end of my answer, because this may not be the right time to learn about generators, for someone who's already ahead of his class just by learning about lists…</span>
