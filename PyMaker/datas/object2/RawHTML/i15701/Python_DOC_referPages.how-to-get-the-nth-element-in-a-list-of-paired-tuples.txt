<div class="post-text" itemprop="text">
<pre><code>a=[((a1,a2),(b1,b2)),((c1,c2),(d1,d2))]
</code></pre>
<p>In this code, how would I access just the values of a1,b1,c1 and d1? I feel like like this may be an unintuitive way of doing what I'd like, but I would like to know if this is possible. When I try to type say something like</p>
<pre><code>a[0]
</code></pre>
<p>then it will return</p>
<pre><code>((a1,a2),(b1,b2))
</code></pre>
<p>which is not what I want.</p>
<p>I'd like to return something like</p>
<pre><code>answer_list=[(a1,b1),(c1,d1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, using list comprehension you could simply do:</p>
<pre><code>answerlist = [i[0] for j in a for i in j]
</code></pre>
<p>randlet's answer shows the logic broken out</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming this is Python:</p>
<pre><code>a1 = a[0][0][0]
b1 = a[0][1][0]
c1 = a[1][0][0]
d1 = a[1][1][0]
</code></pre>
<p>this works because:</p>
<pre><code>a[0] == ((a1, a2), (b1, b2))
</code></pre>
<p>so</p>
<pre><code>a[0][0] == (a1, a2)
a[0][1] == (b1, b2)
</code></pre>
<p>and therefore</p>
<pre><code>a[0][0][0] == a1
a[0][1][0] == b1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import chain

a=[(('a1','a2'),('b1','b2')),(('c1','c2'),('d1','d2'))]
print list(chain.from_iterable(map(lambda x:zip(*x)[0],a)))
</code></pre>
<p>assuming your list always looks like what you showed</p>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on Joran Beasley answer. Here is code sample using only list comprehensions, no <code>itertools</code> </p>
<pre class="lang-py prettyprint-override"><code>print list(x[0] for t in a for x in t)
</code></pre>
<p>which is almost eqvivalent to:
</p>
<pre><code>result = list()
for t in a:
    for x in t:
        result.append(x[0])
print result
</code></pre>
<p>More on list comprehensions in <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow">python docs</a></p>
</div>
<div class="post-text" itemprop="text">
<p>itertools has a recipe to flatten a list of nested lists one level at a time: <a href="https://docs.python.org/3/library/itertools.html?highlight=flatten" rel="nofollow">https://docs.python.org/3/library/itertools.html?highlight=flatten</a></p>
<p>you could try: </p>
<pre><code>from itertools import chain

# the recipe...
def flatten(listOfLists):
    # "Flatten one level of nesting"
    return chain.from_iterable(listOfLists)

a=[((1,2),(3,4)),((5,6),(7,8))]

print([list(flatten(t)) for t in a])
#   [[1, 2, 3, 4], [5, 6, 7, 8]]

print(list(flatten(flatten(a))))
#   [1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>And then access your data as you need</p>
</div>
<span class="comment-copy">To further my question, how would I then pair these up into a new list of tuples?  So,      answerlist= [(a1,b1),(c1,d1)]</span>
<span class="comment-copy">Given a flat list, you can pair it with <code>zip(l[::2], l[1::2])</code>, but note that it'll drop the last element if there are an odd number of elements in the list. Also, it's generally not a good idea to continue to ask new questions in the same question.</span>
<span class="comment-copy">You could say: answerlist = [tuple(answerlist[:2]),tuple(answerlist[2:])]</span>
<span class="comment-copy">list comprehensions docs can be found at <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs.python.org/2/tutorial/â€¦</a></span>
<span class="comment-copy">You should just edit @AtAFork's answer</span>
