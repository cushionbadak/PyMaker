<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>import itertools
for c in ((yield from bin(n)[2:]) for n in range(10)):
    print(c)
</code></pre>
<p>The output is:</p>
<pre><code> 0
 None
 1
 None
 1
 0 
 None
 1
 1
 None
</code></pre>
<p>... etc. Why do the <code>None</code>s appear? If I instead have:</p>
<pre><code>def hmm():
 for n in range(10):
     yield from bin(n)[2:]

for c in hmm():
    print(c)
</code></pre>
<p>Then I get what I would expect:</p>
<pre><code>0
1
1
0
1
1
</code></pre>
<p>... etc. Further, is there a way to write it as the generator expression to get the same result as the latter?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>yield</code> is an expression, and its value is whatever is sent into the generator with <code>send</code>.  If nothing is sent in, the value of <code>yield</code> is None.  In your example <code>yield from</code> yields the values from the list, but the value of the <code>yield from</code> expression itself is None, which is yielded at each iteration of the enclosing generator expression (i.e., every value of <code>range(10)</code>).</p>
<p>Your example is equivalent to:</p>
<pre><code>def hmm():
    for n in range(10):
        yield (yield from bin(n)[2:])

for item in hmm():
    print(item)
</code></pre>
<p>Note the extra <code>yield</code>.</p>
<p>You will always have this issue if you try to use <code>yield</code> in a generator expression, because the generator expression already yields its target values, so if you add an explicit <code>yield</code>, you are adding an extra expression (the <code>yield</code> expression) whose value will also be output in the generator.  In other words, something like <code>(x for x in range(5))</code> already yields the numbers in <code>range(5)</code>; if you do something like <code>((yield x) for x in range(5))</code>, you're going to get the values of the <code>yield</code> expression in addition to the numbers.</p>
<p>As far as I know, there is no way to get the simple <code>yield from</code> behavior (without extra Nones) using a generator comprehension.  For your case, I think you can achieve what you want by using <code>itertools.chain.from_iterable</code>:</p>
<pre><code>for c in itertools.chain.from_iterable(bin(n)[2:] for n in range(10)):
    print(c)
</code></pre>
<p>(Edit: I realized you can get the <code>yield from</code> behavior in a generator comprehension by using nested <code>for</code> clauses: <code>x for n in range(10) for x in bin(n)[2:]</code>.  However, I don't think this is any more readable than using <code>itertools.chain</code>.)</p>
</div>
<span class="comment-copy">It would be nice to change your example to one that doesn't use an infinite loop.  Why not change <code>itertools.count</code> to <code>range(10)</code> or something?</span>
<span class="comment-copy">From the <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="nofollow noreferrer">docs</a>: "Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator."</span>
<span class="comment-copy">in your first code you mix python2 and 3 specifique syntax, you should remove the print statement and make it a function call</span>
<span class="comment-copy">@LudovicViaud: Thanks, fixed</span>
<span class="comment-copy">@BrenBarn: Well I wouldn't necessarily need a generator then! My use case is specifically making an infinite generator</span>
