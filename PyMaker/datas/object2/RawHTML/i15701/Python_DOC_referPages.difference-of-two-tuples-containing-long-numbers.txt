<div class="post-text" itemprop="text">
<p>I have two tuples of <code>Long</code> values. I need the difference of them, something like <code>x2-x1</code>.</p>
<pre><code>x1 =
(2873120768, 2873122560, 2873123328)
x2 =
(2873121279, 2873122815, 2873123583)
</code></pre>
<p>expected result:</p>
<pre><code>result = (511,255,255)
</code></pre>
<p>but it does not matter if it is tuple or list</p>
<p>I am looking for a way not to do it element by element if possible. Speed is a constraint. I searched for it but couldn't find an answer.</p>
<p>Thank you in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>In pure Python fastest way will be to use <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map</code></a> with <a href="https://docs.python.org/2/library/operator.html#operator.sub" rel="nofollow"><code>operator.sub</code></a>:</p>
<pre><code>&gt;&gt;&gt; from operator import sub
&gt;&gt;&gt; map(sub, x2, x1)
[511L, 255L, 255L]
#If you want tuple as output
&gt;&gt;&gt; from itertools import imap
&gt;&gt;&gt; tuple(imap(sub, x2, x1))
(511L, 255L, 255L)
</code></pre>
<p>If that is not enough switch to Numpy:</p>
<pre><code>&gt;&gt;&gt; x1_arr = np.array(x1)
&gt;&gt;&gt; x2_arr = np.array(x2)
&gt;&gt;&gt; x2_arr - x1_arr
array([511, 255, 255])
</code></pre>
<p>Let's time them:</p>
<pre><code>&gt;&gt;&gt; x1 = (2873120768L, 2873122560L, 2873123328L)*10**5
&gt;&gt;&gt; x2 = (2873121279L, 2873122815L, 2873123583L)*10**5
&gt;&gt;&gt; %timeit map(sub, x2, x1)
100 loops, best of 3: 19.3 ms per loop
&gt;&gt;&gt; %timeit tuple(imap(sub, x2, x1))
10 loops, best of 3: 19.9 ms per loop
&gt;&gt;&gt; %timeit [j - i for i,j in zip(x1, x2)]
10 loops, best of 3: 38.2 ms per loop
</code></pre>
<p>Using <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow"><code>iterools.izip</code></a>(Python 2) or simply <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> in Python 3 will make the list comprehension version almost as fast as <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; %timeit [j - i for i,j in izip(x1, x2)]
10 loops, best of 3: 20.5 ms per loop
&gt;&gt;&gt; %timeit tuple(i-j for i,j in zip(x2,x1))
10 loops, best of 3: 40.5 ms per loop
&gt;&gt;&gt; %timeit tuple(i-j for i,j in izip(x2,x1))
10 loops, best of 3: 25.1 ms per loop
#Numpy arrays
&gt;&gt;&gt; %timeit x2_arr - x1_arr
1000 loops, best of 3: 469 Âµs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>zip</code> the tuples, the iterate over the pairs and perform your subtraction in a list comprehension.</p>
<pre><code>&gt;&gt;&gt; x1 = (2873120768, 2873122560, 2873123328)
&gt;&gt;&gt; x2 = (2873121279, 2873122815, 2873123583)
&gt;&gt;&gt; [j - i for i,j in zip(x1,x2)]
[511, 255, 255]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> function (Make an iterator that aggregates elements from each of the iterables.) :</p>
<pre><code>&gt;&gt;&gt; tuple(i-j for i,j in zip(x2,x1))
(511L, 255L, 255L)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is basic:</p>
<pre><code>&gt;&gt;&gt; x1 =(2873120768L, 2873122560L, 2873123328L)
&gt;&gt;&gt; x2 =(2873121279L, 2873122815L, 2873123583L) 
&gt;&gt;&gt; tuple( x2[i] - x1[i] for i in range(len(x1)))
(511L, 255L, 255L)
</code></pre>
<p>Note: assuming that len(x1) and len(x2) are always the same</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use map/lambda while zipping the values</p>
<pre><code>x1 =(2873120768L, 2873122560L, 2873123328L)
x2 =(2873121279L, 2873122815L, 2873123583L)
print map(lambda (x,y):y-x,zip(x1,x2) )
</code></pre>
</div>
<span class="comment-copy">Do you mean the sum of differences? Element-wise? What have you tried?</span>
<span class="comment-copy">your variable assignments - <code>x1 = (2873120768L, 2873122560L, 2873123328L)</code> in Python 3.4.2 creates invalid syntax error.</span>
<span class="comment-copy">@hagubear 3.x doesn't have <code>long</code> any more. It's worth being familiar with <a href="https://docs.python.org/3.0/whatsnew/3.0.html" rel="nofollow noreferrer">docs.python.org/3.0/whatsnew/3.0.html</a></span>
<span class="comment-copy">I am using Python 2.7 and these were the results. I assigned them with no 'L'!</span>
<span class="comment-copy">@Angel yes, don't worry, the trailing <code>L</code> indicates <code>long</code> integer.</span>
<span class="comment-copy">Thanks but I'd rather the built-in functions :)</span>
<span class="comment-copy">@Angel Then why are you saying speed is a constraint?</span>
<span class="comment-copy">hold on! I have a question. I have a huge size of data to process, which takes lots of RAM and CPU. I'm not sure using the built-in functions makes it faster or needs less RAM?</span>
<span class="comment-copy">wow! this IS faster!</span>
<span class="comment-copy">This will work assuming that len(x1) and len(x2) are always the same. @Hackaholic. If one of them is smaller or larger, the additional 0-padding may be required which OP hasn't probably mentioned anywhere in the question.</span>
<span class="comment-copy">@hagubear Yes, let me add it in note</span>
<span class="comment-copy">+1 for the simplest answer though :)</span>
<span class="comment-copy">You don't even need the <code>lambda</code> you can just use <code>operator.sub</code>.</span>
<span class="comment-copy">u'r right! as shown in the accepted answer</span>
