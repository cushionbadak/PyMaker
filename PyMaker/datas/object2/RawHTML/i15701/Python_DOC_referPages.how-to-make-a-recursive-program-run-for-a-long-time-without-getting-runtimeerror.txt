<div class="post-text" itemprop="text">
<p>This code is the recursive factorial function.</p>
<p>The problem is that if I want to calculate a very large number, it generates this error:
<code>RuntimeError : maximum recursion depth exceeded</code></p>
<pre><code>import time

def factorial (n) :        
    if n == 0:
        return 1
    else:            
        return n * (factorial (n -1 ) )

print " The factorial of the number is: " , factorial (1500)

time.sleep (3600)
</code></pre>
<p>The goal is to do with the recursive function is a factor which can calculate maximum one hour.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a really bad idea. Python is not at all well-suited for recursing that many times. I'd strongly recommend you switch this to a loop which checks a timer and stops when it reaches the limit.</p>
<p>But, if you're seriously interested in increasing the recursion limit in cython (the default depth is 1000), there's a <code>sys</code> setting for that, <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow">sys.setrecursionlimit</a>. Note as it says in the documentation that "the highest possible limit is platform-dependent" - meaning there's no way to know when your program will fail. Nor is there any way you, I or cython could ever tell whether your program will recurse for something as irrelevant to the actual execution of your code as "an hour." (Just for fun, I tried this with a method that passes an int counting how many times its already recursed, and I got to 9755 before IDLE totally restarted itself.)</p>
<p>Here's an example of a way I think you should do this:</p>
<pre><code># be sure to import time
start_time = time.time()
counter = 1

# will execute for an hour
while time.time() &lt; start_time + 3600:
    factorial(counter) # presumably you'd want to do something with the return value here
    counter += 1
</code></pre>
<p>You should also keep in mind that regardless of whether you use iteration or recursion, (unless you're using a separate thread) you're still going to be blocking the entire program for the entirety of the hour.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't do that.  There is an upper limit on how deep your recursion can get.  Instead, do something like this:</p>
<pre><code>def factorial(n):
    result = 1
    for i in range(1, n+1):
        result *= i
    return result
</code></pre>
<p>Any recursive function can be rewritten to an iterative function.  If your code is fancier than this, show us the actual code and we'll help you rewrite it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Few things to note here:</p>
<p>You can increase recursion stack with:</p>
<pre><code>import sys
sys.setrecursionlimit(someNumber) # may be 20000 or bigger.
</code></pre>
<p>Which will basically just increase your limit for recursion. Note that in order for it to run one hour, this number should be so unreasonably big, that it is mostly impossible. This is one of the problems with recursion and this is why people think about iterative programs.</p>
<p>So basically what you want is practically impossible and you would rather make it with a loop/while approach.</p>
<p>Moreover your sleep function does not do what you want. <a href="https://docs.python.org/2/library/time.html#time.sleep" rel="nofollow">Sleep</a> just forces you to wait additional time (frozing your program)</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a guard against a stack overflow. You can change the recursion limit with <code>sys.setrecursionlimit(newLimit)</code>where newLimit is an integer.</p>
<p>Python isn't a functional language. Rewriting the algorithm iteratively, if possible, is generally a better idea.</p>
</div>
<span class="comment-copy">Execution time has nothing to do with that error. Every time a function is called, the interpreter needs to remember the previous function state so that when the called function returns, the calling function resumes in the correct place. The error comes from the interpreter running out of memory while remembering those previous states.</span>
<span class="comment-copy">ok , But How solve this error , because I try to sys.getrecursionlimit ( ), placing limits Big But Not Working or Not Where You place if Below the Function or out of the definition of the function</span>
<span class="comment-copy">Unless you have a really really slow computer, you will run out of memory before an hour is up. Unless you use a language with tail-call elimination, a small amount of memory is needed for each level of function call.</span>
<span class="comment-copy"><code>sys.setrecursionlimit()</code> will not work in the general case.  Eventually, you'll overflow the C stack and segfault or worse.</span>
<span class="comment-copy">@Kevin Hence the part where I say "this is a really bad idea." To me, the title of the question boils down to "how do I recurse farther than cython will ordinarily allow me to." This is an answer to that, regardless of whether it's a poor implementation.</span>
<span class="comment-copy">"AFAIK no language is" - there are languages that are definitely designed to recurse that deep. The Scheme specification mandates support for infinitely deep tail recursion, and I don't think it's terribly uncommon for functional language implementations to support recursing until the heap runs out. Python itself has stackless implementations that allow it.</span>
<span class="comment-copy">@user2357112 You think that'd allow for an hour's worth of recursion with a modern processor? If that's the case, consider me both impressed and educated. Anyway, I've redacted the line.</span>
<span class="comment-copy">I dunno about an hour - I'm not sure what the memory consumption per time would look like, or how much execution would slow down once it starts swapping RAM to disk - but <code>factorial(1500)</code> would definitely run.</span>
<span class="comment-copy">Worth pointing out that the OP's code is not tail recursive.</span>
<span class="comment-copy">@PlatinumAzure My bad. Fixed.</span>
