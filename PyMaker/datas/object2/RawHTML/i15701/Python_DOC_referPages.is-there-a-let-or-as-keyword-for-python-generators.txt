<div class="post-text" itemprop="text">
<p>I'm coming to Python from Clojure, and was wondering if there is a way to have a "temporary variable" inside a generator.</p>
<p>In Clojure, I can use a <code>let</code> inside a for generator to name an intermediary computation on the item:</p>
<pre class="lang-lisp prettyprint-override"><code>(def fnames ["abc1234" "abcdef" "1024"])
(for [fname fnames
      :let [matches (re-matches #"(\w+?)(\d+)" fname)]
      :when matches]
  matches)
;=&gt; (["abc10" "abc" "1234"] ["1024" "1" "024"])
</code></pre>
<p>In Python, I need to use a generator twice to filter out the <code>None</code> results:</p>
<pre class="lang-py prettyprint-override"><code>fnames = ["abc1234", "abcdef", "1024"]
matches = [re.match('(\w+?)(\d+)', fname) for fname in fnames]
matches = [match.groups() for match in matches if match is not None]
# [('abc', '1234'), ('1', '024')]
</code></pre>
<p>So, is there a way to do something like the following? If not, what is the most Pythonic way?</p>
<pre class="lang-py prettyprint-override"><code>matches = [re.match('(\w+?)(\d+)', fname) as match 
   for fname in fnames
   if match is not None]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, there is no direct equivalent of Clojure's <code>let</code>.  The basic structure of Python's list comprehension is:</p>
<pre><code>[name for name in iterable if condition]
</code></pre>
<p>where the <code>if condition</code> part is optional.  That is all that the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">grammar</a> provides for.</p>
<hr/>
<p>In your specific case though, you could put a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">generator expression</a> inside the list comprehension:</p>
<pre><code>matches = [m.groups() for m in (re.match('(\w+?)(\d+)', f) for f in fnames) if m]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; fnames = ["abc1234", "abcdef", "1024"]
&gt;&gt;&gt; matches = [m.groups() for m in (re.match('(\w+?)(\d+)', f) for f in fnames) if m]
&gt;&gt;&gt; matches
[('abc', '1234'), ('1', '024')]
&gt;&gt;&gt;
</code></pre>
<p>Also, you will notice that I removed the <code>is not None</code> part of your condition.  While it is generally a good idea to explicitly test for <code>None</code>, it is not needed in this case since <code>re.match</code> always returns either a match object (a truthy value) or <code>None</code> (a falsey value).</p>
</div>
<span class="comment-copy">So, a more generic approach would be nesting generators? I don't know if it would be more readable than filter/map/reduce.</span>
<span class="comment-copy">@BrunoKim - Yes.  In fact, generator expressions and list comprehensions are <i>preferred</i> by most Python programmers over using filter/map/reduce solutions.  There is even talk of removing the functions you listed from a future version of the language.  That said, you should still watch the length of your comprehensions.  Not everything needs to be done on one line. :)</span>
