<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6074018/why-does-the-expression-0-0-0-return-false-in-python">Why does the expression 0 &lt; 0 == 0 return False in Python?</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to guess which operator has priority: <code>&gt;</code> (greater than) or <code>==</code> (equal). This is my experiment:</p>
<pre><code>&gt;&gt;&gt; 5 &gt; 4 == 1
False
</code></pre>
<p>As far as I know, this has two possible solutions.</p>
<pre><code>&gt;&gt;&gt; (5 &gt; 4) == 1
True
&gt;&gt;&gt; 5 &gt; (4 == 1)
True
</code></pre>
<p>Neither one returns <code>False</code>, so how is the first code resolved by Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>This has to do with operator chaining.  Unlike C/C++ and most other languages, Python allows you to chain comparison operators just like you would in normal mathematics. From the <a href="https://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>Comparisons can be chained arbitrarily, e.g., <code>x &lt; y &lt;= z</code> is
  equivalent to <code>x &lt; y and y &lt;= z</code>, except that <code>y</code> is evaluated only once
  (but in both cases <code>z</code> is not evaluated at all when <code>x &lt; y</code> is found to be
  false).</p>
</blockquote>
<p>So, this expression:</p>
<pre><code>5 &gt; 4 == 1
</code></pre>
<p>is actually interpreted as:</p>
<pre><code>5 &gt; 4 and 4 == 1  # Except that 4 is only evaluated once.
</code></pre>
<p>which becomes:</p>
<pre><code>True and False
</code></pre>
<p>which is <code>False</code>.</p>
<hr/>
<p>Using parenthesis however changes how Python interprets your comparison.  This:</p>
<pre><code>(5 &gt; 4) == 1
</code></pre>
<p>becomes:</p>
<pre><code>True == 1
</code></pre>
<p>which is <code>True</code> (see below for why).  Same goes for:</p>
<pre><code>5 &gt; (4 == 1)
</code></pre>
<p>which becomes:</p>
<pre><code>5 &gt; False
</code></pre>
<p>which is also <code>True</code>.</p>
<hr/>
<p>Because of <a href="http://www.python.org/dev/peps/pep-0285/" rel="nofollow">PEP 0285</a>, <code>bool</code> was made a subclass of <code>int</code> and <code>True == 1</code> while <code>False == 0</code>:</p>
<pre><code>&gt;&gt;&gt; issubclass(bool, int)
True
&gt;&gt;&gt; True == 1
True
&gt;&gt;&gt; False == 0
True
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">You could look this up, but +1 for questioning a (perhaps) counterintuitive result.</span>
<span class="comment-copy">Here's a link to the documentation, just for reference: <a href="https://docs.python.org/2/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">docs.python.org/2/reference/expressions.html#boolean-operations</a></span>
<span class="comment-copy">@iCodez the interpretation with chaining is 5 &gt; 4 and 4 == 1</span>
<span class="comment-copy">Interesting! Thanks a lot.</span>
<span class="comment-copy">"historical reasons" makes it seem like an unintended quirk of backwards compatibility; it's actually <a href="http://stackoverflow.com/a/6865824/1763356">working by design</a>.</span>
<span class="comment-copy">@Veedrac - I always assumed that it was made that way to keep in line with C/C++ bools (yes, I know C didn't have a bool type for awhile, but many people would do something like <code>typedef enum { false, true } bool;</code> to achieve the same result).  I'll change the wording though since it is really just a way to include the PEP link. :)</span>
