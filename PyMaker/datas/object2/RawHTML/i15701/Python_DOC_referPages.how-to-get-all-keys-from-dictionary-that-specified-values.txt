<div class="post-text" itemprop="text">
<p>If I have dict like this:</p>
<pre><code>some_dict = {'a': 1, 'b': 2, 'c': 2}
</code></pre>
<p>How to get keys that have values 2, like this:</p>
<pre><code>some_dict.search_keys(2)
</code></pre>
<p>This is example. Assume some_dict is has many thousands or more keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it like this:</p>
<pre><code>[key for key, value in some_dict.items() if value == 2]
</code></pre>
<p>This uses a list comprehension to iterate through the pairs of <code>(key, value)</code> items, selecting those keys whose value equals 2.</p>
<p>Note that this requires a linear search through the dictionary, so it is <em>O(n)</em>. If this performance is not acceptable, you will probably need to create and maintain another data structure that indexes your dictionary by value.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can also use dictionary comprehension, if you want result to be dictionary</p>
<pre><code>{ x:y for x,y in some_dict.items() if y == 2}
</code></pre>
<p>output:</p>
<pre><code>{'c': 2, 'b': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, you can use <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow">generator</a> to produce found key values, one by one, instead of returning all of them at once.</p>
<p>The function <code>search_keys</code> returns generator</p>
<pre><code>def search_keys(in_dict, query_val):
    return (key for key, val in in_dict.iteritems() if val == query_val)

# get keys, one by one
for found_key in search_keys(some_dict, 2):
    print(found_key)
</code></pre>
</div>
<span class="comment-copy">An example of this answer's last sentence: <code>reversed_dict = collections.defaultdict(list);for k, v in some_dict.items(): reversed_dict[v].append(k)</code></span>
