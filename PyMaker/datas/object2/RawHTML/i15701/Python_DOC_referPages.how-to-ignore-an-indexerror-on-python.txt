<div class="post-text" itemprop="text">
<p>I'm trying to write a script that will go through a list of urls and scrape the web page connected to that url and save the contents to a text file. Unfortunately, a few random urls lead to a page that isn't formatted in the same way and that gets me an IndexError. How do I write a script that will just skip the IndexError and move onto the next URL? I tried the code below but just get syntax errors. Thank you so much in advance for your help. </p>
<pre><code>from bs4 import BeautifulSoup, SoupStrainer
import urllib2
import io
import os
import re

urlfile = open("dailynewsurls.txt",'r') # read one line at a time until end of file
for url in urlfile:  
    try:

        page = urllib2.urlopen(url)
        pagecontent = page.read() # get a file-like object at this url

        soup = BeautifulSoup(pagecontent)

        title = soup.find_all('title')
        article = soup.find_all('article')

        title = str(title[0].get_text().encode('utf-8'))
    except IndexError:
        return None 
        article = str(article[0].get_text().encode('utf-8'))
    except IndexError:
        return None

       outfile = open(output_files_pathname + new_filename,'w')
       outfile.write(title)
       outfile.write("\n")
       outfile.write(article)
       outfile.close()

    print "%r added as a text file" % title

print "All done." 
</code></pre>
<p>The error I get is: 
      File "dailynews.py", line 39
         except IndexError:
              ^
      SyntaxError: invalid syntax</p>
</div>
<div class="post-text" itemprop="text">
<p>you would do something like:</p>
<pre><code>try:
    # the code that can cause the error
except IndexError: # catch the error
    pass # pass will basically ignore it
         # and execution will continue on to whatever comes
         # after the try/except block
</code></pre>
<p>If you're in a loop, you could use <code>continue</code> instead of <code>pass</code>.
<code>continue</code> will immediately jump to the next iteration of the loop,
regardless of whether there was more code to execute in the iteration
it jumps from. <code>sys.exit(0)</code> would end the program.</p>
</div>
<div class="post-text" itemprop="text">
<p>When I run your actual program, either the original version or the edited one, in either Python 2.5 or 2.7, the syntax error I get is:</p>
<pre><code>SyntaxError: 'return' outside function
</code></pre>
<p>And the meaning of that should be pretty obvious: You can't <code>return</code> from a function if you aren't in a function. If you want to "return" from the entire program, you can do that with <a href="https://docs.python.org/3/library/sys.html#sys.exit" rel="nofollow noreferrer"><code>exit</code></a>:</p>
<pre><code>import sys

# ...

except IndexError:
    sys.exit()
</code></pre>
<p>(Note that you can give a value to <code>exit</code>, but it has to be a small integer, not an arbitrary Python value. Most shells have some way to use that return value, normally expecting <code>0</code> to mean success, a positive number to mean an error.)</p>
<hr/>
<p>In your updated version, if you fix that (whether by moving this whole thing into a function and then calling it, or by using <code>exit</code> instead of <code>return</code>) you will get an <code>IndentationError</code>. The lines starting with <code>outfile = â€¦</code> have to be either indented to the same level as the <code>return None</code> above (in which case they're part of the <code>except</code> clause, and will never get run), or dedented back to the same level as the <code>try</code> and <code>except</code> lines (in which case they will always run, unless you've done a <code>continue</code>, <code>return</code>, <code>break</code>, <code>exit</code>, unhandled <code>raise</code>, etc.).</p>
<p>If you fix that, there are no more syntax errors in the code you showed us.</p>
<hr/>
<p>I suspect that your edited code still isn't your real code, and you may have other syntax errors in your real code. One common hard-to-diagnose error is a missing <code>)</code> (or, less often, <code>]</code> or <code>}</code>) at the end of a line, which usually causes the <em>next</em> line to report a <code>SyntaxError</code>, often at some odd location like a colon that looks (and would be, without the previous line) perfectly valid. But without seeing your real code (or, better, a real <a href="https://stackoverflow.com/help/mcve">verifiable example</a>), it's impossible to diagnose any further.</p>
<hr/>
<p>That being said, I don't think you want to <code>return</code> (or <code>exit</code>) here at all. You're trying to continue on to the next iteration of the loop. You do that with the <code>continue</code> statement. The <code>return</code> statement breaks out of the loop, and the entire function, which means none of the remaining URLs will ever get processed.</p>
<hr/>
<p>Finally, while it's not illegal, it's pointless to have extra statements after a <code>return</code>, <code>continue</code>, etc., because those statements can never get run. And similarly, while it's not illegal to have two <code>except</code> clauses with the same exception, it's pointless; the second one can only run in the case where the exception isn't an <code>IndexError</code> but is an <code>IndexError</code>, which means never.</p>
<p>I suspect you may have wanted a separate <code>try</code>/<code>except</code> around each of the two indexing statements, instead of one around the entire loop. While that isn't at all necessary here, it can sometimes make things clearer. If that's what you're going for, you want to write it like this:</p>
<pre><code>page = urllib2.urlopen(url)
pagecontent = page.read() # get a file-like object at this url

soup = BeautifulSoup(pagecontent)

title = soup.find_all('title')
article = soup.find_all('article')

try:
    title = str(title[0].get_text().encode('utf-8'))
except IndexError:
    continue

try:
    article = str(article[0].get_text().encode('utf-8'))
except IndexError:
    return continue

outfile = open(output_files_pathname + new_filename,'w')
outfile.write(title)
outfile.write("\n")
outfile.write(article)
outfile.close()

print "%r added as a text file" % title
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do the following:</p>
<pre><code> except IndexError:
     pass
</code></pre>
<p>And as suggested by another user, remove the another except IndexError.</p>
</div>
<div class="post-text" itemprop="text">
<p>You cant "return"</p>
<pre><code>   except IndexError:
        return None 
        article = str(article[0].get_text().encode('utf-8'))
</code></pre>
<p>this is not a function call  </p>
<p>use a "pass" or "break" or "continue"</p>
<p><strong>EDIT</strong>
try this  </p>
<pre><code>try:
    page = urllib2.urlopen(url)
    pagecontent = page.read() # get a file-like object at this url

    soup = BeautifulSoup(pagecontent)

    title = soup.find_all('title')
    article = soup.find_all('article')

    title = str(title[0].get_text().encode('utf-8'))
except IndexError:
    try:
        article = str(article[0].get_text().encode('utf-8'))
    except IndexError:
        continue
</code></pre>
</div>
<span class="comment-copy">Please give us a <a href="http://stackoverflow.com/help/mcve">minimal, <b>complete</b>, verifiable example</a>, not just a fragment of code. And that includes giving us the actual traceback, not just a description of the error. When we can't see your <code>SyntaxError</code>, or run your code to reproduce it ourselves, we can't tell you how to fix it.</span>
<span class="comment-copy">As a side note, <code>page.read()</code> doesn't "get a file-like object". <code>page</code> is already a file-like object; <code>read()</code> reads the entire contents of that file-like object and gets you a string.</span>
<span class="comment-copy">sorry! updated the content to be more clear</span>
<span class="comment-copy">A few more things: (a) If you just want the first <code>title</code>, just use <code>soup.find('title')</code>, don't use <code>soup.find_all(title)</code> and then use only the first one. (b) If you call <code>encode('utf-8')</code> on a <code>unicode</code> object, you get back a <code>str</code>; calling <code>str</code> on that is useless. If you're pretty sure you should already have a <code>str</code>, don't call <code>str</code> on it; either you're wastefully making an extra copy, or you're disguising a bigger problem and making it harder to debug, which you're still going to have to do.</span>
<span class="comment-copy">Sorry, but that code still can't produce that error. Please read the MCVE link in my first comment and do what it says. If you want us to actually debug your code, instead of just guessing at all the things you might have done wrong in code we can't see, you have to give us a <i>verifiable example</i>: a minimal program that we can run, and that will produce the error you want help with.</span>
<span class="comment-copy">Sure you can. It won't have any effect, but it's not a <code>SyntaxError</code>.</span>
<span class="comment-copy">sorry for the previous answer. Just misread the question.</span>
<span class="comment-copy"><code>article = str(article[0].get_text().encode('utf-8'))</code> is unreachable</span>
<span class="comment-copy">check the edit.</span>
<span class="comment-copy">I'm pretty sure he doesn't want a second try inside the <code>except</code>. As you've written it, it is impossible to ever have both <code>title</code> and <code>article</code> set, meaning you're just going to get a <code>NameError</code> later on when you try to use both of them.</span>
