<div class="post-text" itemprop="text">
<p>I'm not sure how to exactly convey what I'm trying to do, but I'm trying to create a function to split off a part of my string (the leading whitespace) so that I can edit it with different parts of my script, then add it again to my string after it has been altered.</p>
<p>So lets say I have the string:</p>
<pre><code>"    That's four spaces"
</code></pre>
<p>I want to split it so I end up with:</p>
<pre><code>"    " and "That's four spaces"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow"><code>re.match</code></a>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match('(\s*)(.*)', "    That's four spaces").groups()
('    ', "That's four spaces")
&gt;&gt;&gt;
</code></pre>
<p><code>(\s*)</code> captures zero or more whitespace characters at the start of the string and <code>(.*)</code> gets everything else.</p>
<p>Remember though that strings are immutable in Python.  Technically, you cannot <em>edit</em> their contents; you can only create new string objects.</p>
<hr/>
<p>For a non-Regex solution, you could try something like this:</p>
<pre><code>&gt;&gt;&gt; mystr = "    That's four spaces"
&gt;&gt;&gt; n = next(i for i, c in enumerate(mystr) if c != ' ') # Count spaces at start
&gt;&gt;&gt; (' ' * n, mystr[n:])
('    ', "That's four spaces")
&gt;&gt;&gt;
</code></pre>
<p>The main tools here are <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow"><code>next</code></a>, <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a>, and a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">generator expression</a>.  This solution is probably faster than the Regex one, but I personally think that the first is more elegant.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you try matching instead of splitting?</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = "    That's four spaces"
&gt;&gt;&gt; re.findall(r'^\s+|.+', s)
['    ', "That's four spaces"]
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>^\s+</code> Matches one or more spaces at the start of a line.</li>
<li><code>|</code> OR </li>
<li><code>.+</code> Matches all the remaining characters. </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to lstrip the string, then figure out how many characters you've removed. You can then 'modify' the string as desired and finish by adding the whitespace back to your string. I don't think this would work properly with tab characters, but for spaces only it seems to get the job done:</p>
<pre><code>my_string = "    That's four spaces"
no_left_whitespace = my_string.lstrip()
modified_string = no_left_whitespace + '!'
index = my_string.index(no_left_whitespace)
final_string = (' ' * index) + modified_string

print(final_string) #     That's four spaces!
</code></pre>
<p>And a simple test to ensure that we've done it right, which passes:</p>
<pre><code>assert final_string == my_string + '!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One thing you can do it make a list out of string.that is </p>
<pre><code>x="    That's four spaces"
y=list(x)
z="".join(y[0:4]) #if this is variable you can apply a loop over here to detect spaces from start
k="".join(y[4:])
s=[]
s.append(z)
s.append(k)
print s
</code></pre>
<p>This is a non regex solution which will not require any imports </p>
</div>
<span class="comment-copy"><code>re.split(r"^(\s+)", "    That's four spaces", 1)</code> <i>almost</i> does what you want, but there's an extra empty string at the beginning of the array returned.  I can't think of anything better.</span>
<span class="comment-copy">I would love to, but I have to achieve my final product without any imports other than sys.</span>
<span class="comment-copy">Once you have <code>no_left_whitespace</code>, you can go straight to <code>left_whitespace = my_string[:len(my_string)-len(no_left_whitespace)]</code>, without any of the intermediaries.</span>
