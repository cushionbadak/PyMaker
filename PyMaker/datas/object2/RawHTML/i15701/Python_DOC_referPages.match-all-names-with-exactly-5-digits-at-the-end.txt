<div class="post-text" itemprop="text">
<p>I have a text file like this:</p>
<pre><code>john123:
1
2
coconut_rum.zip

bob234513253:
0
jackdaniels.zip
nowater.zip 
3

judy88009:
dontdrink.zip
9

tommi54321:
dontdrinkalso.zip
92

...
</code></pre>
<p>I have millions of entries like this.</p>
<p>I want to pick up the name and number which has a number 5 digits long.  I tried this:</p>
<pre><code>matches = re.findall(r'\w*\d{5}:',filetext2)
</code></pre>
<p>but it's giving me results which have <em>at least</em> 5 digits.</p>
<pre><code>['bob234513253:', 'judy88009:', 'tommi54321:']
</code></pre>
<p><strong>Q1:</strong> How to find the names with <em>exactly</em> 5 digits?</p>
<p><strong>Q2:</strong> I want to append the zip files which is associated with these names with 5 digits. How do I do that using regular expressions?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's because <code>\w</code> includes digit characters:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match('\w*', '12345')
&lt;_sre.SRE_Match object at 0x021241E0&gt;
&gt;&gt;&gt; re.match('\w*', '12345').group()
'12345'
&gt;&gt;&gt;
</code></pre>
<p>You need to be more specific and tell Python that you only want letters:</p>
<pre><code>matches = re.findall(r'[A-Za-z]*\d{5}:',filetext2)
</code></pre>
<hr/>
<p>Regarding your second question, you can use something like the following:</p>
<pre><code>import re
# Dictionary to hold the results
results = {}
# Break-up the file text to get the names and their associated data.
# filetext2.split('\n\n') breaks it up into individual data blocks (one per person).
# Mapping to str.splitlines breaks each data block into single lines.
for name, *data in map(str.splitlines, filetext2.split('\n\n')):
    # See if the name matches our pattern.
    if re.match('[A-Za-z]*\d{5}:', name):
        # Add the name and the relevant data to the file.
        # [:-1] gets rid of the colon on the end of the name.
        # The list comprehension gets only the file names from the data.
        results[name[:-1]] = [x for x in data if x.endswith('.zip')]
</code></pre>
<p>Or, without all the comments:</p>
<pre><code>import re
results = {}
for name, *data in map(str.splitlines, filetext2.split('\n\n')):
    if re.match('[A-Za-z]*\d{5}:', name):
        results[name[:-1]] = [x for x in data if x.endswith('.zip')]
</code></pre>
<p>Below is a demonstration:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt; filetext2 = '''\
... john123:
... 1
... 2
... coconut_rum.zip
...
... bob234513253:
... 0
... jackdaniels.zip
... nowater.zip
... 3
...
... judy88009:
... dontdrink.zip
... 9
...
... tommi54321:
... dontdrinkalso.zip
... 92
... '''
&gt;&gt;&gt; results = {}
&gt;&gt;&gt; for name, *data in map(str.splitlines, filetext2.split('\n\n')):
...     if re.match('[A-Za-z]*\d{5}:', name):
...         results[name[:-1]] = [x for x in data if x.endswith('.zip')]
...
&gt;&gt;&gt; results
{'tommi54321': ['dontdrinkalso.zip'], 'judy88009': ['dontdrink.zip']}
&gt;&gt;&gt;
</code></pre>
<p>Keep in mind though that it is not very efficient to read in all of the file's contents at once.  Instead, you should consider making a generator function to yield the data blocks one at a time.  Also, you can increase performance by pre-compiling your Regex patterns.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

results = {}

with open('datazip') as f:
    records = f.read().split('\n\n')

for record in records:
    lines = record.split()
    header = lines[0]

    # note that you need a raw string
    if re.match(r"[^\d]\d{5}:", header[-7:]):

        # in general multiple hits are possible, so put them into a list
        results[header] = [l for l in lines[1:] if l[-3:]=="zip"]

print results
</code></pre>
<h3><em>Output</em></h3>
<pre><code>{'tommi54321:': ['dontdrinkalso.zip'], 'judy88009:': ['dontdrink.zip']}
</code></pre>
<h3>Comment</h3>
<p>I tried to keep it very simple, if your input is very long you should, as suggested by iCodez, implement a generator that <code>yield</code>s one record at a time, while for the regexp match I tried a little optimization searching only the last 7 characters of the header.</p>
<h3>Addendum: <em>a simplistic implementation of a record generator</em></h3>
<pre><code>import re

def records(f):
    record = []
    for l in f:
        l = l.strip()
        if l:
            record.append(l)
        else:
            yield record
            record = []
    yield record

results = {}
for record in records(open('datazip')):
    head = record[0]
    if re.match(r"[^\d]\d{5}:", head[-7:]):
        results[head] = [ r for r in record[1:] if r[-3:]=="zip"]
print results
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to limit the regex to the end of the word so that it wont match any further using <code>\b</code></p>
<pre><code>[a-zA-Z]+\d{5}\b
</code></pre>
<p>see for example <a href="http://regex101.com/r/oC1yO6/1" rel="nofollow">http://regex101.com/r/oC1yO6/1</a></p>
<p>The regex would match</p>
<pre><code>judy88009:

tommi54321:
</code></pre>
<p>python code would be like</p>
<pre><code>&gt;&gt;&gt; re.findall(r'[a-zA-Z]+\d{5}\b', x)
['judy88009', 'tommi54321']
</code></pre>
</div>
<span class="comment-copy">You should probably wrap parentheses from the start of the string to before the colon so that the colon is not included in the username string.</span>
<span class="comment-copy">Thank you. How do I make a list with this regex and the zip files which are under this username?</span>
<span class="comment-copy">@new_coder - Sorry about the delay; something important popped up.  My edited post answers your second question.</span>
<span class="comment-copy">Hi. One more thing. What if I don't want to hardcode the number 5?  something like this -----------------------------&gt;       if re.match('[A-Za-z]*\d{num}:', name): #where num = 5  is it possible to do that?</span>
<span class="comment-copy">@new_coder - You can use <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer">string formatting</a> to insert whatever number you want: <code>'[A-Za-z]*\d{{{num}}}:'.format(num=5)</code> yields <code>'[A-Za-z]*\d{5}:'</code>.  Note that you need the extra curly braces since <code>{...}</code> denotes a format field.</span>
