<div class="post-text" itemprop="text">
<p>I am trying to convert a number stored as a list of ints to a float type. I got the number via a serial console and want to reassemble it back together into a float.
The way I would do it in C is something like this:</p>
<pre><code>bit_data = ((int16_t)byte_array[0] &lt;&lt; 8) | byte_array[1];
result = (float)bit_data;
</code></pre>
<p>What I tried to use in python is a much more simple conversion:</p>
<pre><code>result = int_list[0]*256.0 + int_list[1]
</code></pre>
<p>However, this does not preserve the sign of the result, as the C code does.
What is the right way to do this in python?</p>
<p><strong>UPDATE:</strong>
Python version is 2.7.3.
My byte array has a length of 2.
in the python code byte_array is list of ints. I've renamed it to avoid misunderstanding. I can not just use the float() function because it will not preserve the sign of the number.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm a bit confused by what data you have, and how it is represented in Python. As I understand it, you have received two unsigned bytes over a serial connection, which are now represented by a list of two python ints. This data represents a big endian 16-bit signed integer, which you want to extract and turn into a float. eg. <code>[0xFF, 0xFE]</code> -&gt; <code>-2</code> -&gt; <code>-2.0</code></p>
<pre><code>import array, struct

two_unsigned_bytes = [255, 254] # represented by ints
byte_array = array.array("B", two_unsigned_bytes) 
# change above to "b" if the ints represent signed bytes ie. in range -128 to 127
signed_16_bit_int, = struct.unpack("&gt;h", byte_array)
float_result = float(signed_16_bit_int)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think what you want is the <a href="https://docs.python.org/3/library/struct.html?highlight=struct" rel="nofollow">struct module</a>.</p>
<p>Here's a round trip snippet:</p>
<pre><code>import struct
sampleValue = 42.13
somebytes = struct.pack('=f', sampleValue)
print(somebytes)
result = struct.unpack('=f', somebytes)
print(result)
</code></pre>
<p><code>result</code> may be surprising to you. <code>unpack</code> returns a tuple. So to get to the value you can do</p>
<pre><code>result[0]
</code></pre>
<p>or modify the result setting line to be</p>
<pre><code>result = struct.unpack('=f', some bytes)[0] 
</code></pre>
<p>I personally hate that, so use the following instead</p>
<pre><code>result , = struct.unpack('=f', some bytes) # tuple unpacking on assignment
</code></pre>
<p>The second thing you'll notice is that the value has extra digits of noise. That's because python's native floating point representation is <code>double</code>.</p>
<p><em>(This is python3 btw, adjust for using old versions of python as appropriate)</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure I really understand what you are doing, but I think you got 4 bytes from a stream and know them to represent a float32 value. The way you handling this suggests big-endian byte-order. </p>
<p>Python has the <code>struct</code> package (<a href="https://docs.python.org/2/library/struct.html" rel="nofollow">https://docs.python.org/2/library/struct.html</a>) to handle bytestreams.</p>
<pre><code>import struct

stream = struct.pack("&gt;f", 2/3.)
len(stream) # 4

reconstructed_float = struct.unpack("&gt;f", stream)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Okay, so I think int_list isn't really just a list of ints. The ints are constrained to 0-255 and represent bytes that can be built into a signed integer. You then want to turn that into a float. The trick is to set the sign of the first byte properly and then procede much like you did.</p>
<pre><code>float((-(byte_array[0]-127) if byte_array[0]&gt;127 else byte_array[0])*256 + byte_array[1])
</code></pre>
</div>
<span class="comment-copy">How big is your byte_array? Is it is 4 elements? Your code doesn't make that clear...</span>
<span class="comment-copy">Also, you didn't mention which python version...</span>
<span class="comment-copy">What is the a byte_array? Is a list of ints, a bytes object?</span>
<span class="comment-copy">Is it too slow to unpack your byte array into a native Python int? Because once you've got it as a native int, float(int) is usually good enough.</span>
<span class="comment-copy">As far as i know, python supports the "&lt;&lt;" operator while maintaining the sign, can you try it?</span>
<span class="comment-copy">I hadn't considered converting to a byte array... very cool. I think its big endian... so "&gt;h". An example other than <code>[255, 255]</code> makes it more clear.</span>
<span class="comment-copy">Thanks! This one suits me the most!</span>
<span class="comment-copy">@tdelaney Good call, about the endianness. I was hung up about the sign of the data, and was trying to think of a byte pattern whose value was different, but obvious for both signed and unsigned ints.</span>
<span class="comment-copy">Thank you for the fast answer! I'm new to Python so I'll need a little time to try it out and understand.</span>
<span class="comment-copy">welcome aboard. It's a fun/capable language.</span>
<span class="comment-copy">You can accept this answer if you want. It is worth pointing out that the struct module does not know half-precision floating point types.</span>
<span class="comment-copy">Thank you for the fast answer! I'm new to Python so I'll need a little time to try it out and understand.</span>
