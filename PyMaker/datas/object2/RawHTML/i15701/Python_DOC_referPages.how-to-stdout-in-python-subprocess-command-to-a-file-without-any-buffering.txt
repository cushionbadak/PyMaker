<div class="post-text" itemprop="text">
<p>I am trying to use the subprocess command to send its stdout output to a log file.
I want the user to be able to use <code>tail -f logfile</code> to look at the logs simultaneously.</p>
<p>However, I observed that the subprocess module is buffering output logs for a long time, before it writes to the file.
Is there any way to avoid this buffering behavior? </p>
<pre><code>file_stdout=open("/var/log/feeder.log","w")
file_stderr=open("/var/log/feeder.err","w")
proc = subprocess.Popen("python /etc/feeder/feeder.py -i " + input_file + " -o " + output_file + " -r " + str(rate) + " -l " +str(lines), stdout=file_stdout, stderr=file_stderr, shell=True)
</code></pre>
<p>When I run <code>tail -f /var/log/feeder.log</code> I would like to see the streaming output.
Any way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Here file_stdout is /var/log/feeder.log</p>
</blockquote>
<p>No it's not. You can't pass a string as <code>stdout</code>. As <a href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments" rel="nofollow">the docs</a> make clear. It takes a file object or a file descriptor (a number).</p>
<p>So, the problem is almost certainly with the way you <em>opened</em> the file, which you haven't shown us. I'm guessing you did it with the <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow"><code>open</code></a> function, and you left the <code>buffering</code> argument as the default. As the docs say:</p>
<blockquote>
<p>When no <em>buffering</em> argument is given, the default buffering policy works as follows:</p>
<ul>
<li><p>Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on <code>io.DEFAULT_BUFFER_SIZE</code>. On many systems, the buffer will typically be 4096 or 8192 bytes long.</p></li>
<li><p>“Interactive” text files (files for which <code>isatty()</code> returns <code>True</code>) use line buffering. Other text files use the policy described above for binary files.</p></li>
</ul>
</blockquote>
<p>(This is the Python 3.x version of <code>open</code>; things are different in 2.x, but the basic problem is equivalent, and so is the solution.)</p>
<p>So, it's going to write in chunks of, e.g., 8192 bytes.</p>
<p>If you want unbuffered output, you can use <code>buffering=0</code> (and of course make sure to open the file in binary mode). Or just use <code>os.open</code> and pass the fd, and let <code>subprocess</code> create its own file object.</p>
<hr/>
<p>While we're at it, you probably shouldn't be using <code>shell=True</code> (the shell could theoretically introduce buffering of its own—and, more importantly, it's not doing you any good, and it will cause all kinds of problems if, say, any of those strings have spaces in them). Also, you may want to use <code>sys.executable</code> instead of <code>'python'</code> for the program name; that ensures that the same version of Python being used to run the parent script also gets used to run the child script, rather than whatever version of Python happens to be first one the <code>PATH</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <code>subprocess.Popen</code> wrong.</p>
<pre><code>proc = subprocess.Popen(["python", "/etc/feeder/feeder.py",
    "-i", input_file,
    "-o", output_file,
    "-r", str(rate),
    "-l", str(lines)],
    stdout=file_stdout, stderr=file_stderr)
</code></pre>
<p>Subprocess is not buffering anything. The called python process does the buffering. You have to use <code>sys.stdout.flush()</code> in <code>/etc/feeder/feeder.py</code> to write the data to the file.</p>
</div>
<div class="post-text" itemprop="text">
<p>here: you need give file discriptor not the file and the file must be opened in append mode</p>
<pre><code>file_stdout = open('output_log','a+')
file_stderr = open('error_log','a+')
proc = subprocess.Popen("python /etc/feeder/feeder.py -i " + input_file + " -o " + output_file + " -r " + str(rate) + " -l " +str(lines), stdout=file_stdout, stderr=file_stderr)
</code></pre>
<p>here is demo:
<img alt="Here is demo" src="https://i.stack.imgur.com/kVsuI.png"/></p>
</div>
<span class="comment-copy">you need to write it to that file</span>
<span class="comment-copy">what is <code>file_stdout</code>?</span>
<span class="comment-copy">file_stdout is a variable opened using file_stdout  =open("/var/log/feeder.log", "w") file_stderr = open("/var/log/feeder.err", "w")</span>
<span class="comment-copy">Using a shell command line instead of a list of arguments has a lot of downsides, but it probably isn't relevant to the OP's problem, and saying he's "using it wrong" is a little misleading given that <code>shell=True</code> does work and is documented and is occasionally even a good idea.</span>
<span class="comment-copy">the file_stdout is already an opened file descriptor, I guess it was not clear in the question</span>
