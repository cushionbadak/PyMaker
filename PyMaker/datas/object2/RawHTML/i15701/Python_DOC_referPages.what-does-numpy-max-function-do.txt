<div class="post-text" itemprop="text">
<p>I went onto a piece of code which goes like this:</p>
<pre><code>while numpy.max(abs(A - B)) &gt; 0.01:
</code></pre>
<p>I am trying to replace the <code>numpy.max</code> with some regular Python (math?) function, but I can not find what exactly does <code>numpy.max</code> does.</p>
<p>I tried googling but I only found:
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.maximum.html" rel="nofollow"><code>numpy.maximum</code></a> which is not the same as <code>numpy.max</code> I suppose.</p>
<p>And:
<a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html" rel="nofollow"><code>numpy.amax</code></a> which is again not what I need.</p>
<p>Does anyone know how I could replicate this numpy.max funtion into some standard python one?</p>
<p>EDIT: I am using Python 2.7</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't replicate the behavior of <code>np.max</code> very easily in pure Python, simply because multi-dimensional arrays aren't standard in Python. If the <code>A</code> and <code>B</code> in your code are such arrays, it would be best to keep the NumPy function.</p>
<p>For flat (one-dimensional) arrays, the Python <code>max</code> and <code>np.max</code> do the same thing and could be exchanged:</p>
<pre><code>&gt;&gt;&gt; a = np.arange(27)
&gt;&gt;&gt; max(a)
26
&gt;&gt;&gt; np.max(a)
26
</code></pre>
<p>For arrays with more than one dimension, <code>max</code> won't work: </p>
<pre><code>&gt;&gt;&gt; a = a.reshape(3, 3, 3)
&gt;&gt;&gt; max(a)
ValueError: The truth value of an array with more than one element is ambiguous [...]
&gt;&gt;&gt; np.max(a)
26
</code></pre>
<p>By default, <code>np.max</code> flattens the 3D array and returns the maximum. (You can also find the maximum along particular axes, and so on.) The Python <code>max</code> cannot do this.</p>
<p>To replace <code>np.max</code>, you'd need to write nested loops over the axes of the array; effectively trying to find the maximum in a list of  nested lists. This is certainly possible, but is likely to be very slow:</p>
<pre><code>&gt;&gt;&gt; max([max(y) for y in x for x in a])
26
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy.max</code> is the same thing as <code>numpy.amax</code>:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; numpy.max # Notice it says 'amax' in the output
&lt;function amax at 0x0228B5D0&gt;
&gt;&gt;&gt; numpy.max is numpy.amax
True
&gt;&gt;&gt;
</code></pre>
<p>Or, more specifically, <code>max</code> is an alias for the <code>amax</code> function.</p>
<p>The purpose of this function is listed in the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html" rel="nofollow">docs link</a> you gave, but it seems that it is mainly used to find the maximum value inside a <code>numpy.array</code> regardless of how many nested levels it has.  You can mimic this behavior with a simple function to flatten a list:</p>
<pre><code>def flatten(lst):
    for item in lst:
        if isinstance(item, list):
            # Use 'yield from flatten(item)' in Python 3.3 or greater
            for sub_item in flatten(item):
                yield sub_item
        else:
            yield item
</code></pre>
<p>and the <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow">built-in <code>max</code> function</a>:</p>
<pre><code>max(flatten(my_list))
</code></pre>
<p>See a demonstration below:</p>
<pre><code>&gt;&gt;&gt; def flatten(lst):
...     for item in lst:
...         if isinstance(item, list):
...             for sub_item in flatten(item):
...                 yield sub_item
...         else:
...             yield item
...
&gt;&gt;&gt; array = [[1, 2, 3], [4, 5, 6]]
&gt;&gt;&gt; max(flatten(array))
6
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">According to <a href="http://comments.gmane.org/gmane.comp.python.scientific.devel/6625" rel="nofollow noreferrer">this old message</a>, "numpy.max exists for historical reasons".</span>
<span class="comment-copy">Note that <code>yield from</code> here relies on Python 3.3 or greater.</span>
<span class="comment-copy">True.  The OP didn't say what version he is on, so I prefer to use the newest.  If anyone is running an older version though, simply replace <code>yield from</code> with a normal for-loop: <code>for i in flatten(item): yield i</code>.</span>
<span class="comment-copy">It's a fine choice, but most projects built around NumPy are still on 2.7 and will be for a long time. NumPy itself works fine now in Python 3, but so many associated libraries and tools do not that it creates a severe problem for many numpy-centric projects.</span>
<span class="comment-copy">Thank you for the reply. But now I am even more confused, because the initial <code>A</code> and <code>B</code> are in fact floats not arrays: <a href="https://github.com/Sandia-Labs/PVLIB_Python/blob/master/pvlib/pvl_ephemeris.py#L128" rel="nofollow noreferrer">github.com/Sandia-Labs/PVLIB_Python/blob/master/pvlib/â€¦</a></span>
<span class="comment-copy">@iCodez - The function appears to be written to work on arrays or scalars.  In that code example, <code>EccenAnom</code> can be an array, not just a scalar.  (Note that the inputs to the function are all documented as array-like objects. Anything involving a time or date will be an array, e.g. <code>T1</code>.)  On a side note, the reason that <code>np.min(2.0)</code> will return a scalar (actually a numpy float, not the python float that was passed in) is that numpy functions are generalized to work with arrays of any shape or size, including 0-length arrays.  It's a pattern across numpy. No reason to break it for <code>min</code>.</span>
