<div class="post-text" itemprop="text">
<p>I'm learning Python's nested loops but couldn't use nested loops to fill a list with the combinations. So far I have</p>
<pre><code>for i in range(3):
   for j in range(3):
       paths = [i,j]
       print paths
</code></pre>
<p>When this prints I get:</p>
<pre><code>[0, 0]
[0, 1]
[0, 2]
[1, 0]
[1, 1]
[1, 2]
[2, 0]
[2, 1]
[2, 2]
</code></pre>
<p>Which is a list of the possible combinations but if I try an extra for-loop to index them it doesn't seem to work and only gives the first element. I'm trying to get an array in the form:</p>
<pre><code>Array = [[0,0], [0,1]... [2,2]]
</code></pre>
<p>where I can index said array and get <code>Array[0] == [0,0]</code> and so on.</p>
<p>Any hints on how to do this? I've tried for-loops and using the append function neither giving me the results I wanted.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can append the lists to the result:</p>
<pre><code>result = []
for i in range(3):
   for j in range(3):
       paths = [i,j]
       result.append(paths)
       print paths

print result
</code></pre>
<p>This says: create a result list <code>[]</code> and append the <code>paths</code> value to it at each step. You'll then have a list of lists and you can access the first element as <code>result[0]</code> (which is indeed <code>[0, 0]</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>I like <a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow">list comprehension</a>!</p>
<pre><code>print [[x, y] for x in range(3) for y in range(3)]
</code></pre>
<p>But it creates three lists (the iterated two stay in memory) in python 2.7 which is the common one nowdays.</p>
<p>If you're using big values try this:</p>
<pre><code>print [[x, y] for x in xrange(3) for y in xrange(3)]
</code></pre>
<p>which uses <a href="https://wiki.python.org/moin/Generators" rel="nofollow">Generators</a> :)</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to do this is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; combos = [list(x) for x in product(range(3), repeat=2)]
&gt;&gt;&gt; combos
[[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
&gt;&gt;&gt; combos[0]
[0, 0]
&gt;&gt;&gt; combos[1]
[0, 1]
&gt;&gt;&gt; combos[8]
[2, 2]
&gt;&gt;&gt;
</code></pre>
<p>Note that this solution is also very flexible.  For example, if you want to find the combinations of the numbers one through five taken three at a time, all you need to do is change the numbers given to <code>range</code> and <code>repeat</code>:</p>
<pre><code>combos = [list(x) for x in product(range(6), repeat=3)]
#                                        ^          ^
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve it using <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow"><code>itertools</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.product(range(3), range(3)))
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
</code></pre>
<p>If you really need lists instead of tuples:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list(itertools.product(range(3), range(3)))
&gt;&gt;&gt; [list(t) for t in itertools.product(range(3), range(3))]
[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
</code></pre>
</div>
