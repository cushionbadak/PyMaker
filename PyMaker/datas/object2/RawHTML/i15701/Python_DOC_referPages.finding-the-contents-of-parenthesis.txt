<div class="post-text" itemprop="text">
<p>I have a few thousand blocks of text  which may or may not contain a date of death for the person in the record, which is always in the form:</p>
<pre><code>(d. xxxxxxxxxxxxx)
</code></pre>
<p>that is that it starts with parenthesis, followed by a <code>d</code> and <code>.</code>, then some date text and closes with the final parenthesis.</p>
<p>I wrote the following code with a few test samples to test a Regex which I wrote:</p>
<pre><code>import re
tests = ["Milt Jackson, vibraphone, piano, guitar, 1923 (d. October 9, 1999)", "Howard Johnson, alto sax, 1908 (d. December 28, 1991)","Sonny Greenwich, guitar, 1936", "Eiichi Hayashi, alto sax, 1960", "Yoshio Ikeda, bass, 1942", "Urs Leimgruber, saxophones, bass clarinet. 1952"]

for test in tests:
    m = re.match ("\(d.(.*)\)", test)
    if m:
        print(m.groups())
</code></pre>
<p>However it prints no results. </p>
<p>I've tested the Regex in an online Regex tester and it works for valid test input.</p>
<p>So, I guess my code is wrong. Can anyone suggest why, please?</p>
<p>Finally - what I want to extract is date of death itself (not the parenthesis and <code>d.</code>)- any suggestions how I could do that?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>re.match</code> always matches from the start of the string.  From the <a href="https://docs.python.org/3/library/re.html#re.match" rel="nofollow">docs</a>:</p>
<blockquote>
<p><code>re.match(pattern, string, flags=0)</code></p>
<p>If zero or more characters <strong>at the beginning of <code>string</code></strong> match the regular expression <code>pattern</code>, return a corresponding match object.</p>
</blockquote>
<p>Emphasis mine.  </p>
<p>You need to use <code>re.search</code> to have Python <em>search</em> for a pattern anywhere in the string:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; tests = ["Milt Jackson, vibraphone, piano, guitar, 1923 (d. October 9, 1999)", "Howard Johnson, alto sax, 1908 (d. December 28, 1991)","Sonny Greenwich, guitar, 1936", "Eiichi Hayashi, alto sax, 1960", "Yoshio Ikeda, bass, 1942", "Urs Leimgruber, saxophones, bass clarinet. 1952"]
&gt;&gt;&gt;
&gt;&gt;&gt; for test in tests:
...     m = re.search ("\(d\.(.*)\)", test)
...     if m:
...         print(m.groups())
...
(' October 9, 1999',)
(' December 28, 1991',)
&gt;&gt;&gt;
</code></pre>
<p>Also, in your pattern, I escaped the <code>.</code> after <code>d</code> to have Python match a literal period.  Otherwise, Python will match any character there (except a newline).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>search</code> instead of <code>match</code></p>
<pre><code>for test in tests:
...     m = re.search ("\(d.(.*)\)", test)
...     if m:
...         print(m.groups())
... 
(' October 9, 1999',)
(' December 28, 1991',)
</code></pre>
<p><strong>Why <code>match</code> wont work?</strong></p>
<p>Tha <code>match</code> searches the pattern at the start of the string. In the test string, the matched part is not at the start of the string and hence <code>match</code> fails.  Where as <code>search</code> searches for the pattern anywhere in the string.</p>
<ul>
<li><p><code>re.search(pattern, string, flags=0)</code></p>
<p>Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding MatchObject instance. Return None if no position in the string matches the pattern;</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Considering it is <em>always in the form (d. xxxxxxxxxxxxx)</em>  and your regex and the answers supplied catch anything in the format <code>(r. then anything)</code> unless you will have cases where you have an <code>(r. followed a space</code> and no closing paren then you can do this without a regex:  </p>
<pre><code>tests = ["Milt Jackson, vibraphone, piano, guitar, 1923 (d. October 9, 1999)", "Howard Johnson, alto sax, 1908 (d. December 28, 1991)","Sonny Greenwich, guitar, 1936", "Eiichi Hayashi, alto sax, 1960", "Yoshio Ikeda, bass, 1942", "Urs Leimgruber, saxophones, bass clarinet. 1952"]
for line in tests:
    if "(d." in line:
        spl = line.split("(d. ")[1]
        print(spl[:spl.find(")")])

 October 9, 1999
 December 28, 1991
</code></pre>
</div>
<span class="comment-copy">thanks for spotting that I was wrongly using match rather than search. As a relative noob to regex I missed that - but can only learn! Thx Ian</span>
<span class="comment-copy">Thanks @nu11p01n73R I appreciate the guidance. Ian</span>
<span class="comment-copy">@Watty62 you are welcome :)</span>
<span class="comment-copy">Even if the death, if present, is always of the form <code>(d. xxxxxx)</code>, it doesn't mean that if <code>(d.</code> is present there's a death.  What if there's no following space, or closing parenthesis?  What if it's <code>(d.o.b ...)</code>?  It <i>is</i> a good idea to use simpler alternatives when they work (e.g., checking for a specific string), but it's not clear that this is one of those cases (at least from the description in the question).</span>
<span class="comment-copy">@JoshuaTaylor from the OP's examples there is nothing to suggest it won't work and <code>line.split("(d. ")</code> takes care of <code>(d.o.b ...)</code>, it is up to the OP to decide if there are cases that it won't work for but if it does it will be a lot more efficient than using re</span>
<span class="comment-copy">@JoshuaTaylor the regex supplied will also catch <code>(d.o.b foo, bar ',)</code> from <code>('o.b foo, bar) </code> so I don't see how that is any better</span>
<span class="comment-copy">@PadraicCunningham , thanks for the alternative solution - I need to think if that is better or not compared to the one above. And Joshua Taylor, thanks for raising the possibility of it catching other '(d. ) constructs. In this case I am certain that there are no (d.o.b) entries. There were initially some (d .) with a space between the d and the point but I was able to use a text editor with find and replace to correct them all to the same format. Thanks Ian</span>
