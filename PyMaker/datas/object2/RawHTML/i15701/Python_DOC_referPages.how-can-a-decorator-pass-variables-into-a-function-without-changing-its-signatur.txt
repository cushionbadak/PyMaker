<div class="post-text" itemprop="text">
<p>Let me first acknowledge that what I want to do may be considered anything from silly to evil, but I want to find out if I can do it in Python anyway.</p>
<p>Let's say I have a function decorator that takes keyword arguments defining variables, and I want to access those variables in the wrapped function. I might do something like this:</p>
<pre class="lang-py prettyprint-override"><code>def more_vars(**extras):
    def wrapper(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            return f(extras, *args, **kwargs)
        return wrapped
    return wrapper
</code></pre>
<p>Now I can do something like:</p>
<pre class="lang-py prettyprint-override"><code>@more_vars(a='hello', b='world')
def test(deco_vars, x, y):
    print(deco_vars['a'], deco_vars['b'])
    print(x, y)

test(1, 2)
# Output:
# hello world
# 1 2
</code></pre>
<p>The thing I don't like about this is that when you use this decorator, you have to change the call signature of the function, adding the extra variable in addition to slapping on the decorator. Also, if you look at the help for the function, you see an extra variable that you're not expected to use when calling the function:</p>
<pre class="lang-py prettyprint-override"><code>help(test)
# Output:
# Help on function test in module __main__:
#
# test(deco_vars, x, y)
</code></pre>
<p>This makes it look like the user is expected to call the function with 3 parameters, but obviously that won't work. So you'd have to also add a message to the docstring indicating that the first parameter isn't part of the interface, it's just an implementation detail and should be ignored. That's kind of crappy, though. Is there any way to do this without hanging these variables on something in the global scope? Ideally, I'd like it to look like the following:</p>
<pre class="lang-py prettyprint-override"><code>@more_vars(a='hello', b='world')
def test(x, y):
    print(a, b)
    print(x, y)

test(1, 2)
# Output:
# hello world
# 1 2
help(test)
# Output:
# Help on function test in module __main__:
#
# test(x, y)
</code></pre>
<p>I am content with a Python 3 only solution if one exists.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do this with some trickery that inserts the variables passed to the decorator into the function's local variables:</p>
<pre><code>import sys
from functools import wraps
from types import FunctionType


def is_python3():
    return sys.version_info &gt;= (3, 0)


def more_vars(**extras):
    def wrapper(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            fn_globals = {}
            fn_globals.update(globals())
            fn_globals.update(extras)
            if is_python3():
                func_code = '__code__'
            else:
                func_code = 'func_code'
            call_fn = FunctionType(getattr(f, func_code), fn_globals)
            return call_fn(*args, **kwargs)
        return wrapped
    return wrapper


@more_vars(a="hello", b="world")
def test(x, y):
    print("locals: {}".format(locals()))
    print("x: {}".format(x))
    print("y: {}".format(y))
    print("a: {}".format(a))
    print("b: {}".format(b))


if __name__ == "__main__":
    test(1, 2)
</code></pre>
<p><em>Can</em> you do this? Sure! <em>Should</em> you do this? Probably not!</p>
<p>(Code available <a href="https://gist.github.com/mdippery/0f634224afcd09af5986" rel="nofollow">here</a>.)</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT: answer edited for readability. Latest answer is on top, original follows.</strong></p>
<p>If I understand well</p>
<ul>
<li>you want the new arguments to be defined as keywords in the <code>@more_vars</code> decorator</li>
<li>you want to use them in the decorated function</li>
<li>and you want them to be hidden to the normal users (the exposed signature should still be the normal signature)</li>
</ul>
<p>Have a look at the <a href="https://smarie.github.io/python-makefun/#removing-parameters-easily" rel="nofollow noreferrer"><code>@with_partial</code></a> decorator in my library <a href="https://smarie.github.io/python-makefun/" rel="nofollow noreferrer"><code>makefun</code></a>. It provides this functionality out of the box:</p>
<pre><code>from makefun import with_partial

@with_partial(a='hello', b='world')
def test(a, b, x, y):
    """Here is a doc"""
    print(a, b)
    print(x, y)
</code></pre>
<p>It yields the expected output and the docstring is modified accordingly:</p>
<pre><code>test(1, 2)
help(test)
</code></pre>
<p>yields</p>
<pre><code>hello world
1 2
Help on function test in module &lt;...&gt;:

test(x, y)
    &lt;This function is equivalent to 'test(x, y, a=hello, b=world)', see original 'test' doc below.&gt;
    Here is a doc
</code></pre>
<p>To answer the question in your comment, the function creation strategy in <code>makefun</code> is exactly the same than the one in the famous <code>decorator</code> library: <code>compile</code> + <code>exec</code>. No magic here, but <code>decorator</code> has been using this trick for years in real-world applications so it is quite solid. See <code>def _make</code> in the <a href="https://github.com/smarie/python-makefun/blob/master/makefun/main.py" rel="nofollow noreferrer">source code</a>.</p>
<p>Note that the <code>makefun</code> library also provides a <code>partial(f, *args, **kwargs)</code> function if you want to create the decorator yourself for some reason (see below for inspiration).</p>
<hr/>
<p>If you wish to do this manually, this is a solution that should work as you expect, it relies on the <code>wraps</code> function provided by <a href="https://smarie.github.io/python-makefun/" rel="nofollow noreferrer"><code>makefun</code></a>, to modify the exposed signature.</p>
<pre><code>from makefun import wraps, remove_signature_parameters

def more_vars(**extras):
    def wrapper(f):
        # (1) capture the signature of the function to wrap and remove the invisible
        func_sig = signature(f)
        new_sig = remove_signature_parameters(func_sig, 'invisible_args')

        # (2) create a wrapper with the new signature
        @wraps(f, new_sig=new_sig)
        def wrapped(*args, **kwargs):
            # inject the invisible args again
            kwargs['invisible_args'] = extras
            return f(*args, **kwargs)

        return wrapped
    return wrapper
</code></pre>
<p>You can test that it works:</p>
<pre><code>@more_vars(a='hello', b='world')
def test(x, y, invisible_args):
    a = invisible_args['a']
    b = invisible_args['b']
    print(a, b)
    print(x, y)

test(1, 2)
help(test)
</code></pre>
<p>You can even make the decorator definition more compact if you use <a href="https://smarie.github.io/python-decopatch/" rel="nofollow noreferrer"><code>decopatch</code></a> to remove the useless level of nesting:</p>
<pre><code>from decopatch import DECORATED
from makefun import wraps, remove_signature_parameters

@function_decorator
def more_vars(f=DECORATED, **extras):
    # (1) capture the signature of the function to wrap and remove the invisible
    func_sig = signature(f)
    new_sig = remove_signature_parameters(func_sig, 'invisible_args')

    # (2) create a wrapper with the new signature
    @wraps(f, new_sig=new_sig)
    def wrapped(*args, **kwargs):
        kwargs['invisible_args'] = extras
        return f(*args, **kwargs)

    return wrapped
</code></pre>
<p>Finally, if you rather do not want to depend on any external library, the most pythonic way to do it is to create a function factory (but then you cannot have this as a decorator):</p>
<pre><code>def make_test(a, b, name=None):
    def test(x, y):
        print(a, b)
        print(x, y)
    if name is not None:
        test.__name__ = name
    return test

test = make_test(a='hello', b='world')
test2 = make_test(a='hello', b='there', name='test2')
</code></pre>
<p>I'm the author of <code>makefun</code> and <code>decopatch</code> by the way ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like your only problem is that <code>help</code> is showing the signature of the raw <code>test</code> as the signature of the wrapped function, and you don't want it to.</p>
<p>The only reason that's happening is that <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow"><code>wraps</code></a> (or, rather, <code>update_wrapper</code>, which <code>wraps</code> calls) explicitly copies this from the wrappee to the wrapper.</p>
<p>You can decide exactly what you do and don't want to copy. If what you want to do differently is simple enough, it's just a matter of filtering stuff out of the default <code>WRAPPER_ASSIGNMENTS</code> and <code>WRAPPER_UPDATES</code>. If you want to change other stuff, you may need to fork <code>update_wrapper</code> and use your own versionâ€”but <code>functools</code> is one of those modules that has a link to <a href="https://hg.python.org/cpython/file/default/Lib/functools.py#l40" rel="nofollow">the source</a> right at the top of the docs, because it's meant to be used as readable sample code.</p>
<p>In your case, it may just be a matter of <code>wraps(f, updated=[])</code>, or you may want to do something fancy, like use <code>inspect.signature</code> to get the signature of <code>f</code>, and modify it to remove the first parameter, and build a wrapper explicitly around that to fool even the <code>inspect</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've found a solution to this problem, although the solution is by most standards almost certainly worse than the problem itself. With some clever rewriting of the decorated function's bytecode, you can redirect all references to variables of a given name to a new closure you can dynamically create for the function. This solution only works for the standard CPython, and I have only tested it with 3.7.</p>
<pre><code>import inspect

from dis import opmap, Bytecode
from types import FunctionType, CodeType

def more_vars(**vars):
    '''Decorator to inject more variables into a function.'''

    def wrapper(f):
        code = f.__code__
        new_freevars = code.co_freevars + tuple(vars.keys())
        new_globals = [var for var in code.co_names if var not in vars.keys()]
        new_locals = [var for var in code.co_varnames if var not in vars.keys()]
        payload = b''.join(
            filtered_bytecode(f, new_freevars, new_globals, new_locals))
        new_code = CodeType(code.co_argcount,
                            code.co_kwonlyargcount,
                            len(new_locals),
                            code.co_stacksize,
                            code.co_flags &amp; ~inspect.CO_NOFREE,
                            payload,
                            code.co_consts,
                            tuple(new_globals),
                            tuple(new_locals),
                            code.co_filename,
                            code.co_name,
                            code.co_firstlineno,
                            code.co_lnotab,
                            code.co_freevars + tuple(vars.keys()),
                            code.co_cellvars)
        closure = tuple(get_cell(v) for (k, v) in vars.items())
        return FunctionType(new_code, f.__globals__, f.__name__, f.__defaults__,
                            (f.__closure__ or ()) + closure)
    return wrapper

def get_cell(val=None):
    '''Create a closure cell object with initial value.'''

    # If you know a better way to do this, I'd like to hear it.
    x = val
    def closure():
        return x  # pragma: no cover
    return closure.__closure__[0]

def filtered_bytecode(func, freevars, globals, locals):
    '''Get the bytecode for a function with adjusted closed variables

    Any references to globlas or locals in the bytecode which exist in the
    freevars are modified to reference the freevars instead.

    '''
    opcode_map = {
        opmap['LOAD_FAST']: opmap['LOAD_DEREF'],
        opmap['STORE_FAST']: opmap['STORE_DEREF'],
        opmap['LOAD_GLOBAL']: opmap['LOAD_DEREF'],
        opmap['STORE_GLOBAL']: opmap['STORE_DEREF']
    }
    freevars_map = {var: idx for (idx, var) in enumerate(freevars)}
    globals_map = {var: idx for (idx, var) in enumerate(globals)}
    locals_map = {var: idx for (idx, var) in enumerate(locals)}

    for instruction in Bytecode(func):
        if instruction.opcode not in opcode_map:
            yield bytes([instruction.opcode, instruction.arg or 0])
        elif instruction.argval in freevars_map:
            yield bytes([opcode_map[instruction.opcode],
                         freevars_map[instruction.argval]])
        elif 'GLOBAL' in instruction.opname:
            yield bytes([instruction.opcode,
                         globals_map[instruction.argval]])
        elif 'FAST' in instruction.opname:
            yield bytes([instruction.opcode,
                         locals_map[instruction.argval]])
</code></pre>
<p>This behaves exactly as I wanted:</p>
<pre><code>In [1]: @more_vars(a='hello', b='world')
   ...: def test(x, y):
   ...:     print(a, b)
   ...:     print(x, y)
   ...:

In [2]: test(1, 2)
hello world
1 2

In [3]: help(test)
Help on function test in module __main__:

test(x, y)
</code></pre>
<p>This is almost certainly not ready for production use. I would be surprised if there weren't edge cases that behave unexpectedly, and possibly even segfault. I'd probably file this under the "educational curiosity" heading.</p>
</div>
<span class="comment-copy">Maybe you should describe your need more.  You'll only get one chance to decorate the function, so what is the advantage of putting <code>a='hello'</code> in the decorator, instead of just putting it as the first line of the function?</span>
<span class="comment-copy">It sounds like you're asking how to inject <code>extras</code> into the closure <code>test</code> after it's already been compiled, without having to modify the defining of <code>test</code> in any way. If so, I don't think that will be possible without some terrible hacks.</span>
<span class="comment-copy">But using a <a href="https://github.com/lihaoyi/macropy" rel="nofollow noreferrer">MacroPy</a> macro instead of a decorator, I'm guessing this would be easyâ€¦ Would that be an acceptable answer?</span>
<span class="comment-copy">Also, I don't understand "This makes it look like the user is expected to call the function with 3 parameters". Where? If the user tries to introspect the decorated function, he sees the signature of the decorated function. And the only reason that shows the extra argument is because you're using <code>wraps</code> with no arguments. Would just defining a custom wrapper around <code>update_wrapper</code> that left it out be sufficient? Or are you worried about people reading your source and getting confused?</span>
<span class="comment-copy">@abarnert "Where" is the output of "help(test)" which I include in my example. According to it, the call signature of test is "test(deco_vars, x, y)" instead of just "test(x, y)", which is how the user actually needs to call it.</span>
<span class="comment-copy">This looks like a decent solution, but I think I see an issue. If you attempt to assign any of the variables injected with more_vars, you'll create a local scope variable of the same name that shadows the injected "fake" global... unless you also add global declarations in the function. Is there any way around this?</span>
<span class="comment-copy">That's exactly why your design is a bad idea in the first place.  Why do you want to break the namespace?  For what possible use case could this be a good idea?  Have you considered using a callable class, and injecting new objects easily and explicitly rather than mucking around with decorators?</span>
<span class="comment-copy">If something is difficult to implement, there's always a tendency to respond with a knee-jerk "you shouldn't be doing that in the first place" without understanding the motivations behind it. I get it, challenging problems are definitely easier to solve when you change them to different, easier ones. But I'm not asking for other strategies to get the functionality I'm after, I'm looking to see if this strategy can be implemented. If you don't know any way to do this with decorators, that's fine, but please don't ask for an essay explaining all my motivations leading to this point.</span>
<span class="comment-copy">Ah, I appreciate this a lot! If you wouldn't mind explaining the strategy your library uses, that would make this even better in my mind.</span>
<span class="comment-copy">Thanks for the feedack ! I updated the answer accordingly.</span>
<span class="comment-copy">That's not the only problem. I also wrote in my initial description of the problem: "The thing I don't like about this is that when you use this decorator, you have to change the call signature of the function, adding the extra variable in addition to slapping on the decorator." The issue with "help" directly follows that sentence, but this is two separate issues. In the last code snippet, I show what I'd like it to look like.</span>
