<div class="post-text" itemprop="text">
<p>I'm trying to replace words like 'rna' with 'ribonucleic acid' from a dictionary of abbreviations. I tried writing the following, but it doesn't replace the abbreviations. </p>
<pre><code>import csv,re
outfile = open ("Dict.txt", "w")
with open('Dictionary.csv', mode='r') as infile:
    reader = csv.reader(infile)
    mydict = {rows[0]:rows[1] for rows in reader}
    print &gt;&gt; outfile, mydict
out = open ("out.txt", "w")
ss = open ("trial.csv", "r").readlines()
s = str(ss)
def process(s):
    da = ''.join( mydict.get( word, word ) for word in re.split( '(\W+)', s ) )
    print &gt;&gt; out, da
process(s)
</code></pre>
<p>A sample trial.csv file would be</p>
<pre><code>A,B,C,D
RNA,lung cancer,15,biotin
RNA,lung cancer,15,biotin
RNA,breast cancer,15,biotin
RNA,breast cancer,15,biotin
RNA,lung cancer,15,biotin
</code></pre>
<p>Sample Dictionary.csv:</p>
<pre><code>rna,ribonucleic acid
rnd,radical neck dissection
rni,recommended nutrient intake
rnp,ribonucleoprotein
</code></pre>
<p>My output file should have 'RNA' replaced by 'ribonucleic acid'</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this line <code>s = str(ss)</code> is causing the problem - the list that was created just became a string!</p>
<p>Try this instead:</p>
<pre><code>def process(ss):
    for line in ss:
        da = ''.join( mydict.get( word, word ) for word in re.split( '(\W+)', line ) )
        print &gt;&gt; out, da

process(ss)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I'm trying to replace 'RNA' but my dictionary has 'rna'. Is there a way I can ignore the case.</p>
</blockquote>
<p>Sure. Just call <a href="https://docs.python.org/3/library/stdtypes.html#str.casefold" rel="nofollow"><code>casefold</code></a> on each key while creating the dictionary, and again while looking up values:</p>
<pre><code>mydict = {rows[0].casefold(): rows[1] for rows in reader}

# ...

da = ''.join( mydict.get(word.casefold(), word) for word in re.split( '(\W+)', s ) )
</code></pre>
<p>If you're using an older version of Python that doesn't have <code>casefold</code> (IIRC, it was added in 2.7 and 3.2, but it may have been later than that…), use <code>lower</code> instead. It won't always do the right thing for non-English characters (e.g., <code>'ß'.casefold()</code> is <code>'ss'</code>, while <code>'ß'.lower()</code> is <code>'ß'</code>), but it seems like that's OK for your application. (If it's not, you have to either write something more complicated with <code>unicodedata</code>, or find a third-party library.)</p>
<hr/>
<blockquote>
<p>Also, I don't want it to replace 'corna' (I know such a word doesn't exist, but I want to make sure it doesn't happen) with 'coribonucleic acid'.</p>
</blockquote>
<p>Well, you're already doing that with your <code>re.split</code>, which splits on any "non-word" characters; you then look up each resulting word separtely. Since <code>corna</code> won't be in the dict, it won't be replaced. (Although note that <code>re</code>'s notion of "word" characters may not actually be what you want—it includes underscores and digits as part of a word, so <code>rna2dna</code> won't match, while a chunk of binary data like <code>s1$_2(rNa/</code> might.)</p>
<hr/>
<p>You've also got another serious problem in your code:</p>
<pre><code>ss = open ("trial.csv", "r").readlines()
s = str(ss)
</code></pre>
<p>Calling <code>readlines</code> means that <code>ss</code> is going to be a list of lines. Calling <code>str</code> on that list means that <code>s</code> is going to be a big string with <code>[</code>, then the repr of each line (with quotes around it, backslash escapes within it, etc.) separated by commas, then <code>]</code>. You almost certainly don't want that. Just use <code>read()</code> if you want to read the whole file into a string as-is.</p>
<hr/>
<p>And you appear to have a problem in your data, too:</p>
<pre><code>rna,ibonucleic acid
</code></pre>
<p>If you replace <code>rna</code> with <code>ibonucleic acid</code>, and so forth, you're going to have some hard-to-read output. If this is really your dictionary format, and the dictionary's user is supposed to infer some logic, e.g., that the first letter gets copied from the abbreviation, you have to write that logic. For example:</p>
<pre><code>def lookup(word):
    try:
        return word[0] + mydict[word.casefold()]
    except KeyError:
        return word
da = ''.join(lookup(word) for word in re.split('(\W+), s))
</code></pre>
<hr/>
<p>Finally, it's a bad idea to use unescaped backslashes in a string literal. In this case, you get away with it, because Python happens to not have a meaning for <code>\W</code>, but that's not always going to be true. The best way around this is to use raw string literals, like <code>r'(\W+)'</code>.</p>
</div>
<span class="comment-copy">Are you trying to replace <code>'rna'</code> or <code>'RNA'</code>? Those are different strings?</span>
<span class="comment-copy">Also, please give us a <i>complete</i> example—a 2-line <code>trial.csv</code> and a <code>-line </code>Dictionary.csv` (or hardcoded values in the code)—that we can run and debug. See <a href="http://stackoverflow.com/help/mcve">MCVE</a> in the help.</span>
<span class="comment-copy">@abarnert I'm trying to replace 'RNA' but my dictionary has 'rna'. Is there a way I can ignore the case. Also, I don't want it to replace 'corna' (I know such a word doesn't exist, but I want to make sure it doesn't happen) with 'coribonucleic acid'.</span>
<span class="comment-copy">Please edit that into the question, don't just answer in comments. (And again, please give us a complete example.)</span>
<span class="comment-copy">This is <i>a</i> problem, but not the one she's asking about; she won't get to this one until she solves the one she asked about.</span>
<span class="comment-copy">@abarnert, my solution will replace abbreviations with their expansions - this is what she wants.</span>
<span class="comment-copy">Thank you. It worked. Only that I had to replace <code>mydict.get( word, word )</code> with <code>mydict.get( word.lower(), word )</code>. <code>lower()</code> worked fine because my dictionary is in lower case and I coulnd't get <code>casefold()</code> workingg.</span>
<span class="comment-copy">Thank you. I tried the edits. With read(), casefold and s, I get <code>'str' object has no attribute 'casefold'</code>. With readlines(), casefold and s I get <code>expected string or buffer</code></span>
<span class="comment-copy">It was my mistake. I haven't copied it properly. It is ribonucleic acid.</span>
<span class="comment-copy">OK, with older versions of Python, <code>casefold</code> doesn't exist; use <code>lower</code>. Same idea otherwise.</span>
