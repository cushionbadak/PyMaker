<div class="post-text" itemprop="text">
<p>I have a question about dictionaries. </p>
<pre><code>food = { 'omlette' : { 'egg': 1, 'ham': 0.2 }, 'soup' : { 'water': 1 , 'vegetables': 2, 'meat': 4 }}
</code></pre>
<p>and a list:</p>
<pre><code>order(['omlette', 4])
</code></pre>
<p>I want to return the ingredients from <code>dict food(values)</code> times the number of servings needed. So my result should look like this:</p>
<pre><code>{ 'egg': 4.0 , 'ham': 0.8 }
</code></pre>
<p>What should I add to this comprehension?</p>
<pre><code>def multi(order):
    return {key for key,value in order if key in food.keys()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be using a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">dict comprehension</a>, not a set comprehension:</p>
<pre><code>&gt;&gt;&gt; def multi(order):
...     return {k:float(v * order[1]) for k, v in food[order[0]].items()}
...
&gt;&gt;&gt; multi(["omlette", 4])
{'egg': 4.0, 'ham': 0.8}
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>iCodez's answer is correct (and I upvoted it :) ). But when comprehensions get this complicated I think it's a good idea to break them down. At least for me it helps me see what's going on better:</p>
<pre><code>def multi(order):
    d = {}
    for k, v in food[order[0]].items():
        d[k] = float(v * order[1])
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def multi(order):
...     if order[0] in food.keys():
...        return { x:float(y*order[1]) for x,y in food[order[0]].items() }
...     else:return "Item not found"
... 
&gt;&gt;&gt; multi(["omlette",4])
{'egg': 4, 'ham': 0.8}
</code></pre>
<p>you can aslo check if the item is in food dictionary or not<br/></p>
<p>if you want to pass tuple:</p>
<pre><code>&gt;&gt;&gt; def multi(order):
...     return [ { i:float(j*y) for i,j in food[x.lower()].items() } for x,y in order if x.lower() in food.keys() ]

&gt;&gt;&gt; multi([('omlette', 4),('Soup' ,1)])
[{'egg': 4.0, 'ham': 0.8}, {'water': 1.0, 'vegetables': 2.0, 'meat': 4.0}]
</code></pre>
</div>
<span class="comment-copy">Thank you for the answer:)</span>
<span class="comment-copy">It will return keyError if keys is not found. &gt;&gt;&gt; def multi(order): ...     return {k:float(v * order[1]) for k, v in food[order[0]].items()} ...  &gt;&gt;&gt; multi(['kfc',5]) Traceback (most recent call last):   File "&lt;stdin&gt;", line 1, in &lt;module&gt;   File "&lt;stdin&gt;", line 2, in multi KeyError: 'kfc'</span>
<span class="comment-copy">Yes,for my needs not important because i have a fixed dict..</span>
<span class="comment-copy">Indeed, i am  new to python and that would be good to use in the start to not get lost.</span>
<span class="comment-copy">Oh, I forgot to return <code>d</code> at the end. Edited it to do so.</span>
<span class="comment-copy">It depends on the desired behavior. Python will already throw an exception and print a message if the item isn't found. The above code changes the message and no longer exits with an error.</span>
<span class="comment-copy">It also returns a <code>string</code> from a function expecting to return a <code>dict</code>, which is not ideal.</span>
<span class="comment-copy">not it will return dict not string</span>
<span class="comment-copy"><code>return "Item not found"</code> returns a <code>string</code>, not a <code>dict</code>.</span>
<span class="comment-copy">you can check code if you want to pass tuple</span>
