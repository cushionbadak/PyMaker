<div class="post-text" itemprop="text">
<p>So I am trying to make a program that prints out the number of ways a message can be decoded.
The mapping can be easily understood in the code itself. Right now it is working for most numbers, but for some it is not calculating it correctly. For example the number 1111, it solves it like there are 2 ways of decoding it but in reality there is 4 different ways of doing so.</p>
<p>This is my code:</p>
<pre><code>mapping=["1", "2", "3", "4", "5", "6", "7" "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26"]

encodedCases = ["918", "739", "1142", "56", "82", "118", "1219", "6", "862", "1111"]

def decodeNumber(test, mapping):
    count=0
    checkFirstLast=0
    for i in range(9, len(mapping)):
        if mapping[i] in test:
            count+=1
        if test[:2]!=test[-2:]:
            if len(test)&gt;3 and mapping[i] in test[:2]:
                checkFirstLast+=1
            elif len(test)&gt;3 and mapping[i] in test[-2:]:
                checkFirstLast+=1

    if checkFirstLast==2:
        count+=1
    print count + 1

for test in encodedCases:
    test = test.strip()
    decodeNumber(test, mapping)
</code></pre>
<p>Using this method I have not found a way to be able to successfully calculate it correctly. Is there a better way of achieving this? Thanks in advance!</p>
<p>NOTE - Mapping is a representation of the alphabet giving each letter the value of their position in the alphabet.</p>
</div>
<div class="post-text" itemprop="text">
<p>I can think of a recursive approach:</p>
<pre><code>def decodeNumber(test):
    if not test: # check if test is empty
        return 1

    count = 0

    for i in mapping:
        if test.startswith(i):
            count += decodeNumber(test[len(i):])

    return count


for test in encodedCases:
    test = test.strip()
    print test, "==&gt;" , decodeNumber(test)
</code></pre>
<p><code>decodeNumer</code> checks if the <code>test</code> input starts with an entry in mapping. For all entries that do it calls itself. The new parameter is <code>test[len(i):]</code> which means <code>test</code> with the entry removed from the begining.</p>
<p>For example let <code>test = "918"</code>: the if statement evaluates to true for the first time when <code>i == "9"</code> and the new parameter is <code>test[len("9"):]</code> which is equal to "18".</p>
<p>The total count is computed as the total number of paths which consume the complete input.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a clean <em>dynamic programming</em> approach which runs in worst-case time O(nk) where k is the length of the mapping and n is the length of the string. In particular, unlike the naive recursive approach, it will never take exponential time on an input.</p>
<p>This works on Python 3.2+.</p>
<pre><code>import functools

@functools.lru_cache(None) # lru_cache implements memoization
def decodeNumber(s, mapping):
    if not s:
        return 1 # base case: there's one way to decode the empty string

    # iterate over all possible prefixes, and count the ways to decode the resulting suffixes
    res = 0
    for m in mapping:
        if s.startswith(m):
            res += decodeNumber(s[len(m):], mapping)
    return res
</code></pre>
<p>Note that <code>mapping</code> should be a <code>tuple</code> in this implementation (you can also just omit the <code>mapping</code> parameter from the function declaration to use a global <code>mapping</code> variable).</p>
<p>Memoization saves us from having to repeatedly compute the same values. Without memoization, the algorithm must do at least <code>res</code> recursive calls (since every counted decoding must end in a recursive call to the <code>return 1</code> case eventually). With memoization, we can skip over recursive calls that have already been handled.</p>
<p>You can see the difference if you try to run <code>decodeNumber("1" * 256, ("1", "11"))</code> with and without memoization. Without memoization it will never finish. With memoization, the result is instant.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an iterative solution with O(n) time complexity (one pass) and O(1) space complexity:</p>
<pre><code>def ways(s):

if (len(s)==0 or len(s)==1): return 1

if (int(s[0:2])&lt;27): prev = 2
else: prev = 1
prevprev = 1

for i in range(2,len(s)):
    if (int(s[i-1:i+1])&lt;27): curr = prev + prevprev
    else: curr = prev
    prevprev = prev
    prev = curr
return prev
</code></pre>
<p>It's a dynamic programming approach. In each iteration add another digit and calculate the number of ways a message can be decoded up to this digit. If the previous and current digits are greater than 26 put together then the current is the same as the previous, because the current digit must be on its own. Otherwise, the ways to encode the message equals the ways to encode the message without the two (prevprev) plus the ways to encode the message without the current digit (prev).</p>
<p>Also, there are 5 ways to decode 1111 (1-1-1-1, 1-1-11, 1-11-1, 11-1-1, 11-11)</p>
</div>
<span class="comment-copy">Tip: you can generate 1-26 with <code>[str(x) for x in range(0, 27)]</code></span>
<span class="comment-copy">So if I declare mapping = [str(x) for x in range(0, 27)] that is the equivalent of what I have on my code? @TimCastelijns</span>
<span class="comment-copy"><code>mapping = [str(x) for x in range(1, 27)]</code> could replace the long <code>mapping = ["1",.. "26"]</code></span>
<span class="comment-copy">It's usually a good idea to <code>return</code> values from functions, instead of printing them.</span>
<span class="comment-copy">Then it would actually be <code>[str(x) for x in range(1,27)]</code></span>
<span class="comment-copy">Could you explain the function in detail? I'm having problems understanding some expressions.I am liking the simplicity of your code.</span>
<span class="comment-copy">What is the purpose of the <code>if not test</code> conditional expression?</span>
<span class="comment-copy">I added a comment, it just checks if <code>test</code> is an empty string.</span>
<span class="comment-copy">Can you explain how an LRU cache makes this better? It is mentioned <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">here</a> that lru cache saves time if the same function is called with the same arguments. Does this happen here?</span>
<span class="comment-copy">I think, I understood it. If there are decodings like "1,2,xxxx" and "12xxxx" then, its possible that the same decode function is called multiple times.</span>
<span class="comment-copy">Is this available in python2 as well?</span>
<span class="comment-copy">Yes, from the <a href="https://pypi.python.org/pypi/functools32" rel="nofollow noreferrer"><code>functools32</code></a> package. (It's not hard to implement a memoized function; <code>lru_cache</code> just makes it so easy to do!)</span>
