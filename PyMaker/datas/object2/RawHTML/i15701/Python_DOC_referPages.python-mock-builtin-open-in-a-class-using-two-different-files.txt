<div class="post-text" itemprop="text">
<p>I am having trouble figuring out how to mock two file opens in a class when they both use context managers. I know how to do it for one context-managed file using the mock module like this:</p>
<pre><code>@patch('__builtin__.open')
def test_interface_mapping(self, mock_config):
        m = MagicMock(spec=file)
        handle = m.return_value.__enter__.return_value
        handle.__iter__.return_value = ('aa', 'bb')
</code></pre>
<p>My problem is how to do this when a class opens two different files in the same call. In my case, the class <code>__init__()</code> preloads the files into two maps. This class is used in other classes. I want to mock the loading of these two files to provide my test data so that the other classes that use the IfAddrConfig object can be tested against my preloaded test file content.</p>
<p>Here's an example of the class I am struggling with that loads two files in <code>__init__()</code>, both of which I want to mock to load my test injected file contents. getInterfaceMap() is the function that is called frequently so I do not want that to be loading and parsing the files every call, hence the reason for preloading the maps in <code>__init__()</code> once.</p>
<pre><code>class IfAddrConfig(object):
    def __init__(self):
        # Initialize the static maps once since they require file operations
        # that we do not want to be calling every time getInterfaceMap() is used
        self.settings_map = self.loadSettings()
        self.config_map = self.loadConfig()

    def loadConfig(self):
        config_map = defaultdict(dict)
        with open(os.path.join('some_path.cfg'), 'r') as stream:
            for line in stream:
                # Parse line and build up config_map entries
        return config_map

    def loadSettings(self):
        settings_map = {}
        with open('another_path.cfg', 'r') as stream:
            for line in stream:
                # Parse line and build up settings_map entries
        return settings_map

    def getInterfaceMap(self, interface):
        # Uses both the settings and config maps to finally create a composite map
        # that is returned to called
        interface_map = {}
        for values in self.config_map.values():
            # Accesss self.settings_map and combine/compare entries with
            # self.config_map values to build new composite mappings that
            # depend on supplied interface value
        return interface_map
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You must use <code>side_effect</code> attribute of your patched <code>open</code> object (<code>mock_open</code>) and don't forget to set the <code>return_value</code> for <code>__exit__</code> method.</p>
<pre><code>@patch('__builtin__.open', spec=open)
def test_interface_mapping(self, mock_open):
    handle1 = MagicMock()
    handle1.__enter__.return_value.__iter__.return_value = ('aa', 'bb')
    handle1.__exit__.return_value=False
    handle2 = MagicMock()
    handle2.__enter__.return_value.__iter__.return_value = ('AA', 'BB')
    handle2.__exit__.return_value=False
    mock_open.side_effect = (handle1, handle2)
    with open("ppp") as f:
        self.assertListEqual(["aa","bb"],[x for x in f])
    with open("ppp") as f:
        self.assertListEqual(["AA","BB"],[x for x in f])
</code></pre>
<hr/>
<p><strong>[EDIT]</strong>
I found a much more elegant way to do it <a href="https://stackoverflow.com/questions/25555161/mock-builtin-open-function-when-used-in-contextlib/27160842#27160842">Mock builtin 'open" function when used in contextlib</a></p>
<p>So you can rewrote test like</p>
<pre><code>@patch('__builtin__.open', new_callable=mock_open, read_data="aa\nbb")
def test_interface_mapping_new(self, mo):
    handlers = (mo.return_value,mock_open(read_data="AA\nBB").return_value,)
    mo.side_effect = handlers
    with open("ppp") as f:
        self.assertEqual("aa\nbb",f.read())
    with open("ppp") as f:
        self.assertEqual("AA\nBB",f.read())
</code></pre>
<p>And from python 3.4 you can use also readline(), readlines() without mocking anything else.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'd create two 'file' mocks, and mock <code>open</code> to return these in sequence as <code>open()</code> is called. The <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side_effect</code> attribute</a> lets you do just that:</p>
<pre><code>@patch('__builtin__.open')
def test_interface_mapping(self, mock_open):
    handle1 = MagicMock('file1').__enter__.return_value
    handle1.__iter__.return_value = ('aa', 'bb')
    handle2 = MagicMock('file2').__enter__.return_value
    handle2.__iter__.return_value = ('foo', 'bar')
    mock_open.return_value.side_effect = (handle1, handle2)
</code></pre>
<p>The mocked <code>open()</code> call returns first <code>handle1</code> when called, then <code>handle2</code>. Either object then responds to <code>__enter__()</code> being called with a mock that returns a given tuple for the <code>__iter__</code> call.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need much more control over file content you can use a wrapper function.
It substitutes the content of a file according to the filename as the original <code>open</code> does.</p>
<pre><code>import unittest.mock as mock


def my_open(filename):
    if filename == 'file.txt':
        content = "text file\ncontent"
    elif filename == 'second.txt':
        content = 'foobar'
    else:
        raise FileNotFoundError(filename)
    file_object = mock.mock_open(read_data=content).return_value
    file_object.__iter__.return_value = content.splitlines(True)
    return file_object
</code></pre>
<p>In the <code>elif</code> chain you set "file contents" for each existing file path.</p>
<p>Tests:</p>
<pre><code># standalone
open_patch = mock.patch('__main__.open', new=my_open)
open_patch.start()

file = open('file.txt')
assert file.read() == "text file\ncontent"
file.close()

open_patch.stop()

#with statement
with mock.patch('__main__.open', new=my_open):
    with open('second.txt') as file:
        assert file.read() == 'foobar'

    # as iterable
    with open('file.txt') as file:
        assert ['text file\n', 'content'] == list(file)

# function decorator
@mock.patch('__main__.open', new=my_open)
def test_patched_open():
    with open('second.txt') as file:
        assert file.readline() == 'foobar'

test_patched_open()
</code></pre>
</div>
<span class="comment-copy">Thanks! This answer is correct and helped.</span>
<span class="comment-copy">@Mark if it was useful don't forget the +1 :)</span>
<span class="comment-copy">Thank you!  My question was different -- how do I mock <code>with open(filename) as f: for line in f: ...</code> -- and your answer helped me do it.  Unfortunately <code>mock_open</code> doesn't do anything about iteration.</span>
<span class="comment-copy">@MariusGedminas try to switch to python3.4 (If you didn't already do) and use <code>h.__iter__=h.readlines.side_effect</code> where <code>h</code> are handlers in <code>handlers</code>. It should fix it ... maybe it is bug or they forget to set it. Here <a href="https://hg.python.org/cpython/file/3.4/Lib/unittest/mock.py#l2309" rel="nofollow noreferrer">hg.python.org/cpython/file/3.4/Lib/unittest/mock.py#l2309</a> is the source code.</span>
<span class="comment-copy">I'm using mock from PyPI with various Pythons (2.6 to 3.4).  It's possible <code>mock_open.return_value.__iter__.side_effect = mock_open.return_value.readline.side_effect</code> might work, but it seems more complicated compared to <a href="https://github.com/mgedmin/mgp2pdf/commit/02eafa6ebedce8276271bc2d0e1b6798f81b7e76" rel="nofollow noreferrer">what I already do</a> (which was inspired by the 1st part of your answer).</span>
<span class="comment-copy">Why do you patch <code>__builtin__.open</code>, only to throw away the resulting Mock object (by immediately redefining <code>mock_open</code> in the first line of the function)?</span>
<span class="comment-copy">@ron.rothmanℝℝ: good question, there is indeed no need to do both. I can't remember why I did that (it's been 3 years almost), so I just removed the second mock.</span>
