<div class="post-text" itemprop="text">
<p>I have 3 lists, all of the same length. One of the lengths is a number representing a day, and the other two lists are data which correspond to that day, e.g</p>
<pre><code>day = [1,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4....]

data1 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4....] # (effectively random numbers)

data2 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4....] # (again, effectively random numbers)
</code></pre>
<p>What I need to do is to take <code>data1</code> and <code>data2</code> for day 1, perform operations on it, and then repeat the process for day 2, day 3, day 4 and so on.</p>
<p>I currently have:</p>
<pre><code>def sortfile(day, data1, data2):

    x=[]
    y=[]
    date=[]
    temp1=[]
    temp2=[]

    i=00
    for i in range(0,len(day)-1):
        if day[i] == day[i+1]:
            x.append(data1[i])
            y.append(data2[i])
            i+=1
        #print x, y
        else:
            for i in range(len(x)):
                temp1.append(x)
            for i in range(len(y)):
                temp2.append(y)
            date.append(day[i]) 
            x=[]                
            y=[]
            i+=1
    while i!=(len(epoch)-1):
        x.append(data1[i])
        y.append(data2[i])
        i+=1
    date.append(day[i])
    return date, temp1, temp2
</code></pre>
<p>This is supposed to append to the x array whilst the day stays the same, and then if it changes append all the data from the x array to the temp1 array, then clear the x array. It will then perform operations on temp1 and temp2. However, when I run this as a check (I'm aware that I'm not clearing temp1 and temp2 at any point), temp1 just fills with the full list of days and temp2 is empty.  I'm not sure why this is and am open to completely restarting if a better way is suggested!</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just zip the lists:    </p>
<pre><code>x = []
y = []
date = []
temp1 = []
temp2 = []
day = [1,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4]

data1 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4]

data2 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4]
zipped = zip(day, data1,data2) # list(zipped) for python 3
for ind, dy, dt1, dt2 in enumerate(zipped[:-1]):
    if zipped[ind+1][0] ==  dy:
        x.append(dt1)
        y.append(dt2)
    else:
        temp1 += x
        temp2 += y
        x = []                
        y = [] 
</code></pre>
<p>Not sure what your while loop is doing as it is outside the for loops and you don't actually return or use <code>x</code> and <code>y</code> so that code seems irrelevant and may well be the reason your code is not returning what you expect.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>groupby</code></a> and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> are a good solution for this problem. It lets you group bits of sorted data together. <code>zip</code> allows you to access the elements at each index of <code>day</code>, <code>data1</code>, and <code>data2</code> together as a tuple. </p>
<pre><code>from operator import itemgetter
from itertools import groupby

day = [1,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4]
data1 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4]
data2 = [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,5,1,2,3,4]

x = []
y = []

for day_num, data in groupby(zip(day, data1, data2), itemgetter(0)):
    data = list(data)
    data1_total = sum(d[1] for d in data)
    x.append(data1_total)
    data2_total = sum(d[2] for d in data)
    y.append(data2_total)
</code></pre>
<p><code>itemgetter</code> is just a function that tells <code>groupby</code> to group the tuple of elements by the first element in the tuple (the day value).</p>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use defaultdict and simply iterate over <code>days</code> adding data as we go:</p>
<pre><code>from collections import defaultdict

d1 = defaultdict(list)
d2 = defaultdict(list)

for n, d in enumerate(day):
    d1[d].append(data1[n])
    d2[d].append(data2[n])
</code></pre>
<p>This creates two dicts like <code>{day: [value1, value2...]...}</code>. Note that this solution doesn't require <code>days</code> to be sorted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Running several threads is similar to running several different programs concurrently sharing the same data. You can call a thread for each array.</p>
<p>Read more about threading on the <a href="https://docs.python.org/2/library/threading.html" rel="nofollow">threading documentation</a></p>
</div>
<span class="comment-copy">Welcome to stackoverflow. Try to ask more about the problem you are trying to solve instead of asking about your solution - as currently stated your question is a bit hard to follow. Note that uses of <code>while</code> that are not <code>while True</code> in Python are a code smell, in most cases it should be replaced by a <code>for</code> loop instead.</span>
<span class="comment-copy">On python 3.x <code>zip</code> returns an iterator, so you would need to do <code>zipped = list(zip(day, data1,data2))</code>.</span>
<span class="comment-copy">@Dunesm true, I will add that in</span>
<span class="comment-copy">Better than my answer. Thanks, this was useful. I didn't know about zip until now. You get my upvote too :P</span>
<span class="comment-copy">Not being a critic, but using thread for OPs may be an overkill.</span>
<span class="comment-copy">@haugubear Yes, I thought that too but couldn't come up with anything better than this. I just saw the other answer here. That one is better than mine. Thanks for the feedback though :)</span>
