<div class="post-text" itemprop="text">
<p>I am converting date and time stored in 4 bytes to Python format. I came up with naive approach first. Then I tried to use <code>ctypes</code> so it should be faster:</p>
<pre><code>from ctypes import *
from datetime import datetime


def bit_unpack(data, bits):
    value = int.from_bytes(data, "big")
    unpacked = []
    for i, field in enumerate(bits):
        shift = sum(bits[i+1:])
        mask = 2 ** field - 1
        bit_field = (value &gt;&gt; shift) &amp; mask
        unpacked.append(bit_field)
    return unpacked


def to_date(data):
    y, m, d, h, n, s = bit_unpack(data, (6, 4, 5, 5, 6, 6))
    return datetime(1980 + y, m, d, h, n, s)


class PackedDate(BigEndianStructure):
    _fields_ = [
        ("year", c_uint, 6),
        ("month", c_uint, 4),
        ("day", c_uint, 5),
        ("hours", c_uint, 5),
        ("minutes", c_uint, 6),
        ("seconds", c_uint, 6),
    ]


class Transfer(Union):
    _fields_ = [
        ("bytes", c_uint32),
        ("date", PackedDate),
    ]


def to_date2(data):
    transfer = Transfer()   
    transfer.bytes = int.from_bytes(data, "little")
    date = transfer.date
    return datetime(date.year + 1980, date.month, date.day, date.hours, date.minutes, date.seconds)


if __name__ == "__main__":
    byte_data = b'q\xa6\xb1\xdf'
    print(to_date(byte_data))
    print(to_date2(byte_data))

    import timeit
    print(timeit.timeit("to_date(byte_data)", r"from bitunpack import to_date; byte_data = b'q\xa6\xb1\xdf'"))
    print(timeit.timeit("to_date2(byte_data)", r"from bitunpack import to_date2; byte_data = b'q\xa6\xb1\xdf'"))
</code></pre>
<p>However, what I do not like is this part:</p>
<pre><code>transfer.bytes = int.from_bytes(data, "little")
</code></pre>
<p>I am converting 4 bytes to uint32. Can I change my Union to be able to easier accept 4 bytes array without converting it to uint32 first? I tried <code>c_ubyte * 4</code> but got <code>TypeError: expected c_ubyte_Array_4 instance, got bytes</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/ctypes.html#ctypes._CData.from_buffer_copy" rel="nofollow"><code>from_buffer_copy</code></a> method that’s available on all <code>ctypes</code> types to create a <code>PackedDate</code> object directly from the <code>bytes</code> data:</p>
<pre><code>&gt;&gt;&gt; date = PackedDate.from_buffer_copy(data)
&gt;&gt;&gt; datetime(date.year + 1980, date.month, date.day, date.hours, date.minutes, date.seconds)
datetime.datetime(2008, 6, 19, 11, 7, 31)
</code></pre>
</div>
<span class="comment-copy">You are still calling <code>int.from_bytes(data, 'little')</code> to convert bytes to integer. I thought about avoiding this as I do not need the integer.</span>
<span class="comment-copy">@Fenikso, use <code>date = PackedDate.from_buffer_copy(data)</code>.</span>
<span class="comment-copy">@eryksun Wow, that’s a lot easier. I was hoping to find something like this but didn’t see it in the documentation. You should post that as an answer.</span>
<span class="comment-copy">@eryksun - That is what I was looking for. Please write it as an answer. I could not find it in the docs either...</span>
<span class="comment-copy">@Fenikso You could have used <a href="https://docs.python.org/3/library/ctypes.html#ctypes.c_char_p" rel="nofollow noreferrer">c_char_p</a> directly (which converts from/to the <code>bytes</code> type) but that would have the wrong byte order.</span>
