<div class="post-text" itemprop="text">
<pre><code>NUMBERS = "123456789"

def digit_checker(x):

    for t in  x:
        if t  in NUMBERS:
           y = True
        else:
           y = False
    return y



 sentence = input("Enter a string to check if its all digits: ")
 checker = digit_checker(sentence)
 print(checker)
</code></pre>
<p>As the title states, how would I find if the string has all digits without using the <code>str.isdigit</code> or a <code>try/except</code>. The code keeps checking the first character and not all. How do I fix that?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>NUMBERS = "123456789"

def digit_checker(x):
    y = True
    for t in  x:
        if t not in NUMBERS:
           y = False
    return y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>all</code></a> and a <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow">generator expression</a>:</p>
<pre><code>NUMBERS = "1234567890"

def digit_checker(x):
    return all(t in NUMBERS for t in x)
</code></pre>
<p>This will go through each character in <code>x</code> and see if it is in <code>NUMBERS</code>.  If not, <code>all</code> will immediately stop checking and return <code>False</code>.  Otherwise, it will return <code>True</code> after it has confirmed that every character is a digit.  Below is a demonstration:</p>
<pre><code>&gt;&gt;&gt; NUMBERS = "1234567890"
&gt;&gt;&gt; def digit_checker(x):
...     return all(t in NUMBERS for t in x)
...
&gt;&gt;&gt; digit_checker('12345')
True
&gt;&gt;&gt; digit_checker('12345a')
False
&gt;&gt;&gt;
</code></pre>
<p>Note too that it would be more efficient if you made <code>NUMBERS</code> a set:</p>
<pre><code>NUMBERS = set("1234567890")
</code></pre>
<p>That way, <code>t in NUMBERS</code> will perform an <code>O(1)</code> (constant) hash lookup rather than an <code>O(n)</code> (linear) search through the string.  Granted, on strings this small, the performance impact of the linear search is not too worrisome.  However, that will quickly change whenever you are working with larger strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, it looks like it is checking every character, but because it sets <code>y</code> for every character, it is the "numberless" of the last character that determines the value returned, regardless of what the other characters are.</p>
<p>Instead, you should initialize <code>y</code> to <code>True</code>, and only set it to <code>False</code> if you ever find a non-number.  In fact, when that happens, you can immediately return.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are chefcking for the fact that all the letters are numbers, you can try the following expression:</p>
<pre><code>def digit_checker(x):
    return all( t in NUMBERS for t in  x )
</code></pre>
<p>It is exactly the same as your code except it will also check whether all the characters within <code>x</code> are numbers. This is what has been missing in your code. The return value is always overwritten by the last check. Of course, using a loop and breaking out might be more efficient unless <code>all</code> does that internally for the generator expression, in which case the two are exactly equivalent.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>NUMBERS = "1234567890" # Did you miss the 0?

def digit_checker(x):
    all_digits = True
    for t in  x:
        if t not in NUMBERS:
           all_digits = False
           break
    return all_digits
</code></pre>
<p>A different approach would be to check them as sets:</p>
<pre><code>def digit_checker(x):
    return True if set(x).difference(set(NUMBERS)) == set() else False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps if you clear up the variable names the problem will be more clear:</p>
<pre><code>def digit_checker(sentence):
    is_number = True
    for character in sentence:
        if character in NUMBERS:
           is_number = True
        else:
           is_number = False
    return is_number 
</code></pre>
<p>As you can see, you are evaluating if it is a number for each character, and changing the <code>is_number</code> variable each time.  So, only the <em>last</em> character will result in proper evaluation.</p>
<p>You probably want to just return <code>False</code> when a non-digit is first detected.  Try <code>if character not in NUMBERS</code> set <code>is_number</code> to <code>False</code> and break the loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are some good answers to do that. Here's another way to do it. You can count the number of characters that are not digits, by storing them in a list, the length of this list should be zero. </p>
<pre><code>NUMBERS = "1234567890"

def digit_checker(x):
    return len([t for t in x if t not in NUMBERS]) == 0


print digit_checker('123') #True
</code></pre>
</div>
<span class="comment-copy">it should be only checking the last character in the given <code>sentence</code>, since you are looping over each character.</span>
<span class="comment-copy">you need to exit at the first false encounter, otherwise you risk reflipping your variable to true later. one time false is definite false in this case.</span>
<span class="comment-copy">This is the smallest change to his code that works, which is greatâ€¦ but some explanation of why it's different would help a lot.</span>
<span class="comment-copy">Except that this answer is not correct - it won't work for say number 10</span>
<span class="comment-copy">He is missing <code>0</code> from his <code>NUMBERS</code> but since you are checking for strings that are digits it's only checking 0-9.</span>
<span class="comment-copy">+1 for using sets.  Note that you could write it more concisely as:  <code>return set(x).difference(NUMBERS) == set()</code>.</span>
<span class="comment-copy">Why set it to False and break? If you want to return False, just <code>return False</code>. And if you do that, you don't need <code>is_number</code> anymore at all.</span>
<span class="comment-copy">Yes, you can do that.  It's only a matter of stylepreference.  It doesn't matter much here since the function is so small, but for larger functions, I prefer to have a single return.</span>
<span class="comment-copy">Writing 5 lines of code that mean "return False" (as you directly describe it in your explanation) just to avoid actually writing <code>return False</code> is silly. It may make sense in other languages like C89, but bringing prejudices from other language is not a good way to write readable Python code.</span>
<span class="comment-copy">Initializing an extra variable makes no sense when you can simply return the Boolean value once you get the answer. If the string <code>'9 askjdhaskjdbsakjdsa...'</code> was passed why keep going once you find the first instance of a digit?</span>
<span class="comment-copy">only a matter of style preference.</span>
