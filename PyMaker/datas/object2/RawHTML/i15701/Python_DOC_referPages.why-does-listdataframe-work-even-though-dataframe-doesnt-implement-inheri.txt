<div class="post-text" itemprop="text">
<p>I can't find an <code>__iter__()</code> method defined in <code>rpy2.robjects.DataFrame</code>, nor in any of its base classes*</p>
<p>Yet, I can use <a href="https://stackoverflow.com/q/24152160/212218">this code</a> to convert a DataFrame into a dict:</p>
<pre><code>from rpy2.robjects import DataFrame
dataframe = DataFrame(...)

d = dict(zip(dataframe.names, map(list, list(dataframe))))
</code></pre>
<p>Why doesn't <code>list(dataframe)</code> in the above code trigger a <code>TypeError: 'DataFrame' object is not iterable</code>?</p>
<hr/>
<p>* Determined by running the following code:</p>
<pre><code>def test_attr(cls, attr):
  if attr in cls.__dict__:
    print cls.__name__
  else:
    for base in cls.__bases__:
      test_attr(base, attr)
</code></pre>
<pre>
Python 2.7.8 (default, Oct 18 2014, 05:53:47)
... 
&gt;&gt;&gt; from rpy2.robjects import DataFrame
&gt;&gt;&gt; test_attr(DataFrame, '__iter__')
</pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>list</code> method works in terms of the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter</code></a> method.* And, as the docs say:</p>
<blockquote>
<p>Without a second argument, <code>object</code> must be a collection object which supports the iteration protocol (the <code>__iter__()</code> method), or it must support the sequence protocol (the <code>__getitem__()</code> method with integer arguments starting at 0).</p>
</blockquote>
<hr/>
<p>Here's an example of a class that's <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow">iterable</a>** without defining <code>__iter__</code>:</p>
<pre><code>class Range10(object):
    def __getitem__(self, i):
        if i &lt; 10: return i
        raise IndexError
r = Range10()
list(r)
</code></pre>
<p>The output will be <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>.</p>
<hr/>
<p>If you're curious, this "sequence protocol" if effectively how <code>for</code> loops worked in early Python, but the modern definition was created for backward compatibility back when iterators were added in Python 2.2.*** It could have been removed in 3.0, but there were good arguments for why it was useful, so it stayed.****</p>
<hr/>
<p><sub>* Actually, at least in CPython, that's not how it actually works, but it's documented to work <em>as if</em> it were calling <code>iter</code>.</sub></p>
<p><sub>** But notice that it's not <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow">an <code>Iterable</code></a>, even though that's one of the few "automatic ABCs" that you don't have to inherit from/register with. The documentation explicitly doesn't say that <code>Iterable</code> means <em>iterable</em>; it says "See also the definition of <em>iterable</em>".</sub></p>
<p><sub>*** For example, third party libraries like <code>numeric</code>, the predecessor to today's <code>numpy</code>, provided collection classes that worked in <code>for</code> loops in Python 2.1, and they wanted them to keep working even though <code>for</code> loops were now implemented in terms of iterators.</sub></p>
<p><sub>**** I don't remember what exactly the arguments were, but it must have had something to do with certain classes being more readable/easier to understand by thinking in terms of the sequence protocol instead of manually reproducing the same thing in terms of the iteration protocol. You'd have to hunt through the python-3000 list archives for details.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I think every robject implements rinterface</p>
<p>you can see the <code>__iter__</code> method in</p>
<p><a href="https://bitbucket.org/lgautier/rpy2/src/08ec0c15bd5ef8170ad8a49c2dc2b4a8dea36d64/rpy/rinterface/_rinterface.c?at=default#cl-2446" rel="nofollow">https://bitbucket.org/lgautier/rpy2/src/08ec0c15bd5ef8170ad8a49c2dc2b4a8dea36d64/rpy/rinterface/_rinterface.c?at=default#cl-2446</a></p>
<p>at least I think ... it gets pretty tangled pretty quick </p>
</div>
<span class="comment-copy">There is <code>__getslice__</code> in rpy2.robjects.Vector. Also, <code>__getitem__</code>.</span>
<span class="comment-copy">Can you just type <code>rpy2.robjects.Dataframe.__iter__</code> at the interactive prompt and see whether it prints out a function or builtin function or raises an <code>AttributeError</code>? That would make the answer a lot easier to find.</span>
<span class="comment-copy">From your edit, have you still not tried just printing out <code>Dataframe.__iter__</code>? While that won't identify the class it's defined in in all cases, it's at least a quick and reliable way to test whether it exists…</span>
<span class="comment-copy">holy cow thats pretty cool ... I never knew you could do that</span>
<span class="comment-copy">I tried looking at the code and decided it wasn't worth trying to untangle… Nice detective work.</span>
<span class="comment-copy">There is a class diagram in the documentation: <a href="http://rpy.sourceforge.net/rpy2/doc-2.5/html/robjects.html#class-diagram" rel="nofollow noreferrer">rpy.sourceforge.net/rpy2/doc-2.5/html/…</a></span>
<span class="comment-copy">thats good and all but doesnt help too much here .. it doesnt even show rinterface ... even though it is clearly a base class type</span>
<span class="comment-copy">@lgautier: Well, I only got as far as <code>Vector</code> before giving up, so that might have helped me at least cut part the search out… but fortunately, Joran found it in less time than it took me to give up anyway. :)</span>
