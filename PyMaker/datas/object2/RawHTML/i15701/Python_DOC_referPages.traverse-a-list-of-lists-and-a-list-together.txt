<div class="post-text" itemprop="text">
<p>I have a list of lists, well a list whose elements can have an attribute which is a list</p>
<pre><code>a =  [ob1,ob2,ob3,ob4,ob52,ob7,ob8,ob10]
ob52.list = [ob5,ob6]
ob82.list = [ob8,ob9]
</code></pre>
<p>and a list</p>
<pre><code>b= [b1,b2,b3,b4,b5,b6,b7,b8,b9,b10]
</code></pre>
<p>both lists contain 10 elements,ie to say they will <b>always</b> contain the same number of elements.</p>
<p>What I want to do is  <code>ob[i].b = b[i]</code> if <code>ob.has_list == False</code> for all i.<br/>
If <code>ob</code> has a list assign each element of <code>ob[i].list</code> the corresponding <code>b[i]</code></p>
<p>I have solved it like this(quite C'ish),and was wondering if there is a simpler way.</p>
<pre><code>i=0;k=0;j=0
for k in xrange(0,len(a)):
    if k&lt;i:
        continue
    if a[j].has_list:
        for q in a[j].list:
            q.b = b[i]
            i+=1
    else:
        a[j].b = b[i]
        i+=1
    j+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since both lists have the same length when <code>a</code> is flattened, you can flatten <code>a</code>, then you can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a>:</p>
<pre><code>import itertools

flat_a = itertools.chain.from_iterable(
            (e.list if e.has_list else (e,))
                for e in a)

for xa, xb in zip(flat_a, b):
    xa.b = xb
</code></pre>
</div>
<span class="comment-copy">This doesn't work as both lists are not equal in length ,they are equal in length if you include the sub-lists.</span>
<span class="comment-copy">@abstract I have edited my answer to fix that.</span>
<span class="comment-copy">,it looks good.</span>
