<div class="post-text" itemprop="text">
<p>For str.split(line) I'm calling a method on the str class and passing a line object, which happens to be a list full of strings, to the string object?</p>
<p>It seems more clear to me that I should just call the split() method on my line object.</p>
<p>I'm having trouble understanding why both ways work.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you're right that in this case, it's more readable (and more Pythonic, etc.) to just call <code>line.split()</code> than <code>str.split(line)</code>.</p>
<p>But are there any cases where <code>str.split</code> is useful? Sure. Imagine that you had a list of lines, and you wanted to split all of them. Which of these is more readable:</p>
<pre><code>split_lines = map(str.split, lines)
split_lines = map(lambda line: line.split(), lines)
</code></pre>
<p>Because <code>str.split</code> is already a function that works on any <code>str</code>, you don't have to create a new function that works on any <code>str</code> to pass around.</p>
<hr/>
<p>More generally, what you're asking is why Python has "unbound methods".* Partly it's because they just naturally fall out of the design for how methods work in Python.** But mainly, it's because they're handy for passing around to higher-order functions (and because of the idea that absolutely everything should be usable as a value unless there's a good reason not to allow it).</p>
<hr/>
<p>As for the the last part, understanding how they both work, that might be a little involved for an SO answer. You can learn the basics of how they work <a href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="nofollow">in the tutorial</a>; for more details, see <a href="http://stupidpythonideas.blogspot.com/2013/06/how-methods-work.html" rel="nofollow">How methods work</a>, which has links to other useful information. But as a quick summary:</p>
<ul>
<li><code>line.split</code> is a bound method—a callable object that knows what value to pass as the <code>self</code> parameter when you later call it. So, <code>line.split()</code> just calls that bound method with no additional arguments, and <code>line</code> automatically gets passed as the <code>self</code>.</li>
<li><code>str.split</code> is an unbound method—basically just a function. So, <code>str.split(line)</code> explicitly passes <code>line</code> as the <code>self</code>.</li>
</ul>
<hr/>
<p><sub>* Since 3.x, the term "unbound method" has been downplayed, because really, an unbound method is the same thing as a function.</sub></p>
<p><sub>** Guido has explained this a few times; start with his 2009 blog post <a href="http://python-history.blogspot.com/2009/02/first-class-everything.html" rel="nofollow">First-Class Everything</a>.</sub></p>
</div>
<span class="comment-copy">@AlexThornton: No, when called as an unbound method, its first argument is the string to be split itself (the <code>self</code>).</span>
<span class="comment-copy">The first sentence in the question seems wrong. If <code>line</code> is a list full of strings, both <code>str.split(line)</code> and <code>line.split()</code> are going to raise exceptions (a <code>TypeError</code>, because a list isn't a str, and an <code>AttributeError</code>, because lists don't have a <code>split</code> method, respectively). I assume you meant that <code>line</code> is a single string <i>within</i> a list full of strings?</span>
