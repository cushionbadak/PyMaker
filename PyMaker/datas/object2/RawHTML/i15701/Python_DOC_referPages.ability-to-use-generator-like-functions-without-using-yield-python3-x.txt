<div class="post-text" itemprop="text">
<p>There are some cases where its convenient to use a generator with <code>yield</code> to pass back data, to the caller over an extended period. Is there a way to do something similar to <code>yield</code>, without having to make the function into a generator?</p>
<p>The reason for this, is in some cases I end up having to make all callee's into generators when those nested functions may have useful return values.</p>
<pre><code># currently this works fine, but requires a return arg

def nested(return_store):
    return_store[0] = some_test()
    yield from some_generator()

def do_stuff(return_store):

    yield some_data

    for more_data in data:
        yield more_data

    # Annoying workaround!
    return_store = [None]
    yield from nested(return_store)
    if return_store[0]:
        pass  # do anything


def main():
    return Reply(do_stuff())
</code></pre>
<p>Instead I'd like to pass an object as an argument which I can pass arguments to (instead of using yield)</p>
<pre><code># is something like this possible?
def nested(iter_obj):
    iter_obj.yield_replacement(some_generator())
    return some_test()

def do_stuff(iter_obj):

    iter_obj.yield_replacement(some_data)

    for more_data in data:
        iter_obj.yield_replacement(more_data)

    # No annoying workaround
    if nested(iter_obj):
        pass  # do anything

def main():
    iter_obj = yield_replacement_object(consumer=print)
    # sets up the generator (Reply should consume iter_obj)
    do_stuff(iter_obj)
    return Reply(iter_obj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generators are just one form of iterators. Anything that implements the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">iterator protocol</a> will do.</p>
<p>This means you can replace your nested function with an object with more attributes:</p>
<pre><code>class Nested():
    def __iter__:
        self.some_flag = some_test()
        yield data
</code></pre>
<p>I implemented the <code>__iter__</code> method as a generator function even.</p>
<p>Then use the object in your generator at will:</p>
<pre><code>n = Nested()
yield from n
if n.some_flag:
    # ...
</code></pre>
<p>Another method is to throw exceptions; if you are trying to communicate some out-of-band state change, throw an exception and catch it in the parent generator.</p>
</div>
