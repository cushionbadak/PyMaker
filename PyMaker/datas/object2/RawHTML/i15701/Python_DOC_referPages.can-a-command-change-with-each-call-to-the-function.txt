<div class="post-text" itemprop="text">
<pre><code>def drawPoint(direction, x):
    turtle.(direction[x])(1)
    turtle.forward(1)
    x = x + 1
    drawPoint(direction, x%2)       

def main():
     x = 0
     myTurtle = turtle.Turtle()
     myWindow = turtle.Screen()
     direction = ['right', 'left', 'up', 'down']
     drawPoint(direction, x)
</code></pre>
<p>For example I was trying to write turtle.(direction[x]). direction is an array of strings, and the strings are turtle commands. So if I iterated through the direction array it would change the turtle command each time I call drawPoint. </p>
</div>
<div class="post-text" itemprop="text">
<p>I can see what you're trying to do here:</p>
<pre><code>turtle.(direction[x])(1)
</code></pre>
<p>You want to use the string in <code>direction[x]</code> as the name of a method. You probably <em>shouldn't</em> want to do that, but you <em>can</em>. Just not directly; you have to use the <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>getattr</code></a> function:</p>
<pre><code>getattr(turtle, direction[x])(1)
</code></pre>
<hr/>
<p>At any rate, using <code>getattr</code> is usually not a good idea. A better idea is to store the <em>methods</em> in a list, rather than their names. Like one of these:*</p>
<pre><code>direction = [myTurtle.right, myTurtle.left, myTurtle.up, myTurtle.down]
direction = [turtle.Turtle.right, turtle.Turtle.left, turtle.Turtle.up, turtle.Turtle.down]
</code></pre>
<p>The first version creates a list of <em>bound methods</em>, which know what object they're attached to (<code>myTurtle</code>), so you can just call <code>direction[0](1)</code>. The second creates a list of <em>unbound methods</em>, which don't know what object they're attached to; you have to pass it in explicitly like an argument, <code>direction[0](myTurtle, 1)</code>. I think the latter makes more sense in this case, because of the next point, but both are perfectly valid.</p>
<hr/>
<p>You've also got another problem here: <code>turtle</code> isn't your turtle object, it's a module. You need some object to work on, but you don't have one in <code>drawPoint</code>. Fortunately, you're creating one named <code>myTurtle</code> in <code>main</code>, so you just need to pass it in to <code>drawPoint</code>.</p>
<hr/>
<p>And finally, if you want to iterate, use a loop, not a recursive call to yourself. Otherwise, on the 1000th loop, you'll get an exception and your program will quit with an ugly stack trace.**</p>
<hr/>
<p>So:</p>
<pre><code>def drawPoint(myTurtle, direction, x):
    while True:
        direction[x](myTurtle)(1)
        myTurtle.forward(1)
        x = x + 1
        x %= 2

def main():
     x = 0
     myTurtle = turtle.Turtle()
     myWindow = turtle.Screen()
     direction = ['right', 'left', 'up', 'down']
     drawPoint(myTurtle, direction, x)
</code></pre>
<hr/>
<p>One more nifty trick. If you want to loop forever over a list, instead of keeping track of an index and using <code>%</code> to reset back to 0, you can use the <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>cycle</code></a> function. In this case, we only want to cycle over the first two elements of <code>direction</code>, so we'll use a slice:</p>
<pre><code>import itertools

def drawPoint(myTurtle, direction, x):
    for dir in itertools.cycle(direction[:2]):
        dir(myTurtle)(1)
        myTurtle.forward(1)
</code></pre>
<hr/>
<p><sub>* In Python, <em>everything</em> is a first-class valueâ€”modules, classes, objects, functions, bound and unbound methods, etc. That means you can stick it in a list, pass it to a function, whatever you want.</sub></p>
<p><sub>** Every time you call another function, it pushes another frame on the stack. When you return, it pops a frame off the stack. But if your function calls another function before returning, and it calls another function before returning, and so on, you eventually end up overflowing the stack. To avoid the nasty crashes (and security holes) of lower-level languages, Python won't let you get that far, and will raise an exception when you get 1000 deep. (If you're used to another language like, say, Scheme, and this surprises you, that's because Scheme does tail call elimination, while Python doesn't; more generally, Scheme is designed to encourage as much recursion as possible, while Python is designed to discouraged it.)</sub></p>
</div>
