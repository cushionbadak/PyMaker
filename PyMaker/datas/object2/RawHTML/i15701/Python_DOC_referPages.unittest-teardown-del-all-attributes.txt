<div class="post-text" itemprop="text">
<p>I have unit tests with setup and teardown methods which look like this:</p>
<pre><code>def setUp(self):
   self.foo = "bar"
   self.bar = "foo"

def tearDown(self):
   del self.foo
   del self.bar
</code></pre>
<p>Is there a cleaner way to call <code>__del__</code> on every object I instantiate in <code>setUp</code>? If I don't do this then connections to a MySQL database which are opened in <code>setUp</code> (by instantiating those objects) seem to remain open after every test.</p>
<p><em>Ideally</em> I would of course figure out the underlying problem (why those database connections aren't being closed when the test finishes and the test case is discarded). In the meantime though, is there a cleaner way to <code>del</code> all those objects?</p>
<p>The database connections are created using the <code>MySQLdb</code> library, there is also a destructor to close the connection:</p>
<pre><code>class Foo(object):

    def __init__(self,some_credentials):
        self.db_connection = MySQLdb.connect(some_credentials)

    def __del__(self):
        self.db_connection.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The underlying problem here is that each python unit test does not discard the test instance after each test case is run. The instances are kept in memory so any object assigned to self is also kept in memory until the entire suite is complete.</p>
<p>You can reproduce this with the following code. The memory usage will grow with each additional test that is run. If <code>self.large_list</code> is set to <code>None</code> in the <code>teardown</code> then the memory usage remains consistent.</p>
<pre><code>import resource
import unittest
import uuid


class TestSelfGarbageCollection(unittest.TestCase):

    def setUp(self):
        # Create an object that will use lots of memory
        self.large_list = []
        for _ in range(300000):
            self.large_list.append(uuid.uuid4())

    def tearDown(self):
        # Without the following line a copy of large_list will be kept in
        # memory for each test that runs, uncomment the line to allow the
        # large_list to be garbage collected.
        # self.large_list = None
        mb_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1000
        print("Memory usage: %s MB" % mb_memory)

    def test_memory1(self):
        pass

    def test_memory2(self):
        pass

    def test_memory3(self):
        pass

    def test_memory4(self):
        pass

    def test_memory5(self):
        pass
</code></pre>
<p>Run with:</p>
<pre><code>py.test test_large_memory.py -s -v
</code></pre>
<p>The simplest solution is to explicitly cleanup any large objects assigned to <code>self</code> or any objects that need cleanup (eg. database connections) in <code>tearDown</code>.</p>
<p><strong>References:</strong><br/>
<a href="https://chrisbailey.blogs.ilrt.org/2013/05/19/pythons-leaky-testcase-aka-hidden-gotchas-using-self/" rel="noreferrer">Pythonâ€™s leaky TestCase</a><br/>
<a href="http://bugs.python.org/issue11798" rel="noreferrer">Issue 11798: Test cases not garbage collected after run - Python tracker</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to delete all those attributes at all.</p>
<p>The <code>TestCase</code> instance will eventually be discarded after the <code>tearDown</code>; each test is run with a fresh, clean, shiny and above all <em>empty</em> new instance. Any attributes on the instance will be cleared, reference counts will drop once the test suite has run and if the instance was the only reference to those values, they'll be gone from memory.</p>
<p>Quoting from the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" rel="nofollow"><code>unittest.TestCase()</code> documentation</a>:</p>
<blockquote>
<pre><code>class unittest.TestCase(methodName='runTest')
</code></pre>
<p>Instances of the <code>TestCase</code> class represent the smallest testable units in the unittest universe. [...]. <strong>Each instance of <code>TestCase</code> will run a single test method</strong>: the method named <em>methodName</em>.</p>
</blockquote>
<p><em>Emphasis mine</em>; a test runner will create these instances, passing in the name of the test method to run; if you have methods <code>test_foo</code> and <code>test_bar</code>, instances will be created passing in those names.</p>
<p>Do use the <code>tearDown</code> to clear up things <em>outside</em> the test instance; delete temporary files, remove mock patches, close database connections, etc. <code>TestCase</code> instances are only going to be finalised (removed from memory) once all tests have run, as the test runner may want to access each test later on to provide detail about them at the end of a full suite run.</p>
</div>
<div class="post-text" itemprop="text">
<p>I always run <code>teardown(self)</code> when I have <code>setUp(self)</code>. This keeps prevents 'kill 9' errors from too much memory being accumulated. By setting variables to <code>None</code>, the total memory is cleared after every unittest.</p>
<pre><code>class TestExample(unittest.TestCase):
    def setUp(self):
        self.example_var = "some small or large amount of data"

    def teardown(self):
        self.example_var = None
</code></pre>
</div>
<span class="comment-copy">Are you actually seeing a difference in behavior with and without the tearDown? As Martijn points out, your object is destroyed after each test, so you should not need to delete attributes.</span>
<span class="comment-copy">"If I don't do this objects proliferate in memory." - Can you post the reason you think that? It sounds like something else may be the problem here (if it really is happening).</span>
<span class="comment-copy">Python isn't <code>C</code> and <code>del</code> isn't <code>free()</code>. Python has a garbage collector via ref-counting. Don't mix the two.</span>
<span class="comment-copy">@NedBatchelder Yes I am - I have added more detail to my question.</span>
<span class="comment-copy">If your object needs some cleaning up between uses, that is exactly the point of tearDown.</span>
<span class="comment-copy">Thanks for the answer. I've added some more detail of the problem in my question. The instantiation of each test is unfortunately causing some negative side-effects (open database connections) which I don't yet fully understand.</span>
<span class="comment-copy">Can you create a repeatable small sample that shows how you create the database connection?</span>
<span class="comment-copy">Yes, I've added some detail, thanks.</span>
<span class="comment-copy">@MikeVella: how certain are you that the test case is the <i>only</i> reference to the <code>Foo</code> instance? You could use <a href="https://docs.python.org/3/library/gc.html#gc.get_referrers" rel="nofollow noreferrer"><code>gc.get_referrers()</code></a> to try and track down any other references to the object, in the <code>tearDown</code>, for example.</span>
<span class="comment-copy">In case of using large objects, which is more expensive in the tearDown(), to <code>del some_large_object</code> or <code>some_large_object = None</code>. In general, for garbage collection it does not make any difference but with respect to Python unittest, does it have any advantage of using one over the other?</span>
