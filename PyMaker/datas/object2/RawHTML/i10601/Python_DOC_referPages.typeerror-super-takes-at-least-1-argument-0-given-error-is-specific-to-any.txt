<div class="post-text" itemprop="text">
<p>I'm getting this error</p>
<blockquote>
<p>TypeError: super() takes at least 1 argument (0 given)</p>
</blockquote>
<p>using this code on python2.7.11: </p>
<pre><code>class Foo(object):
    def __init__(self):
        pass

class Bar(Foo):
    def __init__(self):
        super().__init__()

Bar()
</code></pre>
<p>The workaround to make it work would be:</p>
<pre><code>class Foo(object):
    def __init__(self):
        pass

class Bar(Foo):
    def __init__(self):
        super(Bar, self).__init__()

Bar()
</code></pre>
<p>It seems the syntax is specific to python 3. So, what's the best way to provide compatible code between 2.x and 3.x and avoiding this error happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the 0-argument syntax is specific to Python 3, see <a href="https://docs.python.org/3/whatsnew/3.0.html#builtins" rel="noreferrer"><em>What's New in Python 3.0</em></a> and <a href="https://www.python.org/dev/peps/pep-3135/" rel="noreferrer">PEP 3135 -- <em>New Super</em></a>.</p>
<p>In Python 2 and code that must be cross-version compatible, just stick to passing in the class object and instance explicitly. </p>
<p>Yes, there are "backports" available that make a no-argument version of <code>super()</code> work in Python 2 (like the <code>future</code> library) but these require a number of hacks that include a <a href="https://github.com/PythonCharmers/python-future/blob/master/src/future/builtins/newsuper.py" rel="noreferrer">full scan of the class hierarchy</a> to find a matching function object. This is both fragile and slow, and simply not worth the "convenience". </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://pypi.python.org/pypi/future" rel="nofollow">future</a> library to have a Python2/Python3 compatibility.</p>
<p>The <a href="http://python-future.org/reference.html?highlight=super" rel="nofollow">super</a> function is back-ported.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because of version of python. Check your python version with [python --version] it might be 2.7</p>
<pre><code>In 2.7 use this [ super(baseclass, self).__init__() ]
</code></pre>
<hr/>
<pre><code>class Bird(object):
    def __init__(self):
        print("Bird")

    def whatIsThis(self):
        print("This is bird which can not swim")

class Animal(Bird):
    def __init__(self):
        super(Bird,self).__init__()
        print("Animal")

    def whatIsThis(self):
        print("THis is animal which can swim")

a1 = Animal()
a1.whatIsThis()
</code></pre>
<hr/>
<pre><code>&gt; In 3.0 or more use this [ super().__init__()]
</code></pre>
<hr/>
<pre><code>class Bird(object):
    def __init__(self):
        print("Bird")

    def whatIsThis(self):
        print("This is bird which can not swim")

class Animal(Bird):
    def __init__(self):
        super().__init__()
        print("Animal")

    def whatIsThis(self):
        print("THis is animal which can swim")

a1 = Animal()
a1.whatIsThis()
</code></pre>
</div>
<span class="comment-copy">That syntax is for Python 3.</span>
<span class="comment-copy">@DanielRoseman I see, thanks. To make my question a little bit more useful then I've edited a little bit asking some extra stuff</span>
<span class="comment-copy">The Python 2 syntax is still valid in Python 3 in this case; if you want to support both versions, use that. Note however that there are lots of other incompatibilities between the versions.</span>
<span class="comment-copy">@DanielRoseman Alright, tyvm. All clear then :)</span>
<span class="comment-copy">Oh boy, but that implementation.  Stack frame inspection and a full traverse of the namespaces of the MRO to find the context? I can't recommend actually using this.</span>
<span class="comment-copy">Just use <code>super(ClassName, self)</code> and repeat yourself a little.</span>
