<div class="post-text" itemprop="text">
<p>What is the Pythonic/quick way to search for a partial string in an array and then remove that string from the array?<br/>
(I can do it with a simple loop and IF IN and rebuild two array in the loop, Asking if there is a Pythonic way/function to do this)</p>
<p>Example:  </p>
<pre><code>array = ['rule1','rule2','exception[type_a]','rule3','exception[type_b]']
res(,)=remove_exceptions(array,'exception')
print(res[0]) &gt;&gt;&gt; ['rule1','rule2','rule3']
print(res[1]) &gt;&gt;&gt; ['exception[type_a]','exception[type_b]']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; [x for x in array if 'exception' not in x]
['rule1', 'rule2', 'rule3']
&gt;&gt;&gt; [x for x in array if 'exception' in x]
['exception[type_a]', 'exception[type_b]']
</code></pre>
<p>See also: <a href="https://stackoverflow.com/questions/949098/python-split-a-list-based-on-a-condition">Python: split a list based on a condition?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to separate your items you can do it with one loop and by preserving the items in a dictionary:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for i in array:
...     if 'exception' in i:
...         d.setdefault('exception', []).append(i)
...     else:
...         d.setdefault('other', []).append(i)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; d
{'exception': ['exception[type_a]', 'exception[type_b]'], 'other': ['rule1', 'rule2', 'rule3']}
</code></pre>
<p>You can access to separated items by calling the values of the dictionary:</p>
<pre><code>&gt;&gt;&gt; d.values()
[['exception[type_a]', 'exception[type_b]'], ['rule1', 'rule2', 'rule3']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seriously, just use a <code>for</code> loop, you're trying to create <em>two</em> lists so a single comprehension won't do (i.e the top solution so far iterates <em>twice</em> over the same list).</p>
<p>Create two lists and append to them conditionally:</p>
<pre><code>l1 = list()
l2 = list()
for i in array:
    l1.append(i) if 'exception' in i else l2.append(i)

print(l1)
['exception[type_a]', 'exception[type_b]']
print(l2)
['rule1', 'rule2', 'rule3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For list-of-strings <code>array</code> and thing-to-exclude <code>target</code>:</p>
<p>List comprehensions work:</p>
<pre><code>result = [s for s in array if target not in s]
</code></pre>
<p>Or a generator comprehension for the same:</p>
<pre><code>result = (s for s in array if target not in s)
</code></pre>
<p>(<code>in</code> is effectively a contains operator, and <code>not in</code> is the inverse.)</p>
<p>Alternately, use the <code>filter()</code> <a href="https://docs.python.org/3.5/library/functions.html#filter" rel="nofollow">built-in</a> with a lambda:</p>
<pre><code>result = filter(lambda x: target not in x,
                array)
</code></pre>
<p>Either one returns a new object, rather than modifying your original list. The list comprehension returns a list, <code>filter()</code> returns a generator but you can wrap the call in <code>list()</code> if you need random access.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use in-built <code>filter</code> with <code>lambda</code> function to achieve this as:</p>
<pre><code>&gt;&gt;&gt; my_array = array = ['rule1','rule2','exception[type_a]','rule3','exception[type_b]']
&gt;&gt;&gt; my_string = 'exception'
&gt;&gt;&gt; filter(lambda x: my_string not in x, my_array)
['rule1', 'rule2', 'rule3']
</code></pre>
</div>
<span class="comment-copy">You want to just remove them or you want to extract them from your list?</span>
<span class="comment-copy">Iterating over your list and creating two new lists in the loop suite is Pythonic.  If the list elements are as you represented, you could make use of the <a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer"><code>str.startswith</code></a> method.</span>
<span class="comment-copy">@Kasramvd either would work for me</span>
<span class="comment-copy">@ItayMoav-Malimovka Check out my answer.</span>
<span class="comment-copy">@Kasramvd while this is what I currently (almost) use, my question was if there is a built in function/language construct (Pythonic way) to do it more efficiently (either less text/faster).</span>
<span class="comment-copy">"a single comprehension won't do" I feel like there must be a way to do this with co-routines and a couple of <code>deque</code>s, so that you only pass over the list once, but use the minimal possible additional memory. As against that, like you say, seriously just use a for loop. Especially when the desired result is two lists, just make two lists :-)</span>
<span class="comment-copy">What makes this Pythonic?</span>
<span class="comment-copy">It is Pythonic because of the usage of inbuilt functions that Python provides and perfectly suits the requirement. That says, there is no need to do list comprehension. Now my question to you: What makes it non Pythonic?</span>
<span class="comment-copy">Comprehensions are (arguably) more readable. See <a href="http://stackoverflow.com/a/3013722/1936320">http://stackoverflow.com/a/3013722/1936320</a></span>
<span class="comment-copy">I was curious why this was pythonic or more pythonic than just iterating over the list with a for loop and testing the elements in order to separate them.</span>
<span class="comment-copy">In an ideal world you'd write <code>filter(not x.contains, my_array)</code>, but they're not offering us that ;-)</span>
