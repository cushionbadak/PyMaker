<div class="post-text" itemprop="text">
<p>I've configuration files some formatted as <code>json</code> some formatted as <code>yaml</code>. I want to be able to read those configuration files with values which comes as environment variables. for example:</p>
<pre><code>{"username":"Dan", "password":"&lt;%= ENV['DB_PASSWORD']%&gt;"}
</code></pre>
<p>Which means that password is retrieved when loading the json file from environment variable and replace the <code>&lt;%= ENV['DB_PASSWORD']%&gt;</code> with concrete value.</p>
<p><strong>Note:1. The syntax mentioned above is like it is being used using ruby's erb only for illustration
       2. I prefer a solution of native python without installing new python packages, but if there no such ,I'll accept this also.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is commonly called <em>templating</em>, and you have basically defined a <em>template language</em>.</p>
<p>Depending on what <em>exactly</em> you want to do, you can use the <a href="https://docs.python.org/3/library/string.html#template-strings" rel="nofollow"><code>string.Template</code></a> library from the stdlib. It only does simple variable substitutions, though, as opposed to ERb, which allows <em>arbitrary</em> code (including code that deletes all your data, formats your harddisk, starts a backdoor, â€¦).</p>
<p>So, <code>string.Template</code> is both <em>much</em> less powerful than ERb, but also <em>much</em> safer. Your example already demonstrates this, as you cannot even access environment variables from within a template, you would have to pass them in explicitly.</p>
<p>This is the basic usage:</p>
<pre><code>from string import Template

s = Template('{"username": "Dan", "password": "$db_password"}')

s.safe_substitute(db_password = 's00persekrit')
# &gt;&gt;&gt; {"username": "Dan", "password": "s00persekrit"}
</code></pre>
<p>As accessing environment variables isn't possible inside the template, you will have to pass them in to the template explicitly:</p>
<pre><code>from string import Template
from os import environ as env

s = Template('{"username": "Dan", "password": "$db_password"}')

s.safe_substitute(db_password = env['DB_PASSWORD'])
# &gt;&gt;&gt; {"username": "Dan", "password": "s00persekrit"}
</code></pre>
<p>Actually, if you want to give the template access to all environment variables, you should be able to pass the <code>os.environ</code> dict directly (you can pass any <code>dict</code>-like object for the mapping).</p>
<pre><code>from string import Template
from os import environ as env

s = Template('{"username": "Dan", "password": "$DB_PASSWORD"}')

s.safe_substitute(env)
# &gt;&gt;&gt; {"username": "Dan", "password": "s00persekrit"}
</code></pre>
<p>If you want some more powerful substitutions, then you should look at some other so-called "logic-less" template languages (i.e. languages which only perform simple substitutions but don't allow executing code, and don't allow conditionals or loops). One of those languages is <a href="http://mustache.github.io/" rel="nofollow">Mustache</a> (the templating language used by GitHub), there are implementations in many languages, including <a href="https://github.com/defunkt/pystache/" rel="nofollow">Pystache for Python</a>.</p>
<p>If you want / need more advanced features such as loops, conditionals, etc., you might need to look for more full-featured <a href="https://wiki.python.org/moin/Templating" rel="nofollow">template languages</a> such as <a href="http://jinja.pocoo.org/" rel="nofollow">Jinja</a>.</p>
</div>
