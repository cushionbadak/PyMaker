<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/11125212/interleaving-lists-in-python">Interleaving Lists in Python [duplicate]</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I have two lists:</p>
<pre><code>a = ['a', 'b', 'c', 'd']
b = ['e', 'f', 'g', 'h']
</code></pre>
<p>which I want to merge to one list which contains element nr. 1 of list a as first element, element nr.1 of list b as second element, element nr. 2 of list a as third element and so on, looking like this:</p>
<pre><code>c = ['a', 'e', 'b', 'f', 'c', 'g', 'd', 'h']
</code></pre>
<p>What is the easiest way to do so, possibly without using loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/3/library/functions.html#zip"><code>zip</code></a> them into pairs and then flatten the list using <a href="https://docs.python.org/3.5/library/itertools.html#itertools.chain.from_iterable"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>In [1]: a=['a','b','c','d']

In [2]: b=['e','f','g','h']

In [3]: from itertools import chain

In [4]: chain.from_iterable(zip(a, b))
Out[4]: &lt;itertools.chain at 0x7fbcf2335ef0&gt;

In [5]: list(chain.from_iterable(zip(a, b)))
Out[5]: ['a', 'e', 'b', 'f', 'c', 'g', 'd', 'h']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an answer comparing some of the possible methods with 2 differents datasets, one will consist of many little arrays, the other one will be few large arrays:</p>
<p>import timeit
    import random
    from itertools import chain</p>
<pre><code>def f1(a, b):
    return list(chain.from_iterable(zip(a, b)))


def f2(a, b):
    return list(sum(zip(a, b), ()))


def f3(a, b):
    result = []
    for (e1, e2) in zip(a, b):
        result += [e1, e2]

    return result


def f4(a, b):
    result = []
    len_result = min(len(a), len(b))

    result = []
    i = 0
    while i &lt; len_result:
        result.append(a[i])
        result.append(b[i])
        i += 1

    return result

# Small benchmark
N = 5000000
a_small = ['a', 'b', 'c', 'd']
b_small = ['e', 'f', 'g', 'h']
benchmark1 = [
    timeit.timeit(
        'f1(a_small, b_small)', setup='from __main__ import f1, a_small,b_small', number=N),
    timeit.timeit(
        'f2(a_small, b_small)', setup='from __main__ import f2, a_small,b_small', number=N),
    timeit.timeit(
        'f3(a_small, b_small)', setup='from __main__ import f3, a_small,b_small', number=N),
    timeit.timeit(
        'f4(a_small, b_small)', setup='from __main__ import f4, a_small,b_small', number=N)
]

for index, value in enumerate(benchmark1):
    print " - Small sample with {0} elements -&gt; f{1}={2}".format(len(a_small), index + 1, value)

# Large benchmark
N = 5000
K = 100000
P = 1000
a_large = random.sample(range(K), P)
b_large = random.sample(range(K), P)
benchmark2 = [
    timeit.timeit(
        'f1(a_large, b_large)', setup='from __main__ import f1, a_large,b_large', number=N),
    timeit.timeit(
        'f2(a_large, b_large)', setup='from __main__ import f2, a_large,b_large', number=N),
    timeit.timeit(
        'f3(a_large, b_large)', setup='from __main__ import f3, a_large,b_large', number=N),
    timeit.timeit(
        'f4(a_large, b_large)', setup='from __main__ import f4, a_large,b_large', number=N)
]

for index, value in enumerate(benchmark2):
    print " - Large sample with {0} elements -&gt; f{1}={2}".format(K, index + 1, value)
</code></pre>
<ul>
<li>Small sample with 4 elements -&gt; f1=7.50175959666</li>
<li>Small sample with 4 elements -&gt; f2=5.52386084127</li>
<li>Small sample with 4 elements -&gt; f3=7.12457549607</li>
<li>Small sample with 4 elements -&gt; f4=7.24530968309</li>
<li>Large sample with 100000 elements -&gt; f1=0.512278885906</li>
<li>Large sample with 100000 elements -&gt; f2=28.0679210232</li>
<li>Large sample with 100000 elements -&gt; f3=1.05977378475</li>
<li>Large sample with 100000 elements -&gt; f4=1.17144886156</li>
</ul>
<p>Conclusion: It seems f2 function is the slightly faster method when N is big and the lists are litte. When the arrays are large and the number is little, f1 is the winner though.</p>
<p>Specs: Python2.7.11(64) , N=5000000 on a i-7 2.6Ghz</p>
</div>
<span class="comment-copy">Because question has been closed I won't be able to post my benchmark but the fastest answer so far is this <code>list(sum(zip(a, b), ()))</code></span>
<span class="comment-copy">@BPL Looking forward to your benchmarks, requesting to reopen the question</span>
<span class="comment-copy">@soon Thanks! sometimes admins should give a little bit more time, even if they are duplicated questions... You always can find some guys posting new interesting data adding value to the question ;)</span>
<span class="comment-copy">@soon Ok, I've had the chance to post my little research ;) . Btw, where is it the button to request reopning questions? I didn't know that was even possible (newbie on SO here)</span>
<span class="comment-copy">@BPL You'll be able to cast close and reopen votes after reaching 3k rep. <a href="http://stackoverflow.com/help/privileges/close-questions">Docs</a></span>
<span class="comment-copy">Could you also add benchmarks for large lists?</span>
<span class="comment-copy">@soon Thanks to point it out, I've edited my answer and the benchmark is now a little bit more complete</span>
