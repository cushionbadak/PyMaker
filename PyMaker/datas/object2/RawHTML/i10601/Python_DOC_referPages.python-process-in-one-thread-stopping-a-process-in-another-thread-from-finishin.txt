<div class="post-text" itemprop="text">
<p>I'd appreciate some help with threading, which I pretty new to. </p>
<p>The example code is not exactly what I’m doing (‘notepad’ and ‘calc’ are just example commands), but a simplified version that shows my problem.</p>
<p>I want to run two seperate threads that each run a different command a number of times. I would like the code to do this:</p>
<ol>
<li>Start the first instance of ‘notepad’ and ‘calc’ simultaneously
(which it does) </li>
<li>When I close an instance of ‘notepad’, to open the
next instance of ‘notepad’. </li>
<li>When I close an instance of ‘calc’, to
open the next instance of ‘calc’.</li>
<li>[edit] I want the script to wait until both threads have finished, as it needs to do some processing of the output from these.</li>
</ol>
<p><strong>However, when I close an instance of ‘notepad’, the next instance of ‘notepad’ does not start until I’ve closed the current instance of ‘calc’ and vice versa.</strong> With a bit of de-bugging, it looks like the process (from Popen) for the closed instance of 'notepad' doesn't finish until the current 'calc' is closed.</p>
<p>Running Python 2.7 on Windows 7</p>
<p>Example Code:</p>
<pre><code>from subprocess import Popen, PIPE, STDOUT
from threading import Thread

def do_commands(command_list):

    for command in command_list:
        proc = Popen("cmd.exe", stdin=PIPE, stdout=PIPE, stderr=STDOUT)
        stdout_value, stderr_value = proc.communicate(input=command)

# MAIN CODE
A_command_list = ["notepad\n", "notepad\n", "notepad\n" ]
B_command_list = ["calc\n", "calc\n", "calc\n" ]

A_args = [A_command_list]
B_args = [B_command_list]

A_thread = Thread(target=do_commands, args=(A_args))
B_thread = Thread(target=do_commands, args=(B_args))

A_thread.start()
B_thread.start()

A_thread.join()
B_thread.join()
</code></pre>
<p>Thanks in advance :-)</p>
<p>Nick</p>
</div>
<div class="post-text" itemprop="text">
<p>So the <code>communicate()</code> method is apparently waiting for all processes created by <code>Popen</code> and executing <code>cmd.exe</code> <strong>and started at nearly the same time</strong> to terminate. Since the <code>cmd.exe</code> that runs <code>calculator</code> starts at nearly the same time as the <code>cmd.exe</code> that runs <code>Notepad</code>, both <code>communicate()</code> calls (one in <code>A_thread</code> and one in <code>B_thread</code>) wait until both processes term. Thus neither <code>for</code> loop advances until both processes term.</p>
<p>Adding a delay between starting the two threads fixes the problem. </p>
<p>So, leaving your original code unchanged and adding  </p>
<pre><code>sleep(1)
</code></pre>
<p>between the two <code>Thread</code> <code>starts</code> produces the desired behavior.</p>
<p>On my system, adding a delay of 0.0001 seconds reliably fixed the problem whereas a delay of 0.00001 did not.</p>
</div>
<span class="comment-copy">instead of using <code>Popen</code> and <code>communicate</code> to launch a cmd, couldn't you just launch the actual executables? Like <code>subprocess.call(['notepad.exe'])</code>? (I don't have Windows so you'll have to find the exact name you have to use).</span>
<span class="comment-copy">@Bakuriu - thanks for the input. I considered using call, but I need the stdout and stderr and the documentation says "Note Do not use stdout=PIPE or stderr=PIPE with this function as that can deadlock based on the child process output volume. Use Popen with the communicate() method when you need pipes."</span>
<span class="comment-copy">@NickFromage If you need stdout you may want to use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>check_output</code></a>. Is basically <code>call</code>+<code>stdout=PIPE</code> that uses <code>communicate</code> to obtain the output.</span>
<span class="comment-copy">@Bakuriu - Thanks. I've tried it with check_output instead of Popen/communicate. It runs the same, but also has the same problem (needs the 'sleep' command to stop it waiting for both processes to end). check_output does seem a bit neater, so I'll try using it in future. :-)</span>
<span class="comment-copy">I don't really understand why that <code>sleep</code> hack is needed. If I have time I'll try to think about that. In any case I believe that what <code>sleep</code> is doing is simply triggering the scheduler.</span>
<span class="comment-copy">The "sleep(1)" seems to work.Thanks very much for your help :-)</span>
