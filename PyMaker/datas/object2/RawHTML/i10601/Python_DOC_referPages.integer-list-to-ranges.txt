<div class="post-text" itemprop="text">
<p>I need to convert a list of ints to a string containing all the ranges in the list.
So for example, the output should be as follows:</p>
<pre><code>getIntRangesFromList([1,3,7,2,11,8,9,11,12,15]) -&gt; "1-3,7-9,11-12,15"
</code></pre>
<p>So the input is not sorted and there can be duplicate values. The lists range in size from one element to 4k elements. The minimum and maximum values are 1 and 4094.</p>
<p>This is part of a performance critical piece of code. I have been trying to optimize this, but I can't find a way to get this faster. This is my current code:</p>
<pre><code>def _getIntRangesFromList(list):
    if (list==[]):
        return ''
    list.sort()
    ranges = [[list[0],list[0]]] # ranges contains the start and end values of each range found
    for val in list:
        r = ranges[-1]
        if val==r[1]+1:
            r[1] = val
        elif val&gt;r[1]+1:
            ranges.append([val,val])
    return ",".join(["-".join([str(y) for y in x]) if x[0]!=x[1] else str(x[0]) for x in ranges])
</code></pre>
<p>Any idea on how to get this faster?</p>
</div>
<div class="post-text" itemprop="text">
<p>This could be a task for the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> module.</p>
<pre><code>import itertools

list_num = [1, 2, 3, 7, 8, 9, 11, 12, 15]
groups = (list(x) for _, x in
          itertools.groupby(list_num, lambda x, c=itertools.count(): x - next(c)))
print(', '.join('-'.join(map(str, (item[0], item[-1])[:len(item)])) for item in groups))
</code></pre>
<p>This will give you <code>1-3, 7-9, 11-12, 15</code>.</p>
<p>To understand what's going on you might want to check the content of <code>groups</code>.</p>
<pre><code>import itertools
list_num = [1, 2, 3, 7, 8, 9, 11, 12, 15]

groups = (list(x) for _, x in
          itertools.groupby(list_num, lambda x, c=itertools.count(): x - next(c)))
for element in groups:
    print('element={}'.format(element))
</code></pre>
<p>This will give you the following output.</p>
<pre><code>element=[1, 2, 3]
element=[7, 8, 9]
element=[11, 12]
element=[15]
</code></pre>
<p>The basic idea is to have a counter running parallel to the numbers. <code>groupby</code> will create individual groups for numbers with the same numerical distance to the current value of the counter.</p>
<p>I don't know whether this is faster on your version of Python. You'll have to check this yourself. In my setting it's slower with this data set, but faster with a bigger number of elements.</p>
</div>
<div class="post-text" itemprop="text">
<p>The fastest one I could come up, which tests about 10% faster than your solution on my machine (according to timeit):</p>
<pre><code>def _ranges(l):
  if l:
    l.sort()
    return ''.join([(str(l[i]) + ('-' if l[i] + 1 == l[i + 1] else ',')) 
                    for i in range(0, len(l) - 1) if l[i - 1] + 2 != l[i + 1]] +
                   [str(l[-1])])
  else: return ''
</code></pre>
<p>The above code assumes that the values in the list are unique. If they aren't, it's easy to fix but there's a subtle hack which will no longer work and the end result will be slightly slower.</p>
<p>I actually timed <code>_ranges(u[:])</code> because of the sort; u is 600 randomly selected integers from range(1000) comprising 235 subsequences; 83 are singletons and 152 contain at least two numbers. If the list is sorted, quite a lot of time is saved.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def _to_range(l, start, stop, idx, result):
    if idx == len(l):
        result.append((start, stop))
        return result
    if l[idx] - stop &gt; 1:
        result.append((start, stop))
        return _to_range(l, l[idx], l[idx], idx + 1, result)
    return _to_range(l, start, l[idx], idx + 1, result)

def get_range(l):
    if not l:
        return []
    return _to_range(l, start = l[0], stop = l[0], idx = 0, result = [])

l = [1, 2, 3, 7, 8, 9, 11, 12, 15]
result = get_range(l)
print(result) 
&gt;&gt;&gt; [(1, 3), (7, 9), (11, 12), (15, 15)]
# I think it's better to fetch the data as it is and if needed, change it 
# with
print(','.join('-'.join([str(start), str(stop)]) for start, stop in result))
&gt;&gt;&gt; 1-3,7-9,11-12,15-15
</code></pre>
<p>Unless you don't care at all about the data, then u can just append str(start) + '-' + str(stop) in _to_range function so later there will be no need to type extra '-'.join method.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll concentrate on the performance that is your main issue. I'll give 2 solutions:</p>
<p>1) If the boundaries of the integers stored is between A and B, and you can create an array of booleans(even you can choose an array of bits for expanding the range you can storage) with (B - A + 2) elements, e.g. A = 0 and B = 1 000 000, we can do this (i'll write it in C#, sorry XD). This run in O(A - B) and is a good solution if A - B is less than the number of numbers:</p>
<pre><code>public string getIntRangesFromList(int[] numbers)
    {
        //You can change this 2 constants
        const int A = 0;    
        const int B = 1000000;

        //Create an array with all its values in false by default
        //Last value always will be in false in propourse, as you can see it storage 1 value more than needed for 2nd cycle 
        bool[] apparitions = new bool[B - A + 2];
        int minNumber = B + 1;
        int maxNumber = A - 1;
        int pos;
        for (int i = 0; i &lt; numbers.Length; i++)
        {
            pos = numbers[i] - A;
            apparitions[pos] = true;

            if (minNumber &gt; pos)
            {
                minNumber = pos;
            }
            if (maxNumber &lt; pos)
            {
                maxNumber = pos;
            }
        }

        //I will mantain the concatenation simple, but you can make it faster to improve performance
        string result = "";
        bool isInRange = false;
        bool isFirstRange = true;
        int firstPosOfRange = 0; //Irrelevant what is its initial value
        for (int i = minNumber; i &lt;= maxNumber + 1; i++)
        {
            if (!isInRange)
            {
                if (apparitions[i])
                {
                    if (!isFirstRange)
                    {
                        result += ",";
                    }
                    else
                    {
                        isFirstRange = false;
                    }

                    result += (i + A);
                    isInRange = true;
                    firstPosOfRange = i;
                }
            }
            else
            {
                if (!apparitions[i])
                {
                    if (i &gt; firstPosOfRange + 1)
                    {
                        result += "-" + (i + A - 1);
                    }
                    isInRange = false;
                }
            }
        }

        return result;
    }
</code></pre>
<p>2) O(N * log N)</p>
<pre><code>    public string getIntRangesFromList2(int[] numbers)
    {
        string result = "";

        if (numbers.Length &gt; 0)
        {
            numbers.OrderBy(x =&gt; x); //sorting and making the algorithm complexity O(N * log N)
            result += numbers[0];
            int countNumbersInRange = 1;
            for (int i = 1; i &lt; numbers.Length; i++)
            {
                if (numbers[i] != numbers[i - 1] + 1)
                {
                    if (countNumbersInRange &gt; 1)
                    {
                        result += "-" + numbers[i - 1];
                    }

                    result += "," + numbers[i];
                    countNumbersInRange = 1;
                }
                else
                {
                    countNumbersInRange++;
                }
            }
        }

        return result;
    }
</code></pre>
</div>
<span class="comment-copy">belongs on <a href="http://codereview.stackexchange.com/">codereview.stackexchange.com</a> if it works</span>
<span class="comment-copy">Looks to be linear time, assuming <code>join()</code> is internally implemented to also be linear time.  You might be able to reduce the constant factor (e.g. by coding in C), but nothing can be asymptotically faster.</span>
<span class="comment-copy">Takes about 0.000006 seconds for me. That's not good enough? How fast does it need to be?</span>
<span class="comment-copy">@depperm Can you post a reference to that?</span>
<span class="comment-copy">@depperm This is not a general review question where the poster wants to "improve overall code quality and style". This is a specific question and it is still on topic <a href="http://meta.stackoverflow.com/questions/300981/performance-question-stack-overflow-or-code-review">here</a>.</span>
<span class="comment-copy">@Downvoter: Care to explain?</span>
<span class="comment-copy">looks scary for people who don't know Python, silly isn't it. Have an upvote.</span>
<span class="comment-copy">Is this at least faster on <b>your</b> version of Python? I highly doubt it.</span>
<span class="comment-copy">Thanks for the answer! I tried it, on my device this solution takes about 20 times as much time as my solution.</span>
<span class="comment-copy">Whoa. According to the tests on my machine (Python 3.4.1 32bit) my solution is 50% slower for those elements, but if the list gets bigger my solution is slightly faster.</span>
<span class="comment-copy">Do you have evidence that this is faster than OP's original? If so, why?</span>
<span class="comment-copy">Your output ends wrong.</span>
<span class="comment-copy">For what data? (I hope you've did it on sorted list)</span>
<span class="comment-copy">@Nf4r Who are you talking to? Me? In that case: I didn't do it at all. You yourself showed that your output ends with <code>,15-15</code>. Not with the requested <code>,15</code>.</span>
<span class="comment-copy">Your second solution does not seem to be significantly different from OP's solution, modulo the choice of a different programming language.</span>
