<div class="post-text" itemprop="text">
<p>Suppose I have a multi-line string which may contain lines consisting of a single file name. I want to print each line in the string, unless the line is a file name (defined here as ending in '.txt'), in which case I want to print each line in that file, unless the line in that file is a file name etc.</p>
<p>My initial approach is to use a helper function as follows:</p>
<pre><code>def deep_print_helper(file_path, line_sep):
    with open(file_path) as f:
        text = f.read()
        return deep_print(text, line_sep)

def deep_print(s, line_sep):
    lines = s.split(line_sep)
    for l in lines:
        if l.endswith('.txt'):
            deep_print_helper(l, line_sep)
        else:
            print(l)
</code></pre>
<p>But having to pass <code>line_sep</code> to the helper function only to pass it back again seems inelegant. </p>
<p>So I tried an approach that uses only one function:</p>
<pre><code>def deep_print(line_sep, s='', file_path=''):
    if file_path:
        with open(file_path) as f:
            s = f.read()
    lines = s.split(line_sep)
    for l in lines:
        if l.endswith('.txt'):
            deep_print(line_sep, file_path=l)
        else:
            print(l)
</code></pre>
<p>This has an implicit required argument (either <code>s</code> or <code>file_path</code> but not both), but since the user of the function will only use one form (<code>s=</code>) it may not be too kludgey. It also seems a little odd from a user's perspective that <code>line_sep</code> is the first argument.</p>
<p>Which approach is a better design? Is there another approach I should consider?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your question should not be related to Pythonic way to achieve this. It is related to the design, independent of language. If you ask me among the two approaches, I'll go with <code>1</code>. But the better way to achieve is via class having your functions within it. In Python you may do it like:</p>
<pre><code>class DeepPrint(object):
    def __init__(self, file_path):
        DeepPrint._deep_print_helper(file_path)

    @staticmethod
    def _deep_print_helper(file_path):
        with open(file_path) as f:
            return DeepPrint._deep_print(f)

    @staticmethod
    def _deep_print(f):
        for l in f.readlines():
            if l.endswith('.txt'):
                DeepPrint._deep_print_helper(l)
            else:
                print(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To avoid passing the <code>line_sep</code> parameter, you can define the helper function inside the recursive function:</p>
<pre><code>def deep_print(s, line_sep):

    def deep_print_helper(file_path):
        with open(file_path) as f:
            text = f.read()
            return deep_print(text, line_sep)

    lines = s.split(line_sep)
    for l in lines:
        if l.endswith('.txt'):
            deep_print_helper(l)
        else:
            print(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your requirements may not allow for this, but using <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow">str.splitlines</a> would make things a little less complicated.  In the same vain, is there a reason why the original file is not opened as part of the recursion (i.e., rather than passing a string into <code>deep_print</code>, you could pass in a file_path)?  If those two constraints can be lifted, you could do something like the following:</p>
<pre><code>def deep_print(file_path):
    with open(file_path) as f:
        s = f.read()
    for line in [l.strip() for l in s.splitlines()]:
        if line.endswith('.txt'):
            deep_print(line)
        else:
            print(line)
</code></pre>
</div>
<span class="comment-copy">I would go with the first variant -- A function shouldn't have mutually exclusive inputs if you can help it.</span>
<span class="comment-copy">Since this has 6 upvotes if you could add it as an answer I can accept it.</span>
<span class="comment-copy">Good point about this being a general design question. I changed the title and wording to reflect that.</span>
<span class="comment-copy">The <code>__init__</code> method should have a <code>string</code> argument, not a <code>file_path</code> argument as per requirement in OP. Also we can eliminate the inelegantness of the <code>line_sep</code> method parameters by storing <code>line_sep</code> in an instance variable.</span>
<span class="comment-copy">I haven't modified your code. I just moved your functions to the class. You may now check it. I have modified it based on the updates by you</span>
<span class="comment-copy">Since it is a recursive function, every time <code>deep_print</code> is called, it will create a copy of <code>deep_print_helper</code> which is not required</span>
<span class="comment-copy"><code>[l.strip() for l in s.splitlines()]</code> won't return list of lines, instead words in each line.</span>
<span class="comment-copy">Also, OP requires custom line separator</span>
<span class="comment-copy">Actually I really like the <code>s.splitlines()</code>. It lets me do away with the <code>line_sep</code> argument entirely in my application, which is an answer to this SO question: <code>http://stackoverflow.com/questions/39093525/how-to-join-incorporate-splitted-lines-with-replacing-data-from-a-file-into-the</code> . Yes it would be easier to pass a file name to <code>deep_print</code> but the question has the string argument requirement.</span>
<span class="comment-copy">@MoinuddinQuadri <code>rkersh's</code> code actually returns a list of lines; remember <code>s</code> is a multi-line string in this context</span>
<span class="comment-copy">@Craig: My bad. I thought <code>strip()</code> as <code>split()</code>. It will work fine. If you don't have custom file separator and your file uses the default, this code will work. But still I think you do not need <code>strip()</code> as this is not the part of our requirement.</span>
