<div class="post-text" itemprop="text">
<p>In Python how to write such a function which will call all functions in current file with given prefix?</p>
<p>For example:</p>
<pre><code>def prepare(self):
  # ??? to call prepare_1, prepare_2

def prepare_1(self):

def prepare_2(self):
</code></pre>
<p>How to write <code>prepare</code> so it will call all functions started with <code>prepare_</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>If these functions are methods of a class, use <code>dir(self)</code> to list all attributes of <code>self</code>.</p>
<pre><code>class C:

    def prepare(self):
        print(dir(self))
        for name in dir(self):
            if name.startswith('prepare_'):
                method = getattr(self, name)
                method()

    def prepare_1(self):
        print('In prepare_1')

    def prepare_2(self):
        print('In prepare_2')

C().prepare()
</code></pre>
<p>Output:</p>
<pre><code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'prepare', 'prepare_1', 'prepare_2']
In prepare_1
In prepare_2
</code></pre>
<hr/>
<p>Update: if you want to call methods from outside of class C:</p>
<pre><code>obj = C()
for name in dir(obj):
    if name.startswith('prepare_'):
        m = getattr(obj, name)
        print(m)
        m()
</code></pre>
<p>Output:</p>
<pre><code>&lt;bound method C.prepare_1 of &lt;__main__.C object at 0x7f347c9dff28&gt;&gt;
In prepare_1
&lt;bound method C.prepare_2 of &lt;__main__.C object at 0x7f347c9dff28&gt;&gt;
In prepare_2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow noreferrer">globals</a> to access global namespace, <a href="https://docs.python.org/3/library/stdtypes.html?highlight=iteritems#dict.items" rel="nofollow noreferrer">dict.items</a> to iterate over it and <a href="https://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer">callable</a> and <a href="https://docs.python.org/3/library/stdtypes.html?highlight=startswith#str.startswith" rel="nofollow noreferrer">str.startswith</a> to identify that function has name you wish and it's callable:</p>
<pre><code>def prepare(self):
  for key, value in globals().items():
      if callable(value) and key.startswith('prepare_'):
          value()

def prepare_1(self):print 1

def prepare_2(self):print 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's been asked for, so here's a quick hack:</p>
<pre><code>import functools

class FunctionGroup(object):
   """
       Defines a function group as a list of functions that can be
       executed sequentially from a single call to the function group.

       Use
       @func_group.add
       def my_func(...):
           ...

       to add functions to the function group.

       `func_group(...)` calls the added functions one by one.

       It returns a list of the return values from all evaluated functions.

       Processing terminates when one of the function raises an
       exception and the exception is propagated to the caller.
    """
    def __init__(self):
        self.funcs = []

    def add(self, func):
        self.funcs.append(func)
        return func

    def __call__(self, *args, **kwargs):
        return [
            func(*args, **kwargs) for func in self.funcs
        ]


prepare_group = FunctionGroup()
</code></pre>
<p>Note that the <code>__call__()</code> implementation is rather primitive and does nothing to handle exceptions.</p>
<p>Usage example:</p>
<pre><code>@prepare_group.add
def prepare_1():
    print "prep 1"

@prepare_group.add
def prepare_2():
    print "prep 2"

prepare_group()
</code></pre>
<p>Maybe abused to call methods, of course:</p>
<pre><code>class C(object):
    def m(self):
       pass
c = C()
func_group.add(c.m)
</code></pre>
</div>
<span class="comment-copy">Frankly, I'd write a function decorator <code>@function_group(group_name, ...)</code> and a support function <code>call_function_group(group_name)</code>. Explicit is better than implicit.</span>
<span class="comment-copy">Are these normal stand-alone functions, or are they all methods of a particular class?</span>
<span class="comment-copy">What about function that take arguments?</span>
<span class="comment-copy">@dhke Can you give an example, please?</span>
<span class="comment-copy">@PM2Ring They are all methods of a particular class that must be called from function outside of that class</span>
<span class="comment-copy">Messa, and if I call it outside of <code>C</code>, how can I call <code>method</code>? <code>C.method()</code>, <code>C.method(C)</code>, <code>method(C)</code> does not work :( Can you help, please?</span>
<span class="comment-copy">Lets say <code>c</code> is an instance of <code>C</code>: <code>c = C()</code>. Then you can get <code>c</code>'s attributes: <code>dir(c)</code> and <code>c</code>'s method by name: <code>getattr(c, name)</code>.</span>
<span class="comment-copy">Ok, but when I call the method: <code>method = getattr(c, name); method()</code> Python says: <code>unbound method prepare_xxx() must be called with T instance as first argument (got __metaclass__ instance instead)</code>. <code>method(c)</code>, <code>c.method()</code>, <code>c.method(c)</code> also do not work.</span>
<span class="comment-copy">Messa, with <code>getattr(c, name)()</code> python also gives the same error <code>unbound method...</code></span>
<span class="comment-copy">Are you sure you are calling <code>getattr(c, name)</code> with lowercase <code>c</code> - the object, not the class? <code>getattr(class_, name)</code> return unbound method, <code>getattr(instance, name)</code> returns bound method.</span>
<span class="comment-copy">Order of calls is not guaranteed.</span>
<span class="comment-copy">@≈ÅukaszRogalski It's ok, order is not required</span>
<span class="comment-copy">This is nice approach. With more abstraction this becomes design pattern that a lot of applications uses; see Blinker and other event systems. <a href="https://pythonhosted.org/blinker/" rel="nofollow noreferrer">pythonhosted.org/blinker</a></span>
