<div class="post-text" itemprop="text">
<p>While doing data analysis in Ipython I often have to look at the data by just printing its contents to the shell. Numpy have the facility to show only the <strong>margins</strong> of huge objects when they are too long themselves. I really like this feature of ndarrays but when I print internal python object (eg. dictionary with 15k objects in it) they are dumped to the screen or sometimes truncated in not very friendly fashion. 
So for example for a huge dictionary I would like to see in output something like  this  </p>
<pre><code>{ '39416' : '1397',  
  '39414' : '1397',  
  '7629'  : '7227',  
  ...,  
  '31058' : '9606',  
  '21097' : '4062',  
  '32040' : '9606' }  
</code></pre>
<p>It would be perfect if alignment and nested data structures could be taken care of. Is their a special module which can provide such functionality for python basic classes (list, dict)? Or there are some ipython configuration tricks I know nothing about?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a good built-in library <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow"><code>pprint</code></a>. Take a look at it.</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint({x: list(range(x)) for x in range(10)})
{0: [],
 1: [0],
 2: [0, 1],
 3: [0, 1, 2],
 4: [0, 1, 2, 3],
 5: [0, 1, 2, 3, 4],
 6: [0, 1, 2, 3, 4, 5],
 7: [0, 1, 2, 3, 4, 5, 6],
 8: [0, 1, 2, 3, 4, 5, 6, 7],
 9: [0, 1, 2, 3, 4, 5, 6, 7, 8]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your dictionary is well structured, you could convert it to a Pandas dataframe for viewing.</p>
<pre><code>import numpy as np
import pandas as pd

&gt;&gt;&gt; pd.DataFrame({'random normal': np.random.randn(1000), 
                  'random int': np.random.randint(0, 10, 1000)})
     random int  random normal
0             6       0.850827
1             7       0.486551
2             4      -0.111008
3             9      -1.319320
4             6      -0.393774
5             1      -0.878507
..          ...            ...
995           2      -1.882813
996           3      -0.121003
997           3       0.155835
998           5       0.920318
999           2       0.216229

[1000 rows x 2 columns]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>numpy</code> formatter has an ellipsis functionality; as a default it kicks in with 1000+ items.  </p>
<p><code>pprint</code> can make the display nicer, but I don't think it has an ellipsis functionality.  But you can study its docs.</p>
<p>With a list I may use a slice</p>
<pre><code>list(range(100))[:10]
</code></pre>
<p>to see a limited number of the values.</p>
<p>That's harder to do with a dictionary.  With some trial and error, this works tolerably:</p>
<pre><code>{k:dd[k] for k in list(dd.keys())[:10]}
</code></pre>
<p>(I'm on Py3 so need the extra <code>list</code>).</p>
<p>It wouldn't be hard to write your own utility functions if you can't find something in <code>pprint</code>.  It's also possible that some package on <code>pypi</code> does this.  For example a quick search turned up</p>
<p><a href="https://pypi.python.org/pypi/pprintpp" rel="nofollow">https://pypi.python.org/pypi/pprintpp</a></p>
<p><code>pprintpp</code> which claims to be actually pretty.  But like the stock <code>pprint</code> it seems to be more concerned with the nesting depth of lists and dictionaries, and not so much their length.</p>
</div>
<span class="comment-copy"><code>from pprint import pprint; pprint(my_dict)</code></span>
<span class="comment-copy">Perhaps use Pandas and convert your list or dictionary to a dataframe for viewing.</span>
<span class="comment-copy">I haven't found any functionality for printing margins in pprint.</span>
<span class="comment-copy">@pommy afaik there is only <code>indent</code>, <code>width</code> and <code>depth</code> parameters.</span>
<span class="comment-copy">I think it is an overkill for viewing purposes. I could use numpy structured array for the same purpose but I don't think it is a good solution.</span>
