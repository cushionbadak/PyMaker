<div class="post-text" itemprop="text">
<p>I want to make a program that accesses images from files, encodes them, and sends them to an server.
Than the server is supposed to decode the image, and save it to file.
I tested the image encoding itself, and it worked, so the problem lies in the server and client connection.</p>
<p>Here is the server:</p>
<pre><code>import socket
import errno
import base64

from PIL import Image
import StringIO

def connect(c):
    try:
        image = c.recv(8192)
        return image
    except IOError as e:
        if e.errno == errno.EWOULDBLOCK:
            connect(c)


def Main():
    host = '138.106.180.21'
    port = 12345

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    s.bind((host, port))
    s.listen(1)


    while True:

        c, addr = s.accept()
        c.setblocking(0)

        print "Connection from: " + str(addr)

        image = c.recv(8192)#connect(c)

        imgname = 'test.png'

        fh = open(imgname, "wb")
        if image == 'cusdom_image':
            with open('images.png', "rb") as imageFile:
                image = ''
                image = base64.b64encode(imageFile.read())
                print image
        fh.write(image.decode('base64'))
        fh.close()


if __name__ == '__main__':
    Main()
</code></pre>
<p>And here is the client:</p>
<pre><code>import socket
import base64

from PIL import Image
import StringIO
import os, sys

ip = '138.106.180.21'
port = 12345
print 'Add event executed'
s = socket.socket()
s.connect((ip, port))

image_path = '/home/gilgamesch/Bilder/Bildschirmfoto.png'

print os.getcwd()
olddir = os.getcwd()
os.chdir('/')
print os.getcwd()

if image_path != '':
    with open(image_path, "rb") as imageFile:
        image_data = base64.b64encode(imageFile.read())
        print 'open worked'
else:
    image_data = 'cusdom_image'

os.chdir(olddir)

s.send(image_data)


s.close()
</code></pre>
<p>And the error message is:</p>
<pre><code>Traceback (most recent call last):
  File "imgserv.py", line 49, in &lt;module&gt;
    Main()
  File "imgserv.py", line 34, in Main
    image = c.recv(8192)#connect(c)
socket.error: [Errno 11] Resource temporarily unavailable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the server you are setting the remote socket (that returned by <code>accept()</code>) to non-blocking mode, which means that I/O on that socket will terminate immediately by an exception if there is no data to read.</p>
<p>There will usually be a period of time between establishing the connection with the server and the image data being sent by the client. The server attempts to immediately read data from the client once the connection is accepted, however, there might not be any data to read yet, so <code>c.recv()</code> raises a <code>socket.error: [Errno 11] Resource temporarily unavailable</code> exception. Errno 11 corresponds to <code>EWOULDBLOCK</code>, so <code>recv()</code> aborted because there was no data ready to read.</p>
<p>Your code does not seem to require non-blocking sockets because there is an <code>accept()</code> at the top of the while loop, and so only one connection can be handled at a time. You can just remove the call to <code>c.setblocking(0)</code> and this problem should go away.</p>
</div>
<span class="comment-copy">but what do I do, if the server is supposed to get multiple connection?</span>
<span class="comment-copy">That's another problem. You can use <code>select()</code> to determine which of multiple sockets are ready to read, and then call <code>recv()</code> on those that are. You would also add the main server socket to the list of sockets passed to <code>select()</code> and call accept on that socket whenever <code>select()</code> indicates that it is readable. There are alternatives in the <code>select</code> module such as <code>poll()</code> et. al.</span>
<span class="comment-copy">You might also consider using the <a href="https://docs.python.org/3/library/selectors.html#module-selectors" rel="nofollow noreferrer"><code>selectors</code></a> module or <a href="https://docs.python.org/3/library/asyncio.html#module-asyncio" rel="nofollow noreferrer"><code>asyncio</code></a> if you are using Python 3.4 or later. <a href="https://docs.python.org/2.7/library/asyncore.html#module-asyncore" rel="nofollow noreferrer"><code>asyncore</code></a> is an option on Python 2.</span>
