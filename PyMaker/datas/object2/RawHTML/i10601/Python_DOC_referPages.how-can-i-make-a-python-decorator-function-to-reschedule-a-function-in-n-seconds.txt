<div class="post-text" itemprop="text">
<p>This is my current code:</p>
<pre><code>import asyncio
import serial


def repeat(seconds):
    def wrap(func):
        def decorated(*args):
            loop = asyncio.get_event_loop()
            loop.call_at(loop.time() + seconds, decorated, *args)
            print('scheduled')
            func(*args)
            return func
        return decorated
    return wrap


@repeat(10)
def send_command(ser, text):
    try:
        if text == 'DATA':
            print("\nSending Data Request")
            ser.write(b'\n022022')
        elif text == 'STAY':
            print("\nInmediate Stay ARM")
            ser.write(b'\n0640010002044D')
        elif text == 'AWAY':
            print("\nInmediate Away ARM")
            ser.write(b'\n0640010003044E')
        elif text == 'DISARM':
            print("\nDISARM")
            ser.write(b'\n0940010001040700055B')
        elif text == 'CHIME':
            print("\nChime toggle")
            ser.write(b'\n0640010007014F')
    except serial.SerialException as e:
        raise e


if __name__ == '__main__':

    ser = serial.Serial('/dev/ttyUSB0', 9600, parity=serial.PARITY_ODD, write_timeout=0, timeout=0)

    loop = asyncio.get_event_loop()
    loop.call_at(loop.time() + 5, send_command, ser, 'DATA')
    loop.run_forever()
</code></pre>
<p>In this example I'm trying to schedule the send_command function to run in 5 seconds and every 10 seconds afterwards. It seems to work but I'm a bit confused with the <code>loop.call_at(loop.time() + seconds, decorated, *args)</code> call. Any comments will be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is fine (except as noted you should return func's result inside decorator), I improved it a bit.</p>
<p>It's easier to see and test with synthetic example:</p>
<pre><code>import asyncio
import functools


def repeat(seconds):
    def wrap(func):
        @functools.wraps(func)  # see http://stackoverflow.com/q/308999/1113207
        def decorated(*args, **kwargs):
            # We should call func that decorated again to
            # force decorator's `call_at` code to execute again:
            loop = asyncio.get_event_loop()
            loop.call_at(
                loop.time() + seconds, 
                functools.partial(decorated, *args, **kwargs)  # see http://stackoverflow.com/q/3252228/1113207
            )
            # We should return result of func's excecution:
            return func(*args, **kwargs)
        return decorated
    return wrap


@repeat(2)
def send_command():
    print('send_command')


async def main():
    send_command()  # call once, rescheduling started

    for i in range(10):
        print(i)
        await asyncio.sleep(1)


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>send_command
0
1
send_command
2
3
send_command
4
5
send_command
6
7
send_command
8
9
send_command
[Finished in 10.3s]
</code></pre>
</div>
<span class="comment-copy">not commenting on <code>loop.call_at</code>, your code seems not working at <code>return func</code>, which should be <code>func(*args)</code></span>
<span class="comment-copy">And could you elaborate which part of <code>loop.call_at</code> confused you? according to the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_at" rel="nofollow noreferrer">doc</a>, it just schedules the callback (<code>decorated</code>) to be called at the given time point (<code>loop.time() + seconds</code>)</span>
<span class="comment-copy">Sorry I did not include the actual function call func(*args). Already edited. I'm confused with the call of the inner function (decorated) to reschedule it into the future.</span>
<span class="comment-copy">Thanks a lot for the comments and recommendations!</span>
