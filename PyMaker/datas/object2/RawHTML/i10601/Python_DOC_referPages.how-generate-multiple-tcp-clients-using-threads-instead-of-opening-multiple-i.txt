<div class="post-text" itemprop="text">
<p>I wrote the code for a simple TCP client:</p>
<pre><code>from socket import *

# Configurações de conexão do servidor
# O nome do servidor pode ser o endereço de
# IP ou o domínio (ola.python.net)
serverHost = 'localhost'#ip do servidor
serverPort = 50008

# Mensagem a ser mandada codificada em bytes
menssagem = [b'Ola mundo da internet!']

# Criamos o socket e o conectamos ao servidor
sockobj = socket(AF_INET, SOCK_STREAM)
sockobj.connect((serverHost, serverPort))

# Mandamos a menssagem linha por linha
for linha in menssagem:
    sockobj.send(linha)

    # Depois de mandar uma linha esperamos uma resposta
    # do servidor
    data = sockobj.recv(1024)
    print('Cliente recebeu:', data)

# Fechamos a conexão
sockobj.close()
</code></pre>
<p>I would like to know, how " generate " multiple clients TCP using Threads instead of opening multiple instances of the terminal and run the script several times.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:
The worker method will be set as target for the thread. 
So every thread will use the code of the method. 
After starting all thread, the for loop at the bottom will wait for all threads to finish. </p>
<p>In the worker method you can use arrays or lists of data from outside the method. So you can iterate for example over a list of Urls or append the fetched data to a new output array. </p>
<pre><code>import threading

threads = []
maxNrOfThreads = 5

def worker():
    do_stuff()

for _ in range(maxNrOfThreads):
    thr = threading.Thread(target=worker)
    threads.append(thr)
    thr.setDaemon(True)
    thr.start()

for thread in threads:
    thread.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest and most pythonic way is to use <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy" rel="nofollow">multiprocessing thread pool implementation</a>, and then call <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow"><code>pool.map</code></a>. The former will allow you effortlessly swap from threads to processes when needed. The latter will provide you a clean interface hiding synchronisation chores behind the scenes.</p>
<pre><code>#!/usr/bin/env python3 


import socket
from pprint import pprint
from contextlib import closing
from multiprocessing.dummy import Pool as ThreadPool


serverHost = 'localhost'
serverPort = 80


messageGroups = [
    [b'GET / HTTP/1.0\n\n'],
    [b'GET /some-path HTTP/1.0\n\n'],
]

def send(messages):
    result = []
    options = socket.AF_INET, socket.SOCK_STREAM
    with closing(socket.socket(*options)) as sockobj:
        sockobj.connect((serverHost, serverPort))
        for message in messages:
            sockobj.send(message)
            response = sockobj.recv(1014)
            result.append((message, response))

    return result


if __name__ == '__main__':
    size = 10
    pool = ThreadPool(size)
    result = pool.map(send, messageGroups)
    pool.close()
    pool.join()

    pprint(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have just wrapped your code/what you want to do, into a function i.e. <code>worker()</code>. Next, I have added extra code for <code>thread</code> spawning and set the <code>worker()</code> function as the <code>target</code> (the function/work/code each spawned thread will execute - this is why it's a convention to name it <code>worker</code>).</p>
<pre><code>th = threading.Thread(target=worker)
</code></pre>
<hr/>
<p>The multithreaded version of you above example can be as follows:</p>
<pre><code>import threading
from socket import *

serverHost = 'localhost'#ip do servidor
serverPort = 50008

threads = []
input = input("Enter the number of threads:")
num_of_threads = int(input)

def worker():
    # Criamos o socket e o conectamos ao servidor
    sockobj = socket(AF_INET, SOCK_STREAM)
    sockobj.connect((serverHost, serverPort))

    # Mandamos a menssagem linha por linha
    for linha in menssagem:
        sockobj.send(linha)
        # Depois de mandar uma linha esperamos uma resposta
        # do servidor
        data = sockobj.recv(1024)
        print('Cliente recebeu:', data)

    sockobj.close()

# thread generation block
for t in range(num_of_threads):
    th = threading.Thread(target=worker)
    threads.append(th)
    th.setDaemon(True)
    th.start()

for thread in threads:
    thread.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one solution with queues to send distinct messages.</p>
<pre><code>#!/usr/bin/python

import Queue
import threading
import time
from socket import *


DEF_HOST = 'localhost'
DEF_PORT = 50008


queueLock = threading.Lock()


class myThreadTCP (threading.Thread):

    def __init__(self, host=DEF_HOST, port=DEF_PORT, q=None):
        threading.Thread.__init__(self)
        self.host = host
        self.port = port
        self.q = q

    def run(self):
        global queueLock
        print("Starting Thread")
        # Criamos o socket e o conectamos ao servidor
        sockobj = socket(AF_INET, SOCK_STREAM)
        sockobj.connect((self.host, self.port))
        while not workQueue.empty():
            with queueLock:
                data = q.get()
            if data:
                print("sending %s" % data)
                sockobj.send(data)
                # Depois de mandar uma linha esperamos uma resposta
                # do servidor
                data = sockobj.recv(1024)
                print('Cliente recebeu:', data)
        # Fechamos a conexão
        sockobj.close()
        print("Exiting Thread")


workQueue = Queue.Queue()

# Mensagem a ser mandada codificada em bytes
menssagem = [b'Ola mundo da internet!', b'Ola mundo da internet #2!']
for msg in menssagem:
    workQueue.put(msg)

threads = []

# Create 10 new threads
for i in range(0, 10):
    thread = myThreadTCP(host=DEF_HOST, port=DEF_PORT, q=workQueue)
    thread.daemon = True
    thread.start()
    threads.append(thread)

# Wait for all threads to complete
for t in threads:
    t.join()
print("Exiting Main Thread")
</code></pre>
</div>
<span class="comment-copy"><code>threading</code> Python module might help you. Or try <code>multiprocessing</code> if you wanna break out of the GIL (Global Interpreter Lock - better Google that term). If you're using Python 3.5, you should almost definitely try <code>asyncio</code> and that fancy <code>async def</code> syntax for asynchronous functions definition.</span>
<span class="comment-copy">@ForceBru, thanks. Could you give me a example? I am using Python 3.4.</span>
<span class="comment-copy">simply wrap your current code into a function and spawn several threads running it (something like <code>threading.Thread(target=func).start()</code>)</span>
<span class="comment-copy">here's the documentation on <code>threading</code>: <a href="https://docs.python.org/3.4/library/threading.html" rel="nofollow noreferrer">docs.python.org/3.4/library/threading.html</a></span>
<span class="comment-copy">@ForceBru, thanks for helping!</span>
<span class="comment-copy">why for _ in? I dont understand _</span>
<span class="comment-copy">It means you don't need the index of the iteration. Underscore is a convention to mark the variable as unused.  You can also use <code>i</code> instead of <code>_</code> and ignore it.</span>
<span class="comment-copy">@Au, thanks! I will study the code!</span>
<span class="comment-copy">def worker():     do_stuff() -&gt; it will be my TCP client?</span>
<span class="comment-copy">Yes, there you can open the socket and do your stuff ;)</span>
<span class="comment-copy">There's no <code>raw_input</code> in Python 3. Notice the tag.</span>
<span class="comment-copy">i have corrected it - thanks</span>
<span class="comment-copy">In Python 3 <code>print</code> is no longer an operator. Notice the tag.</span>
<span class="comment-copy">thanks, the code is more a pseudo-code, not tested, but have the ideas that should work.</span>
