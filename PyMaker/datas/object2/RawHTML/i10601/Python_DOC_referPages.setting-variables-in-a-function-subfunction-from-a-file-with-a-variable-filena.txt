<div class="post-text" itemprop="text">
<p>I have a function that has a subfunction and I would like to initialize variables inside of the subfunction. Simply,</p>
<pre><code>file = "foo"
def outerFunction():
    def innerFunction():
        var1 = 0
        var2 = 1
        var3 = 2
        print file, var1, var2, var3
    file = "bar"
    innerFunction()
outerFunction()
</code></pre>
<p>Output: <code>bar 0 1 2</code></p>
<p>However, I have quite a large number of variables in multiple different files and I would like to simply import them into the subfunction when the subfunction is called. Assume I have a file <code>bar.py</code> with the following contents:</p>
<pre><code>var1=0
var2=1
var3=2
</code></pre>
<p>Then I change my code to be </p>
<pre><code>file = "foo"
def outerFunction():
    def innerFunction():
        from file import *
        print file, var1, var2, var3
    file = "bar"
    innerFunction()
outerFunction()
</code></pre>
<p>This is going to result in an error because Python 2.7 doesn't like it when you use <code>import</code> within a subfunction. So, instead, we can use the <code>__import__</code> function directly:</p>
<pre><code>file = "foo"
def outerFunction():
    def innerFunction():
        __import__(file)
        print file, var1, var2, var3
    file = "bar"
    innerFunction()
outerFunction()
</code></pre>
<p>The import method here works, but the variables don't ever actually make it to the subfunction's variable list, resulting in an error when I go to print them out. Now, I know that I can change the code to</p>
<pre><code>file = "foo"
def outerFunction():
    def innerFunction():
        f = __import__(file)
        print file, f.var1, f.var2, f.var3
    file = "bar"
    innerFunction()
outerFunction()
</code></pre>
<p>and it will work peachy. That is not the solution I am looking for, though. I want to be able to import those functions without changing the rest of my code to accommodate. Are there any better solutions to this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>From a maintainability perspective, importing the module and then referencing the variables of the module is the best option. It's easy to see where the variables have come from. </p>
<p><code>from module import *</code> is frowned upon because it makes it hard to trace where variables have come from, especially if multiple modules contain variables with the same name. <code>from module import *</code> is impossible within a function because of how local variables work in Python. Local variables are stored on the stack,  and if Python doesn't know how many variables there will be then it can't allocate space on the stack properly.</p>
<p>However, that said, you can do what you're asking. But you shouldn't. The idea behind this is to leave the variables referenced as globals, and update your globals accordingly when the function starts. eg.</p>
<pre><code>from importlib import import_module

file_ = "foo"
def outer():
    def inner():
        m = import_module(file_) # import module whose name is the contents of file_
        globals().update(m.__dict__) # add module's globals to our own
        print(file_, var0, var1, var2)
    file_ = "bar"
    inner()
outer()
</code></pre>
<p>This is a terrible idea as each inner function will share the same set of globals and may possible overwrite variables with the same name. This is will cause problems if <code>inner</code> functions are run concurrently, or if they overwrite variables needed by the module that defined <code>outer</code>. It is possible to overcome this by modifying each <code>inner</code> function to use its own unique set of globals, but this is a horrible hack, and mainly included to show how this is possible.</p>
<pre><code>from importlib import import_module
from types import FunctionType

file_ = "foo"
def outer():
    def inner():
        m = import_module(file_)
        globals().update(m.__dict__)
        print(file_, var0, var1, var2)
    # redefine inner with new globals
    inner = FunctionType(inner.__code__, 
        dict(import_module=import_module, __builtins__=__builtins__), # new globals
        inner.__name__, inner.__defaults__, inner.__closure__
    )
    file_ = "bar"
    inner()
outer()
</code></pre>
</div>
<span class="comment-copy">Why can't you make file and object and then instantiate it? Then you could just just do file.property (file.var1) or even use a getter function if you are wanting to perform calculations?</span>
<span class="comment-copy">You seem to have some confusion about the Python import system. "Python 2.7 doesn't like it when you use import inside a sub-function." No... Python any version doesn't let you use variables in import statements, regardless of scope. "The import method here works, but the variables don't [get added to local scope]." Well, no, that's not how <code>import x</code> works in any situation. I don't really understand your 3rd point.</span>
<span class="comment-copy">Also, if those are just settings, maybe you should parse them instead of trying to "run" them. For instance, using <a href="https://docs.python.org/3/library/configparser.html" rel="nofollow noreferrer">configparser</a></span>
<span class="comment-copy">There's generally no reason to be importing anywhere but at the top of your file, and certainly not within functions and subfunctions and whatever else. <b>What are you trying to do?</b> You are almost certainly solving the wrong problem, in the wrong way.</span>
<span class="comment-copy">You could consider using something like <a href="https://wiki.python.org/moin/ConfigParserExamples" rel="nofollow noreferrer">configparser</a>.</span>
