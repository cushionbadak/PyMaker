<div class="post-text" itemprop="text">
<p>I'm trying to make a simple test in python, but I'm not able to figure it out how to accomplish the mocking process.</p>
<p>This is the class and def code:</p>
<pre><code>class FileRemoveOp(...)
    @apply_defaults
    def __init__(
            self,
            source_conn_keys,
            source_conn_id='conn_default',
            *args, **kwargs):
        super(v4FileRemoveOperator, self).__init__(*args, **kwargs)
        self.source_conn_keys = source_conn_keys
        self.source_conn_id = source_conn_id


    def execute (self, context)
          source_conn = Connection(conn_id)
          try:
              for source_conn_key in self.source_keys:
                  if not source_conn.check_for_key(source_conn_key):    
                      logging.info("The source key does not exist")  
                  source_conn.remove_file(source_conn_key,'')
          finally:
              logging.info("Remove operation successful.")
</code></pre>
<p>And this is my test for the execute function:</p>
<pre><code>@mock.patch('main.Connection')
def test_remove_execute(self,MockConn):
    mock_coon = MockConn.return_value
    mock_coon.value = #I'm not sure what to put here#
    remove_operator = FileRemoveOp(...)
    remove_operator.execute(self)
</code></pre>
<p>Since the <strong>execute</strong> method try to make a connection, I need to mock that, I don't want to make a real connection, just return something mock. How can I make that? I'm used to do testing in Java but I never did on python..</p>
</div>
<div class="post-text" itemprop="text">
<p>First it is very important to understand that you always need to Mock where it the thing you are trying to mock out is used as stated in the <code>unittest.mock</code> documentation.</p>
<blockquote>
<p>The basic principle is that you patch where an object is looked up,
  which is not necessarily the same place as where it is defined.</p>
</blockquote>
<p>Next what you would need to do is to return a <code>MagicMock</code> instance as <code>return_value</code> of the patched object. So to summarize this you would need to use the following sequence.</p>
<ul>
<li>Patch Object</li>
<li>prepare <code>MagicMock</code> to be used</li>
<li>return the <code>MagicMock</code> we've just created as <code>return_value</code></li>
</ul>
<p>Here a quick example of a project.</p>
<p><strong>connection.py  (Class we would like to Mock)</strong></p>
<pre><code>class Connection(object):                                                        
    def execute(self):                                                           
        return "Connection to server made"
</code></pre>
<p><strong>file.py (Where the Class is used)</strong></p>
<pre><code>from project.connection import Connection                                        


class FileRemoveOp(object):                                                      
    def __init__(self, foo):                                                     
        self.foo = foo                                                           

    def execute(self):                                                           
        conn = Connection()                                                      
        result = conn.execute()                                                  
        return result    
</code></pre>
<p><strong>tests/test_file.py</strong></p>
<pre><code>import unittest                                                                  
from unittest.mock import patch, MagicMock                                       
from project.file import FileRemoveOp                                            

class TestFileRemoveOp(unittest.TestCase):                                       
    def setUp(self):                                                             
        self.fileremoveop = FileRemoveOp('foobar')                               

    @patch('project.file.Connection')                                            
    def test_execute(self, connection_mock):
        # Create a new MagickMock instance which will be the
        # `return_value` of our patched object                                     
        connection_instance = MagicMock()                                        
        connection_instance.execute.return_value = "testing"

        # Return the above created `connection_instance`                     
        connection_mock.return_value = connection_instance                       

        result = self.fileremoveop.execute()                                     
        expected = "testing"                                                     
        self.assertEqual(result, expected)                                       

    def test_not_mocked(self):
        # No mocking involved will execute the `Connection.execute` method                                                   
        result = self.fileremoveop.execute()                                     
        expected = "Connection to server made"                                   
        self.assertEqual(result, expected) 
</code></pre>
</div>
<span class="comment-copy">What are you actually trying to test? Usually you are mocking stuff that is called by the code you are testing and don't call the mock directly. With your approach you will test the mock only.</span>
<span class="comment-copy">A more complete example would be useful. It's hard to gauge what you're trying to achieve. That said, when the mocked class is called it will automatically create another mock as the returned instance. You can then setup this mocked connection as needed.</span>
<span class="comment-copy">Thanks a lot! This was a perfect example and works correctly! :)</span>
<span class="comment-copy">That's almost what I need, is it possible to, for example, patch <code>project.file.Connection</code> with a slightly different version (maybe <code>project.file.Connection2</code>) rather than patch with <code>MagicMock</code> ?</span>
<span class="comment-copy">In that case I suggest you should have a look into <a href="http://python-dependency-injector.ets-labs.org/introduction/di_in_python.html" rel="nofollow noreferrer">depdency injection</a></span>
<span class="comment-copy">what is connection mock? Is it the last argument? What if you had two things to mock?</span>
<span class="comment-copy">If you want to add a second patch to the method you will have to use two <code>patch</code> decorators which can be accessed in the method signature in inverted order. Here is an <a href="https://docs.python.org/3/library/unittest.mock.html#nesting-patch-decorators" rel="nofollow noreferrer">example</a></span>
