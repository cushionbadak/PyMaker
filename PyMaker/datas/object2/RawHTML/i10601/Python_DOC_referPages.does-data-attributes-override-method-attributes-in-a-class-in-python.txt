<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/tutorial/classes.html#random-remarks" rel="nofollow">official documentation</a>, "data attributes override method attributes with the same name". However, I found that to be incorrect.</p>
<pre><code>class C:
    x = 111
    def x(self):
        print('I am x')
c = C()
print(c.x)
</code></pre>
<p>The print statement in the code above shows c.x being a method, not the data attribute assigned to 111. Thus, this code indicates that data attributes do not necessarily override method attributes with the same name and the documentation is wrong. Can anyone confirm my finding?</p>
<p>P.S. I tried the code in both Python 3.5 and Python 2.7 and obtained the same result. </p>
</div>
<div class="post-text" itemprop="text">
<p>I guess the tutorial is unfortunately (because ambiguously) phrased and by</p>
<blockquote>
<p>[d]ata attributes override method attributes with the same name</p>
</blockquote>
<p>it actually means "Data attributes override previously assigned/defined method attributes of the same name and vice versa: method attributes override previously assigned/defined data attributes of the same name."</p>
<p>"Duh", you might think "data attributes also override previously assigned <em>data</em> attributes of the same name, so what's the big deal? Why is this even mentioned?" Assigning and re-assigning (called "overriding" in the cited tutorial) to variables (whether called "attributes" of something or not) is after all one of the prototypical features of an imperative programming language.</p>
<p>Well, let me introduce you to</p>
<h1>Namespaces</h1>
<p>Python classes are namespaces. So what the tutorial might try to tell us here is that data attributes <strong>and</strong> method attributes <em>within</em> a class share a namespace.</p>
<p>This isn't the case for attributes of different classes, though. If a class inherits from another class, it has access to its parent's names. If a name is reused for method definition or data assignment within the inheriting class, the parent class keeps the original values. In the child class they are merely temporarily shadowed. If you remove the name from the child class, it, too, will again provide access to the parent's attribute of the same name:</p>
<pre><code>class A:
        x = 111

class B1(A):
        x = 123  # Shadows A.x

assert B1.x == 123

del B1.x            # But after removing B1's own x attribute ...
assert B1.x == 111  # ... B1.x is just an alias to A.x !


# Shadowing can happen at any time:

class B2(A):
        pass

assert B2.x == A.x == 111

B2.x = 5  # shadowing attributes can also be added after the class definition

assert B2.x == 5
assert A.x == 111

del B2.x
assert B2.x == A.x == 111
</code></pre>
<p>Contrast this with re-definition a.k.a. re-assignment (or "overriding" as the tutorial calls it):</p>
<pre><code>class C:
        x = 555
        def x(self):
                print('I am x')

C().x()  # outputs "I am x"

del C.x
print(C.x) # AttributeError: 'C' object has no attribute 'x'
</code></pre>
<p>Method <code>C.x()</code> didn't temporarily shadow data attribute <code>C.x</code>. It replaced it, so when we delete the method, <code>x</code> is missing completely within <code>C</code>, rather than the data attribute re-appearing under that name.</p>
<h1>More Namespaces</h1>
<p>Instantiation adds another namespace and thus another chance for shadowing:</p>
<pre><code>a = A()
assert a.x == 111  # instance namespace includes class namespace

a.x = 1000
assert a.x == 1000
assert A.x == 111  # class attribute unchanged

del a.x
assert a.x == 111  # sees A.x again
</code></pre>
<p>In fact, all (nested) namespaces in Python work that way: packages, modules, classes, functions and methods, instance objects, inner classes, nested functions ...</p>
<p>When reading a variable, the namespace hierarchy is walked bottom-up until the name is found. (<em>Reading</em> here means finding the value (object, function/method or built-in) to which the variable's name is bound. If the value is mutable, this can also be used to change the value.)</p>
<p>On the other hand, when setting (defining or redefining) a variable, a name of the current namespace is used: Rebound to the new value if the name already exists in that very namespace (rather than only being included there from another namespace) or a newly created name if it didn't exist before.</p>
</div>
<div class="post-text" itemprop="text">
<p>Attributes override methods and vise-versa. A rule of thumb is, the latter overrides the former. So if you do</p>
<pre><code>class C:
    x = 111
    def x(self):
        print('I am x')
    x = 112

c = C()
print(c.x)
</code></pre>
<p>You will get </p>
<pre><code>112
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this would be easier to understand:
Data attributes shadow method attributes with the same name;</p>
</div>
<div class="post-text" itemprop="text">
<p>You were missing the second definition of x, that is why it seemed like the official documentation was wrong.</p>
</div>
<span class="comment-copy">variables can shadow other variables ... methods and attributes and classes and functions are all really just variables</span>
<span class="comment-copy">There is also another way of overriding/shadowing that may happen: Method definitions end up in the class-dict (<code>obj.__class__.__dict__</code>), whereas instance variables end up in the instance-dict (<code>obj.__dict__</code>). Attribute lookup happens in the instance-dict first, so it may shadow a method with the same name, even though that method is still in the class-dict (no actual re-assignment).</span>
<span class="comment-copy">@LukasGraf good point. I've added a another section about that.</span>
<span class="comment-copy">Thank you for a very clear and extensive answer.</span>
<span class="comment-copy">Does that mean that you agree that the official documentation is wrong on this matter?</span>
<span class="comment-copy">@candleindark that sentence in the documentation is at least very misleading. Like Kostas pointed out, a later assignment overrides the former. And <i>usually</i>, data attributes (instance variables) are first assigned in <code>__init__()</code>, which is why they get assigned later than method definitions, which are assigned when the class declaration is parsed. In your example you're using a <b>class</b> level attribute, which is why the "usually" doesn't hold true.</span>
<span class="comment-copy">What do you mean by the second definition of x?</span>
