<div class="post-text" itemprop="text">
<p>From an array <code>Ns</code>, I'd like to derive an array <code>multipliers</code> as follows:</p>
<pre><code>Ns = [3, 3, 6, 3]

multipliers = [0]*len(Ns)
multipliers[0] = 1
for n in range(1,len(Ns)):
    multipliers[n] = multipliers[n-1] * Ns[n-1]
</code></pre>
<p>The resulting array <code>multipliers</code> is <code>[1, 3, 9, 54]</code>. My gut feeling is that it should be possible to make this code more succinct using <code>reduce</code> or another built-in function, but I don't yet see how. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simulate the behavior of <code>accumulate</code> (see @soon's answer) in Python 2 with <code>reduce</code>. You have to manage the list by yourself. </p>
<pre><code>from functools import reduce
Ns = [3, 3, 6, 3]
multipliers = reduce(lambda l, x: l + [l[-1] * x], Ns[:-1], [1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a> with a custom accumulation function (Python 3 only, if you want to use Python 2 you could install <a href="https://github.com/kachayev/fn.py" rel="nofollow"><code>fn.py</code></a> library (or similar) or backport the function using the implementation provided in the docs) :</p>
<pre><code>In [10]: from itertools import accumulate

In [11]: import operator

In [12]: list(accumulate([3, 3, 6, 3], func=operator.mul))
Out[12]: [3, 9, 54, 162]
</code></pre>
<p>And then just fix the first and the last elements:</p>
<pre><code>In [13]: l = list(accumulate([3, 3, 6, 3], func=operator.mul))

In [14]: [1] + l[:-1]
Out[14]: [1, 3, 9, 54]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>reduce</code> give you just the final result of the reducing process, so if you want all the intermediate values you can use list comprehension as followed:</p>
<pre><code>&gt;&gt;&gt; [reduce(lambda x,y:x*y, Ns[:i], 1) for i in range(len(Ns))]
[1, 3, 9, 54]
</code></pre>
<p>but that isn't efficient since it reducing again and again for each sublist.</p>
</div>
<div class="post-text" itemprop="text">
<p>As my comment and other answers mention, this is easy in Python 3, using  <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow"><code>itertools.accumulate</code></a>. However, from your previous questions it appears that you're using Python 2.</p>
<p>In Python, it's almost always better to iterate directly over a list rather than using indices. Your code could be rewritten like this. (I've changed your list name to <code>ns</code> to comply with the <a href="https://www.python.org/dev/peps/pep-0008" rel="nofollow">PEP 8 style guide</a>).</p>
<pre><code>ns = [3, 3, 6, 3]
multipliers = []
last = 1
for u in ns:
    multipliers.append(last)
    last *= u
print multipliers
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 3, 9, 54]
</code></pre>
<p>Note that this code does an extra multiplication at the end, the result of which doesn't get appended to <code>multipliers</code>. Here's an alternative that's a little more compact. Instead of using the <code>last</code> variable it looks up the last element in <code>multipliers</code>, which is slightly less efficient, and while it doesn't do that extra multiplication it does need to create a new list when it slices <code>ns</code>.</p>
<pre><code>ns = [3, 3, 6, 3]
multipliers = [1]
for u in ns[:-1]:
    multipliers.append(u * multipliers[-1])
print multipliers
</code></pre>
</div>
<span class="comment-copy">In Python 3 there's <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>, but you're using Python 2, IIRC.</span>
<span class="comment-copy">Is there some reason you don't want the final element of 162 in <code>multipliers</code>?</span>
<span class="comment-copy">Cute. Of course, building a brand new list for each item processed in <code>Ns</code> is rather less efficient than appending to a fixed list. But I guess that doesn't matter much if <code>Ns</code> is short.</span>
<span class="comment-copy">@PM2Ring Well, I could avoid creating new lists with <code>lambda l, x: l.append(l[-1] * x) or l</code>. But that's probably not a good coding style.</span>
<span class="comment-copy">I went with the <code>append</code> version of <a href="http://stackoverflow.com/users/2162377/user38034">user38034</a>'s solution because it is one line and works in Python 2.</span>
