<div class="post-text" itemprop="text">
<p>I have a nested dict like this, but much larger:</p>
<pre><code>d = {'a': {'b': 'c'}, 'd': {'e': {'f':2}}}
</code></pre>
<p>I've written a function which takes a dictionary and a path of keys as input and returns the value associated with that path.</p>
<pre><code>&gt;&gt;&gt; p = 'd/e'
&gt;&gt;&gt; get_from_path(d, p) 
&gt;&gt;&gt; {'f':2}
</code></pre>
<p>Once I get the nested dictionary, I will need to modify it, however, d can not be modified. Do I need to use deepcopy, or is there a more efficient solution that doesn't require constantly making copies of the dictionary? </p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on your use case, one approach to avoid making changes to an existing dictionary is to wrap it in a <a href="https://docs.python.org/3/library/collections.html#chainmap-objects" rel="nofollow"><code>collections.ChainMap</code></a>:</p>
<pre><code>&gt;&gt;&gt; import collections

&gt;&gt;&gt; # here's a dictionary we want to avoid dirty'ing
&gt;&gt;&gt; d = {i: i for in in range(10)}

&gt;&gt;&gt; # wrap into a chain map and make changes there
&gt;&gt;&gt; c = collections.ChainMap({}, d)
</code></pre>
<p>Now we can add new keys and values to <code>c</code> without corresponding changes happening in <code>d</code></p>
<pre><code>&gt;&gt;&gt; c[0] = -100
&gt;&gt;&gt; print(c[0], d[0])
-100 0
</code></pre>
<p>Whether this solution is appropriate depends on your use case ... in particular the ChainMap will:</p>
<ul>
<li><p>not behave like a regular map when it comes to some things, like deleting keys:</p>
<pre><code>&gt;&gt;&gt; del c[0]
&gt;&gt;&gt; print(c[0])
0
</code></pre></li>
<li><p>still allow you to modify values in place</p>
<pre><code>&gt;&gt;&gt; d = dict(a=[])
&gt;&gt;&gt; collections.ChainMap({}, d)["a"].append(1)
</code></pre>
<p>will alter the list in <code>d</code></p></li>
</ul>
<p>However, if you are merely wishing to take your embedded dictionary and pop some new keys and values on it, then <code>ChainMap</code> may be appropriate.</p>
</div>
<span class="comment-copy">Is your objection to deepcopy based on efficiency only?  Is this a performance critical part of your code where this will cause a problem?</span>
<span class="comment-copy">Once you find the nested dictionary, you should only need to deep copy it once. Therefore, I'm not sure what is meant by "require constantly making copies of the dictionary"?</span>
<span class="comment-copy">@SethMMorton Not at all. Obviously a more efficient solution is always better, but my main objection is that I don't want to have to import the copy module.</span>
<span class="comment-copy">I'm always confused when I see folks trying to reinvent the wheel because of a reluctance to import from the standard library.  It's well tested code that is there for free, save yourself the time and just add <code>from copy import deepcopy</code>.</span>
<span class="comment-copy">@Karin What I meant by that is this function is being run a lot on a large dictionary, so if the alternatives are slower, I will be forced to use deepcopy.</span>
<span class="comment-copy">How does this scale to nested dictionaries (what the OP asked about)?</span>
<span class="comment-copy">This seems to be equivalent to making a shallow dictionary. If <code>d</code> has a mutable attribute like a list, modifying the list in <code>c</code> will also modify it in <code>d</code>.</span>
<span class="comment-copy">How is this different from c= copy.deepcoy(d) ?</span>
<span class="comment-copy">@Karin ... yes, as noted, it depends on your use case ...</span>
<span class="comment-copy">I just think it's important to point out this does not guarantee <code>d</code> cannot change by changing <code>c</code>, which I would have assumed from "Now we can dirty c without corresponding changes happening in d". A deepcopy does guarantee this, though.</span>
