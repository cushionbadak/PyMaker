<div class="post-text" itemprop="text">
<p>In a part of my software code written with python, I have a list of items where it size can vary greatly from 12 to only one item . For each item in this list I'm doing some processing (sending an HTTP request related to the given item, parse results and many other operations . I'd like to speed up my code using threading, I'd like to create 2 threads where each one take a number of items and do the processing async. </p>
<p><strong>Example 1</strong> : Let's say that in my list I have 12 items, each thread would take in this case 6 items and call the processing functions on each item .</p>
<p><strong>Example 2</strong> : Now let's say that my list have 9 items, one thread would take 5 items and the other thread would take the other 4 left items .</p>
<p>Currently I'm not applying any threading and my code base is very large, so here some code that do almost the same thing as my case :</p>
<pre><code>#This procedure need to be used with threading .
itemList = getItems() #This function return an unknown number of items between 1 and 12

if len(itemList) &gt; 0: # Make sure that the list is empty in this case .
    for item in itemList:
        processItem(item) #This is an imaginary function that do the processing on each item 
</code></pre>
<p>Below is a basic lite code that explain what I'm doing, I can't figure out how can I make my threads flexible, so each one take a number of items and the other take the rest (as explained in example 1 &amp; 2) .</p>
<p>Thank's for your time</p>
</div>
<div class="post-text" itemprop="text">
<p>You might rather implement it using shared queues
<a href="https://docs.python.org/3/library/queue.html#queue-objects" rel="nofollow">https://docs.python.org/3/library/queue.html#queue-objects</a></p>
<pre><code>import queue
import threading

def worker():
    while True:
        item = q.get()
        if item is None:
            break
        do_work(item)
        q.task_done()

q = queue.Queue()
threads = []
for i in range(num_worker_threads):
    t = threading.Thread(target=worker)
    t.start()
    threads.append(t)

for item in source():
    q.put(item)

# block until all tasks are done
q.join()

# stop workers
for i in range(num_worker_threads):
    q.put(None)
for t in threads:
    t.join()
</code></pre>
<p>Quoting from
<a href="https://docs.python.org/3/library/queue.html#module-queue" rel="nofollow">https://docs.python.org/3/library/queue.html#module-queue</a>:</p>
<blockquote>
<p>The queue module implements multi-producer, multi-consumer queues. It
  is especially useful in threaded programming when information must be
  exchanged safely between multiple threads.</p>
</blockquote>
<p>The idea is that you have a shared storage and each thread attempts reading items from it one-by-one. 
This is much more flexible than distributing the load in advance as you don't know how threads execution will be scheduled by your OS, how much time each iteration would take etc. 
Furthermore, you might add items for further processing to this queue dynamically — for example, having a producer thread running in parallel.</p>
<p>Some helpful links:</p>
<p>A brief introduction into concurrent programming in python:
<a href="http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency" rel="nofollow">http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency</a></p>
<p>More details on producer-consumer pattern with line-by-line explanation:
<a href="http://www.informit.com/articles/article.aspx?p=1850445&amp;seqNum=8" rel="nofollow">http://www.informit.com/articles/article.aspx?p=1850445&amp;seqNum=8</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="nofollow"><code>ThreadPoolExecutor</code></a> class from the <a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow"><code>concurrent.futures</code></a> module in Python 3. The module is not present in Python 2, but there are some workarounds (which I will not discuss).</p>
<p>A thread pool executor does basically what @ffeast proposed, but with fewer lines of code for you to write. It manages a pool of threads which will execute all the tasks that you submit to it, presumably in the most efficient manner possible. The results will be returned through <code>Future</code> objects, which represent a "pending" result.</p>
<p>Since you seem to know the list of tasks up front, this is especially convenient for you. While you can not guarantee how the tasks will be split between the threads, the result will probably be at least as good as anything you coded by hand.</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=2) as executor:
    for item in getItems():
        executor.submit(processItem, item)
</code></pre>
<p>If you need more information with the output, like some way of identifying the futures that have completed or getting results out of them, see the <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example" rel="nofollow">example</a> in the Python documentation (on which the code above is heavily based).</p>
</div>
<span class="comment-copy">Look into thread executors. Start an executor with two threads and just submit all your items to it. This has the advantage of doing all the bookkeeping for you and figuring out which thread should take the next job in such a way as to keep both maximally busy.</span>
<span class="comment-copy">This is exactly what I was going to propose, but you were faster :-).</span>
<span class="comment-copy">Some explanation of this code. All pending work items are in a <code>Queue</code>. Worker threads don't know how many items they are going to process. They take and process items one-by-one, until the end (<code>None</code>).</span>
<span class="comment-copy">Thank you very much for your input, but I'm very new to threading, I'd love you could explain your code or add some comments which would be better to understand for other newbies .</span>
<span class="comment-copy">This looks like you reinvented the thread executor. Nice code though.</span>
