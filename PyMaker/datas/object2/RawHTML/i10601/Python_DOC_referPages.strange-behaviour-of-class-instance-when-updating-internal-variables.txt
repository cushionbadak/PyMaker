<div class="post-text" itemprop="text">
<p>Let's say I define the following class in Python. </p>
<pre><code>class test():
    def __init__(self):
        self.x = 0
        self.y = self.x ** 2
    def check(self):
        self.x = self.x + 1
        print self.x
        print self.y
</code></pre>
<p>Here I have two internal variables x and y. In the initialization I have set $$ y = x^2 $$. Now each time I call the method <code>check()</code> it increments the value of x by 1 : <code>self.x = self.x + 1</code>. However when I print the values x correctly increments by 1 but y remains 0 always. (Should'nt it be x^2??) What's going wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>self.y</code> is only assigned when you <strong>first</strong> create an instance of your class. It is not updated every time you call a function. The <code>def __init__(self):</code> function is only executed when you do<br/>
<code>myVar = new test()</code>, therefore the value of y is only assigned and updated once.</p>
<p>Your code would need to be:</p>
<pre><code>class test():
    def __init__(self):
        self.x = 0
        self.y = self.x ** 2
    def check(self):
        self.x = self.x + 1
        self.y = self.x ** 2
        print self.x
        print self.y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python is not like a spreadsheet where updating one cell (variable) can automatically affect the values of others.</p>
<p>Following initialisation, the code never changes the value of <code>self.y</code>. You need to add some code to do that, e.g.</p>
<pre><code>    def check(self):
        self.x = self.x + 1
        self.y = self.x ** 2
        print self.x
    print self.y
</code></pre>
<hr/>
<p>There is a way to implement that behaviour though: use <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow">properties</a>:</p>
<pre><code>class Test(object):
    def __init__(self):
        self._x = 0
        self.y = 0

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, value):
        self._x = value
        self.y = value ** 2

    def check(self):
        self.x = self.x + 1
        print self.x, self.y

&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; for i in range(5):
...     t.check()
1 1
2 4
3 9
4 16
5 25

&gt;&gt;&gt; t.x = 200
&gt;&gt;&gt; t.y
40000
</code></pre>
<p>If you wanted you can also implement <code>y</code> as a property and have it set <code>x</code> to its square root when it's updated. This would enforce the relationship that <code>x</code> is the square root of `y`` and vice versa.</p>
</div>
<div class="post-text" itemprop="text">
<p>The variable <code>y</code> is only set when it is instantiated and does not get updated in your code.</p>
<p>You should have separate methods to update and/or increment <code>x</code> and adjust <code>y</code> as necessary, along with your method to check the values.</p>
<pre><code>class test():
    def __init__(self):
        self.x = 0
        self.y = 0
    def update_x(self, x):
        self.x = x
        self.y = x ** 2
    def increment_x(self):
        self.x += 1
        self.y = self.x ** 2
    def check(self):
        print self.x
        print self.y
</code></pre>
</div>
<span class="comment-copy">Nothing is going wrong. You never change <code>self.y</code> after you have initialized the instance, so it retains the same value it always had.</span>
<span class="comment-copy">I highly recommend Ned Batchelder's “<a href="http://nedbatchelder.com/text/names1.html" rel="nofollow noreferrer">Facts and Myths about Python Names and Values</a>” (26 minute <a href="https://www.youtube.com/watch?v=_AEJHKGk9ns" rel="nofollow noreferrer">video from PyCon US 2015</a>) for a crash course in how Python variables and assignment statements are not at all like most other languages'.  (Specifically, names always refer to values, <i>never</i> to expressions or other names.)</span>
