<div class="post-text" itemprop="text">
<p>I have some file with little-endian encoding bytes in it, I want to take <code>N</code> bytes, specify endianess  and convert them into a decimal number using python (any version). How to do it correctly?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 you can use something like this:</p>
<pre><code>int.from_bytes(byte_string, byteorder='little')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As Harshad Mulmuley' answer shows, this is easy in Python 3, using the <code>int.from_bytes</code> method. In Python 2, it's a little trickier.</p>
<p>The <code>struct</code> module is designed to handle standard C data types. It won't handle arbitrary length integers (Python 2 <code>long</code> integers), as these are not native to C. But you can convert them using a simple <code>for</code> loop. I expect that this will be significantly slower than the Python 3 way, since Python <code>for</code> loops are slower than looping at C speed, like <code>int.from_bytes</code> (probably) does.</p>
<pre><code>from binascii import hexlify

def int_from_bytes_LE(s):
    total = 0
    for c in reversed(s):
        total = (total &lt;&lt; 8) + ord(c)
    return total

# Test

data = (
    (b'\x01\x02\x03\x04', 0x04030201),
    (b'\x01\x02\x03\x04\x05\x06\x07\x08', 0x0807060504030201),
    (b'\x01\x23\x45\x67\x89\xab\xcd\xef\x01\x23\x45\x67\x89\xab\xcd\xef', 
        0xefcdab8967452301efcdab8967452301),
)

for s, u in data:
    print hexlify(s), u, int_from_bytes_LE(s)
    #print(hexlify(s), u, int.from_bytes(s, 'little'))
</code></pre>
<p><strong>output</strong></p>
<pre><code>01020304 67305985 67305985
0102030405060708 578437695752307201 578437695752307201
0123456789abcdef0123456789abcdef 318753391026855559389420636404904698625 318753391026855559389420636404904698625
</code></pre>
<p>(I put that Python 3 print call in there so you can easily verify that my function gives the same result as <code>int.from_bytes</code>).</p>
<p>If your data is <em>really</em> large and you don't want to waste RAM reversing your byte string you can do it this way:</p>
<pre><code>def int_from_bytes_LE(s):
    m = 1
    total = 0
    for c in s:
        total += m * ord(c)
        m &lt;&lt;= 8
    return total
</code></pre>
<p>Of course, that uses some RAM for <code>m</code>, but it won't be as much as the RAM used for reversing the input string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using Python 3 (or 2), you can achieve this with the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow">struct</a> library.</p>
<pre><code>with open('blob.dat', 'rb') as f:
    data = f.read(n)
</code></pre>
<p>Now, you unpack using the appropriate <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment" rel="nofollow">format specifier string</a>. For example, big-endian int:</p>
<pre><code>num = struct.unpack("&gt;i",data)
</code></pre>
</div>
<span class="comment-copy">You can probably use the struct module. How big is <code>N</code>?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1400012/endianness-of-integers-in-python">Endianness of integers in Python</a></span>
<span class="comment-copy"><code>N</code> can be up to file size.</span>
<span class="comment-copy">Ooooo I did not know that. +1</span>
<span class="comment-copy">Ok, we have a solution for Python 3. How to do this for Python 2?</span>
<span class="comment-copy">Using <code>struct</code> as @juanpa.arrivillaga has mentioned</span>
<span class="comment-copy">@warchantua: I've posted some Python 2 code. It's not as pretty as the Python 3 version, but it works. :)</span>
<span class="comment-copy"><code>struct</code> is available in Python2 as well, isn't it?</span>
<span class="comment-copy">@VPfB Yes. See the <a href="https://docs.python.org/2.7/library/struct.html#module-struct" rel="nofollow noreferrer">docs</a>.</span>
