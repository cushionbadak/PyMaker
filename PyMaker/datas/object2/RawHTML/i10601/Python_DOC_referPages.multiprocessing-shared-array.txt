<div class="post-text" itemprop="text">
<p>So I'm trying to implement multiprocessing in python where I wish to have a Pool of 4-5 processes running a method in parallel. The purpose of this is to run a total of thousand Monte simulations (250-200 simulations per process) instead of running 1000. I want each process to write to a common shared array by acquiring a lock on it as soon as its done processing the result for one simulation, writing the result and releasing the lock. So it should be a three step process :</p>
<ol>
<li>Acquire lock</li>
<li>Write result</li>
<li>Release lock for other processes waiting to write to array.</li>
</ol>
<p>Everytime I pass the array to the processes each process creates a copy of that array which I donot want as I want a common array. Can anyone help me with this by providing sample code? </p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're only returning state from the child process to the parent process, then using a shared array and explicity locks is overkill. You can use <code>Pool.map</code> or <code>Pool.starmap</code> to accomplish exactly what you need. For example:</p>
<pre><code>from multiprocessing import Pool

class Adder:
    """I'm using this class in place of a monte carlo simulator"""

    def add(self, a, b):
        return a + b

def setup(x, y, z):
    """Sets up the worker processes of the pool. 
    Here, x, y, and z would be your global settings. They are only included
    as an example of how to pass args to setup. In this program they would
    be "some arg", "another" and 2
    """
    global adder
    adder = Adder()

def job(a, b):
    """wrapper function to start the job in the child process"""
    return adder.add(a, b)

if __name__ == "__main__":   
    args = list(zip(range(10), range(10, 20)))
    # args == [(0, 10), (1, 11), ..., (8, 18), (9, 19)]

    with Pool(initializer=setup, initargs=["some arg", "another", 2]) as pool:
        # runs jobs in parallel and returns when all are complete
        results = pool.starmap(job, args)

    print(results) # prints [10, 12, ..., 26, 28] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not tested, but something like that should work.
The array and lock are shared between processes.</p>
<pre><code>from multiprocessing import Process, Array, Lock

def f(array, lock, n): #n is the dedicated location in the array
    lock.acquire()
    array[n]=-array[n]
    lock.release()

if __name__ == '__main__':
    size=100
    arr=Array('i', [3,-7])
    lock=Lock()
    p = Process(target=f, args=(arr,lock,0))
    q = Process(target=f, args=(arr,lock,1))
    p.start()
    q.start()
    q.join()
    p.join()

    print(arr[:])
</code></pre>
<p>the documentation here <a href="https://docs.python.org/3.5/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3.5/library/multiprocessing.html</a> has plenty of examples to start with</p>
</div>
<span class="comment-copy">You have tons of sample code if you search some answers. So, if you don't provide some of yours, we won't be able to help you. Btw, use <a href="https://docs.python.org/2/library/threading.html#semaphore-objects" rel="nofollow noreferrer">semaphores</a> to lock the threads</span>
<span class="comment-copy">What's unclear about the <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">examples</a> in the official documentation?</span>
<span class="comment-copy">Do you need to access the array whilst the simulations are ongoing? If not, you can just use the set of <code>Pool.map</code> functions.</span>
<span class="comment-copy">That is <i>not</i> a shared array. Changing it in a subprocess won't have any effect in the parent.</span>
<span class="comment-copy">@mata corrected the shared array</span>
<span class="comment-copy">Also, an <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Array" rel="nofollow noreferrer">Array</a> is created by default with a lock attached which you can get using its <code>get_lock()</code> method, no need to allocate it explicitly unless you want to use a different lock type. The body could then become just <code>with array.get_lock(): ...</code></span>
<span class="comment-copy">@mata I need some clarification. Do you mean that I can change the function f to just   "def f(array):     with array.get_lock():         #modify array here# "  and there is no need to create a lock object and explicitly pass it?</span>
<span class="comment-copy">@RodrikTheReader yes this is what mata explains: <a href="https://docs.python.org/2/library/multiprocessing.html#shared-ctypes-objects" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
