<div class="post-text" itemprop="text">
<p>If <code>not ''</code> evaluates to <code>True</code>, why does <code>'' == False</code> evaluates to <code>False</code>?</p>
<p>For example, the "voids" of the other types (e.g. 0, 0.0) will return <code>True</code> when compared to <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; 0 == False
True
&gt;&gt;&gt; 0.0 == False
True
</code></pre>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In the context of Boolean operations, and also when expressions are used by control flow statements, the following values are interpreted as false: <code>False</code>, <code>None</code>, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true. User-defined objects can customize their truth value by providing a <code>__bool__()</code> method.</p>
<p>The operator <code>not</code> yields <code>True</code> if its argument is false, <code>False</code> otherwise.</p>
<p><a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="noreferrer">https://docs.python.org/3/reference/expressions.html#comparisons</a></p>
</blockquote>
<p>But:</p>
<blockquote>
<p>The operators <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, and <code>!=</code> compare the values of two objects. The objects do not need to have the same type.</p>
<p>...</p>
<p>Because all types are (direct or indirect) subtypes of <code>object</code>, they inherit the default comparison behavior from <code>object</code>. Types can customize their comparison behavior by implementing rich comparison methods like <code>__lt__()</code> ...</p>
<p><a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="noreferrer">https://docs.python.org/3/reference/expressions.html#boolean-operations</a></p>
</blockquote>
<p>So, the technical implementation answer is that it behaves the way it does because <code>not</code> and <code>==</code> use different comparisons. <code>not</code> uses <code>__bool__</code>, the "truth value" of an object, while <code>==</code> uses <code>__eq__</code>, the direct comparison of one object to another. So it's possible to ask an object whether it considers itself to be <em>truthy</em> or <em>falsey</em>, and separately from that ask it whether it considers itself to be equal to another object or not. The default implementations for that are arranged in a way that two objects can both consider themselves <em>falsey</em> yet not consider themselves equal to one another.</p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't make sense for <code>''</code> and <code>[]</code> to actually equal <code>False</code>, because they are clearly different values: a string and a list. If they both equalled <code>False</code> they would have to be equal to each other*. They are just "falsey", which means they come out as false when they are converted to a boolean.</p>
<p>(* in any sensibly constructed language)</p>
<p><code>not</code> is an operation that returns a boolean. Which boolean it returns depends on whether the operand is falsey or not. So <code>not x</code> is not equivalent to <code>x==False</code>; it is equivalent to <code>bool(x)==False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to check the <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow">official explanation</a>, just cast your values like this:</p>
<pre><code>print(bool(None) == False)
print(False == False)
print(bool(0) == False)
print(bool(0.0) == False)
print(bool(0j) == False)
print(bool('') == False)
print(bool(()) == False)
print(bool([]) == False)
print(bool({}) == False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>int(False) == 0</code> and <code>int(True) == 1</code>. This is what Python is doing when it tries to evaluate <code>0 == False</code>. </p>
<p>On the other hand, <code>bool('') == False</code>. The same goes for <code>bool([])</code> and <code>bool({})</code>.</p>
<p>The fact that <code>x</code> evaluates to <code>True</code> doesn't necessarily mean that <code>x == True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Such a comparison isn't "Pythonic" (<em>i.e.</em> it isn't what an experienced Python programmer would naturally do). The Pythonic way to proceed is to use a value in a Boolean context such as an <code>if</code> statement, and leave the interpreter to apply the <code>bool</code> built-in invisibly to determine a <code>True</code> or <code>False</code> value. That's why people commonly write code such as</p>
<pre><code>if lst:
    print(headers)
    for item in lst:
        print(item.format())
else:
    print(no_data_message)
</code></pre>
<p>rather than using the commonly-seen but less Pythonic <code>if len(lst):</code> or the even clumsier but still functionally correct <code>if len(lst) &gt; 0:</code>.</p>
<p>In some respects unfortunately, Python's designer decided that <code>True</code> and <code>False</code> would be instances of the <code>bool</code> type, and that <code>bool</code> would be a subclass of <code>int</code>. As a result of this <code>True</code> compares equal to <code>1</code> and <code>False</code> compares equal to <code>0</code>. Numerical conversion accounts for the floating-point (and, for that matter, complex) result.</p>
<p>But just because a <code>bool(x) == True</code> doesn't mean <code>x == True</code>, any more than <code>bool(x) == False</code> implies <code>x == False</code>. There are many other values that evaluate false, the best-known being</p>
<ul>
<li>Numeric zeroes</li>
<li><code>None</code></li>
<li>The empty string</li>
<li>Empty containers (list, tuple, dict)</li>
</ul>
<p>There's no way they can all be equal to each other!</p>
</div>
<span class="comment-copy">empty sequence evaluates to <code>False</code>, but does not equal <code>False</code>. Read here: <a href="http://stackoverflow.com/a/9573259/6313992">stackoverflow.com/a/9573259/6313992</a> (top 2 answers cover this)</span>
<span class="comment-copy">Thanks. Nevertheless, my question remains: Why?</span>
<span class="comment-copy">@TonyPower Because this is how Python was chosen to be implemented. There's no real answer for the question "why". Also, why would an empty  list be <i>equal</i> to False? it is still a list, just an empty one.</span>
<span class="comment-copy">Fantastic!!! That is what I wanted to hear ;)</span>
<span class="comment-copy"><i>cough</i> Behold PHP's logic: <code>[] == false; '' == false; [] != '';</code> Yup…</span>
<span class="comment-copy">Hence my note at *</span>
<span class="comment-copy">Yeah, I know… :o)</span>
<span class="comment-copy">So, you are saying that it is not sensible to say that <code>''</code> is <code>False</code> but it makes sense to say that <code>0</code> is? I know boolean logic is all about zeroes and ones, nevertheless, it makes as much sense to me to say that <code>''</code> is <code>False</code> as it makes sense saying <code>not ''</code> is True.</span>
<span class="comment-copy">The Python expression <code>'' is False</code> evaluates false, because <code>is</code> only returns True when the operands are references to the same object. <code>'' is True</code> also evaluates false, for exactly the same reason.</span>
<span class="comment-copy">And if you switch things around? For example:  <code>False == 0</code>  Is it doing <code>False == bool(0)</code>?  If so, it should do the same with the empty string, and is not doing it.</span>
<span class="comment-copy">"That is the reason that <code>is</code> should be used in checks against a boolean value and not <code>==</code>" -- I don't see how this follows</span>
<span class="comment-copy">The tests <code>x is True</code> and <code>x is False</code> are, for most values of <code>x</code>, both False, so your advice that <code>is</code> should be used is dangerously wrong.</span>
<span class="comment-copy">Also, understand the mechanism that is used. The interpreter applies the <code>bool</code> function to values.  <code>bool</code> returns either <code>True</code> or <code>False</code>.</span>
<span class="comment-copy">It makes sense. Thanks.</span>
