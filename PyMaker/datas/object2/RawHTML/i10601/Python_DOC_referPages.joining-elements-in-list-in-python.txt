<div class="post-text" itemprop="text">
<p>I have the data below, I want to find the unique values in 'a' and sum the data for the corresponding indices from 'b', 'c'. Any ideas on the best way to do this? I'm not sure where to start.</p>
<pre><code>a = ['x', 'y', 'z', 'z', 'x', 'w']
b = [  1,   4,   5,   7,   9,  5]
c = [  3,   6,   7,   8,   9,  7]
</code></pre>
<p>After processing,</p>
<pre><code>a = ['x', 'y',  'z',  'w']
b = [ 10,   4,   12,   5 ]
c = [ 12,   6,   15,   7 ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could do something like this using <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow">OrderedDict</a>, since you need to maintain the same order:</p>
<pre><code>from collections import OrderedDict

a = ['x', 'y', 'z', 'z', 'x', 'w']
b = [  1,   4,   5,   7,   9,  5]
c = [  3,   6,   7,   8,   9,  7]
b_data = OrderedDict()
c_data = OrderedDict()

for letter, b_value, c_value in zip(a, b, c):
    if letter in b_data:
        b_data[letter] += b_value
        c_data[letter] += c_value
    else:
        b_data[letter] = b_value
        c_data[letter] = c_value

a = b_data.keys()
b = b_data.values()
c = c_data.values()


print(a)
print(b)
print(c)
</code></pre>
<p>Output:</p>
<pre><code>['x', 'y', 'z', 'w']
[10, 4, 12, 5]
[12, 6, 15, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>collections.defaultdict</code>:</p>
<pre><code>from collections import defaultdict

a = ['x', 'y', 'z', 'z', 'x', 'w']
b = [  1,   4,   5,   7,   9,  5]
c = [  3,   6,   7,   8,   9,  7]

b_unique = collections.defaultdict(int)
c_unique = collections.defaultdict(int)
for k, bv, cv in zip(a,b,c):
    b_unique[k] += bv
    c_unique[k] += cv
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using Pandas:</p>
<pre><code>import pandas as pd

# To keep original order of values.
a_ordered = [val for idx, val in enumerate(a) if val not in a[:idx]]
# &gt;&gt;&gt; a_ordered
# OUT: ['x', 'y', 'z', 'w']

df = pd.DataFrame({'a': a, 'b': b, 'c': c}).groupby('a').sum().T[a_ordered]
a = df.columns.tolist()
b, c = df.values.tolist()

&gt;&gt;&gt; a
['x', 'y', 'z', 'w']

&gt;&gt;&gt; b
[10, 4, 12, 5]

&gt;&gt;&gt; c
[12, 6, 15, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just felt like playing a little code-golf:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; od = OrderedDict()
&gt;&gt;&gt; for t in zip(a,zip(b,c)):
...   od[t[0]] = [i + x for i,x in zip(od.get(t[0],[0,0]), t[1])]
... 
&gt;&gt;&gt; od
OrderedDict([('x', [10, 12]), ('y', [4, 6]), ('z', [12, 15]), ('w', [5, 7])])
&gt;&gt;&gt; a = list(od.keys())
&gt;&gt;&gt; b,c = map(list,zip(*od.values()))
&gt;&gt;&gt; a
['x', 'y', 'z', 'w']
&gt;&gt;&gt; b
[10, 4, 12, 5]
&gt;&gt;&gt; c
[12, 6, 15, 7]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is an elementary approach</p>
<pre><code>d1 = defaultdict(int)
d2 = defaultdict(int)
for x,y,z in zip(a,b,c):
    d1[x] += y
    d2[x] += z

an=list()
bn=list()
cn=list()

for k in sorted(d1.keys(), key=lambda x:a.index(x)):
    an.append(k)
    bn.append(d1[k])
    cn.append(d2[k])

[an,bn,cn]


[['x', 'y', 'z', 'w'], [10, 4, 12, 5], [12, 6, 15, 7]]
</code></pre>
</div>
<span class="comment-copy">start with <code>for i,ltr in enumerate(a)</code></span>
<span class="comment-copy">Does the order of items in <code>a</code> matter?</span>
<span class="comment-copy">Yes, I need to keep the original order.</span>
<span class="comment-copy"><code>for letter, b_value, c_value in zip(a, b, c):</code> would make this a little shorter.</span>
<span class="comment-copy"><code>b_data[letter] = b_data.get(letter, 0) + b_value</code> would also be shorter but perhaps less readable.</span>
<span class="comment-copy">@StevenRumbalski: thanks for the suggestions! I've updated to use your first suggestion</span>
<span class="comment-copy"><code>defaultdict</code> was my first thought, but the OP states that the order of the keys matters.</span>
<span class="comment-copy"><code>for k,bv,cv in zip(a,b,c):v1,v2=od.get(k,(0,0));od[k]=(bv+v1,cv+v2)</code></span>
