<div class="post-text" itemprop="text">
<p>I'd like to slice a list of strings based on substrings <em>possibly</em> contained into its elements:</p>
<pre><code>l = ['Some long text', 'often begins', ' with ',
     'impenetrable fog ', 'which ends', ' somewhere further']
startIndex = [u for u, v in enumerate(l) if 'begins' in v)][0]
finalIndex = [u for u, v in enumerate(l) if 'ends' in v)][0]
</code></pre>
<p>so that I'd get:</p>
<pre><code>' '.join(l[startIndex:finalIndex]) == 'often begins with impenetrable fog'   
</code></pre>
<p>My main problem being that the beginning and end conditions used to get indexes are different and should be variable (basic substring containment as above-mentioned, regexes or other methods possible).</p>
<p>First and last elements might need to be stripped out but I guess this is a matter of adjusting indexes by 1.
My code works in the ideal cases but will often fail as structure and contents of <code>l</code> are not very predictable. Absence of one or both elements matching conditions should end up with the final string being <code>None</code>.</p>
<p>Are comprehensions relevant, or mapping a lambda function to apply both conditions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>l = ['Some long text', 'often begins', 'with', 'impenetrable fog', 'which ends', 'somewhere further']

"""
return the index of the phase in 'phases' if phase contains 'word'
if not found, return 'default'
"""
def index(phases, word, default):
    for i, s in enumerate(phases):
        if word in s: return i
    return default

startIndex = index(l, "long", -1)
finalIndex = index(l, "somewhere", len(l))

print(' '.join(l[startIndex+1:finalIndex]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; l = ['Some long text', 'often begins', ' with ',
...      'impenetrable fog ', 'which ends', ' somewhere further']
&gt;&gt;&gt; start, end = 'begins', 'ends'
&gt;&gt;&gt; key_index = {'start': {'word': start, 'index': -1}, 
                 'end': {'word': end, 'index': -1}}
&gt;&gt;&gt; for i, val in enumerate(l):
...     if key_index['start']['word'] in val:
...         key_index['start']['index'] = i
...     elif key_index['end']['word'] in val:
...         key_index['end']['index'] = i
...
&gt;&gt;&gt; start_index, end_index = key_index['start']['index'], key_index['end']['index']
&gt;&gt;&gt; my_list = l[start_index+1:end_index] if start_index &gt;=0 and end_index &gt;= 0 and start_index+1 &lt; end_index else None
&gt;&gt;&gt; my_list
[' with ', 'impenetrable fog ']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or with <a href="https://docs.python.org/2/library/functions.html#next" rel="nofollow"><code>next()</code></a>:</p>
<pre><code>l = ['Some long text', 'often begins', ' with ', 'impenetrable fog ', 
     'which   ends', ' somewhere further']

startIndex = next((u for u, v in enumerate(l) if 'begins' in v), 0)
finalIndex = next((u for u, v in enumerate(l) if 'ends' in v), 0)

if (startIndex and finalIndex) and (finalIndex &gt; startIndex):
    sentence = ' '.join(l[startIndex:finalIndex])
else:
    sentence = None
print(sentence)
</code></pre>
<p>Similar as list comprehension, execpt it doesn't return a list but the first element it found. if it doesn't found anything, it return an optional element (here <code>'0'</code>)</p>
<p>This way, if there is no <code>'begins'</code> or no <code>'ends'</code> in your list, you don't have to print anything. Therefore, this allows you to check either if the <code>'ends'</code> comes before the <code>'begins'</code>. </p>
<p>I also love list comprehension but sometimes what you need isn't a list.</p>
<p><strong>SOLUTION FOR ADVANCE USER:</strong></p>
<p>The problem with the use of two comprehension list, is that you check twice your list from start and it will fail when <code>ends</code> comes before start:</p>
<pre><code>l = ['Some long text ends here',  'often begins', ' with ', 'which   ends']
                     ^^^
</code></pre>
<p>To avoid this, you might use a generator with <a href="https://docs.python.org/3/reference/expressions.html#examples" rel="nofollow"><code>send()</code></a> to only iterate once on your list.</p>
<pre><code>def get_index(trigger_word):
    for u, v in enumerate(l):
        if trigger_word in v:
            trigger_word = yield u

gen = get_index('begins')
startIndex = gen.send(None)
finalIndex = gen.send('ends')
</code></pre>
<p>Here, the <code>yield</code> allows you to get the index without exiting the function.</p>
<p>This is better, but if there is no <code>begins</code> or <code>ends</code>in the list, there will be a <a href="https://docs.python.org/2/library/exceptions.html#exceptions.StopIteration" rel="nofollow">StopIteration</a> exception. To avoid this, you can just do a infinite loop on <code>yield</code> 0 instead. Now the complete solution will be:</p>
<pre><code>def get_index(l, trigger_word):
    for u, v in enumerate(l):
        if trigger_word in v:
            trigger_word = yield u
    while True:
        yield 0

def concat_with_trigger_words(l):           
    gen = get_index(l, 'begins')
    startIndex = gen.send(None)
    finalIndex = gen.send('ends')
    return ' '.join(l[startIndex:finalIndex]) if (startIndex and finalIndex) else None

# Here some list for free lists for your future unitary tests ;)

l_orignal = ['Some long text here',  'often begins', ' with ', 
             'impenetrable fog ', 'which   ends', ' somewhere further']
l_start_with_ends = ['ends',  'often begins', ' with ', 
                     'impenetrable fog ', 'which   ends', 'begins']
l_none = ['random', 'word']
l_without_begin = ['fog', 'ends here']
l_without_end = ['begins', 'but never' '...']

print(concat_with_trigger_words(l_orignal)) # often begins  with  impenetrable fog 
print(concat_with_trigger_words(l_start_with_ends)) # often begins  with  impenetrable fog 
print(concat_with_trigger_words(l_none)) # None
print(concat_with_trigger_words(l_without_end)) # None
print(concat_with_trigger_words(l_without_begin)) # None
</code></pre>
</div>
<span class="comment-copy">Can you please provide the clear example? Do you want all the <code>strings</code> in <code>list</code> between the <code>start</code> and <code>end</code> string. For example: <code>['How May', 'I help', 'You with', 'Your Problem', 'Andreas']</code>.  With start = <code>help</code>, and end = <code>Problem</code>. What should be your required output?</span>
<span class="comment-copy">Yes I'd like to get <code>'You with Your Problem'</code> as output with your example. Thanks for replying anyway!</span>
<span class="comment-copy">By the way, what did you already try with map and lambda functions?</span>
