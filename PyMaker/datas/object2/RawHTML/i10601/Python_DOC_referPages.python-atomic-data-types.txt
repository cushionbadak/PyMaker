<div class="post-text" itemprop="text">
<p>It was written <a href="https://ru.wikipedia.org/wiki/Python" rel="nofollow">here</a> that Python has both atomic and reference object types. Atomic objects are: int, long, complex.
When assigning atomic object, it's value is copied, when assigning reference object it's reference is copied.</p>
<p>My question is:
why then, when i do the code bellow i get 'True'?</p>
<pre><code>a = 1234
b = a
print id(a) == id(b)
</code></pre>
<p>It seems to me that i don't copy value, i just copy reference, no matter what type it is. </p>
</div>
<div class="post-text" itemprop="text">
<p>Assignment (binding) in Python NEVER copies data. It ALWAYS copies a reference to the value being bound.</p>
<p>The interpreter computes the value on the right-hand side, and the left-hand side is bound to the new value by referencing it. If expression on the right-hand side is an existing value (in other words, if no operators are required to compute its value) then the left-hand side will be a reference to the same object.</p>
<p>After</p>
<pre><code>a = b
</code></pre>
<p>is executed,</p>
<pre><code>a is b
</code></pre>
<p>will ALWAYS be true - that's how assignment works in Python. It's also true for containers, so <code>x[i].some_attribute = y</code> will make <code>x[i].some_attribute is y</code> true.</p>
<p>The assertion that Python has atomic types and reference types seems unhelpful to me, if not just plain untrue. I'd say it has atomic types and container types. Containers are things like lists, tuples, dicts, and instances with private attributes (to a first approximation).</p>
<p>As @BallPointPen helpfully pointed out in their comment, mutable values can be altered without needing to re-bind the reference. Since immutable values cannot be altered, references must be re-bound in order to refer to a different value.</p>
<p>Edit: Recently reading <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="nofollow noreferrer">the English version</a> of <a href="https://ru.wikipedia.org/wiki/Python" rel="nofollow noreferrer">the quoted page</a> (I'm afraid I don't understand Russian) I see "Python uses dynamic typing, and a combination of reference counting and a cycle-detecting garbage collector for memory management." It's possible the Russian page has mistranslated this to give a false impression of the language, or that it was misunderstood by the OP. But Python doesn't have "reference types" except in the most particular sense for <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer">weakrefs</a> and similar constructs.</p>
</div>
<div class="post-text" itemprop="text">
<p>int types are immutable.
what you see is the reference for the number 1234 and that will never change.</p>
<p>for mutable object like list, dictionary you can use</p>
<pre><code>import copy
a = copy.deepcopy(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually like @spectras said there are only references but there are immutable objects like <code>float</code>s, <code>int</code>s, <code>tuple</code>s. For immutable objects (apart from memory consumption) it just does not matter if you pass around references or create copies.</p>
<p>The interpreter even does some optimizations making use of numbers with the same value being interchangeable making checking numbers for identity interesting because eg for </p>
<pre><code>a=1
b=1
c=2/2
d=12345 
e=12345*1
</code></pre>
<p><code>a is b</code> is true and <code>a is c</code> is also true but <code>d is e</code> is false (<code>==</code> works normally as expected)</p>
<p>Immutable objects are atomic the way that <em>changing</em> them is threadsafe because you do not actually change the object itself but just put a new reference in a variable (which is threadsafe).</p>
</div>
<span class="comment-copy">That page is wrong then.</span>
<span class="comment-copy">In Python simple assignment (<code>name = something</code>) never creates copies.  See <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a> by <a href="http://stackoverflow.com/users/14343/ned-batchelder">Ned Batchelder</a>.</span>
<span class="comment-copy">Python only has references. More interesting is whether they refer to mutable or immutable objects.</span>
<span class="comment-copy">Since the value <i>is</i> atomic and <i>immutable</i>, why would Python need to create a copy of this simple number? <code>1234</code> is <code>1234</code>, it only needs to be stored in memory once.</span>
<span class="comment-copy">Thanks for your answer!</span>
<span class="comment-copy">The reason it "feels" like Python differentiates between value types and reference types is that some types are immutable, which means the only way to change the value of a variable of that type is to reassign, pulling the reference off of the old value. You can even check that <code>a = 1; print(id(a)); a += 1; print(id(a))</code> will produce two different values of <code>id</code>. Meanwhile mutable types can be modified in place, which makes them feel more reference-y. The real distinction lies in (im)mutability.</span>
<span class="comment-copy">Good point, which I have added as an edit.</span>
