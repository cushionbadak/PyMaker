<div class="post-text" itemprop="text">
<p>I have ~5M csv files stored in ~100.000 folders. Each folder contains roughly the same number of files and there's always an even number of files in a folder. I need to find the paths to all these files and load them into a list in a somewhat strange order for a statistical modeling project.</p>
<p>In particular, I need the following to be upheld:</p>
<ul>
<li>Uniqueness: Each file must only be in the list once</li>
<li>Pairs: Each file must be next to another file from the same folder (it can be next to two if due to randomness)</li>
<li>Randomness: The probability of any two files that are not "paired" being next to each other should be the same (i.e. it wouldn't work just to iterative over all files)</li>
</ul>
<p>I've created an example below.</p>
<p><strong>Files</strong></p>
<pre><code>Folder_1
- File_A
- File_B
- File_C
- File_D
Folder_2
- File_E
- File_F
- File_G
- File_H
</code></pre>
<p><strong>Good Result (randomized, but upholds the rule of pairs)</strong></p>
<pre><code>paths = ['Folder_1/File_A', 'Folder_1/File_D', 'Folder_2/File_G',  'Folder_2/File_F',  'Folder_2/File_E', 'Folder_2/File_H', 'Folder_1/File_C', 'Folder_1/File_B']
</code></pre>
<p>A simple approach might be something like "Pick a random folder, pick a random file in that folder and a random pair in the folder. Save these picks in a list to avoid getting picked again. Repeat.". However, that would take far too long. Can you recommend a good strategy for creating this list? The randomness requirement can be relaxed a bit if needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to ensure that everything's random is to use <code>random.shuffle</code>, which shuffles a list inplace. That way you can simply pair each item with its neighbor, safe in the knowledge that the pairing is random. To achieve a result like your example you can then shuffle and flatten the resulting list of pairs. Here's an example:</p>
<pre><code>from random import shuffle

# generate some sample directory names
ls = [[]] * 5
i = 0
while i &lt; len(ls):
    ls[i] = [str(i) + chr(j) for j in range(97,101)]
    i += 1

# shuffle files within each directory
pairs = []
for l in ls:
    shuffle(l)
    pairs += list(zip(l[1::2], l[::2]))

# shuffle and flatten the list of pairs
shuffle(pairs)
flat = [item for sublist in pairs for item in sublist]    
print(flat)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best strategy would be to divide and conquer with some help from threading. You want to get the file names loaded into memory as quick as possible for fastest completion.</p>
<p>First step would be to create a queue for the folder names and another for the list of the files in each folder. Something like:</p>
<pre><code>folders = queue.Queue()
files = queue.Queue()
</code></pre>
<p>A Queue is a lot like a list, only it can be shared safely between different threads. Using threads to tackle multiple folders at once will speed up processing time.</p>
<p>Create a function that will get the paths to each folders, then store each path "folders" queue.</p>
<pre><code>folderPaths = getFolderPaths()
for path in folderPaths:
    folders.put(path)
</code></pre>
<p>Eventually you will end up with a queue with all the folder paths in it (e.g. ["Folder A", "Folder B", ...])</p>
<p>Make a worker function for the threads that will go through all the files in a folder and store the names of each in a list. The general idea is:</p>
<pre><code>def threadJob():
    while True:
        folderPath = folders.get()
        if folderPath is None:
           break
        fileNames = getFilesInFolder(folderPath)
        files.put(fileNames)
</code></pre>
<p>Here "getFilesInFolder()" is a function that takes in a path argument and returns a list of all the files in that folder.</p>
<p>By the time all the threads are finished, "files" should be full of lists of files for each folder. Now you need to empty the queue into a regular list.</p>
<pre><code>fileList = []
file = files.get()
while file not None:
    fileList.append(file)
    file = files.get()
</code></pre>
<p>Now you have a list of lists. Shuffle each of the lists to randomize the file order:</p>
<pre><code>for files in fileList:
    random.shuffle(files)
</code></pre>
<p>Now you can create the final list (statList) and pop off pairs of files from randomly chosen sub-lists until all the files have been appended:</p>
<pre><code>statList = []

while len(finalFileList &gt; 0):
    index = random.randrange(len(fileList))
    if len(fileList[index]) == 0:
        fileList.pop(index)
    else:
        statList.append(fileList.pop())
        statList.append(fileList.pop())
</code></pre>
<p>No guarantees that this will be speedy, but it's the fastest method I can think of. </p>
<p>More information about queues and threading if interested:</p>
<p><a href="https://docs.python.org/3/library/queue.html" rel="nofollow">https://docs.python.org/3/library/queue.html</a></p>
<p><a href="http://www.tutorialspoint.com/python3/python_multithreading.htm" rel="nofollow">http://www.tutorialspoint.com/python3/python_multithreading.htm</a></p>
</div>
<span class="comment-copy">have you attempted anything?</span>
<span class="comment-copy">Yes, I've done a crude version of the simple approach I described at the bottom.</span>
<span class="comment-copy">Do file/folder names follow a pattern?</span>
<span class="comment-copy">Do you need to make it a list? Or could it be, e.g. a generator?</span>
<span class="comment-copy">A generator could work as well. There's no patterns in the naming.</span>
<span class="comment-copy">Thanks - this works! I have a very related task, where I need to find a list like this, but where each pair must contain files in different folders. The other requirements still apply. Do you have a suggestion for how to modify your solution for this related task?</span>
<span class="comment-copy">Sure! I'd just flatten the original list then shuffle it. Since you have 100,000 folders the chances of each pair of two files coming from the same folder are tiny, so although it's not a guarantee it should work just fine.</span>
<span class="comment-copy">Yeah, I was also considering it. Maybe I should just ignore that small chance of errors :) Thanks.</span>
