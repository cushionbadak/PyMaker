<div class="post-text" itemprop="text">
<p>This has given me a lot of trouble, and I am perplexed by the incompatibility of numpy arrays with pandas series. When I create a boolean array using a series, for instance</p>
<pre><code>x = np.array([1,2,3,4,5,6,7])
y = pd.Series([1,2,3,4,5,6,7])
delta = np.percentile(x, 50)
deltamask =  x- y &gt; delta
</code></pre>
<p>delta mask creates a boolean pandas series.</p>
<p>However, if you do</p>
<pre><code>x[deltamask]
y[deltamask]
</code></pre>
<p>You find that the array ignores completely the mask. No error is raised, but you end up with two objects of different length. This means that an operation like</p>
<pre><code>x[deltamask]*y[deltamask]
</code></pre>
<p>results in an error:</p>
<pre><code>print type(x-y)
print type(x[deltamask]), len(x[deltamask])
print type(y[deltamask]),  len(y[deltamask])
</code></pre>
<p>Even more perplexing, I noticed that the operator &lt; is treated differently. For instance</p>
<pre><code>print type(2*x &lt; x*y)
print type(2 &lt;  x*y) 
</code></pre>
<p>will give you a pd.series and np.array respectively. </p>
<p>Also,</p>
<pre><code>5 &lt; x - y
</code></pre>
<p>results in a series, so it seems that the series takes precedence, whereas the boolean elements of a series mask are promoted to integers when passed to a numpy array and result in a sliced array.</p>
<p>What is the reason for this?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Fancy Indexing</strong></p>
<p>As numpy currently stands, fancy indexing in numpy works as follows:</p>
<ol>
<li><p>If the thing between brackets is a <code>tuple</code> (whether with explicit parens or not), the elements of the tuple are indices for different dimensions of <code>x</code>. For example, both <code>x[(True, True)]</code> and <code>x[True, True]</code> will raise <code>IndexError: too many indices for array</code> in this case because <code>x</code> is 1D. However, before the exception happens, a telling warning will be raised too: <code>VisibleDeprecationWarning: using a boolean instead of an integer will result in an error in the future</code>.</p></li>
<li><p>If the thing between brackets is <strong>exactly</strong> an <code>ndarray</code>, not a subclass or other array-like, and has a boolean type, it will be applied as a mask. This is why <code>x[deltamask.values]</code> gives the expected result (empty array since <code>deltamask</code> is all <code>False</code>.</p></li>
<li><p>If the thing between brackets is any array-like, whether a subclass like <code>Series</code> or just a <code>list</code>, or something else, it is converted to an <code>np.intp</code> array (if possible) and used as an integer index. So <code>x[deltamask]</code> yeilds something equivalent to <code>x[[False] * 7]</code> or just <code>x[[0] * 7]</code>. In this case, <code>len(deltamask)==7</code> and <code>x[0]==1</code> so the result is <code>[1, 1, 1, 1, 1, 1, 1]</code>.</p></li>
</ol>
<p>This behavior is counterintuitive, and the <code>FutureWarning: in the future, boolean array-likes will be handled as a boolean array index</code> it generates indicates that a fix is in the works. I will update this answer as I find out about/make any changes to numpy.</p>
<p>This information can be found in Sebastian Berg's response to my initial query on Numpy discussion <a href="https://mail.scipy.org/pipermail/numpy-discussion/2016-August/075908.html" rel="nofollow">here</a>.</p>
<p><strong>Relational Operators</strong></p>
<p>Now let's address the second part of your question about how the comparison works. Relational operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) work by calling the corresponding method on one of the objects being compared. For <code>&lt;</code> this is <code>__lt__</code>. However, instead of just calling <code>x.__lt__(y)</code> for the expression <code>x &lt; y</code>, Python actually checks the types of the objects being compared. If <code>y</code> is a subtype of <code>x</code> that implements the comparison, then Python prefers to call <code>y.__gt__(x)</code> instead, regardless of how you wrote the original comparison. The only way that <code>x.__lt__(y)</code> will get called if <code>y</code> is a subclass of <code>x</code> is if <code>y.__gt__(x)</code> returns <code>NotImplemented</code> to indicate that the comparison is not supported in that direction.</p>
<p>A similar thing happens when you do <code>5 &lt; x - y</code>. While <code>ndarray</code> is not a subclass of <code>int</code>, the comparison <code>int.__lt__(ndarray)</code> returns <code>NotImplemented</code>, so Python actually ends up calling <code>(x - y).__gt__(5)</code>, which is of course defined and works just fine.</p>
<p>A much more succinct explanation of all this can be found in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">Python docs</a>.</p>
</div>
<span class="comment-copy"><code>pandas</code> data structures are built on top of <code>numpy</code> arrays. <code>Series</code> do play <b><i>somewhat</i></b> nicely with <code>numpy</code> arrays, they're not really <code>numpy</code> arrays. Also, what do you mean by: <i>the series ignores completely the mask.</i>? <code>deltamask</code> is all <code>False</code>, so the <code>Series</code> should not return any values.</span>
<span class="comment-copy">Sorry, I meant the other way around. Series do not respect array masks and arrays do not respect series masks.</span>
<span class="comment-copy">I think <code>Series</code> do respect <code>numpy array</code> masks; check again. But numpy arrays don't seem to be taking <code>Series</code> masks (that's quite interesting, actually). But <code>x[deltamask.values]</code> does do the trick.</span>
<span class="comment-copy">The issue is with numpy slicing. For some reason, it only accepts raw <code>ndarray</code> as a boolean mask. <code>x[deltamask]</code> gets interpreted as <code>x[[0, 0, ..., 0]]</code> rather than <code>x[[False, False, ..., False]]</code>, so the result is <code>[1, 1, ..., 1]</code>. I will look into this.</span>
<span class="comment-copy">The <code>False</code> elements of the Series get promoted to integer 0 for some reason. I get the following warning when I index <code>x[deltamask]</code>: <code>FutureWarning: in the future, boolean array-likes will be handled as a boolean array index</code>. This is a good indication of the fact that numpy devs are aware of the issue and have a fix coming.</span>
