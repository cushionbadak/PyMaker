<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/29747224/append-to-a-list-defined-in-a-tuple-is-it-a-bug">Append to a list defined in a tuple - is it a bug? [duplicate]</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I was just toying around in the interpreter and ran across something that I do not understand. When I create a tuple with a list as one the elements and then try to update that list, something strange happens. For example, when I run this:</p>
<pre><code>tup = (1,2,3,[4,5])
tup[3] += [6]
</code></pre>
<p>I get: </p>
<pre><code>TypeError: 'tuple' object does not support item assignment
</code></pre>
<p>Which is exactly what I expected. However then when I reference the tuple again, I get:</p>
<pre><code>&gt;&gt;&gt; tup
(1, 2, 3, [4, 5, 6])
</code></pre>
<p>So the list was in fact updated even though python threw an exception. How does that work? I can't imagine a scenario where I would actually want to do something like this, but I still would like to understand what is going on. Thank you. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually documented in the <a href="https://docs.python.org/3/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" rel="noreferrer">Python docs</a>.</p>
<p><strong>EDIT</strong>: Here's a summary so that this is a more complete answer.</p>
<ol>
<li>When we use <code>+=</code>, Python calls the <code>__iadd__</code> magic method on the item, then uses the return value in the subsequent item assignment.</li>
<li>For lists, <code>__iadd__</code> is equivalent to calling <code>extend</code> on the list and then returning the list.</li>
<li><p>Therefore, when we call <code>tup[3] += [6]</code>, it is equivalent to:</p>
<pre><code>result = tup[3].__iadd__([6])
tup[3] = result
</code></pre></li>
<li><p>From #2, we can determine this is equivalent to:</p>
<pre><code>result = tup[3].extend([6])
tup[3] = result
</code></pre></li>
<li>The first line succeeds in calling <code>extend</code> on the list, and since the list is mutable, it updates. However, the subsequent assignment fails because tuples are immutable, and throws the error.</li>
</ol>
</div>
<span class="comment-copy">I think the answer would benefit from the addition that it is because the extend isn't just <code>tup[3].__iadd__([6])</code>; it is <code>tup[3] = tup[3].__iadd__([6])</code>.  It's merely convenient that <code>list.__iadd__</code> returns the same object that it is mutating.</span>
<span class="comment-copy">Thanks for the link to the docs! That's a big help.</span>
<span class="comment-copy">Thanks, I didn't catch this in the docs. So to make sure I understand this right, basically in my example the list is updated because i am just doing tup[3].__iadd__([6]) and THEN python attempts (and fails at) the item assignment on the tuple? So I get the exception saying that it failed, but by that point we have already updated the list?</span>
<span class="comment-copy">I updated my answer to try to summarize what the docs say - I hope that's ok! :)</span>
