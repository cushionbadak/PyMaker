<div class="post-text" itemprop="text">
<p>From something like this:</p>
<pre><code>print(get_indentation_level())

    print(get_indentation_level())

        print(get_indentation_level())
</code></pre>
<p>I would like to get something like this:</p>
<pre><code>1
2
3
</code></pre>
<p>Can the code read itself in this way?</p>
<p>All I want is the output from the more nested parts of the code to be more nested. In the same way that this makes code easier to read, it would make the output easier to read. </p>
<p>Of course I could implement this manually, using e.g. <code>.format()</code>, but what I had in mind was a custom print function which would <code>print(i*' ' + string)</code> where <code>i</code> is the indentation level. This would be a quick way to make readable output on my terminal. </p>
<p>Is there a better way to do this which avoids painstaking manual formatting?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want indentation in terms of nesting level rather than spaces and tabs, things get tricky. For example, in the following code:</p>
<pre><code>if True:
    print(
get_nesting_level())
</code></pre>
<p>the call to <code>get_nesting_level</code> is actually nested one level deep, despite the fact that there is no leading whitespace on the line of the <code>get_nesting_level</code> call. Meanwhile, in the following code:</p>
<pre><code>print(1,
      2,
      get_nesting_level())
</code></pre>
<p>the call to <code>get_nesting_level</code> is nested zero levels deep, despite the presence of leading whitespace on its line.</p>
<p>In the following code:</p>
<pre><code>if True:
  if True:
    print(get_nesting_level())

if True:
    print(get_nesting_level())
</code></pre>
<p>the two calls to <code>get_nesting_level</code> are at different nesting levels, despite the fact that the leading whitespace is identical.</p>
<p>In the following code:</p>
<pre><code>if True: print(get_nesting_level())
</code></pre>
<p>is that nested zero levels, or one? In terms of <code>INDENT</code> and <code>DEDENT</code> tokens in the formal grammar, it's zero levels deep, but you might not feel the same way.</p>
<hr/>
<p>If you want to do this, you're going to have to tokenize the whole file up to the point of the call and count <code>INDENT</code> and <code>DEDENT</code> tokens. The <a href="https://docs.python.org/2/library/tokenize.html"><code>tokenize</code></a> module would be very useful for such a function:</p>
<pre><code>import inspect
import tokenize

def get_nesting_level():
    caller_frame = inspect.currentframe().f_back
    filename, caller_lineno, _, _, _ = inspect.getframeinfo(caller_frame)
    with open(filename) as f:
        indentation_level = 0
        for token_record in tokenize.generate_tokens(f.readline):
            token_type, _, (token_lineno, _), _, _ = token_record
            if token_lineno &gt; caller_lineno:
                break
            elif token_type == tokenize.INDENT:
                indentation_level += 1
            elif token_type == tokenize.DEDENT:
                indentation_level -= 1
        return indentation_level
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yeah, that's definitely possible, here's a working example:</p>
<pre><code>import inspect

def get_indentation_level():
    callerframerecord = inspect.stack()[1]
    frame = callerframerecord[0]
    info = inspect.getframeinfo(frame)
    cc = info.code_context[0]
    return len(cc) - len(cc.lstrip())

if 1:
    print get_indentation_level()
    if 1:
        print get_indentation_level()
        if 1:
            print get_indentation_level()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>sys.current_frame.f_lineno</code> in order to get the line number. Then in order to find the number of indentation level you need to find the previous line with zero indentation then be subtracting the current line number from that line's number you'll get the number of indentation:</p>
<pre><code>import sys
current_frame = sys._getframe(0)

def get_ind_num():
    with open(__file__) as f:
        lines = f.readlines()
    current_line_no = current_frame.f_lineno
    to_current = lines[:current_line_no]
    previous_zoro_ind = len(to_current) - next(i for i, line in enumerate(to_current[::-1]) if not line[0].isspace())
    return current_line_no - previous_zoro_ind
</code></pre>
<p>Demo:</p>
<pre><code>if True:
    print get_ind_num()
    if True:
        print(get_ind_num())
        if True:
            print(get_ind_num())
            if True: print(get_ind_num())
# Output
1
3
5
6
</code></pre>
<p>If you want the number of the indentation level based on the previouse lines with <code>:</code> you can just do it with a little change:</p>
<pre><code>def get_ind_num():
    with open(__file__) as f:
        lines = f.readlines()

    current_line_no = current_frame.f_lineno
    to_current = lines[:current_line_no]
    previous_zoro_ind = len(to_current) - next(i for i, line in enumerate(to_current[::-1]) if not line[0].isspace())
    return sum(1 for line in lines[previous_zoro_ind-1:current_line_no] if line.strip().endswith(':'))
</code></pre>
<p>Demo:</p>
<pre><code>if True:
    print get_ind_num()
    if True:
        print(get_ind_num())
        if True:
            print(get_ind_num())
            if True: print(get_ind_num())
# Output
1
2
3
3
</code></pre>
<p>And as an alternative answer here is a function for getting the number of indentation (whitespace):</p>
<pre><code>import sys
from itertools import takewhile
current_frame = sys._getframe(0)

def get_ind_num():
    with open(__file__) as f:
        lines = f.readlines()
    return sum(1 for _ in takewhile(str.isspace, lines[current_frame.f_lineno - 1]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; help(inspect.indentsize)
Help on function indentsize in module inspect:

indentsize(line)
    Return the indent size, in spaces, at the start of a line of text.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To solve the ”real” problem that lead to your question you could implement a contextmanager which keeps track of the indention level and make the <code>with</code> block structure in the code correspond to the indentation levels of the output. This way the code indentation still reflects the output indentation without coupling both too much. It is still possible to refactor the code into different functions and have other indentations based on code structure not messing with the output indentation.</p>
<pre><code>#!/usr/bin/env python
# coding: utf8
from __future__ import absolute_import, division, print_function


class IndentedPrinter(object):

    def __init__(self, level=0, indent_with='  '):
        self.level = level
        self.indent_with = indent_with

    def __enter__(self):
        self.level += 1
        return self

    def __exit__(self, *_args):
        self.level -= 1

    def print(self, arg='', *args, **kwargs):
        print(self.indent_with * self.level + str(arg), *args, **kwargs)


def main():
    indented = IndentedPrinter()
    indented.print(indented.level)
    with indented:
        indented.print(indented.level)
        with indented:
            indented.print('Hallo', indented.level)
            with indented:
                indented.print(indented.level)
            indented.print('and back one level', indented.level)


if __name__ == '__main__':
    main()
</code></pre>
<p>Output:</p>
<pre><code>0
  1
    Hallo 2
      3
    and back one level 2
</code></pre>
</div>
<span class="comment-copy">I'm really curious as to why you need this.</span>
<span class="comment-copy">@Harrison I wanted to indent the output of my code according to how it was indented in the code.</span>
<span class="comment-copy">The real question is: Why would you need this? The indentation level is static; you know it with certainty when you put the <code>get_indentation_level()</code> statment into your code. You can just as well do <code>print(3)</code> or whatever directly. What might be more itneresting is the current level of nesting on the function call stack.</span>
<span class="comment-copy">Is it for the purpose of debugging your code? This seems either a super genius way of logging the flow of execution or like a super over-engineered solution for a simple problem, and I'm not sure which it is... maybe both!</span>
<span class="comment-copy">@FabvonBellingshausen: That sounds like it'd be a lot less readable than you're hoping. I think you might be better served by explicitly passing around a <code>depth</code> parameter and adding the appropriate value to it as necessary when you pass it to other functions. The nesting of your code isn't likely to correspond cleanly to the indentation you want out of your output.</span>
<span class="comment-copy">This doesn't work in the way I would expect when <code>get_nesting_level()</code> is called within that function call―it returns the nesting level within that function. Could it be rewritten to return the 'global' nesting level?</span>
<span class="comment-copy">@FabvonBellingshausen: You may be getting indentation nesting level and function call nesting level mixed up. This function gives indentation nesting level. Function call nesting level would be rather different, and would give a level of 0 for all of my examples. If you want a sort of indentation/call nesting level hybrid that increments for both function calls and control flow structures like <code>while</code> and <code>with</code>, that'd be doable, but it's not what you asked for, and changing the question to ask something different at this point would be a bad idea.</span>
<span class="comment-copy">Incidentally, I'm in complete agreement with all the people saying this is a really weird thing to do. There's probably a much better way to solve whatever problem you're trying to solve, and relying on this is likely to hamstring you by forcing you to use all kinds of nasty hacks to avoid changing your indentation or function call structure when you need to make changes to your code.</span>
<span class="comment-copy">i certainly did not expect someone to have actually answered this.  (consider the <code>linecache</code> module for stuff like this though — it's used to print tracebacks, and can handle modules imported from zip files and other weird import tricks)</span>
<span class="comment-copy">@Eevee: I certainly wasn't expecting so many people to <i>upvote</i> this! <code>linecache</code> might be good for reducing the amount of file I/O (and thanks for reminding me about it), but if I started optimizing that, I'd be bothered by how we're redundantly re-tokenizing the same file for repetitions of the same call, or for multiple call sites within the same file. There are a number of ways we could optimize that too, but I'm not sure how much I really want to tune and bulletproof this crazy thing.</span>
<span class="comment-copy">Relating to the comment made by @Prune, can this be made to return the indentation in levels instead of spaces? Will it always be ok to simply divide by 4?</span>
<span class="comment-copy">No, divide by 4 to get indent level will not work with this code. Can verify by increasing level of indent of last print statement, last printed value is just increased.</span>
<span class="comment-copy">A good start, but doesn't really answer the question imo.  The number of spaces is not the same as the indentation level.</span>
<span class="comment-copy">@wim But the OP accepts the answer 0_O!</span>
<span class="comment-copy">It's not that simple.  Replacing 4 spaces with single spaces can change the logic of the code.</span>
<span class="comment-copy">question asked for number of indentation levels, not number of spaces.  they are not necessarily proportional.</span>
<span class="comment-copy">@wim That's right, check out the update.</span>
<span class="comment-copy">For your demo code the output should be 1 - 2 - 3 - 3</span>
<span class="comment-copy">@CraigBurgler  For getting 1 - 2 - 3 - 3 we can count the number of lines before the current line that are ends with a <code>:</code> until we encounter the line with zero indentation, Check out the edit!</span>
<span class="comment-copy">hmmm ... ok ... now try some of @user2357112's test cases ;)</span>
<span class="comment-copy">This gives the indentation in spaces, not in levels.  Unless the programmer uses consistent indentation amounts, this might be ugly to convert to levels.</span>
<span class="comment-copy">Is the function undocumented? I cannot find it <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">here</a></span>
