<div class="post-text" itemprop="text">
<p>I have looked at many possible ways to parse python times. <a href="https://stackoverflow.com/questions/1101508/how-to-parse-dates-with-0400-timezone-string-in-python">Using parse seems link the only method that should work</a>. <a href="https://stackoverflow.com/questions/10494312/parsing-time-string-in-python">While trying to use datetime.strptime causes an error because <code>%z</code> does not work with python 2.7</a>. But using parse.parse incorrectly recognizes the time zone.</p>
<p>I parse both <code>Fri Nov 9 09:04:02 2012 -0500</code> and <code>Fri Nov 9 09:04:02 2012 -0800</code> and get the exact same timestamp in unix time. <code>1352480642</code></p>
<ul>
<li>My version of python 2.7.10 </li>
<li>My version of dateutil 1.5</li>
</ul>
<p>Here is my code that runs the test.</p>
<pre><code>#!/usr/bin/python
import time
from dateutil import parser

def get_timestamp(time_string):
    timing = parser.parse(time_string)
    return time.mktime(timing.timetuple())

test_time1 = "Fri Nov 9 09:04:02 2012 -0500"
test_time2 = "Fri Nov 9 09:04:02 2012 -0800"
print get_timestamp(test_time1)
print get_timestamp(test_time2)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>1352480642.0
1352480642.0
</code></pre>
<p><strong>Expected output</strong></p>
<pre><code>1352469842.0
1352480642.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This has nothing to do with the parser, you'll see the same behavior just from <code>mktime()</code> alone, since <code>datetime.timetuple()</code> doesn't have any time zone offset information, and <code>mktime()</code> is the inverse of <code>localtime</code>. You can correct this by converting it to <code>localtime</code> before calling <code>timetuple()</code>:</p>
<pre><code>from time import mktime
from datetime import datetime
from dateutil import tz

dt_base = datetime(2012, 11, 9, 9, 4, 2)

dt_est = dt_base.replace(tzinfo=tz.tzoffset('EST', -5 * 3600))
dt_pst = dt_base.replace(tzinfo=tz.tzoffset('PST', -8 * 3600))

def print_mktime(dt):
    print(mktime(dt.timetuple()))

# Run in UTC
print_mktime(dt_est)   # 1352469842.0
print_mktime(dt_pst)   # 1352469842.0

# Convert to local time zone first first
print_mktime(dt_est.astimezone(tz.tzlocal())) # 1352469842.0
print_mktime(dt_pst.astimezone(tz.tzlocal())) # 1352480642.0
</code></pre>
<p>Note that there is a chart on the <a href="https://docs.python.org/3/library/time.html" rel="nofollow">documentation for <code>time()</code></a> (<a href="https://docs.python.org/2/library/time.html" rel="nofollow">python 2.x docs</a>) that tells you how to convert between these representations:</p>
<pre><code>From                        To                           Use
---------------------------------------------------------------------------
seconds since the epoch   | struct_time in UTC        |  gmtime()
seconds since the epoch   | struct_time in local time |  localtime()
struct_time in UTC        | seconds since the epoch   |  calendar.timegm()
struct_time in local time | seconds since the epoch   |  mktime()
</code></pre>
<p>My personal preference would be to convert the parsed date to UTC, in which case <code>calendar.timegm()</code> would be the appropriate function:</p>
<pre><code>from calendar import timegm
def print_timegm(dt):
    print(timegm(dt.timetuple()))

print_timegm(dt_est.astimezone(tz.tzutc())) # 1352469842.0
print_timegm(dt_pst.astimezone(tz.tzutc())) # 1352480642.0
</code></pre>
</div>
<span class="comment-copy">in python 3, I get <code>1352448242.0</code> for both lines! are you sure the timezone is properly parsed?</span>
<span class="comment-copy">Not sure at all. I am pulling these strings straight from GIT logs. I am not doing the parsing python is.</span>
<span class="comment-copy">the fact is: values are different depending on python versions!</span>
<span class="comment-copy">Actually the value is different based on your time zone, as the timezone is being ignored in the string and I believe python is just taking your time zone. As I can see you are probably somewhere in Europe 9 hours ahead because of the time difference you get.</span>
<span class="comment-copy">I like the idea of converting to local time first. But the data I am working with has date strings like this <code>Fri Nov 9 09:04:02 2012 -0800</code>. Is there anyway I can do this without selecting out each int individually to do <code>datetime(2012, 11, 9, 9, 4, 2)</code></span>
<span class="comment-copy">@Whitecat I strongly suggest using UTC, not localtime, to avoid DST related issues. I don't understand your objection about selecting out ints. I just manually created the output of the dateutil parser to show you it has nothing to do with the parser. You just need to change the time zone of the output of the parser like I did in the examples before calling <code>timetuple</code>.</span>
<span class="comment-copy">My objection to selecting ints manually is I have to write that parser, to identify the different parts of the string. Also DO I have to create a different timetuple for every time zone? As the time zones are any one of multiple different time zones.</span>
<span class="comment-copy">@Whitecat I'm not recommending that you use date literals here. <code>parse</code> returns a timezone aware <code>datetime</code> object. You can use <code>astimezone(tz.tzutc)</code> to convert that to a <code>datetime</code> object in UTC, which you can then convert to a <code>timetuple</code>, which can then be fed to <code>calendar.timegm</code>. The only reason I didn't use <code>dateutil.parser.parse</code> in my example is because your issue has nothing to do with parsing dates.</span>
