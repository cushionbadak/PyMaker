<div class="post-text" itemprop="text">
<p>I'm trying to find the continued fractions of any non-square number (until it repeats).</p>
<p>For example: input: <code>23 = [4; 1,3,1,8]</code></p>
<p>my code works for many numbers (even though it's very clumsy).
It works for 23 where it outputs: </p>
<pre><code>[4, 1, 3, 1, 8, 1, 3, 1]
</code></pre>
<p>(Ignore the extra 1, 3, 1)</p>
<p>But when i input 61 it never stops... here a line of the output:</p>
<pre><code>[7, 1, 4, 3, 1, 2, 2, 1, 3, 4, 1, 14, 1, 4, 3, 1, 2, 2, 1, 4, 5, 1, 6900]
</code></pre>
<p>After 14 it doesn't repeat like it should (4, 5 instead of 3, 4 and 6900 are out of place)</p>
<p>I'm a bit of a noob when it comes to coding, so it would help alot if someone could tell my why it doesn't work and how i should fix it</p>
<p>Here's my code: </p>
<pre><code>def find_fractions(n):
    d = math.sqrt(n)
    x = 0
    y = 0
    safeint = 0
    safe = True
    a = ["a", "b", "c", "d"]
    while a[1:int(len(a) / 2)] != a[int(len(a) / 2) + 1:]:
        a.append(math.floor(d))
        d = 1 / (d - math.floor(d))
        print(a)
        safeint += 1
        if safeint &gt; 4 and safe:
            del a[0]
            del a[0]
            del a[0]
            del a[0]
            safe = False
    print(a)

find_fractions(23)
</code></pre>
<p>Edit: not 63, meant 61</p>
</div>
<div class="post-text" itemprop="text">
<p>What you have is a precision error.  These calculations are extremely precise, meaning they require many binary digits to represent.  The finite floating point precision that your computer uses is sometimes not enough to do this accurately.  Somewhere along the line, the behavior of how this inaccuracy is handled in your machine is breaking your calculations.  I used the <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal" rel="nofollow">decimal</a> module to handle this large precision.</p>
<pre><code>import math
from decimal import Decimal
from decimal import getcontext

def find_fractions(n):
    d = Decimal(n).sqrt()
    x = 0
    y = 0
    safeint = 0
    safe = True
    a = ["a", "b", "c", "d"]
    while a[1:int(len(a) / 2)] != a[int(len(a) / 2) + 1:]:
        a.append(math.floor(d))
        d = Decimal(1 / (d - math.floor(d)))
        print(a)
        safeint += 1
        if safeint &gt; 4 and safe:
            del a[0]
            del a[0]
            del a[0]
            del a[0]
            safe = False
    print(a)
</code></pre>
<p>This gives me the output
<code>[7, 1, 4, 3, 1, 2, 2, 1, 3, 4, 1, 14, 1, 4, 3, 1, 2, 2, 1, 3, 4, 1]</code>
for input 61.  The default number of places for the Decimal class is 28.  If necessary, you can set the Decimal objects to use higher precision like so 
<code>getcontext().prec = x</code></p>
<p>Here's a the <a href="https://en.wikipedia.org/wiki/Floating_point" rel="nofollow">Wikipedia page</a> to review floating point precision.  If you'd like I would be happy to give you some suggestions on making your code cleaner as well.  </p>
</div>
<span class="comment-copy">Could you please provide a general mathematical description of what you want to achieve?</span>
<span class="comment-copy">wokrs fine for me for <code>63</code> resulting in <code>[7, 1, 14, 1, 14, 1, 14, 1]</code>. for 64 it gives <code>ZeroDivisionError</code></span>
<span class="comment-copy">Basically i'm following this: <a href="http://math.stackexchange.com/questions/265690/continued-fraction-of-a-square-root" title="continued fraction of a square root">math.stackexchange.com/questions/265690/â€¦</a> and trying to find the continued fractions of any non-square number</span>
<span class="comment-copy">@vsminkov it works fine for any numbers with a not so long repeat series (if the makes sense) but it doesn't for fx, 61 or 109. Also the reason 64 doesn't work is because its a perfect square</span>
<span class="comment-copy">Thanks a million! It works now! And thank you for the in depth explanation!</span>
