<div class="post-text" itemprop="text">
<p>Here is an example:</p>
<pre><code>l = [1, 5, 9, 3]
h = l

h[0], h[2] = h[2], h[0]

print(h) # [9, 5, 1, 3]
print(l) # [9, 5, 1, 3]

h = h*2
print(h) # [9, 5, 1, 3, 9, 5, 1, 3]
print(l) # [9, 5, 1, 3]
</code></pre>
<p>My understanding was that calling setting <code>h = l</code> would simply point <code>h</code> at the same item in memory that <code>l</code> was pointing at. So why is it that in the last 3 lines, <code>h</code> and <code>l</code> don't give the same results?</p>
</div>
<div class="post-text" itemprop="text">
<p>The assignment does make <strong>h</strong> point to the same item as <strong>l</strong>.  However, it does not permanently weld the two.  When you change <strong>h</strong> with <strong>h = h * 2</strong>, you tell Python to build a doubled version elsewhere in memory, and then make <strong>h</strong> point to the doubled version.  You haven't given any instructions to change <strong>l</strong>; that still points to the original item.</p>
</div>
<div class="post-text" itemprop="text">
<p>That's quite simple to check, run this simple test:</p>
<pre><code>l = [1, 5, 9, 3]
h = l

h[0], h[2] = h[2], h[0]

print(h)  # [9, 5, 1, 3]
print(l)  # [9, 5, 1, 3]

print id(h), id(l)
h = h * 2
print id(h), id(l)

print(h)  # [9, 5, 1, 3, 9, 5, 1, 3]
print(l)  # [9, 5, 1, 3]
</code></pre>
<p>As you can see because of the line <code>h = h * 2</code>, the h's id has been changed</p>
<p>Why is this? When you're using <code>*</code> operator it creates a new list (new memory space). In your case this new list is being assigned to the old h reference, that's why you can see the id is different after <code>h = h * 2</code></p>
<p>If you want to know more about this subject, make sure you look at <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Data Model</a> link.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>h = h * 2</code> assigns <code>h</code> to a new list object.</p>
<p>You probably want to modify <code>h</code> <em>in-place</em>: </p>
<pre><code>h *= 2
print(h) # [9, 5, 1, 3, 9, 5, 1, 3]
print(l) # [9, 5, 1, 3, 9, 5, 1, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Anytime you assign to a variable, its identity (memory address) generally changes - the only reason why it wouldn't change is that you happened to assign it the value that it already held.  So, your statement <code>h = h * 2</code> caused h to become an entirely new object - one whose value happened to be based on the previous value of h, but that's not actually relevant to its identity.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's tricky, but when you multiply a list, you are creating a new list.</p>
<pre><code>l = [1, 5, 9, 3]
h = l
</code></pre>
<p>'l' and 'h' are now referring to the same list in memory.</p>
<pre><code>h[0], h[2] = h[2], h[0]

print(h)  # [9, 5, 1, 3]
print(l)  # [9, 5, 1, 3]
</code></pre>
<p>You swapped the values in <code>h</code>, so the values are changed in <code>l</code>.  This makes sense when you think about them as different names for <em>the same object</em></p>
<pre><code>h = h * 2

print(h)  # [9, 5, 1, 3, 9, 5, 1, 3]
print(l)  # [9, 5, 1, 3]
</code></pre>
<p>When multiplying <code>h * 2</code>, you are creating a <em>new list</em>, so now only <code>l</code> will be the original list object.</p>
<pre><code>&gt;&gt;&gt; l = [1, 5, 9, 3]
&gt;&gt;&gt; h = l
&gt;&gt;&gt; id(h) == id(l)
True
&gt;&gt;&gt; id(h)
139753623282464
&gt;&gt;&gt; h = h * 2
&gt;&gt;&gt; id(h) == id(l)
False
&gt;&gt;&gt; id(h)
139753624022264
</code></pre>
<p>See how the <code>id</code> of <code>h</code> changes after the multiplication?  The <code>*</code> operator creates a new list, unlike other list operation, such as <code>append()</code> which alter the current list.</p>
<pre><code>&gt;&gt;&gt; h.append(1000)
&gt;&gt;&gt; id(h)
139753623282464    # same as above!
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
print np.may_share_memory(l,k)
</code></pre>
<p>helps in confirming if two variables l and k share the same memory</p>
</div>
<span class="comment-copy">You change what <code>h</code> points to when you assign to <code>h</code> again.</span>
<span class="comment-copy">It depends on whether the value of the variable is mutable. Lists are mutable, Integers aren't.</span>
<span class="comment-copy">Setting <code>h = l</code> does point <code>h</code> at <code>l</code>.  But then setting <code>h = h*2</code> points <code>h</code> to something else.</span>
<span class="comment-copy">yes, but this doesn't tell me <i>why</i></span>
<span class="comment-copy">@AlanH Ok, I've edited my answer</span>
<span class="comment-copy">Short and sweet... +1 <code>h += h * 2</code> would work too. :)</span>
<span class="comment-copy">@l'L'l That works, but won't it triple rather than double? You meant <code>h += h</code>?</span>
<span class="comment-copy">Yeah thanks for the correction, that's what I meant, my phone somehow left the * 2... on there.</span>
