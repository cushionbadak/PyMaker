<div class="post-text" itemprop="text">
<p>I'm really beginner in Python, so please forgive me if this is something obvious. </p>
<p>I have an enum class, and I want to be able to compare the members. Below code seems to do what I want ( but not how I want )</p>
<pre><code>import enum

class AB(enum.Enum):

    a=1
    b=2
    c=3
    d=4
    e=5

    @classmethod
    def le(cls, a, b):
        lst = [cls.a, cls.b, cls.c, cls.d, cls.e]
        ia = lst.index(a)
        ib = lst.index(b)
        return(ia &lt;= ib)


if AB.le(AB.a, AB.b):
    print('Do this')
else:
    print('Do that')
</code></pre>
<p>Now my question is how to code the comparison operator <code>__le__</code> so that I can run the below code instead? </p>
<pre><code>mem1 = AB.a
mem2 = AB.c

if mem1 &lt;= mem2 :
    print('Do this')
else:
    print('Do that')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Enum</code> subclasses are somewhat special in that all enumeration values become <em>instances</em> of the class (with a few tweaks). This does mean you can 'just' define a normal method on the <code>Enum</code> subclass and they'll be available on each enumeration value.</p>
<p>This applies to special methods like <code>object.__le__()</code> too; just define it as a regular method, <em>not</em> a <code>classmethod</code>:</p>
<pre><code>class AB(enum.Enum):
    def __le__(self, b):
        return self.value &lt;= b.value

    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
</code></pre>
<p>Note that I used the <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="noreferrer">instance attribute <code>.value</code></a>, just like you can do <code>AB.a.value</code>.</p>
<p>You could also use the <a href="https://docs.python.org/3/library/enum.html#intenum" rel="noreferrer"><code>IntEnum</code> class</a>; that makes each enumeration value a subclass of <code>int</code>, and they can be compared <em>naturally</em>:</p>
<pre><code>class AB(enum.IntEnum):
    a = 1
    b = 2
    c = 3
    d = 4
    e = 5
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import enum
&gt;&gt;&gt; class AB(enum.Enum):
...     def __le__(self, b):
...         return self.value &lt;= b.value
...     a = 1
...     b = 2
...     c = 3
...     d = 4
...     e = 5
...
&gt;&gt;&gt; AB.a &lt;= AB.b
True
&gt;&gt;&gt; AB.b &lt;= AB.a
False
&gt;&gt;&gt; AB.a &lt; AB.b
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: AB() &lt; AB()
</code></pre>
<p>and using <code>IntEnum</code> as the base:</p>
<pre><code>&gt;&gt;&gt; class AB(enum.IntEnum):
...     a = 1
...     b = 2
...     c = 3
...     d = 4
...     e = 5
...
&gt;&gt;&gt; AB.a &lt;= AB.b
True
&gt;&gt;&gt; AB.b &gt;= AB.a
True
&gt;&gt;&gt; AB.b &gt; AB.a
True
&gt;&gt;&gt; AB.a + AB.b
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The  <code>__le__</code> method should be called as a member function of the LHS operand and takes the RHS operand as its parameter.</p>
<p>However it's not clear from your code which member variables of an <code>AB</code> object should be used in the comparison, so I can't really write the code for you.</p>
<p>Roughly it should look something like:</p>
<pre><code>def __le__(self, b):
    return # do something with self and b to figure out which one would be &lt;=
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @Rawing and @machine yearning,</p>
<pre><code>import enum

class AB(enum.Enum):

    a=1
    b=2
    c=3
    d=4
    e=5

    def __le__(self, other):
        return(self.value &lt;= other.value)


if AB.c &lt;= AB.d:
    print('Do this')
else:
    print('Do that')
</code></pre>
</div>
<span class="comment-copy">It's much like implementing <code>__le__</code> for any other class really. <code>def __le__(self, other): return self.value &lt;= other.value</code></span>
<span class="comment-copy">Thanks! that simple! I was unnecessarily trying to avoid 'self' and use a class method. Thanks!</span>
<span class="comment-copy">Thanks! Exactly the information I needed. Marking as answer!</span>
<span class="comment-copy">IntEnum bring in these by default? Mostly i need just int values. I should not add those like that last example though!</span>
<span class="comment-copy">@kollery: each value object in the enum is <i>also</i> an integer, so you can use them in any way integers can be used, without having to use the <code>.value</code> attribute. You can use them to index lists, for example: <code>l = ['foo', 'bar']</code>, then <code>l[AB.b]</code>. Etc. And yes, that means they work in arithmetic too.</span>
<span class="comment-copy">For a working implementation addressing these issues, see <a href="https://stackoverflow.com/users/5014455/juanpa-arrivillaga">juanpa.arrivillaga</a>'s explanatory <a href="https://stackoverflow.com/a/39269589/2809027">answer</a> at this <a href="https://stackoverflow.com/questions/39268052">duplicate question</a>.</span>
<span class="comment-copy">@CecilCurry: the <code>__lt__</code> method is merely a simplified version of the attempt the OP made, adding in <code>NotImplemented</code> is of course trivial. Using <code>IntEnum</code> is a tradeoff; using it <i>may</i> be bad software design, it is not a <i>plague</i>, it won't horribly break all your code. Please don't resort to hyperbole like that.</span>
<span class="comment-copy">Yes. I had somehow got tracked myself into thinking 'classmethod' is the way for enums. not correct.</span>
