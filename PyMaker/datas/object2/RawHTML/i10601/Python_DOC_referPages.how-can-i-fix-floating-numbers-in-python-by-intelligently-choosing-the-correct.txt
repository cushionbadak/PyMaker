<div class="post-text" itemprop="text">
<p>I've seen many discussions here about rounding floating values in python or similar topics, but I have a related problem that I want a good solution for.</p>
<p>Context:</p>
<p>I use the netCDF4 python library to extract data from NetCDF files. My organization keeps a precision attribute on variables within these files.</p>
<p>Example: <code>TS:data_precision = 0.01f ;</code></p>
<p>I collect these precision attributes using the library like this:</p>
<pre><code>d = netCDF4.Dataset(path) # assume path is the file or url link
precisions = {}
for v in d.variables:
    try:
        precisions[v] = d.variables[v].__getattribute__('data_precision')
    except AttributeError:
        pass
return precisions
</code></pre>
<hr/>
<p>When I retrieve these precision values from a dataset, in python they end up showing up like:</p>
<pre><code>{u'lat': 9.9999997e-05, u'lon': 9.9999997e-05, u'TS': 0.0099999998, u'SSPS': 0.0099999998}
</code></pre>
<p>But, what I really want is:</p>
<pre><code>{u'lat': 0.0001, u'lon': 0.0001, u'TS': 0.01, u'SSPS': 0.01}
</code></pre>
<hr/>
<p>Essentially I need a way in python to intelligently round these values to their most appropriate decimal place. I am sure I can come up with a really ugly method to do this, but I want to know if there is already a 'nice' solution to this problem.</p>
<p>For my use case, I suppose I can take advantage of the fact that since these values are all 'data_precision' values, I can just count the zero's from the decimal place, and then round to the last 0. (I'm making the assumption that <code>0 &lt; n &lt; 1</code>). With these assumptions, this would be my solution:</p>
<pre><code>#/usr/bin/python

def intelli_round(n):
    def get_decimal_place(n):
        count = 0
        while n &lt; 1:
            n *= 10
            count += 1
        return count
    return round(n, get_decimal_place(n))

examples = [0.0099999, 0.00000999, 0.99999]
for e in examples:
    print e, intelli_round(e)
</code></pre>
<p>.</p>
<pre><code>0.0099999 0.01
9.99e-06 1e-05
0.99999 1.0
</code></pre>
<p>Does this seem appropriate? It seems to work under the constraints, but I'm curious to see alternatives.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to Benjamin for linking another post in the comments above to the solution I was looking for. A better way to word my question is that I want to operate on float values such that only 1 significant digit is retained.</p>
<p>Simple examples:</p>
<pre><code>0.00999  -&gt; 0.01
0.09998  -&gt; 0.1
0.00099  -&gt; 0.001
</code></pre>
<p><a href="https://stackoverflow.com/a/3411435/3454650">This solution</a> was perfect for my needs:</p>
<pre><code>&gt;&gt;&gt; from math import log10, floor
&gt;&gt;&gt; def round_to_1(x):
...   return round(x, -int(floor(log10(abs(x)))))
</code></pre>
<p>It handles inputs within my specific context (<code>1.0e^p, p &lt; 0</code>) just fine so thank you so much for the help guys!</p>
</div>
<div class="post-text" itemprop="text">
<p>For rounding the values to <code>float</code> with 2 decimal precision, you may use below code:</p>
<pre><code>&gt;&gt;&gt; x = [0.0099999, 0.00000999, 0.99999]
&gt;&gt;&gt; ['%.2f' % i for i in x]
['0.01', '0.00', '1.00']
</code></pre>
<p>OR, you may use <code>format</code> as:</p>
<pre><code>&gt;&gt;&gt; ["{0:.2f}".format(i) for i in x]
['0.01', '0.00', '1.00']
</code></pre>
<p>In case you do not want to use these pythonic approach, and interested to implement it via mathematical logic, you may do:</p>
<pre><code>&gt;&gt;&gt; [int((i * 100) + 0.5) / 100.0 for i in x]
[0.01, 0.0, 1.0]
</code></pre>
</div>
<span class="comment-copy">Isn't this what the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code> module</a> is for?</span>
<span class="comment-copy">Please can you provide the sample input and required output. It will help us in helping you.</span>
<span class="comment-copy">Python already does this for double-precision floats.  I don't know of a way to make this happen if your data is single-precision.</span>
<span class="comment-copy">There is a good solution here: <a href="http://stackoverflow.com/questions/3410976/how-to-round-a-number-to-significant-figures-in-python" title="how to round a number to significant figures in python">stackoverflow.com/questions/3410976/â€¦</a></span>
<span class="comment-copy">@jwodder, I haven't used the module too much, but at a brief glance it seems most of the utilities have the programmer specify the precision to round to. I'm trying to avoid that here. @Moinuddin the examples i put at the bottom would pretty much cover my use cases since the raw netcdf input is always <code>1.0e^p, p &lt; 0</code>. @DietrichEpp I did not know that! My data is natively single precision. But ty that is interesting to know.</span>
<span class="comment-copy">I don't think this is what the question is actually asking for. The OP is actually changing the value to the less precise value using the round() function, and he or she wants a way for this to happen intelligently. Your response merely changes the presentation of the number as it's output. Underneath, it's still a float with higher precision.</span>
<span class="comment-copy">I already added the comment regarding clarification. The actual requirement of OP is not clear to me.</span>
