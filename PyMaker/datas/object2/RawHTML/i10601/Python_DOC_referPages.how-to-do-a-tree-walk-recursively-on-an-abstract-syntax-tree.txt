<div class="post-text" itemprop="text">
<p>Simple example of assignment in my language:</p>
<pre><code>x = 3 -&gt;
</code></pre>
<p>Here's the generated AST after parsing (In Python):</p>
<pre><code>[('statement', ('assignment', 'x', ('assignment_operator', '='), ('expr', ('term', ('factor', '3')))), '-&gt;')]
</code></pre>
<p>How can I recursively access any possible depth in order to, in the most trivial case, print all of them? (Or convert the text into something else?). Is there a specific algorithm for doing this? If there is, do you recommend any specific material?</p>
</div>
<div class="post-text" itemprop="text">
<p>To walk a tree, just use a stack or a queue (depending on wether you want to go depth first or breath first).</p>
<p>For each node encountered, push the children onto the stack or into the queue, then take the next item out of the data structure to process and repeat.</p>
<p>For example, breath first could look like this:</p>
<pre><code>from collections import deque

def walk(node):
    queue = deque([node])
    while queue:
        node = queue.popleft()
        if isinstance(node, tuple):
            queue.extend(node[1:])  # add the children to the queue
        yield node
</code></pre>
<p>which produces the following walking order for your tree:</p>
<pre><code>&gt;&gt;&gt; for node in walk(tree[0]):
...     print(node[0] if isinstance(node, tuple) else node)
...
statement
assignment
-&gt;
x
assignment_operator
expr
=
term
factor
3
</code></pre>
<p>Your data structure is a little messy, mixing tuples of different length. You may want to look to using a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noreferrer"><code>nametuple</code> class</a> to formalise the contents a little.</p>
</div>
<span class="comment-copy">Why not just use the <code>ast</code> module functionality? <a href="https://docs.python.org/2/library/ast.html#ast.walk" rel="nofollow noreferrer"><code>ast.walk()</code></a> for example.</span>
<span class="comment-copy">I had no idea of the existence of such module. I only knew about os.walk() (Which is specific for directories).</span>
<span class="comment-copy">Well, it may be that that module is too specific to the Python grammar; if you have your own grammar the module is probably not suitable.</span>
<span class="comment-copy">I do have <a href="https://github.com/EricsonWillians/Lilith" rel="nofollow noreferrer">my own grammar</a>. I was trying to interpret everything at each parse rule function from YACC, and as it grew in complexity (Such as condition blocks), I've learned that I need to generate an AST and later interpret / translate the code from it.</span>
<span class="comment-copy">The structure of your tuples are not entirely clear to me; I made an assumption that everything but the  first element are children, but you may want to formalise the contents a little.</span>
<span class="comment-copy">The nametuple class is a hell of a good idea. Thank you very much! It'll certainly help me (Especially when the language becomes more nightmarish to interpret).</span>
<span class="comment-copy">@EricsonWillians: you may want to <a href="https://hg.python.org/cpython/file/3.5/Lib/ast.py" rel="nofollow noreferrer">study the <code>ast</code> module source code</a>; Python uses custom classes per node type but the module helper functions and classes should be of help in any AST processing.</span>
