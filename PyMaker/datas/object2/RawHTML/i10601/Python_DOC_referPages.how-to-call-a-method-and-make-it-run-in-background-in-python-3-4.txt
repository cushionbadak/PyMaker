<div class="post-text" itemprop="text">
<p>I have implemented the Google Cloud Messaging server in python and I want that method to be Asynchronous. I do not expect any return values from that method. Is there a simple way to do this?
I have tried using <code>async</code> from <code>asyncio</code> package:</p>
<pre><code>...
loop = asyncio.get_event_loop()
 if(module_status=="Fail"):
      loop.run_until_complete(sendNotification(module_name, module_status))
... 
</code></pre>
<p>and here is my method <code>sendNotification()</code>:</p>
<pre><code>async def sendNotification(module_name, module_status):
    gcm = GCM("API_Key")
    data ={"message":module_status, "moduleName":module_name}
    reg_ids = ["device_tokens"]
    response = gcm.json_request(registration_ids=reg_ids, data=data)
    print("GCM notification sent!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/dev/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow noreferrer">ThreadPoolExecutor</a>:</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor

def send_notification(module_name, module_status):
    [...]

with ThreadPoolExecutor() as executor:
    future = executor.submit(send_notification, module_name, module_status)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since GCM is not async library compatible need to use an external event loop. </p>
<p>There are a few, simplest one IMO is probably <a href="http://www.gevent.org/" rel="nofollow">gevent</a>.</p>
<p>Note that gevent monkey patching may introduce dead locks if the underlying libraries used rely on blocking behaviour to operate.</p>
<pre><code>import gevent
from gevent.greenlet import Greenlet
from gevent import monkey
monkey.patch_all()

def sendNotification(module_name, module_status):
    gcm = GCM("API_Key")
    data ={"message":module_status, "moduleName":module_name}
    reg_ids = ["device_tokens"]
    response = gcm.json_request(registration_ids=reg_ids, data=data)
    print("GCM notification sent!")

greenlet = Greenlet.spawn(sendNotification, 
                          args=(module_name, module_status,))
# Yield control to gevent's event loop without blocking
# to allow background tasks to run
gevent.sleep(0)
# 
# Other code, other greenlets etc here
# 
# Call get to get return value if needed
greenlet.get()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use asyncio's api: <code>loop.run_in_executor(None, callable)</code></p>
<p>This will run the code using an executor (by default a <a href="https://docs.python.org/dev/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow">ThreadPoolExecutor</a>)</p>
<p>See the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow">documentation</a></p>
</div>
<span class="comment-copy">If the <code>gcm.json_request</code> method is not defined using <code>asyncio</code>, then there is not a simple way to do this.</span>
<span class="comment-copy">@NateMara I am using python-gcm librabry  <a href="https://github.com/geeknam/python-gcm/blob/master/gcm/gcm.py" rel="nofollow noreferrer">link</a>. I saw its code and it is not async. Can you suggest a solution to make my method run in background?</span>
<span class="comment-copy">You could use <code>multiprocessing</code> or do the HTTP call yourself using <code>aiohttp</code></span>
<span class="comment-copy">Seems simple but this does not work for me.</span>
<span class="comment-copy">@Alexis.Rolland Could you elaborate?</span>
<span class="comment-copy">Indeed my comment was lacking details, apologies. My code is still executing properly but I was expecting it to run in background and immediately show some prints I've done after the <code>with</code> block. I guess I'm doing it wrong. Let me try again.</span>
<span class="comment-copy">It seems I'm progressing. Now I have the error message <code>RuntimeWarning: coroutine 'migrate' was never awaited</code>.</span>
<span class="comment-copy">@Alexis.Rolland Sorry I wasn't so clear. Original poster said he wanted to run a job in the background, and that he tried to use asyncio. But it seems like his library, gcm, does not support asyncio (meaning, it does not provide coroutines to use in the context of an asyncio application). So the easiest solution to his problem is probably to use a threadpool executor in order to submit (synchronous) jobs to a background thread and get the results later. This also means that with this solution, <code>send_notification</code> is no longer a coroutine (<code>async def</code>) but a regular function (<code>def</code>).</span>
