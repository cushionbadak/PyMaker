<div class="post-text" itemprop="text">
<p>I have 3 parallel lists representing a 3-tuple (date, description, amount), and 3 new lists that I need to merge without creating duplicate entries. Yes, the lists have overlapping entries, however these duplicate entries are not grouped together (instead of all of the duplicates being 0 through x and all of the new entries being x through the end).</p>
<p>The problem I'm having is iterating the correct number of times to ensure all of the duplicates are caught. Instead, my code moves on with duplicates remaining.</p>
<pre><code>for x in dates:
    MoveNext = 'false'
    while MoveNext == 'false':
        Reiterate = 'false'
        for a, b in enumerate(descriptions):
            if Reiterate == 'true':
                break
            if b in edescriptions:
                eindex = [c for c, d in enumerate(edescriptions) if d == b]
                for e, f in enumerate(eindex):
                    if Reiterate == 'true':
                        break
                    if edates[f] == dates[a]:
                        if eamounts[f] == amounts[a]:
                            del dates[a]
                            del edates[f]
                            del descriptions[a]
                            del edescriptions[f]
                            del amounts[a]
                            del eamounts[f]
                            Reiterate = 'true'
                            break
                        else:
                            MoveNext = 'true'
                    else:
                        MoveNext = 'true'
            else:
                MoveNext = 'true'
</code></pre>
<p>I don't know if it's a coincidence, but I'm currently getting exactly one half of the new items deleted and the other half remain. In reality, there should be far less than that remaining. That makes me think the <code>for x in dates:</code> is not iterating the correct number of times.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest a different approach:  Instead of trying to remove items from a list (or worse, several parallel lists), run through the input and <code>yield</code> only the data that passes your test --- in this case, data you haven't seen before.  This is much easier with a single stream of input.</p>
<p>Your lists of data are crying out to be made into objects, since each piece (like the date) is meaningless without the other two... at least for your current purpose.  Below, I start by combining each triplet into an instance of <code>Record</code>, a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow"><code>collections.namedtuple</code></a>.  They're great for this kind of use-once-and-throw-away work.</p>
<p>In the program below, <code>build_records</code> creates <code>Record</code> objects from your three input lists.  <code>dedup_records</code> merges multiple streams of <code>Record</code> objects, using <code>unique</code> to filter out the duplicates.  Keeping each function small (most of the <code>main</code> function is test data) makes each step easy to test.</p>
<pre class="lang-python3 prettyprint-override"><code>#!/usr/bin/env python3

import collections
import itertools


Record = collections.namedtuple('Record', ['date', 'description', 'amount'])


def unique(records):
    '''
    Yields only the unique Records in the given iterable of Records.
    '''
    seen = set()
    for record in records:
        if record not in seen:
            seen.add(record)
            yield record
    return


def dedup_records(*record_iterables):
    '''
    Yields unique Records from multiple iterables of Records, preserving the
    order of first appearance.
    '''
    all_records = itertools.chain(*record_iterables)
    yield from unique(all_records)
    return


def build_records(dates, descriptions, amounts):
    '''
    Yields Record objects built from each date-description-amount triplet.
    '''
    for args in zip(dates, descriptions, amounts):
        yield Record(*args)
    return


def main():
    # Sample data
    dates_old = [
      '2000-01-01',
      '2001-01-01',
      '2002-01-01',
      '2003-01-01',
      '2000-01-01',
      '2001-01-01',
      '2002-01-01',
      '2003-01-01',
      ]
    dates_new = [
      '2000-01-01',
      '2001-01-01',
      '2002-01-01',
      '2003-01-01',
      '2003-01-01',
      '2002-01-01',
      '2001-01-01',
      '2000-01-01',
      ]
    descriptions_old = ['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']
    descriptions_new = ['b', 'b', 'c', 'a', 'a', 'c', 'd', 'd']
    amounts_old = [0, 1, 0, 1, 0, 1, 0, 1]
    amounts_new = [0, 0, 0, 0, 1, 1, 1, 1]
    old = [dates_old, descriptions_old, amounts_old]
    new = [dates_new, descriptions_new, amounts_new]

    for record in dedup_records(build_records(*old), build_records(*new)):
        print(record)
    return


if '__main__' == __name__:
    main()
</code></pre>
<p>This reduces the 16 input <code>Record</code>s to 11:</p>
<pre class="lang-none prettyprint-override"><code>Record(date='2000-01-01', description='a', amount=0)
Record(date='2001-01-01', description='b', amount=1)
Record(date='2002-01-01', description='c', amount=0)
Record(date='2003-01-01', description='d', amount=1)
Record(date='2000-01-01', description='b', amount=0)
Record(date='2001-01-01', description='b', amount=0)
Record(date='2003-01-01', description='a', amount=0)
Record(date='2003-01-01', description='a', amount=1)
Record(date='2002-01-01', description='c', amount=1)
Record(date='2001-01-01', description='d', amount=1)
Record(date='2000-01-01', description='d', amount=1)
</code></pre>
<p>Note that the <code>yield from ...</code> syntax requires Python 3.3 or greater.</p>
</div>
<span class="comment-copy">It would be useful if you could give example input and output; that code is a little hard to follow.</span>
<span class="comment-copy"><code>set(yourList)</code> returns a new list of unique items i.e. removing duplicates.</span>
<span class="comment-copy">Deleting lots of arbitrary elements from a list is always going to be slow.  Creating a new list containing only the elements you want would be both faster and easier.</span>
<span class="comment-copy">What determines the output order of the de-duplicated elements --- which one do you "keep"?  Maintain the order of appearance in the old list?  Or the new list?  First appearance in any list?  Last appearance?  Something else?</span>
<span class="comment-copy">Thank you very much for all of your comments. @KevinJ.Chase you are correct, they are parallel lists; I just didn't know about named tuples and will look into that.</span>
<span class="comment-copy">I really appreciate your detailed example. I've seen it working for myself and spent a couple of hours working through it, but I'm still piecing it together in my head. Google has helped answer many of my questions and I'm starting to get it, but I can't figure out your last two lines of code. I've googled the double underscore use but it still isn't clear to me. And I think I'm understanding that main() simply executes main() which doesn't require any args because you've defined the example data inside the function. Could the if statement not simply be replaced with main()? Thanks</span>
<span class="comment-copy">@SunnyNonsense:  The <code>if __name__ == '__main__':</code> construct is the standard way of <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer">structuring a command-line script</a>.  Without it, everything at the module level would be executed whenever someone imported the script (say, to test it, or to use one of its functions).  More importantly for a beginner, putting all your start-to-end logic in a function like <code>main</code> gets them out of the "global" module namespace, where they cause lots of rookie errors.  Finally, it serves as a helpful "start here" signpost in big modules.</span>
<span class="comment-copy">@SunnyNonsense: An additional reference:  <i>The Python Tutorial</i>, section <a href="https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts" rel="nofollow noreferrer">6.1.1 Executing modules as scripts</a>, and the Stack Overflow question "<a href="https://stackoverflow.com/questions/419163">What does <code>if __name__ == "__main__":</code> do?</a>".  I try to keep everything I can out of the module level, which is why I only have the call to <code>main()</code> after the <code>if</code>.</span>
<span class="comment-copy">@SunnyNonsense:  To specifically answer your last question about removing the <code>if</code> condition:  Sort of.  If you only ever ran --- let's call this script <code>dedup.py</code> --- on the command line, then leaving a bare <code>main()</code> on the last line would behave the same as before.  But if some other Python program ever ran <code>import dedup</code> (maybe to use the <code>Record</code> class, or one of the functions), the <code>if</code>-less <code>dedup.py</code> would execute <code>main()</code>, and that innocent-looking <code>import dedup</code> would vomit all our made-up test data to standard output.  The <code>if __name__ == '__main__':</code> prevents surprises like that.</span>
<span class="comment-copy">I got it to work! I didn't do exactly what you have here but I did use named tuples (and some other pieces) which you introduced me to here. I selected your answer as correct because I witnessed it working and I greatly appreciate your effort to help me.</span>
