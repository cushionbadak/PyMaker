<div class="post-text" itemprop="text">
<p>suppose i have the data like this</p>
<pre><code>mpg   cylinder
14    4
26    6
45    4
20    4
23    8
21    8
</code></pre>
<p>and my output should be like this</p>
<pre><code>cylinder 4= 14+45+20/3
</code></pre>
<p>and so on</p>
<pre><code>dataset=[]
f= open('auto-mpg-data.csv')
csv_f=csv.reader(f)
for row in csv_f:
    dataset.append(row)

#reading mpg column
mpg=[]
for row in dataset:
    mpg.append(float(row[0]))

#reading cylinder column
cylinder=[]
for row in dataset:
    cylinder.append(float[row[1])

#calculating average with condition
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Calculating an average from a condition is easy with <code>sum</code> and <code>len</code> after using a list comprehension to filter. For example, to calculate the average <code>mpg</code> where there are four <code>cylinders</code>, you could do:</p>
<pre><code>mpg4cylinder = [m for m, c in zip(mpg, cylinder) if c == 4]

# For greater precision with float summing, you may want to use math.fsum
cylinder4avg = sum(mpg4cylinder) / len(mpg4cylinder)
</code></pre>
<p>If you're using modern Python (3.4+), it's even easier with <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow">the <code>statistics</code> module</a>:</p>
<pre><code>cylinder4avg = statistics.mean(m for m, c in zip(mpg, cylinder) if c == 4)
</code></pre>
<p>which is even more accurate than <code>math.fsum</code> approaches and more concise, in exchange for being slower.</p>
<p>This is somewhat inefficient if you are calculating stats for all cylinders, not just one or two. You could improve on this by grouping them by cylinder as you go:</p>
<pre><code>from collections import defaultdict

cyl_to_mpgs = defaultdict(list)
for m, c in zip(mpg, cylinder):
    cyl_to_mpgs[c].append(m)
</code></pre>
<p>Now you can get the averages for any given cylinder count without needing to search through the whole list of data to filter out the bits you want, you just do:</p>
<pre><code>statistics.mean(cyl_to_mpgs[4.0])
</code></pre>
<p>which gets the pre-filtered <code>list</code> cheaply (having prefiltered all cylinder combinations in a single pass up front).</p>
<p>FYI, Python can do a lot of the work for you more succinctly. The creation and population of <code>dataset</code> could be just:</p>
<pre><code># newline='' is the correct way to do csv in Py3; on Py2, you'd get rid of it
# but provide a mode argument of "rb"
with open('auto-mpg-data.csv', newline='') as f:
    dataset = list(csv.reader(f))
</code></pre>
<p><code>mpg</code> would be:</p>
<pre><code>mpg = [float(row[0]) for row in dataset]
</code></pre>
<p>with the same pattern for <code>cylinder</code>. Loops that do nothing but <code>append</code> values one by one are usually best replaced with the <code>list</code> constructor or a list comprehension (if the <code>list</code> already has values, you'd call <code>extend</code> with the same arguments or comprehension as <code>list</code>/listcomps).</p>
</div>
<span class="comment-copy">And your question is...?</span>
<span class="comment-copy">you just give the overall average of mpg. I am looking for the average mpg that has the similar cylinder. Like cylinder 4=14+45+23/3    cylinder 6=26    and cylinder 8=21+23/2</span>
<span class="comment-copy">@Cool: Why are cylinders being parsed as <code>float</code> if they're <code>int</code>s? In any event, I'll update.</span>
