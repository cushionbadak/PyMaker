<div class="post-text" itemprop="text">
<p>I'm porting some code from Python 2 to 3, and <code>py.test</code> isn't playing well with the <code>patch</code> decorator from <code>unittest.mock</code>. When I use the <code>patch</code> decorator to pass a mock into the arguments of a test function, <code>py.test</code> instead interprets that argument to be a fixture, and is unable to set up the test.</p>
<p>Here's a contrived example that hopefully illuminates the problem:</p>
<pre><code>@patch('my_module.my_func')
def test_my_func(mock_func):
    mock_func()
    mock_func.assert_called_once_with()
</code></pre>
<p>After running <code>py.test</code>, the error message would look like:</p>
<pre><code>E       fixture 'my_func' not found
&gt;       available fixtures: cache, capfd, capsys, doctest_namespace, monkeypatch, pytestconfig, record_xml_property, recwarn, tmpdir, tmpdir_factory
&gt;       use 'pytest --fixtures [testpath]' for help on them.
</code></pre>
<p>This is the only scenario under which this failure occurs. If I explicitly call the test (i.e. run <code>test_my_func()</code>), no error. If I patch <code>my_func</code> using either of the other patching techniques, no error. If I import patch from <code>mock</code> instead of <code>unittest.mock</code>, no error.</p>
<p>It's only while running my tests using <code>py.test</code>, using <code>unittest.mock</code>, and patching using the decorator when this occurs.</p>
<p>I'm running Python 3.4.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, mock decorators are not supported.
It's not such bad -- changing function signature by decorator appliance is considered as bad idea.
But you still  may use <code>with mock.patch(...)</code> syntax.</p>
<p>Also as an option there is <a href="https://pypi.python.org/pypi/pytest-mock" rel="noreferrer">pytest-mock</a> plugin with pretty clean api for mocking:</p>
<pre><code>def test_foo(mocker):
    # all valid calls
    mocker.patch('os.remove')
    mocker.patch.object(os, 'listdir', autospec=True)
    mocked_isfile = mocker.patch('os.path.isfile')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There was a <code>pytest</code> issue that now seems to be solved in a newer version of <code>pytest</code>:
<a href="https://github.com/pytest-dev/pytest/pull/3206/commits/b6166dccb4d2b48173aa7e7739be52db9d2d56a0" rel="nofollow noreferrer">https://github.com/pytest-dev/pytest/pull/3206/commits/b6166dccb4d2b48173aa7e7739be52db9d2d56a0</a></p>
<p>Basically, if you had <code>mock</code> installed, this would fail. You can verify by uninstalling <code>mock</code> and running the test again.</p>
<p>If you really need that version of pytest, you can get the mock using <code>with patch(..)</code> inside the function.</p>
</div>
<span class="comment-copy">when you say that they are not supported, who doesnt support them? see <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a>, it mentions patch's usability as a decorator</span>
<span class="comment-copy">also, using the newer unittest.mock.patch(), you can get the mock from @patch if you use test_my_func(*args). Your mock will be in args[0]</span>
<span class="comment-copy">Mock decorators were not compatible with <code>pytest</code> until pytest 3.4.1. Please note: <code>pytest</code> is not the same as the standard <code>unittest</code> library.</span>
