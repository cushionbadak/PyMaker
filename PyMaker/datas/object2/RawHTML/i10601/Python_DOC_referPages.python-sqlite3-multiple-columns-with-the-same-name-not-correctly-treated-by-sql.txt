<div class="post-text" itemprop="text">
<p>I am accessing a sqlite database taken from my phone (specifically, from the gnucash app). I want to access the columns by name, so I set conn.row_factory = sqlite3.Row on my connection. Then I join two tables with the following query:</p>
<pre><code>&gt;&gt;&gt; rows = curr.execute('select * from splits s left join transactions t on s.transaction_uid = t.uid')
</code></pre>
<p>The column names are correctly reported, but without the table alias:</p>
<pre><code>&gt;&gt;&gt; row = rows.fetchone()
&gt;&gt;&gt; print(row.keys())
['_id', 'uid', 'memo', 'type', 'value_num', 'value_denom', 'quantity_num', 'quantity_denom', 'account_uid', 'transaction_uid', 'created_at', 'modified_at', '_id', 'uid', 'name', 'description', 'timestamp', 'is_exported', 'is_template', 'currency_code', 'scheduled_action_uid', 'created_at', 'modified_at', 'commodity_uid']
</code></pre>
<p>so, when I access values, I get the same values for duplicate columns:</p>
<pre><code>&gt;&gt;&gt; for k in row.keys():
...   print(k, row[k])
...
_id 3690
uid a93bf33079924d82afcca4fd6acc0823
memo None
type CREDIT
value_num 1882.9999999999998
value_denom 100
quantity_num 1882.9999999999998
quantity_denom 100
account_uid sbilancio-e966169c8dfe
transaction_uid 2ad90ed9766b4716b8e443c8c19b35a0
created_at 2015-11-03 13:55:03
modified_at 2015-11-03 13:55:03
_id 3690
uid a93bf33079924d82afcca4fd6acc0823
name Sbilancio
description 
timestamp 1412340295000
is_exported 0
is_template 0
currency_code EUR
scheduled_action_uid None
created_at 2015-11-03 13:55:03
modified_at 2015-11-03 13:55:03
commodity_uid None
</code></pre>
<p>The values for _id, uid, created_at and modified_at come from SPLITS, and the one from TRANSACTIONS are not available.</p>
<p>You may tell me I shouldn't use "SELECT *", but that doesn't solve the problem:</p>
<pre><code>&gt;&gt;&gt; rows = curr.execute('select s._id, t._id from splits s left join transactions t on s.transaction_uid = t.uid where s._id = 3758')
&gt;&gt;&gt; row = rows.fetchone()
&gt;&gt;&gt; print(row.keys())
['_id', '_id']
&gt;&gt;&gt; for k in row.keys():
...   print(k, row[k])
... 
_id 3758
_id 3758
</code></pre>
<p>while using column aliases, luckily, works:</p>
<pre><code>&gt;&gt;&gt; rows = curr.execute('select s._id s_id, t._id t_id from splits s left join transactions t on s.transaction_uid = t.uid where s._id = 3758')
&gt;&gt;&gt; row = rows.fetchone()
&gt;&gt;&gt; print(row.keys())
['s_id', 't_id']
</code></pre>
<p>Would you consider this behaviour a bug? And what would you expect from sqlite3, in such a case? I think that if table aliases are given they should be prepended to column names, otherwise a sqlite3.OperationalError exception should be thrown, as for syntax errors in the query. Other ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://www.sqlite.org/c3ref/column_name.html" rel="nofollow">documentation</a> says:</p>
<blockquote>
<p>The name of a result column is the value of the "AS" clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified.</p>
</blockquote>
<p>So when you have a row with two columns that happen to have the same name, it is not possible to access both of them <em>by their name</em>.
How should Python know that <code>row['_id']</code> and <code>row['_id']</code> should be different?</p>
<p>You either have to explicitly rename some columns, or access the row values by their position (<code>row[0]</code> and <code>row[1]</code>).</p>
</div>
<span class="comment-copy">I am not sure it's SQLite bug, more chances it's the python driver you use. Try and run the same query using the sqlite3 CLI, see what you get.</span>
<span class="comment-copy">Yes, I agree, by "sqlite3" I mean the python module, maybe confusingly that's how it's called... <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer">docs.python.org/3/library/sqlite3.html</a></span>
<span class="comment-copy">Yes, that's what I'm saying. The python module <i>should</i> use <code>s._id</code> and <code>t._id</code>, but it doesn't.</span>
<span class="comment-copy">You added the quote from the documentation. It is interesting, but apparently the python module does not use that method, since it <i>does</i> return the correct list of column names, with duplicates included.</span>
<span class="comment-copy">"Unspecified" means that there is a name, but the name could be anything.</span>
