<div class="post-text" itemprop="text">
<p>I'm trying to write many JSON files to a CSV file. Each JSON file has several keys, but different files have different keys. Here are three JSON files as an example.</p>
<p>file A:</p>
<pre><code>{"a": 1, "c": 2}
</code></pre>
<p>file B: </p>
<pre><code>{"b": 5, "d": 3}
</code></pre>
<p>file C:</p>
<pre><code>{"a": 6, "b": 7}
</code></pre>
<p>I'd like one CSV file like this with four columns and three rows (commas omitted for simplicity):</p>
<pre><code>a b c d

1   2 

  5   3

6 7 
</code></pre>
<p>One way to do this is by multiple try/except statements using csv writer. But that becomes infeasible as I am dealing with a large number of keys. Are there any alternatives?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can append each JSON file to a list and then create dataframes and concatenate.</p>
<pre><code>a = {"a": 1, "c": 2}
b = {"b": 5, "d": 3}
c = {"a": 6, "b": 7}
data = [a, b, c]

&gt;&gt;&gt; pd.concat([pd.DataFrame(s, index=[0]) for s in data]).reset_index()
    a   b   c   d
0   1 NaN   2 NaN
1 NaN   5 NaN   3
2   6   7 NaN NaN
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you know all the possible field names ahead of time <a href="https://docs.python.org/3.5/library/csv.html#csv.DictWriter" rel="nofollow"><code>csv.DictWriter</code></a> already comes with a solution for this, use the <code>restval</code> argument to the constructor:</p>
<blockquote>
<p>If the row read has fewer fields than the fieldnames sequence, the
  remaining keys take the value of the optional <code>restval</code> parameter.</p>
</blockquote>
<p>so specifying <code>csv.DictWriter(..., restval=" ")</code> would replace any missing values with a single space although by default <code>restval</code> is set to <code>""</code> (an empty string) which will probably be more useful to you anyway.</p>
<p>so basically your code would look like this:</p>
<pre><code>import csv, json
all_fields = ["a","b","c","d"]
all_files = ["A.json","B.json","C.json"]

with open("OUTPUT.csv", "w") as output_file:
    writer = csv.DictWriter(output_file,all_fields)
    writer.writeheader()

    for filename in all_files:
        with open(filename,"r") as in_file:
            writer.writerow(json.load(in_file))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could load each individual dictionary with the missing keys and give them null values. So it might look like this</p>
<pre><code>for items in list:
    for x in ['a','b','c','d']:
        if x not in item:
            item[x] = ""
</code></pre>
<p>Now that each dictionary has the same keys, you should be able to write the csv easily in the format you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works :</p>
<pre><code>csv_separator = ';'

data = [{"a": 1, "c": 2},
{"b": 5, "d": 3},
{"a": 6, "b": 7}]

headers = sorted(list(set(sum([list(l.keys()) for l in data], []))))

with open('output.csv', 'w+') as f:
    f.write(csv_separator.join(headers))
    for l in data:
        line_elements = []
        for k in headers:
            try:
                line_elements.append(str(l[k]))
            except: # key not in dict, append empty string, i'll let you catch the exception properly
                line_elements.append('')
        f.write(csv_separator.join(line_elements))


# Output : 
# a;b;c;d
# 1;;2;
# ;5;;3
# 6;7;;
</code></pre>
</div>
<span class="comment-copy">that doesn't really look like CSV, using spaces as the delimiter and the "empty space" would make loading that data really difficult.  Also do you know all the possible keys ahead of time?</span>
<span class="comment-copy">You should show the code you have.</span>
<span class="comment-copy">1: this is what <code>dict.setdefault</code> is intended for, 2: a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> can do this significantly more efficiently.</span>
<span class="comment-copy">why are you even opening a file if printing everything to stdout? Also you can just use the <code>.get</code> method on dicts to handle missing keys.</span>
<span class="comment-copy">I forgot about writing to a file, just did pipe the output, thanks for your attention.</span>
