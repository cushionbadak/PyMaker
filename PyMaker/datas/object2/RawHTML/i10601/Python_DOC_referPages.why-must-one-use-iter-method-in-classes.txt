<div class="post-text" itemprop="text">
<p>What exactly is the role of <strong>iter</strong>? Consider the following code block:</p>
<pre><code>class Reverse:
    def __init__(self,data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
</code></pre>
<p>omitting <strong>iter</strong>(self) and rewritting:</p>
<pre><code>class Reverse2:
    def __init__(self,data):
        self.data = data
        self.index = len(data)
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
</code></pre>
<p>Then:</p>
<pre><code>x = [1,2,3]
y = Reverse(x)
z = Reverse2(x)
y.next()
&gt;&gt;&gt; 3
y.next()
&gt;&gt;&gt; 2
y.next()
&gt;&gt;&gt; 1
z.next()
&gt;&gt;&gt; 3
z.next()
&gt;&gt;&gt; 2
z.next()
&gt;&gt;&gt; 1
</code></pre>
<p>The classes behave the same way regardless of whether I include <strong>iter</strong>() or not, so why should i include it in the first place? I'm sorry if my question isn't clear--I simply don't know how to state it in a more clear way...</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__iter__</code> method is always called, when an iterator is needed, e.g. by explicitly calling <code>iter</code> or in <code>for</code>-loops or when creating lists <code>list(xy)</code>.</p>
<p>So you cannot use your second class <code>Reverse2</code> in all these contexts.</p>
<pre><code>&gt;&gt;&gt; list(Reverse("abc"))
['c', 'b', 'a']
&gt;&gt;&gt; list(Reverse2("abc"))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: iteration over non-sequence
</code></pre>
<p>To answer the question in the comment: the <code>__iter__</code>-method must return any iterator or instance with a <code>__next__</code>-method. Only if your class is a iterator by itself, it should return <code>self</code>. An example of returning a generator as iterator:</p>
<pre><code>class Reverse3:
    def __init__(self,data):
        self.data = data
    def __iter__(self):
        # returns an generator as iterator
        for idx in range(len(self.data)-1, -1, -1):
            yield self.data[idx]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The __iter__ return the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">iterator object</a> which allows to convert the object to a container which can be iterated via <code>for .. in ..</code>.</p>
<p>The iterator object is any object which define __next__ method which returns the next item if exists or raise <code>StopIteration</code> otherwise.</p>
<p>While __iter__ can return any such iterator object, It can return itself if it implement __next__ method.</p>
<p>For example:</p>
<pre><code>class Reverse:
    def __init__(self,data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
</code></pre>
<p>Now you can use in for loops:</p>
<pre><code>for xx in Reverse(x):
    print xx
</code></pre>
</div>
<span class="comment-copy">ok I understand why <b>iter</b> must be included now, but why should I make that method return 'self'?</span>
<span class="comment-copy">@KevinMoon: see my answer, but you should also edit your question.</span>
<span class="comment-copy">ok I understand why <b>iter</b> must be included now, but why should I make that method return 'self'?</span>
