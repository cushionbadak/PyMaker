<div class="post-text" itemprop="text">
<p>I have been running a script where I use the <code>ord()</code> function and for whatever the reason in python 2.7, it accepts the unicode string character just as it requires and outputs an integer.</p>
<p>In python 3.4, this is not so much the case. This is the output of error that is being produced : </p>
<pre><code>Traceback (most recent call last):
  File "udpTransfer.py", line 38, in &lt;module&gt;
    buf.append(ord(c))
TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>When I look in both documentations, the ord function is explained to be doing the same exact thing. </p>
<p>This is the code that I am using for both python versions:</p>
<pre><code>import socket,sys, ast , os, struct
from time import ctime
import time
import csv


# creating the udo socket necessary to receive data
sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
ip = '192.168.10.101' #i.p. of our computer
port = 20000 # socket port opened to connect from the matlab udp send data stream
server_address = (ip, port)

sock.bind(server_address)   # bind socket

sock.settimeout(2)          # sock configuration
sock.setblocking(1)
print('able to bind')
ii = 0
shotNummer = 0
client = ''
Array = []
byte = 8192
filename = time.strftime("%d_%m_%Y_%H-%M-%S")
filename = filename + '.csv'
try :
    with open(filename,'wb') as csvfile :
        spamwriter = csv.writer(csvfile, delimiter=',',quotechar='|', quoting=csv.QUOTE_MINIMAL)
        # spamwriter.writerow((titles))
        # as long as data comes in, well take it
        while True:
            data,client = sock.recvfrom(byte)
            buf = []
            values = []
            for c in data:
                # print(type(c))
                buf.append(ord(c))
                if len(buf) == 4 :
                    ###
</code></pre>
<p>Can anyone explain why python3.4 it says that <code>c</code> is an integer, rather than in Python 2.7 where it is actually a string, just as the <code>ord()</code> function requires?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the difference is that in Python 3 the <code>sock.recvfrom(...)</code> call returns bytes while Python 2.7 recvfrom returns a string. So <code>ord</code> did not change but what is being passed to ord has changed. </p>
<p><a href="https://docs.python.org/2.7/library/socket.html#socket.socket.recvfrom" rel="nofollow">Python 2.7 recvfrom</a></p>
<p><a href="https://docs.python.org/3.5/library/socket.html#socket.socket.recvfrom" rel="nofollow">Python 3.5 recvfrom</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You are passing in an <em>integer</em> to <code>ord()</code> in Python 3. That's because you are iterating over a <code>bytes</code> object in Python 3 (the first element in the tuple return value from <a href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom" rel="nofollow"><code>socket.recvfrom()</code></a>):</p>
<pre><code>&gt;&gt;&gt; for byte in b'abc':
...     print(byte)
...
97
98
99
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code> type documentation</a>:</p>
<blockquote>
<p>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers[.]</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Since bytes objects are sequences of integers (akin to a tuple), for a bytes object <em>b</em>, <code>b[0]</code> will be an integer [...].</p>
</blockquote>
<p>In <a href="https://docs.python.org/2/library/socket.html#socket.socket.recvfrom" rel="nofollow">Python 2, <code>socket.recvfrom()</code></a> produces a <code>str</code> object instead, and iteration over such an object gives new one-character string objects, which indeed need to be passed to <code>ord()</code> to be converted to an integer.</p>
<p>You could instead use a <code>bytearray()</code> here to get the same integer sequence in both Python 2 and 3:</p>
<pre><code>for c in bytearray(data):
    # c is now in integer in both Python 2 and 3
</code></pre>
<p>You don't need to use <code>ord()</code> at all in that case.</p>
</div>
<span class="comment-copy">Your traceback is incomplete. You did not include the actual <i>exception</i>.</span>
<span class="comment-copy">updated as explained...</span>
<span class="comment-copy">thanks. I ended up decoding the bytes package that came using data.decode('format') .</span>
