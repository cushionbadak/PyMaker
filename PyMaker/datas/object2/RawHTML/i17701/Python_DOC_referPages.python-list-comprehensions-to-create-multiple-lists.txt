<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/949098/python-split-a-list-based-on-a-condition">Python: split a list based on a condition?</a>
<span class="question-originals-answer-count">
                    29 answers
                </span>
</li>
</ul>
</div>
<p>I want to create two lists <code>listOfA</code> and <code>listOfB</code> to store indices of <code>A</code> and <code>B</code> from another list s.</p>
<pre><code>s=['A','B','A','A','A','B','B']
</code></pre>
<p>Output should be two lists</p>
<pre><code>listOfA=[0,2,3,4]
listOfB=[1,5,6]
</code></pre>
<p>I am able to do this with two statements.</p>
<pre><code>listOfA=[idx for idx,x in enumerate(s) if x=='A']
listOfB=[idx for idx,x in enumerate(s) if x=='B']
</code></pre>
<p>However, I want to do it in only one iteration using list comprehensions only.
Is it possible to do it in a single statement?
something like <code>listOfA,listOfB=[--code goes here--]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The very definition of a list comprehension is to produce <strong>one</strong> list object. Your 2 list objects are of different lengths even; you'd have to use side-effects to achieve what you want.</p>
<p>Don't use list comprehensions here. Just use an ordinary loop:</p>
<pre><code>listOfA, listOfB = [], []

for idx, x in enumerate(s):
    target = listOfA if x == 'A' else listOfB
    target.append(idx)
</code></pre>
<p>This leaves you with just <strong>one</strong> loop to execute; this will beat any two list comprehensions, at least not until the developers find a way to make list comprehensions build a list twice as fast as a loop with separate <code>list.append()</code> calls.</p>
<p>I'd pick this any day over a nested list comprehension <em>just</em> to be able to produce two lists on one line. As the <a href="http://www.python.org/dev/peps/pep-0020/" rel="noreferrer">Zen of Python</a> states:</p>
<blockquote>
<p>Readability counts.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Sort of; the key is to generate a 2-element list that you can then unpack:</p>
<pre><code>listOfA, listOfB = [[idx for idx, x in enumerate(s) if x == c] for c in 'AB']
</code></pre>
<p>That said, I think it's pretty daft to do it that way, an explicit loop is much more readable.</p>
</div>
<div class="post-text" itemprop="text">
<p>A nice approach to this problem is to use defaultdict. As @Martin already said, list comprehension is not the right tool to produce two lists. Using defaultdict would enable you to create segregation using a single iteration. Moreover your code would not be limited in any form.</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s=['A','B','A','A','A','B','B']
&gt;&gt;&gt; listOf = defaultdict(list)
&gt;&gt;&gt; for idx, elem in enumerate(s):
    listOf[elem].append(idx)
&gt;&gt;&gt; listOf['A'], listOf['B']
([0, 2, 3, 4], [1, 5, 6])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you're trying to do isn't exactly impossible, it's just complicated, and probably wasteful.</p>
<p>If you want to partition an iterable into two iterables, if the source is a list or other re-usable iterable, you're probably better off either doing it in two passes, as in your question. </p>
<p>Even if the source is an iterator, if the output you want is a pair of lists, not a pair of lazy iterators, either use <a href="https://stackoverflow.com/a/21023591/908494">Martijn's answer</a>, or do two passes over <code>list(iterator)</code>.)</p>
<p>But if you really need to lazily partition an arbitrary iterable into two iterables, there's no way to do that without some kind of intermediate storage. </p>
<p>Let's say you partition <code>[1, 2, -1, 3, 4, -2]</code> into <code>positives</code> and <code>negatives</code>. Now you try to <code>next(negatives)</code>. That ought to give you <code>-1</code>, right? But it can't do that without consuming the <code>1</code> and the <code>2</code>. Which means when you try to <code>next(positives)</code>, you're going to get <code>3</code> instead of <code>1</code>. So, the <code>1</code> and <code>2</code> need to get stored somewhere.</p>
<p>Most of the cleverness you need is wrapped up inside <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a>. If you just make <code>positives</code> and <code>negatives</code> into two teed copies of the same iterator, then filter them both, you're done.</p>
<p>In fact, this is one of the recipes in the <code>itertools</code> docs:</p>
<pre><code>def partition(pred, iterable):
    'Use a predicate to partition entries into false entries and true entries'
    # partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9
    t1, t2 = tee(iterable)
    return filterfalse(pred, t1), filter(pred, t2)
</code></pre>
<p>(If you can't understand that, it's probably worth writing it out explicitly, with either two generator functions sharing an iterator and a tee via a closure, or two methods of a class sharing them via <code>self</code>. It should be a couple dozen lines of code that doesn't require anything tricky.)</p>
<p>And you can even get <code>partition</code> as an import from a third-party library like <code>more_itertools</code>.</p>
<hr/>
<p>Now, you can use this in a one-liner:</p>
<pre><code>lst = [1, 2, -1, 3, 4, -2]
positives, negatives = partition(lst, lambda x: x&gt;=0)
</code></pre>
<p>… and you've got an iterator over all the positive values, and an iterator over all of the negative values. They look like they're completely independent, but together they only do a single pass over <code>lst</code>—so it works even if you assign <code>lst</code> to a generator expression or a file or something instead of a list.</p>
<hr/>
<p>So, why isn't there some kind of shortcut syntax for this? Because it would be pretty misleading. </p>
<p>A comprehension takes no extra storage. That's the reason generator expressions are so great—they can transform a lazy iterator into another lazy iterator without storing anything. </p>
<p>But this takes <code>O(N)</code> storage. Imagine all of the numbers are positive, but you try to iterate <code>negative</code> first. What happens? All of the numbers get pushed to <code>trueq</code>. In fact, that <code>O(N)</code> could even be <em>infinite</em> (e.g., try it on <code>itertools.count()</code>).</p>
<p>That's fine for something like <code>itertools.tee</code>, a function stuck in a module that most novices don't even know about, and which has nice docs that can explain what it does and make the costs clear. But doing it with syntactic sugar that made it look just like a normal comprehension would be a different story.</p>
</div>
<div class="post-text" itemprop="text">
<p>For those who live on the edge ;)</p>
<pre><code>listOfA, listOfB = [[i for i in cur_list if i is not None] for cur_list in zip(*[(idx,None) if value == 'A' else (None,idx) for idx,value in enumerate(s)])]
</code></pre>
</div>
<span class="comment-copy">Why? Are you concerned about the 2*N complexity? O(2N) ≈ O(N). I would seriously consider just using two generators that are written pretty much the same as your list comprehensions.</span>
<span class="comment-copy">@kojiro: No complexity is not an issue here, I just want to explore features of python.</span>
<span class="comment-copy">@Martin's solution seems better as it iterates only once</span>
<span class="comment-copy">Is list comprehension (to generate a single list) faster than list generation by appending?</span>
<span class="comment-copy">@Heisenberg: yes, because Python can do the list building entirely in C then. No pesky Python stack pushes and pops, no <code>.append()</code> attribute lookups. We can optimize the latter a little (use <code>A, B = listOfA.append, listOfB.append</code> outside the loop and reuse those), but the stack call is still going to be slower than the C code.</span>
<span class="comment-copy">This still loops twice, and is mightily unreadable.</span>
<span class="comment-copy">He also said he wanted a single iteration, not just a single statement (this still iterates <code>s</code> twice).</span>
<span class="comment-copy">For two keys, I'd put money on my conditional statement beating your <code>hash(elem)</code> calls.</span>
<span class="comment-copy">@MartijnPieters: I wont bet on this with you. I am just providing an alternative, provided OP wants to extend this idea over multiple keys(items).</span>
