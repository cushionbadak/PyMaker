<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19751556/pythons-in-contains-operator-returns-a-bool-whose-value-is-neither-true-n">Python's in (__contains__) operator returns a bool whose value is neither True nor False</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<pre><code>&gt;&gt;&gt; 3 &gt; 2 == True
 False  #say what?
&gt;&gt;&gt; (3 &gt; 2) == True
 True
&gt;&gt;&gt; 3 &gt; (2 == True)
 True
&gt;&gt;&gt; 3 &gt; 1 == True
 True
&gt;&gt;&gt; 3 &gt; False
 True
</code></pre>
<p>What is Python doing in its godforsaken hidden logics that makes that first statement <code>False</code>, while the rest are <code>True</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a chained comparison (see <a href="http://docs.python.org/3.3/reference/expressions.html#not-in">here</a> in the docs), the same way that</p>
<pre><code>&gt;&gt;&gt; 1 &lt; 2 &lt; 3
True
</code></pre>
<p>is</p>
<pre><code>&gt;&gt;&gt; (1 &lt; 2) and (2 &lt; 3)
True
</code></pre>
<p>In this case, we have</p>
<pre><code>&gt;&gt;&gt; 3 &gt; 2 == True
False
</code></pre>
<p>because</p>
<pre><code>&gt;&gt;&gt; (3 &gt; 2) and (2 == True)
False
</code></pre>
<p>because</p>
<pre><code>&gt;&gt;&gt; (3 &gt; 2), (2 == True)
(True, False)
</code></pre>
</div>
<span class="comment-copy">Comparison chaining doesn't work the way you think it does. See the third paragraph here: <a href="http://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow noreferrer">docs.python.org/3/reference/expressions.html#not-in</a></span>
<span class="comment-copy">And <code>1 == True</code> is True because <code>bool</code> is a subclass of <code>int</code> and <code>True == 1</code> and <code>False == 0</code>. Which is also why <code>3 &gt; True</code> is true, and <code>0 &lt; True</code> is true, but <code>0 &gt; False</code> is not..</span>
<span class="comment-copy">Also, I don't know if you're making this mistake, but a common mistake is to do something akin to <code>if 3 &gt; 2 == True:</code>, when they mean <code>if 3 &gt; 2:</code>.  You'll almost never want to test if something explicitly <code>== True</code> in python.</span>
<span class="comment-copy">@Neftas: No, only <code>0 == False</code> is true. Every other number is <i>not</i> equal to <code>False</code>.</span>
<span class="comment-copy">This was for a lecture, I was explaining the different comparison operators. What I meant was the second line (3&gt;2) == True, just to show them what <i>can</i> be done.</span>
<span class="comment-copy">And <code>1 == True</code> is true because <code>bool</code> is a subclass of <code>int</code>.</span>
<span class="comment-copy">And <code>3 &gt; True</code> is true for the same reasons.</span>
<span class="comment-copy">Well said @DSM. Thanks much. Hooray for python playing fast and loose with the rules of precedence for the sake of a minor convenience!</span>
<span class="comment-copy">@Andrew: glad to help.  But respectfully, if you haven't seen this before, you haven't used Python enough in real programs to decide whether or not the convenience is worth it.  FWIW I find it so.</span>
