<div class="post-text" itemprop="text">
<p>When forgetting to pass certain arguments to a function, Python gives the only-somewhat-helpful message "myfunction() takes X arguments (Y given)". Is there a way to figure out the names of the missing arguments, and tell the user? Something like:</p>
<pre><code>try:
    #begin blackbox
    def f(x,y):
        return x*y

    f(x=1)
    #end blackbox
except Exception as e:
    #figure out the missing keyword argument is called "y" and tell the user so
</code></pre>
<p>Assuming that the code between begin blackbox and end blackbox is unknown to the exception handler.</p>
<p>Edit: As its been pointed out to me below, Python 3 already has this functionality built in. Let me extend the question then, is there a (probably ugly and hacky) way to do this in Python 2.x? </p>
</div>
<div class="post-text" itemprop="text">
<p>A much cleaner way to do this would be to wrap the function in another function, pass through the <code>*args, **kwargs</code>, and then use those values when you need them, instead of trying to reconstruct them after the fact. But if you don't want to do that…</p>
<p>In Python 3.x (except very early versions), this is easy, as poke's answer explains. Even easier with 3.3+, with <a href="http://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow"><code>inspect.signature</code></a>, <a href="http://docs.python.org/3/library/inspect.html#inspect.getargvalues" rel="nofollow"><code>inspect.getargvalues</code></a>, and <a href="http://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow"><code>inspect.Signature.bind_partial</code></a> and friends.</p>
<p>In Python 2.x, there is no way to do this. The exception only has the string <code>'f() takes exactly 2 arguments (1 given)'</code> in its <code>args</code>.</p>
<p>Except… in CPython 2.x specifically, it's possible with enough ugly and brittle hackery.</p>
<p>You've got a traceback, so you've got its <code>tb_frame</code> and <code>tb_lineno</code>… which is everything you need. So as long as the source is available, the <a href="http://docs.python.org/2/library/inspect.html" rel="nofollow"><code>inspect</code></a> module makes it easy to get the actual function call expression. Then you just need to parse it (via <a href="http://docs.python.org/2/library/ast.html" rel="nofollow"><code>ast</code></a>) to get the arguments passed, and compare to the function's signature (which, unfortunately, isn't nearly as easy to get in 2.x as in 3.3+, but between <code>f.func_defaults</code>, <code>f.func_code.co_argcount</code>, etc., you can reconstruct it).</p>
<p>But what if the source isn't available? Well, between <code>tb_frame.f_code</code> and <code>tb_lasti</code>, you can find out where the function call was in the bytecode. And the <a href="http://docs.python.org/2/library/dis.html" rel="nofollow"><code>dis</code></a> module makes that relatively easy to parse. In particular, right before the call, the positional arguments and the name-value pairs for keyword arguments were all pushed on the stack, so you can easily see which names got pushed, and how many positional values, and reconstruct the function call that way. Which you compare to the signature in the same way.</p>
<p>Of course that relies on the some assumptions about how CPython's compiler builds bytecode. It would be perfectly legal to do things in all kinds of different orders as long as the stack ended up with the right values. So, it's pretty brittle. But I think there are already better reasons not to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would argue that doing this doesn’t really make that much sense. Such an exception is thrown because the programmer missed specifying the argument. So if you knowingly catch the exception, then you could just as well just fix it in the first place.</p>
<p>That being said, in current Python 3 versions, the <code>TypeError</code> that is being thrown does mention which arguments are missing from the call:</p>
<pre><code>"f() missing 1 required positional argument: 'y'"
</code></pre>
<p>Unfortunately, the argument name is not mentioned separately, so you would have to extract it from the string:</p>
<pre><code>try:
    f(x=1)
except TypeError as e:
    if 'required positional argument' in e.args[0]:
        argumentNames = e.args[0].split("'")[1::2]
        print('Missing arguments are ' + argumentNames)
    else:
        raise # Re-raise other TypeErrors
</code></pre>
<p>As Joran Beasley pointed out in the comments, Python 2 does not tell you which arguments are missing but just how many are missing. So there is no way to tell from the exception which arguments were missing in the call.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>except TypeError as e:
   import inspect
   got_args = int(re.search("\d+.*(\d+)",str(e)).groups()[0])
   print "missing args:",inspect.getargspec(f).args[got_args:]
</code></pre>
<p>a better method would be a decorator</p>
<pre><code>def arg_decorator(fn):
   def func(*args,**kwargs):
       try: 
           return fn(*args,**kwargs)
       except TypeError:
           arg_spec = inspect.getargspec(fn)
           missing_named = [a for a in arg_spec.args if a not in kwargs]
           if arg_spec.defaults:
                    missing_args = missing_named[len(args): -len(arg_spec.defaults) ]
           else:
                    missing_args = missing_named[len(args):]
           print "Missing:",missing_args
   return func

@arg_decorator
def fn1(x,y,z):                      
      pass

def fn2(x,y):
    pass

arged_fn2 = arg_decorator(fn2)

fn1(5,y=2)
arged_fn2(x=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With purely the exception to deal with it is not possible to do what you want and handle keyword arguments. This is of course wrt Python 2.7.</p>
<p>The code that generates this message in Python is:</p>
<pre><code>PyErr_Format(PyExc_TypeError,
    "%.200s() takes %s %d "
    "argument%s (%d given)",
    PyString_AsString(co-&gt;co_name),
    defcount ? "at most" : "exactly",
    co-&gt;co_argcount,
    co-&gt;co_argcount == 1 ? "" : "s",
    argcount + kwcount);
</code></pre>
<p>Taken from lines 3056-3063 from <a href="http://hg.python.org/cpython/file/0e5df5b62488/Python/ceval.c" rel="nofollow">http://hg.python.org/cpython/file/0e5df5b62488/Python/ceval.c</a></p>
<p>As you can see, there is just not enough information given to the exception as to what arguments are missing. <code>co</code> in this context is the <code>PyCodeObject</code> being called. The only thing given is a string (which you could parse if you like) with the function name, whether or not there is a vararg, how many arguments are expected, and how many arguments were given. As has been pointed out, this does not give you sufficient information as to what argument(s) were not given (in the case of keyword arguments).</p>
<p>Something like <code>inspect</code> or the other debugging modules might be able to give you enough information as to what function was called and how it was called, from which you could figure out what arguments were not given.</p>
<p>I should also mention however that almost certainly, whatever solution you come up with will not be able to handle at least some extension module methods (those written in C) because they don't provide argument information as part of their object.</p>
</div>
<span class="comment-copy">@CrazyCasta That’s not really answering the question…</span>
<span class="comment-copy">It's a helpful and related question, but not a duplicate.  People are too trigger happy with the close votes on SO these days ...</span>
<span class="comment-copy">Which version of Python is this for? The answers are different for very early 2.x, later 2.x, very early 3.x, and later 3.x…</span>
<span class="comment-copy">Note that current python 3 will give you this information.  Upgrade!  :)</span>
<span class="comment-copy">@marius: If this is just an exercise… it may be a great time to start playing with tracebacks, frames, code objects, <code>inspect.getsource</code>, <code>dis.dis</code>, etc. But really, I think you might be better off first moving to Python 3.4, where all of this is a lot easier and cleaner and more fun to play around with than in 2.7, and the knowledge you gain will be valuable farther into the future.</span>
<span class="comment-copy">+1 for slowest gun in the west</span>
<span class="comment-copy">@wim: I was originally planning to write some example code for this… but then I decided that if someone is doing this "as an exercise", it would be more fun for him to build it from scratch based on the links—see what is and isn't in the half-documented <code>code</code> object, what <code>ast</code> objects and/or disassembly look like, etc. So I rewrote the whole think, making it even later.</span>
<span class="comment-copy">this is not true for python 2.6 at least <code>aa() takes exactly 2 non-keyword arguments (1 given)</code></span>
<span class="comment-copy">IndexError in python 2</span>
<span class="comment-copy">@wim I get TypeError in 2.6</span>
<span class="comment-copy">@wim Huh, for what line?</span>
<span class="comment-copy">This is the easiest and best way to do it in Python 3.1+ (I think… maybe 3.2+). It doesn't work for 2.x or 3.0, but then <i>nothing</i> easy works there.</span>
<span class="comment-copy">The number in the exeption message will not tell you <i>which</i> argument is missing, but just how many.</span>
<span class="comment-copy">try <code>f(y=5)</code> to see output  so while technically yes its just how many ... you can use it to get the last index given</span>
<span class="comment-copy"><code>except TypeError as e:</code>, otherwise good</span>
<span class="comment-copy">f(y=5) still gives me "missing args: ['y']" am I missing something?</span>
<span class="comment-copy">umm I get x,y when i do it in 2.6 it returns <code>aa() takes exactly 2 non-keyword arguments (0 given)</code> even though I called it with the second positional named argument</span>
<span class="comment-copy">For the last paragraph, that's another thing that's (getting) better in 3.x. Functions defined with <a href="http://www.python.org/dev/peps/pep-0436/" rel="nofollow noreferrer">Argument Clinic</a> expose <code>inspect.Signature</code> objects. In 3.4b3+, that should be most of the builtins and stdlib. After 3.4, I believe the goal is to make it more usable for third-party extension modules, including those that work with earlier versions (though whether that means 3.1+ or 2.6+ I don't know).</span>
