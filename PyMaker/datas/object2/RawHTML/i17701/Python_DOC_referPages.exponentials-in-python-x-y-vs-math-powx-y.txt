<div class="post-text" itemprop="text">
<p>Which one is more efficient using math.pow or the ** operator? When should I use one over the other?</p>
<p>So far I know that <code>x**y</code> can return an <code>int</code> or a <code>float</code> if you use a decimal
the function <code>pow</code> will return a float</p>
<pre><code>import math

print math.pow(10, 2)

print 10. ** 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the power operator <code>**</code> will be faster as it won’t have the overhead of a function call. You can see this if you disassemble the Python code:</p>
<pre><code>&gt;&gt;&gt; dis.dis('7. ** i')
  1           0 LOAD_CONST               0 (7.0) 
              3 LOAD_NAME                0 (i) 
              6 BINARY_POWER         
              7 RETURN_VALUE         
&gt;&gt;&gt; dis.dis('pow(7., i)')
  1           0 LOAD_NAME                0 (pow) 
              3 LOAD_CONST               0 (7.0) 
              6 LOAD_NAME                1 (i) 
              9 CALL_FUNCTION            2 (2 positional, 0 keyword pair) 
             12 RETURN_VALUE         
&gt;&gt;&gt; dis.dis('math.pow(7, i)')
  1           0 LOAD_NAME                0 (math) 
              3 LOAD_ATTR                1 (pow) 
              6 LOAD_CONST               0 (7) 
              9 LOAD_NAME                2 (i) 
             12 CALL_FUNCTION            2 (2 positional, 0 keyword pair) 
             15 RETURN_VALUE         
</code></pre>
<p>Note that I’m using a variable <code>i</code> as the exponent here because constant expressions like <code>7. ** 5</code> are actually evaluated at compile time.</p>
<p>Now, in practice, this difference does not matter that much, as you can see when timing it:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit('7. ** i', setup='i = 5')
0.2894785532627111
&gt;&gt;&gt; timeit('pow(7., i)', setup='i = 5')
0.41218495570683444
&gt;&gt;&gt; timeit('math.pow(7, i)', setup='import math; i = 5')
0.5655053168791255
</code></pre>
<p>So, while <code>pow</code> and <code>math.pow</code> are about twice as slow, they are still fast enough to not care much. Unless you can actually identify the exponentiation as a bottleneck, there won’t be a reason to choose one method over the other if clarity decreases. This especially applies since <a href="http://docs.python.org/3/library/functions.html#pow" rel="noreferrer"><code>pow</code></a> offers an integrated modulo operation for example.</p>
<hr/>
<p>Alfe asked a good question in the comments above:</p>
<blockquote>
<p><code>timeit</code> shows that <code>math.pow</code> is slower than <code>**</code> in all cases. What is <code>math.pow()</code> good for anyway? Has anybody an idea where it can be of any advantage then?</p>
</blockquote>
<p>The big difference of <code>math.pow</code> to both the builtin <code>pow</code> and the power operator <code>**</code> is that it <em>always</em> uses float semantics. So if you, for some reason, want to make sure you get a float as a result back, then <code>math.pow</code> will ensure this property.</p>
<p>Let’s think of an example: We have two numbers, <code>i</code> and <code>j</code>, and have no idea if they are floats or integers. But we want to have a float result of <code>i^j</code>. So what options do we have?</p>
<ul>
<li>We can convert at least one of the arguments to a float and then do <code>i ** j</code>.</li>
<li>We can do <code>i ** j</code> and convert the result to a float (float exponentation is automatically used when either <code>i</code> or <code>j</code> are floats, so the result is the same).</li>
<li>We can use <code>math.pow</code>.</li>
</ul>
<p>So, let’s test this:</p>
<pre><code>&gt;&gt;&gt; timeit('float(i) ** j', setup='i, j = 7, 5')
0.7610865891750791
&gt;&gt;&gt; timeit('i ** float(j)', setup='i, j = 7, 5')
0.7930400942188385
&gt;&gt;&gt; timeit('float(i ** j)', setup='i, j = 7, 5')
0.8946636625872202
&gt;&gt;&gt; timeit('math.pow(i, j)', setup='import math; i, j = 7, 5')
0.5699394063529439
</code></pre>
<p>As you can see, <code>math.pow</code> is actually faster! And if you think about it, the overhead from the function call is also gone now, because in all the other alternatives we have to call <code>float()</code>.</p>
<hr/>
<p>In addition, it might be worth to note that the behavior of <code>**</code> and <code>pow</code> can be overridden by implementing the special <code>__pow__</code> (and <code>__rpow__</code>) method for custom types. So if you don’t want that (for whatever reason), using <code>math.pow</code> won’t do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for the protocol: The <code>**</code> operator calls the <a href="https://docs.python.org/2/library/functions.html#pow" rel="nofollow">built-in <code>pow</code> function</a> which accepts an optional third argument (modulus) if the first two arguments are integer types.</p>
<p>So, if you intend to calculate remainders from powers, use the built-in function. The <code>math.pow</code> may give you false results:</p>
<pre><code>import math

base = 13
exp = 100
mod = 2
print math.pow(base, exp) % mod
print pow(base, exp, mod)
</code></pre>
<p>When I ran this, I got <code>0.0</code> in the first case which obviously cannot be true, because 13 is odd (and therefore all of it's integral powers). The <code>math.pow</code> version uses limited accuracy which causes an error. </p>
<p>For sake of fairness, we must say, <code>math.pow</code> can be much faster:</p>
<pre><code>import timeit
print timeit.timeit("math.pow(2, 100)",setup='import math')
print timeit.timeit("pow(2, 100)")
</code></pre>
<p>Here is what I'm getting as output:</p>
<pre><code>0.240936803195
1.4775809183
</code></pre>
<hr/>
<p>Some online examples</p>
<ul>
<li><a href="http://ideone.com/qaDWRd" rel="nofollow">http://ideone.com/qaDWRd</a> (wrong remainder with <code>math.pow</code>)</li>
<li><a href="http://ideone.com/g7J9Un" rel="nofollow">http://ideone.com/g7J9Un</a> (lower performance with <code>pow</code> on int values)</li>
<li><a href="http://ideone.com/KnEtXj" rel="nofollow">http://ideone.com/KnEtXj</a> (slightly lower performance with <code>pow</code> on float values)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Well, they are for different tasks, really.  </p>
<p>Use <code>pow</code> (equivalent to <code>x ** y</code> with two arguments) when you want integer arithmetic.  </p>
<p>And use <code>math.pow</code> if either argument is float, and you want float output.  </p>
<p>For a discussion on the differences between <code>pow</code> and <code>math.pow</code>, see this <a href="https://stackoverflow.com/q/10282674/674039">question</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>**</code> is indeed faster then <code>math.pow()</code>, but if you want a simple quadratic function like in your example it is even faster to use a product.</p>
<pre><code>10.*10.
</code></pre>
<p>will be faster then </p>
<pre><code>10.**2
</code></pre>
<p>The difference is not big and not noticable with one operation (using <code>timeit</code>), but with a large number of operations it can be significant.</p>
</div>
<span class="comment-copy">Why not <code>timeit</code> to find out?</span>
<span class="comment-copy"><code>timeit</code> shows that <code>math.pow</code> is slower than <code>**</code> in all cases.  What is <code>math.pow()</code> good for anyway?  Has anybody an idea where it can be of any advantage then?</span>
<span class="comment-copy">@Alfe how did you measure, or do I misunderstand your <code>in all cases</code>? I <a href="http://stackoverflow.com/a/28539821/2932052">see cases</a> where <code>math.pow</code> is much faster.</span>
<span class="comment-copy">@Wolf, Do you?  Your link points to a comparison of <code>pow</code> with <code>math.pow</code>, but I'm talking about a comparison of <code>math.pow</code> with the <code>**</code> operator.  Your comparison there can be completed by adding that third version, then <code>**</code> again beats every other option: <code>import timeit; print timeit.timeit("math.pow(2, 100)",setup='import math'), timeit.timeit("pow(2, 100)"), timeit.timeit("2 ** 100")</code> → <code>0.170357942581 1.00546097755 0.013473033905</code>.</span>
<span class="comment-copy">But I have to admit that the results are not exactly the same.  <code>math.pow</code> <i>always</i> returns a <code>float</code> (also for <code>int</code> input) while <code>**</code> returns the type of its input (well, mixed input results in <code>float</code>).  But that's still no good reason to use <code>math.pow</code>, IMHO.</span>
<span class="comment-copy">fantastic answer</span>
<span class="comment-copy"><code>__builtin__.pow</code> may more explicitly specify that it's the built-in, but unless the OP already knows about the <code>__builtin__</code> module, it's likely to be confusing.</span>
