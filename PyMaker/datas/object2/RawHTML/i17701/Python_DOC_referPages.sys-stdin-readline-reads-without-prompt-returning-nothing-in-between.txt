<div class="post-text" itemprop="text">
<p>I have a function that executes the following (among other things): </p>
<pre><code>userinput = stdin.readline()
betAmount = int(userinput)
</code></pre>
<p>Is supposed to take input integer from stdin as a string and convert it to an integer.</p>
<p>When I call the function, however, it returns a single newline character (it doesn't even wait for me to input anything).</p>
<p>Earlier in the program I get some input in the form of:</p>
<pre><code>stdin.read(1)
</code></pre>
<p>to capture a single character.</p>
<p>Could this have something to do with it? Am I somehow writing a newline character to the next line of stdin?</p>
<p>How can I fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>stdin.read(1)</code> reads one character from <code>stdin</code>. If there was more than one character to be read at that point (e.g. the newline that followed the one character that was read in) then that character or characters will still be in the buffer waiting for the next <code>read()</code> or <code>readline()</code>. </p>
<p>As an example, given <code>rd.py</code>:</p>
<pre><code>from sys import stdin

x = stdin.read(1)
userinput = stdin.readline()
betAmount = int(userinput)
print ("x=",x)
print ("userinput=",userinput)
print ("betAmount=",betAmount)
</code></pre>
<p>... if I run this script as follows (I've typed in the <code>234</code>):</p>
<pre><code>C:\&gt;python rd.py
234
x= 2
userinput= 34

betAmount= 34
</code></pre>
<p>... so the <code>2</code> is being picked up first, leaving the <code>34</code> and the trailing newline character to be picked up by the <code>readline()</code>.</p>
<p>I'd suggest fixing the problem by using <code>readline()</code> rather than <code>read()</code> under most circumstances.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simon's answer and Volcano's together explain what you're doing wrong, and Simon explains how you can fix it by redesigning your interface.</p>
<p>But if you really <em>need</em> to read 1 character, and then later read 1 line, you can do that. It's not trivial, and it's different on Windows vs. everything else.</p>
<p>There are actually three cases: a Unix tty, a Windows DOS prompt, or a regular file (redirected file/pipe) on either platform. And you have to handle them differently.</p>
<p>First, to check if stdin is a tty (both Windows and Unix varieties), you just call <code>sys.stdin.isatty()</code>. That part is cross-platform.</p>
<p>For the non-tty case, it's easy. It may actually just work. If it doesn't, you can just read from the unbuffered object underneath <code>sys.stdin</code>. In Python 3, this just means <code>sys.stdin.buffer.raw.read(1)</code> and <code>sys.stdin.buffer.raw.readline()</code>. However, this will get you encoded bytes, rather than strings, so you will need to call <code>.decode(sys.stdin.decoding)</code> on the results; you can wrap that all up in a function.</p>
<p>For the tty case on Windows, however, input will still be line buffered even on the raw buffer. The only way around this is to use the <a href="http://docs.python.org/3/library/msvcrt.html#console-i-o">Console I/O</a> functions instead of normal file I/O. So, instead of <code>stdin.read(1)</code>, you do <code>msvcrt.getwch()</code>.</p>
<p>For the tty case on Unix, you have to set the terminal to raw mode instead of the usual line-discipline mode. Once you do that, you can use the same <code>sys.stdin.buffer.read(1)</code>, etc., and it will just work. If you're willing to do that permanently (until the end of your script), it's easy, with the <a href="http://docs.python.org/3/library/tty.html"><code>tty.setraw</code></a> function. If you want to return to line-discipline mode later, you'll need to use the <a href="http://docs.python.org/3/library/termios.html#module-termios"><code>termios</code></a> module. This looks scary, but if you just stash the results of <code>termios.tcgetattr(sys.stdin.fileno())</code> before calling <code>setraw</code>, then do <code>termios.tcsetattr(sys.stdin.fileno(), TCSAFLUSH, stash)</code>, you don't have to learn what all those fiddly bits mean.</p>
<p>On both platforms, mixing console I/O and raw terminal mode is painful. You definitely can't use the <code>sys.stdin</code> buffer if you've ever done any console/raw reading; you can only use <code>sys.stdin.buffer.raw</code>. You could always replace <code>readline</code> by reading character by character until you get a newline… but if the user tries to edit his entry by using backspace, arrows, emacs-style command keys, etc., you're going to get all those as raw keypresses, which you don't want to deal with.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>stdin.read(1)
</code></pre>
<p>will not return when you press one character - it will wait for '\n'. The problem is that the second character is buffered in standard input, and the moment you call another input - it will return immediately because it gets its input from buffer.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need just one character and you don't want to keep things in the buffer, you can simply read a whole line and drop everything that isn't needed.</p>
<p>Replace:</p>
<pre><code>stdin.read(1)
</code></pre>
<p>with</p>
<pre><code>stdin.readline().strip()[:1]
</code></pre>
<p>This will read a line, remove spaces and newlines and just keep the first character.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this ...</p>
<pre><code>import sys
buffer = []
while True:
    userinput = sys.stdin.readline().rstrip('\n')
    if userinput == 'quit':
        break
    else:
        buffer.append(userinput)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys
userinput = sys.stdin.readline()
betAmount = int(userinput)

print betAmount
</code></pre>
<p>This works on my system. I checked int('23\n')  would result in 23.</p>
</div>
<span class="comment-copy">@volcano summarised this very nicely for me, thank you both</span>
<span class="comment-copy"><code>sys.stdin.buffer.raw</code> won't unbuffer the stdout buffer of a process on the other end of the pipe in non-tty case when the block buffering is probably used for stdout i.e., you won't be able to read anything from Python until the other process flushes its stdout buffer.</span>
<span class="comment-copy">A concise explanation- thank you</span>
<span class="comment-copy">This answers the question that Google sent me here for. +1</span>
<span class="comment-copy">Checked with python 2.7..</span>
<span class="comment-copy">If you read the whole question, you're not testing the key part of what he's doing—calling <code>sys.stdin.read(1)</code> before <code>sys.stdin.readline()</code>, so the fact that your code works doesn't mean anything. (Plus, the OP's code is Python 3; why would you test that in 2.7 and then assume it's the same?)</span>
