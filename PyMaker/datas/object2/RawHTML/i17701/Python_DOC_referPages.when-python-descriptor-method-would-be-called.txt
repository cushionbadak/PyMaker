<div class="post-text" itemprop="text">
<p>I simulate some data using python descriptor.  </p>
<pre><code>class Number:
    def __init__(self):
        self.num = 0 

    def __get__(self, instance, obj):
        print("is getting number")
        return self.number

    def __set__(self, instance, value):
        print("is setting number")
        self.number = value

    def __str__(self):
        return str(self.number)

num = Number()
num = 2 
print(num + 7)
</code></pre>
<p>the output:</p>
<pre><code>9
</code></pre>
<p>It seems successfully call the method <code>__get__</code> and <code>__set__</code>, but i don't know why there's no output message <code>is getting number</code> or <code>is setting number</code>.</p>
<p>I'm not sure whether python call the descriptor method or not.</p>
<p>my question is when descriptor method would be called?</p>
<p>I summary my origin guess:</p>
<ol>
<li><p>get</p>
<ul>
<li>When use <code>obj.prop</code> to get property and the prop is another object which is setting descriptor</li>
<li>when calculate some expression should get value such as <code>a + 5</code>. If a is have descriptor and will call <code>__get__</code></li>
<li>If a object simulate a function will call <code>__get__</code> to get function body first, and then call <code>__call__</code> to run the function.</li>
</ul></li>
<li><p>set</p>
<ul>
<li>When the object appear in the left side of assignment statement such as <code>obj = 5</code></li>
</ul></li>
</ol>
<p>But I must be wrong, i need someone to tell me the right concept.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your descriptors are not being called, and there is no way to write a descriptor or anything else to do what you seem to want.</p>
<p>When you do <code>num = 2</code>, you have thrown away your <code>Number</code> object and set the variable <code>num</code> to the ordinary number 2.  When you then add 7 to it, it equals 9, because it's just a regular number.  Your <code>Number</code> class is not involved in any way.</p>
<p>Descriptors allow you to hook into what happens when you do <code>obj.foo</code> or <code>obj.foo = blah</code>.  In these cases it is <code>foo</code> that is the descriptor, not <code>obj</code>, and the descriptor only works when it is an attribute.  There is no way to change what happens when you do <code>obj = blah</code>, where <code>obj</code> is a bare name (i.e., no dots or <code>[]</code>).  In relation to your guess:</p>
<ol>
<li><p>get</p>
<ul>
<li>When use obj.prop to get property and the prop is another object which is setting descriptor
<ul>
<li>Yes, basically.  When you do <code>obj.prop</code> and <code>prop</code> is a descriptor, then its <code>__get__</code> is called.  Note that <code>prop</code> is the descriptor, not <code>obj</code>.</li>
</ul></li>
<li>when calculate some expression should get value such as <code>a + 5</code>. If a is have descriptor and will call <code>__get__</code>
<ul>
<li>No.  You can override such behavior with the <code>__add__</code> magic method, or similar methods for other operators</li>
</ul></li>
<li>If a object simulate a function will call <code>__get__</code> to get function body first, and then call <code>__call__</code> to run the function.
<ul>
<li>I don't understand what this means, but I think no.  If the object defines <code>__call__</code>, then <code>obj()</code> calls its <code>__call__</code> without involving any descriptor.</li>
</ul></li>
</ul></li>
<li><p>set</p>
<ul>
<li>When the object appear in the left side of assignment statement such as <code>obj = 5</code>
<ul>
<li>No.  Only when the descriptor is accessed <em>as an attribute</em> on the left side, as in <code>obj.prop = 5</code>, where prop is a descriptor.</li>
</ul></li>
</ul></li>
</ol>
<p>The bottom line is that descriptors only work when they are attributes of classes.  Just creating a "bare" descriptor as you're trying to do (i.e., doing <code>obj = SomeDescriptorClass()</code>) won't do anything.</p>
<p>Also, as a side note, descriptors only work when set on new-style classes.  If you're using Python 2, this means that the class holding the descriptor has to inherit from <code>object</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>num = 2</code> makes <code>num</code> an <code>int</code> but not <code>Number</code> anymore.</p>
<p>Descriptor needs to be an attribute of instance and inherited from <code>object</code>.</p>
<pre><code>class Number(object):
    def __init__(self):
        self.num = 0

    def __get__(self, instance, obj):
        print("is getting number")
        return self.num

    def __set__(self, instance, value):
        print("is setting number")
        self.num = value

    # no need to define this for descriptor
    def __str__(self):
        return str(self.num)

class A(object):
    num = Number()

n = A()
n.num = 5
print(n.num + 7)
</code></pre>
</div>
<span class="comment-copy">thank you. so, the descriptor only happen in property of object right?</span>
<span class="comment-copy">I explain what i said <code>emulate function</code>. In the official <a href="http://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods" rel="nofollow noreferrer">doc</a>. the emulation is using <code>__get__</code> to emulate <code>@classmethod</code>. so, i guess call a function will call <code>__get__</code> first.</span>
<span class="comment-copy">@FreedomKnight: Yes.  If you google around you can find plenty of other questions about descriptors on this site, and descriptions on the web.</span>
<span class="comment-copy">@FreedomKnight: In that example, the descriptor is again an attribute.  It happens to return a callable object, but that has nothing to do with how the descriptor protocl works.  It works just the same in that case as in any other case.</span>
<span class="comment-copy">I see, thanks for your help.</span>
