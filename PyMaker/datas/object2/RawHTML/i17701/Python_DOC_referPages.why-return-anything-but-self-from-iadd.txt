<div class="post-text" itemprop="text">
<p>Python's <a href="http://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="noreferrer">documentation on the methods related to the in-place operators</a> like <code>+=</code> and <code>*=</code> (or, as it calls them, the <em>augmented arithmetic assignments</em>) has the following to say:</p>
<blockquote>
<p>These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, <em>self</em>). If a specific method is not defined, the augmented assignment falls back to the normal methods.</p>
</blockquote>
<p>I have two closely related questions:</p>
<ul>
<li>Why is it necessary to return anything from these methods if the documentation specifies that, if implemented, they should only be doing stuff in-place anyway? Why don't the augmented assignment operators simply not perform the redundant assignment in the case where <code>__iadd__</code> is implemented?</li>
<li>Under what circumstances would it ever make sense to return something other than <code>self</code> from an augmented assignment method?</li>
</ul>
<p>A little experimentation reveals that Python's immutable types don't implement <code>__iadd__</code> (which is consistent with the quoted documentation):</p>
<pre><code>&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x.__iadd__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'int' object has no attribute '__iadd__'
</code></pre>
<p>and the <code>__iadd__</code> methods of its mutable types, of course, operate in-place and return <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; list1 = []
&gt;&gt;&gt; list2 = list1
&gt;&gt;&gt; list1 += [1,2,3]
&gt;&gt;&gt; list1 is list2
True
</code></pre>
<p>As such, I can't figure out what the ability to return things other than <code>self</code> from <code>__iadd__</code> is for. It seems like it would be the <em>wrong</em> thing to do in absolutely all circumstances.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why is it necessary to return anything from these methods if the documentation specifies that, if implemented, they should only be doing stuff in-place anyway? Why don't the augmented assignment operators simply not perform the redundant assignment in the case where <code>__iadd__</code> is implemented?</p>
</blockquote>
<p>One reason is to force them to be statements instead of expressions.</p>
<hr/>
<p>A bigger reason is that the assignment isn't always superfluous. In the case where the left-hand side is just a variable, sure, after mutating the object, re-binding that object to the name it was already bound to is usually not necessary.</p>
<p>But what about the case where the left-hand side is a more complicated assignment target? Remember that <a href="http://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">you can assign—and augmented-assign—to subscriptions, slicings, and attribute references</a>, like <code>a[1] += 2</code> or <code>a.b -= 2</code>. In that case, you're actually calling <code>__setitem__</code> or <code>__setattr__</code> on an object, not just binding a variable.</p>
<hr/>
<p>Also, it's worth noting that the "redundant assignment" isn't exactly an expensive operation. This isn't C++, where any assignment can end up calling a custom assignment operator on the value. (It may end up calling a custom setter operator on an object that the value is an element, subslice, or attribute of, and that could well be expensive… but in that case, it's not redundant, as explained above.)</p>
<hr/>
<p>And the last reason directly ties into your second question: You <em>almost always</em> want to return <code>self</code> from <code>__ispam__</code>, but <em>almost always</em> isn't <em>always</em>. And if <code>__iadd__</code> ever didn't return <code>self</code>, the assignment would clearly be necessary.</p>
<hr/>
<blockquote>
<p>Under what circumstances would it ever make sense to return something other than self from an augmented assignment method?</p>
</blockquote>
<p>You've skimmed over an important related bit here:</p>
<blockquote>
<p>These methods should <strong><em>attempt to</em></strong> do the operation in-place (modifying <em>self</em>)</p>
</blockquote>
<p>Any case where they can't do the operation in-place, but can do something <em>else</em>, it will likely be reasonable to return something other than <code>self</code>.</p>
<p>Imagine an object that used a copy-on-write implementation, mutating in-place if it was the only copy, but making a new copy otherwise. You can't do that by not implementing <code>__iadd__</code> and letting <code>+=</code> fall back to <code>__add__</code>; you can only do it by implementing an <code>__iadd__</code> that may make and return a copy instead of mutating and returning <code>self</code>. (You might do that for performance reasons, but it's also conceivable that you'd have an object with two different interfaces; the "high-level" interface looks immutable, and copies-on-write, while the "low-level" interface exposes the actual sharing.)</p>
<p>So, the first reason it's needed is to handle the non-in-place case.</p>
<hr/>
<p>But are there other reasons? Sure.</p>
<p>One reason is just for wrapping other languages or libraries where this is an important feature.</p>
<p>For example, in Objective C, lots of methods return a <code>self</code> which is usually but not always the same object that received the method call. That "not always" is how ObjC handles things like class clusters. In Python, there are better ways to do the same thing (even changing your class at runtime is usually better), but in ObjC, it's perfectly normal and idiomatic. (It's only used for <code>init</code> methods in Apple's current Framework, but it's a convention of their standard library that mutator methods added by <code>NSMutableFoo</code> always return <code>void</code>, just like the convention that mutator methods like <code>list.sort</code> always return <code>None</code> in Python, not part of the language.) So, if you wanted to wrap up the ObjC runtime in Python, how would you handle that?</p>
<p>You could put an extra proxy layer in front of everything, so your wrapper object can change up what ObjC object it's wrapping. But that means a whole lot of complicated delegation code (especially if you want to make ObjC reflection work back up through the wrapper into Python) and memory-management code, and a performance hit.</p>
<p>Instead, you could just have a generic thin wrapper. If you get back a different ObjC object than you started with, you return the wrapper around that thing instead of the wrapper around the one you started with. Trivial code, memory management is automatic, no performance cost. As long as the users of your wrapper always do <code>a += b</code> instead of <code>a.__iadd__(b)</code>, they will see no difference.</p>
<p>I realize that "writing a PyObjC-style wrapper around a different ObjC framework library than Apple's Foundation` is not exactly an every-day use case… but you already knew that this is a feature you don't use every day, so what else would you expect?</p>
<p>A lazy network object proxy might do something similar—start with a tiny moniker object, swap that out for a full proxy object the first time you try to do something to it. You can probably think of other such examples. You will probably never write any of them… but if you had to, you could.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer your second question, you return something other than self when you are dealing with immutable objects.</p>
<p>Take this example:</p>
<pre><code>&gt;&gt;&gt; foo = tuple([1, 2, 3])
&gt;&gt;&gt; foo
(1, 2, 3)
</code></pre>
<p>Now I try to mutate the object in place:</p>
<pre><code>&gt;&gt;&gt; foo += (4,)
&gt;&gt;&gt; foo
(1, 2, 3, 4)
</code></pre>
<p>Can't believe that worked!...now we try to call its <code>__iadd__</code> method:</p>
<pre><code>&gt;&gt;&gt; foo.__iadd__((5,))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'tuple' object has no attribute '__iadd__'
</code></pre>
<p>It doesn't have one! Strange...now you must wonder to yourself, what happened when we did <code>foo += (4,)</code>?</p>
<p>Well essentially what happened is that when such in-place modification is attempted on immutable objects, python uses the objects <code>__add__</code> method to carry out the operation, i.e. a new object is created. So what actually happened was that when we did this:</p>
<pre><code>&gt;&gt;&gt; foo += (4,)
</code></pre>
<p>This happened:</p>
<pre><code>&gt;&gt;&gt; foo = foo + (4,)
</code></pre>
<p><a href="https://stackoverflow.com/a/11836636/2089675">See this</a></p>
<p>So when you attempt to use <code>+=</code> or any other inplace modification on an immutable object, python will use the non-mutating equivalent of that operator and you will get back a new object. Another example:</p>
<pre><code>&gt;&gt;&gt; foo += (5,) + (6,)
&gt;&gt;&gt; foo
(1, 2, 3, 4, 5, 6)
</code></pre>
<p>The above translates to:</p>
<pre><code>foo = foo + (5,) + (6,)
</code></pre>
<p>Hope that answers your question</p>
</div>
<span class="comment-copy"><code>l = [1, 2, 3]; l = l.__iadd__([3, 2, 1]) + [1]; &gt;&gt;&gt; l [1, 2, 3, 3, 2, 1, 1]</code></span>
<span class="comment-copy">@Smac89 Nice - that's an eccentric but just about legit justification for <code>__iadd__</code> having a return value, so I guess I can check the first of my questions off. I'm still stumped by the second question, though - under what circumstances would it ever be useful or correct to return something other than <code>self</code> from the <code>__iadd__</code> method, as the docs indicate is permissible?</span>
<span class="comment-copy">The assignment is necessary for cases like <code>x[[0, 1]] += 2</code>, where <code>x</code> is a NumPy array and the assignment adds 2 to a list of selected indices. I can't think of any case where you'd return anything but <code>self</code>, though.</span>
<span class="comment-copy">@Smac89: Actually, I'm not sure that's a good justification. You could just as easily argue that <code>l = l.sort() + [1]</code> should work, and it (intentionally) doesn't.</span>
<span class="comment-copy">I would like to point out that <code>+=</code> does not have a value. For example, <code>foo = (bar += 1)</code> is a <b>syntax error</b> no matter what type  <code>bar</code> is.  So unless you expect your clients to call <code>__iadd__</code> directly (and who in their right mind would do that?!) it <b>does not matter</b> what you return from it.</span>
<span class="comment-copy">@abarnert: <code>x[index_list] += 2</code>, where <code>x</code> is a NumPy array.</span>
<span class="comment-copy">@abarnert: Actually, that's pretty much what it does. It's a temporary array, not a list, but it really does make a big temporary array of values, add 2 to them, and assign them back. This sometimes bites people when they expect <code>x[[0, 0]] += 2</code> to add 4 to <code>x[0]</code>.</span>
<span class="comment-copy">@MarkAmery: (2) A copy-on-write object, where you make millions of copies (possibly in a tree rather than a flat line), would be one example of where you might want to make a copy and return something else if there were other references, but mutate in-place (saving a lot of copying time) if there weren't.</span>
<span class="comment-copy">@MarkAmery: (3) ObjC <i>does</i> have limited operator overloading nowadays, but that's not relevant; any decent Python wrapper is probably going to want to expose ObjC features as operators, so you can write <code>a[3]</code> instead of <code>a.objectAtIndex_(3)</code> whenever possible.</span>
<span class="comment-copy">@MarkAmery: (4) There's nothing in the ObjC language that makes that only for <code>-init</code> methods; it's a convention in Foundation—just like the convention in Python's stdlib—that methods added by <code>NSMutableFoo</code> return <code>void</code>. Look at earlier mutable-string classes that returned <code>self</code> from <code>appendString:</code> so they could change classes if needed; at some point NeXT decided the benefit of doing that was not as nice as the benefit of following the convention everywhere.</span>
<span class="comment-copy">No, when you deal with immutable objects you don't implement <code>__iadd__</code> at all.  Just implement <code>__add__</code> which will be used to override += instead</span>
<span class="comment-copy">Thanks for the attempt - and your earlier comment on the question was genuinely helpful - but -1 to this answer for the reason given by wim. There's a clear error in justifying having <code>__iadd__</code> return something other than <code>self</code> by appealing to the case of types that don't even implement <code>__iadd__</code>.</span>
<span class="comment-copy">After your edit, this answer is no longer wrong, but is no longer relevant either - it's mostly about the <code>+=</code> operator now rather than the <code>__iadd__</code> method. I'm asking about the method, not the operator. You haven't provided an example of a case where it makes sense to <i>actually implement</i> <code>__iadd__</code> but have it return something other than <code>self</code>.</span>
<span class="comment-copy">@Smac89 Well yeah - the case in which <code>__iadd__</code> is not implemented and <code>+=</code> falls back on <code>__add__</code>, as described in the docs you quoted. My question is when you would want to write a custom <code>__iadd__</code> method that returned something other than <code>self</code>, not when <code>+=</code> might assign something other than <code>self</code>.</span>
<span class="comment-copy">@Falmarri: How would this answer help there? Sure, it's useful to know that you can block <code>__iadd__</code> by just overriding it with a method that returns <code>NotImplemented</code>, or (in 2.x only, I think) by interposing an extra class to sabotage base class attribute lookup, but this answer wouldn't help you find that out, would it?</span>
