<div class="post-text" itemprop="text">
<p>I am attempting to write this code which can act as an index of sorts to sift through text files and return the occurrences of strings and which line they were on.  I'm getting closer, but I've run into an issue with my iteration and I can't figure out what to do.</p>
<pre><code>def index(fileName, wordList):

    infile = open(fileName,'r')

    i = 0
    lineNumber = 0
    while True:
        for line in infile:
            lineNumber += 1
            if wordList[i] in line.split():
                print(wordList[i], lineNumber)
        i += 1
        lineNumber = 0

fileName = 'index.txt'
wordList = eval(input("Enter a list of words to search for: \n"))

index(fileName,wordList)
</code></pre>
<p>I filled my .txt file with generic terms so it looks like this:</p>
<pre><code>bird 
bird 
dog 
cat 
bird
</code></pre>
<p>When I feed a list of strings such as:</p>
<pre><code>['bird','cat']
</code></pre>
<p>I get the following output:</p>
<pre><code>Enter a list of words to search for: 
['bird','cat']
bird 1
bird 2
bird 5
</code></pre>
<p>So it is giving me the term and line number for the first string in the list, but it isn't continuing on to the next string.  Any advice?  If I could possibly optimize the output to contain the line numbers to a single print that would appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Once file is read, the current file position is changed. Once the file position reached the end of the file, reading file yield empty string.</p>
<p>You need to rewind the file positition using <code>file.seek</code> to re-read the file.</p>
<p>But, instead of rewinding, I would rather do as follow (using <a href="http://docs.python.org/3/library/functions.html#func-set" rel="nofollow"><code>set</code></a> and <code>in</code> operator):</p>
<pre><code>def index(filename, words):
    with open(filename) as f:
        for line_number, line in enumerate(f, 1):
            word = line.strip()
            if word in words:
                print(word, line_number)

fileName = 'index.txt'
wordList = ['bird', 'cat'] # input().split()
words = set(wordList)
index(fileName, words)
</code></pre>
<ul>
<li><code>eval</code> executes arbitrary expression. Instead of using <code>eval</code>, how about using <code>input().split()</code> ?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Since when you reach the end of the file any attempt to read the file will yield an empty string, your program fails. One way to get over this is to use <code>file.readlines</code> and store the lines in a list:</p>
<pre><code>with open('test.txt') as f:
    wordInput = [input(), input()] #capture the input
    lines = f.readlines()
    for word in wordInput:
        counter = 0
        for line in lines:
            counter += 1
            if word in line:
                print(word, counter)
</code></pre>
<p>However, this is a bit inefficient for large files since it'll load the whole file into the buffer in memory. As an alternative, you can loop through the lines, and then call <code>file.seek(0)</code> when you're done. That way the seek is back to the beginning of the file, and you can reloop it again. It works this way:</p>
<pre><code>&gt;&gt;&gt; with open('test.txt') as f:
        for line in f:
            print(line)
        f.seek(0)
        for line in f:
            print(line)


bird 

bird 

dog 

cat 

bird
0 #returns the current seek position
bird 

bird 

dog 

cat 

bird
</code></pre>
<p>Also, as @falsetru mentioned in his answer, avoid using <code>eval(input)</code> since it evaluates any expression you put in there, and this cand lead to unexpected input problems. Use a <code>something</code> separated values, and then do <code>wordList = input().split(something)</code>.</p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you try to loop over a file object repeatedly, any attempt after the first will start at the end of the file and immediately halt. There are several ways you could handle this; you could change your algorithm to work in a single pass over the file, or you could save the file's contents to some other data structure and then analyze that instead of the file, or you could use <code>infile.seek(0)</code> to return to the start of the file between loops.</p>
</div>
<span class="comment-copy">Interesting, thank you for your response I am reading about the enumerate() right now, still learning.  Any input on the output optimization? i.e. bird 1,2,5.  It seems like it may be difficult within the iteration? I'm working on it now.</span>
<span class="comment-copy">@user2909869, How about using a dictionary to hold matches? (words as key, matched lines (list) as value)</span>
<span class="comment-copy">Good idea, thanks</span>
<span class="comment-copy">Thanks for the dictionary idea, I made some slight changes to my original to get it up and running, but using the dictionary for output finished the job. Appreciate it.</span>
<span class="comment-copy">Thank you for your response.  I ended up using the seek function that you gave me and it helped me fix my code all together.  Thank you again!</span>
