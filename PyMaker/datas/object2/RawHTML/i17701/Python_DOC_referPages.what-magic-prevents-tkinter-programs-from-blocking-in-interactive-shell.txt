<div class="post-text" itemprop="text">
<p><em>Note: This is somewhat a follow-up on the question: <a href="https://stackoverflow.com/questions/8683217/tkinter-when-do-i-need-to-call-mainloop">Tkinter - when do I need to call mainloop?</a></em></p>
<p>Usually when using <a href="http://docs.python.org/3/library/tkinter.html" rel="nofollow noreferrer">Tkinter</a>, you call <a href="http://www.tcl.tk/man/tcl8.5/TkLib/MainLoop.htm" rel="nofollow noreferrer">Tk.mainloop</a> to run the event loop and ensure that events are properly processed and windows remain interactive without blocking.</p>
<p>When using Tkinter from within an interactive shell, running the main loop does not seem necessary. Take this example:</p>
<pre><code>&gt;&gt;&gt; import tkinter
&gt;&gt;&gt; t = tkinter.Tk()
</code></pre>
<p>A window will appear, and it will not block: You can interact with it, drag it around, and close it.</p>
<p>So, something in the interactive shell does seem to recognize that a window was created and runs the event loop in the background.</p>
<p>Now for the interesting thing. Take the example from above again, but then in the next prompt (without closing the window), enter anything—without actually executing it (i.e. don’t press enter). For example:</p>
<pre><code>&gt;&gt;&gt; t = tkinter.Tk()
&gt;&gt;&gt; print('Not pressing enter now.') # not executing this
</code></pre>
<p>If you now try to interact with the Tk window, you will see that it completely <em>blocks</em>. So the event loop which we thought would be running in the background stopped while we were entering a command to the interactive shell. If we send the entered command, you will see that the event loop <em>continues</em> and whatever we did during the blocking will continue to process.</p>
<p>So the big question is: <strong>What is this magic that happens in the interactive shell?</strong> What runs the main loop when we are not doing it explicitly? And why does it need to halt when we <em>enter</em> commands (instead of halting when we execute them)?</p>
<p><em>Note:</em> The above works like this in the command line interpreter, not IDLE. As for IDLE, I assume that the GUI won’t actually tell the underlying interpreter that something has been entered but just keep the input locally around until it’s being executed.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's actually not being an interactive interpreter that matters here, but waiting for input on a TTY. You can get the same behavior from a script like this:</p>
<pre><code>import tkinter
t = tkinter.Tk()
input()
</code></pre>
<p>(On Windows, you may have to run the script in pythonw.exe instead of python.exe, but otherwise, you don't have to do anything special.)</p>
<hr/>
<p>So, how does it work? Ultimately, the trick comes down to <code>PyOS_InputHook</code>—the same way the <code>readline</code> module works.</p>
<p>If stdin is a TTY, then, each time it tries to fetch a line with <code>input()</code>, various bits of the <code>code</code> module, the built-in REPL, etc., Python calls any installed <code>PyOS_InputHook</code> instead of just reading from stdin.</p>
<p>It's probably easier to understand <a href="http://hg.python.org/cpython/file/045e7a587f3c/Modules/readline.c#l983">what <code>readline</code> does</a>: it tries to <code>select</code> on stdin or similar, looping for each new character of input, or every 0.1 seconds, or every signal.</p>
<p><a href="http://hg.python.org/cpython/file/045e7a587f3c/Modules/_tkinter.c#l3051">What <code>Tkinter</code> does</a> is similar. It's more complicated because it has to deal with Windows, but on *nix it's doing something pretty similar to <code>readline</code>. Except that it's calling <code>Tcl_DoOneEvent</code> each time through the loop.</p>
<p>And that's the key. Calling <code>Tcl_DoOneEvent</code> repeatedly is exactly the same thing that <a href="http://hg.python.org/cpython/file/045e7a587f3c/Modules/_tkinter.c#l2581"><code>mainloop</code></a> does.</p>
<p>(Threads make everything more complicated, of course, but let's assume you haven't created any background threads. In your real code, if you want to create background threads, you'll just have a thread for all the <code>Tkinter</code> stuff that blocks on <code>mainloop</code> anyway, right?)</p>
<hr/>
<p>So, as long as your Python code is spending most of its time blocked on TTY input (as the interactive interpreter usually is), the Tcl interpreter is chugging along and your GUI is responding. If you make the Python interpreter block on something other than TTY input, the Tcl interpreter is not running and the your GUI is not responding.</p>
<hr/>
<p>What if you wanted to do the same thing manually in pure Python code? You'd of need to do that if you want to, e.g., integrate a Tkinter GUI and a <code>select</code>-based network client into a single-threaded app, right?</p>
<p>That's easy: Drive one loop from the other.</p>
<p>You can <code>select</code> with a timeout of 0.02s (the same timeout the default input hook uses), and call <code>t.dooneevent(Tkinter.DONT_WAIT)</code> each time through the loop.</p>
<p>Or, alternatively, you can let Tk drive by calling <code>mainloop</code>, but use <code>after</code> and friends to make sure you call <code>select</code> often enough.</p>
</div>
<span class="comment-copy">This part of the magic is actually really simple—it just weaves the Tcl main loop into the Python main loop. However, the platform-specific stuff that Python does to allow it to wait on stdin and also run a GUI loop (on Windows and classic Mac you have to ask for this manually by running <code>pythonw</code>, on OS X it's what causes an app icon to suddenly appear in your Dock, on most *nix/X11 systems it's more invisible), that's ugly.</span>
<span class="comment-copy">You can see how simple the tkinter—specific thing is: if you just run <code>import tkinter; tk=tkinter.Tk(); input()</code> (as a script, not in the interactive interpreter), Python will start up the combined-GUI-and-stdin loop, which is all it takes to get Tcl running while it's waiting on your <code>input</code>.</span>
<span class="comment-copy">Thanks a lot for that insight and the references to the source!</span>
<span class="comment-copy">More generically, what inside of Tcl_DoOneEvent is letting it select on either stdin or GUI events? I see in Tkinter where it handles Tcl events but it never seems to get back to Python. I installed PyOS_InputHook but since the select statement always waits for 100ms the GUI stutters badly.</span>
<span class="comment-copy">Could use please give more examples on how to solve this kind of problems (expand your answer), or a good more complete reference with examples?</span>
