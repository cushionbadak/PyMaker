<div class="post-text" itemprop="text">
<p>I am trying to extract data out of a byte object. For example:
From <code>b'\x93\x4c\x00'</code> my integer hides from bit 8 to 21.
I tried to do <code>bytes &gt;&gt; 3</code> but that isn't possible with more than one byte.
I also tried to solve this with struct but the byte object must have a specific length.</p>
<p>How can I shift the bits to the right?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>bytes</code> to represent integer values; if you need bits, <a href="http://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow">convert to an <code>int</code></a>:</p>
<pre><code>value = int.from_bytes(your_bytes_value, byteorder='big')
bits_21_to_8 = (value &amp; 0x1fffff) &gt;&gt; 8
</code></pre>
<p>where the <code>0x1fffff</code> mask could also be calculated with:</p>
<pre><code>mask = 2 ** 21 - 1
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; your_bytes_value = b'\x93\x4c\x00'
&gt;&gt;&gt; value = int.from_bytes(your_bytes_value, byteorder='big')
&gt;&gt;&gt; (value &amp; 0x1fffff) &gt;&gt; 8
4940
</code></pre>
<p>You can then move back to bytes with the <a href="http://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow"><code>int.to_bytes()</code> method</a>:</p>
<pre><code>&gt;&gt;&gt; ((value &amp; 0x1fffff) &gt;&gt; 8).to_bytes(2, byteorder='big')
b'\x13L'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you have a bytes string and you want to strip the right-most <em>eight</em> bits (i.e. one byte), you can simply it from the bytes string:</p>
<pre><code>&gt;&gt;&gt; b'\x93\x4c\x00'[:-1]
b'\x93L'
</code></pre>
<p>If you want to convert that then to an integer, you can use Python’s <a href="http://docs.python.org/3/library/struct.html" rel="nofollow">struct</a> to unpack it. As you correctly said, you need a fixed size to use structs, so you can just pad the bytes string to add as many zeros as you need:</p>
<pre><code>&gt;&gt;&gt; data = b'\x93\x4c\x00'
&gt;&gt;&gt; data[:-1]
b'\x93L'
&gt;&gt;&gt; data[:-1].rjust(4, b'\x00')
b'\x00\x00\x93L'
&gt;&gt;&gt; struct.unpack('&gt;L', data[:-1].rjust(4, b'\x00'))[0]
37708
</code></pre>
<p>Of course, you can also convert it first, and then shift off the 8 bits from the resulting integer:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;Q', data.rjust(8, b'\x00'))[0] &gt;&gt; 8
37708
</code></pre>
<p>If you want to make sure that you don’t actually interpret more than those 13 bits (bits 8 to 21), you have to apply the bit mask <code>0x1FFF</code> of course:</p>
<pre><code>&gt;&gt;&gt; 37708 &amp; 0x1FFF
4940
</code></pre>
<p>(If you need big-endianness instead, just use <code>&lt;L</code> or <code>&lt;Q</code> respectively.)</p>
<hr/>
<p>If you are really counting the bits from left to right (which would be unusual but okay), then you can use that padding technique too:</p>
<pre><code>&gt;&gt;&gt; struct.unpack('&gt;Q', data.ljust(8, b'\x00'))[0] &gt;&gt; 43
1206656
</code></pre>
<p>Note that we’re adding the padding to the other side, and are shifting it by 43 bits (your 3 bits plus 5 bytes for the padded data we won’t need to look at)</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach that works for arbitrarily long byte sequences is to use the <a href="http://pythonhosted.org/bitstring/" rel="nofollow">bitstring</a> library which allows for bitwise operations on bitstrings e.g.</p>
<pre><code>&gt;&gt;&gt; import bitstring
&gt;&gt;&gt; bitstring.BitArray(bytes=b'\x93\x4c\x00') &gt;&gt; 3
BitArray('0x126980')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could convert your bytes to an integer then multiply or divide by powers of two to accomplish the shifting</p>
</div>
<span class="comment-copy">In Perl, you'd use <code>my $i = ( unpack('N', substr("\x00\x00".$s, -4)) &gt;&gt; 8) &amp; 0x1FFF;</code>.</span>
<span class="comment-copy">Note that bits are counted from right to left starting at 0; bit 8 is the last bit of the <code>\x4c</code> byte, bit 21 through 16 are the last right-most 5 bits of the first byte. Your shift by 3 implies that you are counting bits from left to right; perhaps you are looking for a different set of bits from the convention?</span>
<span class="comment-copy">For those who find their way here via Google: note that this solution is only appropriate if you are using Python 3.  The <code>int</code> class in Python 2 does not have a <code>from_bytes</code> method.</span>
<span class="comment-copy">@larsks: yes, the question is specifically tagged with the <a href="https://stackoverflow.com/questions/tagged/python-3.x">python-3.x</a> tag. :-)</span>
<span class="comment-copy">to get 8-21 bits, you could drop the first 8 bits and take 13 bits from what left: <a href="https://www.python.org/dev/peps/pep-0515/" rel="nofollow noreferrer"><code>(value &gt;&gt; 8) &amp; 0b1_1111_1111_1111</code></a>. To get <code>n</code> bits from <code>x</code> starting with <code>offset</code>: <code>get_bits = lambda x, n, offset=0: (x &gt;&gt; offset) &amp; ~-(1 &lt;&lt; n)</code></span>
<span class="comment-copy">Note that <code>int.from_bytes()</code> doesn't require padding and can take byte sizes larger than 8 as well.</span>
