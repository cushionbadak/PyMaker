<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2295290/what-do-lambda-function-closures-capture">What do (lambda) function closures capture?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I wanted to play around with anonymous functions so I decided to make a simple prime finder. Here it is:</p>
<pre><code>tests = []
end = int(1e2)
i = 3
while i &lt;= end:
    a = map(lambda f:f(i),tests)
    if True not in a:
        tests.append(lambda x:x%i==0)
        print i
    print tests
    print "Test: "+str(i)
    print str(a)
    i+=2
</code></pre>
<p>What I find however, is that the <code>i</code> in the <code>lambda x:x%i==0</code> is accessed each time, while i want it to be a literal number. how can I get it to become <code>lambda x:x%3==0</code> instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can "capture" the <code>i</code> when creating the lambda</p>
<pre><code>lambda x, i=i: x%i==0
</code></pre>
<p>This will set the <code>i</code> in the lambda's context equal to whatever <code>i</code> was when it was created.  you could also say <code>lambda x, n=i: x%n==0</code> if you wanted, it's not exactly capture, but it gets you what you need.</p>
<p>Without this, as you've seen, it's going to look for an <code>i</code> in the enclosing scope</p>
<hr/>
<p>It's an issue of lookup that's analogous to the following with defined functions:</p>
<pre><code>i = "original"

def print_i1():
    print(i) # prints "changed" when called below

def print_i2(s=i): #default set at function creation, not call
    print(s) # prints "original" when called below


i = "changed"
print_i1()
print_i2()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that each of those functions in <code>tests</code> is referring to the variable <code>i</code>.</p>
<p>More commonly, you do this inside a function, in which case you have a local-to-the-defining-scope variable <code>i</code>, which gets stored in a closure, as nicely explained in <a href="http://code.activestate.com/recipes/502271/" rel="nofollow noreferrer">These Nasty Closures</a>.</p>
<p>But here, it's even simpler: <code>i</code> is a global variable, so there is no closure. The functions are compiled to look up <code>i</code> as a global variable when run. Since <code>i</code> has changed, the functions will see the changed value when they run. Simple as that.</p>
<hr/>
<p>The traditional way around this (which works for both closures and globals) is fondly known as "the default-value hack", even though it's not really a hack. (See <a href="https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects" rel="nofollow noreferrer">the explanation in the FAQ</a>.) Ryan Haining's answer explains how to do this:</p>
<pre><code>lambda x, i=i: x%i==0
</code></pre>
<p>This creates a parameter named <code>i</code>, with a default value equal to the value of <code>i</code> at the time the function is created. Then, inside the function, when you access parameter <code>i</code>, and you get that value.</p>
<hr/>
<p>A different way around this, which may seem more familiar if you're using to languages like JavaScript, is to create a function-creating function, and pass the value of <code>i</code> as an argument to that function-creating function, as in user2864740's answer:</p>
<pre><code>(lambda i: lambda x: x%i)(i)
</code></pre>
<p>This avoids "polluting" the signature of the function with an extra parameter (that someone could accidentally pass an argument to), but at the cost of creating and calling a function for no good reason.</p>
<hr/>
<p>A third way around this is to use <code>partial</code>. In cases where all you're trying to do is partially apply a function, using <code>partial</code> instead of defining a wrapper function as a <code>lambda</code> can be cleaner.</p>
<p>Unfortunately, in this case, the function is hidden inside an operator, and the function <code>operator.mod</code> that exposes it doesn't take keyword arguments, so you can't usefully partial its second operand. So, this is a bad solution in this case. If you really wanted to, you could just write a wrapper that behaves better and <code>partial</code> that:</p>
<pre><code>def opmod(a, b):
    return a % b

partial(operator.mod, b=i)
</code></pre>
<p>In this case, I think you're better off with the other solutions; just keep this one in your head for cases where it <em>is</em> appropriate.</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a new function that returns the lambda. Then call that, passing in <code>i</code> as an argument. This will create a new binding scope.</p>
<pre><code>def make_test (i):
   # this i refers to the parameter (which evaluates to the /value/ passed)
   return lambda x: x%i==0

# ..
# the /value/ resulting from evaluating the variable is passed
tests.append(make_test(i))
</code></pre>
</div>
<span class="comment-copy">Also see <a href="http://code.activestate.com/recipes/502271/" rel="nofollow noreferrer">These Nasty Closures</a> for a better explanation than the one in the official docs. But the short version is that each of these test functions is effectively a closure around the same variable <code>i</code>, and <code>i</code> keeps changing value. (This isn't quite accurate, because global variables don't actually need to be stored in closures, but the effect is the same.)</span>
<span class="comment-copy">Ooh, cleverish.</span>
<span class="comment-copy">+1 Very nice :)</span>
<span class="comment-copy">This works because default arguments are evaluated when the function is <i>created</i>, whereas variable look up is done when the function is <i>called</i>.</span>
<span class="comment-copy">Awesome. 'Capture' saves my day.</span>
<span class="comment-copy">I could not find anything related to that on the link you provided.</span>
<span class="comment-copy">@erm3nda There are at least two links in the answer, and I have no idea what "that" refers to in your comment.</span>
<span class="comment-copy">Sorry. About the default value hack at <a href="http://docs.python.org/3/faq/design.html#why-are-default-values-shared-between-objects" rel="nofollow noreferrer">docs.python.org/3/faq/…</a></span>
<span class="comment-copy">@erm3nda Ah, that seems to be in the Programming chapter of the FAQ, not the Design chapter. I don't know if that changed over the last 4 years, or if you were the first one to actually follow the link in all that time, but either way, thanks for catching it, and I'll edit.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow noreferrer">docs.python.org/3/faq/…</a> thanks.</span>
