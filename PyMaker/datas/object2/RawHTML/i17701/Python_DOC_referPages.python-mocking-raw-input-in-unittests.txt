<div class="post-text" itemprop="text">
<p>Suppose I have this python code:</p>
<pre><code>def answer():
    ans = raw_input('enter yes or no')
    if ans == 'yes':
        print 'you entered yes'
    if ans == 'no':
        print 'you entered no'
</code></pre>
<p>How do I write a unittest for this ? I know i have to use 'Mock' but I don't understand how. Can anyone make some simple example ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't patch input but you can wrap it to use mock.patch(). Here is a solution:</p>
<pre><code>from unittest.mock import patch
from unittest import TestCase


def get_input(text):
    return input(text)


def answer():
    ans = get_input('enter yes or no')
    if ans == 'yes':
        return 'you entered yes'
    if ans == 'no':
        return 'you entered no'


class Test(TestCase):

    # get_input will return 'yes' during this test
    @patch('yourmodule.get_input', return_value='yes')
    def test_answer_yes(self, input):
        self.assertEqual(answer(), 'you entered yes')

    @patch('yourmodule.get_input', return_value='no')
    def test_answer_no(self, input):
        self.assertEqual(answer(), 'you entered no')
</code></pre>
<p>Keep in mind that this snippet will only work in Python versions 3.3+</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, first off, I feel it's necessary to point out that in the original code in question, there are actually two things that need to be tackled:</p>
<ol>
<li><code>raw_input</code> (an input side effect) needs to be mocked.</li>
<li><code>print</code> (an output side effect) needs to be checked.</li>
</ol>
<p>In an ideal function for unit testing, there would be no side effects. A function would simply be tested by handing in arguments and its output would be checked. But often we want to test functions which aren't ideal, IE, in functions like yours.</p>
<p>So what are we to do? Well, in Python 3.3, both of the issues I listed above became trivial because the <code>unittest</code> module gained the ability to mock and check for side effects. But, as of the start of 2014, only 30% of Python programmers had moved on to 3.x, so for the sake of the other 70% of Python programmers still using 2.x, I'll outline an answer. At the current rate, 3.x won't overtake 2.x until ~2019, and 2.x won't vanish until ~2027. So I figure this answer will be useful for several years to come. </p>
<p>I want to address the issues listed above one at a time, so I'm going to initially change your function from using <code>print</code> as its output to using <code>return</code>. No surprises, here's that code:</p>
<pre><code>def answerReturn():
    ans = raw_input('enter yes or no')
    if ans == 'yes':
        return 'you entered yes'
    if ans == 'no':
        return 'you entered no'
</code></pre>
<p>So all we need to do is mock <code>raw_input</code>. Easy enough - <a href="https://stackoverflow.com/a/21047107/901641">Omid Raha's answer to this very question</a> shows us how to do that by swizzling out the <code>__builtins__.raw_input</code> implementation with our mock implementation. Except his answer wasn't properly organized into a <code>TestCase</code> and functions, so I'll demonstrate that.</p>
<pre><code>import unittest    

class TestAnswerReturn(unittest.TestCase):
    def testYes(self):
        original_raw_input = __builtins__.raw_input
        __builtins__.raw_input = lambda _: 'yes'
        self.assertEqual(answerReturn(), 'you entered yes')
        __builtins__.raw_input = original_raw_input

    def testNo(self):
        original_raw_input = __builtins__.raw_input
        __builtins__.raw_input = lambda _: 'no'
        self.assertEqual(answerReturn(), 'you entered no')
        __builtins__.raw_input = original_raw_input
</code></pre>
<p>Small note just on Python naming conventions - variables which are required by the parser  but not used are typically named <code>_</code>, as in the case of the lambda's unused variable (which is normally the prompt shown to the user in the case of the <code>raw_input</code>, incase you're wondering why it's required at all in this case).</p>
<p>Anyways, this is messy and redundant. So I'm going to do away with the repetition by adding in a <code>contextmanager</code>, which will allow for simple <code>with</code> statements.</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def mockRawInput(mock):
    original_raw_input = __builtins__.raw_input
    __builtins__.raw_input = lambda _: mock
    yield
    __builtins__.raw_input = original_raw_input

class TestAnswerReturn(unittest.TestCase):
    def testYes(self):
        with mockRawInput('yes'):
            self.assertEqual(answerReturn(), 'you entered yes')

    def testNo(self):
        with mockRawInput('no'):
            self.assertEqual(answerReturn(), 'you entered no')
</code></pre>
<p>I think that nicely answers the first part of this. On to the second part - checking <code>print</code>. I found this much trickier - I'd love to hear if anyone has a better answer.</p>
<p>Anyways, the <code>print</code> statement can't be overridden, but if you use <code>print()</code> functions instead (as you should) and <code>from __future__ import print_function</code> you can use the following:</p>
<pre><code>class PromiseString(str):
    def set(self, newString):
        self.innerString = newString

    def __eq__(self, other):
        return self.innerString == other

@contextmanager
def getPrint():
    promise = PromiseString()
    original_print = __builtin__.print
    __builtin__.print = lambda message: promise.set(message)
    yield promise
    __builtin__.print = original_print

class TestAnswer(unittest.TestCase):
    def testYes(self):
        with mockRawInput('yes'), getPrint() as response:
            answer()
            self.assertEqual(response, 'you entered yes')

    def testNo(self):
        with mockRawInput('no'), getPrint() as response:
            answer()
            self.assertEqual(response, 'you entered no')
</code></pre>
<p>The tricky bit here is that you need to <code>yield</code> a response before the <code>with</code> block is entered. But you can't know what that response will be until the <code>print()</code> inside the <code>with</code> block is called. This would be fine if strings were mutable, but they aren't. So instead a small promise or proxy class was made - <code>PromiseString</code>. It only does two things - allow a string (or anything, really) to be set and let us know if it's equal to a different string. A <code>PromiseString</code> is <code>yield</code>ed and then set to the value that would normally be <code>print</code> within the <code>with</code> block.</p>
<p>Hopefully you appreciate all this trickery I've written up since it took me around 90 minutes to put together this evening. I tested all of this code and verified it all worked with Python 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just ran across the same problem, but I just mocked out <code>__builtin__.raw_input</code>.</p>
<p>Only tested on Python 2. <code>pip install mock</code> if you don't already have the package installed.</p>
<pre><code>from mock import patch
from unittest import TestCase

class TestAnswer(TestCase):
    def test_yes(self):
        with patch('__builtin__.raw_input', return_value='yes') as _raw_input:
            self.assertEqual(answer(), 'you entered yes')
            _raw_input.assert_called_once_with('enter yes or no')

    def test_no(self):
        with patch('__builtin__.raw_input', return_value='no') as _raw_input:
            self.assertEqual(answer(), 'you entered no')
            _raw_input.assert_called_once_with('enter yes or no')
</code></pre>
<p>Alternatively, using the library <a href="https://github.com/box/genty" rel="noreferrer">genty</a>, you can simplify the two tests:</p>
<pre><code>from genty import genty, genty_dataset
from mock import patch
from unittest import TestCase

@genty
class TestAnswer(TestCase):
    @genty_dataset(
        ('yes', 'you entered yes'),
        ('no', 'you entered no'),
    )
    def test_answer(self, expected_input, expected_answer):
        with patch('__builtin__.raw_input', return_value=expected_input) as _raw_input:
            self.assertEqual(answer(), expected_answer)
            _raw_input.assert_called_once_with('enter yes or no')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am using Python 3.4 and had to adapt answers above. My solution factors out common code into the custom <code>runTest</code> method and shows you how to patch both <code>input()</code> and <code>print()</code>. Here's code that runs:
    import unittest
    from io import StringIO
    from unittest.mock import patch</p>
<pre><code>def answer():
    ans = input('enter yes or no')
    if ans == 'yes':
        print('you entered yes')
    if ans == 'no':
        print('you entered no')


class MyTestCase(unittest.TestCase):
    def runTest(self, given_answer, expected_out):
        with patch('builtins.input', return_value=given_answer), patch('sys.stdout', new=StringIO()) as fake_out:
            answer()
            self.assertEqual(fake_out.getvalue().strip(), expected_out)

    def testNo(self):
        self.runTest('no', 'you entered no')

    def testYes(self):
        self.runTest('yes', 'you entered yes')

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def answer():
    ans = raw_input('enter yes or no')
    if ans == 'yes':
        return 'you entered yes'
    if ans == 'no':
        return 'you entered no'


def test_answer_yes():
    assert(answer() == 'you entered yes')

def test_answer_no():
    assert(answer() == 'you entered no')

origin_raw_input = __builtins__.raw_input

__builtins__.raw_input = lambda x: "yes"
test_answer_yes()

__builtins__.raw_input = lambda x: "no"
test_answer_no()

__builtins__.raw_input = origin_raw_input
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2617057/supply-inputs-to-python-unittests">supply inputs to python unittests</a></span>
<span class="comment-copy">I can't find the answer there</span>
<span class="comment-copy">One of the three answers is <i>literally</i> about using <code>mock</code> to test <code>raw_input</code></span>
<span class="comment-copy">@ArtOfWarfare mock is new in python3.3 <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a> There is a backport <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">pypi.python.org/pypi/mock</a></span>
<span class="comment-copy">You should specify python version in your answer. Thanks @gawel</span>
<span class="comment-copy">You don't need to wrap input. <code>@patch('builtins.input', return_value='yes')</code> should do the trick.</span>
<span class="comment-copy"><code>@patch('builtins.input', return_value='yes')</code> is not a good idea considering it causes <code>pdb.set_trace()</code> to crash.</span>
<span class="comment-copy">why do you need to add input as a second argument in <code>def test_answer_yes(self, input):</code> ?</span>
<span class="comment-copy">I adapted your answer for my setup with <code>nose2</code> (not using <code>unittest</code> directly), and this worked well for me.  One thing to note is that if you change <code>fakeout.getvalue()</code> to <code>fakeout.getvalue().strip()</code> you can avoid passing the extra newline.</span>
