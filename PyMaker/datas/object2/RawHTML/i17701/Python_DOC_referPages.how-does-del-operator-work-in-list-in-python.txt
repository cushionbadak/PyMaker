<div class="post-text" itemprop="text">
<p>I have read the <code>python docs</code> for <code>list</code> and how the <code>del</code> operators works, but I need explanation for the following behavior</p>
<p>In this case, <code>c</code> and <code>l</code> points to the same object(list), so doing changes on one affects the other, but deleting one does not delete the object. So what happens here? Is it just the <code>pointer</code> to the list object is lost?</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3]
&gt;&gt;&gt; c = l
&gt;&gt;&gt; c.append(4)
&gt;&gt;&gt; c
[1, 2, 3, 4]
&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; del c
&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; c
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'c' is not defined
</code></pre>
<h3>Deletion by slice operation</h3>
<pre><code>&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; del l[::2]
&gt;&gt;&gt; l
[2, 4]
</code></pre>
<p><code>l[::2]</code> returns the new list. but <code>del l[::2]</code> does in-place deletion. So in this case, is not a new list being returned? What exactly is happening here?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>l</code> and <code>c</code> are <em>bound</em> to the same object. They both are references to a list, and manipulating that list object is visible through both references. <code>del c</code> <em>unbinds</em> <code>c</code>; it removes the reference to the list.</p>
<p><code>del l[::2]</code> removes a specific set of indices <em>from the list</em>, you are now operating on the list object <em>itself</em>. You are not unbinding <code>l</code>, you are unbinding indices <strong>inside</strong> of the list.</p>
<p>You can compare this with retrieving and setting values as well. <code>print c</code> is different from <code>print c[::2]</code> and <code>c = something</code> is different from <code>c[::2] = something</code>; the first of both examples accesses just the list object, or assign a new value to <code>c</code>, the latter examples retrieve a slice of values or set new values to the sliced indices.</p>
<p>Under the hood, <code>del c</code> removes the name <code>c</code> from the dictionary handling all variables (<code>globals()</code> gives you a reference to this dictionary). <code>del l[::2]</code> calls the <a href="http://docs.python.org/3/reference/datamodel.html#object.__delitem__"><code>__delitem__</code> special method</a> on the list, passing in a <code>slice()</code> object.</p>
</div>
<span class="comment-copy">I understand <code>print c</code> is different from <code>print c[::2]</code> because in the latter case, a new list object is returned. Now your explanation for <code>__delitem__</code>, passing the slice object makes perfect sense. but wondering, the corresponding indices have to de-reference those items, before shifting elements to the left..correct?</span>
<span class="comment-copy">That is correct; those indices are references that are being removed from the list.</span>
<span class="comment-copy"><code>print c[::2]</code> is translated as <code>c.__getitem__(slice(None, None, 2))</code>, which can return whatever it likes.  A <code>list</code> returns a new list with values, yes.</span>
