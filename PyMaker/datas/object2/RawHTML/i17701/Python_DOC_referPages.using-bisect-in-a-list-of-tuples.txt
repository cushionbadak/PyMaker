<div class="post-text" itemprop="text">
<p>I'm trying to figure out how to use bisect in a list of tuples
for example</p>
<pre><code>[(3, 1), (2, 2), (5, 6)]
</code></pre>
<p>How can I bisect this list according to the [1] in each tuple?</p>
<pre><code>list_dict [(69, 8), (70, 8), ((65, 67), 6)]
tup1,tup2 (69, 8) (70, 8)
list_dict [((65, 67), 6)]
fst, snd ((65, 67),) (6,)
</code></pre>
<p>And I'm inserting to bisect </p>
<pre><code>idx = bisect.bisect(fst, tup1[1]+tup2[1])
</code></pre>
<p>Which gives me <code>unorderable types: int() &lt; tuple()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can separate out the values into separate lists.</p>
<pre><code>from bisect import bisect

data = [(3, 1), (2, 2), (5, 6)]
fst, snd = zip(*data)
idx = bisect(fst, 2)
</code></pre>
<p>Note however, that for <code>bisect</code> to work, your data really should be ordered...</p>
</div>
<div class="post-text" itemprop="text">
<p>In some cases just the simple</p>
<pre><code>bisect(list_of_tuples, (3, None))
</code></pre>
<p>will be enough.</p>
<p>Because <code>None</code> will compare less than any integer, this will give you the index of the first tuple starting with at least 3, or <code>len(list_of_tuples)</code> if all of them are smaller than 3. Note that <code>list_of_tuples</code> is sorted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check the bottom section of the documentation: <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow">http://docs.python.org/3/library/bisect.html</a>. If you want to compare to something else than the element itself, you should create a separate list of so-called keys. In your case a list of ints containing only [1] of the tuple. Use that second list to compute the index with bisect. Then use that to both insert the element into the original (list of tuples) and the key ([1] of the tuple) into the new list of keys (list of ints).</p>
</div>
<span class="comment-copy">This specific method doesn't wrok for me since I'm updating the tuples everytime, I'll explain in the edit</span>
<span class="comment-copy">@user3157919 you need to make sure what you're bisecting on, and what you're working with are separate (and the bisection be of comparable types) and put them back together later if needs be...</span>
<span class="comment-copy">that doesn't work in Python 3. If you pass the exact number 3, you'll get <code>TypeError: unorderable types: int() &lt; NoneType()</code>. BUT <code>bisect(list_of_tuples, (3, ))</code> would be all right.</span>
