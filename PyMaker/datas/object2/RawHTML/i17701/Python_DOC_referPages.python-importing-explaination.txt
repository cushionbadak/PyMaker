<div class="post-text" itemprop="text">
<p>Similar Question: <a href="https://stackoverflow.com/questions/5226893/understanding-a-chain-of-imports-in-python?rq=1">Understanding A Chain of Imports in Python</a></p>
<p>NB: I'm using Python 3.3
I have setup the following two files in the same directory to explain importing to myself, however I still don't get exactly what it's doing. I understand function and class definitions are statements that need to run.</p>
<p>untitled.py:</p>
<pre><code>import string

class testing:
    def func(self):
        try:
            print(string.ascii_lowercase)
        except:
            print('not imported')
class second:
    x=1
print('print statement in untitled executed')
</code></pre>
<p>stuff.py:</p>
<pre><code>from untitled import testing

try:
    t=testing()
    t.func()
except NameError:
    print('testing not imported')

try:
    print(string.ascii_uppercase)
except NameError:
    print('string not imported')

try:
    print(untitled.string.ascii_uppercase)
except NameError:
    print('string not imported in untitled')

try:
    s=second()
    print(s.x)
except NameError:
    print('second not imported')
</code></pre>
<p>This is the output I get from running stuff.py:</p>
<pre><code>print statement in untitled executed
abcdefghijklmnopqrstuvwxyz
string not imported
string not imported in untitled
second not imported
</code></pre>
<p>The print statement in untitled.py is executed despite the import in stuff.py specifying only the testing class. Moreover what is the string module's relation inside stuff.py, as it can be called from within the testing class yet not from the outside.</p>
<p>Could somebody please explain this behaviour to me, what exactly does a "from import" statment do (what does it run)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/reference/simple_stmts.html#from" rel="nofollow"><code>from</code></a> statement isn't any different to <code>import</code> with regard to loading behaviour. Always the top level code is executed, when loading the module. <code>from</code> just controls which parts of the loaded module are being added to the current scope (the first point is most important):</p>
<blockquote>
<p>The from form uses a slightly more complex process:</p>
<ul>
<li>find the module specified in the from clause loading and initializing it if necessary;</li>
<li>for each of the identifiers specified in the import clauses:
  <ul>
<li>check if the imported module has an attribute by that name</li>
<li>if not, attempt to import a submodule with that name and then check the imported module again for that attribute</li>
<li>if the attribute is not found, ImportError is raised.</li>
<li>otherwise, a reference to that value is bound in the local namespace, using the name in the as clause if it is present, otherwise using the attribute name</li>
</ul></li>
</ul>
</blockquote>
<p>Thus you can access the contents of a module partially imported with <code>from</code> with this inelegant trick:</p>
<pre><code>print(sys.modules['untitled'].string.ascii_uppercase)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can think of python modules as namespaces. Keep in mind that imports are not includes:</p>
<ul>
<li>modules are only imported once</li>
<li>the first time, the top level code is executed</li>
<li>any imports, variable, function or class declarations affects only the module local namespace</li>
</ul>
<p>Suppose you have a module called <code>foo.py</code>:</p>
<pre><code>import eggs

bar = "Lets drink, it's a bar'
</code></pre>
<p>So when you do a <code>from foo import bar</code> in another module, you will make <code>bar</code> available in the current namespace. The module <code>eggs</code> will be available under <code>foo.eggs</code> if you do an <code>import foo</code>. If you do a <code>from foo import *</code>, then <code>eggs</code>, <code>bar</code> and everything else in the module namespace will be also in the current namespace - but never do that, wildcard imports are frowned upon in Python.</p>
<p>If you do a <code>import foo</code> and then <code>import eggs</code>, the top level code at <code>eggs</code> will be executed once and the module namespace will be stored in the module cache: if another module  imports it the information will be pulled from this cache. If you are going to use it, then import it - no need to worry about multiple imports executing the top level code multiple times.</p>
<p>Python programmers are very fond of namespaces; I always try to use <code>import foo</code> and then <code>foo.bar</code> instead of <code>from foo import bar</code> if possible - it keeps the namespace clean and prevent name clashes.</p>
<p>That said, the import mechanism is hackable, you can make python <code>import</code> statement work even with files that are not python.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your first file (untitled.py), when python compiler parses(since you called it in import) this file It will create 2 class code objects and execute the print statement. Note that it will even print it if you run untitled.py from command line. </p>
<p>In your second file(stuff.py), to add to @Paulo comments, you have only imported testing class in your namspace, so only that will be available, from the 2 code objects from untitled.py
However if you just say </p>
<pre><code>import untitled
</code></pre>
<p>your 3rd "try" statement will work, since it will have untitled in its namespace.</p>
<p>Next thing. try importing untitled.testing :)</p>
</div>
<span class="comment-copy">From what you're saying I understand  that  from foo import bar is equivalent to  import foo; bar=foo.bar'?  If this is the case why doesn't 'print(untitled.string.ascii_uppercase)' work inside stuff.py ?(or untitled.second)</span>
<span class="comment-copy">@Michal It's not equivalent. It's equivalent in terms of "loading a module" i.e., executing the top level code. What's different is said above explicitly, i.e. that only specified names are added to local scope.</span>
<span class="comment-copy">Would there be a way to access the string module from stuff without changing any imports?</span>
<span class="comment-copy">Yes, this seems to work: <code>sys.modules['untitled'].string</code>.</span>
<span class="comment-copy">Meaning all of module foo is run, but only bar is added to the namespace of the current file?</span>
<span class="comment-copy">Yes, only <code>bar</code> is added to the namespace; note that the top level code at <code>foo</code> only runs once, so if it was previously imported by another module it will not run again, instead <code>bar</code> will be fetched from the module cache.</span>
