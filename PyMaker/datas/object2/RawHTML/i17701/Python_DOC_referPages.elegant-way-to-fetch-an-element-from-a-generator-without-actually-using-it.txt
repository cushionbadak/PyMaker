<div class="post-text" itemprop="text">
<p>I'm using a lot of generator in Python, often I need to get one and only one object from my generator but I don't want this to skip this object, just to be able to look at it (to view its keys if it's a dictionary for example).</p>
<pre><code>import random
def get_generator():
    for i in range(0, 10):
        d = {'id': i, value: random.random()}
        yield d

g = get_generator()
fields = g.the_function_im_looking_for().keys()
print "this generator will offer " + str(len(fields)) + " fields in each item. "\
      "I know this information but I still can iterate over it"

for v in g:
    print g
</code></pre>
<p>Please do not explain workarounds in your answer (like testing for first element within the loop), I'm looking for a "clean" way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible to get an element from a generator without advancing the generator.  That's how generators work.  You can use tricks to store the element to use it again later (which you seem to already know about).  You could also write a class providing that behavior that wraps a generator with a <code>peek</code> method.  But you have to do all that external to the generator mechanism.  There isn't any way to make the generator itself not go forward when you get an element.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe this can be done using itertools.tee():
<a href="http://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow">http://docs.python.org/3/library/itertools.html#itertools.tee</a></p>
<p>However the storage requirements may become large.</p>
<p>itertools.tee() allows you to create two iterators from one.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a wrapper generator that allows you to 'peek' at the next value:</p>
<pre><code>_sentinel = object()

class PeekingGenerator(object):
    def __init__(self, it):
        self.it = it
        self.peeked = _sentinel

    def __iter__(self):
        return self

    def next(self):
        if self.peeked is not _sentinel:
            nextval, self.peeked = self.peeked, _sentinel
        else:
            nextval = next(self.it)
        return nextval

    def peek(self):
        if self.peeked is _sentinel:
            self.peeked = next(self.it)
        return self.peeked
</code></pre>
<p>This allows you to use the <code>.peek()</code> method to look at the next value; note calling <code>.peek()</code> can raise <code>StopIteration</code> if there is no next value to look at.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no <em>clean</em> way to do this, <em>in general</em>. This contradicts the whole concept of generators. </p>
<p>The optimistic case is when you have some specific knowledge about generated items, and can you tell how many possible items are there, without explicitly enumerating them (for example, number of even numbers in range 0-100). In such case you can easily implement a special case class-generator with additional property.</p>
<p>But in general case (i.e. you don't know anything specific about generated items) if you want to know how many items are there up front, then you must really generate them all. So in fact you don't want a generator.</p>
<p>Note that some generators can be infinite - in such case the notion "number of generated elements" doesn't really make any sense at all.</p>
</div>
<span class="comment-copy">How do you know that you generator will only generate a finite amount of elements? There is no such flag in python for generators so it's not possible.</span>
<span class="comment-copy">So does <code>yield random</code> yield the <code>random</code> module or is this a typo?</span>
<span class="comment-copy">There was a typo</span>
<span class="comment-copy">+1 I've seen tee, but it creates a complete iterator from a single one... which is a bit of an overkill.</span>
<span class="comment-copy">"Overkill" in what sense, @AsTeR? Iterators are relatively light-weight things (compared to large collections), that's part of their beauty.</span>
<span class="comment-copy">Thanks for this example nicely completing @BrenBam's answer</span>
<span class="comment-copy">I was thinking about it, but was too lazy to write it down :) Nice work!</span>
