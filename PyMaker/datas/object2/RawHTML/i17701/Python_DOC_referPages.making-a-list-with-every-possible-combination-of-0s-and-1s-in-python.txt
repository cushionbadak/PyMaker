<div class="post-text" itemprop="text">
<p>I am trying to iterate over every possible combination of 0's and 1's in a list. For example, if I was working with 3 parameters, I would get:</p>
<pre><code>[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1]
</code></pre>
<p>I thought the solution on <a href="https://stackoverflow.com/questions/3549634/array-combinations-of-0s-and-1s">Array combinations of 0s and 1s</a> was inadequate due to the problems with storing binary numbers of the length I need. I would like to be able to iterate over lists like this for lengths of 20 or more, where the sheer size becomes hard to deal with in integers. I have been using code like this:</p>
<pre><code>for a in [0, 1]:
   for b in [0, 1]:
       for c in [0, 1]:
          print([a, b, c])
</code></pre>
<p>Is there something more Pythonic or quick? A 20-deep nested loop, even a simple one like this, is still a monster. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>import itertools

for numbers in itertools.product([0, 1], repeat=3):
    print(numbers)
</code></pre>
<p>output:</p>
<pre><code>(0, 0, 0)
(0, 0, 1)
(0, 1, 0)
(0, 1, 1)
(1, 0, 0)
(1, 0, 1)
(1, 1, 0)
(1, 1, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option, you can just count up in binary:</p>
<pre><code>['{:03b}'.format(x) for x in range(8)]
Out[10]: ['000', '001', '010', '011', '100', '101', '110', '111']
</code></pre>
<p>And if you truly needed them to be lists: </p>
<pre><code>[list('{:03b}'.format(x)) for x in range(8)]
Out[12]: 
[['0', '0', '0'],
 ['0', '0', '1'],
 ['0', '1', '0'],
 ['0', '1', '1'],
 ['1', '0', '0'],
 ['1', '0', '1'],
 ['1', '1', '0'],
 ['1', '1', '1']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are looking for the <a href="http://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow noreferrer">cartesian product</a>.</p>
<p>For the cartesian product of a few, you can use this type of list comprehension:</p>
<pre><code>&gt;&gt;&gt; [(a,b,c) for a in (0,1) for b in (0,1) for c in (0,1)]
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
</code></pre>
<p>For more than a few (say more than 4) you should use <a href="https://stackoverflow.com/a/20962871/298607">falsetru's</a> method. </p>
</div>
<span class="comment-copy">"due to the problems with storing binary numbers of the length I need". What? Python can easily store integers far larger than the largest value it can count to in time equal to the age of the universe. Just start at <code>0</code> and keep going. The only problem with that approach in Python is that converting those integers to lists of digits is liable to be slower than using <code>itertools.product</code> instead.</span>
<span class="comment-copy">"20 or more" - even languages like C can handle that with integers, no problem, and those languages have fixed-size ints.</span>
