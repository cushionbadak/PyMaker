<div class="post-text" itemprop="text">
<p>It seems that checking <code>isinstance(..., io.IOBase)</code> is the 'correct' way to determine if an object is 'file-like'. </p>
<p>However, when defining my own file-like class, it doesn't seem to work:</p>
<pre class="lang-python prettyprint-override"><code>import io

class file_like():

    def __init__(self):
        pass

    def write(self, line):
        print("Written:", line)

    def close(self):
        pass

    def flush(self):
        pass

print(isinstance(file_like(), io.IOBase))
# Prints 'False'
</code></pre>
<p>How can I make it work?</p>
</div>
<div class="post-text" itemprop="text">
<p>Checking <code>isinstance(something, io.IOBase)</code> only checks if <code>something</code> is an instance of an <code>io.IOBase</code> or a class derived from it — so I don't understand where you got the mistaken idea that it's the "correct" way to determine if an object is "file-like".</p>
<p>A different way to do it is with an <em>Abstract Base Class</em>. Python has a number of <a href="http://docs.python.org/3/library/collections.abc.html?highlight=collections%20abstract%20base%20classes" rel="nofollow noreferrer">built-in ones</a>, but currently doesn't have one for "file-like" that could used with <code>isinstance()</code>. However you can define your own by using the <code>abc</code> module as outlined in <a href="http://www.python.org/dev/peps/pep-3119/#id34" rel="nofollow noreferrer">PEP 3119</a>.</p>
<p><a href="http://pymotw.com/2" rel="nofollow noreferrer">The Python Module of the Week</a> webiste has a <a href="http://pymotw.com/2/abc" rel="nofollow noreferrer">good explanation</a> of using the <code>abc</code> module to do things like as this. And this highly rated <a href="https://stackoverflow.com/a/306222/355230">answer</a> to the question <a href="https://stackoverflow.com/questions/305359/correct-way-to-detect-sequence-parameter">Correct way to detect sequence parameter?</a> shows a similar way of defining your own ABC.</p>
<p>To illustrate applying it to your case, you could define an ABC like this with all its methods abstract — thereby forcing derived classes to define all of them in order to be instantiated:</p>
<pre><code>from abc import ABCMeta, abstractmethod

class ABCFileLike(metaclass=ABCMeta):
    @abstractmethod
    def __init__(self): pass

    @abstractmethod
    def write(self, line): pass

    @abstractmethod
    def close(self): pass

    @abstractmethod
    def flush(self): pass
</code></pre>
<p>You could then derive your own concrete classes from it, making sure to supply implementations of all the abstract methods. (If you don't define them all, then a <code>TypeError</code> will be be raised if any attempts are made to instantiate it.)</p>
<pre><code>class FileLike(ABCFileLike):
    """ Concrete implementation of a file-like class.
        (Meaning all the abstract methods have an implementation.)
    """
    def __init__(self):
        pass

    def write(self, line):
        print("Written:", line)

    def close(self):
        pass

    def flush(self):
        pass

print(isinstance(FileLike(), ABCFileLike))  # -&gt; True
</code></pre>
<p>You can even add existing classes to it by registering them with the new metaclass:</p>
<pre><code>import io

print(isinstance(io.IOBase(), ABCFileLike))  # -&gt; False

ABCFileLike.register(io.IOBase)
print(isinstance(io.IOBase(), ABCFileLike))  # -&gt; True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>isinstance(obj, some_class)</code> just iterates up obj's inheritance chain, looking for <code>some_class</code>. Thus <code>isinstance(file_like, io.IOBase)</code>, will be false, as your <code>file_like</code> class doesn't have <code>io.IOBase</code> in its ancestry. <code>file_like</code> doesn't designate an explicit parent, hence it implicitly inherits only from <code>object</code>. That's the only class - besides <code>file_like</code> itself - that will test positive for a <code>file_like</code> instance with <code>isinstance()</code>.</p>
<p>What you are doing in <code>file_like</code> is defining the methods expected on a file-like object while not inheriting from any particular "file-like" class. This approach is called <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">duck-typing</a>, and it has many merits in dynamic languages, although it's more popular in others (e.g. Ruby) than Python. Still, if whatever you're providing your <code>file_like</code> instance to follows duck-typing, it should work, provided your <code>file_like</code> does in fact "quack like a file", i.e. behaves sufficiently like a file to not cause errors upon usage at the receiving end.</p>
<p>Of course, if the receiving end is not following duck-typing, for example tries to check types by <code>isinstance()</code> as you do here, this approach will fail.</p>
<p>Finally, a small stylistic nit: don't put empty parens on a class if it doesn't inherit anything explicitly. They are redundant.</p>
</div>
<span class="comment-copy">Thanks for your answer. It cleared up many of my questions. Thanks also for the style note, I believe it's a carryover from functions which requires parens. I'll take note of it</span>
