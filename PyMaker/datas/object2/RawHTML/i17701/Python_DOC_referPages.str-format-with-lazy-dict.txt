<div class="post-text" itemprop="text">
<p>I want to use <code>str.format()</code> and pass it a custom lazy dictionary.</p>
<p><code>str.format()</code> should only access the key in the lazy dict it needs.</p>
<p>Is this possible?</p>
<p>Which interface needs to be implemented by the lazy_dict?</p>
<p><strong>Update</strong></p>
<p>This is not what I want:</p>
<pre><code>'{0[a]}'.format(d)
</code></pre>
<p>I need something like this:</p>
<pre><code>'{a}'.format(**d)
</code></pre>
<p>Need to run on Python2.7</p>
</div>
<div class="post-text" itemprop="text">
<p>For doing <code>'{a}'.format(**d)</code>, especially the <code>**d</code> part, the "lazy" dict is transformed into a regular one. Here happens the access to <em>all</em> keys, and <code>format()</code> can't do anything about it.</p>
<p>You could craft some proxy objects which are put in place of the elements, and on string access they do the "real" work.</p>
<p>Something like</p>
<pre><code>class LazyProxy(object):
    def __init__(self, prx):
        self.prx = prx
    def __format__(self, fmtspec):
        return format(self.prx(), fmtspec)
    def __repr__(self):
        return repr(self.prx())
    def __str__(self):
        return str(self.prx())
</code></pre>
<p>You can put these elements into a dict, such as</p>
<pre><code>interd = { k, LazyProxy(lambda: lazydict[k]) for i in lazydict.iterkeys()}
</code></pre>
<p>I didn't test this, but I think this fulfills your needs.</p>
<p>After the last edit, it now works with <code>!r</code> and <code>!s</code> as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>__format__</code> method (Python 3 only). See the doc <a href="http://docs.python.org/3/reference/datamodel.html?highlight=__format__#object.__format__" rel="nofollow">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your question correctly, you want to pass a custom dictionary, that would compute values only when needed. First, we're looking for implementation of <code>__getitem__()</code>:</p>
<pre><code>&gt;&gt;&gt; class LazyDict(object):
...    def __init__(self, d):
...        self.d = d
...    def __getitem__(self, k):
...        print k             # &lt;-- tracks the needed keys
...        return self.d[k]
...
&gt;&gt;&gt; d = D({'a': 19, 'b': 20})
&gt;&gt;&gt; '{0[a]}'.format(d)
a
'19'
</code></pre>
<p>This shows that only key <code>'a'</code> is accessed; <code>'b'</code> is not, so you already have your lazy access. </p>
<p>But also, any object attribute is usable for <code>str.format</code> this way, and using <code>@property</code> decorator, you can access function results: </p>
<pre><code>class MyObject(object):
    def __init__(self):
        self.a = 19
        self.b = 20
    def __getitem__(self, var): 
        return getattr(self, var)
        # this command lets you able to call any attribute of your instance,
        # or even the result of a function if it is decorated by @property:
    @property
    def c(self):
        return 21
</code></pre>
<p>Example of usage:</p>
<pre><code>&gt;&gt;&gt; m = MyObject()
&gt;&gt;&gt; '{0[c]}'.format(m)
'21'
</code></pre>
<p>But note that this also works, making the formating string a little bit specific, but avoid the need for <code>__getitem__()</code> implementation.</p>
<pre><code>&gt;&gt;&gt; '{0.c}'.format(m)
'21'
</code></pre>
</div>
<span class="comment-copy">"<code>str.format()</code> should only access the key in the lazy dict it needs" It <i>already</i> does this. It does <i>not</i> iterate over all the dictionary!</span>
<span class="comment-copy">@Bakuriu But in the case of <code>**d</code>, the converstion accesses all items.</span>
<span class="comment-copy">Thank you for your answer. I updated my question. I am very sorry, that I did not explain my thoughts in more details. Please look at the question again.</span>
<span class="comment-copy">@guettli Well, now I have no idea how to answer to your question; actually, it appears I'm not even able to get the interest of your question :-/</span>
