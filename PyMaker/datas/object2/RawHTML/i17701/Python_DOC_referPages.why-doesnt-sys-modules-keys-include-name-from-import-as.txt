<div class="post-text" itemprop="text">
<p>Say I import a module as follows:</p>
<pre><code>import os as OSMOD
</code></pre>
<p>and then wanted to find the working directory</p>
<pre><code>OSMOD.getcwd()
</code></pre>
<p><code>OSMOD</code> is now a stand in for <code>os</code>, and using <code>os</code> won't work.  This is all dandy, and works for me. However, I noticed something a little odd.  If I import <code>os</code> as I do above, and then get a list of all imported modules, here's what happens:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import os as OSMOD
&gt;&gt;&gt; modList = sys.modules.keys()
&gt;&gt;&gt; print "os" in modList
True
&gt;&gt;&gt; print "OSMOD" in modList
False
</code></pre>
<p>This is not what I expected.  According to the docs <code>modules.keys() only lists the imported modules</code>.  To me, this means it should list <code>OSMOD</code>.  </p>
<p>Why doesn't <code>sys.modules.keys()</code> contain <code>OSMOD</code> instead of <code>os</code>?</p>
<p>Additionally, is there an equivalent list to <code>sys.modules.keys()</code> which would contain <code>OSMOD</code>?</p>
<p><strong>EDIT:</strong> I guess the larger question here is the rationale.  If Python is going to keep <code>os</code> as the module, why delete the reference? (ie, why don't both <code>os.getcwd()</code> and <code>OSMOD.getcwd()</code> work?)</p>
<p>Or, more simply put, why doesn't <code>import os as OSMOD</code> behave the same as <code>import os</code> followed by <code>OSMOD = os</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You seem to be confused about the module <em>object</em> and the references to that object. <code>sys.modules['os']</code> is <em>one</em> reference to the module object, and <code>OSMOD</code> is another.</p>
<p>When you use the statement <code>import os as OSMOD</code>, Python makes sure the <code>os</code> module is loaded into memory (using the <code>sys.modules</code> dictionary as a cache) then creates a reference to the module object in your current namespace. Because you used <code>as OSMOD</code> Python sees that you want to use the name <code>OSMOD</code> and binds the module to that name.</p>
<p>Had you used <code>import os</code>, then Python would have defaulted to the same name as the module, so it binds the object to <code>os</code> in your local namespace.</p>
<p>You are in no way restricted here. You can still bind the same object to <em>other</em> names too:</p>
<pre><code>os = OSMOD
</code></pre>
<p>would give you another reference to the same module object.</p>
<p>Remember that your module global namespace is only global to the module; other modules don't see the same names. As such you want to control what names are defined in it. Perhaps you wanted use the name <code>os</code> for something <em>else</em> entirely. The following is legal:</p>
<pre><code>os = 'Ozzy Santana'
import os as OSMOD
</code></pre>
<p>and I would expect <code>os</code> to still be bound to the string, not the module.</p>
<p>At the same time, another module in my Python project can still use <code>import os</code> and have <code>os</code> refer to the module; it won't see the string bound to <code>os</code> in the first module.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because the name of the module is <code>os</code>. You did <code>import os</code>. <code>as OSMOD</code> just tells Python to assign that module to the name <code>OSMOD</code> <em>in your module's namespace.</em></p>
<p><code>sys.modules</code> is a cache of imported modules to prevent modules from being imported more than once. If it stored the imported module under <code>OSMOD</code>, another module that did <code>import os</code> would import the module again.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="http://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>The basic import statement (no from clause) is executed in two steps:</p>
<ul>
<li>find a module, loading and initializing it if necessary</li>
<li>define a name or names in the local namespace for the scope where the import statement occurs.</li>
</ul>
</blockquote>
<p>In particular, the second step means:</p>
<blockquote>
<p>If the requested module is retrieved successfully, it will be made available in the local namespace in one of three ways:</p>
<ul>
<li>If the module name is followed by as, then the name following as is bound directly to the imported module.</li>
</ul>
</blockquote>
<p>This implies that the name under which your module is available will be present in <code>locals()</code> or <code>globals()</code>:</p>
<pre><code>&gt;&gt;&gt;import sys as X
&gt;&gt;&gt; locals()['X']
&lt;module 'sys' (built-in)&gt;
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/sys.html#sys.modules" rel="nofollow"><code>sys.modules</code></a> contains the true names of the imported modules.  However, it does <em>not</em> contain the names they were imported under using <code>as &lt;name&gt;</code>.</p>
<p>In other words, when you do:</p>
<pre><code>import os as OSMOD
</code></pre>
<p>the <code>os</code> module is in fact imported.  However, it is imported under the name of <code>OSMOD</code>.  </p>
<p>Nevertheless, the name <code>os</code> is still added to <code>sys.modules</code> because that is the true name of the imported module.  <code>OSMOD</code> though is <em>not</em> added because it is not a module.  Instead, it is an alternate name for the <code>os</code> module that was imported.</p>
</div>
<div class="post-text" itemprop="text">
<p>You imported <code>os</code>. Then you put it to the name <code>OSMOD</code>. Here is a simple illustration of what's happening:</p>
<pre><code>import os
OSMOD = os
del os
</code></pre>
<p>The module imported is still <code>os</code>, not <code>osmod</code>, so it will be the one listed in <code>sys.modules.keys()</code>.</p>
<p>And yes, <code>type(OSMOD)</code> is a module since it's bound to a module object.</p>
</div>
<span class="comment-copy">OSMOD is in <code>globals()</code>.</span>
<span class="comment-copy"><i>why doesn't import os as OSMOD behave the same as import os followed by OSMOD = os?</i>: Because you don't want to pollute the global namespace of your module with names you are not going to use.</span>
<span class="comment-copy">Right, but then Python should recognize <code>os</code> just the same since that module was imported</span>
<span class="comment-copy">What Python "should" do is what it is documented as doing. Which is: first, it imports the module <code>os</code>. If you specify a name using the <code>as</code> clause, it then assigns the module to that name in your module's namespace. Otherwise it assigns the module into your namespace under its actual name. Think of <code>import</code> as an assignment.</span>
<span class="comment-copy">@wnnmaw: no, because <code>import</code> <b>binds</b> the imported module to a name of your choosing.</span>
<span class="comment-copy">@wnnmaw: By using <code>import os as OSMOD</code> you are now free to use <code>os = somethingelse</code>.</span>
<span class="comment-copy">@wnnmaw: But another module can still use <code>import os</code> and use the exact same methods contained within the <code>os</code> module.</span>
<span class="comment-copy">But <code>type(OSMOD)</code> returns <code>&lt;type 'module'&gt;</code></span>
