<div class="post-text" itemprop="text">
<p>I understand that in Python regular c++ style variable assignment is replaced by references to stuff ie</p>
<pre><code>a=[1,2,3]
b=a
a.append(4)
print(b)       #gives [1,2,3,4]
print(a)       #gives [1,2,3,4]
</code></pre>
<p>but I'm still confused why an analogous situation with basic types eg. integers works differently?</p>
<pre><code>a=1
b=a
a+=1
print(b)          # gives 1
print(a)          # gives 2
</code></pre>
<p>But wait, it gets even more confusing when we consider loops!</p>
<pre><code>li=[1,2,3]
for x in li:
    x+=1
print(li)     #gives [1,2,3]
</code></pre>
<p>Which is what I expected, but what happens if we do:</p>
<pre><code>a,b,c=1,2,3
li=[a,b,c]
for x in li:
    x+=1
print(li)        #gives [1,2,3]
</code></pre>
<p>Maybe my question should be how to loop over a list of integers and change them without map() as i need a if statement in there. The only thing I can come up short of using</p>
<pre><code>for x in range(len(li)):
    Do stuff to li[x]
</code></pre>
<p>is packaging the integers in one element list. But there must be a better way.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a=[1,2,3]
b=a
a.append(4)
print(b)       #[1,2,3,4]
print(a)       #[1,2,3,4]
</code></pre>
<p>Here you are modifying the list. The list content changes, but the list identity remains.</p>
<pre><code>a=1
b=a
a+=1
</code></pre>
<p>This, however, is a reassignment. You assign a different object to <code>a</code>.</p>
<p>Note that if you did <code>a += [4]</code> in the 1st example, you would have seen the same result. This comes from the fact that <code>a += something</code> is the same as <code>a = a.__iadd__(something)</code>, with a fallback to <code>a = a.__add__(something)</code> if <code>__iadd__()</code> doesn't exist.</p>
<p>The difference is that <code>__iadd__()</code> tries to do its job "inplace", by modifying the object it works on and returning it. So <code>a</code> refers to the same as before. This only works with mutable objects such as lists.</p>
<p>On immutable objects such as ints <code>__add__()</code> is called. It returns a different object, which leads to <code>a</code> pointing to another object than before. There is no other choice, as ints are immutable.</p>
<hr/>
<pre><code>a,b,c=1,2,3
li=[a,b,c]
for x in li:
    x+=1
print(li)        #[1,2,3]
</code></pre>
<p>Here <code>x += 1</code> means the same as <code>x = x + 1</code>. It changes where <code>x</code> refers to, but not the list contents.</p>
<blockquote>
<p>Maybe my question should be how to loop over a list of integers and change them without &gt;map() as i need a if statement in there.</p>
</blockquote>
<pre><code>for i, x in enumerate(li):
    li[i] = x + 1
</code></pre>
<p>assigns to every list position the old value + 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, you need to think of <strong>mutable</strong> and <strong>immutable</strong> type.</p>
<p>For a list, it's mutable.
For a integer, it's immutable, which means you will refer to a new object if you change it. When <em>a</em>+=1 is executed, <em>a</em> will be assigned a new object, but <em>b</em> is still refer to the same one.</p>
</div>
<div class="post-text" itemprop="text">
<p>The important thing here are the variable <em>names</em>. They really are just keys to a dictionary. They are resolved at runtime, depending on the current scope.</p>
<p>Let's have a look what names you access in your code. The <a href="http://docs.python.org/2/library/functions.html#locals" rel="nofollow">locals</a> function helps us: It shows the names in the local scope (and their value). Here's your code, with some debugging output:</p>
<pre><code>a = [1, 2, 3]       # a is bound
print(locals())
for x in a:         # a is read, and for each iteration x is bound
    x = x + 3       # x is read, the value increased and then bound to x again
    print(locals())
print(locals())
print(x)
</code></pre>
<p>(Note I expanded <code>x += 3</code> to <code>x = x + 3</code> to increase visibility for the name accesses - read and write.)</p>
<p>First, you bind the list <code>[1, 2, 3]</code>to the name <code>a</code>. Then, you iterate over the list. During each iteration, the value is bound to the name <code>x</code> in the current scope. Your assignment then assigns another value to <code>x</code>.</p>
<p>Here's the output</p>
<pre><code>{'a': [1, 2, 3]}
{'a': [1, 2, 3], 'x': 4}
{'a': [1, 2, 3], 'x': 5}
{'a': [1, 2, 3], 'x': 6}
{'a': [1, 2, 3], 'x': 6}
6
</code></pre>
<p>At no point you're accessing <code>a</code>, the list, and thus will never modify it.</p>
<p>To fix your problem, I'd use the enumerate function to get the index along with the value and then access the list using the name <code>a</code> to change it.</p>
<pre><code>for idx, x in enumerate(a):
    a[idx] = x + 3
print(a)
</code></pre>
<p>Output:</p>
<pre><code>[4, 5, 6]
</code></pre>
<p>Note you might want to wrap those examples in a function, to avoid the cluttered global namespace.</p>
<p>For more about scopes, read the <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow">chapter in the Python tutorial</a>. To further investigate that, use the <a href="http://docs.python.org/2/library/functions.html#globals" rel="nofollow">globals</a> function to see the names of the global namespace. (Not to be confused with the <code>global</code> keyword, note the missing 's'.)</p>
<p>Have fun!</p>
</div>
<div class="post-text" itemprop="text">
<p>For a C++-head it easiest tho think that <em>every Python object is a pointer</em>. When you write <code>a = [1, 2, 3]</code> you essentially write <code>List * a = new List(1, 2, 3)</code>. When you write <code>a = b</code>, you essentially write <code>List * b = a</code>.</p>
<p>But when you take out actual items from the lists, these items <em>happen to be</em> numbers. Numbers are immutable; holding a pointer to an immutable object is about as good as holding this object by value.</p>
<p>So your <code>for x in a: x += 1</code> is essentially </p>
<pre><code> for (int x, it = a.iterator(); it-&gt;hasMore(); x=it.next()) {
    x+=1; // the generated sum is silently discarded
 }
</code></pre>
<p>which obviously has no effect.</p>
<p>If list elements were mutable objects you could mutate them exactly the way you wrote. See:</p>
<pre><code>a = [[1], [2], [3]] # list of lists
for x in a:  # x iterates over each sub-list
  x.append(10)
print a  # prints [[1, 10], [2, 10], [3, 10]]
</code></pre>
<p>But unless you have a compelling reason (e.g. a list of millions of objects under heavy memory load) you are better off making a copy of the list, applying a transformation and optionally a filter. This is easily done with a <em>list comprehension:</em> </p>
<pre><code>a = [1, 2, 3, 0]
b = [n + 1 for n in a] # [2, 3, 4, 1]
c = [n * 10 for n in a if n &lt; 3] # [10, 20, 0]
</code></pre>
<p>Either that, or you can write an explicit loop that creates another list:</p>
<pre><code>source = [1, 2, 3]
target = []
for n in source:
  n1 = &lt;many lines of code involving n&gt;
  target.append(n1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your question has multiple parts, so it's going to be hard for one answer to cover all of them. glglgl has done a great job on most of it, but your final question is still unexplained:</p>
<blockquote>
<p>Maybe my question should be how to loop over a list of integers and change them without map() as i need a if statement in there</p>
</blockquote>
<p>"I need an if statement in there" doesn't mean you can't use <code>map</code>.</p>
<hr/>
<p>First, if you want the <code>if</code> to select which values you want to keep, <code>map</code> has a good friend named <a href="http://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter</code></a> that does exactly that. For example, to keep only the odd numbers, but add one to each of them, you could do this:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for x in a:
...     if x%2:
...         b.append(x+1)
</code></pre>
<p>Or just this:</p>
<pre><code>&gt;&gt;&gt; b = map(lambda x: x+1, filter(lambda x: x%2, a))
</code></pre>
<p>If, on the other hand, you want the <code>if</code> to control the expression itself—e.g., to add 1 to the odd numbers but leave the even ones alone, you can use an <code>if</code> expression the same way you'd use an if statement:</p>
<pre><code>&gt;&gt;&gt; for x in a:
...     if x%2:
...         b.append(x+1)
...     else:
...         b.append(x)

&gt;&gt;&gt; b = map(lambda x: x+1 if x%2 else x, a)
</code></pre>
<hr/>
<p>Second, comprehensions are basically equivalent to <code>map</code> and <code>filter</code>, but with <em>expressions</em> instead of <em>functions</em>. If your expression would just be "call this function", then use <code>map</code> or <code>filter</code>. If your function would just be a lambda to "evaluate this expression", then use a comprehension. The above two examples get more readable this way:</p>
<pre><code>&gt;&gt;&gt; b = [x+1 for x in a if x%2]
&gt;&gt;&gt; b = [x+1 if x%2 else x for x in a]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this: <code>li = [x+1 for x in li]</code></p>
</div>
<span class="comment-copy"><code>b=a</code> is a resource reference. So it will affect the same memory, thus it stays linked. The <code>for</code> loop you do is a new instance (<code>x</code>) and will thus not affect the <code>li</code> unless you write the modification back to the list.</span>
<span class="comment-copy">Maybe this link: <a href="http://stackoverflow.com/questions/4081217/how-to-modify-list-entries-during-for-loop" title="how to modify list entries during for loop">stackoverflow.com/questions/4081217/…</a> can clarify you aoome things regarding this topic.</span>
<span class="comment-copy">This is important... in C, there are pointers and references, but <i>never</i> really an 'object'. In python, there are objects, and there are names for those objects, and they don't line up exactly to C-style references or pointers.</span>
<span class="comment-copy">@CorleyBrigman JFYI, indeed there are objects in C (read the standard), but usually not in a OOP way. But you can do OOP in C as well, with function pointers and the like.</span>
<span class="comment-copy">Even numbers are "pointers" in Python. The fact that they're pointers to immutable objects doesn't mean they're not pointers—after all, the same is true of, say, tuples.</span>
<span class="comment-copy">@abarnert: I know :) I can imagine that for arithmetic calculations they can be represented as plain numbers, and only "boxed" when actual object properties are required (hashing, for instance, or overloaded operations). I'm no expert in CPyhton internals, though. so maybe this is not the case. I've edited my answer, though.</span>
<span class="comment-copy">It's definitely not the case in CPython. It might be the case in Jython, and you could end up with something equivalent after JIT-compiling with PyPy or IronPython. But with CPython, even evaluating <code>1+2</code> looks up the <code>np_add</code> slot on the first <code>PyLongObject *</code> and calls it with the other <code>PyLongObject *</code> as an argument. (It's actually even more complicated than that, but that's enough to give you the idea. There is no unboxing.)</span>
<span class="comment-copy">Anyway, your edited version still says "every Python object is a pointer, except for numbers", which is still not true. Every Python object is a pointer, including numbers. Some Python objects are pointers to immutable objects, including everything from numbers to tuples, but that's a separate issue, which you already address nicely in the next paragraph.</span>
<span class="comment-copy">@abarnert: Oops, fixed.</span>
<span class="comment-copy">It is a workaround, but it doesn't help understanding the issue.</span>
