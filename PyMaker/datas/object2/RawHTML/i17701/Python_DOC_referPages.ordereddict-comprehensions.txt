<div class="post-text" itemprop="text">
<p>Can I extend syntax in python for dict comprehensions for other dicts, like the OrderedDict in <code>collections</code> module or my own types which inherit from <code>dict</code>?  </p>
<p>Just rebinding the <code>dict</code> name obviously doesn't work, the <code>{key: value}</code> comprehension syntax still gives you a plain old dict for comprehensions and literals.  </p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; olddict, dict = dict, OrderedDict
&gt;&gt;&gt; {i: i*i for i in range(3)}.__class__
&lt;type 'dict'&gt;
</code></pre>
<p>So, if it's possible how would I go about doing that?  It's OK if it only works in CPython.  For syntax I guess I would try it with a <code>O{k: v}</code> prefix like we have on the <code>r'various' u'string' b'objects'</code>.</p>
<p><em>note:</em>  Of course we can use a generator expression instead, but I'm more interested seeing how hackable python is in terms of the grammar.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no direct way to change Python's syntax from within the language. A dictionary comprehension (or plain display) is always going to create a <code>dict</code>, and there's nothing you can do about that. If you're using CPython, it's using special bytecodes that generate a dict directly, which ultimately call the <a href="http://docs.python.org/3/c-api/dict.html" rel="noreferrer"><code>PyDict</code></a> API functions and/or the same underlying functions used by that API. If you're using PyPy, those bytecodes are instead implemented on top of an RPython <code>dict</code> object which in turn is implemented on top of a compiled-and-optimized Python <code>dict</code>. And so on.</p>
<p>There is an <em>indirect</em> way to do it, but you're not going to like it. If you read the docs on <a href="http://docs.python.org/dev/reference/import.html" rel="noreferrer">the import system</a>, you'll see that it's the importer that searches for cached compiled code or calls the compiler, and the compiler that calls the parser, and so on. In Python 3.3+, almost everything in this chain either is written in pure Python, or has an alternate pure Python implementation, meaning you can fork the code and do your own thing. Which includes parsing source with your own PyParsing code that builds ASTs, or compiling a dict comprehension AST node into your own custom bytecode instead of the default, or post-processing the bytecode, or…</p>
<p>In many cases, an <a href="http://www.python.org/dev/peps/pep-0302/" rel="noreferrer">import hook</a> is sufficient; if not, you can always write a custom finder and loader.</p>
<p>If you're not already using Python 3.3 or later, I'd strongly suggest migrating before playing with this stuff. In older versions, it's harder, and less well documented, and you'll ultimately be putting in 10x the effort to learn something that will be obsolete whenever you do migrate.</p>
<p>Anyway, if this approach sounds interesting to you, you might want to take a look at <a href="https://github.com/lihaoyi/macropy" rel="noreferrer">MacroPy</a>. You could borrow some code from it—and, maybe more importantly, learn how some of these features (that have no good examples in the docs) are used.</p>
<p>Or, if you're willing to settle for something less cool, you can just use <code>MacroPy</code> to build an "odict comprehension macro" and use that. (Note that MacroPy currently only works in Python 2.7, not 3.x.) You can't quite get <code>o{…}</code>, but you can get, say, <code>od[{…}]</code>, which isn't too bad. Download <a href="http://pastebin.com/MbLPADJW" rel="noreferrer"><code>od.py</code></a>, <a href="http://pastebin.com/F9uJDQ4f" rel="noreferrer"><code>realmain.py</code></a>, and <a href="http://pastebin.com/dDSaL5MA" rel="noreferrer"><code>main.py</code></a>, and run <code>python main.py</code> to see it working. The key is this code, which takes a <code>DictionaryComp</code> AST, converts it to an equivalent <code>GeneratorExpr</code> on key-value <code>Tuple</code>s, and wraps it in a <code>Call</code> to <code>collections.OrderedDict</code>:</p>
<pre><code>def od(tree, **kw):
    pair = ast.Tuple(elts=[tree.key, tree.value])
    gx = ast.GeneratorExp(elt=pair, generators=tree.generators)
    odict = ast.Attribute(value=ast.Name(id='collections'), 
                          attr='OrderedDict')
    call = ast.Call(func=odict, args=[gx], keywords=[])
    return call
</code></pre>
<hr/>
<p>A different alternative is, of course, to modify the Python interpreter.</p>
<p>I would suggest dropping the <code>O{…}</code> syntax idea for your first go, and just making normal dict comprehensions compile to odicts. The good news is, you don't really need to change the grammar (which is beyond hairy…), just any one of:</p>
<ul>
<li>the bytecodes that dictcomps compile to,</li>
<li>the way the interpreter runs those bytecodes, or</li>
<li>the implementation of the <code>PyDict</code> type</li>
</ul>
<p>The bad news, while all of those are a lot easier than changing the grammar, none of them can be done from an extension module. (Well, you can do the first one by doing basically the same thing you'd do from pure Python… and you can do any of them by hooking the .so/.dll/.dylib to patch in your own functions, but that's the exact same work as hacking on Python plus the extra work of hooking at runtime.)</p>
<p>If you want to hack on <a href="http://hg.python.org/cpython/file/" rel="noreferrer">CPython source</a>, the code you want is in <code>Python/compile.c</code>, <code>Python/ceval.c</code>, and <code>Objects/dictobject.c</code>, and the <a href="http://docs.python.org/devguide/" rel="noreferrer">dev guide</a> tells you how to find everything you need. But you might want to consider hacking on <a href="https://bitbucket.org/pypy/pypy/src" rel="noreferrer">PyPy source</a> instead, since it's mostly written in (a subset of) Python rather than C.</p>
<hr/>
<p>As a side note, your attempt wouldn't have worked even if everything were done at the Python language level. <code>olddict, dict = dict, OrderedDict</code> creates a binding named <code>dict</code> in your module's globals, which <em>shadows</em> the name in builtins, but doesn't replace it. You <em>can</em> replace things in builtins (well, Python doesn't guarantee this, but there are implementation/version-specific things-that-happen-to-work for every implementation/version I've tried…), but what you did isn't the way to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorry, not possible. Dict literals and dict comprehensions map to the built-in dict type, in a way that's hardcoded at the C level. That can't be overridden.</p>
<p>You can use this as an alternative, though:</p>
<pre><code>OrderedDict((i, i * i) for i in range(3))
</code></pre>
<p>Addendum: as of Python 3.6, all Python dictionaries are ordered. <a href="https://docs.python.org/3/whatsnew/3.7.html#what-s-new-in-python-3-7" rel="noreferrer">As of 3.7</a>, it's even part of the language spec. If you're using those versions of Python, no need for OrderedDict: the dict comprehension will Just Work (TM).</p>
</div>
<div class="post-text" itemprop="text">
<p>Slightly modifying the response of @Max Noel, you can use list comprehension instead of a generator to create an OrderedDict in an ordered way (which of course is not possible using dict comprehension).</p>
<pre><code>&gt;&gt;&gt; OrderedDict([(i, i * i) for i in range(5)])
OrderedDict([(0, 0), 
             (1, 1), 
             (2, 4), 
             (3, 9), 
             (4, 16)])
</code></pre>
</div>
<span class="comment-copy">By "can I extend syntax", do you mean by making a custom build of CPython or PyPy or something, or do you mean from within the language?</span>
<span class="comment-copy">That's precisely where I'm a bit unsure.  Can cpython extensions be used for stuff this hairy, or are we getting into building-your-own-python territory here?</span>
<span class="comment-copy">You can extend the {} syntax for dictionary comprehensions by using the following code: <a href="http://stackoverflow.com/a/7880276/313113">stackoverflow.com/a/7880276/313113</a> and <b>You'd need to add a visit_DictComp() method to the DictDisplayTransformer class.</b> If you <i>really</i> need to ;)</span>
<span class="comment-copy">Just move to Python3.6, where <a href="https://stackoverflow.com/q/39980323/974555">dicts are ordered</a>.</span>
<span class="comment-copy">I'm interested in getting involved with the Python C api. Is the C api for 3 substantially different from 2? (My day job is 2 and won't ever go to 3)</span>
<span class="comment-copy">@EdgarAroutiounian: The C API is even more conservative than the language itself—<code>long</code> and <code>unicode</code> changed to <code>int</code> and <code>str</code>, but the C types are still <code>PyLong</code> and <code>PyUnicode</code>. Almost all of the differences are related to new functionality that didn't exist in 2.x. (If you dive into hacking on CPython itself, there are much bigger differences. But in most cases—with the notable exception of Unicode internal storage—3.4 is simpler than 2.7, so it still makes sense to learn the easy way first.)</span>
<span class="comment-copy">@EdgarAroutiounian: Anyway, the best way to get involved with the C API is to build a simple extension that wraps some C library and exposes it to Python in a nice way. The <a href="http://docs.python.org/3.3/extending/index.html" rel="nofollow noreferrer">Extending and Embedding</a> tutorial in the official docs is pretty good. You might want to try doing the same wrapper with <code>ctypes</code>/<code>cffi</code> and a native extension (and maybe Cython, too) to really understand how things look from the different sides.</span>
<span class="comment-copy">Very cool answer.  Thanks.</span>
<span class="comment-copy">"There is an indirect way to do it, but you're not going to like it." -- I like it already :)</span>
<span class="comment-copy">This seems to give you the same end result as Max's answer. Does this have any benefits/difference over the other?</span>
<span class="comment-copy">@user694733 This shows that you can use <code>OrderedDict([(0, 2), (2, 5)])</code> using arbitrary values.</span>
<span class="comment-copy">@user694733 The OP's question ends with "note: Of course we can use a generator expression instead, but I'm more interested seeing how hackable python is in terms of the grammar." This solution accomplishes the same thing without a generator.</span>
<span class="comment-copy">I think 'generators' in python is a bit of advanced concept and not everyone using python need to know it. So it makes sense to use a list contribution if the target audience who will read/maintain the script are not experts with the language.</span>
