<div class="post-text" itemprop="text">
<p>In my Django I have a model as such:</p>
<pre><code>class myModel(models.model):
    a = models.TextField()
</code></pre>
<p>In my views.py file, I have this:</p>
<pre><code>myDict = {
    "A": myModel(a="X"),
    "B": myModel(a="Y"),
    "C": myModel(a="Z"),
}
</code></pre>
<p>I have created the following template tag:</p>
<pre><code>@register.filter
def get_item(dictionary, key):
    return dictionary[key]
</code></pre>
<p>In my Template, I loop through the keys with myKey. I have the following. It works:</p>
<pre><code>{% for myKey in myDict %}
    {{myDict|get_item:myKey}}
{% endfor %}
</code></pre>
<p>I can tell it works because it prints myDict[myKeys] on the webpage.</p>
<p>However, when I want to access the attribute a of myDict["myKey"], it fails:</p>
<pre><code>{% for myKey in myDict %}
    {{myDict|get_item:myKey.a}}
{% endfor %}
</code></pre>
<p>It gives me the following error: </p>
<pre><code>Failed lookup for key [a] in u'A'
</code></pre>
<p>The problem is that when I say myDict|get_item:myKey.a, I mean (myDict|get_item:myKey).a but it thinks I mean myDict|get_item:(myKey.a)</p>
<p>How do I tell it that the the precedence of the : operator is higher . without using parenthesis (which Django templates don't allow)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need custom filter. Just use <a href="http://docs.python.org/3/library/stdtypes.html#dict.values" rel="nofollow"><code>dict.values</code></a> (or <a href="http://docs.python.org/2/library/stdtypes.html#dict.itervalues" rel="nofollow"><code>dict.itervalues</code></a> if you use Python 2.x):</p>
<pre><code>{% for myModel in myDict.values %}
    {{ myModel.a }}
{% endfor %}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>with</code> tag:</p>
<pre><code>{% with myDict|get_item:myKey as item %}
    {{ item.a }}
{% endwith %} 
</code></pre>
</div>
<span class="comment-copy">What about iterating over the dict in an <a href="https://docs.djangoproject.com/en/dev/ref/templates/builtins/#for" rel="nofollow noreferrer">usual manner</a>: <code>{% for key, value in myDict.items %}{{ value.a }}{% endfor %}</code>?</span>
<span class="comment-copy">I recommend @alecxe's answer above. You could also do <code>{% with myDict|get_item:myKey as item %}{{ item.a }}{% endwith %}</code></span>
<span class="comment-copy">The order of that iteration over myDict is relevant. I want to go in a very specific order that is not captured in the above solution (or even properly by my original question).</span>
<span class="comment-copy">@SaqibAli, Python dictionary does not guarantee the order of keys. How about using <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a>?</span>
<span class="comment-copy">@Anentropic answer worked perfectly for me. Thanks!</span>
