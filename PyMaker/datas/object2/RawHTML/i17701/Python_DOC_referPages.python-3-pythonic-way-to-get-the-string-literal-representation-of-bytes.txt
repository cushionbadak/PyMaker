<div class="post-text" itemprop="text">
<p>There is <a href="https://stackoverflow.com/questions/15390374/python-3-how-do-i-get-a-string-literal-representation-of-a-byte-string">similiar question</a>, but the solution doesn't seem to work.</p>
<p>Say I've encoded a string:</p>
<pre><code>&gt;&gt;&gt; a = 'dada大大'.encode('utf-8')
&gt;&gt;&gt; type(a)
&lt;class 'bytes'&gt;
&gt;&gt;&gt; a
&gt;&gt;&gt; b'dada\xe5\xa4\xa7\xe5\xa4\xa7'
</code></pre>
<p>What I want is something like this:</p>
<pre><code>dada\xe5\xa4\xa7\xe5\xa4\xa7
</code></pre>
<p><code>str(a)</code> doesn't work:</p>
<pre><code>&gt;&gt;&gt; str(a)
&gt;&gt;&gt; "b'dada\\xe5\\xa4\\xa7\\xe5\\xa4\\xa7'"
</code></pre>
<p>I've tried redirect stdout to a variable, but still, I got <code>"b'dada\\xe5\\xa4\\xa7\\xe5\\xa4\\xa7'"</code>.  </p>
<p>I can deal with it using regular expression and get what I want, but I'm searching for a more pythonic way to do this. Any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>As you were so nice to mention <em>your actual problem</em> in a comment, I’ll update my answer once more to respond to that actually. The original answer can be seen below.</p>
<blockquote>
<p>It's the string I post to Github Markdown API. This is the only way that unicode character can be accepted. I got the rendered html with the orignal character <code>dada大大</code></p>
</blockquote>
<p>The <a href="http://developer.github.com/v3/markdown/" rel="nofollow">GitHub Markdown API</a> requires you to send the data as JSON. JSON itself borrows the string escaping from JavaScript, which would be <code>\u5927</code> for this character. When using the <a href="http://docs.python.org/3/library/json.html" rel="nofollow"><code>json</code> module</a> however, you don’t need to worry about that at all:</p>
<pre><code>from urllib import urlopen
import json

text = 'dada大大'
data = json.dumps({ mode: 'markdown', 'text': text }).encode()
r = urlopen('https://api.github.com/markdown', data)

print(r.read().decode()) # &lt;p&gt;dada大大&lt;/p&gt;
</code></pre>
<p>As you can see, the API accepts the encoded text without problems and correctly produces the correct output, without having to worry about the encoding.</p>
<p>Or when using the raw API with the <code>requests</code> library:</p>
<pre><code>h = { 'Content-Type': 'text/plain' }
r = requests.post('https://api.github.com/markdown/raw', text.encode(), headers=h)

print(r.content.decode()) # &lt;p&gt;dada大大&lt;/p&gt;
</code></pre>
<hr/>
<h2>Original answer</h2>
<pre><code>&gt;&gt;&gt; a = 'dada大大'.encode('utf-8')
&gt;&gt;&gt; a
b'dada\xe5\xa4\xa7\xe5\xa4\xa7'
&gt;&gt;&gt; str(a)
"b'dada\\xe5\\xa4\\xa7\\xe5\\xa4\\xa7'"
&gt;&gt;&gt; str(a)[2:-1]
'dada\\xe5\\xa4\\xa7\\xe5\\xa4\\xa7'
&gt;&gt;&gt; print(_)
dada\xe5\xa4\xa7\xe5\xa4\xa7
</code></pre>
<p>When you just do <code>str(a)</code> you will get the string representation of the bytes string. Of course, when you just use it like that in the interpreter, the interpreter will actually call <code>repr</code> on it to display it. And a string that contains backslashes will have them escaped as <code>\\</code>. That’s where those came from.</p>
<p>And finally, you have to strip of the <code>b'</code> and the trailing <code>'</code> to get just the content of the string representation of the bytes string.</p>
<p><em>Side note: <code>str()</code> and <code>repr()</code> will produce the same result when used on bytes objects.</em></p>
<hr/>
<blockquote>
<p>According to Poke's answer, what I need is preventing autoescaping of <code>repr</code>.</p>
</blockquote>
<p>No, you don’t. There are no double backslashes in the final string. They only appear because when you enter stuff in your REPL, it will output the <em>return values</em> of things to the console after calling <code>repr</code> on them. But that does not mean, that the actual string suddenly got changed:</p>
<pre><code>&gt;&gt;&gt; s = str(a)[2:-1]
&gt;&gt;&gt; len(s)
28
&gt;&gt;&gt; list(s)
['d', 'a', 'd', 'a', '\\', 'x', 'e', '5', '\\', 'x', 'a', '4', '\\', 'x', 'a', '7', '\\', 'x', 'e', '5', '\\', 'x', 'a', '4', '\\', 'x', 'a', '7']
</code></pre>
<p>As you can see, there are not double backslashes in the string. Yes, you can see them again, but that’s again only because the return value of <code>list(s)</code> is being printed by the REPL. Each item of the list is <em>a single character</em> though, including the backslashes. They are just escaped again because <code>'\'</code> wouldn’t be a valid string.</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; '\'
SyntaxError: EOL while scanning string literal
&gt;&gt;&gt; '\\'
'\\'
&gt;&gt;&gt; len('\\')
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>bytes</code> is really an array of integers:</p>
<pre><code>&gt;&gt;&gt; a = 'dada大大'.encode() # 'utf-8' by default
&gt;&gt;&gt; list(a)
[100, 97, 100, 97, 229, 164, 167, 229, 164, 167]
</code></pre>
<p>You can get the hex values of each of these using</p>
<pre><code>&gt;&gt;&gt; list(map(hex, a))
['0x64', '0x61', '0x64', '0x61', '0xe5', '0xa4', '0xa7', '0xe5', '0xa4', '0xa7']
</code></pre>
<p>And therefore</p>
<pre><code>&gt;&gt;&gt; list(chr(x) if x &lt; 128 else hex(x) for x in a)
['d', 'a', 'd', 'a', '0xe5', '0xa4', '0xa7', '0xe5', '0xa4', '0xa7']

&gt;&gt;&gt; print("".join(chr(x) if x &lt; 128 else hex(x).replace("0", "\\") for x in a))
dada\xe5\xa4\xa7\xe5\xa4\xa7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>OK, finally I found the solution, it's from <a href="https://stackoverflow.com/questions/5186839/python-replace-with">Python Replace \\ with \</a></p>
<pre><code>a = 'dada大大'.encode('utf-8')
b = str(a)[2:-1].encode('utf-8').decode('unicode_escape')
</code></pre>
<p>Maybe I should have explained what I want clearer.</p>
<h2>Edit - My test result</h2>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; text = 'dada大大'
&gt;&gt;&gt; h = {'Content-Type': 'text/plain'}
&gt;&gt;&gt; r = requests.post('https://api.github.com/markdown/raw', text.encode(), headers=h)
&gt;&gt;&gt; print(r.content.decode())
{"message":"Invalid request media type (expecting 'text/plain')","documentation_url":"http://developer.github.com/v3/markdown/#render-a-markdown-document-in-raw-mode"}
&gt;&gt;&gt; print(r.content.decode('utf-8'))
{"message":"Invalid request media type (expecting 'text/plain')","documentation_url":"http://developer.github.com/v3/markdown/#render-a-markdown-document-in-raw-mode"}
&gt;&gt;&gt; r = requests.post('https://api.github.com/markdown/raw', text.encode('utf-8'), headers=h)
&gt;&gt;&gt; print(r.content.decode('utf-8'))
{"message":"Invalid request media type (expecting 'text/plain')","documentation_url":"http://developer.github.com/v3/markdown/#render-a-markdown-document-in-raw-mode"}
</code></pre>
</div>
<span class="comment-copy">"the solution doesn't seem to work" - be more specific! Do you get errors (if so, provide full traceback)? Odd outputs (provide inputs, expected outputs, actual outputs)?</span>
<span class="comment-copy">what output are you looking for? the string representation looks like what you want (of course you are seeing the dual \\ because they need escaped)...</span>
<span class="comment-copy">Is there any particular reason you want to strip off the <code>b</code> and the single quotes? <code>str(a)</code> has pretty close to what you want. You're seeing the <code>repr</code> of the string, which has extra escaping. If you <code>print(str(a))</code>, you'll see the string's contents rather than an expression that evaluates to the string.</span>
<span class="comment-copy">@jonrsharpe see my edit</span>
<span class="comment-copy">@user2357112 Yes, indeed. I just want the string literal.</span>
<span class="comment-copy">thanks, so how to prevent auto escape?</span>
<span class="comment-copy">@laike9m As I explained, there is no auto escaping. <code>str(a)[2:-1]</code> is a string—with only single backslashes, not double backslashes. But when the <i>interpreter</i> outputs the return value it automatically calls <code>repr</code> on it which creates a <i>string</i> reprentation to be used as if you wrote that string in Python itself. And then you would have to escape those backslashes which is why you see them. But as you can see, when you print the string or output it <i>anywhere</i>, there are no escaped backslashes.</span>
<span class="comment-copy">Why go the overhead of converting the integers manually to hex, when calling <code>str()</code> on a bytes object already does all that?</span>
<span class="comment-copy">That makes no sense. Did you actually look at the result?</span>
<span class="comment-copy">sure, this is what I want really...</span>
<span class="comment-copy">@poke I know the question is not well explained...</span>
<span class="comment-copy"><code>dadaå¤§å¤§</code>? How does that even remotely look like the <code>dada\xe5\xa4\xa7\xe5\xa4\xa7</code> you mentioned in the question as what you wanted?</span>
<span class="comment-copy">@poke it's the string I post to Github Markdown API. This is the only way that unicode character can be accepted. I got the rendered html with the orignal character <code>dada大大</code>.</span>
