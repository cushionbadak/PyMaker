<div class="post-text" itemprop="text">
<p>Python programs are often short and concise and what usually requires bunch of lines in other programming languages (that I know of) can be accomplished in a line or two in python.
One such program I am trying to write was to extract every other letters from a string.
I have this working code, but wondering if any other concise way is possible?</p>
<pre><code>&gt;&gt;&gt; s
'abcdefg'
&gt;&gt;&gt; b = ""
&gt;&gt;&gt; for i in range(len(s)):
...   if (i%2)==0:
...      b+=s[i]
... 
&gt;&gt;&gt; b
'aceg'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; 'abcdefg'[::2]
'aceg'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://stackoverflow.com/questions/509211/pythons-slice-notation">Explain Python's slice notation</a>:</p>
<pre><code>&gt;&gt;&gt; 'abcdefg'[::2]
'aceg'
&gt;&gt;&gt;
</code></pre>
<p>The format for slice notation is <code>[start:stop:step]</code>.  So, <code>[::2]</code> is telling Python to step through the string by 2's (which will return every other character).</p>
</div>
<div class="post-text" itemprop="text">
<p>The <em>right</em> way to do this is to just slice the string, as in the other answers.</p>
<p>But if you want a more concise way to write <em>your</em> code, which will work for similar problems that aren't as simple as slicing, there are two tricks: <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">comprehensions</a>, and the <a href="http://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> function.</p>
<p>First, this loop:</p>
<pre><code>for i in range(len(foo)):
    value = foo[i]
    something with value and i
</code></pre>
<p>… can be written as:</p>
<pre><code>for i, value in enumerate(foo):
    something with value and i
</code></pre>
<p>So, in your case:</p>
<pre><code>for i, c in enumerate(s):
    if (i%2)==0:
        b+=c
</code></pre>
<p>Next, any loop that starts with an empty object, goes through an iterable (string, list, iterator, etc.), and puts values into a new iterable, possibly running the values through an <code>if</code> filter or an expression that transforms them, can be turned into a comprehension very easily.</p>
<p>While Python has comprehensions for lists, sets, dicts, and iterators, it doesn't have comprehensions for strings—but <code>str.join</code> solves that.</p>
<p>So, putting it together:</p>
<pre><code>b = "".join(c for i, c in enumerate(s) if i%2 == 0)
</code></pre>
<p>Not nearly as concise or readable as <code>b = s[::2]</code>… but a lot better than what you started with—and the same idea works when you want to do more complicated things, like <code>if i%2 and i%3</code> (which doesn't map to any obvious slice), or doubling each letter with <code>c*2</code> (which could be done by zipping together two slices, but that's not immediately obvious), etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could try using slice and join:</p>
<pre><code>&gt;&gt;&gt; k = list(s)
&gt;&gt;&gt; "".join(k[::2])
'aceg'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Practically, slicing is the best way to go. However, there are also ways you could improve your existing code, not by making it shorter, but by making it more Pythonic:</p>
<pre><code>&gt;&gt;&gt; s
'abcdefg'
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for index, value in enumerate(s):
      if index % 2 == 0:
         b.append(value)
&gt;&gt;&gt; b = "".join(b)
</code></pre>
<p>or even better:</p>
<pre><code>&gt;&gt;&gt; b = "".join(value for index, value in enumerate(s) if index % 2 == 0)
</code></pre>
<p>This can be easily extended to more complicated conditions:</p>
<pre><code>&gt;&gt;&gt; b = "".join(value for index, value in enumerate(s) if index % 2 == index % 3 == 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another example both for list and string:</p>
<pre><code>sentence = "The quick brown fox jumped over the lazy dog."

sentence[::2]
</code></pre>
<p>Here we are saying: Take the entire string from the beginning to the end and return every 2nd character.</p>
<p>Would return the following:</p>
<pre><code>'Teqikbonfxjme vrtelz o.'
</code></pre>
<p>You can do the same for a list:</p>
<pre><code>colors = ["red", "organge", "yellow","green", "blue"]
colors[1:4]
</code></pre>
<p>would retrun:</p>
<pre><code>['organge', 'yellow', 'green']
</code></pre>
<p>The way I read the slice is: If we have <code>sentence[1:4]</code>
Start at index 1 (remember the starting position is index 0) and Stop BEFORE the index 4</p>
</div>
<span class="comment-copy">wow! that is really concise. although I know how slice works, I did not think of this..interestingly, all other answers too posted use slice notations</span>
<span class="comment-copy">@eagertoLearn: <a href="http://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">"There should be one-- and preferably only one --obvious way to do it."</a>. That's why all of the posted answers do the same thing.</span>
<span class="comment-copy">@abarnert: haha! thats the <code>zen of python</code> I guess..beautiful</span>
<span class="comment-copy">correct me if I am wrong: the one you had is not list comprehension right; it is generator expression, but this is list comprehension: <code>b = "".join([c for i, c in enumerate(s) if i%2 == 0])</code>. ofcourse, generator are best here. but just want to clarify. do not mistake me</span>
<span class="comment-copy">@user1988876: You're exactly right. Using parentheses (or nothing) makes a generator expression, square brackets makes a list comprehension, curly braces makes a set or dict comprehension.</span>
<span class="comment-copy">@user1988876: Also, in the case of passing to <code>str.join</code>, there's really no difference—if <code>str.join</code> gets something that isn't fast-indexable from C, it just makes a list out of it so it can fast-index it. In fact (especially before 3.4), counter-intuitively, the listcomp may even be faster and use less memory. But conceptually, I think it's clearer to not build a list when you don't need it. (And, unless you knew how <code>str.join</code> worked under the covers, you wouldn't know that you needed it.)</span>
<span class="comment-copy">Or just slice the string as it is</span>
<span class="comment-copy">@sweeneyrod: ofcourse, thats why my reputations are low :)</span>
<span class="comment-copy">But +1 from me anyway - <code>join</code>ing the string is an improvement over his current code.</span>
