<div class="post-text" itemprop="text">
<p>I am using recursion to get the permutation of a list. Here is what I wrote, but the <code>yield</code> version won't work:</p>
<pre><code>def test_permutation_rec():
    print "test 2"
    permutation_rec2([1,2,3],[])     
    print "test 1"
    for one in permutation_rec1([1,2,3],[]):
        print "one:",one 

def permutation_rec1(onelist,prelist):  
    if onelist == [] :
        print prelist
        yield prelist

    lenlist= len(onelist)
    for i, oneitem in enumerate(onelist) :
        leftlist = [onelist[j] for j in range(0,lenlist) if j != i]
        permutation_rec1(leftlist,prelist + [oneitem])

def permutation_rec2(onelist,prelist):
    if onelist == [] :
        print prelist

    lenlist= len(onelist)
    for i, oneitem in enumerate(onelist) :
        leftlist = [onelist[j] for j in range(0,lenlist) if j != i]
        permutation_rec2(leftlist,prelist + [oneitem])

if __name__ == "__main__":
    test_permutation_rec()
</code></pre>
<p>the result:</p>
<pre><code>test 2
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
test 1
</code></pre>
<p>I think I used <code>yield</code> like in <a href="https://stackoverflow.com/questions/104420/how-to-generate-all-permutations-of-a-list-in-python/104436#104436">this the answer</a>.</p>
<p>Can anyone tell me why <code>yield</code> doesn't take effect?</p>
<p>By the way, <code>leftlist = [onelist[j] for j in range(0,lenlist) if j != i]</code>
in <code>permutation_rec2</code>, is ugly I think. When the list is big, it creates many temporary lists. How can I improve that? </p>
</div>
<div class="post-text" itemprop="text">
<p>You need to pass on the results of the recursive call; each call returns a <em>generator</em> and you do have to iterate over that. The answer you linked to certainly loops over the recursive call too.</p>
<p>Add a <code>for</code> loop over <code>permutation_rec1()</code> and yield each resulting value on to the next caller:</p>
<pre><code>def permutation_rec1(onelist, prelist):  
    if not onelist:
        yield prelist

    lenlist = len(onelist)
    for i, oneitem in enumerate(onelist):
        leftlist = [onelist[j] for j in range(lenlist) if j != i]
        for res in permutation_rec1(leftlist, prelist + [oneitem]):
            yield res
</code></pre>
<p>If you are using Python 3.3 or newer, you can use the new <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator"><code>yield from</code> generator delegation syntax</a>:</p>
<pre><code>def permutation_rec1(onelist,prelist):  
    if not onelist:
        yield prelist

    lenlist = len(onelist)
    for i, oneitem in enumerate(onelist):
        leftlist = [onelist[j] for j in range(lenlist) if j != i]
        yield from permutation_rec1(leftlist, prelist + [oneitem])
</code></pre>
</div>
<span class="comment-copy">For future reference - if you actually need to get permutations, just use the <code>itertools</code> module.</span>
<span class="comment-copy">yes . your are right. something like <code>itertools.permutations([1,2,3])</code> can somebody find what about the tmplist i have post. Seem  it was not the best solution.</span>
<span class="comment-copy">Anything I'm missing and can add to make you un-accept my answer? :-)</span>
<span class="comment-copy">I review the answer yesterday. sorry may be misclick,</span>
