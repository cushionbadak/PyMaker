<div class="post-text" itemprop="text">
<p>If input is </p>
<pre><code>round_robin(range(5), "hello")
</code></pre>
<p>i need o/p as</p>
<pre><code>[0, 'h', 1, 'e', 2, 'l', 3, 'l', 4, 'o']
</code></pre>
<p>I tried</p>
<pre><code>def round_robin(*seqs):
list1=[]
length=len(seqs)
list1= cycle(iter(items).__name__ for items in seqs)
while length:
    try:
        for x in list1:
            yield x
    except StopIteration:
        length -= 1

pass
</code></pre>
<p>but it gives error as </p>
<pre><code>AttributeError: 'listiterator' object has no attribute '__name__'
</code></pre>
<p>How to modify the code to get the desired o/p</p>
</div>
<div class="post-text" itemprop="text">
<p>You could find a series of iteration recipes here: <a href="http://docs.python.org/2.7/library/itertools.html#recipes" rel="nofollow noreferrer">http://docs.python.org/2.7/library/itertools.html#recipes</a></p>
<pre><code>from itertools import islice, cycle


def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))


print list(roundrobin(range(5), "hello"))
</code></pre>
<p><strong>EDIT</strong>: Python 3</p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools-recipes</a></p>
<pre><code>def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))

print list(roundrobin(range(5), "hello"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a> function and then flatten the result with list comprehension, like this</p>
<pre><code>def round_robin(first, second):
    return[item for items in zip(first, second) for item in items]
print round_robin(range(5), "hello")
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[0, 'h', 1, 'e', 2, 'l', 3, 'l', 4, 'o']
</code></pre>
<p><code>zip</code> function groups the values from both the iterables, like this</p>
<pre><code>print zip(range(5), "hello") # [(0, 'h'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]
</code></pre>
<p>We take each and every tuple and flatten it out with list comprehension.</p>
<p>But as @Ashwini Chaudhary suggested, use <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="nofollow">roundrobin receipe from the docs</a></p>
<pre><code>from itertools import cycle
from itertools import islice
def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

print list(roundrobin(range(5), "hello"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can leverage <a href="http://docs.python.org/2/library/itertools.html#itertools.chain" rel="nofollow">itertools.chain</a> (to unwrap the tuples) with <a href="http://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow">itertools.izip</a> (to transpose the elements in order to create an interleaving pattern) to create your result</p>
<pre><code>&gt;&gt;&gt; from itertools import izip, chain
&gt;&gt;&gt; list(chain.from_iterable(izip(range(5), "hello")))
[0, 'h', 1, 'e', 2, 'l', 3, 'l', 4, 'o']
</code></pre>
<p>If the strings are of unequal length, use izip_longest with a pad value (preferably empty string)</p>
</div>
<div class="post-text" itemprop="text">
<p>list(roundrobin('ABC', 'D', 'EF'))</p>
<p><strong>Output :</strong> ['A', 'D', 'E', 'B', 'F', 'C']</p>
<pre><code>def roundrobin(*iterables):
    sentinel = object()
    from itertools import chain
    try:
        from itertools import izip_longest as zip_longest
    except:
        from itertools import zip_longest 
    return (x for x in chain(*zip_longest(fillvalue=sentinel, *iterables)) if x is not sentinel)  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For anyone looking for Python 3, use this</p>
<pre><code>def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))
</code></pre>
<p>The difference is that Python 3's iterator has <code>__next__()</code> instead of <code>next()</code>.
<a href="https://docs.python.org/3/library/itertools.html#recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#recipes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>A mixture of the two itertools roundrobin recipes for <a href="https://docs.python.org/2/library/itertools.html#recipes" rel="nofollow noreferrer">Python 2</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">Python 3</a> looks like this:</p>
<pre><code>from itertools import islice, cycle

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    num_active = len(iterables)
    try:
        iter([]).__next__  # test attribute
        nexts = cycle(iter(it).__next__ for it in iterables)
    except AttributeError:  # Python 2 behavior
        nexts = cycle(iter(it).next for it in iterables)
    while num_active:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            # Remove the iterator we just exhausted from the cycle.
            num_active -= 1
            nexts = cycle(islice(nexts, num_active))

print(list(roundrobin(range(5), "hello")))
</code></pre>
</div>
<span class="comment-copy"><code>[ i for t in  zip(range(5), "hello") for i in t]</code></span>
<span class="comment-copy"><code>roundrobin</code> recipe is already present in itertools's docs: <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html#recipes</a></span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/19883826/interleaving-2-lists-of-unequal-lengths">Interleaving 2 lists of unequal lengths</a></span>
<span class="comment-copy">it is not working for round_robin([1, 2], "a", (5, 6, 7), [4])</span>
<span class="comment-copy">@riteshbhat I obtain: [1, 'a', 5, 4, 2, 6, 7]. Which version of python are you running?</span>
<span class="comment-copy">python 2.7.6 This is my o/p    [1, 'a', 5, 4, 2, 6, &lt;itertools.cycle object at 0x025AD8C8&gt;]</span>
<span class="comment-copy">Im using python 2.7.5 but your o/p it's very strange. Are you sure you copied this code?</span>
<span class="comment-copy">Oh yeah ur code works perfect i has done small mistake. Thanks :)</span>
<span class="comment-copy">What if sequences are of unequal length?</span>
<span class="comment-copy">@thefourtheye I am making a function that takes variable arguments each time. How to do for that???</span>
<span class="comment-copy">@AshwiniChaudhary In that case, <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> terminates after the first sequence reached itâ€™s end. You can use <a href="http://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> to pad with <code>None</code> (or any other value).</span>
<span class="comment-copy">@JonasWielicki We don't pad with <code>None</code>(or any other value) in <code>roundrobin</code>, we need the item from next iterable in that case.</span>
