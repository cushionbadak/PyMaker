<div class="post-text" itemprop="text">
<p>The question is to remove negatives from numbers. </p>
<p>When <code>remove_negs([1, 2, 3, -3, 6, -1, -3, 1])</code> is executed, the result is: <code>[1, 2, 3, 6, -3, 1]</code>. The result is suppose to be <code>[1, 2, 3, 6, 3, 1]</code>. what is happening is that if there are two negative numbers in a row (e.g., <code>-1, -3</code>) then the second number will not get removed. 
    def main():
       numbers = input("Enter a list of numbers: ")
       remove_negs(numbers)</p>
<pre><code>def remove_negs(num_list): 
  '''Remove the negative numbers from the list num_list.'''
    for item in num_list: 
        if item &lt; 0: 
           num_list.remove(item) 

    print num_list

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's generally a bad idea to remove elements from a list while iterating over it (see <a href="http://arshajii.com/coding-faqs/conc-list-mod.html" rel="noreferrer">the link</a> in my comment for an explanation as to why this is so). A better approach would be to use a <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>:</p>
<pre><code>num_list = [item for item in num_list if item &gt;= 0]
</code></pre>
<p>Notice that the line above creates a <em>new</em> list and assigns <code>num_list</code> to that. You can also do an "in-place" assignment of the form</p>
<pre><code>num_list[:] = ...
</code></pre>
<p>which does not create a new list in memory, but instead modifies the memory location already being pointed to by <code>num_list</code>. This difference is explained in more detail <a href="https://stackoverflow.com/questions/10155951/what-is-the-difference-between-slice-assignment-that-slices-the-whole-list-and-d">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Much simpler:</p>
<pre><code>&gt;&gt;&gt; a = [ 1, 2, 3, -3, 6, -1, -3, 1]
&gt;&gt;&gt; [x for x in a if x &gt;= 0 ]
[1, 2, 3, 6, 1]
</code></pre>
<p>If you really do want to loop, try this:</p>
<pre><code>def remove_negs(num_list): 
    r = num_list[:]
    for item in num_list: 
        if item &lt; 0: 
           r.remove(item) 
    print r
</code></pre>
<p>This does what you want:</p>
<pre><code>&gt;&gt;&gt; remove_negs([ 1, 2, 3, -3, 6, -1, -3, 1])
[1, 2, 3, 6, 1]
</code></pre>
<p>The key is that the assignment statement <code>r = num_list[:]</code> makes a copy of num_list.  In order not to confuse the loop, We then remove items from <code>r</code> rather than from the list we are looping over.</p>
<p><strong>More:</strong>  Python's treatment of variables is a bit subtle.  Python keeps variable names, like <code>r</code> or <code>num_list</code> separate from variable data, such as <code>[1, 2, 3, 6, 1]</code>.  The names are merely pointers to the data.  Consider the assignment statement:</p>
<pre><code>r = num_list
</code></pre>
<p>After this statement is run, <code>r</code> and <code>num_list</code> both point to the same data.  If you make a change to <code>r</code>'s data, you are also making a change to <code>num_list</code>'s data because they both point to the <em>same</em> data.  Now, consider:</p>
<pre><code>r = num_list[:]
</code></pre>
<p>This statement tells python to modify <code>num_list</code>'s data by taking only certain elements of it.  Because of this, python makes a copy of <code>num_list</code>'s data.  It just so happens that <code>[:]</code> specifies that we want all of <code>num_list</code>'s data unchanged but that doesn't stop python from making a copy.  The copy is assigned to <code>r</code>.  This means that <code>r</code> and <code>mum_list</code> now point to <em>different</em> data.  We can make changes to <code>r</code>'s data and it doesn't affect <code>num_list</code>'s data because they have <em>different</em> data.</p>
<p>If this is new to you, you might want to look at this tutorial about python's approach to variable names and variable data:  <a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" rel="noreferrer">Understanding Python variables and Memory Management</a></p>
<p><strong>Examples:</strong></p>
<pre><code>&gt;&gt;&gt; a = [ 1, 2, 3, -3, 6, -1, -3, 1]
&gt;&gt;&gt; b = a   # a and b now point to the same place
&gt;&gt;&gt; b.remove(-1) 
&gt;&gt;&gt; a
[1, 2, 3, -3, 6, -3, 1]
</code></pre>
<p>Contrast with:</p>
<pre><code>&gt;&gt;&gt; a = [ 1, 2, 3, -3, 6, -1, -3, 1]
&gt;&gt;&gt; b = a[:] # a and b now point to different data
&gt;&gt;&gt; b
[1, 2, 3, -3, 6, -1, -3, 1]
&gt;&gt;&gt; b.remove(-1)
&gt;&gt;&gt; b
[1, 2, 3, -3, 6, -3, 1]
&gt;&gt;&gt; a
[1, 2, 3, -3, 6, -1, -3, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another solution</p>
<pre><code>filter( lambda x: x&gt;0, [ 1, 2, 3, -3, 6, -1, -3, 1])
[1, 2, 3, 6, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From a comment on arshajii's answer:</p>
<blockquote>
<p>but that's removing the negative numbers. i need the negative signs removed but still keep the number in the list.</p>
</blockquote>
<p>Removing the negative numbers is exactly what your code is clearly trying to do, and it's also the only way to get the desired result:</p>
<blockquote>
<p>THe result is suppose to be [1, 2, 3, 6, 3, 1]</p>
</blockquote>
<p>But if you really want to "remove the negative signs" from the numbers, that's even easier. For example, to remove the negative sign from <code>-3</code>, you just negate it and get <code>3</code>, right? You can do this in-place, as in your existing code:</p>
<pre><code>for index, item in enumerate(num_list): 
    if item &lt; 0: 
       num_list[index] = -item
</code></pre>
<p>… or in a list comprehension, as in arshajii's:</p>
<pre><code>num_list = [-item if item &lt; 0 else item for item in num_list]
</code></pre>
<p>And it's even easier with the <code>abs</code> function, which does exactly that—negates negative numbers, leaves positive and zero alone:</p>
<pre><code>num_list = [abs(item) for item in num_list]
</code></pre>
<p>Either way, of course, this will give you <code>[1, 2, 3, 3, 6, 1, 3, 1]</code>, which is the wrong answer… but if your comment is correct, it's the answer you asked for.</p>
</div>
<div class="post-text" itemprop="text">
<p>Other the the conventional <code>variable operator non-variable</code> Try some <a href="http://en.wikipedia.org/wiki/Yoda_conditions" rel="nofollow">yoda conditions</a> too =)</p>
<pre><code>&gt;&gt;&gt; [i for i in x if 0 &lt;= i]
[1, 2, 3, 6, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>to strip the numbers off their negative signs, this is the easiest thing to do</p>
<pre><code>def remove_negs(somelist):
    for each in somelist:
        if each &lt; 0:
            somelist[somelist.index(each)] = -each
    print(somelist)
</code></pre>
<p>for example </p>
<blockquote>
<p>rNegatives([-2,5,11,-1]) </p>
</blockquote>
<p>prints out </p>
<blockquote>
<p>[2,5,11,1]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I think an elegant solution can be like this:</p>
<pre><code>import numpy as np

x = [1, 2, 3, -3, 6, -1, -3, 1] # raw data
x = np.array(x) # convert the python list to a numpy array, to enable 
                  matrix operations 
x = x[x &gt;=0] # this section `[x &gt;=0]` produces vector of True and False 
               values, of the same length as the list x
             # as such, this statement `x[x &gt;=0]` produces only the 
               positive values and the zeros

print(x)   
[1 2 3 6 1] # the result
</code></pre>
</div>
<span class="comment-copy">Sounds like a good job for a list comprehension which checks for val &gt;= 0.</span>
<span class="comment-copy">Don't remove items from a list you are iterating over as that changes the index of the items and you could end up skipping over some of the elements.</span>
<span class="comment-copy">As others said, don't change the content of data container while you are iterating over it. Iterate over a copy - for item in list(num_list):</span>
<span class="comment-copy">Also, you should not call <code>remove</code> to delete an item when you already know where it is. This is (a) potentially wrong, because <code>remove</code> deletes the first item that's equal to <code>item</code>, which may not be the one you want, and (b) slow, because it means you have to search the whole list to find the item even though you already knew where it was. <code>del num_list[index]</code> is always better. But how do you know the index? Simple: <code>for index, item in enumerate(num_list):</code>. (This is all a side note; it won't solve your actual problem… but there are already good answers and comments for that.)</span>
<span class="comment-copy">I don't think the OP actually needs to mutate <code>num_list</code> here, so the original version (without the slice assignment) was probably fine. Maybe it would be even better to show both and explain the difference?</span>
<span class="comment-copy">@abarnert Yes, perhaps you're right. I'll edit to explain the difference.</span>
<span class="comment-copy">@user3161743: You said "THe result is suppose to be <code>[1, 2, 3, 6, 3, 1]</code>." That's exactly what arshajii's code produces. If you did it the way you're claiming to want, the result would be <code>[1, 2, 3, 3, 6, 1, 3, 1]</code>.</span>
<span class="comment-copy">what does [:] do?</span>
<span class="comment-copy">@user3161743  Good question.  See updated answer.</span>
