<div class="post-text" itemprop="text">
<p>I was trying to normalize a simple numpy array <code>a</code> as follows:</p>
<pre><code>a = np.ones((3,3))

cv2.normalize(a)
</code></pre>
<p>On running this, OpenCV throws an error saying <code>TypeError: Required argument 'dst' (pos 2) not found</code>. So I put the <code>dst</code> argument as also mentioned in the <a href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html" rel="nofollow noreferrer">documentation</a>. Here is how I did:</p>
<pre><code>b = np.asarray([])
cv2.normalize(a, b)
</code></pre>
<p>This call returns the normalized array but the value of <code>b</code> is still empty. Why is it so? </p>
<p>On the other hand, if I try the following:</p>
<pre><code>b = np.copy(a)

cv2.normalize(a,b)
</code></pre>
<p>The values in <code>b</code> are now filled with normalized values. I just wanted to understand this behaviour of OpenCV. Why does it not fill <code>b</code> when it is empty / shape is not the same as <code>a</code>? Why doesn't OpenCV throw an error?</p>
</div>
<div class="post-text" itemprop="text">
<p>You would need to assign the result of <code>cv2.normalize</code> back to a variable, in the first example. From <a href="https://docs.opencv.org/master/d2/de8/group__core__array.html#ga87eef7ee3970f86906d69a92cbf064bd" rel="nofollow noreferrer">the docs</a>, the signature for <code>cv2.normalize()</code> is:</p>
<pre><code>dst = cv.normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]])
</code></pre>
<p>You'll notice that <code>dst</code> is both an input and return value from the function. This means that you can either input a <code>dst</code> array into the function, and it will be modified in-place, <em>or</em>, you can pass <code>None</code> or a blank array for that argument when calling the function, and a new array will be created and returned. </p>
<hr/>
<p>To be a little more specific, if you're not very familiar with C++: in C++, you generally only return primitives (e.g. integers) or pointers from functions. It's not as easy like Python where you can just return any number of whatever objects you want; you have to stuff them into a container and return a pointer to that container, for example. So, the more common thing is for you to pass the object to the function directly, and the function will just modify the object instead of worrying about returns and all this nonsense. Furthermore, this means that the function isn't creating objects behind the scenes that you don't know about. Instead <em>you</em> control object creation and instantiation, and you pass them into the function.</p>
<p>It is much less common (though still possible) in Python to pass mutable arguments into functions with the understanding that they will be modified. </p>
<p>Since the bindings for OpenCV are automatically generated from the C++ libraries, the functions have the ability to be used in either of these ways; you can initialize an array of the right size/shape, pass it in, and have it be mutated (the standard C++ way), <em>or</em> you can pass in <code>None</code> or a blank array, and it will instead <em>return</em> the output array (the standard Python way).</p>
<p>This is actually very common all throughout the OpenCV library. If you see the same input as one of the outputs and you don't need to use it to initialize the function, you can basically always send <code>None</code> for that argument.</p>
<hr/>
<p>I'm not sure the philosophical reason of <em>why</em> OpenCV chooses to not throw an error if you pass in totally bogus arrays there, though that type of question isn't really a good format for this site. Additionally, errors are not very consistent in OpenCV, where they are extremely strict on assertions for function argument checking, but will happily return a null pointer if you try and read an image that doesn't exist. Anyways, what ends up happening for the cases of the wrong shape/type is simply that the argument is ignored. The argument is only mutated if it's the correct shape/type. You can imagine the equivalent of something like this happening:</p>
<pre class="lang-py prettyprint-override"><code>In [29]: a = np.eye(3, dtype=np.float64)

In [30]: b = np.eye(3, dtype=np.uint8)  # different dtype

In [31]: c = np.eye(2)  # different shape

In [32]: d = 'asdf'  # not even an array

In [33]: cv2.normalize(a, b)
Out[33]:
array([[0.57735027, 0.        , 0.        ],
       [0.        , 0.57735027, 0.        ],
       [0.        , 0.        , 0.57735027]])

In [34]: b  # not modified because different dtype
Out[34]:
array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1]], dtype=uint8)

In [35]: cv2.normalize(a, c)
Out[35]:
array([[0.57735027, 0.        , 0.        ],
       [0.        , 0.57735027, 0.        ],
       [0.        , 0.        , 0.57735027]])

In [36]: c  # not modified because different shape
Out[36]:
array([[1., 0.],
       [0., 1.]])

In [37]: cv2.normalize(a, d)  # error because it's not convertible to a `cv::UMat`
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-37-642f9bb78a6b&gt; in &lt;module&gt;
----&gt; 1 cv2.normalize(a, d)

TypeError: Expected cv::UMat for argument 'dst'
</code></pre>
<p>But when we have the right combination of shape and dtype:</p>
<pre class="lang-py prettyprint-override"><code>In [38]: e = np.empty_like(a)   # same dtype/shape as a

In [39]: cv2.normalize(a, e)
Out[39]:
array([[0.57735027, 0.        , 0.        ],
       [0.        , 0.57735027, 0.        ],
       [0.        , 0.        , 0.57735027]])

In [40]: e  # mutated
Out[40]:
array([[0.57735027, 0.        , 0.        ],
       [0.        , 0.57735027, 0.        ],
       [0.        , 0.        , 0.57735027]])
</code></pre>
</div>
