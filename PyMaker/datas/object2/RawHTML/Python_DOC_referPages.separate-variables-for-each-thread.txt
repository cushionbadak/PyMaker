<div class="post-text" itemprop="text">
<p>I have a problem with values being passed from threads to threads. I just want that every thread once started has the variable with the thread-only values. For example, if I have a <code>requests.session</code>, I don't want that the session for Thread 1 and 2 are the same.</p>
<pre><code>import requests
import threading

def functionName():
   s=requests.session()
   r=s.get("") #get a random site
   #do some things

if __name__== "__main__":
    t=threading.Thread(target=functionName)
    tt=threading.Thread(target=functionName)
    t.start()
    tt.start()
</code></pre>
<p>If I add other actions instead of <code>#do some things</code> and save the whole results in a file, it looks like the two threads got merged and worked in an unique session, even if I want the 2 sessions being separate for each Thread. </p>
</div>
<div class="post-text" itemprop="text">
<p>From your description of the problem and the fact that <code>r</code> and <code>s</code> <em>are</em> already local to each thread (as @Solomon Slow pointed-out in a comment), I suspect the problem is with how you're obtaining the results from each thread. </p>
<p>Since you haven't provided a <a href="https://stackoverflow.com/help/mcve">MCVE</a>, I made up something to show one way that can be done. In it, the results of each thread are stored in a shared global dictionary named <code>merged</code>. As you can see from the output, the two threads did not interfere with one another.</p>
<pre><code>from ast import literal_eval
import requests
import threading
from random import randint


def functionName(thread_name, shared, lock):
    s = requests.Session()
    sessioncookie = str(randint(100000000, 123456789))
    s.get('https://httpbin.org/cookies/set/sessioncookie/' + sessioncookie)
    r = s.get('https://httpbin.org/cookies')
    r_as_dict = literal_eval(r.text)

    print('r_as_dict:', r_as_dict)

    # Store result in shared dictionary.
    with lock:
        shared[thread_name] = r_as_dict['cookies']['sessioncookie']


if __name__ == '__main__':

    merged = {}
    mlock = threading.Lock()  # Control concurrent access to "merged" dict.

    t=threading.Thread(target=functionName, args=('thread1', merged, mlock))
    tt=threading.Thread(target=functionName, args=('thread2', merged, mlock))
    t.start()
    tt.start()
    t.join()
    tt.join()

    print(merged)
</code></pre>
<p>Sample output:</p>
<pre class="lang-none prettyprint-override"><code>r_as_dict: {'cookies': {'sessioncookie': '111147840'}}
r_as_dict: {'cookies': {'sessioncookie': '119511820'}}
{'thread1': '111147840', 'thread2': '119511820'}
</code></pre>
</div>
<span class="comment-copy">I think you are talking about data race right?, if it is you can create a lock function to prevent this data race condition. Ex: <code>def locking_increment():     with db.get_lock():         return increment() </code></span>
<span class="comment-copy">You could also think about using processes instead of threads because processes don't share memory</span>
<span class="comment-copy">The variables, <code>r</code> and <code>s</code>, are <i>local</i> variables. They aren't shared between threads.  So if there's any problem here, it's in the implementation of <code>requests.session()</code> or in the implementation of <code>s.get()</code>. What do those functions look like?</span>
<span class="comment-copy">I think @SolomonSlow's point about <code>r</code> and <code>s</code> already being local variables is correct, but doubt the "problem" is because of the way <code>session</code> and <code>get</code> are implemented â€” and instead suspect it's due to whatever <code>#do something things</code> is (and/or code in the main thread also not shown). It's impossible to tell for sure without a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
