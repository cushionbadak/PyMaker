<div class="post-text" itemprop="text">
<p>I'm working on a project where I'd need to generate a list of strings based on a pattern and range defined inline.</p>
<p>Say I have the following string:</p>
<pre><code>"NAME_{1:2}_{3:5}"
</code></pre>
<p>each bracket defining both lower and upper limits. </p>
<p>The generated result should be:</p>
<pre><code>["NAME_1_3", "NAME_1_4", "NAME_1_5", "NAME_2_3", "NAME_2_4", "NAME_2_5"]
</code></pre>
<p>Ideally it should handle scenarios like these seamlessly:</p>
<ol>
<li>"NAME" =&gt; ["NAME"]</li>
<li>"NAME_{1:2}" =&gt; ["NAME_1", "NAME_2"]</li>
</ol>
<p>The convention used is arbitrary, so I'd happy to use alternatives if that makes parsing easier with some lib as long as the definition is self-contained in a string.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're looking for is a <a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow noreferrer">Cartesian product</a>. It essentially gives all possible combinations of two list inputs. Thankfully, Python's <code>itertools</code> library has a built-in <code>product</code> class that can act as an iterator. So now we want to do this in 3 steps: </p>
<ol>
<li>Parse the string</li>
<li>Generate the Cartesian product</li>
<li>Reconstruct the string</li>
</ol>
<h2>1. Parse the string</h2>
<p>As I'm assuming you can have any number of <code>{x:y}</code>s, we'll use a while loop</p>
<pre><code>def parse_string(string): 
    index_of_ = string.find ("_")
    name = string [:index_of_]
    if index_of_ == -1: return name, []
    ranges = []
    while index_of_ != -1:  # still an _
        next_underscore = string.find ("_", index_of_ + 1)
        if next_underscore == -1:  # last underscore
            range_ = string [index_of_ + 1:]
        else: range_ = string [index_of_ + 1:next_underscore]
        start = range_ [1 : range_.find (":")]
        end = range_ [range_.find (":") + 1 : -1]
        ranges.append (tuple (range (int (start), int (end) + 1)))  # put all those numbers in
        if next_underscore == -1: break
        else: index_of_ = next_underscore
    return name, ranges
</code></pre>
<p>This function loops over the string, extracts the name, and iteratively finds the ranges. It returns the name and a list of all the ranges, so for your example -- NAME, [(1, 2), (3, 4, 5)]</p>
<p><h2>2. Generate the combos</h2> Now that we have a list of all the ranges, let's get the cartesian product of that list.   </p>
<pre>from itertools import product   
    def generate_combos(ranges): 
        return product (*ranges)  # unpack the list</pre>
<p>This just helps us pass the list to <code>product</code>, which does all the hard work.</p>
<h2>3. Generating the string</h2>
<p>Here we need a function to bring the other two together. First it parses the string to get the ranges and the name. Then, for every combination of the Cartesian product, it iteratively adds the digit to the name, then stores the result: </p>
<pre><code>def generate_string(string): 
    name, ranges = parse_string (string)
    results = []
    for combo in generate_combos (ranges):
        result = name
        for num in combo: 
            result += f"_{num}"
        results.append (result)
    return results
</code></pre>
<p>An example: </p>
<pre><code>print (generate_string ("NAME_{1:2}_{3:5}"))
</code></pre>
<p>Gives: </p>
<pre><code>['NAME_1_3', 'NAME_1_4', 'NAME_1_5', 'NAME_2_3', 'NAME_2_4', 'NAME_2_5']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another (a bit more compact) way:</p>
<pre><code>name, first, second = a.split('_')
first_range = range(int(first[1]), int(first[3]) + 1)
second_range = range(int(second[1]), int(second[3]) + 1)

res = ['{}_{}_{}'.format(name, i, j) for j in second_range for i in first_range]
# ['NAME_1_3', 'NAME_2_3', 'NAME_1_4', 'NAME_2_4', 'NAME_1_5', 'NAME_2_5']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most elegant and dynamic way I could think of solving this problem was using recursion:</p>
<pre><code>import re

a = "NAME_{1:2}_{3:5}"
b = "NAME_{1:2}"
c = "NAME"
d = "NAME_{1:2}_{3:4}_{7:8}"

def recure(myRanges, myString, varReference):

    if not myRanges:
        varReference.append(myString)
        return

    for i in myRanges[0]:
        tempVar = myRanges[:]
        del tempVar[0]
        recure(tempVar, myString + "_" + str(i), varReference)


def getMyList(myInput):
    myInputList = list(myInput)

    a = [i.start() for i in re.finditer('{', myInput)]

    try:
        myName = myInput[:a[0] - 1]
    except:
        myName = myInput

    myRanges = [range(int(myInputList[i + 1]), int(myInputList[i + 3]) + 1) for i in a]

    myList = []

    recure(myRanges, myName, myList)

    return myList

print(getMyList(a)) # -&gt; ['NAME_1_3', 'NAME_1_4', 'NAME_1_5', 'NAME_2_3', 'NAME_2_4', 'NAME_2_5']
print(getMyList(b)) # -&gt; ['NAME_1', 'NAME_2']
print(getMyList(c)) # -&gt; ['NAME']
print(getMyList(d)) # -&gt; ['NAME_1_3_7', 'NAME_1_3_8', 'NAME_1_4_7', 'NAME_1_4_8', 'NAME_2_3_7', 'NAME_2_3_8', 'NAME_2_4_7', 'NAME_2_4_8']
</code></pre>
<p><strong>Original Post</strong></p>
<p>Something like the following does the trick</p>
<pre><code>a = "NAME_{1:2}_{3:5}"
aList = list(a)

myString = a[:a.find("_")]

startI = int(aList[a.find("{") + 1])
endI = int(aList[a.find("}") - 1]) + 1

startII = int(aList[a.rfind("{") + 1])
endII = int(aList[a.rfind("}") - 1]) + 1

myList = []

for i in range(startI, endI):
    for j in range(startII, endII):
        myList.append(myString + "_" + str(i) + "_" + str(j))

print(myList) # -&gt; ['NAME_1_3', 'NAME_1_4', 'NAME_1_5', 'NAME_2_3', 'NAME_2_4', 'NAME_2_5']
</code></pre>
</div>
<span class="comment-copy">Got it, it's just gonna take a sec to type...</span>
<span class="comment-copy">Seeing the down votes, any tip on how to improve the question? More than going after a trivial implementation (like iterating on a list of list) I'm more interested in alternatives which could provide a more compact and pythonic way to solve this</span>
<span class="comment-copy">The reason I downvoted was because there was no code on your part. SO has a strict requirement that you post some code to show your work, instead of us working from scratch. This way, we can also help if there is no <i>one</i> library to do this, at least help with your existing code</span>
<span class="comment-copy">Fair enough, perhaps I failed to emphasize that I was keen on getting alternative definitions on my string formatting if that would ease the parsing (I'm fairly new to Python)</span>
<span class="comment-copy">@DaneelOlivaw I guess you have solved your Problem. However, for the purpose of widening your horizon have a look at my edited example using recursion.</span>
<span class="comment-copy">Thanks a lot for such thorough reply. The Cartesian product is what I need to generate indeed. I'm a bit concerned about the code it'd take to parse the string, so I'm thinking that perhaps I'm not defining an easy enough format to deal with. Given that I have complete freedom on this perhaps I should go towards something simpler like "NAME_${X}_${Y}:[1,2]:[2,4]" or similar which would make the parsing simpler while keeping all the information in a single string, and also making use of template substitution. Thanks again, I'll definitely take many tips from your answer</span>
<span class="comment-copy">Well, as long as you loop instead of expecting anything, you're current syntax is perfect because you can find what you're looking for instead of blindly hoping it's there. Plus any error you get will be really detailed</span>
<span class="comment-copy">OP needs this to handle 0, 1, 2, or more ranges</span>
<span class="comment-copy">Indeed, ranges are variable, and also I'd do the parsing on the {X:Y} sequence, as otherwise strings like "NAME_LAST_{2:3}-{1:3}" would fail. In a way, this looks like the opposite of finding a regex to match a sample of strings so I was wondering if there isn't a library doing something like this</span>
<span class="comment-copy">Thanks, I had a similar idea in mind but being new to Python I was wondering if there was a better way to define this format and thus produce the sequence in a more succinct way, or even natively?</span>
<span class="comment-copy">This acts unexpectedly when given only one input, or none, as the OP required.</span>
