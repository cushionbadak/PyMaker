<div class="post-text" itemprop="text">
<p>I am trying to distribute a <code>mplstyle</code> I wrote such that I can share it easily. It boils down to copying a text file to the proper configuration direction (which is known for any architecture) during installation. I want to be able to install using either <code>python setup.py install</code> or <code>pip install ...</code>. Currently I do not seem to get either of the two ways robust (see current approach below).</p>
<ul>
<li>Installing with <code>pip install ...</code> does not seem to invoke the copying at all.</li>
<li><p>Installing with <code>python setup.py install</code> works well on my machine, but ReadTheDocs gives me the following error:</p>
<pre><code>python setup.py install --force

running install
error: [Errno 2] No such file or directory: u'/home/docs/.config/matplotlib/stylelib/goose.mplsty
</code></pre></li>
</ul>
<p>What is the proper way to copy configuration files during installation in a robust way? </p>
<h1>Current approach</h1>
<h2>File structure</h2>
<pre><code>setup.py
goosempl/
| __init__.py
| stylelib/
  | goose.mplstyle
  | ...
</code></pre>
<h2><code>setup.py</code></h2>
<pre><code>from setuptools                 import setup
from setuptools.command.install import install

class PostInstallCommand(install):

  def run(self):

    import goosempl
    goosempl.copy_style()

    install.run(self)

setup(
  name              = 'goosempl',
  ...,
  install_requires  = ['matplotlib&gt;=2.0.0'],
  packages          = ['goosempl'],
  cmdclass          = {'install': PostInstallCommand},
  package_data      = {'goosempl/stylelib':['goosempl/stylelib/goose.mplstyle']},
)
</code></pre>
<h2><code>goosempl/__init__.py</code></h2>
<pre><code>def copy_style():

  import os
  import matplotlib

  from pkg_resources import resource_string

  files = [
    'stylelib/goose.mplstyle',
  ]

  for fname in files:
    path = os.path.join(matplotlib.get_configdir(),fname)
    text = resource_string(__name__,fname).decode()

    print(path, text)

    open(path,'w').write(text)
</code></pre>
<h2>Upload to PyPi</h2>
<pre><code>python setup.py bdist_wheel --universal
twine upload dist/*
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, based on the project structure you've provided, you're not specifying the <code>package_data</code> correctly. If <code>goosempl</code> is a package and <code>stylelib</code> a directory inside it containing the <code>mplstyle</code> files (what I assume from your code), then your <code>package_data</code> configuration line should be:</p>
<pre><code>package_data = {'goosempl': ['stylelib/goose.mplstyle']},
</code></pre>
<p>As described in <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files" rel="nofollow noreferrer">Building and Distributing Packages with Setuptools</a>:</p>
<blockquote>
<p>The <code>package_data</code> argument is a dictionary that maps from package names to lists of glob patterns. The globs may include subdirectory names, if the data files are contained in a subdirectory of the package.</p>
</blockquote>
<p>So your package is <code>goosempl</code> and <code>stylelib/goose.mplstyle</code> is the file to be included in package data for <code>goosempl</code>.</p>
<p>Your second issue (<code>No such file or directory</code>) is simple: in the <code>copy_style()</code> function, you never check if the parent directory of the file exists before writing the file. You should be able to reproduce this locally by removing the directory <code>/home/&lt;user&gt;/.config/matplotlib/stylelib/</code> (or moving it temporarily).</p>
<p>The fix is also quite simple, actually there are lots of them. Use whatever you want to create missing directories.</p>
<ul>
<li><p><a href="https://docs.python.org/3.6/distutils/apiref.html#distutils.dir_util.mkpath" rel="nofollow noreferrer"><code>distutils.dir_util.mkpath</code></a> is suitable for both <code>python2</code> and <code>python3</code>:</p>
<pre><code>for fname in files:
    path = os.path.join(matplotlib.get_configdir(), fname)
    distutils.dir_util.mkpath(os.dirname(path))
</code></pre></li>
<li><p>My preferred one is using <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a>, but it is available only since Python 3.4:</p>
<pre><code>for fname in files:
    path = pathlib.Path(matplotlib.get_configdir(), fname)
    path.parent.mkdir(parents=True, exist_ok=True)
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Thanks, this solves most of my problems. I used <code>os</code> in the end: <code>if not os.path.isdir(os.path.dirname(path)): os.makedirs(os.path.dirname(path))</code> (notice the small bug on my side). It does not, however, seem to fix the problem with pip. Installing from PyPi with pip does not seems to invoke the <code>PostInstallCommand</code> command. (It is only invoked on my machine before uploading to PyPi).</span>
<span class="comment-copy">The <code>install</code> command won't be invoked by <code>pip</code>. It does not install from source by design. Instead, it builds a wheel and installs from it - but <code>wheel</code> format does not use the setup script - it does not even include it. So your <code>PostInstallCommand</code> won't be called.</span>
<span class="comment-copy">OK, I understand. Is there a way to copy these configuration files upon installing with <code>pip</code>? I understand that one can just include the copying command such that it is always invoked upon including the library, but this is really not what I am looking for as (i) this results in unnecessary checks that are run over and over, and (ii) in my particular case I want users to load the style, without ever needed to include the library.</span>
<span class="comment-copy">Unfortunately, in your case there isn't - you want to place the file outside of the <code>site-packages</code> directory, and <code>wheel</code> doesn't allow that. See my <a href="https://stackoverflow.com/a/47465374/2650249">other answer</a> to a similar question - the OP wanted to place a config file in the user's home dir on installation. The only workaround for that is not to build wheels in first place, building a source tar/zip/bz2 instead, and on installation tell <code>pip</code> not to build a wheel out of source distribution with the <code>--no-binary</code> flag.</span>
<span class="comment-copy">Thanks. That's a bit disappointing, but I guess what it is.</span>
