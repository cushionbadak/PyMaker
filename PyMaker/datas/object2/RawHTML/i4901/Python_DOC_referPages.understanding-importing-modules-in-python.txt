<div class="post-text" itemprop="text">
<p>It seems that I am still missing some basics of python. I was trying to understand <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow noreferrer">submodules importing</a>, which I feel I have not understood yet. But I have also stumbled upon something new.</p>
<p>I am having following two packages in two different PyDev projects:</p>
<pre><code>package1
|
+--mod1.py
|
+--mod2.py


package2
|
+--__init__.py
|
+--modx.py
|
+--mody.py
</code></pre>
<p>In <code>mod1</code>, I can do <code>import mod2</code>. But in <code>__init__</code> and <code>modx</code>, I cannot do <code>import mody</code> (Eclipse says "unresolved imports"). In <code>__init__</code>, I can do <code>import .mody</code> or <code>from .mody import vary</code>. In <code>modx</code>, I cannot do <code>import .mody</code>. (In fact I never saw use of <code>.</code> in <code>import</code> statement as prefix to the module. Earlier I only came across <code>import mod</code> and <code>from mod import var</code>, but never saw <code>import .mod</code> and <code>from .mod import var</code>.) Why this might be happening? I must be unaware some context which is causing this behaviour. But then I dont know what is it?</p>
<p>PS: I am using Python 3.4</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a subtle different between how Python is treating both of those packages.</p>
<p><code>package1</code> is treated as a <strong>namespace</strong> package in that it <strong>does not</strong> contain an <code>__init__.py</code> file.</p>
<p><code>package2</code> is treated as a <strong>regular</strong> package in that it <strong>does</strong> contain an <code>__init__.py</code> file.</p>
<p>So I'll give a quick breakdown of why each step is happening:</p>
<blockquote>
<p>In mod1, I can do import mod2.</p>
</blockquote>
<p>This is happening due to how <strong>namespace</strong> packages are handled using absolute imports. You're most likely executing <code>python mod1.py</code> from the directory in which the file is stored, right (in my attempt to re-create your folder structure and test it myself locally, I did the same)? So <code>package1</code> becomes your <strong>current working directory</strong> with your <code>mod2</code> file being at the root of that directory.</p>
<p>With namespace packages, Python will default look to <code>sys.path</code> in an attempt to find the imports you have requested. Since your current working directory is automatically added to and included in <code>sys.path</code>, Python can successfully find your <code>import mod2</code> request without any difficulty.</p>
<p><strong>Thanks to ShadowRanger for correcting my initial response to this where I had misunderstood exactly how Python is including the current working directory in its search.</strong></p>
<blockquote>
<p>In <strong>init</strong>, I can do import .mody or from .mody import vary.</p>
</blockquote>
<p>This is because Python is treating this as a <strong>regular</strong> package. The name of your regular package in this case is <code>package2</code>. When you use the <code>.</code> notation, you are asking Python to start searching for the import from the <strong>current</strong> package (which in this case is your parent <code>package2</code>). So you have to use <code>import .mody</code> to find the <code>mody</code> package within the current package.</p>
<p>If you used <code>..</code> then it would import from the parent of the current package and so on.</p>
<p>The dot notation is useful as you are explicitly declaring that you wish to search from the current package only - so if there was another <code>package2</code> package on your <code>PYTHONPATH</code>, Python would know which one to choose.</p>
<blockquote>
<p>But in <strong>init</strong> and modx, I cannot do import mody (Eclipse says "unresolved imports").</p>
</blockquote>
<p>With <code>__init__.py</code> this is because you have not used the dot notation and have not told Python that you wish to search for these modules in the <strong>current</strong> package. So it's looking to the Python standard library and to your <code>PYTHONPATH</code> for these packages and not finding them (hence your error in Eclipse). By using the dot notation, you are stating that you wish to include the current package in the search and, thus, Python will then be able to locate those files.</p>
<p>Using the dot notation like this, to import via <code>from . import mody</code>, is to use a <strong>relative import</strong>.</p>
<p>With <code>modx</code> you also have to use a relative import (see next section).</p>
<blockquote>
<p>In modx, I cannot do import .mody. Why this might be happening?</p>
</blockquote>
<p>This is because you're not using a <strong>relative / absolute import</strong>. You'll be using a relative import in this case. A relative import is the <code>from . import mody</code> syntax you've seen already. Using a relative or absolute import behaviour is default in Python.</p>
<p>It is now the default behaviour as, with the old Python <code>import</code> behaviour, suppose Python's own standard library had a package called <code>mody</code>. When you'd use <code>import mody</code> it would previously have imported <code>mody</code> from your package and <strong>not</strong> the standard library. This wasn't always desirable. What if you specifically wanted the standard library version?</p>
<p>So now your imports must be made using <code>from . import mody</code> or <code>from .mody import vary</code> syntax so as the import is very clear. If you use <code>import</code> and not the <code>from...</code> syntax, Python will assume it's a standard library or <code>PYTHONPATH</code> import.</p>
<p>By the way, sources for a lot of the above information came from the following sites:</p>
<p><a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">https://docs.python.org/3/reference/import.html</a></p>
<p><a href="https://docs.python.org/2.5/whatsnew/pep-328.html" rel="nofollow noreferrer">https://docs.python.org/2.5/whatsnew/pep-328.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python modules are optional "additions" to Python that can be imported using the <code>import</code> command like so:</p>
<pre><code>import package1
package1.mod1   # Can be accessed using this
</code></pre>
<p>To import individual parts of the package, use <code>from</code> like so:</p>
<pre><code>from package1 import mod1
mod1                      # Can be accessed using this
</code></pre>
<p>If you want to import every part of a module and use it without <code>package.</code>, use:
from package1 i</p>
</div>
<span class="comment-copy">Are you using Python 2 or 3?</span>
<span class="comment-copy">"But in __init__ and modx, I cannot do import mody" &lt;-- that statement may be an Eclipse issue? I can't reproduce it in Python 3.6.4 REPL.</span>
<span class="comment-copy">On Python 3, you shouldn't be able to do <code>import mod2</code> from <code>mod1</code> unless your working directory is <code>package1</code>.</span>
<span class="comment-copy">To be honest, as a beginner in python, I love importing stuff as 'black-box' functionality. So far, I've never had to write my own 'black boxes' and have just skipped over studying the mechanics of importing modules. Amazing how much is out there to plug into!</span>
<span class="comment-copy">You should add your python version to your question, it's important.  Read  AJC24's answer to see why.</span>
<span class="comment-copy">You say "Namespace packages automatically attempt to find an <code>import</code> from the same package that the import call was made from." Where is that behavior specified? My understanding was that, at least in Python 3 (or Py2 with <code>__future__</code>'s <code>absolute_import</code> in play), using <code>import mod2</code> in <code>package1/mod1.py</code> was guaranteed to fail unless there was a top-level <code>mod2.py</code> in <code>sys.path</code> or the script's working directory was <code>package1</code> (just a special case of being in <code>sys.path</code>). Doesn't matter if it's a namespace package or not. Trying this locally on Python 3.6, it works the way I expect too.</span>
<span class="comment-copy">To test, create <code>~/.local/lib/python3.6/site-packages/testns</code>, then in it create <code>one.py</code> that does <code>import two</code> and <code>print(two.x)</code>. Additionally, create <code>two.py</code> in <code>testns</code> that just does <code>x = 1</code>. Then, from your home directory, run <code>python3 -mtestns.one</code>, and it will error (<code>import two</code> fails). On the other hand, if you make <code>one.py</code> contain <code>import testns.two</code> and <code>print(testns.two.x)</code>, then everything works, demonstrating that <code>import mod2</code> in the OP's case should fail.</span>
<span class="comment-copy">Yeah, you're misreading. The idea behind namespace packages is that, by not having <code>__init__.py</code>, Python understands that when looking for subpackages, it shouldn't stop in that directory. So if you have directories <code>A</code> and <code>B</code> in <code>sys.path</code> (in that order), and both contain a subdirectory <code>foo</code>, where A's <code>foo</code> contains <code>spam.py</code> and B's <code>foo</code> contains <code>eggs.py</code> (and neither has <code>__init__.py</code>), if your main module does <code>import foo.eggs</code>, even though it checks <code>A/foo</code> first and doesn't find <code>eggs</code>, it continues the search to <code>B/foo</code> where it finds <code>foo.eggs</code>.</span>
<span class="comment-copy">Point is, it doesn't undo the rule that <code>import X</code> is always absolute in Python 3 (and in Py2 under <code>absolute_import</code> semantics). Thus why I was saying the OP's code should only work if <code>sys.path</code> included <code>package1</code> itself (<i>not</i> just its parent directory). This would happen implicitly when <code>os.getcwd()</code> indicated the program was already running in the <code>package1</code> directory (because the program's working directory is automatically included in <code>sys.path</code>).</span>
<span class="comment-copy">The main reason you might see a case where namespace packages matter would be if you installed two PyPI packages with <code>pip</code>, one in the system site-packages (shared with all users) and one in user site-packages (only seen by the single user who installed it). Without implicit namespace packages, you need a special <code>__init__.py</code> file that manually continues the search for other modules in the namespace in the user site-packages; without it, the user install would mask the modules installed globally. Or you just omit <code>__init__.py</code> entirely, and Python handles it for you.</span>
<span class="comment-copy">Why was this downvoted?</span>
<span class="comment-copy">Well, among other reasons: 1. <code>import package1</code> actually gives no guarantees that <code>package1.mod1</code> is valid when <code>mod1</code> is a module (if <code>package1</code>'s <code>__init__.py</code> doesn't import <code>mod1</code> explicitly, and no one else has imported <code>package1.mod1</code>, then <code>package1</code> won't have a <code>mod1</code> attribute). 2. The term "extension" usually refers to Python C extension modules, not all modules, so you're confusing terminology. 3. Your answer describes imports generally, without addressing the OP's problem (how relative imports work from within a package). Everything you posted is clearly already known to the OP.</span>
