<div class="post-text" itemprop="text">
<p>I'm trying to extend libhydrogen (open source found here: <a href="https://github.com/jedisct1/libhydrogen/" rel="nofollow noreferrer">https://github.com/jedisct1/libhydrogen/</a>) to support calls to the underlying library in Python. However, I ran into a strange issue.
Specifically I have the following code:</p>
<pre><code>static PyObject* crypto_secretbox_encrypt(PyObject* self, PyObject* args){
    char* m;
    size_t mlen;
    uint64_t msg_id;
    char *ctx;
    size_t ctx_len;
    const uint8_t *key; //this shouldn't matter its secret
    size_t key_len;
    PyArg_ParseTuple(args, "s#|K|s#|s#", &amp;m, &amp;mlen, &amp;msg_id, &amp;ctx, &amp;ctx_len, &amp;key, &amp;key_len); //only s# accepts null bytes, need to random pointers to store lengths
    //printf("Parsed \n");
    //printf("MSG: %s, MSG_ID: %" PRIu64 ", CTX: %s\n", m, msg_id, ctx);
    if(ctx_len != hydro_secretbox_CONTEXTBYTES){
        PyErr_Format(PyExc_ValueError, "Context not of correct size: Received %lu bytes", ctx_len);
        return NULL;
    }

    if(key_len != hydro_secretbox_KEYBYTES){
        PyErr_Format(PyExc_ValueError, "Key not of correct size: Received %lu bytes", key_len);
        return NULL;
    }
</code></pre>
<p>Which is able to successfully parse the length of ctx, however, when it gets to the key it gets thrown the error, </p>
<pre><code>  File "cryptotest.py", line 7, in &lt;module&gt;
    c1 = crypto.secretbox_encrypt("message1", 0, "\x00"*8, '\x00'*32);
ValueError: Key not of correct size: Received 140123308032032 bytes
</code></pre>
<p>Any ideas on why I'm unable to successfully parse the key length?</p>
</div>
<div class="post-text" itemprop="text">
<p>You've specified the length as a <code>size_t</code>. The <code>s#</code> format does not take a <code>size_t</code>. <a href="https://docs.python.org/3/c-api/arg.html#strings-and-buffers" rel="nofollow noreferrer">It takes an <code>int</code> or <code>Py_ssize_t</code></a>, depending on whether the <code>PY_SSIZE_T_CLEAN</code> macro was <code>#define</code>d before including <code>Python.h</code>.</p>
<blockquote>
<p><strong>Note:</strong> For all <code>#</code> variants of formats (<code>s#</code>, <code>y#</code>, etc.), the type of the length argument (int or <code>Py_ssize_t</code>) is controlled by defining the macro <code>PY_SSIZE_T_CLEAN</code> before including <code>Python.h</code>. If the macro was defined, length is a <code>Py_ssize_t</code> rather than an <code>int</code>. This behavior will change in a future Python version to only support <code>Py_ssize_t</code> and drop <code>int</code> support. It is best to always define <code>PY_SSIZE_T_CLEAN</code>.</p>
</blockquote>
</div>
<span class="comment-copy">Thanks! I just realized that I was casting to the wrong data type and that was a potential issue, which I assume some type conversion messes up the value of number when it gets parsed. I can't find documentation on Py_ssize_t, but would I be able to just cast to size_t without an issue?</span>
<span class="comment-copy">@HansonDuan: The closest thing to documentation for <code>Py_ssize_t</code> is <a href="https://www.python.org/dev/peps/pep-0353/" rel="nofollow noreferrer">PEP 353</a>, which specifies it as the same size as <code>size_t</code> but signed, and as a typedef for <code>ssize_t</code> when <code>ssize_t</code> is available.</span>
