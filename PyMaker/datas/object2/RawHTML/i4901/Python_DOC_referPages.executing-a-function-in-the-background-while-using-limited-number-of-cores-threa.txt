<div class="post-text" itemprop="text">
<p>I want to use a limited number of threads (at most <code>2</code>) to run a function in a class for removing some files on disk in the background. The rest of my code within the same class is independent of this background function and might get executed tens of times more than the background function. However, I still need to enforce the core/thread limit. So it is possible that the background jobs might exceed <code>2</code> and I need to queue them. Note that my background function <strong>does not</strong> take any arguments.</p>
<p>I am pretty new to multi-threading and multi-processing but I think I have done my homework and looked at many posts here on <em>Stack Overflow</em> and tried a couple of approaches. However, none of those approaches seems to work for me. Here's the structure of my code:</p>
<pre><code>class myClass(object):
    def __init__(self):
        #some stuff
    def backgroundFunc(self):
        # delete some files on disk
    def mainFunc(self, elem):
        # Do some other things
        self.backgroundFunc() #I want to run this in the background
</code></pre>
<p>Here's how I run the code</p>
<pre><code>import myClass

myClassInstance = myClass()
For element in someList:
    myClassInstance.mainFunc(elem=element)
</code></pre>
<p>Note that I cannot start the background job before the stuff in <code>mainFunc</code> has started running.</p>
<p>And here is my first try with <code>threading</code> in my class file:</p>
<pre><code>from threading import Thread
class myClass(object):
    def __init__(self):
        #some stuff
    def backgroundFunc(self):
        # delete some files on disk
    def mainFunc(self, elem):
        # Do some other things
        thr = Thread(target=self.backgroundFunc)
        thr.start()
</code></pre>
<p>However, the problem with this approach is that the program crashes at random times; sometimes right at the beginning of prpgram execution and sometimes later the erro messages are also different every time. I guess it's possibly because threads do not block a piece of memory and things might be being written/read from those memory cells. Or, unlikely, maybe this is because I am running my code on a server and there are some limitations enforced from the server on the allocated resources. In addition, I <strong>cannot</strong> set a limit on the number of threads and cannot do queuing, in case <code>mainFunc</code> code gets executed more than twice while I already have two background jobs running.</p>
<p>Here's another try with <code>multiprocessing.Process</code>:</p>
<pre><code>from multiprocessing import Process
class myClass(object):
    def __init__(self):
        #some stuff
    def backgroundFunc(self):
        # delete some files on disk
    def mainFunc(self, elem):
        # Do some other things
        p = Process(target=self.backgroundFunc)
        p.start()
</code></pre>
<p>The problem with this approach is that Process will use as many threads/cores that my machine has in its disposal and since the rest of my code automatically is run in parallel, everything becomes super slow very quickly.</p>
<p>I eventually arrived at <code>multiprocessing.Pool</code> but I am still pretty confused on how I can use it effectively. Anyways, here's my try with <code>Pool</code>:</p>
<pre><code>from multiprocessing import Pool
class myClass(object):
    def __init__(self):
        #some stuff
        self.pool = Pool(processes=2)
    def backgroundFunc(self):
        # delete some files on disk
        print('some stuff')
    def mainFunc(self, elem):
        # Do some other things
        self.pool.apply_async(self.backgroundFunc)
</code></pre>
<p>However, <code>apply_async</code> seems not to work. None of the <code>print</code> statements that I have in the <code>backgroundFunc</code> print anything on the screen. I added <code>self.pool.close()</code> after <code>apply_async</code> but I get some errors soon after the second processes start. I tried using things like <code>self.pool.apply</code> and some others but it seems that they require a function that takes limited arguments. But my <code>backgroundFunc</code> does not take any arguments. Finally, I do not know how I can do the <code>queuing</code> that I explained earlier using Pool.</p>
<p>Also, I want to have control over how many times and when I want to run <code>backgroundFunc</code>. Also, <code>mainFunc</code> should not wait for all threads to finish running before it exits. If that happens, I won't benefit from multi threading because the background function might take too long to finish. Maybe I should have been more clear in the question; sorry about that.</p>
<p>So I would really appreciate if someone can help me with this. I am pretty confused. Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>the program crashes randomly. I guess</p>
</blockquote>
<p>It would be easier to concentrate on one problem at a time, without guessing, so, what's the <em>crash</em>?</p>
<p>Here's a test with <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a> that might inspire you, based on the  example for <a href="https://docs.python.org/3/library/queue.html#queue.Queue.join" rel="nofollow noreferrer"><code>queue</code></a>. </p>
<pre><code>#!python3
#coding=utf-8
""" https://stackoverflow.com/q/49081260/ """

import sys, time, threading, queue

print(sys.version)

class myClass:
    """ """

    def __init__(self):
        """ """
        self.q = queue.Queue()
        self.threads = []
        self.num_worker_threads = 2

    def backgroundFunc(self):
        """ """
        print("thread started")
        while True:
            item = self.q.get()
            if item is None:
                #self.q.task_done()
                break
            print("working on ", item)
            time.sleep(0.5)
            self.q.task_done()
        print("thread stopping")

    def mainFunc(self):
        """ """

        print("starting thread(s)")
        for i in range(self.num_worker_threads):
            t = threading.Thread(target=self.backgroundFunc)
            t.start()
            self.threads.append(t)

        print("giving thread(s) some work")
        for item in range(5):
            self.q.put(item)

        print("giving thread(s) more work")
        for item in range(5,10):
            self.q.put(item)

        # block until all tasks are done
        print("waiting for thread(s) to finish")
        self.q.join()

        # stop workers
        print("stopping thread(s)")
        for i in range(self.num_worker_threads):
            self.q.put(None)
        for t in self.threads:
            self.q.join()

        print("finished")



if __name__ == "__main__":
    print("instance")
    myClassInstance = myClass()

    print("run")
    myClassInstance.mainFunc()

    print("end.")
</code></pre>
<p>It prints</p>
<pre><code>3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)]
instance
run
starting thread(s)
thread started
thread started
giving thread(s) some work
giving thread(s) more work
waiting for thread(s) to finish
working on  0
working on  1
working on  2
working on  3
working on  4
working on  5
working on  6
working on  7
working on  8
working on  9
stopping thread(s)
thread stopping
thread stopping
finished
end.
</code></pre>
</div>
<span class="comment-copy">Why do you want to use a limited number of threads? Python threads are not the same as system threads and won’t consume more cpu cores.</span>
<span class="comment-copy">@JoelCornett Because I need all other cores to spend time on doing some other processes that I care much more about.</span>
<span class="comment-copy">To reiterate, python threads are not system threads, they don’t consume multiple cores. What sort of background work are you doing? Is it IO bound or CPU bound?</span>
<span class="comment-copy">It appears you have already received a number of answers so I'll just leave 2 general tips here: (1) If you plan on using multiprocessing in Python, reading <a href="https://pymotw.com/3/multiprocessing/index.html" rel="nofollow noreferrer">Doug Hellman's tutorial on multiprocessing</a> is time very well spent. It will show you with short, runnable examples of all the main design patterns available to you.</span>
<span class="comment-copy">(2) If the answers you are receiving are not satisfactory, it may help to clarify your questions using a <a href="https://stackoverflow.com/help/mcve">runnable MCVE</a>. For example, instead of mentioning "Each of these functions will execute some parallel operations" show us in the code. We probably don't need to see the long serial computation, (so substituting <code>time.sleep(1)</code> may suffice) but we do need to see the structure of your parallel operations and overall program. A small runnable example may enable us to help you better.</span>
<span class="comment-copy">Move the thread management to <code>__init__</code> (also mabye <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">docs.python.org/3.6/reference/datamodel.html#object.__del__</a>) if <code>mainFunc</code> gets called more than once. For several instances of myClass, see <a href="https://stackoverflow.com/questions/68645/static-class-variables-in-python" title="static class variables in python">stackoverflow.com/questions/68645/…</a></span>
<span class="comment-copy">I have not run your code but it seems to me that your code assigns <code>backgroundFunc</code> to two threads immediately but I do not want that to be the case. I want to have control over how many times and when I want to run <code>backgroundFunc</code>. Also, <code>mainFunc</code> should not wait for all threads to finish running before it exits. If that happens, I won't benefit from multi threading because the background function might take too long to finish. Maybe I should have been more clear in the question; sorry about that.</span>
<span class="comment-copy">In addition, from the impression I got from all other posts, your code seems a bit too complicated. Is there a way to simplify it?</span>
<span class="comment-copy">I've retried the original example code: it does work as-is. I had issues with <code>q.join()</code> blocking, and added <code>task_done()</code> to solve that - commented out now in the code above, but not tested again.</span>
<span class="comment-copy">I'm gonna try your proposed method sometime soon and will get back to you on it. Thank you!</span>
