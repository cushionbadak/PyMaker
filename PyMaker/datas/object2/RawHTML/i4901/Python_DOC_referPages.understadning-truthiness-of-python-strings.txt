<div class="post-text" itemprop="text">
<p>I understand that Python built-in types have a "truthiness" value, and the empty string is considered <code>False</code>, while any non-empty string is considered <code>True</code>.</p>
<h3>This makes sense</h3>
<p>I can check this using the built-in function <code>bool</code>.</p>
<pre><code>&gt;&gt;&gt; bool("")
False

&gt;&gt;&gt; bool("dog")
True
</code></pre>
<p>I can also make use of these truthiness values when using conditionals. For example:</p>
<pre><code>&gt;&gt;&gt; if "dog":
...     print("yes")
...
yes
</code></pre>
<h3>This is confusing</h3>
<p>This doesn't work with the <code>==</code> operator though:</p>
<pre><code>&gt;&gt;&gt; "dog" == True
False

&gt;&gt;&gt; "dog" == False
False
</code></pre>
<p>Can anyone explain why <code>==</code> seems to act differently than a conditional?</p>
</div>
<div class="post-text" itemprop="text">
<p>See the <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">truth value testing</a> and <a href="https://docs.python.org/3/library/stdtypes.html#comparisons" rel="nofollow noreferrer">comparisons</a> sections of the documentation, excerpted below.</p>
<p>In a nutshell, most things are truthy by default, which is why <code>bool("dog")</code> is true.  The <code>==</code> operator compares two objects for equality, as opposed to comparing their truthinesses, as I assume you had expected.</p>
<blockquote>
<p><strong>4.1. Truth Value Testing</strong> </p>
<p>Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below.</p>
<p>By default, an object is considered true unless its class defines
  either a <code>__bool__()</code> method that returns False or a <code>__len__()</code> method
  that returns zero, when called with the object. </p>
<p>Here are most of the built-in objects considered false:</p>
<ul>
<li>constants defined to be false: <code>None</code> and <code>False</code></li>
<li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>empty sequences and collections: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
<p>Operations and built-in functions that have a Boolean result always 
  return 0 or False for false and 1 or True for true, unless otherwise
  stated. (Important exception: the Boolean operations <code>or</code> and <code>and</code>
  always return one of their operands.)</p>
<p><strong>4.3. Comparisons</strong></p>
<p>Objects of different types, except different numeric types, never
  compare equal.</p>
<p>...</p>
<p>Non-identical instances of a class normally compare as non-equal
  unless the class defines the <code>__eq__()</code> method.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h3>The basics</h3>
<p>I believe your confusion might come from comparing Python to languages such as JavaScript where there is a <code>==</code> and a <code>===</code> operator. Python does not work this way.</p>
<p>In Python the only way to compare for equality is with <code>==</code> and this compares both value and type.</p>
<p>Thus if you compare <code>True == "dog"</code>, then the expression is immediately <code>False</code> because the types <code>bool</code> and <code>str</code> are not types that can be compared.</p>
<p>Although, note that it does not mean that there are no types that are comparable between themselves. Examples are <code>set</code> and <code>frozenset</code>:</p>
<pre><code>frozenset({1,2,3}) == {1,2,3} # True
</code></pre>
<p>Or simply <code>int</code> and <code>float</code></p>
<pre><code>1 == 1.0 # True
</code></pre>
<p>This is the behaviour for most built-in types.</p>
<h3>The classy part</h3>
<p>In the case where you <em>define your own types</em>, i.e. when you define classes, you can write the <code>__eq__</code> which is called when you compare a class object to another value.</p>
<p>By example you could do this (which by the way was pointed out as a terrible idea in the comments, you should not inherit built-in types).</p>
<pre><code>class WeirdString(str):
    def __eq__(self, other):
        return str(self) == str(other) or bool(self) == bool(other)

s = WeirdString("dog")
s == True # True
</code></pre>
<p>In the case where you do not define <code>__eq__</code>, then Python fall back on comparing whether the objects are <em>the same object</em> with <code>is</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><em>When you compare <code>"dog" == True</code>, you are also comparing the type of these objects and not just their boolean value.</em></p>
</blockquote>
<p>Now as <code>True</code> has a type <code>bool</code> and <code>"dog"</code> has a type <code>str</code>, they are not equivalent according to the <code>==</code> operator, irrespective of their boolean values being equal.</p>
<p><strong>Note: Both the object's type,boolean values are being checked here.</strong></p>
</div>
<span class="comment-copy">have you read the documentation?</span>
<span class="comment-copy"><code>==</code> is comparison operator. a string and a boolean can never be equal.</span>
<span class="comment-copy">When you compare <code>"dog" == "True"</code>, you are also comparing the type of these objects and not just their bool value.</span>
<span class="comment-copy">here type is compared, not the value</span>
<span class="comment-copy">I have pants. I am not equal to my pants. A string has a truth value. A string is not equal to its truth value.</span>
<span class="comment-copy">For those who wonder why I say <i>for most built-in types</i>, I was thinking of shady stuff like this: <a href="https://docs.python.org/3/library/stdtypes.html#memoryview.__eq__" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#memoryview.__eq__</a></span>
<span class="comment-copy">To be clear, <code>WeirdString</code> is a <i>terrible</i> idea. <code>s</code> in this case will be equal to <code>"foo"</code>, <code>{1}</code>, <code>[1]</code>, <code>-200.5</code>, <code>{'a': 1}</code>, <code>object()</code>, etc. Python is strongly typed for a reason; with dynamic typing already in play, weak typing makes it nigh impossible to write code you can reason about usefully. The real lesson here is to write idiomatic code, which <i>never</i> uses <code>== True</code> or <code>== False</code>, and just use implicit truthiness.</span>
<span class="comment-copy">It is a terrible idea, I will mention this to be clear.</span>
<span class="comment-copy">Also, standard <code>==</code> is not testing type explicitly. Different numeric types are comparable, <code>set</code> can be compared to <code>frozenset</code>, many bytes-like types compare to each other as expected, etc. Don't bring in the explicit type checking of JS's <code>===</code> here, it just confuses the matter.</span>
<span class="comment-copy">I reworked my answer to include your remarks, that are on point by the way.</span>
<span class="comment-copy"><code>True</code> inside a double quotes in not bool</span>
<span class="comment-copy">@bro-grammer , Thanks i fixed it!</span>
