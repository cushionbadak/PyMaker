<div class="post-text" itemprop="text">
<p>So I am trying to write a simple wrapper in python to call rasa, a nlu tool from. The command I would write on the the command line is this:</p>
<blockquote>
<p>curl -X POST "localhost:5000/parse" -d '{"q":"I am looking for fucking Mexican food"}' | python -m json.tool</p>
</blockquote>
<p>The output I expect is something like this:</p>
<blockquote>
<p>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                   Dload  Upload   Total   Spent    Left  Speed
  100   545    0   500  100    45  33615   3025 --:--:-- --:--:-- --:--:-- 35714</p>
</blockquote>
<p>plus the outprint of a json file. </p>
<p>I wrote this program in python: </p>
<pre><code>import subprocess

utterance = "Lets say something"


result = subprocess.run(["curl", "-X", "POST", "localhost:5000/parse", "-d", "'{\"q\":\""+utterance+"\"}'", "|", "python", "-m", "json.tool"], stdout=subprocess.PIPE)
print(vars(result))
print(result.stdout.decode('utf-8'))
</code></pre>
<p>Unfortunately my output is like this, meaning I dont actually get the return from the curl call: </p>
<blockquote>
<p>{'args': ['curl', '-X', 'POST', 'localhost:5000/parse', '-d', '\'{"q":"Lets say something"}\'', '|', 'python', '-m', 'json.tool'], 'returncode': 2, 'stdout': b'', 'stderr': None}</p>
</blockquote>
<p>If I call my python programm from the commandline, this is the output:</p>
<blockquote>
<p>curl: option -m: expected a proper numerical parameter
  curl: try 'curl --help' or 'curl --manual' for more information
  {'args': ['curl', '-X', 'POST', 'localhost:5000/parse', '-d', '\'{"q":"Lets say something"}\'', '|', 'python', '-m', 'json.tool'], 'returncode': 2, 'stdout': b'', 'stderr': None}</p>
</blockquote>
<p>I tried looking everywhere but just cant get it going. Would really appreciate some help.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update:</strong> I grossly misunderstood the question the first time.  Rushed reading the details, so my apologies there.  You are having a problem because you are trying to pipe two commands together using Popen.  The pipe operator, however, is something implemented by the shell, not python.  So it is expecting your command to just be a command related to curl.  It is complicated, but you have options.</p>
<p>I think for your particular example, the simplest is to not try to chain the command to json.tool.  You actually have no need for it.  You are already in python, so you can just pretty print the output you get from curl yourself.  Using python would look something like</p>
<pre><code>import json
import shlex
from subprocess import Popen, PIPE

command = 'curl -XGET http://localhost:9200'

p = Popen(shlex.split(command), stdin=PIPE, stdout=PIPE, stderr=PIPE)
output, err = p.communicate()

if p.returncode != 0:
    print(err)

j = json.loads(output.decode("utf-8"))
print(json.dumps(j, indent=4, sort_keys=True))
</code></pre>
<p>However, if what you want long term is to actually connect multiple processes with pipes, well there it depends on the scenario.  The easiest method is to pass <code>shell=True</code> to <code>Popen</code> and pass the exact command (not a list of arguments).  This delegates everything to the shell.  I need to warn you that <strong>this is very exploitable when the command is based off user input</strong>.  Both <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">2.x</a> <code>pipes.quote()</code> and <a href="https://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">3.x</a> <code>shlex.quote()</code> have a recommendation of how to escape the command so it <em>should</em> be safe.</p>
<pre><code>from subprocess import Popen, PIPE

command = 'curl -XGET http://localhost:9200 | python -m json.tool'

p = Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True)
output, err = p.communicate()

if p.returncode != 0:
    print(err)

print(output.decode("utf-8"))
</code></pre>
<p>So if you find yourself needing to connect processes but have something based on user input, you can use <a href="https://docs.python.org/2.7/library/subprocess.html#replacing-shell-pipeline" rel="nofollow noreferrer">multiple processes</a> and connect them yourself.</p>
<pre><code>import shlex
from subprocess import Popen, PIPE

command1 = 'curl -XGET http://localhost:9200'
command2 = 'python -m json.tool'

p1 = Popen(shlex.split(command1), stdout=PIPE)
p2 = Popen(shlex.split(command2), stdin=p1.stdout, stdout=PIPE)
p1.stdout.close()
output, err = p2.communicate()

if p2.returncode != 0:
    print(err)

print(output.decode("utf-8"))
</code></pre>
<p><a href="https://stackoverflow.com/q/295459/3884529">This</a> question has a bunch more on the topic if you are curious.</p>
</div>
<span class="comment-copy">A thought, have you looked at pycurl or requests -- you would be writing native code, easier to implement, easier to read, easier to debug.</span>
<span class="comment-copy">I tried using Popen, unfortunatley your exact code with my command produces this: b"curl: option -m: expected a proper numerical parameter\ncurl: try 'curl --help' or 'curl --manual' for more information\n" b''</span>
<span class="comment-copy">I'll try something later, but you can probably drop the <code>| python -m json.tool</code> part.  You are already in python so you can pretty print it in your code if need be.</span>
<span class="comment-copy">@JulianKurz updated the answer.  I totally did not read your question close enough.   What SteveJ said about pycurl also looks interesting as a nicer alternative to executing curl without invoking an external process.</span>
<span class="comment-copy">Thank you so much, just to learn something I tried both of your options, and they both work beautifully. So of course I implemented the first one. Although I might play around myself with trying to cause harm with the second option, since the user input is speech based and I find it interesting to see if it is still possible.</span>
<span class="comment-copy">@JulianKurz I made one more update.  Both 2.x and 3.x have a recommendation for escaping the command that I added mention of when using <code>shell=True</code>.  I did not immediately get it to work so I'll try that later and update the example, but maybe worth trying.  Turning text to speech into code is probably difficult, but still possible.  If this helped accepting the answer would be super helpful.</span>
