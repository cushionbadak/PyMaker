<div class="post-text" itemprop="text">
<p>I have three arrays of same size (can be very long upto 5000). I have to look up for pair of values (this will always be unique) in the first two arrays, for ex,(2,3) and accordingly fetch the value from third array at the same index. What is the fastest way to do this or any simple python inbuilt library present for this? The simplest solution for the problem is:</p>
<pre><code>a = [1,1,1,2,2,2,3,3,3,4,4,4]
b = [2,3,4,3,4,5,7,3,2,1,8,9]
c = [4,5,6,13,4,8,80,4,2,3,7,11]
for i in range(0, len(a)):
  if a[i] == 2 and b[i] == 3:
    fetch = c[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Find the index and use it:</p>
<pre><code>&gt;&gt;&gt; c[zip(a, b).index((2, 3))]
13
</code></pre>
<p>Or prepare a dict to look the pair up:</p>
<pre><code>&gt;&gt;&gt; dict(zip(zip(a, b), c))[2, 3]
13
</code></pre>
<p>This would be faster if you wanted to look up many pairs, not just one. And you could use its <code>get</code> in case it's possible that the pair doesn't exist.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a generator expression with <code>next()</code> and <code>zip()</code> over all the lists together:</p>
<pre><code>&gt;&gt;&gt; next((z for x, y, z in zip(a, b, c) if (x, y) == (2, 3)), 'None found')
13
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Benchmarking different solutions, using lists of length 10000 similar to the shown ones and searching all existing pairs, using Python 2.7.14:</p>
<pre><code> 2.380 seconds rajat      # The original
 1.712 seconds rajat2     #   Precomputed range
 1.843 seconds rajat3     #   xrange instead of range
 5.243 seconds stefan1    # zip(a, b).index
 0.954 seconds stefan1b   #   Precomputed zip(a, b).index
16.108 seconds stefan2    # dict
 0.002 seconds stefan2b   #   Precomputed dict
10.782 seconds chris      # next(generator)
 6.728 seconds chris2     #   bit optimized
 1.754 seconds chris3     #   Precomputed zip(a, b, c)
</code></pre>
<p>The code:</p>
<pre><code>from timeit import timeit

b = range(100) * 100
a = sorted(b)
c = range(10000)

#-------------------------------------------------------------------------

def rajat(A, B):
    'The original'
    for i in range(0, len(a)):
        if a[i] == A and b[i] == B:
            return c[i]

def rajat2(A, B, r=range(0, len(a))):
    '  Precomputed range'
    for i in r:
        if a[i] == A and b[i] == B:
            return c[i]

def rajat3(A, B):
    '  xrange instead of range'
    for i in xrange(0, len(a)):
        if a[i] == A and b[i] == B:
            return c[i]

def stefan1(A, B):
    'zip(a, b).index'
    return c[zip(a, b).index((A, B))]

def stefan1b(A, B, index=zip(a, b).index):
    '  Precomputed zip(a, b).index'
    return c[index((A, B))]

def stefan2(A, B):
    'dict'
    return dict(zip(zip(a, b), c))[A, B]

def stefan2b(A, B, d=dict(zip(zip(a, b), c))):
    '  Precomputed dict'
    return d[A, B]

def chris(A, B):
    'next(generator)'
    return next((z for x, y, z in zip(a, b, c) if (x, y) == (A, B)), 'None found')

def chris2(A, B):
    '  bit optimized'
    return next((z for x, y, z in zip(a, b, c) if x == A and y == B), 'None found')

def chris3(A, B, abc=zip(a, b, c)):
    '  Precomputed zip(a, b, c)'
    return next((z for x, y, z in abc if x == A and y == B), 'None found')

#-------------------------------------------------------------------------

ab = zip(a, b)
def test():
    for A, B in ab:
        func(A, B)

for func in rajat, rajat2, rajat3, stefan1, stefan1b, stefan2, stefan2b, chris, chris2, chris3:
    t = timeit(test, number=1)
    print '%6.3f seconds %-10s # %s' % (t, func.__name__, func.__doc__)
</code></pre>
</div>
<span class="comment-copy">I don't know if this is faster, but using <code>zip</code> will certainly bring more elegance <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">docs.python.org/3/library/functions.html</a></span>
<span class="comment-copy">Is <code>a</code> sorted as in the example?</span>
<span class="comment-copy">no, arrays are not sorted, this is just an example</span>
<span class="comment-copy">Nice, I prefer this to my approach</span>
<span class="comment-copy">@Chris_Rands Someone should do a proper benchmark, btw, since the question asks for the fastest way. In a test I just did, for single search all of our solutions were significantly slower than the OP's. For multiple searches, mine are faster (when I prepare the dict and the index method only once).</span>
<span class="comment-copy">@Chris_Rands Added a benchmark answer now...</span>
