<div class="post-text" itemprop="text">
<p>I have an app which adds coroutines to an already-running event loop.
The arguments for these coroutines depend on I/O and are not available when I initially start the event loop - with <em>loop.run_forever()</em>, so I add the tasks later. To demonstrate the phenomenon, here is some example code:</p>
<pre><code>import asyncio
from threading import Thread
from time import sleep

loop = asyncio.new_event_loop()

def foo():
    loop.run_forever()

async def bar(s):
    while True:
        await asyncio.sleep(1)
        print("s")

#loop.create_task(bar("A task created before thread created &amp; before loop started"))
t = Thread(target=foo)
t.start()
sleep(1)
loop.create_task(bar("secondary task"))
</code></pre>
<p>The strange behaviour is that everything works as expected when there is at least one task in the loop when invoking <em>loop.run_forever()</em>. i.e. when the commented line is not commented out. </p>
<p>But when it is commented out, as shown above, nothing is printed and it appears I am unable to add a task to the event_loop. Should I avoid invoking <em>run_forever()</em> without adding a single task? I don't see why this should be a problem. Adding tasks to an event_loop after it is running is standard, why should the empty case be an issue?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Adding tasks to an event_loop after it is running is standard, why should the empty case be an issue?</p>
</blockquote>
<p>Because you're supposed to add tasks <em>from the thread running the event loop</em>. In general one should not mix threads and asyncio, except through APIs designed for that purpose, such as <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer"><code>loop.run_in_executor</code></a>.</p>
<p>If you understand this and still have good reason to add tasks from a separate thread, use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe</code></a>. Change <code>loop.create_task(bar(...))</code> to:</p>
<pre><code>asyncio.run_coroutine_threadsafe(bar("in loop"), loop=loop)
</code></pre>
<p><code>run_coroutine_threadsafe</code> accesses the event loop in a thread-safe manner, and also ensures that the event loop <em>wakes up</em> to notice the new task, even if it otherwise has nothing to do and is just waiting for IO/timeouts.</p>
<p>Adding another task beforehand only appeared to work because <code>bar</code> happens to be an infinite coroutine that makes the event loop wake up every second. Once the event loop wakes up for any reason, it executes all runnable tasks regardless of which thread added them. It would be a really bad idea to rely on this, though, because <code>loop.create_task</code> is not thread-safe, so there could be any number of race conditions if it executed in parallel with a running event loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because loop.create_task is not thread safe, and if you set <code>loop._debug = True</code>, you should see the error as</p>
<p><code>
Traceback (most recent call last):
  File "test.py", line 23, in &lt;module&gt;
    loop.create_task(bar("secondary task"))
  File "/Users/soulomoon/.pyenv/versions/3.6.3/lib/python3.6/asyncio/base_events.py", line 284, in create_task
    task = tasks.Task(coro, loop=self)
  File "/Users/soulomoon/.pyenv/versions/3.6.3/lib/python3.6/asyncio/base_events.py", line 576, in call_soon
    self._check_thread()
  File "/Users/soulomoon/.pyenv/versions/3.6.3/lib/python3.6/asyncio/base_events.py", line 615, in _check_thread
    "Non-thread-safe operation invoked on an event loop other "
RuntimeError: Non-thread-safe operation invoked on an event loop other than the current one
</code></p>
</div>
