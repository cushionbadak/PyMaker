<div class="post-text" itemprop="text">
<h2>brief summary</h2>
<p><code>MyClass.my_method</code> has a call to <code>instance = SomeLibrary()</code>  I want to create a mock so <code>instance</code> is a mocked object that I can control.  In the spirit of isolated testing, I don't actually want to call into <code>SomeLibrary</code>.</p>
<h2>what argument to pass to <code>@mock.patch()</code></h2>
<p>I'm trying to mock the class constructor, but I haven't figured out what to pass to the @mock.patch() decorator.  The docs say that the argument must be fully dotted (<code>pyftdi.ftdi.Ftdi</code>), but the <code>where to patch</code> docs say that the argument must match the name by which the code being tested knows it (<code>Ftdi</code>).  I don't see how to satisfy both.</p>
<p>To make it concrete, here's the file being tested:</p>
<pre><code>from pyftdi.ftdi import Ftdi

class FtdiInterface(object):
    @classmethod
    def set_power(cls, url, on):
        ftdi = Ftdi()
        ftdi.open_from_url(url)
        # ... do other things with ftdi
</code></pre>
<p>... and the test file</p>
<pre><code>import unittest
from unittest import mock
from ftdi_interface import FtdiInterface
import pyftdi.ftdi

class TestFtdiInterface(unittest.TestCase):

    @mock.patch('pyftdi.ftdi.Ftdi')
    def testPowerOn(self, MockFtdi):
        url = 'some_string'
        ftdi_instance = mock.MagicMock()
        ftdi_instance.open_from_url = mock.MagicMock()
        MockFtdi.return_value = ftdi_instance

        FtdiInterface.set_power(url, True)
        ftdi_instance.open_from_url.assert_called_with(url)
</code></pre>
<p>What I observe is that, despite my attempt to patch Ftdi(), the call to <code>ftdi_instance.open_from_url()</code> calls the library code, not my mocked object.</p>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.mock.html?#where-to-patch" rel="nofollow noreferrer">Where to patch</a> states:</p>
<blockquote>
<p>The basic principle is that you patch where an object is looked up, which is not necessarily the same place as where it is defined.</p>
</blockquote>
<p>It means that to <code>mock</code> a class <code>Ftdi</code> you have to provide a path to the place in your code where <code>Ftdi</code> is actually instantiated.</p>
<p>To do so you you need to replace <code>@mock.patch('pyftdi.ftdi.Ftdi')</code> with <code>@mock.patch('ftdi_interface.Ftdi')</code>:</p>
<pre><code>import unittest
from unittest import mock
from ftdi_interface import FtdiInterface

class TestFtdiInterface(unittest.TestCase):

    @mock.patch('ftdi_interface.Ftdi')
    def testPowerOn(self, MockFtdi):
        url = 'some_string'
        ftdi_instance = mock.MagicMock()
        ftdi_instance.open_from_url = mock.MagicMock()
        MockFtdi.return_value = ftdi_instance

        FtdiInterface.set_power(url, True)
        ftdi_instance.open_from_url.assert_called_with(url)
</code></pre>
<p>Line <code>import pyftdi.ftdi</code> doesn't make anything useful for test and can be dropped. </p>
</div>
<span class="comment-copy">Doh!  I must have read that sentence in <code>where to patch</code> a dozen times, but it wasn't until I saw your answer that I fully understood its implications.  Thanks -- worked!</span>
