<div class="post-text" itemprop="text">
<p>I've been using Structure in ctypes recently, but i got a strange question.</p>
<p>This is my Python3 code:</p>
<pre><code>from ctypes import *
class AcknowledgeHeader(Structure):
    _fields_ = [
        ('test', c_uint8),
    ]
ack_header = AcknowledgeHeader()
</code></pre>
<p>The question is: Is <code>test</code> a class member of AcknowledgeHeader or an instance attribute of ack_header?</p>
<p>I tried to find the answer.</p>
<p>If <code>test</code> is an instance attribute of ack_header, then why does <code>ack_header.__dict__</code> print a empty dict?</p>
<pre><code>if __name__ == '__main__':
    ack_header = AcknowledgeHeader()
    print(ack_header.__dict__)

C:\Users\Administrator\PycharmProjects\gige-lib\venv\Scripts\python.exe
C:/Users/Administrator/PycharmProjects/gige-lib/channel/common.py
{}

Process finished with exit code 0
</code></pre>
<p>If <code>test</code> is a class member of AcknowledgeHeader, then why is <code>type(ack_header.test)</code> not equal to <code>type(AcknowledgeHeader.test)</code>?</p>
<pre><code>if __name__ == '__main__':
    ack_header = AcknowledgeHeader()
    print(type(ack_header.test))
    print(type(AcknowledgeHeader.test))

C:\Users\Administrator\PycharmProjects\gige-lib\venv\Scripts\python.exe C:/Users/Administrator/PycharmProjects/gige-lib/channel/common.py
&lt;class 'int'&gt;
&lt;class '_ctypes.CField'&gt;

Process finished with exit code 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>test</code> is a <strong>data descriptor object</strong> on the <code>AcknowledgeHeader</code> class. Accessing it on the <code>ack_header</code> instance causes code to run that translates between C conventions and Python types.</p>
<p>Because it is a data descriptor, all interaction with the attribute is captured, including deletion and assignment. If you were to set a <code>'test'</code> key in the <code>ack_header.__dict__</code> attribute dictionary it'd simply be ignored.</p>
<p>Instead, <code>ack_header.test</code> will always invoke <code>AcknowledgeHeader.test.__get__(ack_header, AcknowledgeHeader)</code>, while assignment to <code>ack_header.test</code> will trigger <code>AcknowledgeHeader.test.__set__(ack_header, &lt;new value&gt;)</code>.</p>
<p>In this case, only getting and setting is implemented, there is no <a href="https://docs.python.org/3/reference/datamodel.html#object.__delete__" rel="nofollow noreferrer"><code>_ctypes.CField.__delete__()</code> method</a>, only <code>__get__</code> and <code>__set__</code>, so <code>del ack_header.test</code> will throw an exception.</p>
<p>See the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor HOWTO</a> for more details on how descriptors work.</p>
</div>
