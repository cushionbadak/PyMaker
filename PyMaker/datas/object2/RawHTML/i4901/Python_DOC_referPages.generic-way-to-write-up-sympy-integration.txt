<div class="post-text" itemprop="text">
<p>Right now, to integrate a function <code>fx</code> with SymPy I would do the following:</p>
<pre><code>from sympy.abc import alpha as _alpha_, beta as _beta_, x as _x_

sym_args = _alpha_, _beta_

fx_definite_integral = sympy.integrate(fx(_x_, *sym_args), (_x_, xmin, xmax))
</code></pre>
<p>But this requires me to know beforehand what symbols I might need for a given function. But what if I plugged in a different function, with parameters, say, A, B, Y, Z, Q, W?</p>
<p>Instead of manually assigning symbols in SymPy, is there a way to generically assign symbols - basically, my <code>sym_args</code>, based on the input function?</p>
<p>Ideally</p>
<pre><code>sym_args = sympy.all_the_symbols_I_need_for_random_function(fx)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is a bit ill-defined because, after all, you need to know <em>something</em> about the arguments of <code>fx</code>, right? For example, <code>fx</code> should have at least one argument for the <code>x</code>; is it always the first argument, or the argument called <code>x</code>, which may or may not be the first? Should the rest of arguments be given a specific sequence of names, such as <code>alpha</code>, <code>beta</code>, etc. or instead use symbols with the name of the argument? What if the arguments have default values?</p>
<p>I'll give one possible approach for a simple example, then you can choose how to implement it exactly for your case. Let's have this function:</p>
<pre><code>def fx(x, a, b, c):
    return x * (a + (b / c))
</code></pre>
<p>In order to extract information about the function arguments, you can use the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a></p>
<pre><code>import inspect
fx_args = inspect.getfullargspec(fx).args  # fx_args &lt;- ['x', 'a', 'b', 'c']
</code></pre>
<p><a href="https://docs.python.org/3/library/inspect.html#inspect.getfullargspec" rel="nofollow noreferrer"><code>inspect.getfullargspec</code></a> returns a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> with information about the function arguments, you can check the docs to see if you need something else (e.g. to ignore parameters with default values). Now you can convert those to SymPy symbols:</p>
<pre><code>import sympy
fx_argsym = sympy.symbols(fx_args)  # fx_argsym &lt;- [x, a, b, c]
</code></pre>
<p>Here you could use a different strategy. For example, if you wanted to have the first argument be always <code>x</code> and the rest of arguments be always Greek letters (as long as you don't have too many arguments) you could do:</p>
<pre><code>import sympy.abc
fx_argsym = [sympy.abc.x] + list(sympy.symbols(sympy.abc.greeks[:len(fx_args) - 1]))
# fx_argsym &lt;- [x, alpha, beta, gamma]
</code></pre>
<p>You can manipulate <code>fx_argsym</code> however you want to suit your needs. When you get get it right, you can call <code>sympy.integrate</code> as usual:</p>
<pre><code>fx_definite_integral = sympy.integrate(fx(*fx_argsym), (_x_, xmin, xmax))
</code></pre>
<p>Note that if you didn't make sure that <code>x</code> was in <code>fx_argsym</code> you may get an error, but that is easy to check for example with:</p>
<pre><code>assert _x_ in fx_argsym
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use </p>
<pre><code>f = Function('f')
expr.Integral(f(x), (x, xmin, xmax))
</code></pre>
<p>and then use <code>expr.replace(f, your_function)</code> to replace <code>f</code> with your function. You will need to <a href="https://docs.python.org/3.6/library/functools.html#functools.partial" rel="nofollow noreferrer">curry</a> <code>your_function</code> so that it accepts one parameter to match <code>f</code>. As far as <code>Integral</code> is concerned, it only needs to know that <code>f</code> depends on <code>x</code>. The rest of the (constant) variables can be "in" <code>f</code>. </p>
<p>For instance, if your expression is <code>x + A + B</code>, you can use <code>expr.replace(f, lambda x: x + A + B)</code>.</p>
</div>
<span class="comment-copy">What is <code>fx</code> here? Is it a Python function returning a SymPy expression?</span>
<span class="comment-copy">An expression for a mathematical function, e.g. <code>def fx(x, alpha, beta): return x+alpha**2+beta</code>, where here I would have to manually define symbols for all the input arguments.</span>
<span class="comment-copy">SymPy does not integrate functions, it integrates expressions. A symbolic expression does not need anything to be plugged in, it already contains symbols. When you write Python functions like <code>def fx...</code> for use in SymPy, you are probably overcomplicating.</span>
<span class="comment-copy">PyCharm tells me that <code>inspect.getargspec(fx).args</code> is deprecated for Python3. Instead I had to use <code>fx_args = [*inspect.signature(fx).parameters.keys()]</code> to get out the parameters in a list (otherwise, returns an OrderedDict), for SymPy to take them.</span>
<span class="comment-copy">@komodovaran_ Thanks, I didn't notice that. According to the docs <a href="https://docs.python.org/3/library/inspect.html#inspect.getfullargspec" rel="nofollow noreferrer"><code>inspect.getfullargspec</code></a> should be a valid drop-in replacement, but you can do it however it works best for you.</span>
<span class="comment-copy">Oh, you're <i>completely</i> right. It was because PyCharm didn't pick up the <code>.args</code> in the autocomplete, so I thought it didn't exist. That's what you get for not reading the manual.</span>
