<div class="post-text" itemprop="text">
<p>I'm kind of confused on <code>d.items()</code> and <code>d.keys()</code>. My textbook said that they return view objects that are tuples but they can be changed? For instance, my code is this</p>
<pre><code>d = {"Bob":27, "Frank":75}

for key, value in d.items():
    if d[key] == 27:
        d[key] = 20
        print(d)
</code></pre>
<p>It prints out 20 instead of 27. </p>
</div>
<div class="post-text" itemprop="text">
<p>What your textbook means is that if the keys of the dictionary change, then so will the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">view</a>.</p>
<pre><code>d = {1: 1}

keys = d.keys() # dict_keys([1])

d[2] = 2

keys # dict_keys([1, 2])
</code></pre>
<p>The same happens for items.</p>
<pre><code>d = {1: 1}

items = d.items() # dict_items([(1, 1)])

d[2] = 2

keys # dict_keys([(1, 1), (2, 2)])
</code></pre>
<p>Also, they are not tuples, they have their own class.</p>
<pre><code>isinstance(d.keys(), tuple) # False

type(d.keys()) # &lt;class 'dict_keys'&gt;

type(d.items()) # &lt;class 'dict_items'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = {
    'a': 'aa',
    'b': 'bb',
    'c': 'cc'
}

for k,v in a.items(): # does't change anything.
    k = 'c' # k is the first item of the tuples in the dict_items object

for k in a.keys(): # doesn't change anything.
    k = 'd' # k is the first item of the tuples in the dict_keys object

for k,v in a.items():
    # you are using __setitem__ method of the dictionary with the first item of the tuple
    # so you are not actually changing the tuple
    # you are just using the tuple to index the dictionary
    a[k] = v + '!!!' # you find the value of the given key, and added a string to it 

print(a.items()) # will print a dict_items object containing key,value tuples of the dictionary
</code></pre>
<p>-~-~-~-~-~-</p>
<pre><code>for a in a.items(): # does't change anything
    print(isinstance(a,tuple))
</code></pre>
<p>The above code vill give you all True because every item in the dict_items object is indeed a tuple. <code>a.items()</code> doesn't return tuples yet returns an object which holds tuples. </p>
</div>
<span class="comment-copy">Because you changed it....</span>
<span class="comment-copy">Their point is that how can it be changed if it returns tuples since tuples items can't be changed @ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000</span>
<span class="comment-copy"><code>keys</code> and <code>items</code> do not return tuples, they are their own type subclassed from the base type of Python.</span>
<span class="comment-copy">They don't. They return objects which holds tuples. Let me edit my answer so you can see it better. I even said they are the tuples inside the <code>dict_keys</code> object, I'm not sure why you are confused.</span>
<span class="comment-copy">This is kind of technical, and you can think of it as a tuple, but it does not have an internal tuple. It's really a memory view at the C code level</span>
<span class="comment-copy">@Olivier, I believe you. But if you cycled through <code>for i in a.items()</code>, would <code>i</code> act in all ways like you would expect a tuple to act, e.g. immutable, and so the only difference is the way it is held in memory?</span>
<span class="comment-copy">You are almost correct if you loop, because you don't have access to the object <code>a.items()</code> returned. but the whole point is that if you do <code>a[k] = v + '!!!'</code>, yes the object returned by <code>a.items()</code> actually changed.</span>
