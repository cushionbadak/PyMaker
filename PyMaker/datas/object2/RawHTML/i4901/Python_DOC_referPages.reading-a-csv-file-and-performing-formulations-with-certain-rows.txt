<div class="post-text" itemprop="text">
<p>I asked a question similar last night, but my professor gave some clarification on how she wants the question answered, and it's thrown me for a loop.</p>
<p>I've got a csv file with 3 columns.  I'm saving them as a dictionary, but I'm trying to find a way to read the <code>year</code> and the <code>title_field</code> and find a specific <code>title_field</code> (Occupied Housing Units), match it up with the earliest year (2008) and take the number in the <code>value</code> column next to those and match it to the NEXT <code>year</code> (2009) with the same <code>title_field</code> (Occupied Housing Units), find the difference between those two values, and print the outcome and do the same with 2009 &amp; 2010, etc. like this:</p>
<pre class="lang-none prettyprint-override"><code>2008-2009  795
2009-2010  5091
etc.
</code></pre>
<p>The csv looks like this:</p>
<pre class="lang-none prettyprint-override"><code>year,title_field,value
2014,Total Housing Units,49109
2014,Vacant Housing Units,2814
2014,Occupied Housing Units,46295
2013,Total Housing Units,47888
2013,Vacant Housing Units,4215
2013,Occupied Housing Units,43673
2012,Total Housing Units,45121
2012,Vacant Housing Units,3013
2012,Occupied Housing Units,42108
2011,Total Housing Units,44917
2011,Vacant Housing Units,4213
2011,Occupied Housing Units,40704
2010,Total Housing Units,44642
2010,Vacant Housing Units,3635
2010,Occupied Housing Units,41007
2009,Total Housing Units,39499
2009,Vacant Housing Units,3583
2009,Occupied Housing Units,35916
2008,Total Housing Units,41194
2008,Vacant Housing Units,4483
2008,Occupied Housing Units,36711
</code></pre>
<p>And the code I have so far is:</p>
<pre><code>import csv
def process(year, field_name, value):
    print(year, field_name, value)

with open('denton_housing.csv', 'r', encoding='utf8',newline='') as f:
    reader = csv.DictReader(f, delimiter=',')
    housing_stats = []
    for row in reader:
        year = row["year"]
        field_name = row["title_field"]
        value = int(row["value"])
        denton_dict = {"year": year, "field_name": field_name, "value": value}
        housing_stats.append(denton_dict)
        process(year, field_name, value)
</code></pre>
<p>Thanks!  I'm new to programming, and I'm an older dude.  I love that the programming community is beyond helpful, as if you all are welcoming everyone into a cult (the good kind?).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it like this:</p>
<ol>
<li>Create a <code>list</code> of those row <code>dicts</code>s which have the target <code>title_field</code> value in them.</li>
<li>Sort it by the year value in each one.</li>
<li>Use the <code>itertools</code> recipe for the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>pairwise()</code></a> generator to process each pair of rows/years in the sorted <code>list</code>.</li>
</ol>
<p>Code implementing the above:</p>
<pre><code>import csv
from itertools import tee

# From https://docs.python.org/3/library/itertools.html#recipes
def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

target_title_field = 'Occupied Housing Units'
csv_filename = 'denton_housing.csv'

with open(csv_filename, 'r', encoding='utf8', newline='') as f:
    housing_stats = []
    for row in csv.DictReader(f, delimiter=','):
        if row['title_field'] == target_title_field:
            year = int(row["year"])
            field_name = row["title_field"]
            value = int(row["value"])
            denton_dict = {"year": year, "field_name": field_name, "value": value}
            housing_stats.append(denton_dict)

housing_stats.sort(key=lambda row: row['year'])

for r1, r2 in pairwise(housing_stats):
    print('{}-{} {:5}'.format(r1['year'], r2['year'], abs(r2['value'] - r1['value'])))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>2008-2009   795
2009-2010  5091
2010-2011   303
2011-2012  1404
2012-2013  1565
2013-2014  2622
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One easy way is to use 3 lists(each of your title_field) to keep the year and value fields, then you can process each list.</p>
<pre><code>total = []
vacant = []
occupied = []

with open('denton_housing.csv', 'r', encoding='utf8',newline='') as f:
    spamreader = csv.reader(f, delimiter=',')
    for row in spamreader:
        if row[1] == 'Occupied Housing Units':
            # use the data structure you preferred, in this example I use tuple
            mytuple = (row[0], row[2])
            occupied.append(mytuple)
        # do the same for total and vacant list, ignore if you don't need
        ...

# then you can process the list, for example, occupied
# I assume your csv file is sorted by year, so you may safely assume that each 
# year field of the data entry in the occupied list is sorted as well
for i in range(len(occupied)-1):
    # if your data contains every year, ie 2008-2014 without missing any
    # the year field is useless in this case, so you can just
    value_diff = abs(occupied[i][1] - occupied[i+1][1])

# if the year entry is not sorted, and it may missed some years
occupied.sort(key=lambda x: x[0])    # this sort in ascending order
for i in range(len(occupied)-1):
    this_year = occupied[i][0]
    next_year = occupied[i+1][0]
    if next_year - this_year == 1:
        value_diff = abs(occupied[i][1] - occupied[i+1][1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you to use pandas for doing it.
Then you could use <code>groupby</code> and aggregation in a breeze.</p>
<p>like this:</p>
<pre><code>df.groupby(df['year'].dt.year)['a'].agg(['value'])
</code></pre>
<p>Result:</p>
<pre class="lang-none prettyprint-override"><code>2012   14   
2015    6
</code></pre>
</div>
<span class="comment-copy">I LOVE this answer.  I don't want you to take time out of your day, but I wish I knew how this code worked, line by line.  I really hope I learn to interpret the code as I keep going!  Thank you!</span>
<span class="comment-copy">ArchivistG: You're welcome. I'm sure you'll be able to figure-out how most of the code works since most of it is fairly straight-forwardâ€”however you may find the <code>pairwise()</code> generator function more of a challenge to understand. Iterators and generators are both very powerful and useful features in Python, especially in version 3, so any extra effort it requires ought to be well worth your study time.</span>
