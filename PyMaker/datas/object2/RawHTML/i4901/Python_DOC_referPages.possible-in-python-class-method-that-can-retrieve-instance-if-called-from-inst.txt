<div class="post-text" itemprop="text">
<p>Thinking about this and I'm wondering if it is possible (and if so, how to make such a decorator etc.) to have a classmethod, that IF called from an instance, can retrieve data on the instance?  Perhaps some more clarity on how the staticmethod and classmethod decorators work would be helpful too (looking at the implementation __builtin__.py did not help)</p>
<p>Example use would be:</p>
<pre><code>class A(object):

    def __init__(self, y):
        self.y = y

    @classmethod
    def f(cls, x, y=None):

        # if y is unspecified, retrieve it from cls which is presumably an instance 
        # (should throw an error if its a class because y is not set
        if y is None:
            y = cls.y

        return x + y
</code></pre>
<p>So that we could do:</p>
<pre><code>&gt;&gt;&gt;A.f(3, 5)
8

&gt;&gt;&gt;a = A(5)
&gt;&gt;&gt;a.f(3)
8
</code></pre>
<p>I came up with this below to mimic the behavior but its pretty inconvenient to implement:</p>
<pre><code>class A(object):

    def __init__(self, y):
        self.y = y
        self.f = self.f_

    def f_(self, x):
        return x + self.y

    @classmethod
    def f(cls, x, y):
        return x + y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To expand on the comments made by @Adirio You could make a decorator that accomplishes this dynamically.</p>
<p>In this particular implementation, when the decorated method is called it will do a partial bind of the provided arguments to the method and uses the method's signature to determine what parameters have not been provided. </p>
<p>For any unspecified argument, if the calling object has an attribute matching the unspecified parameter name, the object's attribute value will be injected into the function.</p>
<pre><code>import inspect
class BindableConstructor(object):
    def __init__(self, meth):
        self.meth = meth
        self.sig = inspect.signature(self.meth)

    def __get__(self, obj, klass=None):
        if obj is not None:
            print('Method ', repr(self.meth), ' called from instance ', repr(obj))
        if klass is None:
            klass = type(obj)
        def newmeth(*args, **kwargs):
            ba = self.sig.bind_partial(*args, **kwargs)
            ba.apply_defaults()
            for paramname in self.sig.parameters:
                if paramname not in ba.arguments and hasattr(obj, paramname):
                    ba.arguments[paramname] = getattr(obj, paramname)
            return self.meth(klass, *ba.args, **ba.kwargs)
        return newmeth
</code></pre>
<p>Then suppose you have the following class using this decorator</p>
<pre><code>class MyClass(object):
    def __init__(self, y):
        self.y = y

    @BindableConstructor
    def my_constructor(cls, x, y):
        return cls(x + y)
</code></pre>
<p>Then the following behavior would be observed</p>
<pre><code>&gt;&gt;&gt; a = MyClass(5)
&gt;&gt;&gt; b = MyClass.my_constructor(3, 2)
&gt;&gt;&gt; b
&lt;__main__.MyClass object at 0x0605C770&gt;
&gt;&gt;&gt; b.y
5
&gt;&gt;&gt; c = b.my_constructor(3) # c.y == b.y + 3
Method  &lt;function MyClass.my_constructor at 0x05396420&gt;  called from instance  &lt;__main__.MyClass object at 0x0605C770&gt;
&gt;&gt;&gt; c.y
8
</code></pre>
<p>In this particular case <code>ba.apply_defaults</code> is called <em>before</em> checking the object's attributes to inject. If you want the object's attributes to take precedence over defaults, call <code>ba.apply_defaults</code> <em>after</em> the parameter injection logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you try you example, you get an error saying 
<em>AttributeError: type object 'A' has no attribute 'y'</em>, because in constructor, you assigned <code>y</code> as an attribute of the object and not of the class.</p>
<p>The trivial fix:</p>
<pre><code>class A(object):

    def __init__(self, y):
        A.y = y

    @classmethod
    def f(cls, x, y=None):

        # if y is unspecified, retrieve it from cls which is presumably an instance 
        # (should throw an error if its a class because y is not set
        if y is None:
            y = cls.y

        return x + y
</code></pre>
<p>Would indeed solve the error, but as the class will only know one single object at a time, you would get weird result as soon as you use more than one:</p>
<pre><code>&gt;&gt;&gt; A.f(3,5)
8
&gt;&gt;&gt; a = A(5)
&gt;&gt;&gt; a.f(3)             # fine till there...
8
&gt;&gt;&gt; b = A(7)
&gt;&gt;&gt; a.f(3)             # last created object wins here!
10
</code></pre>
<p>So the only foolproof way is to create an attribute with the name of the class function in each object. As you only call a class method, a lamdba is enough:</p>
<pre><code>class A(object):

    def __init__(self, y):
        self.y = y
        self.f = lambda x: A.f(x, y)   # declare a shortcut for the class method

    @classmethod
    def f(cls, x, y=None):
        return x + y
</code></pre>
<p>You can then safely do:</p>
<pre><code>&gt;&gt;&gt; A.f(3,5)
8
&gt;&gt;&gt; a = A(5)
&gt;&gt;&gt; a.f(3)
8
&gt;&gt;&gt; b = A(7)
&gt;&gt;&gt; a.f(3)
8
&gt;&gt;&gt; b.f(3)
10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do not forget to handle error cases.</p>
<pre><code>class InstanceAndClassMethod(object):

    def __init__(self, f):
        self.f = f

    def __get__(self, instance, owner=None):
        if instance is None:
            instance = owner
        def newfunc(*args, **kwargs):
            return self.f(instance, *args, **kwargs)
        return newfunc

class A(object):

    def __init__(self, y):
        self.y = y

    @InstanceAndClassMethod
    def f(cls, x, y=None):
        try:
            y = cls.y if y is None else y
        except AttributeError:
            raise TypeError("f() missing 1 required positional argument: 'y'")
        return x + y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the help of docs.python.org/3/howto/descriptor.html I came up with this, seems to work:</p>
<pre><code>class CoolerClassMethod(object):

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass):
        if obj is None:
            self_ = klass
        else:
            self_ = obj
        def newfunc(*args, **kwargs):
            return self.f(self_, *args, **kwargs)
        return newfunc

class A(object):

    def __init__(self, y):
        self.y = y

    @CoolerClassMethod
    def f(cls, x, y=None):
        y = cls.y if y is None else y
        return x + y
</code></pre>
<p>Testing:</p>
<pre><code>&gt;&gt;&gt; a = A(5)
&gt;&gt;&gt; A.f(3, 5)
8
&gt;&gt;&gt; a.f(3)
8
&gt;&gt;&gt; A.f(3, 5)
8
</code></pre>
</div>
<span class="comment-copy">So you want a function that acts both as a classmethod and as an instance method?</span>
<span class="comment-copy">I think you may have some misunderstanding of what classmethods are for. See <a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner">this question</a> first for clarification on staticmethods and classmethods.</span>
<span class="comment-copy">Yes, I want function that acts both as a classmethod and as an instance method (since classmethods can be called from instances too) I understand what classmethods are intended for, I'm asking how to create a decorator that has different behavior for this use case.  Perhaps if there were a way to rebind a function through a decorator when <b>init</b> is called we could achieve this.  I'm sure it will be tricky but I'm curious nonetheless because this would be very "cool"</span>
<span class="comment-copy">I like this but is it only for Python 3? Inspect module doesn't have signature in Python2.7</span>
<span class="comment-copy">@TheDude, <code>inspect.signature</code> was introduced in Python3. In Python2 there is <a href="https://docs.python.org/2/library/inspect.html#inspect.getargspec" rel="nofollow noreferrer"><code>inspect.getargspec</code></a>,   and <code>inspect.getcallargs</code> which should provide information necessary to accomplish something analogous to this.  There are also 3rd party <a href="https://pypi.python.org/pypi/funcsigs" rel="nofollow noreferrer">packages that claim to add this functionality for Python2</a></span>
<span class="comment-copy"><code>import inspect</code> is strictly prohibited in my production code</span>
<span class="comment-copy">How unfortunate @Adirio. I can identify with the sentiment, but there are plenty of production-suitable use cases for <code>inspect</code>. Everybody has unique needs, do what's right for you. That said, I should have probably made more clear that, if the only goal is to determine the calling instance, that is accomplished in the first two lines of the <code>__get__</code> method and <code>inspect</code> is not required. I was just trying to apply the idea in some meaningful way in the following lines.</span>
<span class="comment-copy">Thank you, this is what I was working towards as well, I'm wondering if its possible to get this rebinding behavior via the decorator (for python coolness)</span>
<span class="comment-copy">@TheDude decorators are executed when evaluating the class not when creating an instance, so I expect the answer to your question to be no. You may be able to get this kind of behaviour with meta-classes though</span>
<span class="comment-copy">Actually don't pay attentio to my comment, it may be doable with decorators, as <code>classmethod</code> can be implemented in pure Python. <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html</a></span>
<span class="comment-copy">@Adirio: it can certainly be implemented with decorators, but without a clear specification of how the class method can be declared (what about the number of parameters, whether they can have keywords or be keyword only, whether an aggregate list like <code>*args</code> is allowed) and how the instance one will be called (how many parameters associated to the instance, where they should go), a fully general decorator will be hard to implement in Python3 and even harder in Python2 where you will at least lose any signature information.</span>
<span class="comment-copy">Thank you for the link, see the post for what I came up with.</span>
<span class="comment-copy">I gave an other answer proposing some modifications to your code to handle error cases so that it shows the appropiate error.</span>
