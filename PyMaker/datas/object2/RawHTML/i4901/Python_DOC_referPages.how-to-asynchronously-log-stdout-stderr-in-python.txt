<div class="post-text" itemprop="text">
<p>I have a function (which I cannot change) and it prints data to stdout/stderr. I need to log the output of this function. My first idea was to replace <code>sys.stdout</code> with a buffer in the form of <code>StringIO()</code> and then process its contents. That worked well, but the problem is, when the function fails, it prints the error message and <strong>exits the current process</strong>. In that case, contents of the buffer are lost, because my code after function call is never executed.</p>
<p>So my idea was to somehow watch the buffer asynchronously and process its contents immediatelly when there are data to be read. I tried a solution with <code>asyncio</code> and its <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_reader" rel="nofollow noreferrer">add_reader</a> method, but that seems to not support <code>StringIO()</code> and not even a regular file.</p>
<p>This is my first try to just asynchronously print the stdout:</p>
<pre><code>import asyncio
import sys
from io import StringIO

async def f():
    print('Some output')

def logger(buffer):
    sys.__stdout__.write(buffer.read())

buffer = StringIO()
sys.stdout = buffer

loop = asyncio.get_event_loop()
loop.add_reader(buffer, logger, buffer)
loop.run_until_complete(f())
</code></pre>
<p>That fails with</p>
<pre><code>ValueError: Invalid file object: &lt;_io.StringIO object at 0x7f8a93e9aa68&gt;
</code></pre>
<p>Is there any solution to this problem? At least I need to clarify if my approach makes sense.</p>
<p><strong>UPDATE:</strong>
I have discovered standard module <code>atexit</code>, which can call a function upon interpreter exit. This is another way to solve my problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a custom subclass of <code>io.TextIOBase</code> and replace <code>sys.stdout</code> with an instance of your custom class.  The <code>write()</code> method of your class will be called whenever output is sent to <code>sys.stdout</code>.  Optionally you can forward all output to the original stdout:</p>
<pre><code>class MyStdOut(io.TextIOBase):
    def __init__(self, orig_stdout=None):
        self.orig_stdout = orig_stdout
    def write(self, s):
        # Process output in whatever way you like
        process(s)
        # Write output to original stream, if desired
        if self.orig_stdout:
            self.orig_stdout.write(s)

sys.stdout = MyStdOut(sys.stdout)
</code></pre>
<p>This aproach wil be completely synchronous â€“ no threads or asynchronous I/O needed.</p>
</div>
<span class="comment-copy">can you post what you've got so far?</span>
<span class="comment-copy">Can you just stop the program from... eh... <i>stopping</i> instead of monitoring the buffer? If there's an exception, you can just catch it and go on.</span>
<span class="comment-copy">@Phydeaux I just updated my post.</span>
<span class="comment-copy">@ForceBru The exception is processed inside the function, it will never return from the function call.</span>
<span class="comment-copy">@rubick I've turned the comment into an answer.</span>
