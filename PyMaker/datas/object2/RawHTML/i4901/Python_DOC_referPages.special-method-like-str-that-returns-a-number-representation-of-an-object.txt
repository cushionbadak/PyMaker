<div class="post-text" itemprop="text">
<p>Say I have a Python class as follows: </p>
<pre><code>class TestClass():
    value = 20

    def __str__(self):
        return str(self.value)
</code></pre>
<p>The <code>__str__</code> method will automatically be called any time I try to use an instance of <code>TestClass</code> as a string, like in <code>print</code>. Is there any equivalent for treating it as a number? For example, in</p>
<pre><code>an_object = TestClass()
if an_object &gt; 30:
    ...
</code></pre>
<p>where some hypothetical <code>__num__</code> function would be automatically called to interpret the object as a number. How could this be easily done?</p>
<p>Ideally I'd like to avoid overloading every normal mathematical operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can provide <code>__float__()</code>, <code>__int__()</code>, and/or <code>__complex__()</code> methods to convert objects to numbers. There is also a <code>__round__()</code> method you can provide for custom rounding. <a href="https://docs.python.org/3/reference/datamodel.html#object.__complex__" rel="nofollow noreferrer">Documentation here</a>. The <code>__bool__()</code> method technically fits here too, since Booleans are a subclass of integers in Python.</p>
<p>While Python does implicitly convert objects to strings for e.g. <code>print()</code>, it never converts objects to numbers without you saying to. Thus, <code>Foo() + 42</code> isn't valid just because <code>Foo</code> has an <code>__int__</code> method. You have to explicitly use <code>int()</code> or <code>float()</code> or <code>complex()</code> on them. At least that way, you know what you're getting just by reading the code.</p>
<p>To get classes to actually behave like numbers, you have to implement all the special methods for the operations that numbers participate in, including arithmetic and comparisons. As you note, this gets annoying. You can, however, write a mixin class so that at least you only have to write it once. Such as:</p>
<pre><code>class NumberMixin(object):

    def __eq__(self, other):    return self.__num__() == self.__getval__(other)
    # other comparison methods

    def __add__(self, other):   return self.__num__() + self.__getval__(other)
    def __radd__(self, other):  return self.__getval__(other) + self.__num__()
    # etc., I'm not going to write them all out, are you crazy?
</code></pre>
<p>This class expects two special methods on the class it's mixed in with.</p>
<ul>
<li><code>__num__()</code> - converts <code>self</code> to a number. Usually this will be an alias for the conversion method for the most precise type supported by the object. For example, your class might have <code>__int__()</code> and <code>__float__()</code> methods, but <code>__int__()</code> will truncate the number, so you assign <code>__num__ = __float__</code> in your class definition. On the other hand, if your class has a natural integral value, you might want to provide <code>__float__</code> so it can also be converted to a float, but you'd use <code>__num__ = __int__</code> since it should behave like an integer.</li>
<li><code>__getval__()</code> - a static method that obtains the numeric value from another object. This is useful when you want to be able to support operations with objects other than numeric types. For example, when comparing, you might want to be able to compare to objects of your own type, as well as to traditional numeric types. You can write <code>__getval__()</code> to fish out the right attribute or call the right method of those other objects. Of course with your own instances you can just rely on <code>float()</code> to do the right thing, but <code>__getval__()</code> lets you be as flexible as you like in what you accept.</li>
</ul>
<p>A simple example class using this mixin:</p>
<pre><code>class FauxFloat(NumberMixin):

    def __init__(self, value):     self.value = float(value)
    def __int__(self):             return int(self.value)
    def __float__(self):           return float(self.value)
    def __round__(self, digits=0): return round(self.value, digits)
    def __str__(self):             return str(self.value)

    __repr__ = __str__
    __num__  = __float__

    @staticmethod
    def __getval__(obj):
        if isinstance(obj, FauxFloat):
            return float(obj)
        if hasattr(type(obj), "__num__") and callable(type(obj).__num__):
            return type(obj).__num__(obj)   # don't call dunder method on instance
        try:
            return float(obj)
        except TypeError:
            return int(obj)

ff = FauxFloat(42)
print(ff + 13)    # 55.0
</code></pre>
<p>For extra credit, you could register your class so it'll be seen as a subclass of an appropriate abstract base class:</p>
<pre><code>import numbers
numbers.Real.register(FauxFloat)
issubclass(FauxFloat, numbers.Real)   # True
</code></pre>
<p>For extra extra credit, you might also create a global <code>num()</code> function that calls <code>__num__()</code> on objects that have it, otherwise falling back to the older methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>In case of numbers it a bit more complicated. But its possible! You have to override your class operators to fit your needs.</p>
<pre><code>operator.__lt__(a, b)    # lower than

operator.__le__(a, b)    # lower equal

operator.__eq__(a, b)    # equal

operator.__ne__(a, b)    # not equal

operator.__ge__(a, b)    # greater equial

operator.__gt__(a, b)    # greater than
</code></pre>
<p><a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">Python Operators</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like you need <code>__gt__</code> method.</p>
<pre><code>class A:
    val = 0

    def __gt__(self, other):
        return self.val &gt; other


a = A()
a.val = 12
a &gt; 10
</code></pre>
<p>If you just wanna cast object to int - you should define <code>__int__</code> method (or <code>__float__</code>).</p>
</div>
<span class="comment-copy">Provide <code>__int__()</code> or <code>__float__()</code> according to your need (or <code>__complex__()</code>). <a href="https://docs.python.org/3/reference/datamodel.html#object.__complex__" rel="nofollow noreferrer">Docs</a></span>
<span class="comment-copy">Not a duplicate, but highly related: <a href="https://stackoverflow.com/questions/19750394/dynamically-overriding-functions-in-python" title="dynamically overriding functions in python">stackoverflow.com/questions/19750394/â€¦</a></span>
<span class="comment-copy">I should mention that Python does not convert to numeric type implicitly, while it <i>does</i> convert implicitly to strings for some operations. For that, you do need to override all the methods (<code>__add__()</code> etc. as well as <code>__eq__()</code> etc.). You could write a mixin class for that so as not to have to repeat yourself.</span>
<span class="comment-copy">@kindall You really should write this up as an answer.  I was about to, but you know it better than I.</span>
<span class="comment-copy">@ScottMermelstein Done.</span>
<span class="comment-copy">Great answer, thank you. :)</span>
<span class="comment-copy">That'll work for one operator, but I'm hoping for a more general solution without having to implement the 15 or so operator override methods for the sake of cleanliness.</span>
<span class="comment-copy">Python has static typing. So you you should override methods or cast one to another.</span>
