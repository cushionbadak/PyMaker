<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2502833/store-output-of-subprocess-popen-call-in-a-string">Store output of subprocess.Popen call in a string</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>How can I get the output of a process run using <code>subprocess.call()</code>?</p>
<p>Passing a <code>StringIO.StringIO</code> object to <code>stdout</code> gives this error:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/subprocess.py", line 444, in call
    return Popen(*popenargs, **kwargs).wait()
  File "/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/subprocess.py", line 588, in __init__
    errread, errwrite) = self._get_handles(stdin, stdout, stderr)
  File "/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/subprocess.py", line 945, in _get_handles
    c2pwrite = stdout.fileno()
AttributeError: StringIO instance has no attribute 'fileno'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Output from <code>subprocess.call()</code> should only be redirected to files.</p>
<p>You should use <code>subprocess.Popen()</code> instead. Then you can pass <code>subprocess.PIPE</code> for the stderr, stdout, and/or stdin parameters and read from the pipes by using the <code>communicate()</code> method:</p>
<pre><code>from subprocess import Popen, PIPE

p = Popen(['program', 'arg1'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
output, err = p.communicate(b"input data that is passed to subprocess' stdin")
rc = p.returncode
</code></pre>
<p>The reasoning is that the file-like object used by <code>subprocess.call()</code> must have a real file descriptor, and thus implement the <code>fileno()</code> method. Just using any file-like object won't do the trick.</p>
<p>See <a href="http://docs.python.org/library/subprocess.html#replacing-shell-pipeline" rel="noreferrer">here</a> for more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have Python version &gt;= 2.7, you can use <a href="http://docs.python.org/library/subprocess.html#subprocess.check_output" rel="noreferrer">subprocess.check_output</a> which basically does exactly what you want (it returns standard output as string).</p>
<p>Simple example (linux version, see note):</p>
<pre><code>import subprocess

print subprocess.check_output(["ping", "-c", "1", "8.8.8.8"])
</code></pre>
<p>Note that the ping command is using linux notation (<code>-c</code> for count). If you try this on Windows remember to change it to <code>-n</code> for same result.</p>
<p>As commented below you can find a more detailed explanation in <a href="https://stackoverflow.com/a/8235171/881224">this other answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have the following solution. It captures the exit code, the stdout, and the stderr too of the executed external command:</p>
<pre><code>import shlex
from subprocess import Popen, PIPE

def get_exitcode_stdout_stderr(cmd):
    """
    Execute the external command and get its exitcode, stdout and stderr.
    """
    args = shlex.split(cmd)

    proc = Popen(args, stdout=PIPE, stderr=PIPE)
    out, err = proc.communicate()
    exitcode = proc.returncode
    #
    return exitcode, out, err

cmd = "..."  # arbitrary external command, e.g. "python mytest.py"
exitcode, out, err = get_exitcode_stdout_stderr(cmd)
</code></pre>
<p>I also have a blog post on it <a href="http://pythonadventures.wordpress.com/2014/01/08/capture-the-exit-code-the-stdout-and-the-stderr-of-an-external-command/" rel="noreferrer">here</a>.</p>
<p><strong>Edit:</strong> the solution was updated to a newer one that doesn't need to write to temp. files.</p>
</div>
<div class="post-text" itemprop="text">
<p>For python 3.5+ it is recommended that you use the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run">run function from the subprocess module</a>. This returns a <code>CompletedProcess</code> object, from which you can easily obtain the output as well as return code.</p>
<pre><code>from subprocess import PIPE, run

command = ['echo', 'hello']
result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)
print(result.returncode, result.stdout, result.stderr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I recently just figured out how to do this, and here's some example code from a current project of mine:</p>
<pre><code>#Getting the random picture.
#First find all pictures:
import shlex, subprocess
cmd = 'find ../Pictures/ -regex ".*\(JPG\|NEF\|jpg\)" '
#cmd = raw_input("shell:")
args = shlex.split(cmd)
output,error = subprocess.Popen(args,stdout = subprocess.PIPE, stderr= subprocess.PIPE).communicate()
#Another way to get output
#output = subprocess.Popen(args,stdout = subprocess.PIPE).stdout
ber = raw_input("search complete, display results?")
print output
#... and on to the selection process ...
</code></pre>
<p>You now have the output of the command stored in the variable "output".  "stdout = subprocess.PIPE" tells the class to create a file object named 'stdout' from within Popen.  The communicate() method, from what I can tell, just acts as a convenient way to return a tuple of the the output and the errors from the process you've run.  Also, the process is run when instantiating Popen.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>Ipython</code> shell:</p>
<pre><code>In [8]: import subprocess
In [9]: s=subprocess.check_output(["echo", "Hello World!"])
In [10]: s
Out[10]: 'Hello World!\n'
</code></pre>
<p>Based on sargue's answer. Credit to sargue.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following captures stdout and stderr of the process in a single variable.  It is Python 2 and 3 compatible:</p>
<pre><code>from subprocess import check_output, CalledProcessError, STDOUT

command = ["ls", "-l"]
try:
    output = check_output(command, stderr=STDOUT).decode()
    success = True 
except CalledProcessError as e:
    output = e.output.decode()
    success = False
</code></pre>
<p>If your command is a string rather than an array, prefix this with:</p>
<pre><code>import shlex
command = shlex.split(command)
</code></pre>
</div>
<span class="comment-copy">Mike's answer is correct.  Note that <code>StringIO</code> works like a file <i>in most cases</i> but not all.  It doesn't work in your case because the <code>multiprocessing</code> module assumes actual files in some cases.  This may have been fixed: see <a href="http://bugs.python.org/issue5313" rel="nofollow noreferrer">bugs.python.org/issue5313</a> for a related bug.</span>
<span class="comment-copy">Actually, <code>communicate()</code> uses <code>select.select()</code>, which only accepts file descriptors, so it isn't really a bug. I was quite confused by this when I first encountered it and exploring the depths of subprocess.py taught me a lot!.</span>
<span class="comment-copy">I think <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run</code></a> makes this simpler, as of Python 3.5. I'll add an answer when I get a chance.</span>
<span class="comment-copy">this page <a href="http://docs.python.org/library/subprocess.html#module-subprocess" rel="nofollow noreferrer">docs.python.org/library/subprocess.html#module-subprocess</a> discourages using <code>subprocess.PIPE</code>, any idea how to overcome this?</span>
<span class="comment-copy">also, the question especifies using subprocess.call and Mike's answer is using Popen in fact, as subprocess.call only return the returncode, but no means of accessing any of the streams. That's if using 2.6, if using 2.7 @Sergi answer could be used</span>
<span class="comment-copy">@Halst: the docs warn about <code>PIPE</code> for the <code>call()</code> call (don't use <code>PIPE</code> in this case). It is fine to use <code>PIPE</code> with <code>subprocess.Popen</code> e.g., <code>output, _ = Popen(..., stdout=PIPE).communicate()</code> as this answer suggests.</span>
<span class="comment-copy">@NathanBasanese: in short: doesn't use <code>PIPE</code> unless you consume the pipe. <code>call()</code> is <code>Popen().wait()</code> and therefore it does not consume the pipes (as soon as the corresponding OS pipe buffer fills, the child process will hang forever). <code>Popen().communicate()</code> writes/reads data from pipes if <code>PIPE</code> is used thus allowing the child process to continue.</span>
<span class="comment-copy">// , Ah, OK. That makes sense. Weird that it even allows PIPE as an argument, then. Anyway, I was a good StackOverFlow citizen, though, and made a question for it: <a href="http://stackoverflow.com/questions/32364849/what-difference-between-subprocess-call-and-subprocess-popen-makes-pipe" title="what difference between subprocess call and subprocess popen makes pipe">stackoverflow.com/questions/32364849/â€¦</a> would you be willing to throw that in as the answer?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/8235171/881224">Found another answer with working code</a>. Please upvote if you used it.</span>
<span class="comment-copy">But be aware that check_output will throw an exception if the process returns a non zero exit code.</span>
<span class="comment-copy">Note that <code>check_output</code> suffers from the PIPE filling up problem as <code>run</code> since it's just calling <code>run</code>. So if you have a process generating a bit more output it will hang indefinitely. The <code>Popen</code> solution from <a href="https://stackoverflow.com/a/1996540/220986">@Mike's</a> and <a href="https://stackoverflow.com/a/21000308/220986">@Jabba's</a> answers works a lot better</span>
<span class="comment-copy">But the other answer does not demonstrate how to read stdout from check_call.</span>
<span class="comment-copy">You should really put it in your answer though.</span>
<span class="comment-copy">Thanks. Great answer.</span>
<span class="comment-copy">@Jabba for some reason it wouldn't work unless I added <code>shell=True</code> to the arguments of Popen(), could you explain why?</span>
<span class="comment-copy">@JaeGeeTee: What is the command you wanted to call? My guess is that you wanted to call a command that contains pipes (e.g. "<code>cat file.txt | wc -l</code>").</span>
<span class="comment-copy">@Jabba I was running <code>ping 127.0.0.1</code></span>
<span class="comment-copy">@JaeGeeTee - try using /bin/ping explicitly?</span>
<span class="comment-copy">This is a brilliant answer.  But don't overlook the 'stdout=PIPE' part, as I did the first time around, otherwise the output will be very shortlived!</span>
<span class="comment-copy">Doesn't really answer the question of how to use call (judiciously.)</span>
<span class="comment-copy">Good to see the example here.</span>
<span class="comment-copy"><code>s=subprocess.check_output(["echo", "Hello World!"]); print(s)</code> prints as <code>b'Hello World!\n'</code> how could I get rid of <code>b''</code>index ? @jhegedus</span>
<span class="comment-copy"><code>subprocess.check_output</code> you mean. Works great. Finally, a func that does what everyone actually expects.</span>
<span class="comment-copy">@sudo sorry.  forgot the import statement</span>
<span class="comment-copy">Np, was easy to search. BTW, it also has an <code>input=</code> option to specify input to pipe into the command instead of that super-overly-complicated way of doing it with <code>Popen</code>.</span>
<span class="comment-copy">great because it works even with non-zero exit code!</span>
<span class="comment-copy">@Matt edited the import</span>
