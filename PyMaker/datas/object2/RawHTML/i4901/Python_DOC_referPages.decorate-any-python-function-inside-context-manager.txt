<div class="post-text" itemprop="text">
<p>I would like to create a python context manager, which would allow the following (with reverse_decorator applying the decorated function with first argument reversed if it is string):</p>
<pre><code>print('hi')
with MyFunctionDecorator('print', reverse_decorator):
    print('hello')
print('bye')
</code></pre>
<p>to result in:</p>
<pre><code>hi
olleh
bye
</code></pre>
<p>The point is not the print function itself, but writing this kind of context manager, that could decorate any function - local, global, builtin, from whatever module.  Is this even possible in python? How should I do it?</p>
<p>EDIT: To clarify a bit, the point was not to have to change the code inside the <em>with</em> context.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is my approach:</p>
<pre><code>from contextlib import contextmanager
from importlib import import_module

@contextmanager
def MyFunctionDecorator(func, decorator):
    if hasattr(func, '__self__'):
        owner = func.__self__
    elif hasattr(func, '__objclass__'):
        owner = func.__objclass__
    else:
        owner = import_module(func.__module__)
        qname = func.__qualname__
        while '.' in qname:
            parent, qname = qname.split('.', 1)
            owner = getattr(owner, parent)
    setattr(owner, func.__name__, decorator(func))
    yield
    setattr(owner, func.__name__, func)

# Example decorator, reverse all str arguments
def reverse_decorator(f):
    def wrapper(*args, **kwargs):
        newargs = []
        for arg in args:
            newargs.append(arg[::-1] if isinstance(arg, str) else arg)
        newkwargs = {}
        for karg, varg in kwargs.values():
            newkwargs[karg] = varg[::-1] if isinstance(varg, str) else varg
        return f(*newargs, **newkwargs)
    return wrapper

# Free functions
print('hi')
with MyFunctionDecorator(print, reverse_decorator):
    print('hello')
print('bye')

# Class for testing methods (does not work with builtins)
class MyClass(object):
    def __init__(self, objId):
        self.objId = objId
    def print(self, arg):
        print('Printing from object', self.objId, arg)

# Class level (only affects instances created within managed context)
# Note for decorator: first argument of decorated function is self here
with MyFunctionDecorator(MyClass.print, reverse_decorator):
    myObj = MyClass(1)
    myObj.print('hello')

# Instance level (only affects one instance)
myObj = MyClass(2)
myObj.print('hi')
with MyFunctionDecorator(myObj.print, reverse_decorator):
    myObj.print('hello')
myObj.print('bye')
</code></pre>
<p>Output:</p>
<pre><code>hi
olleh
bye
Printing from object 1 olleh
Printing from object 2 hi
Printing from object 2 olleh
Printing from object 2 bye
</code></pre>
<p>This should work across functions and other modules and so on, since it modifies the attributes of the module or class. Class methods are complicated, because once you create an instance of a class its attributes point to the functions defined in the class <em>at the time the object was created</em>, so you have to choose between modifying the behavior of a particular instance or modifying the behavior of new instances within the managed context, as in the example. Also, trying to decorate methods of builtin classes like <code>list</code> or <code>dict</code> does not work.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible if you modify it add a bit:</p>
<pre><code>print('hi')
with MyFunctionDecorator(print, reverse_decorator) as print:
    print('hello')
print('bye')
</code></pre>
<p>Here is a definition that works for this example*:</p>
<pre><code>def reverse_decorator(func):
    def wrapper(*args, **kwargs):
        if len(args) == 1 and not kwargs and isinstance(args[0], str):
            return func(args[0][::-1])
        return func(*args, **kwargs)
    return wrapper

class MyFunctionDecorator:
    def __init__(self, func, decorator):
        self.func = func
        self.decorator = decorator

    def __enter__(self):
        """Return the decorated function"""
        return self.decorator(self.func)

    def __exit__(self, *args):
        """Reset the function in the global namespace"""
        globals()[self.func.__name__] = self.func
</code></pre>
<hr/>
<p>But its probably easier to just do it explicitly, following the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Python Zen</a>:</p>
<pre><code>print('hi')
print('hello'[::-1])
print('bye')
</code></pre>
<hr/>
<p>*This code does not work under many circumstances, as <a href="https://stackoverflow.com/users/1222951/aran-fey">@AranFey</a> noted in <a href="https://stackoverflow.com/questions/49034642/decorate-any-python-function-inside-context-manager/49035013#comment85074890_49035013">the comments</a>:</p>
<ul>
<li>Inside functions</li>
<li>If the function you want to decorate is imported with <code>import x from y as z</code></li>
<li>If you care that afterwards you have a <code>print</code> function defined in the <code>globals()</code>, instead of directly being a built-in</li>
</ul>
<p>Since this is more a proof-of-concept, that yes, one can write a decorator that works in this example, I will not try to fix these shortcomings. Just use the way I gave above, or use only the decorator:</p>
<pre><code>print('hi')
reverse_decorator(print)('hello')
print('bye')
</code></pre>
</div>
<span class="comment-copy">you could use some form of <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer"><code>patch</code></a> from the <code>mock</code> module. I don't know if it supports patching builtins like print though.</span>
<span class="comment-copy">ok you should be able to do it by patching <code>__builtins__.print</code>. patch still won't work with anything that isnt importable though.</span>
<span class="comment-copy">There is no not-hacky way to do this. In some cases it's simply not possible to decorate/replace a function - if the function was defined in a local scope or a closure, for example.</span>
<span class="comment-copy">Caveats: 1) You're assuming that the function's is accessible on its owner as <code>func.__name__</code>, so your code gets tripped up by things like <code>from builtins import print as pprint</code> (trying to decorate <code>pprint</code> will do nothing). 2) The decorator becomes active in the whole program, not just within the <code>with</code> block. 3) Doesn't work if the decorated function has no qualname (that is, the qualname contains <code>&lt;locals&gt;</code> or something similar).</span>
<span class="comment-copy">@Aran-Fey Yes, all true, thanks for pointing out. I didn't think of 1), I guess maybe you could work around it by passing the function name as string, then replacing also (or only?) the names in the module (<code>__main__</code> or wherever it is from)... quite hacky, though :S (I mean, <i>even</i> more). And yes, 2) is important in multithreaded contexts... I can't imagine a workaround for that. I suppose 3) is most noticeable for lambdas and decorated functions... again, maybe circumventable with hacky string-based solution.</span>
<span class="comment-copy">Btw, I initially misread the question thinking that the OP wanted a decorator applied to <i>every</i> function call, not just one particular function, and I pondered a solution based on <a href="https://docs.python.org/3/library/sys.html#sys.setprofile" rel="nofollow noreferrer"><code>sys.setprofile</code></a>. It's a rather overkill approach for a single function, but it could be a possible path to it too, I guess...</span>
<span class="comment-copy">Note that this doesn't work inside functions. You'll get a <code>UnboundLocalError: local variable 'print' referenced before assignment</code> error. The code also assumes that the function was defined in the global scope, which might not be true - <code>print</code> is defined in <code>builtins</code>, so this context manager has the side effect of adding <code>print</code> to the globals. And finally, it assumes that the function was registered as <code>func.__name__</code>, which is not the case if the function has been imported as <code>from x import func as func_alias</code>, for example.</span>
<span class="comment-copy">@Aran-Fey Yeah, you are right. Not sure how to fix that. But then again this is already so hackish, I would not want to use this in production anyways.</span>
