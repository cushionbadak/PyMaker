<div class="post-text" itemprop="text">
<p>I need to rewrite this awful piece of code using recursion in Python. The depth of the nesting should depend on argument of function rec but eventaully I'd like it to be length of the variable "a", which is string. I'd be grateful for any responses and clues how to approach this problem.  </p>
<pre><code>def rec():
    count=0
    for i in range(len(letters)):
        for j in range(i+1, len(letters)):
            if letters[i]+letters[j] in a:
                for k in range(j+1, len(letters)):
                    if letters[i]+letters[j]+letters[k] in a:
                        if letters[i]+letters[j]+letters[k]==a:
                            count+=1
                        else:
                            for l in range(k+1, len(letters)):
                                if letters[i]+letters[j]+letters[k]+letters[l]==a:
                                    count+=1

    return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>FWIW, some kinds of combinatoric logic are more easily expressed with <a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="noreferrer">itertools</a> than with recursion.  For example, when this pattern occurs:</p>
<pre><code>letters = 'ABCDEF'
for i in range(len(letters)):
    a = letters[i]
    for j in range(i+1, len(letters)):
        b = letters[j]
        for k in range(j+1, len(letters)):
            c = letters[k]
            print(a, b, c)
</code></pre>
<p>It can be replaced with this:</p>
<pre><code>from itertools import combinations

letters = 'ABCDEF'
for a, b, c in combinations(letters, 3):
    print(a, b, c)
</code></pre>
<p>There is more to your question than this, but I wanted to point out that combinatoric functions are a good starting point for the kind of logic posed in this question.</p>
</div>
<div class="post-text" itemprop="text">
<p>This awful code can be re-written as below in iterative, but it will reduce the efficiency. Same applies to the recursive function.</p>
<pre><code>def rec():
    count=0
    for i in range(len(letters)):
        for j in range(i+1, len(letters)):
            for k in range(j+1, len(letters)):
                if letters[i]+letters[j]+letters[k]==a:
                     count+=1
                     continue
                for l in range(k+1, len(letters)):
                    if letters[i]+letters[j]+letters[k]+letters[l]==a:
                         count+=1

    return count
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just a recursive solution...</p>
<pre><code>def rec(letters, a):
    return sum(rec(letters[i+1:], a[1:])
               for i, c in enumerate(letters)
               if c == a[0]) if a else 1
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; rec('onerene', 'one')
4
</code></pre>
</div>
<span class="comment-copy">What is this supposed to be doing?</span>
<span class="comment-copy">Welcome to Stack Overflow! StackOverflow expects you to <a href="http://meta.stackoverflow.com/questions/261592">try to solve your own problem first</a>. Please update your question to show what you have already tried in a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>. For further information, please see <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>, and take the <a href="https://stackoverflow.com/tour">tour</a> :)</span>
<span class="comment-copy">Why would you prefer recursion over iteration? If you can pick one never chose recursion. It's too limited and too slow. There might be a way to simplify your algorithm (whatever it does) but it is unlikely that recursion is the way to go.</span>
<span class="comment-copy">Can you clarify your problem and the desired output the function should produce? In python you can often avoid looping by using more problem specific packages.</span>
<span class="comment-copy">It checks the number of occurences of one substring in larger string. For example, for string "onerene" and a="one", it should return 4, because there's 4 possibilites to get substring "one" from "onerene".</span>
<span class="comment-copy">Doesn't allow detecting dead ends early, though. If <code>a+b</code> is futile prefix, you'll still try it with every available <code>c</code>.</span>
<span class="comment-copy">@StefanPochmann It is easy to run the combinatorics on the first two levels and then add early out logic.  I was just pointing out that there are sometimes alternatives to burying yourself in heavy nesting and recursion.</span>
<span class="comment-copy">This is great and really changed my way of thinking about the issue. Thank you so much.</span>
<span class="comment-copy">No tests again? <code>NameError: name 'letters' is not defined</code></span>
<span class="comment-copy">@DeliriousLettuce the code is same as the OP just removed the check. hence it's op fault not me...</span>
<span class="comment-copy">You don't seem to run any of your code though, how can you ensure it's correct if you never run it?</span>
<span class="comment-copy">@DeliriousLettuce what about <code>letters</code> is a global variable?</span>
<span class="comment-copy">Great question... which you probably should have posed to OP before posting a broken answer.</span>
