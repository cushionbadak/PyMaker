<div class="post-text" itemprop="text">
<p>I am trying to build a man-in-middle proxy server that relays the client request to the various proxy services predefined in my app. So, in order to do this, I need to distinguish the client's request for a service.<br/>
The code below works as long as I don't uncomment <code># data = await client_reader.read(2048)</code> from which I can parse the headers. i.e. If I do perform that code,<br/>
Say if am doing this with that line of code uncommmented:  </p>
<pre><code>r = requests.get('http://api.ipify.org/', headers = {'Proxy-Type':'custom'}, proxies={'http':'http://127.0.0.1:9911'}) 
</code></pre>
<p>I would get a <code>408 Request Time-out</code> from ipify in the <code>r.content</code></p>
<pre><code>async def proxy_data(reader, writer, connection_string):

  try:
    while True:
      data = await reader.read(2048)
      if not data:
        break
      writer.write(data)
      await writer.drain()
  except Exception as e:
    raise
  finally:
    writer.close()

async def accept_client(client_reader, client_writer):

  try:
    # Get proxy service - [Proxy-Type] from header via client_reader
    # Set remote_address and remote_port based on it

    # data = await client_reader.read(2048)

    (remote_reader, remote_writer) = await asyncio.wait_for(
    asyncio.open_connection(host = remote_address, port = remote_port),
      timeout = 30)
  except asyncio.TimeoutError:
    client_writer.close()
  except Exception as e:
    client_writer.close()
  else:
    # Pipe the streams
    asyncio.ensure_future(proxy_data(client_reader, remote_writer))
    asyncio.ensure_future(proxy_data(remote_reader, client_writer))

def main():

  def handle_client(client_reader, client_writer):
    asyncio.ensure_future(
      accept_client(
        client_reader = client_reader,
        client_writer = client_writer
      )
    )


  loop = asyncio.get_event_loop()
  try:
    server = loop.run_until_complete(
      asyncio.start_server(
        handle_client, host = '127.0.0.1', port = 9911))
  except Exception as e:
    logger.error('Bind error: {}'.format(e))
    sys.exit(1)

  for s in server.sockets:
    logger.debug('Proxy broker listening on {}'.format(s.getsockname()))

  try:
    loop.run_forever()
  except KeyboardInterrupt:
    pass
if __name__ == '__main__':
  main()
</code></pre>
<p>Can anyone point out the issue here or how to open connection conditionally?</p>
</div>
<div class="post-text" itemprop="text">
<p>Fixed the issue by refeeding the client_reader (<a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.feed_data" rel="nofollow noreferrer">ReaderStream</a>)</p>
<p>Thanks to Vincent for comments to point out the request tampering situation and reconstructing the request back to its native form</p>
<pre><code>async def accept_client(client_reader, client_writer):

  try:
    # Get proxy service - [Proxy-Type] from header via client_reader
    # Set remote_address and remote_port based on it

    data = await client_reader.read(2048)

    # -------- Edited --------

    # perform operations based on data and obtain remote_address, remote_port

    (remote_reader, remote_writer) = await asyncio.wait_for(
    asyncio.open_connection(host = remote_address, port = remote_port),
      timeout = 30)
  except asyncio.TimeoutError:
    client_writer.close()
  except Exception as e:
    client_writer.close()
  else:

    # Write the data to remote
    remote_writer.write(data)
    await remote_writer.drain()

    # Pipe the streams
    asyncio.ensure_future(proxy_data(client_reader, remote_writer))
    asyncio.ensure_future(proxy_data(remote_reader, client_writer))
</code></pre>
</div>
<span class="comment-copy">Maybe you forgot to write the header data in the remote writer before piping the streams?</span>
<span class="comment-copy">But shouldn't the remote_writer depend on the opened connection? i.e. shouldn't the remote_writer be based on the custom proxy services requested in the client header?</span>
<span class="comment-copy">Yes, but you don't want to break the request format by extracting the proxy information. You have to find a way to reconstruct a valid request that can be processed by the remote service.</span>
<span class="comment-copy">Exactly, but as I don't wish to tamper the request by any means, it would be fine to just have a tmp_reader copy of the local_reader stream in the <code>accept_client</code> and work on that for the condition. This doesn't seem to work either by a mere copying, am supposing this has to do with it being a coro ?!</span>
<span class="comment-copy">Fixed by using <code>client_reader.feed_data(data)</code> after saving the data</span>
<span class="comment-copy">Actually, <code>feed_data</code> is meant to be called by the underlying stream protocol, I don't think it's safe to use it this way. For instance, the protocol might receive more data from the client and feed it before you can feed the header back, therefore corrupting the request. I'd use <code>remote_writer.write(data)</code> instead (before piping the streams).</span>
<span class="comment-copy">Not sure if I could use the <code>remote_writer</code> as my condition to actually define the <code>remote_address</code> and <code>remote_port</code> would depend on the data obtained from headers in <code>local_reader</code>. Say like, if the client header contains <code>'Proxy-Type':'tor'</code>, then my remote_address would be that of a <code>tor ip</code>.</span>
<span class="comment-copy">Sure, but that shouldn't be a problem. I'd use the following workflow: read the header from the client, get the remote address, create the remote connection, write the header to the remote, pipe the client and the remote.</span>
<span class="comment-copy">Great!. Thanks again</span>
