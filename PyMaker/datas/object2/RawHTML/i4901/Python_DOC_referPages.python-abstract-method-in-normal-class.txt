<div class="post-text" itemprop="text">
<p>I was reading official python <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">documentation</a>.</p>
<p>In the mentioned link, the second line states that:</p>
<blockquote>
<p>Using this decorator requires that the class’s metaclass is ABCMeta or
  is derived from it.</p>
</blockquote>
<p>But, I was successfully able to define the below given class.</p>
<pre><code>from abc import abstractmethod

class A(object):
    def __init__(self):
        self.a = 5
    @abstractmethod
    def f(self):
        return self.a

a = A()
a.f()
</code></pre>
<p>So, the code above worked fine.
And also, I was able to create a subclass</p>
<pre><code>class B(A):
    def __init__(self):
        super(B, self).__init__() 

b = B()
b.f()
</code></pre>
<p>Without overriding the abstract method defined above.</p>
<p>So, basically does this mean that if my base class's <code>metaclass</code> is not <code>ABCMeta</code>(or derived from it), the class does not behave like an abstract class even though I have an abstract method in it?</p>
<p>That means, the documentation needs more clarity?</p>
<p>Or, is this behaviour useful somehow and I'm missing the point.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>So, basically does this mean that if my base class's metaclass is not
  ABCMeta(or derived from it), the class does not behave like an
  abstract class even though I have an abstract method in it?</p>
</blockquote>
<p>Correct.</p>
<p>All <code>abstractmethod</code> does is mark the method with <code>__isabstractmethod__ = True</code>.  <code>ABCMeta</code> does all the real work. <a href="https://github.com/python/cpython/blob/3.6/Lib/abc.py#L9" rel="nofollow noreferrer">Here</a> is the code for <code>abstractmethod</code>: </p>
<pre><code>def abstractmethod(funcobj):
    """A decorator indicating abstract methods.
    Requires that the metaclass is ABCMeta or derived from it.  A
    class that has a metaclass derived from ABCMeta cannot be
    instantiated unless all of its abstract methods are overridden.
    The abstract methods can be called using any of the normal
    'super' call mechanisms.
    Usage:
        class C(metaclass=ABCMeta):
            @abstractmethod
            def my_abstract_method(self, ...):
                ...
    """
        funcobj.__isabstractmethod__ = True
        return funcobj
</code></pre>
</div>
<span class="comment-copy">How were you expecting it to work? I think the documentation is pretty clear. Also, I'd say, here is not the place to discuss documentation issues.</span>
<span class="comment-copy">I expect <code>Using this decorator requires that the class’s metaclass is ABCMeta or is derived from it.</code> to be enforced?</span>
<span class="comment-copy">@harman786 Problem is that the only way in Python to enforce something like that is with a metaclass. It's a Catch-22.</span>
