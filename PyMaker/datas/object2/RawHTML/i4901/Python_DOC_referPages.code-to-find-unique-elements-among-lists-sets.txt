<div class="post-text" itemprop="text">
<p><a href="https://i.stack.imgur.com/hUq9n.jpg" rel="nofollow noreferrer"><img alt="Shaded area required" src="https://i.stack.imgur.com/hUq9n.jpg"/></a></p>
<p>The above shaded area, according to <a href="https://www.wolframalpha.com/input/?i=A+XOR+B+XOR+C+XOR+(A+AND+B+AND+C)&amp;rawformassumption=%7B%22C%22,+%22XOR%22%7D+-%3E+%7B%22MathOperator%22%7D" rel="nofollow noreferrer">Wolfram</a> is supposed to represent: </p>
<pre><code> A XOR B XOR C XOR (A AND B AND C)
</code></pre>
<p>How to translate this into python code? The code must closely correlate to the set operations as provided in the above expression, at least that is the preference. The code must be generic enough to handle more more than 3 lists as well. </p>
<p><strong>UPDATE:</strong> 
Seems like Wolfram is throwing up an erroneous venn diagram? 
Also, what we actually want is </p>
<pre><code>(A XOR B XOR C) - (A AND B AND C)
</code></pre>
<p>and I am not able to represent that in Wolfram. </p>
</div>
<div class="post-text" itemprop="text">
<p>Python supports sets (<a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">more about sets</a>). For three lists it will be:</p>
<pre><code>A = [1, 2, 3, 4]
B = [2, 3, 5, 6]
C = [3, 4, 5, 7]
As = set(A)
Bs = set(B)
Cs = set(C)

print((As ^ Bs ^ Cs) ^ (As &amp; Bs &amp; Cs))
</code></pre>
<p>For list of lists (<strong>this is wrong - all it does is XORing all sets, ANDing all sets and than XORing this two results - correct solution below</strong>):</p>
<pre><code>import functools

def do_xor(s1, s2):
    return s1 ^ s2

def do_and(s1, s2):
    return s1 &amp; s2

def do_task(list_of_lists):
    list_of_sets = list(map(set, list_of_lists))
    xors = functools.reduce(do_xor, list_of_sets)
    ands = functools.reduce(do_and, list_of_sets)
    return xors ^ ands

A = [1, 2, 3, 4]
B = [2, 3, 5, 6]
C = [3, 4, 5, 7]
D=[A, B, C]
print(do_task(D))
</code></pre>
<p>Correct solution:</p>
<pre><code>import functools 

def do_or(s1, s2):
    return s1 | s2

def do_task2(list_of_lists):
    list_of_sets = list(map(set, list_of_lists))
    list_of_intersects = [X &amp; Y for X in list_of_sets for Y in list_of_sets if X is not Y]
    intersects = functools.reduce(do_or, list_of_intersects)
    ors = functools.reduce(do_or, list_of_sets)
    return ors - intersects

lol33 = [
    [1, 2], 
    [3, 2], 
    [3], 
    [3, 2, 4]
    ]

print(do_task2(lol33)) # {1, 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use operations <code>&amp;</code> [intersection] and <code>|</code> [union] for your purpose. Data from @WPedrak.</p>
<pre><code>A = {1, 2, 3, 4}
B = {2, 3, 5, 6}
C = {3, 4, 5, 7}

lst = [A, B, C]

result = (A | B | C) - ((A &amp; B) | (A &amp; C) | (B &amp; C) | (A &amp; B &amp; C))

# {1, 6, 7}
</code></pre>
<p><strong>Explanation</strong></p>
<p>We take the union of all elements and subtract all intersections. See <a href="https://stackoverflow.com/a/49118803/9209546">@WPedrak's solution</a> for general case.</p>
</div>
<span class="comment-copy">But what I have <code>n</code> lists?</span>
<span class="comment-copy">I've edited answer to include <code>n case</code></span>
<span class="comment-copy">If <code>lol1 = [ 		[1, 2],  		[3, 2] 	]</code>, then <code>do_task(lol1)</code> returns <code>{1, 2, 3}</code>. How come?</span>
<span class="comment-copy">If <code>lol33 = [ 	[1, 2],  	[3, 2],  	[3],  	[3, 2, 4] 	]</code> then <code>do_task(lol3)</code> returns <code>{1, 2, 3, 4}</code>. This is incorrect, right?</span>
<span class="comment-copy">I am very intrigued as to why this doesn't work. Use this to further probe where the problem might be...<a href="https://repl.it/@kgashok/MotionlessUnderstatedLinuxpc" rel="nofollow noreferrer">repl.it/@kgashok/MotionlessUnderstatedLinuxpc</a></span>
