<div class="post-text" itemprop="text">
<p>I haven't seen a way to do this. I am in Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04). MacOS under Sierra, though we'll need this to work on Python 2.</p>
<p>I have a custom class which does something which looks like an int with subfield decoding. For my own reasons, I want to be able to do things both like</p>
<pre><code>inst * 4
</code></pre>
<p>and</p>
<pre><code>inst.subfield &lt;&lt; 1
</code></pre>
<p>(where subfield is an attribute of inst). These objects are highly overloaded, and e.g. printing <code>inst</code> will dump the subfields for viewing.</p>
<p>This is all done by overloading all the custom functions to handle the math and interaction with other objects. In general, it works really well, with one glaring exception: printing. For the most part, a user can forget this isn't really an integer and use it like one, but using the integer print commands won't work:</p>
<pre><code>print("%#x"%inst)
TypeError: %x format: an integer is required, not CustomType
</code></pre>
<p>I do have <code>__int__</code> overloaded, and <code>int(inst)</code> returns an integer as expected.</p>
<p>Is there any way to make this work? It's a minor annoyance, but one I'd like to fix.</p>
<p>Also, I do have <code>__format__</code> implemented. So <code>'{0:x}'.format(inst)</code> works, but the print above doesn't.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__int__" rel="nofollow noreferrer"><code>__int__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer"><code>__index__</code></a>:</p>
<pre><code>class X(object):
    def __int__(self):
        return 42
    def __index__(self):
        return 42

x = X()
print('%#x' % x)
</code></pre>
<p>output:</p>
<pre><code>0x2a
</code></pre>
<p>From the docs for <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer"><code>__index__</code></a>:</p>
<blockquote>
<p>Called to implement operator.index(), and whenever Python needs to
  losslessly convert the numeric object to an integer object (such as in
  slicing, <strong>or in the built-in bin(), hex() and oct() functions</strong>).
  Presence of this method indicates that the numeric object is an
  integer type. Must return an integer.</p>
</blockquote>
<p>So <code>__index__</code> is called by <code>hex()</code>, as can be seen by looking at the relevant source code in <a href="https://github.com/python/cpython/blob/f320be77ffb73e3b9e7fc98c37b8df3975d84b40/Objects/abstract.c#L1481" rel="nofollow noreferrer">PyNumber_ToBase</a>.</p>
</div>
<span class="comment-copy">you have to define <code>__format__</code> not <code>__int__</code></span>
<span class="comment-copy">Cannot reproduce. Works just fine as long as you implement <code>__int__</code> (in both python 2 and 3).</span>
<span class="comment-copy">Really @Aran-Fey? I'm getting an error: <a href="https://ideone.com/J8vwri" rel="nofollow noreferrer">ideone.com/J8vwri</a>.</span>
<span class="comment-copy">I tried 3.6.4 (Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28)), no change. However, I did find something interesting: <code>'%d'</code> works, <code>'%x'</code> doesn't. Maybe something specific to hex output; I'll edit the question.</span>
<span class="comment-copy">lol, that's fine @Aran-Fey :) I think I'll do a bit of digging to see if something was introduced in Python 3.5 that previous versions didn't have.</span>
<span class="comment-copy">Maybe a bit of explanation? :-) This does work, but I'm a bit curios to know why <code>__index__</code> is needed. Seems pretty unrelated.</span>
<span class="comment-copy">Same here... amazingly enough this does the trick, but is not intuitive at all :)</span>
<span class="comment-copy">Does adding <code>__index__</code> somehow make Python recognize instances of <code>X</code> as integers?</span>
<span class="comment-copy"><code>__int__</code> represents a way to cast to an integer, but it is assumed it could be lossy, as in "the object itself" may not be an int. When <code>__index__</code> returns an integer, the convention is to believe that this integer "really is" the object (which is still not actually true, but allows it to proceed with integer-requiring operations, like being used as a slice index, or for <code>hex</code>, etc.).</span>
<span class="comment-copy">Strangely, on Python 3, both <code>__int__</code> and <code>__index__</code> are needed; on Py2, only <code>__int__</code> is needed. It would have made sense if Py3 needed <code>__index__</code> and Py2 needed <code>__int__</code>, but it looks like the formatting accidentally demands that <code>__index__</code> be there (to support the actual conversion) and <code>__int__</code> be there (because <code>PyNumber_Check</code> only accepts things with the slot corresponding to <code>__int__</code> or <code>__float__</code>, not checking for <code>__index__</code>). On Py2, the conversion and type check both look for <code>__int__</code>.</span>
