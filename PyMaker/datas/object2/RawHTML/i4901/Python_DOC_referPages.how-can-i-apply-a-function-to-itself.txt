<div class="post-text" itemprop="text">
<p>Suppose I have function, <code>f</code>, which takes in some variable and returns a variable of the same type.  For simplicity, let's say</p>
<pre><code>def f(x):
    return x/2+1
</code></pre>
<p>I'm interested in applying <code>f</code> to itself over and over.  Something like <code>f(f(f(...(f(x))...)))</code>.</p>
<p>I could do this like</p>
<pre><code>s = f(x)
for i in range(100):
    s = f(s)
</code></pre>
<p>But I was wondering if there was a simpler, less verbose way to doing the same thing.  I wan't to avoid <code>for</code> loops (just as a challenge to myself).  Is there maybe some way of using <code>map</code> or a similar function to accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there maybe some way of using <code>map</code> or a similar function to accomplish this?</p>
</blockquote>
<p>Not <code>map</code>, but <code>reduce</code>. I wouldn't use it for this, but you could call <code>reduce</code> on an <em>n</em>-item sequence to cause <code>f</code> to be called <em>n</em> times. For example:</p>
<pre><code>&gt;&gt;&gt; def f(x):
...   return x+1
... 
&gt;&gt;&gt; reduce(lambda n,_: f(n), range(100), 42)
142
</code></pre>
<p>Explanation:</p>
<ul>
<li><code>n</code> is assigned each successive return value of <code>f</code>.</li>
<li><code>_</code> is the list of numbers from <code>range(100)</code>. These numbers are all ignored. All that matters is how many there are.</li>
<li><code>42</code> is the starting value.</li>
</ul>
<p><code>100</code> nested calls to <code>f(f(f...(f(42))...))</code> results in <code>142</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, a for loop is the most ergonomic and readable way to do this. So I would consider this mostly an exercise â€” these are more natural to use in functional languages.</p>
<p><a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> collapses a list of values to a single value by repeatedly calling a function of two arguments. Here's factorial:</p>
<pre><code>&gt;&gt;&gt; import functools, operator
&gt;&gt;&gt; operator.mul(2,3)
6
&gt;&gt;&gt; functools.reduce(operator.mul, range(1, 10), 1)
362880
</code></pre>
<p>We can abuse this to use a list of values for its length only and ignore the actual contents.</p>
<pre><code>&gt;&gt;&gt; def f(x):
...   return x/2+1
... 
&gt;&gt;&gt; functools.reduce(lambda x, y: f(x), range(10), 1)
1.9990234375
</code></pre>
<p>Or we can string together <em>n</em> copies of the (unary) function in a list and collapse them by applying each one to the accumulated value.</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; functools.reduce(lambda x, g: g(x), itertools.repeat(f, 10), 1)
1.9990234375
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While it is not clear from your example if you are trying to calculate a final numerical result or accumulate a list of values, you can use a very simple recursive approach with a lambda function:</p>
<p>Single value:</p>
<pre><code>f = lambda x, c = 1:x if c == 100 else f(x/2 + 1, c+1)
&gt;&gt;f(200)
2
</code></pre>
<p>List of values:</p>
<pre><code>f = lambda x, c = 1:x if c == 100 else f(x+[x[-1]/2+1], c+1)
&gt;&gt;f([200])
[200, 101, 51, 26, 14, 8, 5, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The construct would be recursion. But recursion requires that your call stack ends at some point. Such a case could work with an algorithm such as:</p>
<pre><code>if(x == 0):
    return 1
# this will make sure it ends at the preceding line in the next call
return f(x - 1) 
</code></pre>
<p>This is typically the approach used to compute results such as the factorial.</p>
<p>To use an example, adding a requirement (that you only compute if x &lt; 2, just as an example):</p>
<pre><code>def f(x):
  if(x &lt; 2):
    return 1
  return f(x/2+1)
</code></pre>
<p>The key is that there be a point at which the call stack starts returning (to avoid an overflow)</p>
</div>
<div class="post-text" itemprop="text">
<p>You could add the function itself in the return line of the definition. An example would be the top answer here <a href="https://stackoverflow.com/questions/479343/how-can-i-build-a-recursive-function-in-python">How can I build a recursive function in python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could factor out recursion:</p>
<pre><code>from functools import partial
recurse = partial(lambda g,f,x,n: g(g,f,x,n), # capture g
                  lambda g,f,x,n: n and g(g, f, f(x), n-1) or x)
</code></pre>
<p>If you're into something better than a one-liner, recursion can be abolished:</p>
<pre><code>import itertools
def recurse(f, x, n):
  for _ in itertools.repeat(None, n):
    x = f(x)
  return x
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; f = lambda x: x/2+1
&gt;&gt;&gt; recurse(f, 42, 5)
7.0
&gt;&gt;&gt; f(f(f(42)))
7.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What I think you're asking about is concept called Recursion. You could use something like a lambda function but recursive calls in a for loop aren't inherently bad. I'd go read more about recursive functions in general and then look for python implementations specifically. </p>
</div>
<span class="comment-copy">No, for loops are not bad, but I want to avoid them as a challenge.  Recursion is a good all, I had forgotten about that.</span>
