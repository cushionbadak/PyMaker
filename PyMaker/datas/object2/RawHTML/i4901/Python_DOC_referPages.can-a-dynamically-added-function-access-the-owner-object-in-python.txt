<div class="post-text" itemprop="text">
<p>I'm making a program in python in which specific instances of an object must be decorated with new functions built at runtime.</p>
<p>I've seen very simple examples of adding functions to objects through MethodType:</p>
<pre><code>import types
def foo():
    print("foo")

class A:
    bar = "bar"

a = A()
a.foo = types.MethodType(foo, a)
</code></pre>
<p>But none of the examples I've seen show how a function added in this manner can reference to the new owner's attributes. As far as I know, even though this binds the <code>foo()</code> function to the instance <code>a</code>, <code>foo()</code> must still be a pure function, and cannot contain references to anything local.</p>
<p>In my case, I need functions to change attributes of the object they are added to. Here are two examples of the kind of thing I need to be able to do:</p>
<pre><code>class A:
    foo = "foo"
    def printme():
        print(foo)

def nofoo():
    foo = "bar"

def printBar():
    if foo != "foo"
        self.printme()
</code></pre>
<p>I would then need a way to add a copy of a <code>nofoo()</code> or <code>printBar()</code> to an A object in such a way that they can access the object attributes named <code>foo</code> and the function named <code>printme()</code> correctly.</p>
<p>So, is this possible? <strong>Is there a way to do this kind of programming in vanilla Python?</strong> or at least <strong>Is there a programming pattern that achieves this kind of behavior?</strong></p>
<p>P.S.: In my system, I also add attributes dynamically to objects. Your first thought then might be "How can I ever be sure that the object I'm adding the <code>nofoo()</code> function to actually has an attribute named <code>foo</code>?", but I also have a fairly robust tag system that makes sure that I never try to add a <code>nofoo()</code> function to an object that hasn't a <code>foo</code> variable. The reason I mention this is that solutions that look at the class definition aren't very useful to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>As said in the comments, your function actually <em>must</em> take at least one parameter: <code>self</code>, the instance the method is being called on. The <code>self</code> parameter can be used as it would be used in a normal instance method. Here is an example:</p>
<pre><code>&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; 
&gt;&gt;&gt; class Class:
        def method(self):
            print('method run')


&gt;&gt;&gt; cls = Class()
&gt;&gt;&gt; 
&gt;&gt;&gt; def func(self): # must accept one argument, `self`
        self.method()


&gt;&gt;&gt; cls.func = MethodType(func, cls)
&gt;&gt;&gt; cls.func()
method run
&gt;&gt;&gt;
</code></pre>
<p>Without your function accepting <code>self</code>, an exception would be raised:</p>
<pre><code>&gt;&gt;&gt; def func():
        self.method()

&gt;&gt;&gt; cls.func = MethodType(func, cls)
&gt;&gt;&gt; cls.func()
Traceback (most recent call last):
  File "&lt;pyshell#21&gt;", line 1, in &lt;module&gt;
    cls.func()
TypeError: func() takes 0 positional arguments but 1 was given
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class A:
     def __init__(self):
         self.foo = "foo"

     def printme(self):
         print(self.foo)

def nofoo(self):
     self.foo = "bar"

a.nofoo = types.MethodType(nofoo, a)
a.nofoo()
a.printme()
</code></pre>
<p>prints</p>
<pre><code>bar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not entirely clear what you're trying to do, and I'm worried that whatever it is may be a bad idea. However, I can explain how to do what you're <em>asking</em>, even if it isn't what you want, or should want. I'll point out that it's very uncommon to want to do the second version below, and even rarer to want to do the third version, but Python does allow them both, because "even rarer than very uncommon" still isn't "never". And, in the same spirit…</p>
<p>The short answer is "yes". A dynamically-added method can access the owner object exactly the same way a normal method can.</p>
<hr/>
<p>First, here's a normal, non-dynamic method:</p>
<pre><code>class C:
    def meth(self):
        return self.x

c = C()
c.x = 3
c.meth()
</code></pre>
<p>Obviously, with a normal method like this, when you call <code>c.meth()</code>, the <code>c</code> ends up as the value of the <code>self</code> parameter, so <code>self.x</code> is <code>c.x</code>, which is 3.</p>
<hr/>
<p>Now, here's how you dynamically add a method to a class:</p>
<pre><code>class C:
    pass

c = C()
c.x = 3

def meth(self):
    print(self.x)

C.meth = meth
c.meth()
</code></pre>
<p>This is actually doing exactly the same thing. (Well, we've left another name for the same function object sitting around in globals, but that's the only difference) If <code>C.meth</code> is the same function it was in the first version, then obviously whatever magic made <code>c.meth()</code> work in the first version will do the exact same thing here.</p>
<p>(This used to be slightly more complicated in Python 2, because of unbound methods, and classic classes too… but fortunately you don't have to worry about that.)</p>
<hr/>
<p>Finally, here's how you dynamically add a method to an instance:</p>
<pre><code>class C:
    pass

c = C()
c.x = 3

def meth(self):
    print(self.x)

c.meth = types.MethodType(meth, c)
c.meth()
</code></pre>
<p>Here, you actually have to know the magic that makes <code>c.meth()</code> work in the first two cases. So read the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HOWTO</a>. After that, it should be obvious.</p>
<p>But if you just want to pretend that Guido is a wizard (Raymond <em>definitely</em> is a wizard) and it's magic… Well, in the first two versions, Guido's magic wand creates a special bound method object whenever you ask for <code>c.meth</code>, but even he isn't magical enough to do that when <code>C.meth</code> doesn't exist. But we can painstakingly create that same bound method object and store it as <code>c.meth</code>. After that, we're going to get the same thing we stored whenever we ask for <code>c.meth</code>, which we explicitly built as the same thing we got in the first two examples, so it'll obviously do the same thing.</p>
<hr/>
<p>But what if we did this:</p>
<pre><code>class C:
    pass

c = C()
c.x = 3

def meth(self):
    print(self.x)

c.meth = meth
c.meth(c)
</code></pre>
<p>Here, you're not letting Guido do his descriptor magic to create <code>c.meth</code>, and you're not doing it manually, you're just sticking a regular function there. Which means if you want anything to show up as the <code>self</code> parameter, you have to explicitly pass it as an argument, as in that silly <code>c.meth(c)</code> line at the end. But if you're willing to do that, then even <em>this</em> one works. No matter how <code>self</code> ends up as <code>c</code>, <code>self.x</code> is going to be <code>c.x</code>.</p>
</div>
<span class="comment-copy">Your function must take at least one argument, i.e. <code>self</code> which will be passed the instance so you can access state associated with the instance. Note, this is how it <i>always</i> works.. also, of course <code>foo</code> can contain local references...</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object-instance">Adding a Method to an Existing Object Instance</a></span>
<span class="comment-copy">Well, technically you could make this a <code>@staticmethod</code> (or just not wrap it in a <code>types.MethodType</code> before adding it to the instance, which has the same effect), and then it doesn't have to take a <code>self</code> argument. But of course then it can't access any attributes of <code>self</code>, because that's the whole point of static methods, and of not having <code>self</code>, so…</span>
<span class="comment-copy">Meanwhile, if you're adding methods to the class, not to the instances, you don't actually need <code>MethodType</code>, and in fact almost certaily don't want it. What are you trying to accomplish here?</span>
<span class="comment-copy">See <a href="https://repl.it/repls/HeftyScarceStrategy" rel="nofollow noreferrer">repl.it/repls/HeftyScarceStrategy</a> for an interactive example. That's how you add methods to classes dynamically; dead simple. <a href="https://repl.it/repls/FlamboyantCrookedThing" rel="nofollow noreferrer">repl.it/repls/FlamboyantCrookedThing</a> is how you add them to instances; still pretty simple. Whatever problems you're having are either because you're trying to do something trickier than necessary, or because you're misunderstanding something much more fundamental and shouldn't even be trying this stuff yet.</span>
