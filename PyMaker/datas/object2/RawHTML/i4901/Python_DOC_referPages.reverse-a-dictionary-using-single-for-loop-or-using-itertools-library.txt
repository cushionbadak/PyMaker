<div class="post-text" itemprop="text">
<p>I have a dictionary of lists like this:</p>
<pre><code>my_dict = {
    'key_a': [1, 3, 4],
    'key_b': [0, 2],
}
</code></pre>
<p>I want to create a reverse lookup dict like this:</p>
<pre><code>reverse_dict = {
    0: 'key_b',
    1: 'key_a',
    2: 'key_b',
    3: 'key_a',
    4: 'key_a',
}
</code></pre>
<p>I have a <strong>working version of the solution</strong>:</p>
<pre><code>reverse_dict = {elem: key for key, a_list in my_dict.items() for elem in a_list}
</code></pre>
<p>But wanted to know if someone can provide an alternate answer that doesn't use a double <code>for</code> as I feel it loses readability. So I'd prefer having a single <code>for</code> loop or use functions like the ones in itertools or functional programming</p>
</div>
<div class="post-text" itemprop="text">
<p>Your solution using <em>dictionary comprehension</em> is the Pythonic way to achieve it. </p>
<p>However, as an <strong>alternative with single <code>for</code> loop</strong> as requested by you, here is the functional one using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a>, <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat()</code></a>, and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a>, but I doubt that it is any better then yours solution in terms of readability:</p>
<pre><code>my_dict = {
    'key_a': [1, 3, 4],
    'key_b': [0, 2],
}

from itertools import chain, repeat

new_dict = dict(chain.from_iterable(zip(v, repeat(k)) for k, v in my_dict.items()))
</code></pre>
<p>where <code>new_dict</code> will hold:</p>
<pre><code>{0: 'key_b', 1: 'key_a', 2: 'key_b', 3: 'key_a', 4: 'key_a'} 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; dict(chain.from_iterable(map(lambda k: map(lambda j:(j, k), my_dict.get(k)), my_dict)))
{1: 'key_a', 3: 'key_a', 4: 'key_a', 0: 'key_b', 2: 'key_b'}
</code></pre>
<p>No for loops. It's clearly not more readable</p>
<p>Another one based off @MoinuddinQuadri's idea</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, repeat
&gt;&gt;&gt; dict(chain.from_iterable(map(lambda k: zip(my_dict[k], repeat(k)), my_dict)))
{1: 'key_a', 3: 'key_a', 4: 'key_a', 0: 'key_b', 2: 'key_b'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one without explicit for loop. Not really recommended, though (side-effect in <code>map</code> which is a no-no to many):</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; out = {}
&gt;&gt;&gt; any(map(out.update, it.starmap(dict.fromkeys, map(reversed, my_dict.items()))))
False
&gt;&gt;&gt; out
{1: 'key_a', 3: 'key_a', 4: 'key_a', 0: 'key_b', 2: 'key_b'}
</code></pre>
</div>
<span class="comment-copy">what about duplicate keys? last key in wins?</span>
<span class="comment-copy">Your code looks perfect to this pair of eyes.</span>
<span class="comment-copy">we can assume lists won't have duplicate elements</span>
<span class="comment-copy">This <i>is</i> functional programming.</span>
<span class="comment-copy">The code you have is the pythonic way to achieve it, and it is very simple as compared to various nested single liners that you may write in Python. I don't see any issue with readability here</span>
<span class="comment-copy">It's clear from the comments and the received answers that readability is not an issue with my code. I don't want to delete my question as it might be useful for someone else. I'll accept this answer as it shows the best use of itertools as requested</span>
<span class="comment-copy">very unwanted usage of lambdas with <code>map</code> to remove <code>for</code> loops. But still "+1" as OP only wants to reduce them</span>
<span class="comment-copy">@MoinuddinQuadri, it is a silly question, but it can be fun to kick these ideas around and see what drops out</span>
<span class="comment-copy">Side effect in map is indeed a no-no, so just a +0.7 rounded up</span>
