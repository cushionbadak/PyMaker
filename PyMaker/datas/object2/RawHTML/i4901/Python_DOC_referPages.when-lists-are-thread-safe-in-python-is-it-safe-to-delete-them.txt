<div class="post-text" itemprop="text">
<p>I have a multi threaded application in Python 3 and have a setter and getter method of a list. The setter method appends an element to the list, while the getter method deletes all elements of the list after returning them.</p>
<p>The setter method looks like the following, which is in a larger async function:</p>
<pre><code>while self.semaphor:
   print("waiting...")
   time.sleep(0.001)
self.semaphor=True
self.messages.append(msg)
print("appended data!")
</code></pre>
<p>While the getter method looks like the following:</p>
<pre><code>while self.semaphor:
    time.sleep(0.001)
self.semaphor = True
l = self.messages
self.messages = []
self.semaphor = False
if len(l) == 0:
   return None
else:
   return l
</code></pre>
<p>However the application crashes without any error messages (probably hidden due to multithreaded output in the command line) right after the prinst statetement "append data" - So I was wondering if the code snippets are thread safe and correct?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is not threadsafe, because your <code>self.semaphore</code> handling is not thread-safe. Two threads can read <code>self.semaphore</code> as <code>False</code>, before either of them have set it to <code>True</code>, as thread switches can take place at any point between instructions.</p>
<p>What you want to use is a <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow noreferrer">proper thread lock object</a> (a semaphore is the wrong primitive to use here).</p>
<p>When creating your instance, set a <code>self.messages_lock = threading.Lock()</code> attribute, and whenever you need to alter your <code>messages</code> list, use:</p>
<pre><code>with self.messages_lock:
    # locked block of code, guaranteed to be thread-safe.
</code></pre>
<p>or</p>
<pre><code>try:
    while not self.messages_lock.acquire(timeout=0.01):
        print("waiting...")
    # locked block of code, guaranteed to be thread-safe.
finally:
    self.messages_lock.release()
</code></pre>
<p>if you must have a thread that prints out that it is waiting for a lock.</p>
</div>
<span class="comment-copy">Your <code>self.semaphore</code> flag is not thread safe, hence you can have 2 writes at the same time, also can occur a threadlock situation.</span>
<span class="comment-copy">Your code is not thread-safe, there is a race-condition in setting the <code>semaphore</code> attribute. Use a real semaphore.</span>
<span class="comment-copy">To conculde, appending data to lists is thread safe, but variables are not in Python?</span>
<span class="comment-copy">Besides, a semaphore is the wrong object to use here, your actual usecase would require a lock instead.</span>
<span class="comment-copy">@Kev1n91: sure, but that's overkill. A semaphore uses a condition and lock in the implementation. You don't <i>need</i> the extra overhead, so don't use it either.</span>
