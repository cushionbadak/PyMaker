<div class="post-text" itemprop="text">
<p>I'm using SageMath to perform some mathematical calculations, and at one point I have a for loop that looks like this:</p>
<pre><code>uni = {}
end = (l[idx]^(e[idx] - 1)) * (l[idx] + 1) # where end in my case is about 2013265922, 
                                           # but can also be much much larger too.
for count in range(0, end):
    i = randint(1, 303325737249669131)     # this executes very fast in Sage
    if i in uni:
        uni[i] += 1
    else:
        uni[i] = 1
</code></pre>
<p>So basically, I want to create very large number of random integers in the given range, check whether the number was already in the dictionary, if yes increment its count, if not initialize it to 1. But, the loop takes such a long time that it doesn't finish in a reasonable amount of time, and not because the operations inside the loop are complicated, but instead because there are a huge number of iterations to be performed. Therefore, I want to ask whether there is any way to avoid (or speed up) this kind of loops in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Biggest speedup you can make without low-level magic is using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a>, i.e.</p>
<pre><code>uni = defaultdict(int)
for count in range(0, end):
    i = randint(1, 303325737249669131)     # this executes very fast in Sage
    uni[i] += 1
</code></pre>
<p>If you're using python2, change <code>range</code> to <code>xrange</code>.</p>
<p>Except this - I'm pretty sure that its somewhere near limit for python. Loop is </p>
<ul>
<li>generating random integer (optimized as much as possible without static typing)</li>
<li>calculating hash</li>
<li>updating dict. With <code>defaultdict</code> <code>if-else</code> branches is factored to more optimized code</li>
<li>from time to time, <code>malloc</code> calls to resize dict - this is fast (considering inablity to preallocate memory for dict)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I profiled your code (use cProfile for this) and the vast majority of the time spent, is spend within the randint function that is called for each iteration of the loop.</p>
<p>I recommend you vectorize the loop using numpy random number generation libraries, and then a single call to the Counter class to extract frequency counts.</p>
<pre><code>import numpy.random
import numpy
from collections import Counter

assert 303325737249669131 &lt; 18446744073709551615 # limit for uint64
numbers = numpy.random.randint(low=0, high=303325737249669131, size=end, 
dtype=numpy.uint64)
frequency = Counter(numbers)
</code></pre>
<p>For a loop of 1000000 iterations (smaller than the one you suggest) I observed a reduction from 6 seconds to about 1 second. So even with this you cannot expect more than an order of magnitude reduction in terms of computation time.</p>
<p>You may think that keeping an array of all the values in memory is inefficient, and may lead to memory exhaustion before the computation ends. However, due to the small value of "end" compared with the range of the random integers the rate at which you will be recording collisions is low, and therefore the memory cost of a full array is not significantly larger than storing the dictionary.  However, if this becomes and issue you may wish to perform the computation in batches. In that spirit you may also want to use the multiprocessing facilities to distribute computations across many CPUs or even many machines (but lookout for network costs if you chose that).</p>
</div>
<span class="comment-copy">And aren't you getting any index error?</span>
<span class="comment-copy">@UbdusSamad why would it be a set?</span>
<span class="comment-copy">@UbdusSamad No, why should I get index error? Sage is comfortable in handling huge numbers.</span>
<span class="comment-copy">You would need about 64 GB only to store the keys of your dict - so you should probably do it otherwise...</span>
<span class="comment-copy">Well, the numbers are uniformly distributed. You can calculate how many  will be repeated in expectation (probably something like end * (1 - (1/303325737249669131) (303325737249669130/303325737249669131)) - 303325737249669130/303325737249669131)**2) Why do you want to generate so many samples?</span>
<span class="comment-copy">When I try to do <code>uni(i) += 1</code> I get an error that defaultdict is not callable.</span>
<span class="comment-copy">My bad, should be <code>uni[i]</code>, fixed codeblock in answer</span>
