<div class="post-text" itemprop="text">
<p>I'm currently using a <code>try/except</code> block to treat a particular variable as an iterable when I can, but handle it a different, though correct, manner when it isn't iterable. </p>
<p>My problem is that a TypeException may be thrown for reasons other than trying to iterate with a non-iterable. My check was to use the message attached to the TypeException to ensure that this was the reason and not something like an unsupported operand. </p>
<p>But messages as a part of exceptions have been deprecated. So, how can I check on the reason for my TypeException?</p>
<p>For the sake of completeness, the code I'm using is fairly similar to this:</p>
<pre><code>            try:
               deref = [orig[x].value.flatten() for x in y]
            except TypeError as ex:
                if "object is not iterable" in ex.message:
                    x = y
                    deref = [orig[x].value.flatten()]
                else:
                    raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Separate the part that throws the exception you're interested in from the parts that throw unrelated exceptions:</p>
<pre><code>try:
    iterator = iter(y)
except TypeError:
    handle_that()
else:
    do_whatever_with([orig[x].value.flatten() for x in iterator])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way, if it suits your use case, is to use <code>collections.Iterable</code>. Because this is such a common task, I tend to wrap it in a function:</p>
<pre><code>from collections import Iterable

def iterify(obj):
    return obj if isinstance(obj, Iterable) else [obj]

deref = [orig[x].value.flatten() for x in iterify(y)]
</code></pre>
<p>But note the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered
  as Iterable or that have an <code>__iter__()</code> method, but it does not detect
  classes that iterate with the <code>__getitem__()</code> method. The only reliable
  way to determine whether an object is iterable is to call <code>iter(obj)</code>.</p>
</blockquote>
</div>
<span class="comment-copy">Can you provide the code you are using and also the desired outcome..</span>
<span class="comment-copy">why do you need to catch it? Why don't you just check whether it is an iterable first ... like hasattr(y, '_<i>iter_</i>')</span>
<span class="comment-copy">@SamRedway: Not all iterables have an <code>__iter__</code> method.</span>
<span class="comment-copy">@user2357112 huh? Really? I had considered this the definition of an iterable?</span>
<span class="comment-copy">@SamRedway, see the quotation in my answer.. <code>__iter__</code> is not the only way a class can iterate.</span>
