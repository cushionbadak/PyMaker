<div class="post-text" itemprop="text">
<p>My requirement is to run 2 functions at the same time and stop execution of one if the another one calculates and returns a result faster.</p>
<p>I have know knowledge of async programming or event loops. I read <a href="https://docs.python.org/3/library/asyncio-eventloop.html#run-an-event-loop" rel="nofollow noreferrer">python 3.6</a> which lead me to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="nofollow noreferrer">asyncio.wait()</a></p>
<p>My sample code:</p>
<pre><code>import time
import asyncio as aio

async def f(x):
    time.sleep(1) # to fake fast work
    print("f say: " + str(x*2))
    return x*2

async def s(x):
    time.sleep(3) # to fake slow work
    print("s say: " + str(x*2))
    return x**2

x = 10

assert aio.iscoroutinefunction(f)
assert aio.iscoroutinefunction(s)

futures = {f(x), s(x)}

def executor():
    yield from aio.wait(futures, return_when=aio.FIRST_COMPLETED)

done, pending = executor()
</code></pre>
<p>But it doesnt work for some unknown reason.</p>
</div>
<div class="post-text" itemprop="text">
<p>The particular assertion you are getting has to do with incorrect use of <code>yield from</code>. However, the problem runs deeper:</p>
<blockquote>
<p>My requirement is to run 2 functions at the same time</p>
</blockquote>
<p>This is not how asyncio works, nothing is run "at the same time". Instead, one runs async functions which execute until the point when they reach what would normally be a blocking call. Instead of blocking, an async function then suspends its execution, allowing other coroutines to run. They must be driven by an <em>event loop</em>, which drives them and wakes them up once some IO event allows them to resume.</p>
<p>A more correct asyncio version of your code would look like this:</p>
<pre><code>import asyncio

async def f(x):
    await asyncio.sleep(1) # to fake fast work
    print("f say: " + str(x*2))
    return x*2

async def s(x):
    await asyncio.sleep(3) # to fake slow work
    print("s say: " + str(x*2))
    return x**2

async def execute():
    futures = {f(10), s(10)}
    done, pending = await asyncio.wait(futures, return_when=asyncio.FIRST_COMPLETED)
    for fut in pending:
        fut.cancel()
    return done

loop = asyncio.get_event_loop()
done = loop.run_until_complete(execute())
print(done)
</code></pre>
<p>Note in particular that:</p>
<ul>
<li><p><code>asyncio.sleep()</code> is used instead of <code>time.sleep()</code>. This applies to every blocking call.</p></li>
<li><p>Coroutines such as <code>asyncio.sleep</code> and <code>asyncio.wait</code> must be <em>awaited</em> using the <code>await</code> keyword. This allows the coroutine to suspend itself upon encountering a blocking call.</p></li>
<li><p>Async code is executed through the event loop, whose entry point is typically <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>run_until_complete</code></a> or <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_forever" rel="nofollow noreferrer"><code>run_forever</code></a>.</p></li>
</ul>
</div>
<span class="comment-copy">thanks for detail explaining. your second paragraph makes me think i should use threadpoolexecutor or something. am i on the right track?</span>
<span class="comment-copy">@vvsLaxman If the functions are synchronous, then you can use <code>loop.run_in_executor(None, sync_function)</code>. Also note that Python's GIL will not allow functions to truly run at the same time.</span>
