<div class="post-text" itemprop="text">
<p>For example I have a class with Linked list class </p>
<pre><code>class Link:

    empty = ()

    def __init__(self, first, rest=empty):
        assert rest is Link.empty or isinstance(rest, Link)
        self.first = first
        self.rest = rest

    def __repr__(self):
        if self.rest is Link.empty:
            return 'Link({})'.format(self.first)
        else:
            return 'Link({}, {})'.format(self.first, repr(self.rest))

    def __str__(self):
        """Returns a human-readable string representation of the Link

        &gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))
        &gt;&gt;&gt; str(s)
        '&lt;1 2 3 4&gt;'
        &gt;&gt;&gt; str(Link(1))
        '&lt;1&gt;'
        &gt;&gt;&gt; str(Link.empty)  # empty tuple
        '()'
        """
        string = '&lt;'
        while self.rest is not Link.empty:
            string += str(self.first) + ' '
            self = self.rest
        return string + str(self.first) + '&gt;'
</code></pre>
<p>Is it possible to take a Linked list object and input it into a function which will alter it without assigning </p>
<pre><code>def func(lst):

    lst=lst.rest
</code></pre>
<p>instead of</p>
<pre><code>def func2(lst):

    return lis.rest
</code></pre>
<p>so I could do func1(lst) and it would altered instead of lst=func2(lst)</p>
</div>
<div class="post-text" itemprop="text">
<p>Because objects are mutable (by default) in Python you can modify an object but that won't change a reference in an outer scope. You can use the <code>id</code> function to test this:</p>
<pre><code>class A:
    pass

def func1(a):
    print('From func1 before assignment ', id(a))
    a = A()
    print('From func1 after assignment ', id(a))

a = A()
print('From global scope before function ', id(a))
func1(a)
print('From global scope after function ', id(a))
</code></pre>
<p>outputs</p>
<pre><code>From global scope before function  4646262768
From func1 before assignment  4646262768
From func1 after assignment  4646263888
From global scope after function  4646262768
</code></pre>
<p>So in <code>func1</code> we changed what the variable <code>a</code> refers to, but because it is a local variable, it doesn't change the <code>a</code> reference outside of the function's scope.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you meant trying to change an attribute of an object within a function without having to re-create that object, yes you can:</p>
<pre><code>def change_link(lnk):
    lnk.rest = Link(10)
</code></pre>
<p>If you didn't want to use the assignment operator, you could use <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer"><code>setattr</code></a>:</p>
<pre><code>def change_link(lnk):
    setattr(lnk, 'rest', Link(10))
</code></pre>
<p>But <code>setattr</code> doesn't return anything after setting the attribute, not even the object. So doing</p>
<pre><code>def change_link(lnk):
    return setattr(lnk, 'rest', Link(10))
</code></pre>
<p>would return <code>None</code>.</p>
<p>Now, if what you're really trying to do is <strong>chain several functions which modify a <code>Link</code> object one after the other</strong> like this: </p>
<pre><code>modify_list(add_item(pop_first(lnk)))
</code></pre>
<p>then you need to <em><strong>modify and return</strong></em> the object from the functions:</p>
<pre><code>&gt;&gt;&gt; def insert_2nd_link(lnk):
...     lnk.rest = Link(10, lnk.rest)  # adds a new 2nd item
...     return lnk                     # return the object
...
&gt;&gt;&gt; def multiply_first_by_50(lnk):
...     lnk.first *= lnk.first * 50    # modifies 1st item
...     return lnk                     # return the object
...
&gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))
&gt;&gt;&gt; s      # original s
Link(1, Link(2, Link(3, Link(4))))
&gt;&gt;&gt; new_s = multiply_first_by_50(insert_2nd_link(s))
&gt;&gt;&gt; new_s  # is it actually new? No
Link(50, Link(10, Link(2, Link(3, Link(4)))))
&gt;&gt;&gt; s      # old s
Link(50, Link(10, Link(2, Link(3, Link(4)))))
&gt;&gt;&gt; id(s) == id(new_s)
True
&gt;&gt;&gt;
</code></pre>
<p>Note that outside your function chain, you don't need to assign the return value since it happens "in-place":</p>
<pre><code>&gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))
&gt;&gt;&gt; s
Link(1, Link(2, Link(3, Link(4))))
&gt;&gt;&gt; multiply_first_by_50(insert_2nd_link(s))
Link(50, Link(10, Link(2, Link(3, Link(4)))))
&gt;&gt;&gt; s
Link(50, Link(10, Link(2, Link(3, Link(4)))))
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Want do you want to obtain? Have you tried your example? what you get and what do you expect? If I correctly understand what you are doing, <code>func</code> seems a great way write confusing and hard to debug code!</span>
