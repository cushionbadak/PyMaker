<div class="post-text" itemprop="text">
<p>Here is how my dataset looks like:</p>
<pre><code>Name | Country
---------------
Alex | USA
Tony | DEU
Alex | GBR
Alex | USA
</code></pre>
<p>I am trying to get something like this out, essentially grouping and counting:</p>
<pre><code>Name | Country
---------------
Alex | {USA:2,GBR:1}
Tony | {DEU:1}
</code></pre>
<h2>Works, but slow on LARGE datasets</h2>
<p>Here is my code that does work on smaller dfs, but takes forever on bigger dfs (mine is around 14 million rows). I also use the multiprocessing module to speed up, but it doesn't help much:</p>
<pre><code>def countNames(x):
    return dict(Counter(x))

def aggregate(df_full,nameList):
    df_list = []
    for q in nameList:
        df = df_full[df_full['Name']==q]
        df_list.append(df.groupby('Name')['Country'].apply(lambda x: str(countNames(x))).to_frame().reset_index()) 
    return pd.concat(df_list)

df = pd.DataFrame({'Name':['Alex','Tony','Alex','Alex'], 
                'Country':['USA','GBR','USA','DEU']})[['Name','Country']]

aggregate(df,df.Name.unique())
</code></pre>
<p>Is there anything that can speed up the internal logic (except for running with multiprocessing)? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is essentially a cross tabulation.  You said "something like this" which implies that you aren't quite sure what the output should be.</p>
<p><strong>Option 1</strong><br/>
Group by and <code>value_counts</code> </p>
<pre><code>df.groupby('Name').Country.value_counts()

Name  Country
Alex  USA        2
      GBR        1
Tony  DEU        1
Name: Country, dtype: int64
</code></pre>
<p>To get your specified output:</p>
<pre><code>pd.Series({
    name: pd.value_counts(d).to_dict()
    for name, d in df.groupby('Name').Country
}).rename_axis('Name').reset_index(name='Country')

   Name               Country
0  Alex  {'USA': 2, 'GBR': 1}
1  Tony            {'DEU': 1}
</code></pre>
<hr/>
<p><strong>Option 2</strong><br/>
However, I'd prefer these representations.  Which we can see a number of ways to do this in <a href="https://stackoverflow.com/a/47152692/2336654">the answer to question # 9 in this answer</a></p>
<pre><code>pd.crosstab(df.Name, df.Country)

Country  DEU  GBR  USA
Name                  
Alex       0    1    2
Tony       1    0    0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Are you looking for this?</p>
<pre><code>import pandas as pd

df = pd.DataFrame({'Name':['Alex','Tony','Alex','Alex'], 
                'Country':['USA','GBR','USA','DEU']})[['Name','Country']]

df = (df.groupby('Name')['Country']
         .apply(lambda x: str(x.value_counts().to_dict()))
         .reset_index(name='Country'))
</code></pre>
<p>Returns:</p>
<pre><code>   Name               Country
0  Alex  {'USA': 2, 'DEU': 1}
1  Tony            {'GBR': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For an O(<em>n</em>) complexity solution, use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>.</p>
<pre><code>from collections import Counter, defaultdict
import pandas as pd

df = pd.DataFrame({'Name':['Alex','Tony','Alex','Alex'], 
                   'Country':['USA','GBR','USA','DEU']})[['Name','Country']]

c = Counter(map(tuple, df.values))

# Counter({('Alex', 'DEU'): 1, ('Alex', 'USA'): 2, ('Tony', 'GBR'): 1})
</code></pre>
<p><strong>Dictionary result</strong></p>
<p>You can then get a Name -&gt; Country dictionary mapping via <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>. I would not put dictionaries in a <code>pandas</code> dataframe, it's not designed for this purpose.</p>
<pre><code>tree = lambda: defaultdict(tree)
d = tree()

for k, v in c.items():
    d[k[0]][k[1]] = v

for k, v in d.items():
    print(k, v)

# Alex defaultdict(&lt;function &lt;lambda&gt;&gt;, {'USA': 2, 'DEU': 1})
# Tony defaultdict(&lt;function &lt;lambda&gt;&gt;, {'GBR': 1})
</code></pre>
<p><strong>Dataframe result</strong></p>
<p>For display purposes, you can build a dataframe directly from the <code>defaultdict</code>:</p>
<pre><code>res_df = pd.DataFrame.from_dict(d, orient='index').fillna(0)

#       USA  DEU  GBR
# Alex  2.0  1.0  0.0
# Tony  0.0  0.0  1.0
</code></pre>
</div>
<span class="comment-copy">Yes, don't use a <code>for</code> loop. Do you really want to store data as <code>{USA:2,GBR:1}</code> e.g. a dictionary in a cell? You lose a lot of Pandas functionality doing that</span>
<span class="comment-copy">Which is fine, since the output needs to be written into a CSV. Any suggestions how to replace the <code>for</code> loop?</span>
<span class="comment-copy">Nice way of getting the series of interest indeed.</span>
<span class="comment-copy">I love Option 2 a lot, but I encounter this error:   <code>TypeError: 'DataFrame' objects are mutable, thus they cannot be hashed</code>. Any idea why?</span>
<span class="comment-copy">did you switch <code>name</code> and <code>d</code>?</span>
<span class="comment-copy">@piRSquared, I am talking about Option 2, which is the crosstab function.</span>
<span class="comment-copy">@ka_boom yeah, that's weird.  I'd need to see the data your using and the exact commands your running to understand why that is happening.</span>
