<div class="post-text" itemprop="text">
<p>I have two classes</p>
<pre><code>class Something(object):
   def __init__(self):
      self.thing = "thing"

class SomethingElse(Something):
   def __init__(self):
      self.thing = "another"
</code></pre>
<p>as you can see, one inherits from another.
When I run <code>super(SomethingElse)</code>, no error is thrown. However, when I run <code>super(SomethingElse).__init__()</code>, I was expecting an unbound function call (unbound to a hypothetical SomethingElse instance) and so was expecting that <code>__init__()</code> would complain about not receiving an object for its <code>self</code> parameter, but instead I get this error:</p>
<pre><code>TypeError: super() takes at least 1 argument (0 given)
</code></pre>
<p>What is the meaning of this message?</p>
<p>EDIT:  I often see people hand-wave answer a <code>super</code> question, so please don't answer unless you really know how the <code>super</code> delegate is working here, and know about descriptors and how they are used with <code>super</code>.</p>
<p>EDIT: Alex suggested I update my post with more details. I'm getting something different now in both ways I used it for 3.6 (Anaconda). Not sure what is going on. I don't receive what Alex did, but I get:</p>
<pre><code>class Something(object):
   def __init__(self):
   self.thing = "thing"

class SomethingElse(Something):
   def __init__(self):
      super(SomethingElse).__init__()
</code></pre>
<p>The calls (on Anaconda's 3.6):</p>
<pre><code>SomethingElse()

&lt;no problem&gt;

super(SomethingElse).__init__()

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: super(): no arguments 

super(SomethingElse).__init__(SomethingElse())

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: super() argument 1 must be type, not SomethingElse
</code></pre>
<p>My understanding of super was that, according to <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#super</a>, that <code>super()</code> with just the first argument would leave the <code>super</code> object unbounded to an instance, so that if you called <code>__init__()</code> on the <code>super</code> object, you'd need to pass in an instance as <code>__init__()</code> would be unbounded as well. However, 3.6 complains about how, with <code>super(SomethingElse).__init__(SomethingElse()</code>, <code>SomethingElse</code> isn't a <code>type</code>, which it should be as it inherits from a parent that inherits from <code>object</code>. </p>
<p>on 2.7.13 gives the original error for <code>super(SomethingElse).__init__()</code>, which was <code>TypeError: super() takes at least 1 argument (0 given)</code>. For <code>super(SomethingElse).__init__(SomethingElse())</code> it throws <code>TypeError: super() argument 1 must be type, not SomethingElse</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Calling <code>super</code> with 1 argument produces an "unbound" super object. Those are weird and undocumented and mostly useless, and I won't go into how they were intended to be used, but for the purposes of this answer, we really only need to know one thing about them.</p>
<p><code>super(SomethingElse).__init__</code> doesn't go through the usual <code>super</code> proxy logic. You're getting the <code>super</code> instance's own <code>__init__</code> method, not anything related to <code>SomethingElse</code>.</p>
<p>From there, the rest of the behavior follows. The <code>TypeError: super() takes at least 1 argument (0 given)</code> on Python 2 is because <code>super.__init__</code> takes at least 1 argument, and you're passing it 0. (You might expect it to say <code>TypeError: super() takes at least 2 arguments (1 given)</code> because it's still getting <code>self</code> - the <code>super</code> object <code>self</code>, not the <code>SomethingElse</code> instance - but due to weird implementation details, methods implemented in C generally don't count <code>self</code> for this kind of error message.)</p>
<p><code>SomethingElse()</code> succeeds on Python 3 because the <code>super</code> constructor pulls <code>__class__</code> and <code>self</code> from the usual stack inspection magic.</p>
<p>Calling <code>super(SomethingElse).__init__()</code> manually from outside the class produces <code>RuntimeError: super(): no arguments</code> because <code>super.__init__</code> tries to do its stack inspection magic and doesn't find <code>__class__</code> or <code>self</code>.</p>
<p><code>super(SomethingElse).__init__(SomethingElse())</code> fails because the first argument to the <code>super</code> constructor is supposed to be a type, not an instance.</p>
</div>
<span class="comment-copy">@Narendra This doesn't help. I've scoured the internet, and have seen that multiple times.</span>
<span class="comment-copy">Is this python 2?</span>
<span class="comment-copy">You should switch to Python version 3.6+ while you are still learning.... <a href="https://pythonclock.org/" rel="nofollow noreferrer">pythonclock.org</a></span>
<span class="comment-copy">Can reproduce on 2.7. Can't reproduce on 3.6.</span>
<span class="comment-copy">@ben Please update your question to reflect the actual context in which you are invoking <code>super(SomethingElse).__init__()</code> - it will save some time trying to reproduce the error.  Side note: I cannot reproduce the error on Python 2.7 - I get <code>TypeError: unbound method __init__() must be called with SomethingElse instance as first argument (got nothing instead)</code> - thank you!</span>
<span class="comment-copy">Why does <code>super</code> expect a type during <code>__init__</code> when I've already given it one in the call <code>super(SomethingElse)</code>? The Python documentation (<a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#super</a>)  doesn't suggest that it would lose track of its type.</span>
<span class="comment-copy">@ben: Because <code>__init__</code> expects a type. It doesn't matter whether you already provided one. You're calling the constructor again, and you need to provide all constructor parameters.</span>
<span class="comment-copy">If you think that's weird, well, calling the constructor of a constructed object is weird.</span>
<span class="comment-copy">Right, but when you call <code>super(SomethingElse, SomethingElse()).__init__()</code>, it doesn't use <code>super</code>'s constructor, which is why this is getting confusing.</span>
