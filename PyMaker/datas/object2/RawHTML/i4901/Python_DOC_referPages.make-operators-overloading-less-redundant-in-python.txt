<div class="post-text" itemprop="text">
<p>I'm writing a class overloading the list type.
I just wrote this and I'm wondering if there exists any other way less redundant to do it :  </p>
<pre><code>class Vector:
    def __mul__(self, other):
        #Vector([1, 2, 3]) * 5 =&gt; Vector([5, 10, 15])
        if isinstance(other, int) or isinstance(other, float):
            tmp = list()
            for i in self.l:
                tmp.append(i * other)
            return Vector(tmp)
        raise VectorException("We can only mul a Vector by a scalar")

    def __truediv__(self, other):
        #Vector([1, 2, 3]) / 5 =&gt; Vector([0.2, 0.4, 0.6])
        if isinstance(other, int) or isinstance(other, float):
            tmp = list()
            for i in self.l:
                tmp.append(i / other)
            return Vector(tmp)
        raise VectorException("We can only div a Vector by a Scalar")

    def __floordiv__(self, other):
        #Vector([1, 2, 3]) // 2 =&gt; Vector([0, 1, 1])
        if isinstance(other, int) or isinstance(other, float):
            tmp = list()
            for i in self.l:
                tmp.append(i // other)
            return Vector(tmp)
        raise VectorException("We can only div a Vector by a Scalar")
</code></pre>
<p>As you can see, every overloaded method is a copy/paste of the previous with just small changes.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want to do here is dynamically generate the methods. There are multiple ways to do this, from going super-dynamic and creating them on the fly in a metaclass's <code>__getattribute__</code> (although that doesn't work for some special methods—see <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">the docs</a>)
to generating source text to save in a <code>.py</code> file that you can then <code>import</code>. But the simplest solution is to create them in the class definition, something like this:</p>
<pre><code>class MyVector:
    # ...

    def _make_op_method(op):
        def _op(self, other):
            if isinstance(other, int) or isinstance(other, float):
                tmp = list()
                for i in self.l:
                    tmp.append(op(i. other))
                return Vector(tmp)
            raise VectorException("We can only {} a Vector by a scalar".format(
                op.__name__.strip('_'))
        _.op.__name__ = op.__name__
        return _op

    __mul__ = _make_op(operator.__mul__)
    __truediv__ = _make_op(operator.__truediv__)
    # and so on
</code></pre>
<hr/>
<p>You can get fancier and set <code>_op.__doc__</code> to an appropriate docstring that you generate (see <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.wraps</code></a> in the <code>stdlib</code> for some relevant code), and build <code>__rmul__</code> and <code>__imul__</code> the same way you build <code>__mul__</code>, and so on. And you can write a metaclass, class decorator, or function generator that wraps up some of the details if you're going to be doing many variations of the same thing. But this is the basic idea.</p>
<p>In fact, moving it outside the class makes it easier to eliminate even more repetition. Just define that <code>_op(self, other, op)</code> method in the class instead of locally inside <code>_make_op</code> and decorate the class with <code>@numeric_ops</code>, which you can define like this:</p>
<pre><code>def numeric_ops(cls):
    for op in "mul truediv floordiv".split():  # "mul truediv floordiv ... ".split():
        def _op(self, other):
            return self._op(other, getattr(operator, op)
        _op.__name__ = f"__{op}__"
        setattr(cls, f"__{op}__", _op)
</code></pre>
<p>If you look at, e.g., <code>functions.total_ordering</code>, it does something similar to generate any missing ordering ops out of the ones that are there.</p>
<p>The <code>operator.mul</code>, etc., come from the <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a> module in the stdlib—they're just trivial functions where <code>operator.__mul__(x, y)</code> basically just calls <code>x * y</code>, and so on, made for when you need to pass around an operator expression as a function.</p>
<p>There are some examples of this kind of code in the stdlib—although far more examples of the related but much simpler <code>__rmul__ = __mul__</code>.</p>
<p>The key here is that there's no difference between names you create with <code>def</code> and names you create by assigning with <code>=</code>. Either way, <code>__mul__</code> becomes an attribute of the class, and its value is a function that does what you want. (And, similarly, there’s almost no difference between names you create during class definition and names you inject afterward.)</p>
<hr/>
<p>So, should you be doing this?</p>
<p>Well, DRY is important. If you copy-paste-edit a dozen times it’s not unlikely that you’ll screw up one of the edits and end up with a mod method that actually multiples and that (and a unit test that doesn’t catch it). And then, if you later discover a flaw in the implementation you copied and pasted a dozen times (as between the original and edited version of the question), you have to fix the same flaw in a dozen places, which is yet another potential bug magnet.</p>
<p>On the other hand, readability counts. If you don't understand how that works, you probably shouldn't be doing this, and should settle for Ramazan Polat's answer. (It's not quite as compact, or as efficient, but it's surely easier to understand.) After all, if the code isn’t obvious to you, the fact that you only have to fix a bug once instead of a dozen times is swamped by the fact that you don’t know how to fix it. And even if you do understand it, the cost of cleverness can often outweigh the benefits of DRY.</p>
<p>I think <code>total_ordering</code> shows about where you’d want to draw the line. If you’re doing this one time, you’re better off with the repetition, but if you’re doing it for multiple classes or in multiple projects, you’re probably better off abstracting the cleverness into a library that you can write once, exhaustive test with a variety of different classes, and then use over and over.</p>
</div>
<div class="post-text" itemprop="text">
<p>Factorize code using <a href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="nofollow noreferrer">decorator design pattern</a> and <a href="https://pythonspot.com/python-lambda/" rel="nofollow noreferrer">lambda function</a>:</p>
<pre><code>class Vector:
    def __do_it(self, other, func):
        if isinstance(other, int) or isinstance(other, float):
            tmp = list()
            for i in self.l:
                tmp.append(func(i, other))
            return Vector(tmp)
        raise ValueError("We can only operate a Vector by a scalar")

    def __mul__(self, other):
        return self.__do_it(other, lambda i, o: i * o)

    def __truediv__(self, other):
        return self.__do_it(other, lambda i, o: i / o)

    def __floordiv__(self, other):
        return self.__do_it(other, lambda i, o: i // o)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code could be as compact as below (juanpa.arrivillaga suggested to <code>return NotImplemented</code> instead of raising an exception): </p>
<pre><code>def __mul__(self, other):
    #Vector([1, 2, 3]) * 5 =&gt; Vector([5, 10, 15])
    try:
        return Vector([i * other for i in self.l])
    except TypeError:
        return NotImplemented
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Strategy pattern is your friend here. I'll also touch on a couple of other ways you can clean up code.</p>
<p>You can read about the strategy pattern here: <a href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Strategy_pattern</a></p>
<p>You said "As you can see, every overloaded method is a copy/paste of the previous with just small changes." This is your hint to use this pattern. If you can make the small change into a function, then you can write the boilerplate code once and focus on the interesting parts.</p>
<pre><code>class Vector:
    def _arithmitize(self, other, f, error_msg):
        if isinstance(other, int) or isinstance(other, float):
            tmp = list()
            for a in self.l:
                tmp.append(func(a, other))
            return Vector(tmp)
        raise ValueError(error_msg)

    def _err_msg(self, op_name):
        return "We can only {} a vector by a scalar".format(opp_name)

    def __mul__(self, other):
        return self._arithmitize(
            other, 
            lambda a, b: a * b, 
            self._err_msg('mul'))

    def __div__(self, other):
        return self._arithmitize(
            other, 
            lambda a, b: a / b, 
            self._err_msg('div'))
    # and so on ...
</code></pre>
<p>We can clean this up a little more with a list comprehension</p>
<pre><code>class Vector:
    def _arithmetize(self, other, f, error_msg):
        if isinstance(other, int) or isinstance(other, float):
            return Vector([f(a, other) for a in self.l])
        raise ValueError(error_msg)

    def _err_msg(self, op_name):
        return "We can only {} a vector by a scalar".format(opp_name)

    def __mul__(self, other):
        return self._arithmetize(
            other, 
            lambda a, b: a * b, 
            self._err_msg('mul'))

    def __div__(self, other):
        return self._arithmetize(
            other, 
            lambda a, b: a / b, 
            self._err_msg('div'))
</code></pre>
<p>We can improve the type check</p>
<pre><code>import numbers

class Vector:
    def _arithmetize(self, other, f, error_msg):
        if isinstance(other, number.Numbers):
            return Vector([f(a, other) for a in self.l])
        raise ValueError(error_msg)
</code></pre>
<p>We can use operators instead of writing lambdas:</p>
<pre><code>import operators as op

class Vector:
    # snip ...
    def __mul__(self, other):
        return self._arithmetize(other, op.mul, self._err_msg('mul'))
</code></pre>
<p>So we end up with something like this:</p>
<pre><code>import numbers
import operators as op

class Vector(object):
    def _arithmetize(self, other, f, err_msg):
        if isinstance(other, numbers.Number):
            return Vector([f(a, other) for a in self.l])
        raise ValueError(self._error_msg(err_msg))
    def _error_msg(self, msg):
        return "We can only {} a vector by a scalar".format(opp_name)

    def __mul__(self, other):
        return self._arithmetize(op.mul, other, 'mul')

    def __truediv__(self, other):
        return self._arithmetize(op.truediv, other, 'truediv')

    def __floordiv__(self, other):
        return self._arithmetize(op.floordiv, other, 'floordiv')

    def __mod__(self, other):
        return self._arithmetize(op.mod, other, 'mod')

    def __pow__(self, other):
        return self._arithmetize(op.pow, other, 'pow')
</code></pre>
<p>There are other ways you might dynamically generate these, but for a small set of functions like this, readability counts.</p>
<p>If you need to generate these dynamically, try something like this:</p>
<pre><code>class Vector(object):
    def _arithmetize(....):
        # you've seen this already 

    def __getattr__(self, name):
        funcs = {
            '__mul__': op.mul, # note: this may not actually work with dunder methods. YMMV
            '__mod__': op.mod,
            ...
        }
        def g(self, other):
            try:
                return self._arithmetize(funcs[name],...)
             except:
                 raise NotImplementedError(...)
        return g
</code></pre>
<p>If you find this dynamic example does not work, check out <a href="https://stackoverflow.com/questions/49141878/make-operators-overloading-less-redundant-in-python/49142031#49142031">make operators overloading less redundant in python?</a>, which handles the case of dynamically creating dunder_methods in most python implementations.</p>
</div>
<span class="comment-copy">Why don't you use list comprehensions? <code>return Vector(i*other for i in self.l)</code> is much more compact than your four lines. As for <code>isinstance</code>, why not let Python itself raise <code>TypeError</code>?</span>
<span class="comment-copy">This is a good place to use the Strategy pattern.</span>
<span class="comment-copy">The less redundant way is to <code>import numpy</code></span>
<span class="comment-copy">I believe the "correct" way to do these is to return <code>NotImplemented</code> instead of raising the error, check out <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">Don't edit your question in a way that completely invalidates the answers. You asked a question. Don't then edit the question to make the answers nonsensical. I've rolled your question back to its original form and readded the tag that smci added; in the future, don't do that again.</span>
<span class="comment-copy">The metaclass <code>__getattribute__</code> approach wouldn't work; magic method lookup ignores that.</span>
<span class="comment-copy">Probably want to pass <code>operator.mul</code> instead of <code>operator.__mul_</code></span>
<span class="comment-copy">@juanpa.arrivillaga Why? Try <code>operator.__mul__ is operator.mul</code>. They're the exact same object. And I think <code>__mul__</code> is clearer for this case, because (a) we're implementing a <code>__mul__</code> method, and (b) it makes it more obvious that we're doing something that involves implementation stuff.</span>
<span class="comment-copy">This code block should be within some <code>class</code> block, right? I think, assuming I understand correctly, that this would be much easier to read it you added that one line and an extra level of indentation, to see that you’re doing that assignment within the class definition. (And if you <i>aren’t</i> doing it within a class’s block, then this answer leaves me quite confused as to how these operators are getting assigned to the class.)</span>
<span class="comment-copy">@RamazanPolat That's the point of the conclusion: it's probably only worth doing this kind of cleverness if you can abstract that cleverness away into a library. Which is exactly what the Python stdlib does—see the dynamic but trickily clever code in the reusable <code>total_ordering</code> decorator vs. the simpler but more repetitive code in some of the <code>collections</code> classes. (it's also why I upvoted your answer, and recommended it in my conclusion.) All that being said, it's worth learning how to read and understand this code (even if you're never going to write it).</span>
<span class="comment-copy">This is all true, but it doesn't answer the question. You're still copying and pasting the same implementation, with one character changed for each version. And, if fact, your changes show exactly why that's a problem: because if he wants to make the fixes you're suggesting, he has to make those same fixes in every one of the methods. What are the odds that he'll make a typo in one of them and not catch it until after he's created reams of buggy output?</span>
<span class="comment-copy">In you penultimate example, you don't need the <code>err_msg</code> argument to <code>arithimitize</code> - you can use <code>f.__name__</code> instead.  (i.e. <code>op.mul.__name__</code> is "mul").</span>
<span class="comment-copy">Also, it should be "arithm<b>e</b>tize" (names are important)</span>
<span class="comment-copy">The last version sadly won't work. Well, it won't work in CPython, and <i>probably</i> won't work in any Python; the rules for special method lookup are (intentionally) vague. But unless you're writing, e.g., a proxy class that lazily generates methods the first time they're called, creating them at class creation time (as with <code>total_ordering</code>, or my answer) rather than lookup time is usually all the dynamicness you need, and more efficient and easier to reason about (if a bit more verbose and harder to initially code up), so this limitation usually isn't a problem.</span>
<span class="comment-copy">@abarnert that's a good point. I've left a comment in there with a link to your answer. I think this still works if you need to implement some other interface that's not using special method names, so I've left it otherwise in place.</span>
<span class="comment-copy">@munk: Yeah, if it didn't work for non-special-method names, <code>__getattr__</code> and <code>__getattribute__</code> wouldn't  exist. And dynamic proxies (for bridges, ORMs, RPCs, etc.) often need it. I wasn't suggesting you remove it from your answer, just making a comment.</span>
