<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager" rel="nofollow noreferrer">According to the documentation</a>,</p>
<blockquote>
<p>Connection objects can be used as context managers that automatically commit or rollback transactions. In the event of an exception, the transaction is rolled back; otherwise, the transaction is committed:</p>
</blockquote>
<p>I understand that everything within a <code>with</code> statement should be an atomic transaction. Now consider this code</p>
<pre><code>import sqlite3
con = sqlite3.connect(':memory:')

try:
  with con:
    con.execute('create table foo (id integer primary key)')
    con.execute('insert into foo values (1)')
    con.execute('insert into foo values (1)')
except sqlite3.Error:
  print('transaction failed')

try:
  rec = con.execute('select count(*) from foo')
  print('number of records: {}'.format(rec.fetchone()[0]))
except sqlite3.Error as e:
  print(e)
</code></pre>
<p>which returns</p>
<pre class="lang-none prettyprint-override"><code>transaction failed
number of records: 0
</code></pre>
<p>On one hand, the transaction failed, due to the duplicated value. On the other hand, table <code>foo</code> exists, even though it is empty, which means that the first insert has been rolled back. Shouldn't the table creation be rolled back as well?</p>
<p>Doing the transaction "by hand" produces the expected result:</p>
<pre><code>import sqlite3
con = sqlite3.connect(':memory:')

con.execute('begin')
try:
  con.execute('create table foo (id integer primary key)')
  con.execute('insert into foo values (1)')
  con.execute('insert into foo values (1)')
  con.execute('commit')
except sqlite3.Error:
  con.execute('rollback')
  print('transaction failed')

try:
  rec = con.execute('select count(*) from foo')
  print('number of records: {}'.format(rec.fetchone()[0]))
except sqlite3.Error as e:
  print(e)
</code></pre>
<p>returns </p>
<pre class="lang-none prettyprint-override"><code>transaction failed
no such table: foo
</code></pre>
<p>Why the discrepency?</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.6, DDL, or Data Defitinion Language statements, like <code>CREATE TABLE</code>, do not start a transaction. This means that any such statement is automatically committed the moment you execute one.</p>
<p>See the <a href="https://docs.python.org/3/library/sqlite3.html#controlling-transactions" rel="nofollow noreferrer"><em>Controlling transactions</em> section</a>:</p>
<blockquote>
<p>By default, the <code>sqlite3</code> module opens transactions implicitly before a Data Modification Language (DML) statement (i.e. <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>).</p>
<p>[...]</p>
<p><em>Changed in version 3.6</em>: <code>sqlite3</code> used to implicitly commit an open transaction before DDL statements. This is no longer the case.</p>
</blockquote>
<p>This means that you'll have to start a transaction <em>explicitly</em> if you want DDL statements to be part of a transaction.</p>
<p>Using the connection as a context manager still only issues a <em>commit</em> or <em>rollback</em> when exiting, it does not <em>start</em> a transaction; instead the first DML statement encountered will start one. If you want DDL to be part of a transaction, add a <code>begin</code> statement at the top:</p>
<pre><code>try:
    with con:
        con.execute('begin')  # explicit, rather than implicit, transaction start
        con.execute('create table foo (id integer primary key)')
        con.execute('insert into foo values (1)')
        con.execute('insert into foo values (1)')
except sqlite3.Error:
    print('transaction failed')
</code></pre>
</div>
