<div class="post-text" itemprop="text">
<p>I have an issue with using a class to decorate another class's method. Code is as follows</p>
<pre><code>class decorator(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args):
        return self.func(*args)

class test(object):
    @decorator
    def func(self, x, y):
        print x, y

t = test()
t.func(1, 2)
</code></pre>
<p>It shows this error </p>
<blockquote>
<p>TypeError: func() takes exactly 3 arguments (2 given).</p>
</blockquote>
<p>if called using</p>
<pre><code>t.func(t, 1, 2)
</code></pre>
<p>then it passes. But then if the decorator is taken away, then this line will have issue again.</p>
<p>Why this is happening and how to solve it?</p>
<p>EDIT: second version of the code to show the self in decorator.<strong>call</strong> should be different than the self in test.func</p>
<pre><code>class decorator(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args):
        return self.func(*args)

class test(object):
    def __init__(self):
        self.x = 1
        self.y = 2
    @decorator
    def func(self):
        print self
        print self.x, self.y

t = test()
t.func()
</code></pre>
<p>This shows the same error. But </p>
<pre><code>t.func(t)
</code></pre>
<p>works but not ideal.</p>
</div>
<div class="post-text" itemprop="text">
<p>To work as a method, an object in a class needs to implement part of <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">the descriptor protocol</a>. That is, it should have a <code>__get__</code> method that returns a callable object which has been "bound" to the instance the method was looked up on.</p>
<p>Here's one way that you could make that work, using a wrapper function:</p>
<pre><code>class decorator(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def wrapper(*args):
            return self.func(instance, *args) # note, self here is the descriptor object
        return wrapper
</code></pre>
<p>You could instead return an instance of some other class from <code>__get__</code>, rather than a function, and use the <code>__call__</code> method of that other class to implement the wrapper. If you're not using a closure though, you'd need to pass the <code>instance</code> to the wrapper class explicitly (as well as the function, since <code>self.func</code> won't work outside the descriptor class).</p>
</div>
<span class="comment-copy">Thanks for the descriptor suggestion. I found a related question in <a href="https://stackoverflow.com/questions/2365701/decorating-python-class-methods-how-do-i-pass-the-instance-to-the-decorator" title="decorating python class methods how do i pass the instance to the decorator">stackoverflow.com/questions/2365701/â€¦</a>. As you suggest, either getting the descriptor working or using closure function works. This code is clear for the descriptor solution <a href="https://stackoverflow.com/a/45361673">stackoverflow.com/a/45361673</a>. I ended up using closure function for easier maintenance.</span>
