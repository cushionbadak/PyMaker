<div class="post-text" itemprop="text">
<p>I have a CSV file like this one:</p>
<pre><code>route|id|alias|longitude|latitude
A|1|first|-33.51808226|-70.58256582
A|1|first|-33.52850414|-70.57645648
B|2|second|-33.51952529|-70.58043875
B|2|second|-33.53452223|-70.58343824
</code></pre>
<p>Each route has an <code>id</code> and an <code>alias</code> that are always the same for the same <code>route</code>. Also each <code>route</code> has a set of <code>points</code>, each of them made of a <code>longitude</code> and <code>latitude</code>. I'm trying to group the <code>points</code> by <code>route</code>, but I want to yield every field of the file.</p>
<p>When I use <code>itertools groupby</code> to group by <code>route</code>, I'm only able to yield <code>route</code> and <code>points</code>:</p>
<pre><code>with open(self.datafile, "r") as f:
        reader = csv.DictReader(f, delimiter='|')
        # Group data using 'route' as key
        for route, points in groupby(reader, lambda p: p['route']):
            points = list(points)
            points = [
                {
                    'longitude': p['longitude'],
                    'latitude': p['latitude']
                } for p in points
            ]
            yield {
                "_source": {
                    "route": route,
                    "points": points
                }
            }
</code></pre>
<p>I tried different ways to get the <code>id</code> and <code>alias</code> for that <code>route</code> (like using <code>route['id']</code> or <code>p['id']</code> to get the <code>id</code> or using another for outside the existing one), but none of them worked. </p>
<p>Is there a way to have a composite key when using groupby? Or maybe an easier solution to my problem?</p>
<p>I would like to be able to yield this:</p>
<pre><code>yield {
                "_source": {
                    "route": route,
                    "id": id,
                    "alias": alias,
                    "points": points
                }
            }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can indeed <code>groupby</code> with a composite key:</p>
<pre><code># Group data using 'route', 'id', 'alias' as key
for route_id_alias, values in itertools.groupby(reader, lambda p: (p['route'], p['id'], p['alias'])):
    points = [
        {
            'longitude': p['longitude'],
            'latitude': p['latitude'],
        } for p in values
    ]
    print( {
        "_source": {
            "route": route_id_alias[0],
            "id": route_id_alias[1],
            "alias": route_id_alias[2],
            "points": points,
        }
    })
</code></pre>
<p>You just need to access your key by index when you yield the result.</p>
<p><a href="https://tio.run/##ZZJNi9swEIbv@hWDe7ANXuPIVuIN5NBSKD0V2mMIQRtps2Idy0jyQqj2t6f68GZTRwfxzuixZt6Rh7N5kX19uYjTIJWBg35DkxSGKyNlp68JiRCjhm6SJFFyNNwKZmknqLad7I/CjIzbjpog0Fe7sM9CaWMf6roki7ZqMV7ah1VVkhaTpdvmDG5J1SyayKyWDVk2LfpmsdX8IHs2XfRIMMGP00VVU7crcgfVDcEY1xNUOwg3rmuEFKeMK9h4o@V3cTC/QyITsvxjlOiPP39l3mNeAOOdOPkhbFKb5gh9gR/O9QD@GEbtWEjDGNICUsH8HoaRAtXwys/oWSoIwF6wfTgq4I12I9cg@s/xlkd/7dM5i70V0NHTE6MwrCEbtlOJXQFOuypRxEK7PF8jcGuQojfaudqG0K@/V@VXen2gdO2//wx3xQyc3m/iPqIb7B28scF7iG7CyS424kZospviyV7LUR14sp51FP8gl/5/Qttq1lAi2D20mEMhfc/hORcH5cAobkwF9Z5fLv8A" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>groupby</code> multiple fields at once if you return a tuple from your <code>key</code> function.</p>
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> for that. The for loop would look like:</p>
<pre><code>for (route, id, alias), points in groupby(reader, key=operator.itemgetter('route', 'id', 'alias')):
</code></pre>
</div>
<span class="comment-copy">What does your expected output look like?  Are you okay with using pandas?</span>
<span class="comment-copy">1. What do you mean by "not worked" ?  2. You can return a tuple from the <code>key</code> lambda  3. <code>itertools.groupby</code> works best if  it is used on sorted data (according to the same <code>key</code> used for the grouping)</span>
<span class="comment-copy"><code>for route, points in groupby(reader, lambda p: p['route']): ;  for point in points: ; print(point['id'], point['alias'])</code> works perfectly fine</span>
<span class="comment-copy">If you get an error, please provide it. Also provide an expected output</span>
<span class="comment-copy">I tried to clarify the expected output</span>
<span class="comment-copy">I somewhat need to understand what happened here. I posted and answer that is conceptually the same than this one (return a tuple from the key function) and got downvoted; <b>then</b> you post this and get all the credit. Why is that?</span>
<span class="comment-copy">@MathiasEttinger First of all: I did not copy your answer. I was working on mine when you published yours. Our answers are indeed conceptually equivalent, but yours is more... conceptual. And I think the use of itemgetter introduces an unncessary complexity here for the OP. I tried to give a very simple and immediately useful answer (with a TYO link). What I don't understand is why your answer was downvoted. BTW: I just upvoted your answer.</span>
<span class="comment-copy">The comment wasn't meant to be accusatory in any way, sorry if it felt like that. It's more like you said "I don't understand is why [my] answer was downvoted" when it boils down to the same thing as yours, but maybe the spoonfeeding with the whole loop body and the TIO link really was the killer thing… Anyway, leaving the comment helped me refine the text of my answer. And thanks for the vote.</span>
