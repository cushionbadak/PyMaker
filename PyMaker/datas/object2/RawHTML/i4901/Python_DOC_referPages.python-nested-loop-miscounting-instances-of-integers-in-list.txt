<div class="post-text" itemprop="text">
<p>I'm banging my head against the wall trying to figure out why this nested loop is miscounting the number of times an integer occurs in a list. I've set up a function to take two lines of input, <code>n</code> and <code>ar</code>, where <code>n</code> is the number of integers in <code>ar</code> and <code>ar</code> is the list of integers. My code is below:</p>
<pre><code>import sys

n = sys.stdin.readline()
n = int(n)
ar = sys.stdin.readline()
ar = ar.split(' ')
ar = [int(i) for i in ar]

def find_mode(n,ar):
    # create an empty dict and initially set count of all integers to 1
    d = {}
    for i in range(n):
        d[ar[i]] = 1

    for i in range(n):
        # hold integer i constant and check subsequent integers against it
        # increase count if match
        x = ar[i]

        for k in range(i+1,n):
            if ar[k] == x:
                d[ar[k]] += 1

    print(d)
</code></pre>
<p>The counter seems to be increasing the count by 1 every time, which leads me to believe it's a problem with the nested loop.</p>
<pre><code>&gt;&gt;&gt; 9 
&gt;&gt;&gt; 1 2 3 4 4 9 9 0 0
{0: 2, 1: 1, 2: 1, 3: 1, 4: 2, 9: 2}
</code></pre>
<p>OK</p>
<pre><code>&gt;&gt;&gt; 10
&gt;&gt;&gt; 1 2 3 4 4 9 9 0 0 0
{0: 4, 1: 1, 2: 1, 3: 1, 4: 2, 9: 2}
</code></pre>
<p>Count of 0 increased by +2</p>
<pre><code>&gt;&gt;&gt; 11
&gt;&gt;&gt; 1 2 3 4 4 9 9 0 0 0 0
{0: 7, 1: 1, 2: 1, 3: 1, 4: 2, 9: 2}
</code></pre>
<p>Count of 0 increased by +3</p>
<p>I understand there might be more efficient or "pythonic" ways to count the amount of times a number occurs in a list but this was the solution I came up with and as someone still learning Python, it would help to understand why this exact solution is failing. Many thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because for each distinct number in the list (call it <code>x</code>) you count the number of subsequent appearances. This is fine if a number only occurs twice but if it occurs multiple times you will over-count for each additional appearance.</p>
<p>For example: <code>[0, 0, 0, 0]</code>. You iterate over the list and then for each item you iterate over the list that follows that item. So for the first <code>0</code> you count a total of <code>3</code> subsequent <code>0</code>s. For the second however you will count a total of <code>2</code> and for the third a total of <code>1</code> which makes <code>6</code>. This is why you have <code>3</code> too much in the end.</p>
<p>You can achieve this task by using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; d = Counter(ar)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not exactly sure that I can fix your specific problem, but would something like this work instead?</p>
<pre><code>d={}
for x in ar:
    d[x] = d.get(x, 0) + 1
</code></pre>
<p>I understand that you want to fix your existing work as a learning exercise, but I'm not sure that that approach is even the right one. As it is, I can't really tell what you're going for, so it's hard for me to offer specific advice. I would recommend that you don't throw good time after bad.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>python</code> has a <code>method</code> to do exactly what you're describing.</p>
<p>It's called <code>.count()</code>.</p>
<p>If you do <code>ar.count(3)</code>, it will return the number of occurences of 3 in the list <code>ar</code>.</p>
<p>** In your case:**</p>
<p>There's no need for a nested loop as you only need one loop.</p>
<p>Try this:</p>
<pre><code>dic = {}
for num in ar:
    if num not in dic:
        dic[num] = 1
    else:
        dic[num] += 1
</code></pre>
<p>This would produce the <code>dict</code> you want with the numbers and their occurences</p>
</div>
<div class="post-text" itemprop="text">
<p>You can refer to other answers as to how you should solve this problem more efficiently, but to answer the question you're asking (Why doesn't this nested loop work?):</p>
<p>To visualize what your nested loop is doing consider the following input:</p>
<p><code>0 0 0 0 0</code></p>
<p>Your algorithm will count the following:</p>
<p><code>0 0 0 0 0 
 ^ ^ ^ ^ ^</code>   (5)</p>
<p>then,</p>
<p><code>0 0 0 0 0 
   ^ ^ ^ ^</code>  (4)</p>
<p>then,</p>
<p><code>0 0 0 0 0 
     ^ ^ ^</code> (3)</p>
<p>then,</p>
<p><code>0 0 0 0 0 
       ^ ^</code> (2)</p>
<p>and finally,</p>
<p><code>0 0 0 0 0 
         ^</code> (1)</p>
<p>What happens is it counts the number of 0's multiple times over. In this instance it will count</p>
<p><code>15</code> 0's (5+4+3+2+1)</p>
</div>
<div class="post-text" itemprop="text">
<p>itertools are your friend</p>
<pre><code>from itertools import groupby

def group_by_kv_l(n):
    l = []
    for k, v in groupby(n):
        l.append((len(list(v)),int(k)))
    return l

def group_by_kv_d(n):
    d = {}
    for k, v in groupby(n):
        d[(int(k))] = len(list(v))
    return d

if __name__ == "__main__":

    n = input().split()
    n = "".join(n)

    print(
        "STDIN: {}".format(n)
    )

    print(
        group_by_kv_l(n)
    )

    print(
        group_by_kv_d(n)
    )
</code></pre>
</div>
<span class="comment-copy">You don't need to have a nested loop in order to solve this problem. The problem you're facing is the existence of a nested loop.</span>
<span class="comment-copy">Can you elaborate a bit more as to why a nested loop won't work? My thought process was to hold one integer constant then loop through the rest of them (via nested loop) and compare them to the constant. Can this not be achieved?</span>
<span class="comment-copy">Var n feels unnecessary because you can just use len().</span>
<span class="comment-copy">This can be observed via adding <code>print("Found %s at position %s" % (x, k))</code> to the inner loop where you increment the dct.</span>
<span class="comment-copy">Thank you for the explanation. That hit the nail on the head for me.</span>
<span class="comment-copy">Thank you very much for this explanation. Essentially, the first pass is the correct answer, which is why it was recommended not to use a nested loop?</span>
<span class="comment-copy">Yeah, that's exactly why</span>
