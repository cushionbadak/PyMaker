<div class="post-text" itemprop="text">
<p>Apologies for incorrect lingo, I am still new to this. </p>
<p>I want to make a class initialiser that, using a conditional, will decide whether or not the instance of said class will collapse into a simple integer.</p>
<p>Simplified Unworking Example:</p>
<pre><code>class A(object): 
    def __init__(self,a,b):
        self.a = a
        self.b = b
        if self.b == 0:
            return int(a)
    def __repr__(self):
        return str(a)+":"+str(b)

DoesntBecomeAnInt = A(3,4)
WillBecomeAnInt = A(3,0)
print(DoesntBecomeAnInt,WillBecomeAnInt)

##Desired Output:
##3:4, 3
</code></pre>
<p>Any help would be very much appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class A:
    def __new__(cls, a, b):
        if b == 0:
            return a
        return super().__new__(cls)
    def __init__(self, a, b):
        print('Initilizing')
        self.a = a
        self.b = b
    def __repr__(self):
        return str(self.a)+":"+str(self.b)
</code></pre>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> is the method used to control the creation of new objects (hence the name).  Here we check if <code>b</code> is zero in <code>__new__</code> and return an instance of the appropriate type.  </p>
<p>In action:</p>
<pre><code>&gt;&gt;&gt; DoesntBecomeAnInt = A(3,4)
Initilizing
&gt;&gt;&gt; WillBecomeAnInt = A(3,0)
&gt;&gt;&gt; print(DoesntBecomeAnInt,WillBecomeAnInt)
3:4 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use the magic method <code>__new__</code> for this. <code>__new__</code> is used as a factory where you can decide which class should be instantiated.</p>
<pre><code>class A(object):
    def __new__(self, a):
        return int(a)

A(4)
&gt; 4
A(4).__class__
&gt; &lt;type 'int'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>You don't.</h1>
<p>The behavior you desire is completely unexpected and somewhat bizarre. Calling <code>A()</code> is expected to return an instance of <code>A</code>. Doing anything else is confusing and unintuitive, which makes it difficult to read and understand any code invoking it.</p>
<h1>Alternative</h1>
<p>If you really need this behavior, create a factory method:</p>
<pre><code>def make_thing(a, b):
    if 0 == b:
        return int(a)
    else:
        return A(a, b)
</code></pre>
<p>Obviously, you need a better name than <code>make_thing</code>, but without any context, I can't give you any suggestions.</p>
<h1>Avoid the problem if possible</h1>
<p>Since <code>A</code> is not a number and is generally not compatible with <code>int</code>, it is also somewhat strange to store both <code>int</code> and <code>A</code> in the same variable.</p>
<p>If all you're doing is converting to a string, then you don't need a class at all. A simple method outside of a class is the better alternative:</p>
<pre><code>def a_and_b_to_string(a, b):
    if b == 0:
        return str(int(a))
    else:
        return str(a) + ":" + str(b)
</code></pre>
<p>If you're doing more than that, your calling code will probably end up looking something like this:</p>
<pre><code>x = make_thing(input1, input2)
if isinstance(x, A):
    result = x.some_method_from_a() # Or some other calculation requiring an A
else:
    result = 5 * x # Or some other calculation requiring an `int`
</code></pre>
<p>This is somewhat silly: you write a method to choose the data type and then have to write specialized code for each possible result. You're not getting any benefits from having a function that returns the separate types here. I can think of two simpler alternatives:</p>
<ol>
<li><p>Just move the check to the calling code:</p>
<pre><code>if input2 == 0:
    temp = A(input1, input2)
    result = temp.some_method_from_a() # Or some other calculation requiring an A
else:
    result = 5 * int(input1) # Or some other calculation requiring an int
</code></pre>
<p>If you go this route, you should also modify <code>A.__init__</code> to throw a <code>ValueError</code> if <code>b == 0</code>, since that would be an invalid state for an <code>A</code> to be in.</p></li>
<li><p>Modify <code>A</code> so that it works properly regardless of whether <code>b</code> is <code>0</code>:</p>
<pre><code>class A(object):
    def __init__(self,a,b):
        self.a = a
        self.b = b

    def some_method_from_a():
        if self.b == 0:
            # Some calculation involving only a
            return int(self.a) * 5
        else:
            # Some other more complex calculation involving both a and b
            return self.a * self.b * 6

    def __repr__(self):
        if self.b == 0:
            return str(int(self.a))
        else:
            return str(self.a) + ":" + str(self.b)
</code></pre>
<p>Then</p>
<pre><code>x = A(a, b)
result = x.some_method_from_a()
</code></pre></li>
</ol>
<p>But again, it's hard to provide recommendations without knowing how you're actually using it.</p>
</div>
<span class="comment-copy">This is perfect. Thank you!</span>
<span class="comment-copy">This is bizarre and makes understanding the behavior of callers more difficult. -1</span>
<span class="comment-copy"><code>__new__</code> needs to take <code>b</code> as well here</span>
<span class="comment-copy">This is bizarre and makes understanding the behavior of callers more difficult. -1</span>
