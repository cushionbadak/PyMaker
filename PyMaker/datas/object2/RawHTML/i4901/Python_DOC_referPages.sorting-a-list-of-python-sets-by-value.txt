<div class="post-text" itemprop="text">
<p>The frozenset docs says:</p>
<blockquote>
<p>The frozenset type is immutable and hashable â€” its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</p>
</blockquote>
<p>However, the docs for for python sets says:</p>
<blockquote>
<p>Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets.</p>
</blockquote>
<p>This makes me ask:  why is the case?  And, if I wanted to sort a list of sets by set content, how could I do this?  I know that the extension intbitset:  <a href="https://pypi.python.org/pypi/intbitset/2.3.0" rel="nofollow noreferrer">https://pypi.python.org/pypi/intbitset/2.3.0</a> , has a function for returning a bit sequence that represents the set contents.  Is there something comparable for python sets?</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuples, lists, strings, etc. have a natural lexicographic ordering and can be sorted because you can always compare two elements of a given collection. That is, either <code>a &lt; b</code>, <code>b &lt; a</code>, or <code>a == b</code>.</p>
<p>A natural comparison between two sets is having <code>a &lt;= b</code> mean <code>a</code> is a subset of <code>b</code>, which is what the expression <code>a &lt;= b</code> actually does in Python. What the documentation means by "partial ordering" is that not all sets are comparable. Take, for example, the following sets:</p>
<pre><code>a = {1, 2, 3}
b = {4, 5, 6}
</code></pre>
<p>Is <code>a</code> a subset of <code>b</code>? No. Is <code>b</code> a subset of <code>a</code>? No. Are they equal? No. If you can't compare them at all, you clearly can't sort them.</p>
<p>The only way you can sort a collection of sets is if your comparison function actually can compare any two elements (a <a href="https://en.wikipedia.org/wiki/Total_order" rel="nofollow noreferrer">total order</a>). This means you can still sort a collection of sets using the above subset relation, but you will have to ensure that all of the sets are comparable (e.g. <code>[{1}, {1, 2, 4}, {1, 2}]</code>).</p>
<p>The easiest way to do what you want is to transform each individual set into something that you actually <em>can</em> compare. Basically, you do <code>f(a) &lt;= f(b)</code> (where <code>&lt;=</code> is obvious) for some simple function <code>f</code>. This is done with the <code>key</code> keyword argument:</p>
<pre><code>In [10]: def f(some_set):
   ...       return max(some_set)
   ...

In [11]: sorted([{1, 2, 3, 999}, {4, 5, 6}, {7, 8, 9}], key=f)
Out[11]: [{4, 5, 6}, {7, 8, 9}, {1, 2, 3, 999}]
</code></pre>
<p>You're sorting <code>[f(set1), f(set2), f(set3)]</code> and applying the resulting ordering to <code>[set1, set2, set3]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take an example: say you wanted to sort a list of sets by the "first element" of each set.  The issue is that Python sets or frozensets don't have a "first element."  They have no sense of their own ordering.  A set is an unordered collection with no duplicate elements.</p>
<p>Furthermore, <code>list.sort()</code> sorts the list in place, <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="nofollow noreferrer">using only the <code>&lt;</code> operator between items</a>.</p>
<p>If you just use <code>a.sort()</code> without passing any <code>key</code> parameter, saying <code>set_a &lt; set_b</code> (or <code>set_a.__lt__(set_b)</code>) is <em>insufficient</em>.  By insufficient, I mean that <code>set_a.__lt__(set_b)</code> is a <em>subset</em> operator.  (Is <code>a</code> a subset of <code>b</code>?).  As mentioned by @Blender and referenced in your question, this provides for partial rather than total ordering, which is insufficient for defining what ever sequence holds the sets.</p>
<p>From the docs:</p>
<blockquote>
<p><code>set &lt; other</code>: Test whether the set is a proper subset of other, that
  is, <code>set &lt;= other</code> and <code>set != other</code>.</p>
</blockquote>
<p>You <em>could</em> pass a <code>key</code> to <code>sort()</code>, it just couldn't refer to anything to do with the "ordering" of the sets internally, because remember--there is none.</p>
<pre><code>&gt;&gt;&gt; a = {2, 3, 1}
&gt;&gt;&gt; b = {6, 9, 0, 1}
&gt;&gt;&gt; c = {0}
&gt;&gt;&gt; i = [b, a, c]
&gt;&gt;&gt; i.sort(key=len)
&gt;&gt;&gt; i
[{0}, {1, 2, 3}, {0, 9, 6, 1}]
</code></pre>
</div>
<span class="comment-copy">Please provide a code example of what you can't do and then we can provide a code example of how to do it.</span>
<span class="comment-copy">Okay, so I understand this request in some cases.  But what in the world do I need a code example for here.  What is confusing about this question that a code example would clear up?  I was pretty specific.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/42956966/how-does-python-sort-a-list-of-sets">How does Python sort a list of sets?</a></span>
