<div class="post-text" itemprop="text">
<pre><code>productcode = ['apple','orange','melons'] # 1000+ more
pairs = []
count = 0
for xi,x in enumerate(productcode):
    del productcode[xi]
    for yi,y in enumerate(productcode):
        pc2 += 1
        p = (x,y)
        pairs.append(p)

print ("Number of distinct pairs:",pc2)
</code></pre>
<p>productcode contains over a thousand data items: </p>
<pre><code>apple

orange

grape
</code></pre>
<p>Expected output:</p>
<pre><code>apple orange

apple grape

orange grape
</code></pre>
<p>The nested for loops only iterate over half the items in the list (productcode) and therefore I end up with much lesser number of pairs than I expect. Could anyone help explain what I've done wrong, or what is actually happening? </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> is a natural choice for this. To avoid duplicates, just convert your <code>list</code> to a <code>set</code> first. There are 2 similar solutions, depending on whether you need ordered results.</p>
<p><strong>Ordered</strong></p>
<pre><code>from itertools import combinations

productcode = ['apple', 'orange', 'grape']

res_lst = sorted(map(sorted, combinations(set(productcode), 2)))

# [['apple', 'grape'], ['apple', 'orange'], ['grape', 'orange']]
</code></pre>
<p>I'm not sure what order you require, so I've sorted both <em>within</em> and <em>across</em> sublists, alphabetically in each case.</p>
<p><strong>Unordered</strong></p>
<p>If order is unimportant anywhere, then you need to use a <code>set</code> of <code>frozenset</code> items:</p>
<pre><code>res_set = set(map(frozenset, combinations(set(productcode), 2)))

# {frozenset({'apple', 'orange'}),
#  frozenset({'grape', 'orange'}),
#  frozenset({'apple', 'grape'})}
</code></pre>
<p>This is because <code>set</code> items must be immutable; <code>frozenset</code> is an immutable version of <code>set</code>. This is one natural way to test whether a pair is in the set. For example:</p>
<pre><code>{'orange', 'apple'} in res_set  # True
</code></pre>
<p>Another way is to use a set of alphabetically sorted tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>You modify a collection while iterating it. Bad idea.</p>
<p>There is this <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">cool datastructure that gets rid of duplicates</a>:</p>
<p><strong>Create plenty of duplicate data:</strong></p>
<pre><code>from itertools import combinations

# make all 2-length combinations of 1,2,3,1,2,3,4,5,3   
comb = list(combinations([ 1,2,3,1,2,3,4,5,3  ],2)) # works with strings as well
print(comb) 
</code></pre>
<p>Output:</p>
<pre><code>[(1, 2), (1, 3), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), 
 (1, 3), (2, 3), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), 
 (2, 3), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 3), 
 (1, 2), (1, 3), (1, 4), (1, 5), (1, 3), (2, 3), (2, 4), 
 (2, 5), (2, 3), (3, 4), (3, 5), (3, 3), (4, 5), (4, 3), (5, 3)]
</code></pre>
<p><strong>Make data unique:</strong></p>
<pre><code>uniques = set(comb)
print(uniques)  
</code></pre>
<p>Output:</p>
<pre><code>set([(1, 2), (3, 2), (1, 3), (3, 3), (4, 5), (3, 1), (1, 4), 
     (2, 4), (1, 5), (2, 3), (2, 1), (4, 3), (2, 2), (2, 5), 
     (5, 3), (3, 4), (1, 1), (3, 5)])
</code></pre>
<p>If you need all <a href="https://docs.python.org/3.6/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">combinations</a> of something, stuff the somethings into a <code>set</code> beforehand to eleminate all dupes and create your <code>combinations</code> via <code>itertools.combinations</code> from the <code>set</code>. If you use <code>combinations</code> on a <code>list</code> with dupes, you create unneeded many <code>combinations</code> - so <strong><code>set</code></strong> first, then <strong><code>combination</code>s</strong> from it.</p>
<hr/>
<p>Drawback/catch for sets (and dicts) is that they need immutable keys - so <code>tuples</code> are fine, <code>lists</code> are not but <code>strings</code> work well. You can <code>tuple(alist)</code> if you need to. </p>
</div>
<span class="comment-copy">Add desired input and output. What's <code>content</code>?</span>
<span class="comment-copy">do not moidify when enumerating over something - just as a safeguard. and provide code as  <a href="https://stackoverflow.com/help/mcve">mvce</a> so we can copy your <b>m</b>inimal <b>e</b>xamplecode to <b>v</b>erify without need to add to it so it is <b>c</b>omplete (<b>out of order</b> - you get the gist of it).</span>
<span class="comment-copy">you modify the enumeration while enumerating it ...</span>
<span class="comment-copy">did one of the below answers help? if so, feel free to accept one, or ask questions to clarify.</span>
<span class="comment-copy">Thank you. Using "combinations" and keeping the sorting took me 20 seconds runtime, removing the sorting took me to 8 seconds (for 2113 distinct productcodes that I'm reading from a file). Can I get greedier than 8 secs?</span>
<span class="comment-copy">@JubG, I can't see any obvious way, but it may be possible via <code>cython</code>, but this will be a more complex solution.</span>
