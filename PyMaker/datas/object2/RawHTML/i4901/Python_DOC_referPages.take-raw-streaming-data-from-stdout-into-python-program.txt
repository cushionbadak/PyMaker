<div class="post-text" itemprop="text">
<p>I have a hackrf hardware unit that is feeding a continuous raw uint8 data stream to a linux shell pipe. </p>
<p>For example this will pipe continous data to another application in a linux shell like so:</p>
<p><code>hackrf_transfer -r /dev/stdout -f 92700000 -s 8000000 - | (another appli</code>cation)</p>
<p>In python this will do the same:</p>
<pre><code>hackout = subprocess.Popen(['hackrf_transfer', '-r', '/dev/stdout', '-f', '92700000', '-s', '8000000'], stdout=subprocess.PIPE)
</code></pre>
<p>BUT I cannot get the Hackrf pipe stream into a python script. For example I may want to decimate that raw data stream or manipulate it in some way and then send it on to another subprocess application etc. like so:</p>
<blockquote>
<p>(HackRF)source subprocess &gt;&gt; a python script &gt;&gt; sink subprocess (eg.
  baudline)</p>
</blockquote>
<p>or in a single python script:</p>
<blockquote>
<p>source hackrf &gt;&gt; my_function &gt;&gt; sink application</p>
</blockquote>
<p>I can do source &gt;&gt; sink in a python script where both applications already accept a shell command such as a hackrf subprocess pipe into Baudline subprocess stdin pipe. In other words if the two apps work in the shell using a pipe it works in a python subprocess call. But I can't get a python function between this shell pipe to alter the data using a python script or function.</p>
<p>Does anyone have any ideas on how I could go about this please?</p>
</div>
<div class="post-text" itemprop="text">
<p>The output of <code>hackrf_transfer</code> is a byte stream, not line-oriented, so <a href="https://docs.python.org/3/library/io.html#io.IOBase.readlines" rel="nofollow noreferrer"><code>readlines()</code></a> doesn't work; use <a href="https://docs.python.org/3/library/io.html#io.RawIOBase.read" rel="nofollow noreferrer"><code>read(8*1024)</code></a> instead.</p>
<blockquote>
<p>If I use hackout.stdout.read() or hackout.communicate it 'sinks' the data stream.</p>
</blockquote>
<p>Right, those calls without arguments cannot be used to read a continuous data stream in parallel.</p>
<ul>
<li><a href="https://docs.python.org/3/library/io.html#io.RawIOBase.read" rel="nofollow noreferrer"><code><b>read</b>(<i>size=-1</i>)</code></a>:

<blockquote>
<p>As a convenience, if <em>size</em> is unspecified or -1, all bytes until EOF are returned.</p>
</blockquote></li>
<li><a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code><b>communicate</b>(<i>input=None, timeout=None</i>)</code></a>:

<blockquote>
<p>Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate.</p>
</blockquote></li>
</ul>
<p>This is why I told to use <code>read(8*1024)</code>.</p>
<blockquote>
<p>Its not running errors or messages with this: data = hackout.stdout.readlines(8*1024) but I want to take this and feed it to stdout. I tried sys.stdin.write(data) its not writing but It's seeing 'data' as a list. So its captured the data but I can't write that captured data back out.</p>
</blockquote>
<p>I hope you meant <code>read</code> rather than <code>readlines</code>, for the reason I stated at the beginning of this post.</p>
<p>Here's a sketch of working code, based on what you posted in a meanwhile deleted "answer":</p>
<pre><code>hackout = subprocess.Popen(['hackrf_transfer', …], stdout=subprocess.PIPE)
# We need to start the "sink subprocess" at the outset, and that with stdin=PIPE
baudline = subprocess.Popen("baudline … -stdin …", stdin=subprocess.PIPE, shell=True)

def decimator():
    for iq_samples in iter(lambda: bytearray(hackout.stdout.read(8*1024)), b''):
        # convert the samples chunk for use by numpy, if you wish
        dat = np.array(iq_samples)
        dat = dat.astype(float)/255
        # dat = … do further processing, as you wish    
        # now convert data back for use by baudline -format u8 and write out
        baudline.stdin.write((dat*255).astype('i1').tostring())

decimator()
</code></pre>
</div>
<span class="comment-copy">That threw an error as an unexpected token.</span>
<span class="comment-copy">@user6754791 - The expression <code>hackout.stdout.read(8*1024)</code> does not give that error. What did you write exactly?</span>
<span class="comment-copy">Unfortunately none of these ideas work. What I think the issue is that, the script opens a new subprocess it can't tell what pipe to use as it has no reference.For example if I created a linux statement in a shell and I pipe to a python script that has one statement in it to open a subprocess to baudline, it will trigger the python interpreter to open, it will run the subprocess statement, it will open baudline application but the pipes I suspect are in different shells and have no reference back to each other. Therefore baudline just sits waiting for data that never arrives.</span>
<span class="comment-copy">@user6754791 - What <i>ideas</i> are you talking of? I suggested only one approach.</span>
<span class="comment-copy">I feel I am very close I tried what you said above it still doesn't work. The output is different. Its not running errors or messages with this: data = hackout.stdout.readlines(8*1024) but I want to take this and feed it to stdout. I tried sys.stdin.write(data) its not writing but It's seeing 'data' as a list. So its captured the data but I can't write that captured data back out.</span>
