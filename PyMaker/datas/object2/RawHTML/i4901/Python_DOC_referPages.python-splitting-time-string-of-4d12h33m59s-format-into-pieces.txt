<div class="post-text" itemprop="text">
<p>I was wondering if anyone could help to come up with an elegant solution how to split a time string received from router's API of format <code>"4d12h33m59s"</code> into pieces.</p>
<p>The problem is that string could be dynamical size. For example, it can be <code>"4d12h33m59s"</code> or <code>"12h33m59s"</code> or <code>"12y14w4d12h33m59s"</code> or <code>"12m23s"</code>, <code>"33s"</code>.</p>
<p>Is there any elegant way to have split the string and get a list like:</p>
<pre><code>received_string = "12y14w4d12h33m59s"
time_list = convert_string(received_string)

print(time_list) 
["12y","14w","4d","12h","33m","59s"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/howto/regex.html#regex-howto" rel="nofollow noreferrer">regular expression</a>:</p>
<pre><code>import re

time_list = re.findall('\d+[a-z]', received_string)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.findall()</code> function</a> produces a list of all matches of a given pattern in the input string. Here the pattern looks for 1 or more digits, followed by one lower-case ASCII letter.</p>
<p>You could make it more picky about what letters are allowed by using <code>[ywdhms]</code>, but if your input is reasonably well-formed I'd not worry about that.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; received_string = "12y14w4d12h33m59s"
&gt;&gt;&gt; re.findall('\d+[a-z]', received_string)
['12y', '14w', '4d', '12h', '33m', '59s']
</code></pre>
<p>You may want to further split out the digits and letters, however, to make it easier to then transform the information into an easier to work with format like a <code>datetime.timedelta()</code> object, perhaps into a dictionary:</p>
<pre><code>{type_: int(count) for count, type_ in re.findall('(\d+)([a-z])', received_string)}
</code></pre>
<p>The added <code>(..)</code> groupings alter the <code>re.findall()</code> output to produce a tuple for each match, containing the separate group values (so <code>('12', 'y')</code>, <code>('14', 'w')</code>, etc.).</p>
<p>This produces</p>
<pre><code>{'y': 12, 'w': 14, 'd': 4, 'h': 12, 'm': 33, 's': 59}
</code></pre>
<p>for your input.</p>
</div>
<div class="post-text" itemprop="text">
<p>Martijn's answer is excellent as usual. I just thought I'd expand a touch on a way to use <a href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="nofollow noreferrer">timedelta</a> in this conversion:</p>
<pre><code>import datetime, re, operator, functools
times = {'s': datetime.timedelta(seconds=1),
         'm': datetime.timedelta(minutes=1),
         'h': datetime.timedelta(hours=1),
         'd': datetime.timedelta(days=1),
         'w': datetime.timedelta(weeks=1),
         'y': datetime.timedelta(days=365)}
fieldre = re.compile(r'(\d+)([{}])'.format(''.join(times.keys())))

samplevalue = "12y14w4d12h33m59s"

duration = functools.reduce(operator.add, 
     (times[unit]*int(value) for (value,unit) in 
      fieldre.findall(samplevalue)))

remains = fieldre.subn("", samplevalue)
if remains:
    raise ValueError("Unexpected time fields in {!r}: {!r}".format(
        samplevalue, remains))
</code></pre>
<p>Admittedly, that last is a bit of a mess. Note that the year unit is a rough approximation (365 days). I used <code>dict.keys</code> to extract those units and permit them in the regular expression, parenthesis in the regular expression to produce value and unit as a pair, and <code>functools.reduce(operator.add, iterable)</code> as a substitute for <code>sum</code> because the latter didn't work on <code>timedelta</code>. In the end we have a single timedelta we can read normalized times from with e.g. <code>duration.total_seconds()</code>.</p>
<p>Possibly more usefully I added a way to detect if we've left something out using <code>subn</code>. Wrong data could be more harmful than detecting invalid conversions. </p>
</div>
<span class="comment-copy">Waaaaaat? Man, I did not expect to get a perfect answer so quick! Thank you, you are my hero! Works perfectly!</span>
