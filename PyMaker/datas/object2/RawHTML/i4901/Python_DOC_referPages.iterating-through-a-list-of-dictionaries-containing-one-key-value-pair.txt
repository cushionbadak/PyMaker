<div class="post-text" itemprop="text">
<p>I want to iterate through a list of key value pairs as efficiently as possible. The aim is to iterate through the data set to find the key value pair containing the key corresponding to the code I'm trying to find, this is nested in another for loop which is iterating through a set of codes.
my logos object looks something like:</p>
<pre><code>data_set = [{'key1': 'value'}, {'key2': 'value2'}, {'key3': 'value3'}, ]
codes = ['key1', 'key2', 'key3']
</code></pre>
<p>where the keys correspond to codes and the value is the data I want to extract</p>
<pre><code>for code in codes:
    data = ''
    for idx, data_obj in enumerate(data_set):
        for (key, value) in data_obj.items():
            if key == code:
                data = value
                break
        if data != '':
            del data_set[idx]
            break
    do_something_with_data(data)
</code></pre>
<p>My method at the moment works fine and reasonably fast but I can't help but wonder if there isn't a cleaner/faster way of doing it</p>
</div>
<div class="post-text" itemprop="text">
<p>If you had <em>one</em> dict with all your keys this would be trivial and could be done with <a href="https://docs.python.org/3/library/stdtypes.html#dict.pop" rel="nofollow noreferrer">dict.pop(key[,default])</a>. </p>
<p>Having disjunct keys in several 1-key dicts in a list is a very bad choice of data structure - you should solidyfy them into one big dictionary to enable O(1) acces to the keys instead of manipulating your list into shape afterwards.</p>
<p>Solution for a dict with multiple keys that will be vanquished from it if they are in your code-list: </p>
<pre><code>data_set = {'key1': 'value', 'key2': 'value2', 'key3': 'value3'} # use a dict
codes = ['key1', 'key2', 'key3']

for code in codes:
    data = data_set.pop(code, None) # get value &amp; remove key, return None if not there
    if data:
        print(data) # do something with the data
print(data_set)
</code></pre>
<p>Output:</p>
<pre><code>value
value2
value3
{}
</code></pre>
<hr/>
<p>When getting the data from your 3rd party:</p>
<pre><code>ds = [{'key1': 'value'}, {'key2': 'value2'}, {'key3': 'value3'}, ] 
data_set = { key:value for x in ds for key,value in x.items() }
print(data_set)
</code></pre>
<p>Output:</p>
<pre><code>{'key1': 'value', 'key2': 'value2', 'key3': 'value3'} 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should speed things up a bit</p>
<pre><code>codes_set = set(codes)
values = [v for d in data_set for k, v in d if k in codes_set]
</code></pre>
<p><code>values</code> should be the list of values you're looking for. It's definitely faster than your version, since it uses O(1) set lookup</p>
</div>
<div class="post-text" itemprop="text">
<p>This solution uses a list comprehension for an overall <code>O(n^2)</code> solution:</p>
<pre><code>data_set = [{'key1': 'value'}, {'key2': 'value2'}, {'key3': 'value3'}, ]
codes = ['key1', 'key2', 'key3']
new_data_set = [i for i in data_set if any(code in i for code in codes)]
</code></pre>
<p>Output:</p>
<pre><code>[{'key1': 'value'}, {'key2': 'value2'}, {'key3': 'value3'}]
</code></pre>
</div>
<span class="comment-copy">Are there duplicate keys in the dictionaries in <code>data_set</code>?</span>
<span class="comment-copy">Not answering the question but it's not a very good idea to <code>del data_set[idx]</code> in the same loop iterating data_set. It's not wise to modify the collection you're iterating</span>
<span class="comment-copy">@roganjosh there cannot be duplicate keys in the data set. Also I delete from the data set as the keys are unique so I know it won't be used again in the loop which iterates hundreds of times.</span>
<span class="comment-copy">What is <code>logo</code> ?</span>
<span class="comment-copy">Why do you have a <code>list</code> of 1-key <code>dicts</code> that do not overlap ?! Put them all into <i>one</i> dict - thats what dicts are for, then you get O(1) access to the key and can <code>pop</code> it when needed</span>
<span class="comment-copy">@roganjosh Thanks - missed that completely. reformulated the answer but its only a "do not do what you do, do this instead"  kind of answer.</span>
<span class="comment-copy">Yeh I would like to have the data structured like this but they're coming from a third party api and I don't have control over the data structure</span>
<span class="comment-copy">You could transform your data_set into a dictionary, that should take O(n) (n = number of dictionaries) and then you could check for your keys so another O(m) (m = number of keys). In total O(n+m) which is way better than your approach O(n^2).</span>
<span class="comment-copy">@Jacob transfrom it when you get it. edited answer.</span>
