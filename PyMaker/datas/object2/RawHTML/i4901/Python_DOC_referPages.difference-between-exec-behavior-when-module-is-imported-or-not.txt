<div class="post-text" itemprop="text">
<p>I am running to of the following programs. Importantly, imagine that there is <code>mymodule.py</code> file in the directory where both these programs are located.</p>
<p><em>The first</em>:</p>
<pre><code>exec('''import sys
import os
os.chdir('/') 
sys.path = []
import mymodule''', {})
</code></pre>
<p><em>The second</em>:</p>
<pre><code>import mymodule
exec('''import sys
import os
os.chdir('/') 
sys.path = []
import mymodule''', {})
</code></pre>
<p>The first snippet raises <code>ImportError</code> as expected (after all, the directory where mymodule is located is not in path). The second snippet, however, does not, even though mymodule is also not in its path and the environment I am giving it is empty.</p>
<p>My question is why</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="noreferrer">The import system - The module cache</a>,</p>
<blockquote>
<p><strong>The first place checked during import search is <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="noreferrer"><code>sys.modules</code></a>. This
  mapping serves as a cache of all modules that have been previously
  imported, including the intermediate paths. So if foo.bar.baz was
  previously imported</strong>, sys.modules will contain entries for foo,
  foo.bar, and foo.bar.baz. Each key will have as its value the
  corresponding module object.</p>
<p><strong>During import, the module name is looked up in <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="noreferrer"><code>sys.modules</code></a> and if
  present, the associated value is the module satisfying the import, and
  the process completes.</strong> However, if the value is None, then a
  ModuleNotFoundError is raised. If the module name is missing, Python
  will continue searching for the module.</p>
</blockquote>
<p>The second snippets successfully imports <code>mymodule</code>; it's cached in <code>sys.modules</code>, so no search in other places occurs.</p>
</div>
<div class="post-text" itemprop="text">
<p>This has nothing to do with <code>exec()</code>, and is a simple misunderstanding about what is available on your <code>sys.path</code> when running a script, and when Python looks for files to load.</p>
<p>You state:</p>
<blockquote>
<p>I am running to of the following programs. Importantly, imagine that there is <code>mymodule.py</code> file in the directory where both these programs are located.</p>
<p>[...]</p>
<p>The second snippet, however, does not, even though mymodule is also not in its path</p>
</blockquote>
<p>The module <em>is</em> on its path. The directory your script is located in, is added at the start of the module search path. See <a href="https://docs.python.org/3/using/cmdline.html#command-line" rel="nofollow noreferrer"><em>Command line</em></a>:</p>
<blockquote>
<p><strong><code>&lt;script&gt;</code></strong></p>
<p>Execute the Python code contained in script, which must be a filesystem path (absolute or relative) referring to either a Python file, a directory containing a <code>__main__.py</code> file, or a zipfile containing a <code>__main__.py</code> file.</p>
<p>[...]</p>
<p>If the script name refers directly to a Python file, <strong>the directory containing that file is added to the start of <code>sys.path</code></strong>, and the file is executed as the <code>__main__</code> module.</p>
</blockquote>
<p>Bold emphasis mine.</p>
<p>So, <code>mymodule.py</code>, which you state is located in the same directory as the scripts you are running, is on the path.</p>
<p>Once loaded, modules <em>stay</em> loaded. <code>import &lt;module&gt;</code> will only look at the module search path if there is not already a module in <code>sys.modules</code> by that name. It doesn't matter if you use <code>exec</code> or not to do the import.</p>
<p>From the <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow noreferrer"><code>import</code> statement documentation</a>:</p>
<blockquote>
<p>The basic <code>import</code> statement (no from clause) is executed in two steps:</p>
<ol>
<li>find a module, <strong>loading and initializing it if necessary</strong></li>
<li>define a name or names in the local namespace for the scope where the <code>import</code> statement occurs.</li>
</ol>
</blockquote>
<p>The <em>if necessary</em> part is the important bit.</p>
<p>Further, from <a href="https://docs.python.org/3/reference/import.html#importsystem" rel="nofollow noreferrer"><em>The import system</em></a>:</p>
<blockquote>
<p>The <code>import</code> statement combines two operations; it searches for the named module, then it binds the results of that search to a name in the local scope.</p>
<p>[...]</p>
<p>When a module is first imported, Python searches for the module and if found, it creates a module object, initializing it.</p>
</blockquote>
<p>and from <a href="https://docs.python.org/3/reference/import.html#the-module-cache" rel="nofollow noreferrer"><em>The module cache</em></a>:</p>
<blockquote>
<p>The first place checked during import search is <code>sys.modules</code>. This mapping serves as a cache of all modules that have been previously imported, including the intermediate paths. So if <code>foo.bar.baz</code> was previously imported, <code>sys.modules</code> will contain entries for <code>foo</code>, <code>foo.bar</code>, and <code>foo.bar.baz</code>. Each key will have as its value the corresponding module object.</p>
<p>During import, the module name is looked up in <code>sys.modules</code> <strong>and if present, the associated value is the module satisfying the import, and the process completes</strong>.</p>
</blockquote>
<p>So by the time your <code>exec()</code> code runs, the first <code>import mymodule</code> had already succeeded and <code>sys.modules[</code>mymodule<code>] exists. The second</code>import mymodule` finds that object, and the search ends.</p>
</div>
<span class="comment-copy">This function supports dynamic execution of Python code. object must be either a string or a code object. If it is a string, the string is parsed as a suite of Python statements which is then executed (unless a syntax error occurs). If it is a code object, it is simply executed. In all cases, the code that’s executed is expected to be valid as file input (see the section “File input” in the Reference Manual). Be aware that the return and yield statements may not be used outside of function definitions even within the context of code passed to the exec() function. The return value is <code>None</code>.</span>
<span class="comment-copy"><i>"The module is on its path. The directory your script is located in, is added at the start of the module search path."</i> That is not correct in this case - yes, that directory is added to the module search path, but the code later explicitly sets <code>sys.path = []</code>. So the OP's statement that <code>mymodule</code> isn't in the module search path (at the time of the import) is indeed correct.</span>
<span class="comment-copy">@Aran-Fey: <code>sys.path</code> is reset <b>after the first import</b>. The second snippets <b>starts</b> with <code>import mymodule</code>. That first import is what counts.</span>
<span class="comment-copy">@Aran-Fey: The OP is not 100% clear on this, but the sentence <i>The second snippet, however, does not, even though mymodule is also not in its path</i> seems to imply that they think that <code>mymodule</code> is <i>never</i> on the module search path, even when that first <code>import mymodule</code> statement is being executed. I'm addressing both interpretations of the question here, that they think the current directory is never on the path, and that they think that <code>sys.path = []</code> matters when the second <code>import mymodule</code> is being executed.</span>
