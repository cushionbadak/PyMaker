<div class="post-text" itemprop="text">
<p>I want to combine two lists in to one dictionary type.</p>
<pre><code>Name = ['John','Mary','Serena','Felicia']
Data = ['26','179','25','164','29','149','29','167']
</code></pre>
<p>desirable output in Json format</p>
<pre><code>{"people":[{'Name': 'John',
     'Age': '26',
     'Height': '179'},
{'Name': 'Mary',
     'Age': '25',
     'Height': '164'}
{'Name': 'Serena',
     'Age': '29',
     'Height': '149'}
{'Name': 'Felicia',
     'Age': '29',
     'Height': '167'} ]
}    
</code></pre>
<p>I try to combine with <code>list1 = {k: 'Name' for k in Name}</code> but the dictionary
shown 'John' = 'Name' which is reverse of what I need.</p>
</div>
<div class="post-text" itemprop="text">
<p>a couple of nested zips &amp; slices do the trick to build dicts in a list comprehension, as value of the outer dict:</p>
<pre><code>Name = ['John','Mary','Serena','Felicia']
Data = ['26','179','25','164','29','149','29','167']

result = {'people':[{'Name' : name, 'Age' : age, 'Height' : height} 
          for name,(age,height) in zip(Name,zip(Data[::2],Data[1::2]))]}


print(result)
</code></pre>
<p>prints:</p>
<pre><code>{'people': [{'Name': 'John', 'Height': '179', 'Age': '26'}, {'Name': 'Mary', 'Height': '164', 'Age': '25'}, {'Name': 'Serena', 'Height': '149', 'Age': '29'}, {'Name': 'Felicia', 'Height': '167', 'Age': '29'}]}
</code></pre>
<p>if you don't want to create "hard" slices, use <code>itertools.islice</code>, also would be interesting to convert integer values as integer, which avoids the easy trap of lexicographical compare of integers as strings later on:</p>
<pre><code>from itertools import islice
result = {'people':[{'Name' : name, 'Age' : int(age), 'Height' : int(height)}
          for name,age,height in zip(Name,islice(Data,None,None,2),islice(Data,1,None,2))]}
</code></pre>
<p>(and also thanks to comments, no need to nest <code>zip</code> statements)</p>
<p>result:</p>
<pre><code>{'people': [{'Height': 179, 'Age': 26, 'Name': 'John'}, 
            {'Height': 164, 'Age': 25, 'Name': 'Mary'}, 
            {'Height': 149, 'Age': 29, 'Name': 'Serena'}, 
            {'Height': 167, 'Age': 29, 'Name': 'Felicia'}]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>:</p>
<pre><code>Name = ['John','Mary','Serena','Felicia']
Data = ['26','179','25','164','29','149','29','167']

dct = {"people": [{'Name': i, 'Age': j, 'Height': k} for i, j, k in zip(Name, Data[::2], Data[1::2])]}
print(dct)
</code></pre>
<p>Output:</p>
<pre><code>{'people': [{'Name': 'John', 'Age': '26', 'Height': '179'}, {'Name': 'Mary', 'Age': '25', 'Height': '164'}, {'Name': 'Serena', 'Age': '29', 'Height': '149'}, {'Name': 'Felicia', 'Age': '29', 'Height': '167'}]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an interesting approach.</p>
<pre><code>&gt;&gt;&gt; Name = ['John','Mary','Serena','Felicia']
&gt;&gt;&gt; Data = ['26','179','25','164','29','149','29','167']
&gt;&gt;&gt; keys = ['Name', 'Age', 'Height']
&gt;&gt;&gt; it = iter(Data)
&gt;&gt;&gt; {'people':[dict(zip(keys,i)) for i in zip(Name, it, it)]}
</code></pre>
<p>Can't make it too much more compact than this.</p>
<p><strong>Ouput</strong></p>
<pre><code>{'people': [{'Name': 'John', 'Age': '26', 'Height': '179'}, {'Name': 'Mary', 'Age': '25', 'Height': '164'}, {'Name': 'Serena', 'Age': '29', 'Height': '149'}, {'Name': 'Felicia', 'Age': '29', 'Height': '167'}]}
</code></pre>
</div>
<span class="comment-copy">Seems to work in python 3 with just one zip like  for name,age,height in zip(Name,Data[::2],Data[1::2])]}</span>
<span class="comment-copy">yes, it's even simpler</span>
<span class="comment-copy">Thanks, could you elaborate why <code>zip(Data[::2],Data[1::2]</code>? <code>Data[::2]</code> will take <code>26,179</code> and <code>Data[1::2]</code> is <code>179</code>. The data is repeated but the output data is correct.</span>
<span class="comment-copy">never mind. Just understand the double colon meaning</span>
