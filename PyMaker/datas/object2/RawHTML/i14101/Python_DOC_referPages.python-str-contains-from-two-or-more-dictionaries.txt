<div class="post-text" itemprop="text">
<p>I want to check if a string contains one or more values from two dictionaries.</p>
<pre><code>company = {"AXP": "American Express", "BIDU": "Baidu"}
stock_index = {"GOOG": "Google"}

for c, i in zip(company, stock_index):
    df.loc[df.name.str.contains(c, i), "instrumentclass"] = "Equity"
</code></pre>
<p>For some reason, it only writes <code>"Equity"</code> for the first match in the dictionaries, i.e. <code>"AXP":"American Express"</code>. For <code>"Baidu"</code>and <code>"Google"</code>, nothing happens.</p>
<p>I know that I can combine the dictionaries to one as seen below, but I would prefer not to.</p>
<pre><code>benchmarks = company.copy()
benchmarks.update(stock_index)
</code></pre>
<hr/>
<p>The data is written and retrieved with help of a <code>pandas DataFrame</code>.</p>
<pre><code>import pandas as pd
df = pd.DataFrame(["LONG AXP", "SHORT AXP", "LONG BIDU", "LONG GOOG"], columns=["name"])
</code></pre>
<p>The code copies the column <code>name</code> to column <code>instrumentclass</code> and by doing this is supposed to substitute each cell to <code>"Equity"</code> if it contains <code>"AXP"</code>, <code>"BIDU"</code> or <code>"GOOG"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you start by breaking down this data, like this:</p>
<pre><code>df = pd.DataFrame(["LONG AXP", "SHORT AXP", "LONG BIDU", "LONG GOOG"],
                  columns=["name"])

# split on spaces and get the last part
df["company_name"] = df.name.str.split().str.get(-1)

&gt;&gt;&gt; print df
        name company_name
0   LONG AXP          AXP
1  SHORT AXP          AXP
2  LONG BIDU         BIDU
3  LONG GOOG         GOOG
</code></pre>
<p>Now, it's much easier to work with these strings. Given this is a sample of your dictionaries:</p>
<pre><code>company = {"AXP": "American Express", "BIDU": "Baidu"}
stock_index = {"GOOG": "Google"}
</code></pre>
<p>You can exploit "dictonary views" which behave like sets in Python:</p>
<pre><code># this is Python 2, if you use Python 3, .keys() method returns a view
all_companies = company.viewkeys() | stock_index.viewkeys()

&gt;&gt;&gt; print all_companies
{'AXP', 'BIDU', 'GOOG'}
</code></pre>
<p>So now, we have a set-like object we can use to filter on the data and set "Equity":</p>
<pre><code>df.loc[df.company_name.isin(all_companies), "instrumentclass"] = "Equity"
</code></pre>
<p>If you are concerned about not joining these dictionaries like that, you might want to consider using something like a ChainMap: <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow">https://docs.python.org/3/library/collections.html#collections.ChainMap</a>
 That's Python 3 standard library, but backports to Python 2 should exist.</p>
</div>
<span class="comment-copy">What's <code>df</code>? Please write a minimum working example.</span>
<span class="comment-copy">df is a Pandas DataFrame. I'll update the question shortly with a working example.</span>
<span class="comment-copy">From the documentation for <code>zip():</code> <i>The returned list is truncated in length to the length of the shortest argument sequence</i></span>
<span class="comment-copy">@boardrider Ah, so that's why it doesn't work. Is there a solution to make it  check through two dictionaries without combining them?</span>
<span class="comment-copy">Loop over all your dictionaries, and check for value existence.</span>
<span class="comment-copy">Thanks, just a follow up: If I have more than two words in <code>name</code>, how can I split it and use the last two words together? For <code>LONG AXP VOX</code>, something like <code>str.get(-2:)</code>?</span>
