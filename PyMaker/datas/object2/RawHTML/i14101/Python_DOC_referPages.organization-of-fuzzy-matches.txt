<div class="post-text" itemprop="text">
<p>I've gone through and fuzzy matched each element in a list of 20,000+ movie titles with each other element, which returns a value for each pair: </p>
<pre><code>from fuzzywuzzy import fuzz

titles = ['Scary Movie', 'Happy Movie', 'Sappy Movie', 'Crappy Movie']

print fuzz.ratio(titles[2],titles[3])
&gt;&gt;&gt; 91 #/100 higher value denotes closer match 

for x in titles:
    for y in titles:
        fuzzed = fuzz.ratio(x,y)

    print "value for %r and %r is %r" % (x, y, fuzzed)
</code></pre>
<p>How can I organize this data efficiently? More specifically- how can I get matches to group together based on their match value? </p>
<p>Capturing the return values from the nested loops and then packaging them with x and y into tuples or lists is obviously redundant and messy. I attempted an implementation using classes but I'm missing something.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehensions and <code>itertools.product</code>:</p>
<pre><code>from itertools import product
[(x, y, fuzz.ratio(x, y)) for (x, y) in product(titles, repeat=2)]
</code></pre>
<p>Nice and lazy solution using <a href="https://github.com/pytoolz/toolz" rel="nofollow"><code>toolz</code></a></p>
<pre><code>from toolz.curried import pipe, filter, map
pipe(
    product(titles, repeat=2),
    # No reason to check duplicates
    filter(lambda (x, y): x &gt; y),
    map(lambda (x, y): (x, y, fuzz.ratio(x, y))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You only need to iterate over <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>combinations</code></a> of the titles since the ratio doesn't depend on the order. This is significantly faster than iterating over a <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>product</code></a> of it.</p>
<p>For your list of 20,000 titles, you would iterate over <strong>400 000 000</strong> pairs if you used <code>product</code>. With <code>combinations</code>, you are only iterating over <strong>199 990 000</strong>.</p>
<pre><code>from fuzzywuzzy import fuzz

import collections
import itertools

titles = ['Scary Movie', 'Happy Movie', 'Sappy Movie', 'Crappy Movie']
</code></pre>
<p>Then you can store the ratios in a dictionary where you can look up a ratio to get a <code>set</code> of pairs with that ratio.</p>
<pre><code>fuzzes_by_ratio = collections.defaultdict(set)
</code></pre>
<p>Or in a dictionary where you can look up a <code>frozenset</code> of pairs and get their ratio.</p>
<pre><code>fuzzes_per_pair = {}
</code></pre>
<p>-</p>
<pre><code>for m1, m2 in itertools.combinations(titles, 2):
    pair = frozenset({m1, m2})
    ratio = fuzz.ratio(m1, m2)

    fuzzes_by_ratio[ratio].add(pair)
    fuzzes_per_pair[pair] = ratio
</code></pre>
<p>Then you can retrieve the data later:</p>
<pre><code># I don't have fuzzywuzzy installed so this is just made up:
&gt;&gt;&gt; fuzzes_by_ratio[91]
{frozenset({"Scary Movie", "Happy Movie"}), frozenset({"Sappy Movie", "Happy Movie"})}

&gt;&gt;&gt; fuzz_per_pair[frozenset({"Scary Movie", "Sappy Movie"})]
82
</code></pre>
<p>Keep in mind that you will need tons of memory for this storage. You can halve it by using only one of the two methods above, depending on your needs / convenience.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you can store the <code>fuzzed</code> ratio in a dictionary with the <code>(x,y)</code> tuple as the key, would make it easier to search the <code>ratio</code> for each pair later on. For that you can create an empty dictionary outside the for loop , and then in for loop assign the <code>fuzz.ratio(x , y)</code> to the key <code>(x, y)</code> for that dictionary.</p>
<p>Example code -</p>
<pre><code>fuzzDict = {}
for x in titles:
    for y in titles:
        fuzzDict[(x,y)] = fuzz.ratio(x,y)
</code></pre>
<p>Later when you want to retrieve the ratio, you can simple call <code>fuzzDict[(x , y)]</code> to get it.</p>
<hr/>
<p>You can also use dictionary comprehension for that in Python 2.7+ -</p>
<pre><code>{(x, y) : fuzz.ratio(x,y) for x in titles for y in titles}
</code></pre>
</div>
<span class="comment-copy">Does <code>fuzz.ratio(x, y)</code> == <code>fuzz.ratio(y, x)</code> for all x and y?</span>
<span class="comment-copy">@Navith yes, actually 'ratio' is somewhat of a misnomer, I think it is better described as a match percentage since the return values are 0-100</span>
<span class="comment-copy">Accepted answer, thanks- I did amend my question to include this: ...how can I get matches to group together based on their match value and title? (need to account for different matches between titles having the same number value)</span>
<span class="comment-copy">Do you mean grouping like this: <code>('Crappy Movie', 87) =&gt; ('Happy Movie', 'Sappy Movie')</code>?</span>
