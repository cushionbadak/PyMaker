<div class="post-text" itemprop="text">
<p>Is python's <code>hash</code> function portable?</p>
<p>By "portable" I mean, will it return the same results (for the same data) across python versions, platforms and implementations?</p>
<p>If not, is there any alternative to it that provides such features (while still capable of hashing common data-structures)?</p>
<hr/>
<p><a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow noreferrer">The documentation</a> is not particularly helpful. 
<a href="https://stackoverflow.com/questions/27758375/python-portable-hash">This question</a> refers a library that seems to roll its own version, but I'm not sure non-portability would be the reason for it.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, <code>hash()</code> is not guaranteed to be portable.</p>
<p>Python 3.3 also uses <em>hash randomisation</em> by default, where certain types are hashed with a hash seed picked at start-up. Hash values then differ between Python interpreter invocations.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>object.__hash__()</code> documenation</a>:</p>
<blockquote>
<p>By default, the <code>__hash__()</code> values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.</p>
<p>This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n^2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="nofollow">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>Changing hash values affects the iteration order of dicts, sets and other mappings. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).</p>
<p>See also <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED" rel="nofollow">PYTHONHASHSEED</a>.</p>
</blockquote>
<p>Python 2.6.8 and 3.2.3 and newer support the same feature but have it normally disabled.</p>
<p>Python 3.2 introduced a <a href="https://docs.python.org/3/library/sys.html#sys.hash_info" rel="nofollow"><code>sys.hash_info</code> named tuple</a> that gives you details about the hash implementation for the current interpreter.</p>
<p>If you need a portable hash, there are plenty of implementations. The standard library includes a cryptographic hash library called <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow"><code>hashlib</code></a>; these implementations are definitely portable. Another option would be the <a href="https://github.com/hajimes/mmh3" rel="nofollow"><code>mm3</code> package</a> which provides <a href="https://en.wikipedia.org/wiki/MurmurHash" rel="nofollow">Murmur3 non-cryptographic hash function implementations</a>.</p>
<p>Common data structures would need to be converted to bytes first; you could use serialisation for that, like the <a href="https://docs.python.org/3/library/json.html" rel="nofollow"><code>json</code></a> or <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow"><code>pickle</code></a> modules.</p>
</div>
<span class="comment-copy"><code>hash</code> is just for use with the <code>dict</code> type, which is implemented as a hash table. You probably want a function from the <code>hashlib</code> module in the standard library.</span>
<span class="comment-copy">@chepner I'm looking for something that hashes arbitrary data structures like <code>hash</code>, I don't think <code>hashlib</code> does that?</span>
<span class="comment-copy"><code>hash</code> can't hash arbitrary data structures, either. (Try passing a <code>dict</code> or a <code>set</code> to <code>hash</code>.)</span>
<span class="comment-copy">@chepner Yes, I'm aware only simple and immutable structures are supported. That would be sufficient for my needs (though maybe not everyone else's)</span>
<span class="comment-copy">That's an excellent response to the main question. As to an alternative, I've <a href="http://stackoverflow.com/questions/5417949/computing-an-md5-hash-of-a-data-structure">dug a bit more</a>, and it looks like serializing to json is a reasonable alternative. If you don't mind me editing your answer, I could include that information</span>
<span class="comment-copy">@goncalopp: serialising to JSON won't give you a compact hash; you'd still have to run that through some kind of hashing algorithm. I've added a pointer to <code>hashlib</code>.</span>
<span class="comment-copy">Yes, you can then run it through hashlib, as in <a href="http://stackoverflow.com/a/10288255/1595865">this answer</a>. Note I've edited the question to clarify I'm looking for something that hashes data-structures as <code>hash</code> does, not just strings</span>
<span class="comment-copy">@goncalopp: then convert those data structures to bytes; JSON can do that, but so can the <code>pickle</code> module.</span>
<span class="comment-copy"><code>pickle</code> generates different output on different python versions, so it wouldn't be a "portable hash". The JSON serialization is <a href="https://docs.python.org/2/library/json.html#basic-usage" rel="nofollow noreferrer">easy enough to control</a> in order to get something <a href="http://wiki.laptop.org/go/Canonical_JSON" rel="nofollow noreferrer">reasonably canonical</a></span>
