<div class="post-text" itemprop="text">
<p>I am looking for a method analogous to <code>if "x" in variable:</code> that is case insensitive and light-weight to implement.</p>
<p>I have tried some of the implementations here but they don't really fit well for my usage: <a href="https://stackoverflow.com/questions/3627784/case-insensitive-in-python">Case insensitive 'in' - Python</a></p>
<p>What I would like to make the below code case insensitive:</p>
<pre><code>description = "SHORTEST"

if "Short" in description:
    direction = "Short"
</code></pre>
<p>Preferably without having to convert the string to e.g. lowercase. Or if I have to convert it, I would like to keep <code>description</code> in its original state â€“ even if it is mixed uppercase and lowercase.</p>
<p>For my usage, it is good that this method is non-discriminating by identifying <code>"Short"</code> in <code>"Shorter"</code> or <code>"Shortest"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just do </p>
<pre><code>if "Short".lower() in description.lower():
    ...
</code></pre>
<p>The <code>.lower()</code> method does not change the object, it returns a new one, which is changed. If you are worried about performance, don't be, unless your are doing it on huge strings, or thousands of times per second.</p>
<p>If you are going to do that more than once, or just want more clarity, create a function, like this:</p>
<pre><code>def case_insensitive_in(phrase, string):
    return phrase.lower() in string.lower()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative way without calling <code>.lower()</code> on both strings would be to use a case-insensitive regular expression match:</p>
<pre><code>if re.search(re.escape("Short"), "SHORTEST", re.IGNORECASE):
    ...
</code></pre>
<p>On long strings, it might be a little quicker:</p>
<pre><code>$ python -m timeit -s 'needle = "Short"; haystack = ("abc"*1000000) + "shortest" + ("abc"*1000000)'\
 'needle.lower() in haystack.lower()'
10 loops, best of 3: 88.9 msec per loop

$ python -m timeit -s 'needle = "Short"; haystack = ("abc"*1000000) + "shortest" + ("abc"*1000000); import re; pat = re.compile(re.escape("Short"), re.IGNORECASE)'\
 'pat.search(haystack)'
10 loops, best of 3: 61.1 msec per loop
</code></pre>
<p>However for a vast majority of cases, <code>"Short".lower() in description.lower()</code> will be more than fast enough, and is the clearest way to write it</p>
</div>
<span class="comment-copy"><code>"Short".lower()</code> produces <code>"short"</code></span>
<span class="comment-copy"><code>if x.lower() in "description":</code> (where <code>x</code> is <code>"Short"</code>). It does change it to lowercase, but not "permanently." <code>x</code> will still be <code>"Short"</code> afterwards.</span>
<span class="comment-copy">note: lowercasing produces a <i>new</i> string.</span>
<span class="comment-copy">@Finwood I'm aware of that, but I would prefer to keep the code to as few alterations as possible. I could of course create a new variable and make that lowercase, but since I'm doing this as many places in the code, it would be easier with a function or maybe a wrapper.</span>
<span class="comment-copy">so? create a wrapper.</span>
<span class="comment-copy">@Winterflags: As maniexx mentions, this function has to create &amp; destroy 2 new strings every time you call it. So if you <i>are</i> comparing the same <code>phrase</code> &amp;/or <code>string</code> <b><i>many</i></b> times it may be much quicker to explicitly create &amp; test lower-cased versions of <code>phrase</code> &amp; <code>string</code>, even though it makes the code a little more cluttered. OTOH, premature optimization is the root of all evil...</span>
<span class="comment-copy">@Winterflags: if you are doing lots of tests on the same strings it's probably worthwhile to do some <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a> tests on actual sample data to decide if maniexx's function is adequate speed-wise or whether you should make explicit lower-cased copies of your strings.</span>
<span class="comment-copy">Thanks for the suggestion!</span>
