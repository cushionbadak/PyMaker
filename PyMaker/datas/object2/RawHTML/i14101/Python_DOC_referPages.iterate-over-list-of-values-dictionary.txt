<div class="post-text" itemprop="text">
<p>I have a dict like this</p>
<pre><code>data = {
    'a': [95, 93, 90],
    'b': [643, 611, 610]
}
</code></pre>
<p>I want to iterate over the dict and fetch key and value from list of values for each item, something like this</p>
<pre><code>{'a': 95, 'b': 643}
{'a': 93, 'b': 611}
{'a': 90, 'b': 610}
</code></pre>
<p>I have implemented the logic for this and it works fine, but when i see the <code>temp_dict</code> created in process, i see lots of intermediate unnecessary looping. The end result works just fine but i think it can be improved a lot.</p>
<pre><code>import timeit

data = {
    'a': [95, 93, 90],
    'b': [643, 611, 610]
}


def calculate(**kwargs):
    temp_dict = {}
    index = 0
    len_values = list(kwargs.values())[0]

    while index &lt; len(len_values):
        for k, v in kwargs.items():
            temp_dict[k] = v[index]
        index += 1
        yield temp_dict


start_time = timeit.default_timer()
for k in (calculate(**data)):
    print(k)
print(timeit.default_timer() - start_time)
</code></pre>
<p>How to do it more efficiently?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try something like this -</p>
<pre><code>&gt;&gt;&gt; data = {
...     'a': [95, 93, 90],
...     'b': [643, 611, 610]
... }
&gt;&gt;&gt; lst = list(data.items())
&gt;&gt;&gt; lst1 = list(zip(*[i[1] for i in lst]))
&gt;&gt;&gt; lst1
[(95, 643), (93, 611), (90, 610)]
&gt;&gt;&gt; newlist = []
&gt;&gt;&gt; for aval, bval in lst1:
...     newlist.append({lst[0][0]:aval , lst[1][0]:bval})
...
&gt;&gt;&gt; newlist
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
<p>When passing a list using * as a parameter to a function, it will break the list into individual elements and pass it onto the function. Example - if we pass <code>[[1,2],[3,4]]</code> it would be passed as two different arguments - <code>[1,2]</code> and <code>[3,4]</code> - checkt this <a href="http://www.python-course.eu/passing_arguments.php">here</a> (Section - * in Function calls)</p>
<p>Example to explain this -</p>
<pre><code>&gt;&gt;&gt; lst = [[1,2,3],[4,5,6],[7,8,9]]
&gt;&gt;&gt; def func(a, b, c):
...     print(a)
...     print(b)
...     print(c)
...
&gt;&gt;&gt; func(*lst)
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
</code></pre>
<p>zip - This function returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.</p>
<hr/>
<p>A bit more scale-able model -</p>
<pre><code>&gt;&gt;&gt; lst = list(data.items())
&gt;&gt;&gt; lst
[('a', [95, 93, 90]), ('b', [643, 611, 610])]
&gt;&gt;&gt; lst1 = list(zip(*[i[1] for i in lst]))
&gt;&gt;&gt; lst1
[(95, 643), (93, 611), (90, 610)]
&gt;&gt;&gt; newlist = []
&gt;&gt;&gt; for x in lst1:
...     d = {}
...     for i,y in enumerate(lst):
...             d[y[0]] = x[i]
...     newlist.append(d)
...
&gt;&gt;&gt; newlist
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A fun way to do it with a list comprehension.</p>
<pre><code>&gt;&gt;&gt; data = {
'a': [95, 93, 90],
'b': [643, 611, 610]
}
&gt;&gt;&gt; [dict(zip(data, x)) for x in zip(*data.values())] 
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
<p>Or a more traditional (less fun) way</p>
<pre><code>&gt;&gt;&gt; result = []
&gt;&gt;&gt; for tuple_ in zip(*data.values()):
...     d = {}
...     for key, val in zip(data, tuple_):
...         d[key] = val
...     result.append(d)
&gt;&gt;&gt; print result
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
<p>And per comments, here is a way to do it without relying on 'non-guaranteed' behavior like the same ordering of data.keys() and data.values().</p>
<p>List Comprehension</p>
<pre><code>&gt;&gt;&gt; keys, values = zip(*data.items())
&gt;&gt;&gt; [dict(zip(keys, tuple_)) for tuple_ in zip(*values)]
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
<p>And traditional for-loop</p>
<pre><code>&gt;&gt;&gt; result = []
&gt;&gt;&gt; keys, values = zip(*data.items())
&gt;&gt;&gt; for tuple_ in zip(*values):
...     d = {}
...     for key, val in zip(keys, tuple_):
...         d[key] = val
...     result.append(d)
&gt;&gt;&gt; print result
[{'a': 95, 'b': 643}, {'a': 93, 'b': 611}, {'a': 90, 'b': 610}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the number and actual literals used as keys are not known at coding time, here's an idea: </p>
<p>you can yield a series of dict-like objects. Each instance would expose the the i-th value from the value list. You can read about <a href="https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types" rel="nofollow">emulating python container types</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something similar to this (but replace the print with a yield):</p>
<pre><code>keys = []
values = []
for k, v in data.iteritems():
    keys.append(k)
    values.append(v)
for vals in zip(*values):
    print dict(zip(keys, vals))
</code></pre>
<p>The <code>zip(*values)</code> in the second for-loop more or less <a href="https://stackoverflow.com/q/19339/2647279">transposes</a> the list of lists in <code>values</code>. Slightly more compact way of writing the same:</p>
<pre><code>keys = list(data)
for vals in zip(*data.values()):
    print dict(zip(keys, vals))
</code></pre>
<p>In both cases, the result is:</p>
<pre><code>{'a': 95, 'b': 643}
{'a': 93, 'b': 611}
{'a': 90, 'b': 610}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one way to do it:</p>
<pre><code>data = {
    'a': [95, 93, 90],
    'b': [643, 611, 610]
}

x = data.values()
d1 = {'a':x[0][0], 'b':x[1][0]}
d2 = {'a':x[0][1], 'b':x[1][1]}
d3 = {'a':x[0][2], 'b':x[1][2]}
</code></pre>
<p>Output:</p>
<pre><code>{'a': 95, 'b': 643}
{'a': 93, 'b': 611}
{'a': 90, 'b': 610}
</code></pre>
</div>
<span class="comment-copy">Since you have a working code, I think you should post it in the code review section.</span>
<span class="comment-copy">Hey do you have a link to article explaining sifnficance of <code>*</code> in <code>list(zip(*data.values()))</code></span>
<span class="comment-copy">Thanks a lot man :)</span>
<span class="comment-copy">What if dict is not known at coding time?</span>
<span class="comment-copy">I will udpate the answer with a little bit for scalable model</span>
<span class="comment-copy">Updated the answer.</span>
<span class="comment-copy">Your answer is beautiful. It can be further extended to use generator expressions, something like <code>yield from (dict(zip(kwargs, x)) for x in zip(*kwargs.values()))</code></span>
<span class="comment-copy">yeah, hard to find a balance of what is fun to write and what is acceptable to read.</span>
<span class="comment-copy">Dictionary has no sense of order, are you sure your solution would work all the time?</span>
<span class="comment-copy">I mean even if you access <code>data</code> dictionary in the same line multiple times, they can give result in different order (theoratically speaking)</span>
<span class="comment-copy">@AnandSKumar we are accessing elements of a list in a dictionary .So basically we are obtaining lists element lists are order in nature so I think it is correct .Correct me if I am wrong</span>
<span class="comment-copy">The dict is not known at coding time.</span>
<span class="comment-copy">@ajkumar25 what do you mean not known?</span>
<span class="comment-copy">The keys of dict will be varying. The dict is not constant,</span>
<span class="comment-copy">@ajkumar25 This code works if you want to get this output from this dict</span>
<span class="comment-copy">@JoeR nice solution. I think he means there might be more keys (eg. 'c' in addition to 'a' and 'b') so the code cannot reference the key value directly or it won't work for all the possible inputs.</span>
