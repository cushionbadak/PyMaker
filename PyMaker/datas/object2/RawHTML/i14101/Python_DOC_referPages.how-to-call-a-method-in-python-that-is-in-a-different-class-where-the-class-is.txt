<div class="post-text" itemprop="text">
<p>I have a file named <code>main.py</code> which contains a class called <code>mainWindow</code>. I have a second file named <code>popupWindow.py</code>, which contains a class named <code>popupWindow</code>. <code>mainWindow</code> class contains 2 methods. One called <code>clearListBox</code> which clears the list box in the main window, and one called <code>addScouts(I)</code> which is a recursive function for writing the scouts stored in a file to the list box. I would like to be able to call the <code>clearListBox</code> and <code>addScouts(I)</code> from my class <code>popupWindow</code>. How do i achieve this?</p>
<p>upon trying <code>from main import mainWindow</code> then calling <code>mainWindow.addScouts(1)</code> i received the error that <code>addScouts</code> requires arg <code>self</code></p>
<p>In my <code>main.py</code> file:</p>
<pre><code>class mainWindow:
    def __init__(self,master):
        self.master = master
        self._scouts = []
        addBtn = Button(master,text="Create Scout",command=self._createScout)
        addBtn.pack()
        remBtn = Button(master,text="Remove Scout",command=self._removeScout)
        remBtn.pack()
        fndBtn = Button(master,text="Find Scout",command=self._findScout)
        fndBtn.pack()
        exitBtn = Button(master,text="Exit",command=self._exit)
        exitBtn.pack()
        scoutList = Listbox(master)
        scoutList.pack()
        self.scoutList = scoutList
        self.addScouts(1)
        w = 1000 #The value of the width
        h = 750 #The value of the height of the window

        # get screen width and height
        ws = root.winfo_screenwidth()#This value is the width of the screen
        hs = root.winfo_screenheight()#This is the height of the screen

        # calculate position x, y
        x = (ws/2) - (w/2)
        y = (hs/2) - (h/2)

        #This is responsible for setting the dimensions of the screen and where it is
        #placed
        root.geometry('%dx%d+%d+%d' % (w, h, x, y))
        self._createLeaderboard()

    def addScouts(self,I):
        i = I
        with open(fileName,"r") as f:
            lines = f.readlines()
            for line in lines:
                if str(line.split(",")[3])[:-1] == str(i):
                    self.scoutList.insert(END,line[:-1])
                    i += 1
                    return self.addScouts(i)
        return

    def clearListBox(self):
        self.scoutList.delete(0,END)
        return
</code></pre>
<p>In <code>popupWindow.py</code>:</p>
<pre><code>from main import mainWindow
</code></pre>
<p>In <code>popupWindow</code> class:</p>
<pre><code>mainWindow.clearListBox()
mainWindow.addScouts(1)
</code></pre>
<p>My Error:</p>
<pre><code>Traceback (most recent call last):
  File "C:\Users\KRIS\Documents\Python Projects\Scouts\popupWindow.py", line     4, in &lt;module&gt;
    from main import mainWindow
  File "C:\Users\KRIS\Documents\Python Projects\Scouts\main.py", line 4, in     &lt;module&gt;
    from popupWindow import *
  File "C:\Users\KRIS\Documents\Python Projects\Scouts\popupWindow.py", line 4, in &lt;module&gt;
    from main import mainWindow
ImportError: cannot import name 'mainWindow'
</code></pre>
<p>Thank you in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>This question has been asked times and times again - and is nothing Python-specific. To call a method on <em>an instance</em> of another class, you need to have a reference to this instance. The very obvious solution is to pass this reference, either at call time:</p>
<pre><code>class A(object):
    def __init__(self, var_a):
        self.var_a = var_a

    def method(self, another_object):
        return another_object.another_method(self.var_a)


class B(object):
    def __init__(self, var_b):
        self.var_b = var_b

    def another_method(self, var):
        return self.var_b + var


a = A(42)
b = B(1138)
print a.method(b)
</code></pre>
<p>or at instanciation time:</p>
<pre><code>class A(object):
    def __init__(self, var_a, another_object):
        self.var_a = var_a
        self.another_object = another_object

    def method(self):
        return self.another_object.another_method(self.var_a)


class B(object):
    def __init__(self, var_b):
        self.var_b = var_b

    def another_method(self, var):
        return self.var_b + var

b = b(1138)
a = A(b)
print a.method()
</code></pre>
<p>Note that in both cases, <code>B</code> doesn't need to know about class <code>A</code> - it just gets an instance as param and that's it. So if <code>A</code> and <code>B</code> live in different modules, the module containing <code>B</code> doesn't have to import the one containing <code>A</code>:</p>
<pre><code># module b.py
class B(object):
    def __init__(self, var_b):
        self.var_b = var_b

    def another_method(self, var):
        return self.var_b + var

# module a.py

from b import B

class A(object):
    def __init__(self, var_a, another_object):
        self.var_a = var_a
        self.another_object = another_object

    def method(self):
        return self.another_object.another_method(self.var_a)

if __name__ == "__main__":    
    b = b(1138)
    a = A(b)
    print a.method()
</code></pre>
<p>which avoids the circular import error you obviously have given your traceback.</p>
</div>
<div class="post-text" itemprop="text">
<p>At the beginning of <code>popupWindow.py</code>, put the line</p>
<pre><code>from main import mainWindow
</code></pre>
<p>Then you can just call, e.g., <code>mainWindow.clearListBox()</code></p>
<p>EDIT after OP posted code sample:
<code>clearListBox</code> is an instance method and as such can only be called on an instance, not on the class itself. You first have to instantiate an object of type <code>mainWindow</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on your question and on your comment to @niceguy's answer, it's clear that the solution to your problem is to go read <a href="https://docs.python.org/3/tutorial/" rel="nofollow">the python tutorial</a>: Very soon you'll learn about modules (including <code>import</code>) and classes (including <code>self</code>, and calling class methods).</p>
<p><strong>Edit:</strong> If you already understand about classes and instances, then here's your problem spelled out: Your class name is <code>mainWindow</code>, your instance is <code>mainWin</code>. You should be calling your functions on <code>mainWin</code>, e.g. <code>mainWin.addScouts(1)</code>; not on <code>mainWindow</code>.</p>
</div>
<span class="comment-copy">You could do this by importing the classes you need using the <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer"><code>import</code></a> pattern. Try to import your class containing the desired method by using the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow noreferrer"><code>import-from</code></a> as shown for submodules statement. However, you should think about your file- resp. directory-structure regarding main- and helper-files, because it seems you want to import main methods into a helper file.</span>
<span class="comment-copy"><code>import</code> is a keyword of the language, not a "pattern"</span>
<span class="comment-copy">Post some code @AdminHydra</span>
<span class="comment-copy">Your code sample is incomplete.</span>
<span class="comment-copy">Are you sure that <code>addScouts(self,I)</code> is a method of your <code>mainWindow</code> class?</span>
<span class="comment-copy">This does not help me, as my classes are stored in different files, which seems to be causing the issues</span>
<span class="comment-copy">@AdminHydra importing a module from another one shouldn't be much a problem from someone who claims to understand Python, should it ? I mean, it's part of the tutorial... <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#the-module-search-path</a></span>
<span class="comment-copy">And I'm sorry to have to say that you also need to understand the above - specially the difference between a class and an instance.</span>
<span class="comment-copy">Please read the tutorial - the part about the module search path (which I linked to) and the part about what makes a python package (in the same section of the tutorial).</span>
<span class="comment-copy">Just for the fun of it: could it be that <code>main.py</code> has an <code>import popupWindow</code> at the top level ? If yes look no further - you do "understand Python" but not enough to understand what a circular import is obviously. And if you really understood my answer you'd know you don't even need to import <code>main</code> from <code>popupWindow</code> : assuming your <code>popupWindow.popupWindow|</code>instance is created by <code>mainWindow</code>, you just have ot pass the <code>mainWindow</code> instance to <code>popupWindow</code>.</span>
<span class="comment-copy">I tried this, however clearListBox requires self, as it is contained within the mainWindow class, and references to the list which is contained in the class</span>
<span class="comment-copy">I guess you need to post a minimal example to progress here. <code>self</code> only makes sense inside a class, so I do not quite understand what you mean.</span>
<span class="comment-copy">It's clear that the OP is looking at a complex program, and they don't know enough python to understand it. Don't try to teach him/her python in the space of this answer.</span>
<span class="comment-copy">@alexis i do understand python thank you very much. I've had a long and busy day and i have a project deadline of tomorrow and my program barely functions. I'm tired and looking for a quick solution so please do not judge before you know the facts</span>
<span class="comment-copy">@admin, I didn't mean to bust on you, but I do want to discourage well-meaning people from wasting their time. If this is your own code, then I was wrong about that part. Anyway I've given you my constructive advice in my answer.</span>
