<div class="post-text" itemprop="text">
<p>I want to use mock-image for creating an object in <strong>Django</strong>.</p>
<p><strong>tests.py</strong>:</p>
<pre><code>from django.test import TestCase
from .models import MyModel
from unittest import mock
from django.core.files import File


class MyModelTestCase(TestCase):

    def setUp(self):
        file_mock = mock.Mock(spec=File, name='FileMock')
        file_mock.name = 'test.png'
        MyModel.objects.create(img=file_mock, name='123',)

    def test_creation(self):
        obj =  MyModel.objects.get(name='123')
        self.assertEqual(obj, '1, 123')
</code></pre>
<p>But I have an error:</p>
<pre><code>TypeError: 'Mock' does not support the buffer interface
</code></pre>
<p>I use <strong>spec</strong>-argument, how it described in <a href="https://docs.python.org/3/library/unittest.mock.html#the-mock-class" rel="nofollow">documentation</a>.</p>
<p>Why it does not work and how to fix that?</p>
<p>Thanks!</p>
<p><strong>UPDATE</strong></p>
<p>If I use this in <strong>setUp()</strong>:</p>
<pre><code>file_mock.read.return_value = b'my_img_data'
</code></pre>
<p>And then run test, nothing happens:</p>
<pre><code>Creating test database for alias 'default'...
</code></pre>
<p>So, no errors and no running tests. </p>
<p><strong>UPDATE 1:</strong></p>
<p>In setUP():</p>
<pre><code>image = Image.new('RGBA', size=(50,50), color=(256,0,0))
image_file = BytesIO(image.tostring())
file = InMemoryUploadedFile(image_file, None, 'test.jpg', 'image/jpg', 1024, None)
MyModel.objects.create(img=file, name='123',) 
</code></pre>
<p>And it generates new error:</p>
<pre><code>TypeError: 'NoneType' object is not subscriptable
</code></pre>
<p><strong>Traceback:</strong></p>
<pre><code>Creating test database for alias 'default'...
E
======================================================================
ERROR: test_creation ()
----------------------------------------------------------------------
Traceback (most recent call last):
  File "dir/graffities/tests.py", line 21, in setUp
    MyModel.objects.create(img=file, name='123',)
  File "dir/env/lib/python3.4/site-packages/django/db/models/manager.py", line 127, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "dir/env/lib/python3.4/site-packages/django/db/models/query.py", line 346, in create
    obj = self.model(**kwargs)
  File "dir/env/lib/python3.4/site-packages/django/db/models/base.py", line 482, in __init__
    signals.post_init.send(sender=self.__class__, instance=self)
  File "dir/env/lib/python3.4/site-packages/django/dispatch/dispatcher.py", line 201, in send
    response = receiver(signal=self, sender=sender, **named)
  File "dir/env/lib/python3.4/site-packages/django/db/models/fields/files.py", line 477, in update_dimension_fields
    width = file.width
  File "dir/env/lib/python3.4/site-packages/django/core/files/images.py", line 17, in _get_width
    return self._get_image_dimensions()[0]
TypeError: 'NoneType' object is not subscriptable

----------------------------------------------------------------------
Ran 1 test in 0.071s

FAILED (errors=1)
</code></pre>
<p><strong>UPDATE 2:</strong></p>
<p>models.py:</p>
<pre><code>class MyModel(models.Model):
    width = models.PositiveIntegerField(editable=False,)
    height = models.PositiveIntegerField(editable=False,)
    img = models.ImageField(upload_to = get_file_path, height_field='height', width_field='width')
    name = models.CharField('Название', max_length=50)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried using <code>MagicMock</code>? I doubt it will help, though. The problem is, that <code>MyModel.objects.create</code> requires your mock object returns useful values when it invokes methods like <code>.read()</code> on your <code>file_mock</code> instance. However, mocks only return mocks in the first place and you'd have to configure the mock's return values and attributes so that <code>MyModel.objects.create</code> can work with it.
Depending on what you do with the image file in the database, I would assume a simple <code>StringIO</code> instance with arbitrary data might be good enough for providing a stub for an image file.</p>
<p><strong>Update</strong></p>
<p>Your <code>MyModel.objects.create(img=file, name='123',)</code> requires a <a href="https://docs.djangoproject.com/en/1.8/ref/files/file/#the-imagefile-class" rel="nofollow"><code>django.core.files.ImageFile</code></a> instance. So you need to pass the <code>BytesIO</code> buffer to <code>ImageFile</code> and you probably have to <em>save</em> the image into the buffer, I'm not sure if the <code>Image.tostring</code> would work:</p>
<pre><code>image = Image.new('RGBA', size=(50,50), color=(256,0,0))
image_file = BytesIO()
image.save(image_file, 'PNG') # or whatever format you prefer
file = ImageFile(image_file)
MyModel.objects.create(img=file, name='123',)
</code></pre>
</div>
<span class="comment-copy">with <b>MagicMock</b> the same problem</span>
<span class="comment-copy">Yep, expected that. So you have to either go through the exercise and setup your mock correctly or try finding a different way of providing a faked image file.</span>
<span class="comment-copy">I use <code>file_mock.read.return_value</code> but now the system is "waiting". I have updated the post</span>
<span class="comment-copy">Have you tried using a StringIO instance instead of a Mock? It doesn't look like you need the Mock functionality, like asserts on the method calls, as you don't want to tes the image file.</span>
<span class="comment-copy">I have tried using BytesIO, and I have new error. The post is updated</span>
