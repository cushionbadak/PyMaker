<div class="post-text" itemprop="text">
<p>I see a lot of questions about the run-time complexity of python's built in methods, and there are a lot of answers for a lot of the methods (e.g. <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">https://wiki.python.org/moin/TimeComplexity</a> , <a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" rel="nofollow noreferrer">https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt</a> , <a href="https://stackoverflow.com/questions/1115313/cost-of-len-function">Cost of len() function</a> , etc.)</p>
<p>What I don't see anything that addresses enumerate.  I know it returns at least one new array (the indexes) but how long does it take to generate that and is the other array just the original array?</p>
<p>In other words, I'm assuming it's O(n) for creating a new array (iteration) and O(1) for the reuse of the original array...O(n) in total (I think).  Is the another O(n) for the copy making it O(n^2), or something else...?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the naïve approach (enumerate duplicates the array, then iterates over it), you have O(n) time for duplicating the array, then O(n) time for iterating over it. If that was just <em>n</em> instead of O(n), you would have 2 * <em>n</em> time total, but that's not how O(n) works; all you know is that the amount of time it takes will be <em>some</em> multiple of <em>n</em>. That's (basically) what O(n) means anyway, so in any case, the enumerate function is O(n) time total.</p>
</div>
<div class="post-text" itemprop="text">
<p>The enumerate-function returns an iterator. The concept of an iterator is described <a href="http://anandology.com/python-practice-book/iterators.html" rel="noreferrer">here</a>.</p>
<p>Basically this means that the iterator gets initialized pointing to the first item of the list and then returning the next element of the list every time its next() method gets called.</p>
<p>So the complexity should be:</p>
<p>Initialization: O(1) </p>
<p>Returning the next element: O(1) </p>
<p>Returning all elements: n * O(1)</p>
<p>Please note that enumerate does NOT create a new data structure (list of tuples or something like that)! It is just iterating over the existing list, keeping the element index in mind.</p>
<p>You can try this out by yourself:</p>
<pre><code># First, create a list containing a lot of entries:
# (O(n) - executing this line should take some noticeable time)
a = [str(i) for i in range(10000000)] # a = ["0", "1", ..., "9999999"]

# Then call the enumeration function for a.
# (O(1) - executes very fast because that's just the initialization of the iterator.)
b = enumeration(a)

# use the iterator
# (O(n) - retrieving the next element is O(1) and there are n elements in the list.)
for i in b:
    pass  # do nothing
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As martineau pointed out, <code>enumerate()</code> does not make a copy of the array.  Instead it returns an object which you use to iterate over the array.  The call to <code>enumerate()</code> itself is O(1).</p>
</div>
<span class="comment-copy">O(n^2) wolud mean O(n * n) not O(n + n)</span>
<span class="comment-copy"><code>enumerate</code> returns an enumeration object — which is an iterator object — not a list, so it's complexity is going to depend somewhat on how it's used.</span>
<span class="comment-copy">there is no <code>list.enumerate</code>. There is <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">built-in <code>enumerate()</code> function</a> that works with arbitrary iterables.</span>
<span class="comment-copy">As in the example @caenyon has and given how people often use enumerate, I'm assuming a situation like <code>for i,v in enumerate(a)</code> would be O(n+n+1) and thus O(2n)?</span>
<span class="comment-copy">@10'004 No. In any situation where the dominant term in the complexity of an algorithm is linear (i.e. if the time taken by an algorithm is some multiple of <i>n</i>), the complexity is O(n). Whether the actual time is 2n, 3n, 4n, 0.5n, or any multiple of <i>n</i>, the complexity is always O(n).</span>
<span class="comment-copy">@10'004: <code>enumerate()</code> may work with infinite generators and therefore it does not copy its input. Though it won't change the time complexity even if it did (for a finite input).</span>
