<div class="post-text" itemprop="text">
<pre><code>def tf(tokens):
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens from tokenize
    Returns:
        dictionary: a dictionary of tokens to its TF values
    """
    li = {}
    total = len(tokens)
    li = {token: 1 if not token in li else li[token] + 1 for token in tokens }
    return {token: li[token]/ float(total) for token in li}
</code></pre>
<p>Basically, I want a dictionary where the token is the key and the value is the frequency of that token in the list of tokens.</p>
<p>I want my comprehension to check if the token is already in li. If it is just increase its value by 1, if it's not, create it and set its value to 1.</p>
<p>For some reason, every key ends up with a value of (1), no matter how many times it appears in the list of tokens.</p>
<p>Can you help me see why this is happening?</p>
<p>I could solve it with a loop but i want to grasp dict comprehensions.</p>
<p>Thank you SO much!</p>
</div>
<div class="post-text" itemprop="text">
<p>A comprehension expression like list/dictionary comprehension is a builder expression and the object is not constructed until the expression is completely evaluated. The assignment to a symbolic name to the reference of the generated dictionary follows subsequent to that.</p>
<p>In your particular example, you are referring to the the symbol <code>li</code>, that refers to the object empty dictionary. So during the evaluation of the expression, <code>li</code> continues to refer to an empty dictionary which would mean, the dictionary comprehension can be equivalently written as</p>
<pre><code>li = {token: 1 if not token in {} else l{}[token] + 1 for token in tokens }
</code></pre>
<p>or to simplify as membership test on an empty dictionary is always false</p>
<pre><code>li = {token: 1  for token in tokens }
</code></pre>
<p>What you need is an already available library utility or a state based solution.</p>
<p>Luckily, standard library <a href="https://docs.python.org/2/library/collections.html" rel="nofollow">collections</a> provides a function called <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow">counter</a> which was written and designed for this purpose</p>
<p>Which would simply your function as</p>
<pre><code>def tf(tokens):
    from collections import Counter
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens from tokenize
    Returns:
        dictionary: a dictionary of tokens to its TF values
    """
    return Counter(tokens)
</code></pre>
<p>A state based solution simply requires an external counter for each unique occurrence</p>
<pre><code>def tf(tokens):
    from collections import defaultdict
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens from tokenize
    Returns:
        dictionary: a dictionary of tokens to its TF values
    """
    counter = defaultdict(int)
    for token in tokens:
          counter[token] += 1
    return counter
</code></pre>
<p>or if you do not intend to use <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow">defaultdict</a></p>
<pre><code>def tf(tokens):
    from collections import defaultdict
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens from tokenize
    Returns:
        dictionary: a dictionary of tokens to its TF values
    """
    counter = {}
    for token in tokens:
          counter[token] = counter.get(token, 0) + 1
    return counter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The dictionary comprehension is executed <em>first</em>, producing a <em>new</em> dictionary object. Only when that expression has completed, is <code>li</code> bound to that new dictionary.</p>
<p>In other words, this is what happens under the hood, without <code>_result</code> being available for reference in the loop:</p>
<pre><code>li = {}
_result = {}
for token in tokens:
    _result[token] = 1 if not token in li else li[token] + 1
li = _result
</code></pre>
<p>Since <code>li</code> is empty during the entire loop, <code>token in li</code> is always going to be <code>False</code>. The dictionary comprehension itself is working just fine.</p>
<p>If you wanted to count values, you <em>could</em> just make it an explicit loop:</p>
<pre><code>li = {}
for token in tokens:
    li[token] = 1 if not token in li else li[token] + 1
</code></pre>
<p>but you'd be better off using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter()</code> object</a>, which encapsulates the same procedure and adds other functionality on top:</p>
<pre><code>from collections import Counter

def tf(tokens):
    li = Counter(tokens)
    total = float(len(tokens))
    return {token: li[token] / total for token in li}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow">Counter</a> dict:</p>
<pre><code>from collections import Counter
li = Counter(tokens)
</code></pre>
<p>Using a normal dict you need to use a for loop and <code>dict.setdefault</code>:</p>
<pre><code>li = {}

for t in tokens:
    li.setdefault(t,0) # if key not yet added create key/value pairing
    li[t] += 1 # increment count for the key
</code></pre>
<p>You cannot increment a count in a dict comprehension as you will always end up with a count of <code>1</code>, you need either a Counter dict or an explicit loop to handle repeating keys as li is referring to the empty dict until the comprehension is complete.</p>
<p><code>if not token in li</code> is always True so you always set the value to <code>1</code></p>
<p>So in your function use a Couner dict and iterate over the items:</p>
<pre><code>def tf(tokens):
    """ Compute TF
    Args:
        tokens (list of str): input list of tokens from tokenize
    Returns:
        dictionary: a dictionary of tokens to its TF values
    """
    total = float(len(tokens))
    li = Counter(tokens)
    return {token: v / float(total) for token,v in li.iteritems()}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def tf(tokens):
    mydic = {}
    for key in tokens:
        if key not in mydic:
            mydic[key] = 1
        else:
            mydic[key] = mydic[key] + 1
    d2 = dict((k, float(v)/len(tokens)) for k,v in mydic.items())            
    return d2
</code></pre>
</div>
<span class="comment-copy"><code>itertools.Counter() object</code> ? I think you meant <code>collections.Counter()</code></span>
<span class="comment-copy">@Abhijit: of course I did. Uhm, not even sure why Chrome auto-completed the URL, I must've made the mistake before. Off to the site search engine!</span>
<span class="comment-copy">@Abhijit: bingo, <a href="https://stackoverflow.com/a/12732835">adding item to dictionary python with a variable name key</a> corrected.</span>
<span class="comment-copy">thank you very much, very useful and fast response!</span>
