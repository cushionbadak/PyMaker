<div class="post-text" itemprop="text">
<p>I have the following code</p>
<pre><code>r, w = os.pipe()
rf, wf = os.fdopen(r, 'rb', 0), os.fdopen(w, 'wb', 0)
wf.write('hello')
</code></pre>
<p>When reading it with</p>
<pre><code>rf.read(10)
</code></pre>
<p>It blocks forever. However, if I'm reading it with</p>
<pre><code>os.read(r, 10)
</code></pre>
<p>It returns <code>'hello'</code> without waiting for 10 bytes to be available.</p>
<p>Question is: How do I make <code>.read()</code> on <code>os.fdopen()</code>'ed file object behave the same? (aka non-blocking)</p>
</div>
<div class="post-text" itemprop="text">
<p>There might be a better way, but you can use the <a href="https://docs.python.org/2/library/fcntl.html" rel="nofollow"><code>fcntl</code> module</a> to set <code>O_NONBLOCK</code>:</p>
<pre><code>import fcntl

r, w = os.pipe()
fcntl.fcntl(r, fcntl.F_SETFL, os.O_NONBLOCK)
…
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is solved by using <code>io.open()</code> instead of <code>os.fdopen()</code></p>
<p>Note that you must use <code>buffering=0</code> for this to work:</p>
<pre><code>rf = io.open(r, 'rb', 0)
rf.read(10)
</code></pre>
</div>
<span class="comment-copy">It doesn’t block in Python 3, interestingly enough.</span>
<span class="comment-copy">That is intentional. <code>file.read</code> <a href="https://docs.python.org/2/library/stdtypes.html?highlight=file.read#file.read" rel="nofollow noreferrer">tries to read the exact number of bytes</a>. Python 3 differentiates between buffered and unbuffered i/o and has <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase.read1" rel="nofollow noreferrer">an additional <code>read1</code> method</a> that does not call <code>read</code> more than once.</span>
<span class="comment-copy">@Phillip this looks like the right direction. Any idea how to achieve the same behavior with Python2? Is it possible?</span>
<span class="comment-copy">I don't know of any way (but I'm not sure none exists, hence I won't post this as an answer). But you can work around the issue by using <code>io.open(r, 'rb').read1(10)</code>, <code>select</code> on a non-blocking file, or simply stick with <code>os.read</code>.</span>
<span class="comment-copy">@Phillip Python2 doesn't have <code>.read1()</code>, however, using <code>io.open(r, 'rb', 0)</code> works! Thanks!</span>
<span class="comment-copy">This only is a partial answer. <code>rf.read</code> and <code>os.read</code> will show the same behaviour afterwards, but <code>os.read</code> won't behave as before. (It will raise an IOError if there is no data available, instead of blocking.)</span>
<span class="comment-copy">Thanks. Apparently <code>file.read()</code> keeps calling <code>os.read()</code> until the buffer fills (like @Phillip said). Changing the file to non-blocking mode solves this by making <code>os.read()</code> raise an exception when there aren't any bytes left in the OS buffer.</span>
<span class="comment-copy">@Phillip actually I don't need <code>os.read()</code> to keep working. I wanted <code>os.fdopen()</code> to behave as I requested</span>
<span class="comment-copy">Ok. There is a problem with this method. It makes <code>file.read()</code> non-blocking (obviously) when there is no data in the OS buffer (unlike <code>os.read()</code>).</span>
<span class="comment-copy">this should be the answer! I'm on Python 3.5 and by defaults it blocks, rf, wf = os.fdopen(r, 'rb', 0); rf.read(123) blocks without fcntl it first.</span>
<span class="comment-copy">This appears to work for both Python 2 &amp; 3.</span>
