<div class="post-text" itemprop="text">
<p>I have two models a <code>Slot</code> and an <code>Appointment</code>.</p>
<p>Slot objects are basically appointment requests by <code>User</code>s and they are defined for <code>week_starting</code> <code>DateField</code>, and I need to match two slots to create an Appointment object for that <code>week_starting</code>. I am iterating slots and creating appointments as follows:</p>
<pre><code>while Slot.objects.filter(week_starting=next_weekday(datetime.datetime.today(), 0), is_matched=False).count() &gt; 1:
            slot = Slot.objects.filter(week_starting=next_weekday(datetime.datetime.today(), 0), is_matched=False)[:1].get()
            users = User.objects.filter(~Q(id=slot.user.id))

            min_count = Appointment.objects.filter(users_id=slot.user.id).filter(users_id=users[0].id).count()

            for user in users:

                if Appointment.objects.filter(users_id=slot.user.id).filter(users_id=user.id).count() &lt; min_count and Slot.objects.filter(Q(user=user) &amp; Q(is_matched=False) &amp; Q(week_starting=next_weekday(datetime.datetime.today()))).count() &gt; 0:
                    min_count = Appointment.objects.filter(users_id=slot.user.id).filter(users_id=user.id).count()
                    temp_slot = Slot.objects.filter(Q(user=user) &amp; Q(is_matched=False) &amp; Q(week_starting=next_weekday(datetime.datetime.today())))[:1].get()

            slot_to_match = temp_slot

            appointment = Appointment(week_starting=slot.week_starting)
            appointment.users.add(slot.user)
            appointment.users.add(slot_to_match.user)
            appointment.save()

            slot.is_matched = True
            slot.matched_on = datetime.datetime.now()
            slot.save()

            slot_to_match.is_matched = True
            slot_to_match.matched_on = datetime.datetime.now()
            slot_to_match.save()
</code></pre>
<p><code>next_weekday</code> is a method where I find the next monday's date.</p>
<p>A new requirement has just popped up, and apparently I need to match the slots according to their users' previous appointments count together, i.e. For any slot, I need to find another one, of which the User has fewer appointment count than with anybody else.</p>
<p><code>Slot</code> model:</p>
<pre><code>class Slot(models.Model):
    user = models.ForeignKey(User)
    week_starting = models.DateField()
    is_matched = models.BooleanField(default=False, blank=False, null=False)
    matched_on = models.DateTimeField(blank=True, null=True)
</code></pre>
<p><code>Appointment</code> model:</p>
<pre><code>class Appointment(models.Model):
    week_starting = models.DateField()
    start_date = models.DateTimeField(null=True, blank=True)
    users = models.ManyToManyField(User, related_name='appointment_users')
    supervisor = models.OneToOneField(User, related_name='appointment_supervisor', null=True, blank=True, unique=False)
</code></pre>
<p>I need to match two <code>Slot</code> objects that is not <code>is_matched</code> to create an <code>Appointment</code> object. I need to do it for every single Slot object. When doing that, I need to match two users who have the least number of <code>Appointment</code>s together.</p>
<p>I don't know any other solutions but looping. Any thoughts?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may need to tweak this for related names and the like but something like the below should help. If I understand you correctly you need your<code>Slot</code> objects to be aware of their <code>User</code>'s <code>Appointment</code> counts.</p>
<pre><code># define as a method of your Slot class
def user_appointment_count(self):
    return [(x, x.appointment_set.count()) for x in self.user_set.all()]
</code></pre>
<p>That will return a list of 2-tuples, where the first item is the user and the second is their appointment count. Taking the first two items in such a list will give you the two related users with the fewest appointments for any given slot. Remember to handle cases where there are fewer than 2 people in the list, or where there are ties in the appointment count.</p>
<p>I might add another model method for just that along the lines of:</p>
<pre><code>def relevant_appointment_count(self):
    return sum(x[1] for x in self.user_appointment_count()[:2])
</code></pre>
<p>You would combine this with something similar to the suggestion in my first comment as a queryset (either as extra context or as the main queryset depending on your preference) if you want to sort slots by how few appointments their two users from the above have.</p>
<pre><code># use this perhaps to return a queryset or extra context in a view
return sorted(
    Slot.objects.filter(is_matched=False),
    key=lambda s: s.relevant_appointment_count(),
    reverse=True
)
</code></pre>
<p>That should (haven't tested so again, may need a slight tweak) return a list of slots in the order I've described. Again you'd need to handle the same cases I described before.</p>
</div>
<span class="comment-copy">I don't fully understand your question detail. The question in the headline is something I usually use <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">sorted</a> for. For example: <code>return sorted(Slot.objects.all(), key=lambda s: s.computed_value_defined_in_model())</code></span>
<span class="comment-copy">The computed value is not in the model. It is "computed". I am trying to match two people with fewer appointments count together. Slots are requests that they want to be matched for that week.</span>
<span class="comment-copy">Without seeing the model it's hard to say for sure, but you should be able to define that computation as a model method and call it as I'm suggesting.</span>
<span class="comment-copy">I will post the models asap, sorry for that. But what I am asking is to sort the model objects according to the count of rows in another model's table. So the model does not know how many of it there are in the database, hence no such method can be implemented.</span>
<span class="comment-copy">Let me know when the models are up. Right now I'm still pretty confident you can get what you want with a model method and <code>sorted</code>, because what you've written so far suggested there are foreign key relationships that will let that count happen.</span>
<span class="comment-copy">Thanks a lot, I will test this asap and will tell you the result. But I think you got it! I was just about to go and write it in SQL :)</span>
<span class="comment-copy">I had to twist, but this was what I ended with roughly. Thanks.</span>
