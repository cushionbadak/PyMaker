<div class="post-text" itemprop="text">
<p>I just conducted an interesting test:</p>
<pre><code>~$ python3 # I also conducted this on python 2.7.6, with the same result
Python 3.4.0 (default, Apr 11 2014, 13:05:11) 
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; class Foo(object):
...     def __add__(self, other):
...         global add_calls
...         add_calls += 1
...         return Foo()
...     def __iadd__(self, other):
...         return self
...
&gt;&gt;&gt; add_calls = 0
&gt;&gt;&gt; a = list(map(lambda x:Foo(), range(6)))
&gt;&gt;&gt; a[0] + a[1] + a[2]
&lt;__main__.Foo object at 0x7fb588e6c400&gt;
&gt;&gt;&gt; add_calls
2
&gt;&gt;&gt; add_calls = 0
&gt;&gt;&gt; sum(a, Foo())
&lt;__main__.Foo object at 0x7fb588e6c4a8&gt;
&gt;&gt;&gt; add_calls
6
</code></pre>
<p>Obviously, the <code>__iadd__</code> method is more efficient than the <code>__add__</code> method, not requiring the allocation of a new class.  If my objects being added were sufficiently complicated, this would create unnecessary new objects, potentially creating huge bottlenecks in my code.  </p>
<p>I would expect that, in an <code>a[0] + a[1] + a[2]</code>, the first operation would call <code>__add__</code>, and the second operation would call <code>__iadd__</code> on the newly created object.</p>
<p>Why doesn't python optimize this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__add__</code> method is free to return a different type of object, while <code>__iadd__</code> should, if using in-place semantics, return <code>self</code>. They are not required to return the same type of object here, so <code>sum()</code> should not rely on the special semantics of <code>__iadd__</code>.</p>
<p>You can use the <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce()</code> function</a> to implement your desired functionality yourself:</p>
<pre><code>from functools import reduce

sum_with_inplace_semantics = reduce(Foo.__iadd__, a, Foo())
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; class Foo(object):
...     def __add__(self, other):
...         global add_calls
...         add_calls += 1
...         return Foo()
...     def __iadd__(self, other):
...         global iadd_calls
...         iadd_calls += 1
...         return self
... 
&gt;&gt;&gt; a = [Foo() for _ in range(6)]
&gt;&gt;&gt; result = Foo()
&gt;&gt;&gt; add_calls = iadd_calls = 0
&gt;&gt;&gt; reduce(Foo.__iadd__, a, result) is result
True
&gt;&gt;&gt; add_calls, iadd_calls
(0, 6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/31054540/1335431">Martjin's answer</a> provides an excellent workaround, but I feel the need to summarize the bits and pieces of answers scattered throughout the comments:</p>
<p>The <code>sum</code> function is primarily used for immutable types.  Performing all additions except the first in-place would create a performance improvement on objects that had an <code>__iadd__</code> method, but checking for the <code>__iadd__</code> method would cause a performance loss in the more typical case. <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Special cases aren't special enough to break the rules</a>.</p>
<p>I also stated that <code>__add__</code> should probably only be called once in <code>a + b + c</code>, where <code>a + b</code> creates a temporary variable, and then calls <code>tmp.__iadd__(c)</code> before returning it.  However, this would violate the principle of least surprise.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you are writting your class anyway, you know it's <code>__add__</code> can return the same object as well, don't you? </p>
<p>And therefore you can do your currying optimized code to run with both the <code>+</code> operator and the built-in <code>sum</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def __add__(self, other):
...         global add_calls
...         add_calls += 1
...         return self
</code></pre>
<p>(Just beware of passing your code to third party functions that expect "+" to be a new object)</p>
</div>
<span class="comment-copy"><code>sum</code> is mostly used for immutable numeric types that have no <code>__iadd__</code> method.  It seems to me that implementing special logic to check for an <code>__iadd__</code> method would slow down the common case.</span>
<span class="comment-copy">Not necessarily true. The OP asks for using the first temporary, not the passed arguments. This is more like C++11-move-semantics.</span>
<span class="comment-copy">OP addressed this in his question "I would expect that ... the first operation would call <code>__add__</code>, and the second operation would call <code>__iadd__</code> on the newly created object."</span>
<span class="comment-copy">@deets: Python <i>cannot know</i> that the first object is a temporary.</span>
<span class="comment-copy">@MartijnPieters It can also not know that the result of <code>__add__</code> is a new object, so how does that matter? You need to keep the semantics of both operations within the expectations of their mathematical counterparts, but <i>if</i> you do, I fail to see why Python couldn't do it. Steven makes a good point about incurred runtime checking cost, though.</span>
<span class="comment-copy">@StevenRumbalski: I did miss that, thanks for highlighting that for me.</span>
<span class="comment-copy">I'd rather make my code semantically correct.  If I did this, I'd probably, and other people on my team would definitely, forget about this "feature" and end up with problems.  Martjin's answer above may not be as short, but it's more verbose.</span>
