<div class="post-text" itemprop="text">
<p>I have a server set up with sockets and threading, and when I connect multiple clients to it, if a client sends a message, the server repeats that same message back to it, instead of to all other connected clients. For example:</p>
<pre><code>#server terminal
Server is connected on 8000
('127.0.0.1', 50328) is Connected
('127.0.0.1', 50329) is Connected
Received Message b'hi\n'

#Client 1 terminal
#input
[user1]hi
#returns:
[user1] b'hi\nhi\n'[user1]

#Client 2 terminal
#doesn't return anything, just sits at the prompt
[user2]
</code></pre>
<p>The relevant code for the server is:</p>
<pre><code>def clientHandler():
    c, addr = s.accept() 
    print(addr, "is Connected")
    if addr not in clients:
        clients.append(addr)
    try:
        while True:
            data = c.recv(1024)
            if not data: 
                break 
            print("Received Message ", repr(data))
            for client in clients:
                c.sendto(data, client)
    except:
        print("Error. Data not sent.")
</code></pre>
<p>I have read the following sources, but to no avail:</p>
<p><a href="https://stackoverflow.com/questions/21690683/python-tcp-server-sending-data-to-multiple-clients">python tcp server sending data to multiple clients</a></p>
<p><a href="https://docs.python.org/3/library/socket.html" rel="nofollow noreferrer">https://docs.python.org/3/library/socket.html</a></p>
<p>What must I do to make it send user1's message to all other users through the server?</p>
<p>Edit 1:
All server.py code:</p>
<pre><code>from socket import *
from threading import Thread

clients = []

def clientHandler():
    c, addr = s.accept() 
    print(addr, "is Connected")
    if addr not in clients:
        clients.append(addr)
    try:
        while True:
            data = c.recv(1024)
            if not data: 
                break 
            for client in clients:
                c.sendto(data, client)
    except:
        print("Error. Data not sent to all clients.")

HOST = '' #localhost
PORT = 8000

s = socket(AF_INET, SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(5)

print("Server is running on "+ str(PORT))

#Thread(target=clientHandler).start()
#Thread(target=clientHandler).start()
#Thread(target=clientHandler).start()

for i in range(5): 
    Thread(target=clientHandler).start()

s.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I see a few issues in your code -</p>
<ol>
<li><p>You are starting clientHandler threads, but then you are not making the main thread join any , this may cause main thread to die before the child threads finish processing, I think you would want to save the <code>Thread</code> objects you create to a variable and then make them join the main thread.</p></li>
<li><p>Instead of making the clientHandlers directly, you should first wait for accepting a connection from client (outside the handler function) and once you get the connection, add it to list of clients and send it over to the clientHandler.</p></li>
<li><p>In your code - <code>for client in clients: c.sendto(data, client)</code> m this sends data to all clients ,instead you should check if <code>client</code> is not the <code>client</code> that this thread is servicing, by checking against the <code>addr</code> that this thread is servicing.</p></li>
</ol>
<p>Example changes -</p>
<pre><code>from socket import *
from threading import Thread

clients = []

def clientHandler(c, addr):
    global clients
    print(addr, "is Connected")
    try:
        while True:
            data = c.recv(1024)
            if not data: 
                break 
            for client in clients:
                if addr != client:
                    c.sendto(data, client)
    except:
        print("Error. Data not sent to all clients.")

HOST = '' #localhost
PORT = 8000

s = socket(AF_INET, SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(5)

print("Server is running on "+ str(PORT))

#Thread(target=clientHandler).start()
#Thread(target=clientHandler).start()
#Thread(target=clientHandler).start()
trds = []

for i in range(5): 
    c, addr = s.accept() 
    clients.append(addr)
    t = Thread(target=clientHandler, args = (c, addr))
    trds.append(t)
    t.start()

for t in trds:
    t.join()

s.close()
</code></pre>
</div>
<span class="comment-copy">Are you using multiple threads for each new client? If so, please show us the relevant code for that as well</span>
<span class="comment-copy">if it actually sent the data to all clients, wouldnt you end up in an infinite sending loop? receive data --&gt; send to all hosts --&gt; they all receive data --&gt; send it to all hosts again, and so on?</span>
<span class="comment-copy">Im not sure. The way I send data to all clients from the server is by using the for loop. I would think that once it runs through all possibilities in the clients list it would stop. No?</span>
<span class="comment-copy">Its a client/server model, I do not think client would be sending back everything they receive. Server is the one that is sending the data to multiple clients, not the other way round ,I guess</span>
<span class="comment-copy">yes that is correct. my server is the one that receives data from client 1 for example, and then has to send that data to every other client in the clients list</span>
<span class="comment-copy">this seems to work up to a point. Now, it simply return the message to the client that sent it, not to the other clients</span>
<span class="comment-copy">Are you sure you are using the complete code i pasted? including the changes to the clientHandler() function? its a <code>!=</code> , not <code>==</code></span>
<span class="comment-copy">can you put a <code>print</code> statement before the sendto function for <code>addr</code> and check wat address it sends to?</span>
<span class="comment-copy">the first client outputs this: ('127.0.0.1', 50835) and the second ('127.0.0.1', 50836)</span>
<span class="comment-copy">and that client's address is?</span>
