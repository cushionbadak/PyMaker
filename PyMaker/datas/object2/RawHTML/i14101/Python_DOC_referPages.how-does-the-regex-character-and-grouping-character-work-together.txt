<div class="post-text" itemprop="text">
<p>I am trying to see which statements the following pattern matches:</p>
<pre><code>\(*[0­-9]{3}\)*-­*[0-­9]{3}­\d\d\d+
</code></pre>
<p>I am a little confused because the grouping characters <code>()</code> have a <code>\</code> before it. Does this mean that the statement must have a <code>(</code> and <code>)</code>? Would that mean the statements without <code>(</code> or <code>)</code> be unmatched? </p>
<pre><code>Statements:
'404­678­2347'
'(123)­1247890'
'456­900­900'
'(678)­2001236'
'404123­1234'
'(404123­123'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Context is important:</p>
<ul>
<li><code>re.match(r'\(', content)</code> matches a literal parenthesis.</li>
<li><code>re.match(r'\(*', content)</code> matches 0 or more literal parentheses, thus making the parens optional (and allowing more than one of them, but that's clearly a bug).</li>
</ul>
<p>Since the intended behavior isn't "0 or more" but rather "0 or 1", this should probably be written <code>r'\(?'</code> instead.</p>
<hr/>
<p>That said, there's a whole lot about this regex that's silly. I'd consider instead:</p>
<pre><code>[(]?\d{3}[)]?-?\d{6,}
</code></pre>
<ul>
<li>Using <code>[(]?</code> avoids backslashes, and consequently is easier to read whether it's rendered by <code>str()</code> or <code>repr()</code> (which escapes backslashes).</li>
<li>Mixing <code>[0-9]</code> and <code>\d</code> is silly; better to pick one and stick with it.</li>
<li>Using <code>*</code> in place of <code>?</code> is silly, unless you <strong>really</strong> want to match <code>(((123))456-----7890</code>.</li>
<li><code>\d{3}\d\d\d+</code> matches three digits, then three or more additional digits. Why not just match six or more digits in the first place?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Normally, the parentheses would act as grouping characters, however regex metacharacters are reduced simply to the raw characters when preceded by a backslash. From the Python docs:</p>
<blockquote>
<p>As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a <code>[</code> or <code>\</code>, you can precede them with a backslash to remove their special meaning: <code>\[</code> or <code>\\</code>.</p>
</blockquote>
<p>In your case, the statements <i>don't</i> need parentheses in order to match, as each <code>\(</code> and <code>\)</code> in the expression is followed by a <code>*</code>, which means that the previous character can be matched any number of times, <i>including</i> none at all. From the Python docs:</p>
<blockquote>
<p><code>*</code> doesn’t match the literal character <code>*</code>; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once.</p>
</blockquote>
<p>Thus the statements with or without parentheses around the first 3 digits may match.</p>
<p>Source: <a href="https://docs.python.org/2/howto/regex.html" rel="nofollow">https://docs.python.org/2/howto/regex.html</a></p>
</div>
<span class="comment-copy">The \ will make the regex match a literal "(" symbol. However, you need to make sure you are using a <i>raw string</i> in your program.</span>
<span class="comment-copy">@rlbond: Actually <code>r'\(' == '\('</code> as <a href="https://docs.python.org/2.0/ref/strings.html" rel="nofollow noreferrer">per specification</a> (<a href="https://docs.python.org/3/reference/lexical_analysis.html" rel="nofollow noreferrer">Python 3</a>), but you where right to look out for it.</span>
<span class="comment-copy">@Shan That's correct. When you put backslash before a character that has special meaning in a regexp, it removes the special meaning.</span>
<span class="comment-copy">This should be explained in any decent regexp tutorial. Go to regular-expression.info</span>
<span class="comment-copy"><code>\(</code> as a grouping operator is something you'd see in GNU BRE, not in Python regular expressions (where it just matches a <code>(</code> literal). This looks like you're conflating two very different regular expression syntaxes.</span>
