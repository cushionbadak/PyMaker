<div class="post-text" itemprop="text">
<p>this is probably a simple problem so hopefuly its easy for someone to point out my mistake or if this is even possible.</p>
<p>I have an object that has multiple objects as properties. I want to be able to dynamically set the properties of these objects like so:</p>
<pre><code>class Person(object):
    def __init__(self):
        self.pet = Pet()
        self.residence = Residence()

class Pet(object):
    def __init__(self,name='Fido',species='Dog'):
        self.name = name
        self.species = species

class Residence(object):
    def __init__(self,type='House',sqft=None):
        self.type = type
        self.sqft=sqft


if __name__=='__main__':
    p=Person()
    setattr(p,'pet.name','Sparky')
    setattr(p,'residence.type','Apartment')
    print p.__dict__
</code></pre>
<p>The output is:</p>
<p>{'pet': &lt;<strong>main</strong>.Pet object at 0x10c5ec050&gt;, 'residence': &lt;<strong>main</strong>.Residence object at 0x10c5ec0d0&gt;, 'pet.name': 'Sparky', 'residence.type': 'Apartment'}</p>
<p>As you can see, rather then having the name attribute set on the pet object of the person, a new attribute "pet.name" is created. </p>
<p>I cannot specify person.pet to setattr because different child-objects will be set by the same method, which is parsing some text and filling in the object attributes if/when a relevant key is  found.</p>
<p>Is there a easy/built in way to accomplish this? </p>
<p>Or perhaps I need to write a recursive function to parse the string and call getattr multiple times until the necessary child-object is found and then call setattr on that found object?</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noreferrer"><code>functools.reduce</code></a>:</p>
<pre><code>import functools

def rsetattr(obj, attr, val):
    pre, _, post = attr.rpartition('.')
    return setattr(rgetattr(obj, pre) if pre else obj, post, val)

# using wonder's beautiful simplification: https://stackoverflow.com/questions/31174295/getattr-and-setattr-on-nested-objects/31174427?noredirect=1#comment86638618_31174427

def rgetattr(obj, attr, *args):
    def _getattr(obj, attr):
        return getattr(obj, attr, *args)
    return functools.reduce(_getattr, [obj] + attr.split('.'))
</code></pre>
<p><code>rgetattr</code> and <code>rsetattr</code> are drop-in replacements for <code>getattr</code> and <code>setattr</code>,
which can also handle dotted <code>attr</code> strings.</p>
<hr/>
<pre><code>import functools

class Person(object):
    def __init__(self):
        self.pet = Pet()
        self.residence = Residence()

class Pet(object):
    def __init__(self,name='Fido',species='Dog'):
        self.name = name
        self.species = species

class Residence(object):
    def __init__(self,type='House',sqft=None):
        self.type = type
        self.sqft=sqft

def rsetattr(obj, attr, val):
    pre, _, post = attr.rpartition('.')
    return setattr(rgetattr(obj, pre) if pre else obj, post, val)

def rgetattr(obj, attr, *args):
    def _getattr(obj, attr):
        return getattr(obj, attr, *args)
    return functools.reduce(_getattr, [obj] + attr.split('.'))
</code></pre>
<hr/>
<pre><code>if __name__=='__main__':
    p = Person()
    print(rgetattr(p, 'pet.favorite.color', 'calico'))
    # 'calico'

    try:
        # Without a default argument, `rgetattr`, like `getattr`, raises
        # AttributeError when the dotted attribute is missing
        print(rgetattr(p, 'pet.favorite.color'))
    except AttributeError as err:
        print(err)
        # 'Pet' object has no attribute 'favorite'

    rsetattr(p, 'pet.name', 'Sparky')
    rsetattr(p, 'residence.type', 'Apartment')
    print(p.__dict__)
    print(p.pet.name)
    # Sparky
    print(p.residence.type)
    # Apartment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For one parent and one child:</p>
<pre><code>if __name__=='__main__':
    p = Person()

    parent, child = 'pet.name'.split('.')
    setattr(getattr(p, parent), child, 'Sparky')

    parent, child = 'residence.type'.split('.')
    setattr(getattr(p, parent), child, 'Sparky')

    print p.__dict__
</code></pre>
<p>This is simpler than the other answers for this particular use case.</p>
</div>
<div class="post-text" itemprop="text">
<p>I made a simple version based on ubntu's answer called <a href="https://pypi.org/project/magicattr/" rel="nofollow noreferrer">magicattr</a> that also works on attrs, lists, and dicts by parsing and walking the ast.</p>
<p>For example, with this class:</p>
<pre><code>class Person:
    settings = {
        'autosave': True,
        'style': {
            'height': 30,
            'width': 200
        },
        'themes': ['light', 'dark']
    }
    def __init__(self, name, age, friends):
        self.name = name
        self.age = age
        self.friends = friends


bob = Person(name="Bob", age=31, friends=[])
jill = Person(name="Jill", age=29, friends=[bob])
jack = Person(name="Jack", age=28, friends=[bob, jill])
</code></pre>
<p>You can do this</p>
<pre><code># Nothing new
assert magicattr.get(bob, 'age') == 31

# Lists
assert magicattr.get(jill, 'friends[0].name') == 'Bob'
assert magicattr.get(jack, 'friends[-1].age') == 29

# Dict lookups
assert magicattr.get(jack, 'settings["style"]["width"]') == 200

# Combination of lookups
assert magicattr.get(jack, 'settings["themes"][-2]') == 'light'
assert magicattr.get(jack, 'friends[-1].settings["themes"][1]') == 'dark'

# Setattr
magicattr.set(bob, 'settings["style"]["width"]', 400)
assert magicattr.get(bob, 'settings["style"]["width"]') == 400

# Nested objects
magicattr.set(bob, 'friends', [jack, jill])
assert magicattr.get(jack, 'friends[0].friends[0]') == jack

magicattr.set(jill, 'friends[0].age', 32)
assert bob.age == 32
</code></pre>
<p>It also won't let you/someone call functions or assign a value since it doesn't use eval or allow Assign/Call nodes.</p>
<pre><code>with pytest.raises(ValueError) as e:
    magicattr.get(bob, 'friends = [1,1]')

# Nice try, function calls are not allowed
with pytest.raises(ValueError):
    magicattr.get(bob, 'friends.pop(0)')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok so while typing the question I had an idea of how to do this and it seems to work fine. Here is what I came up with:</p>
<pre><code>def set_attribute(obj, path_string, new_value):
    parts = path_string.split('.')
    final_attribute_index = len(parts)-1
    current_attribute = obj
    i = 0
    for part in parts:
        new_attr = getattr(current_attribute, part, None)
        if current_attribute is None:
            print 'Error %s not found in %s' % (part, current_attribute)
            break
        if i == final_attribute_index:
            setattr(current_attribute, part, new_value)
        current_attribute = new_attr
        i+=1


def get_attribute(obj, path_string):
    parts = path_string.split('.')
    final_attribute_index = len(parts)-1
    current_attribute = obj
    i = 0
    for part in parts:
        new_attr = getattr(current_attribute, part, None)
        if current_attribute is None:
            print 'Error %s not found in %s' % (part, current_attribute)
            return None
        if i == final_attribute_index:
            return getattr(current_attribute, part)
        current_attribute = new_attr
        i += 1
</code></pre>
<p>I guess this solves my question, but I am still curious if there is a better way to do this?</p>
<p>I feel like this has to be something pretty common in OOP and python, so I'm surprised gatattr and setattr do not support this natively.</p>
</div>
<div class="post-text" itemprop="text">
<p>unutbu's answer (<a href="https://stackoverflow.com/a/31174427/2683842">https://stackoverflow.com/a/31174427/2683842</a>) has a "bug". After <code>getattr()</code> fails and is replaced by <code>default</code>, it continues calling <code>getattr</code> on <code>default</code>.</p>
<p>Example: <code>rgetattr(object(), "nothing.imag", 1)</code> should equal <code>1</code> in my opinion, but it returns <code>0</code>:</p>
<ul>
<li><code>getattr(object(), 'nothing', 1)</code>  == 1.</li>
<li><code>getattr(1, 'imag', 1)</code>  == 0 (since 1 is real and has no complex component).</li>
</ul>
<h2>Solution</h2>
<p>I modified rgetattr to return <code>default</code> at the first missing attribute:</p>
<pre><code>import functools

DELIMITER = "."

def rgetattr(obj, path: str, *default):
    """
    :param obj: Object
    :param path: 'attr1.attr2.etc'
    :param default: Optional default value, at any point in the path
    :return: obj.attr1.attr2.etc
    """

    attrs = path.split(DELIMITER)
    try:
        return functools.reduce(getattr, attrs, obj)
    except AttributeError:
        if default:
            return default[0]
        raise
</code></pre>
</div>
<span class="comment-copy">Wow that was something I did not know.</span>
<span class="comment-copy">Thank you for the reply! This is cool, I love how you can do in 5 lines what took me 30. Very neat and concise solution!</span>
<span class="comment-copy">Beautiful answer!</span>
<span class="comment-copy">@RedX: The post has been updated to include a <code>default</code> parameter. I wish I could make it a little simpler, but c'est la vie.</span>
<span class="comment-copy">Hi, Thanks for your inspiration, But I've made a simplified implementation with the same effect: <a href="https://gist.github.com/wonderbeyond/d293e7a2af1de4873f2d757edd580288" rel="nofollow noreferrer">gist.github.com/wonderbeyond/d293e7a2af1de4873f2d757edd580288</a></span>
<span class="comment-copy">this should be the accepted answer, thanks alot</span>
<span class="comment-copy">The name of the last attribute, <code>final_attribute</code> can occur more than once. For example, <code>p.foo.foo</code> is legal. So the condition <code>part == final_attribute</code> may trigger too soon.</span>
<span class="comment-copy">Ahh very good point, I changed to checking the index, which should resolve that issue. Thank you for pointing this out!</span>
