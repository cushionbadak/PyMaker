<div class="post-text" itemprop="text">
<p>I have a deeply nested configuration hassle.</p>
<p>The problem happens to be in machine learning, where an end-user calling a cross-validation routine, may, or may not specify any of various parameters (e.g. "randomSeed" = 17)</p>
<p>Either way, the parameters then have to be passed first to the cross-validation algorithm, and then on to a first machine learning algorithm. The machine learning algorithm, must be able to set and pass on other parameters, all without the initial user knowing.   </p>
<p>Most all of the consumers in the chain of parameter users expect a java Map interface to be doing the look-up from. </p>
<p>Flattening the keys into one library is unattractive for performance reasons -- both CPU and memory  -- (the 'root key-name' space) will be used without modification many thousands of times, and each time a number of additional parameters need to be specified before the bundle is passed along. </p>
<p>A decent analog is how the PATH variable works, each element in the path being a directory (key-namespace). When a query is made against the PATH variable (eg. you type 'emacs' at the command line), it looks in each directory (unnamed namespace of keys) for that file-name (specified value) in order, until it either finds it, or fails to find it.  If it finds it, you get to execute the specific contents of the executable file it found (get the value of the parameter set). If you have a PATH variable from another, you can append a new directory  (anonymous key-space ) in front of it as you pass that PATH variable setting along to a new end-user, without modifying the previous directories (preferences).</p>
<p>Given the name-space on the configuration parameters is effectively flat, a solution like Python's <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow">ChainMap</a> would be perfect (eg <a href="https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes" rel="nofollow">example usage</a>) but I'm finding no equivalent solution in Java?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Over the weekend I went ahead and created a <a href="https://bitbucket.org/dimo414/code-samples/src/tip/java/src/com/mwdiamond/ChainMap.java" rel="nofollow noreferrer"><code>ChainMap</code></a> implementation as well; thanks to Java 8 it's a surprisingly small class.  My implementation is slightly different than yours; it doesn't attempt to mirror Python's behavior and instead follows the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" rel="nofollow noreferrer"><code>Map</code></a> interface's specifications.  Notably:</p>
<ul>
<li>Lookup order is insertion order; the first map passed to the constructor takes precedence over the following maps.</li>
<li><code>.containsValue()</code> doesn't match values that are masked by earlier maps.</li>
<li><code>.put()</code> returns the previous value of the chain map, even if that value was in a later map.</li>
<li><code>.remove()</code> removes the key from all maps, not just the first map or the visible entry.  From the Javadoc: "<em>The map will not contain a mapping for the specified key once the call returns.</em>"</li>
<li>Similarly <code>.clear()</code> clears all maps, not just the top map.</li>
<li>Implements <code>.equals()</code> and <code>.hashCode()</code> on the basis of its entry set, so that it is equal to other <code>Map</code> implementations.</li>
</ul>
<p>I also did not implement push/pop behavior as it felt like an anti-pattern; <code>ChainMap</code> is already an O(1) view into a series of maps, you can simply construct additional <code>ChainMap</code>s with the maps you want as needed.</p>
<p>Obviously, if your implementation works for your use case, that's great.  But it violates the <code>Map</code> contract in several places; I'd strongly suggest removing <code>implements Map&lt;K, V&gt;</code> and just let it be a standalone class.</p>
<p>Many of the class's methods are nice one-liners, e.g.:</p>
<pre><code>@Override
public int size() {
  return keySet().size();
}

@Override
public boolean isEmpty() {
  return !chain.stream().filter(map -&gt; !map.isEmpty()).findFirst().isPresent();
}

@Override
public boolean containsKey(Object key) {
  return chain.stream().filter(map -&gt; map.containsKey(key)).findFirst().isPresent();
}

@Override
public boolean containsValue(Object value) {
  return entrySet().stream()
    .filter(e -&gt; value == e.getValue() || (value != null &amp;&amp; value.equals(e.getValue())))
    .findFirst().isPresent();
}

@Override
public V get(Object key) {
  return chain.stream().filter(map -&gt; map.containsKey(key))
    .findFirst().map(map -&gt; map.get(key)).orElse(null);
}
</code></pre>
<p>I've written some <a href="https://bitbucket.org/dimo414/code-samples/src/tip/java/tests/com/mwdiamond/ChainMapTest.java" rel="nofollow noreferrer">tests</a> to verify the class's behavior as well.  Additional test cases are welcome.</p>
<hr/>
<p>I also extended your idea of using <code>Maps.asMap()</code> to create an immutable view of a collection of maps; if you don't need mutation this will work nicely.  (As <a href="https://stackoverflow.com/a/31041589/113632">I learned</a>, you have to use the three-argument form of <code>.reduce()</code> to get the generics to behave).</p>
<pre><code>public static &lt;K, V&gt; Map&lt;K, V&gt; immutableChainView(
    Iterable&lt;? extends Map&lt;? extends K, ? extends V&gt;&gt; maps) {
  return StreamSupport.stream(maps.spliterator(), false).reduce(
    (Map&lt;K,V&gt;)ImmutableMap.&lt;K,V&gt;of(),
    (a, b) -&gt; Maps.asMap(Sets.union(a.keySet(), b.keySet()),
                         k -&gt; a.containsKey(k) ? a.get(k) : b.get(k)),
    (a, b) -&gt; Maps.asMap(Sets.union(a.keySet(), b.keySet()),
                         k -&gt; a.containsKey(k) ? a.get(k) : b.get(k)));
    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since there seems to be nothing off the shelf (thanks to  lopisan and dimo414 for their tips/pointers), I did a first crack implementation that will at least serve my immediate needs. I'll hold off marking this as an answer for a few days, in case someone knows about a library-grade version. </p>
<p>I've included lots of example usage calls. They could be converted to unit tests. There's places it could be more efficient. </p>
<pre><code>import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;


/** 
 * Not thread safe. To make it thread safe, you'd also have to ensure the underlying collections are thread safe.
 * Expected use case is  indexing Strings
 */
public class ChainMap&lt;K, V&gt;  implements Map&lt;K, V&gt;, Cloneable{ 
    ArrayList&lt;  Map&lt;K, V&gt; &gt; scopes = new ArrayList&lt;&gt;(); 

    @Override
    public V get(Object key) {

        for( Map&lt;K, V&gt; m : Lists.reverse( scopes ))
            if( m.containsKey( key)) return  m.get(key);

        //no one has it..
        return null; 
    }


    public  void pushScope( Map&lt; K, V&gt;  scope){
        scopes.add( scope); 
    }

    public  Map&lt;K, V&gt;  popScope( ) {
        if( scopes.size() == 0) throw new RuntimeException("must have at least one underlying map in the Chain to do a pop"); 

        return scopes.remove( scopes.size() -1); 
    }


    /** warning, this risks being expensive, as the semantics are interpreted as the count of distinct keys. 
     * you may want to cache this value*/ 
    public int size() {        return keySet().size();    }


    public boolean isEmpty() {
        for(  Map&lt;K, V&gt; m : scopes  )         //no reverese iteration  needed
            if( !m.isEmpty()) return false; 
        return true; 
    }


    public boolean containsKey(Object key) { 
        for(  Map&lt;K, V&gt; m : scopes  )       //no reverese iteration  needed
            if( m.containsKey( key)) return true;   
        return false; 
    }


    public boolean containsValue(Object value) {
        for(  Entry&lt;K, V&gt; e : entrySet())
            if( (value == e.getValue() || (value != null &amp;&amp; value.equals(e.getValue()))) == true) 
                return true; 

        return false; 
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Map) {
            return entrySet().equals(((Map&lt;?,?&gt;)obj).entrySet());
        }
        return false;
    }

    @Override
    public int hashCode() {
        return entrySet().hashCode();
    }


    public V put(K key, V value) {
        if( scopes.size() == 0) throw new RuntimeException("must have at least one underlying map in the Chain to do a put"); 

        return scopes.get( scopes.size()-1).put( key, value); 
    }


    public V remove(Object key) {
        return scopes.get( scopes.size()-1).remove( key); 
    }


    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        if( scopes.size() == 0) throw new RuntimeException("must have at least one underlying map in the Chain to do a put"); 
        scopes.get( scopes.size()-1).putAll( m); 
    }


    /** clears only the last, by default */
    public void clear() { 
        scopes.get( scopes.size()-1).clear();   
   }


    /** builds the result as a view on the underlying keySet */
    public Set&lt;K&gt; keySet() {
        int numMaps = scopes.size(); 
        if( numMaps == 0) return Collections.emptySet(); 
        else if( numMaps == 1) return scopes.get(0).keySet(); 
        else{ 

            Set&lt;K&gt; result = Sets.union( scopes.get(numMaps-1).keySet(), scopes.get(numMaps-2).keySet()); 

            for (int i = scopes.size()-3; i &gt;=0 ; i--) 
                result = Sets.union( result, scopes.get( i).keySet());

            return result; 
        }
    }

    public Collection&lt;V&gt; values() {
        return this.entrySet().stream().map( e -&gt; e.getValue()).collect(Collectors.toList()); 
    }

    /** builds the result as a view on the underlying entrySets */
    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
        int numMaps = scopes.size(); 
        if( numMaps == 0) return new HashMap&lt;K, V&gt;().entrySet();
        else if( numMaps == 1) return scopes.get(0).entrySet(); 
        else{ 

            Set&lt;K&gt; keySet = this.keySet(); 
            Map&lt;K, V&gt; m = Maps.asMap( keySet,    key -&gt; this.get(key)); 
            return m.entrySet(); //return Maps.asMap( keySet,    key -&gt; this.get(key)).keySet();  
        }
    }


    @SuppressWarnings("unchecked")
    public Object clone(){
        try {
            ChainMap&lt; K, V&gt; cm  = (ChainMap&lt; K, V&gt;) super.clone();
            cm.scopes = (ArrayList&lt;  Map&lt;K, V&gt; &gt; ) this.scopes.clone();
            return cm; 
        } catch (CloneNotSupportedException e) {
            throw new Error( e ); 
        }
    }


    public ChainMap&lt;K, V&gt; copy(){ 
        @SuppressWarnings("unchecked")
        ChainMap&lt;K, V&gt; c  = (ChainMap&lt;K, V&gt;) clone();
        return c; 
    }








    public static void 
    examples1
    ( )
    {
        ChainMap&lt;String, Object&gt; cm1 = new ChainMap&lt;&gt;();  
        HashMap&lt;String, Object&gt; a = new HashMap&lt;&gt;();
        a.put( "a", "A"); 
        a.put( "b", "B"); 
        a.put( "c", "C"); 
        a.put( "m", "M"); 
        a.put( "a'sMap", "asValue");  //&lt;-- tracer entry

        HashMap&lt;String, Object&gt; b = new HashMap&lt;&gt;();
        b.put( "c", "CCC"); 
        b.put( "b'sMap", "bsValue");   //&lt;-- tracer entry

        HashMap&lt;String, Object&gt; c = new HashMap&lt;&gt;();
        c.put( "a", "AAA"); 
        c.put( "b",  1); 
        c.put( "z", "ZZZ"); 
        c.put( "c'sMap", "csMapValue");   //&lt;-- tracer entry

        cm1.pushScope( a);
        cm1.pushScope( b);
        cm1.pushScope( c);
        PrintStream o = System.out; 

        o.println( cm1.get( "z")); //prints "ZZZ"
        o.println( cm1.get( "b")); //prints 1

        cm1.put( "z", 5);
        o.println( cm1.get( "z")); //prints 5

        ChainMap&lt;String, Object&gt; cm2 = cm1.copy();

        HashMap&lt;String, Object&gt; d = new HashMap&lt;&gt;();
        d.put( "a", 999);
        d.put( "w", "WWWWWWW");
        d.put( "x", "XXXXXXX");
        d.put( "t", "TTTTTTT");
        d.put( "d'sMap", "dsMapValue");  //&lt;-- tracer entry
        cm2.pushScope(d); 

        ChainMap&lt;String, Object&gt; cm3 = cm2.copy();  

        o.println( cm2.get( "a")); //prints "999"
        o.println( cm1.get( "a")); //prints "AAA"

        cm2.popScope(); 
        cm2.popScope();
        o.println( cm2.get("a"));//prints "A"


        o.println( cm3.keySet().size()); 


        o.println( "__________"); 
        //show how can iterate keys-value pairs
        for( Entry&lt;String, Object&gt;  e: cm3.entrySet()) 
            o.println( e.getKey() + ":" + e.getValue()); 

        o.println( "__________"); 

        o.println( cm3.keySet().contains( "w")); //prints true


        o.println( cm3.containsKey( "f")); //prints false 
        o.println( cm3.containsKey( "a")); //prints true
        o.println( cm3.containsKey( "w")); //prints true


        cm3.popScope(); 
        o.println( cm3.containsKey( "w")); //prints false

    }


    public static void 
    examples2
    ( )
    {
        ChainMap&lt;String, Object&gt; cm1 = new ChainMap&lt;&gt;();  
        HashMap&lt;String, Object&gt; a = new HashMap&lt;&gt;();
        a.put( "a", "A"); 
        a.put( "a'sMap", "asValue"); 

        HashMap&lt;String, Object&gt; b = new HashMap&lt;&gt;();
        b.put( "b", "BBB"); 
        b.put( "b'sMap", "bsValue"); 

        HashMap&lt;String, Object&gt; c = new HashMap&lt;&gt;();
        c.put( "c", "CCC"); 
        c.put( "c'sMap", "csMapValue"); 

        HashMap&lt;String, Object&gt; d = new HashMap&lt;&gt;();
        d.put( "d", "DDD"); 
        d.put( "d'sMap", "dsMapValue"); 

        cm1.pushScope( a);
        cm1.pushScope( b);
        cm1.pushScope( c);
        PrintStream o = System.out; 

        // we can make a chainMap part of another 
        ChainMap&lt;String, Object&gt; cmMeta = new ChainMap&lt;&gt;(); 
        cmMeta.pushScope( cm1);
        cmMeta.pushScope( d);


        o.println( "__________"); 
        for( Entry&lt;String, Object&gt;  e: cmMeta.entrySet()) 
            o.println( e.getKey() + ":" + e.getValue()); 
        o.println( "__________"); 

        /*Gives: 
            __________
            d'sMap:dsMapValue
            d:DDD
            c:CCC
            c'sMap:csMapValue
            b:BBB
            b'sMap:bsValue
            a:A
            a'sMap:asValue
            __________
         */

    }

    public static void   main( String[] args ) {   examples1();  examples2();     }

}
</code></pre>
<p>Since this emulates the python ChainMap API, notice that <code>aChainMapInstance.remove(someKey)</code> doesn't mean the key won't still be in there. That remove call will only work if the top map on the scope-stack contains the key. </p>
<p>( Updated to emulate dimo414's implementation of <code>containsValue()</code>, <code>hashcode()</code> and <code>equals()</code>. ) </p>
<hr/>
<p>Incidentally, while trying to build this, I noticed there's a one liner version of the implicit fusion of two maps with guava (if that is all you need). An example usage case: both maps have perhaps millions of keys, and your user may not even bother to query it at all. Modifications though, unlike the ChainMap above, will give you an UnsupportedOperationException. This one should work through nestings, like: composedMapView( map1, composedMapView( map2, map3)). </p>
<pre><code> public static &lt;K, V&gt; 
    Map&lt;K, V&gt; composedMapView( Map&lt;K, V&gt; look1st, Map&lt;K, V&gt; look2nd){
        return  Maps.asMap( Sets.union( look1st.keySet(), look2nd.keySet()), 
                    k -&gt;  look1st.containsKey(k) ? look1st.get(k) : look2nd.get(k));  

    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Out of the box I'm not aware of an equivalent.  Guava doesn't provide a <code>Maps.chain()</code> method either, but perhaps it should.</p>
<p>For normal use cases, I would simply construct a new <code>Map</code>; with Guava you can do so succinctly, e.g.:</p>
<pre><code>// Entries in map2 overwrite map1; reverse the insertion order if needed
ImmutableMap.builder().putAll(map1).putAll(map2).build();
</code></pre>
<p>You could define your own <code>ChainMap&lt;K, V&gt;</code> implementation that stores a <code>List&lt;Map&lt;? extends K, ? extends V&gt;&gt;</code> with relative ease by extending <code>AbstractMap</code>.  However this introduces an <code>O(k)</code> overhead (where <code>k</code> is the number of maps in the chain).  This would be worthwhile if your maps are so large that copying is prohibitive, or you intend to construct these chained mappings very frequently, but otherwise I wouldn't suggest it.</p>
<p>For a use case like merging properties, I would just construct a new map and be done with it.</p>
</div>
<span class="comment-copy">Maybe this will help: <a href="http://stackoverflow.com/questions/4299728/how-can-i-combine-two-hashmap-objects-containing-the-same-types" title="how can i combine two hashmap objects containing the same types">stackoverflow.com/questions/4299728/…</a></span>
<span class="comment-copy">Since I know nothing about Python, an explanation of what you are trying to do would help.</span>
<span class="comment-copy">@lopisan - that's a possibly workaround, though less desired for performance reasons, usage clarity, and to some degree debugging. The notion sought is very similar to name resolution in an object-oriented-type hierarchy, except here the 'fields' are both sparse and dynamic. The end user gets obliviousness to how that chain of names was created when he(she) attempt to access a field.</span>
<span class="comment-copy">nice!   Your containsValue() improvement revealed a bug in my initial implementation, and your equals() and hashcode() is obviously the right way to do it!  I credited you with the updates I did for those three methods.</span>
<span class="comment-copy">Glad it was helpful :)  I'd still suggest dropping the <code>implements Map&lt;K, V&gt;</code> from your implementation since it does not obey <code>Map</code>'s contracts.</span>
<span class="comment-copy">On how put(), remove(), putAll() and clear() work, seems somewhat an end-application-usage driven topic. I came at the problem looking for Java's ChainMap, but all-in, I think your attention to the design intention of the Java Map interface is the better way to go. I'll check it as the answer.; With this implementation, to get the python ChainMap behavior of only modifying the top map, you could wrap the non-surface maps with a Guava FowardingMap on which you override the modifying methods to do nothing (as distinct from using an unmodifiableCollection() wrapper, which would throw exceptions).</span>
