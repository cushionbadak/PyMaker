<div class="post-text" itemprop="text">
<p>Given an ordered list of integers:</p>
<pre><code>[1,3,7,8,9]
</code></pre>
<p>How can I find all the sublists that can be created from original list where order is maintained? Using the example above, I'm looking for a way to programmatically generate these sequences:</p>
<pre><code>[[1],[3,7,8,9]]
[[1, 3],[7,8,9]]
[[1, 3, 7],[8,9]]
[[1, 3, 7, 8],[9]]
[[1, 3, 7, 8, 9]]
[[1, 3, 7], [8, 9]]
[[1], [3, 7], [8], [9]]
[[1], [3], [7, 8], [9]]
[[1], [3], [7], [8, 9]]
...
</code></pre>
<p>I'm basically looking for a way to generate all the permutations of a list where order is maintained. I can generate all the sublists where there are only 2 sublists in total using this code:</p>
<pre><code>def partition(arr, idx):
    return [arr[:idx], arr[idx:]]

l = [1,3,7,8,9]
for idx in range(1, len(l)):
    groups = partition(l, idx)
    print(groups)

[[1], [3, 7, 8, 9]]
[[1, 3], [7, 8, 9]]
[[1, 3, 7], [8, 9]]
[[1, 3, 7, 8], [9]]
</code></pre>
<p>However, this code snippets only splits the original list in two and generates all the possible sublists where there are only two sublists. How can I generate all the possible sublists that can be created from original list where order is maintained?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>import itertools

def subsets(seq):
    for mask in itertools.product([False, True], repeat=len(seq)):
        yield [item for x, item in zip(mask, seq) if x]

def ordered_groups(seq):
    for indices in subsets(range(1, len(seq))):
        indices = [0] + indices + [len(seq)]
        yield [seq[a:b] for a,b in zip(indices, indices[1:])]

for group in ordered_groups([1,3,7,8,9]):
    print group
</code></pre>
<p>Result:</p>
<pre><code>[[1, 3, 7, 8, 9]]
[[1, 3, 7, 8], [9]]
[[1, 3, 7], [8, 9]]
[[1, 3, 7], [8], [9]]
[[1, 3], [7, 8, 9]]
[[1, 3], [7, 8], [9]]
[[1, 3], [7], [8, 9]]
[[1, 3], [7], [8], [9]]
[[1], [3, 7, 8, 9]]
[[1], [3, 7, 8], [9]]
[[1], [3, 7], [8, 9]]
[[1], [3, 7], [8], [9]]
[[1], [3], [7, 8, 9]]
[[1], [3], [7, 8], [9]]
[[1], [3], [7], [8, 9]]
[[1], [3], [7], [8], [9]]
</code></pre>
</div>
<span class="comment-copy">Seems like you're reinventing the wheel with <code>subsets</code>. I'm sure the same thing could be more easily done with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>.</span>
<span class="comment-copy">I suppose you could instead define <code>subsets</code> as <code>for i in range(len(seq)+1): for x in itertools.combinations(seq, i): yield list(x)</code>. Not sure if you could do it with only one <code>for</code> loop though.</span>
<span class="comment-copy"><code>[item for x, item in zip(mask, seq) if x]</code> -&gt; <code>list(itertools.compress(seq, mask))</code></span>
<span class="comment-copy">Oh nice, I've overlooked <code>compress</code> up until now. TIL.</span>
<span class="comment-copy">This is the only time I've found a use for it.</span>
