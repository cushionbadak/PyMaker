<div class="post-text" itemprop="text">
<p>I want to generate a dictionary from a list of dictionaries, grouping list items by the value of some key, such as:</p>
<pre class="lang-python prettyprint-override"><code>input_list = [
        {'a':'tata', 'b': 'foo'},
        {'a':'pipo', 'b': 'titi'},
        {'a':'pipo', 'b': 'toto'},
        {'a':'tata', 'b': 'bar'}
]
output_dict = {
        'pipo': [
             {'a': 'pipo', 'b': 'titi'}, 
             {'a': 'pipo', 'b': 'toto'}
         ],
         'tata': [
             {'a': 'tata', 'b': 'foo'},
             {'a': 'tata', 'b': 'bar'}
         ]
}
</code></pre>
<p>So far I've found two ways of doing this. The first simply iterates over the list, create sublists in the dict for each key value and append elements matching these keys to the sublist :</p>
<pre><code>l = [ 
    {'a':'tata', 'b': 'foo'},
    {'a':'pipo', 'b': 'titi'},
    {'a':'pipo', 'b': 'toto'},
    {'a':'tata', 'b': 'bar'}
    ]

res = {}

for e in l:
    res[e['a']] = res.get(e['a'], []) 
    res[e['a']].append(e)
</code></pre>
<p>And another using <code>itertools.groupby</code>:</p>
<pre><code>import itertools
from operator import itemgetter

l = [ 
        {'a':'tata', 'b': 'foo'},
        {'a':'pipo', 'b': 'titi'},
        {'a':'pipo', 'b': 'toto'},
        {'a':'tata', 'b': 'bar'}
]

l = sorted(l, key=itemgetter('a'))
res = dict((k, list(g)) for k, g in itertools.groupby(l, key=itemgetter('a')))
</code></pre>
<p>I wonder which alternative is the most efficient ?</p>
<p>Is there any more pythonic/concise or better performing way of achieving this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Is it correct that you want to group your input list by the value of the 'a' key of the list elements? If so, your first approach is the best, one minor improvement, use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="noreferrer"><code>dict.setdefault</code></a>:</p>
<pre><code>res = {}
for item in l:
    res.setdefault(item['a'], []).append(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A one liner -</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; input_list = [
...         {'a':'tata', 'b': 'foo'},
...         {'a':'pipo', 'b': 'titi'},
...         {'a':'pipo', 'b': 'toto'},
...         {'a':'tata', 'b': 'bar'}
... ]
&gt;&gt;&gt; {k:[v for v in input_list if v['a'] == k] for k, val in itertools.groupby(input_list,lambda x: x['a'])}
{'tata': [{'a': 'tata', 'b': 'foo'}, {'a': 'tata', 'b': 'bar'}], 'pipo': [{'a': 'pipo', 'b': 'titi'}, {'a': 'pipo', 'b': 'toto'}]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If by <strong>efficient</strong> you mean <strong>"time efficient"</strong>, it is possible to measure it using the <code>timeit</code> built in module.</p>
<p>For example:</p>
<pre><code>import timeit
import itertools
from operator import itemgetter

input = [{'a': 'tata', 'b': 'foo'},
         {'a': 'pipo', 'b': 'titi'},
         {'a': 'pipo', 'b': 'toto'},
         {'a': 'tata', 'b': 'bar'}]

def solution1():
    res = {}
    for e in input:
        res[e['a']] = res.get(e['a'], [])
        res[e['a']].append(e)
    return res

def solution2():
    l = sorted(input, key=itemgetter('a'))
    res = dict(
        (k, list(g)) for k, g in itertools.groupby(l, key=itemgetter('a'))
    )
    return res

t = timeit.Timer(solution1)
print(t.timeit(10000))
# 0.0122511386871

t = timeit.Timer(solution2)
print(t.timeit(10000))
# 0.0366218090057
</code></pre>
<p>Please refer to the <a href="https://docs.python.org/3.4/library/timeit.html" rel="nofollow">timeit official docs</a> for further information.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best approach is the first one you mentioned, and you can even make it more elegant by using <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a> as mentioned by bernhard above. The complexity of this approach is O(n) since we simply iterate over the input once and for each item we perform a lookup into the output dict we are building to find the appropriate list to append it to, which takes constant time (lookup+append) for each item. So overlal complexity is O(n) which is optimal. </p>
<p>When using itertools.groupby, you must sort the input beforehand (which is O(n log n)). </p>
</div>
<span class="comment-copy">by "best", you mean performance/complexity-wise ?</span>
<span class="comment-copy">(and yes, it is correct that I "want toi group my input list by the value of the 'a' key of the list elements" - <code>groupby</code> seemed to be the best option, however I feared the mandatory sort before would add unecessary complexity compared to a simple <code>for</code> loop)</span>
<span class="comment-copy">'best' was referring to complexity-wise, yes.</span>
<span class="comment-copy">I feel my question was poorly worded. I'm going to accept your answer as it is the most upvoted and actually answers my question. However @gen-y-s answer is also good as it clarify the question and the why, and another demonstrate its time-efficiency, which can be something different from compexity in some cases : for instance, if the input dataset is substantially ordered - which is the case of my real-life data - the complexity of the second approach is still O(n).</span>
<span class="comment-copy">also note that @ewilazarus answer actually showed that against my almost-sorted data, your solution is still more efficient.</span>
<span class="comment-copy">Yes, I actually meant <i>time efficient</i>. Thanks for sharing this.</span>
<span class="comment-copy">I already knew the complexity of the second approach was O(n log n), thus worse, but thank you for clarifying this point. What I was actually looking is an solution with same complexity as approach #1, but using a low-overhead, memory-efficient, high-performance, etc solution such as the ones found in <code>itertools</code>. I guess there isn't one in this case.</span>
<span class="comment-copy">also be aware that python uses timsort, which as O(n) complexity on substantially sorted data: <a href="https://en.wikipedia.org/wiki/Timsort" rel="nofollow noreferrer">en.wikipedia.org/wiki/Timsort</a></span>
