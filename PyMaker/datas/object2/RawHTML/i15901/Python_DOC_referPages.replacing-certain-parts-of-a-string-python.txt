<div class="post-text" itemprop="text">
<p>I can not seem to solve this. I have many different strings, and they are always different. I need to replace the ends of them though, but they are always different lengths. Here is a example of a couple strings:</p>
<pre><code>string1 = "thisisnumber1(111)"
string2 = "itsraining(22252)"
string3 = "fluffydog(3)"
</code></pre>
<p>Now when I print these out it will of course print the following:</p>
<pre><code>thisisnumber1(111)
itsraining(22252)
fluffydog(3)
</code></pre>
<p>What I would like it to print though is the follow:</p>
<pre><code>thisisnumber1
itsraining
fluffydog
</code></pre>
<p>I would like it to remove the part in the parentheses for each string, but I do not know how sense the lengths are always changing. Thank You</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" rel="nofollow"><code>str.rsplit</code></a> for this:</p>
<pre><code>&gt;&gt;&gt; string1 = "thisisnumber1(111)"
&gt;&gt;&gt; string2 = "itsraining(22252)"
&gt;&gt;&gt; string3 = "fluffydog(3)"
&gt;&gt;&gt;
&gt;&gt;&gt; string1.rsplit("(")
['thisisnumber1', '111)']
&gt;&gt;&gt; string1.rsplit("(")[0]
'thisisnumber1'
&gt;&gt;&gt;
&gt;&gt;&gt; string2.rsplit("(")
['itsraining', '22252)']
&gt;&gt;&gt; string2.rsplit("(")[0]
'itsraining'
&gt;&gt;&gt;
&gt;&gt;&gt; string3.rsplit("(")
['fluffydog', '3)']
&gt;&gt;&gt; string3.rsplit("(")[0]
'fluffydog'
&gt;&gt;&gt;
</code></pre>
<p><code>str.rsplit</code> splits the string from right-to-left rather than left-to-right like <code>str.split</code>.  So, we split the string from right-to-left on <code>(</code> and then retrieve the element at index <code>0</code> (the first element).  This will be everything before the <code>(...)</code> at the end of each string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your other option is to use regular expressions, which can give you more precise control over what you want to get.</p>
<pre><code>import re
regex = regex = r"(.+)\(\d+\)"

print re.match(regex, string1).groups()[0] #returns thisisnumber1
print re.match(regex, string2).groups()[0] #returns itsraining
print re.match(regex, string3).groups()[0] #returns fluffydog
</code></pre>
<p>Breakdown of what's happening:</p>
<p><code>regex = r"(.+)\(\d+\)"</code> is the regular expression, the formula for the string you're trying to find</p>
<p><code>.+</code> means match 1 or more character of any kind except newline</p>
<p><code>\d+</code> means match 1 or more digit</p>
<p><code>\(</code> and <code>\)</code> are the "(" and ")" characters</p>
<p>putting <code>.+</code> in parentheses puts that string sequence in a group, meaning that group of characters is one that you want to be able to access later on. We don't put the sequence <code>\(\d+\)</code> in a group because we don't care about those characters.</p>
<p><code>regex.match(regex, string1).groups()</code> gives every substring in <code>string1</code> that was part of a group. Since you only want 1 substring, you just access the 0th element.</p>
<p>There's a nice tutorial on regular expressions on Tutorial's Point <a href="http://www.tutorialspoint.com/python/python_reg_expressions.htm" rel="nofollow">here</a> if you want to learn more.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you say in a comment:</p>
<blockquote>
<p>"all that will be in the parentheses will be numbers"</p>
</blockquote>
<p>so you'll always have digits between your parens, I'd recommend taking a look at removing them with the regular expression module:</p>
<pre><code>import re

string1 = "thisisnumber1(111)"
string2 = "itsraining(22252)"
string3 = "fluffydog(3)"

strings = string1, string2, string3

for s in strings:
    s_replaced = re.sub(
        r'''
        \( # must escape the parens, since these are special characters in regex
        \d+ # one or more digits, 0-9
        \)
        ''', # this regular expression will be replaced by the next argument
        '', replace the above with an empty string
        s, # the string we're modifying
        re.VERBOSE) # verbose flag allows us to comment regex clearly
    print(s_replaced)
</code></pre>
<p>prints:</p>
<pre><code>thisisnumber1
itsraining
fluffydog
</code></pre>
</div>
<span class="comment-copy">Do you need to worry about, e.g., <code>"thishasparens(butnotanumber)"</code> or <code>"thishasunclosedparens(10"</code> or <code>"thishastwosets(10)(20)"</code> or <code>"thishasparens(123)thenmore(456)"</code> or anything else like that? If so, what do you want to do for each of those cases?</span>
<span class="comment-copy">Nope, all that will be in the parentheses will be numbers :)</span>
<span class="comment-copy">To ensure the the operation is only on the end of the string you might want to restrict to a single split to handle strings like <code>"flu(ffy)dog(3)"</code>, e.g. <code>rsplit("flu(ffy)dog(3)", 1)</code>.</span>
<span class="comment-copy">@mhawke: On the other hand, how do you know that <code>flu(ffy)dog</code> would be the desired output in that case, as opposed to <code>fludog</code> or <code>flu</code>? (That's why I asked the OP, who confirmed that none of these cases exist in his data, which means this answer is sufficient.)</span>
<span class="comment-copy">@abarnert : in retrospect, yes. OP did state replacing the end of the string and my suggestion restricts it to that without assuming that the data does not contain any additional left parens.</span>
