<div class="post-text" itemprop="text">
<p>My python script gets and sends words over a serial line.
Each word is a <strong>signed 24-bit value</strong>, received as <strong>hex string</strong>.
The script should now take these strings and convert them to <strong>integers</strong>, do some calculations on it, and send them back in the same format.
My problem is, how to do this conversion</p>
<pre><code>Examples

Rx string -&gt; calc int
 012345   -&gt;  74565
 fedcba   -&gt; -74566

calc int -&gt; Tx string
  74565  -&gt; 012345
 -74566  -&gt; fedcba
</code></pre>
<p>How can this be done?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def str_to_int(s):
    i = int(s, 16)
    if i &gt;= 2**23:
        i -= 2**24
    return i

def int_to_str(i):
    return '%06x'%((i+2**24)%2**24)
</code></pre>
<p>Test results:</p>
<pre><code>In [36]: str_to_int('012345')
Out[36]: 74565

In [37]: str_to_int('fedcba')
Out[37]: -74566

In [38]: int_to_str(74565)
Out[38]: '012345'

In [39]: int_to_str(-74566)
Out[39]: 'fedcba'
</code></pre>
<p>Reference: <a href="https://stackoverflow.com/questions/6727875/hex-string-to-signed-int-in-python-3-2">Hex string to signed int in Python 3.2?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>(Edit: An oversight on my part. See <a href="https://stackoverflow.com/a/26283443/923794">Rob's answer</a> for correctly covering the negative sign numbers)</p>
<p>If you just want to convert a hex string into an int, do e.g.:</p>
<pre><code>&gt;&gt;&gt; int('0xff', 16)
255
&gt;&gt;&gt; int('0xdaad', 16)
55981
</code></pre>
<p>The reverse can be done with the <code>hex()</code> function. From the help page:</p>
<p>Help on built-in function hex in module builtins:</p>
<pre><code>&gt;&gt;&gt; help(hex)
hex(...)
    hex(number) -&gt; string

    Return the hexadecimal representation of an integer.

       &gt;&gt;&gt; hex(3735928559)
       '0xdeadbeef'
</code></pre>
<p>It should be trivial to remove or add the '0x' if it's missing in your data stream.
Here's an example to ensure padding to 6 chars (representing 3 bytes = 24 bits):</p>
<pre><code>&gt;&gt;&gt; '0x' + hex(255)[2:].rjust(6, '0')
'0x0000ff'
</code></pre>
<p>If you get the data in 3 byte form (24 bits), you can use <code>int.to_bytes()</code> and <code>int.from_bytes()</code> as described in <a href="https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types" rel="nofollow noreferrer">the Python docs</a>. This is new in Python 3.2.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>$ pip install bitstring
</code></pre>
<p>Then:</p>
<pre><code>from bitstring import BitStream
s1 = BitStream('0x012345')
s1.int # 74565
s2 = BitStream(int=-74565, length=24)
s2.hex # fedcbb
</code></pre>
</div>
<span class="comment-copy">Please confirm: the serial data is six bytes of <code>'0'</code>-padded text in the range <code>0-9a-fA-F</code>. It is not 3-bytes of binary data. Is that correct?</span>
<span class="comment-copy">Can your <b>Task Definition</b> also explicitly confirm any form of a lower-level serial line-code protocol present ( data-bits, stop-bits, parity, CRC, framing, HDB3-transmission-line-code-protection et al)?</span>
<span class="comment-copy">@Robᵩ: correct.</span>
<span class="comment-copy">@user3666197: there is another part of the software which treats the low level stuff, my part only gets/sets the 6 char string</span>
<span class="comment-copy">"<i>there is another part of the software which treats the low level stuff</i>" - that makes much more sense. It seemed unlikely that hardware guys would design a serial line protocol like you described.</span>
<span class="comment-copy">Thanks @Robᵩ, works flawlessly!</span>
<span class="comment-copy">I marked the answer of @Robᵩ, because his solution does not need installing a module.</span>
