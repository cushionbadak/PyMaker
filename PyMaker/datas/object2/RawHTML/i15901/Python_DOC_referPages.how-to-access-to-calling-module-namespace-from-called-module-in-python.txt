<div class="post-text" itemprop="text">
<p>I made a tiny sql renderer/wrapper for SQLite. The main idea is to write:</p>
<pre><code>execute( 'select * from talbe1 where col1={param1} and col2={param2}' )
</code></pre>
<p>instead of</p>
<pre><code>execute( 'select * from table1 where col1=? and col2=?', (param1,param2) )
</code></pre>
<p>Here is the code:</p>
<pre><code>import re
import sqlite3

class SQLWrapper():
    def __init__(self, cursor):
        self.cursor = cursor
    def execute(self, sql):
        regexp=re.compile(r'\{(.+?)\}')
        sqlline = regexp.sub('?',sql)
        statements = regexp.findall(sql)
        varlist = tuple([ eval(_statement) for _statement in statements ])
        self.cursor.execute(sqlline, varlist)
        return self
    def fetchall(self):
        return self.cursor.fetchall()

#usage example
db = sqlite3.connect(':memory:')
cursor = db.cursor()

wrap = SQLWrapper(cursor)

wrap.execute('create table t1(a,b)')
for i in range(10):
    wrap.execute('insert into t1(a,b) values({i}, {i*2})')

limit = 50
for line in wrap.execute('select * from t1 where b &lt; {limit}').fetchall():
    print line
</code></pre>
<p>It works, but when I move the class <code>SQLWrapper</code> to a separate module (file sqlwrap.py) and import it, the program crashes with:</p>
<pre><code>Traceback (most recent call last):
  File "c:\py\module1.py", line 15, in &lt;module&gt;
    wrap.execute('insert into t1(a,b) values({i}, {i*2})')
  File "c:\py\sqlwrap.py", line 10, in execute
    varlist = tuple([ eval(_statement) for _statement in statements ])
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name 'i' is not defined
</code></pre>
<p>I.e. variable i is not visible from the other module. How to overcome this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This goes against normal scope rules of most programming languages.</p>
<p>Normally you don't want that functions (or methods) that you call somehow magically do things with your own variables. That means, that only those variable values (!) are accessible to the called routine, which you explicitly added as parameter.</p>
<p>When you in your first code (all in one module) move your for loop with the i into an own function will run into the same problem -- than i will be local to this function and not visible to SQLwrapper.</p>
<p>Scope rules intentionally limit the access of variables to those which are "in scope" and don't give access to things that are "out of scope". Thus some information hiding is done and complexity is reduced.</p>
<p>This implies some writing overhead in some situations, but also makes the programs more save by inhibiting some dangerous practices and complexity.</p>
<p>I would recommend something like that, when you only intend to use SQLite (or MySQL):</p>
<pre><code>execute( 'select * from table1 where col1=@param1 and col2=@param2', {'param1': param1, 'param2': param2} )
</code></pre>
<p>Thus you have a more readable and understandable version, but without the scope problems you encountered. The @-prefix works on SQLite and as much I know, also in MySQL -- but it is DB specific (sadly, SQL did not standardize it). In the documentation for the sqlite3-module an other prefix is used ':' this also works in SQLite, but I don't know on which other DB.</p>
<p>See: <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.execute" rel="nofollow">sqlite3.Cursor.execute documentation</a></p>
<p>BTW, if you want to reduce your writing overhead a little bit, you could write some wrapper like that:</p>
<pre><code>def myExcecute(sql, **params):
   self.cursor.execute(sql, params)
</code></pre>
<p>Thus you can call execute with a little less overhead (and less brackets):</p>
<pre><code>myExecute( 'select * from table1 where col1=@param1 and col2=@param2', param1=param1, param2=param2 )
</code></pre>
</div>
