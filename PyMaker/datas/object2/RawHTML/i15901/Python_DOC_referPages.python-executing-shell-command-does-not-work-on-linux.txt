<div class="post-text" itemprop="text">
<p>I like to run a shell command from Python on my Linux Mint system.
Specifically the command runs all Bleachbit cleaners and works perfectly
fine when run maually.</p>
<p>Yet, trying to run the same command via the subprocess.call module
always results in an exception raised.</p>
<p>I just can not see why it should not work.
The command does not require sudo rights, so not requiring
right not given.</p>
<p>I also have firefox/browsers closed when executing the python command.</p>
<p>Anybody, any suggestions how to fix this issue?</p>
<p>My code:</p>
<pre><code>try:
    subprocess.call('bleachbit -c firefox.*') 
except:
    print "Error."
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow"><code>subprocess</code> module</a> does not run the shell by default therefore the shell wildcards (globbing patterns) such as <code>*</code> are not expanded. You could use <code>glob</code> to expand it manually:</p>
<pre><code>#!/usr/bin/env python
import glob
import subprocess

pattern  = 'firefox.*'
files = glob.glob(pattern) or [pattern]
subprocess.check_call(["bleachbit", "-c"] + files)
</code></pre>
<p>If the command is more complex and you have full control about its content then you could use <code>shell=True</code> to run it in the shell:</p>
<pre><code>subprocess.check_call("bleachbit -c firefox.*", shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When shell is False you need to pass a list of args:</p>
<pre><code>import subprocess
try:
    subprocess.call(["bleachbit", "-c","firefox.*"])
except:
    print ("Error.")
</code></pre>
</div>
<span class="comment-copy">You don't have a file named <code>firefox.*</code> on your system. When ran manually, your shell takes care of wildcard expansion, but subprocess.call uses no shell by default, and takes an array of strings rather than one space-separated string.</span>
<span class="comment-copy"><code>subprocess.call</code> takes an <i>array</i> according to <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">the docs</a>, and can have a <code>shell=True</code> argument. (not a Python expert so commenting, not answering)</span>
<span class="comment-copy">don't use bare <code>expect:</code> it might catch too much e.g., <code>KeyboardInterrupt</code></span>
<span class="comment-copy">Setting, shell=True did the trick for me. While the first solution gives an error message. Good to know the intricacies of using subprocess. I should have been able to find it via the docs myself, yet was expecting something more complicated to be the issue.</span>
<span class="comment-copy">Check the list returned by the glob call. Is it empty? I've updated the answer, to pass the wildcard as is if there are no corresponding files</span>
<span class="comment-copy">You can pass it a string as well.  If you have shell=true, you must pass it a string.</span>
<span class="comment-copy">@PaulBecotte, <code>shell=True</code> is usually best avoided</span>
<span class="comment-copy"><code>"*"</code> wildcard is expanded by the shell i.e., it is not expanded in your example.</span>
<span class="comment-copy">Both answers work. Yet, I think Sebastian's answer to be most elegant (from my beginner's perspective), not requiring to hack the string into pieces, which can become nasty for long commands, Padraic. Why would one want to avoid shell = True?</span>
<span class="comment-copy">@JohnSlathon, have a look at the warning in this page <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
