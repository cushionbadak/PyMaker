<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6893968/how-to-get-the-return-value-from-a-thread-in-python">how to get the return value from a thread in python?</a>
<span class="question-originals-answer-count">
                    21 answers
                </span>
</li>
</ul>
</div>
<p>I'd like to create a multi-threaded version of a function. I discover <code>t.start()</code> returns <code>None</code>, so I have to use queue.
I searched the documentation, but I don't understand how to use it in my example.</p>
<p>This is the function:</p>
<pre><code>def derivative(lst, var):  # Example of lst =  [1 + [3 * x]]
    if len(lst) == 1:       
        return derive_solver(lst[0], var)

    if lst[1] == '+':
        return [derivative(lst[0], var), '+', derivative(lst[2], var)]

    if lst[1]  == '*':
        return [[derivative(lst[0], var), '*', lst[2]], '+', [lst[0], '*', derivative(lst[2], var)]]
</code></pre>
<p>And this my attempt to multi-thread that function:</p>
<pre><code>def derivative(lst, var):  # Example of lst =  [1 + [3 * x]]
    if len(lst) == 1:       
        return derive_solver(lst[0], var)

    if lst[1] == '+':
        t1 = threading.Thread(target = derivative,  args=(lst[0], var))
        t2 = threading.Thread(target = derivative,  args=(lst[2], var))
        return [t1.start(), '+', t2.start()]

    if lst[1]  == '*':
        t1 = threading.Thread(target = derivative,  args=(lst[0], var))
        t2 = threading.Thread(target = derivative,  args=(lst[2], var))
        return [[t1.start(), '*', lst[2]], '+', [lst[0], '*', t2.start()]] 
</code></pre>
<p>The problem is that <code>t1.start(</code>) doesn't return values...</p>
<p>Have you any idea how to solve this using queue?</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The problem is that <code>t1.start()</code> doesn't return values...</p>
</blockquote>
<p>Of course not. <code>t1</code> hasn't finished at this point. If <code>start</code> waited for the background thread to finish, there would be absolutely no reason to use threads in the first place.</p>
<p>You need to set things up so the background threads post their work somewhere and signal you that they're done, then wait until both threads have signaled you. A queue is one way to do that. So is a shared variable plus a <code>Condition</code>. Or, in this case, just a shared variable plus <code>join</code>ing the thread. But I'll show one way to do it with a queue, since that's what you asked for:</p>
<pre><code>def enthread(target, args):
    q = queue.Queue()
    def wrapper():
        q.put(target(*args))
    t = threading.Thread(target=wrapper)
    t.start()
    return q

q1 = enthread(target = derivative,  args=(lst[0], var))
q2 = enthread(target = derivative,  args=(lst[2], var))
return [q1.get(), '+', q2.get()]
</code></pre>
<p>What I did there is to create a queue, pass it into the target function for the background thread (which wraps the <em>real</em> target function), and have the background thread put its result on the queue. Then, the main thread can just wait on the queue.</p>
<p>Note that this isn't <code>join</code>ing each thread, which can be a problem. But hopefully you can see how to expand on the code to make it more robust.</p>
<p>Also note that we're explicitly waiting for thread 1 to finish before checking on thread 2. In a situation where you can't do anything until you have all the results anyway, that's fine. But in many applications, you'll want a <em>single</em> queue, so you can to pick up the results as they come in (tagging the values in some way if you need to be able to reconstruct the original order).</p>
<hr/>
<p>A much better solution is to use a higher-level abstraction, like a thread pool or a future (or an executor, which combines both abstractions into one). But it's worth understanding how these pieces work first, then learning how to do things the easy way. So, once you understand why this works, go read the docs on <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow"><code>concurrent.futures</code></a>.</p>
<hr/>
<p>Finally, assuming you're using CPython or another GIL-based implementation—which you probably are—and that <code>derive_solver</code> function isn't a C extension function explicitly designed to do most of its work without the GIL, this isn't going to be a good idea in the first place. Threads are great when you need concurrency without parallelism (because your code is simpler that way, or because it's I/O bound), but when you're actually trying to benefit from multiple cores, they aren't the answer, because only one thread can run the interpreter at the time. Use <code>multiprocessing</code> (or just <code>concurrent.futures.ProcessPoolExecutor</code> instead of <code>concurrent.futures.ThreadPoolExecutor</code>) if you need parallelism. </p>
</div>
<span class="comment-copy">You code example is confusing. Why is <code>return</code> outside of the function?</span>
<span class="comment-copy">@minerals: This example is a fragment of the code that goes inside the OP's derivative function. All of it, including the local <code>enthread</code> definition. (Since <code>enthread</code> doesn't need to close over any locals here, you could move it out to the top level if you wanted to reuse it, but leaving it here avoids polluting the namespace with a function that you aren't going to reuse otherwise.)</span>
<span class="comment-copy">Thread's without a return it's near to useless and a waste of coffe loops. I've spent so much coffe on determine that use queue it's a must for serious coding. I've tried to make some shortcuts but after all you should use queue or an external method, wich would be slower for sure.</span>
<span class="comment-copy"><code>queue.Queue</code> is not really needed. A simple <code>[]</code> would do.</span>
