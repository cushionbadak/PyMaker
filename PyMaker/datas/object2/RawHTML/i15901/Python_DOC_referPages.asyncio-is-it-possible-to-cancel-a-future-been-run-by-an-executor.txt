<div class="post-text" itemprop="text">
<p>I would like to start a blocking function in an Executor using the asyncio call loop.run_in_executor and then cancel it later, but that doesn't seem to be working for me.</p>
<p>Here is the code:</p>
<pre><code>import asyncio
import time

from concurrent.futures import ThreadPoolExecutor


def blocking_func(seconds_to_block):
    for i in range(seconds_to_block):
        print('blocking {}/{}'.format(i, seconds_to_block))
        time.sleep(1)

    print('done blocking {}'.format(seconds_to_block))


@asyncio.coroutine
def non_blocking_func(seconds):
    for i in range(seconds):
        print('yielding {}/{}'.format(i, seconds))
        yield from asyncio.sleep(1)

    print('done non blocking {}'.format(seconds))


@asyncio.coroutine
def main():
    non_blocking_futures = [non_blocking_func(x) for x in range(1, 4)]
    blocking_future = loop.run_in_executor(None, blocking_func, 5)
    print('wait a few seconds!')
    yield from asyncio.sleep(1.5)

    blocking_future.cancel()
    yield from asyncio.wait(non_blocking_futures)



loop = asyncio.get_event_loop()
executor = ThreadPoolExecutor(max_workers=1)
loop.set_default_executor(executor)
asyncio.async(main())
loop.run_forever()
</code></pre>
<p>I would expect the code above to only allow the blocking function to output:</p>
<pre><code>blocking 0/5
blocking 1/5
</code></pre>
<p>and then see the output of the non blocking function. But instead the blocking future continues on even after I have canceled.</p>
<p>Is it possible? Is there some other way of doing it?</p>
<p>Thanks</p>
<p><strong>Edit:</strong> More discussion on running blocking and non-blocking code using asyncio: <a href="https://stackoverflow.com/questions/23898363/how-to-interface-blocking-and-non-blocking-code-with-asyncio">How to interface blocking and non-blocking code with asyncio</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In this case, there is no way to cancel the <code>Future</code> once it has actually started running, because you're relying on the behavior of <code>concurrent.futures.Future</code>, and <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.cancel">its docs state the following</a>:</p>
<blockquote>
<p><strong><code>cancel()</code></strong></p>
<p>Attempt to cancel the call. <strong>If the call is currently being executed
  and cannot be cancelled then the method will return <code>False</code></strong>, otherwise
  the call will be cancelled and the method will return <code>True</code>.</p>
</blockquote>
<p>So, the only time the cancellation would be successful is if the task is still pending inside of the <code>Executor</code>. Now, you're actually using an <code>asyncio.Future</code> wrapped around a <code>concurrent.futures.Future</code>, and in practice the <code>asyncio.Future</code> returned by <code>loop.run_in_executor()</code> will raise a <code>CancellationError</code> if you try to <code>yield from</code> it after you call <code>cancel()</code>, even if the underlying task is actually already running. But, it won't <em>actually</em> cancel the execution of the task inside the <code>Executor</code>.</p>
<p>If you need to actually cancel the task, you'll need to use a more conventional method of interrupting the task running in the thread. The specifics of how you do that is use-case dependent. For the use-case you presented in the example, you could use a <code>threading.Event</code>:</p>
<pre><code>def blocking_func(seconds_to_block, event):
    for i in range(seconds_to_block):
        if event.is_set():
            return
        print('blocking {}/{}'.format(i, seconds_to_block))
        time.sleep(1)

    print('done blocking {}'.format(seconds_to_block))


...
event = threading.Event()
blocking_future = loop.run_in_executor(None, blocking_func, 5, event)
print('wait a few seconds!')
yield from asyncio.sleep(1.5)

blocking_future.cancel()  # Mark Future as cancelled
event.set() # Actually interrupt blocking_func
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As threads share the same memory address space of a process, there is no safe way to terminate a running thread. This is the reason why most programming languages do not allow to kill running threads (there are lots of ugly hacks around this limitation).</p>
<p>Java learnt it the <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html" rel="nofollow noreferrer">hard way</a>.</p>
<p>A solution would consist in running your function in a separate process instead of a thread and terinate it gracefully.</p>
<p>The <a href="https://pypi.python.org/pypi/Pebble" rel="nofollow noreferrer">Pebble</a> library offers an interface similar to <code>concurrent.futures</code> supporting running <code>Futures</code> to be cancelled.</p>
<pre><code>from pebble import ProcessPool

def function(foo, bar=0):
    return foo + bar

with ProcessPool() as pool:
    future = pool.schedule(function, args=[1])

    # if running, the container process will be terminated 
    # a new process will be started consuming the next task
    future.cancel()  
</code></pre>
</div>
<span class="comment-copy">Thanks for the reply. The solution you suggest sounds good for solving this case.  My issue is that the blocking_func is in a 3rd party in my real life case.  I am going to wait for a day or two to see if anyone has any further suggestions; otherwise I will mark your answer as accepted.</span>
<span class="comment-copy">Do you know how can I add a callback to the blocking_func on completion?</span>
<span class="comment-copy">@Luis <code>blocking_future.add_done_callback(callback)</code></span>
<span class="comment-copy">I confirm this works (in my case with aiohttp)</span>
<span class="comment-copy">The link to Pebble is actually the same as the "hard way" link.</span>
<span class="comment-copy">Fixed the issue, thanks!</span>
