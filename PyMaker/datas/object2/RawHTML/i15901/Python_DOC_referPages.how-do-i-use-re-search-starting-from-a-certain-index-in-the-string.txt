<div class="post-text" itemprop="text">
<p>Seems like a simple thing but I'm not seeing it. How do I start the search in the middle of a string?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/re.html#re.search" rel="noreferrer"><code>re.search</code></a> function doesn't take a <code>start</code> argument like the <code>str</code> methods do. But <a href="https://docs.python.org/3/library/re.html#regular-expression-objects" rel="noreferrer"><code>search</code></a> method of a compiled <code>re.compile</code>/<code>re.RegexObject</code> pattern <em>does</em> take a <code>pos</code> argument.</p>
<p>This makes sense if you think about it. If you really need to use the same regular expressions over and over, you probably <em>should</em> be compiling them. Not so much for efficiency—the cache works nicely for most applications—but just for readability.</p>
<hr/>
<p>But what if you need to use the top-level function, because you can't pre-compile your patterns for some reason?</p>
<p>Well, there are plenty of third-party regular expression libraries. Some of these wrap PCRE or Google's RE2 or ICU, some implement regular expressions from scratch, and they all have at least slightly different, sometimes radically different, APIs.</p>
<p>But the <a href="https://pypi.python.org/pypi/regex/" rel="noreferrer"><code>regex</code></a> module, which is being designed to be an eventual replacement for <code>re</code> in the stdlib (although it's been bumped a couple times now because it's not quite ready) is pretty much usable as a drop-in replacement for <code>re</code>, and (among other extensions) it takes <code>pos</code> and <code>endpos</code> arguments on its <code>search</code> function.</p>
<hr/>
<p>Normally, the most common reason you'd want to do this is to "find the next match after the one I just found", and there's a much easier way to do that: use <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="noreferrer"><code>finditer</code></a> instead of <code>search</code>. </p>
<p>For example, this str-method loop:</p>
<pre><code>i = 0
while True:
    i = s.find(sub, i)
    if i == -1:
        break
    do_stuff_with(s, i)
</code></pre>
<p>… translates to this much nicer regex loop:</p>
<pre><code>for match in re.finditer(pattern, s):
    do_stuff_with(match)
</code></pre>
<hr/>
<p>When that isn't appropriate, you can always slice the string:</p>
<pre><code>match = re.search(pattern, s[index:])
</code></pre>
<p>But  that makes an extra copy of half your string, which could be a problem if <code>string</code> is actually, say, a 12GB <code>mmap</code>. (Of course for the 12GB <code>mmap</code> case, you'd probably want to map a new window… but there are cases where that won't help.)</p>
<hr/>
<p>Finally, you can always just modify your pattern to skip over <code>index</code> characters:</p>
<pre><code>match = re.search('.{%d}%s' % (index, pattern), s)
</code></pre>
<p>All I've done here is to add, e.g., <code>.{20}</code> to the start of the pattern, which means to match exactly 20 of any character, plus whatever else you were trying to match. Here's a simple example:</p>
<pre><code>.{3}(abc)
</code></pre>
<p><img alt="Regular expression visualization" src="https://www.debuggex.com/i/LwxOs1hFga7Vg4gi.png"/></p>
<p><a href="https://www.debuggex.com/r/LwxOs1hFga7Vg4gi" rel="noreferrer">Debuggex Demo</a></p>
<p>If I give this <code>abcdefabcdef</code>, it will match the first <code>'abc'</code> after the 3rd character—that is, the second <code>abc</code>.</p>
<p>But notice that what it actually matches <code>'defabc'</code>. Because I'm using capture groups for my real pattern, and I'm not putting the <code>.{3}</code> in a group, <code>match.group(1)</code> and so on will work exactly as I'd want them to, but <code>match.group(0)</code> will give me the wrong thing. If that matters, you need lookbehind.</p>
</div>
<span class="comment-copy">Can't you just do:  <code>re.search(regex, your_string[index:], ...)</code>?</span>
<span class="comment-copy">Or, if you don't want to copy a giant string, <code>re.search('.{%d}%s'%(index, pattern), string)</code>.</span>
<span class="comment-copy">Yeah, I definitely don't want to be copying the string. I don't completely understand that example, though - could you explain why it works?</span>
<span class="comment-copy">@Pineapple: OK, I've written it as an answer to explain it.</span>
<span class="comment-copy">@Pineapple: don't optimize prematurely. If (after you measure it) the <code>your_string[index:]</code> is indeed a bottleneck in your application then you could think about ways to optimize it e.g., <code>buffer(your_string, index)</code> could be used to avoid copying (Python 2, bytestrings). <code>re.compile(regex).search(your_string, index)</code> (<a href="http://stackoverflow.com/a/26434675/4279">suggested by @abarnert</a>) should work in this particular case.</span>
<span class="comment-copy">If I do that, won't it keep recompiling the expression? I don't think finditer would be suitable. I have a list of expressions and I want to see which of them match the current position in a string. Then I record that info, jump to the end of the longest match, and try again, and repeat until end of string. Why doesn't python's module include this functionality? Never struck me as something that should be missing in any implementation.</span>
<span class="comment-copy">It could potentially be, yeah. The strings would be large and there would be many of them. PCRE has a start parameter, I never thought that would be unique to it.</span>
<span class="comment-copy">This is how I intend to use it: <a href="http://pastebin.com/M0wBCkz8" rel="nofollow noreferrer">pastebin.com/M0wBCkz8</a></span>
<span class="comment-copy">Ah, awesome, if regex can do that then it's probably what I want to be using. Thanks much for all the info you gave, by the way.</span>
<span class="comment-copy">@Pineapple: Hold on, even simpler answer…</span>
