<div class="post-text" itemprop="text">
<p>What is the best method for testing a method that looks like this</p>
<pre><code>class Foo(object):

   is_running = False
   def run(self):
       self.is_running = True
       while self.is_running:
           do_some_work()
</code></pre>
<p>This is pretty standard code for a consumer, do work while the <code>is_running</code> flag is set.</p>
<p>But this is difficult to test because it's going to enter the loop and never come out unless I create a second thread to change <code>is_running</code> to false. </p>
<p>Are there any good strategies for testing this without spinning up a separate thread to run the code?</p>
<p>I haven't seen anything but I am thinking maybe the mock library would provide functionality that can return a <code>[True, True, False]</code> each time <code>is_running</code> is read but would that require me to change <code>is_running</code> from a member variable to a property or a method?</p>
</div>
<div class="post-text" itemprop="text">
<p>As I mentioned in the comments, I think testing this method using threads is a perfectly viable approach, and probably the best solution. However, if you really want to avoid threads, you could convert <code>is_running</code> to a <code>property</code> and then use <a href="http://www.voidspace.org.uk/python/mock/mock.html#mock.PropertyMock" rel="nofollow"><code>mock.PropertyMock</code></a> to mock the <code>property</code>:</p>
<pre><code>import mock
import time

class Foo(object):

   def __init__(self):
       self._is_running = False

   @property
   def is_running(self):
       return self._is_running

   @is_running.setter
   def is_running(self, val):
       self._is_running = val 

   def run(self):
       self._is_running = True  # Don't go through the property here.
       while self.is_running:
           print("in here")
           time.sleep(.5)


with mock.patch('__main__.Foo.is_running', new_callable=mock.PropertyMock,
                side_effect=[True, True, False]) as m:
    f = Foo()
    f.run()
</code></pre>
<p>Output:</p>
<pre><code>in here
in here
&lt;done&gt;
</code></pre>
<p>I would say that changing your production implementation this much just to enable a specific method of testing is not worth it, though. Just have your test function create a thread to set <code>is_running</code> after some period of time.</p>
</div>
<span class="comment-copy">perhaps you can use <code>subprocess.Popen.wait()</code>...</span>
<span class="comment-copy">Why not replace it with a full descriptor instead of just a property?</span>
<span class="comment-copy">why not use coroutines: <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html</a></span>
<span class="comment-copy">Try <code>threading.Timer</code> - it spins up the thread for you. This object looks like its supposed to run in a separate thread anyway, so unit testing it that way seems normal to me.</span>
<span class="comment-copy">I'm with @tdelaney - if the class is designed to be used in conjunction with another thread, why not test it that way? Creating a thread to use for this sort of test would only take a few lines of code, so its not like it adds a ton of overhead.</span>
