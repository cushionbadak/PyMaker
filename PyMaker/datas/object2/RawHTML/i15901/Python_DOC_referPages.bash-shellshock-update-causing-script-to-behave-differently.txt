<div class="post-text" itemprop="text">
<p>This is one of the things that happened since we've updated our bash ( due to the Shellshock thing )</p>
<p>This is the code that I'm testing:</p>
<pre><code>#!/usr/bin/python2.4
import subprocess, os
    p = subprocess.Popen(
            cmd,        
            shell = True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE
        )
        out, err = p.communicate()

        print "out:", out
        print "err:", er
</code></pre>
<p>First running the command:</p>
<pre><code>cmd = "cd /home/me/; pwd; p4 client -o"
out: /home/me/
err:
perforce client that is NOT mine ( some kind of a default template is trying to be used here )
</code></pre>
<p>The second test, I add the following Python args:</p>
<pre><code>env = os.environ.copy()
# and add "env" variable to the Popen command after "cmd, like:
env = env,
</code></pre>
<p>Output:</p>
<pre><code>cmd = "cd /home/me/; pwd; p4 client -o"
out: /home/me/
err:
my perforce client information - as it should.
</code></pre>
<p>My question is,
I can't seem to understand why "env = env," mattered here.
I tried running several commands such "export" etc to understand the different between with/without it - but the results are the same, also checked the "shell" both uses "sh". so I'm not really sure which part of the environment causing it not to work as example #1.</p>
<p>I'm sure it's not really related to the Perforce itself, Perforce just probably needed some environment variables that somehow were affected due to this bash Shellshock thing.</p>
<h1>EDIT - clarifying @5gon12eder suggestion</h1>
<p>I tried reviewing the ENV without "env=env," ( which was an os.environ.copy() ), </p>
<pre><code># 1
# The outouput is wrong ( generic Perforce views )
cd /home/me/; pwd; p4 client -o

# 2 - manually adding P4CONFIG
# The outouput is *correct*
cd /home/me/; pwd; P4CONFIG='.perforce'; p4 client -o


# But the environment variable looks like is there with the correct information ( can't paste it here )
subprocess.call("env") | grepping the script's output P4
&gt; P4CONFIG=...
&gt; P4PORT=...
&gt; P4USER ...
</code></pre>
<p>Note, that the P4 variables are configured twice:</p>
<pre><code>/etc/profile
/home/me/.bash_profile
</code></pre>
<h1>EDIT 2 - reproducing with Perl as well:</h1>
<p>The environment ignore the P4CONFIG entry in %ENV.</p>
<pre><code>#!/usr/bin/perl -w

use strict;
use Data::Dumper;

my $dir = "/home/me/";
my $cmd1 = "cd $dir; p4 client -o";
my $cmd2 = "cd $dir; P4CONFIG='.perforce'; p4 client -o";

# Scenario 1 - does NOT work ! $ENV does have P4CONFIG with a correct value.  
`$cmd1`;
# ** still wrong result - generic Perforce views

# Scenario 2 - adding P4CONFIG= to the command:
`$cmd2`;
# Correct result - my .perforce client's views.

# Scenario 3 - Adding to the ENV P4CLIENT ( which does not exists in %ENV )
$ENV{'P4CLIENT'} = "my_client_name";
`$cmd1`;    # The one without the P4CONFIG enforcement. - WORK.
</code></pre>
<h1>EDIT 3 - There's a difference if I use/don't use &gt;&gt; and |</h1>
<p>Actually, when thinking about it, the whole problem was introduced when one of my libs had a "&gt; /dev/null" redirect in the subprocess ( Python ) "cmd" example above which caused the script to hang and exit on timeout, I replaced it with "-o file-output" and the problem was gone, but then I fell into this issue so I opened this post.</p>
<pre><code># I already found that adding this row - solving the ENV thing ( not really solving ... but )
$ENV{'P4CONFIG'} = ".perforce";

# Work, I see the excepted output
my $bla = `p4 client -o`;

# Doesn't work, script hangs and Perforce exit with a timeout ( like a P4PORT missing error )
# (I was just trying to remove all the comments-junk )
my $bla = `p4 client -o | grep -v '^#'`;

# Script doesn't hang for example if I just "echo"
my $bla = `echo 'p4 client bla bla' | grep -v '^#'`;
</code></pre>
<p>Just wanting to say again, that it was all working before the shellshock thing ( may a realted or maybe a coincidence ) but something is different in the environment of the exec() calls...
Any ideas ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Is your code modifying the environment?  The thing is that</p>
<pre class="lang-python prettyprint-override"><code>os.putenv('VAR', 'VAL')
</code></pre>
<p>(potentially) modifies the environment directly but does not update <code>os.environ</code> whereas </p>
<pre class="lang-python prettyprint-override"><code>os.environ['VAR'] = 'VAL'
</code></pre>
<p>does.  From the <a href="https://docs.python.org/3/library/os.html#os.environ" rel="nofollow">Python documentation</a>:</p>
<blockquote>
<p>Calling <code>putenv()</code> directly does not change <code>os.environ</code>, so it's better to modify <code>os.environ</code>.</p>
<p>If <code>putenv()</code> is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment.</p>
</blockquote>
<p>What becomes not so clear from this documentation but after reading the somewhat obscure source code of the <code>os</code> Python module and the accompanying <code>posixmodule</code> C module is that if the C library of the underlying platform does not have the <a href="http://linux.die.net/man/3/putenv" rel="nofollow"><code>putenv(3)</code></a> C function, then setting keys in <code>os.environ</code> only affects the Python dictionary and <code>os.putenv</code> is a no-op.  From <code>Lib/os.py</code>:</p>
<pre class="lang-python prettyprint-override"><code>try:
    _putenv = putenv
except NameError:
    _putenv = lambda key, value: None
else:
    if "putenv" not in __all__:
        __all__.append("putenv")
</code></pre>
<p>And from <code>Modules/posixmodule.c</code>:</p>
<pre class="lang-c prettyprint-override"><code>static PyMethodDef posix_methods[] = {
  /* Lots and lots of code skipped... */
#ifdef HAVE_PUTENV
  {"putenv", posix_putenv, METH_VARARGS, posix_putenv__doc__},
#endif
  /* Even more code skipped... */
};
</code></pre>
<p>Therefore, you can observe different behavior in the two situations you show since – much to my surprise – if <code>env=None</code> is passed to the <code>subprocess.Popen</code> constructor, it does <em>not</em> substitute <code>os.environ</code> as a default, but uses the value from the C standard library.</p>
<p>The code to set up the environment for the child process (in <code>Lib/subprocess.py</code>) is</p>
<pre class="lang-python prettyprint-override"><code>if env is not None:
    env_list = [os.fsencode(k) + b'=' + os.fsencode(v)
                for k, v in env.items()]
    else:
        env_list = None  # Use execv instead of execve.
</code></pre>
<p>and did not change recently.  And from the man page of <a href="http://linux.die.net/man/3/exec" rel="nofollow"><code>exec(3)</code></a> (emphasis mine):</p>
<blockquote>
<p>The <code>execle()</code> and <code>execvpe()</code> functions allow the caller to specify the environment of the executed program via the argument envp.  The <code>envp</code> argument is an array of pointers to null-terminated strings and must be terminated by a null pointer.  <strong>The other functions take the environment for the new process image from the external variable <code>environ</code> in the calling process.</strong></p>
</blockquote>
<p>I went into the source code of <code>Modules/_posixsubprocess.c</code> (for <code>execv</code> / <code>execve</code>) and <code>Modules/posixmodule.c</code> (for <code>putenv</code>) to check that they really call the system functions as described and from what I can tell, they appear to do so.  None of the two C modules has received a recent change that seems related to this functionality.</p>
<p>My fist idea after reading your question was that eventually, the Python developers have introduced a sanity-check for the environment passed to subprocesses but it does not seem they have.  Sorry if this is kind of a non-answer but I thought it might still prove useful to others to help them avoid diving into the CPython source code.</p>
<p>As a suggestion for further debugging, try running</p>
<pre class="lang-none prettyprint-override"><code>$ python -c "import os; import subprocess; os.putenv('VAR', 'VAL'); subprocess.call('env');" | grep VAR=
</code></pre>
<p>and various variations to track down what is going on.</p>
<p><strong>Footnote:</strong> I consider the behavior of <code>subprocess.Popen</code> more a bug than a feature since it makes Python code behave differently on platforms that provide or don't provide the <code>putenv</code> C function for no good reason.</p>
</div>
<div class="post-text" itemprop="text">
<p>So I wanted to share the findings with everyone, in case someone else will be stuck on this for a while.
The issue was, that we've had some exported functions in:</p>
<pre><code>/etc/profile
</code></pre>
<p>Which caused the environment to behave different after the bash patch was implemented.
Removing these functions solved the issue in all our scripts... and there were no changes needed for the environment variables anymore ..</p>
<p>Thanks everyone for trying to help !</p>
</div>
<span class="comment-copy">Perforce will indeed generate a default client spec if the named client spec does not exist. The most important environment variable in this context, then, is P4CLIENT. To observe if the setting of P4CLIENT is relevant to the behavior you see, trying modifying 'p4 client -o' to 'p4 -c &lt;clientname&gt; client -o', where '&lt;clientname&gt;' is the value of your P4CLIENT environment variable. The -c flag overrides the P4CLIENT value that p4 gets from the environment; see 'p4 help usage' for other similar flags you can use in place of env vars.</span>
<span class="comment-copy">Please try to produce a self-contained example, probably not using <code>p4</code>, that we could run which would demonstrate the same difference between using the default value of <code>env</code> and a copy of the environment.</span>
<span class="comment-copy">@bryan I have a .perforce file in the directory which i'm "cd" into, if I didn't said it before - the same "cmd" string - works if I copy paste it and run it through shell/bash as is.</span>
<span class="comment-copy">@chepner I tried, but I'm not sure what I can think of that without the ENV will not work ... I'll try it again today</span>
<span class="comment-copy">It sounds like your ".perforce" file is a P4CONFIG file, and contains Perforce configuration settings, such as your client name. That is, in your .perforce file, there is the line "P4CLIENT=&lt;clientname&gt;". This means that the most important external environment variable is P4CONFIG, which you must typically be setting to ".perforce".</span>
<span class="comment-copy">Note that you are citing code from the Python 3 version of <code>subprocess.py</code>; the OP is using Python 2.4. At least in Python 2.6, <code>subprocess</code> simply chooses between <code>execvp</code> and <code>execvpe</code>, rather than doing any handling of the environment itself.</span>
<span class="comment-copy">@chepner Well spotted; I have missed out on the OP's version number.  Now the OP's observation seems even stranger since in Python 2, <code>os.execvp</code> further calls <code>os._execvpe</code> with <code>env=None</code> and the latter function contains <code>if env is None: env = environ</code>.  At least, in Python 2.7 that is.  I'm afraid that my answer is a bit of pointless now…</span>
