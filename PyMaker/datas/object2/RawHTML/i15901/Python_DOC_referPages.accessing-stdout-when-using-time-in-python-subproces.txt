<div class="post-text" itemprop="text">
<p>I have been doing some manual benchmark tests in my shell using the <code>time</code> command. I would like to scale my benchmarks by writing a python script that both automates the tests and affords me access to the time data so that I can record it in the format of my choosing (likely a csv). I see there is the <code>timeit</code> module, but that seems like it is more for benchmarking python code, where what I am trying to benchmark here are programs run in the command line.</p>
<p>This is what I have been doing manually:</p>
<pre><code>time program -aflag -anotherflag
</code></pre>
<p>My initial attempt to implement this in a script looks like:</p>
<pre><code>cmnd = ['time', 'program', 'aflag', 'anotherflag']
p = subprocess.Popen(cmnd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = p.communicate
print out
print err
</code></pre>
<p>I can access the output of <code>time</code> just fine – this is delivered to stderr, however I am not getting <code>program</code>'s output as expected in stdout. If I remove <code>time</code> from <code>cmnd</code> and change <code>shell=False</code> to True, I then get the program's output in stdout – however obviously not <code>time</code>'s output, which is the whole point.</p>
<pre><code>cmnd = ['program', 'aflag', 'anotherflag']
p = subprocess.Popen(cmnd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = p.communicate
print out
print err
</code></pre>
<p>If I add <code>time</code> back to cmnd with <code>shell=True</code>, I get time's output but <code>program</code> doesn't actually run.</p>
<p>How can I get both working?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of trying to get this to work, why not use the functionality built into Python in the <a href="https://docs.python.org/2/library/resource.html" rel="nofollow"><code>resource</code></a> module?</p>
<pre><code>import resource
import subprocess

cmd = ['program', 'aflag', 'anotherflag']
p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = p.communicate()
usage = resource.getrusage(resource.RUSAGE_CHILDREN)
print out
print err
print usage.ru_utime, usage.ru_stime, usage.ru_utime+usage.ru_stime
</code></pre>
<hr/>
<p>If you need to distinguish different child processes running simultaneously, <code>getrusage</code> isn't obviously not sufficient. In that case, you need to use <a href="https://docs.python.org/3/library/os.html#os.wait4" rel="nofollow"><code>wait4</code></a> or similar to get per-process resource usage. This makes your use of <code>Popen</code> more complicated. What you'd probably want to do for this case is subclass or fork the <code>subprocess</code> code (but make sure to use <a href="https://pypi.python.org/pypi/subprocess32" rel="nofollow"><code>subprocess32</code></a> backport if you're on 3.1 or earlier to avoid the bugs in <code>communicate</code>—and so that the class actually has the method you want to hook…) and change <a href="https://hg.python.org/cpython/file/default/Lib/subprocess.py#l1510" rel="nofollow">the <code>_try_wait</code> method</a> to use <code>wait4</code> instead of <code>waitpid</code> and stash the extra results in, e.g., <code>self.rusage</code> so you can access it later.</p>
<p>I think something like this would work:</p>
<pre><code>import subprocess32

class Popen(subprocess32.Popen):
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts, rusage) = _eintr_retry_call(os.wait4, self.pid, wait_flags)
            if pid == self.pid:
                self.rusage = rusage
        except OSError as e:
            if e.errno != errno.ECHILD:
                raise
            pid = self.pid
            sts = 0
        return (pid, sts)

cmd = ['program', 'aflag', 'anotherflag']
p = Popen(cmd, shell=False, stdout=subprocess32.PIPE, stderr=subprocess32.PIPE)
out, err = p.communicate()
print out
print err
try:
    usage = p.rusage
except AttributeError:
    print 'Child died before we could wait on it, no way to get rusage'        
else:
    print usage.ru_utime, usage.ru_stime, usage.ru_utime+usage.ru_stime
</code></pre>
</div>
<span class="comment-copy">Please copy-paste an <b>actuall</b> short, standalone program that demonstrates your error. Please do not just type it in, but test it, run it, and copy-paste it. Thanks. See <a href="http://stackoverflow.com/help/mcve">stackoverflow.com/help/mcve</a></span>
<span class="comment-copy">the <code>time</code> command in shell doesn't show the result !! it just show the time <code>real</code> ,<code>os</code>,<code>user</code> !</span>
<span class="comment-copy">After fixing the syntax errors in your test program, and replacing your <code>cmnd</code> with <code>cmnd = ['time', 'ls', '-s', '-h']</code>, I get the correct results in both <code>out</code> and <code>err</code>. <a href="http://ideone.com/ALUs52" rel="nofollow noreferrer">This link</a> contains my program.</span>
<span class="comment-copy">so whats your program ? is it a python code ? or ... ?</span>
<span class="comment-copy">@Kasra: It's even worse than that; the program <code>/usr/bin/time</code> and the shell builtins named <code>time</code> in different shells are all different in what they do with the program's output and/or error, which makes it very confusing for novices to write code around the command…</span>
