<div class="post-text" itemprop="text">
<p>I am attempting to read from keyboard input without waiting for input. The purpose is to be used in an "infinite" loop ala while True:.</p>
<p>Thus far I've been trying to manipulate the readchar library <a href="https://pypi.python.org/pypi/readchar/0.6" rel="nofollow">https://pypi.python.org/pypi/readchar/0.6</a> , but with no luck. While it doesn't wait for Enter, it still waits for some input. I don't want it to wait for input, but simply to check and return "" or some placeholder if there is no input.</p>
<p>Here is what I've been working with:</p>
<pre><code>def readchar():
fd = sys.stdin.fileno()
old_settings = termios.tcgetattr(fd)
try:
    tty.setraw(sys.stdin.fileno())
    ch = sys.stdin.read(1)
finally:
    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
return ch

def main():
    while True:
        current = readchar()
        if current == "some letter":
            print("things happen")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The POSIX I/O functions that ultimately underlie Python's file objects have two different modes, blocking and non-blocking, controlled by a flag named <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html" rel="nofollow"><code>O_NONBLOCK</code></a>. In particular, the <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html" rel="nofollow"><code>read</code></a> function says:</p>
<blockquote>
<p>When attempting to read a file … that … has no data currently available … If <code>O_NONBLOCK</code> is set, <em>read()</em> shall return -1 and set <em>errno</em> to <code>[EAGAIN]</code>.</p>
</blockquote>
<p>In Python, this flag is available in the <a href="https://docs.python.org/3/library/os.html#os.O_NONBLOCK" rel="nofollow"><code>os</code></a> module.</p>
<hr/>
<p><code>sys.stdin</code> is already open, so you can't just pass <code>O_NONBLOCK</code> to the <code>os.open</code> function, so… what do you do? Well, you actually <em>might</em> want to open <code>/dev/tty</code> instead; it kind of depends on what you're actually doing. In that case, the answer is obvious. But let's assume that you don't. So, you want to change the flags of the already-open file. That's exactly what <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fcntl.html" rel="nofollow"><code>fcntl</code></a> is for. You use the <code>F_GETFL</code> operation to read the current flags, or in the bit for <code>O_NONBLOCK</code>, and <code>F_SETFL</code> the result. You can remember the current flags for later if you want to restore things, of course.</p>
<p>In Python, the <code>fcntl</code> function, and the operation constants, are available in the <a href="https://docs.python.org/3/library/fcntl.html#fcntl.fcntl" rel="nofollow"><code>fcntl</code></a> module.</p>
<hr/>
<p>One last problem: <code>sys.stdin</code> isn't a raw file object, it's a <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>TextIOWrapper</code></a> that does Unicode decoding on top of a <a href="https://docs.python.org/3/library/io.html#io.BufferedReader" rel="nofollow"><code>BufferedReader</code></a>, which itself adds buffering on top of a <a href="https://docs.python.org/3/library/io.html#io.FileIO" rel="nofollow"><code>FileIO</code></a>. So, <code>sys.stdin.read()</code> isn't directly calling the POSIX <code>read</code> function. In order to do that, you need to use <code>sys.stdin.buffer.raw</code>. And you may also need to do lots of careful flushing if you want to go back and forth between raw and normal input. (Note that this means you're giving up Unicode and instead getting a single-byte <code>bytes</code> object, which could be, say, half of a UTF-8 character or a quarter of a terminal escape character. Hopefully you're expecting that.)</p>
<hr/>
<p>Now, what does <code>FileIO.read</code> return when nothing is available? Well, it's an implementation of <code>RawIOBase</code>, and <a href="https://docs.python.org/3/library/io.html#io.RawIOBase.read" rel="nofollow"><code>RawIOBase.read</code></a> says:</p>
<blockquote>
<p>If 0 bytes are returned, and size was not 0, this indicates end of file. If the object is in non-blocking mode and no bytes are available, <code>None</code> is returned.</p>
</blockquote>
<p>In other words, you're going to get <code>None</code> if nothing is available, <code>b''</code> for EOF, or a single-byte <code>bytes</code> for anything else.</p>
<hr/>
<p>So, putting it all together:</p>
<pre><code>old_settings = termios.tcgetattr(fd)
old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)
try:
    tty.setraw(fd)
    fcntl.fcntl(fd, fcntl.F_SETFL, old_flags | os.O_NONBLOCK)
    return sys.stdin.buffer.raw.read(1)
finally:
    fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)
    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
</code></pre>
<hr/>
<p>One last thing: Is there a way to tell if input is ready without reading it? Yes, but not portably. Depending on your platform, <code>select</code>, <code>poll</code>, <code>epoll</code>, and/or <code>kqueue</code> may be available and may work on regular files. <code>read(0)</code> may be guaranteed to return <code>b''</code> instead of <code>None</code>. And so on. You can read your local man pages. But a simpler solution is the same thing C's stdio does: add a 1-byte-max buffer, and use it to implement your own <code>read</code> and <code>peek</code> or <code>read</code> and <code>unread</code> wrappers.</p>
</div>
<span class="comment-copy">The thing you call wait is normaly referred to as blocking. Try to search SO and google for <code>read stream non blocking  python</code></span>
<span class="comment-copy">In general, there are two parts to this: open/reopen/fcntl the file (you may or may not want to use <code>/dev/tty</code> instead of stdin) with <code>O_NONBLOCK</code>, and then either use <code>select.select</code> or handle <code>EAGAIN</code> errors or <code>None</code> returns on <code>read</code>. (If you're using a <code>TextIOWrapper</code> like <code>sys.stdin</code> instead of its underlying <code>.buffer.raw</code> you may get back a <code>''</code> or something else instead in either of those cases; as far as I know, it's not actually specified…)</span>
<span class="comment-copy">The source code to a library like <a href="https://github.com/riquito/richinput" rel="nofollow noreferrer"><code>richinput</code></a> probably shows everything you need, even if you don't want to use such a library directly.</span>
<span class="comment-copy">One more thing: It seems at least possible that what you <i>really</i> want here is <a href="https://docs.python.org/3/library/curses.html" rel="nofollow noreferrer"><code>curses</code></a>, so… if you've never heard of that, check it out.</span>
<span class="comment-copy">I've definitely thought about curses, but in terms of the entire project I think it's a bit overkill/tangential for my purposes. This is the only piece curses would really help hugely with.</span>
<span class="comment-copy">Thanks for the detailed answer. I've tried your implementation as well as a simple implementation with /dev/tty (which is an option), but it's returning "OSError: [Errno 11] Resource temporarily unavailable" when it tries to read from /dev/tty or stdio. Thoughts?</span>
<span class="comment-copy">@LegendaryQ: What platform are you on? How are you running the script? In particular, is it actually running in a terminal or other TTY provider? Is it running as the user who owns that TTY, or is it being launched by some other program that dropped privs? Beyond basic guesses, though, it's hard to debug it without seeing your actual code and exactly what line raised what exception.</span>
<span class="comment-copy">ah, my bad. I'd had the sys.stdin.read(1) returning instead of sys.stdin.buffer.raw.read(1), which did the trick. Thanks!</span>
<span class="comment-copy">@LegendaryQ: Sorry; I missed that in my initial version and corrected it in a later edit. As I explained in the text, <code>sys.stdin.read()</code> could be reading from a buffer—or reading into a buffer until it gets a complete Unicode character.</span>
