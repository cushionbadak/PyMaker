<div class="post-text" itemprop="text">
<p>Why does the following</p>
<pre><code>class A(object): pass
class B: pass

def p(x): print x

a = A()
b = B()

a.__enter__ = lambda *a, **k: p('a.enter')
b.__enter__ = lambda *a, **k: p('b.enter')
a.__exit__  = lambda *a, **k: p('a.exit')
b.__exit__  = lambda *a, **k: p('b.exit')

print 'direct call'
a.__enter__()
b.__enter__()
a.__exit__()
b.__exit__()

print 'with statement'
with a: pass
with b: pass
</code></pre>
<p>Print the following, but also throw an exception?</p>
<pre><code>direct call
a.enter
b.enter
a.exit
b.exit
with statement
Traceback (most recent call last):
  File "lol.py", line 21, in &lt;module&gt;
    with a: pass
AttributeError: __exit__
</code></pre>
<p>GamesBrainiac is correct that I'm looking to monkey-patch an instance.  The reason for this is that the standard way to use the <code>logging</code> standard library is a combination of <code>getLoggerClass</code>/<code>setLoggerClass</code> and <code>getLogger</code>.  Using the former pair will override all future behavior (undesireable) and using the latter appears to preclude me from monkey-patching the object to have special behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>Apparently context manager functions only work with classes. You're defining them on the instance. From the python <a href="https://docs.python.org/3/library/stdtypes.html#context-manager-types" rel="nofollow">docs</a>:</p>
<blockquote>
<p>Python’s with statement supports the concept of a runtime context defined by a context manager. This is implemented using a pair of methods that allow user-defined <strong>classes</strong> to define a runtime context that is entered before the statement body is executed and exited when the statement ends:</p>
</blockquote>
<p>However, I did come up with this hack which I think will work for you:</p>
<pre><code>class A:
    pass

def p(x):
    print(x)

a = A()

class MonkeyPatched(a.__class__):
    pass

MonkeyPatched.__enter__ = lambda *a, **k: p('a.enter')
MonkeyPatched.__exit__  = lambda *a, **k: p('a.exit')

a.__class__ = MonkeyPatched

with a:
    pass

a = A()

with a:
    pass
</code></pre>
<p>The first <code>with</code> works, but not the second.</p>
<p>This is rather ugly and I'm not sure if there are side effects of setting <code>__class__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to "monkey-patch" the class of the respective instance:</p>
<pre><code>new_class = type(a.__class__.__name__, (a.__class__,), {})
new_class.__enter__ = ...
new_class.__exit__ = ...
a.__class__ = new_class
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated Response</strong></p>
<p>You lambdas are unbound methods. When a is passed, it uses the <code>__exit__</code> method of the class, not the instance. Since the class has no method, it's an attribute error.</p>
<p>To demonstrate:</p>
<pre><code>class C(object):
    def __enter__(self):
        print 'entered'
    def __exit__(self, exc_type, exc_value, traceback):
        print self
        print exc_type
        print 'exiting'

c = C()
with c:
    print 'inside context'
</code></pre>
<p>prints:</p>
<pre><code>entered
inside context
&lt;__main__.C object at 0x7fd885e4eed0&gt;
None
exiting
</code></pre>
<p>but when we assign an lambda, we still get the bound method:</p>
<pre><code>c.__exit__ = lambda *args: p('lambda exit')
with c:
    print 'inside context'
</code></pre>
<p>prints:</p>
<pre><code>entered
inside context
&lt;__main__.C object at 0x7fd885e4eed0&gt;
None
exiting
</code></pre>
<p>You can mock the class method with the mock library (I had to get it from the Ubuntu repos for python 2 with `sudo apt-get install python-mock), unittest.mock in Python 3's standard lib:</p>
<pre><code>import mock # unittest.mock in Python 3
with mock.patch.object(C, '__exit__', autospec=True) as mock_method:
    new_c = C()
    with new_c:
        print 'inside context'

# __exit__ is called with three None's if no exception
mock_method.assert_called_with(new_c, None, None, None)
</code></pre>
<p>prints:</p>
<pre><code>entered
inside context
</code></pre>
<p>Note that the original <code>__exit__</code> method is no longer called.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this out, since <code>__enter__</code> is bound to <code>__class__</code>:</p>
<pre><code>from types import MethodType


class A(object):
    pass




class B(object):
    pass

a = A()
b = B()


def p(x):
    print(x)


def en(self, *args):
    p('starting')
    return self


def ex(self, exc_type, exc_value, traceback):
    p('finishing')
    return False

a.__class__.__enter__ = MethodType(en, a)
a.__class__.__exit__ = MethodType(ex, a)

with a:
    print("Inside stuff")
</code></pre>
</div>
<span class="comment-copy">If you can wait a little bit, I'm writing you a fleshed out answer.</span>
<span class="comment-copy">I think I've provided you with a solution, am I mistaken?</span>
<span class="comment-copy">@AaronHall I tried man. But, I guess you <i>cant</i> do it. Because its not defined with <code>__dict__</code>.</span>
<span class="comment-copy">@AaronHall Waaaaiiittt! I think I monkey patched the special method!</span>
<span class="comment-copy">@AaronHall Done! Man, it feels good to be awesome.</span>
<span class="comment-copy"><i>All</i> member functions are looked up via the class. You can get around that limitation by actually modifying the class.</span>
<span class="comment-copy">@filmor But I think op wants to monkey patch the instance.</span>
<span class="comment-copy">I don't think Zach wants to modify the class.</span>
<span class="comment-copy">Giving you the points since you had the documentation on <i>why</i> it didn't work, and including an example for the specific use.  @Filmor, that does not appear to be accurate.  Normal lookups don't work this way: <a href="https://gist.github.com/zachriggle/2b21203d263a6d8da617" rel="nofollow noreferrer">gist.github.com/zachriggle/2b21203d263a6d8da617</a></span>
<span class="comment-copy">@ZachRiggle <i>Member functions</i> are always looked up like this. By member function I mean a function that gets its first attribute implicitly assigned to the object it is called on ("<code>self</code>"). Sure, you can place a function in a normal instance attribute, but that is not the same (as you have seen). Additionally, the special member functions (i.e. <code>__call__</code>, <code>__add__</code> and the like) are always resolved as member functions in the given sense.</span>
<span class="comment-copy">But in essence you are still creating a new class.</span>
<span class="comment-copy">He <i>is</i> creating a new class. This doesn't answer.</span>
<span class="comment-copy">This does appear to be the proper way to do it without modifying the original class.  This solution is the same as simonzack's, but I can only give points to one of you.  I've adopted an approach similar to both of your answers.</span>
<span class="comment-copy">I am creating a class that behaves exactly like the class before, it has even the same name (note that this is a (minor) difference to simonzack's solution). In particular, things like <code>isinstance</code> and <code>issubclass</code> will continue to work as expected as long as you don't use <code>a.__class__</code> for this. IMHO this is the only pythonic way to do what you want.</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">That was a typo.  Changing that to <code>lambda: p('...')</code> still throws the exception.  Problem updated.</span>
<span class="comment-copy">Yes, you can do this, but he wanted monkey patched bound context managers.</span>
<span class="comment-copy">Apart from being nearly the same as simonzack's and my answer, this modifies <code>A</code> directly. After this <i>all</i> instances of <code>A</code> will have the overwritten <code>__enter__</code> and <code>__exit__</code> functions, which, btw. will always have <code>a</code> as their <code>self</code> attribute!</span>
<span class="comment-copy">@filmor Eh? I tried yours, it didn’t work for me.</span>
<span class="comment-copy">I edited it once (the <code>type</code> call was messed up). That doesn't relate, however, to the problems in your solution :)</span>
