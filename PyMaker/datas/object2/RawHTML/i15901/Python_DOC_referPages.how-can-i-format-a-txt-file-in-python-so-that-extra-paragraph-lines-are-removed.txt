<div class="post-text" itemprop="text">
<p>I'm trying to format a file similar to this: (random.txt)</p>
<pre class="lang-none prettyprint-override"><code>        Hi,    im trying   to format  a new txt document so
that extra     spaces between    words   and paragraphs   are only 1.



   This should make     this txt document look like:
</code></pre>
<p>This is how it should look below: (randomoutput.txt)</p>
<pre class="lang-none prettyprint-override"><code>Hi, I'm trying to format a new txt document so
that extra spaces between words and paragraphs are only 1.

This should make this txt document look like:
</code></pre>
<p>So far the code I've managed to make has only removed the spaces, but I'm having trouble making it recognize where a new paragraph starts so that it doesn't remove the blank lines between paragraphs. This is what I have so far.</p>
<pre><code>def removespaces(input, output):
    ivar = open(input, 'r')
    ovar = open(output, 'w')
    n = ivar.read()
    ovar.write(' '.join(n.split()))
    ivar.close()
    ovar.close()
</code></pre>
<p>Edit:</p>
<p>I've also found a way to create spaces between paragraphs, but right now it just takes every line break and creates a space between the old line and new line using:</p>
<pre><code>m = ivar.readlines()
m[:] = [i for i in m if i != '\n']
ovar.write('\n'.join(m))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should process the input line-by line.  Not only will this make your program simpler but also more easy on the system's memory.</p>
<p>The logic for normalizing horizontal white space in a line stays the same (split words and join with a single space).</p>
<p>What you'll need to do for the paragraphs is test whether <code>line.strip()</code> is empty (just use it as a boolean expression) and keep a flag whether the previous line was empty too.  You simply throw away the empty lines but if you encounter a non-empty line and the flag is set, print a single empty line before it.</p>
<pre><code>with open('input.txt', 'r') as istr:
    new_par = False
    for line in istr:
        line = line.strip()
        if not line:  # blank
            new_par = True
            continue
        if new_par:
            print()  # print a single blank line
        print(' '.join(line.split()))
        new_par = False
</code></pre>
<p>If you want to suppress blank lines at the top of the file, you'll need an extra flag that you set only after encountering the first non-blank line.</p>
<p>If you want to go more fancy, have a look at the <a href="https://docs.python.org/3/library/textwrap.html" rel="nofollow"><code>textwrap</code></a> module but be aware that is has (or, at least, used to have, from what I can say) some bad worst-case performance issues.</p>
</div>
<div class="post-text" itemprop="text">
<p>The trick here is that you want to turn any sequence of 2 or more <code>\n</code> into exactly 2 <code>\n</code> characters. This is hard to write with just <code>split</code> and <code>join</code>â€”but it's dead simple to write with <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a>:</p>
<pre><code>n = re.sub(r'\n\n+', r'\n\n', n)
</code></pre>
<p>If you want lines with nothing but spaces to be treated as blank lines, do this <em>after</em> stripping spaces; if you want them to be treated as non-blank, do it <em>before</em>.</p>
<p>You probably also want to change your space-stripping code to use <code>split(' ')</code> rather than just <code>split()</code>, so it doesn't screw up newlines. (You could also use <code>re.sub</code> for that as well, but it isn't really necessary, because turning 1 or more spaces into exactly 1 <em>isn't</em> hard to write with <code>split</code> and <code>join</code>.)</p>
<hr/>
<p>Alternatively, you could just go line by line, and keep track of the last line (either with an explicit variable inside the loop, or by writing a simple adjacent_pairs iterator, like <code>i1, i2 = tee(ivar); next(i2); return zip_longest(i1, i2, fillvalue='')</code>) and if the current line and the previous line are both blank, don't write the current line.</p>
</div>
<div class="post-text" itemprop="text">
<p>split without Argument will cut your string at each occurence if a whitespace ( space, tab, new line,...). 
Write
    n.split(" ")
and it will only split at spaces.
Instead of writing the output to a file, put it Ingo a New variable, and repeat the step again, this time with</p>
<pre><code>m.split("\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, let's see, what exactly is the problem...
You cannot have 1+ consecutive spaces or 2+ consecutive newlines.</p>
<p>You know how to handle 1+ spaces. 
That approach won't work on 2+ newlines as there are 3 possible situations:
  - 1 newline
  - 2 newlines
  - 2+ newlines</p>
<p>Great so.. How do you solve this then?
There are many solutions. I'll list 3 of them.</p>
<ol>
<li><p>Regex based.
This problem is very easy to solve iff<sup>1</sup> you know how to use regex...
So, here's the code:</p>
<pre><code>s = re.sub(r'\n{2,}', r'\n\n', in_file.read())
</code></pre>
<p>If you have memory constraints, this is not the best way as we read the entire file into the momory.</p></li>
<li><p>While loop based.
This code is really self-explainatory, but I wrote this line anyway...</p>
<pre><code>s = in_file.read()
while "\n\n\n" in s:
    s = s.replace("\n\n\n", "\n\n")
</code></pre>
<p>Again, you have memory constraints, we still read the entire file into the momory.</p></li>
<li><p>State based.
Another way to approach this problem is line-by-line. By keeping track whether the last line we encountered was blank, we can decide what to do.</p>
<pre><code>was_last_line_blank = False
for line in in_file:
    # Uncomment if you consider lines with only spaces blank
    # line = line.strip()

    if not line:
        was_last_line_blank = True
        continue
    if not was_last_line_blank:
        # Add a new line to output file
        out_file.write("\n")
    # Write contents of `line` in file
    out_file.write(line)

    was_last_line_blank = False
</code></pre></li>
</ol>
<p>Now, 2 of them need you to load the entire file into memory, the other one is fairly more complicated. My point is: All these work but since there is a small difference in ow they work, what they need on the system varies...</p>
<p><sup>1</sup> The "iff" is intentional.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically, you want to take lines that are non-empty (so <code>line.strip()</code> returns empty string, which is a <code>False</code> in boolean context). You can do this using list/generator comprehension on result of <code>str.splitlines()</code>, with <code>if</code> clause to filterout empty lines.</p>
<p>Then for each line you want to ensure, that all words are separated by single space - for this you can use <code>' '.join()</code> on result of <code>str.split()</code>.</p>
<p>So this should do the job for you:</p>
<pre><code>compressed = '\n'.join(
    ' '.join(line.split()) for line in txt.splitlines() 
        if line.strip() 
    )
</code></pre>
<p>or you can use <code>filter</code> and <code>map</code> with helper function to make it maybe more readable:</p>
<pre><code>def squash_line(line):
    return ' '.join(line.split())

non_empty_lines = filter(str.strip, txt.splitlines())
compressed = '\n'.join(map(squash_line, non_empty_lines))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To fix the paragraph issue:</p>
<pre><code>import re
data = open("data.txt").read()

result = re.sub("[\n]+", "\n\n", data)
print(result)
</code></pre>
</div>
<span class="comment-copy">+1 for a clear question with a precise problem statement, sample input and expected output and showing reasonable self-effort.  I don't see this kind of (first!) questions very often, these days.</span>
<span class="comment-copy">I was about to get this to work with my program, thank you.</span>
