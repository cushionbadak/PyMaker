<div class="post-text" itemprop="text">
<p>Suppose there is a class <code>MyArray</code> in C++. It implements an array of <code>SomeType</code> In order to make a <code>__getitem__</code> function for it in Python, I do something like this</p>
<pre><code>const SomeType&amp; getitem(const MyArray *arr, PyObject *slice) {
    // ???
}

BOOST_PYTHON_MODULE(mymodule) 
{
    class_&lt;MyArray&gt;("MyArray")
    .def("__getitem__", &amp;getitem)
    // probably some other methods...
    ;
}
</code></pre>
<p>It is possible to get indices in <code>slice</code> by using <a href="https://docs.python.org/3/c-api/slice.html" rel="nofollow">these functions</a>. However, "<a href="https://wiki.python.org/moin/boost.python/GettingStarted" rel="nofollow">Boost::Python is designed with the idea in mind that users never touch a PyObject*</a>".</p>
<p>Is there a better 'boost way' to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Boost.Python is designed to minimize the need to interact with <code>PyObject</code>, and it often accomplishes this by:</p>
<ul>
<li>Providing higher-level type wrappers.</li>
<li>Allowing access to the Python object's interface through the associated <code>boost::python::object</code>.</li>
</ul>
<p>For example, one can access the Python object's interface through C++ in a similar manner as  one would do in Python.  The following demonstrates accessing the <code>start</code> attribute of a <code>boost::python::object</code> that refers to a Python <code>slice</code> instance:</p>
<pre class="lang-cpp prettyprint-override"><code>namespace python = boost::python;
python::object slice = get_slice_object();
python::object start = slice.attr("start");
std::size_t start_index = !start.is_none()
  ? python::extract&lt;std::size_t&gt;(start) // Extract index.
  : 0;                                  // Default.
</code></pre>
<p>While this approach works, it tends to result in much boilerplate code: creating defaults when <code>None</code> is provided, handling zero-length slices, and converting negative indexes to positive index.  In this case, Boost.Python provides a higher-level type wrapper <a href="http://www.boost.org/doc/libs/1_56_0/libs/python/doc/v2/slice.html" rel="nofollow"><code>boost::python::slice</code></a> that has a <code>get_indices()</code> member-function that will remove much of the boilerplate code.  Here is a complete minimal example:</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;vector&gt;
#include &lt;boost/range/algorithm.hpp&gt;
#include &lt;boost/range/irange.hpp&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;boost/python/slice.hpp&gt;

/// @brief Mockup class that creates a range from 0 to N.
struct counter
{
  counter(std::size_t n)
  {
    data.reserve(n);
    boost::copy(boost::irange(std::size_t(0), n), std::back_inserter(data));
  }

  std::vector&lt;int&gt; data;
};

/// @brief Handle slicing for counter object.
boost::python::list spam_getitem(
  const counter&amp; self,
  boost::python::slice slice)
{
  namespace python = boost::python;
  python::list result;

  // Boost.Python will throw std::invalid_argument if the range would be
  // empty.
  python::slice::range&lt;std::vector&lt;int&gt;::const_iterator&gt; range;
  try
  {
    range = slice.get_indices(self.data.begin(), self.data.end());
  }
  catch (std::invalid_argument)
  {
    return result;
  }

  // Iterate over fully-closed range.
  for (; range.start != range.stop; std::advance(range.start, range.step))
  {
    result.append(*range.start);
  }
  result.append(*range.start); // Handle last item.
  return result;
}

BOOST_PYTHON_MODULE(example)
{
  namespace python = boost::python;
  python::class_&lt;counter&gt;("Counter", python::init&lt;int&gt;())
    .def("__getitem__", &amp;spam_getitem)
    ;
}
</code></pre>
<p>Interactive usage:</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; from example import Counter
&gt;&gt;&gt; counter = Counter(5)
&gt;&gt;&gt; assert(counter[:]    == [0,1,2,3,4])
&gt;&gt;&gt; assert(counter[:-2]  == [0,1,2])
&gt;&gt;&gt; assert(counter[-2:]  == [3,4])
&gt;&gt;&gt; assert(counter[::2]  == [0,2,4])
&gt;&gt;&gt; assert(counter[1::2] == [1,3])
&gt;&gt;&gt; assert(counter[100:] == [])
</code></pre>
</div>
<span class="comment-copy">Great example! Can this be extended to deal with both slices and indices (e.g., counter[2:-1] and counter[2])?</span>
