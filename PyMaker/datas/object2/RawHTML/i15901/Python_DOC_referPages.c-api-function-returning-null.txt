<div class="post-text" itemprop="text">
<p>I am trying to create some python objects and use NumPy from C++. I have modified some examples I have found. My code below finds the NumPy module, the function numpy.array but returns null for pValue. I have used Python3.4. Could anyone shed any light on why the function always returns NULL?</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;Python.h&gt;
int runPython(int argc, char * argv[]) {

    std::cout &lt;&lt; "Hello from runPython()" &lt;&lt; std::endl;
    PyObject *pFunc;
    PyObject *pValue, *pYVec;
    int i;

    Py_Initialize();

    std::cout &lt;&lt; Py_GetVersion() &lt;&lt; std::endl;

    PyObject *sys = PyImport_ImportModule("sys");
    PyObject *path = PyObject_GetAttrString(sys, "path");
    std::cout &lt;&lt; PyList_Size(path) &lt;&lt; std::endl;
    Py_DecRef(path);
    Py_DecRef(sys);

    PyObject* item = PyList_GetItem(path,1);
    std::cout &lt;&lt; PyString_Check(item) &lt;&lt; std::endl;
    Py_DecRef(item);

    PyObject *numpy = PyImport_ImportModule("numpy");

    if (numpy != NULL) {
        pFunc = PyObject_GetAttrString(numpy, "array"); //Get the function by its name
        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
            static const double yarr[] = {0,0,1,1,0,0,2,2,0,0,1,1,0,0};
            std::vector&lt;double&gt; yvec (yarr, yarr + sizeof(yarr) / sizeof(yarr[0]) );

            //Transfer the other C++ vector to a python list
            pYVec = PyList_New(yvec.size());
            for (i = 0; i &lt; yvec.size(); ++i) {
                pValue = PyFloat_FromDouble(yvec[i]);
                if (!pValue) {

                    fprintf(stderr, "Cannot convert array value\n");
                    return 1;
                }
                PyList_SetItem(pYVec, i, pValue); //
            }

            //Call the python function
            pValue = PyObject_CallMethodObjArgs(pFunc, pYVec);
            if (pValue != NULL) {
                printf("Result of call: %ld\n", PyInt_AsLong(pValue));
            }
            //Some error catching
            else {
                Py_DecRef(pValue);
                Py_DecRef(pYVec);
                //Py_DecRef(pFunc);

                Py_XDECREF(pFunc);
                Py_DecRef(numpy);
                fprintf(stderr,"Call failed\n");
                PyErr_Print();

                return 1;
            }
        }
        else {
            if (PyErr_Occurred())
                PyErr_Print();
            fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
        }
        //Py_DECREF(pModule);
    }
    else {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
        return 1;
    }
    Py_Finalize();
    return 0;
}

int main ( int argc, char *argv[] )
{
    std::cout &lt;&lt; "Hello from main" &lt;&lt; std::endl;
    runPython(argc, argv);
    std::cout &lt;&lt; "Program finished" &lt;&lt; std::endl;
    return EXIT_SUCCESS;
}
</code></pre>
<p>produces output</p>
<pre><code>Hello from main
Hello from runPython()
3.4.0 (default, Apr 11 2014, 13:08:40) 
[GCC 4.8.2]
7
0
Call failed
Program finished
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your arguments to <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_CallMethodObjArgs" rel="nofollow"><code>PyObject_CallMethodObjArgs</code></a> are not correct.  In fact, I think you are calling the wrong function.  <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_CallFunctionObjArgs" rel="nofollow"><code>PyObject_CallFunctionObjArgs</code></a> looks more appropriate.  Instead of</p>
<pre><code>    pValue = PyObject_CallMethodObjArgs(pFunc, pYVec);
</code></pre>
<p>try</p>
<pre><code>    pValue = PyObject_CallFunctionObjArgs(pFunc, pYVec, NULL);
</code></pre>
</div>
<span class="comment-copy">@matsjoyce - I've had a look at the library but there doesn't seem to be much documentation. Do you have a SSCE?</span>
