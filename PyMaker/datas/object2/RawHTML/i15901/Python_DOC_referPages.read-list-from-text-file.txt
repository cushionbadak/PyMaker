<div class="post-text" itemprop="text">
<p>I have been experimenting with ways of storing some variables from my python project in a user readable/editable text file. The text file is laid out like this:</p>
<pre><code>a = "hello"
b = 123
c = [4,5,6]
</code></pre>
<p>As you can see, a is meant to be a string, b an integer, and c a list. The code I have so far goes as follows:</p>
<pre><code>for line in file:
    name = line.split('=')[0]
    value = line.split('=')[1]
    vars()[name] = value
</code></pre>
<p>It splits the line at the '=' and sets the first section as the variable name, and the second section as the value for that variable.</p>
<p>However, when the program runs, instead of coming out as an integer and a list, b (123) and c ([4,5,6]) both are saved as strings.</p>
<p>Is there any way that I can convert the strings into their proper types? Or is their a better (but still simple) way of doing what I am trying to do?</p>
<p>Any help would be much appreciated. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way, using <a href="https://docs.python.org/2/library/ast.html#ast.literal_eval" rel="nofollow"><code>ast.literal_eval</code></a>:</p>
<pre><code>import ast
def config_file(filename):
    result = {}
    with open(filename) as f:
        for line in f:
            line = line.split('=',1)
            result[line[0]] = ast.literal_eval(line[1].strip())
    return result

print config_file('cfg.txt')
</code></pre>
<p>You'll probably want more beef in the <code>for</code> loop, like ignoring blank lines, removing comments, etc.</p>
<p>Also note that this puts the data in a <code>dict</code>, and not into the <code>vars()</code> dict. You should <a href="http://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html" rel="nofollow">keep data out of your variable names</a>. If you do want to add your config variables to your namespace, you can still use my function like so:</p>
<pre><code>vars().update(config_file('cfg.txt'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>"Or is their a better (but still simple) way of doing what I am trying to do?"</strong> </p>
<p><strong>Option 1</strong>
One easy and good way is to use a dictionary in a python file just do an import.</p>
<p><strong>myConfig.py</strong></p>
<pre><code>cfg={'a':"hello", 'b':123, 'c':[4,5,6]}
</code></pre>
<p><strong>In your code:</strong></p>
<pre><code>from myConfig import *
print cfg['a']
</code></pre>
<p>You can also use indvidual variables instead of dictionary and do the same. </p>
<p><strong>Option 2</strong></p>
<p>If you don't want a python file you can read any other file and use <code>exec</code> to executing the command line by line. Docs here: <a href="https://docs.python.org/2/reference/simple_stmts.html#exec" rel="nofollow noreferrer">https://docs.python.org/2/reference/simple_stmts.html#exec</a> </p>
<p>You can use <code>execfile</code> but I believe it is discontinued in versoin 3.x Docs here: <a href="https://docs.python.org/2/library/functions.html#execfile" rel="nofollow noreferrer">https://docs.python.org/2/library/functions.html#execfile</a></p>
<p><strong>Option 3</strong></p>
<p><strong>You can also use other ways:</strong></p>
<ol>
<li>Python ConfigParser:     <a href="https://docs.python.org/2/library/configparser.html" rel="nofollow noreferrer">https://docs.python.org/2/library/configparser.html</a> </li>
<li>YAML files:  <a href="http://pyyaml.org/wiki/PyYAMLDocumentation" rel="nofollow noreferrer">http://pyyaml.org/wiki/PyYAMLDocumentation</a></li>
<li>XML files: See this for an example:
    <a href="https://stackoverflow.com/questions/7108319/parsing-xml-configuration-file-using-etree-in-python">parsing XML configuration file using Etree in python</a></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In addition to answers below, for simple data structures you can use <code>json</code> format and dictionaries or namedtuples:</p>
<pre><code>import json
from ast import literal_eval
from collections import namedtuple

json_vars = """{
    'a' : "hello",
    'b' : 123,
    'c' : [4,5,6]
}"""


print json_vars
from_json = literal_eval(json_vars)
# or:
# from_json = json.loads(json_vars)

variables = namedtuple('Vars', from_json.keys())(*from_json.values())

print variables
print variables.a
print variables.b
print variables.c

print variables._asdict()
d = dict(variables._asdict())
print d

print d['a']
print d.items()


as_json_again = json.dumps(d, indent=2)

print as_json_again
</code></pre>
<p>For more advanced objects, see <code>pickle</code> module.</p>
</div>
<span class="comment-copy">You could use <code>eval</code>, but there a piles of security risks attached.</span>
<span class="comment-copy">Have a look at <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>.  Unlike <code>eval</code>, it is safe to use.</span>
<span class="comment-copy">maybe just make a function that says "hey, is this a list?" using stuff like <code>line.startswith('[')</code> (or even regexes like a boss)  and then use string manip to sort it out, and eventually int() on the stringed ints to finally convert them...... would be safer than eval/exec, but actually require work</span>
<span class="comment-copy">You would want exec not eval I believe</span>
