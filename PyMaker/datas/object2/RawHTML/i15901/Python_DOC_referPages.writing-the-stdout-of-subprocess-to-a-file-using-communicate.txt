<div class="post-text" itemprop="text">
<p>I am using subprocess to run a executable and piping the output of it using communicate. Finally, I write the contents of communicate to a file. The exact code is shown below</p>
<pre><code>run = subprocess.Popen(['executable'], stdout=subprocess.PIPE)
output = run.communicate()[0]
logfile = open('run.log', 'a')
logfile.write(output)
logfile.close()
</code></pre>
<p>In the above process, the logfile is written at the end of the run. However, is there a way to write the output to the log as the executable is running?</p>
</div>
<div class="post-text" itemprop="text">
<p>You mean something like:</p>
<pre><code>with open("run.log","a") as f:
      run = subprocess.Popen(['executable'], stdout=f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I found the solution to this:</p>
<pre><code>logfile = ('run.log', 'w')
run = subprocess.Popen(['executable'], stdout = logfile)
run.wait()
logfile.close()
</code></pre>
<p>The first line creates the <code>run.log</code> for writing and <code>stdout</code> writes directly to the logfile as the executable is running. The <code>run.wait()</code> waits for the executable to complete and then the log file is closed.</p>
</div>
<span class="comment-copy">This is directly explained in <a href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">the docs</a>: "<i>stdin</i>, <i>stdout</i> and <i>stderr</i> specify the executed programâ€™s standard input, standard output and standard error file handles, respectively. Valid values are <code>PIPE</code>, <code>DEVNULL</code>, an existing file descriptor (a positive integer), an existing file object, and <code>None</code>."</span>
<span class="comment-copy">use <code>subprocess.check_call()</code> to wait for the child process to finish (like in the question). <code>check_call()</code> also raises an exception automatically if the subprocess returns a non-zero exit status.</span>
<span class="comment-copy">Thanks @padraic. While the above works, the terminal gets free from the executable. Is there a way for the <code>subprocess</code> to retain the executable in the terminal until the run is over?</span>
<span class="comment-copy">@Deepak: just replace <code>Popen</code> with <code>check_call</code> as I've suggested. The parameters are the same.</span>
<span class="comment-copy">As <code>Popen</code> returns after it has started the process, wont it leave the <code>with</code> block causing <code>f</code> to be left as a closed file?</span>
