<div class="post-text" itemprop="text">
<p>Please be kind with me, I'm a Python beginner :-)</p>
<p>Now, I see that the 'best practice' for writing Python programs would be to wrap the main code inside a 'main' function, and do the <code>if "__main__" == __name__:</code> test to invoke the 'main' function.</p>
<p>This of course results in the necessity of using a series of <code>global</code> statements in the 'main' function to access the global variables.</p>
<p>I wonder if it is more proper (or 'Pythonic', if you will) to gather the global variables into a custom class, say <code>_v</code>, and refer to the variables using <code>_v.</code> prefix instead?</p>
<p>Also, as a corollary question, would that have any negative impact to, let's say, performance or exception handling?</p>
<hr/>
<p><strong>EDIT :</strong> The following is the general structure of the program:</p>
<pre><code>paramset = {
    0: { ...dict of params... }
    1: { ...dict of params... }
    2: { ...dict of params... }
    }

selector = 0
reset_requested = False
selector_change = False

def sighup_handler(signal,frame):
    global reset_requested
    logger.info('Caught SIGHUP, resetting to set #{0}'.format(new_selector))
    reset_requested = True
    selector = 0

def sigusr1_handler(signal,frame):
    global selector
    new_selector = (selector + 1) % len(paramset)
    logger.info('Caught SIGHUP, changing parameters to set #{0}'.format(new_selector))
    selector = new_selector
    selector_change = True

signal.signal(signal.SIGHUP, sighup_handler)
signal.signal(signal.SIGUSR1, sigusr1_handler)

def main():
    global reset_requested
    global selector
    global selector_change
    keep_running = True
    while keep_running
        logger.info('Processing selector {0}'.format(selector))
        for stage in [process_stage1, process_stage2, process_stage3]
            err, result = stage(paramset[selector])
            if err is not None:
                logger.critical('Stage failure! Err {0} details: {0}'.format(err, result))
                raise SystemError('Err {0} details: {0}'.format(err, result))
            else:
                logger.info('Stage success: {0}'.format(result))
            if reset_requested:
                stage_cleanup()
                reset_requested = False
            else:
                inter_stage_pause()
                if selector_change:
                    selector_change = False
                    break
        selector = (selector + 1) % len(paramset)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are enough pieces missing from the example code that  reaching any firm conclusions is difficult.</p>
<h3>Event-driven approach</h3>
<p>The usual approach for this type of problem would be to make it entirely event-driven.  As it stands, the code is largely polling.  For example, <code>sighup_handler</code> sets <code>reset_requested = True</code> and the <code>while</code> loop in <code>main</code> processes that request.  An event-driven approach would handle the reset, meaning the call to <code>stage_cleanup</code>, directly:</p>
<pre><code>def sighup_handler(signal,frame):
    logger.info('Caught SIGHUP, resetting to set #{0}'.format(new_selector))
    stage_cleanup()
</code></pre>
<p><br/></p>
<h3>Class with shared variables</h3>
<p>In the sample code, the purpose of all those process_stages and cycling through the stages is not clear.  Can it all be put in an event-driven context?  I don't know.  If it can't and it does require shared variables, then your suggestion of a class would be a natural choice.  The beginnings of such a class might look like:</p>
<pre><code>class Main(object);

    def __init__(self):
        self.selector = 0
        self.selector_change = False
        signal.signal(signal.SIGHUP, self.sighup_handler)
        signal.signal(signal.SIGUSR1, self.sigusr1_handler)

    def sighup_handler(self, signal,frame):
        logger.info('Caught SIGHUP, resetting to set #{0}'.format(new_selector))
        stage_cleanup() 
        self.selector = 0

    def sigusr1_handler(self, signal,frame):
        new_selector = (selector + 1) % len(paramset)
        logger.info('Caught SIGHUP, changing parameters to set #{0}'.format(new_selector))
        self.selector = new_selector
        self.selector_change = True

    def mainloop(self):
        # Do here whatever polling is actually required.

if __name__ == '__main__':
    main = Main()
    main.mainloop()
</code></pre>
<p>Again, because the true purpose of the polling loop is not clear to me, I didn't try to reproduce its functionality in the class above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally, it is best practice to avoid global variables, and instead just pass variables to classes/methods that need them through method calls. Example: if you are making a calculator, make an addition method that takes 2 ints and returns an int. This is in contrast to making 2 input ints and 1 output int as global variables, and having the add method work on those.</p>
</div>
<span class="comment-copy">@John1024 I've edited my question, adding only relevant logic.</span>
<span class="comment-copy">Thanks.  That is not a <a href="http://stackoverflow.com/help/mcve">minimal working example</a> but it is very helpful to see what motivated the question.</span>
<span class="comment-copy">Thanks for the explanation! The event-driven approach to signal handling sadly is not applicable, because when a reset is requested, if a stage is still running, the stage must run until completion. So that's why I merely set a flag within the signal handler, and letting the main loop to handle the flag between stages.</span>
<span class="comment-copy">@pepoluan Event-driven signal handlers are designed to handle issues like that.  If a reset must not be processed while a "stage" is running, the solution is for that stage to <a href="https://docs.python.org/3/library/signal.html#signal.pthread_sigmask" rel="nofollow noreferrer">"block"</a> the HUP signal in its critical section and then unblock it later.  There is even a method to see what <a href="https://docs.python.org/3/library/signal.html#signal.sigpending" rel="nofollow noreferrer">signals are pending while blocked</a>.  Signal handling is a well-developed art.</span>
<span class="comment-copy">Hmmm... that's new to me. Thanks for the link!</span>
<span class="comment-copy">I just noticed that those links require py3.3.  If you are using an older version of python, <a href="https://www.osso.nl/blog/python-temporarily-blocking-signals/" rel="nofollow noreferrer">this link</a> might help.</span>
<span class="comment-copy">Well, the 'use case' in my situation is that I had to intercept several signals (HUP, USR1, and USR2), which will activate some flags, which will be handled 'at an opportune time' by the main() function (i.e., sending the program those signals will not have immediate result).</span>
<span class="comment-copy">In python, signals such as HUP, USR1, are intercepted using the <code>signal</code> module.  Documentation <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">here</a>.  No global variables required.</span>
<span class="comment-copy">I know. The signal handler merely sets a flag. A main loop inside the main function will periodically -- before starting a long process -- checks for the flag and change various parameters for the process accordingly.</span>
<span class="comment-copy">@pepoluan Would you show us the code that you have (or a minimal working subset of it)?  It would make it much easier for us to provide useful feedback if we saw what you were attempting.  Thanks.</span>
<span class="comment-copy">I'll edit my question when I get back from the office.</span>
