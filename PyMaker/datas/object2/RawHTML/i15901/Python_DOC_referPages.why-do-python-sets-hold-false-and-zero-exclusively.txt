<div class="post-text" itemprop="text">
<p>when creating a set:</p>
<pre><code>&gt;&gt;&gt; falsey_set = {0, '', False, None}  # set([False, '', None])
&gt;&gt;&gt; falsey_set = {False, '', 0, None}  # set([0,'', None])
&gt;&gt;&gt; # adding an item to the set doesn't change anything either
&gt;&gt;&gt; falsey_set.add(False)  # set([0,'',None])
</code></pre>
<p>or a dictionary, which mimics the behavior somewhat:</p>
<pre><code>&gt;&gt;&gt; falsey_dict = {0:"zero", False:"false"}  # {0:'false'}  # that's not a typo
&gt;&gt;&gt; falsey_dict = {False:'false', 0:'zero'}  # {False: 'zero'} # again, not a typo
&gt;&gt;&gt; falsey_set.add(())  # set([0,'', None, ()])
&gt;&gt;&gt; falsey_set.add({})  
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
&gt;&gt;&gt; falsey_dict[()] = 'list'  # {False:'zero', ():'list'}
&gt;&gt;&gt; falsey_dict({}) = 'dict'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
</code></pre>
<p><code>0</code> and <code>False</code> always remove one another from the set. In the case of dictionaries they are incorrect altogether. <strong>Is there a reason for this</strong>?  While I realize that booleans are derived from integers in Python. What's the pythonic reasoning for acting this way in the context of sets specifically (I don't care about dictionaries too much)? Since while useful in truthy comparison like:</p>
<pre><code>&gt;&gt;&gt; False == 0  # True
</code></pre>
<p>There is obvious value in differentiation:</p>
<pre><code>&gt;&gt;&gt; False is 0  # False
</code></pre>
<p>I've been looking over the <a href="https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset" rel="nofollow">documentation</a> and can't seem to find a reference for the behavior</p>
<p><strong><em>Update</em></strong></p>
<p>@delnan I think you hit the nail on the head with hash determinism you've mentioned in the comments. As @mgilson notes <strong>both</strong> <code>False</code> and <code>0</code> use the same hashing function, however so do <code>object</code> and many of its subclasses (i.e.:<code>super</code>) that have identical <strong>hash</strong> functions.  The key seems to be in the phrase <code>Hashable objects which compare equal must have the same hash value</code> from the <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow">documentation</a>.  Since, False == 0 and and both are hashable, their outputs must by Python's definition be equivalent.  Finally, the definition of <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow">hashable</a> states how sets use hashability in set membership with the following: <code>Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.</code> While I still don't understand why they both use the same hashing function - I can settle with going this deep.</p>
<p>If we all agree then someone propose a polished answer, and I'll accept it. If there could be some improvement or if I'm off base then please let it be known below.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's because <code>False</code> and <code>0</code> <em>hash</em> to the same value <strong>and</strong> are equal.</p>
<p>The reason that they hash to the same value is because <code>bool</code> is a subclass of <code>int</code> so <code>bool.__hash__</code> simply calls the same underlying mechanics that <code>int.__hash__</code> calls...</p>
<pre><code>&gt;&gt;&gt; bool.__hash__ is int.__hash__
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, let's try to explain what's going on at the beginning, with your <code>falsey_set</code> and <code>falsey_dict</code>, so you see that it's not "incorrect", but in fact only possible consistent solution. To do so, we will remove <code>bool</code>s from the picture temporarily, and use something that more people grasp intuitively: decimal numbers.</p>
<pre><code>&gt;&gt;&gt; numset = {3, 5, 3.0, 4}  # {3.0, 4, 5}
&gt;&gt;&gt; numset.add(3)            # no change
</code></pre>
<p>I hope you agree that this is exactly how <code>set</code> should work. If you don't, then it seems that either you think <code>3</code> and <code>3.0</code> are not really equal, or you think that a set should be allowed to have equal elements. Neither of these are really productive beliefs IMO.</p>
<p>(Of course, <em>which one</em> of 3 and 3.0 ends up in the set is a matter of processing displays, and set is a bit weird since it is an atrophied dict where key and value are the same. But it is consistent and specified in Pythton. The point for now is, surely they cannot <em>both</em> be in a set.)</p>
<p>One more point: as you see, the thing I can add many other true things into my set (like <code>4</code> and <code>5</code>) doesn't matter at all. Same, the fact you can add many other false things in your set (like <code>''</code> and <code>None</code>) doesn't matter at all. Truth is a red herring. A set can have true elements and false elements. What is cannot have, is <em>equal</em> elements.</p>
<pre><code>&gt;&gt;&gt; numdict = {3:"a", 3.0:"b"}  # {3:"b"}
</code></pre>
<p>This looks weirder at a first glance, but is in fact much clearer what's going on, since keys and values are separate. Python rules are precise: read dict display from left to right, take every pair <em>a</em>:<em>b</em>, then if key <em>a</em> is already in the dict, update its value to <em>b</em>, else insert key <em>a</em> into the dict with value <em>b</em>.</p>
<p>With that algorithm, I guess it's obvious how the final dict ends up like that, and all the other behaviours you've noticed. What's important is that, like in a set, what you <em>really</em> need in a dict is to have only one value for any given key. Having two equal keys in the same dict would be an invitation to disaster, since then you'd be able to assign them different values.</p>
<p>So, in a nutshell: I think you dug yourself too deep with hash functions and other implementation stuff. These are nice way of seeing <em>how</em> Python does X, <em>once</em> you realize that X is the right thing to do. But first you have to see that X is the right thing to do. And I hope I've shown that to you now. <strong>A set cannot have equal elements.</strong> It would defeat a widely used purpose of a set, removing duplicates. And <strong>3 and 3.0 really are equal.</strong> This has nothing to do with types, some embeddings are so natural we've erased them on a mathematical level.</p>
<p>Of course, that leaves the question "why are 0 and False really equal"? In fact, the answer is not very different: just another mathematically erased embedding that's so incredibly useful we would have to jump through many ridiculous hoops without it. For more about that, read about Iverson bracket. ;-) But anyway, it seems you know about that part. The above is what was problematic, I guess.</p>
</div>
<span class="comment-copy">Why should the identity matter? Two equal strings can have different identities, imagine the pain if they were considered distinct by sets and dicts. Also note that by the definition of hashability, <code>hash(x) == hash(y)</code> <b>must</b> hold when <code>x == y</code>.</span>
<span class="comment-copy">Related question: <a href="http://stackoverflow.com/questions/2764017/is-false-0-and-true-1-in-python-an-implementation-detail-or-is-it-guarante" title="is false 0 and true 1 in python an implementation detail or is it guarante">stackoverflow.com/questions/2764017/â€¦</a>.</span>
<span class="comment-copy">You shouldn't get too hung up on the hashing part of this; it's mostly irrelevant.  The simple answer is that dict and set (and list, come to that) membership is based on <i>equality</i> (unless you want to nitpick, in which case a better description is identity-then-equality), and since <code>False == 0</code>, they're considered the same when used as set elements or dictionary keys.  The fact that dicts and sets use a hash table (and hence that keys and elements must be hashable, and equality should imply equality of hashes) is secondary.</span>
<span class="comment-copy">I agree that, simply put it's based on equality, <b><i>except</i></b> that you can't have a list, dict, or set inside a set because it throws this error <code>TypeError: unhashable type:</code>. So saying that it's based on equality is a simplistic model but accurate enough for real use and, like you say, mostly irrelevant. Thanks for the reality check.</span>
<span class="comment-copy">If they are equal and <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer">hashable</a>, they <i>must</i> hash to the same value. @RogerFan</span>
<span class="comment-copy">@delnan -- Not exactly.  It's pretty easy to cook up a contrived example where two objects hash to the same value but aren't equal...</span>
<span class="comment-copy">I think arguing by the subclass relationship is putting the cart before the horse. <code>True</code> and <code>False</code> are intended to be the integers 1 and 0 with different <code>repr()</code>, that's why they are implemented as subclass of <code>int</code>.</span>
<span class="comment-copy">"Must" in the sense of "really really should and is even explicitly required in the documentation", not in the sense of "it is enforced that". Also, you got it backwards: Equal hashes for different objects are just ordinary collisions and expected; the bad counter example would be equal objects with different hashes.</span>
<span class="comment-copy">int and bool are different objects but they share the same <code>__hash__</code> function by identity: <code>&lt;slot wrapper '__hash__' of 'int' objects&gt;</code> but I think it would be much to ask for a counter example.</span>
