<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/22783778/initialize-list-to-a-variable-in-a-dictionary-inside-a-loop">Initialize List to a variable in a Dictionary inside a loop</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>Is there a more elegant way to write this code? </p>
<p>What I am doing: I have keys and dates. There can be a number of dates assigned to a key and so I am creating a dictionary of lists of dates to represent this. The following code works fine, but I was hoping for a more elegant and Pythonic method. </p>
<pre><code>dates_dict = dict() 
for key,  date in cur:
    if key in dates_dict:
        dates_dict[key].append(date)
    else:
        dates_dict[key] = [date] 
</code></pre>
<p>I was expecting the below to work, but I keep getting a NoneType has no attribute append error. </p>
<pre><code>dates_dict = dict() 
for key,  date in cur:
    dates_dict[key] = dates_dict.get(key, []).append(date) 
</code></pre>
<p>This probably has something to do with the fact that</p>
<pre><code>print([].append(1)) 
None 
</code></pre>
<p>but why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list.append</code> returns <code>None</code>, since it is an in-place operation and you are assigning it back to <code>dates_dict[key]</code>. So, the next time when you do <code>dates_dict.get(key, []).append</code> you are actually doing <code>None.append</code>. That is why it is failing. Instead, you can simply do</p>
<pre><code>dates_dict.setdefault(key, []).append(date)
</code></pre>
<p>But, we have <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict"><code>collections.defaultdict</code></a> for this purpose only. You can do something like this</p>
<pre><code>from collections import defaultdict
dates_dict = defaultdict(list)
for key, date in cur:
    dates_dict[key].append(date)
</code></pre>
<p>This will create a new list object, if the <code>key</code> is not found in the dictionary.</p>
<p><strong>Note:</strong> Since the <code>defaultdict</code> will create a new list if the key is not found in the dictionary, this will have unintented side-effects. For example, if you simply want to retrieve a value for the key, which is not there, it will create a new list and return it.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a more elegant way to write this code?</p>
</blockquote>
<p>Use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">collections.defaultdict</a>:</p>
<pre><code>from collections import defaultdict

dates_dict = defaultdict(list)
for key, date in cur:
    dates_dict[key].append(date)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dates_dict[key] = dates_dict.get(key, []).append(date)</code> sets   <code>dates_dict[key]</code> to <code>None</code> as <code>list.append</code> returns <code>None</code>.</p>
<pre><code>In [5]: l = [1,2,3]

In [6]: var = l.append(3)

In [7]: print var
None
</code></pre>
<p>You should use <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow">collections.defaultdict</a></p>
<pre><code>import collections
dates_dict = collections.defaultdict(list)
</code></pre>
</div>
<span class="comment-copy">You should look into <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></span>
<span class="comment-copy">you may try using extend() instead of append()</span>
<span class="comment-copy"><code>for key,  date in cur:</code> - what is <code>cur</code> ?</span>
<span class="comment-copy">@Mawg this was a while ago, but I was probably using a cursor object associated with Python's sqlite3 library.</span>
<span class="comment-copy">@chepner: Note that <code>__missing__()</code> is not called for any operations besides <code>__getitem__()</code>. This means that <code>get()</code> will, like normal dictionaries, return <code>None</code> as a default rather than using <code>default_factory</code> i.e., <code>key in dates_dict</code> and <code>dates_dict.get(key)</code> work as expected</span>
<span class="comment-copy">Just as a followup. I ended up using setdefault as this git me exactly what I wanted without an extra import. Thanks for the help</span>
<span class="comment-copy">Your explanation of why <code>[].append</code> returns <code>None</code> doesn't make sense to me. If you are assigning or printing it immediately, why does it matter it is an in-place operation? Why would <code>dates_dict.get(key, []).append</code> yield <code>None</code> unless <code>dates_dict[key] == None</code>?</span>
<span class="comment-copy">Exactly! In one of the iterations, the result of append is stored against the key and the same is retrieved with get and appended. But this time it's not a list but None</span>
<span class="comment-copy">What's the advantage of using defaultdict over setdefault ?</span>
<span class="comment-copy">When I try <code>for key, date_list in dates_dict:</code>, I get <code>error: too many values to unpack (expected 2)</code></span>
<span class="comment-copy">@Mawg look at the code in the answer. I don't see your example there.</span>
<span class="comment-copy">Sorry, what I meant was that I find lots of examples of how to put the values in, but my problem was getting them back out :-)  Nvm, I figured it out</span>
<span class="comment-copy">Yeah, that's what I thought. As there is no value returned. It will return None as default. Thanks</span>
<span class="comment-copy">@MichaelMurphy, using defaultdict will be the most efficient way to do what you want</span>
