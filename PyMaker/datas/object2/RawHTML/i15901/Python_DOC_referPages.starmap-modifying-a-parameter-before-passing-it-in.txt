<div class="post-text" itemprop="text">
<p>I have a strange bug that I'm encountering when trying to use multiprocessing.Pool.starmap. The minimum code needed to reproduce the bug is here :</p>
<pre><code>from multiprocessing import Pool

# Ignore the fact that this class is useless as-is, it has more code but it wasn't relevant to the bug
class Coordinate(tuple) :                                                                          

    def __new__(cls, *args):                                                                   
        return tuple.__new__(cls, args)                                                        

#Essentially just stores two coordinates
class Move :                                                     

    def __init__(self, oldPos, newPos) :      
        self.oldPos = oldPos                  
        self.newPos = newPos                  

    def __str__(self) :      
        return 'Old pos : ' + str(self.oldPos) + ' -- New pos : ' + str(self.newPos)

#Dummy function to show the problem
def funcThatNeedsTwoParams(move, otherParam) :
    print(move)             
    # Second param ignored, no problem there

p = Pool(2)  
moveOne = Move(Coordinate(0, 2), Coordinate(0, 1))
moveTwo = Move(Coordinate(2, 1), Coordinate(3, 0))
moveThree = Move(Coordinate(22345, -12400), Coordinate(153, 2357))
# The numbers are irrelevant, no effect on whether problem shows up or not

moves = [moveOne, moveTwo, moveThree]
paramsForStarmap = [[move, 'other param'] for move in moves]

print(paramsForStarmap)
#Output : 
#[[&lt;__main__.Move object at 0x1023d4438&gt;, 'other param'], [&lt;__main__.Move object at 0x1023d4470&gt;, 'other param'], [&lt;__main__.Move object at 0x1023d44a8&gt;
for move in [params[0] for params in paramsForStarmap] :
    print(move)
#Output : 
#Old pos : (0, 2) -- New pos : (0, 1)
#Old pos : (2, 1) -- New pos : (3, 0)
#Old pos : (22345, -12400) -- New pos : (153, 2357)
p.starmap(funcThatNeedsTwoParams, paramsForStarmap)
#Output :
#Old pos : ((0, 2),) -- New pos : ((0, 1),)
#Old pos : ((22345, -12400),) -- New pos : ((153, 2357),)
#Old pos : ((2, 1),) -- New pos : ((3, 0),)
</code></pre>
<p>Basically, I have an array of pairs of parameters, something like this : [[move, otherParam], [move, otherParam], ...], I print out every first parameter to show that the moves are valid before using the starmap function. Then I call the starmap function using the pool that was created earlier, and tell it to use the pairs of parameters I have. Then, inexplicably, every move's coordinates become tuples of the form ((coordinate), ), instead of (coordinate).</p>
<p>I can't seem to figure out why starmap would change the properties of an object passed to it, any help would be greatly appreciated, thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is an interesting one. The issue isn't just with <code>starmap</code>. It happens with all <code>Pool</code> functions - <code>apply</code>, <code>map</code>, etc. And, as it turns out, the issue isn't with <code>multiprocessing</code> at all. It's happens when you pickle/unpickle the <code>Coordinate</code> class:</p>
<pre><code>&gt;&gt;&gt; c = Coordinate(0,2)
&gt;&gt;&gt; print(c)
(0, 2)
&gt;&gt;&gt; str(pickle.loads(pickle.dumps(c)))
'((0, 2),)'
</code></pre>
<p>Pickling a <code>tuple</code> subclass isn't as straightforward as it looks, at it turns out. You can fix it by defining a <a href="https://docs.python.org/3/library/pickle.html#object.__reduce__" rel="nofollow"><code>__reduce__</code></a> method that fixes the pickling process:</p>
<pre><code>class Coordinate(tuple):
    def __new__(cls, *args):
        return tuple.__new__(cls, args)

    def __reduce__(self):
        return (self.__class__, tuple(self))
</code></pre>
<p>Now it pickles just fine:</p>
<pre><code>&gt;&gt;&gt; c = Coordinate(0,2)
&gt;&gt;&gt; pickle.loads(pickle.dumps(c))
(0, 2)
</code></pre>
<p>And your example code works fine, too.</p>
</div>
<span class="comment-copy">Great, thanks for the answer! How did you find out that pickling was what was causing the issue?</span>
<span class="comment-copy">@MarcusBuffett Well, first I noticed that the breakage happened when I used <code>map</code> and <code>apply</code>, so I knew it wasn't a <code>starmap</code> problem. Then I added print statements inside of the <code>Pool</code> code to trace the output of printing the <code>Move</code> instance, and noticed that the point at which the <code>Coordinates</code> got broken was as soon as it got to the worker process. My next thought was that something weird was happening when <code>Coordinate</code> got pickled, since it was a <code>tuple</code> subclass, which an unusual pattern. So I tested it and confirmed that was the issue.</span>
<span class="comment-copy">Thanks! Last question, you said you added print statements inside the Pool code, how did you do that? Seems like a useful debugging trick</span>
<span class="comment-copy">@MarcusBuffett Opened up /usr/lib/python3.4/multiprocessing/pool.py in a text editor, and started hacking away. :)</span>
<span class="comment-copy">Great, thanks for all the help!</span>
