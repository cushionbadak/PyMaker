<div class="post-text" itemprop="text">
<p>I've written a simple wordslist generator in python 3.4, I'm still learning so it's not the best code to do it but I'm just trying to get deeper and understand the language and it's logic, first here is my code:</p>
<pre><code>import random
letters = ['a','b','c','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9','0']
wordslist = []
def Generate_words(_from,_to,_length):
    while _from &lt;= _to:
        random_word = _length*random.choice(letters)
        if (random_word) in (wordslist): 
            print ("Word already exists, looking for another one..") 
        else: 
            wordslist.append(random_word)
            print ("total of "+str(_from)+" generated word(s) added to wordlist..")
            progress = _from/_to*100
            print ('total progress is: '+str(progress)+'%')
            _from = _from+1

    if _from &gt; _to:
        print ("Wordslist generated: ")
        print (wordslist)

Fnumber = input ("Enter the total number of words you want to generate: ")
Snumber = input ("Enter the length of each word: ")
Generate_words(1,int(Fnumber),int(Snumber))
Exit = input("Press any key to exit")
</code></pre>
<p>Now I know that this line: random_word = _length*random.choice(letters) will generate X number of identical letters and this is the first problem I'm trying to fix.
The second thing I'm trying to do is finding a way that prevents the script from generating a previously generated word which will make it faster and more efficient </p>
</div>
<div class="post-text" itemprop="text">
<p>Your code works fine, except for the <code>_length*random.choice(letters)</code> line. What you really want there is to pick a new random character each time. This can be done in two ways. You could just use a for loop:</p>
<pre><code>random_word = ''
for j in range(_length):
    random_word += random.choice(letters)
</code></pre>
<p>However, this is quite an ugly way of doing it, since you are (1) appending to a string, which is inefficient and (2) not making use of one of Python's semi-unique features, a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>. </p>
<p>A better way to do this is to use a list comprehension along with the <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow">str.join()</a> method.</p>
<pre><code>random_word = ''.join((random.choice(letters) for i in range(length))
</code></pre>
<p>In addition, when you want to check whether something is in a collection, a <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow">set</a> is a better choice than a list (it's <em>much</em> faster for checking membership).</p>
<p>So, <code>wordslist = []</code> becomes <code>wordlist = set()</code> and <code>wordlist.append(random_word)</code> becomes <code>wordlist.add(random_word)</code>.</p>
<p>You can get the list of lowercase letters and digits from the <code>string</code> library, so you don't have to type them out manually. So: <code>letters = ['a', 'b'...]</code> becomes <code>letters = string.ascii_lowercase + string.digits</code>. Note that the resulting object is a string, not a list, but for our purposes, that doesn't matter.</p>
<p>There are also a few minor style problems in the code, such as starting variable names with capital letters. More importantly, names starting with <code>_</code> have a special meaning in Python, they generally signify that a variable is private (and not meant to be used outside its class). It's generally a good idea to follow the guidelines outlined in <a href="http://legacy.python.org/dev/peps/pep-0008/#naming-conventions" rel="nofollow">PEP8</a> for style. I've fixed these and slightly changed some other things. The full code is pasted below. I'd be happy to further clarify the minor changes if you have questions.</p>
<pre><code>import random
import string

letters = string.ascii_lowercase + string.digits
wordslist = set()

def generate_words(number, length):
    i = 0
    while i &lt; number:
        random_word = ''.join(random.choice(letters) for i in range(length))
        if random_word in wordslist: 
            print("Word already exists, looking for another one..") 
        else: 
            wordslist.add(random_word)
            print("total of "+str(i+1)+" generated word(s) added to wordlist..")
            progress = (i+1)/number*100
            print ('total progress is: '+str(progress)+'%')
            i += 1
    else:
        print("Wordslist generated: ")
        print(wordslist)

if __name__ == '__main__':
    f_number = input ("Enter the total number of words you want to generate: ")
    s_number = input ("Enter the length of each word: ")
    generate_words(int(f_number),int(s_number))
    input("Press any key to exit")
</code></pre>
<p><strong>EDIT:</strong> There was a bug in the <code>for</code> loop that would have caused less words to be generated if a duplicate was found. Fixed now.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, by convention, function and variable names should not start with an upper case letter. This is reserved for classes. That being said, about your questions:</p>
<p>1.</p>
<p>The product of an integer multiplied by a string contains that very string repeated as often as the operation implies. As your expression <code>random.choice(letters)</code> is evaluated first, the multiplication will simply repeat its result. To create a list of random characters, it has to be:</p>
<pre><code>random_chars = [random.choice(letters) for i in range(_length)]
</code></pre>
<p>...which can be collapsed to a string using:</p>
<pre><code>random_word = ''.join(random_chars)
</code></pre>
<p>2.</p>
<p>Instead of using a list instance with poor lookup performance, put your words into a dictionary for logarithmic lookup time:</p>
<pre><code>wordslist = {}
#...
if wordslist.get(random_word):
#...
wordslist[random_word] = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is extremely close to working!</p>
<p>The only thing I changed was your line <code>random_word = _length*random.choice(letters)</code></p>
<p>which I changed to        </p>
<pre><code>random_word = '' #we need a new random_word for each iteration of the loop
    for index in range(0,_length): #we need our words to be _length long
        random_word += random.choice(letters) #add a new letter to our random word
</code></pre>
<p>Basically, what's happening is that your random_word is saying "pick a random letter, and whatever the length of the word is, put n of them next to each other". Hence you always getting "xx", "00", "ff" etc. for your words.</p>
<p>The difference in my code is that it's actually picking n random letters. Your code is picking 1 random letter, and concatenating n of them together.</p>
<p>As far as preventing it from generating a previously generated word, this might be a little too much theory going on here, but that's kind of impossible.... if you KNOW that you can't generate something, then what you're generating isn't random.</p>
</div>
<span class="comment-copy">This is exactly what I was looking for. Thanks for your reply, really appreciate it</span>
<span class="comment-copy">A <code>set()</code> is better than a <code>dict()</code> in this case, since we only want the membership check.</span>
<span class="comment-copy">Good point. I was already one step ahead of myself, thinking about maintaining a custom dictionary structure for on-the-fly lookup during generation. +1 for your elaborate, python3-conforming answer!</span>
