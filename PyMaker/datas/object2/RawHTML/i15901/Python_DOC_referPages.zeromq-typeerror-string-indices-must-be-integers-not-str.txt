<div class="post-text" itemprop="text">
<p>I want to establish publish subscribe communication between to machines.</p>
<p>The two machines, that I have, are <code>ryu-primary</code> and <code>ryu-secondary</code></p>
<p>The steps I follow in each of the machines are as follows.</p>
<p>In the initializer for <code>ryu-primary</code> (IP address is 192.168.241.131)</p>
<pre><code> self.context    = zmq.Context()
 self.sub_socket = self.context.socket(zmq.SUB)
 self.pub_socket = self.context.socket(zmq.PUB)
 self.pub_port   = 5566
 self.sub_port   = 5566


def establish_zmq_connection(self):                      # Socket to talk to server
    print( "Connection to ryu-secondary..." )
    self.sub_socket.connect( "tcp://192.168.241.132:%s" % self.sub_port )

def listen_zmq_connection(self):
    print( 'Listen to zmq connection' )
    self.pub_socket.bind( "tcp://*:%s" % self.pub_port )

def recieve_messages(self):
    while True:
        try:
            string = self.sub_socket.recv( flags=zmq.NOBLOCK )
            print( 'flow mod messages recieved {}'.format(string) )
            return string
        except zmq.ZMQError:
            break

def push_messages(self,msg):
    self.pub_socket.send( "%s" % (msg) )
</code></pre>
<p>From ryu-secondary (IP address - 192.168.241.132)</p>
<p>In the initializer </p>
<pre><code>    self.context    = zmq.Context()
    self.sub_socket = self.context.socket(zmq.SUB)
    self.pub_socket = self.context.socket(zmq.PUB)
    self.pub_port   = 5566
    self.sub_port   = 5566


def establish_zmq_connection(self):                     # Socket to talk to server
     print( "Connection to ryu-secondary..." )
     self.sub_socket.connect( "tcp://192.168.241.131:%s" % self.sub_port )

def listen_zmq_connection(self):
     print( 'Listen to zmq connection' )
     self.pub_socket.bind( "tcp://*:%s" % self.pub_port )

def recieve_messages(self):
    while True:
        try:
            string = self.sub_socket.recv( flags=zmq.NOBLOCK )
            print( 'flow mod messages recieved {}'.format(string) )
            return string
        except zmq.ZMQError:
            break

def push_messages(self,msg):
    print( 'pushing message to publish socket' )
    self.pub_socket.send( "%s" % (msg) )
</code></pre>
<p>These are the functions that I have.</p>
<p>I am calling on <code>ryu-secondary</code>:</p>
<pre><code>establish_zmq_connections()
push_messages() 
</code></pre>
<p>On <code>ryu-primary</code>, when I call </p>
<pre><code>listen_zmq_connection()
recieve_messages() 
</code></pre>
<p><strong>after</strong> subscribing to all types of messages using <strong><code>.setsockopt( zmq.SUBSCRIBE = '')</code></strong></p>
<p>However the message I am trying to send is of the following type.</p>
<pre><code>msg = {'in_port':in_port,'dst':dst,'actions':actions}
self.push_messages(msg)
</code></pre>
<p>However on the other side (<code>recieve_messages()</code> I get the following error when I do this</p>
<pre><code>flow_mod = recieve_messages() 

flow_mod['in_port']
flow_mod['dst']
flow_mod['actions']


TypeError: string indices must be integers, not str
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>msg</code> is a Python dict, but you are sending (and receiving) messages formatted as strings. Probably the easiest thing to do is to serialize <code>msg</code> to JSON format, send it as a string, then load the received string back into a dict again. Then, and only then, will you be able to access the keys and values properly. Something like this should work (make sure you <code>import json</code> somewhere above):</p>
<pre><code># on the sending end
msg = {'in_port':in_port,'dst':dst,'actions':actions}
msg_string = json.dumps(msg)
self.push_messages(msg)

# on the receiving end
payload = receive_messages()
message = json.loads(payload)
</code></pre>
<p>You can find the full docs for the <code>json</code> module <a href="https://docs.python.org/2/library/json.html" rel="nofollow">here</a> (for Python 2) and <a href="https://docs.python.org/3/library/json.html" rel="nofollow">here</a> for Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<h2>ZeroMQ API background</h2>
<p>ZeroMQ <strong><code>.send()</code></strong> <strong><code>.recv()</code></strong> methods operate on strings. You pass to them a dictionary object they do not know how to process. Transform dictionary object to a JSON-format, as an example of a serialisation aimed to this very situation and your job is done.</p>
<h2>The answer = What is the reason for getting a TypeError?</h2>
<p>As writen, the ZeroMQ's <code>.send()</code> method could not do much about sending an object it does not understand and the .recv() part still reads whatever gets delivered on the ZeroMQ layer.</p>
<p>Thus your <strong><code>flow_mod</code></strong> variable, correctly, receives a <strong>string</strong> as <strong><code>return string</code></strong> instruction in the function <strong><code>recieve_messages()</code></strong> orders.</p>
<p>The <strong><code>string = self.sub_socket.recv( flags=zmq.NOBLOCK )</code></strong> simply serves any string, being it an empty one or any non-zero-length string as received from opposite side of the socket.</p>
<p><strong>Finally:</strong>
The <strong><code>flow_mod['in_port']</code></strong> will syntactically crash ( and must do so ), because the content of the variable <code>flow_mod</code>, assigned &amp; type-adjusted right before this, has no dictionary-alike access method to handle this type of syntax.</p>
<p>Thus the <strong><code>TypeError: string indices must be integers, not str</code></strong> exception must be raised here.</p>
<p><strong>Q.E.D.</strong></p>
<hr/>
<h2>JSON serialised representation of objects - Encoding &amp; Decoding intro:</h2>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; print json.__doc__
JSON (JavaScript Object Notation) &lt;http://json.org&gt; is a subset of
JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data
interchange format.

[json] exposes an API familiar to users of the standard library
[marshal] and [pickle] modules. It is the externally maintained
version of the [json] library contained in Python 2.6, but maintains
compatibility with Python 2.4 and Python 2.5 and (currently) has
significant performance advantages, even without using the optional C
extension for speedups.

Encoding basic Python object hierarchies::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
    '["foo", {"bar": ["baz", null, 1.0, 2]}]'
    &gt;&gt;&gt; print json.dumps("\"foo\bar")
    "\"foo\bar"
    &gt;&gt;&gt; print json.dumps(u'\u1234')
    "\u1234"
    &gt;&gt;&gt; print json.dumps('\\')
    "\\"
    &gt;&gt;&gt; print json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
    {"a": 0, "b": 0, "c": 0}
    &gt;&gt;&gt; from StringIO import StringIO
    &gt;&gt;&gt; io = StringIO()
    &gt;&gt;&gt; json.dump(['streaming API'], io)
    &gt;&gt;&gt; io.getvalue()
    '["streaming API"]'

Compact encoding::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; json.dumps([1,2,3,{'4': 5, '6': 7}], sort_keys=True, separators=(',',':'))
    '[1,2,3,{"4":5,"6":7}]'

Pretty printing::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; print json.dumps({'4': 5, '6': 7}, sort_keys=True,
    ...                  indent=4, separators=(',', ': '))
    {
        "4": 5,
        "6": 7
    }

Decoding JSON::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]
    &gt;&gt;&gt; json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]') == obj
    True
    &gt;&gt;&gt; json.loads('"\\"foo\\bar"') == u'"foo\x08ar'
    True
    &gt;&gt;&gt; from StringIO import StringIO
    &gt;&gt;&gt; io = StringIO('["streaming API"]')
    &gt;&gt;&gt; json.load(io)[0] == 'streaming API'
    True

Specializing JSON object decoding::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; def as_complex(dct):
    ...     if '__complex__' in dct:
    ...         return complex(dct['real'], dct['imag'])
    ...     return dct
    ...
    &gt;&gt;&gt; json.loads('{"__complex__": true, "real": 1, "imag": 2}',
    ...     object_hook=as_complex)
    (1+2j)
    &gt;&gt;&gt; from decimal import Decimal
    &gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1')
    True

Specializing JSON object encoding::

    &gt;&gt;&gt; import json
    &gt;&gt;&gt; def encode_complex(obj):
    ...     if isinstance(obj, complex):
    ...         return [obj.real, obj.imag]
    ...     raise TypeError(repr(o) + " is not JSON serializable")
    ...
    &gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex)
    '[2.0, 1.0]'
    &gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j)
    '[2.0, 1.0]'
    &gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))
    '[2.0, 1.0]'
</code></pre>
</div>
<span class="comment-copy">@WarrenWeckesser - I want to access the information contained in that dictionary namely the values of the keys 'in_port','dst' and 'actions'</span>
<span class="comment-copy">thanks for the reply.Can you please explain how to do that.I am not very proficient in python?</span>
<span class="comment-copy">@liv2hak see my edit above</span>
<span class="comment-copy">thanks for the reply.Can you please explain how to do that.I am not very proficient in python?</span>
<span class="comment-copy">Got a straight downvote? Tell me why Brave Anonymous Downvoter, this is mediocre practice...</span>
<span class="comment-copy">I pressed upvote the system downvoted you :( I have reverted it.Will upvote once it works :)</span>
<span class="comment-copy">@liv2hak No problem on your -1/+1, but there was another downvote before yours.</span>
