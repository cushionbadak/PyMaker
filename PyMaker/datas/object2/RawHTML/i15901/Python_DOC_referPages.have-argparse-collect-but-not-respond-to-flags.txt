<div class="post-text" itemprop="text">
<p>I have a script which takes in some arguments, uses some of those argument to choose a script to run, and passes the rest of the arguments to that script. So it looks something like this:</p>
<pre><code>parser = ArgumentParser()
parser.add_argument('script', choices['a', 'b'])
parser.add_argument('rest_args', nargs='*')
args = parser.parse_args()
if args.script == 'a':
    subprocess.call('python a.py %s' % ' '.join(args.rest_args))
else:
    subprocess.call('python b.py %s' % ' '.join(args.rest_args))
</code></pre>
<p>This works fine, unless I want to pass in arguments that start with <code>-</code>. For example, if I called <code>python my_script.py a --foo</code>, I'd get an error <code>unrecognized arguments</code>, when really I want to just have it run <code>python a.py --foo</code> (i.e. just pass the <code>--foo</code> along to the subprocess).</p>
<p>Is there a way to get around this with <code>argparse</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps you are looking for <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args" rel="noreferrer">parse_known_args</a>. It will parse all the options it recognizes, and returns all the unrecognized arguments in <code>unknown</code>:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('script', choices=['a', 'b'])

args, unknown = parser.parse_known_args(['a', '--foo'])

print(args)
# Namespace(script='a')
print(unknown)
# ['--foo']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I discovered the function <code>parse_known_args</code>, which provides a solution to this, albeit perhaps not ideal.</p>
<pre><code>parser = ArgumentParser()
parser.add_argument('script', choices['a', 'b'])
args, rest_args = parser.parse_known_args()
if args.script == 'a':
    subprocess.call('python a.py %s' % ' '.join(rest_args))
else:
    subprocess.call('python b.py %s' % ' '.join(rest_args))
</code></pre>
<p>What this does is use <code>parse_known_args</code> to parse what's known, and collect the rest in a list. Then those remaining arguments can be passed to the subprocess as desired.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>'*'</code> works if you include <code>'--'</code> in the argument list:</p>
<pre><code>1502:~/mypy$ python2.7 stack26264831.py a -- --foo bar
Namespace(rest_args=['--foo', 'bar'], script='a')
</code></pre>
<p>An alternative is to use <code>REMAINDER</code> ('...') instead of '*':</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('script', choices=['a', 'b'])
parser.add_argument('rest_args', nargs=argparse.REMAINDER)
args = parser.parse_args()
print args

1500:~/mypy$ python2.7 stack26264831.py a --foo bar
Namespace(rest_args=['--foo', 'bar'], script='a')
</code></pre>
<p>Both the '--' and REMAINDER mean: 'treat what follows as positional arguments'.</p>
<p><code>parse_known_args</code> also works, though its logic is different - 'just return a list of the strings you didn't recognize'.  <code>parse_args</code> calls <code>parse_known_args</code> and raises an error is the <code>rest</code> value is not empty.</p>
<hr/>
<p>But don't use <code>REMAINDER</code> as the first positional argument:  <a href="https://stackoverflow.com/questions/43219022/using-argparse-remainder-at-beginning-of-parser-sub-parser">Using argparse.REMAINDER at beginning of parser / sub parser</a></p>
</div>
<span class="comment-copy">What is foo? Is it the arg name or a value you want to store into rest_args?</span>
<span class="comment-copy">I want it to be stored in <code>rest_args</code>.</span>
<span class="comment-copy">argparse, when it faces a - or --, is looking in your args definition, for any optional arg having foo as name. I don't believe this is possible and to be honest this is not logical. None of the unix commands take a value with -- prefix</span>
<span class="comment-copy">I just posted this exact thing as a solution! I'll give you the check though :)</span>
