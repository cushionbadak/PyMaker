<div class="post-text" itemprop="text">
<p>In Python 3, <code>dict_values</code>, <code>dict_keys</code> and <code>dict_items</code> do not support indexing</p>
<pre><code>my_dict = {'a': 0', 'b': 1', 'c': 2}
</code></pre>
<p>All of the queries below fail:</p>
<pre><code>my_dict.keys()[1]
my_dict.values()[1]
my_dict.items()[1]
</code></pre>
<p>for that reason. </p>
<p>Sometimes I just want to get a random sample of what's in my dictionary. I know I can convert them their output to lists. Do they have any other getter methods that do not require creating another data structure? (I would also imagine that converting them to a list would create a copy, which may not work well for huge dictionaries).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Sometimes I just want to get a random sample of what's in my dictionary. I know I can convert them their output to lists. Do they have any other getter methods that do not require creating another data structure? (I would also imagine that converting them to a list would create a copy, which may not work well for huge dictionaries).</p>
</blockquote>
<p>The key types are explained under <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow">Dictionary view objects</a>, and also guaranteed to be subclasses of <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow"><code>collections.abc.KeysView</code></a> and friends. Basically, this means you can only count on them having <code>__contains__</code>, <code>__iter__</code>, and <code>__len__</code>.</p>
<p>They don't directly support indexing because their ordering can be invalidated.* But practically, in any implementation of Python, they're only actually invalidated if you mutate the dictionary. Which means you can safely do things like this:</p>
<pre><code>next(itertools.islice(my_dict.keys(), i, None))
</code></pre>
<p>Basically, the same way you'd index a <code>set</code>, or any other non-iterator iterable.</p>
<p><sub>* The actual rules as to what behavior is documented have changed a few times. The current version actually says "They provide a dynamic view on the dictionaryâ€™s entries, which means that when the dictionary changes, the view reflects these changes," which implies the practical rule can now be relied on. But even if you're using an older version that, e.g., explicitly only guarantees consistency between adjacent calls to <code>keys</code>, <code>values</code>, <code>items</code>, and related functions, unless you're worried about someone writing a new implementation of Python 2.6 or 3.1 or something, there's no reason to worry about that.</sub></p>
<hr/>
<p>Of course you probably want to wrap that up in a function that's more readable. In fact, I'd do it in two steps. First, use the <code>nth</code> function from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> recipes</a>:</p>
<pre><code>def nth(iterable, n, default=None):
    return next(itertools.islice(iterable, n, None), default)
</code></pre>
<p>Then wrap up the key indexing:</p>
<pre><code>def getkey(mapping, index, default=None):
    return nth(mapping.keys(), index, default)
</code></pre>
<p>What if you want a random sample? Well, dictionary views are <code>Sized</code>, as are dictionaries themselves, so you can always use <code>randrange</code>:</p>
<pre><code>def choosekey(mapping):
    return getkey(mapping, random.randrange(len(mapping)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want <em>a</em> key, value or item, use <code>next()</code> and <code>iter()</code>:</p>
<pre><code>next(iter(my_dict))
next(iter(my_dict.values()))
next(iter(my_dict.items()))
</code></pre>
</div>
<span class="comment-copy">Do you need a <i>random</i> sample (i.e., uniformly chosen from the keys), or just an <i>arbitrary</i> sample (i.e., you don't care which key you get, and don't care if you get the same one every time)?  Using <code>[1]</code>, for instance, is not going to give you a random sample.</span>
<span class="comment-copy">Thanks BrenBarn - Good point. I am looking for a way of getting an arbitrary sample. It does not have to be random.</span>
