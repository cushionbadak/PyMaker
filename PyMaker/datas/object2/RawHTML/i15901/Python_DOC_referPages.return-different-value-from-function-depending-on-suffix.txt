<div class="post-text" itemprop="text">
<p>Kind of similar to a class, but should also work inside a class. I'm not sure if it's possible, and not sure the correct keywords to search for, so apologies if there's already an answer.</p>
<p>For example, I mean like this -</p>
<pre><code>def location():
    x = 5
    y = 0
    z = 0
    return x,y,z
</code></pre>
<p>Then by typing location().x, you'd get the number 5. It'd be a lot better using <code>location().x</code> instead of <code>location()[0]</code> in my opinion.</p>
<p>Edit: I'm asking for this way instead of a class as you may want to have it inside a class, something like <code>objectInfo( object ).getLocation().x</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow"><code>collections.namedtuple</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt;
&gt;&gt;&gt; XYZ = namedtuple('XYZ', ['x', 'y', 'z'])
&gt;&gt;&gt;
&gt;&gt;&gt; def location():
...     return XYZ(5, 0, 0)
...
&gt;&gt;&gt; location().x
5
</code></pre>
<p>using <code>namedtuple</code>, you can still access the values using indexing <code>[..]</code>:</p>
<pre><code>&gt;&gt;&gt; location()[0]
5
</code></pre>
<hr/>
<p><strong>UPDATE</strong></p>
<p>If you use Python 3.3+, you can also use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow"><code>types.SimpleNamespace</code></a>:</p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; def location():
...     return SimpleNamespace(x=5, y=0, z=0)
...
&gt;&gt;&gt; location().x
5
</code></pre>
<p>Otherwise, use following class (which came from the above <code>SimpleNamespace</code> link):</p>
<pre><code>class SimpleNamespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
    def __repr__(self):
        keys = sorted(self.__dict__)
        items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
        return "{}({})".format(type(self).__name__, ", ".join(items))
    def __eq__(self, other):
        return self.__dict__ == other.__dict__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/" rel="nofollow">"bunch"</a>:</p>
<pre><code>&gt;&gt;&gt; class Bunch(object):
...     def __init__(self, **kwargs):
...             self.__dict__.update(kwargs)
... 
&gt;&gt;&gt; def location():
...     return Bunch(x=5, y=0, z=0)
... 
&gt;&gt;&gt; location().x
5
&gt;&gt;&gt; location().y
0
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do it as a matrix</p>
<p>def (x,y,z):
x=1
y=7
z=10``
return A=[x,y,z]</p>
<p>and after you can take the numpers with this way A[1] for x .
I thing you understand what i mean, and this is a way to have your variables in a series  </p>
</div>
<span class="comment-copy">What is the benefit of something like this over actually defining a class?</span>
<span class="comment-copy">Because this way you can put it inside a class. In the example above, you could have getObjectInfo( objectName ).location().x, I'm not sure if it'd be the correct way but I quite like the idea of it.</span>
<span class="comment-copy">I was just going to suggest this.</span>
<span class="comment-copy">Ah thanks, that works great, is setting the named tuple earlier in the code the only way though?</span>
<span class="comment-copy">@Peter, Yes, you should define it before you use it. Alternatively you can use <code>types.SimpleNamespace</code> if you use Pyhton 3.3+: <code>from types import SimpleNamespace; .... return SimpleNamespace(x=5, y=0, z=0)</code></span>
<span class="comment-copy">You could, inefficiently, redefine the named tuple each time <code>location()</code> is called, but you have to define a class <i>somewhere</i>.</span>
<span class="comment-copy">Ah right thanks, I just tried chepners suggestion and it works alright ('return namedtuple('XYZ', ['x', 'y', 'z',])(5,0,0)' if you fancy adding it to the answer), I'll test it out for speed later on</span>
<span class="comment-copy">Thanks a lot, works great, falsetru's method is really good but this way seems a lot better :)</span>
<span class="comment-copy">That's not even valid Python, let alone a return value with attributes.</span>
<span class="comment-copy">I get what he means haha, I'm looking for an alternative way to numbers in square brackets though :)</span>
<span class="comment-copy">ok i thing i help :) ...</span>
