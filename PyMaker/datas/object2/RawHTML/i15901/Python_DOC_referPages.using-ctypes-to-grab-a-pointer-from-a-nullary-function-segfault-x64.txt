<div class="post-text" itemprop="text">
<p>I've reduced my problem to the following toy file and command:</p>
<pre><code>// a.c --&gt; a.out, compiled with `gcc -fPIC -shared a.c`
void* r2() {
  return NULL; // &lt;-- could be anything
}
</code></pre>
<p><code>python -i -c 
"from ctypes import *;
clib = cdll.LoadLibrary('/home/soltanmm/tmp/a.out');
CFUNCTYPE(c_void_p).in_dll(clib,'r2')()"</code></p>
<p>^ results in a segfault in a call directly within <code>ffi_call_unix64</code>.</p>
<p>I'm on an AMD64 Linux machine running Python 2.7. What am I doing wrong?</p>
<h2>EDIT</h2>
<p>To lend weight to how the pointers don't matter, a second example that segfaults:</p>
<pre><code>// a.c --&gt; a.out
int r1() {
  return 1;
}
</code></pre>
<p><code>python -i -c 
"from ctypes import *;
clib = cdll.LoadLibrary('/home/soltanmm/tmp/a.out');
CFUNCTYPE(c_int).in_dll(clib,'r1')()"</code></p>
</div>
<div class="post-text" itemprop="text">
<p>CFUNCTYPE is used for callbacks (or pointers to functions defined as a variable in the shared object). After you do <code>cdll.LoadLibrary</code> you should simply be able to call <code>C</code> functions on the returned library object directly. So something like this should work:</p>
<pre><code>from ctypes import *;
clib = cdll.LoadLibrary('/home/soltanmm/tmp/a.out');
print(clib.r2())
</code></pre>
<p>Method <code>in_dll</code> is generally used to access <strong>variables</strong> that are exported from shared objects. Not functions themselves. An example of using <code>in_dll</code> would be something like this:</p>
<p>File <strong>a.c</strong>:</p>
<pre><code>#include &lt;stdlib.h&gt;

int r2() {
    return 101;
}

int (*f)(void) = r2;
char *p = "Hello World";

char *gethw() {
    return p;
}
</code></pre>
<p>Python script:</p>
<pre><code>from ctypes import *;
clib = cdll.LoadLibrary('/home/soltanmm/tmp/a.out');

# print should call r2() since f is a variable initialized to
# point to function r2 that returns an int. Should 
# print 101
print (CFUNCTYPE(c_int).in_dll(clib,'f')())

# or call r2 directly
print(clib.r2())

# prints out the character (char *) string variable `p'
# should result in 'Hello World' being printed.
print((c_char_p).in_dll(clib,'p').value)

# call the gethw() function that returns a point to a char *
# This too should print 'Hello World'
# we must set the restype c_char_p explicitly since the default
# is to assume functions return `int`
gethw = clib.gethw
gethw.restype = c_char_p
print(gethw())
</code></pre>
<p>More on the usage of ctypes can found in the <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow">Python Documentation</a></p>
</div>
<span class="comment-copy">Why do you expect 0x34 to be a valid virtual address?</span>
<span class="comment-copy">I don't. I expect to have the function return an invalid address. I'm not dereferencing it, and the segfault is clearly occurring in an FFI call not having to do with dereferencing the result. I could replace that with a 0 and it'd still segfault. I've edited the question to indicate the irrelevance of the result.</span>
<span class="comment-copy">Oh, oops. <code>a.out</code> was correct - I'unno why I wrote <code>a.so</code>. I've added the compilation command.</span>
<span class="comment-copy">Wait, then what's up with this <code>in_dll</code> function I've been seeing in the docs?</span>
<span class="comment-copy">in_dll is used to access <b>variables</b> exported from a shared object not the functions themselves. I give an example of using CFUNTYPE to return a variable that is a pointer to a function and then I call it.</span>
<span class="comment-copy">AHHHHH! Okay! I'm a bit weirded out, though, that there's no equivalence of treatment between function pointers and the function symbols. But, cool, thanks.</span>
