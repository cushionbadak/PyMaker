<div class="post-text" itemprop="text">
<p>I want to replace some elements of a list immediately.</p>
<p>Suppose we have these lists:</p>
<pre><code>list = [1, 2, 3, 4, 5, 6]
idx = [1, 3, 4]
new = [100, 200, 300]
</code></pre>
<p>I want to replace elements 1, 3, 4 from <code>list</code> with <code>new</code> values. for example :</p>
<pre><code>list[idx] = new
</code></pre>
<p>so the final list is =&gt; <code>[1, 100, 3, 200, 300, 6]</code></p>
<p>I know you can use it in this way in Matlab, but want to know what should I do in Python?</p>
<p><strong>Note</strong> : I know it's possible to use loops and do this.</p>
<hr/>
<p><strong>Edit</strong> : I want to use a pure python solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>The "pythonic" way would be to use <code>zip</code>:</p>
<pre><code>for i, n in zip(idx, new):
    L[i] = n
</code></pre>
<p>Python itself doesn't support matlab-style array operations, but you can look into numpy if you're interested in that coding style (see @abarnert's answer). </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>L = [1, 2, 3, 4, 5, 6]
idx = [1, 3, 4]
new = [100, 200, 300]
for i in range(len(idx)):
    L[idx[i]] = new[i]
</code></pre>
<p>A slightly slower version without loops:</p>
<pre><code>L = [1, 2, 3, 4, 5, 6]
idx = [1, 3, 4]
new = [100, 200, 300]
L = [num if i not in idx else new[i] for i,num in enumerate(L)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're looking for a Matlab-like solution, there's a good chance you should really be using <a href="http://www.numpy.org/" rel="nofollow">NumPy</a> here. In fact, if you do things that way, you can write exactly the code you wanted:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; idx = [1, 3, 4]
&gt;&gt;&gt; new = [100, 200, 300]
&gt;&gt;&gt; a[idx] = new
&gt;&gt;&gt; a
array([  1, 100,   3, 200, 300,   6])
</code></pre>
<p>Besides giving you Matlab-ish element-wise operators and functions, NumPy also gives you convenient multi-dimensional arrays, and access to a huge library of higher-level functions (especially if you include adjunct libraries like <a href="http://scipy.org/" rel="nofollow">SciPy</a>). Plus you typically get performance benefits like, e.g., 6x speed and .25x space.</p>
<hr/>
<p>If you want a pure-Python solution, it's not <em>that</em> hard to implement this much of NumPy (or as much as you need) in Python. You can write your own <code>Array</code> class that <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow">emulates a container type</a> in any way you want. In particular, note that <code>a[idx] = new</code> calls <code>a.__setitem__(idx, new)</code>. You probably want to handle single numbers and slices the same way as <code>list</code>, but there's nothing at all stopping you from handling other types that <code>list</code> rejects. For example:</p>
<pre><code>def __setitem__(self, idx, value):
    if isinstance(idx, collections.abc.Iterable):
        for i, v in zip(idx, value):
            self.lst[i] = v
    else:
        self.lst[idx] = value
</code></pre>
<p>(You'd probably want to add a bit of error-handling for the case where <code>idx</code> and <code>value</code> have different lengths. You could work out the best rules from first principles, or start by looking at what NumPy does and just decide what you do and don't want to copy…)</p>
<p>Of course it's not an accident that the guts of this implementation will be code very much like alexis's answer, because all we're doing is wrapping up that logic so you only have to write it once, instead of every time you need it.</p>
</div>
<span class="comment-copy">Or to not mutate the list in-place at all; something like <code>d = dict(zip(idx, new)); L = [d.get(idx, value) for idx, value in enumerate(L)]</code>.</span>
<span class="comment-copy">A new list would be more appropriate in many cases, but the question is about updating the list in place.</span>
<span class="comment-copy">Sure, but often the best way to do that is to do it with a new list and then either <code>L =</code> or <code>L[:] =</code>… That may or may not be true in this case, but it's worth it for novices to know both ways to do it so they can choose the right one.</span>
<span class="comment-copy">I agree. Still, in this case updating is so simple that if a new list is desired I would make a copy <i>first</i>, and then apply the edits to the copy.</span>
<span class="comment-copy">First, why use <code>range(len(idx))</code> instead of just <code>zip(idx, new)</code>? Also, the second version has the same loop as the first, and what makes you think it's slower?</span>
<span class="comment-copy">@abarnert: the second one has a lookup for an element in a list, which requires O(n) time; hence the slowdown. <code>zip</code> is definitely a better version than my first loop</span>
<span class="comment-copy">Ah, I didn't see that you were doing it that way; yes, it's slower. But you can pretty easily write a listcomp that's probably <i>faster</i> (except on very small inputs like this, where it's probably slower but who cares?). I'm probably being overly wary because there are so many answers that falsely imply that mutating a list in-place is usually faster than building a new list just because that's true in C, when it's often false and even more often irrelevant in Python; apologies for not reading more carefully.</span>
<span class="comment-copy">Numpy is a good library and i used it before. but I want a pure python solution :)</span>
<span class="comment-copy">@mehD: Well, you can always write this much of NumPy in pure Python; in fact, it's pretty trivial. See my updated answer.</span>
