<div class="post-text" itemprop="text">
<p>What encoding do we consider <code>bytes(map(ord, string))</code> is using? Why is it sometimes true that <code>string.encode('utf-8') != bytes(map(ord, string))</code>?</p>
<p>I ran into this problem when having client side javascript interact with a Django 1.5 (Python 3) application.</p>
<p>Basically I'm uploading an mp3 file as a string (I couldn't find a solution for just uploading the file directly) using ajax and jDataView. I use jDataView to convert the file to a string. In my Django application when I save the file it changes sizes. However if instead of using <code>string.encode('utf-8')</code> I use <code>bytes(map(ord, string))</code> the files saves fine. Why is that? Why is <code>string.encode('utf-8') != bytes(map(ord, string))</code>?</p>
<p>My client side code looks like this:</p>
<pre><code>function send(file) {
    var reader = new FileReader();
    reader.onload = function(event) {
        var self = this;
        $.ajax({
            url: 'upload/',
            type: 'POST'
            data: {contents: (new jDataView(self.result)).getString()}
        });
    }
    reader.readAsArrayBuffer(file);
}
</code></pre>
<p>and my view receives the data like so:</p>
<pre><code>def upload(request):
    contents = request.POST.get('contents')
    track = Track.objects.all[0] # For testing only
    contents = bytes(map(ord, contents))
    track.file.save('file.mp3', ContentFile(contents))
</code></pre>
<p>I checked and <code>contents</code> in both the JS code and Python code are the same thing. They have the same byte length and seem to have the same contents judging by the first and last few characters that fit on my screen.</p>
<p>If I change my code to </p>
<pre><code>def upload(request):
    contents = request.POST.get('contents')
    track = Track.objects.all[0] # For testing only
    contents = contents.encoding('utf-8')
    track.file.save('file.mp3', ContentFile(contents))
</code></pre>
<p>the file changes size and is no longer a valid mp3 file.</p>
</div>
<div class="post-text" itemprop="text">
<p>UTF-8 does <strong>not</strong> map Unicode codepoints straight to bytes. That's only true for ASCII codepoints, in the range U+0000 to U+007F. Beyond that range, UTF-8 uses 2 or more bytes per codepoint:</p>
<pre><code>&gt;&gt;&gt; '\u007f'.encode('utf8')
b'\x7f'
&gt;&gt;&gt; '\u0080'.encode('utf8')
b'\xc2\x80'
</code></pre>
<p>You are thinking of the Latin-1 encoding instead, where the codepoints U+0000 to U+00FF do map directly to bytes:</p>
<pre><code>&gt;&gt;&gt; string = ''.join([chr(i) for i in range(0x100)])
&gt;&gt;&gt; string.encode('latin-1') == bytes(map(ord, string))
True
</code></pre>
<p>Instead of encoding to text, you could base64 encode your binary data before storing, or you can upgrade to Django 1.6 or later, to use a <a href="https://docs.djangoproject.com/en/stable/ref/models/fields/#django.db.models.BinaryField" rel="nofollow noreferrer">binary field type</a>.</p>
</div>
<span class="comment-copy">It's worth noting that if you really do need to pass arbitrary byte data through a text-only channel (rather than just artificially calling something a text-only channel even though it handles arbitrary bytes, as the OP seems to be doing here because of a limitation of Django 1.5, but I'm not sureâ€¦), the right answer is usually <a href="https://docs.python.org/3/library/codecs.html#codec-base-classes" rel="nofollow noreferrer"><code>'surrogateescape'</code></a></span>
<span class="comment-copy">@abarnert: it appears this is more about browser - Django post handler data transfers.</span>
<span class="comment-copy">Thanks. This is exactly what I was looking for. I don't totally understand encodings so this is helpful.</span>
