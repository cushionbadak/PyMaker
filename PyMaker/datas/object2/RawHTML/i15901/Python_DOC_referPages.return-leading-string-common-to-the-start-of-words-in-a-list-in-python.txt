<div class="post-text" itemprop="text">
<p>I'm having one of those experiences where I write something that should be trivial and it takes more lines of code than expected. Can somebody suggest a more elegant solution to the problem of pulling (from a list of words) the leading string that is common to them all? I'm included my code so you can laugh at it. </p>
<pre><code>def _allStartWith( words ):
     """ Return leading string common to (the start of) words in a list  """

     n = len( words[0] )
     for other in words[1:]:
         if other != words[0]:
            n = min( n, _sameFor( other, words[0] ) )
     return words[0][:n]   
</code></pre>
<p>where</p>
<pre><code>def _sameFor( word1, word2 ):
            """ How many letters are the same before one is false ?"""
            return ( [ c1==c2 for c1, c2 in zip( word1, word2 ) ] + [ False ] ).index( False )
</code></pre>
<p>For example,    </p>
<pre><code> _allStartWith( [ 'foo2you and you','foo bar and you'] )
    'foo'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could abuse <a href="https://docs.python.org/3/library/os.path.html#os.path.commonprefix" rel="nofollow"><code>os.path.commonprefix()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.commonprefix(['foo2you and you', 'foo bar and you'])
'foo'
</code></pre>
<p>Here's <a href="https://hg.python.org/cpython/file/0f520ed901a5/Lib/genericpath.py#l67" rel="nofollow">its code</a>:</p>
<pre><code># Return the longest prefix of all list elements.
def commonprefix(m):
    "Given a list of pathnames, returns the longest common leading component"
    if not m: return ''
    s1 = min(m)
    s2 = max(m)
    for i, c in enumerate(s1):
        if c != s2[i]:
            return s1[:i]
    return s1
</code></pre>
</div>
<span class="comment-copy">Can you show some example input and expected output?</span>
<span class="comment-copy">Brilliant!.....</span>
<span class="comment-copy">Love it. Thanks.</span>
