<div class="post-text" itemprop="text">
<p>I'm writing a unit test for a function that will confirm that a function called within it is called with the correct arguments. The problem is that one of the arguments is a generator.</p>
<p>Is there a way to compare the contents of the generator that <code>fn</code> is called with using <a href="http://www.voidspace.org.uk/python/mock/mock.html#mock.Mock.assert_has_calls" rel="nofollow"><code>assert_has_calls</code></a>? An example of the behavior that I'm looking for is exhibited in 'AssertSequenceEqual.' As it is, <code>test_use_fn</code> fails because the generator objects that it is comparing are different.</p>
<pre><code>import mock

def fn(entries):
    pass

def use_fn(entries, convert=lambda x: x):
    entries = (convert(entry) for entry in entries)
    entries = fn(entries)
    entries = fn(entries)

@mock.patch('fn')
def test_use_fn(self, mock_fn):
    mock_fn.return_value = 'baz'
    entries = ['foo', 'bar']
    use_fn(entries)
    call_1 = mock.call((entry for entry in entries))
    call_2 = mock.call('baz')
    mock_fn.assert_has_calls([call_1, call_2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>call_args_list</code> <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_args_list" rel="nofollow">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_args_list</a></p>
<p>I assume that you would check if every items of the generators are the same. I write a <code>assertEqualGenerators()</code> method of the test case class that do the work (if the arguments are not generators use standard <code>assertEqual()</code>). The module file name is <code>mock_generators.py</code> and you must use <code>mock_generators.fn</code> to patch <code>fn</code>. The last trick is the <code>call</code> object arguments: take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.call.call_list" rel="nofollow">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.call.call_list</a> for the dettails of how fetch the data (in your case the first element is what you need).</p>
<pre><code>import unittest
from unittest import mock

def fn(entries):
    pass

def use_fn(entries, convert=lambda x: x):
    entries = (convert(entry) for entry in entries)
    entries = fn(entries)
    entries = fn(entries)

class MyTestCase(unittest.TestCase):

    def assertEqualGenerators(self,a,b):
        try:
            for x,y in zip(a,b):
                self.assertEqual(x, y)
        except TypeError:
            self.assertEqual(a, b)

    @mock.patch("mock_generators.fn")
    def test_use_fn(self, mock_fn):
        mock_fn.return_value = 'baz'
        entries = ['foo', 'bar']
        use_fn(entries)
        calls = [mock.call((entry for entry in entries)),
                    mock.call('baz')]
        self.assertEqual(len(calls), mock_fn.call_count)
        for a,b in zip(mock_fn.call_args_list,calls):
            self.assertEqualGenerators(a[0],b[0])


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">No two generator objects are the same, so they will always fail an equality or <code>is</code> test. The same is true for nested inner functions.</span>
<span class="comment-copy">This seems like an example of the <a href="http://XYproblem.info" rel="nofollow noreferrer">XYproblem.info</a> . Could you explain further about why you want to verify a call like this?</span>
<span class="comment-copy">@aruisdante, I'm aware; that's the heart of the question. An example of the behavior that I'm looking for is exhibited in 'assertSequenceEqual.'</span>
<span class="comment-copy">thanks for pointing me in the direction of call_args_list.</span>
<span class="comment-copy">Use <code>itertools.zip_longest()</code> in <code>assertEqualGenerators()</code>. <code>zip()</code> will fail to report a difference if one generator is longer than the other. You should use an 'impossible' fillvalue, such as <code>object()</code> so it can't accidentally compare equal.</span>
