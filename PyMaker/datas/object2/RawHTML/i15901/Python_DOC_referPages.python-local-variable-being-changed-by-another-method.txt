<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>I wonder if any python folks can fill me in on how/why the following happens:</p>
<pre><code># define a list and send it as an arg to another function
def foo():
    nums=[1,2,3]
    bar(nums)
    print(nums)

# Take the list as an arg and pop the last element off
def bar(numbrs):
    numbrs.pop()

# Call the first function
foo()

# The nums local variable has been modified
[1, 2]
</code></pre>
<p>As a rubyist I find it really strange that a locally defined variable (nums) in the foo function can be changed by an action performed in the bar function! Is this kind of entanglement normal? Is there a name for it?</p>
<p>The two functions don't even use the same name to refer to the list. It's very peculiar. I kind of like it though.</p>
</div>
<div class="post-text" itemprop="text">
<p>A list is an object, and calling a method on an object - such as pop() - affects its state.</p>
<p>To be more precise, let's walk through your code and see what's happening:</p>
<pre><code>def foo():
    nums=[1,2,3]  # create a list and give it a name. nums contains a reference to the list
    bar(nums)     # call the method bar, passing it the reference to that list
    print(nums)   # print the list.
</code></pre>
<p>Okay, so that's pretty clear. What happens in bar is what's concerning to you:</p>
<pre><code># Take the list as an arg and pop the last element off
def bar(numbrs):  # method gets a value. In this case the value is a reference to a list
    numbrs.pop()  # call a method on that object
</code></pre>
<p>So what happens when you call numbrs.pop()? Presumably, in the definition of list, you'll find a method definition:</p>
<pre><code>def pop(self):
</code></pre>
<p>which modifies the state of the self object by removing one of its members, and returns the removed member. </p>
<p>What is self in that case? It's a reference to a list. Specifically, it's the reference that was called numbrs when you did the pop() operation, which is the same reference that you stored as nums when you created it. </p>
<p>I hope this helps - it's a lot of indirection, but if you follow the reference around you'll see how it all goes. </p>
</div>
<div class="post-text" itemprop="text">
<p>The behavior is exactly same with Ruby:</p>
<pre><code>def foo()
  nums = [1,2,3]
  bar(nums)
  p(nums)
end

def bar(numbers)
  numbers.pop
end

foo()
# prints [1, 2]
</code></pre>
<p><a href="http://ideone.com/niRtPw" rel="nofollow">DEMO</a></p>
<p>You can not change the reference of the local variable to reference other variable. But you can call the method that change the state in-place. <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow"><code>list.pop</code></a> is one of such methods. (Same for <a href="http://ruby-doc.org/core-2.0/Array.html#method-i-pop" rel="nofollow"><code>Array#pop</code></a> in Ruby)</p>
</div>
<div class="post-text" itemprop="text">
<p>this is kinda strange, and im not sure if this is an answer to the question, but if you run this:</p>
<pre><code>def foo():
    nums=[1,2,3]
    print "foo"
    print locals()
    print globals()
    bar(nums)
    print "foo-after"
    print locals()
    print globals()
    print(nums)


def bar(numbrs):
    print "bar"
    print locals()
    print globals()
    numbrs.pop()
    print "bar-after"
    print locals()
    print globals()

foo()
</code></pre>
<p>output:</p>
<pre><code>&gt;&gt;&gt; foo()
foo
{'nums': [1, 2, 3]}
{'bar': &lt;function bar at 0x024759B0&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__package__': None, '__name__': '__main__', 'foo': &lt;function foo at 0x024593B0&gt;, '__doc__': None}
bar
{'numbrs': [1, 2, 3]}
{'bar': &lt;function bar at 0x024759B0&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__package__': None, '__name__': '__main__', 'foo': &lt;function foo at 0x024593B0&gt;, '__doc__': None}
bar-after
{'numbrs': [1, 2]}
{'bar': &lt;function bar at 0x024759B0&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__package__': None, '__name__': '__main__', 'foo': &lt;function foo at 0x024593B0&gt;, '__doc__': None}
foo-after
{'nums': [1, 2]}
{'bar': &lt;function bar at 0x024759B0&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__package__': None, '__name__': '__main__', 'foo': &lt;function foo at 0x024593B0&gt;, '__doc__': None}
[1, 2]
</code></pre>
</div>
<span class="comment-copy">this puts a strange feeling in my stomach</span>
<span class="comment-copy">Thanks a lot, I had no idea this happened in Ruby as well as in Python. Your explanation really helps me understand this. Cheers.</span>
<span class="comment-copy">Yes, this is pretty standard for object-oriented languages. There's really a triple-indirection going on here. The name "nums" points to a value on the stack, which points to an object on the heap. Where ruby will be different is that it's more so: in java and python, the value 5 will be on the stack as just 5, but I believe in ruby it's also going to be a reference to an object on the heap. (I may be wrong on this, my ruby is weak... corrections are will be gladly acccepted!)</span>
<span class="comment-copy">@JonKiparsky: Numbers are immutable in Ruby. Since there is no way to mutate a number, you cannot tell the difference between whether it is allocated as an object on the heap or directly allocated on the stack. The actual truth is: neither! Most Ruby implementations optimize small integers (for C implementations that would be integers that fit into a single machine word - 1 bit, for JRuby that's 64 bit) completely away, so that they are represented <i>inside</i> the pointer (aka tagged pointer representation).</span>
<span class="comment-copy">@JÃ¶rgWMittag Makes sense. Thanks!</span>
<span class="comment-copy">Christ, you're right! I just expected Ruby to be different there, but right enough both languages do this.</span>
<span class="comment-copy">@marflar, Before/after call to <code>bar(nums)</code>, try to print id of the <code>nums</code>: <code>print(id(nums))</code>. It will not change.</span>
<span class="comment-copy">Yea. I need to lie down, everything I thought I knew is wrong</span>
<span class="comment-copy">Thanks for this!</span>
