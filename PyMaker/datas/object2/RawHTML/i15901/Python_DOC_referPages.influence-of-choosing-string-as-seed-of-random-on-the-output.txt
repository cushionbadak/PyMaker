<div class="post-text" itemprop="text">
<p>In python, in order to permutate the lettters of a string one can write</p>
<pre><code>import random
random.seed(str_key)
length = range(len(original_str))
random.shuffle(length)
join "".join([original_key[idx] for idx in length])
</code></pre>
<p>I wonder what does seed do with the key string and how it produces from it the permutation (or says shuffle how to do that). For example if I take the key to be 'hGd' how I get that specific output while if I write another key like 'AGd' I get another output?</p>
<p><strong>EDIT</strong>: The decryption algorithm I tried to use on that code is:</p>
<pre><code>for key in itertools.product(*3*[string.ascii_letters]):
    indices = range(len(enc_msg))
    list_encrypted_msg = list(enc_msg)
    random.seed(key)
    random.shuffle(indices)
    decrypted = ""

    for idx in indices[::-1]:
        decrypted += list_encrypted_msg[idx]

    try:
        if not decrypted.index("The"):
            print decrypted
    except ValueError:
        continue
return "not found!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What <code>seed()</code> does with its argument is to pass it to the built-in <code>hash()</code> function, which converts it to a 32 bit signed integer, in other words a number in the range -2,147,483,648 to 2,147,483,647. That number is then used as the starting number by the pseudo-random integer generator (by default, the Mersenne Twister algorithm) that is the heart of the standard random functions. </p>
<p>Each time a pseudo-random number generator (PRNG) is called it does a particular arithmetic operation on its current number to produce a new number. It may return that number as is, or it may return a modified version of that number. See <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow noreferrer">Wikipedia</a> for a simple type of PRNG.</p>
<p>With a good PRNG it is very hard to predict what the next number in the sequence is going to be, and Mersenne Twister is very good. So it's not easy to predict the effect that different seeds will have on the output.</p>
<p>BTW, you can pass <code>seed()</code> any kind of hashable object. So it can be passed an int, string, tuple, etc, but not a list. But as I said above, whatever you pass it, it gets converted to a number.</p>
<p><strong>Update</strong> In recent versions of Python, <a href="https://docs.python.org/3/library/random.html#random.seed" rel="nofollow noreferrer"><code>random.seed</code></a> takes an optional <em>version</em> arg version 1 works as I described above, but version 2 (the default in Python 3.2+) a <code>str</code>, <code>bytes</code>, or <code>bytearray</code> object gets converted to an <code>int</code> and all of its bits are used.</p>
<p>And I guess I should mention that if you call <code>seed()</code> without a seed value it uses the <a href="https://en.m.wikipedia.org/wiki/Entropy_(computing)" rel="nofollow noreferrer">system entropy</a> pool to generate a seed value, and if the system doesn't provide an entropy pool the current time as its seed value.</p>
<hr/>
<p>The Mersenne Twister algorithm has a period of <code>2**19937 - 1</code>, which is a number of about 6000 decimal digits. So it takes a <strong>very</strong> long time before the cycle of integers it produces repeats exactly. Of course, individual integers and sub-sequences of integers will repeat <strong>much</strong> sooner. Python's version of Mersenne Twister doesn't actually return the integers it calculates, it converts them to 53 bit floating-point numbers; I assume it uses 64 bits internally. See the Wikipedia article on the <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow noreferrer">Mersenne Twister</a> if you're curious to know how it works.</p>
<p>FWIW, here's a slightly improved version of your program.</p>
<pre><code>import random

#Convert string to list
msg = list(original_str)

random.seed(str_key)
random.shuffle(msg)
print "".join(msg)
</code></pre>
<hr/>
<p>Now, onto your decryption problem. :) Is the message you have to decrypt merely scrambled, as by the program above, or does it use some other form of encryption? If it's merely scrambled, it will be relatively easy to unscramble. So unless you tell me otherwise, I shall assume that to be the case.</p>
<p>You said that the key length is 3. Is the key purely alphabetic, or can the 3 characters in the key be anything in the range chr(0) to chr(255)? Either way, that's not really a lot of keys to check, and a Python program will be able to unscramble the message using a brute-force search of all keys in less than one <s>second</s> minute.</p>
<hr/>
<p>To iterate over all possible keys, you can do this:</p>
<pre><code>from itertools import product
from string import ascii_letters

for k in product(*3*[ascii_letters]):
    str_key = ''.join(k)
</code></pre>
<p>I used <code>product()</code> in that code because we want to generate all possible strings of 3 ascii letters, so we want the Cartesian product of 3 copies of <code>ascii_letters</code>. <code>3*[ascii_letters]</code> is equivalent to <code>[ascii_letters, ascii_letters, ascii_letters]</code> and putting <code>*</code> in front unpacks that list so that <code>product()</code> gets 3 separate args. If we use <code>permutations()</code> then we don't get any strings with repeated characters. To illustrate:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; s='abc'
&gt;&gt;&gt; [''.join(u) for u in itertools.permutations(s, 3)]
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
&gt;&gt;&gt; [''.join(u) for u in itertools.product(*3*[s])]
['aaa', 'aab', 'aac', 'aba', 'abb', 'abc', 'aca', 'acb', 'acc', 
 'baa', 'bab', 'bac', 'bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 
 'caa', 'cab', 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
</code></pre>
<p><strong>Update</strong> <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> takes a <em>repeat</em> keyword arg, so we can simplify that to <code>itertools.product(s, repeat=3)</code>.
......</p>
<p>I thought you said that the string to be decoded has 42 chars, but there are only 40 chars in <code>euTtSa:0 kty1h a0 nlradstara atlot 5wtic</code>. Also, the appearance of the digits <code>0</code> &amp; <code>5</code> in that string is a bit of a worry, although I guess the original unscrambled version could have digits in it...</p>
<p>Anyway, I just tried unscrambling that string using the shuffle algorithm with all possible 140608 3 letter keys and printing the permutations produced that begin with <code>The</code>. There are only 5 of them, and only one of those had a space after <code>The</code>. But in every case the rest of the unscrambled string is garbage. My guess is that you've misunderstood the encryption algorithm that your lecturer used. </p>
<hr/>
<p>Just in case you were wondering how random.shuffle() works, you can see Python code equivalent to the actual C source code <a href="http://svn.python.org/projects/python/branches/py3k/Lib/random.py" rel="nofollow noreferrer">here</a>. It's like a randomized version of one pass through a selection sort.</p>
<p>Another cute method is to sort the list using a random comparison function, or a random key function. Eg</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.seed(42)
&gt;&gt;&gt; for i in range(10):
...   s.sort(key=lambda i:random.random())
...   print ''.join(s)
...
gabecdf
dbgfeac
agbfdce
cebdgaf
fgedbca
afbecgd
bcaegfd
aebcdfg
bacgfed
fgdebca
</code></pre>
<p>However, the technique used by <code>random.shuffle()</code> is more efficient, and <em>much</em> faster since it's totally implemented in C.</p>
<hr/>
<h2>Reversing the shuffling procedure for a given key</h2>
<p>Let's look at what happens when we shuffle a simple range.</p>
<pre><code>from random import seed, shuffle

r = range(5)
key = 'zap'
seed(key)
shuffle(r) 
</code></pre>
<p>After the shuffle, <code>r</code> will be </p>
<p><code>[2, 4, 1, 3, 0]</code></p>
<p>So to unshuffle <code>r</code> we need to build this list:</p>
<p><code>[r[4], r[2], r[0], r[3], r[1]]</code></p>
<p>Can you see how to do that? If you can't figure it out, I'm happy to post my code, but I think you should spend a little bit of time trying to figure it out first. Hint: Don't try to do it in a list comprehension, just use a <code>for</code> loop.</p>
<hr/>
<p>Ok. You've struggled with this long enough. Here's my decoder.</p>
<pre><code>#! /usr/bin/env python

''' Unscramble a string of text by brute force

From http://stackoverflow.com/questions/26248379/influence-of-choosing-string-as-seed-of-random-on-the-output

'''

import sys
from random import seed, shuffle
from itertools import product
from string import ascii_letters


def scramble(seq, key):
    seed(key)
    msg = seq[:]
    shuffle(msg)
    return msg


def scramble_old(seq, key):
    seed(key)
    r = range(len(seq))
    shuffle(r)
    return [seq[i] for i in r]


def unscramble(seq, key):
    seed(key)
    r = range(len(seq))
    shuffle(r)
    newseq = len(seq) * [None]
    for i, j in enumerate(r):
        newseq[j] = seq[i]
    return newseq


def test():
    key = 'zap'
    #orig = 'quickbrownfox'
    orig = '01234'

    print 'orig:       ', orig
    shuf = scramble(list(orig), key)
    print 'shuffled:   ', ''.join(shuf)
    unshuf = unscramble(shuf, key)
    print 'unshuffled: ', ''.join(unshuf)


def decode(seq, begin):
    count = 0
    begin_len = len(begin)
    for k in product(*3*[ascii_letters]):
        key = ''.join(k)
        dup = seq[:]
        newseq = unscramble(dup, key)
        if newseq[:begin_len] == begin:
            count += 1
            print '%s: [%s] %s' % (key, ''.join(newseq), count)
            #print '     [%s]\n' % ''.join(scramble(newseq, key))


def main():
    original_str = 'euTtSa:0 kty1h a0  nlradstara  atlot 5wtic'.lower()    
    original_list = list(original_str)
    print '     [%s], %d\n' % (original_str, len(original_str))

    decode(original_list, begin=list('the'))


if __name__ == '__main__':
    #test()
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to start by noting the code you posted is a little confusing! message is never named, but I assume you mean the original string by that. So we good. Your question is also confusing. Are you asking what random number generator seeds are? Because that's easy enough. But if you're asking how to get the output of an 'AGd' seeded generator using an 'hGd' seeded generator, that should probably be impossible because 'hGd' is not a permutation of 'AGd' and vice versa. They're simply not in the same set of permutations! But supposing they were, if you're asking how many iterations you would need to get the same output (or a collision, in other words) that would depend on the implementation and the algorithm and whatnot. Maybe it'd be worth looking into the details of python's random module; I'll admit I don't personally know that.</p>
<p>But as for seeding, we could for example write a pseudorandom number generator but iteratively applying the equation <code>y = 5*x + 77 mod 100</code> (where of course this one would be pretty garbage as far as random number generators go). The output on each call will be the equation applied to the input. But obviously this specifies a whole class of generators depending on what the initial value of x is! That's all a random seed is, usually, it's the value of x that starts off the whole process. Now checking the documentation here: <a href="https://docs.python.org/2/library/random.html" rel="nofollow">https://docs.python.org/2/library/random.html</a> I see that random seeds can actually be any hashable object. Consequently, if you feed in a string, the first thing it does is apply some hash function to the string in order to get a suitable seed to the pseudorandom number generator, where, of course, suitable is relative to the implementation of the specific pseudorandom number generator.</p>
<p>If I've misunderstood your question, please accept my humble apologies.</p>
<p>EDIT: PM 2Ring beat me to it, and his answer is better. See his.</p>
</div>
<span class="comment-copy">thanks. So allegedly if I got an encrypted message (I'm taking a course in cryptography right now and alas decrypting a string is a part of the assignment) which I only know that the key is of length 3 and the first word is 'The', I cannot predict what key is used?</span>
<span class="comment-copy">Why do you say "alas"? It would be a pretty poor cryptography course if it had no decryption assignments. :) But that's correct, you can't predict what key was used just by simple analysis of a small sample of the output of a PRNG unless it uses a very simple algorithm with small parameters (like the equation in Stephen's answer). Give me a few minutes and I'll add a little more detail to my answer.</span>
<span class="comment-copy">I said alas because I'm stuck with 42 chars which means nothing to me (right now). The key is composed of 3 captial/small lettters which means I need to go over 52**3 cases. My problem is what to do with the 38 chars remaining after I know the first word (whose length is 3 + space after it).</span>
<span class="comment-copy">So is this string of 42 chars just scrambled using the algorithm in your code (or my version of it). Or is it using a different encryption algorithm?</span>
<span class="comment-copy">yes. I think I can identify there words like "attack" and "The " [the first word which is given] which reduces the problem to 16 chars or so if my lame try for reverse engineering the lecturer is correct.</span>
<span class="comment-copy">Thanks for the compliment, Stephen. If you're curious, you can see the C source code of Python's string hash function in the top answer to <a href="http://stackoverflow.com/questions/2070276/where-can-i-find-source-or-algorithm-of-pythons-hash-function">this question</a>.</span>
<span class="comment-copy">Hey thanks for the source! I'll add it to the list.</span>
