<div class="post-text" itemprop="text">
<p>I created some functions which return 1 if all went well and 0 if there was an error. Now, I need to execute each of these functions in a defined order and verify the return values. If one of them returns 0, I need to reboot immediately, without invoking any of the subsequent functions.</p>
<p>I intended to use multiple <code>if</code>s but with one <code>else</code>:</p>
<pre><code>if function_1():
    if function_2():
        if function_3():
            print "Everything went well"
else:
    reboot()
</code></pre>
<p>but it does not work like I want: I want the <code>else</code> part to be executed right after any of these conditions fails, and now it is executed only if <code>function_1</code> fails.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two ways to do this.</p>
<p>1). You can use one <code>if</code> statement, and <code>and</code> the conditions together. This will produce "short circuiting" behavior, in that it will continue through the functions until the first one fails, then none of the remaining will execute.</p>
<pre><code>if function_1() and function_2() and function_3():
    print "Everythings went well"
else:
    Reboot
</code></pre>
<p>2) If you want all to execute, here is a method, though it is more cumbersome.:</p>
<pre><code>successful = True

successful = successful and function_1()
successful = successful and function_2()
successful = successful and function_2()

if successful:
    print "Everythings went well"
else:
    Reboot
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's possible to get the short-circuiting behaviour you want (jumping directly to the <code>else</code> clause as soon as any of your functions return <code>False</code>) in a more compact way with <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow"><code>all()</code></a>:</p>
<p>Let's set up some dummy functions for demonstration purposes:</p>
<pre><code>def function_1():
    print("first")
    return True

def function_2():
    print("second")
    return False

def function_3():
    print("third")
    return True
</code></pre>
<p>... now, with this code:</p>
<pre><code>functions = [function_1, function_2, function_3]

if all(f() for f in functions):
    print("all good")
else:
    print("oh no!")
</code></pre>
<p>... we get this output:</p>
<pre><code>first
second
oh no!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could make a list:</p>
<pre><code>functions = [function_1(), function_2(), function_3()]
</code></pre>
<p>then check all of them:</p>
<pre><code>if all(functions):
    print 'OK'
else:
    Reboot
</code></pre>
<p>This way you're running all the functions (assuming this is a requirement), and checking whether all are true. </p>
<p>Assuming all the functions pass:</p>
<pre><code>In [1]: functions = [True, True, True]

In [2]: all(functions)
Out[2]: True
</code></pre>
<p>Or if one fails:</p>
<pre><code>In [3]: functions = [True, True, False]

In [4]: all(functions)
Out[4]: False
</code></pre>
</div>
<span class="comment-copy">Raise an exception inside the functions if there's an error; it will propagate all the way up, and if you catch it on the outer level, you can decide to reboot.</span>
<span class="comment-copy">Do you want all the functions to always run, or do you want to immediately reboot if any of them fail?</span>
<span class="comment-copy">Why is there a <code>[tag:linux]</code>? Do you you also want to know how to do the reboot in Python?</span>
<span class="comment-copy">Sorry for the linux tag, it's just because I run the script in Linux. The script needs to stop if one function fails</span>
<span class="comment-copy">This would work if you wanted the behavior of a short-circuit on any of the functions failing, but not if you need to gaurentee that each function is called.</span>
<span class="comment-copy">Not sure why this got a downvote  - seems like this solutions is the same as the OPs - even with respect to the shortcutting.</span>
<span class="comment-copy">If <code>function_1()</code> fails, the other functions won't be executed. This I think is not the intended behaviour.</span>
<span class="comment-copy">The SO engine is pretty good at spotting that behaviour and reversing it.</span>
<span class="comment-copy">It's funny that people are downvoting and quibbling about the answer to an unclear question instead of downvoting the question and voting to close it as unclear.</span>
<span class="comment-copy">Why are you calling the first two, and not the third?  If you invoke the functions when building the tuple, they will all execute regardless of the results or previous functions.  If not, you need a little more work to call them.</span>
<span class="comment-copy">@WilliamPursell Whoops - a typo! Cheers GreenAsJade</span>
<span class="comment-copy">@Cyber No, but executing them all and storing the results in a list will (which this does)</span>
<span class="comment-copy">Better change it to a generator: <code>functions = (f() for f in (function_1, function_2, function_3))</code></span>
<span class="comment-copy">@AshwiniChaudhary You could do, but it adds a bit of complexity. I'm assuming OP is unfamiliar with Python, so I'm trying to keep it really simple</span>
