<div class="post-text" itemprop="text">
<h1>Background</h1>
<p>I wish to use a meta class in order to add helper methods based on the original class. If the method I wish to add uses <code>self.__attributeName</code> I get an <code>AttributeError</code> (because of name mangling) but for an existing identical method this isn't a problem.</p>
<h1>Code example</h1>
<p>Here is a simplified example</p>
<pre><code># Function to be added as a method of Test
def newfunction2(self):
    """Function identical to newfunction"""
    print self.mouse
    print self._dog
    print self.__cat

class MetaTest(type):
    """Metaclass to process the original class and
    add new methods based on the original class
    """
    def __new__(meta, name, base, dct):
        newclass = super(MetaTest, meta).__new__(
                meta, name, base, dct
                )

        # Condition for adding newfunction2
        if "newfunction" in dct:
            print "Found newfunction!"
            print "Add newfunction2!"
            setattr(newclass, "newfunction2", newfunction2)

        return newclass

# Class to be modified by MetaTest
class Test(object):
    __metaclass__ = MetaTest

    def __init__(self):
        self.__cat = "cat"
        self._dog = "dog"
        self.mouse = "mouse"

    def newfunction(self):
        """Function identical to newfunction2"""
        print self.mouse
        print self._dog
        print self.__cat

T = Test()
T.newfunction()
T.newfunction2() # AttributeError: 'Test' object has no attribute '__cat'
</code></pre>
<h1>Question</h1>
<p>Is there a way of adding <code>newfunction2</code> that could use <code>self.__cat</code>?</p>
<p>(Without renaming <code>self.__cat</code> to <code>self._cat</code>.)</p>
<p>And maybe something more fundamental, why isn't <code>self.__cat</code> being treated in the same way for both cases since <code>newfunction2</code> is now part of <code>Test</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Name mangling happens when the methods in a class are compiled. Attribute names like <code>__foo</code> are turned in to <code>_ClassName__foo</code>, where <code>ClassName</code> is the name of the class the method is defined in. Note that you can use name mangling for attributes of other objects!</p>
<p>In your code, the name mangling in <code>newfunction2</code> doesn't work because when the function is compiled, it's not part of the class. Thus the lookups of <code>__cat</code> don't get turned into <code>__Test_cat</code> the way they did in <code>Test.__init__</code>. You could explicitly look up the mangled version of the attribute name if you want, but it sounds like you want <code>newfunction2</code> to be generic, and able to be added to multiple classes. Unfortunately, that doesn't work with name mangling.</p>
<p>Indeed, preventing code not defined in your class from accessing your attributes is the whole reason to use name mangling. Usually it's only worth bothering with if you're writing a proxy or mixin type and you don't want your internal-use attributes to collide with the attributes of the class you're proxying or mixing in with (which you won't know in advance).</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer both of your questions:</p>
<ol>
<li>You will need to change <code>self.__cat</code> when you need to call it from <code>newfunction2</code> to <code>self._Test__cat</code> thanks to the name mangling rule. </li>
</ol>
<hr/>
<ol start="2">
<li><a href="https://docs.python.org/2.7/tutorial/classes.html#private-variables-and-class-local-references" rel="nofollow noreferrer">Python documentation:</a></li>
</ol>
<blockquote>
<p>This mangling is done without regard to the syntactic position of the
  identifier, as long as it occurs within the definition of a class.</p>
</blockquote>
<p>Let me brake it down for you, it's saying that it doesn't matter where your interpreter is reading when it encounters a name mangled name. <strong>The name will only be mangled <em>if</em> it occurs in the definition of a class</strong>, which in your case, it's not. Since it's not directly "under" a class definition. So when it reads <code>self.__cat</code>, it's keeping it at <code>self.__cat</code>, <strong>not</strong> going to textually replace it with <code>self._Test__cat</code> since it isn't defined inside the<code>Test</code> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>&lt;Test instance&gt;._Test__cat</code> to access the <code>__cat</code> attribute from the <code>Test</code> class. (where <code>&lt;Test instance&gt;</code> is replaced by <code>self</code> or any other instance of the <code>Test</code> class)</p>
<p>learn more in the <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">Python doc</a></p>
</div>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-a-single-and-a-double-underscore-before-an-object-name">What is the meaning of a single- and a double-underscore before an object name?</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-a-single-and-a-double-underscore-before-an-object-name">What is the meaning of a single- and a double-underscore before an object name?</a></span>
<span class="comment-copy">In this docs tutorial of Django <a href="https://docs.djangoproject.com/en/2.0/intro/tutorial02/" rel="nofollow noreferrer">docs.djangoproject.com/en/2.0/intro/tutorial02</a>   . There is this code line ' Question.objects.get(pub_date__year=current_year)' and pub date year var has a double underscore, is this the same as you have mentioned?@Blckknght</span>
<span class="comment-copy">@LordDraagon: No, that appears to be Django's own thing. Its spelling may be partly inspired by Python's native name mangling, but it's implemented separately, and has different meaning. I think the double underscores are sort of like dots in attribute notation (so <code>pub_date__year</code> is sort of like <code>pub_date.year</code>). I don't know enough about Django to give a more complete explanation.</span>
<span class="comment-copy">I thought of this, but since I am adding <code>newmethod2</code> as a method, I thought the behaviour should be the same. i.e. that I can access <code>self.__cat</code>.</span>
