<div class="post-text" itemprop="text">
<p>I'm trying to make a simple little program in python 3 where i have constant statements that will activate further in the code whenever a variable is changed so that i don't have to mess with decisions.
For example:</p>
<pre><code>example = 0
if example == 1:
    print("Successful")
example = 1
</code></pre>
<p>but it does not update, I'm not sure if 'if' is the best statement for this, but I don't know what else i could use. I tried while but it also did not work. If you could point me in the correct direction that would be great. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can't do it that way. Here is an example of how you can use <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a> to achieve something similar:</p>
<pre><code>class Foo:
    def __init__(self):
        self._example = 0

    @property
    def example(self):
        return self._example

    @example.setter
    def example(self, value):
        if value == 1:
            print("Successful")
        self._example = value


f = Foo()
f.example = 1
</code></pre>
<p>Let me warn you not to get too carried away with this pattern though. It's a good way to end up with hard to debug code.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible with primitive types. It can be done through defining an object, and using descriptors. Using the observer design pattern, you can determine the rules you need to trigger a callback event. </p>
<p>In the example below, ObservableVar enables binding to property changes. So, changes in the "example" attribute will trigger callbacks to the binding rules you defined.</p>
<pre><code>class ObservableVar:
    def __init__(self):
        self._example = 0
        self._observers = []

    def __setattr__(self, name, value):
        if name == 'example':
            print("Example changed!")
            for callback in self._observers:
                callback(value)            
        super(ObservableVar, self).__setattr__(name, value)

    def bind(self, callback):
        self._observers.append(callback)

    @property
    def example(self):
        return self._example

    @example.setter
    def example(self, value):
        self._example = value


def callback_rule(example):
    if example == 1:
        print("Successful")    

var = ObservableVar()
var.bind(callback_rule)

var.example = 1
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/q/44013428">stackoverflow.com/q/44013428</a> deals with similar issues.  Keep in mind there's a difference between a variable and the object it references.</span>
<span class="comment-copy">one might say its an anti-pattern in python.</span>
