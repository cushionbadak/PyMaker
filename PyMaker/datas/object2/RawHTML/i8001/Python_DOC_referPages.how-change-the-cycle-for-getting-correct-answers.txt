<div class="post-text" itemprop="text">
<p>I have a task to create a function that reverse any string character inside the regular bracket sequence, starting from the innermost pair. The string sequence can have, spaces, punctuation marks, letters and brakets. So the result should be sting.</p>
<p>Example</p>
<p>For string </p>
<pre><code>s = "a(bc)de"
</code></pre>
<p>the output should be</p>
<pre><code>reverseParentheses(s) = "acbde".
</code></pre>
<p>I have wrote the following code to solve this problem:</p>
<pre><code>s_i = s   
for i in range(s.count('(')):
    # reverse letters inside parenthesis
    s_i = s_i.replace(s_i[s_i.rindex('(')+1:s_i.index(')')], s_i[s_i.rindex('(')+1:s_i.index(')')][::-1])
    # delete outward parenthesis
    s_i =s_i[:s_i.rindex('(')] + s_i[s_i.rindex('(')+1:]
    # delete inward parenthesis
    s_i =s_i[:s_i.index(')')] + s_i[s_i.index(')')+1:]
    i += 1
print(s_i)
</code></pre>
<p>However, I become false results for following strings:</p>
<pre><code>s = "abc(cba)ab(bac)c"
</code></pre>
<p>It should be  </p>
<pre><code>abcabcabcabc
</code></pre>
<p>I get</p>
<pre><code>abccabbaabcc
</code></pre>
<p>And </p>
<pre><code>s = "The ((quick (brown) (fox) jumps over the lazy) dog)"
</code></pre>
<p>It should be like this:</p>
<pre><code>The god quick nworb xof jumps over the lazy
</code></pre>
<p>But I get only:</p>
<pre><code>The god quick xof nworb jumps over the lazy
</code></pre>
<p>How should I correct or adjust my code for becoming right results for last two examples?</p>
<p><strong>Code Adjustment</strong></p>
<p>I have tried to take into consideration answers and hints but I could not use recursion. I adressed the problem with the parantacies when there are just two of them located as: <code>"..(...) (...).., .."</code></p>
<p>So I made the following code:</p>
<pre><code>def reverse(s):
#ensure parens are in pairs
if '(' not in s and ')' not in s:
    while '(' in s:
            s = s.replace(s[s.rindex('(')+1:s.index(')')], s[s.rindex('(')+1:s.index(')')][::-1])
            s = s[:s.rindex('(')] + s[s.rindex('(')+1:]
            s = s[:s.index(')')] + s[s.index(')')+1:]
    return s
else:
    if (s[s.index(')'):s.rindex('(')+1] == ''):
        while '(' in s:
                s = s.replace(s[s.rindex('(')+1:s.index(')')], s[s.rindex('(')+1:s.index(')')][::-1])
                s = s[:s.rindex('(')] + s[s.rindex('(')+1:]
                s = s[:s.index(')')] + s[s.index(')')+1:]
        return s
    elif (s[s.index(')'):s.rindex('(')+1] != ''):
        betw = s[s.index(')')+1:s.rindex('(')]
        part1 = s[:s.index(')')+1]
        part2 = s[s.rindex('('):]
        part1 = part1.replace(part1[part1.rindex('(')+1:part1.index(')')], part1[part1.rindex('(')+1:part1.index(')')][::-1])
        part1 = part1[:part1.rindex(')')]
        part2 = part2.replace(part2[part2.rindex('(')+1:part2.index(')')], part2[part2.rindex('(')+1:part2.index(')')][::-1])
        part2 = part2[part2.rindex('(')+1:]
        s = part1+betw+part2
        s = s[:s.rindex('(')] + s[s.rindex('(')+1:]
        s = s[:s.index(')')] + s[s.index(')')+1:]
        while '(' in s:
            s = s.replace(s[s.rindex('(')+1:s.index(')')], s[s.rindex('(')+1:s.index(')')][::-1])
            s = s[:s.rindex('(')] + s[s.rindex('(')+1:]
            s = s[:s.index(')')] + s[s.index(')')+1:]
        return s
    else:
        while '(' in s:
            s = s.replace(s[s.rindex('(')+1:s.index(')')], s[s.rindex('(')+1:s.index(')')][::-1])
            s = s[:s.rindex('(')] + s[s.rindex('(')+1:]
            s = s[:s.index(')')] + s[s.index(')')+1:]
        return s
</code></pre>
<p>However, I think that it can not perform well for the following example:</p>
<pre><code>s = "abc(147)ab(123)c(12)asd"
</code></pre>
<p>The answer should be: <code>"abc741ab321c21asd"</code> but I get <code>"abc12c321ba147asd"</code></p>
<p>What should be changed in order to get the correct answer?</p>
</div>
<div class="post-text" itemprop="text">
<p>rather than doing this manually, use the <a href="https://en.wikipedia.org/wiki/Regular_expression" rel="nofollow noreferrer">regular expression</a> module <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a> that specialize in string manipulation</p>
<pre><code>import re

def reverseParentheses(s):
    def reverse_interior(m):
        s = m.group()
        return s[-2:0:-1]
    old = ""
    while old != s:
        old = s
        s = re.sub(r'(\([^\(\)]*\))',reverse_interior,s)
    return s

assert reverseParentheses("a(bc)de") == "acbde"
assert reverseParentheses("abc(cba)ab(bac)c") == "abcabcabcabc"
assert reverseParentheses("The ((quick (brown) (fox) jumps over the lazy) dog)") == "The god quick nworb xof jumps over the lazy"
assert reverseParentheses("((ob))") == "ob"
</code></pre>
<p>here the expression <code>'(\([^\(\)]*\))'</code> would search anything that is between <code>(</code> and <code>)</code> that is a one of characters defined in <code>[^\(\)]*</code> which in turn means any numbers character that is not a <code>(</code> or <code>)</code>, this way it will search the innermost group that match, then I use the function <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer">re.sub</a> to replace those in the string with that auxiliary function, that take a string of the form <code>"(xyz)"</code> and return <code>"zyx"</code>. As this only work for the innermost group, the process should be repeated while there are changes to be made, hence the loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason your solution isn't working is because it is mismatching parentheses:</p>
<pre><code>"abc(cba)ab(bac)c"
"   (cba)ab(bac) "
"       )ab(     "
</code></pre>
<p>Your method ultimately won't work: Instead, I recommend you figure out a better way of figuring out which parens match:</p>
<pre><code>def find_paren_set(str):
    # magic
    return left, right
</code></pre>
<p>Once you have that capability, you can then just <code>while has_parens(str):</code> through until you're done.</p>
<p>Additional note: Each time you reverse a section, the inner parens will get swapped, <code>((ob))</code> will become <code>)bo(</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since it appears that any number of <code>()</code> pairs could occur, I would recommend implementing a recursive function that can be called as long as pairs of parens still exist at a level outside the first:</p>
<pre><code>def reverseParentheses(s):
    # ensure parens are in pairs
    assert '(' in s and ')' in s

    while '(' in s:
        # Go through and swap strings/letters in the innermost parens only.
        # Then reassign `s` to that newly formatted string 
        #  (after taking out those parens)
        # Call the function again until it purges the string of all parens
        reverseParentheses(s)
    return s
</code></pre>
</div>
<span class="comment-copy">Since it appears that any number of <code>()</code> pairs could occur, I would recommend implementing a recursive function that can be called as long as pairs of parens still exist at a level outside the first</span>
<span class="comment-copy">This is basically a lispy language parser.  Check this out <a href="http://norvig.com/lispy.html" rel="nofollow noreferrer">norvig.com/lispy.html</a></span>
<span class="comment-copy">@JacobIRR thank you. However, how to get parenthesis that are close to each other? F.ex.: <code>...(brown) (fox)...</code> .</span>
<span class="comment-copy">@JacobIRR I think you should post that as an answer. The question is actually asking how to adjust/correct his code (not asking for the solution to the paren-reversal problem itself)</span>
<span class="comment-copy">this look like a job for regular exoresions</span>
