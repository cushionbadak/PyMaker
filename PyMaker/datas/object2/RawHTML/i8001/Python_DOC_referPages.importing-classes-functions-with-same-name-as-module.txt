<div class="post-text" itemprop="text">
<p>Say I use a python package with the following structure:</p>
<pre><code>package/
   bar.py
   foo.py
   __init__.py
</code></pre>
<p><code>bar.py</code> contains the class <code>bar</code> and <code>foo.py</code> contains the function <code>foo</code>.
When I want to import the function/class do I have to write</p>
<pre><code>from package.bar import bar
from package.foo import foo
</code></pre>
<p>or can I write</p>
<pre><code>from package import bar
from package import foo
</code></pre>
<p>More generally asked:
Can I always omit the class/function name, when I import a module with the same name as the class/function?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you can't omit the module or object name. There is no mechanism that'll implicitly do such imports.</p>
<p>From the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer"><em>Zen of Python</em></a>:</p>
<blockquote>
<p>Explicit is better than implicit.</p>
</blockquote>
<p>Note that importing the <em>module itself</em> should always be a valid option too. If <code>from package import bar</code> imported the <code>package.bar.bar</code> object instead, then you'd have to go out of your way to get access to <code>package.bar</code> module itself.</p>
<p>Moreover, such implicit behaviour (auto-importing the object contained in a module rather than the module itself) leads to confusing inconsistencies. </p>
<ul>
<li>What does <code>import package.bar</code> add to your namespace? Would referencing <code>package.bar</code> be the module or the contained object? </li>
<li>What should happen to code importing such a name, when you rename the contained object? Does <code>from package import bar</code> then give you the module instead? Some operations will still succeed, leading to weird, hard to debug errors, instead of a clear <code>ImportError</code> exception.</li>
</ul>
<p>Generally speaking, Python modules rarely contain just <em>one</em> thing. Python is not Java, modules consist of closely related groups of objects, not just one class or function.</p>
<p>Now, there is an inherent namespace collision in packages; <code>from package import foo</code> can refer both to names set on the <code>package</code> module, <em>or</em> to a nested module name. Python will first look at the <code>package</code> namespace in that case.</p>
<p>This means you <em>can</em> make an explicit decision to provide the <code>foo</code> and <code>bar</code> objects at the package level, in <code>package/__init__.py</code>:</p>
<pre><code># in package/__init__.py
from .foo import foo
from .bar import bar
</code></pre>
<p>Now <code>from package import foo</code> and <code>from package import bar</code> will give you those objects, masking the nested modules.</p>
<p>The general mechanism of importing objects from submodules into the package namespace is a common method of composing your public API whilst still using internal modules to group your code logically. For example, the <a href="https://docs.python.org/3/library/json.html#exceptions" rel="nofollow noreferrer"><code>json.JSONDecodeError</code> exception</a> in the Python standard library is defined in the <code>json.exceptions</code> module, then imported into <code>json/__init__.py</code>. I generally would discourage <em>masking submodules</em> however; but <code>foo</code> and <code>bar</code> into a module with a different name.</p>
</div>
<span class="comment-copy">If you do <code>from package import bar</code> then the <code>bar</code> function in the <code>bar</code> module is available as <code>bar.bar</code>.</span>
