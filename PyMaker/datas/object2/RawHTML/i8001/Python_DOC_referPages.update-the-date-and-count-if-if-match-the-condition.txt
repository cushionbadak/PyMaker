<div class="post-text" itemprop="text">
<p>I wrote the following code:</p>
<pre><code>daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
startDate = {'day': 1, 'month': 1, 'year': 1901, 'dayOfTheWeek': 3}
endDate = {'day': 31, 'month': 12, 'year': 2000, 'dayOfTheWeek': 1}
counter = 0


def update_date():
    startDate['day'] += 1
    startDate['dayOfTheWeek'] += 1
    if startDate['dayOfTheWeek'] &gt; 7:
        startDate['dayOfTheWeek'] = 1
    if startDate['day'] &gt; daysInMonths[startDate['month'] - 1]:
        startDate['day'] = 1
        startDate['month'] += 1
    if startDate['month'] &gt; 12:
        startDate['month'] = 1
        startDate['year'] += 1
    if startDate['year'] % 4 == 0 and not startDate['year'] % 100 == 0:
        daysInMonths[2] = 29


def compare():
    if startDate['day'] != endDate['day']:
        return True
    if startDate['month'] != endDate['month']:
        return True
    if startDate['year'] != endDate['year']:
        return True
    return False

while compare():
    if startDate['day'] == startDate['dayOfTheWeek'] == 1:
        counter += 1
        print(counter)
    print(startDate)
    update_date()
</code></pre>
<p>so I'm trying to count when it's Sunday on the first day of the month , but i get a bad result (173) , any suggestion where my code went wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your whole code is expressible as:</p>
<pre><code>import calendar
import itertools

first_of_months = itertools.product(range(1901, 2001),
                                    range(1,13),
                                    itertools.repeat(1)):
result = sum(1 for y,m,d in first_of_months
             if calendar.weekday(y,m,d) == calendar.SUNDAY)
</code></pre>
<p>Or equivalently with:</p>
<pre><code>from calendar import weekday, SUNDAY

total = 0
for y in range(1901, 2001):
    for m in range(1, 13):
        d = 1
        if weekday(y, m, d) == SUNDAY:
            total += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An even shorter solution (more out of curiosity than of necessity):</p>
<pre><code>import calendar

sum(calendar.monthrange(year,month)[0]==calendar.SUNDAY 
    for year in range(1901,2001) 
    for month in range(1,13))
</code></pre>
</div>
<span class="comment-copy">goodness your code needs the <code>datetime</code> and <code>calendar</code> libraries!</span>
<span class="comment-copy">Why do you need <code>compare()</code> when you can simply do <code>startDate!=endDate</code>?</span>
<span class="comment-copy">cause it did not work</span>
<span class="comment-copy">I do notice that you're being thrown off by 0 indexing. For instance, feb in your array is daysInMonths[1] but you have daysInMonths[2] = 29 in your code. I suggest just getting used to using 0 indexing all the way through/all the time to avoid stuff like this. Helps some other programmers read it since we're used to it too!</span>
<span class="comment-copy">Surely it does.</span>
<span class="comment-copy">Once again, don't use 0-12 dangit.</span>
<span class="comment-copy">@LVT huh? <code>calendar.weekday</code> is <a href="https://docs.python.org/3/library/calendar.html?highlight=calendar#calendar.weekday" rel="nofollow noreferrer">documented</a> as expecting a month from 1-12.</span>
<span class="comment-copy">Yeah I looked it up too and that's... awkward. Although I understand that they wanted to use human readable dates, it's kind of weird to me to see a one based range in a language with zero based containers. At any rate, I now know!</span>
<span class="comment-copy">@LVT that's exactly what it is. The <code>calendar</code> module is designed to give human-readable calendars, take human-readable input, and give human-readable output. The <code>datetime</code> module is the computer-friendly version (though note that months are 1-12 there, too!)</span>
<span class="comment-copy">You can also do a one-liner <code>sum(calendar.monthrange(year, month)[0] == calendar.SUNDAY for year in range(1901, 2001) for month in range(1, 13))</code></span>
