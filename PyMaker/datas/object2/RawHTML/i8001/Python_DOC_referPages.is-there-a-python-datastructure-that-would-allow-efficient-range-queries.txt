<div class="post-text" itemprop="text">
<p>Say, you had a list of integers, e.g.</p>
<pre><code>foo = [3,9,23,54,77,123,...]
</code></pre>
<p>Is there an <strong>efficient</strong> datastructure that would allow queries like</p>
<pre><code>x = everything in foo between 10 and 100
</code></pre>
<p>so that </p>
<pre><code>x == [23,54,77]
</code></pre>
<p>or
    x = everything &lt; 50</p>
<p>giving</p>
<pre><code>x = [3,9,23]
</code></pre>
<p>etc?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming these integers are already sorted it's not a data structure that you want, but an algorithm: that is, binary search. In Python this is provided by the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code> module</a>.</p>
<p>So, for example, to find all the members that are less than 50:</p>
<pre><code>from bisect import bisect_left
i = bisect_left(foo, 50)
result = foo[:i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is the <code>range</code> function (or <code>xrange</code> in python 2):</p>
<pre><code>foo = [3,9,23,54,77,123]

x = [y for y in foo if y in range(10,101)]
# x = [23,54,77]
</code></pre>
<p>If there's an infinite number on one side, use the operators and add <code>float(y).is_integer()</code> to match only integers:</p>
<pre><code>x = [y for y in foo if y &lt; 50 if float(y).is_integer()]
# x = [3,9,23]
</code></pre>
</div>
<span class="comment-copy">that looks good, thank you!</span>
<span class="comment-copy">I guess so, those are still O(n).  Was hoping for something more efficient</span>
