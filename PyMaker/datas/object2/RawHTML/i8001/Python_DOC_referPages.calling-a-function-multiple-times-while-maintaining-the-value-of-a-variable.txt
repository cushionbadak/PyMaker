<div class="post-text" itemprop="text">
<p>The goal of my code is to try and get my function to only run on the first call, and after to just return the answer of the first call. However it appears "answer" is not staying as the appended version for the second call. How should I fix this? </p>
<pre><code>class Attempt:
    def __init__(self, stop):
        self.stop = stop

answer = Attempt([])

def oncefunc(func):
    if answer.stop == []:
        answer.stop.append(func)
        return answer.stop[0]
    else:
        return answer.stop[0]
</code></pre>
<p>Here's an example of what I would be running:</p>
<pre><code>def mult(a1, a2):
    return a1 * a2
multonce = oncefunc(mult)
</code></pre>
<p>For example, I would want to call multOnce(1,2) and then multOnce(3,4), but for both calls I want to return 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>The thing that you want to do is called "memoization". First of all, in your code the function never actually gets called, you are just storing the function object itself. In order to fix that you need to create a wrapper function inside <code>oncefunc()</code> and return it:</p>
<p>(here I am not considering the keyword arguments to <code>func</code> for simplicity)</p>
<pre><code>class Attempt:
    def __init__(self, stop):
        self.stop = stop

answer = Attempt([])

def oncefunc(func):
    def wrapper(*args):
        if answer.stop == []:
            answer.stop.append(func(*args))
            return answer.stop[0]
        else:
            return answer.stop[0]
    return wrapper

def mult(a1, a2):
    print("calculating")
    return a1 * a2

multonce = oncefunc(mult)

print(multonce(1, 2))
print(multonce(1, 2))
</code></pre>
<p>Then we have the next problem: the answer gets stored in the same place for <em>any</em> arguments of <code>func</code>! So if you call <code>multonce</code> with different arguments the second time, it will return the same value. This can be fixed by keeping a dictionary with keys being the argument tuples:</p>
<pre><code>class Attempt:
    def __init__(self):
        self.answers = {}

answer = Attempt()

def oncefunc(func):
    def wrapper(*args):
        if args not in answer.answers:
            answer.answers[args] = func(*args)
            return answer.answers[args]
        else:
            return answer.answers[args]
    return wrapper

def mult(a1, a2):
    print("calculating")
    return a1 * a2

multonce = oncefunc(mult)

print(multonce(1, 2))
print(multonce(1, 2))
print(multonce(3, 4))
</code></pre>
<p>And the last thing is that keeping the answer database outside makes it global for all functions wrapped in <code>oncefunc</code>. It is much more convenient to keep it in a closure, so that it is unique for every application of <code>oncefunc</code>:</p>
<pre><code>def oncefunc(func):
    answers = {}
    def wrapper(*args):
        if args not in answers:
            answers[args] = func(*args)
            return answers[args]
        else:
            return answers[args]
    return wrapper

def mult(a1, a2):
    print("calculating")
    return a1 * a2

multonce = oncefunc(mult)

print(multonce(1, 2))
print(multonce(1, 2))
print(multonce(3, 4))
</code></pre>
<p>Of course, this is a very common pattern, so Python already has an implementation of it: <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>lru_cache</code></a>:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=None)
def mult(a1, a2):
    print("calculating")
    return a1 * a2

print(mult(1, 2))
print(mult(1, 2))
print(mult(3, 4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think, class attribute will be more reliable in your case as you need to maintain same list over all calls down the line.</p>
<p>Since <code>stop = []</code> is defined at class level, every call will use the same reference of the list <code>stop</code> as below.</p>
<pre><code>class Attempt:
    stop = []
    # def __init__(self, stop):
    #     self.stop = stop

answer = Attempt()

def oncefunc(func):

    if answer.stop == []:
        print('entered first')
        answer.stop.append(func)
        return answer.stop[0]
    else:
        print('entered second')
        answer.stop.append(func)
        return answer.stop



def mult(a1, a2):
    return a1 * a2

multonce = oncefunc(mult)
multonce = oncefunc(mult)

print(multonce)
</code></pre>
<p>OUTPUT:</p>
<pre><code>entered first
entered second
[&lt;function mult at 0x7fc4e3a91cf8&gt;, &lt;function mult at 0x7fc4e3a91cf8&gt;]
</code></pre>
<p>Is this answer your concerns?</p>
</div>
<div class="post-text" itemprop="text">
<p>You pass method as parameter into your method <code>oncefunc</code>, you didn't provide any value for method <code>mult</code>, your <code>answer.stop[0]</code> is the method mult <code>object</code>, you can provide 2 parameters for it, for instance:</p>
<pre><code>class Attempt:
    def __init__(self, stop):
        self.stop = stop

answer = Attempt([])

def oncefunc(func):
    if answer.stop == []:
        answer.stop.append(func)
        return answer.stop[0](3,4)
    else:
        return answer.stop[0](3,4)

def mult(a1, a2):
    return a1 * a2

print(oncefunc(mult))  # this print out 12
</code></pre>
<p>Alternatively, keep <code>oncefunc</code> unmodified, and when you invoke mult with 2 numerical values as:</p>
<pre><code>oncefunc(mult(3,4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you use a closure to do this rather than a class?</p>
<pre><code>#This is the outer function, that keeps track of whether its been run or not
def outer(f):
    #You can use a list or boolean
    has_been_run = []
    #wrapper function
    def wrapper(*args, **kwargs):
        if not(has_been_run):
            print "I haven't been run before!"
            #Store the results of the function call
            has_been_run.append(f(*args, **kwargs))
        else:
            #This has been run before, so just return the list
            print "I have been run before!"
            return has_been_run
        #Return the original function
        return f(*args, **kwargs)    
    return wrapper


@outer
def m(a, b):
    return a + b
</code></pre>
</div>
<span class="comment-copy">You're not doing anything with calling time nor the returned value.</span>
<span class="comment-copy">What you try to implement is called Memoization. Related question: <a href="https://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python">What is memoization and how can I use it in Python?</a></span>
<span class="comment-copy">You're comparing to an empty list. I think what you want is <code>isinstance</code> Use <code>if isinstance(answer.stop, list):</code></span>
<span class="comment-copy">Why do you even need a class. Can this not be done with a closure? Your method requires defining and instantiating a class, which is not used for anything other than storing a dictionary/list</span>
<span class="comment-copy">If you read past the first code block, you will see that I switched to a closure later. I started from the class because that's what the original question had.</span>
<span class="comment-copy">Thank you so much! I actually wanted it to return only the first value every time so your first example worked perfectly. Thank you for the help!</span>
<span class="comment-copy">Glad it helped, although I'm not sure what a practical application of this strategy would be. Still, consider using a closure like in the third code block (but just keeping a single answer there, not a dictionary indexed by <code>args</code>), it makes the code cleaner.</span>
<span class="comment-copy">Ok I see what you are doing, but what if I want to call the function for two different sets of values and I want it to return the value of the first call both times. For example:  multOnce(1,2) and then multOnce(3,4), but for both calls I want to return 2</span>
<span class="comment-copy">Ok I see what you are doing, but what if I want to call the function for two different sets of values and I want it to return the value of the first call both times. For example: multOnce(1,2) and then multOnce(3,4), but for both calls I want to return 2</span>
