<div class="post-text" itemprop="text">
<p>Using the following example from the <a href="https://docs.djangoproject.com/en/1.11/topics/migrations/#data-migrations" rel="nofollow noreferrer">documentation</a>:</p>
<pre><code>def combine_names(apps, schema_editor):
    Person = apps.get_model("yourappname", "Person")
    for person in Person.objects.all():
        person.name = "%s %s" % (person.first_name, person.last_name)
        person.save()

class Migration(migrations.Migration):    
    dependencies = [
        ('yourappname', '0001_initial'),
    ]    
    operations = [
        migrations.RunPython(combine_names),
    ]
</code></pre>
<p>How would I create and run a test against this migration, confirming that the data is migrated correctly?</p>
</div>
<div class="post-text" itemprop="text">
<p>Running your data-migration functions (such as <code>combine_names</code> from the OP's example) through some basic unit-tests, before actually applying them, makes sense to me too.</p>
<p>At first glance this should not be much more difficult than your normal Django unit-tests: migrations are Python modules and the <code>migrations/</code> folder is a package, so it is possible to import things from them. However, it took some time to get this working.</p>
<p>The <em>first</em> difficulty arises due to the fact that the default migration file names start with a number. For example, suppose the code from the OP's (i.e. Django's) data-migration example sits in <code>0002_my_data_migration.py</code>, then it is tempting to use </p>
<pre><code>from yourappname.migrations.0002_my_data_migration import combine_names
</code></pre>
<p>but that would raise a <code>SyntaxError</code> because the module name starts with a number (<code>0</code>). </p>
<p>There are at least two ways to make this work:</p>
<ol>
<li><p>Rename the migration file so it does not start with a number. This should be perfectly fine according to the <a href="https://docs.djangoproject.com/en/2.1/topics/migrations/#version-control" rel="nofollow noreferrer">docs</a>: "Django just cares that each migration has a different name." Then you can just use <code>import</code> as above.</p></li>
<li><p>If you want to stick to the default numbered migration file names, you can use Python's <code>import_module</code> (see <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">docs</a> and <a href="https://stackoverflow.com/q/10675054">this</a> SO question).</p></li>
</ol>
<p>The <em>second</em> difficulty arises from the fact that your data-migration functions are designed to be passed into <code>RunPython</code> (<a href="https://docs.djangoproject.com/en/2.1/ref/migration-operations/#runpython" rel="nofollow noreferrer">docs</a>), so they expect two input arguments by default: <code>apps</code> and <code>schema_editor</code>. To see where these come from, you can inspect the <a href="https://docs.djangoproject.com/en/2.1/_modules/django/db/migrations/operations/special/#RunPython" rel="nofollow noreferrer">source</a>.</p>
<p>Now, I'm not sure this works for every case (please, anyone, comment if you can clarify), but for our case, it was sufficient to import <code>apps</code> from <a href="https://docs.djangoproject.com/en/2.1/ref/applications/#application-registry" rel="nofollow noreferrer">django.apps</a> and get the <code>schema_editor</code> from the active database <code>connection</code> (<a href="https://docs.djangoproject.com/en/2.1/topics/db/sql/#executing-custom-sql-directly" rel="nofollow noreferrer">django.db.connection</a>). </p>
<p>The following is a stripped-down example showing how you can implement this for the OP example, assuming the migration file is called <code>0002_my_data_migration.py</code>:</p>
<pre><code>from importlib import import_module
from django.test import TestCase
from django.apps import apps
from django.db import connection
from yourappname.models import Person
# Our filename starts with a number, so we use import_module
data_migration = import_module('yourappname.migrations.0002_my_data_migration')


class DataMigrationTests(TestCase):
    def __init__(self, *args, **kwargs):
        super(DataMigrationTests, self).__init__(*args, **kwargs)
        # Some test values
        self.first_name = 'John'
        self.last_name = 'Doe'

    def test_combine_names(self):
        # Create a dummy Person
        Person.objects.create(first_name=self.first_name,
                              last_name=self.last_name, 
                              name=None)
        # Run the data migration function
        data_migration.combine_names(apps, connection.schema_editor())
        # Test the result
        person = Person.objects.get(id=1)
        self.assertEqual('{} {}'.format(self.first_name, self.last_name), person.name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could add a crude if statement to a prior migration that tests if the test suite is running, and adds initial data if it is -- that way you can just write a test to check if the objects are in the final state you want them in. Just make sure your conditional is compatible with production, here's an example that would work with <code>python manage.py test</code>:</p>
<pre><code>import sys
if 'test in sys.argv:
    # do steps to update your operations
</code></pre>
<p>For a more "complete" solution, this older blog post has some good info and more up-to-date comments for inspiration:</p>
<p><a href="https://micknelson.wordpress.com/2013/03/01/testing-django-migrations/#comments" rel="nofollow noreferrer">https://micknelson.wordpress.com/2013/03/01/testing-django-migrations/#comments</a></p>
</div>
