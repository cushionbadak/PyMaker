<div class="post-text" itemprop="text">
<p>Suppose I have an iterator</p>
<pre><code>numbers = iter(range(100))
</code></pre>
<p>and I want to count consecutive mean values and store them in <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">iterable</a> with elements</p>
<pre><code>0., 0.5, ..., 49., 49.5
</code></pre>
<p>this could be done by converting iterable to <a href="https://docs.python.org/3.6/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list</code></a>/<a href="https://docs.python.org/3.6/library/stdtypes.html#tuple" rel="nofollow noreferrer"><code>tuple</code></a> and counting its <a href="https://docs.python.org/3/glossary.html#term-slice" rel="nofollow noreferrer">slices</a> like</p>
<pre><code>from statistics import mean

# in cases with large or potentially infinite amounts of data
# this conversion will fail
numbers_list = list(numbers)
numbers_slices = (numbers_list[:end + 1] for end in range(len(numbers_list)))
mean_values = map(mean, numbers_slices)
</code></pre>
<p>(more info about <code>mean</code> function at <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow noreferrer">docs</a>)</p>
<p><strong>So my question is more general</strong>: is there any way to get consecutive slices of iterable using standard library without wrapping with <code>list</code>/<code>tuple</code>?</p>
<hr/>
<p>We can write utility function like</p>
<pre><code>def get_slices(iterable):
    elements = []
    for element in iterable:
        elements.append(element)
        yield elements
</code></pre>
<p>and then</p>
<pre><code>numbers_slices = get_slices(numbers)
mean_values = map(mean, numbers_slices)
</code></pre>
<p>but it also looks awful</p>
<hr/>
<p><strong>P. S.</strong>: I know that it will be better to count consecutive mean values like</p>
<pre><code>def get_mean_values(numbers):
    numbers_sum = 0
    for numbers_count, number in enumerate(numbers, start=1):
        numbers_sum += number
        yield numbers_sum / numbers_count
</code></pre>
<p>but it is not what I am talking about.</p>
</div>
<div class="post-text" itemprop="text">
<p>it seems like there is no standard way of getting consecutive slices of <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">iterable</a> (<a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">iterator</a>/<a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list</code></a>/<a href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="nofollow noreferrer"><code>tuple</code></a>/etc)</p>
<p>so better way i've found out is to use a bit modified utility function from original question</p>
<pre><code>def consecutive_slices(iterable):
    elements = []
    for element in iterable:
        elements.append(element)
        yield list(elements)
</code></pre>
<hr/>
<p><strong>Modifications</strong>:</p>
<ul>
<li><p>added copying of <code>elements</code> (btw there are many ways of <a href="https://stackoverflow.com/a/2612815/5997596">doing that</a>), because previous version in case of wrapping in <code>list</code></p>
<pre><code>&gt;&gt;&gt; numbers_slices = list(get_slices(numbers))
</code></pre>
<p>will give us <code>list</code> with <code>N</code> repititions of <code>elements</code> with all numbers in them (<code>N</code> equals to 100 in example):</p>
<pre><code>&gt;&gt;&gt; numbers_slices == [list(range(100))] * 100
True
</code></pre></li>
</ul>
<hr/>
<h2>Functional approach</h2>
<p>After writing a bit more I realized that this can also be done using <a href="https://docs.python.org/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code> module</a> like</p>
<pre><code>from itertools import (accumulate,
                       chain)


def consecutive_slices(iterable):
    def collect_elements(previous_elements, element):
        return previous_elements + [element]

    return accumulate(chain(([],), iterable), collect_elements)
</code></pre>
<p>here we are prepending empty <code>list</code> using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain</code></a> as initial slice, which can be ignored in result using <code>islice</code> like</p>
<pre><code>from itertools import islice
...
islice(consecutive_slices(range(10)), 1, None)
</code></pre>
<p>but it seems legit to leave it as one slices since empty slice is also a slice afterall.</p>
<p>In comparison with previous solution this is still 4-lines-of-code function that does nearly the same thing, but less "spaghetti" IMO.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could have an generator that directly <code>yield</code>s the means, with local variables containing the running total and count. (Actually you could get the count for free by iterating over <code>enumerate(iterable)</code> and adding <code>1</code> to the index. Is that enough of a hint?</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at <code>itertools.islice</code>
<a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow noreferrer">Link</a></p>
<pre><code>import itertools
def get_slices(iterable):
    return map(lambda x: itertools.islice(iterable, x), xrange(len(iterable)))
</code></pre>
<p>If you don't know the length, here you have a reduce version, highly ineficcient in memory:</p>
<pre><code>from functools import reduce
numbers = (number for number in range(1,100))
mean = lambda x, y: (x+y)/float(2)
reduce(lambda x, y: x + [mean(x[-1], y)], numbers, [0])
[0.0, 0.5, 1.25, 2.125, 3.0625, 4.03125, 5.015625, 6.0078125, 7.00390625, 8.001953125, 9.0009765625, 10.00048828125, 11.000244140625, 12.0001220703125, 13.00006103515625, 14.000030517578125, 15.000015258789062, 16.00000762939453, 17.000003814697266, 18.000001907348633, 19.000000953674316, 20.000000476837158, 21.00000023841858, 22.00000011920929, 23.000000059604645, 24.000000029802322, 25.00000001490116, 26.00000000745058, 27.00000000372529, 28.000000001862645, 29.000000000931323, 30.00000000046566, 31.00000000023283, 32.000000000116415, 33.00000000005821, 34.000000000029104, 35.00000000001455, 36.000000000007276, 37.00000000000364, 38.00000000000182, 39.00000000000091, 40.000000000000455, 41.00000000000023, 42.000000000000114, 43.00000000000006, 44.00000000000003, 45.000000000000014, 46.00000000000001, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0]
</code></pre>
<p>So, in the end we are doing almost the same as your code, so you should go with it or <strong>use a list instead of a generator ande then use slices of the list (<code>itertools.ilice</code>)</strong>.</p>
<p><strong>EDIT</strong>:
I've been thinking about this, it was easily solved with <code>Haskell</code> <code>scanl</code>, so I generilezed the concept and get a very good result:</p>
<pre><code>def scanl(f, g):
    n = next(g)
    yield n
    for e in g:
        n = f(n, e)
        yield n

list(scanl(mean, number))
[0, 0.5, 1.25, 2.125, 3.0625, 4.03125, 5.015625, 6.0078125, 7.00390625, 8.001953125, 9.0009765625, 10.00048828125, 11.000244140625, 12.0001220703125, 13.00006103515625, 14.000030517578125, 15.000015258789062, 16.00000762939453, 17.000003814697266, 18.000001907348633, 19.000000953674316, 20.000000476837158, 21.00000023841858, 22.00000011920929, 23.000000059604645, 24.000000029802322, 25.00000001490116, 26.00000000745058, 27.00000000372529, 28.000000001862645, 29.000000000931323, 30.00000000046566, 31.00000000023283, 32.000000000116415, 33.00000000005821, 34.000000000029104, 35.00000000001455, 36.000000000007276, 37.00000000000364, 38.00000000000182, 39.00000000000091, 40.000000000000455, 41.00000000000023, 42.000000000000114, 43.00000000000006, 44.00000000000003, 45.000000000000014, 46.00000000000001, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0]
</code></pre>
</div>
<span class="comment-copy">So you don't have a <code>range</code> object like you originally stated? you can actually index a py 3 <code>range</code> object directly without conversion to a <code>list</code></span>
<span class="comment-copy">@Chris_Rands: in my case i have a generator, fixed</span>
<span class="comment-copy">This seems like a case where using a <code>list</code> is the best idea, because the iterator is consumed, so you'd have to build a new iterator for every slice. This is possible with <code>itertools.tee</code> but likely slow</span>
<span class="comment-copy">The only other way I see is if your generator happens to have a <code>__reversed__()</code> method, then you could make the slices in reverse, but I guess it does not</span>
<span class="comment-copy">counting of mean value and generating of slices should be independent operations in my case</span>
<span class="comment-copy">in my case iterable has no <code>__len__</code></span>
<span class="comment-copy">@AzatIbrakov, cant you know the lenght?</span>
<span class="comment-copy">no, i've fixed the example</span>
<span class="comment-copy">@AzatIbrakov, can you iterate several times? or will the iterable be consumed?</span>
<span class="comment-copy">yes, it will be consumed</span>
