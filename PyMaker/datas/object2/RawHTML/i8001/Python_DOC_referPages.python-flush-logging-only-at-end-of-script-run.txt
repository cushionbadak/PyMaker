<div class="post-text" itemprop="text">
<p>Currently I use for logging a custom logging system that works as follow:<br/>
I have a Log <code>class</code> that ressemble the following:</p>
<pre><code>class Log:
    def __init__(self):
        self.script = ""
        self.datetime = datetime.datetime.now().replace(second=0, microsecond=0)
        self.mssg = ""
        self.mssg_detail = ""
        self.err = ""
        self.err_detail = ""
</code></pre>
<p>I created a function decorator that perform a <code>try/except</code> on the function call, and add a message either to <code>.mssg</code> or <code>.err</code> on the <code>Log</code> object accordingly.</p>
<pre><code>def logging(fun):
    @functools.wraps(fun)
    def inner(self, *args):
        try:
            f = fun(self, *args)
            self.logger.mssg += fun.__name__ +" :ok, "                
            return f               
        except Exception as e:
            self.logger.err += fun.__name__ +": error: "+str(e.args) 
    return inner 
</code></pre>
<p>So usually a script is a class that is composed of multiple methods that are run sequentially.
I hence run those methods (decorated such as mentionned above) , and lastly I  upload the Log object into a mysql db.</p>
<p>This works quite fine and alright. But now I want to modify those items so that they integrate with the "official" logging module of python.</p>
<p>What I dont like about that module is that it is not possible to "save" the messages onto 1 log object in order to upload/save to log only at the end of the run. Rather each logging call will write/send the message to a file etc. - which create lots of performances issues sometimes. I could use<code>handlers.MemoryHandler</code> , but it still doesn't seems to perform as my original system: it is said to collect messages and flush them to another handler periodically - which is not what i want: I want to collect the messages in memory and to flush them on request with an explicit function.</p>
<p>Anyone has any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my idea. Use a handler to capture the log in a StringIO. Then you can grab the StringIO whenever you want. Since there was perhaps some confusion in the discussion thread - StringIO is a "file-like" interface for strings, there isn't ever an actual file involved. </p>
<pre><code>import logging
import io
def initialize_logging(log_level, log_name='default_logname'):
    logger = logging.getLogger(log_name)
    logger.setLevel(log_level)

    log_stream = io.StringIO()

    if not logger.handlers:
        ch = logging.StreamHandler(log_stream)
        ch.setLevel(log_level)
        ch.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        ))
        logger.addHandler(ch)
        logger.propagate = 0
    return logger, log_stream
</code></pre>
<p>And then something like:</p>
<pre><code>&gt;&gt;&gt; logger, log_stream = initialize_logging(logging.INFO, "logname")
&gt;&gt;&gt; logger.warning("Hello World!")
</code></pre>
<p>And when you want the log information:</p>
<pre><code>&gt;&gt;&gt; log_stream.getvalue()
'2017-05-16 16:35:03,501 - logname - WARNING - Hello World!\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>At program start (in the main), you can:</p>
<ul>
<li>instanciate your custom logger =&gt; global variable/singleton.</li>
<li>register a function at program end which will flush your logger.</li>
<li>Run your decorated functions. </li>
</ul>
<p>To register a function you can use <code>atexit.register</code> function. See the page <a href="https://docs.python.org/3/library/atexit.html?highlight=exit#module-atexit" rel="nofollow noreferrer">Exit handlers</a> in the doc. </p>
<p><strong>EDIT</strong></p>
<p><em>The idea above can be simplified.</em></p>
<p>To delay the logging, you can use the standard <code>MemoryHandler</code> handler, described in the page <a href="https://docs.python.org/3/library/logging.handlers.html#memoryhandler" rel="nofollow noreferrer">logging.handlers â€” Logging handlers</a></p>
<p>Take a look at this GitHub project: <a href="https://github.com/tantale/python-ini-cfg-demo" rel="nofollow noreferrer">https://github.com/tantale/python-ini-cfg-demo</a></p>
<p>And replace the INI file by this:</p>
<pre><code>[formatters]
keys=default

[formatter_default]
format=%(asctime)s:%(levelname)s:%(message)s
class=logging.Formatter

[handlers]
keys=console, alternate

[handler_console]
class=logging.handlers.MemoryHandler
formatter=default
args=(1024, INFO)
target=alternate

[handler_alternate]
class=logging.StreamHandler
formatter=default
args=()

[loggers]
keys=root

[logger_root]
level=DEBUG
formatter=default
handlers=console
</code></pre>
<p>To log to a database table, just replace the <strong>alternate</strong> handler by your own database handler.</p>
<p>There is some blog/SO questions about that:</p>
<ul>
<li>You can look at <a href="http://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/logging/sqlalchemy_logger.html" rel="nofollow noreferrer">Logging Exceptions To Your SQLAlchemy Database</a> to create a <code>SQLAlchemyHandler</code></li>
<li>See <a href="https://stackoverflow.com/q/11887816/1513933">Store Django log to database</a> if you are using DJango.</li>
</ul>
<p><strong>EDIT2</strong></p>
<p>Note: ORM generally support "Eager loading", for instance with <a href="http://docs.sqlalchemy.org/en/latest/orm/tutorial.html#eager-loading" rel="nofollow noreferrer">SqlAlchemy</a></p>
</div>
<span class="comment-copy">By the way, you ought to reraise the exception in your decorator.</span>
<span class="comment-copy">@Laurent LAPORTE no the whole point is that the script carries on until the end in order to be able to upload the log...</span>
<span class="comment-copy">This is your choice but not a good practice. How do you handle <code>KeyboardInterrupt</code>, for instance?</span>
<span class="comment-copy">"But now I want to modify those items so that they integrate with the "official" logging module of python."  What do you mean? Why do this?</span>
<span class="comment-copy">i mean that the expression <code>self.logger.err += fun.__name__ +": error: "+str(e.args)</code> etc in the decorator method will be replaced by <code>logging.error(fun.__name__ +": error: "+str(e.args))</code> .Similarly the <code>Log</code> class declaration will be replaced by a basicConfig logging declaration. I do that because I need to integrate my code with another library that uses the main python logging module.</span>
<span class="comment-copy">thx a lot. i was wondering - or those LogRecord <a href="https://docs.python.org/3/library/logging.html#logrecord-objects" rel="nofollow noreferrer">docs.python.org/3/library/logging.html#logrecord-objects</a> something that I could use instead of the stringio ?</span>
<span class="comment-copy">I've not looked into it.  Sorry</span>
<span class="comment-copy">that's an interesting pointers thx! It doesnt answer the main concern of my post (ie I want to get rid of my custom logger and replace it with the python logging utility) but it's definitely something i can use to improve my code.</span>
<span class="comment-copy">If you use a database, you certainly have a cache which you can configure. You can use that with the standard logger.</span>
<span class="comment-copy">See also <a href="http://stackoverflow.com/q/2314307">stackoverflow.com/q/2314307</a></span>
<span class="comment-copy">@LaurentLAPORTE  I just gave an answer that answers the specific question. But of course the more obvious answer is the one you site, write a handler that just goes directly to the Database.  I guess the bottom line is... write a handler that does what you want.</span>
<span class="comment-copy">@LaurentLAPORTE Ok thx. I mention <code>memoryhandler</code> in my initial post already. The problem is that they are flushed (according to the doc) either when the buffer is full or when an event with a specified level of severity occurs. None of those option are satisfactory to me and i dont know how to circonvene them. I would like to be able to upload all the logs to db explicitely calling a function doing so. btw do you think i could use <a href="https://docs.python.org/3/library/logging.html#logrecord-objects" rel="nofollow noreferrer">docs.python.org/3/library/logging.html#logrecord-objects</a> ? Just discarding all actual log event, then at exit uploading all the logrecords?</span>
