<div class="post-text" itemprop="text">
<p><strong>Set-up</strong></p>
<p>I have a list containing tuples, each which contains a tuple.</p>
<p>Part of the list, </p>
<pre><code>l = [ ('E', ('1058GK', '1058GK')),
      ('K', ('1058GL', '1058GN')),
      ('E', ('1058GP', '1058HC')),
      ('K', ('1058HD', '1058LT'))]
</code></pre>
<hr/>
<p><strong>Problem</strong></p>
<p>I want to convert <code>l</code> to a dictionary such that,</p>
<pre><code>d = {'E': ['1058GK','1058GK','1058GP','1058HC'],
     'K': ['1058GL','1058GN','1058HD','1058LT']}
</code></pre>
<p>How would I go about?</p>
<p><hr/>
<strong>Tried</strong></p>
<p><code>d = {k:v for k,v in l}</code> brings me close, but this would create,</p>
<pre><code>d = {'E': ('1058GP','1058HC'),
     'K': ('1058HD','1058LT')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could use  <a href="https://docs.python.org/3/library/stdtypes.html?highlight=setdefault#dict.setdefault" rel="nofollow noreferrer"><code>setdefault</code></a>:</p>
<pre><code>d = {}
for key, lst in l:
    d.setdefault(key, []).extend(lst)

# results in
# d = {'E': ['1058GK', '1058GK', '1058GP', '1058HC'], 
#      'K': ['1058GL', '1058GN', '1058HD', '1058LT']}
</code></pre>
<p>if the <code>key</code> is not in the dictionary already, it will be added, containing an empty list. the list is then extended with the elements in the corresponding tuples.</p>
<hr/>
<p>or you could use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict

d = defaultdict(list)

for key, lst in l:
    d[key].extend(lst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [ 
    ('E', ('1058GK', '1058GK')),
    ('K', ('1058GL', '1058GN')),
    ('E', ('1058GP', '1058HC')),
    ('K', ('1058HD', '1058LT'))
]
res = dict()
for elem in l:
    res[elem[0]] = res.get(elem[0], []) + list(elem[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the keys in your original list can occur several times, it is best to loop through your list. You can go through your list element wise and right away split the outer tuple into key-element pairs like so:</p>
<pre><code>l = [ ('E', ('1058GK', '1058GK')),
      ('K', ('1058GL', '1058GN')),
      ('E', ('1058GP', '1058HC')),
      ('K', ('1058HD', '1058LT'))]
mydict = {}
for key, tup in l:
    try:
        mydict[key]+=list(tup)
    except KeyError:
        mydict[key]=list(tup)

print(mydict)
</code></pre>
<p>the try-except block makes sure that the different keys really exist within mydict and if they don't, creates them accordingly.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is ok</p>
<pre><code>d = {k:[] for (k, v) in l}
for (k, v) in l:
    d[k] += list(v)
print(d)
</code></pre>
<p>First it allocates a dictionary of empty lists. Then is iterates over the elements of <code>l</code> casting tuples to lists and merging them with respect to the keys <code>k</code>.</p>
</div>
<span class="comment-copy">Have you done anything so far?</span>
<span class="comment-copy">It works both in python3 and python2.</span>
