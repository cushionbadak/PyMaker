<div class="post-text" itemprop="text">
<p>I have the following code: </p>
<pre><code>class Company(enum.Enum):
    EnterMedia = 'EnterMedia'
    WhalesMedia = 'WhalesMedia'

    @classmethod
    def choices(cls):
        return [(choice.name, choice.name) for choice in cls]

    @classmethod
    def coerce(cls, item):
        print "Coerce", item, type(item)
        if item == 'WhalesMedia':
            return Company.WhalesMedia
        elif item == 'EnterMedia':
            return Company.EnterMedia
        else:
            raise ValueError
</code></pre>
<p>And this is my wtform field:</p>
<pre><code>company = SelectField("Company", choices=Company.choices(), coerce=Company.coerce)
</code></pre>
<p>This is the html generated in my form:</p>
<pre><code>&lt;select class="" id="company" name="company" with_label=""&gt;
    &lt;option value="EnterMedia"&gt;EnterMedia&lt;/option&gt;
    &lt;option value="WhalesMedia"&gt;WhalesMedia&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>Somehow, when I click submit, I keep getting "Not a Valid Choice". </p>
<h2>Any ideas why?</h2>
<p>This is my terminal output:</p>
<p>When I look at my terminal I see the following:</p>
<pre><code>Coerce None &lt;type 'NoneType'&gt;
Coerce EnterMedia &lt;type 'unicode'&gt;
Coerce EnterMedia &lt;type 'str'&gt;
Coerce WhalesMedia &lt;type 'str'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you need to convert the argument passed to <code>coerce</code> method into an instance of the enum.</p>
<pre><code>import enum

class Company(enum.Enum):
    EnterMedia = 'EnterMedia'
    WhalesMedia = 'WhalesMedia'

    @classmethod
    def choices(cls):
        return [(choice.name, choice.value) for choice in cls]

    @classmethod
    def coerce(cls, item):
        item = cls(item) \
               if not isinstance(item, cls) \
               else item  # a ValueError thrown if item is not defined in cls.
        return item.value
        # if item.value == 'WhalesMedia':
        #     return Company.WhalesMedia.value
        # elif item.value == 'EnterMedia':
        #     return Company.EnterMedia.value
        # else:
        #     raise ValueError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a lot cleaner than the accepted solution, as you don't need to put the options more than once.</p>
<p>By default Python will convert objects to strings using their path, which is why you end up with Company.EnterMedia and so on. In the below solution, I use <code>__str__</code> to tell python that the name should be used instead, and then use the [] notation to look up the enum object by the name.</p>
<pre><code>class Company(enum.Enum):
    EnterMedia = 'EnterMedia'
    WhalesMedia = 'WhalesMedia'

    def __str__(self):
        return self.name

    @classmethod
    def choices(cls):
        return [(choice, choice.value) for choice in cls]

    @classmethod
    def coerce(cls, item):
        return item if type(item) == Company else Company[item]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>WTForm will either pass in strings, <code>None</code>, or <em>already coerced data</em> to <code>coerce</code>; this is a little annoying but easily handled by testing if the data to coerce is already an instance:</p>
<pre><code>isinstance(someobject, Company)
</code></pre>
<p>The <code>coerce</code> function must otherwise raise a <code>ValueError</code> or <code>TypeError</code> when coercing.</p>
<p>You want to use the <em>enum names</em> as the values in the select box; these are always going to be strings. If your enum <em>values</em> are suitable as labels, then that's great, you can use those for the option readable text, but don't confuse those with the option values, which must be unique, enum values do not need to be.</p>
<p><code>Enum</code> classes let you map a string containing an enum name to the <code>Enum</code> instance by using subscription:</p>
<pre><code>enum_instance = Company[enum_name]
</code></pre>
<p>See <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="nofollow noreferrer"><em>Programmatic access to enumeration members and their attributes</em></a> in the <code>enum</code> module documentation.</p>
<p>Next, we could leave conversion of the enum objects to unique strings (for the <code>value="..."</code> attribute of <code>&lt;option&gt;</code> tags) and to label strings (to show to the users) to standard hook methods on the enum class, such as <code>__str__</code> and <code>__html__</code>.</p>
<p>Together, for your specific setup, use:</p>
<pre><code>from markupsafe import escape

class Company(enum.Enum):
    EnterMedia = 'Enter Media'
    WhalesMedia = 'Whales Media'

    def __str__(self):
        return self.name  # value string

    def __html__(self):
        return self.value  # label string

def coerce_for_enum(enum):
    def coerce(name):
        if isinstance(name, enum):
            return name
        try:
            return enum[name]
        except KeyError:
            raise ValueError(name)
    return coerce

company = SelectField(
    "Company",
    # (unique value, human-readable label)
    # the escape() call can be dropped when using wtforms 3.0 or newer
    choices=[(v, escape(v)) for v in Company],
    coerce=coerce_for_enum(Company)
)
</code></pre>
<p>The above keeps the Enum class implementation separate from the presentation; the <code>cource_for_enum()</code> function takes care of mapping <code>KeyError</code>s to <code>ValueError</code>s. The <code>(v, escape(v))</code> pairs provide the value and label for each option; <code>str(v)</code> is used for the <code>&lt;option value="..."&gt;</code> attribute value, and that same string is then used via <code>Company[__html__result]</code> to coerce back to enum instances. WTForms 3.0 will start using <code>MarkupSafe</code> for labels, but until then, we can directly provide the same functionality with <code>escape(v)</code>, which in turn uses <code>__html__</code> to provide a suitable rendering.</p>
<p>If having to remember about what to put in the list comprehension, and to use <code>coerce_for_enum()</code> is becoming tedious, you can generate the <code>choices</code> and <code>coerce</code> options with a helper function; you could even have it verify that there are suitable <code>__str__</code> and <code>__html__</code> methods available:</p>
<pre><code>def enum_field_options(enum):
    """Produce WTForm Field instance configuration options for an Enum

    Returns a dictionary with 'choices' and 'coerce' keys, use this as
    **enum_fields_options(EnumClass) when constructing a field:

    enum_selection = SelectField("Enum Selection", **enum_field_options(EnumClass))

    Labels are produced from str(enum_instance.value) or 
    str(eum_instance), value strings with str(enum_instance).

    """
    assert not {'__str__', '__html__'}.isdisjoint(vars(enum)), (
        "The {!r} enum class does not implement __str__ and __html__ methods")

    def coerce(name):
        if isinstance(name, enum):
            # already coerced to instance of this enum
            return name
        try:
            return enum[name]
        except KeyError:
            raise ValueError(name)

    return {'choices': [(v, escape(v)) for v in enum], 'coerce': coerce}
</code></pre>
<p>and for your example, then use</p>
<pre><code>company = SelectField("Company", **enum_field_options(Company))
</code></pre>
<p>Note that once WTForm 3.0 is released, you can use a <code>__html__</code> method on enum objects without having to use <code>markdownsafe.escape()</code>, because the project is <a href="https://github.com/wtforms/wtforms/pull/400" rel="nofollow noreferrer">switching to using MarkupSafe for the label values</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've just been down the same rabbit hole. Not sure why, but <code>coerce</code> gets called with <code>None</code> when the form is initialised. After wasting a lot of time, I decided it's not worth coercing, and instead I just used:</p>
<pre><code>field = SelectField("Label", choices=[(choice.name, choice.value) for choice in MyEnum])
</code></pre>
<p>and to get the value:</p>
<pre><code>selected_value = MyEnum[field.data]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Company(enum.Enum):
  WhalesMedia = 'WhalesMedia'
  EnterMedia = 'EnterMedia'

  @classmethod
  def choices(cls):
    return [(choice, choice.value) for choice in cls]

  @classmethod
  def coerce(cls, item):
    """item will be both type(enum) AND type(unicode).
    """
    if item == 'Company.EnterMedia' or item == Company.EnterMedia:
      return Company.EnterMedia
    elif item == 'Company.WhalesMedia' or item == Company.WhalesMedia:
      return Company.WhalesMedia
    else:
      print "Can't coerce", item, type(item)
</code></pre>
<p>So I hacked around and this works. </p>
<p>It seems to me that coerce will be applied to both (x,y) for (x,y) in choices. </p>
<p>I can't seem to understand why I keep seeing: <code>Can't coerce None &lt;type 'NoneType'&gt;</code> though </p>
</div>
<span class="comment-copy">You can map string names to objects (<i>coerce</i>) simply by indexing the enum: <code>Company["EnterMedia"]</code> produces <code>Company.EnterMedia</code>. You can use <code>coerce=Company.__getitem__</code>. Calling works too, for <i>values</i>, so <code>coerce=Company</code>. See See <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="nofollow noreferrer"><i>Programmatic access</i></a>. Your names and values match, so you can use either here.</span>
<span class="comment-copy">I gave this a try and it doesn't work, getting a "Not a valid choice".   This is what's being rendered: <code>&lt;select id="company" name="company"&gt;&lt;option selected value="EnterMedia"&gt;EnterMedia&lt;/option&gt;&lt;option value="WhalesMedia"&gt;WhalesMedia&lt;/option&gt;&lt;/select&gt;</code>.  And this is what form.company.data = <code>Company.WhalesMedia (type:&lt;enum 'Company'&gt;)</code></span>
<span class="comment-copy">I believe the error arise from Enum.coerce mapping form.data to an enum but WTForm's SelectField is looking for a string since that's what's given in choices</span>
<span class="comment-copy">@Sparrowcide I updated the answer to return the value in the enum field.</span>
<span class="comment-copy">Mapping string names to enum objects is done by using <code>[...]</code>: <code>Company['EnterMedia']</code>. See <a href="https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes" rel="nofollow noreferrer"><i>Programmatic access</i></a>. Calling can work too, for <i>values</i>.</span>
<span class="comment-copy">Don't use <code>type(...) == ...</code>, ever. You want <code>isinstance(item, Company)</code>, or if subclasses are not permissable, use <code>type(item) is Company</code> (note the identity test, not equality). Concrete <code>Enum</code> classes are not sub-classable, so <code>isinstance()</code> is more than fine.</span>
<span class="comment-copy">And <code>coerce()</code> will never be called with an enum instance, because WTF deals with strings, exclusively!</span>
<span class="comment-copy">See my solution, it's considerably cleaner</span>
