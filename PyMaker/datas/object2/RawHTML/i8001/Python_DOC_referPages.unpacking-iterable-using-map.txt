<div class="post-text" itemprop="text">
<p>Assuming I have two iterables of numbers of the same length</p>
<pre><code>weights = range(0, 10)
values = range(0, 100, 10)
</code></pre>
<p>I need to count weighted sum. I know that it can be done with list comprehension</p>
<pre><code>weighted_sum = sum(weight * value for weight, value in zip(weights, values))
</code></pre>
<p>I wonder if it can be done using <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> and <a href="https://docs.python.org/3/library/operator.html#operator.mul" rel="nofollow noreferrer"><code>operator.mul</code></a> like</p>
<pre><code>import operator

weighted_sum = sum(map(operator.mul, zip(weights, values)))
</code></pre>
<p>but this gives an error</p>
<pre><code>Traceback (most recent call last):
  File "&lt;input&gt;", line 3, in &lt;module&gt;
TypeError: op_mul expected 2 arguments, got 1
</code></pre>
<p>so my question: is there any way of passing unpacked tuples to function using <code>map</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>map</code> doesn't need the <code>zip</code>, just use</p>
<pre><code>weighted_sum = sum(map(operator.mul, weights, values))
</code></pre>
<p>From <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code>'s Documentation</a></p>
<blockquote>
<p>If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel.</p>
</blockquote>
<p>Also mentioned in <code>map</code>'s documentation is that instead you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer"><code>itertools.starmap</code></a> instead of <code>map</code> for already <code>zip</code>ped input.</p>
<hr/>
<p>As <a href="https://stackoverflow.com/a/44039847/321973">Rahul hinted at</a>, using <code>numpy</code> is always a good idea when dealing with numerics, actually something like</p>
<pre><code>import numpy as np

np.asarray(weights) * values
</code></pre>
<p>already should do the trick (though in contrast to <code>map</code> this <em>requires</em> the two arrays to be of same length, while <code>map</code> would map the shortest length).</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt;
&gt;&gt;&gt; weights = range(0, 10)
&gt;&gt;&gt; values = range(0, 100, 10)
&gt;&gt;&gt; sum(map(lambda i:operator.mul(*i), zip(weights, values)))
2850
</code></pre>
<p>Or</p>
<pre><code>&gt;&gt;&gt; sum(map(operator.mul, weights, values))
2850
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also attempt with <code>numpy</code>,</p>
<pre><code>In [45]: import numpy as np

In [46]: sum(map(np.multiply,weights,values))
Out[46]: 2850
</code></pre>
<p>As per Tobias Kienzler's Suggestion,</p>
<pre><code>In [52]: np.sum(np.array(weights) * values)
Out[52]: 2850
</code></pre>
</div>
<span class="comment-copy">shouldn't it be <code>weighted_sum = sum(map(operator.mul, weights, values))</code> without the <code>zip</code>? Or, as hinted at in <code>map</code>'s documentation, maybe <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer"><code>itertools.starmap</code></a> helps</span>
<span class="comment-copy">Done, though as <a href="https://stackoverflow.com/a/44039847/321973">Rahul suggested</a>, using <code>numpy</code> is even better</span>
<span class="comment-copy">I suggest to use the second attempt.</span>
<span class="comment-copy">First one seems rather convoluted, the second one looks more Pythonic to me (maybe that's because I was just thinking the same ;)</span>
<span class="comment-copy">@TobiasKienzler Yeah, actually, there' no need to use <code>zip</code>. The second way is much better and Pythonic. :)</span>
<span class="comment-copy">Good point, especially for larger arrays this might speed things up. Though, then you might as well convert the arrays into numpy ones and simply use <code>*</code> for the scalar product, which already sums the element-wise product anyway.</span>
<span class="comment-copy">thanks, but i need it for tests in project without <code>numpy</code>, so it would be an overkill :-)</span>
