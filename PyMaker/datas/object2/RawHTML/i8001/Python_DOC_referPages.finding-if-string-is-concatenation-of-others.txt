<div class="post-text" itemprop="text">
<p>I am working on a problem where one must determine if a string is a concatenation of other string (these strings can be repeated in the concatenated strings). I am using backtracking to be as efficient as possible. If the string is a concatenation, it will print the strings it is a concatenation of. If not, it will print <code>NOT POSSIBLE</code>. Here is my python code:</p>
<pre><code># note: strList has to have been sorted
def findFirstSubstr(strList, substr, start = 0):
    index = start
    if (index &gt;= len(strList)):
        return -1
    while (strList[index][:len(substr)] != substr):
        index += 1
        if (index &gt;= len(strList)):
            return -1
    return index


def findPossibilities(stringConcat, stringList):
    stringList.sort()
    i = 0
    index = 0
    substr = ''
    resultDeque = []
    indexStack = []
    while (i &lt; len(stringConcat)):
        substr += stringConcat[i]
        index = findFirstSubstr(stringList, substr, index)
        if (index &lt; 0):
            if (len(resultDeque) == 0):
                return 'NOT POSSIBLE'
            else:
                i -= len(resultDeque.pop())
                index = indexStack.pop() + 1
                substr = ''
                continue
        elif (stringList[index] == substr):
            resultDeque.append(stringList[index])
            indexStack.append(index)
            index = 0
            substr = ''
        i += 1
    return ' '.join(resultDeque)
</code></pre>
<p>I keep failing the last half of the test cases and can't figure out why. Could someone prompt me in the right direction for any cases that this would fail? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>First, of all, this code is unnecessary complicated. For example, here is an equivalent but shorter solution:</p>
<pre><code>def findPossibilities(stringConcat, stringList):
    if not stringConcat:  # if you want exact match, add `and not stringList`
        return True

    return any(findPossibilities(stringConcat[len(s):],
                                 stringList[:i] + stringList[i+1:])  # assuming non-repeatable match. Otherwise, simply replace with `stringList`
               for i, s in enumerate(stringList)
               if stringConcat.startswith(s))
</code></pre>
<p>Actual answer:</p>
<p>Border condition: remaining part of <code>stringConcat</code> matches some of <code>stringList</code>, search is stopped:</p>
<pre><code>&gt;&gt;&gt; findPossibilities('aaaccbbbccc', ['aaa', 'bb', 'ccb', 'cccc'])
'aaa ccb bb'
</code></pre>
</div>
<span class="comment-copy">FYI: if you want a deque, use the <code>deque</code> class in <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a>.</span>
<span class="comment-copy">@ChristianDean thanks for the advice. I'm new to Python and am just using the list because that's all I know</span>
<span class="comment-copy">Yeah, I thought I might mention it since you said you were looking for speed. Because its a dedicated deque it will be a faster than a standard Python list(assmuing of course, you <i>use</i> it like a deque).</span>
<span class="comment-copy">It'll take me a bit to sort through your code but upvoting for the border condition</span>
