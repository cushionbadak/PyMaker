<div class="post-text" itemprop="text">
<p>In JavaScript this is possible:</p>
<pre><code>tmp = eval("randomname = [1,2,3,4]")
</code></pre>
<p>However, neither Pythons <code>eval</code> nor <code>exec</code> supports that.</p>
<pre><code>eval("randomname = range(1,2)") # this throws a syntax error
exec("randomname = range(1,2)") # this returns nothing
</code></pre>
<p>Is there any "special" Python function/method/library, which can evaluate statements AND return the last value?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, there are some problems with some assumptions you're making, <code>randomname = [1,2,3,4]</code> is a statement. It does not produce a value. So attempting to <code>eval</code> that would be a syntax error (<code>eval()</code> expects an expression, not statement). Eval takes a single expression, evaluates it, and returns its value. It's ok in javascript since assignments are considered expressions which is not the case in python.</p>
<p>In the same vein, <code>exec</code> is a statement that takes a sequence of statements and executes it. It does not return a value as statements do not produce values. So it would be wrong to expect that it should.</p>
<p>Once you have that figured out, you'll want to parse the code and separate out the last expression to be returned. Then execute the first part of the code (if any) then evaluate the last expression returning its result.</p>
<pre><code>import ast

def eval_code(code, context=None):
    tree = ast.parse(code)
    last = ast.Expression(tree.body.pop().value)
    if tree.body:
        exec (compile(tree, __name__, 'exec'), globals(), context)
    return eval(compile(last, __name__, 'eval'), globals(), context)
</code></pre>
<p>With this, you could then evaluate your code, multiple statements and all.  Just make sure that the last one is an expression that has a definite value otherwise you may run into problems.</p>
<pre><code>eval_code('''
randomname = [1,2,3,4]
print('got value: {!r}'.format(randomname))
randomname
''') # [1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For python, you must first have the variable declared before calling <code>eval()</code> on it. See the docs for <code>eval()</code>: <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#eval</a></p>
<p>Your best bet to evaluate a statement and return the last value would be to do something like: 
<code>randomname = range(1,2)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you wrap <code>exec()</code> then? Something like:</p>
<pre><code>def return_exec(expr, context=None):
    exec("__ret__ = {}".format(expr))
    if not context:
        return __ret__
    loc = locals()
    loc.pop("expr", None)
    loc.pop("context", None)
    context.update(loc)
    return __ret__
</code></pre>
<p>If you use it without context you'll get only the return value:</p>
<pre><code>print("exec: {}".format(return_exec("randomname=range(1, 5)")))  # exec: [1, 2, 3, 4]
print("randomname: {}".format(randomname))  # NameError: name 'randomname' is not defined
</code></pre>
<p>But if you forward it local context it will update it:</p>
<pre><code>print("exec: {}".format(return_exec("randomname=range(1, 5)", vars())))  # exec: [1, 2, 3, 4]
print("randomname: {}".format(randomname))  # randomname: [1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With influence from Jeffs answer, I build this:</p>
<pre><code># &gt;&gt;&gt; eval_code("a = 1+2; 10*10; range(1,10);")
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# &gt;&gt;&gt; eval_code("a = 1+2; 10*10; range(1,10);\nif True: 123;")
# &gt;&gt;&gt; eval_code("abc = 123")
# 123
# &gt;&gt;&gt;

def eval_code(code, context=None):
    tree = ast.parse(code)
    # prevent access to last element when there are non, e.g. eval_code("")
    if (len(tree.body) == 0):
        return None
    # only return a value when the last node is actually an ast.Expr
    if isinstance(tree.body[-1], ast.Expr):
        # convert ast.Expr into ast.Expression
        last = ast.Expression(tree.body.pop().value)
        # only execute the Module when tree.body has some elements left
        if tree.body:
            exec (compile(tree, __name__, 'exec'), globals(), context)
        return eval(compile(last, __name__, 'eval'), globals(), context)
    elif isinstance(tree.body[-1], ast.Assign):
        assignnode = tree.body[-1]

        # simply add ast.Name to the targets attribute
        assignnode.targets.append( ast.Name(id="__ret__", ctx=ast.Store()) )
        #print ("assign name: " + assignnode.targets[0].id); # e.g. "abc"

        # otherwise: TypeError: required field "lineno" missing from expr
        ast.fix_missing_locations(tree)

        # run it normally
        exec (compile(tree, __name__, 'exec'), globals(), context)
        # and return it
        return __ret__
    else:
        # otherwise just exec it normally without returning anything
        exec (compile(tree, __name__, 'exec'), globals(), context)
        return None
</code></pre>
<p>This is quite close to JavaScript behaviour and not too much hackery, so this helps me really alot to quickly evaluate expressions in my REPL GUI (e.g. select a bit of code, press Ctrl+Enter to execute the code and pretty print the return value).</p>
</div>
<span class="comment-copy">what happens if you "print randomname" after exec call?</span>
<span class="comment-copy">There's almost always a better solution than <code>eval</code> in every language, what do you need it for?</span>
<span class="comment-copy"><code>exec</code> is for statements. <code>eval</code> is for expressions. Hence the <code>SyntaxError</code>.</span>
<span class="comment-copy">The variable is set, but I cannot access it "programmatically", since it's a "random name" or in other cases there will be no name at all. I am implementing a REPL system currently, so I need the last value of the evaluated code. My JavaScript REPL works perfectly, but couldn't solve it for Python yet.</span>
<span class="comment-copy">@zwer, it does not, otherwise I wouldn't ask.</span>
<span class="comment-copy">Don't be fooled that <code>eval_code("randomname = [1,2,3,4]")</code> returns a value fine. I didn't add any sort of validation in the code. This only works because the last statement is an <code>ast.Assign</code> object which happens to have a <code>value</code>. Any other final statement that has no <code>value</code> would raise an error. e.g., <code>eval_code("print 'hello world'")</code></span>
<span class="comment-copy">Thanks, this is going into the right direction. I started yesterday to learn the AST API aswell and began to rewrite the AST (actually inserting Assign nodes to <b>ret</b>, when it makes sense). I'm not done yet tho, there are a lot of special cases like <code>if (0) { 111; } else { 222; }</code> returns <code>222</code> in JavaScript. Basically I gotta iterate the whole AST and consider every possible return value.</span>
<span class="comment-copy">I would say, you should just make perfectly clear to the users of your program that they're writing python code, not javascript. I think evaluating multiline scripts is an acceptable compromise that could be reasonably implemented, but implementing full javascript semantics is a fools errand. Your example there is technically a statement which has no value (in javascript and in python). You shouldn't have to worry about all the minor quirks.</span>
<span class="comment-copy">Thanks a bunch for the code, I posted my own answer based on it now to deal with the filthy special cases :)</span>
<span class="comment-copy">I kinda know the limitations of <code>eval</code>, hence I'm asking for something more useful. ;-)</span>
<span class="comment-copy">I thought about this approach, but I need the "last" value. Imagine a REPL call with <code>return_exec("a = range(1,2); b = range(3,4)")</code> e.g.</span>
<span class="comment-copy">Well, for simple assignments you'll need to use either new lines or semicolons as separators - all you need to do is to split the expressions, execute them in the same order and pick up the return from the last one.</span>
<span class="comment-copy">To do this 100% correctly, I would end up reimplementing Python parsing. I'm looking for a "first time right" solution.</span>
