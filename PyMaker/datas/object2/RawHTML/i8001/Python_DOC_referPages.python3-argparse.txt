<div class="post-text" itemprop="text">
<p>I have been struggling with this for a few days now and still dont have a good solution. Instead of providing code this time which with this problem has lately been leading to unhelpful tangents, let me just give you an idea of exactly what I am trying to accomplish and perhaps this will streamline the solution.</p>
<p>All I am trying to do run a python program while inputting a few variables to control what the program does. Allow me to give a specific example.</p>
<p>Example Syntax Structure</p>
<pre><code>program_name function_to_run variable_1 variable_2 variable_n
</code></pre>
<p>Generic Syntax Example</p>
<pre><code>parrot add "Mr Fluffy" "Red" "15oz"
</code></pre>
<p>Another Example</p>
<pre><code>datamine search "Chris"
</code></pre>
<p>So to expand on these examples. The first program "parrot" has an add function. When the program is run and the add function is used from the command line, the program expects three variables (Name, color, weight). In the second example, the program named "datamine" has a function named "search" that expects a single string (the search term). The idea is, the program (datamine) for example will have several functions that could be used. Perhaps "add", "search", "delete" are all examples and each will have different expected variables. Using datamine help would list out each function and the required and or optional components.</p>
<p>Using argparse, I have not been able to figure out a working implementation of this yet. From past experience, I think the solution will involved using custom actions. Can anyone please help with some example code? I am using Python 3 by the way.</p>
<p>Thanks for the help! </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="nofollow noreferrer" title="subparsers">subparsers</a>. The docs give a good example of how to use <code>set_defaults</code> to specify the function that should be called for each subparser:</p>
<blockquote>
<p>One particularly effective way of handling sub-commands is to combine the use of the add_subparsers() method with calls to set_defaults() so that each subparser knows which Python function it should execute. </p>
</blockquote>
<p>In your examples, <code>parrot</code> and <code>datamine</code> would be separate parsers in separate modules, and <code>add</code> and <code>search</code> would be subparsers under them respectively. For example, the datamine module would look something like this:</p>
<pre><code>#!/usr/bin/env python
# datamine

def add(a, b):
     print(a + b)

def search(query, search_all=True):
     run_my_search_app(query, search_all=search_all)

if __name__ == '__main__':
    # create the top-level parser
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    # create the parser for the "add" command
    parser_add = subparsers.add_parser('add')
    parser_add.add_argument('-a', type=int, default=1)
    parser_add.add_argument('-b', type=int, default=2)
    parser_add.set_defaults(func=add)

    # create the parser for the "search" command
    parser_search = subparsers.add_parser('search')
    parser_search.add_argument('query')
    parser_search.add_argument('--search-all', action='store_true')
    parser_search.set_defaults(func=search)

    args = parser.parse_args()
    args = vars(args)
    func = args.pop("func")
    func(**args)
</code></pre>
<p>If this file is executable in your shell as <code>datamine</code>, you can do:</p>
<pre><code>datamine add -a 11 -b 5
datamine search foo --search-all
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without optional flags you don't need anything fancy - just look at <code>sys.argv</code> directly:</p>
<pre><code>import sys

def my_add(*args):
    print( ','.join(args))

def my_search(*args):
    print(args)

fn_map = {"add": my_add, "search": my_search}

if sys.argv[1:]:
    fn = fn_map[sys.argv[1]]
    rest = sys.argv[2:]
    fn(*rest)
</code></pre>
<p>sample runs</p>
<pre><code>1951:~/mypy$ python stack43990444.py 
1951:~/mypy$ python stack43990444.py add "Mr Fluffy" "Red" "15oz"
Mr Fluffy,Red,15oz
1951:~/mypy$ python stack43990444.py search "Chris"
('Chris',)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Fully functional extrapolation of code from your parrot example using subparsers.  Data set (created by this code) and usage examples at the bottom.  <strong>Beware, example set does not consist strictly of parrots</strong></p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3
import argparse
import json


def add_parrot(name, weight, kind, **kwargs):
    print("Adding {} of type {} and size {}".format(name, kind, weight))
    with open('parrots.json', 'r') as parrotdb:
        parrots = json.load(parrotdb)
    parrots.append({'name': name, 'weight': weight, 'type': kind})
    with open('parrots.json', 'w') as parrotdb:
        json.dump(parrots, parrotdb)


def delete_parrot(name, **kwargs):
    print("Uh oh!  What happened to {}?".format(name))
    with open('parrots.json', 'r') as parrotdb:
        parrots = json.load(parrotdb)
    parrots[:] = [p for p in parrots if p.get('name') != name]
    with open('parrots.json', 'w') as parrotdb:
        json.dump(parrots, parrotdb)


def show_parrots(name=None, weight=0, kind=None, **kwargs):
    with open('parrots.json', 'r') as parrotdb:
        parrots = json.load(parrotdb)
    for p in parrots:
        if (name or weight or kind):
            if name in p['name'] or weight == p['weight'] or kind == p['type']:
                print("{}\t{}\t{}".format(
                    p['name'], p['weight'], p['type']))
        else:
            print("{}\t{}\t{}".format(p['name'], p['weight'], p['type']))


parser = argparse.ArgumentParser(description="Manage Parrots")
subparsers = parser.add_subparsers()
add_parser = subparsers.add_parser('insert', aliases=['add', 'a'])
add_parser.add_argument('name')
add_parser.add_argument('weight', type=int)
add_parser.add_argument('kind')
add_parser.set_defaults(func=add_parrot)

del_parser = subparsers.add_parser("delete", aliases=['del', 'd'])
del_parser.add_argument('name')
del_parser.set_defaults(func=delete_parrot)

ls_parser = subparsers.add_parser('list', aliases=['show', 'ls'])
ls_parser.add_argument('--name')
ls_parser.add_argument('--size', type=int)
ls_parser.add_argument('--type', dest='kind')
ls_parser.set_defaults(func=show_parrots)


args = parser.parse_args()
args.func(**vars(args))
</code></pre>
<p>Dataset and usage examples:
</p>
<pre><code>➜  ~ cat parrots.json
[{"name": "tweety", "weight": 4, "type": "yellow"}, {"name": "donald", "weight": 18, "type": "white"}, {"name": "daffy", "weight": 12, "type": "black"}]
➜  ~ ./parrot.py ls
tweety  4   yellow
donald  18  white
daffy   12  black
➜  ~ ./parrot.py ls --name tweety
tweety  4   yellow
➜  ~ ./parrot.py delete tweety
Uh oh!  What happened to tweety?
➜  ~ ./parrot.py ls --name tweety
➜  ~
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">Yes I have it bookmarked, but have not figured out a working solution yet.</span>
<span class="comment-copy">Subparsers. I linked specifically to the part about subparsers.</span>
<span class="comment-copy">If the structure of the input is that convoluted, why not just make it a config file you read on start. Pick a format for that, parse it.</span>
<span class="comment-copy">I was just giving a random example off the top of my head.</span>
