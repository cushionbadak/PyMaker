<div class="post-text" itemprop="text">
<p>Let's say I have a module named <code>foo</code> with a class <code>Bar</code>. <code>Bar</code> has a classwide counter attribute that allows me to track the order which instances were created. <code>foo</code> looks like this:</p>
<pre><code>from itertools import count

class Bar:
    class_count = count(0)
    def __init__(self):
        self.id = self.class_count.next()
</code></pre>
<p>Now I have a test file where I am testing the various functionalities of <code>Bar</code>. I am unsure of how to test this <code>id</code> attribute, because the other unittests are creating instances of <code>Bar</code> and so I don't know what the given id of a <code>Bar</code> instance <em>should</em> be. Furthermore, this behavior of my class means that my unittests are independent of each other, which is undesirable. How should I structure my unittests so the tests are independent of each other?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp" rel="nofollow noreferrer"><code>setUp</code></a> to safe the current count and then temporarily reset the count. Then with <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown" rel="nofollow noreferrer"><code>tearDown</code></a> you restore the original state again:</p>
<pre><code>from itertools import count
import unittest

class Bar:
    class_count = count(0)
    def __init__(self):
        self.id = next(self.class_count)


class TestBar(unittest.TestCase):
    def setUp(self):
        self.nxtcount = next(Bar.class_count)  # safe current state
        Bar.class_count = count(0)             # reset to 0

    def tearDown(self):
        Bar.class_count = count(self.nxtcount) # reset to old state

    def teststh1(self):
        x = Bar()
        self.assertEqual(x.id, 0)

    def teststh2(self):
        x1 = Bar()
        x2 = Bar()
        x3 = Bar()
        self.assertEqual(x1.id, 0)
        self.assertEqual(x2.id, 1)
        self.assertEqual(x3.id, 2)
</code></pre>
<p>This makes sure every test method will start with a <code>Bar.class_count</code> of 0.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would stub out Bar to bypass the constructor.</p>
<pre><code>class BarStub(Bar):
  def __init__(self):
    self.class_count = None
    self.id = None
</code></pre>
<p>Now you can test like this:</p>
<pre><code>class TestBar(...):
  def setUp(...)
    ...
    self.bar = BarStub()

  def test_foo_should_blah_when_blah(self):
    with mock.patch.object(self.bar, 'count_class', side_effect=[...]) as mock_count:
      actual = self.bar.unit_under_test(...)
      mock_count.assert_called_with([...])
</code></pre>
</div>
<span class="comment-copy">This most likely answers your question: <a href="https://stackoverflow.com/questions/7460363/re-import-module-under-test-to-lose-context" title="re import module under test to lose context">stackoverflow.com/questions/7460363/â€¦</a></span>
<span class="comment-copy">The question here is: what to test? Basically you only need to test that the counter's next method is called. Testing the function of the counter is not your job. So, mock the counter and assert if the mock is called as expected.</span>
