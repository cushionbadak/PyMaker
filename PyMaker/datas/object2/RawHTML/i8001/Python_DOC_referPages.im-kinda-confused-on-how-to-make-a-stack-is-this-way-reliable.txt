<div class="post-text" itemprop="text">
<pre><code>stack = ["1", "2", "3"]
stack.append("4")
stack.append("6")
stack.pop()
print (stack)
</code></pre>
<p>This is usually how I make one, but I see other types of examples here, and can't tell if I'm doing it right. Any explenations?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is from the official docs:
<a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html</a></p>
<p>5.1.1. Using Lists as Stacks<br/>
The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop() without an explicit index. For example:</p>
<pre><code>&gt;&gt;&gt; stack = [3, 4, 5]  
&gt;&gt;&gt; stack.append(6)  
&gt;&gt;&gt; stack.append(7)  
&gt;&gt;&gt; stack  
[3, 4, 5, 6, 7]  
&gt;&gt;&gt; stack.pop()  
7  
&gt;&gt;&gt; stack  
[3, 4, 5, 6]  
&gt;&gt;&gt; stack.pop()  
6  
&gt;&gt;&gt; stack.pop()  
5  
&gt;&gt;&gt; stack  
[3, 4]  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't "make a stack" this way.</p>
<p>In your example, you use a <code>list</code> instance as a stack, simply by limiting the number of allowed methods. It's a bit like putting a blindfold on your eyes and pretending you're blind.</p>
<p><code>stack[i]</code> and <code>stack.insert(i, x)</code> shouldn't be used, for example. But <code>type(stack)</code> still returns <code>&lt;class 'list'&gt;</code>:</p>
<pre><code>&gt;&gt;&gt; stack = ["1", "2", "3"]
&gt;&gt;&gt; stack.append("4")
&gt;&gt;&gt; stack.append("6")
&gt;&gt;&gt; stack.pop()
'6'
&gt;&gt;&gt; stack
['1', '2', '3', '4']
&gt;&gt;&gt; type(stack)
&lt;class 'list'&gt;
</code></pre>
<p>So this way isn't really reliable, because there's nothing to prevent you from calling a <code>list</code> instance method on your stack:</p>
<pre><code>&gt;&gt;&gt; stack.insert(0,'0')
&gt;&gt;&gt; stack
['0', '1', '2', '3', '4']
</code></pre>
<p>If you want to restrict the number of methods available to your <code>stack</code> object, you could write a <code>Stack</code> wrapper around <code>list</code>:</p>
<pre><code>class Stack:

    def __init__(self, items=[]):
        self.items = items

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def size(self):
        return len(self.items)

    def __str__(self):
        return str(self.items)


stack = Stack(["1", "2", "3"])
stack.push("4")
stack.push("6")
stack.pop()
print(stack)
# ['1', '2', '3', '4']
stack.insert(0, '0')
# AttributeError: Stack instance has no attribute 'insert'
</code></pre>
</div>
<span class="comment-copy">That's the correct way to use a list as a stack. Your code is almost identical to the example found in the docs: <a href="https://docs.python.org/3.5/tutorial/datastructures.html#using-lists-as-stacks" rel="nofollow noreferrer">docs.python.org/3.5/tutorial/…</a></span>
<span class="comment-copy">Oh, okay. Thanks!</span>
