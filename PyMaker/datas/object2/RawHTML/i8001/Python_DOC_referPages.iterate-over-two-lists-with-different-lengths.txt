<div class="post-text" itemprop="text">
<p>I have 2 lists of numbers that can be different lengths, for example:</p>
<pre><code>list1 = [1, 2, -3, 4, 7]
list2 = [4, -6, 3, -1]
</code></pre>
<p>I need to iterate over these with the function:</p>
<pre><code>final_list = []
for index in range(???):
    if list1[index] &lt; 0:
        final_list.insert(0, list1[index])
    elif list1[index] &gt; 0:
        final_list.insert(len(final_list), list1[index])
    if list2[index] &lt; 0:
        final_list.insert(0, list2[index])
    elif list2[index] &gt; 0:
        final_list.insert(len(final_list), list2[index])
return final_list
</code></pre>
<p>but can't figure out how to deal with the range as the shorter list will become "out of range" if I use the <code>max</code> length. Any thoughts on how to overcome this or how to change my function?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="noreferrer"><code>itertools.zip_longest(*iterables, fillvalue=None)</code></a> will do the job for you:</p>
<blockquote>
<p>If the iterables are of uneven length, missing values are filled-in with <em>fillvalue</em>.</p>
</blockquote>
<p>For your example lists, this will yield:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list1 = [1, 2, -3, 4, 7]
&gt;&gt;&gt; list2 = [4, -6, 3, -1]

&gt;&gt;&gt; for combination in itertools.zip_longest(list1, list2):
    print(combination)

(1, 4)
(2, -6)
(-3, 3)
(4, -1)
(7, None)
</code></pre>
<hr/>
<p>If you only want to use as many values as are present in <em>both</em> lists, use the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code></a>:</p>
<blockquote>
<p>The iterator stops when the shortest input iterable is exhausted.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; for combination in zip(list1, list2):
    print(combination)

(1, 4)
(2, -6)
(-3, 3)
(4, -1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can process adjacent items from the lists by using <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest()</code></a> (<code>itertools.izip_longest()</code> if using Python 2) to produce a sequence of paired items. Pairs will be padded with <code>None</code> for lists of mismatched length.</p>
<p>Then you can simplify the code in the body of the loop by flattening the sequence of paired items and filtering out the <code>None</code> values, and in your case, <code>0</code> values. That's what the generator expression below does.</p>
<p>Then it's just a matter of appending or inserting values into <code>final_list</code> if greater or less than zero respectively.</p>
<p>In code:</p>
<pre><code>from itertools import zip_longest

final_list = []
for value in (i for pair in zip_longest(list1, list2) for i in pair if i):
    if value &gt; 0:
        final_list.append(value)
    else:
        final_list.insert(0, value)

print(final_list)
</code></pre>
<pre>
[-1, -3, -6, 1, 4, 2, 3, 4, 7]
</pre>
<p>Notice that this will filter out any zero values that might be present in the lists. If you want to keep these then modify the generator expression to filter out the <code>None</code> values only:</p>
<pre><code>(i for pair in zip_longest(list1, list2)
    for i in pair if i is not None)
</code></pre>
<p>and modify the body of the loop to insert the <code>0</code> wherever it should go in <code>final_list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your case you should probably just check if the index is longer than the sequence:</p>
<pre><code>list1 = [1, 2, -3, 4, 7]
list2 = [4, -6, 3, -1]

final_list = []
for index in range(max(len(list1), len(list2))):
    if index &lt; len(list1):
        if list1[index] &lt; 0:
            final_list.insert(0, list1[index])
        elif list1[index] &gt; 0:
            final_list.insert(len(final_list), list1[index])

    if index &lt; len(list2):
        if list2[index] &lt; 0:
            final_list.insert(0, list2[index])
        elif list2[index] &gt; 0:
            final_list.insert(len(final_list), list2[index])

print(final_list)
# [-1, -3, -6, 1, 4, 2, 3, 4, 7]
</code></pre>
<p>Or use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> (or <code>itertools.izip_longest</code> on python-2.x) and check for some fillvalue (i.e. <code>None</code>):</p>
<pre><code>import itertools

list1 = [1, 2, -3, 4, 7]
list2 = [4, -6, 3, -1]

final_list = []
for item1, item2 in itertools.zip_longest(list1, list2, fillvalue=None):
    if item1 is None:
        pass
    elif item1 &lt; 0:
        final_list.insert(0, item1)
    elif item1 &gt; 0:
        final_list.append(item1)

    if item2 is None:
        pass
    elif item2 &lt; 0:
        final_list.insert(0, item2)
    elif item2 &gt; 0:
        final_list.append(item2)
</code></pre>
<hr/>
<p>However your approach skips items when they are <code>== 0</code>, that's probably an oversight but you should check that it's working correct with zeros.</p>
<p>Also you use <code>insert</code> a lot. The last <code>elif</code>s could instead use <code>final_list.append(item1)</code> (or <code>item2</code>), like I did in the second example.</p>
<p>In this case the handling for <code>item1</code> and <code>item2</code> is identical, so you could use another loop:</p>
<pre><code>import itertools

list1 = [1, 2, -3, 4, 7]
list2 = [4, -6, 3, -1]

final_list = []
for items in itertools.zip_longest(list1, list2, fillvalue=None):
    for item in items:
        if item is None:
            pass
        elif item &lt; 0:
            final_list.insert(0, item)
        elif item &gt; 0:
            final_list.append(item)
</code></pre>
</div>
<span class="comment-copy">what do you want to accomplish?</span>
<span class="comment-copy">Can you explain what the output should be?</span>
<span class="comment-copy"><code>for item1, item2 in itertools.zip_longest(list1, list2)</code>?</span>
<span class="comment-copy">Use <code>zip_longest</code> from <code>itertools</code></span>
<span class="comment-copy">Please explain your logic?</span>
