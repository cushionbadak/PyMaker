<div class="post-text" itemprop="text">
<p>I'm looking for elegant solutions to this:</p>
<pre><code>x = {}
x['key'] = 'something'
...
...
for i in someKeyList:
    if i in x: raise KeyError('Enforcing single assign') #Happens for i == 'key' for example
    x[i] = 'else'
</code></pre>
<p>Basically I want a dictionary where assigning to an existing key throws an error. I currently implement a <code>UserDict</code>, but these are slower than the builtins.  but I'm looking for something builtin or at least in the common modules.</p>
<p>XY: This is an hash checking for existence, I need O(1) lookup and insertion.</p>
<p><strong>NOTE</strong></p>
<p>The dict I want is <strong>not immutable</strong> (is mutable...). You can add, remove or do what ever to it. The only difference is assigning a value to an existing value throws an error.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can directly subclass <code>dict</code> instead of <code>UserDict</code> if you want.</p>
<pre><code>class SingleAssignDict(dict):
    def __init__(self, *args, **kwargs):
        super(SingleAssignDict, self).__init__(*args, **kwargs)
    def __setitem__(self, key, value):
        if dict.__contains__(self, key):
            raise KeyError('Enforcing single assign')
        dict.__setitem__(self, key, value)

x = SingleAssignDict()
x['a'] = 1
x['a'] = 1
&gt;&gt;&gt; KeyError: 'Enforcing single assign'
</code></pre>
<p>An alternative without exception is to use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a>, although that would just ignore repeated assignments instead of throwing an exception. If your <code>'else'</code> value is guaranteed not to be already present for any dict key you can do a hack like this:</p>
<pre><code>x = {}
x['key'] = 'something'
...
...
for i in someKeyList:
    if x.setdefault(i, 'else') != 'else':
        raise KeyError('Enforcing single assign')
</code></pre>
</div>
<span class="comment-copy"><a href="https://pypi.python.org/pypi/frozendict/" rel="nofollow noreferrer">frozendict?</a></span>
<span class="comment-copy">Do you need it to raise an exception if the key is already assigned or can you live with "silently ignore the assignment if the key already exists"?</span>
<span class="comment-copy">@Ev.Kounis frozendict enforces immutability of keys. I don't want that, I want to be able to create the key dynamically, but throw an error on a second assignment. And yes, I can't ignore existence.</span>
<span class="comment-copy">I'm afraid I have no idea how the other question relates to mine. It's so much more complicated? Besides, I don't want an immutable dict. I'll have to edit.</span>
<span class="comment-copy">@jdehesa I would prefer an exception, but if you have a nice solution with out one and it's the best I'll take it.</span>
<span class="comment-copy">Thanks, but as I wrote in my post, I already did this. User collections are much slower then builtins, hence I was looking for something else.</span>
<span class="comment-copy">@kabanus Well you mentioned <code>UserDict</code>, but in any case, I'm not sure where you get the idea that a subclass of <code>dict</code> will be much slower that a regular <code>dict</code> (btw added an alternative without exceptions).</span>
<span class="comment-copy">@jdehesa I'd be interested in the evidence that a subclass of dict with setitem added was significantly slower for operations other than item assignment.  I'd even be mildly surprised if that setitem method destroyed the performance of assignment.</span>
<span class="comment-copy">@SamHartman User collections need python wrappers, in contrast to built-ins which go faster to the C code. The timing may not be significant to anything you've used.  In any case I'm looking for a solution I didn't have already, but again, thanks for the effort.</span>
<span class="comment-copy">@kabanus I see what you mean, I've taken some measures and I see the performance decrease can be big (although I had to have quite big dictionaries to have a significant difference). But I don't think there is something that goes "directly to C" that does that in the library (besides <code>dict.setdefault</code>, which is not quite it). Even using <code>dict</code> and putting that <code>if</code> and assignment in a function instead of directly into the loop (for reuse) makes it around twice as slow. I've added a potential alternative that I'm not sure if you could use...</span>
