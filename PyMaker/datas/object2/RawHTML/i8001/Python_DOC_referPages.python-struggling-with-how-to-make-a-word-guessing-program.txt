<div class="post-text" itemprop="text">
<p>So i started a project, mainly to test how quickly a PC can compute these sorts of things. The idea was that the user inputted a word and the computer will systematically run all possibilities until it guesses the word. e.g. a-z and once it hits z it starts aa, ab, ac... etc. Obviously getting it to work with just one letter is not an issue but with two letters it is proving to be very difficult. Any help would be appreciated. </p>
<pre><code>def main_menu():

    #Initial menu print and input
    menu = ("""
    0: Exit
    1: Brute Force No Lock
    """)
    choice = int(input(menu))

    #Loop to catch invalid input, requests further input
    while choice != 1 and choice != 0:
        print("Choice Invalid, Please Try Again")
        choice = int(input(menu))

    #If statments to decide what to do with input
    if choice==1:
        brute_force_no_lock()
    elif choice==0:
        exit()

def brute_force_no_lock():
    letters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]

    toCrack = input("Please enter the word for the computer to crack: ")

    counter = 0

    cur_guess = []

    def repeater(letters, toCrack):
        counter = 0
        for x in letters:
            cur_guess = letters[counter]
            counter += 1
            print(cur_guess)
            if cur_guess == toCrack:
                print ("Cracked, Your Word Was", cur_guess)
                break

    repeater(letters, toCrack)

main_menu()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer"><pre>itertools.combinations_with_replacement(<i>iterable, r</i>)</pre></a></p>
<blockquote>
<p>Return <i>r</i> length subsequences of elements from the input <i>iterable</i>
  allowing individual elements to be repeated more than once.</p>
<p>Combinations are emitted in lexicographic sort order. So, if the input
  iterable is sorted, the combination tuples will be produced in sorted
  order.</p>
<p>Elements are treated as unique based on their position, not on their
  value. So if the input elements are unique, the generated combinations
  will also be unique.</p>
</blockquote>
<p>So to get all 2-letter-combinations:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; letters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
&gt;&gt;&gt; for word in itertools.combinations_with_replacement(letters, 2):
        print("".join(word), end=" ")

aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz cc cd ce cf cg ch ci cj ck cl cm cn co cp cq cr cs ct cu cv cw cx cy cz dd de df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz ee ef eg eh ei ej ek el em en eo ep eq er es et eu ev ew ex ey ez ff fg fh fi fj fk fl fm fn fo fp fq fr fs ft fu fv fw fx fy fz gg gh gi gj gk gl gm gn go gp gq gr gs gt gu gv gw gx gy gz hh hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz mm mn mo mp mq mr ms mt mu mv mw mx my mz nn no np nq nr ns nt nu nv nw nx ny nz oo op oq or os ot ou ov ow ox oy oz pp pq pr ps pt pu pv pw px py pz qq qr qs qt qu qv qw qx qy qz rr rs rt ru rv rw rx ry rz ss st su sv sw sx sy sz tt tu tv tw tx ty tz uu uv uw ux uy uz vv vw vx vy vz ww wx wy wz xx xy xz yy yz zz 
</code></pre>
<p>Wrapping that in a loop starting with <code>r=1</code> and increasing <code>r</code> should lead you to the word to crack eventually.</p>
<p><em>Hint:</em> right now you are only producing combinations of lower letters, but allow any input as a word. This can lead to an infinite loop. You should consider sanitizing the input before starting to "crack" it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another approach:</p>
<pre><code>from itertools import product
import string

def allwords(chars, length):
    for letters in product(chars, repeat=length):
        yield ''.join(letters)

def main():
    letters = string.ascii_lowercase
    for wordlen in range(0, 10):
        for word in allwords(letters, wordlen):
            print(word)

if __name__=="__main__":
    main()
</code></pre>
<p>You can change the <code>min</code> and <code>max</code> length of your words by changing these values: <code>for wordlen in range(min, max):</code></p>
<p>Output:</p>
<pre><code>a
b
c
d
e
.
.
.
zzzzzzzzzz
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The method that popped into my head-</p>
<p>Store your guess letters in an array as ascii values. Increment arr[0] from 97-122, then increment arr[1] once, and repeat. Convert from ascii to string for the success check. I believe that conversion is inexpensive.</p>
<p>Word="hello"</p>
<p>arr{104,101,108,108,111,0,0,0,0,0}</p>
<p>There are likely faster computational methods out there, but I thought this keeps it simple.</p>
</div>
<span class="comment-copy">What exactly is not working?</span>
