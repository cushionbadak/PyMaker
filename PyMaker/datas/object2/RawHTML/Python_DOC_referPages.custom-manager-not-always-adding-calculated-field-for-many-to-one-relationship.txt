<div class="post-text" itemprop="text">
<p>I am using Django 2.1 for a project. One of my <code>Models</code> (called <code>Event</code> in the example below) has a many-to-one relationship to another <code>Model</code> (<code>Thing</code> in the example below). The first model should have what I think is a calculated field.</p>
<p>To illustrate:</p>
<pre><code>class Thing(models.Model):
    ...

class Event(models.Model):
    ...
    thing = models.ForeignKey(Thing, on_delete=models.CASCADE)
    ts = models.DateTimeField(default=django.utils.timezone.now)
    _delta = timedelta()
    ...
    objects = EventManager()

    @property
    def delta(self):
        return self._delta

    @delta.setter
    def delta(self, value):
        self._delta = value
</code></pre>
<p>An <code>Event</code> should have a calculated field (a <code>timedelta</code> called <code>delta</code>) that shows how much after the previous event it happened. Because an <code>Event</code>'s time can change, it seems better to calculate this <code>timedelta</code> at run time instead of storing it in the database (keeping the deltas up to date in the database gets hairy, for example if an event's time changes in a way that changes the sequence of events, i.e. one event "jumps" over another one).</p>
<p>So I have a custom manager for <code>Event</code>'s</p>
<pre><code>class EventManager(models.Manager):

    def get_queryset(self):
        qs = super().get_queryset()
        for r in qs:
            r.delta = django.utils.timezone.now() - r.ts  # fake calculation
    return qs
</code></pre>
<p>When I now "use" this, for example in a template</p>
<pre><code>{% for event in thing.event_set.all|dictsortreversed:"ts" %}
</code></pre>
<p>or in code like so</p>
<pre><code>events = thing.event_set.all()
</code></pre>
<p>Then <code>event.delta</code> or <code>events.delta</code> is not set. Even though it <em>seems</em> (I do not know how to prove it) that the custom manager (<code>EventManager</code>) is used/called.</p>
<p>I am not sure if the problem is that I cannot change the queryset (i.e. the line with the <code># fake calculation</code> is the problem) or if this is related to the following statement in the <a href="https://docs.djangoproject.com/en/2.1/topics/db/managers/" rel="nofollow noreferrer">Base managers documentation</a></p>
<blockquote>
<p>Base managers arenâ€™t used when querying on related models.</p>
</blockquote>
<p>or something completely different.</p>
<p>Any pointers are highly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>In most cases, the queryset returned by a manager (here: <code>EventManager</code>) is used not as a list of instances but as a <em>query definition</em>. The only exception is when calling <code>Event.objects.all()</code>. This is the only case where your <code>r</code> objects are actually used. In every other case adding the field <code>delta</code> to them is a waste of time as they are never used at all.</p>
<p>What you can do is define a method that can be called on instances of the class to do any calculation upon request:</p>
<pre><code>class Event(models.Model):
    def delta(self):
        return django.utils.timezone.now() - self.t
</code></pre>
<p>You can use this method also for sorting in the template.</p>
<p>An alternative would be to add any calculated fields you need in your view (but here again, you would need to take care that the querysets are not modified when accessed in the template, otherwise a new query is issued, the objects will be reinstantiated and any fields you added in the view are lost.</p>
</div>
<span class="comment-copy">Thanks for this explanation. Do you happen to have a reference for the "only exception" thing? I think I am still slightly struggling with the concept of a <code>QuerySet</code>. I will try to use the "instance method" approach; it seems to be a tad more tricky though because the calculation is not "local" (I need the "other" <code>Event</code>'s timestamp to calculate the diff...). Let's see.</span>
<span class="comment-copy">QuerySets and the difference between defining and evaluating them are explained <a href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#s-when-querysets-are-evaluated" rel="nofollow noreferrer">here</a>. You didn't clarify what input goes into the calculation; it may make more sense to add the result to a queryset as an <a href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/#annotate" rel="nofollow noreferrer">annotation</a>.</span>
<span class="comment-copy">Thanks again for the hint/link about <code>QuerySet</code>s as well as the annotation possibility. It brought me on track, I think. Currently I am trying to leverage <a href="https://docs.djangoproject.com/en/2.1/ref/models/instances/#django.db.models.Model.get_previous_by_FOO" rel="nofollow noreferrer">Model.get_next_by_FOO/Model.get_previous_by_FOO</a> which seems promising.</span>
