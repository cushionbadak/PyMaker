<div class="post-text" itemprop="text">
<p>My goal of below code is pretty simple:</p>
<p>1: When I press on <code>TextInput</code> the <code>hint_text</code> clears, <code>'+'</code> appears and I can type a value to add.</p>
<p>2: When I press on <code>TextInput</code> and then press outside the <code>hint_text</code> shows old value. </p>
<p>3: The same as in p. 2 when I press on other <code>TextInput</code>. </p>
<p>I've achived the goal but the amount of code and complexity is terrible and I belive there is much simpler way. </p>
<p>I wonder if there is a way to make a function that will <code>return</code> an <code>id:</code> of the widget I'm touching without calling a method from each instance of StorageBox. </p>
<p>Please keep in mind that there will be more of inputs in this app not just twice. I've added 10 inputs and it works but the code is hard to maintain.  </p>
<p>You can see behaviour on the 
<a href="https://www.youtube.com/watch?v=iJ4BCsIQO7g&amp;feature=youtu.beClip" rel="nofollow noreferrer">Clip</a></p>
<pre><code>from kivy.config import Config    
Config.set('graphics', 'multisamples', '0')
from kivy.app import App
from kivy.lang import Builder
from kivy.uix.gridlayout import GridLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.textinput import TextInput
from kivy.clock import Clock

kv = """
#:import FadeTransition kivy.uix.screenmanager.FadeTransition
ScreenManager:
    transition: FadeTransition()
    StorageScreen:

&lt;StorageButton@Button&gt;
    size_hint_y: None
    height: 15
    text: 'ADD'
&lt;StorageLabel@Label&gt;

&lt;StoragePlusLabel@Label&gt;
    size_hint_x: None
    width: 10

&lt;StorageInput@TextInput&gt;:
    unfocus_on_touch: False
    #focus: True
    multiline: False
    text_size: self.size
    halign: "right"
    valign: "middle"
    markup: True

&lt;StorageBox&gt;
    orientation: 'vertical'
    size_hint: None, None
    size: 50, 50
    padding: 1
    canvas.before:
        Color:
            rgba: (0, 0, 0, 1)
        Rectangle:
            pos: self.pos
            size: self.size
    on_touch_down: if not self.collide_point(*args[1].pos): root.this_is(True) 
    on_touch_down: if  self.collide_point(*args[1].pos): root.this_is(False)

&lt;Storage&gt;:
    StorageBox:
        StorageLabel:
            text: 'UPC'
    StorageBox:
        StorageLabel:
            text: '1m'
    StorageBox:
        StorageLabel:
            text: '2m'

    StorageBox:
        StorageLabel:
            text: 'LC/LC'

    StorageBox:
        id: lc_lc_1m
        on_touch_down:  if not self.collide_point(*args[1].pos):  root.touched('lc_lc_1m', False, False) 
        GridLayout:
            cols:3 
            StoragePlusLabel: 
                id: lc_lc_1m_lbl               
            StorageInput:            
                id: lc_lc_1m_inp 
                on_touch_down:  if  self.collide_point(*args[1].pos): root.touched('lc_lc_1m', False, True) 
            StoragePlusLabel:
        StorageButton: 
            id: lc_lc_1m_btn
            on_press: root.touched('lc_lc_1m', True, False)

    StorageBox: 
        id: lc_lc_2m  
        on_touch_down:  if not self.collide_point(*args[1].pos):  root.touched('lc_lc_2m', False, False)    
        GridLayout:
            cols:3 
            StoragePlusLabel: 
                id: lc_lc_2m_lbl               
            StorageInput:            
                id: lc_lc_2m_inp 
                on_touch_down:  if self.collide_point(*args[1].pos): root.touched('lc_lc_2m', False, True)                                                                                                   
            StoragePlusLabel:                                   
        StorageButton: 
            id: lc_lc_2m_btn
            on_press: root.touched('lc_lc_2m', True, False)


&lt;StorageScreen&gt;
    Storage:

"""

outside_storage_box = False


class StorageBox(BoxLayout):
    def __init__(self, **kwargs):
        super(StorageBox, self).__init__(**kwargs)

    def this_is(self, val):
        global outside_storage_box
        outside_storage_box = val
        print('outside_storage_box', val)

class Storage(GridLayout):
    cols = 3
    rows = 2
    i = 0
    storage = {'lc_lc_1m': '12', 'lc_lc_2m': '33'}

    def __init__(self, **kwargs):
        super(Storage, self).__init__(**kwargs)
        Clock.schedule_once(self.fill)

    def fill(self, dt):
        print('fill')
        for key in self.storage.keys():
            self.ids[key+'_lbl'].text = ''
            self.ids[key + '_inp'].text = ''
            self.ids[key + '_inp'].hint_text = self.storage[key]


    def touched(self, key, add, collide):
        global outside_storage_box
        print(self.i)
        self.i += 1
        self.key = key
        self.inp = self.key + '_inp'
        self.lbl = self.key + '_lbl'
        self.value = self.ids[self.inp].text
        self.add = add
        self.collide = collide

        print('------------------------------')
        print('key', key,  'add', self.add, 'value', self.value, 'outside', outside_storage_box, 'collide', self.collide)

        if self.add == False and self.collide == False and outside_storage_box == True:
            self.fill(1)

        if self.add == False and self.collide == True and outside_storage_box == False:
            self.fill(1)
            self.ids[self.lbl].text = '+'
            self.ids[self.inp].hint_text = ''

        if self.add == True and self.collide == False:
            try:
                int(self.value)
            except:
                print('Must be integer')
            else:
                self.storage[self.key] = str(int(self.storage[self.key]) + int(self.value))
                self.fill(1)


class StorageScreen(Screen):
    pass

class ScreenManagement(ScreenManager):
    pass

sm = Builder.load_string(kv)

class TestApp(App):
    def build(self):
        return sm

if __name__ == '__main__':
    TestApp().run()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a complete working example of what you want to do, you'll have to modify the look and feel to make it fit your application probably. Let me know if you have any questions.</p>
<p><code>main.py</code></p>
<pre><code>from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.scrollview import ScrollView

class MainApp(App):
    pass

MainApp().run()
</code></pre>
<p><code>main.kv</code></p>
<pre><code>&lt;MyWidget@GridLayout&gt;: 
    cols: 1
    text: ""
    GridLayout:
        rows: 1
        Label:
            text: ""
            id: plus_label
        TextInput:
            id: text_input
            hint_text: root.text  # root.text refers to the text variable at the top of this widget
            on_focus:
                plus_label.text = "+" if self.focus else ""  # If the user clicks in the text input, show the plus sign.
                # If they click outside the text input, hide the plus sign
    Button:
        text: "ADD"
        on_release:
            text_input.hint_text = str(int(text_input.hint_text) + int(text_input.text)) # Do some math using the text and hint text
            text_input.text = ""  # Clear the text





GridLayout:
    rows: 1
    MyWidget:
        text: "8" # This sets the `root.text` variable, which the text input initializes to
    MyWidget:
        text: "3"
</code></pre>
</div>
<span class="comment-copy">Thanks to your response I've noticed that <code>on_focus</code> can call method when the <code>TexInput</code> is defocusing. That let me to call function that checks if the "TextInput` is focused and  fills my <code>labels</code> and <code>inputs</code> even when I touch outside the <code>TexInput</code></span>
