<div class="post-text" itemprop="text">
<pre><code>helpful
'[2, 4]'
'[0, 0]'
'[0, 1]'
'[7, 13]'
'[4, 6]'
</code></pre>
<p>Column name helpful has a list inside the string. I want to split 2 and 4 into separate columns.</p>
<pre><code>[int(each) for each in df['helpful'][0].strip('[]').split(',')]
</code></pre>
<p>This works the first row but if I do </p>
<pre><code>[int(each) for each in df['helpful'].strip('[]').split(',')]
</code></pre>
<p>gives me attribute error</p>
<pre><code>AttributeError: 'Series' object has no attribute 'strip'
</code></pre>
<p>How can I print out like this in my dataframe??</p>
<pre><code>helpful not_helpful
2       4
0       0
0       1
7       13
4       6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As suggested by @abarnert, the first port of call is find out <em>why</em> your data is coming across as strings and try and rectify that problem.</p>
<p>However, if this is beyond your control, you can use <code>ast.literal_eval</code> as below.</p>
<pre><code>import pandas as pd
from ast import literal_eval

df = pd.DataFrame({'helpful': ['[2, 4]', '[0, 0]', '[0, 1]', '[7, 13]', '[4, 6]']})

res = pd.DataFrame(df['helpful'].map(literal_eval).tolist(),
                   columns=['helpful', 'not_helpful'])

#    helpful  not_helpful
# 0        2            4
# 1        0            0
# 2        0            1
# 3        7           13
# 4        4            6
</code></pre>
<p><strong>Explanation</strong> </p>
<p>From the <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">documentation</a>, <code>ast.literal_eval</code> performs the following function:</p>
<blockquote>
<p>Safely evaluate an expression node or a string containing a Python
  literal or container display. The string or node provided may only
  consist of the following Python literal structures: strings, bytes,
  numbers, tuples, lists, dicts, sets, booleans, and None.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Assuming what you've described here accurately mimics your real-world case, how about a regex with <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.extract.html" rel="nofollow noreferrer"><code>.str.extract()</code></a>?</p>
<pre><code>&gt;&gt;&gt; regex = r'\[(?P&lt;helpful&gt;\d+),\s*(?P&lt;not_helpful&gt;\d+)\]'
&gt;&gt;&gt; df
  helpful
0  [2, 4]
1  [0, 0]
2  [0, 1]

&gt;&gt;&gt; df['helpful'].str.extract(regex, expand=True).astype(np.int64)
   helpful  not_helpful
0        2            4
1        0            0
2        0            1
</code></pre>
<p>Each pattern <code>(?P&lt;name&gt;...)</code> is a named capturing group.  Here, there are two: helpful/not helpful.  This assumes the pattern can be described by: opening bracket, 1 or more digits, comma, 0 or more spaces, 1 or more digits, and closing bracket.  The Pandas method (<code>.extract()</code>), as its name implies, "extracts" the result of <code>match.group(i)</code> for each <code>i</code>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; regex = r'\[(?P&lt;helpful&gt;\d+),\s*(?P&lt;not_helpful&gt;\d+)\]'
&gt;&gt;&gt; re.search(regex, '[2, 4]').group('helpful')
'2'
&gt;&gt;&gt; re.search(regex, '[2, 4]').group('not_helpful')
'4'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun without module.</p>
<pre><code>s = """
helpful
'[2, 4]'
'[0, 0]'
'[0, 1]'
'[7, 13]'
'[4, 6]'
"""

lst = s.strip().splitlines()
d = {'helpful':[], 'not_helpful':[]}

el = [tuple(int(x) for x in e.strip("'[]").split(', ')) for e in lst[1:]]

d['helpful'].extend(x[0] for x in el)
d['not_helpful'].extend(x[1] for x in el)

NUM_WIDTH = 4
COLUMN_WIDTH = max(len(k) for k in d)
print('{:^{num_width}}{:^{column_width}}{:^{column_width}}'.format(
    ' ', *sorted(d),
    num_width=NUM_WIDTH,
    column_width=COLUMN_WIDTH
    )
)
for (i, v) in enumerate(zip(d['helpful'], d['not_helpful']), 1):
    print('{:^{num_width}}{:^{column_width}}{:^{column_width}}'.format(
        i, *v,
        num_width=NUM_WIDTH,
        column_width=COLUMN_WIDTH
        )
    )
</code></pre>
</div>
<span class="comment-copy">Look at <code>ast.literal_eval</code></span>
<span class="comment-copy">The first question is how you're <i>getting</i> those strings with lists inside. If you're trying to store data by just printing it out to a file as strings and then parsing the result, that's almost never a good idea—see <code>json</code>, <code>pickle</code>, and various alternatives you can find on PyPI—but in the specific case of a CSV, why not make it two columns instead of one column with a 2-element list? Or a Numpy struct field, or a Pandas compound thingy I forget the name of?</span>
<span class="comment-copy">json file that I found online had a list of the string in one column. My goal is to split it and make it into two separate columns. Thank you for your feedback tho!</span>
