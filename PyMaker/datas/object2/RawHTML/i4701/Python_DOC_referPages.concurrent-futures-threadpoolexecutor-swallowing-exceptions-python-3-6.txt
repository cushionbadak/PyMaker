<div class="post-text" itemprop="text">
<p>I'm trying to use <code>ThreadPoolExecutor</code> in Python 3.6 on Windows 7 and it seems that the exceptions are silently ignored or stop program execution. Example code:</p>
<pre><code>#!/usr/bin/env python3

from time import sleep

from concurrent.futures import ThreadPoolExecutor

EXECUTOR = ThreadPoolExecutor(2)


def run_jobs():
    EXECUTOR.submit(some_long_task1)
    EXECUTOR.submit(some_long_task2, 'hello', 123)
    return 'Two jobs was launched in background!'


def some_long_task1():
    print("Task #1 started!")
    for i in range(10000000):
        j = i + 1
    1/0
    print("Task #1 is done!")


def some_long_task2(arg1, arg2):
    print("Task #2 started with args: %s %s!" % (arg1, arg2))
    for i in range(10000000):
        j = i + 1
    print("Task #2 is done!")


if __name__ == '__main__':
    run_jobs()
    while True:
        sleep(1)
</code></pre>
<p>The output:</p>
<pre><code>Task #1 started!
Task #2 started with args: hello 123!
Task #2 is done!
</code></pre>
<p>It's hanging there until I kill it with <kbd>Ctrl</kbd>+<kbd>C</kbd>. </p>
<p>However, when I remove <code>1/0</code> from <code>some_long_task1</code>, Task #1 completes without problem:</p>
<pre><code>Task #1 started!
Task #2 started with args: hello 123!
Task #1 is done!
Task #2 is done!
</code></pre>
<p>I need to capture the exceptions raised in functions running in <code>ThreadPoolExecutor</code> <em>somehow</em>.</p>
<p>Python 3.6 (Minconda), Windows 7 x64.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.6/library/concurrent.futures.html#concurrent.futures.Executor.submit" rel="nofollow noreferrer"><code>ThreadPoolExecutor.submit</code></a> returns a <a href="https://docs.python.org/3.6/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><em>future</em> object</a> that represents the result of the computation, once it's available. In order to not ignore the exceptions raised by the job, you need to actually access this result. First, you can change <code>run_job</code> to return the created futures:</p>
<pre><code>def run_jobs():
    fut1 = EXECUTOR.submit(some_long_task1)
    fut2 = EXECUTOR.submit(some_long_task2, 'hello', 123)
    return fut1, fut2
</code></pre>
<p>Then, have the top-level code <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.wait" rel="nofollow noreferrer">wait</a> for the futures to complete, and access their results:</p>
<pre><code>import concurrent.futures

if __name__ == '__main__':
    futures = run_jobs()
    concurrent.futures.wait(futures)
    for fut in futures:
        print(fut.result())
</code></pre>
<p>Calling <code>result()</code> on a future whose execution raised an exception will propagate the exception to the caller. In this case the <code>ZeroDivisionError</code> will get raised at top-level.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can handle the exceptions with a <a href="https://docs.python.org/2/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer"><code>try</code></a> statement. This is how your <code>some_long_task1</code> method could look like:</p>
<pre class="lang-py prettyprint-override"><code>def some_long_task1():
    print("Task #1 started!")
    try:
        for i in range(10000000):
            j = i + 1
        1/0
    except Exception as exc:
        print('some_long_task1 generated an exception: {}'.format(exc))
    print("Task #1 is done!")
</code></pre>
<p>Output when the method is used within your script:</p>
<pre><code>Task #1 started!
Task #2 started with args: hello 123!
some_long_task1 generated an exception: integer division or modulo by zero
Task #1 is done!
Task #2 is done!
(the last while loop running...)
</code></pre>
</div>
