<div class="post-text" itemprop="text">
<p>I want to compute the maximum value of a function in python, then print the maximum value, as well as values of the variables at that maximum.</p>
<p>I think I have gotten pretty far.  In my example below, the function is just the values from <code>x</code> multiplied by the values from <code>y</code> multiplied by the values from <code>z</code> (in theory this function could be anything). The maximum of which would be <code>3 * 6 * 9 = 162</code>.  </p>
<p>My problem is: if these lists are hundreds of numbers long, I don't really want to print the entire list of inputs, which could be a massive list hundreds of thousands of entries long.  </p>
<p>I am only interested in the final set of values (so <code>3 6 9</code> here), but I just can't seem to work out how to print only this set.</p>
<p>Any help would be greatly appreciated.</p>
<p>Thanks!</p>
<pre><code>p=[1,2,3]
q=[6,5,4]
r=[7,8,9]

def f(x,y,z):
    maximum=0
    for a in x:
        for b in y:
            for c in z:
                if a*b*c &gt; maximum:
                    maximum = a*b*c
                    print (a,b,c)
    print (maximum)  

f(p,q,r)
</code></pre>
<p>Result:</p>
<pre><code>1 6 7
1 6 8
1 6 9
2 6 7
2 6 8
2 6 9
3 6 7
3 6 8
3 6 9
162
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to do it would be to keep track of the values in the same way that you keep track of the current maximum:</p>
<pre>
def f(x,y,z):
    maximum = 0
    for a in x:
        for b in y:
            for c in z:
                if a*b*c &gt; maximum:
                    maximum = a*b*c
                    <b>a_max = a
                    b_max = b
                    c_max = c
    print(a_max,b_max,c_max)</b>
    print(maximum)
</pre>
<p>You can make your code more robust by using a technique different than setting <code>maximum = 0</code> in the beginning. For example, what if your list only has negative numbers? The result will be wrong. You can use what is called a sentinel value, like <code>None</code>, to indicate the first iteration. A sentinel is a marker that indicates that an "invalid" value. That will ensure that the correct maximum is always found:</p>
<pre>
def f(x,y,z):
    maximum = <b>None</b>
    for a in x:
        for b in y:
            for c in z:
                if <b>maximum is None</b> <i>or</i> a*b*c &gt; maximum:
                    maximum = a*b*c
                    <b>abc_max = (a, b, c)</b>
    print (<b>*abc_max, sep=', '</b>)
    print (maximum)
</pre>
<p>You can improve the design of your code by <em>returning</em> the numbers you are interested in, instead of just printing them. That will allow you to manipulate them in any way you want, including printing them, afterwards. Python allows multiple return values using tuples, so you can do something like this:</p>
<pre>
def f(x,y,z):
    maximum = None
    for a in x:
        for b in y:
            for c in z:
                if maximum is None or a*b*c &gt; maximum:
                    maximum = a*b*c
                    abc_max = (a, b, c)
    <b>return maximum, abc_max

max, pqr = f(p, q, r)
print(*pqr, sep=', ')
print(max)</b>
</pre>
<p>An optimization you may want to consider is not evaluating your "function" more than once. This is especially important for more complex cases and functions that don't return the same value twice. You can replace the beginning of the <code>if</code> block with something like</p>
<pre><code>...
current_value = a * b * c
if current_value &gt; maximum:
    maximum = current_value
    ...
</code></pre>
<p>If you are really interested in making this work on arbitrary functions, you can use Python to do that. Functions are objects, and can be passed around just like lists, numbers and strings:</p>
<pre>
def f(<b>fn</b>, x, y, z):
    maximum = None
    for a in x:
        for b in y:
            for c in z:
                current = <b>fn(a, b, c)</b>
                if maximum is None or current &gt; maximum:
                    maximum = current
                    abc_max = (a, b, c)
    return maximum, abc_max

max, pqr = f(<b>lambda x, y, z: x * y * z,</b> p, q, r)
</pre>
<p>If you are interested in further generalizations, you can take a look at <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>, which has the function <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> for running a "flattened" version of your nested <code>for</code> loop. This will allow you to accept any number of input iterables, not just three. Python allows an arbitrary number of positional arguments using a <code>*</code> in the argument list. The argument with the <code>*</code> in its name will be a tuple of all the remaining positional arguments. It can be used in a lambda as well:</p>
<pre>
from functools import reduce
from itertools import product
from operator import mul

def f(fn, *iterables):
    max_values = max(product(*iterables), key=lambda x: fn(*x))
    return fn(*max_values), max_values

max, pqr = f(lambda *args: reduce(mul, args), p, q, r)
</pre>
<p>You could consider adding a comparator to do something other than computing the maximum. However, that would actually be overkill, since you can convert any other operation to a maximum computation using a properly implemented <code>fn</code>. That is the same logic to implementing Pythons sort functions in terms of a key instead of a comparator. In the example above, you could find the minimum value by flipping the sign of the key: <code>lambda *args: -reduce(mul, args)</code>. You could find the combination whose product is closest to it's sum with something like <code>lambda *args: -abs(sum(args) - reduce(mul, args))</code>. The possibilities are vast.</p>
<p>Here is a link to an IDEOne example demonstrating the last version shown above: <a href="https://ideone.com/QNj55T" rel="nofollow noreferrer">https://ideone.com/QNj55T</a>. IDEOne is a handy tool for showing off or testing small snippets. I have no affiliation with it but I use it quite often.</p>
</div>
<div class="post-text" itemprop="text">
<p>Turns out writing your question out is a good way of solving it. Thanks anyway!</p>
<pre><code>def f(x,y,z):
    maximum=0
    for a in x:
        for b in y:
            for c in z:
                if a*b*c &gt; maximum:
                    j=(a,b,c)
                    maximum = a*b*c
    print (maximum)
    print (j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that is a bit more streamlined and <code>pythonic</code> since you are wanting this to be a learning example.  I also commented heavily so you can follow-along:</p>
<pre><code># importing this is necessary in python3 as `reduce` was removed in python3
import functools

p = [1,2,3]
q = [6,5,4]
r = [7,8,9]

def f (x,y,z):

    # 1. Combine the list arguments together into 1 list "[x,y,z]"
    # 2. Iterate over each list in the group of lists "for li in [x,y,z]"
    # 3. Get the max number within each list "max(li)"
    # 4. Assign the resulting list to the maxv variable "maxv = ..." yielding [3,6,9]
    maxv = [max(li) for li in [x,y,z]]

    # Print the 3 largest integers used to multiply next
    print( maxv )

    # Use reduce to multiply each list element by themselves
    product = functools.reduce(lambda x,y: x*y, maxv)

    # Print the output = 162 in this case
    print( product )

f(p,q,r)    
</code></pre>
<h1>Update</h1>
<p>Incase you don't know how many lists of integers are going to be passed into the function (perhaps more than 3) you could iterate over the entire argument handler and make that your list instead of coding <code>[x,y,z]</code>, like so:</p>
<pre><code>p = [1,2,3]
q = [6,5,4]
r = [7,8,9]
s = [8,9,10]
t = [9,10,11]

def d (*args):
    maxv = [max(li) for li in [x for x in args]]
    print( maxv )
    product = functools.reduce(lambda x,y: x*y, maxv)
    print( product )

d(p,q,r)   # yields 162
d(p,q,r,s) # yields 1620
d(p,q,r,s,t) # yeilds 17820
</code></pre>
</div>
<span class="comment-copy">The last items are by definition your maximum.</span>
<span class="comment-copy">Sure but I <b>*only</b> wanted the values 3 6 9 and not the list above it</span>
<span class="comment-copy">Really insightful, thanks!</span>
<span class="comment-copy">@JaneWatson. Glad to help when I see that you put a lot of work into this yourself.</span>
<span class="comment-copy">@JaneWatson. It's pretty standard to accept an answer once something that helps comes along, even if it is your own.</span>
<span class="comment-copy">Won't let me for another 2 days.</span>
<span class="comment-copy">Nice work. Try <code>print(*j, sep=', ')</code>.</span>
<span class="comment-copy">Kinda defeats the purpose given "in theory this function could be anything" in the question...</span>
<span class="comment-copy">Still a nice solution.</span>
<span class="comment-copy">well, he wanted to 'multiply' the values together, so we know its only going to contain integers.  I would say the only way to make this more <code>dynamic</code> would be to create an argument iterator to combine all possible arguments (incase more than 3 are given) into a list versus hardcoding <code>[x,y,z]</code></span>
<span class="comment-copy">The best way would be to pass in your function for combining the values, your function for comparing them to the current "maximum" and your arbitrary list of iterables.</span>
<span class="comment-copy">Take a look at the last bit of code in my answer.</span>
