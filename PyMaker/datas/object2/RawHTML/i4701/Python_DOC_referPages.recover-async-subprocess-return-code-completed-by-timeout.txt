<div class="post-text" itemprop="text">
<p>I would like to know if there is a way to recover the return code when the asynchronous process has been completed by a timeout. 
The constraints are that I want to recover this code in another class that is in another python file. In addition, I do not want to block my GUI ...</p>
<p>In my MainView.py, my code this :</p>
<pre><code>        if self.comboBox.currentText() == "HASHCAT" :
        self.process = Hashcat(MainWindow.hashcatPath, 100, 3, MainWindow.hashFilePath, MainWindow.dictPath, MainWindow.pathOutFile)
        self.process.run(2)
</code></pre>
<p>And my Hashcat.py file look like this :</p>
<pre><code>    def run(self,timeout):
        def target():

            FNULL = open(os.devnull, 'w')

            if self.typeAttack == 0 :
                self.subprocess=\
                    subprocess.Popen([self.pathHashcat,"-m",str(self.algoHash),"-a",str(self.typeAttack),self.pathHashFile,self.pathDict,
                                     "-o",self.pathOutFile],
                                stdout=FNULL, stderr=subprocess.STDOUT)

            if self.typeAttack == 3 :

                self.subprocess =\
                subprocess.Popen(
                [self.pathHashcat, "-m", str(self.algoHash), "-a", str(self.typeAttack),self.pathHashFile,"-o",self.pathOutFile])
                self.timer.start()
                self.subprocess.wait()
                self.timer.cancel()



        def timer_callback():
            print('Terminating process (timed out)')
            self.subprocess.terminate()

        self.thread = threading.Thread(target=target)
        self.timer = threading.Timer(timeout, timer_callback)
        self.thread.start()
        print(self.timer.isAlive)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Calling <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.terminate" rel="nofollow noreferrer"><code>terminate</code></a> just sends the signal to kill the process; you may still have to <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer"><code>wait</code></a> on it before you can get the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.returncode" rel="nofollow noreferrer"><code>returncode</code></a>; otherwise, it will still be <code>None</code>.</p>
<p>However, the <code>returncode</code> is unlikely to be all that meaningful. You just killed the process with a <code>SIGTERM</code>, so the <code>returncode</code> is going to be <code>-SIGTERM</code>.</p>
<p>If the problem is just that <code>terminate</code> takes too long, or isn't deterministic—well, <code>SIGTERM</code> is meant to be something the child process can use for clean shutdown, which can take time—and can even fail to do anything, if the child has a serious bug. If you really want it to go away immediately, you need to send a <code>SIGKILL</code> instead. (This is the difference between <code>kill 12345</code> and <code>kill -9 12345</code> from the terminal.) The way to do that from <code>subprocess</code> is to call the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.kill" rel="nofollow noreferrer"><code>kill</code></a> method instead of <code>terminate</code>.</p>
<p>The ideal solution is usually to have a double-timeout—e.g., <code>terminate</code> after X seconds, then <code>kill</code> if another Y seconds have passed without termination. This gives the process a chance to do graceful shutdown whenever possible, but still guarantees deterministic killing after X+Y seconds. But it depends—for some uses of some programs, giving the child an extra Y seconds to hopefully finish is more important than giving it Y seconds to clean up. Or it doesn't make much difference either way, and the single-step <code>kill</code> is just simpler to code.</p>
<p>(This is all a different if you're on Windows, but since you're on OS X, that's irrelevant.)</p>
</div>
<span class="comment-copy">Thanks form the quick reply. I want to get the signal of the end of the subprocess in an other class file (MainView.py). In order to, not block my python program... I'm under OS X. I don't know if i'm using the best method to timeout the subprocess asyn...</span>
<span class="comment-copy">@BorisElGareh I don't understand your additional requirements. Are you looking for a way to force the program to absolutely positively terminate in a deterministic amount of time, and <code>terminate</code> is taking too long? If so, you can use <code>kill(SIGKILL)</code> instead of <code>terminate()</code> (or, maybe better, do a <code>terminate</code> first, then only <code>kill(SIGKILL)</code> if that doesn't happen fast enough).</span>
<span class="comment-copy">@BorisElGareh But either way, that doesn't change the fact that you're not going to get a useful <code>returncode</code> if you terminated the process; you're just going to get the signal back, negated (because, after all, you never gave the process a chance to do a normal <code>exit</code>, so there can't be any useful <code>returncode</code>).</span>
<span class="comment-copy">@abarnet  Thanks for the additional information, I will use the kill () method. Indeed, my goal is to timeout the process if it takes too much time, in my case 60 seconds would suffice. And I want to run a test in my MainView.py file to find out if the process ended properly or when it was timeout by kill() method</span>
<span class="comment-copy">@BorisElGareh OK, then doing <code>kill</code> then <code>wait</code> to get the retcode will work… although of course you could also just keep track of the fact that you called <code>kill</code>.</span>
