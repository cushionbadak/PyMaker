<div class="post-text" itemprop="text">
<p>I was converting some old Python code to use <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> instead of <code>os.path</code> for most path-related operations, but I ended up with the following problem: I needed to add another extension to a path that already had an extension (not replace it). With <code>os.path</code>, since we are merely manipulating strings, the solution was to add the extension with string operations:</p>
<pre><code>newpath = path + '.res'
</code></pre>
<p>It doesn't work with <code>pathlib.Path</code> because it doesn't allow concatenation of arbitrary characters. The closest I could find was the following:</p>
<pre><code>newpath = path.with_suffix(path.suffix + '.res')
</code></pre>
<p>It looks like a workaround because it still uses string addition in the end. And it has a new pitfall because I forgot at first to handle the case where there are already several extensions and you want to add a new one, leading to the following code to get back the old behaviour:</p>
<pre><code>newpath = path.with_suffix(''.join(path.suffixes) + '.res')
</code></pre>
<p>Now it doesn't feel terse nor clean since it uses more and more string operations to achieve the old behaviour instead of pure path operations. The fact that <code>Path.suffixes</code> exists means that the library's developers considered the case where a file can have multiple extensions, yet I couldn't find a way to simply add a new extension to a path. Is there a more idiomatic way that I have missed to achieve the same behaviour?</p>
<p>EDIT: actually <code>path.with_suffix(path.suffix + '.res')</code> is enough to handle the case where there are already several file extensions, even though it wasn't immeditely obvious to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't seem like Path's like being modified in-place (you can't change <code>.parts[-1]</code> directory or change <code>.suffixes</code>, etc.), but that doesn't mean you need to resort to anything too unsavory. The following works just fine, even if it's not quite as elegant as I'd like:</p>
<pre><code>new_path = path.parent / (path.name + new_suffix)
</code></pre>
<p>where <code>path</code> is your original Path variable, and <code>new_suffix</code> is the string with your new suffix/extension (including the leading ".")</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just convert your <code>Path</code> to string then add new extension and convert back to <code>Path</code>:</p>
<pre><code>from pathlib import Path
first = Path("D:/user/file.xy")
print(first)
second = Path(str(first)+".res")
print(second)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following code should do what you want it to in a very dynamic way.</p>
<pre><code>from pathlib import Path
import time

p = Path('.')
p = p / '..' / 'Python' / 'Files' / 'Texts_to_read' / 'a_text_file'

new_p = str(p).split('\\')

new_suffix = '.txt'

new_p[-1] = new_p[-1] + new_suffix

p = Path('.')

for x in new_p:
    p = p / x

print(new_p)

print(p)
print(str(p))

time.sleep(5)
</code></pre>
<p>The fact that normal string operations can be used in this case is a good thing, as it adds a great deal of control over the file path desired without requiring a large assortment of new functions. </p>
</div>
<span class="comment-copy">Didn't see your edit until after posting my answer... that seems like a pretty good solution too</span>
<span class="comment-copy">If you are going to write out both extensions, it would probably be more canonical to write as <code>new_path = path.with_suffix(new_suffix)</code></span>
