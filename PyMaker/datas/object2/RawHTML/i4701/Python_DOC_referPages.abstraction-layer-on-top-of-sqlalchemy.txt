<div class="post-text" itemprop="text">
<p>I am on a Python 3.6 project that uses Sqlalchemy where we want another layer of abstraction over Sqlalchemy. This will allow us to more easily replace Sqlalchemy with another library if desired.</p>
<p>In this example it is the <code>DbHelper</code> class:</p>
<p><strong>dbhelper.py</strong></p>
<pre><code>from dbconn import dbconn
from models.animals import Dogs

class DbHelper():
    @staticmethod
    def get_dog_by_nickname(nickname):
        return dbconn.session.query(Dogs).get(nickname)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code>from dbhelper import DbHelper

class Dog():
    def __init__(self, nickname, breed, age):
        self.nickname = nickname
        self.breed = breed
        self.age = age

    @classmethod
    def using_nickname(cls, nickname):
        row = DbHelper.get_dog_by_nickname(nickname)
        return Dog(row.id, row.breed, row.age)

dog = Dog.using_nickname('Tom')
</code></pre>
<p><strong>Question:</strong> Is there a better method than creating the <code>DbHelper</code> class for use as a container and having only <code>staticmethod</code> in it? I have read that this is not pythonic.</p>
<p>Converting all the <code>staticmethod</code> functions in <code>dbhelper.py</code> to regular methods will populate the namespace when we do <code>from dbhelper import *</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is a better solution than creating a class full of <code>staticmethod</code>s: Just don't create the class, and make them all module-level functions:</p>
<pre><code>from models.animals import Dogs

dbconn = ... 

def get_dog_by_nickname(nickname):
    return dbconn.session.query(Dogs).get(nickname)
</code></pre>
<p>The only real point of a class full of <code>staticmethod</code>s is to provide a namespace for all those functions to live in. A module already <em>is</em> a namespace for all those functions to live in. And, because it's more directly supported by the language syntax, it means you can more easily go around the namespacing when you want to do so explicitly (e.g., <code>from dbhelper import ...</code>).</p>
<hr/>
<p>You say:</p>
<blockquote>
<p>Converting all the staticmethod functions in dbhelper.py to regular methods will populate the namespace when we do <code>from dbhelper import *</code></p>
</blockquote>
<p>But the answer to that is obvious: Don't <code>from dbhelper import *</code>, just <code>import dbhelper</code>. Then, all the code that you would have written with <code>DbHelper.spam()</code> becomes <code>dbhelper.spam()</code>.</p>
<p>If you really want two levels of namespace, you can just use a package with a submodule, rather than a module with a class. But I can't see any good reason you'd need two levels of namespace here.</p>
<hr/>
<p>Another alternative (as suggested by juanpa.arrivillaga in the comments) is to turn this into a real class, where each instance (even if there will probably only be one in your real code) has its own <code>self.dbconn</code> instead of using a module global. That <code>dbconn</code> can either be passed into the <code>__init__</code>, or constructed directly inside the <code>__init__</code>. For example:</p>
<pre><code>class DbHelper:
    def __init__(self, dbname, otherdbparam):
        self.dbconn = dblib.connect(dbname, otherdbparam)
    def get_dog_by_nickname(self, nickname):
        return self.dbconn.session.query(Dogs).get(nickname)
</code></pre>
<p>Notice that we're using normal methods, and accessing a normal instance variable. This is what a class is forâ€”to wrap up some state together with the methods that transform that state.</p>
<p>How do you decide between the two? Well, if there's only ever going to be one <code>dbconn</code> per process, they're <em>functionally</em> equivalent, but conceptually they have different connotations. If you think of a DbHelper as a database, both the connection and the database behavior, it should be a class, and you should instantiate an instance of that class and use it that way. If you think of it as just a bunch of helper functions that operate on a dbconn that has its own independent existence, it should be a flat module.</p>
<hr/>
<p>In some languages (like Java), there is another point to using a class full of <code>staticmethod</code>-equivalents: the language either doesn't support "free functions", or makes them a completely different kind of thing from methods. But that isn't true in Python.</p>
<hr/>
<p>While we're at it, do you want your module to export <code>Dogs</code> and <code>dbconn</code> as a "public" part of the interface? If not, you should add an <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer"><code>__all__</code></a> spec to the top of your module, like this:</p>
<pre><code>from models.animals import Dogs

__all__ = [
    'get_dog_by_nickname',
    ...
]

dbconn = ... 

def get_dog_by_nickname(nickname):
    return dbconn.session.query(Dogs).get(nickname)
</code></pre>
<p>Or, alternatively, name all your "private" module members with underscores:</p>
<pre><code>from models.animals import Dogs as _Dogs

_dbconn = ... 

def get_dog_by_nickname(nickname):
    return _dbconn.session.query(_Dogs).get(nickname)
</code></pre>
<p>Either way, users of your module can still access the "private" data, but it won't show up in  <code>from dbhelper import *</code>, <code>help(dbhelper)</code>, the default autocomplete in many IDEs, etc.</p>
</div>
<span class="comment-copy">If you have two separate things to ask about (even if they're about the same project, they clearly don't have the same answer), you should create two separate SO questions. You should ideally add links between them, and make sure to write them carefully enough that it's obvious you're asking something different, so someone doesn't mark one as a dup of the other. (There are a lot of bad questions here, so people sometimes jump the gun on closes.)</span>
<span class="comment-copy">@abarnert Thank you for the suggestion, I have edited the question to contain just one single question</span>
<span class="comment-copy">If <code>from dbhelper import *</code> is a problem, why not just not <code>from dbhelper import *</code>? The reason <code>import dbhelper</code> doesn't do that by default is to give you exactly the functionality you're looking for. You're working around that just so you can reimplement the same thing you threw away.</span>
<span class="comment-copy">As a side note, I'm not sure this is as great an idea as it seems. If you're doing non-trivial queries that take advantage of alchemy's spiffy expression-tree query builders, none of that will port easily to another library. But if all your queries are as simple as the example you've shown, you really don't need alchemy in the first place, and could just write these wrappers around straight SQL queries.</span>
<span class="comment-copy">Definitely, a class with no state and all static-methods suggests your code could be refractored into a module with a bunch of module-level functions. However, in this case, you are merely relying on a module-global attribute! If you are going to use a class, then <i>it should be managing state</i>.  You probably should pass the db-connection as an argument to your <code>DbHelper</code> constructor. And viola: you are encapsulating state <code>dbh = DbHelper(dbconn)</code></span>
