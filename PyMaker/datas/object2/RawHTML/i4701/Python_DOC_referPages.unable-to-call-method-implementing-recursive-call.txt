<div class="post-text" itemprop="text">
<p>I'm a python beginner. When I tried to implement the BinarySearchTree below, I got the following error</p>
<pre><code>exec(code, run_globals) 
  File "binarysearchtree.py", line 23, in &lt;module&gt; 
    print(BinarySearchTree.contains(n2,3)) 
TypeError: contains() missing 1 required positional argument: 'value'
</code></pre>
<p>Any help would be greatly appreciated. Thank you!</p>
<pre><code>import collections

class BinarySearchTree:

    Node = collections.namedtuple('Node', ['left', 'right', 'value'])

    @staticmethod
    def contains(self,root, value):
        if (root is None):
            return None
        elif (root.value==value):
            return root
        elif (root.value &lt; value):
            self.contains(root.right,value)
        else:
            self.contains(root.left,value)


n1 = BinarySearchTree.Node(value=1, left=None, right=None)
n3 = BinarySearchTree.Node(value=3, left=None, right=None)
n2 = BinarySearchTree.Node(value=2, left=n1, right=n3)

print(BinarySearchTree.contains(n2,3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you've defined your method as a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>staticmethod</code></a>, but then you're trying to use it as a normal method.</p>
<p>With a normal method, when you do <code>obj.meth(a, b)</code>, it calls<code>Cls.meth(obj, a, b)</code>, giving you that <code>obj</code> value as a <code>self</code> argument.</p>
<p>With a static method, <code>obj.meth(a, b)</code> just calls <code>Cls.meth(a, b)</code>. There is no <code>self</code> argument.</p>
<hr/>
<p>So, the error is because you're asking for <code>self, root, value</code> but only passing <code>root, value</code>. Just as the exception says, you're one argument short.</p>
<p>And meanwhile, you're trying to use that <code>self</code> within the method body, so you can't just get rid of it.</p>
<p>If you really want this to be a staticmethod on the tree, since the only thing you're actually doing with <code>self</code> is calling a staticmethod on the class, you can use the class name explicitly, like this:</p>
<pre><code>@staticmethod
def contains(root, value):
    if (root is None):
        return None
    elif (root.value==value):
        return root
    elif (root.value &lt; value):
        BinarySearchTree.contains(root.right,value)
    else:
        BinarySearchTree.contains(root.left,value)
</code></pre>
<p>And then your code will work. Well, it'll get rid of that exception; it still has other bugs (like not returning the result of the recursive call back up the chain).</p>
<hr/>
<p>But I don't understand why you wanted a staticmethod in the first place.</p>
<p>My guess is that you're trying to port what's basically a ML-translated-to-Java design. In Java, putting a bunch of free functions in a useless class counts as OO. In Python, you don't need to do that; you just have free functions on the module. A staticmethod doesn't really give you anything extra here except confusion.</p>
<p>Or you can actually translate this to OO. For example, if you merge the tree and node types (or turn the tree into a node handle for the root that passes the method through), you can make <code>contains</code> a perfectly normal method. Then you have to put the <code>None</code> check before each recursive call instead of at the top, but that's it.</p>
</div>
<span class="comment-copy">A better solution would be to make this a classmethod, not a staticmethod; those take a <code>cls</code> parameter and you can then do <code>cls.contains(...)</code>. But your point about not needing a class at all is absolutely correct.</span>
<span class="comment-copy">@DanielRoseman Making it a classmethod doesn't really buy you anything, unless you want to be able to subclass the type and make sure it calls methods on the subclass—and even that won't matter here, because the only method it calls is itself, and either you override this method or you don't. A better solution would be a free function, which does the same thing as a staticmethod without the extra confusion and misleadingness.</span>
<span class="comment-copy">Yes, I agree, as I said. But I do prefer <code>cls.contains</code> to explicitly naming the class.</span>
<span class="comment-copy">@DanielRoseman I try to avoid using <code>classmethod</code> and <code>cls</code> unless I explicitly need subclassing support—or an alternate constructor whether or not it needs subclassing support, because that's not just a common idiom, but 90% of the valid uses of <code>classmethod</code>. If I'm actually doing "static method" stuff, that's rare enough that it's better to be obvious about it, than to imply that this is something more normal.</span>
