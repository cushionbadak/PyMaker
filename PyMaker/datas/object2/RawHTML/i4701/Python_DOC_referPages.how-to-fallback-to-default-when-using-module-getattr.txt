<div class="post-text" itemprop="text">
<p>TL;DR: Is <code>globals()[name]</code> the CORRECT way to fall back to the "default"?</p>
<p>I have a large set of dynamically created classes that are defined from a YML file.</p>
<p>Dynamic class creation is accomplished via a combination of <a href="http://pyyaml.org/wiki/PyYAMLDocumentation" rel="nofollow noreferrer">PyYAML <code>yaml.safe_load_all</code></a> and the <a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer"><code>dataclasses.make_dataclass</code></a> (<a href="https://docs.python.org/dev/whatsnew/3.7.html" rel="nofollow noreferrer">new in 3.7</a>). I expect the specifications for these classes to occasionally change over time, which is why I chose YML as an easily understood format to describe them.</p>
<p>Python 3.7 is introducing new functionality (<a href="https://www.python.org/dev/peps/pep-0562/" rel="nofollow noreferrer">see PEP 562</a>): a module-level <code>__getattr__</code> function for managing module attribute access (there is also a module-level <code>__dir__</code> function). It would be convenient to utilize this new function to allow importing of each dynamically created <code>dataclass</code> class from the module namespace, like so:</p>
<pre><code># some_module.py
from package_name import DataClassName1, DataClassName2
</code></pre>
<p>...and like so:</p>
<pre><code># package_name/__init__
from .my_dataclasses import DynamicDataClassesDict

def __getattr__(name):
    try:
        return DynamicDataClassesDict[name]
    except KeyError:
        # fall back on default module attribute lookup
</code></pre>
<p>In reading PEP 562 it isn't immediately clear to me how to fall back to default functionality for module attribute access. For a class, one would just call <code>super().__getattr__(*args)</code>. I do see this line in one of the examples:</p>
<pre><code>return globals()[f"_deprecated_{name}"]
</code></pre>
<p>This approach seems to work. Is <code>globals()[name]</code> the CORRECT way to fall back to the "default"? It doesn't seem to be, given that <code>globals()[name]</code> will raise a <code>KeyError</code> rather than the expected <code>AttributeError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have it backwards. The module-level <code>__getattr__</code> function is only called as a <em>last resort</em>. There is nothing to fall back to - all other mechanisms have already failed to find an attribute of that name.</p>
<p>For example, if your module defines a global <code>foo</code> variable and someone accesses <code>your_module.foo</code>, then <code>__getattr__</code> won't even be called.</p>
<p>The PEP explains this in the <a href="https://www.python.org/dev/peps/pep-0562/#specification" rel="nofollow noreferrer">specification</a>:</p>
<blockquote>
<p>If an attribute is not found on a module object through the normal
  lookup (i.e. <code>object.__getattribute__</code>), then <code>__getattr__</code> is searched in
  the module <code>__dict__</code> before raising an AttributeError.</p>
</blockquote>
<p>Hence, the correct "fallback behavior" is to raise an AttributeError.</p>
</div>
<span class="comment-copy">I don't have Python 3.7 installed (yet), but if getting module attributes works like getting them from other objects, you should be able to use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr()</code></a> which supports an optional <code>default</code> argument which will be the return value if the attribute doesn't exist. As far as I can tell, PEP 562 doesn't discuss whether the new module <code>__getattr__()</code> will work with the built-in <code>getattr()</code> function, but I would expect that to be the case.</span>
<span class="comment-copy">@martineau i haven't tried it yet but it's possible <code>getattr()</code> would work on modules that include a <code>__getattr__</code> function- but i wouldn't expect it to work on modules that do not, and it would also probably be blind to objects that the <code>__getattr__</code> isn't aware of.</span>
<span class="comment-copy">Rick: If you're going to be using Python 3.7, can't you assume that all modules will have it (that work with that version)? If not there may be some way to test whether one does. I say all that because I think using <code>getattr()</code> would be the most "pythonic" ways to do what you want.</span>
<span class="comment-copy">@martineau If I am reading the PEP correctly, it sounds to me that only modules that explicitly define <code>__getattr__</code> have it. I'm mostly trying to gain an understanding of how his new feature is meant to work; at this point I have my own code working to my satisfaction.</span>
<span class="comment-copy">Rick: There's answers showing how to do it in earlier versions under the question <a href="https://stackoverflow.com/questions/2447353/getattr-on-a-module"><code>__getattr__</code> on a module</a>. Personally I've always liked the one where the module in <code>sys.modules[]</code> is replace by an instance of a regular class.</span>
<span class="comment-copy">makes sense. however, the default traceback message is lost when doing things this way. this makes me think it isn't <i>quite</i> the equivalent "default/fallback" I am looking for...</span>
<span class="comment-copy">@RickTeachey: There are definitely ways in which that's inconvenient, but it's the way the <code>__getattr__</code> system works (and not just for module <code>__getattr__</code>). The original AttributeError and traceback are <a href="https://github.com/python/cpython/blob/v3.7.0b2/Objects/typeobject.c#L6445" rel="nofollow noreferrer">unconditionally discarded</a> before invoking <code>__getattr__</code>. (Module <code>__getattr__</code> goes through a <a href="https://github.com/python/cpython/blob/v3.7.0b2/Objects/moduleobject.c#L679" rel="nofollow noreferrer">different code path</a>, but that code path doesn't let you use the default AttributeError either.)</span>
<span class="comment-copy">@RickTeachey Hmm. Unfortunately I don't have python 3.7 yet, so I can't tell what difference it makes. However, the PEP is quite clear that <i>if</i> <code>__getattr__</code> is called, its return value will be used as the attribute's value: <i>"If found, it is called with the attribute name and the result is returned."</i> So raising an exception is really the only thing you can do if you don't want to return anything.</span>
<span class="comment-copy">@user2357112 I suppose the only thing to be done, then is the same as in the case of any other object: re-create the traceback message yourself.</span>
