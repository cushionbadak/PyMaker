<div class="post-text" itemprop="text">
<pre><code>##### Case 1, use property #####
class Case1:
    # ignore getter and setter for property
    var = property(getter, setter, None, None)

##### Case 2, use equivalent methods ####
class Descriptor:
    def __get__(self, obj, type=None):
        return None
    def __set__(self, obj, val):
        pass

class Case2:
     var = Descriptor()
</code></pre>
<p>My question is:</p>
<p>When I use 'property' to control the access of one variable,</p>
<p><code>instance.var</code>  will correctly return the real value,
while <code>Class.var</code> will return the property object itself (e.g. <code>property object at 0x7fc5215ac788</code>)</p>
<p>But when I use equivalent methods (e.g. descriptor) and override <code>__get__</code> and <code>__set__</code> methods, 
both <code>instance.var</code> and <code>Class.var</code> can return the real value instead of the object itself.</p>
<p>So why they behave so differently? </p>
<p>I guess it is because some of default functions implemented in the my descriptor make the magic, so what are they?</p>
<hr/>
<p><code>update:</code></p>
<p>The reason for the above question is that <code>__get__</code> function implemented in the <code>property</code> will determine if it is called by instance or Class, and when it is called by Class, it will return the object itself (i.e. self).</p>
<p>But as <code>__set__</code> function does not have <code>type</code> or <code>cls</code> parameter, and based on my test, <code>Class.var = 5</code> cannot be caught by <code>__set__</code> function.
Therefore, I wonder what hooks we can use to customize the class variable level assignment <code>Class.var = value</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you do <code>MyClass.some_descriptor</code>, there's (obviously) no instance to be passed to the descriptor, so it is invoked with <code>obj=None</code>:</p>
<pre><code>&gt;&gt;&gt; class Desc(object):
...     def __get__(self, obj, cls=None):
...         print "obj : {} - cls : {}".format(obj, cls)
...         return 42
... 
&gt;&gt;&gt; class Foo(object):
...    bar = Desc()
... 
&gt;&gt;&gt; Foo.bar
obj : None - cls : &lt;class '__main__.Foo'&gt;
42
&gt;&gt;&gt; Foo().bar
obj : &lt;__main__.Foo object at 0x7fd285cf4a90&gt; - cls : &lt;class '__main__.Foo'&gt;
42
&gt;&gt;&gt; 
</code></pre>
<p>In most cases (and specially with the generic <code>property</code> descriptor) the goal is to compute the return value based on instance attributes so there's not much you can return without the instance. In this case, most authors choose to return the descriptor instance itself so it can be correctly identified for what it is when inspecting the class. </p>
<p>If you want this behaviour (which makes sense for most descriptors), you just have to test <code>obj</code> against <code>None</code> and return <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; class Desc2(object):
...     def __get__(self, obj, cls=None):
...         if obj is None:
...             return self
...         return 42
... 
&gt;&gt;&gt; Foo.baaz = Desc2()
&gt;&gt;&gt; Foo.baaz
&lt;__main__.Desc2 object at 0x7fd285cf4b10&gt;
&gt;&gt;&gt; Foo().baaz
42
&gt;&gt;&gt; 
</code></pre>
<p>And that's all the "magic" involved .</p>
<p>Now if you wonder why this is not the default: there are use cases for returning something else for a descriptor looked up on a class - methods for example (yes, Python functions are descriptors -  their <code>__get__</code> method returns a <code>method</code> object, which is actually a callable wrapper around the instance (if any), class and function):</p>
<pre><code>&gt;&gt;&gt; Foo.meth = lambda self: 42
&gt;&gt;&gt; Foo.meth
&lt;unbound method Foo.&lt;lambda&gt;&gt;
&gt;&gt;&gt; Foo().meth
&lt;bound method Foo.&lt;lambda&gt; of &lt;__main__.Foo object at 0x7fd285cf4bd0&gt;&gt;
&gt;&gt;&gt; Foo.meth(Foo())
42
</code></pre>
</div>
<span class="comment-copy">very clear explanation, Thanks a lot.</span>
<span class="comment-copy">btw, I found Python really has many 'implit' behavior, for example, like how 'instance.var' involve '_<i>getattribute_</i>' and finally involve '_<i>getattr_</i>', and it is hardly mentioned in many books. I wonder if there are some good materials covering these kind of topics?</span>
<span class="comment-copy">What about <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html</a> ? As far as I'm concerned, this is rather explicit, specially since Python is one of the very few OOPLs that publicly exposes its object model's inners and let you hook into it. Oh and yes: <code>__getattr__</code> is only invoked if implemented (there's no default implementation in <code>object</code>) AND as a last resort if nothing else resolved the attribute before.</span>
<span class="comment-copy">Based on my test, class variable level assignment <code>Class.var = value</code> cannot be caught by <code>__set__</code> function even if <code>var</code> is descriptor as it does not have <code>type</code> or <code>cls</code> parameter. So do you know what hooks I can use to make this kind of customization?</span>
<span class="comment-copy">Put the descriptor on the metaclass.</span>
