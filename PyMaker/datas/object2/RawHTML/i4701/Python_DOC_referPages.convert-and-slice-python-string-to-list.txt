<div class="post-text" itemprop="text">
<p>I am given a raw string which is a path or "direction" to a string in JSON. 
I need the following string converted to a list containing dictionaries.. </p>
<pre><code>st = """data/policy/line[Type="BusinessOwners"]/risk/coverage[Type="FuelHeldForSale"]/id"""
</code></pre>
<p>The list should look like this </p>
<pre><code>paths = ['data','policy','line',{'Type':'BusinessOwners'},'risk','coverage',{"Type":"FuelHeldForSale"},"id"]
</code></pre>
<p>I then iterate over this list to find the object in the JSON (which is in a Spark RDD)</p>
<p>I attempted <code>st.split(\)</code> which gave me</p>
<pre><code>st.split('/')
Out[370]: 
['data',
 'policy',
 'line[Type="BusinessOwners"]',
 'risk',
 'coverage[Type="FuelHeldForSale"]',
 'CalculationDisplay']
</code></pre>
<p>But how do I convert and split items like <code>'line[Type="BusinessOwners"]'</code> to <code>'line',{'Type':'BusinessOwners'}</code>  ?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import json

first_list = st.replace('[', '/{"').replace(']', '}').replace('="', '": "').split('/')
[item if not "{" in item  else json.loads(item) for item in first_list]
</code></pre>
<p>or using <code>ast.literal_eval</code></p>
<pre><code>import ast

[item if not "{" in item  else ast.literal_eval(item) for item in first_list]


out:
['data',
 'policy',
 'line',
 {'Type': 'BusinessOwners'},
 'risk',
 'coverage',
 {'Type': 'FuelHeldForSale'},
 'id']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Would be more efficient if it wasn't a 1 liner, but I'll let you figure it out from here. Probably wanna come up with a more robust regex based parsing engine if your input varies more than your given schema. Or just use a standardized data model like JSON.</p>
<pre><code>[word if '=' not in word else {word.split('=')[0]:word.split('=')[1]} for word in re.split('[/\[]', st.replace(']','').replace('"',''))]
</code></pre>
<blockquote>
<p>['data', 'policy', 'line', {'Type': 'BusinessOwners'}, 'risk',
  'coverage', {'Type': 'FuelHeldForSale'}, 'id']</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Let's do it in one line :</p>
<pre><code>import re

pattern=r'(?&lt;=Type=)\"(\w+)'
data="""data/policy/line[Type="BusinessOwners"]/risk/coverage[Type="FuelHeldForSale"]/id"""


print([{'Type':re.search(pattern,i).group().replace('"','')} if '=' in i else i for i in re.split('\/|\[',data)])
</code></pre>
<p>output:</p>
<pre><code>['data', 'policy', 'line', {'Type': 'BusinessOwners'}, 'risk', 'coverage', {'Type': 'FuelHeldForSale'}, 'id']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/howto/regex.html" rel="nofollow noreferrer">Regular expressions</a> may be a good tool here. It looks like you want to transform elements that look like <code>text1[text2="text3"]</code> with `text1, {text2: text3}. The regex would look something like this:</p>
<pre><code>(\w+)\[(\w+)=\"(\w+)\"\]
</code></pre>
<p>You can modify this expression in any number of ways. For example, you could use something other than <code>\w+</code> for the names, and insert <code>\s*</code> to allow optional whitespace wherever you want.</p>
<p>The next thing to keep in mind is that when you do find a match, you need to expand your list. The easiest way to do that would be to just create a new list and <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">append/extend</a> it:</p>
<pre><code>import re

paths = []
pattern = re.compile(r'(\w+)\[(\w+)=\"(\w+)\"\]')
for item in st.split('/'):
    match = pattern.fullmatch(item)
    if match:
        paths.append(match.group(1))
        paths.append({match.group(2): match.group(3)})
    else:
        paths.append(item)
</code></pre>
<p>This makes a <code>paths</code> that is</p>
<pre><code>['data', 'policy', 'line', {'Type': 'BusinessOwners'}, 'risk', 'coverage', {'Type': 'FuelHeldForSale'}, 'id']
</code></pre>
<p><a href="https://ideone.com/CaIEkl" rel="nofollow noreferrer">[IDEOne Link]</a></p>
<p>I personally like to split the functionality of my code into pipelines of functions. In this case, I would have the main loop accumulate the <code>paths</code> list based on a function that returned replacements for the split elements:</p>
<pre><code>def get_replacement(item):
    match = pattern.fullmatch(item)
    if match:
        return match.group(1), {match.group(2): match.group(3)}
    return item,

paths = []
for item in st.split('/'):
    paths.extend(get_replacement(item))
</code></pre>
<p>The comma in <code>return item,</code> is very important. It makes the return value into a tuple, so you can use <code>extend</code> on whatever the function returns.</p>
<p><a href="https://ideone.com/cs7s9P" rel="nofollow noreferrer">[IDEOne Link]</a></p>
</div>
<span class="comment-copy">Hi. Did you try using eval()? Can you try this out: st_new=eval(st) Then print st_new. I hope this works.!</span>
<span class="comment-copy">Hi! That did not work @ShrinivasDeshmukh data/policy/line[Type="BusinessOwners"]/risk/coverage[Type="FuelHeldForSale"]/id                          ^ SyntaxError: invalid syntax</span>
<span class="comment-copy">Please refer to this link, a similar problem has been discussed here: <a href="https://stackoverflow.com/questions/36068779/how-to-convert-a-string-containing-a-list-of-dict-into-python-object" title="how to convert a string containing a list of dict into python object">stackoverflow.com/questions/36068779/â€¦</a></span>
<span class="comment-copy">@mdeonte001 --- You should be a lot more specific as to what you want if you want people to use their time to solve your problem. If you want a dictionary in your list then state it instead of leaving others to read your mind!</span>
<span class="comment-copy">@MichaelSwartz please see above, i state 'list containing dictionaries..' and in my example i show a dictionary.</span>
<span class="comment-copy">Hi, I ran this and I got the error AttributeError: 'str' object has no attribute 'literal_eval' - what is ast.literal_eval(item) should that be st.literal?</span>
<span class="comment-copy">sorry. you need to import ast first. please check again.</span>
<span class="comment-copy">Not a huge fan of using literal_eval, but this is much better.</span>
<span class="comment-copy">This works! Thank you. @MadPhysicist care share why you dislike literal_eval?</span>
<span class="comment-copy">It certainly does work. I am wary of literal_eval because of things like <a href="https://gist.github.com/Aran-Fey/2667cef9420e930e57d80187a76e35e4" rel="nofollow noreferrer">this gist</a>. I am not 100% sure if it can be done exactly with literal_eval, but I would rather not take a chance.</span>
<span class="comment-copy">For your edification: <a href="https://ideone.com/aa9DLo" rel="nofollow noreferrer">ideone.com/aa9DLo</a></span>
