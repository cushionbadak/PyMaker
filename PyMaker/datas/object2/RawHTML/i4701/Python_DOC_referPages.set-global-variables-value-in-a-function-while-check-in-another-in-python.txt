<div class="post-text" itemprop="text">
<p>My test script <code>test.py</code> is below:</p>
<pre><code>import time
from multiprocessing import Pool

n = []
print('global', id(n))


def slowf():
    global n
    time.sleep(5)
    n.append(1)
    print('slowf---', n, id(n))


def checkn():
    global n
    while 1:
        if n:
            print('checkn', n, id(n), "T")
            break
        else:
            print('checkn', n, id(n), "F")
        time.sleep(1)


def main():
    global n
    p = Pool()
    p.apply_async(slowf, args=())
    p.apply_async(checkn, args=())
    p.close()
    p.join()


if __name__ == '__main__':
    main()
</code></pre>
<p>And output of the script with running in <code>python3.6</code> is:</p>
<pre><code>global 4534751304
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
slowf--- [1] 4534751304
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
checkn [] 4534751304 F
......
</code></pre>
<p>So, why <code>slowf()</code> function has changed the global variable <code>n</code> after 5 seconds, but it still read a <code>[]</code> in <code>checkn()</code> function. They just both got into the global var <code>n</code> with the same <code>id</code>. I just confused! </p>
<p>I appreciate it if someone could explain this to me!
Thanks forwardÔºÅ</p>
</div>
<div class="post-text" itemprop="text">
<p>Separate processes do not share memory. Changes you make in one child won't be visible in another.</p>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">The docs</a> explain this, and also why you often don't <em>want</em> shared state (you need to add synchronization, which is tricky to get right), and also what you can do instead.</p>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#shared-ctypes-objects" rel="nofollow noreferrer">You <em>can</em> use explicit shared memory, but only with basic "C types" like 32-bit integers or arrays of floats</a>. And then you have to use explicit synchronization like <code>Lock</code> in the right places to make your code safe.</p>
<p>The ideal solution, when possible, is to redesign your code to <a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow noreferrer">pass data over queues instead of sharing it</a>.</p>
<p>If that's not appropriate for your problem, you can use a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-managers" rel="nofollow noreferrer"><code>Manager</code></a>, which basically fakes shared high-level Python objects on top of a queue. This can be excruciatingly slow for some uses, but when it isn't, it can be the simplest answer.</p>
</div>
<span class="comment-copy">Ok, I has read <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">The docs</a>, and learned a lot from it. Finally, I choose to use a <code>Manager().Queue()</code>. It just works fine. Thank so much for your answer!</span>
