<div class="post-text" itemprop="text">
<p>My application uses a third party API that throws an exception belonging to another api-handling module. The code looks something like this:</p>
<pre><code>#API Module
def getdatafromapi(req):
    # Trying to get data ...
    if response_err in data:
        raise APIModuleException('API error')
    if conn_err in data:
        raise APIConnectionError('API error')

    # Do some processing
    return response
# My Module
def get_data_and_crunch(req):
    response = getdatafromapi(req)
    if not response:
        raise ValueError('Something happened')
    # Proceed to number crunch


# Main script
def main():
    # Sanitize api request...
    try:
        get_data_and_crunch(req)
    except ValueError:
       print('Something happened')
</code></pre>
<p>The main module behaves the same way no matter if <code>APIModuleException</code> or <code>APIConnectionError</code> occurs, but I would still like to log which exception class actually caused the exception.</p>
<p>Is there a way I could avoid having <code>APIModuleException</code> and <code>APIConnectionError</code> classes in my main script and still propagate the exceptions up just using <code>ValueError</code> to tell which exception class actually caused the exception in the API Module?</p>
</div>
<div class="post-text" itemprop="text">
<p>Make sure that your module's exception is not the exact same type as the API's. It can be a base type, as <code>ValueError</code> seems to be in your case. Your raising code is fine in this regard.</p>
<p>Add multiple <code>except</code> blocks to catch the different types of exception:</p>
<pre><code>try:
    get_data_and_crunch()
except (APIModuleException, APIConnectionError) as e:
    print('API error caught:', str(e))
except ValueError as e:
    print('My module!:', str(e))
</code></pre>
<p>You can  have as many <code>except</code> blocks as you like, and each one can catch as many types of exceptions as you like.</p>
<p>It is very important to put the <code>ValueError</code> catch after the one for the API exceptions if they inherit from <code>ValueError</code>. The blocks are evaluated in order, using <code>instanceof</code>, so if the <code>ValueError</code> block came first, all the exceptions would trigger it, and you would never see the API-specific messages.</p>
<p>If you need to know arbitrarily specific information about the exception, use the exception objects available through the <code>as ...</code> syntax shown above. The function <a href="https://docs.python.org/3/library/sys.html#sys.exc_info" rel="nofollow noreferrer"><code>sys.exc_info</code></a> will also help you get information like the calling sequence that led to the error. You can  use the <a href="https://docs.python.org/3/library/traceback.html" rel="nofollow noreferrer"><code>traceback</code></a> module to get even more details.</p>
<p><strong>UPDATE</strong></p>
<p>Based on your latest comment you want to get the exception information without additional imports. <strong>Disclaimer</strong>: This is technically possible, and I will explain a way of doing it below, but I <strong>highly</strong> recommend against this approach.</p>
<p>The trick is to catch the base class of all the possible exceptions that you will be getting, as you attempted to do with <code>ValueError</code>. The problem is that <a href="https://docs.python.org/3/library/exceptions.html#ValueError" rel="nofollow noreferrer"><code>ValueError</code></a>, despite being one of the most widely-used exception types, is <em>not</em> the base of all your exceptions, <a href="https://docs.python.org/3/library/exceptions.html#Exception" rel="nofollow noreferrer"><code>Exception</code></a> is. You could go overboard and catch <a href="https://docs.python.org/3/library/exceptions.html#BaseException" rel="nofollow noreferrer"><code>BaseException</code></a>, but then things like pressing <kbd>Ctrl+C</kbd> would stop working, so don't do it (just mentioning it for <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" rel="nofollow noreferrer">completeness</a>).</p>
<p>You can get the type (and therefore the name of the type) using the same notation I showed you above. Tracebacks will work as usual as well, to show you calling sequences and where the exception occurred:</p>
<pre><code>try:
    get_data_and_crunch()
except Exception as e:
    print('Got a', type(e).__name__)
</code></pre>
<p>As per <a href="https://stackoverflow.com/questions/49364859/exception-propagation-in-python/49365190?noredirect=1#comment85770157_49365190">@abarnert's comment</a>, there are a few common ways of getting basic exception info before you delve into <code>sys.exc_info</code> and <code>traceback</code>. <code>type(e)</code> will get you the class of the thrown error. <code>str(e)</code> returns just the message of the error in 99% of sane exception classes. <code>repr(e)</code> will generally return the standard <code>type: message</code> string you see at the end of a printout.</p>
<p>As a disclaimer to my disclaimer, I have to add that while techniques like this are not <em>recommended</em>, they can be used quite effectively if you know what you are doing. So read the docs I linked carefully and make sure you understand your code thoroughly. This is much more important than heeding any sort of generic unqualified warnings.</p>
</div>
<div class="post-text" itemprop="text">
<p>not sure i understand correctly. but this would be the standard way to differentiate exceptions:</p>
<pre><code>class APIModuleException(Exception): pass
class APIConnectionError(Exception): pass

def get_data_and_crunch(req):
    # raise ValueError
    raise APIConnectionError
    # raise APIModuleException

def main():
    # Sanitize api request...
    try:
        req = None
        get_data_and_crunch(req)
    except APIModuleException as exc:
        # ...handle
        print('APIModuleException')
    except APIConnectionError as exc:
        # ...handle
        print('APIConnectionError')
    except ValueError as exc:
       # ...handle
       print('ValueError')

main()
</code></pre>
</div>
<span class="comment-copy">what does <code>APIModuleException</code> inherit from? <code>ValueError</code>? why not <code>except APIModuleException</code> in your main?</span>
<span class="comment-copy"><code>APIModuleException</code> inherits from Base <code>Exception</code> class in this case. But I am looking for a general solution for propagating information across exceptions</span>
<span class="comment-copy">I realized I had written the question in a way that seemed misleading. I've made an edit just now</span>
<span class="comment-copy">@Ajit. It's still unclear what exact information you are looking for.</span>
<span class="comment-copy">Spceifically, the following two statements seem to be at odds: "I can't tell which exception class actually raises the exception" and "...better informed about the actual source of the exception". Do you want to know the source of the exception class, the line that raised it, or something else? Please clarify your terminology. What do you mean by "which exception class raises the exception"? What do you mean by "actual source"?</span>
<span class="comment-copy">If you are going to do the "bad version", probably better to just log the <code>repr</code> of the exception, which will (for all reasonable exceptions) include the type plus the message.</span>
<span class="comment-copy">@MadPhysicist. Could you give more details on why you would recommend against the second approach? I am trying to hide the implementation details of the API module behind <code>get_data_and_crunch</code>. To me, main module being only dependent on intermediate module makes more intuitive sense</span>
<span class="comment-copy">@Ajit. That's why I have two disclaimers. In general it's bad practice to do something like this when you have a specific exception that a function can throw because you can end up consuming unintentionally. However, in your case, where the exceptions are really unknown, you are at the top level, and you clearly understand what you are doing, it's probably fine.</span>
<span class="comment-copy">@abarnert. I added a note for that</span>
<span class="comment-copy">Really, ensuring that the full exception info (with type or whatever gets printed by repr) gets to your (human-readable, or at least ops-or-dev-readable) logs/pager message/whatever, even if your program doesn’t care about that information, isn’t an uncommon or too-dangerous request, and this answer covers it nicely. I think it only seems scary because as written before Ajit improved the question, it sounded like maybe he wanted to do something programmatic with those human-readable strings about the type info after throwing away the more useful type info itself.</span>
<span class="comment-copy">Why did you add <code>req = None</code>?</span>
<span class="comment-copy">@MadPhysicist i just wanted to keep the example self-contained and not change the interface given in the question... i agree: it's a bit pointless...</span>
