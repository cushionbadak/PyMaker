<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9057669/how-can-i-intercept-calls-to-pythons-magic-methods-in-new-style-classes">How can I intercept calls to python's “magic” methods in new style classes?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/42146413/why-does-pythons-bool-builtin-only-look-at-the-class-level-bool-method">Why does Python's bool builtin only look at the class-level __bool__ method [duplicate]</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I am trying to create a custom object that passes all non-existent method calls down to a member attribute. This works under normal custom method invocations, but fails when attempting to call arithmetic operators.</p>
<p>Below is a console snippet of an example class, a test function, and a cleaned up disassembly of the test function.</p>
<pre><code>&gt;&gt;&gt; class NoAdd(object):
...    member = 0
...    def __getattr__(self, item):
...        print('NoAdd __getattr__')
...        # return getattr(self.member, item)
...        if item == '__add__':
...            return self.member.__add__
&gt;&gt;&gt; def test():
...    print('Call __add__ directly.')
...    NoAdd().__add__(5)  # 5
...    print('Implicit __add__.')
...    NoAdd() + 5  # TypeError
&gt;&gt;&gt; dis(test)
  3           8 LOAD_GLOBAL              1 (NoAdd)
             10 CALL_FUNCTION            0
             12 LOAD_ATTR                2 (__add__)
             14 LOAD_CONST               2 (5)
             16 CALL_FUNCTION            1
             18 POP_TOP
  5          28 LOAD_GLOBAL              1 (NoAdd)
             30 CALL_FUNCTION            0
             32 LOAD_CONST               2 (5)
             34 BINARY_ADD
             36 POP_TOP
             38 LOAD_CONST               0 (None)
             40 RETURN_VALUE
&gt;&gt;&gt; test()
Call __add__ directly.
NoAdd __getattr__
Implicit __add__.
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 5, in test
TypeError: unsupported operand type(s) for +: 'NoAdd' and 'int'
</code></pre>
<p>I thought that the Python interpreter would look for the <code>__add__</code> method using the standard procedure of invoking <code>__getattr__</code> when the method was not found in the object's method list, before looking for <code>__radd__</code> in the int. This is apparently not what is happening.</p>
<p>Can someone help me out by explaining what is going on or helping me find out where in the Python source code I can find what <code>BINARY_ADD</code> is doing? I'm not sure if I can fix this, but a workaround would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>The methods <code>__getattr__</code> and <code>__getattribute__</code> are only used for recovering attributes when you call then explicitly, by example when you do <code>foo.bar</code>. They are not used for implicit invocation.</p>
<p>This behaviour is specified in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer">documentation</a></p>
<blockquote>
<p><strong>Note:</strong> This method may still be bypassed when looking up special methods
  as the result of implicit invocation via language syntax or built-in
  functions.</p>
</blockquote>
<p>The reason for such an implementation is explained <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">here</a>.</p>
<blockquote>
<p>Bypassing the <code>__getattribute__()</code> machinery in this fashion provides
  significant scope for speed optimisations within the interpreter, at
  the cost of some flexibility in the handling of special methods</p>
</blockquote>
<p>In conclusion what you are trying to do, <em>i.e.</em> using <code>__getattr__</code> to redirect implicit special method calls, has been voluntarily sacrificed in favor of speed.</p>
<h2>Inheritance</h2>
<p>The behaviour you are describing can be achieved by class inheritance. Although, passing in arguments to your class constructor will require the following fidling with the <code>__new__</code> method.</p>
<pre><code>class NoAdd(int):

    def __new__(cls, x, *args, **kwargs):
        return super().__new__(cls, x)

    def __init__(self, x, *args, **kwargs):
        ...

x = NoAdd(0)

x + 5 # 5
x * 2 # 0
</code></pre>
<h2>Metaclass</h2>
<p>Now, suppose you really need to catch implicit call to special methods. I see very little case where this could be useful, but it is a fun exercise. In this case we can rely on metaclass to fill in missing methods with the ones from <code>member</code>.</p>
<pre><code>class ProxyToMember(type):

    def __init__(cls, name, bases, name_space):
        super().__init__(name, bases, name_space)

        if hasattr(cls, 'member'):
            proxy_attrs = (attr for attr in dir(cls.member) if not hasattr(cls, attr))

            def make_proxy(attr):

                attr_value = getattr(cls.member, attr)

                def proxy(_, *args, **kwargs):
                    return attr_value(*args, **kwargs)

                if callable(attr_value):
                    return proxy
                else:
                    return property(lambda _: getattr(cls.member, attr))

            for attr in proxy_attrs:
                setattr(cls, attr, make_proxy(attr))

class A(metaclass=ProxyToMember):
    member = 0

class B(metaclass=ProxyToMember):
    member = 'foo'

A() + 1 # 1
B().startswith('f') # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After some more intense research (and following some initially unlikely trails) I found my answer. My thought process didn't come up with the same search keywords, which is why I didn't find these before. My question could probably be considered a duplicate of one of the ones linked below.</p>
<p>I found the simplest/best explanation for why this happens <a href="https://stackoverflow.com/questions/13511386/python-built-in-functions-vs-magic-functions-and-overriding?noredirect=1&amp;lq=1">here</a>. I found some good references for resolving this <a href="https://stackoverflow.com/questions/9057669/how-can-i-intercept-calls-to-pythons-magic-methods-in-new-style-classes">here</a> and <a href="https://stackoverflow.com/questions/8637254/intercept-operator-lookup-on-metaclass">here</a>. The links in <a href="https://stackoverflow.com/a/49356663">Oliver's</a> answer are also helpful.</p>
<p>In summary, Python does not use the standard method lookup process for the magic methods such as <code>__add__</code> and <code>__str__</code>. It looks like the workaround is to make a <code>Wrapper</code> class from <a href="https://stackoverflow.com/questions/9057669/how-can-i-intercept-calls-to-pythons-magic-methods-in-new-style-classes">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't understand you.</p>
<p>Why you can't do something like:</p>
<pre><code>class MyInt(int):
    pass

def test():
    print(MyInt(5) + 5)

test()
</code></pre>
</div>
<span class="comment-copy">If you really need a transparent object proxy where only override certain methods, with the rest forwarded on to the wrapped object, use the <code>wrapt</code> package. <a href="http://wrapt.readthedocs.io/en/latest/wrappers.html" rel="nofollow noreferrer">wrapt.readthedocs.io/en/latest/wrappers.html</a></span>
<span class="comment-copy">Dunder methods like __add__ are only looked up in the class, never the instance through an operator. You need to define __getattr__ on the proxy's metaclass if you want this to work.</span>
<span class="comment-copy">This is an even better dupe, but I wanted to make the longest possible chain: <a href="https://stackoverflow.com/q/38133096/2988730">stackoverflow.com/q/38133096/2988730</a></span>
<span class="comment-copy">Your explanation is <i>almost</i> correct</span>
<span class="comment-copy">The specific optimization here is that when you do <code>a + b</code>, it always calls <code>type(a).__add__(a, b)</code> instead of <code>a.__getattribute__('__add__')(b)</code>. The first one technically should call <code>type(type(a)).__getattribute__(type(a), '__add__')</code>, so you can make the proxy work by messing with the metaclass.</span>
<span class="comment-copy">@MadPhysicist I'll go read about this sublety. When you say almost correct, do you mean that something is wrong or that I missed that detail?</span>
<span class="comment-copy">The explanation you provide shows that the bypass is documented, but does not really explain why it happens, so it is not of much value. I am sure that at least one of the answers to the dupes I voted with has a link to the docs that explain the specific case I refer to above.</span>
<span class="comment-copy">That actually works out of the box. <code>int.__add__</code> will raise a <code>NotImplementedError</code> since it does not recognize the type and addition will be deferred to your custom type. I'll find you the doc momentarily. If you think about how adding a numpy array to a scalar works, you will see that this is quite intuitive...</span>
<span class="comment-copy">You can just vote to close your own question. As it stands, your "answer" is link-only at best. It has no content of its own.</span>
<span class="comment-copy">As you should be able to see, I have already done that, and marked my question as a duplicate. My answer is to provide closure to this question.</span>
<span class="comment-copy">It looks like you flagged your own answer instead of clicking on the "anwers my question" link that appears in the yellow box.</span>
<span class="comment-copy">This is a comment, not an answer.</span>
<span class="comment-copy">The reason I cannot do this is because the class must be able to support any type, not just ints.</span>
<span class="comment-copy">@Yos233 do you mean your need member to be dynamic?</span>
<span class="comment-copy">@OlivierMelançon, he want write Wrapper for any type in Python with inheritance all attributes.</span>
<span class="comment-copy">I added an example of that in my answer above, it was fun</span>
