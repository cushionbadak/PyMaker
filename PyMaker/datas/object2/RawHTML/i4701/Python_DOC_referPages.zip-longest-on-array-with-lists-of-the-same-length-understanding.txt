<div class="post-text" itemprop="text">
<p>I have an Array which contains a few lists all the same length. All those lists need to be written in a .csv-file. Using a piece of code i have found it works pretty well. Here the code:</p>
<pre><code>ag=[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]

export_data = zip_longest(*ag, fillvalue = '') 

with open('motion_profile.csv', 'w', encoding="ISO-8859-1", newline='') as myfile:
    wr = csv.writer(myfile, delimiter=',')
    wr.writerow(("m","ax","ay","az","sx","sy","sz"))
    wr.writerows(export_data)  
myfile.close()
</code></pre>
<p>I understand the basic concept of <code>zip</code> and <code>zip_longest</code> when i have two arrays which i use it on. But i just can't wrap my head around what it does with a single array like here <code>export_data = zip_longest(*ag, fillvalue = '')</code></p>
<p>What exactly happens to <code>ag</code> if i use <code>zip</code> or <code>zip_longest</code> on it? </p>
<p>Since i don't have two arrays what does it zip against? </p>
<p><code>zip_longest</code> is being applied to each list in <code>ag</code> hence the <code>*</code>. That is how far I have gotten with it. </p>
<p>Could anyone walk me through that?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>zip()</code> does not necessarily take two arrays; it takes an arbitrary number of arrays (iterables) <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">as positional arguments</a>.</p>
<p>Taking this in smaller steps,</p>
<ul>
<li><code>*ag</code> unpacks the nested list.  Note that it only unpacks "one level down."  You're effectively left with 4 lists, <code>[1, 2, 3]</code>, ... <code>[10, 11, 12]</code>, as disparate elements that will become positional arguments.</li>
<li>From there, <code>zip()</code> behaves as expected (you're passing it multiple unpacked lists).</li>
</ul>
<p>You can see the equivalency:</p>
<pre><code>&gt;&gt;&gt; i, j, k = zip(*ag)

&gt;&gt;&gt; i
(1, 4, 7, 10)
&gt;&gt;&gt; k
(3, 6, 9, 12)

&gt;&gt;&gt; i2, j2, k2 = zip([1,2,3],[4,5,6],[7,8,9],[10,11,12])
                #     |_______|_______|________|
                #                 i2

&gt;&gt;&gt; i2
(1, 4, 7, 10)
&gt;&gt;&gt; k2
(3, 6, 9, 12)
</code></pre>
<p>In other words, those four sub-lists are passed as four positional arguments to <code>zip()</code>.</p>
<p>In terms of the call syntax, <code>itertools.zip_longest(*iterables, fillvalue=None)</code> is pretty similar; it just has one keyword argument tacked on to the end.  The way in which the sub-lists are passed is effectively the same.</p>
</div>
