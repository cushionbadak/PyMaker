<div class="post-text" itemprop="text">
<p>How does one properly and cleanly terminate a python program if needed? <code>sys.exit()</code> does not reliably perform this function as it merely terminates the thread it is called from, <code>exit()</code> and <code>quit()</code> are not supposed to be used except in terminal windows, <code>raise SystemExit</code> has the same issues as <code>sys.exit()</code> and is bad practice, and <code>os._exit()</code> immediately kills everything and does not clean up, which can cause issues with residuals.</p>
<p>Is there a way to ALWAYS kill the program and all threads, regardless of where it is called from, while still cleaning up?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a way to ALWAYS kill the program and all threads, regardless of where it is called from, while still cleaning up?</p>
</blockquote>
<p>No - "regardless where it is called from" and "cleaning up" do not mix.</p>
<hr/>
<p>It is simply not <em>meaningful</em> to both reliably and safely kill a thread. Killing a thread (or process) means interrupting what it is doing - that includes clean up. Not interrupting any clean up means, well, not actually killing a thread. You cannot have both at the same time.</p>
<p>If you want to <strong>kill</strong> all threads, then <code>os._exit()</code> is precisely what you are asking for. If you want to clean up a thread, no generic feature can fulfil that.</p>
<p>The only reliable way to shut down threads is to implement your own, safe interrupt. To some extent, this must be customised to your use case - after all, you are the only one knowing when it is safe to shut down.</p>
<h2>Killing a thread with Exceptions</h2>
<p>The underlying CPython API allows you to raise an exception in another thread. See for example <a href="https://stackoverflow.com/a/325528/5349916">this answer</a>.</p>
<p>This is not portable and <em>not safe</em>. You could be killing that thread at any arbitrary point. If your code expects an exception or your resources clean up after themselves (via <code>__del__</code>), you can limit harm, but not exclude it. Still, it is very close to what most people think of as a "clean kill".</p>
<h2>Self-Cleaning daemon threads with <code>atexit</code></h2>
<p>Threads running with <a href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">Thread.daemon</a> are abruptly terminated if no other threads remain. Usually, this is half of what you want: <em>gracefully</em> terminate if all proper threads exit.</p>
<p>Now, the key is that a <code>daemon</code> thread does not prevent shutdown. This also means it does not prevent <code>atexit</code> from running! Thus, a daemon can use <code>atexit</code> to automatically shutdown itself and cleanup on termination.</p>
<pre><code>import threading
import atexit
import time


class CleanThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.daemon = True
        # use a signal to inform running code about shutdown
        self.shutdown = threading.Event()

    def atexit_abort(self):
        # signal to the thread to shutdown with the interpreter
        self.shutdown.set()
        # Thread.join in atexit causes interpreter shutdown
        # to be delayed until cleanup is done
        self.join()  # or just release resources and exit

    def run(self):
        atexit.register(self.atexit_abort)
        while not self.shutdown.wait(0.1):
            print('who wants to live forever?')
        print('not me!')
        atexit.unregister(self.atexit_abort)


thread = CleanThread()
thread.start()
time.sleep(0.3)
# program exits here
</code></pre>
<p>Note that this still requires your code to listen for a cleanup signal! Depending on what the Thread does, there are other mechanisms to achieve this. For example, the <code>concurrent.future</code> module empties the task queue of all worker threads on shutdown.</p>
</div>
<div class="post-text" itemprop="text">
<p>While your app is running Bad Things can happen, which we'd like to recover from. One example is Power Fail.</p>
<p>There is no computing technique for arranging for instructions to execute on a device that is powered off. So we may need to reset some state upon restart. Your app already has this requirement; I'm just making it explicit.</p>
<p>It is hard to reliably gain control just after each of the various Bad Things that might happen, as you found when you carefully considered several standard techniques. You weren't specific about the sort of items needing cleanup that you envision, but we could consider these cases:</p>
<ol>
<li>transient - TCP connections, flock, etc.</li>
<li>permanent - disk files, side effects on distant hosts</li>
</ol>
<p>Rather than invoking your app directly, arrange for it to be run by a Nanny process which forks the app as a child. At some point the app will exit, the Nanny will regain control with all transient items having been tidied up by the OS, and then the Nanny can do any necessary cleanup on permanent items prior to an app restart. This is identical to the cleanup the Nanny will need to do on initial startup, for example after power fail events. The advantage of running your app under a parent process is that the parent can perform immediate cleanups after simple app failures such as SEGV.</p>
<p>Cleaning up permanent items likely involves timeouts on timestamped resources. If your system is able to reboot within say 2 seconds of a brief power outage, you may find it necessary to deliberately stay Down (sleep) for long enough to ensure that distant hosts have reliably detected your transition to Down, prior to announcing a transition to Up. Techniques like Virtual Synchrony and Paxos can help you drive toward rapid convergence.</p>
<h2>summary</h2>
<p>Sometimes an app will unexpectedly die before running cleanup code. Take a belt-and-suspenders approach: put essential cleanup code in the (simpler, more reliable) parent process.</p>
</div>
<span class="comment-copy">There's <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer">atexit</a> which you can use to define clean up actions.</span>
<span class="comment-copy">See also <a href="https://stackoverflow.com/q/19747371/3767239">Python exit commands - why so many and when should each be used?</a>.</span>
<span class="comment-copy">how about using "Context Management Protocol" in your class where you can define <code>__enter__</code> and <code>__exit__</code> and run your code using <code>with context</code></span>
<span class="comment-copy">@a_guest Does not address the issue with <code>sys.ext()</code> and threading. The whole reason I had to ask this is because this behavior makes it too unreliable, especially as many interpreters will break some calls into threads invisibly leading to it being called in a non-main thread even when you are not intentionally using threading.</span>
<span class="comment-copy">@Elliot I know and that is why I didn't mark your question as a duplicate. I just wanted to point other readers to that resource.</span>
