<div class="post-text" itemprop="text">
<p>I have a conventional multithreaded producer/consumer pattern with a <a href="https://docs.python.org/3/library/queue.html#queue.Queue" rel="nofollow noreferrer">queue.Queue</a> in between. This implementation of queues is thread safe. The consumer can consume the data in two ways:</p>
<p>Blocking</p>
<pre><code>while self.running:
    data = self.receiver_q.get(block=True)
    # do something with data
</code></pre>
<p>Non-blocking</p>
<pre><code>while self.running:
    try:
        data = self.receiver_q.get(block=False)
    except queue.Empty:
        continue
    # do something with data
</code></pre>
<p>In the blocking method, the consumer waits until there is data in the queue. During this time, is the consumer holding the lock on the queue? I can't imagine a way for it to hold the lock while allowing the queue to have new data placed on it.</p>
<p>Also, is there a performance difference between the two patterns?</p>
</div>
<div class="post-text" itemprop="text">
<p>(1) No, the consumer is not holding a lock; it's merely blocked until the request is satisfied, but the queue is still available.  If there are multiple consumers, then this one is in the pool of potential recipients; the resolution function will choose the order of satisfaction.</p>
<p>(2) Any performance difference depends on the implementation.  Don't ask us -- you have the foremost authority in front of you: your computer.  Use a test scenario of your choice, and the <code>timeit</code> facility.</p>
</div>
