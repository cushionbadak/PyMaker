<div class="post-text" itemprop="text">
<p>I have a collection of python scripts, that I would like to be able to execute with a button press, from a web browser.</p>
<p>Currently, I run <code>python -m http.server 8000</code> to start a server on port 8000. It serves up html pages well, but that's about all it does. Is it possible to have it execute a python script (via ajax) and return the output, instead of just returning the full text of the .py file.</p>
<p>Additionally, if not, is there a simple (as in only 1 or 2 files) way to make this work? I'm looking for the equivalent of PHP -s, but for python.</p>
<p>For completeness, this is my html</p>
<pre><code>&lt;h1&gt;Hello World&lt;/h1&gt;

&lt;button&gt;
Click me!
&lt;/button&gt;

&lt;script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.js"&gt;    &lt;/script&gt;

&lt;script&gt;
  $('button').click(function(){
    $.get('/gui/run_bash.py');
  });
&lt;/script&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add <code>--cgi</code> to your command line.</p>
<pre><code>python -m http.server --cgi 8000
</code></pre>
<p>Then place your python scripts in ./cgi-bin and mark them as executable.</p>
<pre><code>$ mkdir cgi-bin
$ cp hello.py cgi-bin/hello.py
$ chmod +x cgi-bin/hello.py
</code></pre>
<p>You may need to slightly modify your python scripts to support the CGI protocol.</p>
<p>Here is the server running:</p>
<pre class="lang-none prettyprint-override"><code>$ cat cgi-bin/hello.py 
#! /usr/bin/env python3

print("Content-Type: application/json")
print()

print('{"hello": "world"}')
radams@wombat:/tmp/z/h$ python -m http.server --cgi
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
127.0.0.1 - - [20/Mar/2018 18:04:16] "GET /cgi-bin/hello.py HTTP/1.1" 200 -
</code></pre>
<p>Reference: <a href="https://docs.python.org/3/library/http.server.html#http.server.CGIHTTPRequestHandler" rel="nofollow noreferrer">https://docs.python.org/3/library/http.server.html#http.server.CGIHTTPRequestHandler</a></p>
</div>
<div class="post-text" itemprop="text">
<p><code>http.server</code> merely serves static files, it does not do any serverside processing or execute any code when you hit a python file. If you want to run some python code, you'll have to write an application to do that. Flask is a Python web framework that is probably well-suited to this task.</p>
<p>Your flask application might look something like this for executing scripts...</p>
<pre><code>import subprocess
from flask import Flask
app = Flask(__name__)

SCRIPTS_ROOT = '/path/to/script_dir' 
@app.route('/run/&lt;script_name&gt;')
def run_script(script_name):
    fp = os.path.join(SCRIPTS_ROOT, script_name)
    try:
        output = subprocess.check_output(['python', fp])
    except subprocess.CalledProcessError as call:
        output = call.output # if exit code was non-zero
    return output.encode('utf-8') # or your system encoding

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8000)
</code></pre>
<p>And of course, I should include an obligatory warning 'having a webserver execute commands like this is insecure', etc, etc. Check out the <a href="http://flask.pocoo.org/docs/0.12/quickstart/" rel="nofollow noreferrer">Flask quickstart</a> for more details.</p>
</div>
<span class="comment-copy"><code>http.server</code> is just that -- a way to serve static files. It does not do any server-side processing. You probably want to look at a framework like Flask, which would allow you to make such an application with minimal effort.</span>
