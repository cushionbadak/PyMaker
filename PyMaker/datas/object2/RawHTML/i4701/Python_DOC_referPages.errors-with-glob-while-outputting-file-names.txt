<div class="post-text" itemprop="text">
<p>I am combining two questions here because they are related to each other. </p>
<p>Question 1: I am trying to use glob to open all the files in a folder but it is giving me "Syntax Error". I am using Python 3.xx. Has the syntax changed for Python 3.xx?</p>
<p>Error Message:</p>
<pre><code>File "multiple_files.py", line 29
files = glob.glob(/src/xyz/rte/folder/)

SyntaxError: invalid syntax
</code></pre>
<p>Code:</p>
<pre><code>import csv
import os
import glob
from pandas import DataFrame, read_csv

    #extracting
files = glob.glob(/src/xyz/rte/folder/)
for fle in files:
    with open (fle) as f:
        print("output" + fle)                   
f_read.close()
</code></pre>
<p>Question 2: I want to read input files, append "output" to the names and print out the names of the files. How can I do that?</p>
<p>Example: Input file name would be - xyz.csv and the code should print output_xyz.csv .</p>
<p>Your help is appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your first problem is that strings, including pathnames, need to be in quotes. This:</p>
<pre><code>files = glob.glob(/src/xyz/rte/folder/)
</code></pre>
<p>… is trying to divide a bunch of variables together, but the leftmost and rightmost divisions are missing operands, so you've confused the parser. What you want is this:</p>
<pre><code>files = glob.glob('/src/xyz/rte/folder/')
</code></pre>
<hr/>
<p>Your next problem is that this glob pattern doesn't have any globs in it, so the only thing it's going to match is the directory itself.</p>
<p>That's perfectly legal, but kind of useless.</p>
<p>And then you try to open each match as a text file. Which you can't do with a directory, hence the <code>IsADirectoryError</code>.</p>
<p>The answer here is less obvious, because it's not clear what you want.</p>
<ul>
<li><p>Maybe you just wanted all of the files in that directory? In that case, you don't want <code>glob.glob</code>, you want <code>listdir</code> (or maybe <code>scandir</code>): <code>os.listdir('/src/xyz/rte/folder/')</code>.</p></li>
<li><p>Maybe you wanted all of the files in that directory or any of its subdirectories? In that case, you could do it with <code>rglob</code>, but <code>os.walk</code> is probably clearer.</p></li>
<li><p>Maybe you did want all the files in that directory that match some pattern, so <code>glob.glob</code> is right—but in that case, you need to specify what that pattern is. For example, if you wanted all <code>.csv</code> files, that would be <code>glob.glob('/src/xyz/rte/folder/*.csv')</code>.</p></li>
</ul>
<hr/>
<p>Finally, you say "I want to read input files, append "output" to the names and print out the names of the files". Why do you want to read the files if you're not doing anything with the contents? You can do that, of course, but it seems pretty wasteful. If you just want to print out the filenames with output appended, that's easy:</p>
<pre><code>for filename in os.listdir('/src/xyz/rte/folder/'):
    print('output'+filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works in <a href="http://pyfiddle.io" rel="nofollow noreferrer">http://pyfiddle.io</a>:</p>
<p>Doku: <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">https://docs.python.org/3/library/glob.html</a></p>
<pre><code>import csv
import os
import glob 

# create some files
for n in ["a","b","c","d"]:
    with open('{}.txt'.format(n),"w") as f:
        f.write(n) 

print("\nFiles before")

# get all files
files = glob.glob("./*.*")

for fle in files:
    print(fle)      # print file
    path,fileName = os.path.split(fle)  # split name from path

    # open file for read and second one for write with modified name
    with open (fle) as f,open('{}{}output_{}'.format(path,os.sep, fileName),"w") as w:
        content = f.read()            # read all
        w.write(content.upper())      # write all modified

# check files afterwards
print("\nFiles after")
files = glob.glob("./*.*")  # pattern for all files
for fle in files:
    print(fle)                              
</code></pre>
<p>Output:</p>
<pre><code>Files before
./d.txt
./main.py
./c.txt
./b.txt
./a.txt

Files after
./d.txt
./output_c.txt
./output_d.txt
./main.py
./output_main.py
./c.txt
./b.txt
./output_b.txt
./a.txt
./output_a.txt
</code></pre>
<p>I am on windows and would use <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk</code> (Doku)</a> instead. </p>
<pre><code>for d,subdirs,files in os.walk("./"): # deconstruct returned aktDir, all subdirs, files
    print("AktDir:", d)
    print("Subdirs:", subdirs)
    print("Files:", files)

Output:

AktDir: ./
Subdirs: []
Files: ['d.txt', 'output_c.txt', 'output_d.txt', 'main.py', 'output_main.py', 
        'c.txt', 'b.txt', 'output_b.txt', 'a.txt', 'output_a.txt'] 
</code></pre>
<p>It also recurses into subdirs.</p>
</div>
<span class="comment-copy">The filepath needs to be a string - <code>files = glob.glob("/src/xyz/rte/folder/")</code></span>
<span class="comment-copy">Thanks! Now I am getting a different error - IsADirectoryError: [Errno 21] Is a directory: "/src/xyz/rte/folder/)". Please comment!</span>
<span class="comment-copy">Definitely, I am doing lot more to the files. I just wrote "print" because I wanted to simplify my questions. I want to create file with filenames "output_&lt;input_filename&gt;". I will process these files later. Your answer works but could you tell me how to append the file names and create files with "output" in the front?</span>
<span class="comment-copy">@NewUser The part at the end shows how to do that. And you were already doing it in your own code. Although if you want an underscore there, you have to include it in the string: <code>'output_' + filename</code>.</span>
<span class="comment-copy">The top part seems to be working in linux, as well.</span>
<span class="comment-copy">@NewUser  thats why I tried it on <a href="http://pyfiddle.io" rel="nofollow noreferrer">pyfiddle.io</a> - its a web based python fiddle that runs on some linux-derivate  server ;o)</span>
