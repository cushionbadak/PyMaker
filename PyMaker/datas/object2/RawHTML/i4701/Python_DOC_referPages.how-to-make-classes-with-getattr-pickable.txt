<div class="post-text" itemprop="text">
<p>How can I modify the classes below to make them pickeable? </p>
<p>This question: <a href="https://stackoverflow.com/questions/42272335/how-to-make-a-class-which-has-getattr-properly-pickable">How to make a class which has __getattr__ properly pickable?</a> is similar but refer to wrong exception in the use of <strong>getattr</strong>.</p>
<p>This other question seems to provide meaningful insight <a href="https://stackoverflow.com/questions/12101574/why-does-pickle-dumps-call-getattr">Why does pickle.dumps call __getattr__?</a>, however it fails to provide an example, and I honestly cannot understand what I am suppose to implement. </p>
<pre><code>import pickle
class Foo(object):
    def __init__(self, dct):
        for key in dct:
            setattr(self, key, dct[key])


class Bar(object):
    def __init__(self, dct):
        for key in dct:
            setattr(self, key, dct[key])

    def __getattr__(self, attr):
        """If attr is not in channel, look in timing_data
        """
        return getattr(self.foo, attr)

if __name__=='__main__':
    dct={'a':1,'b':2,'c':3}
    foo=Foo(dct)
    dct2={'d':1,'e':2,'f':3,'foo':foo}
    bar=Bar(dct2)
    pickle.dump(bar,open('test.pkl','w'))
    bar=pickle.load(open('test.pkl','r'))
</code></pre>
<p>Results:</p>
<pre><code>     14         """If attr is not in channel, look in timing_data
     15         """
---&gt; 16         return getattr(self.foo, attr)
     17
     18 if __name__=='__main__':

RuntimeError: maximum recursion depth exceeded while calling a Python object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that your <code>__getattr__</code> method is poorly implemented. It assumes that <code>self.foo</code> exists. If <code>self.foo</code> doesn't exist, trying to access it ends up calling <code>__getattr__</code> - which results in infinite recursion:</p>
<pre><code>&gt;&gt;&gt; bar = Bar({})  # no `foo` attribute
&gt;&gt;&gt; bar.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "untitled.py", line 19, in __getattr__
    return getattr(self.foo, attr)
  File "untitled.py", line 19, in __getattr__
    return getattr(self.foo, attr)
  File "untitled.py", line 19, in __getattr__
    return getattr(self.foo, attr)
  [Previous line repeated 329 more times]
RecursionError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<p>To fix this, you have to throw an AttributeError if no <code>foo</code> attribute exists:</p>
<pre><code>def __getattr__(self, attr):
    """If attr is not in channel, look in timing_data
    """
    if 'foo' not in vars(self):
        raise AttributeError
    return getattr(self.foo, attr)
</code></pre>
<p>(I used the <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars</code></a> function to get the object's dict, because it looks nicer than <code>self.__dict__</code>.)</p>
<hr/>
<p>Now everything works as expected:</p>
<pre><code>dct={'a':1,'b':2,'c':3}
foo=Foo(dct)
dct2={'d':1,'e':2,'f':3,'foo':foo}
bar=Bar(dct2)
data = pickle.dumps(bar)
bar = pickle.loads(data)
print(vars(bar))
# output:
# {'d': 1, 'e': 2, 'f': 3, 'foo': &lt;__main__.Foo object at 0x7f040fc7e7f0&gt;}
</code></pre>
</div>
<span class="comment-copy">Adding a little more explanation to the first paragraph: <code>__getattr__</code> is only called if an attribute cannot be found in "the usual ways", such as checking the object's <code>__dict__</code>. That's why <code>self.foo</code> in <code>__getattr__</code> is not giving you infinite recursion <i>all the time</i>, but only when <code>self.foo</code> cannot be found in the <code>__dict__</code>.</span>
