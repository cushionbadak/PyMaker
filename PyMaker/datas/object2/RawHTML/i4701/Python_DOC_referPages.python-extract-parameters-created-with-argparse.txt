<div class="post-text" itemprop="text">
<p>I have a file called simple_example.py, which consists of 2 functions:</p>
<pre><code># import the necessary packages
import argparse


class simple:

    @staticmethod
    def func1():

        # construct the argument parse and parse the arguments
        ap = argparse.ArgumentParser()
        ap.add_argument("-n", "--name", help="name of the user", default='host')
        ap.add_argument('-num', '--number', required=True, help='choose a number')
        args = vars(ap.parse_args())

        # display a friendly message to the user
        print("Hi there {}, it's nice to meet you! you chose {}".format(args['name'], args['age']))


    @staticmethod
    def func2():

        # construct the argument parse and parse the arguments
        ap = argparse.ArgumentParser()
        ap.add_argument("-n", "--name", help="name of the user", default='host')
        ap.add_argument('-num', '--number', required=True, help='choose a number')
        ap.add_argument("-g", "--greet", help="say greetings", default='hello')
        args = vars(ap.parse_args())

        # display a friendly message to the user
        print("{} there {}, it's nice to meet you! you chose {}".format(args['greet'], args['name'], args['age']))
</code></pre>
<p>I'd like to be able to call either func1() or func2() from the command line, so, I created another file called pyrun.py from this <a href="https://stackoverflow.com/questions/29130994/python-run-function-from-the-command-line/29130994#29130994">link</a></p>
<pre><code># !/usr/bin/env python
# make executable in bash chmod +x PyRun

import sys
import inspect
import importlib
import os


if __name__ == "__main__":
    cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile(inspect.currentframe()))[0]))
    if cmd_folder not in sys.path:
        sys.path.insert(0, cmd_folder)

    # get the second argument from the command line
    methodname = sys.argv[1]

    # split this into module, class and function name
    modulename, classname, funcname = methodname.split(".")

    # get pointers to the objects based on the string names
    themodule = importlib.import_module(modulename)
    theclass = getattr(themodule, classname)
    thefunc = getattr(theclass, funcname)

    # pass all the parameters from the third until the end of what the function needs &amp; ignore the rest
    args = inspect.getargspec(thefunc)

    print(args)
</code></pre>
<p>However, args in ArgSpec(args=[], varargs=None, keywords=None, defaults=None) shows an empty list. </p>
<ol>
<li><p>How can I extract the parameters from either func1 or func2?</p></li>
<li><p>Is there a better way to run either func1 or func2 from the command line?</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to use <a href="https://docs.python.org/3/library/argparse.html#sub-commands" rel="nofollow noreferrer">sub-commands</a>. Here is an implementation of your example using sub-commands.</p>
<pre><code>import argparse

def func1(args):

    print("Hi there {}, it is nice to meet you! You chose {}.".format(args.name, args.number))

def func2(args):

    print("{} there {}, it is nice to meet you! You chose {}.".format(args.greet, args.name, args.number))

#
# The top-level parser
#
parser = argparse.ArgumentParser('top.py', description='An example sub-command implementation')

#
# General sub-command parser object
#
subparsers = parser.add_subparsers(help='sub-command help')

#
# Specific sub-command parsers
#
cmd1_parser = subparsers.add_parser('cmd1', help='The first sub-command')
cmd2_parser = subparsers.add_parser('cmd2', help='The second sub-command')

#
# Assign the execution functions
#
cmd1_parser.set_defaults(func=func1)
cmd2_parser.set_defaults(func=func2)

#
# Add the common options
#
for cmd_parser in [cmd1_parser, cmd2_parser]:
    cmd_parser.add_argument('-n',   '--name',   default='host', help='Name of the user')
    cmd_parser.add_argument('-num', '--number', required=True,  help='Number to report')

#
# Add command-specific options
#
cmd2_parser.add_argument('-g', '--greet', default='hello', help='Greeting to use')

#
# Parse the arguments
#
args = parser.parse_args()

#
# Invoke the function
#
args.func(args)
</code></pre>
<p>Example output:</p>
<pre><code>$ python ./top.py cmd1 -n Mark -num 3    
Hi there Mark, it is nice to meet you! You chose 3.

$ python ./top.py cmd2 -n Bob -num 7 -g Hello
Hello there Bob, it is nice to meet you! You chose 7.
</code></pre>
<p>And, of course, the help functions work for each of the sub-commands.</p>
<pre><code>$ python ./top.py cmd2 -h

usage: top.py cmd2 [-h] [-n NAME] -num NUMBER [-g GREET]

optional arguments:
  -h, --help            show this help message and exit
  -n NAME, --name NAME  Name of the user
  -num NUMBER, --number NUMBER
                        Number to report
  -g GREET, --greet GREET
                        Greeting to use
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I put your first block of code in a file, I can import it into a <code>ipython</code> session and run your 2 functions:</p>
<pre><code>In [2]: import stack49311085 as app
In [3]: app.simple
Out[3]: stack49311085.simple
</code></pre>
<p><code>ipython</code> tab expansion (which uses some form of <code>inspect</code>) shows me that the module has a <code>simple</code> class, and the class itself has two static functions.</p>
<p>I can call <code>func1</code>, and get an <code>argparse</code> error message:</p>
<pre><code>In [4]: app.simple.func1()
usage: ipython3 [-h] [-n NAME] -num NUMBER
ipython3: error: the following arguments are required: -num/--number
An exception has occurred, use %tb to see the full traceback.

SystemExit: 2
</code></pre>
<p>Similarly for <code>func2</code>:</p>
<pre><code>In [7]: app.simple.func2()
usage: ipython3 [-h] [-n NAME] -num NUMBER [-g GREET]
ipython3: error: the following arguments are required: -num/--number
An exception has occurred, use %tb to see the full traceback.

SystemExit: 2
</code></pre>
<p><code>parse_args</code> as a default parses the <code>sys.argv[1:]</code> list, which obviouslly is not tailored to its requirements.</p>
<pre><code>def foo(argv=None):
    parser = ....
    ....
    args = parse.parse_args(argv=argv)
    return args
</code></pre>
<p>is a more useful wrapper.  With this I can pass a test <code>argv</code> list, and get back the parsed <code>Namespace</code>.  If I don't give it such a list, it will used the <code>sys.argv</code> default.  When testing a parser I like to return and/or display the whole <code>Namespace</code>.</p>
<p>I haven't used <code>inspect</code> enough to try to figure out what you are trying to do with it, or how to correct it.  You don't need <code>inspect</code> to run code in an imported module like this.</p>
<hr/>
<p>I can test your imported parser by modifying the <code>sys.argv</code></p>
<pre><code>In [8]: import sys
In [9]: sys.argv
Out[9]: 
['/usr/local/bin/ipython3',
 '--pylab',
 '--nosep',
 '--term-title',
 '--InteractiveShellApp.pylab_import_all=False']
In [10]: sys.argv[1:] = ['-h']
In [11]: app.simple.func2()
usage: ipython3 [-h] [-n NAME] -num NUMBER [-g GREET]

optional arguments:
  -h, --help            show this help message and exit
  -n NAME, --name NAME  name of the user
  -num NUMBER, --number NUMBER
                        choose a number
  -g GREET, --greet GREET
                        say greetings
An exception has occurred, use %tb to see the full traceback.

SystemExit: 0
</code></pre>
<p>Or following the <code>help</code>:</p>
<pre><code>In [12]: sys.argv[1:] = ['-num=42', '-nPaul', '-gHI']
In [13]: app.simple.func2()
...
---&gt; 30         print("{} there {}, it's nice to meet you! you chose {}".format(args['greet'], args['name'], args['age']))
KeyError: 'age'
</code></pre>
<p>Oops, there's an error in your code.  You ask for <code>args['age']</code>, but didn't define a parser argument with that name.  That's part of why I like to print the <code>args</code> Namespace` - to make sure it is setting all the attributes that I expect.</p>
<hr/>
<p>Normally we don't use different parsers for different inputs.  It's possible to do that based on your own test of <code>sys.avgv[1]</code>, but keep in mind that that string will still be on <code>sys.argv[1:]</code> list that your parser(s) read.  Instead write one parser that can handle the various styles of input.  The <code>subparser</code> mentioned in the other answer is one option.  Another is to base your action on the value of the <code>args.greet</code> attribute.  If not used it will be the default value.</p>
</div>
<span class="comment-copy">You do not need use <code>argparse</code> in func1 and func2, just write <code>def func2(name, number, greet)</code> like your given link.</span>
<span class="comment-copy">You can also try the <a href="https://github.com/google/python-fire" rel="nofollow noreferrer">python-fire</a>.</span>
<span class="comment-copy">What kind of <code>parameters</code> are you seeking?  Neither of your functions takes an argument.</span>
<span class="comment-copy">Thanks for the edit, I was wondering about that when I saw your edit.</span>
