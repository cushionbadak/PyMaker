<div class="post-text" itemprop="text">
<p>I have a function that accepts an arbitrary file handle and either loads all the data or allows the data to be loaded lazily <em>if</em> the object supports random access.</p>
<pre>
class DataLoader:
    def __init__(self, file):
        self.file = file
        self.headers = {}
    def load_data(self):
        # header is a hashable (e.g. namedtuple with name, size, offset)
        header = self.load_next_header()
        <b>if self.file.random_access:</b>
            # Return and load the data only as necessary if you can
            self.headers[header.name] = (header, None)
            self.file.seek(header.size + self.file.tell())
        else:
            # Load the data up front if you can't
            self.headers[header.name] = (header, self.file.read(header.size))

</pre>
<p>How can I check if a file object supports random access?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/io.html#io.IOBase.seekable" rel="nofollow noreferrer"><code>seekable</code></a> method to check if the file supports random access.</p>
<blockquote>
<p><strong>seekable()</strong></p>
<p>Return <code>True</code> if the stream supports random access. If <code>False</code>, <code>seek()</code>, <code>tell()</code> and <code>truncate()</code> will raise <code>OSError</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>An alternative approach in line with the Python convention of <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> is to just assume the file object supports random access and handle the exception that occurs when it doesn't:</p>
<pre><code>class DataLoader:
    def __init__(self, file):
        self.file = file
        self.headers = {}
    def load_data(self):
        # header is a hashable (e.g. namedtuple with name, size, offset)
        header = self.load_next_header()
        try:
            # Return and load the data only as necessary if you can
            self.headers[header.name] = (header, None)
            self.file.seek(header.size + self.file.tell())
        except OSError:
            # Load the data up front if you can't
            self.headers[header.name] = (header, self.file.read(header.size))
</code></pre>
</div>
<span class="comment-copy">another strategy might be to try to access randomly. if it throws an exception, you know it doesn't support it. See, for reference, <a href="https://docs.quantifiedcode.com/python-anti-patterns/readability/asking_for_permission_instead_of_forgiveness_when_working_with_files.html" rel="nofollow noreferrer">docs.quantifiedcode.com/python-anti-patterns/readability/â€¦</a></span>
<span class="comment-copy">@avigil. If you turn that into an answer, I will certainly upvote it. I disagree with the accepted answer being an anti-pattern because there are a number of other reasons that an <code>OSError</code> may be raised.</span>
<span class="comment-copy">Thanks. Under normal circumstances I would accept this as the answer. However, for the real application I have in mind, I need to select a different loading method up front based on the seekability.</span>
