<div class="post-text" itemprop="text">
<p>I am having a lot of confusion using the <code>sys.getsizeof</code> function in python. All I want to find out is that for say a floating point value, is the system using 4 or 8 bytes (i.e. single or double precision in C terms).</p>
<p>I do the following:</p>
<pre><code>import sys

x = 0.0
sys.getsizeof(x)  # Returns 24

type(x) # returns float

sys.getsizeof(float)  # Returns 400.
</code></pre>
<p>How can I simply find out the how many bytes are actually used for the floating point representation. I know it should be 8 bytes but how can I verify this (something like the <code>sizeof</code> operator in C++)</p>
</div>
<div class="post-text" itemprop="text">
<p>Running</p>
<pre><code>sys.getsizeof(float)
</code></pre>
<p>does not return the size of any individual float, it returns the size of the <code>float</code> <em>class</em>. That class contains a lot more data than just any single float, so the returned size will also be much bigger.</p>
<p>If you just want to know the size of a single float, the easiest way is to simply instantiate some arbitrary float. For example:</p>
<pre><code>sys.getsizeof(float())
</code></pre>
<p>Note that</p>
<pre><code>float()
</code></pre>
<p>simply returns <code>0.0</code>, so this is actually equivalent to:</p>
<pre><code>sys.getsizeof(0.0)
</code></pre>
<p>This returns <code>24</code> bytes in your case (and probably for most other people as well). In the case of CPython (the most common Python implementation), every <code>float</code> object will contain a reference counter and a pointer to the type (a pointer to the <code>float</code> class), which will each be 8 bytes for 64bit CPython or 4 bytes each for 32bit CPython. The remaining bytes (<code>24 - 8 - 8 = 8</code> in your case which is very likely to be 64bit CPython) will be the bytes used for the actual float value itself. </p>
<p>This is not guaranteed to work out the same way for other Python implementations though. The <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">language reference</a> says:</p>
<blockquote>
<p>These represent machine-level double precision floating point numbers. You are at the mercy of the underlying machine architecture (and C or Java implementation) for the accepted range and handling of overflow. Python does not support single-precision floating point numbers; the savings in processor and memory usage that are usually the reason for using these are dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating point numbers.</p>
</blockquote>
<p>and I'm not aware of any runtime methods to accurately tell you the number of bytes used. However, note that the quote above from the language reference does say that Python only supports double precision floats, so in most cases (depending on how critical it is for you to always be 100% right) it should be comparable to double precision in C.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>getsizeof() calls the object’s <strong>sizeof</strong> method and adds an additional garbage collector overhead if the object is managed by the garbage collector.</p>
</blockquote>
<p><code>sys.getsizeof</code> is not about the byte size as in C.</p>
<p>For <code>int</code> there is <a href="https://docs.python.org/3/library/stdtypes.html#int.bit_length" rel="nofollow noreferrer"><code>bit_length()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import ctypes
ctypes.sizeof(ctypes.c_double)
</code></pre>
</div>
<span class="comment-copy">Just curious: Why are you interested in this?</span>
<span class="comment-copy">What do you expect <code>sys.getsizeof(float)</code> to <code>return</code>? Why are you checking the size of the actual class?</span>
<span class="comment-copy">@Chris_Rands Yes, that is what I want to find out. How can I check the size of the underlying representation?</span>
<span class="comment-copy">@LutzHorn Converting some code from C and want to see if the differences are down to precision issues. Also, just want to know how to do that.</span>
<span class="comment-copy">@Luca from the docs: <code>Almost all machines today (November 2000) use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754 “double precision”.</code> &lt;-- double precision it is.</span>
<span class="comment-copy">If you look in my question, I tried this and it returns 24...which again seems wrong. I was expecting 8 bytes or 64 bits</span>
<span class="comment-copy">@Luca I've edited in some more info</span>
<span class="comment-copy">Yes, i see that now but what is the python way to find out the size of a floating point value?</span>
