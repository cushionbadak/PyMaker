<div class="post-text" itemprop="text">
<p>How to avoid multiple nested for-loops when one nested for-loop has range up to the current iteration of the outer for-loop? For example, consider the following code:
This program returns a triplet from a list arr such that <code>arr[i] - arr[j] = arr[j] - arr[k] = d</code> and <code>i&lt;j&lt;k</code>.</p>
<pre><code>d =3
arr = [1, 2, 4, 5, 7, 8, 10]
list1 = []

for biggest in range(0, len(arr)):
    for bigger in range(0, biggest):
        for big in range(0, bigger):
            if abs(arr[big] - arr[bigger]) == d and abs(arr[bigger] - arr[biggest]) == d:
                list1.append([arr[big], arr[bigger], arr[biggest]])
print(list1))
</code></pre>
<p>Are there any other alternatives to using multiple nested loops?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can replace the three loops with:</p>
<pre><code>from itertools import combinations

for big, bigger, biggest in combinations(range(0, len(arr)), 3):
</code></pre>
<p>You can replace all the code with:</p>
<pre><code>print([t for t in combinations(arr, 3)
       if t[2] - t[1] == t[1] - t[0] == d])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">the combinations function from itertools</a>. Your code would then become:</p>
<pre><code>from itertools import combinations

d = 3
arr = [1, 2, 4, 5, 7, 8, 10]
list1 = []
for big, bigger, biggest in combinations(arr, 3):
    if abs(big - bigger) == d and abs(bigger - biggest) == d:
        list1.append([big, bigger, biggest])

print(list1)
</code></pre>
<p>Which gives the same printout as your code (after you remove the extraneous right parenthesis on your last line):</p>
<pre><code>[[1, 4, 7], [2, 5, 8], [4, 7, 10]]
</code></pre>
<p>Note that I changed the meanings of your variables <code>big</code>, <code>bigger</code>, <code>biggest</code> to be the array values rather than their indices. Working with values and avoiding indices is more pythonic and easier to understand.</p>
<p>You could also just do it in a list comprehension, for a slightly different look, avoiding the temporary list, and probable speed increase.</p>
<pre><code>from itertools import combinations

d = 3
arr = [1, 2, 4, 5, 7, 8, 10]
print([[big, bigger, biggest]
        for big, bigger, biggest in combinations(arr, 3)
        if abs(big - bigger) == d and abs(bigger - biggest) == d
    ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While previous answers are pythonic,
if you care about the implementation of the search algorithm, you can reduce the complexity of your algorithm from <code>O(N^3)</code> to <code>O(N^2logN)</code> by implementing a binary search algorithm to find <code>k</code> in the space between <code>j+1</code> and the length of <code>lst</code> which satisfies <code>d - abs(lst[j] - lst[k]) == 0</code>.</p>
<pre><code>d = 3
lst = [1, 2, 4, 5, 7, 8, 10]


def bsearch(lst, left, right, j):
    while left &lt; right:
        k = (left + right) // 2

        diff = d - abs(lst[j] - lst[k])

        if diff == 0:
            return k
        if diff &gt; 0:
            left = k + 1
        else:
            right = k

    return None


l, result = len(lst), []
for i in range(l):
    for j in range(i + 1, l):
        diff = d - abs(lst[i] - lst[j])

        if diff != 0: continue
        k = bsearch(lst, j + 1, l, j)

        if not k: continue
        result.append((lst[i], lst[j], lst[k]))

print(result)

[(1, 4, 7), (2, 5, 8), (4, 7, 10)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Found a better way I guess! avoiding the nested loops.</p>
<pre><code>arr = [1,2,3,4,5,6,7,8,9]
d = 3
list1 = arr
list2 = []
for each in (0,len(list1)):
    if list1[each] + d in arr and list1[each] + 2*d in arr:
         list2.append([list1[each], list1[each]+d, list1[each]+2*d])
print(list2)
</code></pre>
</div>
<span class="comment-copy">If your code works (which seems to the be the case), then it's OT here and you want to repost this on codereview. Else please explain exactly what's the problem.</span>
<span class="comment-copy">I believe that this question is on-topic here and off-topic for Code Review, since he is looking for one particular improvement in the code and not a general overlook of all aspects.</span>
<span class="comment-copy">Thank you! But Is it faster than the code in the question?</span>
<span class="comment-copy">@AkshayMurali: I replaced the print lines with return statements to improve my speed tests, and both of my routines are faster than yours, with my first routine slightly faster than my second. The times were 21.2 µs for your code, 8.6 µs for my first, and 8.75 µs for my second. So the list comprehension is not faster than the loop and is indeed slightly slower.</span>
