<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/49404488/balanced-binary-tree-python">Balanced binary tree python</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<pre><code># stack_depth is initialised to 0
def find_in_tree(node, find_condition, stack_depth):
    assert (stack_depth &lt; max_stack_depth), 'Deeper than max depth'
    stack_depth += 1
    result = []
    if find_condition(node):
        result += [node]
    for child_node in node.children:
        result.extend(find_in_tree(child_node, find_condition, stack_depth))
    return result
</code></pre>
<p>I need help understanding this piece of code. The question i want to answer is </p>
<p><strong>The Python function above searches the contents of a balanced binary tree.
 If an upper limit of 1,000,000 nodes is assumed what should the max_stack_depth constant be set to?</strong></p>
<p>From what I understand, this is a trick question. If you think about it, stack_depth is incremented every time the find_in_tree() function is called in the recursion. And we are trying to find a particular node in the tree. And in our case we are accessing every single node every time even if we find the correct node. Because there is no return condition when stops the algorithm when the correct node is found. Hence, max_stack_depth should 1,000,000? </p>
<p>Can someone please try to explain me their thought process.</p>
</div>
<div class="post-text" itemprop="text">
<p>The key thing to notice is that <code>stack_depth</code> is passed down to each recursive call of the function. If it's a balanced binary tree then each call to <code>find_in_tree</code> will pass the same <code>stack_depth</code> value to up to two children. Just keep in mind that the reference to <code>stack_depth</code> is not shared between subsequent calls to <code>find_in_tree</code>. They will have their own version of <code>stack_depth</code> initialized to the value of the parent call.</p>
<p>This should be enough information to figure out what the value should be before the assert fires.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>If you look at when stack_depth increments then it looks like we will increment every time we access a node. And in our case we are accessing every single node every time. Because there is no return condition when stops the algorithm when the correct node is found.</p>
</blockquote>
<p>This is incorrect.  While <em>a</em> <code>stack_depth</code> variable is incremented for every node examined, it's not the <em>same</em> <code>stack_depth</code> variable.  <code>stack_depth</code> is a local within the function.  When <code>find_in_tree</code> recurses and the recursive call increments <code>stack_depth</code> this <em>does not change</em> the value of <code>stack_depth</code> in the caller.</p>
<p><code>stack_depth</code> is measuring the level of recursion that takes place as this function runs to completion.  The maximum value it takes on will be the maximum depth of the tree you're inspecting.</p>
<p>That said, if all you know is that you have a million nodes, you still need to step <code>max_stack_depth</code> to a million to guarantee the assertion doesn't fail because you don't know what <em>shape</em> the tree has.  It could be that every node has exactly one child.  In this case, you would need to recurse about a million times (maybe 999,999 times depending on how you count) to visit every node.</p>
<p>Of course, Python will stop you long before you get there.</p>
<p>Fortunately, you also know the tree is balanced.  This means many nodes have two children.  This tells you the maximum depth you will find should be close to the log base 2 of the number of nodes.</p>
</div>
<span class="comment-copy">Only about 20. Hint: Try to prove that the value of <code>stack_depth</code> is equal to the distance between <code>node</code> and the root.</span>
<span class="comment-copy">I understand how u get 19. You pretty much go 1+2+4+8+16......... until you reach 1,000,000. But are we not calling find_in_tree() for EVERY SINGLE NODE in the tree and incrementing stack_depth?</span>
<span class="comment-copy">You can see the answers below which explains your mistake (local variable)</span>
<span class="comment-copy">Uh... don't shout (write in capital case) please.</span>
<span class="comment-copy">Sorry I wasnt shouting, I just placed it there to highlight it.</span>
<span class="comment-copy">Thank you very much. I understand that.</span>
<span class="comment-copy">Now another question, If the assumptions (upper limit of 1,000,000 nodes) regarding the trees are wrong, what is at risk of occurring? Will the program just crash because the program will try access out of bound memory?</span>
<span class="comment-copy">You will likely get a <a href="https://docs.python.org/3/library/exceptions.html#RecursionError" rel="nofollow noreferrer">RecursionError</a>, which is thrown when you reach the maximum recursion depth. You can try this yourself with a simple program like: <code>def recur(): recur(); recur()</code></span>
<span class="comment-copy">If you really need it to run for more than the recursion limit you can also try <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow noreferrer">raising the recursion limit</a>. However if you really need it to run at a higher recursion limit (which for a balanced binary search tree would be an enormous tree), you are probably better off switching to a different solution.</span>
<span class="comment-copy">Thanks so much for your help.</span>
<span class="comment-copy">"balanced". (4 more to go)</span>
<span class="comment-copy">yea thanks, adjusted.</span>
<span class="comment-copy">Thanks for the clear answer :)</span>
<span class="comment-copy">Now another question, If the assumptions (upper limit of 1,000,000 nodes) regarding the trees are wrong, what is at risk of occurring? Will the program just crash because the program will try access out of bound memory?</span>
<span class="comment-copy">Why did you post this exact question twice?</span>
