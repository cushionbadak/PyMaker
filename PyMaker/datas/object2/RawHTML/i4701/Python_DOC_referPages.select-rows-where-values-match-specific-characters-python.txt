<div class="post-text" itemprop="text">
<p>I have a series that looks like this:</p>
<pre><code>s = pd.Series(['abdhd','abadh','aba', 'djjb','kjsdhf','abwer', 'djd, 'kja'])
</code></pre>
<p>I need to select all rows whose strings begin with 'dh' or 'kj'</p>
<p>I attempted to use .startswith() and .match(); but i get boolean returns of True and False instead of the values of the list.</p>
<p>I tried this as part of a dictionary as well and got the same bool returns and not the valued themselves.</p>
<p>Is there something else I can do?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try </p>
<pre><code>s[(s.str.startswith('dh')) | (s.str.startswith('kj'))]
</code></pre>
<p>Explanation: <code>(s.str.startswith('dh')) | (s.str.startswith('kj'))</code> is the logical condition you care about, and then putting that inside of <code>s[]</code> slices the series by rows, returning only the rows where the condition is <code>True</code></p>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.contains.html" rel="nofollow noreferrer"><code>pd.Series.str.contains</code></a></h3>
<pre><code>s[s.str.contains('^dh|kj')]

4    kjsdhf
7       kja
dtype: object
</code></pre>
<hr/>
<h3><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html" rel="nofollow noreferrer"><code>pd.Series.isin</code></a></h3>
<pre><code>s[s.str[:2].isin(['dh', 'kj'])]

4    kjsdhf
7       kja
dtype: object
</code></pre>
<hr/>
<h3><a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer"><code>str.startswith</code></a> within a comprehension</h3>
<pre><code>s[[any(map(x.startswith, ['dh', 'kj'])) for x in s]]

4    kjsdhf
7       kja
dtype: object
</code></pre>
<hr/>
<h3>Time Tests</h3>

Functions

<pre><code>pir1 = lambda s: s[s.str.contains('^dh|kj')]
pir2 = lambda s: s[s.str[:2].isin(['dh', 'kj'])]
pir3 = lambda s: s[[any(map(x.startswith, ['dh', 'kj'])) for x in s]]
alol = lambda s: s[(s.str.startswith('dh')) | (s.str.startswith('kj'))]
</code></pre>

Testing

<pre><code>res = pd.DataFrame(
    np.nan, [10, 30, 100, 300, 1000, 3000, 10000, 30000],
    'pir1 pir2 pir3 alol'.split()
)

for i in res.index:
    s_ = pd.concat([s] * i)
    for j in res.columns:
        stmt = f'{j}(s_)'
        setp = f'from __main__ import {j}, s_'
        res.at[i, j] = timeit(stmt, setp, number=200)
</code></pre>

Results

<pre><code>res.plot(loglog=True)
</code></pre>
<p><a href="https://i.stack.imgur.com/130XV.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/130XV.png"/></a></p>
<pre><code>res.div(res.min(1), 0)

           pir1      pir2      pir3      alol
10     2.424637  3.272403  1.000000  4.747473
30     2.756702  2.812140  1.000000  4.446757
100    2.673724  2.190306  1.000000  3.128486
300    1.787894  1.000000  1.342434  1.997433
1000   2.164429  1.000000  1.788028  2.244033
3000   2.325746  1.000000  1.922993  2.227902
10000  2.424354  1.000000  2.042643  2.242508
30000  2.153505  1.000000  1.847457  1.935085
</code></pre>

Conclusions

<p>The only real winner (and only just barely) is <code>isin</code> and it also happens to be the least general.  You can only really extend its use so long as you are looking at just the first 2 characters.</p>
<p>Other than that, the other methods all seem to perform with similar time complexity.</p>
</div>
<span class="comment-copy">Just slice the series by that Boolean list.</span>
<span class="comment-copy">thanks much! it worked!</span>
<span class="comment-copy">@M-M feel free to upvote this answer as well if you found it useful.</span>
<span class="comment-copy">@ALolls I posted time tests if you are interested.  Sometimes I get bored.  Nice answer btw. +1</span>
