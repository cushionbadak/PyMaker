<div class="post-text" itemprop="text">
<p>I have a list of tuples <code>seg = [(874, 893), (964, 985), (1012, 1031)]</code> and an index. I want to check if the index is inside the range of those tuples, for example, <code>876</code> is while <code>870</code> is not. </p>
<p>My code to do so is the following: </p>
<pre><code>if [x for (x, y) in seg if x &lt;= index &lt;= y]:
   print ("index inside the segment")
</code></pre>
<p>However, I also want to return if the index is in the first second ... segment of the list seg. </p>
<p>For example, for the <code>index = 876</code> to return <code>1</code> and for the <code>index = 1015</code> to return <code>3</code>. </p>
<p>How can I do so?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> + <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> with generator expression:</p>
<pre><code>&gt;&gt;&gt; seg = [(874, 893), (964, 985), (1012, 1031)]
&gt;&gt;&gt; index = 876
&gt;&gt;&gt; next((i for i, (s,f) in enumerate(seg) if s &lt;= index &lt;= f), None)
0
</code></pre>
<hr/>
<p>Or, if you want to iterate over:</p>
<pre><code>&gt;&gt;&gt; for i in (i for i, (s,f) in enumerate(seg) if s &lt;= index &lt;= f):
...     print("in segment:", i)
... 
in segment: 0
</code></pre>
<hr/>
<p><em>thanks <code>@jpp</code> for the hint about <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">the default option of the <code>next</code> function.</a> (It can be used in cases where the given index is not in any of the ranges represented by the tuples)</em></p>
</div>
<div class="post-text" itemprop="text">
<p>As others have pointed out, you can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code></a> to get the indexes. I'd also argue that if you are treating the tuples as ranges, you should make them <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow noreferrer">ranges</a>. This then makes the check to see if the value is inside the range very intuitive: <code>value in range</code>.</p>
<pre><code>import itertools

seg = [(874, 893), (964, 985), (1012, 1031)]
ranges = list(itertools.starmap(range, seg))

def test(value):
  for i, valueRange in enumerate(ranges):
    if value in valueRange:
      return i # + 1 if you want to index from 1 as indicated.
  # You could add some special case handling here if there is no match, like:
  # throw NoSuchRangeException("The given value was not inside any of the ranges.")

print(test(876)) # 0
print(test(1015)) # 1
</code></pre>
<p>Obviously using ranges has some cost (if you are in Python 2.x, this is comparatively huge because it will make actual lists of all the values, and unfortunately <code>xrange()</code> return objects without <code>__contains__()</code> implemented). If you are doing this kind of thing in lots of places, it's much nicer, however.</p>
<p>You may be able to just replace your tuple construction with range construction, depending on the situation, rather than doing the starmap.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming the following:</p>
<p>List is ordered</p>
<p>First number is less than second number</p>
<p>no overlapping</p>
<pre><code>index=870
seg = [(874, 893), (964, 985), (1012, 1031)]
for i, t in enumerate(seg):
    if index &gt;= t[0] and index &lt;= t[1]:
        print i
</code></pre>
</div>
<span class="comment-copy">Are you looking for something like <code>print([i+1 for (i, (x, y)) in enumerate(seg) if x &lt;= index &lt;= y])</code>?</span>
<span class="comment-copy">Dang it, beaten again! Nice answer :-) + 1</span>
<span class="comment-copy">@ChristianDean Thanks :)</span>
<span class="comment-copy">fast fingers here</span>
<span class="comment-copy">@jpp Updated :)</span>
<span class="comment-copy">@theausome Good spot from the OP's question, but I think I will leave that out for the sake of future visitors. I am sure that, if they would like the tuples to be <code>1</code>-based, then they can do the increment themselves :)</span>
<span class="comment-copy">Yes, I was also thinking about making the tuples ranges. I didn't know how efficiency would be affected though.</span>
<span class="comment-copy">@ChristianDean It depends on how often you are doing it, and how you use the values. In most cases the cost should be negligible - ranges are just very small structures around the two values (in Python 3.x).</span>
