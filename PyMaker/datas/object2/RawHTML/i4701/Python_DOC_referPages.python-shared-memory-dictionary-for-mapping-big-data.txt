<div class="post-text" itemprop="text">
<p>I've been having a hard time using a large dictionary (~86GB, 1.75 billion keys) to process a big dataset (2TB) using multiprocessing in Python.</p>
<p>Context: a dictionary mapping strings to strings is loaded from pickled files into memory. Once loaded, worker processes (ideally &gt;32) are created that must lookup values in the dictionary but <strong>not</strong> modify it's contents, in order to process the ~2TB dataset. The data set needs to be processed in parallel otherwise the task would take over a month.</p>
<p>Here are the <s>two</s> <s>three</s> <s>four</s> <s>five</s> <s>six</s> <s>seven</s> <s>eight</s> <strong>nine</strong> approaches (all failing) that I have tried:</p>
<ol>
<li><p>Store the dictionary as a global variable in the Python program and then fork the ~32 worker processes. Theoretically this method might work since the dictionary is <strong>not</strong> being modified and therefore the COW mechanism of <code>fork</code> on Linux would mean that the data structure would be shared and not copied among processes. However, when I attempt this, my program crashes on <code>os.fork()</code> inside of <code>multiprocessing.Pool.map</code> from <code>OSError: [Errno 12] Cannot allocate memory</code>. I'm convinced that this is because the kernel is configured to never overcommit memory (<code>/proc/sys/vm/overcommit_memory</code> is set to <code>2</code>, and I can't configure this setting on the machine since I don't have root access).</p></li>
<li><p>Load the dictionary into a shared-memory dictionary with <code>multiprocessing.Manager.dict</code>. With this approach I was able to fork the 32 worker process without crashing but the subsequent data processing is orders of magnitude slower than another version of the task that required no dictionary (only difference is no dictionary lookup). I theorize that this is because of the inter-process communication between the manager process containing the dictionary and each worker process, that is required for every single dictionary lookup. Although the dictionary is not being modified, it is being accessed many many times, often simultaneously by many processes.</p></li>
<li><p>Copy the dictionary into a C++ <code>std::map</code> and rely on Linux's COW mechanism to prevent it from being copied (like approach #1 except with the dictionary in C++). With this approach, it took a long time to load the dictionary into <code>std::map</code> and subsequently crashed from <code>ENOMEM</code> on <code>os.fork()</code> just as before.</p></li>
<li><p>Copy the dictionary into <a href="https://pypi.python.org/pypi/pyshmht" rel="nofollow noreferrer"><code>pyshmht</code></a>. It takes far too long to copy the dictionary into <code>pyshmht</code>.</p></li>
<li><p>Try using <a href="http://snap.stanford.edu/snappy/doc/reference/composite.html#THash" rel="nofollow noreferrer"><code>SNAP</code></a>'s HashTable. The underlying implementation in C++ allows for it to be made and used in shared memory. Unfortunately the Python API does not offer this functionality.</p></li>
<li><p>Use PyPy. Crash still happened as in #1.</p></li>
<li><p>Implement my own shared-memory hash table in python on top of <code>multiprocessing.Array</code>. This approach still resulted in the out of memory error that ocured in #1.</p></li>
<li><p>Dump the dictionary into <a href="https://docs.python.org/3/library/dbm.html" rel="nofollow noreferrer"><code>dbm</code></a>. After trying to dump the dictionary into a <code>dbm</code> database for four days and seeing an ETA of "33 days", I gave up on this approach.</p></li>
<li><p>Dump the dictionary into Redis. When I try to dump the dictionaries (the 86GB dict is loaded from 1024 smaller dicts) into Redis using <code>redis.mset</code> I get a connection reset by peer error. When I try to dump the key-value pairs using a loop, it takes an extremely long time.</p></li>
</ol>
<p>How can I process this dataset in parallel efficiently without requiring inter-process communication in order to lookup values in this dictionary. I would welcome any suggestions for solving this problem!</p>
<p>I'm using Python 3.6.3 from Anaconda on Ubuntu on a machine with 1TB RAM.</p>
<hr/>
<p><strong>Edit</strong>: What finally worked:</p>
<p>I was able to get this to work using Redis. To get around the issued in #9, I had to chunk the large key-value insertion and lookup queries into "bite-sized" chunks so that it was still processing in batches, but didn't time-out from too large a query. Doing this allowed the insertion of the 86GB dictionary to be performed in 45 minutes (with 128 threads and some load balancing), and the subsequent processing was not hampered in performance by the Redis lookup queries (finished in 2 days). </p>
<p>Thank you all for your help and suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should probably use a system that's meant for sharing large amounts of data with many different processes -- like a Database.</p>
<p>Take your giant dataset and create a schema for it and dump it into a database.  You could even put it on a separate machine.</p>
<p>Then launch as many processes as you want, across as many hosts as you want, to process the data in parallel.  Pretty much any modern database will be more than capable of handling the load.</p>
</div>
<div class="post-text" itemprop="text">
<p>As most people here already mentioned: <br/>
<strong>Don't use that big a dictionary, Dump it on a Database instead!!!</strong><br/></p>
<p>After dumping your data into a database, using indexes will help reduce data retrieval times. <br/>
A good indexing explanation for PostgreSQL databases <a href="https://selectstar.io/blog/postgresql-performance-indexes/" rel="nofollow noreferrer">here</a>.<br/>
<a href="https://wiki.postgresql.org/wiki/Performance_Optimization" rel="nofollow noreferrer">You can optimize your database even further</a> (I give a PostgreSQL example because that is what I mostly use, but those concepts apply to almost every database)</p>
<hr/>
<p>Assuming you did the above (or if you want to use the dictionary either way...), you can implement a parallel and asynchronous processing routine using Python's <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> (<em>needs Python version &gt;= 3.4</em>).</p>
<p>The base idea is to create a mapping method to assign (map) an asynchronous task to each item of an iterable and register each task to asyncio's <a href="https://docs.python.org/3/library/asyncio-eventloop.html#base-event-loop" rel="nofollow noreferrer"><code>event_loop</code></a>.</p>
<p>Finally, we will collect all those promises with <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="nofollow noreferrer"><code>asyncio.gather</code></a> and we will wait to receive all the results.</p>
<p>A skeleton code example of this idea:</p>
<pre><code>import asyncio

async def my_processing(value):
    do stuff with the value...
    return processed_value

def my_async_map(my_coroutine, my_iterable):
    my_loop = asyncio.get_event_loop()
    my_future = asyncio.gather(
        *(my_coroutine(val) for val in my_iterable)
    )
    return my_loop.run_until_complete(my_future)

my_async_map(my_processing, my_ginormous_iterable)
</code></pre>
<p><hr/>
You can use <a href="http://www.gevent.org/index.html" rel="nofollow noreferrer"><code>gevent</code></a> instead of asyncio, but keep in mind that asyncio is part of the standard library.</p>
<p>Gevent implementation:</p>
<pre><code>import gevent
from gevent.pool import Group

def my_processing(value):
    do stuff with the value...
    return processed_value

def my_async_map(my_coroutine, my_iterable):
    my_group = Group()
    return my_group.map(my_coroutine, my_iterable)

my_async_map(my_processing, my_ginormous_iterable)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can successfully load that data into a single process in point 1, you can most likely work around the problem of fork doing copies by using <code>gc.freeze</code> introduced in <a href="https://bugs.python.org/issue31558" rel="nofollow noreferrer">https://bugs.python.org/issue31558</a></p>
<p>You have to use python 3.7+ and call that function before you fork. (or before you do the map over process pool)</p>
<p>Since this requires a virtual copy of the whole memory for the CoW to work, you need to make sure your <a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" rel="nofollow noreferrer">overcommit settings</a> allow you to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you should try do it in database, and maybe try to use Dask to solve your problem,let Dask to care about how to multiprocessing in the low level. You can focus on the main question you want to solve using that large data.
And this the link you may want to look <a href="https://dask.pydata.org/en/latest/" rel="nofollow noreferrer">Dask</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using a dictionary, use a data structure that compresses data, but still has fast lookups. </p>
<p>e.g: </p>
<ul>
<li><p>keyvi: <a href="https://github.com/cliqz-oss/keyvi" rel="nofollow noreferrer">https://github.com/cliqz-oss/keyvi</a> 
keyvi is a FSA-based key-value data structure optimized for space &amp; lookup speed. multiple processes reading from keyvi will re-use the memory, because a keyvi structure is memory mapped and it uses shared memory. Since your worker processes don't need to modify the data structure, I think this would be your best bet.</p></li>
<li><p>marisa trie: <a href="https://github.com/pytries/marisa-trie" rel="nofollow noreferrer">https://github.com/pytries/marisa-trie</a> static trie structure for Python, based on the marisa-trie C++ library. Like keyvi, marisa-trie also uses memory-mapping. Multiple processes using the same trie will use the same memory.</p></li>
</ul>
<p>EDIT: </p>
<p>To use keyvi for this task, you can first install it with <code>pip install pykeyvi</code>. Then use it like this:</p>
<pre><code>from pykeyvi import StringDictionaryCompiler, Dictionary

# Create the dictionary
compiler = StringDictionaryCompiler()
compiler.Add('foo', 'bar')
compiler.Add('key', 'value')
compiler.Compile()
compiler.WriteToFile('test.keyvi')

# Use the dictionary
dct = Dictionary('test.keyvi')
dct['foo'].GetValue()
&gt; 'bar'
dct['key'].GetValue()
&gt; 'value'
</code></pre>
<p>marisa trie is just a trie, so it wouldn't work as a mapping out of the box, but you can for example us a delimiter char to separate keys from values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well I do believe that the Redis or a database would be the easiest and quickest fix. </p>
<p>But from what I understood, why not reduce the problem from your second solution? That is, first try to load a portion of the billion keys into memory (say 50 Million). Then using Multi-processing, create a pool to work on the 2 TB file. If the lookup of the line exists in the table, push the data to a list of processed lines. If it doesn't exist, push it to a list. Once you complete reading the data set, pickle your list and flush the keys you have stored from memory. Then load the next million and repeat the process instead reading from your list. Once it is finished completely, read all your pickle objects. </p>
<p>This should handle the speed issue that you were facing. Of course, I have very little knowledge of your data set and do not know if this is even feasible. Of course, you might be left with lines that did not get a proper dictionary key read, but at this point your data size would be significantly reduced.</p>
<p>Don't know if that is of any help. </p>
</div>
<div class="post-text" itemprop="text">
<p>The already mentioned keyvi (<a href="http://keyvi.org" rel="nofollow noreferrer">http://keyvi.org</a>) sounds like the best option to me, because "python shared memory dictionary" describes exactly what it is. I am the author of keyvi, call me biased, but give me the chance to explain:</p>
<p>Shared memory make it scalable, especially for python where the GIL-problematic forces you to use multiprocessing rather than threading. That's why a heap-based in-process solution wouldn't scale. Also shared memory can be bigger than main memory, parts can be swapped in and out.</p>
<p>External process network based solutions require an extra network hop, which you can avoid by using keyvi, this makes a big performance difference even on the local machine. The question is also whether the external process is single-threaded and therefore introduces a bottleneck again.</p>
<p>I wonder about your dictionary size: 86GB: there is a good chance that keyvi compresses that nicely, but hard to say without knowing the data.</p>
<p>As for processing: Note that keyvi works nicely in pySpark/Hadoop.</p>
<p>Your usecase BTW is exactly what keyvi is used for in production, even on a higher scale.</p>
<p>The redis solution sounds good, at least better than some database solution. For saturating the cores you should use several instances and divide the key space using consistent hashing. But still, using keyvi, I am sure, would scale way better. You should try it, if you have to repeat the task and/or need to process more data.</p>
<p>Last but not least, you find nice material on the website, explaining the above in more detail.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution could be to use some existing database driver which can allocate / retire pages as necessary and deal with the index lookup quickly.</p>
<p><a href="https://docs.python.org/3/library/dbm.html" rel="nofollow noreferrer"><code>dbm</code></a> has a nice dictionary interface available and with automatic caching of pages may be fast enough for your needs. If nothing is modified, you should be able to effectively cache the whole file at VFS level.</p>
<p>Just remember to disable locking, open in not synch-ed mode, and open for <code>'r'</code> only so nothing impacts caching/concurrent access.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're only looking to create a read-only dictionary it is possible that you can get better speed than some off the shelf databases by rolling your own simple version. Perhaps you could try something like:</p>
<pre><code>import os.path
import functools
db_dir = '/path/to/my/dbdir'

def write(key, value):
    path = os.path.join(db_dir, key)
    with open(path, 'w') as f:
        f.write(value)

@functools.lru_cache(maxsize=None)
def read(key):
    path = os.path.join(db_dir, key)
    with open(path) as f:
        return f.read()
</code></pre>
<p>This will create a folder full of text files. The name of each file is the dictionary key and the contents are the value. Timing this myself I get about 300us per write (using a local SSD). Using those numbers theoretically the time taken to write your 1.75 billion keys would be about a week but this is easily parallelisable so you <em>might</em> be able to get it done a lot faster.</p>
<p>For reading I get about 150us per read with warm cache and 5ms cold cache (I mean the OS file cache here). If your access pattern is repetitive you could memoize your read function in process with lru_cache as above.</p>
<p>You may find that storing this many files in one directory is not possible with your filesystem or that it is inefficient for the OS. In that case you can do like the .git/objects folder: Store the key abcd in a file called ab/cd (i.e. in a file cd in folder ab).</p>
<p>The above would take something like 15TB on disk based on a 4KB block size. You could make it more efficient on disk and for OS caching by trying to group together keys by the first n letters so that each file is closer to the 4KB block size. The way this would work is that you have a file called abc which stores key value pairs for all keys that begin with abc. You could create this more efficiently if you first output each of your smaller dictionaries into a sorted key/value file and then mergesort as you write them into the database so that you write each file one at a time (rather than repeatedly opening and appending).</p>
</div>
<div class="post-text" itemprop="text">
<p>While the majority suggestion of <strong><em>"use a database"</em></strong> here is wise and proven, it sounds like you may want to avoid using a database for some reason (and you are finding the load into the db to be prohibitive), so essentially it seems you are IO-bound, and/or processor-bound. You mention that you are loading the 86GB index from 1024 smaller indexes. If your key is reasonably regular, and evenly-distributed, is it possible for you to go back to your 1024 smaller indexes and partition your dictionary? In other words, if, for example, your keys are all 20 characters long, and comprised of the letters a-z, create 26 smaller dictionaries, one for all keys beginning with 'a', one for keys beginning 'b' and so on. You could extend this concept to a large number of smaller dictionaries dedicated to the first 2 characters or more. So, for example, you could load one dictionary for the keys beginning 'aa', one for keys beginning 'ab' and so on, so you would have 676 individual dictionaries. The same logic would apply for a partition over the first 3 characters, using 17,576 smaller dictionaries. Essentially I guess what I'm saying here is "<em>don't load your 86GB dictionary in the first place</em>". Instead use a strategy that naturally distributes your data and/or load.</p>
</div>
<span class="comment-copy">CPython refcounting means you write to an object if you so much as <i>look</i> at it, or even if you don't look at it, but a reference to it passes through your hands. This doesn't play well with copy-on-write.</span>
<span class="comment-copy">@user2357112 The refcounting isn't a performance issue, it's a correctness issue—he gets an <code>ENOMEM</code> error while trying to fork and copy.</span>
<span class="comment-copy">Why not use a DB or something like Redis if you want everything in memory for speed?</span>
<span class="comment-copy">@JonDeaton Redis would be pretty painless, I don't think you'd have to re-write anything. You could probably wrap the Redis client in some class that implements <code>__getitem__</code> and <code>__setitem__</code> and it would be a drop-in replacement for your <code>dict</code>. I'm just saying, Redis <i>solves this problem already</i>. Almost certainly, it would require less effort than implementing a hash-map over <code>multiprocessing.Array</code></span>
<span class="comment-copy">You really should avoid building a dict as large as this in memory. Use a database instead. Redis, SQLite, a heavier database, and use a wrapper that implements the mapping interface if you don’t want to retool all your code.</span>
<span class="comment-copy">Would you be able to suggest a specific database that would work well for this? I tried using <code>dbm</code> and <code>redis</code> and both took an extremely long time to load the data into it.</span>
<span class="comment-copy"><code>redis</code> is designed to store everything in memory, which isn't really possible with a 2TB dataset.  I'm a fan of <code>postgresql</code> with  <code>sqlalchemy</code> as the python ORM.  Unfortunately, it will likely require a significant refactor of your code, or at least require an abstraction layer to turn database queries into dictionaries that your code can process.</span>
<span class="comment-copy">oh im not storing the whole 2TB dataset in memory, just the 86GB key value mapping. The dataset itself is getting incrementally processed and is never all in memory at once.</span>
<span class="comment-copy">@JonDeaton Same deal with the 86 GB.  You're probably going to have to query just that part of the dictionary you need to process and no use the whole dictionary at once.</span>
<span class="comment-copy">I'm open to this idea but not entirely convinced that it would work. The problem with the fork is that it's failing because the system detects that there would not be enough memory <i>if</i> the entire process's memory needed to be copied.</span>
<span class="comment-copy">@JonDeaton I don't think that's why the error is raised. It's not Python's job to try predicting memory usage. If Python says it can't allocate something, that's normally at the point when it actually tries to do that. It means that either it tries to do a large copy early (gc.freeze would help), or system prevents overcommit (adjust the overcommit settings <a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" rel="nofollow noreferrer">kernel.org/doc/Documentation/vm/overcommit-accounting</a> )</span>
<span class="comment-copy">Extending overcommit should be safe, because even though the CoW mapping will be huge (especially with 32 processes), you know you're never going to actually use that memory.</span>
<span class="comment-copy">You are right it's not Python's job but it is the OS's job. <code>/proc/sys/vm/overcommit_memory</code> is <code>2</code> on my machine, meaning that Linux will not overcommit memory, and I'm pretty sure that this is why <code>fork</code> is failing</span>
<span class="comment-copy">If you know you're doing a lot of CoW, it's ok to enable unlimited overcommit (or calculate exactly what ratio you need if you want it in production).</span>
<span class="comment-copy">In agreement here. There are some easy to use hash maps that are memory mapped and for the most used keys (or pages) will perform very fast. Take a look at lmdb: <a href="https://lmdb.readthedocs.io/en/release/" rel="nofollow noreferrer">lmdb.readthedocs.io/en/release</a> . No server is needed and they support multiple processes as explained here: <a href="http://www.lmdb.tech/doc/" rel="nofollow noreferrer">lmdb.tech/doc</a> .</span>
<span class="comment-copy">I tried using Redis for this. It seems to be taking an extremely long time to load the data into the database. I can't use <code>redis.mset</code> since I get a connection reset by peer, and inserting the 2 billion key-value pairs takes forever, even if multiprocessing is used.</span>
<span class="comment-copy">I see. Are you aggregating the results in memory or are you writing each line to file that has been processed to disk?</span>
<span class="comment-copy">I believe that I am aggregating the results in memory. I take each of the 1024 dictionaries and dump them one by one into the Redis database through a local network connection. It takes a long time to loop through the key-value pairs, and I cannot use <code>redis.mset</code> because each of those dictoinaries is too large and I get <code>redis.exceptions.ConnectionError: connection reset by peer</code></span>
<span class="comment-copy">i couldn't agree more. Unfortunately I didn't forsee this issue when I set out on the project. If I do anything like this in the future I will make sure to use a more scalable language.</span>
<span class="comment-copy">After re-reading everything, I realized the bottle neck arises from using python itself.  Because, python doesn't multithread efficiently (bcz of GIL) it uses multiprocessing becoming independent processes and require multiple copies of the map. And redis doesnt make sense seeing as you have a lot of data to load at upfront rather than in incremental insertions.   Of course, blaming the language does not mitigate the problem but does bring the problem more into focus. Esp since you have 1 TB of Ram.</span>
<span class="comment-copy">Do you know how to configure <code>dbm</code> so that it can be written/read to from multiple processes? I'm having a hard time getting that info</span>
<span class="comment-copy">If you force the gnu variant, you can use <code>rfu</code> for mode: <a href="https://docs.python.org/3/library/dbm.html#dbm.gnu.open" rel="nofollow noreferrer">docs.python.org/3/library/dbm.html#dbm.gnu.open</a> and open in each process. That's if you want to read though. I don't know if you can do concurrent writes.</span>
<span class="comment-copy">Oh alright, if it cant be written to by multiple processes then thats ok. I was just hoping it could be so that I could load it in faster, but so long as it can be read in parallel, then it should solve my problem.</span>
<span class="comment-copy">I'm giving <code>dbm</code> a try, but with the way I'm doing it looks like it would take about a week to copy in the 86GB dictionary into <code>dbm</code>. I'm just looping through all the keys and inserting them into the database and have opened it up with <code>cfu</code>. Should it be taking this long and if not how can I make this workable?</span>
<span class="comment-copy">Sorry, I don't know about the insert speed. It was a suggestion for the reading side mostly :(</span>
