<div class="post-text" itemprop="text">
<p>Given a list like this, where first column is the id and second is a string,</p>
<pre><code>[ [2, ["00_01_02"]],
  [1, ["00_03_04"]],
  [3, ["00_03_04"]],
  [6, ["00_03_04"]],
  [4, ["01_02_03"]],
  [5, ["01_02_03"]],    
 ]
</code></pre>
<p>As you can see there are adjacent elements that are the same. For example, the id 1,3 and 6 have the same string so I would like to group them up into another list. Same goes for id 5 and 4. We can also assume that the list is in sorted order by the string.</p>
<p>I would like to solve this problem in 
O(NC) if possible, where N is the number of element in the list, C is the number of characters in the string.</p>
<p>Example output would be something like,</p>
<pre><code>[ [[1,3,6], ["00_03_04"]],
  [[4,5]  , ["01_02_03"]] ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools</code> for efficiency - </p>
<pre><code>a = [ [2, ["00_01_02"]],
  [1, ["00_03_04"]],
  [3, ["00_03_04"]],
  [6, ["00_03_04"]],
  [4, ["01_02_03"]],
  [5, ["01_02_03"]],    
  [7, ["00_03_04"]],
 ]

from itertools import groupby
from operator import itemgetter

print([ [[ g[0] for g in grp], key] for key, grp in groupby(a, key=itemgetter(1))])
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[[2], ['00_01_02']], [[1, 3, 6], ['00_03_04']], [[4, 5], ['01_02_03']], [[7], ['00_03_04']]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should definitely use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collectins.defaultdict</a>:</p>
<pre><code>from collections import defaultdict
l = [ [2, ["00_01_02"]],
  [1, ["00_03_04"]],
  [3, ["00_03_04"]],
  [6, ["00_03_04"]],
  [4, ["01_02_03"]],
  [5, ["01_02_03"]],    
 ]

for v, k in l:
    new_d[k[0]].append(v)


new_d
Out[102]: defaultdict(list, {'00_01_02': [2], '00_03_04': [1, 3, 6], '01_02_03': [4, 5]})
</code></pre>
<p>If you want the similar output as you requested.</p>
<pre><code>[[v,[k]] for k,v in new_d.items() if len(v) &gt; 1]
Out[118]: [[[1, 3, 6], ['00_03_04']], [[4, 5], ['01_02_03']]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try in one line:</p>
<pre><code>data=[ [2, ["00_01_02"]],
  [1, ["00_03_04"]],
  [3, ["00_03_04"]],
  [6, ["00_03_04"]],
  [4, ["01_02_03"]],
  [5, ["01_02_03"]],
 ]

import itertools

print([list(j) for i,j in itertools.groupby(data,key=lambda x:x[1][0])])
</code></pre>
<p>output:</p>
<pre><code>[[[2, ['00_01_02']]], [[1, ['00_03_04']], [3, ['00_03_04']], [6, ['00_03_04']]], [[4, ['01_02_03']], [5, ['01_02_03']]]]
</code></pre>
<p>if you don't want to use any import then:</p>
<pre><code>similar={}
for j in data:
    if j[1][0] not in similar:
        similar[j[1][0]]=[j[0]]
    else:
        similar[j[1][0]].append(j[0])
print(similar)
</code></pre>
<p>output:</p>
<pre><code>{'01_02_03': [4, 5], '00_01_02': [2], '00_03_04': [1, 3, 6]}
</code></pre>
</div>
<span class="comment-copy">You might want to look into using a dictionary</span>
<span class="comment-copy">I did actually check it out and I have a solution using a dictionary. But the thing is that my solution doesn't take into account the fact that items are adjacent to each other. I'll post my solution below.</span>
<span class="comment-copy">Where did <code>2, ["00_01_02"]</code> went in your output, shopping?</span>
<span class="comment-copy">@Rahul i am only looking for strings with 2 or more similar ids</span>
<span class="comment-copy">Fair Enought. Did any of the answer worked for you?</span>
<span class="comment-copy">is there a way to group them together while taking into account that the second column is sorted.</span>
<span class="comment-copy">@Jeevan it does pls check the updated example</span>
<span class="comment-copy">how do you read the complexity of this algorithm</span>
<span class="comment-copy">just wondering what is the complexity of this solution?</span>
<span class="comment-copy">I am sorry but I don't care.</span>
