<div class="post-text" itemprop="text">
<p>im writting an app using python and sockets, here is piece of the server code:</p>
<pre><code>while True:
  c = random.choice(temp_deck)
  temp_deck.remove(c)

  if hakem == p1:
      p1.send(pickle.dumps(('{} for {}'.format(c,'you'),False)))
      p2.send(pickle.dumps(('{} for {}'.format(c,'other'),False)))
  else:
      p1.send(pickle.dumps(('{} for {}'.format(c,'other'),False)))
      p2.send(pickle.dumps(('{} for {}'.format(c,'you'),False)))

  if c in ['A♠','A♣','A♦','A♥']:
      if hakem == p1:
          p1.send(pickle.dumps(('You are Hakem!',False)))
          p2.send(pickle.dumps(('Other Player is Hakem!',False)))
          break
      else:
          p1.send(pickle.dumps(('Other Player is Hakem!',False)))
          p2.send(pickle.dumps(('You are Hakem!',False)))
          break
  if hakem == p1:
      hakem = p2
      other = p1
  else:
      hakem = p1
      other = p2
</code></pre>
<p>this needs two clients to connect, everything is fine except clients don't receive full data:
for example one gets:</p>
<p>3♠ for other</p>
<p>2♠ for you</p>
<p>10♣ for other</p>
<p>10♦ for you</p>
<p>A♣ for other</p>
<p>the other gets:</p>
<p>2♠ for you</p>
<p>10♣ for other</p>
<p>10♦ for you</p>
<p>A♣ for other</p>
<p>what should i do?</p>
<p>client code:</p>
<pre><code>import socket
import pickle

s = socket.socket()

host = socket.gethostname()
port = 12345

s.connect((host, port))

while True:
    o = pickle.loads(s.recv(1024))
    print(o[0])
    if o[1] == True:
        s.send(pickle.dumps(input("&gt;")))
s.close  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that TCP sockets are byte streams, not message streams. When you <code>send</code> some data and the client does a <code>recv</code>, there's no guarantee that it will receive everything you sent. It may get half the message. It may get multiple messages at once.</p>
<p>I've explained this at some length in <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow noreferrer">a blog post</a>—but fortunately, you're actually only hitting half the problem, and it's ultimately the simpler half. You've chosen to use a stream of <code>pickle</code> messages as your protocol, and <code>pickle</code> is a self-delimiting (aka framed) protocol.</p>
<p><code>pickle.load</code> can load pickle after pickle out of anything with a file-like interface. And if your client and server are built around blocking I/O (e.g., using a thread for each direction on the socket), you can simulate <code>read</code> by doing blocking <code>recv</code> calls and appending them onto a buffer until you have enough bytes to satisfy the <code>read</code>.</p>
<p>And, even better, you don't have to do that yourself, because that's exactly what the builtin <a href="https://docs.python.org/3/library/socket.html#socket.socket.makefile" rel="nofollow noreferrer"><code>socket.makefile</code></a> does. I haven't done any more than a quick test with this, so I won't promise it's bulletproof, but…</p>
<p>On the client side, you probably have something like this:</p>
<pre><code>sock.connect(...)
# more stuff

# in a loop somewhere
    buf = sock.recv(16384)
    msg = pickle.loads(buf)

# later
sock.close()
</code></pre>
<p>Change it to this:</p>
<pre><code>sock.connect(...)
rfile = socket.makefile('rb')
# more stuff

# in a loop somewhere
    msg = pickle.load(rfile)

# later
rfile.close()
sock.close()
</code></pre>
<p>And it just works.</p>
<p>Again, you should test this. And you should read either my blog post, or a more complete primer on sockets programming and TCP, to understand what's going on. And really, you're probably better off designing your app around a higher-level framework (<code>asyncio</code> is really cool, especially with the syntactic support in Python 3.5+, or I think Twisted already has a pickle protocol class pre-written for you…). But this may be enough to get you started.</p>
</div>
<span class="comment-copy">Maybe you need to <code>flush</code> the socket after sending? Without seeing the full code and ideally a minimal example, it's hard to tell.</span>
<span class="comment-copy"><a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow noreferrer">TCP sockets are byte streams, not message streams</a> This is probably too much to explain in a SO answer. I tried multiple times in years long past, which i why I wrote that blog post.</span>
<span class="comment-copy">The tl;dr is that when you <code>send</code> on on side and <code>recv</code> on the other, there's no guarantee that the <code>recv</code> gets an entire <code>send</code>. It could get half a <code>send</code>, or two and a half <code>send</code>s. At least you've chosen a self-delimiting protocol, pickle, which takes care of the other problem people usually run into. And actually, maybe that's enough to make this one answerable. I'll give it a try.</span>
<span class="comment-copy">Actually, looking at your output, that may not be the problem. If not, it <i>will</i> be a problem once you try to run this over the internet, but you might have a different problem blocking you before you even get to that point, in which case my answer isn't relevant to your question (although you should still read it).</span>
<span class="comment-copy">Can we see the relevant client code?</span>
