<div class="post-text" itemprop="text">
<p>In my Python programm I want to dynamically load modules and access variables of the module by converting a string parameter into a variable name.</p>
<p><strong>Use Case</strong></p>
<p>I have different Fonts on SD Card which are python files, and a display function which loads the font when needed to display the caracters.</p>
<p>Examples for my font file:</p>
<pre><code># arial14.py
# ch_(ASCII) = (widht), (height), [bitmask]
ch_33 = 3, 16, [0,0,0,0,0,0,0,0,0,1,1,1,1,1 ........
ch_34 = 5, 16, [0,0,0,0,0,0,0,0,0,0,0,0,0,0 ........
....

# arial20.py
ch_33 = 4, 22, [0,0,0,0,0,0,0,0,0,1,1,1,1,1 ........
ch_34 = 8, 22, [0,0,0,0,0,0,0,0,0,0,0,0,0,0 ........
</code></pre>
<p>Further, there is a Writer class which renders the fonts to the display:</p>
<pre><code>class Writer(object):
    def __init__(self):
       try:
           global arial14
           import arial14
           self.current_module = "arial14"
           self.imported_fonts = []
           self.imported_fonds.append(self.current_module)
      except ImportError:
           print("Error loading Font")
   def setfont(self, fontname, fontsize):
           modname = fontname+str(fontsize)
           if modname not in self.importedfonts:
               try:
                    exec("global" + modname)
                    exec("import" + modname)      #import the font (works)
                    self.importedfonts.append(modname)
               except ImportError:
                    print("Error loading Font")
                    return
           else:
               print(modname+" was already imported")
           self.current_module = modname
           print("Font is set now to: "+ self.current_module

## HERE COMES THE NON WORKING PART:
    def putc_ascii(self, ch, xpos, ypos):

           execline = "width, height, bitmap = "+ self.cur_mod+".ch_"+str(ch)
           print(execline) 
           #this example.: width, height,bitmap = arial14.ch_55


           width, height,bitmap = arial14.ch_32
           print(width, height, bitmap) # values of arial14.ch_32 -&gt; correct

           exec (execline)
           print(width, height, bitmap) # values of arial14.ch_32
                                        # BUT VALUES OF arial14.ch_55 EXPECTED
</code></pre>
<p>Has anybody an idea how can I accomplish to save the correct values of the queried character of the correct font into the variables width, height and bitmap? </p>
<p>I want to load the Fonts dynamically only if needed, and offer the possibility to add new fonts by putting new .py font files into the folder.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT</strong> </p>
<p>The OP is actually using micropython, which doesn't implement importlib... </p>
<p>Possible (untested) solution (yes, using <code>exec</code> - if someone knows a better solution please chime in). </p>
<pre><code>def import_module(name):
    name = name.strip().split(
    statement = "import {}"
    exec(statement, globals()) 
    return sys.modules[name]


class Writer(object):
    def __init__(self):
       # reference to the current module
       # WARNING : this is the `module` object itself, 
       # not it's name       
       self.current_module = None

       # {name:module} mapping
       # not sure it's still useful since we
       # now have a reference to the module itself
       # and `sys.modules` already caches imported 
       # modules... 
       self.imported_fonts = {}

       # set default font
       self.setfont("arial", "14")

    def setfont(self, fontname, fontsize):
        self.current_module = self._loadfont(fontname, fontsize)

    def _loadfont(self, fontname, fontsize):
        name = fontname+str(fontsize)
        if name not in self.imported_fonts:
            self.imported_fonts[name] = load_module(name)
        return self.imported_font[name]

    def putc_ascii(self, ch, xpos, ypos):
        width, height, bitmap = self._get_char(ch)
        print("{}.{}: {} - {} - {}".format(
            self.current_module, ch, width, height, bitmap
            )

    def _get_char(self, chrnum):
        # assume the font modules have been rewritten
        # using dicts (cf lower) and all chars are defined
        # in all fonts modules
        return self.current_module[ch]

        # alternate implementation using the current
        # fonts definitions
        # return getattr(self.current_module, "ch_{}".format(ch)) 
</code></pre>
<p><strong>TL:DR</strong> : </p>
<p>You want <code>importlib.import_module</code> and eventually <code>getattr()</code>. But you should still read the longer answer, really, it will save you a lot of time and frustration.</p>
<p><strong>Longer answer</strong>:</p>
<p>First point about your "font" files format - this:</p>
<pre><code>ch_33 = 3, 16, [0,0,0,0,0,0,0,0,0,1,1,1,1,1 ........
ch_34 = 5, 16, [0,0,0,0,0,0,0,0,0,0,0,0,0,0 ........
</code></pre>
<p>is a huge design smell. You want lists or dicts instead (or possibly an ordered dict), ie:</p>
<pre><code>characters = {
    33: (3, 16,  [0,0,0,0,0,0,0,0,0,1,1,1,1,1...]),
    34: (5, 16,  [0,0,0,0,0,0,0,0,0,0,0,0,0,0...]),
    # etc
    }
</code></pre>
<p>As a general rule, when you start having some "var1", "var2", "var3" etc pattern then you know you want some kind of container instead.</p>
<p>Second  point - your error handling, ie:</p>
<pre><code> try:
       global arial14
       import arial14
       self.current_module = "arial14"
       self.imported_fonts = []
       self.imported_fonds.append(self.current_module)
  except ImportError:
       print("Error loading Font")
</code></pre>
<p>is worse than useless, it's actually harmful. First because it doesn't stop program execution in the case of an unrecoverable error (you <em>dont</em> want your program to continue when something totally wrong happened), then because it replaces all the incredibly useful informations you'd either get from the error message and traceback with a plain useless "An error happened" message. </p>
<p>Only catch exceptions that you can properly manage one way or another, let everything else propagate (maybe someone upper in the call stack - usually in the UI part - might be able to handle it properly). </p>
<p>Third point: do not use globals. I mean: do not mutate nor rebind globals (read-only (pseudo-constant) globals are ok of course). Which means you really never have to use the "global" keyword in your code.</p>
<p>When you need to share state between a group a functions, use a class, store the state as attributes and make your functions methods. That's what objects are for (well, not only but that's part of there raison d'être).</p>
<p><strong>EDIT</strong> : <em>this part is still true for complete Python implementation and probably still partly true for micropython, <strong>except</strong> for parts that are not implemented in micropython (like <code>importlib</code> - I don't know what else is missing)</em></p>
<p>And finally: never ever use <code>exec</code> nor <code>eval</code>. <strong>You don't need them</strong>, whatever you're trying to do there's a better, safer specific solution.</p>
<p>In your case, to import a module by it's name, you have <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module</code></a>, and to get an object's attribute by it's name you have <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr()</code></a> (but if you use a proper container, cf first point, you don't even need <code>getattr</code> here). </p>
</div>
<span class="comment-copy">Don't do any of this. Use a dict.</span>
<span class="comment-copy">Thanks for the reply. With the error handling part you are fully right, I forgot to insert code there. In my original code there is a return statement there. The other points I will consider and adjust the implementation. The problem with importlib is, that I am developping on an embedded device with Micropython, and I think there does not exist this module. But I will try it tomorrow when i'm at my workplace. Is there a way without this module to load modules and variables with not predetermined names at runtime (at the moment I use the REPL to send the command to load and draw fonts).</span>
<span class="comment-copy">Looks like there's no importlib in micropython indeed(judging from this : <a href="https://pypi.python.org/pypi/micropython-importlib/0.0.0" rel="nofollow noreferrer">pypi.python.org/pypi/micropython-importlib/0.0.0</a>) . You should really have specified you were working on micropython actually.</span>
<span class="comment-copy">I edited my answer with a possible cleaner implementation, still using <code>exec</code> to import fonts (well yes if you don't have <code>importlib</code> nor any replacement you can hardly avoid <code>exec</code> here)</span>
<span class="comment-copy">Merci beacoup pour votre aide! You´re right, i should have said that i´m developping on Micropython, but I will consider the points in your reply though. Now i figured it out how to solve the problem. Instead of exec which normally returns None (in my case it returns undetermined values) I had to use eval, which is working now. At the moment I have to set the fontname with exec("global "+fontname) to global, but I will try around a  little to keep the variables local.</span>
<span class="comment-copy">De rien - and if this solves your problem then feel free to upvote and accept the answer ;)</span>
