<div class="post-text" itemprop="text">
<p>I create all three-element permutations without mirroring, using <code>itertools.product()</code>:  </p>
<pre><code>import itertools

list_1 = [list(i) for i in itertools.product(tuple(range(4)), repeat=3) if tuple(reversed(i)) &gt;= tuple(i)]
</code></pre>
<p>Output:</p>
<pre><code>[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 0], [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 2, 0], [0, 2, 1], [0, 2, 2], [0, 2, 3], [0, 3, 0], [0, 3, 1], [0, 3, 2], [0, 3, 3], [1, 0, 1], [1, 0, 2], [1, 0, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 1], [1, 2, 2], [1, 2, 3], [1, 3, 1], [1, 3, 2], [1, 3, 3], [2, 0, 2], [2, 0, 3], [2, 1, 2], [2, 1, 3], [2, 2, 2], [2, 2, 3], [2, 3, 2], [2, 3, 3], [3, 0, 3], [3, 1, 3], [3, 2, 3], [3, 3, 3]]
</code></pre>
<p>How do I delete these sublisters from the list <code>list_1</code>, which have the same number of corresponding values and then leave only one of them?</p>
<p>For example, in sublists <code>[1,1,2], [1,2,1]</code> the number of given values is the same in all, that is, in each sub-list there are two <code>1</code> and one <code>2</code>, that's why I consider the sublisters to be the same and that's why I want to leave only the first one, namely  <code>[1,1,2]</code>. How can this be done?</p>
<p>I was thinking about counting the number of corresponding values in each sub-list and creating a list with the occurring feature regarding the amount of given values, and then checking each element from the list list_1 in the loop or the element with the given feature has not occurred before. But it seems to me to be very complicated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than using <code>product</code> from the <code>itertools</code> module, use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="noreferrer">combinations_with_replacement</a>. That does what you want in one line without any massaging afterward:</p>
<pre><code>list1 = [list(i) for i in combinations_with_replacement(range(4),3)]
</code></pre>
<p>The result of <code>print(list1)</code> after that is</p>
<pre><code>[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 2, 2], [0, 2, 3], [0, 3, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]]
</code></pre>
<p>Note that your conversion of the <code>range</code> object to a tuple is not necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>This might do the trick:</p>
<pre><code>import itertools

def uniqifyList(list):
    indexToReturn = []
    sortedUniqueItems = []

    for idx, value in enumerate(list):
        # check if exists in unique_list or not
        value.sort()
        if value not in sortedUniqueItems:
            sortedUniqueItems.append(value)
            indexToReturn.append(idx)

    return [list[i] for i in indexToReturn]

list1 = [list(i) for i in itertools.product(tuple(range(4)), repeat=3) if tuple(reversed(i)) &gt;= tuple(i)]
print(list1)

list2 = uniqifyList(list1)
print(list2)
</code></pre>
<p>Which outputs:</p>
<pre><code>[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 2, 2], [0, 2, 3], [0, 3, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can sort each sublist and then extract unique sublists out as follows.</p>
<pre><code>list_2 = map(sorted, list_1)
list_u = []
[list_u.append(x) for x in list_2 if x not in list_u]
</code></pre>
<p>Output:</p>
<pre><code>list_u = [[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 2, 2], [0, 2, 3], [0, 3, 3], [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]]
</code></pre>
<p>Now, there are more efficient options than sorting each sublist, but I will leave that upto you.</p>
</div>
<span class="comment-copy">Use the <code>Counter</code> structure; if two items have the same <code>count</code> dict, then remove the duplicate.  Is that enough of a hint?</span>
<span class="comment-copy">Rory Daulton gave the simplest solution :)</span>
<span class="comment-copy">cool, I did not know that :)</span>
