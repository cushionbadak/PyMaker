<div class="post-text" itemprop="text">
<p>I need to convert the  nested list <code>result = [[450, 455, 458], [452, 454, 457], [451, 453]]</code> to a dictionary like </p>
<pre><code>{
    0: 
         {
             450: None,
             455: 450,
             458: 450
         },
    1:   {
             452: None,
             454: 452,
             456: 452,
             457: 452
         },
    2:   {
             451: None,
             453: 451
         }

}
</code></pre>
<p><strong>Please take a look at this and assist:</strong></p>
<pre><code>result_group = {}
for sub_group in result:
    group_count = 0
    first_rel_item = 0
    result_group[group_count] = dict()
    for item in sub_group:
        if item == sub_group[0]:
            result_group[group_count][item] = None
            first_rel_item = item
            continue
        result_group[group_count]['item'] = first_rel_face
        group_count += 1
</code></pre>
<p>I messed up with this as i get key Error:1 cant add to dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>result_group = {}
group_count = 0
for sub_group in result:
    first_rel_item = 0
    result_group[group_count] = {}
    result_group[group_count][sub_group[0]] = None
    previtem = sub_group[0]
    for item in sub_group[1:]:
        result_group[group_count][item] = previtem
    group_count += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one way:</p>
<pre><code>lst = [[450, 455, 458], [452, 454, 457], [451, 453]]

res = {i: {w: None if w == v[0] else v[0] for w in v}
          for i, v in enumerate(lst)}
</code></pre>
<p><strong>Result</strong></p>
<pre><code>{0: {450: None, 455: 450, 458: 450},
 1: {452: None, 454: 452, 457: 452},
 2: {451: None, 453: 451}}
</code></pre>
<p><strong>Explanation</strong></p>
<ul>
<li>Use ternary statement to determine whether you choose <code>None</code> or <code>v[0]</code>.</li>
<li>Use <code>enumerate</code> to extract index of nested list.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could use a list comprehension here:</p>
<pre><code>&gt;&gt;&gt; result = [[450, 455, 458], [452, 454, 457], [451, 453]]

&gt;&gt;&gt; dict(enumerate({**{i: a[0] for i in a[1:]}, **{a[0]: None}}
                   for a in result))

{0: {450: None, 455: 450, 458: 450},
 1: {452: None, 454: 452, 457: 452},
 2: {451: None, 453: 451}}
</code></pre>
<p>Note: this uses <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="nofollow noreferrer">"extended"</a> iterable unpacking, which was introduced in Python 3.5.  <code>z = {**x, **y}</code> merges dictionaries <code>x</code> and <code>y</code>.</p>
<p>Each <code>a</code> is a sublist of <code>result</code>.  You want to use <code>a[0]</code> as the value for the 1st elements and above, and None for the 0th element.</p>
<p>The assumption here is that you only want the 0th element of the sublist to have a corresponding None value.  (If the 0th element were repeated, somewhere, it would use the 0th element as its value, as in @jpp's answer.)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># the nice solutions were already given, so by foot:

d = {}
result = [[450, 455, 458], [452, 454, 457], [451, 453]]

for idx,l in enumerate(result): # returns the index and the sublists data
    rMin = min(l)
    d[idx] = {}  # create a inner dict at key idx
    for i in l:
        d[idx][i] = None if i == rMin else rMin   # fill inner dicts keys

print(d)
</code></pre>
<p>Output:</p>
<pre><code>{0: {450: None, 455: 450, 458: 450},
 1: {452: None, 454: 452, 457: 452},
 2: {451: None, 453: 451}}
</code></pre>
</div>
<span class="comment-copy">I can't match your output, where did <code>1: 456</code> come from? Input list of lists has no <code>456</code> ...</span>
<span class="comment-copy">@jpp. Sorry dude second sublist would be [452, 454, 456, 457]. Sorry for my typo.</span>
<span class="comment-copy">Just tried I got this. <a href="https://prnt.sc/itdgor" rel="nofollow noreferrer">link</a> but I need the one like I mentioned in top. Your advice welcome</span>
<span class="comment-copy">very strange, as i got <code>{0: {450: None, 455: 450, 458: 450}, 1: {452: None, 454: 452, 457: 452}, 2: {451: None, 453: 451}}</code></span>
<span class="comment-copy">using Python 3.6.3</span>
<span class="comment-copy">make sure that the spaces are right - i.e. group_count should <i>not</i> be in the inner loop</span>
<span class="comment-copy">I got what I need from your answer. Perfect! Thanks @uvgroovy</span>
