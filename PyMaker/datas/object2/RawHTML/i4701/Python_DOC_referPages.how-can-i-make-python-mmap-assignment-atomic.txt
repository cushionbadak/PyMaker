<div class="post-text" itemprop="text">
<p>How can I make python mmap assignment atomic? Nothing about atomic is said here: <a href="https://docs.python.org/3.0/library/mmap.html" rel="nofollow noreferrer">https://docs.python.org/3.0/library/mmap.html</a></p>
<pre><code>huge_list1 = [888 for _ in range(100000000)]
huge_list2 = [9999 for _ in huge_list1]
b1 = struct.pack("100000000I", *huge_list1)
b2 = struct.pack("100000000I", *huge_list1)

f = open('mmp', 'wb')
f.write(b1)
f.close()
f = open('mmp', 'r+')
m = mmap.mmap(f.fileno(), 0)
m[:]=b2
</code></pre>
<p>Immediately, I execute the following code in another process</p>
<pre><code>f = open('mmp', 'r')
m = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
mm = m[:]
l = struct.unpack("100000000I", mm)
set(l)
</code></pre>
<p>Then I am seeing {888, 9999}</p>
<p>Which means mmap is not atomic. Anyway to make it atomic?</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, you can't. File writes aren't atomic to begin with, whether done via mmap or write. Some filesystems, such as Tahoe-LAFS, do have a file put operation, but even there it's a matter of known completion, not atomic operation (chunks are stored individually). Atomicity of file content updates are frequently done with three methods:</p>
<ol>
<li><p>Using the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html" rel="nofollow noreferrer">rename</a> call, where you can be sure a name points to either the old or new file (Python's <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace" rel="nofollow noreferrer">Path.replace</a> might be more clear). This is the method used in e.g. <a href="http://www.qmail.org/man/man5/maildir.html" rel="nofollow noreferrer">maildir</a>.</p></li>
<li><p>Using <a href="https://docs.python.org/3/library/os.html#os.lockf" rel="nofollow noreferrer">file locks</a>. These are in general cooperative, meaning all programs that access the file must use the same locking method consistently. Sometimes this is not possible, for instance across some network filesystems. Due to this inconsistency, other lock methods such as <a href="https://pypi.python.org/pypi/filelock" rel="nofollow noreferrer">lock files</a> are also used - thus the "same method" requirement. </p></li>
<li><p>Using smaller accesses that are atomic due to underlying architecture, such as disk sectors. This is done e.g. in <a href="https://www.sqlite.org/atomiccommit.html" rel="nofollow noreferrer">SQLite's journal headers</a>. Notably the threshold is different with mmap because the memory page itself may be shared, allowing far finer granularity for atomic accesses (perhaps CPU word size or single byte). </p></li>
</ol>
<p>The topic is fairly complex. The key to combining any of these synchronization methods with mmap is <a href="https://docs.python.org/3/library/mmap.html#mmap.mmap.flush" rel="nofollow noreferrer">mmap.flush</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think it's a <code>mmap</code> problem - I'd bet that it happens because <code>f.close()</code> guarantess just that Python has sent the data to the underlying OS's buffer but that doesn't mean it has been actually written. Then when you open it again, and give the handle to <code>mmap</code>, you're still operating on the buffer.</p>
<p>You can try syncing the buffer before you close the file to ensure everything has been written:</p>
<pre><code>import os

f = open('mmp', 'wb')
f.write(b1)
f.flush()
os.fsync(f.fileno()) 
f.close()
</code></pre>
<p>Or better, just to let Python handle closing cleanly in case of an error:</p>
<pre><code>with open('mmp', 'wb') as f:
    f.write(b1)
    f.flush()
    os.fsync(f.fileno())
</code></pre>
<p>Although even <code>os.fsync()</code> is not a 100% guarantee, from the underlying <code>fsync()</code> man page:</p>
<blockquote>
<p>Calling fsync() does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit fsync() on a file descriptor for the directory is also needed. </p>
</blockquote>
<p>But I'd bet that it wouldn't do what you need in very rare edge cases.</p>
</div>
<span class="comment-copy">Not sure if there’s a way apart from the usual write-other-file-and-rename-over-top. I don’t suppose you could use a lock instead of having it be atomic?</span>
<span class="comment-copy">A nitpick - shoudn't the <code>b2</code> assignment be: <code>b2 = struct.pack("100000000I", *huge_list2)</code>? The way it's presented <code>9999</code> would not get into the file under any circumstances.</span>
<span class="comment-copy">Side note: <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">arrays</a> support the buffer interface as well as fromfile/tofile, and are more efficient for this data handling than struct.</span>
<span class="comment-copy">I think the questioner is running these code snippets at the same time.</span>
<span class="comment-copy">@user2357112 - The way I understood his question is that he has a problem that the data gets interspersed as his initial file write gets mixed with the <code>mmap</code> writing, which can be observed from an external process.</span>
