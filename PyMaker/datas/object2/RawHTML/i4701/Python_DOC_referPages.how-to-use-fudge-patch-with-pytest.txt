<div class="post-text" itemprop="text">
<p>I'm switching from <a href="http://nose.readthedocs.io/en/latest/" rel="nofollow noreferrer">nose</a> to <a href="https://docs.pytest.org/en/latest/" rel="nofollow noreferrer">pytest</a> and having problems using <a href="https://fudge.readthedocs.io/en/latest/" rel="nofollow noreferrer">fudge</a> to create mocks/fakes because <code>@fudge.patch</code> passes them into the test function but pytest interprets test function arguments as fixtures.</p>
<p>I'm wondering if pytest and fudge are fundamentally incompatible, or if there's a trick I'm missing. I prefer fudge to <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">mock</a> because it allows you to set up expectations more intuitively, all in one place before you test something, whereas mock splits things up by defining return values before the test and expected calls after.</p>
<p>With nose I could monkey-patch with a <code>fudge.Fake</code> like this:</p>
<pre><code>from datetime import datetime
from fudge import patch

def today():
    return datetime.utcnow()

def something():
    return today()

test_time = datetime(2018, 1, 1, 12, 34, 56)

@patch('today')
def test_something(fake_today):
    fake_today.expects_call().returns(test_time)
    result = something()
    assert result == test_time
</code></pre>
<p>Note how fudge lets you set expected calls and fake returns in one place, which I find more intuitive than the way mock does it.</p>
<p>However, using pytest this raises an exception because pytest interprets arguments to test functions as fixtures, and doesn't know a fixture called fake_today:</p>
<pre><code>test setup failed
file example.py, line 13
  @patch('today')
  def test_something(fake_today):
E       fixture 'fake_today' not found
&gt;       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, monkeypatch, pytestconfig, record_xml_attribute, record_xml_property, recwarn, tmpdir, tmpdir_factory
&gt;       use 'pytest --fixtures [testpath]' for help on them.
</code></pre>
<p>I could declare a <code>fake_today</code> as a fixture, but I don't think pytest checks expectations, and if it does then the fixture would always have the same expectations wherever it's used, which doesn't always make sense.</p>
<p>I could use the <code>monkeypatch</code> fixture in test functions to inject <code>Fake</code>s, but that's not as neat as using a decorator.</p>
<p>I could also define fixtures that return a <code>Fake</code> like this:</p>
<pre><code>@pytest.fixture
def request(monkeypatch):
    """
    Fake Session.request method so tests can mock expected REST requests.
    """
    fake_request = fudge.Fake()
    monkeypatch.setattr('requests.sessions.Session.request', fake_request)
    yield fake_request
    fudge.verify()
</code></pre>
<p>But you have to do that for every <code>Fake</code> you want to inject, which seems clunky.</p>
<p>Not sure what's the best way.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://github.com/fudge-py/fudge/issues/8#issuecomment-375919893" rel="nofollow noreferrer">this issue comment</a> fudge is not intended to be compatible with pytest.</p>
</div>
