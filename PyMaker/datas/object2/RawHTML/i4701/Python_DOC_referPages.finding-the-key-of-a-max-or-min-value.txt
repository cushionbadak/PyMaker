<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer"><code>max</code></a> and <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min</code></a> functions evaluate the <code>key</code> argument exactly once per element, which I infer from the documentation of <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="nofollow noreferrer"><code>list.sort</code></a> that they refer to (as well as an educated guess about their implementation):</p>
<blockquote>
<p>The key corresponding to each item in the list is calculated once and then used for the entire sorting process.</p>
</blockquote>
<p>This means that it should be safe to use a key function that does not always return the same output for a given input. But is it possible to retrieve the key of the max or min elegantly without a custom function or calling the key function again?</p>
<p>For a non-deterministic key, the following would not work:</p>
<pre><code>max_val = max(iterable, key=key)
max_key = key(max_val)
</code></pre>
<p>The same problem occurs with</p>
<pre><code>max_val = sorted(iterable, key=key)[0]
</code></pre>
<p>A custom function could be written like this:</p>
<pre><code>from itertools import tee
def max_and_key(iterable, *, key=None):
    i1, i2 = tee(iterable)
    max_val = max(k, -i, v for i, (k, v) in enumerate(zip(map(key, i1), i2)))
    return max_val[2], max_val[0]
</code></pre>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>tee</code></a> is necessary to make this work on arbitrary iterables, where the elements of the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> have to work on the same element of the iterable without interfering with each other. The <code>zip</code> ensures that the <code>tee</code> does not have to store more than one element at a time, for maximum laziness in evaluation. <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">Enumeration</a> ensures that for cases where the keys are the same but the values are different, the stability of the comparison is preserved in a manner consistent with the original functions:</p>
<blockquote>
<p>If multiple items are maximal [minimal], the function returns the first one encountered.</p>
</blockquote>
<p>Note the minus sign in the expression being maximized.</p>
<p>All in all, this function seems like massive overkill to retrieve something that is being computed already. Is there a better solution for this?</p>
<p>If there is no other way, at least this function has the same algorithmic complexity and general contract as <code>max</code>.</p>
<p>Tangent/bonus question: what is the adjective meaning "not returning the same result for the same inputs every time"? Non-deterministic is only a small subset of possibilities, and non-reentrant means something subtly different to my understanding.</p>
</div>
<div class="post-text" itemprop="text">
<p>For this you'll need to precompute the keys. It probably makes most sense to put the key/values in a tuple. However, you'll want to take care that <code>min</code>/<code>max</code>/<code>sort</code> only performs comparison on the key and not the value (otherwise if the value isn't comparable this will fail if there are duplicate keys):</p>
<pre><code>from operator import itemgetter

def max_with_key(iterable, key):
    """
    Returns a (max_key, max_value) tuple by applying max to the iterable with
    the given key. Useful in cases when the key function is non-deterministic
    and the original key used in the max operation is desired.

    &gt;&gt;&gt; from random import randint
    &gt;&gt;&gt; max_with_key([1, 2, 3], key=lambda _: randint(0, 10))
    (9, 3)
    &gt;&gt;&gt; max_with_key([1, 2, 3], key=lambda _: randint(0, 10))
    (8, 1)
    """
    prekeyed = ((key(x), x) for x in iterable)
    return max(prekeyed, key=itemgetter(0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about using tuples lexicographical orderings:</p>
<pre><code>max_key, max_val = max((key(val), val) for val in iterable)
</code></pre>
<p>If the values are not comparable, suggestion from <a href="https://stackoverflow.com/questions/49441923/finding-the-key-of-a-max-or-min-value/49441952?noredirect=1#comment85885784_49441952">comments</a>:</p>
<pre><code>max_key, _, max_val = max((key(val), -i, val) for i, val in enumerate(iterable))
</code></pre>
<p>If the result of the keyfunc is hashable:</p>
<pre><code>d = {key(x): x for x in iterable}  # note: last value wins for ties
max_key = max(d)
max_val = d[max_key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe this should also work:</p>
<pre><code>max(((key(x),x) for x in iterable),key=lambda kx:kx[0])
</code></pre>
</div>
<span class="comment-copy">Not sure what you mean about precomputing the keys. This seems perfectly lazy to me.</span>
<span class="comment-copy">A bit confusing the dual use of the name <code>key</code> here, but I get it after staring at it for a bit.</span>
<span class="comment-copy">Yes I guess the terminology is a little muddied. By precomputed, I meant that you computed the key yourself before <code>max</code>/<code>min</code>/<code>sorted</code> did for you (although note that it still does, but it is now deterministic always returning your "precomputed" key). You are correct though that the generator expression is still indeed lazy.</span>
<span class="comment-copy">@win Indeed, I've rewritten the code as a function, cleaned up some inline values and added docs. Hopefully that makes it more clear.</span>
<span class="comment-copy">I would definitely say <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm" rel="nofollow noreferrer">non-deterministic</a>. <a href="https://en.wikipedia.org/wiki/Reentrancy_%28computing%29" rel="nofollow noreferrer">Non-reentrant</a> is a different concept. It is typically more closely related with thread safety. If something is non-reentrant, it means that you can't pause its execution in the middle of it running and while paused run another copy of it. A common case of non-reentrant functions are ones that use global state (because then the two concurrent runnings of the function--one paused--may be mutating the same global state).</span>
<span class="comment-copy">Not stable when when keys are equal but values aren't. That's why I did the enumeration. Couldn't think of any other way to break key ties.</span>
<span class="comment-copy">I think the solution using <code>itemgetter</code> is more elegant though.</span>
<span class="comment-copy">I think you should get rid of the first option entirely. It won't be correct for incomparable values but also for something like <code>key=lambda 1</code></span>
<span class="comment-copy">Still cuts all the crap out of my proposal though.</span>
<span class="comment-copy">I will leave it because incomparable values seems an edge case that other readers will possibly not have, and they should prefer the simpler code.  Further, using <code>key=lambda: 1</code> seems like a useless thing to do in the first place.</span>
<span class="comment-copy">While true, this is just a less elegant phrasing of the accepted answer posted about an hour ago.</span>
<span class="comment-copy">Agreed, but it does avoid the need to import another module if anyone cares about that.</span>
<span class="comment-copy">If used frequently enough on large enough data, there is no module import that will ever outweigh the benefit of using <code>itemgetter</code> in a key. +1 for giving an acceptable reason though.</span>
