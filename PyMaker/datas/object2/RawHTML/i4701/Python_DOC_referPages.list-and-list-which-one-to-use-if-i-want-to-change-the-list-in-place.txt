<div class="post-text" itemprop="text">
<p>I want to reverse a list from the kth element IN PLACE and here's my code:</p>
<pre><code>list[:] = list[len(list) - k:] + list[:len(list) - k]
</code></pre>
<p>I know that this is the right code while the following code is incorrect. Anyone know why?</p>
<pre><code>list = list[len(list) - k:] + list[:len(list) - k]
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The difference is a reflection of the assignment syntax as specified in the <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">python language reference</a>. Your first example generates a modified copy of the list and sets the contents of your list to the contents of the copy. The second example generates a modified copy and assigns the <code>list</code> identifier to point to that copy.</p>
<p>You can see this more clearly by calling <code>id</code> on your list before and after:</p>
<pre><code>id(list)
list[:] = list[len(list) - k:] + list[:len(list) - k]
id(list)  # prints the same id as above

id(list)
list = list[len(list) - k:] + list[:len(list) - k]
id(list)  # prints a new id representing a new list object
</code></pre>
<p>In the second case, <code>list</code> has a different id because it actually represents a new list object, where the first reuses the <code>list</code> and only updates the contents.</p>
<p>With that being said, notice that in both cases a copy of the list is being made so you aren't really gaining anything. Neither update is truly being calculated in-place. For this reason, in 99% of cases I would go with the second more concise syntax.</p>
<p>Furthermore the 'in place' version involves updating potentially many elements within the list, where just updating the <code>list</code> identifier is always a single update. You can see the small performance overhead from the extra copy work with the following experiments:</p>
<pre><code>$ python -m timeit 'x=range(100000); x[:]=x[::-1]'
100 loops, best of 3: 3.62 msec per loop
$ python -m timeit 'x=range(100000); x=x[::-1]'
100 loops, best of 3: 2.62 msec per loop

$ python -m timeit 'x=range(10); x[:]=x[5:] + x[:5]'
1000000 loops, best of 3: 1.31 usec per loop
$ python -m timeit 'x=range(10); x=x[5:] + x[:5]'
1000000 loops, best of 3: 1.02 usec per loop
</code></pre>
</div>
<span class="comment-copy">honestly I would probably do the second. I don't think there is any difference in this case.</span>
<span class="comment-copy">I get the same result as list and list[:] what is the result you get?</span>
<span class="comment-copy">The first snippet modifies the list in-place, while the 2nd snippet creates a new list. So obviously the first one is the correct choice.</span>
<span class="comment-copy">its not exactly obvious why this is the case, thats the whole reason the question was asked!</span>
