<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6618515/sorting-list-based-on-values-from-another-list">Sorting list based on values from another list?</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/12814667/how-to-sort-a-list-according-to-another-list">How to sort a list according to another list?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Let's say currently i have a list with:</p>
<pre><code>L = [[1,'JAYCE'],[2,'AMIE'],[3,'JACK'],[4,'STEVE'],[5,'JAYCE']]
</code></pre>
<p>and i have another list which contains the names sorted in order:</p>
<pre><code>sortedNames = ['AMIE','JACK','JAYCE','JAYCE','STEVE']
</code></pre>
<p>The output I want to get is, based on the sorted names list, i want to add the ID back to the names in the sorted order which is based off the sortedNames list.</p>
<pre><code>finalist = [[2,'AMIE'],[3,'JACK'],[1,'JAYCE'],[5,'JAYCE'],[4,'STEVE']]
</code></pre>
<p>Note that Jayce appeared twice so even if the first occurrence of Jayce has 5, followed by 1, its totally fine too.</p>
<p>I've been thinking of something like:</p>
<pre><code>L = [[1,'JAYCE'],[2,'AMIE'],[3,'JACK'],[4,'STEVE'],[5,'JAYCE']]
sortedNames = ['AMIE','JACK','JAYCE','JAYCE','STEVE']

finalist = []
for i in sortedNames:
    j = 0
    if i in L[j][1]:
        finalist.append(L[0] + i)
    j+=1

print(finalist)
</code></pre>
<p>I'm getting an error saying: </p>
<pre><code>TypeError: can only concatenate list (not "str") to list
</code></pre>
<p>I'm definitely appending it wrong. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">sorted()</a> function to do this, and lookup the position of the stored name using its <code>key</code> argument:</p>
<pre><code>finalList = sorted(L, key=lambda x: sortedNames.index(x[1]))
</code></pre>
<p>Which results in:</p>
<pre><code>[[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, as long as your data is well behaved, you could group your numbers into deques using a defaultdict:</p>
<pre><code>In [14]: from collections import defaultdict, deque

In [15]: grouper = defaultdict(deque)

In [16]: for a,b in L:
    ...:     grouper[b].append(a)
    ...:
</code></pre>
<p>Then simply:</p>
<pre><code>In [17]: grouper
Out[17]:
defaultdict(collections.deque,
            {'AMIE': deque([2]),
             'JACK': deque([3]),
             'JAYCE': deque([1, 5]),
             'STEVE': deque([4])})

In [18]: [[grouper[x].popleft(), x] for x in sortedNames]
Out[18]: [[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
<p>I realize it is an ugly wart to use <code>pop</code> inside a list comprehension...</p>
<p>Here's an approach using only <code>dict</code> and <code>list</code>:</p>
<pre><code>In [19]: grouper = {}
    ...: for a,b in L:
    ...:     grouper.setdefault(b, []).append(a)
    ...:

In [20]: grouper = {k:v[::-1] for k, v in grouper.items()}

In [21]: [[grouper[x].pop(), x] for x in sortedNames]
Out[21]: [[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
<p>Both approaches are O(N). </p>
<p><h3>Edit</h3> I just realized that what you <em>really</em> want is instead of generating a list of sorted names, just sort <code>L</code> using a key directly:</p>
<pre><code>In [26]: L
Out[26]: [[1, 'JAYCE'], [2, 'AMIE'], [3, 'JACK'], [4, 'STEVE'], [5, 'JAYCE']]

In [27]: from operator import itemgetter

In [28]: sorted(L, key=itemgetter(1))
Out[28]: [[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dictionary by grouping each name to a listing of all the IDs found for the name. Then, <code>next</code> can be applied.</p>
<pre><code>import itertools
L = [[1,'JAYCE'],[2,'AMIE'],[3,'JACK'],[4,'STEVE'],[5,'JAYCE']]
new_l = {a:iter([c for c, _ in b]) for a, b in itertools.groupby(sorted(L, key=lambda x:x[-1]), key=lambda x:x[-1])}
sortedNames = ['AMIE','JACK','JAYCE','JAYCE','STEVE']
final_data = [[next(new_l[i]), i] for i in sortedNames]
</code></pre>
<p>Output:</p>
<pre><code>[[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
<p><strong>Edit:</strong></p>
<p>It is also possible to utilize <code>sorted</code>:</p>
<pre><code>L = [[1,'JAYCE'],[2,'AMIE'],[3,'JACK'],[4,'STEVE'],[5,'JAYCE']]
sortedNames = ['AMIE','JACK','JAYCE','JAYCE','STEVE']
new_result = sorted(L, key=lambda x:(sortedNames.index(x[-1]), x[0]))
</code></pre>
<p>Output:</p>
<pre><code>[[2, 'AMIE'], [3, 'JACK'], [1, 'JAYCE'], [5, 'JAYCE'], [4, 'STEVE']]
</code></pre>
</div>
<span class="comment-copy">Can you just sort <code>L</code> on the names?</span>
<span class="comment-copy"><code>sorted</code> take a key argument <code>sorted([[1,'JAYCE'],[2,'AMIE'],[3,'JACK'],[4,'STEVE'],[5,'JAYCE']], key=lambda x: x[1])</code></span>
<span class="comment-copy">@f5r5e5d, why not sort the list in place with its own method?</span>
<span class="comment-copy"><code>L.sort(key=lambda x: x[1])</code> works too.  the <code>.append()</code> can be fixed by wrapping <code>i</code> in a list: <code>finalist.append(L[0] + [i])</code></span>
<span class="comment-copy">And another.. <a href="https://stackoverflow.com/q/12814667/2823755">How to sort a list according to another list</a></span>
