<div class="post-text" itemprop="text">
<p>Suppose I have a list of elements:</p>
<pre><code>my_list = ['CatA', 'CatB', 'CatC', 'CatA', 'CatA', 'CatC']
</code></pre>
<p>and I want to convert this list to a list of indexes of unique elements.</p>
<p>So <code>CatA</code> is assigned to index 0, <code>CatB</code> to index 1 and <code>CatC</code> to index 2.</p>
<p>My desired result would be:</p>
<pre><code>result = [0, 1, 2, 0, 0, 2]
</code></pre>
<p>Currently I'm doing this by creating a dictionary that assigns to each element it's unique <code>id</code> and then using a list comprehension to create the final list of indexes:</p>
<pre><code>unique_classes = np.unique(my_list)
conversion_dict = dict(unique_classes, range(len(unique_classes))
result = [conversion_dict[i] for i in my_list]
</code></pre>
<p>My question is: Is there an easier and straightforward way of doing this?</p>
<p>I am thinking about having a big list of categories so it needs to be efficient but preventing me to manually create the unique list, the dictionary and the list comprehension.</p>
</div>
<div class="post-text" itemprop="text">
<p>As suggested by @mikey, you can use <code>np.unique</code>, as below:</p>
<pre><code>import numpy as np

my_list = ['CatA', 'CatB', 'CatC', 'CatA', 'CatA', 'CatC']

res = np.unique(my_list, return_inverse=True)[1]
</code></pre>
<p>Result:</p>
<pre><code>[0 1 2 0 0 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will do the trick:</p>
<pre><code>my_list = ['CatA', 'CatB', 'CatC', 'CatA', 'CatA', 'CatC']
first_occurances = dict()
result = []

for i, v in enumerate(my_list):
    try:
        index = first_occurances[v]
    except KeyError:
        index = i
        first_occurances[v] = i
    result.append(index)
</code></pre>
<p>Complexity will be <em>O(n)</em>.</p>
<p>Basically what you do is storing in <code>dict</code> indexes of first value occurance. If <code>first_occurances</code> don't have value <code>v</code>, then we save current index <code>i</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by using Label encoder from scikit learn.It will assign labels to each unique values in a list. </p>
<p>Example code : </p>
<pre><code>from sklearn.preprocessing import LabelEncoder
my_list = ['CatA', 'CatB', 'CatC', 'CatA', 'CatA', 'CatC']
le = LabelEncoder()
print(le.fit(my_list).transform(my_list))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>result = [my_list.index(l) for l in my_list]
print(result)
[0, 1, 2, 0, 0, 2]
</code></pre>
<p>list.index() returns the index of first occurrence as required for your task.</p>
<p>For more details check <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer">list.index()</a></p>
</div>
<span class="comment-copy">numpy.unique is a method for this (I donâ€™t remember which kwarg has to be set to True but it is in the numpy docs).</span>
<span class="comment-copy">Yes, I like this solution. I didn't know about this option in np.unique</span>
<span class="comment-copy">Downvotes, can you also tell what is wrong with the answer and why this answer is not usefull?:)</span>
<span class="comment-copy">Yup, but this is pretty inneficient</span>
