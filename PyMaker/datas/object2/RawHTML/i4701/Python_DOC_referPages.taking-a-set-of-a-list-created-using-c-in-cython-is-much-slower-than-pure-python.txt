<div class="post-text" itemprop="text">
<p>In this example, I show two different methods for creating a list of strings using Cython. One uses an array of char pointers (and the <code>strcpy</code> C function) and the other by simply appending elements to a list.</p>
<p>I then pass each of these lists into the <code>set</code> function and see that performance is drastically different.</p>
<p><strong>Question</strong> - What can I do to create the list using character pointers to have equal performance?</p>
<p>A simple function to create lists in Cython</p>
<pre><code>from libc.string cimport strcpy

def make_lists():
    cdef:
        char c_list[100000][3]
        Py_ssize_t i
        list py_list = []

    for i in range(100000):
        strcpy(c_list[i], 'AB')
        c_list[i][2] = b'\0'
        py_list.append(b'AB')

    return c_list, py_list
</code></pre>
<p>Here, <code>c_list</code> is just an array of 3-length characters. Cython will return this object as a Python list. <code>py_list</code> is just a normal Python list. We are filling both lists with just a single sequence of bytes, 'AB'.</p>
<h3>Create the lists</h3>
<pre><code>c_list, py_list = make_lists()
</code></pre>
<h3>Print out some of the contents</h3>
<pre><code>&gt;&gt;&gt; c_list[:10]
[b'AB', b'AB', b'AB', b'AB', b'AB', b'AB', b'AB', b'AB', b'AB', b'AB']
</code></pre>
<h3>Show both lists are equal</h3>
<pre><code>&gt;&gt;&gt; c_list == py_list
True
</code></pre>
<h3>Time operations - this is insane to me! 3x difference</h3>
<pre><code>%timeit set(c_list)
2.85 ms ± 115 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit set(py_list)
1.02 ms ± 26 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<h3>Unicode and pure python</h3>
<p>Interestingly, the performance difference vanishes if I decode each value to unicode, though it is slower than the original <code>set(py_list)</code>. If I create a unicode list in pure Python then I am back to the original performance.</p>
<pre><code>c_list_unicode = [v.decode() for v in c_list]
py_list_unicode = [v.decode() for v in py_list]
py_list_py = ['AB' for _ in range(len(py_list))]

%timeit set(c_list_unicode)
1.63 ms ± 56.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%timeit set(py_list_unicode)
1.7 ms ± 35.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%timeit set(py_list_py)
987 µs ± 45.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<h3>Even simpler example</h3>
<pre><code>def make_lists2():
    cdef:
        char *c_list[100000]
        Py_ssize_t i
        list py_list_slow = []
        list py_list_fast = []

    for i in range(100000):
        c_list[i] = 'AB'
        py_list_slow.append(c_list[i])
        py_list_fast.append(b'AB')

    return c_list, py_list_slow, py_list_fast
</code></pre>
<p>Timings</p>
<pre><code>c_list2, py_list_slow, py_list_fast = make_lists2()

%timeit set(c_list2)
3.01 ms ± 137 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit set(py_list_slow)
3.05 ms ± 168 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit set(py_list_fast)
1.08 ms ± 38.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p><strong>edit</strong></p>
<h3>Possible solution</h3>
<p>I found the function <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_InternFromString" rel="nofollow noreferrer"><code>PyUnicode_InternFromString</code></a> in the unicode Python C API and am getting performance on par with regular python lists. This 'interns' the string - not sure what that means</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>c_list</code> is a list of 100000 distinct bytestrings with the same contents. Cython has to convert each <code>char[3]</code> to a bytestring separately, and it doesn't bother to do any object deduplication.</p>
<p>Your <code>py_list</code> is a list of the same bytestring object 100000 times. Every <code>py_list.append(b'AB')</code> appends the same object to <code>py_list</code>; without the trip through a C array, Cython never needs to copy the bytestring.</p>
<p><code>set(c_list)</code> is slower than <code>set(py_list)</code> because <code>set(c_list)</code> has to actually perform string comparison, while <code>set(py_list)</code> gets to skip that with an object identity check.</p>
</div>
<span class="comment-copy">This has little to do with <code>cython</code>. You are comparing the performance making a set from a list versus a general buffer (coming from C world). I would actually expect that performance drop. With your unicode example you are converting everything to python lists, hence the performance gap vanishes.</span>
<span class="comment-copy">But, both objects are Python lists, since I am taking the set in pure python. I'm guessing their underlying memory allocation is vastly different.  Also, after conversion to unicode, the lists are still 2x as slow as the pure python unicode list.</span>
<span class="comment-copy">Could be. Converting from python list to python set should be more optimised than a list created externally. There might also be some safe-guarding happening in the latter case.</span>
<span class="comment-copy">This sounds almost certainly like it's because <code>c_list</code> is a list of different bytestrings and <code>py_list</code> is a list of 100000 references to the same bytestring. I don't have Cython installed, so I can't confirm.</span>
<span class="comment-copy">Also, doesn't <code>strcpy</code> copy the null terminator for you?</span>
<span class="comment-copy">Thank you for the explanation. Can you show repost my 'even simpler example' with the function <code>PyUnicode_InternFromString</code> and the new timings to show that they are now identical.</span>
