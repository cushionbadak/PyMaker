<div class="post-text" itemprop="text">
<p>I have created my custom exceptions as such within <code>errors.py</code></p>
<pre><code>mapper = {
    'E101':
    'There is no data at all for these constraints',
    'E102':
    'There is no data for these constraints in this market, try changing market',
    'E103':
    'There is no data for these constraints during these dates, try changing dates',
}


class DataException(Exception):
    def __init__(self, code):
        super().__init__()
        self.msg = mapper[code]

    def __str__(self):
        return self.msg
</code></pre>
<p>Another function somewhere else in the code raises different instances of <code>DataException</code> if there is not enough data in a <code>pandas</code> dataframe. I want to use <code>unittest</code> to ensure that it returns the appropriate exception with its corresponding message.</p>
<p>Using a simple example, why does this not work:</p>
<pre><code>from .. import DataException
def foobar():
    raise DataException('E101')

import unittest
with unittest.TestCase.assertRaises(DataException):
    foobar()
</code></pre>
<p>As suggested here: <a href="https://stackoverflow.com/questions/35490843/python-assertraises-on-user-defined-exceptions">Python assertRaises on user-defined exceptions</a></p>
<p>I get this error:</p>
<pre><code>TypeError: assertRaises() missing 1 required positional argument: 'expected_exception'
</code></pre>
<p>Or alternatively:</p>
<pre><code>def foobar():
    raise DataException('E101')

import unittest
unittest.TestCase.assertRaises(DataException, foobar)
</code></pre>
<p>results in:</p>
<pre><code>TypeError: assertRaises() arg 1 must be an exception type or tuple of exception types
</code></pre>
<p>Why is it not recognizing <code>DataException</code> as an <code>Exception</code>? Why does the linked stackoverflow question answer work without supplying a second argument to <code>assertRaises</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to use methods of the <code>TestCase</code> class without creating an instance; those methods are not designed to be used in that manner.</p>
<p><code>unittest.TestCase.assertRaises</code> is an <em>unbound method</em>. You'd use it in a test method on a <code>TestCase</code> class you define:</p>
<pre><code>class DemoTestCase(unittest.TestCase):
    def test_foobar(self):
        with self.assertRaises(DataException):
            foobar()
</code></pre>
<p>The error is raised because unbound methods do not get <code>self</code> passed in. Because <code>unittest.TestCase.assertRaises</code> expects both <code>self</code> and a second argument named <code>expected_exception</code> you get an exception as <code>DataException</code> is passed in as the value for <code>self</code>.</p>
<p>You do now have to use a test runner to manage your test cases; add</p>
<pre><code>if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>at the bottom and run your file as a script. Your test cases are then auto-discovered and executed.</p>
<p>It is technically possible to use the assertions outside such an environment, see <a href="https://stackoverflow.com/questions/18084476/is-there-a-way-to-use-python-unit-test-assertions-outside-of-a-testcase">Is there a way to use Python unit test assertions outside of a TestCase?</a>, but I recommend you stick to creating test cases instead.</p>
<p>To further verify the codes and message on the raised exception, assign the value returned when entering the context to a new name with <code>with ... as &lt;target&gt;:</code>; the context manager object captures the raised exception so you can make assertions about it:</p>
<pre><code>with self.assertRaises(DataException) as context:
    foobar()

self.assertEqual(context.exception.code, 'E101')
self.assertEqual(
    context.exception.msg,
    'There is no data at all for these constraints')
</code></pre>
<p>See the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow noreferrer"><code>TestCase.assertRaises()</code> documentation</a>.</p>
<p>Last but not least, consider using <em>subclasses</em> of <code>DataException</code> rather than use separate error codes. That way your API users can just catch one of those subclasses to handle a specific error code, rather than having to do additional tests for the code and re-raise if a specific code should not have been handled there.</p>
</div>
<span class="comment-copy">Defining specific subclasses of <code>DataException</code> seems more Pythonic than effectively just wrapping instances around <code>mapper.get</code>. Cf. the various <a href="https://docs.python.org/3/library/exceptions.html#os-exceptions" rel="nofollow noreferrer">subclasses of <code>OSError</code></a> in Python 3, which previously were different <i>instances</i> of <code>OSError</code> distinguished by their <code>errno</code> attributes.</span>
<span class="comment-copy">Ah I see. Thanks! And how would I go about testing that the correct error message is being returned? I.e. checking that a given function returns DataException('E102') and not DataException('E103')</span>
<span class="comment-copy">@Ludo: See the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow noreferrer"><code>assertRaises()</code> documentation</a>; the context manager stores the exception raised and you can then make further assertions on it.</span>
