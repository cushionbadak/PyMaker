<div class="post-text" itemprop="text">
<pre><code>my_dic={"Vajk":"vékony","Bibi":'magas'}
my_dic['Bibi']
'magas'
</code></pre>
<p>We can see, that we need the ' to refer to the value for key 'Bibi'. But if want to use the same format in .format(), it gives this error:</p>
<pre><code>print("úgy érzem, hogy Bibi nagyon {0['Bibi']}".format(my_dic))
Traceback (most recent call last):

  File "&lt;ipython-input-109-52760dad9136&gt;", line 1, in &lt;module&gt;
    print("úgy érzem, hogy Bibi nagyon {0['Bibi']}".format(my_dic))

KeyError: "'Bibi'"
</code></pre>
<p>I have to use the reference without ', then it works.</p>
<pre><code>print("úgy érzem, hogy Bibi nagyon {0[Bibi]}".format(my_dic))
úgy érzem, hogy Bibi nagyon magas
</code></pre>
<p>Why doesn't the first work, and why does the second? It should be the opposite, first should work, and second shouldn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, some terminology:</p>
<ul>
<li><p><code>'Bibi'</code> is a <em>string literal</em>, syntax to create a string value. Your keys are strings, and using a string literal you can specify one of those keys.</p>
<p>You could use a variable instead; assign as string value to a variable and use the variable to get an item from your dictionary:</p>
<pre><code>foo = 'Bibi'  # or read this from a file, or from a network connection
print(my_dic[foo])  # -&gt; magas
</code></pre></li>
<li><p>In string formatting, the <code>{...}</code> are <em>replacement fields</em>. The <code>str.format()</code> method provides values for the replacement fields.</p></li>
<li><p>The <code>0[Bidi]</code> part in the <code>{...}</code> replacement field syntax is the <em>field name</em>. When you use <code>[...]</code> in a field name, it is a compound field name (there are multiple parts). The <code>[...]</code> syntax is usually referred to as indexing.</p></li>
</ul>
<p>The format used in field names is deliberately kept simple, and is only Python-<em>like</em>. The syntax is simplified to limit what it can be used for, to constrain the functionality to something that is <em>usually</em> safe to use.</p>
<p>As such, if you use a compound name with getitem <code>[...]</code> indexing syntax, names are treated as strings, but you don't use quotes to create the string. You could not pass in a variable name anyway, there is no need to contrast between <code>'name'</code> (a string) and <code>name</code> (a variable). </p>
<p>In other words, in a Python expression, <code>my_dic[foo]</code> works by looking up the value of the variable <code>foo</code>, and that is a different concept from using a string literal like <code>my_dic['Bidi']</code>. But you <em>can't use variables in a field name</em>, in a <code>str.format()</code> operation, using <code>{0[foo]}</code> should never find the variable <code>foo</code>.</p>
<p>The original <a href="https://www.python.org/dev/peps/pep-3101/#simple-and-compound-field-names" rel="nofollow noreferrer">proposal to add the feature</a> explains this as:</p>
<blockquote>
<p>Unlike some other programming languages, you cannot embed arbitrary expressions in format strings. This is by design - the types of expressions that you can use is deliberately limited. Only two operators are supported: the '.' (getattr) operator, and the '[]' (getitem) operator. The reason for allowing these operators is that they don't normally have side effects in non-pathological code.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>It should be noted that the use of 'getitem' within a format string is much more limited than its conventional usage. In the above example, the string 'name' really is the literal string 'name', not a variable named 'name'. The rules for parsing an item key are very simple. If it starts with a digit, then it is treated as a number, otherwise it is used as a string.</p>
</blockquote>
<p>Keeping the syntax simple makes templates more secure. From the <a href="https://www.python.org/dev/peps/pep-3101/#security-considerations" rel="nofollow noreferrer"><em>Security Considerations</em> section</a>:</p>
<blockquote>
<p>Barring that, the next best approach is to ensure that string formatting has no side effects. Because of the open nature of Python, it is impossible to guarantee that any non-trivial operation has this property. What this PEP does is limit the types of expressions in format strings to those in which visible side effects are both rare and strongly discouraged by the culture of Python developers.</p>
</blockquote>
<p>Permitting <code>{0[foo]}</code> to look up variables in the current scope could easily produce side effects, while treating <code>foo</code> as a string instead means you can know, with certainty, that it'll always be the string <code>'foo'</code> and not something else.</p>
<p>If you are <em>only</em> using string literals and not dynamic values (so <code>'some {} template'.format(...)</code> and not <code>some_variable.format(...)</code>, and you are using Python 3.6 or newer, you can use <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-pep498" rel="nofollow noreferrer"><em>formatted string literals</em></a> instead, as you can then use full Python expressions:</p>
<pre><code>print(f"úgy érzem, hogy Bibi nagyon {my_dic['Bibi']}")
</code></pre>
<p>In an <code>f</code> string, you use actual Python expressions instead of field names, so you use quotes again to pass in a string literal. Because they are string literals, they are evaluated right where they are defined, and you as a developer can see what local variables are available, so presumably you know how to keep that secure.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>It should be the opposite, first should work, and second shouldn't.</p>
</blockquote>
<p>No, it shouldn't because <code>'Bibi'</code> inside a double quoted string is a quoted string not just <code>Bibi</code>. You can check this simply as following:</p>
<pre><code>In [51]: "'Bibi'" == "Bibi"
Out[51]: False
</code></pre>
<p>If in first case the key was <code>"'Bibi'"</code> Then it'd worked perfectly:</p>
<pre><code>In [49]: my_dic={"Vajk":"vékony","'Bibi'":'magas'}

In [50]: print("úgy érzem, hogy Bibi nagyon {0['Bibi']}".format(my_dic))
úgy érzem, hogy Bibi nagyon magas
</code></pre>
<p>The reason that why it doesn't accept <code>"Bibi"</code> in first case and doesn't give you a the expected result is that Python looks for everything between brackets in dictionary and in this case you have <code>"'Bibi'"</code> inside the brackets not <code>'Bibi'</code>.</p>
</div>
<span class="comment-copy">Because placeholder references are not Python syntax. They are <i>Python-like</i>, and aimed at template writers.</span>
<span class="comment-copy">Just to clarify: <code>'</code> is a quote. <code>'value'</code> is a <i>string literal</i>. You could also use variables to get your value: <code>foo = 'Bibi'</code> and <code>my_dic[foo]</code>.</span>
