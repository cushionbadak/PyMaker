<div class="post-text" itemprop="text">
<p>Hi friends I want to perform an operation I believe I can solve this with map.</p>
<p>The following operation is actually working correctly. But I want to do something a bit different.</p>
<p>18 will be 19 when it increases. But when the next value comes, it will now be collected with 19.</p>
<p>in this example, the output I want is:</p>
<pre><code>&gt;&gt; [18,18,18,19,19,21]
</code></pre>
<p>This is what I can do:</p>
<pre><code>def sum(x):
    return x+18

new_list = list(map(sum, [0,0,0,1,0,2]))

&gt;&gt; [18, 18, 18, 19, 18, 20]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about using the <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow noreferrer"><code>reduce</code></a> function which <em>is</em> present in 2.7?  <code>reduce</code> is often used in conjunction with <code>map</code> to aggregate lists after some number of map transformations.</p>
<p>Here's my 3.5 version of it, which should be close, if not identical to 2.7:</p>
<pre><code>startVal =  18
myList   =  [0,0,0,1,0,2]
accumulator = reduce((lambda x, y: ( x + [y + (0 if len(x) == 0 else x[-1])])), myList, [])  
[startVal + v for v in accumulator]

&gt;&gt; [18, 18, 18, 19, 19, 21]
</code></pre>
<p>I'm taking advantage of addition of lists (which concatenates) to append subsequent values to the empty list defined in the initializer.  There's a little conditional since you can't get the last entry of an empty list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying to do what you want with <code>map</code> will require adding some kind of "memory" to the function—it has to know what it's done so far, so it knows what to do next.</p>
<p>You <em>can</em> do this, either by using a closure, or by using a class with a <code>__call__</code> method. But there's an easier way.</p>
<p>What you're looking for is almost exactly the <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>accumulate</code></a> function. The only difference is that you want to supply a starting value. (And, of course, that <code>accumulate</code> isn't actually in the stdlib in 2.7; you need to get it off a backport on PyPI.)</p>
<p>You could handle that in three obvious ways:</p>
<ul>
<li><code>accumulate</code>, then add your starting value to each element.</li>
<li><code>chain</code> a starting value before the input, then <code>accumulate</code>, then <code>next</code> (or <code>islice</code>) to skip over the extra value in the output.</li>
<li>Take the "roughly equivalent" sample code in the <code>accumulate</code> docs and modify it to take a start value.</li>
</ul>
<p>Let's do the last one—it's probably the heaviest-weight option, but the one you can learn the most from, plus it'll work even in 2.7 without any backports:</p>
<pre><code>def accumulate(iterable, func=operator.add, start=0):
    'Return running totals'
    it = iter(iterable)
    total = start
    try:
        total += next(it)
    except StopIteration:
        return total
    yield total
    for element in it:
        total = func(total, element)
        yield total
</code></pre>
<p>Compare to the original code in the docs—all I did was add a new parameter, set <code>total = start</code>, and change the special handling for the first element or for empty iterables. You can obviously simplify things (if we have a start value, we don't even <em>need</em> special handling for empty input), or make things fancier (default to no start value instead of 0, so <code>accumulate</code> works for types that aren't interoperable with int just like the one in <code>itertools</code> does), etc., but this is a simple starting point.</p>
<p>And now:</p>
<pre><code>&gt;&gt;&gt; new_list = accumulate([0,0,0,1,0,2], start=18)
&gt;&gt;&gt; new_list
[18, 18, 18, 19, 18, 20]
</code></pre>
</div>
<span class="comment-copy">First, naming your function <code>sum</code>, and hiding the builtin of that name, is confusing.</span>
<span class="comment-copy">But meanwhile, I think what you want here is <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>accumulate</code></a>, not <code>map</code>. You do want to add a starting value, but there are two easy ways to do that: (1) chain the starting value onto the input before calling <code>accumulate</code> then skip over it in the output, or (2) copy the "roughly equivalent to" code in the docs and write your own version that takes a start value as an additional parameter.</span>
<span class="comment-copy">@abarnert: Though <code>itertools.accumulate</code> isn't an option here, since the OP is using 2.7 (<code>accumulate</code> was added in 3.2). So you'd need to use <code>map</code> and a stateful mapping function (e.g. a class implementing <code>__call__</code> that would maintain the running sum).</span>
<span class="comment-copy">@ShadowRanger Or you can just copy the <code>accumulate</code> "roughly equivalent" code from the 3.2 docs, which work in 2.7. (I was fooled by him explicitly calling <code>list(map(…))</code>, which is pointless in 2.7…)</span>
