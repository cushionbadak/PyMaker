<div class="post-text" itemprop="text">
<p>I have a Python class (it's not actually mine, it's from a package, so I don't want to edit this one). Minimal example (unrealistic):</p>
<pre><code>import os

class SuperClass:
    def __init__(self):
        # Do something, for example
        self.a = 0
        pass

    def from_file(filename):
        # Do something with the file,
        # use it to create superclass
        # instance obj. For example...
        obj = SuperClass()
        obj.a = os.stat(filename).st_size
        return obj
</code></pre>
<p>Now I want to create a subclass of this superclass, whose initialization always comes from a file -- that is, I want to do something like</p>
<pre><code>class SubClass(SuperClass):
    def __init__(self, filename):
        self = SuperClass.from_file(filename)
</code></pre>
<p>This doesn't work (I didn't expect it to): I don't get an exception but the subclass is not initialized correctly. For instance, if the <code>SuperClass</code> has some instance value <code>a</code>, which is always set, doing</p>
<pre><code>new_subclass_instance = SubClass('/filepath/file')
print(new_subclass_instance.a)
</code></pre>
<p>will give an <code>AttributeError: type object 'SubClass' has no attribute 'a'</code>.</p>
<p>How can I initialize using the <code>from_file</code> function from the parent class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>__init__</code> method is in reality not a <em>constructor</em>, it's just an <em>initializer</em>. That's why you cannot implement this behavior in the <code>__init__</code> method - once <code>__init__</code> is called, you already have a superfluous object instance floating around.</p>
<p>The method responsible for actually creating a new instance of the class is <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a>, so we can achieve our goal by overriding that. The basic idea is to write something like this:</p>
<pre><code>class SubClass(SuperClass):
    def __new__(cls, filename):
        return cls.from_file(filename)

    def __init__(self, *args, **kwargs):
        pass
</code></pre>
<p>The empty <code>__init__</code> is necessary because python will automatically call it on the object that's returned from <code>__new__</code>. If we omit the empty <code>__init__</code> method, python will end up calling <code>SuperClass.__init__</code> on the object instead, and that will reset all of its attributes. </p>
<p>There is, however, a problem: Since we've rewritten the <code>__new__</code> method so that it requires a <code>filename</code> argument, the <code>from_file</code> method probably no longer works. You haven't shown its code, but it probably does something along these lines:</p>
<pre><code>@classmethod
def from_file(cls, filename):
    obj = cls()
    obj.filename = filename
    return obj
</code></pre>
<p>The problem here is that the call to <code>cls()</code> will fail: This calls our <code>__new__</code> method, which expects a <code>filename</code> argument, without any arguments. We end up with an exception like <code>TypeError: __new__() missing 1 required positional argument: 'filename'</code>. To work around this, we can make the <code>filename</code> parameter optional:</p>
<pre><code>class SubClass(SuperClass):
    def __new__(cls, filename=None):
        if filename is None:
            return super().__new__(cls)
        return cls.from_file(filename)

    def __init__(self, *args, **kwargs):
        pass
</code></pre>
<p>Now we can call <code>obj = SubClass('/filepath/file')</code> as desired. <em>However</em>, it's also possible to call <code>SubClass</code> without any arguments (like <code>obj = SubClass()</code>), which will return a completely unitialized object instance (remember, our <code>__init__</code> is empty, so the object will have no attributes whatsoever). There is, unfortunately, nothing we can do about this.</p>
<p>Generally speaking, it's probably a bad idea to do this. As I'm sure you can tell by now, there are numerous pitfalls one has to watch out for when trying to change an existing class's interface like this. It's very possible that it's not worth the trouble and you should just stick to creating your instances with <code>SubClass.from_file</code>.</p>
</div>
<span class="comment-copy">Please edit your question and add the exception that you get. Also the code that you posted doesn't work, you forgot the <code>def</code> in the first class</span>
<span class="comment-copy">@FrancescoMontesano There is no exception. They're basically asking how to use the <code>from_file</code> method as the subclass's constructor.</span>
<span class="comment-copy">@FrancescoMontesano, as pointed out, I don't get an exception directly, but I've updated the question a bit to show where the failure lies.</span>
<span class="comment-copy">@MeesdeVries: I don't see the connection between the exception and the rest. What to you expect? <code>a</code> is not defined in the code, thus you get the error. If I try your code I get: <code>NameError: name 'obj' is not defined</code> when initializing <code>SubClass</code>. Also: are you sure that <code>from_file</code> is correct and that you are not forgetting a decorator?</span>
<span class="comment-copy">@FrancescoMontesano, what I posted is not meant as <i>actual code</i> just as an illustration. The comment lines in the superclass are a stand-in for actual code. In particular, in that code, <code>obj</code> will be constructed, and in both methods, the value <code>a</code> will be set. I could expand the code if that would make it clearer.  In other words, the point is that the superclass does not have an <code>__init__()</code> method that accepts a filename, it just has a class function which returns an instance initialized with data from a filename. In the subclass, I want to have an actual <code>__init__()</code> from filename.</span>
<span class="comment-copy">Thank you, this makes a lot of sense. If I now call <code>obj = SubClass('filepath/file')</code> am I correct in thinking that the subclass <code>__init__</code> still gets called, and with the same arguments (i.e. the file path)? And if so, if I want to do further subclass specific initialization, does it make the most sense to do that in the subclass's <code>__init__</code> method?</span>
<span class="comment-copy">@MeesdeVries Yes, that's absolutely correct; <code>__init__</code> will be called with the same arguments as <code>__new__</code>. But keep in mind that the <code>from_file</code> method will instantiate your class without any arguments, so if you plan to implement <code>__init__</code>, you'll have to make all its parameters optional. So if your <code>__init__</code> requires arguments, it's probably easier to do the initialization in <code>__new__</code> instead and leave <code>__init__</code> blank.</span>
<span class="comment-copy">I run into a further problem where the <code>SuperClass</code> actually has an <code>__init__</code> which <i>does</i> take a parameter, though not a filename, and in calling <code>cls.from_file(filename)</code> my new SubClass <code>__init__</code> gets called where it shouldn't. (At this point I'm perfectly ready to give up and just do it "the hard way", using the proper parent class constructor and just doing some stuff by hand. Maybe what I wanted to do was not worth the effort.)</span>
<span class="comment-copy">@MeesdeVries I'm a bit confused. The <code>SuperClass</code>'s <code>__init__</code> shouldn't matter, as long as you've correctly overridden it with an empty <code>__init__</code> in the subclass. The subclass's <code>__init__</code> being called after <code>cls()</code> or <code>cls.from_file(filename)</code> is expected and correct; that's why it's important that it's empty. But anyway, yes, it's certainly possible that trying to change a class's interface like this is more trouble than it's worth. As you can see, there are a lot of pitfalls.</span>
<span class="comment-copy">It seems that if one doesn't call <code>__new__</code> of <code>SuperClass</code>, the resulting type is not <code>SubClass</code>. <code>obj = SubClass('/filepath/file') ; print(type(obj))</code> the result is <code>SuperClass</code> other than the expected <code>SubClass</code>.</span>
