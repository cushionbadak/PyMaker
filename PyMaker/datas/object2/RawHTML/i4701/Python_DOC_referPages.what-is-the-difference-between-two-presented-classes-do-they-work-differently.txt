<div class="post-text" itemprop="text">
<p>What is the difference between this two implementations of Singleton. Does creating of variable _instance in parent class make it work differently from the second class?</p>
<pre><code>class SingletonA(object):
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = object.__new__(cls, *args, **kwargs)
        return cls._instance


class SingletonB(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            cls._instance = object.__new__(cls, *args, **kwargs)
        return cls._instance


# sample usage
class A(SingletonA):
    pass


print(A() == A()) #True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the code posted, there is no difference.</p>
<p>If your subclasses implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer"><code>__bool__</code></a> or <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noreferrer"><code>__len__</code></a> however, the first example will fail, as <code>not self._instance</code> could return <code>True</code> even when an instance has been set. You really want to use <code>if self._instance is None:</code> instead:</p>
<pre><code>&gt;&gt;&gt; class AlwaysFalse(object):
...     def __bool__(self): return False
...
&gt;&gt;&gt; if not AlwaysFalse():
...     print("It doesn't exist? Should we create a new one?")
...
It doesn't exist? Should we create a new one?
&gt;&gt;&gt; AlwaysFalse() is None
False
</code></pre>
<p>Other than that, the differences are cosmetic.</p>
<p>You also want to use identity testing to check if a singleton implementation work correctly; a subclass could implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="noreferrer"><code>__eq__</code> method</a> and return <code>True</code> even if the two objects are distinct (so not singletons):</p>
<pre><code>&gt;&gt;&gt; class EqualNotSingleton(object):
...     def __eq__(self, other): return True
...
&gt;&gt;&gt; EqualNotSingleton() == EqualNotSingleton()
True
&gt;&gt;&gt; EqualNotSingleton() is EqualNotSingleton()
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Agreed with @Martijin Pieters answer,</p>
<p>Besides, provide another way to implement Singleton, called Borg, which share the same state:</p>
<pre><code>class Borg:
    _shared_state = {}
    def __new__(cls, *args, **kwargs):
        obj = super(Borg, cls).__new__(cls, *args, **kwargs)
        obj.__dict__ = cls._shared_state
        return obj

class S1(Borg):
    pass

class S2(Borg):
    pass

assert S1() is not S1()
S1().v = 1
assert S1().v == S1().v
assert S1().v == S2().v


class S3(Borg):
    # if want to have a different state
    _shared_state = {}
    pass

S3().v = 2
assert S3().v != S1().v
</code></pre>
</div>
<span class="comment-copy">the second option creates the <code>_instance</code> variable when needed so it would be more space efficient to have it the second way. the run time may also be in favor of the second option since comparing a value to <code>True</code> (or <code>None</code>) takes more time than just finding the variable</span>
