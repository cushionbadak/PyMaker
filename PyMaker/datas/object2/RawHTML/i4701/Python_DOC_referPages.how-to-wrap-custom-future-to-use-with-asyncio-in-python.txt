<div class="post-text" itemprop="text">
<p>There is a lot of libraries that use their custom version of <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer">Future</a>. <a href="https://github.com/dpkp/kafka-python/blob/master/kafka/future.py" rel="nofollow noreferrer">kafka</a> and <a href="https://github.com/boto/s3transfer/blob/develop/s3transfer/futures.py" rel="nofollow noreferrer">s3transfer</a> are just two examples: all their custom future-like classes have <code>object</code> as the superclass.</p>
<p>Not surprisingly, you cannot directly call <code>asyncio.wrap_future()</code> on such objects and can't use <code>await</code> with them.</p>
<p>What is the proper way of wrapping such futures for use with asyncio?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the future class supports standard future features such as done callbacks and the <code>result</code> method, just use something like this:</p>
<pre><code>def wrap_future(f):
    loop = asyncio.get_event_loop()
    aio_future = loop.create_future()
    def on_done(*_):
        try:
            result = f.result()
        except Exception as e:
            loop.call_soon_threadsafe(aio_future.set_exception, e)
        else:
            loop.call_soon_threadsafe(aio_future.set_result, result)
    f.add_done_callback(on_done)
    return aio_future
</code></pre>
<p>Consider that code a template which you can customize to match the specifics of the future you are dealing with.</p>
<p>Intended usage is to call it from the thread that runs the asyncio event loop:</p>
<pre><code>value = await wrap_future(some_foreign_future)
</code></pre>
<p>If you are calling it from a different thread, be sure to pass <code>loop</code> explicitly because <code>asyncio.get_event_loop</code> will fail when invoked from a thread not registered with asyncio.</p>
</div>
<span class="comment-copy">If you want to use <code>kafka</code> or <code>s3transfer</code> -- perhaps you don't want to work with asyncio code. At least mixing <code>kafka</code> calls inside an executor with regular async program gives expectedly slow result. The same is for <code>s3transfer</code>. What you need is <code>aiokafka</code> and <code>aiobotocore</code> usage.</span>
<span class="comment-copy">We tried <code>aiokafka</code> 0.4.0 in the first place, but unfortunately it's way too buggy -- e.g., it just hangs in <code>position()</code> call or throws obscure exceptions. Just replacing it with <code>kafka</code> instantly solved all our problems.</span>
<span class="comment-copy">Also, there should be no problem mixing asyncio and foreign futures as long as the blocking calls are run outside the asyncio thread, and connected to asyncio using <code>call_soon_threadsafe</code> (shown in the answer) or <code>run_coroutine_threadsafe</code>.</span>
<span class="comment-copy">@kirill.shirokov sorry, I'm not Kafka expert. aiokarka is driven by my friend Taras. Sure, hi does the best and evolves the project fast. Please file a bug on github tracker if you've found a problem.</span>
