<div class="post-text" itemprop="text">
<p>I want to rewrite the following python code functionally:</p>
<pre><code>lst = [0.0] * 10
for pos in [2,5]:
    lst[pos] = 1.0
</code></pre>
<p>This is my attempt, but is incorrect:</p>
<pre><code>lst = (lambda zeros:
          map(
              lambda pos: zeros[pos] = 1.0, [2,5])
      )([0.0] * 10)
</code></pre>
<p>The error I get is <code>lambda cannot contain assignment</code>.</p>
<p>Using list comprehension, the solution is:</p>
<pre><code>lst = [ 1.0 if x in [2,5] else 0.0 for x in range(10) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I do prefer the list comprehension in your own answer, but if I were to do it with more of a functional touch, I think I would use a <code>lambda</code> function and a <code>map</code>:</p>
<pre><code>lazy = map(lambda element: 1 if element in [2,5] else 0, range(10))
</code></pre>
<p>Note that <code>map</code> is a lazy iterator in Python 3. If you want an evaluated <code>list</code> you have to enclose the line in an explicit <code>list(...)</code> constructor:</p>
<pre><code>lst = list(map(lambda element: 1 if element in [2,5] else 0, range(10)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The list comprehension method is probably better, but if you're looking for functional how about this:</p>
<pre><code>lst = [0.0] * 10
lst = map(lambda (i, x): 1.0 if i in {2,5} else x, enumerate(lst))
#[0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0]
</code></pre>
<p>By using <code>enumerate(lst)</code> as the iterable for <code>map()</code>, we get both the index and the value. In this case, we yield 0 if <code>i</code> is in <code>{2, 5}</code>. Otherwise we keep the value <code>x</code>.</p>
<p>If you're using python3, you have to wrap the call to <code>map()</code> with <code>list()</code>. However, that approach is <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer">not recommended</a> as it wastefully creates a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way you can do this is with generic function <code>unfold</code></p>
<pre><code>def unfold (f, acc):
  return f ( lambda x, next: [x] + unfold (f, next)
           , lambda x: [x] 
           , acc                          
           )

def main (ones):
  def value (i):
    return 1 if i in ones else 0   
  return unfold ( lambda next, done, i:
                    done (value (i)) if i &gt;= 10 else next (value (i), i + 1)
                , 0
                )

print (main ( { 2, 5 }))
# [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]
</code></pre>
<p><code>unfold</code> can be used in interesting ways</p>
<pre><code>def alphabet ():
  return unfold ( lambda next, done, c:
                    done (c)            
                      if c == 'z' else
                        next (c, chr (ord (c) + 1))
                , 'a'
                )

print (alphabet ())
# ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
</code></pre>
<p>Python's lambda syntax is really rigid its awkward ternary syntax make functional expressions painful to write. In the example below, we pre-define a function <code>gen</code> using some imperative syntaxes to help readability, then we pass it to <code>unfold</code> - this program also shows that <code>state</code> can be a complex value</p>
<pre><code>def fib (n):
  def gen (next, done, state):
    (n, a, b) = state
    if n == 0:
      return done (a)
    else:
      return next (a, (n - 1, b, a + b))
  return unfold (gen, (n, 0, 1))

print (fib (20))
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
</code></pre>
<p>Of course all of this pain exists for a reason - it's a signal indicating that we're doing something wrong. A seasoned python programmer would never write <code>main</code>, <code>alphabet</code>, or <code>fib</code> like we did above. So it's not <em>pythonic</em> (as they say), but it's <em>functional</em>, and hopefully that answers your question.</p>
<hr/>
<p>Below, we dramatically simplify <code>unfold</code> - instead of passing <code>next</code> and <code>done</code> helpers to the user lambda, we ask the user to return a tuple that encodes their choice: <code>(value, None)</code> says <code>value</code> is the last value in the sequence, <code>(value, nextState)</code> will produce the next value and continue with the next state.</p>
<p>The trade-off here is the <code>unfold</code> is a little less complicated, but it requires the user to know the special tuple signalling to write their program. Before, <code>next</code> and <code>done</code> kept this worry out of the user's mind. Either way is fine, I share this just to give another alternative</p>
<pre><code>def unfold (f, acc):
  (x, nextAcc) = f (acc)
  if nextAcc is None:
    return [x]
  else:
    return [x] + unfold (f, nextAcc)

def fib (n):
  def gen (state):
    (n, a, b) = state
    if n == 0:
      return (a, None)
    else:
      return (a, (n - 1, b, a + b))
  return unfold (gen, (n, 0, 1))

print (fib (20))
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
</code></pre>
</div>
<span class="comment-copy"><i>How</i> is it incorrect? Does it throw an exception or give the wrong answer? Either way, <b>include that in your question</b>.</span>
<span class="comment-copy"><code>lst = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0]</code> ;)</span>
<span class="comment-copy">Your list comprehension is more functional because it does not destroy the input. A very important component of functional programming is immutability and referential transparency. This assures expressions are interchangeable. Even in Haskell, list comprehensions are extremely handy and very functional.</span>
