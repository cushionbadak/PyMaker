<div class="post-text" itemprop="text">
<p>I tried using <code>dict.fromkeys([1,2,3],set())</code>. This initializes creates the dictionary but when I add a value to any one of the sets all the sets get updated!</p>
<pre><code>&gt;&gt;&gt; d=dict.fromkeys([1,2,3],set())
&gt;&gt;&gt; d
&gt;&gt;&gt; {1: set(), 2: set(), 3: set()}
&gt;&gt;&gt; d[1].add('a')
&gt;&gt;&gt; d
&gt;&gt;&gt; {1: {'a'}, 2: {'a'}, 3: {'a'}}
</code></pre>
<p>It seems that all the three values of the dictionary are referring to the same set. I want to initialize all the values of the dictionary to empty sets so that I can perform some operations on these sets in a loop based on the keys later.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Using dictionary comprehension </p>
<pre><code>d = {x: set() for x in [1, 2, 3]}
</code></pre>
<p>Or using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collections.defaultdict</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><strong><code>collections.defaultdict</code></strong></a></p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(set)
&gt;&gt;&gt; d[1].add('a')
&gt;&gt;&gt; d
defaultdict(&lt;class 'set'&gt;, {1: {'a'}})
&gt;&gt;&gt; d[2].add('b')
&gt;&gt;&gt; d
defaultdict(&lt;class 'set'&gt;, {1: {'a'}, 2: {'b'}})
</code></pre>
<p>The way it works, is, when you try to add a value to a key like <code>dict[key].add(value)</code>, it checks whether the key is present; if so, then it adds the value to the set. If it is not present the value is added as a <code>set</code> since the default is set  as a <code>set</code> (<code>defaultdict(set)</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You want a <a href="https://docs.python.org/dev/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> <strong>so you don't need to initialize the sets</strong> in the first place:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(set)
# That's it, initialization complete. Use goes like this:
&gt;&gt;&gt; d[1].add('a')
&gt;&gt;&gt; d[2].add('b')
&gt;&gt;&gt; d[3].add('c')
&gt;&gt;&gt; d
defaultdict(&lt;class 'set'&gt;, {1: {'a'}, 2: {'b'}, 3: {'c'}})
</code></pre>
</div>
<span class="comment-copy">See also <code>defaultdict</code> - you can create a dict that will automatically create an empty set for you for each new key.</span>
<span class="comment-copy">Great! That works. But I thought the <code>fromkeys()</code> should be doing the same thing. Can you explain whats going on in the case of <code>fromkeys()</code>.</span>
<span class="comment-copy"><code>set()</code> is only invoked <i>once</i> in the <code>fromkeys()</code> call. The DC calls it <i>each time</i>.</span>
<span class="comment-copy">Then I don't see the point of <code>fromkeys()</code> function other than maybe using it for the case where the initializing value is an atomic type like numeral or None.</span>
<span class="comment-copy">@Dhruv Precisely, if you want to have mutable values you usually use a <code>defaultdict</code> which saves you the trouble of initializing in the first place, or a dict comprehension if initialization is important in itself or depends on the keys.</span>
