<div class="post-text" itemprop="text">
<p>I have a base list <code>[1,4,10]</code> which needs to be converted to a list having consecutive elements of each element in the base list in an efficient way</p>
<p>Examples:</p>
<ul>
<li>If I need 2 consecutive numbers then <code>[1,4,10]</code> will be <code>[1,2,4,5,10,11]</code>.</li>
<li>If 3 consecutive numbers then <code>[1,4,10]</code> will be <code>[1,2,3,4,5,6,10,11,12]</code>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>arr=[1,4,10]
con=3
[r + i for r in arr for i in range(con)]
# [1, 2, 3, 4, 5, 6, 10, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one liner, assuming the list is x and the number of 'consecutives' is c:</p>
<pre><code>reduce(lambda a, b: a + b, map(lambda x: range(x, x+c), x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [1,4,10]
k = 3 #no of consecutive 
x=[range(b,b+k) for b in a]
output = [m for d in x for m in d]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way. <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain</code></a> removes the need for explicit nested loops.</p>
<pre><code>from itertools import chain

def consecutiver(lst, n=3):
    return list(chain.from_iterable(range(i, i+n) for i in lst))

res = consecutiver([1, 4, 10], 2)
# [1, 2, 4, 5, 10, 11]

res2 = consecutiver([1, 4, 10], 3)
# [1, 2, 3, 4, 5, 6, 10, 11, 12]
</code></pre>
</div>
<span class="comment-copy">and did you try writing anything yourself? How did that go?</span>
<span class="comment-copy">what should the answer be for [1,2,3] and 2 connectives?</span>
<span class="comment-copy">@Sam <code>[1, 2, 2, 3, 3, 4]</code> logically</span>
<span class="comment-copy">How is this answer specific to python 3.x?</span>
<span class="comment-copy">sorry is int -- i confused myself with change of range in python3 compared to range and xrange in python 2 -- in this case it doesnt make a difference. I'll edit the answer</span>
<span class="comment-copy">why use numpy instead of just <code>range</code> here?</span>
<span class="comment-copy">Yup we can use.. thanks</span>
<span class="comment-copy">The <code>chain.from_iterable</code> also accepts generators (so you can drop the <code>[]</code>). Not sure how this affects efficiency though. Nice answer.</span>
<span class="comment-copy">Seems overly complicated. Why are you making the <code>range</code> a list for instance? You can do this with no imports whatsoever... Since you've already given a working solution - then I had: <code>return [el for n in base for el in range(n, n+2)]</code> which'd be <code>return [el for val in lst for el in range(val, val + n)]</code></span>
<span class="comment-copy">Thanks for both your suggestions. Personally, I don't think there should be some kind of anti-import preference. If you look at the code for <code>itertools.chain</code>, it is a fairly trivial construct.</span>
<span class="comment-copy">Sure... I love <code>itertools.chain</code>... you just don't need it.... you also don't need the extra <code>()</code>s around the chain as you've got no other arguments (and can't provide any, anyway, so that'll at least make it look a little nicer)</span>
<span class="comment-copy">@jpp The only thing I have against imports for trivial tasks is that it does not promote effort. You get a sense that you do not have to learn the logic behind coding but simply to know which library to use.</span>
