<div class="post-text" itemprop="text">
<p>I am using a bunch class to transform a dict to an object.</p>
<pre><code>class Bunch(object):
    """ Transform a dict to an object """
    def __init__(self, kwargs):
        self.__dict__.update(kwargs)
</code></pre>
<p>The problem is , i have a key with a dot in its name({'test.this':True}).</p>
<p>So when i call:</p>
<pre><code>spam = Bunch({'test.this':True})
dir(spam)
</code></pre>
<p>I have the attibute:</p>
<pre><code>['__class__',
 '__delattr__',
...
 '__weakref__',
 'test.this']
</code></pre>
<p>But i can't access it:</p>
<pre><code>print(spam.test.this)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-7-ea63f60f74ca&gt; in &lt;module&gt;()
----&gt; 1 print(spam.test.this)

AttributeError: 'Bunch' object has no attribute 'test'
</code></pre>
<p>i got an AttributeError.</p>
<p>How can i access this attribute?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a>:</p>
<pre><code>&gt;&gt;&gt; getattr(spam, 'test.this')
True
</code></pre>
<p>Alternatively, you can get the value from the object's <code>__dict__</code>. Use <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer"><code>vars</code></a> to get <code>spam</code>'s dict:</p>
<pre><code>&gt;&gt;&gt; vars(spam)['test.this']
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Implement <a href="https://docs.python.org/3/reference/datamodel.html?emulating-container-types#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__(self, key)</code></a>:</p>
<pre><code>class D():
    def __init__(self, kwargs):
        self.__dict__.update(kwargs)

    def __getitem__(self, key):
        return self.__dict__.get(key)


d = D({"foo": 1, "bar.baz": 2})

print(d["foo"])
print(d["bar.baz"])
</code></pre>
<p><strong>Edit:</strong></p>
<p>I don't recommend accessing <code>d.__dict__</code> directly from a client of a <code>D</code> instance. Client code like this</p>
<pre><code>d = D({"foo": 1, "bar.baz": 2})
print(d.__dict__.get("bar.baz"))
</code></pre>
<p>is trying to reach into the underpants of <code>d</code> and requires knowledge about implementation details of <code>D</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A correct suggestion would be to avoid using dot in the variables.
And even if we use somehow, its better to get it using <strong>getattr</strong>.</p>
<pre><code>getattr(spam, 'test.this')
</code></pre>
<p>If we are being stubborn by avoid standards so this may help.</p>
<pre><code>class Objectify(object):
    def __init__(self, obj):
        for key in obj:
            if isinstance(obj[key], dict):
                self.__dict__.update(key=Objectify(obj[key]))
            else:
                self.__dict__.update(key=obj[key])


class Bunch(object):
    """ Transform a dict to an object """
    def __init__(self, obj, loop=False):
        for key in obj:
            if isinstance(obj[key], dict):
                self.__dict__.update(key=Objectify(obj[key]))
            else:
                self.__dict__.update(key=obj[key])


spam1 = Bunch({'test': {'this': True}})
print(spam1.test.this)

spam2 = Bunch({'test': {'this': {'nested_this': True}}})
print(spam2.test.this.nested_this)
</code></pre>
<p>Not provided <strong>test.this</strong> as the key. You may want to create a nested dict iterating through the keys having dots.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try spam["test.this"] or spam.get("test.this")</p>
</div>
<span class="comment-copy">Since it hasn't been said yet: The actual solution would be to avoid dots in variable names and using <code>snake_case</code> instead. Unless you don't have the option to rename the variable.</span>
<span class="comment-copy">@Arne I don't think dots must be avoided. There are valid uses cases for a class to behave like a dict and allow names that include dots.</span>
<span class="comment-copy">I like these answers, they use builtins.</span>
<span class="comment-copy">There is absolutely no reason why <code>__getitem__</code> should appear in this answer. The relevant part is <code>self.__dict__.get</code>. It doesn't have to be in <code>__getitem__</code>. I'd recommend removing that. It might confuse some people.</span>
<span class="comment-copy"><code>d.__dict__</code> should not be accessed by a client of a <code>D</code> instance.</span>
<span class="comment-copy">That's true, but that doesn't mean that the class has to implement <code>__getitem__</code>. You could implement a <code>get_attribute</code> method instead or call it whatever you want. Your answer makes it look like implementing <code>__getitem__</code> is necessary for this to work.</span>
<span class="comment-copy">Not necessary but recommended. Why invent <code>get_attribute</code> if <code>__getitem__</code> exists?</span>
<span class="comment-copy">This will not work as it is.</span>
