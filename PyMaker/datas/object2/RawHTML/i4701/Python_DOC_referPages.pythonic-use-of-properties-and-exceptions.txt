<div class="post-text" itemprop="text">
<p>I have a class called Divider1 which divides a numerator by a denominator, set at initialisation:</p>
<pre><code>class Divider1:
    def __init__(self, numerator=0, denominator=1):
        self.numerator = numerator
        self.denominator = denominator

    def divide(self):
        return self.numerator / self.denominator
</code></pre>
<p>The class is easily abused by initialising incorrectly, but it is not immediately clear until dividing actually occurs:</p>
<pre><code>&gt;&gt;&gt; x = Divider1('hello', 5)
&gt;&gt;&gt; x.divide()
TypeError: unsupported operand type(s) for /: 'str' and 'int'
</code></pre>
<p>It seems that raising an exception earlier would be beneficial for debugging and maintenance, so here is my next logical step:</p>
<pre><code>class Divider2:
    def __init__(self, numerator=0, denominator=1):
        try:
            numerator = float(numerator)
        except ValueError:
            raise ValueError("Numerator must be numeric!")

        try:
            denominator = float(denominator)
        except ValueError:
            raise ValueError("Denominator must be numeric!")

        if denominator == 0:
            raise ValueError("Denominator must be non-zero!")

        self.numerator = numerator
        self.denominator = denominator

    def divide(self):
        return self.numerator / self.denominator
</code></pre>
<p>Now we have some safety:</p>
<pre><code>&gt;&gt;&gt; x = Divider2('hello', 5)
ValueError: Numerator must be numeric!
</code></pre>
<p>It's very clear to me, immediately what is wrong on initialisation, but it can still be abused by changing the attribute after initialisation:</p>
<pre><code>&gt;&gt;&gt; x = Divider2(10, 5)
&gt;&gt;&gt; x.numerator = 'hello'
&gt;&gt;&gt; x.divide()
TypeError: unsupported operand type(s) for /: 'str' and 'int'
</code></pre>
<p>I'm trying to figure out the Pythonic way of dealing with these issues. I could possibly just name the numerator and denominator <em>_numerator</em> and <em>_denominator</em>, to indicate that they should be treated as private.</p>
<p>Or alternatively, I could use properties:</p>
<pre><code>class Divider4:
    def __init__(self, numerator=0, denominator=1):
        self.numerator = numerator
        self.denominator = denominator

    @property
    def numerator(self):
        return self._numerator

    @numerator.setter
    def numerator(self, value):
        try:
            value = float(value)
        except ValueError:
            raise ValueError("Denominator must be numeric!")

        self._numerator = value

    @property
    def denominator(self):
        return self._denominator

    @denominator.setter
    def denominator(self, value):
        try:
            value = float(value)
        except ValueError:
            raise ValueError("Denominator must be numeric!")

        if value == 0:
            raise ValueError("Denominator must be non-zero!")

        self._denominator = value

    def divide(self):
        return self.numerator / self.denominator
</code></pre>
<p>So now:</p>
<pre><code>&gt;&gt;&gt; x = Divider4(10, 5)
&gt;&gt;&gt; x.numerator = 'hello'
ValueError: Numerator must be numeric!
&gt;&gt;&gt; x = Divider4(10, 0)
ValueError: Denominator must be non-zero!
</code></pre>
<p>It is clearly much safer, and I know the cause of the error immediately, no matter how the class was used - it's impossible for the Divider to reach an impossible state. But I had to write many more lines of code to achieve this, especially compared to Divider1. But I still think that this sort of safety should always be reached, though I haven't seen people do this all the time when they write Python code. Am I using Python in a way that was unintended? Is it Pythonic to always write such cumbersome properties to ensure safety? Are there times when it should or shouldn't be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>A lot of the ugliness comes from the <code>value = float(value)</code>.  You can use the abstract base class <a href="https://docs.python.org/3/library/numbers.html#numbers.Number" rel="nofollow noreferrer"><code>numbers.Number</code></a> to check if your input is a number.</p>
<pre><code>from numbers import Number

class Divider4:
    def __init__(self, numerator=0, denominator=1):
        self.numerator = numerator
        self.denominator = denominator   
    @property
    def numerator(self):
        return self._numerator   
    @numerator.setter
    def numerator(self, value):
        if not isinstance(value, Number):
            raise ValueError("Bad numerator: {}".format(value))  
        self._numerator = value
    @property
    def denominator(self):
        return self._denominator    
    @denominator.setter
    def denominator(self, value):
        if not isinstance(value, Number) or value == 0:
            raise ValueError('Bad denominator: {}'.format(value))
        self._denominator = value    
    def divide(self):
        return self.numerator / self.denominator
</code></pre>
<p>The type hierarchy for numbers was defined in <a href="https://www.python.org/dev/peps/pep-3141/" rel="nofollow noreferrer">PEP 3141</a></p>
</div>
<span class="comment-copy">Voting to close as opinion-based, which is not on-topic for <a href="https://stackoverflow.com">Stack Overflow</a>. Having said that, here is my opinion: don't do anything. Just let division in <code>.divide()</code> raise an exception. The programmer that uses your class will use it as intended or will receive an exception. If you really want the exception to happen earlier, call <code>self.divide()</code> from <code>self.__init__()</code>, with no <code>try</code> and no <code>except</code>.</span>
<span class="comment-copy">I could see why you would want to catch exceptions if you wanted to handle them differently.  But it seems to me you are still raising the exceptions and terminating the program, albeit immediately and with more specific information (e.g. <code>ValueError: Numerator must be numeric!</code> instead of the generic <code>TypeError: unsupported operand type(s) for /: 'float' and 'str'</code>).  But does that justify all the extra <code>try</code> <code>except</code> statements?  I think the idea with Python is to rely on the built-in exception handling as much as possible.  What is so bad about the generic exception information&gt;?</span>
<span class="comment-copy">"I have a class called Divider1 which divides a numerator by a denominator" - that is not a job for a class. If you want to perform a computation, write a function. If you want to represent a <i>thing</i>, write a class.</span>
<span class="comment-copy">Thanks for the comments. The Divider class is a simplified example of something that I've been thinking about more generally with more complicated classes where there is a lot more going on.</span>
