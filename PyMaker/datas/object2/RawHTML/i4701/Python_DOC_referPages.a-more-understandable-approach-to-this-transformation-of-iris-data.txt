<div class="post-text" itemprop="text">
<p>So, I was following a book about machine learning. But I was confused a bit when I encountered this:  </p>
<blockquote>
<p>the iris dataset marks setosa as zero, we have to change all targets
  with the value 0 to 1, and the other values all to 0.We will also use
  two features, petal length and petal width. These two features are the
  third and fourth entry in each x-value.</p>
</blockquote>
<pre><code>iris = datasets.load_iris()
binary_target = np.array([1. if x==0 else 0. for x in iris.target])
iris_2d = np.array([[x[2], x[3]] for x in iris.data])
</code></pre>
<p>The way the iteration is implemented, is very vague to me. I have never seen such an implementation. Is it a commonly used way that I dont know of? Or is there a better and a more convenient way to implement the same thing.<br/>
Thanks</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Let's establish what the code is doing - it is converting a
  multi-class classification problem into a binary one (one vs rest) -
  with the focus apparently on Setosa.</p>
<p>That said, that is a really poor way of doing it, and I'm really
  surprised to see it in a book about machine learning.</p>
</blockquote>
<p>Note,</p>
<pre><code>print(iris.target)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
</code></pre>
<p>And,</p>
<pre><code>print(iris.data)
array([[5.1, 3.5, 1.4, 0.2],
       [4.9, 3. , 1.4, 0.2],
       [4.7, 3.2, 1.3, 0.2],
       [4.6, 3.1, 1.5, 0.2],
       [5. , 3.6, 1.4, 0.2],
       ...
</code></pre>
<p>One naive way of converting this to a binary problem would be using a loop:</p>
<pre><code>binary_target = []
for t in iris.target:
    if t == 0:
        binary_target.append(1.)
    else:
        binary_target.append(0.)
</code></pre>
<p>Reduce this to a single liner, a list comprehension, and you get:</p>
<pre><code>binary_target = [1. if t == 0 else 0. for t in iris.target]
</code></pre>
<p>Again, this is a poor way of doing it.</p>
<p>I'd rather do this with <code>np.where</code>, keeping this in numpy space -</p>
<pre><code>binary_target = np.where(iris.target == 0, 1, 0)
</code></pre>
<p>You may not see large differences (well, list comprehensions <em>do</em> run in C space and are fast), but numpy is completely vectorised. Again, this is likely not going to be the bottleneck of your code if you're implementing a machine learning classifier, so I wouldn't really worry much about it.</p>
<p>And similarly for the second one, like @DyZ mentioned, it is completely unnecessary. Just do -  </p>
<pre><code>iris_2d = iris.data[:, 2:4]
</code></pre>
<p>A simple slicing with <code>ndarray.__getitem__</code> is sufficient, and you don't even need to convert the result to an array (the slice already is an array). </p>
<hr/>
<p>In summary,</p>
<pre><code>iris = datasets.load_iris()
binary_target = np.where(iris.target == 0, 1, 0)
iris_2d = iris.data[:, 2:4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first list comprehension creates a boolean array where <code>True</code> items correspond to the zero <code>iris.target</code>. The same can be accomplished using the native NumPy tools:</p>
<pre><code>binary_target = iris.target.astype(bool).astype(int)
</code></pre>
<p>The second list comprehension is not necessary at all, because <code>iris.data</code> is already a NumPy array. So,</p>
<pre><code>iris_2d = np.array([[x[2], x[3]] for x in iris.data])
</code></pre>
<p>must be:</p>
<pre><code>iris_2d = iris.data[:,[2,3]]
</code></pre>
<p>I am surprised that a "book about machine learning" offers such a silly advice.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[1. if x==0 else 0. for x in iris.target]
</code></pre>
<p>This is a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">List Comprehension</a>.  It creates a list.  It could also be done as:</p>
<pre><code>[float(x==0) for x in iris.target]
</code></pre>
</div>
<span class="comment-copy">List comprehension is <i>very</i> commonly used. It is considered superior to <code>for</code> loops that could theoretically be use to achieve similar results.</span>
<span class="comment-copy">is the usage of list comprehension a poor way or the way list comprehension is used a poor way?</span>
<span class="comment-copy">@Huzo I love list comprehensions, they are fast. I just think their usage here is inappropriate.</span>
<span class="comment-copy">Since the OP already accepted your answer, do you mind adding <code>binary_target = (iris.target==0).astype(bool)</code> to it?</span>
<span class="comment-copy">@DyZ I can, but I see it already in your answer. I think yours is good, so why not leave it there?</span>
<span class="comment-copy">I see, I too am surprised to encounter such simple mistakes. Maybe the reason is that it is a Tensorflow book. So its scope of focus is more on the usage of Tensorflow, I guess..</span>
<span class="comment-copy">Appreciate that somebody else (a professor!) shares the same view here!</span>
