<div class="post-text" itemprop="text">
<p>I'm using Python 3, and I found that I can't use <code>super()</code> within <code>__call__</code> of metaclass.</p>
<p>Why in the code below does <code>super()</code> raise a <code>TypeError: 'ListMetaclass' object is not iterable</code> exception? Why does it works well if I remove the <code>__call__</code> method from the metaclass?</p>
<pre><code>class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        new_cls = type.__new__(cls, name, bases, attrs)
        return new_cls

    def __call__(cls, *args, **kw):
        ### why the 'super()' here raises TypeError: 'ListMetaclass' object is not iterable
        return super().__call__(cls, *args, **kw)
        return super(__class__, cls).__call__(cls, *args, **kw)
        return super(__class__, cls.__class__).__call__(cls, *args, **kw)

class MyList(list, metaclass=ListMetaclass):
    a=1
    def bar(self):
        print('test');

L=MyList()
L.add(1)
print('Print MyList :', L)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should not pass in <code>cls</code> to <code>super().__call__()</code>; <code>super()</code> takes care of binding for you and so <code>cls</code> is <em>already</em> passed in automatically.</p>
<p>You may have gotten confused by the <code>super().__new__(cls, ...)</code> call in <code>__new__</code>; that's because <code>__new__</code> is the exception here, see the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>object.__new__</code> documentation</a>:</p>
<blockquote>
<p>Called to create a new instance of class <code>cls. __new__()</code> is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument.</p>
</blockquote>
<p>Removing <code>cls</code> from the <code>super().__call__(...)</code> expression works:</p>
<pre><code>class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        new_cls = type.__new__(cls, name, bases, attrs)
        return new_cls;
    def __call__(cls, *args, **kw):
        return super().__call__(*args, **kw)
</code></pre>
<p>By passing in <code>cls</code>, you are effectively executing <code>list(cls)</code>, telling <code>list()</code> to convert <code>cls</code> to values in the new list; that required <code>cls</code> to be an iterable.</p>
<p>When you remove the <code>__call__</code> method on your metaclass, the default <code>type.__call__</code> method is used when you call <code>MyClass()</code>, which just receives the normal arguments (none in your example) and returns a new instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I can see where this will be confusing because you have to pass <code>cls</code> to <code>super().__new__</code> but you <strong>mustn't</strong> pass it to <code>super().__call__</code>.</p>
<p>That's because <code>__call__</code> is a normal method but <code>__new__</code> is special. It's <a href="https://docs.python.org/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">behaving like a <code>staticmethod</code></a>:</p>
<blockquote>
<h3><code>object.__new__(cls[, ...])</code></h3>
<p>Called to create a new instance of class <code>cls</code>. <code>__new__()</code> is a static method (special-cased so you need not declare it as such) [...]</p>
</blockquote>
<p>As staticmethod it <strong>needs all arguments</strong> while you don't need to pass the first argument to normal methods (it's already bound).</p>
<p>So just change it to:</p>
<pre><code>return super().__call__(*args, **kw)
</code></pre>
<p>inside <code>__call__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accessing a method of the super class using <code>super().method</code> will already <em>bind</em> the method to the current instance. So the <code>self</code> argument for methods will already be set automatically, just like when you call <code>self.method()</code>.</p>
<p>So when you then pass the current instance (in this case, the <code>cls</code> type) to the method, you are actually passing it a second time.</p>
<pre><code>super().__call__(cls, *args, **kw)
</code></pre>
<p>So this will end up making a call <code>__call__(cls, cls, *args, **kw)</code>.</p>
<p>When this is then interpreted by your <code>__call__</code> method, the arguments will then be matched to the following definition:</p>
<pre><code>def __call__(cls, *args, **kw):
</code></pre>
<p>So the first <code>cls</code> is properly matched, but the second <code>cls</code> is interpreted to be the variable parameter list <code>*args</code>. And hereâ€™s where your exception comes from: <code>cls</code> is being passed where an iterable is expected, but <code>cls</code>, the class <code>ListMetaclass</code>, is not iterable.</p>
<p>So the fix here is simply to remove that additional <code>cls</code>: <code>super().method()</code> will already include it automatically due to method binding.</p>
</div>
