<div class="post-text" itemprop="text">
<h3>I want to know how to automate this part:</h3>
<pre><code>if n + list1[0] == list2[0] and n + list1[1] == list2[1] and n + list1[2] == list2[2]:
</code></pre>
<h3>In this code:</h3>
<pre><code>def find_first_match(amount_of_checks):
    for n in range(range_start, range_end):
         if n + list1[0] == list2[0] and n + list1[1] == list2[1] and n + list1[2] == list2[2]:
            first_match = n
            return first_match
</code></pre>
<p>Meaning perform specified amount of <code>n + list1[index] == list2[index]</code> checks automatically, instead of manually hard-coding those 3 comparing statements in there. And <strong>not loose</strong> any performance?</p>
<p>I tried to replace this <strong>hard-coded if statement</strong> with this code down below, but it's a few times slower than the hardcoded way:</p>
<pre><code>if all((n + a == b) for a, b in zip(list1[:amount_of_checks], list2[:amount_of_checks])):
</code></pre>
<h3>So is there a way to:</h3>
<ul>
<li>make it not hard-coded (use a variable's value to generate specified amount of check)</li>
<li>retain performance</li>
</ul>
<h2>Update:</h2>
<p>The first list is always the same, the second list always has random values, so I want it to go through the specified range of numbers <code>n</code> (100, 101, 102, ...) and find the first <code>n</code> that would satisfy ALL the checks (find the 2nd list that has the same values as the first list) </p>
<p>I want it to work with all the operations, like +,-,*,/,% etc</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are missing a key point here. You do not need to guess the size of your delta. You can rearrange <code>n + list1[x] == list2[x]</code> to read <code>n == list2[x] - list1[x]</code>. This way, there is only one or no values of <code>n</code> which make all the elements you want to compare equal to each other. You can do something like:</p>
<pre><code>def find_n(amount_of_checks, list1, list2):
    deltas = set(a - b for a, b in zip(list1[:amount_of_checks], list2[:amount_of_checks]))
    if len(deltas) == 1:
        return next(deltas)
</code></pre>
<p>This is a very simplified approach. One improvement that might help with performance would be to use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">itertools.islice</a> instead of the index <code>[1:amount_of_checks]</code> since that would avoid allocating a new pair of lists.</p>
<p>Your original code only allows <code>n</code> within a certain range. If this is something you want and not just an artifact, you can add that test as well:</p>
<pre><code>def find_n(amount_of_checks, list1, list2, n_start, n_end):
    deltas = set(b - a for a, b in zip(list1[1:amount_of_checks], list2[1:amount_of_checks]))
    if len(deltas) == 1:
        n = next(deltas)
        if n &gt;= n_start and n &lt; n_end:
            return next(deltas)
</code></pre>
<p><strong>Update in response to your update</strong></p>
<p>You should be able to write all the operations besides modulo in the same way:</p>
<ul>
<li>For <code>n - list1[x] == list2[x]</code>, use <code>deltas = set(a + b ...</code></li>
<li>For <code>n * list1[x] == list2[x]</code>, use <code>deltas = set(b / a ...</code></li>
<li>For <code>n / list1[x] == list2[x]</code>, use <code>deltas = set(b * a ...</code></li>
<li>For <code>n**list1[x] == list2[x]</code>, use <code>deltas = set(b ** (1 / a) ...</code></li>
<li>etc.</li>
</ul>
<p>The problem with modulo is that it does not have a unique inverse operation. I do not remember enough number theory at this point to say if there will be a faster solution than just using @Steven's answer using a direct application of <code>all</code>, <code>islice</code> and <code>zip</code>, but I suspect not.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the builtin <code>all</code> function</p>
<pre><code>if all(list1[i]-list2[i]==n for i in range(start, end)):
    # Whatever you want to do
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>if all((n % a == b) for a, b in zip(list1[:amount_of_checks], list2[:amount_of_checks]))
</code></pre>
<p>This code is slow because the slices <code>list1[:amount_of_checks]</code> and <code>list2[:amount_of_checks]</code> iterate <code>amount_of_checks</code> times to create sublists that get thrown away.  It's particularly unfortunate when <code>(n % a == b)</code> evaluates to <code>False</code> on an early iteration because <code>all</code> is happy to shorcut evaluation in these situations, but you've already paid the performance penalty in the sublist creation.</p>
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> to avoid the performance penalty of creating the sublists:</p>
<pre><code>zip(islice(list1, amount_of_checks), islice(list2, amount_of_checks))
</code></pre>
<p>This can be streamlined by switching the order or <code>zip</code> and <code>islice</code></p>
<pre><code>islice(zip(list1, list2), amount_of_checks)
</code></pre>
<p>Put it all together and you get</p>
<pre><code>if all((n % a == b) for a, b in islice(zip(list1, list2), amount_of_checks))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>if all([(n + list1[i] == list2[i]) for i in range(start, end)]):
    # ...
</code></pre>
<p>Just change <code>start</code> and <code>end</code> according to your range</p>
<p>However, of course this isn't quite as fast as writing out all the conditions by hand. If we measure execution time using <code>timeit</code> with some sample values, it becomes obvious:</p>
<pre><code>timeit.timeit('all([(2 + 1 == 3) for _ in range(0, 5)])', number=10000)
&gt; 0.008927443002903601
timeit.timeit('2 + 1 == 3 and 2 + 1 == 3 and 2 + 1 == 3 and 2 + 1 == 3 and 2 + 1 == 3', number=10000)
&gt; 0.0011130370003229473
</code></pre>
<p>so keep that in mind (since I don't know how high your performance needs are)</p>
</div>
<span class="comment-copy">Why are you looping over <code>n</code>?  <code>list2[0] - list1[0]</code> is the only value it can possibly have.</span>
<span class="comment-copy">@jasonharper well, I want it to go through the specified range of numbers <code>n</code> (100, 101, 102, ...) and find the first <code>n</code> that would satisfy ALL the checks</span>
<span class="comment-copy">Please add some worked examples, it is not clear what result you are trying to get.</span>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>.  <code>zip(list1[:amount_of_checks], list2[:amount_of_checks])</code> can be rewritten as <code>zip(islice(list1, amount_of_checks), islice(list2, amount_of_checks))</code>.  This avoids creating sublists just to pass them as arguments to <code>zip</code>.  If the condition for <code>all</code> exits early this can have a nice performance boost.</span>
<span class="comment-copy">@StevenRumbalski I think it would be better to <code>islice</code> the <code>zip</code> object</span>
<span class="comment-copy">Thanks, your method is actually mad fast. it takes 0.000007 instead of 0.0001 when I do: <code>islice(zip(list1, list2), amount_of_checks)</code>  wow</span>
<span class="comment-copy">If that's the case, you can always change your selection :)</span>
<span class="comment-copy">I'm trying to figure out why doesn't your method works with modulo operation, like n % list (perhaps we can't rearrange it as with n + list operation?)</span>
<span class="comment-copy">Oh. I forgot you wanted to wrap around. You don't mention that <i>anywhere</i> in your question, but you accepted an answer with modulo. What's up with that?</span>
<span class="comment-copy">I'm sorry, I forgot to mention that and then edited the question. Could you also suggest a way to do this with <code>n % list</code> operation, not just <code>n + list</code>? I'm not sure why it's not working. Is it possible?</span>
<span class="comment-copy">This would create a list of <code>N</code> elements even if the first pair of elements doesn't satisfy the condition.</span>
<span class="comment-copy">Well, if you have a cleaner looking alternative go on :)</span>
<span class="comment-copy">To address @vaultah's objection remove the brackets from your list comprehension and turn it into a generator expression: <code>if all(list1[i]-list2[i]==n for i in range(start, end)):</code></span>
<span class="comment-copy">problem addressed!</span>
<span class="comment-copy">Technically, you don't need to swap <code>islice</code> and <code>zip</code>: <code>zip(islice(list1, amount_of_checks), list2)</code> will work just fine.</span>
<span class="comment-copy">Thanks for the answer, it works but it's 10 times slower then the slice method.</span>
<span class="comment-copy">Yes I agree, the other method seems better ;)</span>
