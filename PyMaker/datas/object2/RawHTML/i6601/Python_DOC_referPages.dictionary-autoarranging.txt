<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/613183/how-do-i-sort-a-dictionary-by-value">How do I sort a dictionary by value?</a>
<span class="question-originals-answer-count">
                    42 answers
                </span>
</li>
</ul>
</div>
<pre><code># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return None
        start = head
        prev = head.val
        a = {prev:1}
        #o = [prev]
        head = head.next
        while head != None:
            if head.val == prev:
                a[prev] += 1
            else:
                prev = head.val
                a[prev] = 1
                #o.append(prev)
            head = head.next
        b = ListNode(0)
        ans = b
        for i in a: # can use for i in o
            if a[i] == 1:
                c = ListNode(i)
                b.next = c
                b = b.next
        return ans.next
</code></pre>
<p>I am trying to remove duplicate items from a <strong>sorted linked list</strong>, eg.<code>[1,2,3,3,4,4,5,6,6,6]</code> -&gt; <code>[1,2,5]</code>. Can someone walk through the code and tell me what will be the final value of <code>a</code> is for the linked list <code>2</code>-&gt;<code>1</code>-&gt;<code>None</code>. It should be <code>{2:1, 1:1}</code> but answer comes out to be <code>{1:1, 2:1}</code>...why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict</code> object doesn't remember the order of elements which are added to the dictionary. If you want to preserve the ordering of the elements you can use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>O(N) option using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a></p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; [k for k,g in groupby([1,2,3,3,4,4,5,6,6,6]) if len(list(g)) == 1]
[1, 2, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the following:</p>
<pre><code>&gt;&gt;&gt; l = [1,2,3,3,4,4,5,6,6,6]
&gt;&gt;&gt; [i for i in l if l.count(i) == 1]
</code></pre>
<p>This preserves the order of items in <code>l</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an approach in <code>O(n)</code> time (in Python 3), regardless of whether the list is sorted.</p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3, 3, 4, 4, 5, 6, 6, 6]
&gt;&gt;&gt; unique = {}
&gt;&gt;&gt; for item in lst:
...     if item in unique:
...         unique[item] += 1
...     else:
...         unique[item] = 1
... 
&gt;&gt;&gt; [k for k, v in unique.items() if v == 1]
[1, 2, 5]
</code></pre>
<ul>
<li>The statement <code>for item in lst: ...</code> is <code>O(n)</code>.

<ul>
<li>The expression <code>item in unique</code> is <code>O(1)</code>.</li>
<li>The statement <code>unique[item] = 1</code> is <code>O(1)</code>, and so is <code>unique[item] += 1</code>.</li>
</ul></li>
<li>The expression <code>[k for k, v in unique.items() if v == 1]</code> is <code>O(n)</code>.</li>
</ul>
<p>So, calculating the time complexity of the <code>for</code> statement:</p>
<ol>
<li><code>O(n) * (O(1) + max(O(1), O(1)))</code></li>
<li><code>O(n) * (O(1) + O(1))</code></li>
<li><code>O(n) * O(1)</code></li>
<li><code>O(n)</code></li>
</ol>
<p>Add that to the time complexity of the list comprehension, and you have <code>O(n) + O(n)</code>, which is <code>O(2n)</code>. Drop the constant, and you have <code>O(n)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>This answer assumes that all you want to do is to create another list, only keeping the values that occur once.</em></p>
<p>One way of doing it would be to use <a href="https://docs.python.org/3.6/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">groupby</a> from <code>itertools</code> and then filter based on the length of each group.</p>
<pre><code># Assuming 's' holds our list
[i for i,k in itertools.groupby(s) if len(list(k)) == 1]
</code></pre>
<p><strong>EDIT</strong> Reading your question again, it seems this solution might not work, unless the linked list type you're using conforms to the iterator protocol. At any rate, it certainly won't produce a list as output, although you could replace the list comprehension with a generator expression and build a linked list from that.</p>
</div>
<span class="comment-copy">Don't make needless classes. Solution is a totally useless class.</span>
<span class="comment-copy">Is the list sorted already?</span>
<span class="comment-copy">No no, you don't understand. It isn't our job to <i>ignore extraneous stuff</i>, it is <i>your job</i> to provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">But, fundamentally, your question: "{2:1,1:1} but answer comes out to be {1:1, 2:1}" doesn'tmake any sense: <b>those are equivalent dictionaries</b>. Python <code>dict</code> is <i>unordered</i>.</span>
<span class="comment-copy">If order is important use <code>collections.OrderedDict</code></span>
<span class="comment-copy">Thanks, this is what I was searching for.</span>
<span class="comment-copy">that requires the list to be sorted, though</span>
<span class="comment-copy">Sure, but if I understand question, it is precondition.</span>
<span class="comment-copy">That's O(N^2). I'm trying to solve it in linear time.</span>
<span class="comment-copy">If you are concerned about performance then you need to be more specific about your situation, e.g. if the items in the list are always sorted, etc.</span>
<span class="comment-copy">@NikhilRanjan people are trying to help here. Why should they have patience with you if you are not willing to do the same for them?</span>
<span class="comment-copy">Looks like you think it is everybody's fault they can't guess what you want from your awesome question.</span>
<span class="comment-copy">It is hard to say what the OP wants: "autoarranging dict" is a bit vague.</span>
