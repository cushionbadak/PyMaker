<div class="post-text" itemprop="text">
<p>After many days I have a working celery and celery beat task list, and the results are stored using django_celery_results. However when I look at the table record, it hasn't got any useful information in there.</p>
<p>is it possible to set the task id to something human readable?</p>
<p><a href="https://i.stack.imgur.com/ZorGj.png" rel="noreferrer"><img alt="results" src="https://i.stack.imgur.com/ZorGj.png"/></a></p>
<p>one example would be using the demo task, it returns the no, but an unreadable task id</p>
<p>tasks.py</p>
<pre><code>@app.task
def test(a,b):
    return a + b
</code></pre>
<p>scheduler in app.settings</p>
<pre><code>CELERYBEAT_SCHEDULE = {
    'test_task': {
        'task': 'home.tasks.test',
        'schedule': crontab(minute='*/1'),
    },
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easy answer is No. The <code>task_id</code> attribute is generated automatically. If you follow the code backwards the core function that generates ID's is in <a href="https://github.com/celery/kombu/blob/master/kombu/utils/uuid.py" rel="nofollow noreferrer"><code>kombu.utils.uuid.uuid(..)</code></a>, which interestingly is just a thin wrapper around the builtin <a href="https://docs.python.org/3/library/uuid.html#uuid.uuid4" rel="nofollow noreferrer"><code>uuid.uuid4(..)</code></a>.</p>
<p>However, if you look at the function signature:</p>
<pre><code>def uuid(_uuid=uuid4):
    """Generate unique id in UUID4 format.
    See Also:
        For now this is provided by :func:`uuid.uuid4`.
    """
    return str(_uuid())
</code></pre>
<p>..it appears like it would be possible to supply your own function that <strong>generates</strong> the ID, and as long as they're unique they should work. Fundamentally you'd have to patch: <code>celery.__init__.uuid</code>, <code>celery.utils.__init__.uuid</code>, and <code>celery.utils.__init__.gen_unique_id</code>.</p>
<p>I don't think that you'd be able to apply worthwhile names since this function is called with no parameters to simply return something unique.</p>
<p><strong>BUT</strong></p>
<p>If you look at <a href="https://github.com/celery/celery/blob/2f422c52bdd3dece65f05c1e7015b335e8bd0175/celery/app/task.py#L695-L698" rel="nofollow noreferrer"><code>Task.apply</code></a> and <a href="https://github.com/celery/celery/blob/2f422c52bdd3dece65f05c1e7015b335e8bd0175/celery/app/task.py#L418-L419" rel="nofollow noreferrer"><code>Task.apply_async</code></a> there's an undocumented parameter <code>task_id</code>!</p>
<p>This would allow you to manually specify the <code>task_id</code> <em>before</em> the Task is called/created, and as long as they're globally unique you'll still get all of the reporting and metrics. Unfortunately I don't see any easy way to change the <code>task_id</code> from a Result, to make it more useful after the fact...kinda making your UI's textbox a little silly.</p>
<hr/>
<p>If your project is set up for it, you can use Task Inheritance and modify task behavior that way. In theory you should be able to overwrite <code>apply</code> and <code>apply_async</code> to inject a task's ID.</p>
<pre><code>import time

from celery import Task

 class NamedTask(Task):
    id_gen = lambda: int(time.time() * 1000)


    def _gen_task_id(self):
        return {
            'task_id': '%s-%s' % (
                self.name,
                self.id_gen())}

    def apply(self, *args, **kwargs):
        kwargs.update(self._gen_task_id())
        return Task.apply(self, *args, **kwargs)

    def apply_async(self, *args, **kwargs):
        kwargs.update(self._gen_task_id())
        return Task.apply_async(self, *args, **kwargs)



@task(base=NamedTask)
def add(x, y):
    return x + y
</code></pre>
<p>Should make your Task ID look like: <code>project.tasks.add-15073315189870</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Implement a <em>custom result backend</em> that overwrites <code>_store_result</code> to decide what is saved as result to the database.</p>
<p>Depending on which backend you're using find the related class in <code>celery.backends</code>.</p>
<p>This example extends the result for an <em>amqp</em> backend.</p>
<pre><code>class UsefulInfoBackend(AMQPBackend):
    def store_result(self, task_id, result, state,
                     traceback=None, request=None, **kwargs):
        result = super(UsefulInfoBackend, self).store_result(task_id, result, state,
                     traceback=None, request=None, **kwargs)
        result['useful_info'] = 'Very Useful! :)' # determine the rules for extraneous information here contains. 
        return result
</code></pre>
<p>When initializing <code>Celery</code> pass your result backend class.</p>
<pre><code>celery.Celery(backend=UsefulInfoBackend)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>@app.task(name="periodic_test")
def test(a, b):
    return a+b
</code></pre>
<p>This may help to find the task status in the UI, but Celery always needs a unique id for each task execution.</p>
</div>
<span class="comment-copy">Hi I dont want to alter the task ID, that is fine, I was wondering if I can add another field to the model where I can give it a description and see it in the django_celery_resutls DB view?</span>
<span class="comment-copy">@AlexW, your question should have been clear on that. Because now the meaning of the question itself changes. And your title clearly stated <code>set task id to something human readable?</code>.</span>
<span class="comment-copy">apologies for the confusion, re reading this I can see how the question needs improvment</span>
<span class="comment-copy">Useful information, +1 thanks!</span>
