<div class="post-text" itemprop="text">
<p>I have the following function but it doesn't give me the intended result:</p>
<pre><code>def GetNthLetters(text,n):
    builtstring=""
    for letter in text:
        if text.index(letter)%n==0:
            builtstring=builtstring+letter
            print letter 
    return builtstring   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.index()</code> finds the <strong>first match</strong> for your letter. If you have a letter that appears more than once, that'll give you the wrong index. For any given character, you only test if their <em>first</em> occurrence in the string is at a n'th position.</p>
<p>To demonstrate, take a look at the string <code>'hello world'</code> with the character indices (I used <code>.</code> to mark the space):</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10
h e l l o . w o r l d
</code></pre>
<p>For the letter <code>l</code>, <code>text.index('l')</code> will return <code>2</code>, so it'll only be included in the output if <code>n</code> is <code>1</code> or <code>2</code>. It doesn't matter that <code>l</code> also appears at index 3 or 9, because you only ever test <code>2 % n == 0</code>. The same applies for <code>'o'</code> (positions 4 and 7), only <code>4 % n == 0</code> is tested for either.</p>
<p>You could use the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a> to give you a running index:</p>
<pre><code>def GetNthLetters(text, n):
    builtstring = ""
    for index, letter in enumerate(text):
        if index % n == 0:
            builtstring = builtstring + letter
    return builtstring
</code></pre>
<p>Now <code>index</code> is correct for every letter, repeated or not.</p>
<p>However, it'll be much easier to use slicing:</p>
<pre><code>def GetNthLetters(text, n):
    return text[::n]
</code></pre>
<p>This takes every n'th letter too:</p>
<pre><code>&gt;&gt;&gt; 'foo bar baz'[::2]
'fobrbz'
&gt;&gt;&gt; 'foo bar baz'[::3]
'f ra'
&gt;&gt;&gt; 'foo bar baz'[::4]
'fbb'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If somebody asked me to give every nth character in a string, I wouldn't include the first character. I would rather do something like below:</p>
<pre><code>def GetNthLetters(text, n):
    builtstring = ""
    for i in range(0, len(text)):
        if (i + 1) % n == 0:
            # print(text[i])
            builtstring = builtstring + text[i]
    return builtstring


text = '1234567890123456789012345678901234567890'

nthLetters = GetNthLetters(text, 1)
print(nthLetters)
nthLetters = GetNthLetters(text, 2)
print(nthLetters)
nthLetters = GetNthLetters(text, 3)
print(nthLetters)
nthLetters = GetNthLetters(text, 10)
print(nthLetters)
nthLetters = GetNthLetters(text, 40)
print(nthLetters)
</code></pre>
<p>This would yield these results:</p>
<p>1234567890123456789012345678901234567890</p>
<p>24680246802468024680</p>
<p>3692581470369</p>
<p>0000</p>
<p>0</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>string = "12345678"

n = 2

splitted_string = string[::n]

print(splitted_string)

# Output : 1357
</code></pre>
<p>Hope this will help.!</p>
</div>
<div class="post-text" itemprop="text">
<h2>Using Python's <code>slicing</code> syntax:</h2>
<p>Python's <code>slicing</code> syntax is much like the <code>range()</code> function. It accepts a <code>start</code>, <code>stop</code> and <code>step</code> value:</p>
<blockquote>
<p><code>string[start : stop : step]</code></p>
</blockquote>
<p>where you can leave any of the parameters blank and they will default to <code>0</code>, the length of the string and <code>1</code> respectively.</p>
<p>This means you can do:</p>
<blockquote>
<p><code>string[::n</code>]</p>
</blockquote>
<p>to get a string's every <code>nth</code> characterter.</p>
<p>So you can write the <code>function</code> as:</p>
<pre><code>def getNthLetters(text, n):
   return text[::n]
</code></pre>
<p>Hope this does what you want!</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with the code is everytime the index of same repeated letter will give same result.</p>
<p>For example 'Hello World!'.index('o') will be always 4 so it will not give intended result.</p>
<p>The best way is to <code>enumerate</code> the for loop. so you will get appropriate index.</p>
<p>You should also remember array starts with 0 not 1.</p>
</div>
<span class="comment-copy">Much easier: <code>return text[::n]</code></span>
<span class="comment-copy">why don't you use text[n]?</span>
<span class="comment-copy">In this case it is easy enough for us to see what you are doing wrong, but you should <i>really</i> include some sample input, the expected output and what you see instead.</span>
<span class="comment-copy">Doesn't your answer gives the same result as the questioner's program?</span>
<span class="comment-copy">@Harry: it doesn't. Note that the questioner has <i>not given us any examples</i>.</span>
<span class="comment-copy">@Harry: <code>GetNthLetters('Hello World!', 4)</code> <i>should</i> produce <code>'Hor'</code>, but the OP's version gives <code>'Hoor'</code> instead. The second <code>'o'</code> at index 7 is included because the first <code>'o'</code> is at position <code>4</code>.</span>
<span class="comment-copy">Got it. Its because of the index will always return the first found index. Thanks edited my answer.</span>
<span class="comment-copy">Using a string without repeating characters hardly demonstrates the error the OP made.</span>
<span class="comment-copy">Sure, but where did the OP go wrong in their implementation?</span>
<span class="comment-copy">@MartijnPieters To be honest, I hadn't tested his <code>function</code>, I just did and it worked fine so I'm not sure why he said: "it doesn't give me the intended result"</span>
<span class="comment-copy">Because it doesn't work for repeated characters.</span>
<span class="comment-copy">@MartijnPieters Ah, yes missed that, but why not just use <code>slicing</code>?</span>
<span class="comment-copy">I didn't say anything about slicing being wrong. It's the best solution. I'm just pointing out that the question was about the OPs implementation, which you ignored.</span>
<span class="comment-copy">No, the answer posted does <b>not</b> produce the same output. You need to test with input strings with repeating characters.</span>
<span class="comment-copy">Got it edited answer with the reason.</span>
<span class="comment-copy">Yes, so it now is just a re-wording of my answer. This was never about the starting index.</span>
<span class="comment-copy">Yeah didn't want to delete the answer. Also didn't want to leave it as wrong.</span>
