<div class="post-text" itemprop="text">
<p><em>Since it's a regex question. This is a potential duplicated question.</em></p>
<p>Considering those given strings</p>
<pre><code>test_str = [
    "bla bla google.com bla bla", #0
    "bla bla www.google.com bla bla", #1
    "bla bla api.google.com bla bla", #2
    "google.com", #3
    "www.google.com", #4
    "api.google.com", #5
    "http://google.com", #6
    "http://www.google.com", #7
    "http://api.google.com", #8
    "bla bla http://www.google.com bla bla", #9
    "bla bla https://www.api.google.com bla bla" #10
]
</code></pre>
<p>My desired return is <code>google.*</code> or <code>www.google.*</code> but not <code>api.google.*</code>. Which means, in above case, 2, 5, 8, 10 should not return any match.</p>
<hr/>
<p>I have tried several regex, but I can not find a one line regex string for doing this tasks. Here are what I tried.</p>
<pre><code>re.compile("((http[s]?://)?www\.google[a-z.]*)") # match 1,4,7,9
re.compile("((http[s]?://)?google[a-z.]*)") # match all
re.compile("((http[s]?://)?.+\.google[a-z.]*)") # match except 0,3,6
re.compile("((http[s]?://)?!.+\.google[a-z.]*)") # match nothing
</code></pre>
<p>Here, I am seeking a way to ignore <code>*.google.*</code> except <code>www.google.*</code> and <code>google.*</code>. But I got stuck while finding a way to get <code>*.google.*</code>.</p>
<hr/>
<p>PS: I have found a O(n**2) way with <code>split()</code> to solve this.</p>
<pre><code>r = re.compile("^((http[s]?://)?www.google[a-z.]*)|^((http[s]?://)?google[a-z.]*)")

for s in test_str:
    for seg in s.split():
        r.findall(seg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use</p>
<pre><code>(?&lt;!\S)(?:https?://)?(?:www\.)?google\.\S*
</code></pre>
<p>See the <a href="https://regex101.com/r/hW8NkU/1" rel="nofollow noreferrer">regex demo</a>.</p>
<p><strong>Details</strong></p>
<ul>
<li><code>(?&lt;!\S)</code> - a location preceded with a whitespace or start of a string (note that you may also use <code>(?:^|\s)</code> here, to be more explicit)</li>
<li><code>(?:https?://)?</code> - an optional non-capturing group matching an optional sequence of <code>https://</code> or <code>http://</code></li>
<li><code>(?:www\.)?</code> an optional non-capturing group matching an optional sequence  of <code>www.</code></li>
<li><code>google\.</code> - a <code>google.</code> substring</li>
<li><code>\S*</code> - 0+ non-whitespace chars.</li>
</ul>
<p><a href="https://ideone.com/PUvhUU" rel="nofollow noreferrer">Python demo</a>:</p>
<pre><code>import re
test_str = [
    "bla bla google.com bla bla", #0
    "bla bla www.google.com bla bla", #1
    "bla bla api.google.com bla bla", #2
    "google.com", #3
    "www.google.com", #4
    "api.google.com", #5
    "http://google.com", #6
    "http://www.google.com", #7
    "http://api.google.com", #8
    "bla bla http://www.google.com bla bla", #9
    "bla bla https://www.api.google.com bla bla", #10
    "bla bla https://www.map.google.com bla bla" #11
]
r = re.compile(r"(?&lt;!\S)(?:https?://)?(?:www\.)?google\.\S*")
for i,s in enumerate(test_str):
    m = r.search(s)
    if m:
        print("{}\t#{}".format(m.group(0), i))
</code></pre>
<p>Output:</p>
<pre><code>google.com  #0
www.google.com  #1
google.com  #3
www.google.com  #4
http://google.com   #6
http://www.google.com   #7
http://www.google.com   #9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Had my keyboard been working properly I would have answered a half hour before.</p>
<p>Anyway, I would recommend to not exaggerate the complexity of regexes. You can use the host language to manage black- (and even white-) lists and use the <code>re</code> module auxiliary. Below is what I did all packed inside a script. Obviously you may need some restructuring if you have to integrate this code into a class or function:</p>
<pre><code>import re

def main():
    input_urls = [ 
        "bla bla google.com bla bla",
        "bla bla www.google.com bla bla",
        # ...
    ]   
    filtered_urls = set()

    google_re = re.compile("(\w+\.)?google.com")
    blacklist = set(["api."])   # I didn't research enough to remove the dot

    for url in input_urls:
        # Beware of the difference between match() and search()
        # See https://docs.python.org/3/library/re.html#search-vs-match
        match = google_re.search(url)

        # The second condition will not be evaluated if the first fails
        if match is not None and match.group(1) not in blacklist:
            filtered_urls.add(url)

    print("Accepted URLs:", *filtered_urls, sep="\n\t", end="\n\n")
    print("Blacklisted URLs:", *(set(input_urls).difference(filtered_urls)), sep="\n\t")


if __name__ == "__main__":
    main()
</code></pre>
<p>Unfortunately, with my <code>a</code> and <code>h</code> keyboard keys not working, I wasn't able to quickly find a way to remove the dot in the URL location (like in <code>api.google</code>, <code>www.google</code>, <code>calendar.google</code> and so on). I highly recommend to do that.</p>
<p>The output displayed on my console was:</p>
<pre><code>None@vacuum:~$ python3.6 ./filter.py 
Accepted URLs:
    http://google.com
    bla bla google.com bla bla
    bla bla www.google.com bla bla
    http://www.google.com
    google.com
    www.google.com
    bla bla http://www.google.com bla bla

Blacklisted URLs:
    api.google.com
    bla bla api.google.com bla bla
    http://api.google.com
    bla bla https://www.api.google.com bla bla
</code></pre>
</div>
<span class="comment-copy">See <a href="https://ideone.com/3Cwfiu" rel="nofollow noreferrer">ideone.com/3Cwfiu</a></span>
<span class="comment-copy">@WiktorStribiżew Thanks. I have an additional question for your answer. If <code>api</code> is not fixed, but I want to filter all of them, such as <code>map.google.*</code>, <code>calendar.google.*</code>. Is this means that I need to add them one by one?</span>
<span class="comment-copy">You may either use the lookbehind approach, and that means you will have to chain the lookbehinds like <code>(?&lt;!\bapi)(?&lt;!\bmap)</code>, or you may use a lookahead based approach, like <a href="https://ideone.com/YswL5x" rel="nofollow noreferrer"><code>r"(?&lt;!\S)(?!\S*\b(?:map|api))\S*\bgoogle\b\S*"</code></a> where you may add the blacklisted terms to the alternation group.</span>
<span class="comment-copy">Thanks for your explanation. Since it is a blacklist way, I am still curious about a whitelist way.</span>
<span class="comment-copy">@WiktorStribiżew Thanks! I believe this is what I want. Your assumptions are correct, http(s) and www are options here. I need to learn more about <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">lookbehinds</a>. Please put your answer below, I will give the answer to you.</span>
