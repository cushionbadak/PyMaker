<div class="post-text" itemprop="text">
<p>I have a DLL in c and meant for windows platforms which has a structure similar to the following:</p>
<p><strong>C Structure</strong></p>
<pre><code>typedef struct some_struct {
    int (_stdcall *function)(int arg1, int arg2);
    ...
}SOME_STRUCT;
</code></pre>
<p>I've defined a python ctypes structure to mimic this with the following</p>
<p><strong>Python Structure</strong></p>
<pre><code>class SOME_STRUCT(Structure):
    _fields_ = [('function', POINTER(CFUNCTYPE(c_int, c_int, c_int))), ...]
</code></pre>
<p>The point of this structure in the C code is to register a callback function that gets executed upon certain triggers in its own thread. What I want to be able to do, if possible, is set that callback to be a Python function such that when the function in the C structure gets called from the C code, it is the python function that gets executed.</p>
<p>What I've got in python to try and accomplish this (which doesn't work) is the following:</p>
<pre><code>def func(arg1,arg2):
    print('I was called!')
    return 0

struct = SOME_STRUCT()
prototype = CFUNCTYPE(c_int, c_int, c_int)
struct.function = byref(prototype(func))
</code></pre>
<p>The specific error I get (that may not be my only issue) is that it complains that <code>struct.function</code> was expecting a <code>LP_CFunctionType</code> instance but got a <code>CArgObject</code> instance. How can I do what I'm trying to do?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a working example and test DLL source.  Oddly, I couldn't get it to work when the callback was the only member of the struct (crash).  It seemed like a bug, because a callback without a struct wrapper or adding a second member to the struct made it work.</p>
<p>Things to note:</p>
<ul>
<li>Use <code>WINFUNCTYPE</code> with <code>__stdcall</code>.  <code>CFUNCTYPE</code> is for <code>__cdecl</code>.</li>
<li>You don't need <code>POINTER</code> or <code>byref</code> to make it work.</li>
<li>The <code>@CALLBACK</code> decorator is equivalent to <code>func = CALLBACK(func)</code>.</li>
</ul>
<p><strong>test.c</strong></p>
<pre><code>#include &lt;stdio.h&gt;

typedef int (__stdcall *CALLBACK)(int arg1, int arg2);

typedef struct some_struct {
    CALLBACK function;
    int other;
} SOME_STRUCT;

__declspec(dllexport) int func(SOME_STRUCT* pss)
{
    printf("%d\n",pss-&gt;other);
    return pss-&gt;function(1,2);
}
</code></pre>
<p><strong>test.py</strong></p>
<pre><code>from ctypes import *

CALLBACK = WINFUNCTYPE(c_int,c_int,c_int)

class SOME_STRUCT(Structure):
    _fields_ = [('function', CALLBACK),
                ('other', c_int)]

@CALLBACK
def callback(arg1,arg2):
    return arg1 + arg2

dll = CDLL('test')
dll.argtypes = POINTER(SOME_STRUCT),
dll.restype = c_int

struct = SOME_STRUCT(callback,7)
print(dll.func(byref(struct)))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>7
3
</code></pre>
</div>
<span class="comment-copy">The example in the ctypes docs <a href="https://docs.python.org/3/library/ctypes.html#callback-functions" rel="nofollow noreferrer">docs.python.org/3/library/ctypes.html#callback-functions</a> doesn't use the call to <code>byref</code> as you are doing.  Does it work if you remove the byref call and just do <code>struct.function = prototype(func)</code>?</span>
<span class="comment-copy">@PaulCornelius I tried doing that but the function never seems to get called then. I never see an output from it. I was trying to follow the example you pointed out, but I believe I need <code>byref</code> or something similar since I'm trying to assign a pointer to a function rather than a function itself (which the example is doing).</span>
<span class="comment-copy">In that case I have one more thought.  If CFUNCTYPE returns an object that represents a pointer to a function, maybe you don't want the POINTER() function call in your structure definition.</span>
<span class="comment-copy">Thanks so much. This has been very useful. One minor thing though, I had to do <code>dll.func(byref(struct))</code> (last line of test.py) to make the call work.</span>
<span class="comment-copy">@zephyr It worked without it for me but that is more technically correct.  Did you have the final comma in <code>argtypes</code>?  It must be a sequence and that makes it a tuple.</span>
<span class="comment-copy">Yes, I did. In fact I copied and pasted your two programs and they worked just fine with the exception of the need for the byref. Without it, I get an OSError saying an access violation when writing to some random memory address.</span>
<span class="comment-copy">@zephyr 32-bit or 64-bit Python?  I'm just wondering why it worked for me and looking for the difference. I was using 64-bit and am guessing the marshaling of a struct is always by pointer in that ABI.  It might also explain why I crashed when there was only one structure member. I'll have to go back and try that fix.</span>
<span class="comment-copy">I'm using 32-bit.</span>
