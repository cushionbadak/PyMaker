<div class="post-text" itemprop="text">
<p>I'm trying to understand how Python 3 handles the index variable value at the completion of a for loop. I'm a python newbie, with prior programming experience in C, so at this point, I "think" in C, and try to construct the equivalent code in Python.</p>
<p>Here's a toy example . . .</p>
<pre><code>def tst(n): return n==6

for i in range(8,0,-1):
    if tst(i): break
print(i)

for i in range(4,0,-1):
    if tst(i): break
print(i)
</code></pre>
<p>After the first loop completes, the value of the variable <code>i</code> is <code>6</code>, as expected.</p>
<p>But after the second loop completes, I expected (from my C experience) that the value of <code>i</code> would be <code>0</code> (i.e., the final value of <code>i</code> would fall one past the end of the range, unless there was a break), but the actual value is <code>1</code>. </p>
<p>I want it to be <code>0</code>.</p>
<p>As an alternative, I could code the second loop this way:</p>
<pre><code>i=4
while i&gt;0:
   if tst(i): break
   i-=1
print(i)
</code></pre>
<p>which works the way I want.</p>
<p>Is that the way to do it?</p>
<p><strong>Update:</strong>
<p>
Thanks to all for explaining how Python interprets range expressions.
<p>
Using juanpa.arrivillaga's suggestion, I've settled for the following . . .</p>
<pre><code>for i in range(4,0,-1):
    if tst(i): break
else:
    i=0
print(i)
</code></pre>
</p></p></div>
<div class="post-text" itemprop="text">
<p>You misunderstood how <code>range()</code> works; the <code>stop</code> value is not included:</p>
<pre><code>&gt;&gt;&gt; list(range(4, 0, -1))
[4, 3, 2, 1]
</code></pre>
<p>If you want the range to go down to 0, use <code>-1</code> as the end value:</p>
<pre><code>&gt;&gt;&gt; list(range(4, -1, -1))
[4, 3, 2, 1, 0]
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow noreferrer"><code>range()</code> object documentation</a>:</p>
<blockquote>
<p>For a positive <em>step</em>, the contents of a range <code>r</code> are determined by the formula <code>r[i] = start + step*i</code> where <code>i &gt;= 0</code> and <code>r[i] &lt; stop</code>.</p>
<p>For a negative <em>step</em>, the contents of the range are still determined by the formula <code>r[i] = start + step*i</code>, but the constraints are <code>i &gt;= 0</code> and <code>r[i] &gt; stop</code>.</p>
</blockquote>
<p><code>r[i] &gt; stop</code> means it'll never be equal to <code>stop</code>.</p>
<p>Your <code>while</code> loop decrements <code>i</code> <strong>after you tested it</strong>, so <code>i &gt; 0</code> is still true for <code>i = 1</code>, but then you substracted <code>1</code>, making it <code>i = 0</code>, at which point the <code>while</code> test is false and the loop ends.</p>
<p>Note that you can't really compare Python's <code>for</code> construct with C <code>for</code>. The Python concept is a <a href="https://en.wikipedia.org/wiki/Foreach_loop" rel="nofollow noreferrer"><em>For each</em> loop</a>, while the <code>C</code> construct is really a <em>setup, test, alter</em> construct, which executes <em>setup</em> once, then repeats until the test fails, running the <em>alter</em> instructions after every repetition. This is what your <code>while</code> loop did too; the <em>setup</em> is <code>i = 4</code>, the <em>test</em> is <code>i &gt; 0</code> and the <em>alter</em> instruction is your <code>i -= 1</code> at the end, at the end of the loop body.</p>
<p>If you wanted think about Python <code>for</code> loops in C terms, the closest I can think of is a <code>for</code> loop over a pointer:</p>
<pre><code>int range[] = { 4, 3, 2, 1 }
for (int* p1=range; p1 &lt; (range + (sizeof(range)/sizeof(range[0]))); p1++)
{
   // ...
} 
</code></pre>
<p>You'd have to add a <code>, 0</code> in the <code>range[]</code> definition if you wanted it to continue on to <code>0</code>. Python <code>for</code> loops handle any iterable however, including infinite generators; see the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">iterator protocol</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>That≈õ because the stop value it's not included. This it's the sintax of range:</p>
<pre><code>range([start], stop[, step])

    start: Starting number of the sequence.
    stop: Generate numbers up to, but not including this number.
    step: Difference between each number in the sequence.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the way to think about it. In Python, the <code>for</code> loop always iterates over a collection of objects. When the loop finishes, the index variable will always hold the last object from the collection. The thing that's tripping you up is that the Python <code>range()</code> function is non-inclusive at the end. See the documentation at <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-range" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#typesseq-range</a>.</p>
<p>So in your case, the second loop is iterating correctly over <code>range(4,0,-1)</code>, which is equivalent to <code>[4, 3, 2, 1]</code>, not <code>[4, 3, 2, 1, 0]</code>. So <code>i</code> ends up with the last value in that collection, which is 1. If you want to include 0 in the range, you have to use <code>range(4, -1, -1)</code>. </p>
<p>I find this behavior of <code>range()</code> confusing, but it's a very standard Python element. It works well if you want a loop to repeat <code>n</code> times -- just use <code>range(n)</code> to get [0, 1, ..., n-1]. String and collection indexing work similarly: <code>mystring[:4]</code> gives you everything <em>before</em> element 4 of <code>mystring</code>. That behavior can be nice if you are splitting strings: <code>mystring[:4]</code> gives you the first 4 characters, and then <code>mystring[4:]</code> gives you everything after that. This saves you from having to add 1 to your indexes in various places or remember to use <code>i&lt;3</code> (not <code>i&lt;=3</code>) as you would in C. </p>
<p>On the other hand, if you want a list of numbers from 1 to 5 (inclusive), you have to remember to use something like <code>range(1, 5+1)</code>. (I sometimes to use +1 as a reminder that this is forcing the range a little further, and so that the <code>range</code> call shows the actual stopping point somewhere.)</p>
</div>
<div class="post-text" itemprop="text">
<p>the problem you have is with <code>range(4,0,-1)</code> this returns <code>[4, 3, 2, 1]</code>
change it to <code>range(4,-1,-1)</code></p>
</div>
<span class="comment-copy">stop argument of for loop in python is not included</span>
<span class="comment-copy">But I don't want to actually pass 0 to tst. I Just want to know that the break didn't happen. So range(4,-1,-1) is not quite what I want.</span>
<span class="comment-copy">@pyrat: but there is no <code>6</code> in <code>range(4, 0, -1)</code>..</span>
<span class="comment-copy">Exactly. So I want the final i value to be the value of i for which tst returns True, or else, if the loop completes without a break, I want the value of i to be 0. My alternative example does just that.</span>
<span class="comment-copy">@pyrat: then use <code>range(4, -1, -1)</code>, because <code>i</code> is only ever going to be assigned values from the <code>range()</code> iterable. Python <code>for</code> loops are <a href="https://en.wikipedia.org/wiki/Foreach_loop" rel="nofollow noreferrer"><i>for each loops</i></a>, not C <code>for</code> loops.</span>
<span class="comment-copy">The problem with range(4,-1,-1) is that the actual tst (not the toy example) doesn't accept 0 as an input, only positive integers.</span>
<span class="comment-copy">Thanks, I follow now. Nice explanation.</span>
<span class="comment-copy">"Always iterates over a collection of objects." Nice. That resolves the confusion. Thanks.</span>
