<div class="post-text" itemprop="text">
<p>First program in book fluent Python. I simplified the program.</p>
<pre><code>class Test:
    a = 15
    def __init__(self):
        self.att = a

t = Test()
print(t.att)
</code></pre>
<p>It didn't work, and if i use</p>
<pre><code>self.att = Test.a
</code></pre>
<p>then it worked.
Why should I always use Test.a even in class Test?
I learned java, and I don't have to do so.</p>
<p>Also, here comes another problem.</p>
<pre><code>class Test:
    a = 15
    def __init__(self, b=Test.a):
        self.att = b

t = Test()
print(t.att)
</code></pre>
<p>It didn't work. I searched on the site.
And is the reason that:
default arguments should be defined while function definition, not till being called?</p>
<p>And since </p>
<pre><code>self.att = Test.a
</code></pre>
<p>worked, so function content will be checked for valid till being called?</p>
<p>Am I right?</p>
<p>Class Test will be ready after #1, but before, I used Test.a, because it didn't check function content before being called. right?</p>
<pre><code>class Test:
    a = 15
    def __init__(self):
        self.att = Test.a 
    #1
t = Test() 
print(t.att)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Members like that need to be accessed like this: <code>self.a</code> (even in the <code>__init__</code> method)</p>
<pre><code>class Test:
    a = 15
    def __init__(self):
        self.att = self.a

t = Test()
print(t.att)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I learned java, and I don't have to do so.</p>
</blockquote>
<p>But if you compare Java with Python, you will notice that you will have to prefix <code>self</code> for every instance member, and you actually need your methods to take that <code>self</code> argument in all the time. So you cannot really expect Java behavior here.</p>
<p>But just like with methods or instance variables, you can access <em>class members</em> using <code>self</code> as well:</p>
<pre><code>class Test:
    a = 15
    def __init__(self):
        self.att = self.a
</code></pre>
<p>At runtime of <code>__init__</code>, <code>self</code> will refer to the instance of your <code>Test</code> type. So when you want to access anything on the instance, you need to do that on <code>self</code>. For class members, all its members are also visible on the instance (unless they are hidden by instance members), so <code>self.a</code> works just like <code>Test.a</code> works. You can also try this with your created instance <code>t</code>: <code>t.a</code> will also work even though there is no <em>instance</em> member <code>a</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason is <code>__init__</code> is executed on object creation; inside your <code>__init__</code> function scope there is no <code>a</code> variable defined. How should it know you mean the <code>a</code> defined in the class?</p>
<p>When stating <code>Test.a</code> you explicity tell python to use the class attribute. When you are using <code>self.a</code> Python uses the <strong>MRO</strong> lookup process to find the <code>a</code> attribute.</p>
<pre><code>class Test:
    a = 15
    def __init__(self):
        self.att = self.a 
    #1
t = Test() 
print(t.att)
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/classes.html#classes" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html#classes</a></span>
<span class="comment-copy">Why do they need to be accessed by <code>self.a</code>? (Suggested answer update - not expecting a comment)</span>
<span class="comment-copy">Thanks. I know this worked, but why?</span>
