<div class="post-text" itemprop="text">
<p>I need this function to return the sum of the elements located at the odd indices. 
And that's what I have right now:</p>
<pre><code>def getSumOdds(aList):
    for element in aList:
        if element % 2 == 1:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the code you've already started, <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> is probably the function you want which returns the count and the values in the list. Then we filter the odd indices and add them to a variable for the sum, as you had already done:</p>
<pre><code>def getSumOdds(aList):
    total = 0
    for index, element in enumerate(aList): 
        if index % 2 == 1:
            total += element
    return total

l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print getSumOdds(l) # 20 (odd indices: 2+4+6+8=20)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you are doing <code>for element in aList</code>, <code>element % 2 == 1</code> will check if <em>each element</em> is odd, not if its index is odd.</p>
<p>What you can do is this:</p>
<pre><code>value = 0
for index in range(len(aList)):
    if index % 2 == 1:
        value += aList[value]
</code></pre>
<p>This goes through all of the <em>indices</em>, and if it's odd, adds the element <em>at that index</em> to the accumulator.</p>
<p>That method is fairly easy to understand; however, it goes through an unnecessary number of elements:</p>
<pre><code>value = 0
for index in range(1, len(aList), 2):
    value += aList[index]
</code></pre>
<p><code>range(x, y, z)</code> generates all elements counting up from <code>x</code> up to but not including <code>y</code>, counting by <code>z</code>. This starts at 1 and takes every 2 elements.</p>
<p>This is rather long though, and can be shortened to the following:</p>
<pre><code>value = sum(aList[index] for index in range(1, len(aList), 2))
</code></pre>
<p>Using list slicing, where <code>aList[start:end:jump]</code> gives every <code>jump</code>-th element starting from <code>start</code> up to <code>end</code> (implicity the very end), you can do the following:</p>
<pre><code>value = sum(aList[1::2])
</code></pre>
<p>This sums every second element starting from the first.</p>
<p>If your input is not necessarily indexable (that is, it's iterable but cannot use <code>[index]</code> syntax, such as a set, range, map, etc), you can do:</p>
<pre><code>value = sum(val for index, val in enumerate(anIter) if index % 2 == 1)
</code></pre>
<p>This sums every value where the index is odd by getting the index and value for each enumerated value. The <code>enumerate</code> function is an iterable which returns <code>(0, a[0]), (1, a[1]), ..., (len(a) - 1, a[-1])</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just you can use a list slice <code>list[1::2]</code>
or function</p>
<pre class="lang-py prettyprint-override"><code>def getSumOdds(aList):
    return sum(aList[1::2])
</code></pre>
</div>
<span class="comment-copy">Welcome to SO. Unfortunately this isn't a study group, discussion forum or code writing service. Please take the time to read <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a> and the links referenced in it.</span>
<span class="comment-copy">When you post code or data please fomat it - <a href="https://stackoverflow.com/editing-help#comment-formatting">stackoverflow.com/editing-help#comment-formatting</a></span>
<span class="comment-copy">Who voted for this to be closed because it's too broad? That vote may be misplaced. There are a few ways to do it, true - however, the most Pythonic way uses the builtin <code>sum</code> function, as well as a generator in tandem with <code>enumerate</code>.</span>
<span class="comment-copy">Note: You could handle arbitrary iterable (possibly non-indexable) types <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer">with <code>itertools.islice</code></a> and avoid index calculations. <code>sum(itertools.islice(anIter, 1, None, 2))</code> and you don't need to track indices at all (and dropping unused values is handled efficiently at the C layer to boot). So really, the only two solutions worth considering speed and succinctness-wise are actual slice and <code>islice</code> approaches; the former is faster but sequence only, the latter is slower but handles all iterables.</span>
<span class="comment-copy">@ShadowRanger Cool, thanks for the additional information!</span>
