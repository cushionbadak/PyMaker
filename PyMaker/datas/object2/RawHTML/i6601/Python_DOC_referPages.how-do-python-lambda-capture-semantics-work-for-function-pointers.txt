<div class="post-text" itemprop="text">
<p>Basically, in the example below, why do the lambdas in <code>f2</code> capture a reference to the list comprehension loop variable, but those in <code>f3</code> "capture" (really, they just accept an argument) "the way we expect" lambda capture to work?</p>
<pre><code>f1 = [lambda x: x, lambda x: x + 1, lambda x: x + 2]
print([f(0) for f in f1])
f2 = [lambda x: f(x) + 1 for f in f1]
print([f(0) for f in f2])
f3 = [(lambda ff: lambda x: ff(x) + 1)(f) for f in f1]
print([f(0) for f in f3])
</code></pre>
<p>The three lines outputted are:</p>
<pre><code>[0, 1, 2]
[3, 3, 3]
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python closures always capture variables, not objects.</p>
<p>In <code>f2</code>,</p>
<pre><code>f2 = [lambda x: f(x) + 1 for f in f1]
</code></pre>
<p>all lambdas in the list capture the <code>f</code> variable, not the object the variable refers to at the time the lambda is defined. At the end of the comprehension, <code>f</code> refers to the last function in <code>f1</code>, so all lambdas in <code>f2</code> find that function when they look up <code>f</code>.</p>
<p>In <code>f3</code></p>
<pre><code>f3 = [(lambda ff: lambda x: ff(x) + 1)(f) for f in f1]
</code></pre>
<p>each call to <code>(lambda ff: lambda x: ff(x) + 1)</code> creates a new local <code>ff</code> variable, and each <code>lambda x: ff(x) + 1</code> captures a different <code>ff</code> variable. Unlike <code>f</code>, the <code>ff</code> variables are never reassigned, so the <code>lambda x: ff(x) + 1</code> functions each see a different value of <code>ff</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>f</code> is the same variable throughout the list comprehension. A simpler example:</p>
<pre><code>&gt;&gt;&gt; fs = [lambda: x for x in [1, 2]]
&gt;&gt;&gt; fs[0]()
2
</code></pre>
<p>One common hack to work around this without the extra lambda wrapper is to use a default (as defaults are evaluated when the function is), but that can be confusing to those new to the idiom and you should generally split it out into a new function instead.</p>
<pre><code>&gt;&gt;&gt; fs = [lambda x=x: x for x in [1, 2]]
&gt;&gt;&gt; fs[0]()
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the second example, <code>f</code> is a free variable in the lambdas in <code>f2</code> which is bound into their enclosing scope (the list comprehension). The functions take <code>f</code>'s value at the time they are called.    The functions in <code>f2</code> are called in the following print statement, at which point <code>f</code> is already the third lambda from <code>f1</code>.
Note that <code>f</code> is never in the scope in which <code>f1</code>, <code>f2</code> and <code>f3</code> are defined (presumably global or some broader function scope), but the lambdas always reference their enclosing scope which contains <code>f</code>.</p>
<p>In contrast, <code>ff</code> is a parameter in the outer lambdas <code>f3</code>, but it is bound in the call to those outer lambdas, which happens in the list comprehension that defines <code>f3</code>.</p>
</div>
<span class="comment-copy">note:  I took the liberty of tagging Python 3 because you rely on the list comp function scope in this code.</span>
<span class="comment-copy">There are <i>no pointers in Python</i>. There are only objects, and the semantics work the same for all object types.</span>
<span class="comment-copy">Possible <a href="https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture">duplicate</a></span>
<span class="comment-copy">So note, the behavior you see here isn't unique to lambda functions,but would work the same way with free variables using an equivalent <code>def</code> statement.</span>
<span class="comment-copy">This object-variable was the distinction I was looking for -- are there any relevant docs I could read on this? It seems that the argument <code>(f)</code> in the <code>f3</code> example gets passed by "object value", so then <code>ff</code> becomes a variable with the corresponding object value from <code>f1</code>.</span>
<span class="comment-copy">@VF1: There are the <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">Python execution model docs</a>, and the <a href="https://www.python.org/dev/peps/pep-0227/" rel="nofollow noreferrer">original closure PEP</a>. <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Ned Batchelder's writeup on Python variable and assignment semantics</a> may also be useful, particularly the part about how function arguments are passed.</span>
<span class="comment-copy">This doesn't really answer my question. I'm aware that the comprehension has the same variable - I'm asking why <code>f3</code> "works".</span>
<span class="comment-copy">@VF1: In <code>f3</code>, <code>ff</code> is not the same variable each time. It’s not even a variable in the same function – you have as many <code>(lambda ff: …)</code>s as elements in <code>f1</code>, and each time they’re called they create a scope with a <code>ff</code>, which becomes part of the <code>lambda x: ff(x) + 1</code> closure. In other words: <code>f2</code> has one variable <code>f</code> shared by every <code>lambda</code>; <code>f3</code> has <i>n</i> variables <code>ff</code>, each associated with a different <code>lambda</code>.</span>
<span class="comment-copy">@chepner Right, but the lambda's scope is the list comprehension's scope.  The lambda keeps that scope alive.</span>
<span class="comment-copy">Rereading what I wrote, I think it was correct, but I've added a bit more discussing the list comprehension scope</span>
