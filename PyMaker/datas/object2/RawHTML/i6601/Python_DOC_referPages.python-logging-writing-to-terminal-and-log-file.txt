<div class="post-text" itemprop="text">
<p>I have two files: <code>script.py</code> and <code>functions.py</code>. In <code>functions.py</code>, I have logger setup, and a set of functions (made up one below):</p>
<pre><code>class ecosystem():
    def __init__(self, environment, mode):
        self.logger = logging.getLogger(__name__)
            if os.path.exists('log.log'):
                os.remove('log.log')

            handler= logging.FileHandler('log.log')
            if mode.lower()== 'info':
                handler.setLevel(logging.INFO)
                self.logger.setLevel(logging.INFO)
            elif mode.lower()== 'warning':
                handler.setLevel(logging.WARNING)
                self.logger.setLevel(logging.WARNING)
            elif mode.lower()== 'error':
                handler.setLevel(logging.ERROR)
                self.logger.setLevel(logging.ERROR)
            elif mode.lower()== 'critical':
                handler.setLevel(logging.CRITICAL)
                self.logger.setLevel(logging.CRITICAL)
            else:
                handler.setLevel(logging.DEBUG)
                self.logger.setLevel(logging.DEBUG)

            #Logging file format
            formatter = logging.Formatter('    %(levelname)s | %(asctime)s | %(message)s \n')
            handler.setFormatter(formatter)
            #Add the handler to the logger
            self.logger.addHandler(handler)

            self.logger.info('Logging starts here')

    def my_function():
        self.logger.debug('test log'))
        return True
</code></pre>
<p>I'm trying to call <code>ecosystem.my_function</code> from <code>script.py</code>, but when I do, the <code>logger.debug</code> message shows up in both the terminal window AND <code>log.log</code>. Any ideas why this might be happening? </p>
<p>If it helps, I also import other modules into <code>functions.py</code>, if those modules import logging as well, could that cause issues?</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you're initializing the logger with <code>log.log</code> file inside the <code>__init__</code> method of <code>ecosystem</code> class. This means that any code that creates an object of <code>ecosystem</code> will initialize the logger. Somewhere in your code, in one the files, you are creating that object and hence the logger is initialized and writes to the file. </p>
<p>Note that you do not need to call <code>__init__</code> yourself as it is called on object creation. ie. after this call</p>
<pre><code>my_obj = ecosystem()
</code></pre>
<p>log files will be written.</p>
<p>You're asking why both stderr and file is used after your new file handler is attached. This is because of the propagate attribute. By default propagate is True and this means your log will bubble up the hierarchy of loggers and each one will continue handling it. Since default root logger is at the top of the hierarchy, it will be handling your log too. Set <code>propagate</code> to False fix this:</p>
<pre><code>self.logger.propagate = False
</code></pre>
<p>You might want to read up a bit on <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">logging</a>. Also, if you want to keep your sanity regarding logging, <a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig" rel="nofollow noreferrer">check how you can use dict to configure logging</a>.</p>
</div>
<span class="comment-copy">Yes, I want to initialize the logger in the <code>ecosystem</code> class. But why would this cause the log to write to the terminal window AND the <code>log.log</code> file? Because it's being called twice somewhere?</span>
<span class="comment-copy">@Scott I've added more information to the answer above. This is because of propagation.</span>
<span class="comment-copy"><code>self.logger.propagate = False</code> did the trick! Thank you!</span>
