<div class="post-text" itemprop="text">
<p>I've done a research over similar questions on this subject, but didn't find a duplicate.</p>
<p>It is stated that an object is <em>iterable</em> if it implements <code>__iter__</code> protocol.</p>
<blockquote>
<p><code>iterator.__iter__()</code>:
  Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements.</p>
<p><code>iterator.__next__()</code>:
  Return the next item from the container. If there are no further items, raise the StopIteration exception.</p>
</blockquote>
<p>From my understanding this applies to all <em>iterator objects</em>. I've encountered a code that implements a binary-tree container. The container only has <code>__iter__</code> and so does the node objects resides in it.</p>
<p>The <code>__iter__</code> implementation of the Node objects returns a <em>generator</em>. It yields objects and seems to do <strong>all the logic</strong>, without an implementation of <code>__next__</code>.</p>
<p>How this code actually works? It seems to function just as a regular <em>iterator</em>, but this one has no <code>__next__</code>. Ofcourse if I manually do <code>iter(obj)</code> and then <code>next(obj)</code> it works. Here is the code snippet:</p>
<pre><code>class BinaryCont(object):

    def __init__(self):
        self.root = None
        self.size = 0

    def __iter__(self):

        class EmptyIter():
            def next(self):
                raise StopIteration

        if self.root:
            return self.root.__iter__()
        return EmptyIter()

class Node(object):

    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def __iter__(self):
        if self.has_left_child():
            for child in self.left:
                yield child

        yield self.val

        if self.has_right_child():
            for child in self.right:
                yield child
</code></pre>
<p>An example of running code</p>
<pre><code>bt = BinaryCont()
bt.insert(5)
bt.insert(3)
bt.insert(7)
for node in bt:
    print node

3
5
7

it = iter(bt)
type(it)
&lt;type 'generator'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>__iter__</code> method is a <a href="https://docs.python.org/3/glossary.html#term-generator" rel="noreferrer"><em>generator function</em></a>, because it uses <a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="noreferrer"><code>yield</code></a> in the function body. A generator function, when called, returns a generator object. It is <em>that object</em> that has a <code>__next__</code> method. </p>
<p>Your <code>Node</code> is not an iterator itself. It is merely an <em>iterable</em> object; an iterable object returns a new iterator instance when you call it's <code>__iter__</code> method, which is what happens here.</p>
</div>
<div class="post-text" itemprop="text">
<p>A generator very much does have a <code>__next__</code> method. You just don't implement it yourself. A "function" with a <code>yield</code> statement does not run your code. It returns an object that runs your code. That object has a <code>__next__</code> method.</p>
<p>You may also want to note that there is one other mechanism for making an object iterable: providing <code>__len__</code> and <code>__getitem__</code> methods. In that case, iteration will occur over the indices from zero to len-1.</p>
</div>
<span class="comment-copy">It is much more clear to me after reading your answer and the <i>generator function</i> docs. Thanks a lot</span>
