<div class="post-text" itemprop="text">
<p>I'm doing an assignment for school and I'm supposed to time a python implementation of an integration function alongside a numpy implementation of the same. I would normally expect numpy to perform better than the python implementation, but that is not the case. I'm getting roughly 4x the speed using list comprehension in python compared to numpy arrays. This holds true from N=1000 up to N=100 000. Haven't tested anything higher as N=100 000 is about where I need to be to get an acceptable error in my estimation.</p>
<p>Regular python code:<br/>
    f is the function being integrated, a and b are limits and N is number of points to integrate over</p>
<pre><code>def integrate(f, a, b, N):
    x_val = [a + (i*b) / N for i in range(N+1)]
    return sum([f(x_val[i]) * (x_val[i] - x_val[i-1]) for i in range(1, len(x_val))])
</code></pre>
<p>Numpy code:</p>
<pre><code>def numpy_integrate(f, a, b, N):
    x_val = numpy.zeros(N+1)
    x_val[0] = a
    res = 0
    for i in numpy.arange(1, len(x_val)):
        x_val[i] = a + (i*b)/N
        res += f(x_val[i]) * (x_val[i] - x_val[i - 1])

    return res
</code></pre>
<p>It may be that I'm doing something horribly wrong with my numpy implementation, or is the regular list comprehension just that much faster at this scale?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, there is a mistake in your code, it only gives the right result for <code>a=0</code>. You need to replace <code>a + (i*b)/N</code> by <code>a + i*(b - a)/N</code>.</p>
<p>As COLDSPEED said in the comments, you are not making the most of numpy capabilities by using a for loop. Here is a more efficient version using array slices:</p>
<pre><code>def numpy_integrate2(f, a, b, N):
    x_val = a + numpy.arange(N+1)*(b - a)/N
    return (f(x_val[1:]) * (x_val[1:] - x_val[:-1])).sum()
</code></pre>
<p>This version was fifty time faster than your <code>intergrate</code> function when I tested it with the square function, a = 1, b = 2 and N = 100000.</p>
<p><strong>EDIT</strong>: I have noticed that it is even faster to define <code>x_val</code> with: </p>
<pre><code>x_val = numpy.arange(a, b + (b - a)/N, (b - a)/N)
</code></pre>
<p>Remark: this answer works only if the function <code>f</code> can be applied on an array.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends a bit on your <code>f</code>, if that allows to process arrays then you could use:</p>
<pre><code>import numpy as np

def integrate(f, a, b, N):
    x_val = a + b / N * np.arange(N+1)
    return (f(x_val[1:]) * np.diff(x_val)).sum()
</code></pre>
<p>This is using vectorized and broadcasting operations to make it (much) faster.</p>
<p>If your <code>f</code> can't process arrays element-wise you should either make it process arrays or you need to create another array there:</p>
<pre><code>def integrate(f, a, b, N):
    x_val = a + b / N * np.arange(N+1)
    return (np.array([f(val) for val in x_val[1:].tolist()]) * np.diff(x_val)).sum()
</code></pre>
<hr/>
<p>Note that you can also make your list-approach faster. That's because iterating over the elements is usually faster than iterating over the elements and you don't need a list-comprehension for <code>sum</code>, a generator will do just as nicely (and is more memory-efficient):</p>
<pre><code>from itertools import tee

def pairwise(iterable):  
    # taken from https://docs.python.org/3/library/itertools.html#itertools-recipes 
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

def integrate(f, a, b, N):
    x_val = [a + (i*b) / N for i in range(N+1)]
    return sum(f(nxt) * (nxt - prev) for prev, nxt in pairwise(x_val))
</code></pre>
</div>
<span class="comment-copy">You shouldn't be using loops when working with numpy.</span>
<span class="comment-copy">Ok, so how would you rewrite the calculations to not use loops?</span>
