<div class="post-text" itemprop="text">
<p>I have a large file that can have strings like <code>file_+0.txt, file_[]1.txt, file_~8.txt</code> etc.</p>
<p>I want to find the missing <code>files_*.txt</code> until a certain number. </p>
<p>For example if I give the below file and a number 5, it should tell that the missing ones are <code>1 and 4</code></p>
<pre><code>asdffile_[0.txtsadfe
asqwffile_~2.txtsafwe
awedffile_[]2.txtsdfwe
qwefile_*0.txtsade
zsffile_+3.txtsadwe
</code></pre>
<p>I wrote a Python script to which I can give the file path and a number and it will give me all file names that are missing until that number.</p>
<p>My program works for small files. But when I give a large file (12MB) that can have file numbers until 10000, it just hangs.</p>
<p>Here is my current Python code</p>
<pre><code>#! /usr/bin/env/python
import mmap
import re

def main():
    filePath = input("Enter file path: ")
    endFileNum = input("Enter end file number: ")
    print(filePath)
    print(endFileNum)
    filesMissing = []
    filesPresent = []
    f = open(filePath, 'rb', 0)
    s = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
    for x in range(int(endFileNum)):
        myRegex = r'(.*)file(.*)' + re.escape(str(x)) + r'\.txt'
        myRegex = bytes(myRegex, 'utf-8')
        if re.search(myRegex, s):
            filesPresent.append(x)
        else:
            filesMissing.append(x)
    #print(filesPresent)
    print(filesMissing)

if __name__ == "__main__":
    main()
</code></pre>
<p>Output hangs when I give a 12MB file which can have files from 0 to 9999</p>
<pre><code>$python findFileNumbers.py
Enter file path: abc.log
Enter end file number: 10000
</code></pre>
<p>Output for a small file (same as the above example)</p>
<pre><code>$python findFileNumbers.py
Enter file path: sample.log
Enter end file number: 5
[0, 2, 3]
[1, 4]
</code></pre>
<ol>
<li>How can I make this work for big files?</li>
<li>Is there a better way I can get these results instead of a Python script?</li>
</ol>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>first collect the existing ones in a set and then look for the missing ones.</p>
<pre><code>my_regex = re.compile('.*file.*(\d+)\.txt.*')
present_ones = set()
for line in open(filepath):
    match = my_regex.match(line)
    if match:
       present_ones.add(int(match.group(1)))
for num in range(...):
    if num not in present_ones:
        print("Missing" + num)
</code></pre>
<p>The reason yours hangs because you are going through the entire file for each number. i.e 12MB * 10000 = 120GB The script is going through 120GB and so it hangs even if you have it in mmap.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest that you simply read through the input file line by line and parse each of the lines for its file number. Then use that file number as an index into a boolean array set False initially. </p>
<p>You don't do any processing that requires the file to be in memory. This approach will work for very large files.</p>
<pre><code>#~ import mmap
import re
import numpy as np

def main():
    #~ filePath = input("Enter file path: ")
    filePath = 'filenames.txt'
    #~ endFileNum = input("Enter end file number: ")
    endFileNum = 5
    print(filePath)
    print(endFileNum)
    found = np.zeros(1+endFileNum, dtype=bool)
    patt = re.compile(r'[^\d]+(\d+)')
    with open(filePath) as f:
        for line in f.readlines():
            r = patt.search(line).groups(0)[0]
            if r:
                found[int(r)]=True
    print (found)

    #~ filesMissing = []
    #~ filesPresent = []
    #~ files = np.zeros[endFileNum, dtype=bool]
    #~ f = open(filePath, 'rb', 0)
    #~ s = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
    #~ for x in range(int(endFileNum)):
        #~ myRegex = r'(.*)file(.*)' + re.escape(str(x)) + r'\.txt'
        #~ myRegex = bytes(myRegex, 'utf-8')
        #~ if re.search(myRegex, s):
            #~ filesPresent.append(x)
        #~ else:
            #~ filesMissing.append(x)
    #print(filesPresent)
    #~ print(filesMissing)

if __name__ == "__main__":
    main()
</code></pre>
<p>This produces the following result from which your <code>filesPresent</code> and <code>filesMissing</code> are easily recovered.</p>
<pre><code>filenames.txt
5
[ True False  True  True False False]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's take a look at what you are actually doing here:</p>
<ol>
<li>Memory map the file.</li>
<li><p>For each number  </p>
<p>a. Compile a regular expression for that number.<br/>
b. Search for the regular expression in the entire file.</p></li>
</ol>
<p>This is very inefficient for large numbers. While memory mapping gives you a string-like <em>interface</em> to the file, it is not magic. You still have load chunks of the file to move around within it. At the same time, you are making a pass, potentially over the entire file, for each regex. And regex matching is expensive as well.</p>
<p>The solution here would be to make a single pass through the file, line by line. You should pre-compile the regular expression instead of compiling it once per number if you have a large number to search for. To get all the numbers in a single pass, you could make a <a href="https://docs.python.org/3.6/library/stdtypes.html?highlight=set#set" rel="nofollow noreferrer"><code>set</code></a> of all the numbers up to the one you want, called "missing", and an empty <code>set</code> called "found". Whenever you encounter a line with a number, you would move the number from "missing" to "found".</p>
<p>Here is a sample implementation:</p>
<pre><code>filePath = input("Enter file path: ")
endFileNum = int(input("Enter end file number: "))
missing = set(range(endFileNum))
found = set()
regex = re.compile(r'file_.*?(\d+)\.txt')
with open(filePath) as file:
    for line in file:
        for match in regex.finditer(line)
            num = int(match.groups(1))
            if num &lt; endFileNum:
                found.add(num)
missing -= found
</code></pre>
<p>Notice that the regular expression uses the <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">reluctant quantifier</a> <code>.*?</code> after <code>file_</code>. This will match as few characters as possible before looking for a digit. If you have the default greedy quantifier of <code>.*</code>, multiple numbers on one line would match only the last one.</p>
</div>
<span class="comment-copy">Big in terms of what? The number of files to search through, the size of the data in the file, the length of its name?</span>
<span class="comment-copy">I gave a 12MB file as input and the number of files it can search through is 10,000</span>
<span class="comment-copy">There is no need to map the files to memory if you just need to get their names.</span>
<span class="comment-copy">I am not getting the names of the files. I have one input file and I am getting matching strings within that file. Can you please check my example above</span>
<span class="comment-copy">You need to use <code>.*?</code> in your regex if OP's implication that multiple numbers can occur on one line are correct.</span>
