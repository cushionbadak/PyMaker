<div class="post-text" itemprop="text">
<p>I have a bunch of CSV-files where first line is the column name, and now I want to change the order according to another list.<br/>
Example:</p>
<pre><code>[
['date','index','name','position'],
['2003-02-04','23445','Steiner, James','98886'],
['2003-02-04','23446','Holm, Derek','2233'],
...
]
</code></pre>
<p>The above order differs slightly between the files, but the same column-names are always available.</p>
<p>So the I want the columns to be re-arranged as:</p>
<pre><code>['index','date','name','position']
</code></pre>
<p>I can solve it by comparing the first row, making an index for each column, then re-map each row into a new list of lists using a for-loop.<br/>
And while it works, it feels so ugly even my blind old aunt would yell at me if she saw it. </p>
<p>Someone on IRC told me to look at on <code>map()</code> and <code>operator</code> but I'm just not experienced enough to puzzle those together. :/</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Plain Python</h1>
<p>You could use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to transpose your data:</p>
<pre><code>data = [
['date','index','name','position'],
['2003-02-04','23445','Steiner, James','98886'],
['2003-02-04','23446','Holm, Derek','2233']
]

columns = list(zip(*data))
print(columns)
# [('date', '2003-02-04', '2003-02-04'), ('index', '23445', '23446'), ('name', 'Steiner, James', 'Holm, Derek'), ('position', '98886', '2233')]
</code></pre>
<p>It becomes much easier to modify the columns order now.</p>
<p>To calculate the needed permutation, you can use:</p>
<pre><code>old = data[0]
new = ['index','date','name','position']
mapping = {i:new.index(v) for i,v in enumerate(old)}
# {0: 1, 1: 0, 2: 2, 3: 3}
</code></pre>
<p>You can apply the permutation to the columns:</p>
<pre><code>columns = [columns[mapping[i]] for i in range(len(columns))]
# [('index', '23445', '23446'), ('date', '2003-02-04', '2003-02-04'), ('name', 'Steiner, James', 'Holm, Derek'), ('position', '98886', '2233')]
</code></pre>
<p>and transpose them back:</p>
<pre><code>list(zip(*columns))
# [('index', 'date', 'name', 'position'), ('23445', '2003-02-04', 'Steiner, James', '98886'), ('23446', '2003-02-04', 'Holm, Derek', '2233')]
</code></pre>
<h1>With Pandas</h1>
<p>For this kind of tasks, you should use <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a>.
It can parse CSVs, reorder columns, sort them and keep an index.</p>
<p>If you have already imported <code>data</code>, you could use these methods to import the columns, use the first row as header and set <code>index</code> column as index.</p>
<pre><code>import pandas as pd
df = pd.DataFrame(data[1:], columns=data[0]).set_index('index')
</code></pre>
<p><code>df</code> then becomes:</p>
<pre><code>            date            name position
index
23445  2003-02-04  Steiner, James    98886
23446  2003-02-04     Holm, Derek     2233
</code></pre>
<p>You can avoid those steps by importing the CSV correctly with <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html" rel="nofollow noreferrer"><code>pandas.read_csv</code></a>. You'd need <code>usecols=['index','date','name','position']</code> to get the correct order directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple and stupid:</p>
<pre><code>LIST = [
    ['date', 'index', 'name', 'position'],
    ['2003-02-04', '23445', 'Steiner, James', '98886'],
    ['2003-02-04', '23446', 'Holm, Derek', '2233'],
]

NEW_HEADER = ['index', 'date', 'name', 'position']


def swap(lists, new_header):

    mapping = {}

    for lst in lists:
        if not mapping:
            mapping = {
                old_pos: new_pos
                for new_pos, new_field in enumerate(new_header)
                for old_pos, old_field in enumerate(lst)
                if new_field == old_field}

        yield [item for _, item in sorted(
            [(mapping[index], item) for index, item in enumerate(lst)])]


if __name__ == '__main__':
    print(LIST)
    print(list(swap(LIST, NEW_HEADER)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To rearrange your data, you can use a dictionary:</p>
<pre><code>import csv
s = [
['date','index','name','position'],
['2003-02-04','23445','Steiner, James','98886'],
['2003-02-04','23446','Holm, Derek','2233'],

]
new_data = [{a:b for a, b in zip(s[0], i)} for i in s[1:]]
final_data = [[b[c] for c in ['index','date','name','position']] for b in new_data]
write = csv.writer(open('filename.csv'))
write.writerows(final_data)
</code></pre>
</div>
<span class="comment-copy">Is this a job for <code>csvreader</code> [<a href="https://docs.python.org/2/library/csv.html]" rel="nofollow noreferrer">docs.python.org/2/library/csv.html]</a>?</span>
<span class="comment-copy">Or with Pandas you could handle the header in the constructor, i.e. <code>pd.DataFrame(data[1:], columns=data[0]).set_index('index')</code></span>
<span class="comment-copy">@Mitch: Excellent, thanks!</span>
<span class="comment-copy">You seem to like constructive criticism, so here goes: This code isn't simple  (but it's not stupid either ;) ). You could create <code>mapping</code> in a single dict comprehension (see my answer). You could also create <code>new_order</code> with a list comprehension. Anyway, your solution seems to work fine, so you get my vote.</span>
<span class="comment-copy">Updated my answer ;)</span>
<span class="comment-copy">If you use <code>a</code> as <code>s[0]</code> as a key, you will lose data, since <code>s[0]</code> is not unique.</span>
