<div class="post-text" itemprop="text">
<p>In Python, I have a decorator that has to skip any real work if a function is defined locally in the one that calls it. I made a simple testing script:</p>
<pre><code>def fn1():
    # @my_decorator will be here
    def fn2():
        pass

    print(fn2)
    return fn2

x = fn1()
print(x)
print(x.__module__)
</code></pre>
<p>It prints this:</p>
<pre><code> &lt;function fn1.&lt;locals&gt;.fn2 at 0x7fd61bdf3ae8&gt;
 &lt;function fn1.&lt;locals&gt;.fn2 at 0x7fd61bdf3ae8&gt;
 __main__
</code></pre>
<p>As I see, Python sees that the function is defined in a local space (<code>&lt;locals&gt;</code> in the printed text), but I can't see how I can find that bit of data. I walked through the <code>inspect</code> module, and don't see anything similar.</p>
<p>I can't rely on whether the function is in globals or not.</p>
<p>What do I use?</p>
</div>
<div class="post-text" itemprop="text">
<p>First off, the direct approach is to check if <a href="https://docs.python.org/3/library/inspect.html#code-objects-bit-flags" rel="nofollow noreferrer">the <code>CO_NESTED</code> flag is set on the function's code object</a>:</p>
<pre><code>import inspect

...

def is_nested(func):
    return func.__code__.co_flags &amp; inspect.CO_NESTED

def deco(func):
    if is_nested(func):
        # This is a nested function, return it unchanged
        return func
    ... otherwise, do your decoration here ...
</code></pre>
<p>That said, there is another approach if what you care about is whether you've actually closed over anything. A function that doesn't use anything from the enclosing scope is nested, but not a closure, and that distinction is often important. So for example:</p>
<pre><code>def foo(x):
    def bar(y):
        pass
    return bar
</code></pre>
<p>is <em>not</em> making a closure because <code>bar</code> makes use of no variables from the scope of the <code>foo</code> call. By contrast, even though it's a garbage reference, this <em>is</em> making a closure simply by reading the value of <code>x</code> from the enclosing scope:</p>
<pre><code>def foo(x):
    def baz(y):
        x
    return baz
</code></pre>
<p>You can tell the difference between <code>bar</code> and <code>baz</code> by testing the <code>__closure__</code> attribute (which is <code>None</code> if no nested variables have been closed over) or by checking the <code>co_freevars</code> attribute of the <code>__code__</code> object (which is a tuple of names closed on, so if it's empty, then it's not a closure, though it may still be a nested function):</p>
<pre><code>def is_closure(func):
    return func.__closure__ is not None
    # Or using documented names, since __closure__ isn't for some reason,
    # co_freevars is a tuple of names captured from nested scope
    return bool(func.__code__.co_freevars)

    # Or on 3.3+, you even get a function to aid you:
    return bool(inspect.getclosurevars(func).nonlocals)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, here's a hacky approach:</p>
<pre><code>'&lt;locals&gt;' in f.__qualname__
</code></pre>
<p>It seems brittle to me, though.</p>
<p>Another approach is to play with the <code>Frame</code>, but I like that even less, I think:</p>
<pre><code>In [1]: import inspect

In [2]: def deco(f):
   ...:     try:
   ...:         frame = inspect.currentframe()
   ...:         print(frame.f_back.f_locals is globals())
   ...:     finally:
   ...:         del frame
   ...:     return f
   ...:

In [3]: @deco
   ...: def g(): pass
   ...:
True

In [4]: def f():
   ...:     @deco
   ...:     def g(): pass
   ...:

In [5]: f()
False
</code></pre>
</div>
<span class="comment-copy">I think this is a legitimately good solution. <code>__qualname__</code> is also what's used (in CPython at least) to create the <code>repr</code> of the function, there's no other hidden attributes that it checks.</span>
<span class="comment-copy">@JimFasarakisHilliard yeah, I was playing around with <code>inspect.currentframe().f_back.f_locals is globals()</code>, which seems to work too, but I like that even <i>less</i>.</span>
