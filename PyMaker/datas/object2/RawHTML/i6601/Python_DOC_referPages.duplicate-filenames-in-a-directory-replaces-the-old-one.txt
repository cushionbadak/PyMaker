<div class="post-text" itemprop="text">
<p>I wish to write to a file based on whether that file already exists or not, only writing if it doesn't already exist (in practice, I wish to keep trying files until I find one that doesn't exist).</p>
<p>The following code shows a way in which a potentially attacker could insert a symlink, as suggested in <a href="https://stackoverflow.com/a/85237/709852">this post</a> in between a test for the file and the file being written. If the code is run with high enough permissions, this could overwrite an arbitrary file.</p>
<p>Is there any way to solve this problem?</p>
<pre><code>import os
import errno

file_to_be_attacked = 'important_file'

with open(file_to_be_attacked, 'w') as f:
    f.write('Some important content!\n')

test_file = 'testfile'

try:
    with open(test_file) as f: pass
except IOError, e:

    # symlink created here
    os.symlink(file_to_be_attacked, test_file)

    if e.errno != errno.ENOENT:
        raise
    else:
        with open(test_file, 'w') as f:
            f.write('Hello, kthxbye!\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit</strong>: See also <a href="https://stackoverflow.com/a/18474773/220155">Dave Jones' answer</a>: from Python 3.3, you can use the <code>x</code> flag to <code>open()</code> to provide this function.</p>
<p><strong>Original answer below</strong></p>
<p>Yes, but not using Python's standard <code>open()</code> call. You'll need to use <a href="http://docs.python.org/library/os.html#os.open" rel="noreferrer"><code>os.open()</code></a> instead, which allows you to specify flags to the underlying C code.</p>
<p>In particular, you want to use <code>O_CREAT | O_EXCL</code>. From the man page for <code>open(2)</code> under <code>O_EXCL</code> on my Unix system:</p>
<blockquote>
<p>Ensure  that  this  call  creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then <code>open()</code> will fail.  The behavior of <code>O_EXCL</code> is undefined if <code>O_CREAT</code> is not specified.</p>
<p>When these two flags are specified, symbolic links are not followed: if pathname is a symbolic link, then <code>open()</code> fails  regardless of where the symbolic link points to.</p>
<p><code>O_EXCL</code>  is only supported on NFS when using NFSv3 or later on kernel 2.6 or later.  In environments where NFS <code>O_EXCL</code> support is not provided, programs that rely on it for performing locking tasks will contain a race condition.</p>
</blockquote>
<p>So it's not perfect, but AFAIK it's the closest you can get to avoiding this race condition.</p>
<p>Edit: the other rules of using <code>os.open()</code> instead of <code>open()</code> still apply. In particular, if you want use the returned file descriptor for reading or writing, you'll need one of the <code>O_RDONLY</code>, <code>O_WRONLY</code> or <code>O_RDWR</code> flags as well.</p>
<p>All the <code>O_*</code> flags are in Python's <code>os</code> module, so you'll need to <code>import os</code> and use <code>os.O_CREAT</code> etc.</p>
<h3>Example:</h3>
<pre><code>import os
import errno

flags = os.O_CREAT | os.O_EXCL | os.O_WRONLY

try:
    file_handle = os.open('filename', flags)
except OSError as e:
    if e.errno == errno.EEXIST:  # Failed as the file already exists.
        pass
    else:  # Something unexpected went wrong so reraise the exception.
        raise
else:  # No exception, so the file must have been created successfully.
    with os.fdopen(file_handle, 'w') as file_obj:
        # Using `os.fdopen` converts the handle to an object that acts like a
        # regular Python file object, and the `with` context manager means the
        # file will be automatically closed when we're done with it.
        file_obj.write("Look, ma, I'm writing to a new file!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For reference, Python 3.3 implements a new <code>'x'</code> mode in the <a href="http://docs.python.org/3/library/functions.html#open" rel="noreferrer"><code>open()</code></a> function to cover this use-case (create only, fail if file exists). Note that the <code>'x'</code> mode is specified on its own. Using <code>'wx'</code> results in a <code>ValueError</code> as the <code>'w'</code> is redundant (the only thing you can do if the call succeeds is write to the file anyway; it can't have existed if the call succeeds):</p>
<pre><code>&gt;&gt;&gt; f1 = open('new_binary_file', 'xb')
&gt;&gt;&gt; f2 = open('new_text_file', 'x')
</code></pre>
<p>For Python 3.2 and below (including Python 2.x) please refer to <a href="https://stackoverflow.com/a/10979569/1459019">the accepted answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code will easily create a FILE if one does not exists.</p>
<pre><code>import os
if not os.path.exists('file'):
    open('file', 'w').close() 
</code></pre>
</div>
<span class="comment-copy">Check atomic writing with Python <a href="http://stackoverflow.com/questions/2333872/atomic-writing-to-file-with-python" title="atomic writing to file with python">stackoverflow.com/questions/2333872/…</a></span>
<span class="comment-copy">@Mikko That doesn’t help here.</span>
<span class="comment-copy">Ah ok. I understood what's the matter... you write ONLY if the file exist?</span>
<span class="comment-copy">Could you write the file in a temporary location, then do a copy command without allowing overwrite?</span>
<span class="comment-copy">+1 for the obviously correct answer.  I'm personally curious to know how many people actually have issues with the NFS caveat—I (perhaps recklessly) dismiss it as an obsolete environment my code should never be run on.</span>
<span class="comment-copy">@zigg: NFSv3 is from 1995, so it seems fair to regard older versions as obsolete.</span>
<span class="comment-copy">I'd be more worried about the kernel version, personally. If you're running anything even vaguely resembling an up-to-date system, you should have no issue, but RHEL 3 (still in extended support phase) is running a 2.4 kernel, for example. Also, I've not investigated if they provide atomic writes on Windows on FAT or NTFS, which is a potentially major limitation.</span>
<span class="comment-copy">@me_and The python page on <a href="http://docs.python.org/library/os.html#open-constants" rel="nofollow noreferrer">open flag constants</a> suggests that this works fine with Windows. I'll be trying it shortly!</span>
<span class="comment-copy">True, but I've not seen anywhere (including <a href="http://msdn.microsoft.com/en-us/library/53xa7z70(v=VS.71).aspx" rel="nofollow noreferrer">MSDN</a>) that explicitly says these flags give <i>atomic</i> file creation. Possibly I'm being overly paranoid, but I'd want to see that "atomic" keyword before trusting this for anything that's security-critical.</span>
<span class="comment-copy">Good suggestion. Unfortunately this appears to be POSIX-only (doesn't work on Windows): <code>Python 3.2 (r32:88445, Feb 20 2011, 21:30:00)</code> <code>[MSC v.1500 64 bit (AMD64)] on win32</code> <code>&gt;&gt;&gt; open("c:/temp/foo.csv","wx")</code> <code>ValueError: invalid mode: 'wx'</code></span>
<span class="comment-copy">You're using python 3.2; the 'x' mode is in 3.3 and above but it is cross platform. Incidentally, you only use 'x' instead of 'wx' - the write mode is redundant as the only thing you could do with the file is write to it anyway</span>
<span class="comment-copy">Python 3.6: <code>ValueError: must have exactly one of create/read/write/append mode</code></span>
<span class="comment-copy">See the comment above :-)</span>
<span class="comment-copy">Will do - though it'll have to wait until I'm back in front of a computer a little later.</span>
<span class="comment-copy">Yes it will. The important point about the question was the safety aspect. The problem is that between identifying the presence of the file and using it or creating it, something might change that results in a bad outcome (as in the original question).</span>
<span class="comment-copy">That's true. It's called TOCTOU!</span>
<span class="comment-copy">If another process creates and writes to the file after the <code>if</code> statement, this code will blank out the file.</span>
