<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/16626789/functools-partial-on-class-method">functools.partial on class method</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I ran into this problem while trying to write a pretty print procedure for a program in which I use several named tuples containing floating point pairs.</p>
<pre><code>from collections import namedtuple
Position = namedtuple('Position', 'x y')
Vector = namedtuple('Vector', 'x y')
Size = namedtuple('Size', 'width height')
</code></pre>
<p>I want to format the floating point numbers when printed because the result of:</p>
<pre><code>import math
print(Position(math.pi, math.pi), Vector(math.pi, math.pi), Size(math.pi, math.pi))
</code></pre>
<p>Is too long:</p>
<pre><code>Position(x=3.141592653589793, y=3.141592653589793) Vector(x=3.141592653589793, y=3.141592653589793) Size(width=3.141592653589793, height=3.141592653589793)
</code></pre>
<p>So I created a function to print the named tuples:</p>
<pre><code>def pretty_float_pair(name, labels, obj):
    """
    If labels = ('a', 'b') and object = (1.2345, 1.2345) returns:
        'name(a=1.23, b=1.23)'
    """
    return '{}({}={:.2f}, {}={:.2f})'.format(name, labels[0], obj[0], labels[1], obj[1])
</code></pre>
<p>The name and labels should be fixed for every type and only the obj argument varies so I thought I could use functools partial.</p>
<pre><code>from functools import partial
Position.__str__ = partial(pretty_float_pair, 'Position', ('x', 'y'))
Vector.__str__ = partial(pretty_float_pair, 'Vector', ('x', 'y'))
Size.__str__ = partial(pretty_float_pair, 'Size', ('width', 'height'))
print(Position(math.pi, math.pi), Vector(math.pi, math.pi), Size(math.pi, math.pi))
</code></pre>
<p>But this throws a <code>TypeError: pretty_float_pair() missing 1 required positional argument: 'obj'.</code></p>
<p>Surprisingly if I use lambda to create the functions it works.</p>
<pre><code>Position.__str__ = lambda x: pretty_float_pair('Position', ('x', 'y'), x)
Vector.__str__ = lambda x: pretty_float_pair('Vector', ('x', 'y'), x)
Size.__str__ = lambda x: pretty_float_pair('Size', ('width', 'height'), x)
print(Position(math.pi, math.pi), Vector(math.pi, math.pi), Size(math.pi, math.pi))
</code></pre>
<p>Prints what I wanted:</p>
<pre><code>Position(x=3.14, y=3.14) Vector(x=3.14, y=3.14) Size(width=3.14, height=3.14)
</code></pre>
<p>I'm trying to understand why the partial version doesn't work.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.6/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a> returns a non-descriptor callable, roughly equivalent to an unbound method. This means that it is not being passed a <code>self</code> parameter, which is consistent with the error you are seeing.</p>
<p>Since a lambda behaves just like a regular function  defined with <code>def</code>, it is in fact a descriptor. The <code>__get__</code> method of the lambda returns a bound version that passes in the instance as <code>x</code>.</p>
<p>To get a partial function that behaves more like a method, use <a href="https://docs.python.org/3.6/library/functools.html#functools.partialmethod" rel="nofollow noreferrer"><code>functools.partialmethod</code></a> instead. You will have to move <code>obj</code> to the beginning of your argument list so it can receive <code>self</code> when the method is bound.</p>
<p>Here is your example:</p>
<pre>
from functools import <b>partialmethod</b>

def pretty_float_pair(<b>obj, </b>name, labels):
    """
    If labels = ('a', 'b') and object = (1.2345, 1.2345), returns:
        name(a=1.23, b=1.23)
    """
    return '{}({}={:.2f}, {}={:.2f})'.format(name, labels[0], obj[0], labels[1], obj[1])

Position.__str__ = <b>partialmethod</b>(pretty_float_pair, 'Position', ('x', 'y'))
Vector.__str__ = <b>partialmethod</b>(pretty_float_pair, 'Vector', ('x', 'y'))
Size.__str__ = <b>partialmethod</b>(pretty_float_pair, 'Size', ('width', 'height'))

print(Position(math.pi, math.pi), Vector(math.pi, math.pi), Size(math.pi, math.pi))
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Functions get their implicit <code>self</code> argument by being <a href="https://docs.python.org/3/reference/datamodel.html#descriptors" rel="nofollow noreferrer">descriptors</a>: the lookup <code>x.f</code> constructs and returns a method object that remembers <code>x</code> so as to supply it to <code>f</code>.  <code>functools.partial(...)</code> does not return a descriptor, so it doesn't get that special treatment.  (It's actually a class, so it "returns" an instance of itself.)</p>
</div>
<span class="comment-copy">Your function is not indented properly. Please fix. You can use my answer for reference.</span>
<span class="comment-copy">Even though your question was closed, you should select an answer from among the ones posted (assuming it helped you).</span>
<span class="comment-copy">Not going to downvote because this istrue , but you need to have a solution to have an answer. Right now you just have a very insightful comment at best.</span>
<span class="comment-copy">@MadPhysicist: There are no question marks in the, er, question, but I wrote this to address "I'm trying to understand why the partial version doesn't work.".</span>
<span class="comment-copy">You are absolutely right. +1. The OP has such a strong implication in their question and I am so tired, I read something very different from the actual question in my mind. Thanks for the catch.</span>
<span class="comment-copy">Thanks for the useful documentation.</span>
