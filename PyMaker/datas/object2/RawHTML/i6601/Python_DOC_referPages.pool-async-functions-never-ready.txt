<div class="post-text" itemprop="text">
<pre><code>import threading
import multiprocessing.dummy as mt
import numpy as np


if __name__ == '__main__':
    n = 6
    a = np.zeros((n, n))

    def f(i, j):
        a[i, j] = i + j

    with mt.Pool() as pool:
        r = pool.starmap_async(f, ((i, j) for i in range(n) for j in range(n)))

    r.wait()
    print(a)
</code></pre>
<p>The snippet above will block itself at <code>r.wait()</code>. But if changing it to</p>
<pre><code>import threading
import multiprocessing.dummy as mt
import numpy as np


if __name__ == '__main__':
    n = 6
    a = np.zeros((n, n))

    def f(i, j):
        a[i, j] = i + j

    with mt.Pool() as pool:
        pool.starmap(f, ((i, j) for i in range(n) for j in range(n)))

    print(a)
</code></pre>
<p>the content of <code>a</code> will be printed immediately. So why is the <code>r</code> in the first snippet never ready? (Python version: <code>Python 3.6.2 :: Anaconda custom (64-bit)</code>, under Linux)</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're waiting outside of the <code>with</code> block. As soon as you exit the <code>with</code> block, the Pool is <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.terminate" rel="nofollow noreferrer">terminated</a>, which prevents any of your tasks from completing. From the javadocs:</p>
<blockquote>
<p>Pool objects now support the context management protocol â€“ see Context Manager Types. <code>__enter__()</code> returns the pool object, and <code>__exit__()</code> calls <code>terminate()</code>.</p>
</blockquote>
<p>...</p>
<blockquote>
<p><strong><code>terminate()</code></strong> </p>
<p>Stops the worker processes immediately without completing
  outstanding work. When the pool object is garbage collected
  <code>terminate()</code> will be called immediately.</p>
</blockquote>
<p>Moving the call to <code>r.wait()</code> inside the <code>with</code> block fixes the issue.</p>
</div>
