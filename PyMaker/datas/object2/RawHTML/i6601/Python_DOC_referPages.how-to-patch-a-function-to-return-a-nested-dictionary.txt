<div class="post-text" itemprop="text">
<p>I am trying to patch a function to return a nested dictionary like so:</p>
<pre><code>with patch('boto3.client') as mock:
        mock.create_platform_endpoint.return_value = {'EndpointArn': 'another_arn'}
        mock.get_endpoint_attributes.return_value = {'Attributes': {'Enabled': 'true', 'Token': 'new_token'}}
        device.register_with_aws()
</code></pre>
<p>This fails, as when accessing the dictionary, the code just finds MogicMock functions e.g. <code>&lt;MagicMock name='client().create_platform_endpoint().__getitem__()' id='4619515160'&gt;</code> or <code>&lt;MagicMock name='client().get_endpoint_attributes().__getitem__().__getitem__()()' id='4424507800'&gt;</code></p>
<p>I guess I could mock these <code>__getitem__()</code> calls, but is there a more elegant solution than pretending to be a dictionary?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that <code>create_platform_endpoint</code> and <code>get_endpoint_attributes</code> are methods of the class <code>boto3.client</code>, this might work for you:</p>
<pre><code>with patch(boto3.client, 'create_platform_endpoint', return_value={'EndpointArn': 'another_arn'}):
    with patch(boto3.client, 'get_endpoint_attributes', return_value={'Attributes': {'Enabled': 'true', 'Token': 'new_token'}}):
        device.register_with_aws()
</code></pre>
<p>Assuming that <code>create_platform_endpoint</code> and <code>get_endpoint_attributes</code> are attributes of the method <code>boto3.client</code>, this might work for you:</p>
<pre><code>with patch('boto3.client.create_platform_endpoint', return_value={'EndpointArn': 'another_arn'}):
    with patch('boto3.client.get_endpoint_attributes', return_value={'Attributes': {'Enabled': 'true', 'Token': 'new_token'}}):
        device.register_with_aws()
</code></pre>
<p>Check out the documentation for <code>patch</code> <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">here</a>.</p>
<p>Few other pointers:
If you have something like this in your class:</p>
<pre><code>class Foo(object):
    ...
    def bar(self):
        ...
        value = boto3.client()    # Assume you are using the method boto3.client() here
        ...
        return whatever           # Assume that this is a dictionary you want
</code></pre>
<p>And now if you want the dictionary returned from <code>Foo().bar()</code> to be patched with some other return value, then this can help you:</p>
<pre><code>with patch.object(Foo, 'bar', return_value={}):
    foo()
</code></pre>
<p>If you want to mock the value <code>Foo().bar().value</code>, then try to mock the client method itself</p>
<pre><code>with patch('boto3.client', return_value={}):    # This makes the value `value` as {}.
    foo()
</code></pre>
</div>
<span class="comment-copy">this gives me <code>AttributeError: &lt;function client at 0x107833378&gt; does not have the attribute 'create_platform_endpoint'</code> Are you sure that nested mocking works this way?</span>
<span class="comment-copy">I assumed that <code>boto3.client</code> was a class. If it was a method then try the edited post.</span>
<span class="comment-copy">Edited the post. Checkout and let me know.</span>
<span class="comment-copy">BTW, you also need to check the order of <code>create_platform_endpoint</code> and <code>get_endpoint_attributes</code> how they are called. The nested patch also should be in the same way. Well it might not matter, but just a pointer.</span>
<span class="comment-copy">I still get the same error. I think the function <code>boto3.client</code> returns an object which in turn has functions. So the error message makes sense. The function does not have an attribute or function called <code>create_platform_endpoint</code></span>
