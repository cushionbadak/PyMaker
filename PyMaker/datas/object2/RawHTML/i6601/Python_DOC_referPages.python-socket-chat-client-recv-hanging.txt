<div class="post-text" itemprop="text">
<p>I have a small problem with a chat program I am trying to build:
There are 2 clients and a server, a client sends out a message and the server receives it, and broadcasts it to everyone (usually both clients, but there can be more). The problem is, that when A client sends data to the other client (through the server), the receiving client has to send something himself in order to see the message.</p>
<p>This is my server.py:</p>
<pre><code>import socket
from thread import start_new_thread
import threading


def thread(c,clients, c_lock,buf=1024,):
    c.send("You are connected! \n")
    while True:
        try:
            data = c.recv(buf)
            print data
            if not data:
                break
            broadcast(clients,c_lock,data)
        except socket.error as e:
            exit(0)
    c.close()

def broadcast(clients,c_lock,data):
    with c_lock:
        for c in clients:
            c.sendall("- " + data)

def main():
    host = ''
    port = 10000
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    clients = set()
    clients_lock = threading.Lock()
    s.bind((host, port))
    s.listen(5)
    print "%s listening on %s" % (host, str(port))
    while True:
            c, addr = s.accept()
            print "got connection from ", addr
            with clients_lock:
                clients.add(c)
            start_new_thread(thread, (c, clients, clients_lock, ))
    s.close()

if __name__ == "__main__":
    main()
</code></pre>
<p>And client.py:</p>
<pre><code>import socket
import time
from sys import exit

def main():
    host = socket.gethostname()
    port = 10000
    name = str(raw_input("Enter your name: "))


    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect(('192.168.1.12', port))
    except Exception as e:
        print 'Connection not working... %s' % (e)
        exit()

    print s.recv(1024)  # greeting msg
    print "Send q to stop the connection \n"
    out = ''
    while out != 'q':
        out = str(raw_input('-&gt;'))
        recv =  s.recv(1024)
        s.send(name + ": " + out)
        time.sleep(0.1)
        print recv
    s.close()
if __name__ == '__main__':
    main()
</code></pre>
<p>Thanks for your help :)
(And please forgive me for the mess :/)</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two issues.</p>
<p><code>recv()</code> is a blocking call.<br/>
<code>raw_input()</code> / <code>input()</code> are also a blocking call.</p>
<p>Meaning the client will "hang" on both of these calls (<code>recv()</code> being an exception <strong>if</strong> there is data in the pipe, then it won't block).</p>
<p>To get around this, as in your example. Either you can use <code>threading</code> as you've done in your server to have a class/instance that is souly responsible for retrieving data from the socket and one to read user input. Or on Linux you can use <code>select.select</code> or <code>select.epoll</code> to poll the socket if data is in the pipe and only then, call <code>recv()</code>. And for the input you're still better off using <code>select/epoll</code> on <code>sys.stdin</code> or use threading.</p>
<p>But <code>recv()</code> will always be a blocking call in Python (and many other languages) if there is no data available to read. And so will <code>raw_input()</code> / <code>input()</code>.</p>
<p>To use <a href="https://docs.python.org/2/library/select.html#select.epoll" rel="nofollow noreferrer">epoll</a>, here's a short example:</p>
<pre><code>from select import epoll, EPOLLIN
import sys

polly = epoll()
polly.register(s.fileno(), EPOLLIN)
polly.register(sys.stdin.fileno(), EPOLLIN)

for fid, eid in polly.poll(1):
    # s is your socket, s.fileno() on linux is the file number that socket has been assigned to.
    # And epoll returns a list of all filenumbers that has data waiting.
    # So we can check if the fid from epoll == the sockets filenumber.
    if fid == s.fileno(): 
        data = s.recv(8192)
    # of if it's sys.stdin's filenumber
    # (stdin is user input, this is where raw_input normally gets its data from)
    elif fid == sys.stdin.fileno():
        user_input = sys.stdin.readline()
        print('User wrote:', user_input)
</code></pre>
<p>Or if you want to use threading:</p>
<pre><code>from threading import Thread, enumerate as t_enum
class userInput(Thread):
    def __init__(self, socket, username):
        Thread.__init__(self)
        self.socket = socket
        self.username = username
        self.start()

    def run(self):
        mainThread = None
        for thread in t_enum():
            if thread.name == 'MainThread':
                mainThread = thread
                break

        while mainThread and mainThread.isAlive():
            out = raw_input('-&gt;') # str() is redundant, it's type(str) already.
            self.socket.send(self.username + ": " + out)
</code></pre>
<p>And a little further down your code:</p>
<pre><code>name = str(raw_input("Enter your name: "))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    s.connect(('192.168.1.12', port))
except Exception as e:
    print 'Connection not working... %s' % (e)
    exit()

userInput(s, name)
</code></pre>
<p>Note that this isn't proper thread handling. But it's a minimal example that will show you the general gist of how to go about the problem.</p>
<p>as a last tipe, <a href="https://stackoverflow.com/a/23702542/929999">fcntl</a> is also a good option.</p>
<h2>Further programming for the future tips</h2>
<p>use <code>print(...)</code> instead of <code>print ...</code><br/>
use <code>'Connection not working... {}'.format(e)</code> instead of <code>'Connection not working... %s' % (e)</code><br/>
And overall, try to use Python3 instead of Python2. Python2 should really only be used if you have a old environment filled with legacy stuff (read: debian, old developed applications etc).</p>
</div>
<span class="comment-copy">Your clients are spending most of their time in <code>raw_input()</code>, and cannot possibly receive anything.  If you did the input/send and the receive in separate threads, things would work - but the result would be a jumbled mess on the screen if a message arrives while the user is typing.  You really need either a GUI, or a text interface like <code>curses</code>, so that the user input and the incoming messages are in separate areas of the screen, that cannot interfere with each other.</span>
<span class="comment-copy">alright so what you tell me is that I should wait for a respond from the other client?</span>
<span class="comment-copy">@LiorDahan No, he's saying you should use a interface that can handle input while displaying output. curses or a gui. Or you can read off <code>sys.stdin</code> one character at a time when data is available, print the recieved data and reprint the current user input state. But realistically, use <a href="https://docs.python.org/3/howto/curses.html" rel="nofollow noreferrer">curses</a> if you're on linux. If you're on windows just go for tkinter/wxPython/qt/gtk+ or any other framework of <a href="https://docs.python.org/3/faq/gui.html" rel="nofollow noreferrer">your poison</a>. Or just use threads and live with the scrambled input/output for now.</span>
