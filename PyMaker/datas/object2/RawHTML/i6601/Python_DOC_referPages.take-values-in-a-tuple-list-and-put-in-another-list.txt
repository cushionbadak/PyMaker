<div class="post-text" itemprop="text">
<p>say I have a list of tuples. I want to put the second element of all tuples in their own list while preserving the original order. Are there any quick and dirty ways to do this?</p>
<p>example before sorting.</p>
<pre><code>[(0,'apple'),
(1,'pineapple'),
(11,'cherry'),
(12,'banana'),
(13,'mango'),
(14,'boot'),
(15,'mangosteen')]
</code></pre>
<p>after sorting</p>
<pre><code>['apple',
'pineapple',
'cherry',
'banana',
'mango',
'boot',
'mangosteen']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You essentially just need to map the operation of getting the element at index 1 of each tuple in a list and produce a new list.  </p>
<p>Given:</p>
<pre><code>&gt;&gt;&gt; LoT
[(0, 'apple'), (1, 'pineapple'), (11, 'cherry'), (12, 'banana'), (13, 'mango'), (14, 'boot'), (15, 'mangosteen')]
</code></pre>
<p>You can use a list comprehension and access the element of interest of each tuple:</p>
<pre><code>&gt;&gt;&gt; [t[1] for t in LoT]
['apple', 'pineapple', 'cherry', 'banana', 'mango', 'boot', 'mangosteen']
</code></pre>
<p>You can use tuple unpacking:</p>
<pre><code>&gt;&gt;&gt; [b for _,b in LoT]
['apple', 'pineapple', 'cherry', 'banana', 'mango', 'boot', 'mangosteen']
</code></pre>
<p>Which fails if the tuple is anything but 2 elements long.</p>
<p>Alternatively, you can use <code>zip</code>:</p>
<pre><code>&gt;&gt;&gt; list(zip(*LoT))[1]
('apple', 'pineapple', 'cherry', 'banana', 'mango', 'boot', 'mangosteen')
</code></pre>
<p>You can use an <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">itemgetter</a> with <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">map</a>:</p>
<pre><code>&gt;&gt;&gt; list(map(itemgetter(1),LoT))
['apple', 'pineapple', 'cherry', 'banana', 'mango', 'boot', 'mangosteen']
</code></pre>
<p>With Python3 you need to use <code>list</code> around <code>zip</code> to subscript the first element or around <code>map</code> to show it. Combined with loops or other flow contol in Python 3, you likely would not need that.</p>
<p>The first, <code>[t[1] for t in LoT]</code>, is the most idiomatic and the last, <code>map(itemgetter(1),LoT)</code> may be the fastest. </p>
</div>
<div class="post-text" itemprop="text">
<p>Tuple unpacking as an alternative.</p>
<pre><code>[b for a,b in lst]
</code></pre>
</div>
<span class="comment-copy">What is this data structure called? When I plug in "t[1] for t in LoT" my console says it is a generator type.</span>
<span class="comment-copy">Put into the console <i>exactly</i> what I did and that should work. Then work backwards from there to you use case. You need to use <code>[...]</code> to get a list comprehension.</span>
<span class="comment-copy">I did that and it works, I was wondering how to reference in the future. Radish says it's called "tuple unpacking"?</span>
<span class="comment-copy">Suppose you have <code>t=(1,2)</code> and you want to access <code>2</code>. You can do <code>t[1]</code> to access the second element (the square bracket is either a slice or index of that tuple) or you can unpack the tuple into named values: <code>a,b=t</code> and the second element will be assigned to <code>b</code>. There are upsides and downsides to that. If your tuple is not exactly 2 element in length, <code>a,b=t</code> is an error. <code>[]</code> is an operator in Python which corresponds to the  <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">_<i>getitem_</i></a> method.</span>
