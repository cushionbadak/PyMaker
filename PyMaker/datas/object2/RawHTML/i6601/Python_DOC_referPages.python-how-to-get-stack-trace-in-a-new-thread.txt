<div class="post-text" itemprop="text">
<p><code>logger.exception</code> doesn't show stacktrace if executed in a pool and error msg is passed as arg. </p>
<p><strong>Setup:</strong></p>
<pre><code>import logging
from concurrent.futures import ThreadPoolExecutor
logger = logging.getLogger('custom')
ch = logging.StreamHandler()
logger.addHandler(ch)
logger.setLevel(logging.INFO)
executor = ThreadPoolExecutor(3)
</code></pre>
<p><strong>Doesn't show stacktrace:</strong></p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.exception, e)
</code></pre>
<p><strong>Shows stackTrace:</strong></p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.exception(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code works because the issue is being logged before being submitted to the threadpool:</p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.exception(e))
</code></pre>
<p>In reality, what you're sending to the thread pool is <code>None</code>.</p>
<p>This doesn't work because there's a bit of magic happening in the logger.exception call that doesn't work when it's outside of the exception handling context (which it will be when it's run in another thread):</p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.exception, e)
</code></pre>
<p>It usually helps to check the documentation.  For the <a href="https://docs.python.org/3/library/logging.html#logging.Logger.exception" rel="nofollow noreferrer"><code>.exception()</code> method</a> the docs say:</p>
<blockquote>
<p>Logs a message with level ERROR on this logger. The arguments are interpreted as for debug(). Exception info is added to the logging message. This method should only be called from an exception handler.</p>
</blockquote>
<p>The relevant part of the documentation for <code>.debug()</code> is:</p>
<blockquote>
<p>logging.debug(msg, *args, **kwargs)</p>
<p>Logs a message with level DEBUG on the root logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)</p>
<p>There are three keyword arguments in kwargs which are inspected: exc_info which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by sys.exc_info()) is provided, it is used; otherwise, sys.exc_info() is called to get the exception information.</p>
</blockquote>
<p>So, this line:</p>
<pre><code>executor.submit(logger.exception, e)
</code></pre>
<p>will invoke cause <code>sys.exc_info()</code> to be called in the thread handling the logging, which has no exception information--so no traceback is logged.  Instead, you want:</p>
<pre><code>executor.submit(logger.exception, "error occurred", exc_info=sys.exc_info())
</code></pre>
<p>So in it's final form, it would look like:</p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.exception, "error occurred", exc_info=sys.exc_info())
</code></pre>
<p>Even better is to avoid the <code>logger.exception()</code> call and just use <code>logger.error()</code> instead:</p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.error, "error occurred", exc_info=sys.exc_info())
</code></pre>
<p>If you want the exception message as the message for the log, you can just do this (similar to what you did in your original code):</p>
<pre><code>try:
    1/0
except Exception as e:
    executor.submit(logger.error, e, exc_info=sys.exc_info())
</code></pre>
<p><code>e</code> will get converted to a string and used as the message for logging the traceback.</p>
</div>
<span class="comment-copy">New thread means new stack.</span>
<span class="comment-copy">But it works if submitted like <code>logger.exception(e)</code></span>
<span class="comment-copy">That is because you do the logging before calling <code>submit</code>. It will actually be called with the result of the logging call, which AFAIR should be <code>None</code>.</span>
<span class="comment-copy">then how can I get the stack in the new thread, should I pass the stack down as arg?</span>
<span class="comment-copy">then I should just call with <code>logger.error, e, exc_info=sys.exc_info()</code> since <code>logger.exception</code> is just <code>logger.error</code> with <code>exc_info=True</code></span>
<span class="comment-copy">You're safe calling logger.exception here as long as you provide the exception information via the <code>exc_info</code> parameter, but, yes, I do think <code>logger.error</code> is the better choice.</span>
