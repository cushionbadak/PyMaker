<div class="post-text" itemprop="text">
<p>In Python 3.6, it takes longer to read a file if there are line breaks.  If I have two files, one with line breaks and one without lines breaks (but otherwise they have the same text) then the file with line breaks will take around 100-200% the time to read. I have provided a specific example.</p>
<h1>Step #1: Create the files</h1>
<pre><code>sizeMB = 128
sizeKB = 1024 * sizeMB

with open(r'C:\temp\bigfile_one_line.txt', 'w') as f:
    for i in range(sizeKB):
        f.write('Hello World!\t'*73)  # There are roughly 73 phrases in one KB

with open(r'C:\temp\bigfile_newlines.txt', 'w') as f:
    for i in range(sizeKB):  
        f.write('Hello World!\n'*73)
</code></pre>
<h1>Step #2: Read the file with one single line and time performance</h1>
<h3>IPython</h3>
<pre><code>%%timeit
with open(r'C:\temp\bigfile_one_line.txt', 'r') as f:
    text = f.read()
</code></pre>
<h3>Output</h3>
<pre><code>1 loop, best of 3: 368 ms per loop
</code></pre>
<h1>Step #3: Read the file with many lines and time performance</h1>
<h3>IPython</h3>
<pre><code>%%timeit
with open(r'C:\temp\bigfile_newlines.txt', 'r') as f:
    text = f.read()
</code></pre>
<h3>Output</h3>
<pre><code>1 loop, best of 3: 589 ms per loop
</code></pre>
<p>This is just one example.  I have tested this for many different situations, and they do the same thing: </p>
<ol>
<li>Different file sizes from 1MB to 2GB </li>
<li>Using file.readlines() instead of file.read()</li>
<li>Using a space instead of tab ('\t') in the single line file (i.e. 'Hello World! ') </li>
</ol>
<p><strong>My conclusion is that files with new lines characters ('\n') take longer to read than files without them</strong>.  However, I would expect all characters to be treated the same.  This can have important consequences for performance when reading a lot of files.  <strong>Does anyone know why this happens?</strong></p>
<p>I am using Python 3.6.1, Anaconda 4.3.24, and Windows 10.  </p>
</div>
<div class="post-text" itemprop="text">
<p>When you open a file in Python in text mode (the default), it uses what it calls "universal newlines" (introduced with <a href="https://www.python.org/dev/peps/pep-0278/" rel="noreferrer">PEP 278</a>, but somewhat changed later with the release of Python 3). What universal newlines means is that regardless of what kind of newline characters are used in the file, you'll see only <code>\n</code> in Python. So a file containing <code>foo\nbar</code> would appear the same as a file containing <code>foo\r\nbar</code> or <code>foo\rbar</code> (since <code>\n</code>, <code>\r\n</code> and <code>\r</code> are all line ending conventions used on some operating systems at some time).</p>
<p>The logic that provides that support is probably what causes your performance differences. Even if the <code>\n</code> characters in the file are not being transformed, the code needs to examine them more carefully than it does non-newline characters.</p>
<p>I suspect the performance difference you see will disappear if you opened your files in binary mode where no such newline support is provided. You can also pass a <code>newline</code> parameter to <code>open</code> in Python 3, which can have various meanings depending on exactly what value you give. I have no idea what impact any specific value would have on performance, but it might be worth testing if the performance difference you're seeing actually matters to your program. I'd try passing <code>newline=""</code> and <code>newline="\n"</code> (or whatever your platform's conventional line ending is).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>However, I would expect all characters to be treated the same.</p>
</blockquote>
<p>Well, they're not. Line breaks are special.</p>
<p>Line breaks aren't always represented as <code>\n</code>. The reasons are a long story dating back to the early days of physical teleprinters, which I won't go into here, but where that story has ended up is that Windows uses <code>\r\n</code>, Unix uses <code>\n</code>, and classic Mac OS used to use <code>\r</code>.</p>
<p>If you open a file in text mode, the line breaks used by the file will be translated to <code>\n</code> when you read them, and <code>\n</code> will be translated to your OS's line break convention when you write. In most programming languages, this is handled on the fly by OS-level code and pretty cheap, but Python does things differently.</p>
<p>Python has a feature called <a href="https://docs.python.org/3/glossary.html#term-universal-newlines" rel="nofollow noreferrer">universal newlines</a>, where it tries to handle all line break conventions, no matter what OS you're on. Even if a file contains a mix of <code>\r</code>, <code>\n</code>, and <code>\r\n</code> line breaks, Python will recognize all of them and translate them to <code>\n</code>. Universal newlines is on by default in Python 3 unless you configure a specific line ending convention with the <code>newline</code> argument to <code>open</code>.</p>
<p>In universal newlines mode, the file implementation has to read the file in binary mode, check the contents for <code>\r\n</code> characters, and</p>
<p><a href="https://github.com/python/cpython/blob/3.6/Modules/_io/textio.c#L310" rel="nofollow noreferrer"><strong><em>construct a new string object with line endings translated</em></strong></a></p>
<p>if it finds <code>\r</code> or <code>\r\n</code> line endings. If it only finds <code>\n</code> endings, or if it finds no line endings at all, it doesn't need to perform the translation pass or construct a new string object.</p>
<p>Constructing a new string and translating line endings takes time. Reading the file with the tabs, Python doesn't have to perform the translation.</p>
</div>
<div class="post-text" itemprop="text">
<p>On Windows, opening in text-mode converts <code>'\n'</code> characters to <code>'\r\n'</code> when you <em>write</em>, and the reverse when you <em>read</em>. </p>
<p>So, I did some experimentation. I am on MacOS, right now, so my "native" line-ending is <code>'\n'</code>, so I cooked up a similar test to yours, except use non-native, Windows line-endings:</p>
<pre><code>sizeMB = 128
sizeKB = 1024 * sizeMB

with open(r'bigfile_one_line.txt', 'w') as f:
    for i in range(sizeKB):
        f.write('Hello World!!\t'*73)  # There are roughly 73 phrases in one KB

with open(r'bigfile_newlines.txt', 'w') as f:
    for i in range(sizeKB):
        f.write('Hello World!\r\n'*73)
</code></pre>
<p>And the results:</p>
<pre><code>In [4]: %%timeit
   ...: with open('bigfile_one_line.txt', 'r') as f:
   ...:     text = f.read()
   ...:
1 loop, best of 3: 141 ms per loop

In [5]: %%timeit
   ...: with open('bigfile_newlines.txt', 'r') as f:
   ...:     text = f.read()
   ...:
1 loop, best of 3: 543 ms per loop

In [6]: %%timeit
   ...: with open('bigfile_one_line.txt', 'rb') as f:
   ...:     text = f.read()
   ...:
10 loops, best of 3: 76.1 ms per loop

In [7]: %%timeit
   ...: with open('bigfile_newlines.txt', 'rb') as f:
   ...:     text = f.read()
   ...:
10 loops, best of 3: 77.4 ms per loop
</code></pre>
<p>Very similar to yours, and note, the performance difference disappears when I open in binary mode. OK, what if instead, I use *nix line-endings?</p>
<pre><code>with open(r'bigfile_one_line_nix.txt', 'w') as f:
    for i in range(sizeKB):
        f.write('Hello World!\t'*73)  # There are roughly 73 phrases in one KB

with open(r'bigfile_newlines_nix.txt', 'w') as f:
    for i in range(sizeKB):
        f.write('Hello World!\n'*73)
</code></pre>
<p>And the results using these new file:</p>
<pre><code>In [11]: %%timeit
    ...: with open('bigfile_one_line_nix.txt', 'r') as f:
    ...:     text = f.read()
    ...:
10 loops, best of 3: 144 ms per loop

In [12]: %%timeit
    ...: with open('bigfile_newlines_nix.txt', 'r') as f:
    ...:     text = f.read()
    ...:
10 loops, best of 3: 138 ms per loop
</code></pre>
<p>Aha! The performance difference disappears! So yes, I think using non-native line-endings impacts performance, which makes sense given the behavior of text-mode.</p>
</div>
<span class="comment-copy">Interesting find. One thought that immediately comes to mind is that this might not be Python's fault -- could be related to your OS or your filesystem. Would be worth testing on other systems.</span>
<span class="comment-copy">Just a thought, on Windows, opening in text-mode converts <code>'\n'</code> characters to <code>'\r\n'</code> when you <i>write</i>, and the reverse when you <i>read</i>. This might explain it. Try opening in binary mode.</span>
<span class="comment-copy">I'd expect <a href="https://docs.python.org/3/glossary.html#term-universal-newlines" rel="nofollow noreferrer">universal newlines</a> handling to also slow things down.</span>
<span class="comment-copy">@user2357112 yep!</span>
<span class="comment-copy">Seems pretty obvious if you think about it, so it's hard to understand all the up votes...</span>
<span class="comment-copy">@pwaivers Don't leave us hanging! What happens to your benchmark when you open the files in binary mode?</span>
<span class="comment-copy">I just completed the same test in Linux and got very similar results: the file that uses <code>\r\n</code> endings took approx twice as long to read. Python 3 performs new line translation, so the <code>\r\n</code> characters are automatically converted to <code>\n</code>, which obviously takes time.</span>
<span class="comment-copy">As an alternative to switching to binary mode (which toggles a ton of different behaviors, not just line ending modes), you might try passing <code>newline='\n'</code> (both for write and for read) which explicitly disables universal newline mode in favor of an OS-agnostic use of <code>\n</code> only.</span>
<span class="comment-copy">@ShadowRanger: Or since this is Windows, <code>newline='\r\n'</code> would probably be more appropriate.</span>
