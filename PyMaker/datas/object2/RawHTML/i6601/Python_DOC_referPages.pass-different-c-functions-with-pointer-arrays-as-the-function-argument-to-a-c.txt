<div class="post-text" itemprop="text">
<p>I am trying to pass different functions which have pointers as arguments to a python function. One example of the input function as input parameter is the given <code>normal</code> function: </p>
<p><strong>Sample.pyx</strong></p>
<pre><code>from cpython cimport array
import cython
import ctypes
cimport numpy as np
cpdef void normal(np.ndarray[ndim=1, dtype=np.float64_t] u, 
                  np.ndarray[ndim=1, dtype=np.float64_t] yu, 
                  np.ndarray[ndim=1, dtype=np.float64_t] ypu):

      cdef int i
      cdef int n=len(u)
      for i in prange(n, nogil=True):
          yu[i]=-u[i]*u[i]*0.5                                                               
          ypu[i]=-u[i]                                                                    
      return                                                     
cdef class _SampleFunc:
     cdef void (*func)(double *, double *, double *)

cdef void sample(int* x, double* hx, double* hxx, void(*func)(double*, double*, double*), int n):
      def int i
      for i from 0 &lt;= i &lt; n:
          func[0](&amp;x[i], &amp;hx[i], &amp;hxx[i])
      return 
cdef class myClass:
     sample_wrapper = _SampleFunc() 
     sample_wrapper.func = Null
     def foo(np.ndarray[ndim=1, dtype=np.float64_t] x,
             np.ndarray[ndim=1, dtype=np.float64_t] hx,
             np.ndarray[ndim=1, dtype=np.float64_t] hxx,
             _SampleFunc sample_func, 
             int k):
         cdef np.ndarray[ndim=1, dtype=np.float64_t] sp
         cdef int num=len(x)
         func = sample_func.func
         assert func is not NULL, "function value is NULL"
         cdef int j
         for j from 0 &lt;= j &lt;k:
             sample(&amp;x[0],&amp;hx[0], &amp;hxx[0], func, num)
             sp[j]=hx[0]
         return sp
</code></pre>
<p><strong>test.py</strong></p>
<pre><code>import numpy as np
from sample import *
x = np.zeros(10, float)
hx = np.zeros(10, float)
hpx = np.zeros(10, float)

x[0] = 0
x[1] = 1.0
x[2] = -1.0
def pynormal(x):
    return -x*x*0.5,-x

hx[0], hpx[0] = pynormal(x[0])
hx[1], hpx[1] = pynormal(x[1])
hx[2], hpx[2] = pynormal(x[2])
num=20
ars=myClass()
s=ars.foo( x, hx, hpx, normal, num)
</code></pre>
<p>Running the <code>test.py</code> code I am getting this error:</p>
<pre><code>'ars._SampleFunc' object has no attribute 'func'
</code></pre>
<p>I am trying to write a wrapper for different <code>C</code> functions which have three pointer arrays as their argument. My conclusion so far was that it can be done with a class, since the class can be accessible in python. I am wondering how I can pass the <code>C</code> functions with pointer arrays as argument to <code>myClass</code> class? </p>
<p><strong>Update: Normal function</strong></p>
<pre><code>cdef void normal(
                 int n,
                 double* u, 
                 double* yu, 
                 double* ypu
                ):          
      cdef int i          
      for i in prange(n, nogil=True):
          yu[i]=-u[i]*u[i]*0.5                                                               
          ypu[i]=-u[i]                                                                    
      return 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first thing to deal with is that a function of signature <code>cdef void (*func)(double *, double *, double *)</code> <strong>does not pass the array length</strong>. You can't know how long these arrays are, and thus you can't safely access their elements. The sensible thing is to change the function signature to pass a length too:</p>
<pre><code>cdef void (*func)(double *, double *, double *, int)
</code></pre>
<p>What is extra confusing is that you seem to be iterating over the same axis of a 1D array in both <code>normal</code> and <code>sample</code>. I suspect that isn't what you want to do, but I'm not going attempt to fix that.</p>
<hr/>
<p>Essentially your problem is that you want to pass an arbitrary Python callable as a C function pointer. The bad news is that Cython can't do it - a Python callable has a significant amount of information associated with it, while a C function pointer is simply the address of some executable memory. Therefore a C function pointer does not have the space available to hold the information in a Python callable. In order to make this work you need to generate code at runtime, which Python can't do.</p>
<p><a href="https://stackoverflow.com/questions/34878942/using-function-pointers-to-methods-of-classes-without-the-gil/34900829#34900829">I've recommended the ctypes standard library module as a solution to similar problems previously</a>, since it can <a href="https://docs.python.org/3/library/ctypes.html#callback-functions" rel="nofollow noreferrer">create a function pointer from a Python callable</a>. There is a simpler but more limited solution if you only want to call <code>cdef</code> Cython functions.</p>
<h2>ctypes</h2>
<p>Here's a minimal example which demonstrates how to implement the idea:</p>
<pre><code>import numpy as np
import ctypes

ctypedef void (*func_t)(int, double *)

cdef void sample(int n, double* x, func_t f):
    f(n,x)

def call_sample(double[::1] x,
                f):

    def func_wrapper(n, arg1):
        # x is a slightly opaque ctypes type
        # first cast it to a ctypes array of known size
        # and then create a numpy array from that
        arg1_as_ctypes_array = (ctypes.c_double*n).from_address(ctypes.addressof(arg1.contents))
        return f(np.asarray(arg1_as_ctypes_array))


    FTYPE = ctypes.CFUNCTYPE(None, # return type
                             ctypes.c_int, # arguments
                             ctypes.POINTER(ctypes.c_double))
    f_ctypes = FTYPE(func_wrapper) # convert Python callable to ctypes function pointer

    # a rather nasty line to convert to a C function pointer
    cdef func_t f_ptr = (&lt;func_t*&gt;&lt;size_t&gt;ctypes.addressof(f_ctypes))[0]

    sample(x.shape[0], &amp;x[0], f_ptr)


def example_function(x):
    # expects a numpy array like object
    print(x)

def test():
    a = np.random.rand(20)
    print(a)
    call_sample(a,example_function)
</code></pre>
<p>I realise that there's some slightly messy conversion between ctypes and Cython - this is unavoidable.</p>
<p>A bit of explanation: I'm assuming you want to keep the Python interface simple, hence <code>example_function</code> just takes a numpy array-like object. The function passed by ctypes needs to accept a number of elements and a pointer to match your C interface.</p>
<p>The ctypes pointer type (<code>LP_c_double</code>) can do do indexing (i.e. <code>arg1[5]</code>) so it works fine for simple uses, but it doesn't store its length internally. It's helpful (but not essential) to change it to a numpy array so you can use it more generally and thus we create a wrapper function to do this. We do:</p>
<pre><code>arg1_as_ctypes_array = (ctypes.c_double*n).from_address(ctypes.addressof(arg1.contents))
</code></pre>
<p>to convert it to a known length ctypes array and then</p>
<pre><code>np.asarray(arg1_as_ctypes_array)
</code></pre>
<p>to convert it to a numpy array. This shares the data rather than makes a copy, so if you change it then your original data will be changed. Because the conversion to a numpy array follows a standard pattern it's easy to generate a wrapper function in <code>call_sample</code>.</p>
<p>(In the comments you ask how to do the conversion if you're just passing a <code>double</code>, not a <code>double*</code>. In this case you don't have to do anything since a ctypes <code>double</code> behaves exactly like a Python type)</p>
<h2>Only <code>cdef</code> functions</h2>
<p>If you're certain the functions you want to pass will always be <code>cdef</code> functions then you can avoid ctypes and come up with something a bit simpler. You first need to make the function signature match the pointer exactly:</p>
<pre><code>cdef void normal(int N, double *x): # other parameters as necessary
    cdef double[::1] x_as_mview = &lt;double[:N:1]&gt;x # cast to a memoryview
    # ... etc
</code></pre>
<p>You should then be able to use your definition of <code>SampleFunc</code> almost as is to create module level objects:</p>
<pre><code># in Cython
normal_samplefunc = SampleFunc()
normal_samplefunc.func = &amp;normal

# in Python
s=ars.foo( x, hx, hpx, normal_samplefunc, num)
</code></pre>
<p><code>ars.foo</code> is the way you wrote it (no <code>ctypes</code> code):</p>
<pre><code>func = sample_func.func
# ...
sample(..., func,...)
</code></pre>
<p>This code will run quicker, but you want be able to call <code>normal</code> from Python.</p>
<hr/>
<h2>Python interface</h2>
<p>You mention in the comments that you'd also like the be able to access <code>normal</code> from Python. You're likely to need a different interface for the Python function and the one you pass to C, so I'd define a separate function for both uses, but share the implementation:</p>
<pre><code>def normal(double[::1] u, # ... other arguments
           ):
   # or cpdef, if you really want
   implementation goes here

# then, depending on if you're using ctypes or not:
def normal_ctypes(int n, u # other arguments ...
   ):
   u_as_ctypes_array = (ctypes.c_double*n).from_address(ctypes.addressof(x.contents))
   normal(u_as_ctypes_array, # other arguments
                )

# or
cdef void normal_c(int n, double* u # ...
              ):
   normal(&lt;double[:N:1]&gt;x # ...
          )
</code></pre>
</div>
<span class="comment-copy">This cannot be possibly the <i>shortest</i> example that you could come up with.</span>
<span class="comment-copy">to elaborate on @AnttiHaapala,   <i>Questions seeking debugging help (why isn't this code working?) must include the desired behavior, a specific problem or error and the shortest code necessary to reproduce it in the question itself. Questions without a clear problem statement are not useful to other readers. See: How to create a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</i></span>
<span class="comment-copy">for example, the function pointer could be <code>void(*func)(double)</code>, then you would need much less code to produce a working example.</span>
<span class="comment-copy">@SouravGhosh I have already tried to ask my question in shorter description but no one give a proper answer. I am wondering the purpose of stackoverflow is educational or just giving as short as possible answers to get upvotes for answer providers without giving deep answers.</span>
<span class="comment-copy">@ead I want that the pointers which I give as inputs to the <code>func</code> carry the updates of their values. If I pass just a normal variable as argument, then defining python function does the job and actually I do not  need to suffer a lot of trouble to define a <code>c</code> function.</span>
<span class="comment-copy">Thanks a lot for the answer and description. I will try to apply your answer to my code.</span>
<span class="comment-copy">A comment and question is that I want the <code>normal</code> function would be callable from python code. If I make it, in the way you described on the top, I can not access it in python. Well, Do you think the way I coded my <code>normal</code> function is wrong in this context?</span>
<span class="comment-copy">The issue is that for the normal function to be callable from C it needs to <i>exactly</i> match the C signature. For it to be callable from python it needs to accept Python types (i.e. not C pointers). What you probably want to do is to write a Python/Cython version and C version. The C version convert the pointers to a memoryview or numpy array as shown above, and then call the Python version.</span>
<span class="comment-copy">Sorry about my naive questions but I am confused whether the <code>cpdef</code> type defining normal function, the way I did above, is right or not? Then can it be used for the pointer function as you defined in your answer? Because I tried to change my code according your comments but kept above definition of the <code>normal</code> function, I got this error :<code>f = FTYPE(f) # convert Python callable to ctypes function pointer TypeError: invalid result type for callback function</code></span>
<span class="comment-copy">I changed the <code>cpdef void normal</code> by adding an extra input argument for the size of vector <code>u</code>. Then I compiled the code and ran my <code>test.py</code> code. For the <code>sample</code> function, I got this error message:<code>File "_ctypes/callbacks.c", line ..., in 'calling callback function' TypeError: Argument 'u' has incorrect type (expected numpy.ndarray, got LP_c_double)</code></span>
