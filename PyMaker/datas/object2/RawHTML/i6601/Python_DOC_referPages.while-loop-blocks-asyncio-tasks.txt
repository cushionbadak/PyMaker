<div class="post-text" itemprop="text">
<p>I've been using asyncio for a bit but I'm still fairly unfamiliar with it. My current issue is that while trying to wait for a response from a function with asyncio, the waiting (while loop) blocks the function from happening. Here is the code that sums up the problem:</p>
<pre><code>import asyncio

response = 0

async def handle(x):
    await asyncio.sleep(0.1)
    return x

async def run():
    global response
    for number in range(1, 21):
        response = await handle(number)
        print(response)
        if response == 10:
            await wait_for_next(response)

async def wait_for_next(x):
    while response == x:
        print('waiting',response,x)
        await asyncio.sleep(0.5)
    print('done')

tasks = [run()]
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
</code></pre>
<p>wait_for_next is supposed to wait for the next response, but the while loop blocks the run() function. How could I stop this happening? Should I be using loop.run_in_executor, and if so, how?</p>
<p>(There were a couple of other examples of this I could find, but they were very specific and I didn't understand if our problems/solutions would be the same.)</p>
</div>
<div class="post-text" itemprop="text">
<p>As already noted, loop stuck because <code>await wait_for_next(response)</code> blocks execution flow until this coroutine wouldn't be finished.</p>
<p>If you want some of your coroutines to be started without blocking execution flow you can start it as <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task" rel="noreferrer">asyncio.Task</a> (<a href="https://stackoverflow.com/a/37345564/1113207">more</a> about tasks) using <code>ensure_future</code> function:</p>
<pre><code>import asyncio

response = 0

async def handle(x):
    await asyncio.sleep(0.1)
    return x

async def run():
    global response
    for number in range(1, 21):
        response = await handle(number)
        print(response)
        if response == 10:

            # run wait_for_next "in background" instead of blocking flow:
            asyncio.ensure_future(wait_for_next(response))

async def wait_for_next(x):
    while response == x:
        print('waiting',response,x)
        await asyncio.sleep(0.5)
    print('done')


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(run())
</code></pre>
<p>Output:</p>
<pre><code>1
2
3
4
5
6
7
8
9
10
waiting 10 10
11
12
13
14
done
15
16
17
18
19
20
</code></pre>
</div>
<span class="comment-copy">I didn't use asyncio before, but I worked with async programming. the while loop will block the current thread, If you need execute a blocking functions you can use the run_in_executor() method of the EventLoop, this will be run the function in an executor. loop.run_in_executor(executor=None, fn, *args)</span>
<span class="comment-copy">It is blocked because there is nothing else to do. There is only one task to execute. May be add another task to tasks and the wait would be interleaved</span>
<span class="comment-copy">Thanks @balki , it seems like adding another task allowed it to continue, so I'll have to split my run() task into seperate parts.</span>
<span class="comment-copy">This also works, thanks! Now I'll have to decide which correction benefits the program more 3:</span>
<span class="comment-copy">Just remember to await on asyncio.sleep() in your background while loop, so other coroutines can be executed too.</span>
