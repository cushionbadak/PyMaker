<div class="post-text" itemprop="text">
<p>I want to create my own parameterized type in Python for use in type hinting:</p>
<pre><code>class MaybeWrapped:
    # magic goes here

T = TypeVar('T')

assert MaybeWrapped[T] == Union[T, Tuple[T]]
</code></pre>
<p>Never mind the contrived example; how can I implement this? I looked at the source for Union and Optional, but it looks like some fairly low-level hackery that I'd like to avoid.</p>
<p>The only suggestion in the documentation comes from an <a href="https://docs.python.org/3/library/typing.html#typing.Generic" rel="nofollow noreferrer">example re-implementation of <code>Mapping[KT,VT]</code> that inherits from Generic</a>. But that example is more about the <code>__getitem__</code> method than about the class itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're just trying to create generic classes or functions, try taking a look at the <a href="http://mypy.readthedocs.io/en/stable/generics.html" rel="nofollow noreferrer">documentation on mypy-lang.org about generic types</a> -- it's fairly comprehensive, and more detailed then the standard library typing docs.</p>
<p>If you're trying to implement your specific example, it's worth pointing out that <a href="http://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases" rel="nofollow noreferrer">type aliases work with typevars</a> -- you can simply do:</p>
<pre><code>from typing import Union, TypeVar, Tuple

T = TypeVar('T')

MaybeWrapped = Union[T, Tuple[T]]

def foo(x: int) -&gt; MaybeWrapped[str]:
    if x % 2 == 0:
        return "hi"
    else:
        return ("bye",)

# When running mypy, the output of this line is:
# test.py:13: error: Revealed type is 'Union[builtins.str, Tuple[builtins.str]]'
reveal_type(foo(3))
</code></pre>
<p>However, if you're trying to construct a generic type with genuinely new semantics, you're very likely out of luck. Your remaining options are to:</p>
<ol>
<li>Construct some kind of custom class/metaclass thing that PEP 484-compliant type checkers <em>can</em> understand and use that.</li>
<li>Modify the type checker you're using somehow (mypy has an experimental "plugin" system, for example)</li>
<li>Petition to modify PEP 484 to include your new, custom type (you can do this by opening an issue in the <a href="https://github.com/python/typing" rel="nofollow noreferrer">typing module repo</a>).</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>It is exactly the <code>__getitem__</code> method that does all the magic. </p>
<p>That is the method called in when you subscribe one name with <code>[</code> and <code>]</code> brackets.</p>
<p>So, you need an  <code>__getitem__</code> method in the class of your class - that is, its metaclass, that will get as parameters whatever is within the brackets. That method is responsible for dynamically creating (or retrieving a cached copy)  of whatever you want to generate, and return it.</p>
<p>I just can't possibly imagin how you want this for type hinting, since the typing library seems to cover all reasonable cases (I can't think of an example they don't cover already). But let's suppose you want a class to return a copy of itself, but with the parameter anotated as its <code>type_</code> attribute:</p>
<pre><code>class MyMeta(type):
    def __getitem__(cls, key):
        new_cls = types.new_class(f"{cls.__name__}_{key.__name__}", (cls,), {}, lambda ns: ns.__setitem__("type", key))
        return new_cls

class Base(metaclass=MyMeta): pass
</code></pre>
<p>And on trying this in interactive mode, one can do:</p>
<pre><code>In [27]: Base[int]
Out[27]: types.Base_int
</code></pre>
</div>
<span class="comment-copy">Thanks, using <code>TypeVar</code> here is what I was missing. Pretty amazing that generics "just work" like this.</span>
<span class="comment-copy">Thanks, although I'm still not sure how this all works. Can you speak to the example in my question? The example in your answer seems a little different from what I'm trying to do.</span>
<span class="comment-copy">@jsbueno -- I don't think your answer works. The code you proposed is certainly a way to construct something that <i>looks like</i> a PEP 484 type, but since it isn't, PEP 484 compliant type checkers won't understand what to do with your <code>MyMeta</code> or <code>Base</code> classes.</span>
