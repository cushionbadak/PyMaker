<div class="post-text" itemprop="text">
<p>Below is an example of decorator in python. I don't quite get how it actually works for the doubly decorated decorator.</p>
<pre><code>from functools import update_wrapper
def decorator(d):
    print(d.__name__)
    return lambda fn: update_wrapper(d(fn),fn)

decorator=decorator(decorator) #I don't understand how this works.

@decorator
def n_ary(f):
    print(f.__name__)
    def n_ary_f(x,*args):               
        return x if not args else f(x,n_ary_f(*args))
    return n_ary_f

@n_ary
def seq(x,y):return ('seq',x,y)
</code></pre>
<p>It seems that the flow should be (I am not sure about it):</p>
<ol>
<li><p><code>decorator</code> is decorated, so it returns <code>lambda fn: update_wrapper(decorator(fn),fn)</code>.</p></li>
<li><p><code>n_ary=decorator(n_ary)</code>, then <code>n_ary</code> is now updated due to the function of <code>update_wrapper(decorator(n_ary),n_ary)</code></p></li>
<li><p>The third part should be the update of seq, but I don't understand when is the <code>update_wrapper</code> function used.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Decoration is just syntactic sugar for calling another function, and replacing the current function object with the result. The <code>decorator</code> dance you are trying to understand is over-using that fact. Even though it tries to make it easier to produce decorators, I find it <em>doesn't actually add anything</em> and is only creating confusion by not following standard practice.</p>
<p>To understand what is going on, you can substitute the function calls (including decorators being applied) with their return values, and tracking the <code>d</code> references by imagining saved references to the original decorated function object:</p>
<ol>
<li><p><code>decorator=decorator(decorator)</code> replaces the original <code>decorator</code> function with a call to itself. We'll just ignore the <code>print()</code> call here to make substitution easier. </p>
<p>The <code>decorator(decorator)</code> call returns <code>lambda fn:
update_wrapper(d(fn),fn)</code>, where <code>d</code> is bound to the original
<code>decorator</code>, so now we have</p>
<pre><code>_saved_reference_to_decorator = decorator
decorator = lambda fn: update_wrapper(_saved_reference_to_decorator(fn), fn)
</code></pre>
<p>so <code>update_wrapper()</code> is not actually called yet. It'll only be called when this new <code>decorator</code> lambda is called.</p></li>
<li><p><code>@decorator</code> then calls the above <code>lambda</code> (the one calling <code>_saved_reference_to_decorator(fr)</code> and passing the result to <code>update_wrapper()</code>) and applies that lambda to the <code>def n_ary(f)</code> function:</p>
<pre><code>n_ary = decorator(n_ary)
</code></pre>
<p>which expands to:</p>
<pre><code>n_ary = update_wrapper(_saved_reference_to_decorator(n_ary), n_ary)
</code></pre>
<p>which is:</p>
<pre><code>_saved_reference_to_n_ary = n_ary
n_ary = update_wrapper(lambda fn: update_wrapper(_saved_reference_to_n_ary(fn), fn), n_ary)
</code></pre>
<p>Now, <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper" rel="noreferrer"><code>update_wrapper()</code></a> just copies metadata from the second argument to the first returning the first argument, so that then leaves:</p>
<pre><code>n_ary = lambda fn: update_wrapper(_saved_reference_to_n_ary(fn), fn)
</code></pre>
<p>with the right <code>__name__</code> and such set on the <code>lambda</code> function object.</p></li>
<li><p><code>@n_ary</code> is again a decorator being applied, this time to <code>def seq(x, y)</code>, so we get:</p>
<pre><code>seq = n_ary(seq)
</code></pre>
<p>which can be expanded to:</p>
<pre><code>seq = update_wrapper(_saved_reference_to_n_ary(seq), seq)
</code></pre>
<p>which if we take the return value of <code>update_wrapper()</code> is</p>
<pre><code>seq = _saved_reference_to_n_ary(seq)
</code></pre>
<p>with the metadata copied over from the original <code>seq</code> to whatever the original <code>n_ary</code> function returns.</p></li>
</ol>
<p>So in the end, all this dance gets you is <code>update_wrapper()</code> being applied to the return value from a decorator, which is the contained wrapper function.</p>
<p>This is all way, <strong>way too complicated</strong>. The <code>update_wrapper()</code> function has a far more readable helper decorator already provided: <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="noreferrer"><code>@functools.wraps()</code></a>. Your piece of code could be rewritten to:</p>
<pre><code>import functools

def n_ary(f):
    print(f.__name__)
    @functools.wraps(f)
    def n_ary_f(x,*args):
        return x if not args else f(x,n_ary_f(*args))
    return n_ary_f

@n_ary
def seq(x,y):return ('seq',x,y)
</code></pre>
<p>I simply replaced the <code>@decorator</code> decorator on the <code>n_ary()</code> function definition with a <code>@functools.wraps()</code> decorator on the contained wrapper function that is returned.</p>
</div>
<span class="comment-copy">Can I ask where you found this? This is someone trying to be too clever for little gain, and I'd love to see what their motivation was.</span>
