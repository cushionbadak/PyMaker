<div class="post-text" itemprop="text">
<p>I need to extract large amount of data from a HP Vertica database and save it to a file. I am using official ODBC driver from Vertica with pyodbc.</p>
<p>This is what I have done so far:</p>
<pre><code>cnxn = pyodbc.connect('DRIVER={Vertica};SERVER=localhost;DATABASE=db;UID=user;PWD=pw')
cnxn.setdecoding(pyodbc.SQL_CHAR, encoding='utf-8')
cnxn.setdecoding(pyodbc.SQL_WCHAR, encoding='utf-8')
cnxn.setencoding(str, encoding='utf-8')
cnxn.setencoding(unicode, encoding='utf-8')
cur = cnxn.cursor()
cur.execute("SELECT * FROM schema.table LIMIT 3")
</code></pre>
<p>Then I read the data</p>
<pre><code>for row in cur:
    print row
</code></pre>
<p>Most of the fields are returned just fine - unicode text, numbers or datetimes. However for a field that stores IP Addresses I get the following:</p>
<pre><code>bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\no\x19\\')
</code></pre>
<p>How do I convert it to text?</p>
<p>Any help with be greatly appreciated!</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>I see there's an accepted answer but... for all the others:</p>
<p>If your data is in Vertica the <strong>very</strong> first thing to do is to check the fine SQL Reference Manual. In this case you will find a built-in function to convert IPv6 address represented as VARBINARY column to a string. </p>
<p>Much simpler and much, much faster:</p>
<pre><code>SELECT V6_NTOA(your_column_here) ;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>VARBINARY(16) is 128 bits, which is just the right size for an IPv6 address. The sample data decodes to</p>
<pre class="lang-none prettyprint-override"><code>0000:0000:0000:0000:0000:ffff:0a6f:195c
</code></pre>
<p>and the "IPv4-mapped IPv6 addresses" subsection of the Wikipedia article on IPv6 (ref: <a href="https://en.wikipedia.org/wiki/IPv6#IPv6_readiness" rel="nofollow noreferrer">here</a>) says that such an address is an IPv4 address (32 bits) mapped into an IPv6 format (128 bits).</p>
<pre class="lang-none prettyprint-override"><code>::ffff:10.111.25.92
</code></pre>
<p>We can generate those string representations above from the raw <code>bytearray</code> data using a function like this:</p>
<pre class="lang-python prettyprint-override"><code>def bytes_to_ip_address(byte_array):
    if byte_array[0:12] == bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff'):
        return '{0}.{1}.{2}.{3}'.format(byte_array[12], byte_array[13], byte_array[14], byte_array[15])
    else:
        return ':'.join(['{0:02x}{1:02x}'.format(byte_array[i], byte_array[i + 1]) for i in range(0, len(byte_array), 2)])


if __name__ == '__main__':
    # examples
    fld = bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\no\x19\\')
    print(bytes_to_ip_address(fld))  # 10.111.25.92
    fld = bytearray(b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\no\x19\\')
    print(bytes_to_ip_address(fld))  # 0100:0000:0000:0000:0000:ffff:0a6f:195c
</code></pre>
<p>Or, with Python3 we can use the <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">ipaddress</a> module:</p>
<pre class="lang-python prettyprint-override"><code>import ipaddress


def bytes_to_ip_address(byte_array):
    ip6 = ipaddress.IPv6Address(bytes(byte_array))
    ip4 = ip6.ipv4_mapped
    if ip4 == None:
        return str(ip6)
    else:
        return str(ip4)


if __name__ == '__main__':
    # examples
    fld = bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\no\x19\\')
    print(bytes_to_ip_address(fld))  # 10.111.25.92
    fld = bytearray(b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\no\x19\\')
    print(bytes_to_ip_address(fld))  # 100::ffff:a6f:195c
</code></pre>
</div>
<span class="comment-copy">What is the corresponding column type in the table definition? Do you know the IP address that those bytes are supposed to represent?</span>
<span class="comment-copy">@GordThompson the corresponding column type in the table definition is varbinary(16). I don't know which IP address those bytes correspond to. It's not easy with my current set up to check.</span>
