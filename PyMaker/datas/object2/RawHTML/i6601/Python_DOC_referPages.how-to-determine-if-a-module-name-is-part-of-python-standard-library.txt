<div class="post-text" itemprop="text">
<p>I have a module name <strong>as a string</strong> (e.g. 'logging') that was given by querying the <strong>module</strong> attribute of an object.</p>
<p>How can I differentiate between modules that are part of my project and modules that are part of python standard library?</p>
<p>I know that I can check if this module was installed by pip using pip.get_installed_distributions(), but these are not related to the standard library</p>
<p>Note: I'm working on python 2.7 so solutions that are valid only in python 3.x are less relevant.</p>
<p>Unlike the answer <a href="https://stackoverflow.com/questions/6463918/how-can-i-get-a-list-of-all-the-python-standard-library-modules">here</a>, I was looking for a solution that can be run in O(1) and will not require holding an array of results nor having to scan the directory for every query.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick 'n dirty solution, using the standard module <a href="https://docs.python.org/2.7/library/imp.html" rel="nofollow noreferrer">imp</a>:</p>
<pre><code>import imp
import os.path
import sys

python_path = os.path.dirname(sys.executable)

my_mod_name = 'logging'

module_path = imp.find_module(my_mod_name)[1]
if 'site-packages' in module_path or python_path not in module_path or imp.is_builtin(my_mod_name):
    print('module', my_mod_name, 'is not included in standard python library')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>EDIT:</strong></p>
<p>I used the solution which is <a href="https://stackoverflow.com/a/6464112/6900838">here</a>.</p>
<pre><code>import distutils.sysconfig as sysconfig
import os

def std_modules():
    ret_list = []
    std_lib = sysconfig.get_python_lib(standard_lib=True)
    for top, dirs, files in os.walk(std_lib):
        for nm in files:
            if nm != '__init__.py' and nm[-3:] == '.py':
                ret_list.append(os.path.join(top, nm)[len(std_lib)+1:-3].replace('\\','.'))
    return ret_list

l = std_modules()
print("logging" in l)
print("os" in l)
</code></pre>
<p>Output:</p>
<pre><code>False
True
</code></pre>
<p>This works in both Python 2 and Python 3.</p>
<p><strong>BEFORE EDIT:</strong></p>
<p>I guess, you can use Python Docs. Here are standard library parts of <a href="https://docs.python.org/2/library/index.html" rel="nofollow noreferrer">Python 2 Docs</a> and <a href="https://docs.python.org/3/library/index.html" rel="nofollow noreferrer">Python 3 Docs</a>. Also, you can select the exact version of Python.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/6463918/how-can-i-get-a-list-of-all-the-python-standard-library-modules">How can I get a list of all the Python standard library modules</a></span>
<span class="comment-copy">I'm curious to know why you want to do this in case there's some other way to solve what you're trying to do.</span>
<span class="comment-copy">As a rule, you don't want to do that. E.g. when the codebase will be run by a different Python version, some modules may move between being stock and 3rd-party/backports. If your problem is that your import syntax is ambiguous, then make it unambiguous instead e.g. by fully qualifying the modules or with relative imports.</span>
<span class="comment-copy">As an example of ways in which this fails, it won't detect modules imported from the script's directory. "Quick and dirty" is an apt description.</span>
<span class="comment-copy">I know. "Quick 'n dirty" is there for a reason ;) I added a refinement to include modules imported outside python install folder.</span>
<span class="comment-copy">@user2357112, do you have other examples of how this may fail? Guillaume's update seems to fix this issue.</span>
<span class="comment-copy">@YohaiDe: The update fixes that problem, but breaks for C modules like <code>sys</code> or <code>itertools</code>.</span>
<span class="comment-copy">fixed for C Builtin modules</span>
<span class="comment-copy">I need an method that can work on the fly.  I can save an offline list based on this list, but it'll need non trivial updates.</span>
<span class="comment-copy">@YohaiDe OK, try this one.</span>
