<div class="post-text" itemprop="text">
<p>Consider a large list of 4 character strings. </p>
<p>For example: ['P0BH', 'LF3J', 'MA1Y', 'STSM', '8Y74', 'JWBD']</p>
<p>I want to add a new string in the following precise manner:</p>
<p>If the new string already exists in the given list, delete the old value from the list and prepend the new string to the front of the list. For example, if the string 'MA1Y' was added, then the output list would look like this:
['MA1Y', 'P0BH', 'LF3J', 'STSM', '8Y74', 'JWBD']. If the new string does not exist in the list, then just prepend the new string to the front. For example, if the string 'FSH7' was added, then the output list would look like this: ['FSH7', 'P0BH', 'LF3J', 'MA1Y', 'STSM', '8Y74', 'JWBD']. </p>
<p>There is one other caveat: <strong>the algorithm must run in constant time complexity. I don't care about space complexity.</strong> </p>
<p>Naturally, I have already implemented a solution, which is given below. I believe it runs in constant time complexity, but I would like that we improve it or redesign something better. My understanding is that a map has constant time deletion, membership testing and assignment. **</p>
<p><strong>Does the addTicker method in my tickerMap class run in constant time?</strong></p>
<pre><code>class tickersMap:
    def __init__(self, tickersList):
        self.Map = {t:i for i, t in enumerate(tickersList)}
        self.firstIndex = 0

    def addTicker(self, newTicker):
        if newTicker in self.Map:
            print('exists')
            del self.Map[newTicker]
            self.Map[newTicker] = self.firstIndex - 1
            self.firstIndex -= 1
        else:
            self.Map[newTicker] = self.firstIndex - 1
            self.firstIndex -= 1

    def listTickers(self):
        # This is O(nlog(n)) but is only required for printing 
        return sorted(self.Map, key=self.Map.get)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're missing a log N detail in there.</p>
<p>Also, <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> seems to be a close match to your needs.</p>
<p>The assignment is O(1) after we've allocated N entries, as long as N never grows after that. However, it is amortized O(log N) for each assignment that creates a new entry. Python doubles the allocation each time it's exceeded. If you were to keep adding and deleting without growing N, then assignment would be O(1).</p>
<p><code>addTicker()</code> could conditionally <code>del</code>, and then unconditionally do those last two statements, as they're the same in either case.</p>
<p>The O(N) comment should be O(N log N), as that's how long the sort takes, and there's no reason to believe all the entries are already in sorted order.</p>
</div>
<span class="comment-copy"><a href="https://codereview.stackexchange.com/q/176499/52915">Cross-posted on Code Review</a></span>
<span class="comment-copy">The paragraph regarding amortizing is unclear to me</span>
<span class="comment-copy">Do you know if the move_to_end function works in constant time?</span>
<span class="comment-copy">I don't know what the <code>move_to_end()</code> function is. You could do an unbounded number of adds and deletes, and as long as their ratio is 1:1 you'll see O(1) time. If the ratio is 2:1, so it grows without bound, then assignment needs to incur some allocation cost, so we move from O(1) to O(log N). For details see <a href="https://en.wikipedia.org/wiki/Amortized_analysis#Dynamic_Array" rel="nofollow noreferrer">en.wikipedia.org/wiki/Amortized_analysis#Dynamic_Array</a></span>
