<div class="post-text" itemprop="text">
<p>I want to detect whether a word is in a sentence using python regex. Also, want to be able to negate it.</p>
<pre><code>import re
re.match(r'(?=.*\bfoo\b)', 'bar red foo here')
</code></pre>
<p>this code works but I do not understand why I need to put <code>.*</code> in there.
Also to negate it, I do not know how to do that.
I've tried:</p>
<pre><code>re.match(r'(?!=.*\bfoo\b)', 'bar red foo here')
</code></pre>
<p>but it does not work.
My ultimate goal is to combine them like so:</p>
<pre><code>re.match(r'(?=.*\bfoo\b)(?!=.*\bbar\b)', 'bar red foo here')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To detect if a word exists in  a string you need a <em>positive lookahead</em>:</p>
<pre><code>(?=.*\bfoo\b)
</code></pre>
<p>The <code>.*</code> is necessary to enable searching farther than just at the string start (<code>re.match</code> anchors the search at the string start).</p>
<p>To check if a string has no word in it, use a <em>negative lookahead</em>:</p>
<pre><code>(?!.*\bbar\b)
 ^^^
</code></pre>
<p>So, combining them:</p>
<pre><code>re.match(r'(?=.*\bfoo\b)(?!.*\bbar\b)', input)
</code></pre>
<p>will find a match in a string that contains a whole word <code>foo</code> and does not contain a whole word <code>bar</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need the <code>.*</code> because <code>re.match()</code> tries to match the pattern to the beginning of the string.  If you want to search the whole string, use <code>re.search()</code>.</p>
<p>Just as you can do <code>if re.search(...):</code>, you can also do <code>if not re.search(...):</code></p>
</div>
<div class="post-text" itemprop="text">
<p><em><strong>Update</strong></em><br/>
Just found that Python <em>re.match()</em> has an implied <code>^</code> anchor.<br/>
In other words it will only match at the beginning of the string,<br/>
and strangely, unlike Java, does not require it to match the entire string.  </p>
<p>Be warned though that combining a sequential positive and negative   <strong>lookahead</strong>,<br/>
as in Stribnez answer, can give unintended results if not anchored to<br/>
something. Either to literal text or a BOS anchor <code>^</code>.  </p>
<p>For general usage, don't rely on the fact that (or if), in some language<br/>
the <em>match()</em> function implies a BOS anchor <code>^</code> (and possibly EOS <code>$</code>).<br/>
Put one (or both) in there at all times. This way it can be used<br/>
in <em>search()</em> as well. And is portable to other languages.  </p>
<p>To see how negative and positive, in-series lookahead's can cause problems,<br/>
take this tricky standalone expression <code>(?=.*\bfoo\b)(?!.*\bbar\b)</code> </p>
<p>It can be examined like this:  </p>
<p>Since it is <em>in-series</em>, both assertions have to be matched at the same<br/>
position in the string.  </p>
<p>Given the same position in the string for both, the negative assertion<br/>
can be satisfied when it finds a place that downstream does not match it's contents.  </p>
<p>Assuming that no anchoring exists, this leave's an opening <em>upstream</em><br/>
(between the search position and the <code>bar</code> literal in the example) for<br/>
the undesired content to exist, that will still satisfy the positive/negative<br/>
assertion pair.  </p>
<p>Example:<br/>
<code>(?=.*\bfoo\b)(?!.*\bbar\b)</code><br/>
<em>matches</em><br/>
<code>bar red foo</code> </p>
<pre><code>**  Grp 0 -  ( pos 1 , len 0 )  EMPTY 

b&lt;here&gt;ar red foo
</code></pre>
<p>This shows that at position 1, both assertions are satisfied.  </p>
<p>Conclusion(s):<br/>
1. Always use anchors, even if they are implied.<br/>
2. Avoid using any language's match() function, use search() instead.  </p>
<p><em><strong>End update</strong></em></p>
<hr/>
<p>It doesn't matter if you use a positive or negative lookahead,<br/>
if you don't use the correct syntax, it won't work.   </p>
<p>Look at this <code>(?!=.*\bfoo\b)</code> </p>
<p>This says that the next character can't be an equal sign <code>=</code> followed by<br/>
a greedy number of characters up to the next <code>foo</code>. This is not allowed.  </p>
<p>So, it will not match <code>= ab foo</code>, but it will match '=(here) ab foo'.  </p>
<p>The next problem is that if you don't give the assertion anything to anchor on<br/>
it will use a bump-along to move the postion to a place <em>between</em> characters<br/>
that will satisfy it.  </p>
<p>The corrections for the negative lookahead you are looking for is this<br/>
<code>^(?!.*\bfoo\b)</code> </p>
<hr/>
<p>For reference:  </p>
<pre><code>(?=..)  Positive lookahead
(?&lt;=..) Positive lookbehind
(?!..)  Negative lookahead
(?&lt;!..) Negative lookbehind   
</code></pre>
<p>And, they can be mixed and nested anywhere.  </p>
</div>
<span class="comment-copy">Why not something like <code>'foo' in sentence and 'bar' not in sentence</code>? (Or whatever you're trying to do)</span>
<span class="comment-copy"><code>re.match(r'\bfoo\b', s) and not re.match(r'\bbar\b', s)</code></span>
<span class="comment-copy">Certainly <code>in</code> and <code>not in</code> are not an option for a whole word search inside a string, that is what regexps are for.</span>
<span class="comment-copy">@L3viathan I can't see where you'd ever prefer that to <code>'substring' in s</code>, can you?</span>
<span class="comment-copy">@Two-BitAlchemist: If you have a closer look at the regex, you will notice <code>\b</code> - a word boundary. Try emulating it with <code>in</code> and <code>not in</code>.</span>
<span class="comment-copy">Just an addition: if the string contains newline symbols, compile the regex with a <code>re.S</code> (<code>re.DOTALL</code>) flag so that <code>.</code> could also match a newline, too.</span>
<span class="comment-copy">Matches lines with <code>bar red foo</code> in it.</span>
<span class="comment-copy">So Python's match() implies BOS (and not EOS). Well that just put Python on my list of crippled engines.</span>
<span class="comment-copy">No need calling Python names. <a href="https://docs.python.org/3/library/re.html#re.fullmatch" rel="nofollow noreferrer">Python 3 has a <code>re.fullmatch</code> method</a>.</span>
<span class="comment-copy">I know for sure this regex <code>(?=.*\bfoo\b)(?!.*\bbar\b)</code> matches somewhere in this string <code>bar red foo</code>. I ran it in Perl but doesn't match in Python, a crippled engine..</span>
<span class="comment-copy">Search still returned a match for: re.search(r'(?=\bfoo\b)(?!\bred\b)', 'bar red foo here')  so I guess I cannot use it.</span>
