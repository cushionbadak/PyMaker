<div class="post-text" itemprop="text">
<p>Note: Goal of the function is to remove duplicate(repeated) characters.</p>
<p>Now for the same given recursive function, different output pops out for different argument:</p>
<pre><code>def rd(x):
    if x[0]==x[-1]:
        return x
    elif x[0]==x[1]:
        return rd(x[1: ])
    else:
        return x[0]+rd(x[1: ])
print("Enter a sentence")
r=raw_input()
print("simplified: "+rd(r))
</code></pre>
<p>This functions works well for the argument only if the duplicate character is within the starting first six characters of the string, for example:</p>
<p>if <code>r=abcdeeeeeeefghijk</code> or if <code>r=abcdeffffffghijk</code></p>
<p>but if the duplicate character is after the first six character then the output is same as the input,i.e, output=input. That means with the given below value of "r", the function doesn't work:</p>
<p><code>if r=abcdefggggggggghijkde</code> (repeating characters are after the first six characters)</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason you function don't work properly is you first <code>if x[0]==x[-1]</code>, there you check the first and last character of the substring of the moment, but that leave pass many possibility like <code>affffffa</code> or <code>asdkkkkkk</code> for instance, let see why:</p>
<p>example 1: <code>'affffffa'</code></p>
<p>here is obvious right?</p>
<p>example 2: <code>'asdkkkkkk'</code></p>
<p>here we go for case 3 of your function, and then again</p>
<pre><code>'a' +rd('sdkkkkkk')
'a'+'s' +rd('dkkkkkk')
'a'+'s'+'d' +rd('kkkkkk')
</code></pre>
<p>and when we are in <code>'kkkkkk'</code> it stop because the first and last are the same</p>
<p>example 3: <code>'asdfhhhhf'</code></p>
<p>here is the same as example 2, in the recursion chain we arrive to <code>fhhhhf</code> and here the first and last are the same so it leave untouched </p>
<p>How to fix it?, simple, as other have show already, check for the length of the string first</p>
<pre><code>def rd(x):
    if len(x)&lt;2: #if my string is 1 or less character long leave it untouched 
        return x
    elif x[0]==x[1]:
        return rd(x[1: ])
    else:
        return x[0]+rd(x[1: ])
</code></pre>
<hr/>
<p>here is alternative and iterative way of doing the same: you can use the <code>unique_justseen</code> recipe from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">itertools recipes</a></p>
<pre><code>from itertools import groupby
from operator import itemgetter

def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return map(next, map(itemgetter(1), groupby(iterable, key)))

def clean(text):
    return "".join(unique_justseen(text)
</code></pre>
<p>test</p>
<pre><code>&gt;&gt;&gt; clean("abcdefggggggggghijk")
'abcdefghijk'
&gt;&gt;&gt; clean("abcdefghijkkkkkkkk")
'abcdefghijk'
&gt;&gt;&gt; clean("abcdeffffffghijk")
'abcdefghijk'
&gt;&gt;&gt; 
</code></pre>
<p>and if you don't want to import anything, here is another way</p>
<pre><code>def clean(text):
    result=""
    last=""
    for c in text:
        if c!=last:
            last = c
            result += c
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only issue I found with you code was the first <code>if</code> statement. I assumed you used it to make sure that the string was at least 2 long. It can be done using string modifier <code>len()</code> in fact the whole function can but we will leave it recursive for OP sake. </p>
<pre><code>def rd(x):
    if len(x) &lt; 2: #Modified to return if len &lt; 2. accomplishes same as original code and more
        return x
    elif x[0]==x[1]:
        return rd(x[1: ])
    else:
        return x[0]+rd(x[1: ])

r=raw_input("Enter a sentence: ")
print("simplified: "+rd(r))
</code></pre>
<p>I would however recommend not making the function recursive and instead mutating the original string as follows</p>
<pre><code>from collections import OrderedDict

def rd(string):
    #assuming order does matter we will use OrderedDict, no longer recursive
    return "".join(OrderedDict.fromkeys(string)) #creates an empty ordered     dict eg. ({a:None}), duplicate keys are removed because it is a dict
                                                 #grabs a list of all the keys in dict, keeps order because list is orderable
                                                 #joins all items in list with '', becomes string
                                                 #returns string
r=raw_input("Enter a sentence: ")
print("simplified: "+rd(r))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your function is correct but, if you want to check the last letter, the function must be:</p>
<pre>
    def rd(x):
        if len(x)==1:
            return x
        elif x[0]==x[1]:
            return rd(x[1: ])
        else:
            return x[0]+rd(x[1: ])
    print("Enter a sentence")
    r=raw_input()
    print("simplified: "+rd(r))
</pre>
</div>
<span class="comment-copy">What is the goal of the function? Remove duplicates?</span>
<span class="comment-copy">yes exactly @agold</span>
<span class="comment-copy">it work fine to me except if the duplicate character is the last one</span>
<span class="comment-copy">Then it works for all the three examples you put here (also with 'abcdefggggggggghijk'), but it won't work if your start and end character are the same, e.g.: 'abbbbca'.</span>
<span class="comment-copy">What is the output you get for r= abcdefggggggg?</span>
<span class="comment-copy">thanks for your advice buddy, but i am not concern about other alternative ways to work it out!! i am concern with why that particular function is not working for me bcz machine can't be wrong!! i am concern with the logical reason of it. why??</span>
<span class="comment-copy">yeah, sorry about that, explanation added</span>
<span class="comment-copy">hey sorry i dint saw ur explanation as my browser were totaly messed up!! you made me totaly clear...thanks a ton buddy!! hatsoff to you :)  i was wrong with my 1st if statement, and your explanation made me logically clear :)</span>
<span class="comment-copy">glad you liked it, I also added another way of doing it without any import</span>
<span class="comment-copy">yeah i checked out that also now!! and i must appreciate ur logical thinking :) thumbs up! :)</span>
<span class="comment-copy">my first "if statement" is two make sure that the function return the exact argument if the string is one character long!!  your this statement confused me "I assumed you used it to make sure that the string was at least 2 long"...</span>
<span class="comment-copy">i am not concern with the alternative way, i am concern with why that function is not working, where i am wrong, or whats the issue here that's what i am concern with</span>
<span class="comment-copy">Okay then my solution correctly does this and fixes a potential error. (What happens if user inputs nothing? With the origonal code it would throw an index error but now it just returns). If len is one it returns, if it's zero it returns. Using len() rather than your origonal means that input 'abba' will not just return because input[0]==input[-1]. Hope this makes sense.</span>
<span class="comment-copy">oops!! :o seriously thanks a lot buddy for this vital valuable  information. thank you!   i wud be more thankful if you could make me clear about the main issue which i am not able to see</span>
<span class="comment-copy">Hey!! you know what!! when i replace my if statement with "if x&lt;=1" as you told to make it sure that that error dont pops out if user enters nothing!!  but this change also solve out my main problem..... with that change if i input the argument with the repeated character even after starting six character then it shows the correct expected output!! i am amazed... and again thankful to you, but i dint understood the logic behind it :o now i caught up in more confusion</span>
<span class="comment-copy">last letter?? which one??</span>
<span class="comment-copy">k, for example: r=abcdefghijkkkkkk</span>
<span class="comment-copy">issue already solved!! your approach is also right!! :)</span>
