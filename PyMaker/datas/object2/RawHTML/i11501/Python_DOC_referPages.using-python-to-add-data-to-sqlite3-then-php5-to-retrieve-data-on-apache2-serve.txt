<div class="post-text" itemprop="text">
<p>*UPDATED
I am try to make a game for my son, it has 2 vibration sensors that represent Balls and Strikes (for baseball). When a sensor is hit I have a loop that adds a tick to either the strike or the ball. When a sensor is hit I want it also to enter into my sqlite db. then I have a php file that reads the sqlite db and displays the balls and strikes as they happen in realtime. I am using php5, sqlite3 and apache2 server. I have the server setup, the python script detects the sensors correctly and updates 2 variables, balls and strikes. I cannot seem to link to py file to the php file so when I navigate to basesloaded.php it execute's sensor.py. If I run the py script in idle first then navigate to the php page it updates correctly just wont run the py script from the php file.</p>
<pre><code>#sensor.py file
#!/usr/bin/env python
import RPi.GPIO as GPIO
import time
import sqlite3

KnockPin = 12 
ShockPin = 13 

BtnPin = 15

inning = 1
runs = 0
strikes = 0
balls = 0

print ("Welcome to Bases Loaded!")

def setstr():
    global strikes
    strikes = 0
    global balls
    balls = 0

def setup():
    GPIO.setmode(GPIO.BOARD)         
    GPIO.setup(KnockPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(ShockPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)   

def knock(ev=None):

    with sqlite3.connect('basesLoaded.db') as conn;

        global strikes
        strikes += 1

        if strikes ==0:
            pass
        elif strikes == 1:            
            conn.execute("UPDATE bl set STRIKE = 1 WHERE ID =1");
            print ("Strike 1 :", conn.total_changes);

        elif strikes == 2:
            conn.execute("UPDATE bl set STRIKE = 2 WHERE ID=1");
            print ("Strike 2 :", conn.total_changes);

        elif strikes == 3:
            conn.execute("UPDATE bl set STRIKE = 0 WHERE ID=1");
            print ("Strike 3 Your Out :", conn.total_changes);

            global inning
            inning +=1
            conn.execute("UPDATE bl set INNING = inning WHERE ID=1");
            setstr()
            print ("Inning Number :", inning);

def shock(ev=None):
    with sqlite3.connect('basesLoaded.db') as conn;
        print ("Opened database successfully");
        global balls
        balls += 1

        if balls ==0:
            pass
        elif balls == 1:          
            conn.execute("UPDATE bl set BALL = 1 WHERE ID=1");
            print ("Ball 1 :", conn.total_changes);

        elif balls == 2:
            conn.execute("UPDATE bl set BALL = 2 WHERE ID=1");
            print ("Ball 2 :", conn.total_changes); 

        elif balls == 3:
            conn.execute("UPDATE bl set BALL = 3 WHERE ID=1");
            print ("Ball 3 :", conn.total_changes);

        elif balls == 4:

            global runs
            runs += 1
            conn.execute("UPDATE bl set BALL = 0 WHERE ID=1");
            conn.execute("UPDATE bl set RUN = 'runs' WHERE ID=1");
            print ("Run Scored! score is :", runs); 
            setstr()

def loop():

    GPIO.add_event_detect(ShockPin, GPIO.FALLING, callback=shock, bouncetime=2500)

    GPIO.add_event_detect(KnockPin, GPIO.FALLING, callback=knock, bouncetime=2500) 

if __name__ == '__main__':     # Program start from here
    setup()
    try:
        loop()

    except KeyboardInterrupt: 
        destroy()
</code></pre>
<p>Here is my php script to retrieve the sqlite data - </p>
<pre><code>#basesLoaded.php file
&lt;?php
$try = exec('python sensor.py');
print_r ($try);
$db = new SQLite3('basesLoaded.db');

echo '&lt;br&gt;';
echo '&lt;br&gt;';
$strikes = ($db-&gt;querySingle('SELECT STRIKE FROM bl WHERE ID = 1'));
$balls = ($db-&gt;querySingle('SELECT BALL FROM bl WHERE ID = 1'));
$outs = ($db-&gt;querySingle('SELECT OUT FROM bl WHERE ID = 1'));
$runs = ($db-&gt;querySingle('SELECT RUN FROM bl WHERE ID = 1'));
$inning = ($db-&gt;querySingle('SELECT INNING FROM bl WHERE ID = 1'));


echo 'Strikes: ' . $strikes . '&lt;br&gt;';
echo 'Balls: ' . $balls . '&lt;br&gt;';
echo 'Outs: ' . $outs . '&lt;br&gt;';
echo 'Runs: ' . $runs . '&lt;br&gt;';
echo 'Inning: ' . $inning . '&lt;br&gt;';
?&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in comments by @Parfait, you need to commit the updates for them to be persistent. Your PHP code is not seeing the updates because they were not committed.</p>
<p>You can call <code>conn.commit()</code> in your code, however, an easy way to guarantee that your updates are committed (or rolled back if there is an error) is to open the database with a <a href="https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager" rel="nofollow">context manager</a>, i.e. using a <code>with</code> statement, for example:</p>
<pre><code>def knock(ev=None):
    with sqlite3.connect('basesLoaded.db') as conn:
        conn.execute("UPDATE bl set STRIKE = 1 WHERE ID =1")
</code></pre>
<p>Now your updates will be automatically committed when the <code>with</code> statement terminates, in this case when the function <code>knock()</code> returns, or rolled back if an exception occurs.</p>
<hr/>
<p><strong>Update</strong></p>
<p>As discussed in comments, there seems to be a problem with the event handling. I suspect that your code needs to explicitly keep running otherwise, once the main thread terminates, the whole program will terminate. You can do it like this:</p>
<pre><code>WAIT_PIN = 14

def register_callbacks():
    GPIO.add_event_detect(ShockPin, GPIO.FALLING, callback=shock, bouncetime=2500)
    GPIO.add_event_detect(KnockPin, GPIO.FALLING, callback=knock, bouncetime=2500) 

def wait():
    GPIO.wait_for_edge(WAIT_PIN, GPIO.BOTH)    # wait for level change

#    # Or wait in a while loop        
#    while True:
#        time.sleep(0.1)

#    # Or wait for keyboard input
#    input('Press &lt;ENTER&gt; to quit: ')

if __name__ == '__main__':
    try:
        setup()
        register_callbacks()
        wait()    # block the main thread
    except KeyboardInterrupt: 
        destroy()  
</code></pre>
<p>You need to have this Python script running all the time. It is independent of the PHP script which is run only in response to HTTP requests via your web server. You can run the Python script as a background process:</p>
<pre><code>$ python sensor.py &amp;
</code></pre>
<p>Also, remove the <code>exec()</code> call from your PHP script.</p>
</div>
<span class="comment-copy">You do not commit --<code>conn.commit()</code>-- you action queries in first Python script. Also, why are you using two languages. Wouldn't Python suffice for all needs?</span>
<span class="comment-copy">Im new to python, I am somewhat familiar with php as I have used it with mysql for other projects.. Can I do all of this with just python? Ultimately it will be a live scoreboard I can view on my tablet wireless through apache2 using the pi ip address..</span>
<span class="comment-copy">conn.commit() did the trick for updating the db, Thanks @Parfait</span>
<span class="comment-copy">If the tablet software supports Python then it should (by the way see QPython for Android) as Python can produce html markup files.</span>
<span class="comment-copy">This fixes my issue with updating the record in idle but when I run the php script it wont update the records when the sensors hit, only when I run it in idle.. Any idea what im missing there? Thanks @mhawke !</span>
<span class="comment-copy">I update the question to be more specific now to the php file not executing the py file after the welcome message at the top of the script.</span>
<span class="comment-copy">Check the docs on the <code>GPIO</code> module as it seems the <code>knock</code> and <code>shock</code> functions are called on the if conditionals in <code>loop()</code>. Is there no actual call to functions?</span>
<span class="comment-copy">The knock and shock functions are only called if it detects gpio falling in that loop.. Not sure if that is the right way to do it as I said im new to python..</span>
<span class="comment-copy">@RyanD: The code in <code>loop()</code> looks suspect. The <code>knock</code> callback is registered only if the <code>shock</code> callback registration fails. I suppose that it's unlikely that the <code>shock</code> registration will fail, do the code will not actually handle <code>knock</code> events. Try getting rid of the <code>if</code> statement and register both callbacks. I'm not sure that the <code>while</code> loop is required because the callback handlers are managed by a second thread, but unsure whether the main thread waits for the child thread. You can try with and without the <code>while</code> loop.</span>
