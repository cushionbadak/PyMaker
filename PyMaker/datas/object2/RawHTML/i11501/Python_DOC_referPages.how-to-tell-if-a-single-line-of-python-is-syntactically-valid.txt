<div class="post-text" itemprop="text">
<p>It is very similar to this:</p>
<p><a href="https://stackoverflow.com/questions/11854745/how-to-tell-if-a-string-contains-valid-python-code">How to tell if a string contains valid Python code</a></p>
<p>The only difference being instead of the entire program being given altogether, I am interested in a single line of code at a time.</p>
<p>Formally, we say a line of python is "syntactically valid" if there exists any syntactically valid python program that uses that particular line.</p>
<p>For instance, I would like to identify these as syntactically valid lines:</p>
<pre><code>for i in range(10):

x = 1
</code></pre>
<p>Because one can use these lines in some syntactically valid python programs.</p>
<p>I would like to identify these lines as syntactically invalid lines:</p>
<pre><code>for j in range(10 in range(10(

x =++-+ 1+-
</code></pre>
<p>Because no syntactically correct python programs could ever use these lines</p>
<p>The check does not need to be too strict, it just need to be good enough to filter out obviously bogus statements (like the ones shown above). The line is given as a string, of course.</p>
</div>
<div class="post-text" itemprop="text">
<p>This uses <a href="https://docs.python.org/3/library/codeop.html#codeop.compile_command"><code>codeop.compile_command</code></a> to attempt to compile the code. This is the same logic that the <a href="https://docs.python.org/3/library/code.html"><code>code</code></a> module <a href="https://github.com/python/cpython/blob/master/Lib/code.py">does</a> to determine whether to ask for another line or immediately fail with a syntax error.</p>
<pre><code>import codeop
def is_valid_code(line):
    try:
        codeop.compile_command(line)
    except SyntaxError:
        return False
    else:
        return True
</code></pre>
<p>It can be used as follows:</p>
<pre><code>&gt;&gt;&gt; is_valid_code('for i in range(10):')
True
&gt;&gt;&gt; is_valid_code('')
True
&gt;&gt;&gt; is_valid_code('x = 1')
True
&gt;&gt;&gt; is_valid_code('for j in range(10 in range(10(')
True
&gt;&gt;&gt; is_valid_code('x = ++-+ 1+-')
False
</code></pre>
<p>I'm sure at this point, you're saying "what gives? <code>for j in range(10 in range(10(</code> was supposed to be <em>invalid!</em>" The problem with this line is that <code>10()</code> is technically <em>syntactically</em> valid, at least according to the Python interpreter. In the REPL, you get this:</p>
<pre><code>&gt;&gt;&gt; 10()
Traceback (most recent call last):
  File "&lt;pyshell#22&gt;", line 1, in &lt;module&gt;
    10()
TypeError: 'int' object is not callable
</code></pre>
<p>Notice how this is a <code>TypeError</code>, <em>not</em> a <code>SyntaxError</code>. <a href="https://docs.python.org/3/library/ast.html#ast.parse"><code>ast.parse</code></a> says it is valid as well, and just treats it as a call with the function being an <code>ast.Num</code>.</p>
<p>These kinds of things can't easily be caught until they actually run.
If some kind of monster managed to modify the value of the cached <code>10</code> value (which would technically be possible), you might be able to do <code>10()</code>. It's still allowed by the syntax.</p>
<p>What about the unbalanced parentheses? This fits the same bill as <code>for i in range(10):</code>. This line is invalid on its own, but may be the first line in a multi-line expression. For example, see the following:</p>
<pre><code>&gt;&gt;&gt; is_valid_code('if x ==')
False
&gt;&gt;&gt; is_valid_code('if (x ==')
True
</code></pre>
<p>The second line is <code>True</code> because the expression could continue like this:</p>
<pre><code>if (x ==
    3):
    print('x is 3!')
</code></pre>
<p>and the expression would be complete. In fact, <a href="https://docs.python.org/3/library/codeop.html#codeop.compile_command"><code>codeop.compile_command</code></a> distinguishes between these different situations by returning a code object if it's a valid self-contained line, <code>None</code> if the line is expected to continue for a full expression, and throwing a <code>SyntaxError</code> on an invalid line.</p>
<p>However, you can also get into a much more complicated problem than initially stated. For example, consider the line <code>)</code>. If it's the start of the module, or the previous line is <code>{</code>, then it's invalid. However, if the previous line is <code>(1,2,</code>, it's completely valid.</p>
<p>The solution given here will work if you only work forward, and append previous lines as context, which is what the <a href="https://docs.python.org/3/library/code.html">code</a> module <a href="https://github.com/python/cpython/blob/master/Lib/code.py">does</a> for an interactive session. Creating something that can always accurately identify whether a single line could <em>possibly</em> exist in a Python file without considering surrounding lines is going to be extremely difficult, as the Python grammar interacts with newlines in non-trivial ways. This answer responds with whether a given line could be at the beginning of a module and continue on to the next line without failing.</p>
<p>It would be better to identify what the purpose of recognizing single lines is and solve that problem in a different way than trying to solve this for every case.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am just suggesting, not sure if going to work... But maybe something with <code>exec</code> and <code>try-except</code>?</p>
<pre><code>code_line += "\n" + ("\t" if code_line[-1] == ":" else "") + "pass"
try:
    exec code_line
except SyntaxError:
    print "Oops! Wrong syntax..."
except:
    print "Syntax all right"
else:
    print "Syntax all right"
</code></pre>
<p>Simple lines should cause an appropriate answer</p>
</div>
<span class="comment-copy">FYI, <code>x =+ 1</code> is syntactically valid. It assigns <code>+1</code> to <code>x</code>.</span>
<span class="comment-copy">What about implicit line concatenation (which would make <code>for j in range(10</code> also possibly syntatically valid)</span>
<span class="comment-copy"><code>for j in range(10</code> is also valid if the next line continues with something like <code>):</code>, and <code>if x &lt; 3</code> could be part of a multi-line expression as well. Almost anything could be part of a multi-line string, too.</span>
<span class="comment-copy">I think the question that you need to answer is <i>why</i> you need/want to do this</span>
<span class="comment-copy">The <code>for</code> is still syntactically valid. The assignment isn't quite valid any more unless, say, it's part of a triple-quoted string or a line-continued comment. I don't think you quite understand what you're trying to do.</span>
<span class="comment-copy">I agree with your logic. But shouldn't the "for j in range(10 in range(10(" be invalid because it has unmatched parenthesis (a syntax only error)?</span>
<span class="comment-copy">No, since that line may continue onto the next line. I'll explain in the answer.</span>
<span class="comment-copy">sounds reasonable enough! Seems more safer than adding the "pass" and trying to compile to an AST (the other answer). I will use this</span>
<span class="comment-copy">@EvanPu Have fun! For examples of integer evil, see <a href="http://codegolf.stackexchange.com/a/28851">this</a> beautiful code golf answer.</span>
<span class="comment-copy">@EvanPu More important would be to know the reasoning for why this needs to be done, and try solving that problem instead.</span>
<span class="comment-copy">I was just about to suggest the <code>+= "pass"</code> approach. You might want to <code>.rstrip</code> the line though. Also, you don't need the new line and the indentation.</span>
<span class="comment-copy">Executing lines is opening Pandora's box. Let's see if <code>while True:</code> is syntactically valid. How about <code>import os; os.system('rm -rf /')</code>?</span>
<span class="comment-copy">@JohnKugelman Right, but this is going to need to be sand-boxed anyways. If OP is randomly generating programs, some of them may not halt, and some of them affect the environment.</span>
<span class="comment-copy">@JohnKugelman You're right... But I can't think of any way to do it without simply making python interpreter... Does someone know of a way to execute python code without really executing it? Stupid question I know but can help much with this</span>
<span class="comment-copy">this is similar to what my labmate and I discussed just now. I will try this approach and report back in an hour. thanks!</span>
