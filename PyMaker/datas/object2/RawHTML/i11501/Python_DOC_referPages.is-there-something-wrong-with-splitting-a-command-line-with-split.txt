<div class="post-text" itemprop="text">
<p>In most <a href="https://stackoverflow.com/questions/89228/calling-an-external-command-in-python">answers</a> (I found) to the question <em>"How to run an external command"</em> I see something along the lines</p>
<blockquote>
<p>If you want to run <code>ls -l</code> you need to use <code>subprocess.call(["ls", "-l"])</code></p>
</blockquote>
<p>What I normally do when I know what I will be running is to call <code>subprocess.call('ls -l'.split(' '))</code> to have visually the command line in one piece (it is usually a variable).</p>
<p>Is there anything inherently wrong with using <code>split()</code> as opposed to building the list manually (again, when the command is known). Or are these answers crafted to explicitly show that a list is needed?</p>
<p>I tried to find some drawbacks (multiple spaces, escaped spaces, ...) but I do not see where that approach could go wrong?</p>
<p>Note: this question is specifically about the robustness of splitting on spaces, not the security issues or other (very important) considerations as such.</p>
</div>
<div class="post-text" itemprop="text">
<p>Observe that this works:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; subprocess.call(['ls', '-l', "my file"])
-rw-rw---- 1 john john 0 May  5 10:46 my file
0
</code></pre>
<p>But this does not:</p>
<pre><code>&gt;&gt;&gt; subprocess.call('ls -l "my file"'.split(' '))
ls: cannot access "my: No such file or directory
ls: cannot access file": No such file or directory
2
</code></pre>
<p>And this does work:</p>
<pre><code>&gt;&gt;&gt; import shlex
&gt;&gt;&gt; shlex.split('ls -l "my file"')
['ls', '-l', 'my file']
&gt;&gt;&gt; subprocess.call(shlex.split('ls -l "my file"'))
-rw-rw---- 1 john john 0 May  5 10:46 my file
0
</code></pre>
<h3>Recommendation</h3>
<p>In python philosphy, <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">explicit is better than implicit</a>.  Thus, of those three forms, use this one:</p>
<pre><code>subprocess.call(['ls', '-l', 'my file'])
</code></pre>
<p>This avoids all preprocessing and shows you clearly and unambiguously and <em>explicitly</em> what will be executed and what its arguments are.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are really certain that there are no issues with unescaped characters (including spaces in filenames), then I don't see any problem.</p>
<p>But you might find it easier to use <code>os.system("ls -l")</code> instead. Just note that if you want to use the result code, it should be right shifted by 8 bits:</p>
<pre><code>exit_code = os.system("ls -l") &gt;&gt; 8
</code></pre>
<p>Alternatively (more robust, but also more work to type...):</p>
<pre><code>subprocess.call('ls -l', shell=True)
</code></pre>
<p>Then you let the shell handle the splitting.</p>
<p>Edit: also mention subprocess.</p>
</div>
<span class="comment-copy">You should be using <a href="https://docs.python.org/2/library/shlex.html#shlex.split" rel="nofollow noreferrer"><code>shlex.split</code></a> for this.</span>
<span class="comment-copy">in most cases you don't have constant command arguments: <code>["ls", "-l", pathname]</code></span>
<span class="comment-copy">I agree with Ashwini.  <code>shlex.split</code> will handle quoting properly ... <code>ls -l "file with spaces"</code>, <code>str.split</code> won't.  Additionally, 99% of the time when you write <code>str.split(' ')</code>, you <i>really</i> want <code>str.split()</code> (which will handle consecutive runs of whitespace in a way that you <i>usually</i> want).</span>
<span class="comment-copy">You may use commands.getoutput() instead</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow noreferrer">The docs</a> for os.system recommend using subprocess instead.</span>
