<div class="post-text" itemprop="text">
<p>I am trying to run all the functions in my class without typing them out individually.</p>
<pre><code>class Foo(object):
    def __init__(self,a,b):
        self.a = a
        self.b=b

    def bar(self):
        print self.a

    def foobar(self):
        print self.b
</code></pre>
<p>I want to do this but with a loop, because my actual class has about 8-10 functions.</p>
<pre><code>x = Foo('hi','bye')
x.bar()
x.foobar()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>dir()</code> or <code>__dict__</code> to go through all of an object's attributes. You can use <code>isinstance()</code> and <a href="https://docs.python.org/2/library/types.html#types.FunctionType" rel="nofollow"><code>types.FunctionType</code></a> to tell which ones are functions. Just call any that are functions.</p>
<h2>Update</h2>
<p>As Tadhg commented, <code>inspect.ismethod</code> seems like the best choice. Here's some example code:</p>
<pre><code>import inspect
from itertools import ifilter


class Foo(object):
    def foo1(self):
        print('foo1')

    def foo2(self):
        print('foo2')

    def foo3(self, required_arg):
        print('foo3({!r})'.format(required_arg))

f = Foo()
attrs = (getattr(f, name) for name in dir(f))
methods = ifilter(inspect.ismethod, attrs)
for method in methods:
    try:
        method()
    except TypeError:
        # Can't handle methods with required arguments.
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get list of all 'public' methods of your instance:</p>
<pre><code>x = Foo('hi','bye')

public_method_names = [method for method in dir(x) if callable(getattr(x, method)) if not method.startswith('_')]  # 'private' methods start from _
for method in public_method_names:
    getattr(x, method)()  # call
</code></pre>
<p>See more about <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">getattr</a>
Actually, Python doesn't have <code>public</code> or <code>private</code> semantic, you can read <a href="https://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">that</a> if interested</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the easiest way to solve this problem, also it's kind of flexible to do changes in it.</p>
<pre><code>import threading
from threading import Thread

class ClassName():
    def func1(self):
        print ('2')

    def func2(self):
        print ('3')

    def runall(self):
        if __name__ == '__main__':
            Thread(target = self.func1).start()
            Thread(target = self.func2).start()
run = ClassName()
run.runall() # will run all the def's in the same time
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While I realize it's not what you're asking, I think what you're asking (execute all methods) in general is a bad idea, because the object's API is not internal to the object. (E.g. the user has to write functionality (namely exactly the functionality that you're asking for) in order to use the class.)</p>
<p>You're much better off defining a list of methods that you want to run yourself. E.g.:</p>
<pre><code>exec_methods = ["bar", "foobar"]
for method in exec_methods:
    getattr(x, method)()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While I do not particularly recommend calling <strong>all</strong> the methods on an object since as soon as you add some that require an argument it will obviously fail, you could use a decorator to label the methods that represent a test case and then search for all the ones that have said label:</p>
<pre><code>def tester_method(f):
    f._is_for_test = True #add an arbitrary attribute to the function, completely supported for exactly this reason.
    return f

def call_all_tester_methods(x):
    """finds all attributes with a ._is_for_test attribute of their 
own and calls all of them in no guaranteed order"""
    methods = {}
    for name in dir(x):
        attr = getattr(x,name)
        if getattr(attr,"_is_for_test",False):
            methods[name] = attr
    for name,method in methods.items():
        #print("calling: {}".format(name))
        method()

class Foo(object):
    def __init__(self,a,b):
        self.a = a
        self.b=b

    @tester_method
    def bar(self):
        print(self.a)

    @tester_method
    def foobar(self):
        print(self.b)

    def othermethod_not_for_test(self,arg):
        return self.a + arg #this is not included in the test case

obj = Foo('hi','bye')
call_all_tester_methods(obj)
</code></pre>
</div>
<span class="comment-copy">What's the point of <code>Foo</code>? <a href="http://xyproblem.info/" rel="nofollow noreferrer">xyproblem.info</a></span>
<span class="comment-copy">might as well check for any <a href="https://docs.python.org/2/library/functions.html#callable" rel="nofollow noreferrer"><code>callable</code></a>s or use <a href="https://docs.python.org/2/library/inspect.html#inspect.ismethod" rel="nofollow noreferrer"><code>inspect.ismethod</code></a></span>
<span class="comment-copy">Thanks for the correction, @zondo.</span>
<span class="comment-copy">I'd forgotten about the <code>inspect</code> module, @TadhgMcDonald-Jensen, thanks.</span>
<span class="comment-copy">with python 3 not need anymore of itertools. ifilter became filter and it is in the core library.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/a/1911287/6301103">This</a> is a much simpler way to do it. Also uses the inspect module.</span>
