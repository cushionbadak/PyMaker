<div class="post-text" itemprop="text">
<p>Is there any difference whatsoever between using <a href="https://docs.python.org/library/random.html#random.randrange" rel="nofollow"><code>random.randrange</code></a> to pick 5 digits individually, like this:</p>
<pre><code>a=random.randrange(0,10)
b=random.randrange(0,10)
c=random.randrange(0,10)
d=random.randrange(0,10)
e=random.randrange(0,10)
print (a,b,c,d,e)
</code></pre>
<p>...and picking the 5-digit number at once, like this:</p>
<pre><code>x=random.randrange(0, 100000)
print (x)  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Any random-number-generator differences (if any --- see the section on Randomness) are minuscule compared to the utility and  maintainability drawbacks of the digit-at-a-time method.</p>
<p>For starters, generating each digit would require a lot more code to handle perfectly normal calls like <code>randrange(0, 1024)</code> or <code>randrange(0, 2**32)</code>, where the digits do <em>not</em> arise in equal probability.  For example, on the closed-closed range [0,1023] (requiring 4 digits), the first digit of the four can <em>never</em> be anything other than 0 or 1.  The last digit is slightly more likely to be a 0, 1, 2, or 3.  And so on.</p>
<p>Trying to cover all the bases would rapidly make that code slower, more bug-prone, and more brittle than it already is.  (The number of annoying little details you've encountered just posting this question should give you an idea what lies farther down that path.)</p>
<p>...and all that grief is <em>before</em> you consider how easily <a href="https://docs.python.org/3/library/random.html#random.randrange" rel="nofollow"><code>random.randrange</code></a> handles non-zero <code>start</code> values, the <code>step</code> parameter, and negative arguments.</p>
<h1>Randomness Problems</h1>
<p>If your RNG is good, your alternative method should produce "equally random" results (assuming you've handled all the problems I mentioned above).  <em>However</em>, if your RNG is biased, then the digit-at-a-time method will probably increase its effect on your outputs.</p>
<p>For demonstration purposes, assume your absurdly biased RNG has an off-by-one error, so that it <em>never</em> produces the last value of the given range:</p>
<ul>
<li><p>The call <code>randrange(0, 2**32)</code> will never produce <code>2**32 - 1</code> (4,294,967,295), but the remaining 4-billion-plus values will appear in very nearly their expected probability.  Its output over millions of calls would be very hard to distinguish from a working pseudo-random number generator.</p></li>
<li><p>Producing the ten digits of that same supposedly-random number individually will subject <em>each</em> digit to that same off-by-one error, resulting in a ten-digit output that consists entirely of the digits [0,8], with no 9s present... <em>ever</em>.  This is vastly "less random" than generating the whole number at once.</p></li>
</ul>
<p>Conversely, the digit-at-a-time method will never be <em>better</em> than the RNG backing it, even when the range requested is very small.  That method might magnify any RNG bias, or just repeat that bias, but it will never reduce it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, no and no.</p>
<p>Yes: probabilities multiply, so the digit sequences have the same probability</p>
<p>prob(a) and prob(b) = prob(a) * prob(b)</p>
<p>Since each digit has 0.1 chance of appear, the probability of two particular digits in order is 0.1**2, or 0.01, which is the probability of a number between 0 and 99 inclusive.</p>
<p>No: you have a typo in your second number.</p>
<p>The second form only has four digits; you probably meant randrange(0, 100000)</p>
<p>No: the output will not be the same</p>
<p>The second form will not print leading digits; you could print("%05d"%x) to get all the digits.  Also, the first form has spaces in the output, so you could instead print("%d%d%d%d%d"%(a,b,c,d,e)).</p>
</div>
<span class="comment-copy">the range constructed by <code>randrange</code> does not include the <code>stop</code> argument; I assume you mean to be calling <code>randrange(0, 10)</code> and <code>randrange(0, 100000)</code></span>
<span class="comment-copy">@Hamms probably not, since he starts the range at <code>0</code>, the number of items is the same had he gone from <code>range(1, 10)</code>.</span>
<span class="comment-copy">I'm inclined to say that I believe the probability distribution of the two approaches is the same, but with some caveats. The first being that the performance of the one-digit-at-a-time method is obviously going to be worse. The second being that you then of course will have to "assemble" your number correctly, which you are not doing in the example given.</span>
<span class="comment-copy">What you print in your example is not a number, it is a tuple of numbers.</span>
<span class="comment-copy">(6, 1, 2) is "a tuple of three integers: six, one, and two", it's not the same as 612 - a single integer "six hundred and twelve". If you want the first one give equivalent output, you will need to do <code>(a * 10000) + (b * 1000) + (c * 100) + (d * 10) + e</code> to convert the digits into a single number.</span>
<span class="comment-copy">Uh, if by [0,1023] you mean a random number drawn from this range, it can and will begin with any digit other than zero. For example, 234, 987, or 64 are numbers in this range. There is a <i>slight</i> bias towards numbers starting with 1, but you would need extensive data to demonstrate this.</span>
<span class="comment-copy">@triplee:  The digit-at-a-time method presented in the question generates <i>n</i> digits every time, where <i>n</i> is just enough to include all possible outputs.  So if the range is [0,1023], emitting a smaller number like 12 requires generating all four digits: 0, 0, 1, 2.  Even if the final output is a string like <code>'12'</code>, the function must generate the leading zero (or else, how do you know the thousands digit is a zero?), while <i>not</i> generating impossible values like 7 (again, even if they're never emitted).</span>
<span class="comment-copy">I still don't understand that part of the exposition. Maybe there is a syntax error there, too. When you say <i>never be anything [other] than 0 or 1</i> I understand that to be trying to say it cannot produce numbers which start with a different digit, which I don't think is true. But maybe your notation means something else than I thought?</span>
<span class="comment-copy">@tripleee: I'm not sure what you're asking.  I <i>think</i> you're missing that a "two-digit" number like 12 can have any number of zeroes in front of it, like 0012.  The number of digits required is determined by the input.  The digit-at-a-time method can't tell which digits will be 0 until its generated them, so it must generate them all.  Thus the closed-closed range [0,1023] requires generating <i>all 4</i> digits, even if the eventual output is "only" 12 (really 0012).  Not all combinations of <i>n</i> digits are valid output.  For [0,1023], the thousands digit can be 0 or 1, but <i>never</i> 2 through 9.</span>
<span class="comment-copy">@tripleee: To put it another way, the greatest integer on the closed-closed range [0,1023] is 1023.  All negative integers (4-digit or otherwise) lie outside that range.  <i>Some</i> 4-digit non-negative integers, including those with leading zeros, lie inside that range, while some lie outside.  Of the 4-digit non-negative integers, <i>all</i> that have a thousands digit of 2 or greater lie outside the range (because 2000 &gt; 1023), and thus are not valid selections from that range.</span>
