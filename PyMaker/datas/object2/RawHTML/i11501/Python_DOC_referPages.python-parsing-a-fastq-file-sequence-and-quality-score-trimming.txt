<div class="post-text" itemprop="text">
<p>I am trying to trim a sequence based upon a trimmed quality score. Since I'm relatively new to python, I was looking for something simple that may do the trick. </p>
<p>I have the following quality score that is converted based on phred scores to numerical values:</p>
<blockquote>
<p>1816  28  32  32  26  164  30  32  1816  1618  216  22  1616  216  218
  20  28  1816  1816  24  1816  1620  20  24  28  28  28  216  26  28 
  1622  216  28  24  18  24  28  1622  30  222  24  18  218  216  26  26
  218  28  1624  24  16  26  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2
  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2
  2  2  2  2  2  2  2  2  2  2</p>
</blockquote>
<p>Here is the corresponding sequence:</p>
<blockquote>
<p>ACCGAGCCGAAGGAGACCGCATTCACCCGGATGCCCTTCGAGGCCAGCGCCACCGCCATCGACCGCGTCATCTGCTCCACCGCGGCCCAGCTGATGGAACA</p>
</blockquote>
<p>Essentially, I want to be able to remove/cut/trim all value "2"s at the end of the quality score, compare the two strings and remove/cut/trim the corresponding sequence nucleotides at the end of the sequence. </p>
<p>I have tried splitting the quality score into two sections, and using that to print the first section of the sequence:</p>
<pre><code>cutquality = actualquality.split(" 2 ",1)
newquality = cutquality[0]
lenofseq = len(cutquality[0].strip("  "))
newseq = actualseq[:lenofseq]
</code></pre>
<p>But it doesn't seem to print the cut sequence. I am able to cut the quality score where I want it to. Another thing you may have noticed is that the quality score values are not spaced appropriately. I'm not sure why this is occurring.. I used a <code>" ".join()</code> for the quality score values once they were converted and this is the output I got. </p>
<p>I would appreciate your suggestions!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dropwhile()</code> from itertools, when applied to the reversed data, does what you want -- it filters until the filter is no longer true and then drops out completely, low quality scores will no longer trip it:</p>
<pre><code>from itertools import dropwhile

qualities = '1816 28 32 32 26 164 30 32 1816 1618 216 22 1616 216 218 20 28 1816 1816 24 1816 1620 20 24 28 28 28 216 26 28 1622 216 28 24 18 24 28 1622 30 222 24 18 218 216 26 26 218 28 1624 24 16 26 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2'.split()

sequence = 'ACCGAGCCGAAGGAGACCGCATTCACCCGGATGCCCTTCGAGGCCAGCGCCACCGCCATCGACCGCGTCATCTGCTCCACCGCGGCCCAGCTGATGGAACA'

QUALITY_LIMIT = 2

QUALITY_SCORE, BASE = 0, 1

filter = lambda pair: pair[QUALITY_SCORE] &lt;= QUALITY_LIMIT

reversed_quality_sequence = zip(reversed([int(quality) for quality in qualities]), reversed(sequence))

filtered_sequence = "".join(reversed([pair[BASE] for pair in dropwhile(filter, reversed_quality_sequence)]))

print(filtered_sequence)
</code></pre>
<p><strong>OUTPUT</strong></p>
<blockquote>
<p>ACCGAGCCGAAGGAGACCGCATTCACCCGGATGCCCTTCGAGGCCAGCGCCA</p>
</blockquote>
<p>This same technique can also be used (more easily) to clean up low qualty data at the start of the sequence.</p>
</div>
<div class="post-text" itemprop="text">
<p>To handle trimming from the end only of the quality scores you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow"><code>itertools.dropwhile()</code></a> on the reversed <code>quality_scores</code> list to get rid of the trailing '2' items (thanks @cdlane for that idea). Then slice the <code>bases</code> to the length of the trimmed quality scores. No zipping required:</p>
<pre><code>from itertools import dropwhile

quality_scores = '1816 28 32 32 26 164 30 32 1816 1618 216 22 1616 216 218 20 28 1816 1816 24 1816 1620 20 24 28 28 28 216 26 28 1622 216 28 24 18 24 28 1622 30 222 24 18 218 216 26 26 218 28 1624 24 16 26 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2'.split()
bases = 'ACCGAGCCGAAGGAGACCGCATTCACCCGGATGCCCTTCGAGGCCAGCGCCACCGCCATCGACCGCGTCATCTGCTCCACCGCGGCCCAGCTGATGGAACA'

length = len(list(dropwhile(lambda x: x == '2', reversed(quality_scores))))
newseq = bases[:length]
print(newseq)
</code></pre>
<p><strong>Output</strong></p>
<pre>
ACCGAGCCGAAGGAGACCGCATTCACCCGGATGCCCTTCGAGGCCAGCGCCA
</pre>
</div>
<span class="comment-copy">If there is no explicit need to implement this task on your own, <a href="http://cutadapt.readthedocs.io/en/stable/guide.html" rel="nofollow noreferrer">cutadapt</a> will do the job for you.</span>
<span class="comment-copy">Good idea (which I have pilfered for my answer:). You don't need to perform the zip or the second reversal; just determine the length of the trimmed qualities and then truncate the nucleotide sequence to that length.</span>
<span class="comment-copy">Could you please explain how the trimmed_base variable is constructed? And is there a way to ensure that it only cuts the scores of 2 at the end? I tried it on my code and I don't think it is doing what it should.</span>
<span class="comment-copy">@Jay: detailed explanation added.</span>
<span class="comment-copy">Updated answer with a simpler solution inspired by the answer of @cdlane</span>
