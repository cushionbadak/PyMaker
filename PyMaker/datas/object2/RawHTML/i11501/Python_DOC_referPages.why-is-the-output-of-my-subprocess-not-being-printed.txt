<div class="post-text" itemprop="text">
<p>Here is my best attempt at asynchronously reading stdin/stdout from a subprocess and printing it from Python:</p>
<pre><code>import asyncio
import subprocess

from asyncio.subprocess import STDOUT, PIPE, DEVNULL


async def start_stream():
    return await asyncio.create_subprocess_shell(
        'watch ls /proc',
        stdout=PIPE,
        stderr=PIPE,
        limit=1024
    )


async def spawn():
    ev_proc = await start_stream()
    while True:
        stdout, stderr = await ev_proc.communicate()
        print(stdout, stderr)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(spawn())
</code></pre>
<p>Why is the print function not outputting anything?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>watch</code> process never terminates and <code>communicate()</code> waits for the process to terminate, therefore <code>stdout</code> never arrives in your script.<br/>
<a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-subprocess.html</a></p>
<blockquote>
<p>coroutine communicate(input=None) </p>
<p>Interact with process: Send data to
  stdin. Read data from stdout and stderr, until end-of-file is reached.
  <strong>Wait for process to terminate.</strong></p>
</blockquote>
<p>Try the following code which was inspired by <a href="https://stackoverflow.com/a/24435988/2776376">https://stackoverflow.com/a/24435988/2776376</a>.
It uses <code>pipe_data_received</code> and then <code>len &gt; 16</code> is simply to prevent printing empty lines.</p>
<blockquote>
<p>SubprocessProtocol.pipe_data_received(fd, data)</p>
<p>Called when the child process writes data into its stdout or stderr pipe. fd is the integer file descriptor of the pipe. data is a non-empty bytes object containing the data.</p>
</blockquote>
<pre><code>import asyncio

class SubprocessProtocol(asyncio.SubprocessProtocol):
    def pipe_data_received(self, fd, data):
        if fd == 1:
            text = data.decode()
            if len(text.strip()) &gt; 16:
                print(text.strip())

    def process_exited(self):
        loop.stop()

loop = asyncio.get_event_loop()


ls = loop.run_until_complete(loop.subprocess_exec(
    SubprocessProtocol, 'watch', 'ls', '/proc'))
loop.run_forever()
</code></pre>
</div>
