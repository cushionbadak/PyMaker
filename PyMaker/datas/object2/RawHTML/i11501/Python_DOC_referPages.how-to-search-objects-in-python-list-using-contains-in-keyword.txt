<div class="post-text" itemprop="text">
<p>I would like to make a list of objects which I define, then use the <code>in</code> keyword (which calls <a href="https://docs.python.org/2/reference/datamodel.html#object.__contains__" rel="nofollow"><code>__contains__</code></a>) to determine if said object exists in the Python list. </p>
<p>Here is a minimal example with comments:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def __init__(self, name):
...             self.name = name
...     def __contains__(self, item):
...             return self.name == item
... 
&gt;&gt;&gt; list_of_objects = [Foo("bar"), Foo("baz"), Foo("quux")]
&gt;&gt;&gt; # I want to see if "bar" is in this list of Foo() objects
&gt;&gt;&gt; Foo("bar") in list_of_objects
False      # &lt;-- I want this to be True
</code></pre>
<p>Shouldn't the <code>in</code> keyword iterate over the Python list and use the <code>__contains__</code> method to determine existence of the object?</p>
<p>Extra kudos if calls to lists <code>index()</code> function are also operational.</p>
<h1>Update</h1>
<p>Thanks to @user2357112, Looks like the answer is implementing the equivalence operator <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a>. Adding the following bit to the <code>Foo</code> class in the previous example fixes the issues I was having.</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def __init__(self, name):
...             self.name = name
...     def __eq__(self, other):
...             return other.name == self.name
&gt;&gt;&gt; list_of_objects = [Foo("bar"), Foo("baz"), Foo("quux")]
&gt;&gt;&gt; Foo("bar") in list_of_objects
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__contains__</code> is the method that's called on the <em>container</em>, not on the elements. You need to implement <code>__eq__</code> instead:</p>
<pre><code>class Foo(object):
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        if isinstance(other, Foo):
            return other.name == self.name
        return self.name == other
</code></pre>
<p>If you are going to store <code>Foo</code> in other containers (like <code>set</code>), remember to implement <code>__hash__</code>.</p>
</div>
<span class="comment-copy">When you do <code>"bar" in list_of_objects</code>, then <code>list.__contains__</code> is called. It does not and absolutely should never call <code>Foo.__contains__</code> just because the list contains <code>Foo</code> instances and it is unclear why you think it should be the case.</span>
<span class="comment-copy">This is understandable, but the question remains, how can it be done? override the <code>list.__contains__</code>?, this is obviously a bad idea...</span>
<span class="comment-copy">While you're at it, you should also define <code>__ne__</code>, or <code>==</code> and <code>!=</code> will be inconsistent with each other. If the objects are mutable, then instead of defining <code>__hash__</code>, you should set <code>__hash__ = None</code> to make the objects unhashable. These things should be handled whether or not you plan to use <code>!=</code>, sets, or dicts with these objects, because getting them right now is much easier than trying to debug the crazy things that will happen later if you forget you didn't handle any of it.</span>
<span class="comment-copy">this is the correct answer, the <code>in</code> operator uses <code>__eq__</code> when iterating over a list. I added this to the code and it works fine. thank you.</span>
<span class="comment-copy">@user2357112 good points, thanks.</span>
<span class="comment-copy">@user2357112 actually, that's applicable to Python 2. In Python 3, <code>__ne__</code> will invert <code>__eq__</code>, and object with <code>__eq__</code>, but without <code>__hash__</code> is not hashable.</span>
<span class="comment-copy">@bereal: Yeah, those are good Python 3 features. There's nothing Python 3 specific in the question, though.</span>
