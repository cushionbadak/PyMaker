<div class="post-text" itemprop="text">
<p>I need some advise on how best (and to what extent) implement explicitly checking for invalid input in python. Coming from a C++ background with strong type setting, this always has been confusing for me.</p>
<p>So, for discussion let us assume that we have the following method signature:</p>
<pre><code>def m(start:float, up:float, down:float):
    pass
</code></pre>
<p>Now start should be greater than or equal to 0 while the other two should be greater than 0. I could do something like:</p>
<pre><code>def m(start:float, up:float=1, down:float=1):
    if start &lt;= 0.0:
        raise ValueError("Error")
    if up&lt; 0.0:
        raise ValueError("Error")
    if down&lt; 0.0:
        raise ValueError("Error")
</code></pre>
<p>I am guessing this will be fine <strong>as long as</strong> the input type is float or some numeric type which is comparable to float. But in python there is nothing stopping a user from calling the function as:</p>
<pre><code>m(start=[], up="Hello", down={})
</code></pre>
<p>In which case all these comparisons will be meaningless. What is the pythonic way to deal with this situation?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check that the arguments are floats with <code>type()</code>.<br/>
For example <code>if type(start) != float</code><br/>
Or you can use <code>isinstance()</code> function like that:</p>
<pre><code>if not isinstance(start, float):
    raise TypeError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several ways, the most common is probably: <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow"><code>EAFP</code></a> (easier to ask forgivness than permission):</p>
<pre><code>def m(start:float, up:float=1, down:float=1):
    try:
        if start &lt;= 0.0:
            raise ValueError
        if up &lt; 0.0:
            raise ValueError
        if down &lt; 0.0:
            raise ValueError
    except TypeError:
        # This is just to give a more meaningful error message.
        raise TypeError('Arguments must be numbers.')
</code></pre>
<p>this will silently fail for python 2 but in python 3 it will raise a TypeError when comparing a not-number to a number. In that sense it will make him aware that he has done something wrong.</p>
<p>The other option is type-checks and the concept of <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow"><code>LBYL</code></a> (look before you leap) also known as <em>defensive programming</em>:</p>
<pre><code>from numbers import Real # or Number if you want to allow compley-types too

def m(start, up=1, down=1):
    # Compare if each argument is a real (floating point) number:
    if not isinstance(start, Real) or not isinstance(up, Real) or not isinstance(down, Real) :
        raise TypeError("Arguments must be numbers.")
    ...
</code></pre>
<p>Most people (including myself) think EAFP with <code>try ... except ...</code> is more pythonic but if you feel more comfortable with <code>isinstance</code>-checks then these provide an alternative.</p>
</div>
<div class="post-text" itemprop="text">
<p>In answer to your question: <code>m(start=[], up="Hello", down={})</code> will crash your program (raise exceptions) as soon as it tries <code>if start &lt;= 0.0:</code>. The situation might be more problematic if you have <code>m('3', '4', '55.27')</code> because those strings <em>will</em> convert to float. </p>
<p>If you want to be defensive in a situation where anything arriving which is not a float or not numeric indicates a logic error in the calling code, then you can test at runtime. <code>assert</code> statements raise an AssertionError which is unlikely to be inappropriately caught. So:</p>
<pre><code>assert type(start)==float, "start is not a float"
assert type(up)  ==float or type(up)  ==int
assert type(down)==float or type(down)==int
</code></pre>
<p>These also have the advantage that they are very easy to comment out at a later date, and read (commented or not) somewhat like declarations in other languages if they immediately follow the <code>def</code> statement.</p>
<p>You can also check the values with assert:</p>
<pre><code>assert  start &gt;= 0
assert up &gt; 0 and down &gt; 0
</code></pre>
<p>or maybe it's better to raise <code>ValueError</code> because these are value errors:</p>
<pre><code>if start &lt; 0 or up &lt;= 0 or down &lt;= 0:
     raise ValueError("Bad arguments start={} up={} down={}".format(start,up,down) )
</code></pre>
<p>The main difference is that raising <code>ValueError</code> is intended to signal something which might sensibly be caught by the caller, whereas <code>assert</code> is intended to indicate that a logic error has been detected and that immediate program termination is probably best. (Or, propagation to a catch-all handler at the very top of, say, an interactive command parser. There is no hard dividing line.)</p>
</div>
<span class="comment-copy">To let the script puke, since the caller has violated the contract.</span>
<span class="comment-copy">Python typing is getting popular :) look at : <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">docs.python.org/3/library/typing.html</a>  It is new and changing with every python new rel. 3.4, 3.5, 3.5.1 ... So what's yours ?</span>
<span class="comment-copy">Python will raise a <code>TypeError</code>. If your user is a developer, they will read the docs at last, if not there is an horrible bug lying <i>elsewhere</i> in their code, and it's not your fault.</span>
<span class="comment-copy">p.s. your tests are switched, it's <code>start &lt; 0</code> and <code>up &lt;= 0</code></span>
