<div class="post-text" itemprop="text">
<p>I am working on migrating an existing python GAE (Google App Engine) standard environment app to the flexible environment. I read through the <a href="https://cloud.google.com/appengine/docs/flexible/python/migrating-an-existing-app" rel="nofollow">guide</a> and decided to try out the python-compact runtime, as it's always good to re-use as much code as possible.</p>
<p>In the standard environment app, we use background_thread.start_new_background_thread() to spawn a bunch of infinite-loop threads to work on some background work forever. However, I couldn't get start_new_background_thread working in the flexible environment, even for some really simple app. Like this sample app:
github.com/GoogleCloudPlatform/python-docs-samples/tree/master/appengine/background</p>
<p>I keep getting the following <a href="http://i.stack.imgur.com/JLC43.png" rel="nofollow">error</a> while running the app in the cloud (it works fine locally though).</p>
<p>I debugged into it by using the cloud debugger, but there was no any error message available at all while the exception was raised in the background_thread.py</p>
<p>Any idea how I can run a long-live background thread in the flexible environment with python-compact runtime? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>One of the differences between App Engine standard and App Engine flexible is that with Flex we're really just running a docker container.  I can think of 2 approaches to try out. </p>
<h1>1. Just use Python multiprocessing</h1>
<p>App Engine standard enforces a sandbox that mostly means no direct use of threads or processes.  With Flex, you <em>should</em> be able to just use the standard Python lib for starting a new sub process:</p>
<p><a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow">https://docs.python.org/3/library/subprocess.html</a></p>
<h1>2. Use supervisord and docker</h1>
<p>If that doesn't work, another approach you could take here is to customize the docker image you're using in Flex, and use supervisord to start multiple processes. First, generate the dockerfile by cd-ing into folder with your sources and running:</p>
<p><code>gcloud preview app gen-config --custom</code></p>
<p>This will create a Dockerfile that you can customize.  Now, you are going to want to start 2 processes - the process we were starting (I think for python-compat it's gunicorn) and your background process.  The easiest way to do that with docker is to use supervisord:</p>
<p><a href="https://docs.docker.com/engine/admin/using_supervisord/" rel="nofollow">https://docs.docker.com/engine/admin/using_supervisord/</a></p>
<p>After modifying your Dockerfile and adding a supervisord.conf, you can just deploy your app as you normally would with <code>gcloud preview app deploy</code>.  </p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>I wish the documentation said that <code>background_thread</code> was not a supported API.</p>
<p>Anyway, I've found some hacks to help with <em>some</em> thread incompatibilities. App Engine uses <code>os.environ</code> to read a lot of settings. The "real" threads in your application will have a bunch of environment variables set there. The background threads you start will have none. One hack I've used is to copy some of the environment variables. For example, I needed to copy set the <code>SERVER_SOFTWARE</code> variable in the background threads in order to get the App Engine cloud storage library to work. We use something like:</p>
<pre><code>_global_server_software = None
_SERVER_SOFTWARE = 'SERVER_SOFTWARE'

def environ_wrapper(function, args):
    if _global_server_software is not None:
        os.environ[_SERVER_SOFTWARE] = _global_server_software
    function(*args)

def start_thread_with_app_engine_environ(function, *args):
    # HACK: Required for the cloudstorage API on Flexible environment threads to work
    # App Engine relies on a lot of environment variables to work correctly. New threads get none
    # of those variables. loudstorage uses SERVER_SOFTWARE to determine if it is a test instance
    global _global_server_software
    if _global_server_software is None and os.environ.get(_SERVER_SOFTWARE) is not None:
        _global_server_software = os.environ[_SERVER_SOFTWARE]

    t = threading.Thread(target=environ_wrapper, args=(
        function, args))
    t.start()
</code></pre>
</div>
<span class="comment-copy">Thanks @justin! The main reason I wanted to try out python-compact was to write less code to migrate the existing GAE app to the new environment. I felt there's still some gap for the python-compact runtime. So I decided to just re-write it in a standard python runtime with gevent. Thanks for ur ideas!</span>
