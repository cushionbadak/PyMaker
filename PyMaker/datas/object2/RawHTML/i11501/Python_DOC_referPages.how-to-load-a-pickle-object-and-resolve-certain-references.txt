<div class="post-text" itemprop="text">
<p>Say we have an object we write to binary file using <code>pickle</code>. Let's say the object graph looks like this:</p>
<pre><code>foo1
 +---&gt;bar
 |     \---&gt;context
 +---&gt;baz
 |     +---&gt;context
 |     \---&gt;qux
 \---&gt;context
</code></pre>
<p>Now the <code>context</code> objects are large datastructures and all instances of qux are the same. Therefore we decided to leave these <code>contexxt</code> objects out of the pickle process with:</p>
<pre><code>def __getstate__(self):
    my_dict = dict(self.__dict__)
    my_dict['context'] = None  # We don't save the context
    return my_dict
</code></pre>
<p>for the classes to which <code>foo</code>, <code>bar</code> and <code>baz</code> belong (and in fact all other classes in our design).</p>
<p>When we <code>load()</code> the object back into memory, we want all <code>context</code> references to be set back to our given context. One can do this by walking over the object tree recursively, but we are wondering whether there is a more elegant solution in <code>pickle</code> that fills in the <code>context</code> values itself when loading the data back into memory?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the <code>.context</code> is of type <code>Context</code>, instead of setting <code>context</code> to <code>None</code>, you could adapt the code from the section <a href="https://docs.python.org/3/library/pickle.html#persistence-of-external-objects" rel="nofollow">Persistence of External Objects</a> in the <code>pickle</code> documentation:</p>
<pre><code>import pickle

class ContextAwarePickler(pickle.Pickler):
    def persistent_id(self, obj):
        # if this is a context, return the key
        if isinstance(obj, Context):
            return ("Context", context.key)

        # pickle as usual
        return None


class ContextAwareUnpickler(pickle.Unpickler):
    def recover_context(self, key_id):
        ...

    def persistent_load(self, pid):
        type_tag, key_id = pid
        if type_tag == "Context":
            return self.recover_context(key_id)
        else:
            raise pickle.UnpicklingError("unsupported persistent object")
</code></pre>
</div>
<span class="comment-copy">Are you looking for <a href="https://docs.python.org/3/library/pickle.html#object.__setstate__" rel="nofollow noreferrer"><code>__setstate__</code></a> or am I missing something?</span>
<span class="comment-copy">@IljaEveril√§: the problem is that <code>__setstate__</code> has no additional parameters such that we can set the context back. Nevertheless I think I've found an answer in <i>persistent pickling</i> (<a href="https://docs.python.org/3.2/library/pickle.html#pickle-persistent" rel="nofollow noreferrer">docs.python.org/3.2/library/pickle.html#pickle-persistent</a>).</span>
<span class="comment-copy">Nice, did not know of that (reference to outside object support). Your own finding seems like the way to go.</span>
<span class="comment-copy">Thank you. A few minutes after asking the question, I found the example. Nevertheless, the modified code makes it easier to understand. +1.</span>
