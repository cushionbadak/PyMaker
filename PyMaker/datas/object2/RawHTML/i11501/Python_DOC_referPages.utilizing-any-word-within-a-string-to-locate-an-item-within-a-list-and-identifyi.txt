<div class="post-text" itemprop="text">
<p>Problem: utilizing any word within a string to locate an item within a list and identifying item or return an index.</p>
<p>Hello, I have been searching this site and other sites to find a solution for my problem. The solutions that I have found are successful in determining if the list has a item in the string,</p>
<p>Example:</p>
<pre><code>any(word in str1 for word in List)
</code></pre>
<p>But this only returns true or false, and with the command,</p>
<pre><code>print word
</code></pre>
<p>returns an error </p>
<p>I need a solution that can locate the list item and either print the item, or give the index within the list. </p>
<p>The project I am using this for as an AI that has an ability to preform math equation. For this it needs to be able to locate operators that are not only the standard " +,-,*,/ " but also the word formats. For example, " plus, minus, etc." When located, the program can simply replace items in the string with proper standard operators that eval() can handle.</p>
<p>Sample code reapplied from project:</p>
<pre><code>from __future__ import division
import re
from math import *
Listopp = ["+","-", "*","/"]
Listadd = ["add","plus"]
Listsub = ["subtract","minus"]
Listmult = ["times","multiply","x"]
Listdivide = [ "divide","over"]
Listmath =Listopp + Listadd + Listsub + Listmult + Listdivide

try:
    str1 = raw_input("what is your math problem?")

    if (any(word in str1 for word in Listmath) and re.findall(r"[-+]?\d*\.\d+|\d+",str1) != []):


# here is where the solution need to be placed

        opp = Listmath.index(any(word in str1))

         # needs to be identified or indexed 


#Replaced with standard operators 
        if (opp in Listdivide):
            str1 = str1.replace( opp ,"/")

        if (opp in Listmult):
            str1 = str1.replace( opp ,"*")

        if (opp in Listsub):
            str1 = str1.replace( opp ,"-")

        if (opp in Listadd):
            str1 = str1.replace( opp ,"+")

        if (opp in Listopp):
            pass

        math = eval(str1)
        if not float(math).is_integer():
            print "rounded"
            result = round(math, 3)
        else:
            print "real"
            result = math
        print result
    else:
        print "No suitable math problems found."
except Exception as e:
    print e
</code></pre>
<p>Any help or advice on this code would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to ignore the part about your AI project, as it isn't a <a href="https://stackoverflow.com/help/mcve">MCVE</a>. I think the first part of your question is, though, so I'll show you how to find the item and index where items in a list occur that satisfy the condition you give (<code>word in str1</code>) using <code>numpy.where</code>:</p>
<pre><code>import numpy as np
List = ["add", "bolt", "dead", "bolter", "test"]
str1 = "bolter"
items = [word in str1 for word in List]
print items
indices = np.where(items)[0]
print indices
</code></pre>
<p>This snippet will output:</p>
<pre><code>[False, True, False, True, False]
[1, 3]
</code></pre>
<p>A word of advice: Don't use a capital letter for a variable like <code>List</code>. I kept my answer like this because I wanted you to be able to easily follow my solution. Typically capital letters denote a class name, so capitalizing variables makes your code harder for other Python programmers to read and comprehend. This is just a stylistic norm in the Python community.</p>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow"><code>next()</code></a>.  The first argument is an iterator and the second (optional) argument is the default value if the iterator is already exhausted.  The following is a Python session showing different uses of <code>next()</code>:</p>
<pre><code>&gt;&gt;&gt; my_list = [4, 6, 1, 4, 1]
&gt;&gt;&gt; any(x &gt; 4 for x in my_list)
True
&gt;&gt;&gt; next(x for x in my_list if x &gt; 4)
6
&gt;&gt;&gt; next(i for i, x in enumerate(my_list) if x &gt; 4)
1
&gt;&gt;&gt; next(i for i, x in enumerate(my_list) if x &gt; 6)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt; default = 4
&gt;&gt;&gt; next((i for i, x in enumerate(my_list) if x &gt; 6), default)
4
&gt;&gt;&gt; next((i for i, x in enumerate(my_list) if x &gt; 4), default)
1
</code></pre>
</div>
<span class="comment-copy">I'm pretty sure you're "doing it wrong". What you're describing is an  expression parser, and it is significantly more complex than search-and-replace.  E.g. using pyparsing: <a href="https://pyparsing.wikispaces.com/file/view/fourFn.py" rel="nofollow noreferrer">pyparsing.wikispaces.com/file/view/fourFn.py</a></span>
