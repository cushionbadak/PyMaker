<div class="post-text" itemprop="text">
<p>I've written the following code for computing the in-center of a triangle. This code is supposed to be for code-golf. Any help would be appreciated.</p>
<pre class="lang-python prettyprint-override"><code>d = lambda x,y: ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5
e = lambda w,x,y,z: float(d(y,z)*x[w]+d(z,x)*y[w]+d(x,y)*z[w])/(d(x,y)+d(y,z)+d(z,x))
a,b,c=eval(input())
px,py=e(0,a,b,c),e(1,a,b,c)
print('[%f,%f]' % (px,py))
</code></pre>
<p>Input:</p>
<pre class="lang-python prettyprint-override"><code>([1,2],[2,2],[1,2])
</code></pre>
<p>Expected Output:</p>
<pre class="lang-python prettyprint-override"><code>[1.2928932188134525, 1.7071067811865475]
</code></pre>
<p>Actual Output:</p>
<pre class="lang-python prettyprint-override"><code>[1.000000,2.000000]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python is doing the maths correctly. Either your logic is wrong or your input is wrong or your expected output is wrong. Given your input, the only possible output for <code>d</code> is <code>0</code> or <code>1</code> (the Cartesian distance between two points). Doing this, we can simply <code>e</code> to see what it might output for the first function call.</p>
<p>Given:</p>
<pre><code>w = 0
x = [1, 2]
y = [2, 2]
z = [1, 2]
result = float(d(y,z)*x[w]+d(z,x)*y[w]+d(x,y)*z[w])/(d(x,y)+d(y,z)+d(z,x))
</code></pre>
<p>becomes:</p>
<pre><code>result = float(d([2, 2],[1, 2])*[1, 2][0]+d([1, 2],[1, 2])*[2, 2][0]+d([1, 2],[2, 2])*[1, 2][0])/(d([1, 2],[2, 2])+d([2, 2],[1, 2])+d([1, 2],[1, 2]))
</code></pre>
<p>becomes:</p>
<pre><code>result = float((1.*1 + 0.*2 + 1.*1) / (1. + 1. + 0))
</code></pre>
<p>becomes:</p>
<pre><code>result = float(2. / 2.)
result = float(1.)
result = 1. # not 1.2928932188134525
</code></pre>
<p>After that, it's up to you to figure out what's wrong as you haven't specified why the expected output is the expected output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure that [1.000000,2.000000] isn't a correct answer? This code:</p>
<pre><code>d = lambda x,y: round(((x[0]-y[0])**2.0+(x[1]-y[1])**2.0)**0.5, 12)
e = lambda w,x,y,z: float(round((d(y,z)*x[w]+d(z,x)*y[w]+d(x,y)*z[w])/(d(x,y)+d(y,z)+d(z,x)),12))
a,b,c= input()
px,py=e(0,a,b,c),e(1,a,b,c)
print px, py
</code></pre>
<p>return floating numbers, for example:</p>
<p><strong>in:</strong> <code>([1.25325,2.34346], [2.25325,4.34346], [22.25325,22.34346])</code></p>
<p><strong>out:</strong> <code>2.559632791 4.11015248488</code></p>
</div>
<span class="comment-copy">If you must use eval (you shouldn't), use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a>.</span>
<span class="comment-copy">See this output from the interpreter:       &gt;&gt;&gt; d = lambda x,y: ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5      &gt;&gt;&gt; e = lambda w,x,y,z: float(d(y,z)*x[w]+d(z,x)*y[w]+d(x,y)*z[w])/(d(x,y)+d(y,z)+d(z,x))     &gt;&gt;&gt; e(0,[1,1],[2,2],[1,2])     Output: 1.2928932188134525     &gt;&gt;&gt; e(1,[1,1],[2,2],[1,2])     Output: 1.7071067811865475</span>
<span class="comment-copy">You've used a different input to the one specified in the question.</span>
<span class="comment-copy">Hahahah. You are right. So, foolish of me.</span>
