<div class="post-text" itemprop="text">
<p>I’d like to understand how python converts bytes to floats, in detail.<br/>
Let’s create a binary file containing just one float 23.0:</p>
<pre><code>~&gt; echo 23 &gt; 23.a  
~&gt; a2b &lt; 23.a n1=1 &gt; 23.b
</code></pre>
<p>Let’s now write a python3 code 23.py:  </p>
<pre><code>~&gt; cat 23.py  
import struct
f='23.b'                                            
fd=open(f,'rb')                                      # Open the file
value_bytes=fd.read()                                # Read file, 4 bytes in total
                                                     # Output:
print("Bytes =",value_bytes)                         # Bytes = b'\x00\x00\xb8A'
print("Float =",struct.unpack("&lt;f",value_bytes))     # Float = (23.0,)
</code></pre>
<p>Execute the code:  </p>
<pre><code>~&gt; python3.5 23.py  
Bytes = b'\x00\x00\xb8A'  
Float = (23.0,)
</code></pre>
<p>So, I am wondering how python converts the bytes '\x00\x00\xb8A' into float 23.0? This has something to do with the DEC-BIN-HEX-ASCII representation, but I have already broken my brain trying to understand this.  </p>
<pre><code>DEC = 23  
BIN = 0000 0000 0001 0111  
HEX =    0    0    1    7
</code></pre>
<p>How do we get '\x00\x00\xb8A' from it? Or vice-versa, how '\x00\x00\xb8A' transforms into 23.0?<br/>
Could anyone explain me step by step? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is clearly <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow">documented in the format table</a>:</p>
<blockquote>
<p>For the <code>'f'</code> and <code>'d'</code> conversion codes, the packed representation uses the IEEE 754 binary32 (for <code>'f'</code>) or binary64 (for <code>'d'</code>) format, regardless of the floating-point format used by the platform.</p>
</blockquote>
<p>So to understand that format, reference the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="nofollow">IEEE floating point standard</a>; you used the <code>f</code> code, so look for the <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format" rel="nofollow">binary32, or <em>single precision</em> format</a>.</p>
<p>This format consists of 32 bits, divided over:</p>
<ul>
<li>Sign bit: 1 bit</li>
<li>Exponent width: 8 bits</li>
<li>Significand precision: 24 bits (23 explicitly stored)</li>
</ul>
<p>Looking at your binary data as bits, (which you treat as little endian, so I'm reversing these to match the Wikipedia big-endian ordering):</p>
<pre><code>&gt;&gt;&gt; ('{:08b}' * 4).format(*b'\x00\x00\xb8A'[::-1])
'01000001101110000000000000000000'
</code></pre>
<p>we see that the sign is 0, the exponent width is 131 (in 2's complement, so minus 127 makes 4), and the significand precision or mantissa is 1.4375 (1 + 1/4 + 1/8 + 1/16, each binary fraction is an enabled bit).</p>
<pre><code>&gt;&gt;&gt; ('{:08b}' * 4).format(*b'\x00\x00\xb8A'[::-1])[:1]  # sign
'0'
&gt;&gt;&gt; ('{:08b}' * 4).format(*b'\x00\x00\xb8A'[::-1])[1:9]  # exponent, signed
'10000011'
&gt;&gt;&gt; int(('{:08b}' * 4).format(*b'\x00\x00\xb8A'[::-1])[1:9], 2) - 127  # exponent, signed
4
&gt;&gt;&gt; ('{:08b}' * 4).format(*b'\x00\x00\xb8A'[::-1])[9:]  # mantissa
'01110000000000000000000'
&gt;&gt;&gt; # That's the 1/4 bit plus the 1/8th bit plus the 1/16th bits all enabled.
...
&gt;&gt;&gt; 1 + 1/4 + 1/8 + 1/16
1.4375
</code></pre>
<p>Together these form the actual floating point value:</p>
<pre><code>&gt;&gt;&gt; 1 * 2 ** 4 * 1.4375 (sign, positive, times 2 to the power exponent, times fractions)
23.0
</code></pre>
<hr/>
<p>To go the other way, express the whole integer number and the value after the decimal point in binary; you may have to <em>approximate</em> the non-integer portion as binary fractions can't express all possible real numbers. 23.0 has no non-integer component, so that is easy here, we only have to convert the integer component to binary:</p>
<pre><code>&gt;&gt;&gt; format(23, 'b')
'10111'
</code></pre>
<p>So the binary representation for the real number is <code>10111.0</code>. You then shift the decimal point up or down to get <code>1</code> and a fraction; here you need to shift the decimal point up 4 spots to <code>1.0111</code>. This gives you the exponent (4), and the significant (0111 plus another 19 zeros for the unused fractions). The value is positive, so you encode the sign as <code>0</code>, the exponent as a signed value (add 127 == 131, encode 131 to binary == <code>10000011</code>), and add the significant:</p>
<pre><code>0 10000011 01110000000000000000000
</code></pre>
<p>Chopping that into 4 groups of 8 bits (4 bytes) gives you <code>0x41 0xB8 0x00 0x00</code>. Python's <code>repr()</code> output for a byte gives you printable ASCII characters for bytes where possible, and <code>0x41</code> is the letter <code>A</code> in the ASCII table:</p>
<pre><code>&gt;&gt;&gt; bytes([0b01000001, 0b10111000, 0b00000000, 0b00000000])
b'A\xb8\x00\x00'
</code></pre>
<p>Reverse those bytes for a little-endian representation:</p>
<pre><code>&gt;&gt;&gt; bytes([0b01000001, 0b10111000, 0b00000000, 0b00000000])[::-1]
b'\x00\x00\xb8A'
</code></pre>
<hr/>
<p>You can visualise how the IEEE binary32 format works with <a href="http://www.h-schmidt.net/FloatConverter/IEEE754.html" rel="nofollow">this online converter</a>.</p>
</div>
<span class="comment-copy">What does the <code>a2b</code> command do? None of my Debian, CentOS, or OS X systems have that command.</span>
<span class="comment-copy">@Martijn You are right, I've overlooked that. That's part of "Seismic Unix". Reads ascii floats line by line and converts them to binary. Little endian, I believe, in this case.</span>
<span class="comment-copy">Right, so that's <a href="http://www.cwp.mines.edu/sututor/node33.html" rel="nofollow noreferrer">this tool</a> then?</span>
<span class="comment-copy">OK, thanks. It is clear now how to convert the 32binary into IEEE float. But I am still missing, how we get '01000001101110000000000000000000' from b'\x00\x00\xb8A', and b'\x00\x00\xb8A' from 23.</span>
<span class="comment-copy">@Michael: <code>b'\x00\x00\xb8A</code> represents 4 bytes, values 0, 0, 184 and 65 in decimal, but printed as ASCII where possible (ASCII 65 is <code>'A'</code>). Reversing those bytes first (little endian to big endian) and converting those to binary representations give you 01000001 10111000 00000000 00000000.</span>
<span class="comment-copy">@Michael: as for going from 23.0 to the binary representation, see the <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format#Converting_from_decimal_representation_to_binary32_format" rel="nofollow noreferrer"><i>decimal representation to binary32 format</i> section</a>. <code>23.0</code> is <code>10111.0</code> in binary (with binary fractions), but that value is 'normalised' by shifting 4 steps to the right to <code>'1.0111'</code>. That way you only need to encode <code>4</code> as the exponent and <code>0111</code> as the mantissa.</span>
<span class="comment-copy">Ah, that's it. The ASCII representation combined with byte reversal was not quite obvious, but I finally got it, thanks to you!</span>
