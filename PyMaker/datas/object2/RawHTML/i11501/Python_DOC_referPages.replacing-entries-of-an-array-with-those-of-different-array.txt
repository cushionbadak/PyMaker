<div class="post-text" itemprop="text">
<p>Consider a <em>numpy</em> 2D array of integers, where some entries are 0 (array1). Consider a different 2D array (array2) in which the first column has the same non zero values of array1 and another column, say index 2, has different numeric values (floats).</p>
<p>How do you create a new array3 by replacing in array1 each non-zero entry by the correspondent value of column 2 of array2? How do you do it super clean?</p>
<p><strong>Example:</strong></p>
<pre><code>&gt;&gt;&gt; array1
array([[0, 27, 43, 10],
       [0, 80, 15,  2],
       [0,  3,  6,  9]])

&gt;&gt;&gt; array2
array([[ 10.,  4., 88.],
       [  2.,  2., 95.],
       [  9.,  2., 65.],
       [ 43.,  1., 62.],
       [ 15.,  5., 64.],
       [  6.,  6., 67.],
       [ 27.,  5., 62.],
       [ 80.,  8., 73.],
       [  3.,  9., 59.]])

&gt;&gt;&gt; array3
array([[0., 62., 62., 88.],
       [0., 73., 64., 95.],
       [0., 59., 67., 65.]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use boolean indexing together with advanced numpy array indexing:</p>
<pre><code>array3 = array1.astype(float) # this copies the array by default.
array3[array1 != 0] = array2[array1[array1 != 0]-1, 2]
</code></pre>
<p>the result is:</p>
<pre><code>array([[ 0, 62., 62., 88.],
       [ 0, 73., 64., 95.],
       [ 0, 59., 67., 65.]])
</code></pre>
<h1>Explanation</h1>
<p>You first create a boolean array which indicates where there are non-zero entries:</p>
<pre><code>&gt;&gt;&gt; non_zero_mask = array1 != 0
array([[False,  True,  True,  True],
       [False,  True,  True,  True],
       [False,  True,  True,  True]], dtype=bool)
</code></pre>
<p>this will be used to find the elements that should be replaced.</p>
<p>Then you need to find the values of these elements:</p>
<pre><code>&gt;&gt;&gt; non_zero_values = array1[non_zero_mask]
array([7, 4, 1, 8, 5, 2, 9, 6, 3])
</code></pre>
<p>Since your <code>array2</code> is ordered and starts with value 1 we need to subtract one to find the appropriate row for the replacement value. If your <code>array2</code> isn't sorted you might need to sort it or do another indexing in between:</p>
<pre><code>&gt;&gt;&gt; replacement_rows = array2[non_zero_values-1]
array([[  7.,   7.,  62.],
       [  4.,   4.,  62.],
       [  1.,   1.,  88.],
       [  8.,   8.,  73.],
       [  5.,   5.,  64.],
       [  2.,   2.,  95.],
       [  9.,   9.,  59.],
       [  6.,   6.,  67.],
       [  3.,   3.,  65.]])

&gt;&gt;&gt; replacement_values = array2[non_zero_values-1, 2] # third element of that row!
array([ 62.,  62.,  88.,  73.,  64.,  95.,  59.,  67.,  65.])
</code></pre>
<p>and then just assign these values to the original or new array:</p>
<pre><code>array3[non_zero_mask] = replacement_values
</code></pre>
<p>This approach relies on the ordering of <code>array2</code> so it will break if there are more complicated conditions. But that would either requiring finding that relation between value and index and inserting it instead of the simple <code>-1</code> I did or doing another intermediate <code>np.where</code>/boolean indexing.</p>
<h1>Extended</h1>
<p>In case you don't have a sorted <code>array2</code> and you can't sort it you could do:</p>
<pre><code>&gt;&gt;&gt; array3 = array1.astype(float)
&gt;&gt;&gt; array3[array1 != 0] = array2[np.where(array2[:, 0][None, :] == array1[array1 != 0][:, None])[1], 2]
&gt;&gt;&gt; array3
array([[  0.,  62.,  62.,  88.],
       [  0.,  73.,  64.,  95.],
       [  0.,  59.,  67.,  65.]])
</code></pre>
<p>since this works with broadcasting the arrays against each other you'll create an array with size <code>array1.size * array1.size</code>. So this might not be very memore-efficient but still completly vectorized.</p>
<h1>Numba (if you want speed)</h1>
<p><a class="post-tag" href="/questions/tagged/numba" rel="tag" title="show questions tagged 'numba'">numba</a> is great if you want to speed up things that would be slow because there is no native numpy or scipy version. If you have anaconda or conda it is already installed so it might be a viable option:</p>
<pre><code>import numba as nb
import numpy as np

@nb.njit
def nb_replace_values(array, old_new_array):
    res = np.zeros(array.shape, dtype=np.float64)

    rows = array.shape[0]
    columns = array.shape[1]
    rows_replace_array = old_new_array.shape[0]

    for row in range(rows):
        for column in range(columns):
            val = array[row, column]
            # only replace values that are not zero
            if val != 0:
                # Find the value to replace the element with
                for ind_replace in range(rows_replace_array):
                    if old_new_array[ind_replace, 0] == val:
                        # Match found. Replace and break the innermost loop
                        res[row, column] = old_new_array[ind_replace, 2]
                        break

    return res

nb_replace_values(array1, array2)
array([[  0.,  62.,  62.,  88.],
       [  0.,  73.,  64.,  95.],
       [  0.,  59.,  67.,  65.]])
</code></pre>
<p>Especially for large arrays this will clearly be the fastest and memory-efficient solution since no temporary arrays are created. The first call will be a lot slower because the function needs to compile on the fly.</p>
<h1>Timings:</h1>
<pre><code>%timeit nb_replace_values(array1, array2)
</code></pre>
<blockquote>
<p>100000 loops, best of 3: 6.23 µs per loop</p>
</blockquote>
<pre><code>%%timeit
array3 = array1.astype(float)
array3[array1 != 0] = array2[np.where(array2[:, 0][None, :] == array1[array1 != 0][:, None])[1], 2]
</code></pre>
<blockquote>
<p>10000 loops, best of 3: 74.8 µs per loop</p>
</blockquote>
<pre><code># Solution provided by @PDRX
%%timeit 
array3 = array1.astype(float)
for i in array2[:,0]:
    i_arr1,j_arr1 = np.where(array1 == i)
    i_arr2 = np.where(array2[:,0] == i)
    array3[i_arr1,j_arr1] = array2[i_arr2,2]
</code></pre>
<blockquote>
<p>1000 loops, best of 3: 689 µs per loop</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>
I'm not sure I understood your requirements but let's try with <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>:</p>
<pre class="lang-py prettyprint-override"><code>array3 = [[array2[subitem1 - 1][2] if subitem1 != 0 else 0 for subitem1 in subarray1] for subarray1 in array1]
</code></pre>
<p>But it's hard to read, I prefer it tabulated:</p>
<pre class="lang-py prettyprint-override"><code>array3 = [
    [
        array2[subitem1 - 1][2] if subitem1 != 0 else 0
        for subitem1 in subarray1
    ]
    for subarray1 in array1
]
</code></pre>
</div>
<span class="comment-copy">Well, in the example I gave array2 is indeed sorted, but in general it is supposed to be any array, not necessarily sorted, with random numbers that maybe cannot be sorted in a uniform sequence, as long as these numbers do not repeat - think of that column as an ID. Can you improve your answer based on that please? I'll update my example.</span>
<span class="comment-copy">@Bella That's much harder and I haven't put much thought into it. But see the last part of the answer. This is very inefficient and I would probably rather recommend using <code>pandas</code> or a customized <code>numba</code> function for these cases.</span>
<span class="comment-copy">Oh I hadn't seen your final edit before! When I saw the other answer I understood it right away which was great. Yours is a bit more difficult to get, but you are right, I tested both solutions for speed and yours is faster, although it is only an order of magnitude faster for larger arrays. Now I'm kind of undecided which answer to accept since I'll probably keep both. :/ I didn't get what you mentioned about the array size though - from what I can see array3 as the same size as array1 and in both solutions getsizeof gives me the same size.</span>
<span class="comment-copy">@Bella Choose the answer that works best for you, I won't get mad if you accept another answer. But: Since I'm quite a <code>numba</code> fanatic I included such a function too. It's much faster than my original and the other solution but numba is not light-weight but at least it's very straight-forward to read it. :-) And it probably scales much better than either.</span>
<span class="comment-copy">Thanks. My computer will lift off now.</span>
