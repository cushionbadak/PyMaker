<div class="post-text" itemprop="text">
<p>So I have this set of code, testing decorator <code>base_permissions_check</code>:</p>
<pre><code>def authenticated(self,*arg,**kwargs):
    function_call = inspect.stack()[1][4][0].strip()
    matched = re.match('^self\.', function_call)
    if not matched:
        raise Exception("function is private")

    return self.user.is_authenticated()

def base_permissions_check(func):
    def wrap(self,**kwargs):

        if not self.authenticated(kwargs):
            return self.permissions
            # func(kwargs)
        return func(kwargs)
    return wrap

#public
@base_permissions_check
def has_video_permission(self,**kwargs):
</code></pre>
<p>The error says that <code>authenticated() takes 1 positional argument but 2 were given</code> when I call has_video_permission. I really don't know what's wrong? while I pass only one kwarg into it</p>
</div>
<div class="post-text" itemprop="text">
<p>The wrapped <code>func()</code> function is not bound to the instance as a method, so you need to pass in <code>self</code> explicitly. You also need to apply the <code>kwargs</code> dictionary as separate keyword arguments using the <code>**kwargs</code> call syntax:</p>
<pre><code>return func(self, **kwargs)
</code></pre>
<p>Your <code>authenticated</code> method is not actually <em>using</em> the <code>kwargs</code> dictionary you pass in, so you could just call <code>self.authenticated()</code>, but if you need to have access to those keyword arguments, you probably want to use the <code>**kwargs</code> call syntax there too:</p>
<pre><code>if not self.authenticated(**kwargs):
</code></pre>
<p>Since you see the error when you <em>call</em> the decorated function, you are probably passing in a <em>positional</em> argument, but your wrapper only accepts <em>keyword arguments</em> (beyond <code>self</code>). Perhaps you want to add <code>*args</code> to handle those positional arguments:</p>
<pre><code>def base_permissions_check(func):
    def wrap(self, *args, **kwargs):

        if not self.authenticated(**kwargs):
            return self.permissions
            # func(kwargs)
        return func(self, *args, **kwargs)
    return wrap

#public
@base_permissions_check
def has_video_permission(self, *args, **kwargs):
    # ...
</code></pre>
</div>
<span class="comment-copy">The first argument is <code>self</code>. <code>kwargs</code> is the second.</span>
<span class="comment-copy">but authenticated accept self and **kwargs, what's wrong?</span>
<span class="comment-copy">You might be looking for <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">argument unpacking</a>.</span>
<span class="comment-copy">still the same error</span>
<span class="comment-copy">Please add the <b>full traceback</b> of the error to your question so we don't have to keep guessing as to what exactly is complaining here.</span>
<span class="comment-copy">I updated but it's still the same error</span>
<span class="comment-copy">Then please provide the <b>full traceback</b> of the error in your question. You have more problems than just the one I pointed out in that case.</span>
<span class="comment-copy">Just realize I need to restart the server to see the changes get affected. That's why it keeps prompting the old error.</span>
<span class="comment-copy">are we able to make decorator within the instance? means to use self</span>
<span class="comment-copy">@LeDuyKhanh: the decorator applies to the <i>function</i>, and the result is added to the class object once the class body is complete. Function objects then act as <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow noreferrer"><i>descriptors</i></a>, which means they produce a method, bound to the instance, when looked up on an instance. So your <code>wrap</code> function is bound as a method and has <code>self</code> passed in, but the original <code>func</code> function is not, so you have to pass in <code>self</code> explicitly.</span>
