<div class="post-text" itemprop="text">
<p>This <a href="https://stackoverflow.com/q/37052139/6292850">question</a> and my <a href="https://stackoverflow.com/a/37055026/6292850">answer</a> got me thinking about this peculiar difference between Python 2.7 and Python 3.4. Take the simple example code:</p>
<pre><code>import timeit
import dis

c = 1000000
r = range(c)
def slow():
    for pos in range(c):
        r[pos:pos+3]

dis.dis(slow)

time = timeit.Timer(lambda: slow()).timeit(number=1)
print('%3.3f' % time)
</code></pre>
<p>In Python 2.7, I consistently get <code>0.165~</code> and for Python 3.4 I consistently get <code>0.554~</code>. The only significant difference between the disassemblies is that Python 2.7 emits the <a href="https://docs.python.org/2/library/dis.html#opcode-SLICE+3" rel="nofollow noreferrer"><code>SLICE+3</code></a> byte code while Python 3.4 emits <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_SLICE" rel="nofollow noreferrer"><code>BUILD_SLICE</code></a> followed by <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_SLICE" rel="nofollow noreferrer"><code>BINARY_SUBSCR</code></a>. Note that I've eliminated the candidates for potential slowdown from the other question, namely strings and the fact that <code>xrange</code> doesn't exist in Python 3.4 (which is supposed to be similar to the latter's <code>range</code> class anyways).</p>
<p>Using <code>itertools'</code> <code>islice</code> yields nearly identical timings between the two, so I highly suspect that it's the slicing that's the cause of the difference here.</p>
<p>Why is this happening and is there a link to an authoritative source documenting change in behavior?</p>
<p>EDIT: In response to the answer, I have wrapped the <code>range</code> objects in <code>list</code>, which did give a noticeable speedup. However as I increased the number of iterations in <code>timeit</code> I noticed that the timing differences became larger and larger. As a sanity check, I replaced the slicing with <code>None</code> to see what would happen.</p>
<p>500 iterations in <code>timeit</code>.</p>
<pre><code>c = 1000000
r = list(range(c))
def slow():
    for pos in r:
        None
</code></pre>
<p>yields <code>10.688</code> and <code>9.915</code> respectively. Replacing the for loop with <code>for pos in islice(r, 0, c, 3)</code> yields <code>7.626</code> and <code>6.270</code> respectively. Replacing <code>None</code> with <code>r[pos]</code> yielded <code>20~</code> and <code>28~</code> respectively. <code>r[pos:pos+3]</code> yields <code>67.531</code> and <code>106.784</code> respectively.</p>
<p>As you can see, the timing differences are huge. Again, I'm still convinced the issue is not directly related to <code>range</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>On Python 2.7, you're iterating over a list and slicing a list. On Python 3.4, you're iterating over a <code>range</code> and <strong>slicing a <code>range</code></strong>.</p>
<p>When I run a test with a list on both Python versions:</p>
<pre><code>from __future__ import print_function
import timeit
print(timeit.timeit('x[5:8]', setup='x = list(range(10))'))
</code></pre>
<p>I get <a href="http://ideone.com/S8Th1n" rel="nofollow">0.243554830551 seconds on Python 2.7</a> and <a href="http://ideone.com/Pf9Nst" rel="nofollow">0.29082867689430714 seconds on Python 3.4</a>, a much smaller difference.</p>
<hr/>
<p>The performance difference you see after eliminating the <code>range</code> object is much smaller. It comes primarily from two factors: addition is a bit slower on Python 3, and Python 3 needs to go through <code>__getitem__</code> with a slice object for slicing, while Python 2 has <code>__getslice__</code>.</p>
<p>I wasn't able to replicate the timing difference you saw with <code>r[pos]</code>; you may have had some confounding factor in that test.</p>
</div>
<span class="comment-copy">Were you using <code>range</code> or <code>xrange</code> in Python 2?</span>
<span class="comment-copy">Try again, with <code>r = list(range(c))</code>.</span>
<span class="comment-copy">Python 3 <code>range</code> and Python 2 <code>xrange</code> objects are not similar in this context.  Python 3 <code>range</code> objects support slicing, Python 2 <code>xrange</code> objects do not support slicing.</span>
<span class="comment-copy">@cdarke In this case it's irrelevant since neither the linked question nor I used xrange. I only mentioned it incase somebody were to bring it up.</span>
<span class="comment-copy">Increasing the number of iterations starts to show bigger and bigger gaps in the timing differences. <code>1.352</code> and <code>2.171</code> respectively for 10 iterations. I'm not sure what I'm missing here.</span>
<span class="comment-copy">@user6292850: How are you running that test?</span>
<span class="comment-copy">I'm merely increasing the number parameter in <code>timeit</code>, and running <code>python test.py</code> followed by <code>python3 test.py</code>.</span>
<span class="comment-copy">@user6292850: I ran some tests and isolated the primary contributors to the remaining performance difference. My tests with <code>r[pos]</code> only showed a 10% runtime difference, unlike your 40% runtime difference, though.</span>
<span class="comment-copy">@user6292850 which <code>test.py</code> are you testing? Yours in the question or the one in this answer? Let's test the same thing. I suggest using this format: <code>python -m timeit -s "r = list(range(1000))" "for pos in range(1000): r[pos:pos+3]"</code>. Why would you not use the default number of iterations of 1000000?</span>
