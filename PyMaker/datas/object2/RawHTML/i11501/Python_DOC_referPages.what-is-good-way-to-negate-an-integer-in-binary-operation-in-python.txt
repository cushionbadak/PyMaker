<div class="post-text" itemprop="text">
<p>Based on what I've read about <a href="http://www.doc.ic.ac.uk/~eedwards/compsys/arithmetic/" rel="nofollow">the binary representation of integers</a>, the first bit is for sign (positive or negative).</p>
<p>Let's say we have an integer <code>x = 5</code> and <code>sys.getsizeof(x)</code> returns <code>28</code> (that is binary representation in 28 bit).</p>
<p>For now I am trying to flip the first bit to <code>1</code> by using <code>x|=(1&lt;&lt;27)</code>but it returns <code>134217733</code>.</p>
<p>I was just wondering whether it needs to be some negative number? (not -5)</p>
<p>Is there anything wrong with what I am doing?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't switch a Python <code>int</code> from positive to negative the way you're trying to, by just flipping a bit in its representation. You're assuming it's stored in a fixed-length two's complement representation. But integers in Python 3 are not fixed-length bit strings, and they are not stored in a two's complement representation. Instead, they are stored as variable-length strings of 30- or 15-bit "digits", with the sign stored separately (like a <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation" rel="nofollow">signed-magnitude representation</a>). So the "lowest-level" way to negate a Python <code>int</code> is not with bit operations, but with the unary <code>-</code> operator, which will switch its sign. (See the end of this answer for details from the Python 3 source.)</p>
<p>(I should also mention that <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow"><code>sys.getsizeof()</code></a> does <em>not</em> tell you the number of bits in your <code>int</code>. It gives you the number of bytes of memory that the integer object is using. This is also not the number of bytes of the actual stored number; most of those bytes are for other things.)</p>
<hr/>
<p>You can still play around with two's complement representations in Python, by emulating a fixed-length bit string using a positive <code>int</code>. First, choose the length you want, for example 6 bits. (You could just as easily choose larger numbers like 28 or 594.) We can define some helpful constants and functions:</p>
<pre><code>BIT_LEN = 6
NUM_INTS = 1 &lt;&lt; BIT_LEN         # 0b1000000
BIT_MASK = NUM_INTS - 1         #  0b111111
HIGH_BIT = 1 &lt;&lt; (BIT_LEN - 1)   #  0b100000

def to2c(num):
    """Returns the two's complement representation for a signed integer."""
    return num &amp; BIT_MASK

def from2c(bits):
    """Returns the signed integer for a two's complement representation."""
    bits &amp;= BIT_MASK
    if bits &amp; HIGH_BIT:
        return bits - NUM_INTS
</code></pre>
<p>Now we can do something like you were trying to:</p>
<pre><code>&gt;&gt;&gt; x = to2c(2)
&gt;&gt;&gt; x |= 1 &lt;&lt; 5
&gt;&gt;&gt; bin(x)
'0b100010'
&gt;&gt;&gt; from2c(x)
-30
</code></pre>
<p>Which shows that turning on the high bit for the number 2 in a 6-bit two's complement representation turns the number into -30. This makes sense, because 2<sup>6-1</sup> = 32, so the lowest integer in this representation is -32. And -32 + 2 = -30.</p>
<hr/>
<p>If you're interested in the details of how Python 3 stores integers, you can look through <a href="https://hg.python.org/cpython/file/580ddeccd689/Objects/longobject.c" rel="nofollow"><em>Objects/longobject.c</em></a> in the source. In particular, looking at <a href="https://hg.python.org/cpython/file/580ddeccd689/Objects/longobject.c#l73" rel="nofollow">the function <code>_PyLong_Negate()</code></a>:</p>
<pre><code>/* If a freshly-allocated int is already shared, it must
   be a small integer, so negating it must go to PyLong_FromLong */
Py_LOCAL_INLINE(void)
_PyLong_Negate(PyLongObject **x_p)
{
    PyLongObject *x;

    x = (PyLongObject *)*x_p;
    if (Py_REFCNT(x) == 1) {
        Py_SIZE(x) = -Py_SIZE(x);
        return;
    }

    *x_p = (PyLongObject *)PyLong_FromLong(-MEDIUM_VALUE(x));
    Py_DECREF(x);
}
</code></pre>
<p>you can see that all it does in the normal case is negate the <code>Py_SIZE()</code> value of the integer object. <a href="https://hg.python.org/cpython/file/580ddeccd689/Include/object.h#l119" rel="nofollow"><code>Py_SIZE()</code></a> is simply a reference to the <code>ob_size</code> field of the integer object. When this value is 0, the integer is 0. Otherwise, its sign is the sign of the integer, and its absolute value is the number of 30- or 15-bit digits in the array that holds the integer's absolute value.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Negative number representations in python :</strong></p>
<p>Depending on how many binary digit you want, subtract from a number (2<sup>n</sup>):</p>
<pre><code>&gt;&gt;&gt; bin((1 &lt;&lt; 8) - 1)
'0b11111111'
&gt;&gt;&gt; bin((1 &lt;&lt; 16) - 1)
'0b1111111111111111'
&gt;&gt;&gt; bin((1 &lt;&lt; 32) - 1)
'0b11111111111111111111111111111111'
</code></pre>
<p>Function to generate two's compliment(negative number):</p>
<pre><code>def to_twoscomplement(bits, value):
    if value &lt; 0:
        value = ( 1&lt;&lt;bits ) + value
    formatstring = '{:0%ib}' % bits
    return formatstring.format(value)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; to_twoscomplement(16, 3)
'0000000000000011'
&gt;&gt;&gt; to_twoscomplement(16, -3)
'1111111111111101'
</code></pre>
<p>Refer : <a href="https://stackoverflow.com/a/21872435/2142994">two's complement of numbers in python</a></p>
</div>
<span class="comment-copy">Considering that  <code>bin(5)</code>  returns <code>'0b101'</code>, which bit do you want to flip?</span>
<span class="comment-copy">Also consider that sys.getsizeof(x) returns the size in bytes, not bits.</span>
<span class="comment-copy">I just want to flip the sign bit (to make it negative number)</span>
<span class="comment-copy">That doesn't really work in Python as the language does everything to hide the bit representation of your numbers. Try to XOR a 1-Bit to the 1000s position of your int. It will just expand your number to 1000 Bit-digits. You will not 'find' the sign bit and therefore can't flip it. Maybe it its possible but then I don't know how. The closest I can think of is ~ operator, which computes the 2s complement: ~5 = -6</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/1604464/4279">Two's Complement in Python</a></span>
