<div class="post-text" itemprop="text">
<p>I have a list of player ranks attributed to players.  In addition to this, I have a list of tuples of ranks...</p>
<pre><code>rank_database = [("Unprocessed Rank", "Processed Rank"), ("Unprocessed Rank 2", "Processed Rank 2")]
</code></pre>
<p>What I would like to do is, for every item in the player ranks list, process them through the rank database --- like find and replace.</p>
<p>So, before replacement:</p>
<pre><code>player_ranks = ["Unprocessed Rank", "Unprocessed Rank 2"]
</code></pre>
<p>After replacement:</p>
<pre><code>player_ranks = ["Processed Rank", "Processed Rank 2"]
</code></pre>
<p>Essentially, I would like to use <code>rank_database</code> to perform a find and replace operation on the <code>player_ranks</code> list.</p>
<h1>Proposed Solution</h1>
<p>My idea was to try to use the tuples with the <a href="https://docs.python.org/3/library/stdtypes.html#str.replace" rel="nofollow"><code>str.replace</code></a> method as follows... </p>
<pre><code>player_ranks = ["Unprocessed Rank", "Unprocessed Rank 2"]
rank_database = [("Unprocessed Rank", "Processed Rank"), ("Unprocessed Rank 2", "Processed Rank 2")]

for x in player_ranks:
    for y in rank_database:
        print("Changed "+x+" to")
        if x == y[0]:
            player_ranks[x].replace(rank_database[y]) #Line 5
            print (x)
            break
        else:
            continue
print("Finished!")
</code></pre>
<p>When I execute the code, since <code>("Unprocessed Rank", "Processed Rank")</code> is a tuple found at <code>rank_database[i]</code>, I'm hoping this will sort of "inject" the tuple as the replacement strings in the <code>str.replace</code> method. </p>
<p>So, when executing the code, Line 5 should look like...</p>
<pre><code>rank.replace(("Unprocessed Rank", "Processed Rank"))
</code></pre>
<p>Would this be a possible solution, or is this not possible, and would other solutions be more appropriate?  This is for a personal project, so I would prefer to get my own solution working.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm making these assumptions:</p>
<ol>
<li><p>The "unprocessed" ranks in your database are unique, because otherwise you'll have to add a way to determine which tuple is the "correct" mapping from that unprocessed rank to a processed one.</p></li>
<li><p>Returning a new list of processed ranks is as good as mutating the original list.</p></li>
<li><p>Your data will all fit in memory easily, because this will take at least twice the memory your database already uses.</p></li>
</ol>
<p>Your database should be stored as a <code>dict</code>, or at least should be converted into one for the kind of work you're doing, since all you're doing is mapping unique(?) keys to values.  The <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow"><code>dict</code> initializer</a> can take an iterable of key-value pairs, which you already have.</p>
<p>Below, I've created a stand-alone function to do the work.</p>
<pre class="lang-python3 prettyprint-override"><code>#!/usr/bin/env python3

def process_ranks(player_ranks, rank_database):
    rank_map = dict(rank_database)
    return [rank_map[rank] for rank in player_ranks]

def main():
    # Sample data.
    player_ranks = ['old' + str(n) for n in range(4)]
    # Database contains more rank data than we will use.
    rank_database = [
      ('old' + str(n), 'new' + str(n)) for n in range(40)
      ]

    print("Original player ranks:")
    print(player_ranks)
    processed_ranks = process_ranks(player_ranks, rank_database)
    print("Processed player ranks:")
    print(processed_ranks)
    return

if "__main__" == __name__:
    main()
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Original player ranks:
['old0', 'old1', 'old2', 'old3']
Processed player ranks:
['new0', 'new1', 'new2', 'new3']
</code></pre>
<p>If you really do need to mutate the original list, you could replace its contents with a slightly different call to <code>process_ranks</code> in <code>main</code> with:</p>
<pre class="lang-python3 prettyprint-override"><code>    player_ranks[:] = process_ranks(player_ranks, rank_database)
</code></pre>
<p>In general, though, I find preserving the original list and creating a new <code>processed_ranks</code> list is easier to code and especially to debug.</p>
</div>
<span class="comment-copy">Can you show some sample data to explain the structure? It's not clear what processed, unprocessed, and unreferenced mean.</span>
<span class="comment-copy"><code>if rank in player_ranks</code> will <i>always</i> be true, unless you have some other thread altering <code>player_ranks</code> behind your back... or you've done something really bizarre with your <code>__eq__</code> methods.</span>
<span class="comment-copy">I agree with Alex Hall that your question is unclear.  However, it is clear that the if statement will always be true, that you probably intended the else statement to be at the same indent level as the if statement above it, that the else: continue construction is redundant in the context of this code, and that =+ is not a valid python operator.</span>
<span class="comment-copy">I have updated this. Thank you for your time and consideration.</span>
<span class="comment-copy">@PaulCornelius I use += all the time. If i = 0 and you say i =+ 2, then i = 2.</span>
<span class="comment-copy">This is clearly the best (simplest) solution to all of this instead of me trying to be crazy with what I'm doing. I guess I got so caught up trying to deploy original code I forgot that I just want this to work in the end. Thanks for your input!</span>
<span class="comment-copy">I'm reasonably new to programming I believe.</span>
