<div class="post-text" itemprop="text">
<p>Some homework help would be greatly appreciated.</p>
<p>Using socket, I need to parse data from a website (<a href="http://www.py4inf.com/code/romeo.txt" rel="nofollow">http://www.py4inf.com/code/romeo.txt</a>).</p>
<p>I'm using a regular expression '^\s*$' to locate the first blank line after the header and above the data.</p>
<p>Any tips on how to only extract the data (and not print the header)?</p>
<pre><code>import socket
import re

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    userUrl = raw_input('Enter a url: ')

    d = userUrl.split('/')
    d.remove("")

    host = d[1]

    mysock.connect((host, 80))
    mysock.send('GET %s HTTP/1.0\n\n'%(userUrl))


    while True:
        data = mysock.recv(3000)
        if len(data) &lt; 1: break
        print (''.join([x for x in re.findall(**'^\s*$'**,data,re.DOTALL)]))           


except Exception as e:
    print (str(e))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming since it's a homework problem you <em>have to</em> use <code>socket</code> and can't use something more user-friendly like <a href="http://python-requests.org/" rel="nofollow"><code>requests</code></a>.</p>
<p>I would first loop until you have the complete response in a string, and then iterate over it like this:</p>
<pre><code>...
response = ""
while True:
    data = mysock.recv(3000)
    if len(data) &lt; 1: break
    response += data

iterator = iter(response.split("\n"))

for line in iterator:
    if not line.strip():  # empty line
        break

body = "\n".join(iterator)  # put the rest of the data in a string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" rel="nofollow">&gt;&gt; Documentation of <code>socket.recv(bufsize)</code> (Python 3)</a></p>
<p>First, it's recommended to use powers of 2 bytes as buffer size for <code>socket.recv</code>:</p>
<pre><code>data = mysock.recv(4096)
</code></pre>
<p>Second, it does not return a string but binary data of <code>bufsize</code> bytes length (or less, if the stream end is reached). That means, you don't get the data line by line and can iterate over it like over a file-like object.</p>
<p>You have to collect the data chunks, concatenate them, convert the result to a string and then split it into a list of lines. Here's a generator function returning lines from a socket stream, so that you can iterate over it like over a file-like object:</p>
<p><sub><em>Update: fixed bytes encoding issue in function below</em></sub></p>
<pre><code>def read_lines_from_socket(mysock):
    data = ""
    while True:
        received = mysock.recv(64)
        if len(received) &lt; 1: 
            return data
        data += received.decode("utf-8")
        if "\n" in data:
            lines = data.split("\n")
            data = lines.pop()  # move not yet completed line back to beginning of input data
            for line in lines:
                yield line
</code></pre>
<p>Note that this function <em>already strips the newline characters <code>\n</code> from the returned lines!</em></p>
<p>You can now use this function's returned generator like a file and iterate over the received lines:</p>
<pre><code>import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    userUrl = 'http://www.py4inf.com/code/romeo.txt'

    d = userUrl.split('/')
    d.remove("")

    host = d[1]

    mysock.connect((host, 80))
    mysock.send('GET %s HTTP/1.0\n\n'%(userUrl))

    ### vvvvv  New example code section starts here:  vvvvv ###    

    header_data = True
    for line in read_lines_from_socket(mysock):
        if header_data:
            if not line.strip():
                # checks for first empty line and sets header_data to False after that
                header_data = False
                print("----- End Of Header -----")

            else:
                # process header data here:
                print("Header:", line)

        else:

            # process content data here:
            print("Content:", line)

    ### ^^^^^  New example code section ends here.  ^^^^^ ###    


except Exception as e:
    print (str(e))
</code></pre>
</div>
<span class="comment-copy">have you tried printing out the raw data received on the socket (without applying any regular expression)?</span>
<span class="comment-copy">to parse html, regular expression are pretty bad. you need to use a parser like beautiful soup</span>
<span class="comment-copy">@Whitefret They are not trying to parse HTML.</span>
<span class="comment-copy">isn't he trying to parse the result because he wants what's in the body no?</span>
<span class="comment-copy">They are trying to parse an HTTP Response. That's very regular, not context free.</span>
<span class="comment-copy">Updated my code to fix a little mistake regarding the string/bytes encoding.</span>
