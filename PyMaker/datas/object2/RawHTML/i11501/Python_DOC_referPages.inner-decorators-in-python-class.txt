<div class="post-text" itemprop="text">
<p>I want to create an inner decorator using it inside my Python class for wrapping the selenium frame switching in and out operations. So I tried this:</p>
<pre><code>class MyPage(object):
    # ...
    def framed(self, frame_query: str):
        def decorator(function):
            @functools.wraps(function)
            def wrapper(*args, **kwargs):
                frame = self.driver.find_element(By.XPATH, frame_query)
                self.driver.switch_to.frame(frame)
                out = function(*args, **kwargs)
                self.driver.switch_to.default_content()
                return out
            return wrapper
        return decorator
    # ...
    @framed('//myxpath/iframe')
    def framed_function(self):
        # ...
</code></pre>
<p>But then I receive this error:</p>
<pre><code>TypeError: framed() missing 1 required positional argument: 'frame_query'
</code></pre>
<p>Obviously it is expecting 2 parameters including the self but in the decorator context it doesn't know anything about the self, so I had to define and inner function inside ´framed_function´ making the solution a lot less elegant:</p>
<pre><code># My workaround
def framed_function(self):
    @framed('//myxpath/iframe')
    def actual_framed():
        #...
    actual_framed()
</code></pre>
<p>Suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>When defining methods for a class, there is no class object yet. There certainly are no instances yet of that class, so there is nothing for a <code>self</code> to be bound to <em>either</em>. Instead, methods are bound to an instance at the time they are looked up on an instance object, see the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow">Python descriptor HOWTO</a>. Just return a new function object from your decorator that will be bound instead.</p>
<p>Also, Python has no privacy model, so there is no concept of 'inner' either (for classes or methods or anything). Just put your decorator outside of the class, this makes it simpler to maintain and reuse, and avoids polluting your class API.</p>
<p>This means that your <code>wrapped()</code> function will become a method, and it'll be passed the <code>self</code> argument when bound. Use that, and pass it on to the wrapped function object explicitly (since that function was not bound):</p>
<pre><code>def framed(frame_query: str):
    def decorator(function):
        @functools.wraps(function)
        def wrapper(self, *args, **kwargs):
            frame = self.driver.find_element(By.XPATH, frame_query)
            self.driver.switch_to.frame(frame)
            out = function(self, *args, **kwargs)
            self.driver.switch_to.default_content()
            return out
        return wrapper
    return decorator

class MyPage(object):
    @framed('//myxpath/iframe')
    def framed_function(self):
</code></pre>
<p>So <code>framed()</code> returns <code>decorator()</code>, which in turn is used to decorate <code>framed_function()</code>; doing so returns <code>wrapper()</code>, which is added to the actual <code>MyPage</code> class object produced. On instances of <code>MyPage()</code> then, accessing <code>instance.framed_function()</code> will bind <code>wrapper()</code> to that instance, so that <code>self</code> is bound to that <code>instance</code> object. Within <code>wrapper</code> you then have access to the instance as <code>self</code>, as well as to the original <code>function</code> object (unbound) and to the <code>frame_query</code> string.</p>
</div>
<span class="comment-copy">Works, but definitely tricky when you don´t know how the decorators are added to the object instance (my failure), I will take a look at this reading you referenced to understand  more about this.</span>
