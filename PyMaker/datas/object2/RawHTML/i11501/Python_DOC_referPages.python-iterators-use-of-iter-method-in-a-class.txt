<div class="post-text" itemprop="text">
<p>What is the most basic definition of "iterable", "iterator" and "iteration" in Python?</p>
<p>I have read multiple definitions but I am unable to identify the exact meaning as it still won't sink in.</p>
<p>Can someone please help me with the 3 definitions in layman terms?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Iteration</strong> is a general term for taking each item of something, one after another. Any time you use a loop, explicit or implicit, to go over a group of items, that is iteration.</p>
<p>In Python, <strong>iterable</strong> and <strong>iterator</strong> have specific meanings.</p>
<p>An <strong>iterable</strong> is an object that has an <code>__iter__</code> method which returns an <strong>iterator</strong>, or which defines a <code>__getitem__</code> method that can take sequential indexes starting from zero (and raises an <code>IndexError</code> when the indexes are no longer valid). So an <strong>iterable</strong> is an object that you can get an <strong>iterator</strong> from.</p>
<p>An <strong>iterator</strong> is an object with a <code>next</code> (Python 2) or <code>__next__</code> (Python 3) method. </p>
<p>Whenever you use a <code>for</code> loop, or <code>map</code>, or a list comprehension, etc. in Python, the <code>next</code> method is called automatically to get each item from the <strong>iterator</strong>, thus going through the process of <strong>iteration</strong>.</p>
<p>A good place to start learning would be the <a href="https://docs.python.org/3/tutorial/classes.html#iterators">iterators section of the tutorial</a> and the <a href="https://docs.python.org/dev/library/stdtypes.html#iterator-types">iterator types section of the standard types page</a>. After you understand the basics, try the <a href="https://docs.python.org/dev/howto/functional.html#iterators">iterators section of the Functional Programming HOWTO</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the explanation I use in teaching Python classes:</p>
<p>An ITERABLE is:</p>
<ul>
<li>anything that can be looped over (i.e. you can loop over a string or file) or</li>
<li>anything that can appear on the right-side of a for-loop:   <code>for x in iterable: ...</code> or</li>
<li>anything you can call with <code>iter()</code> that will return an ITERATOR:  <code>iter(obj)</code> or</li>
<li>an object that defines <code>__iter__</code> that returns a fresh ITERATOR,
or it may have a <code>__getitem__</code> method suitable for indexed lookup.</li>
</ul>
<p>An ITERATOR is an object:</p>
<ul>
<li>with state that remembers where it is during iteration,</li>
<li>with a <code>__next__</code> method that:

<ul>
<li>returns the next value in the iteration</li>
<li>updates the state to point at the next value</li>
<li>signals when it is done by raising <code>StopIteration</code></li>
</ul></li>
<li>and that is self-iterable (meaning that it has an <code>__iter__</code> method that returns <code>self</code>).</li>
</ul>
<p>Notes:</p>
<ul>
<li>The <code>__next__</code> method in Python 3 is spelt <code>next</code> in Python 2, and</li>
<li>The builtin function <code>next()</code> calls that method on the object passed to it.</li>
</ul>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; s = 'cat'      # s is an ITERABLE
                   # s is a str object that is immutable
                   # s has no state
                   # s has a __getitem__() method 

&gt;&gt;&gt; t = iter(s)    # t is an ITERATOR
                   # t has state (it starts by pointing at the "c"
                   # t has a next() method and an __iter__() method

&gt;&gt;&gt; next(t)        # the next() function returns the next value and advances the state
'c'
&gt;&gt;&gt; next(t)        # the next() function returns the next value and advances
'a'
&gt;&gt;&gt; next(t)        # the next() function returns the next value and advances
't'
&gt;&gt;&gt; next(t)        # next() raises StopIteration to signal that iteration is complete
Traceback (most recent call last):
...
StopIteration

&gt;&gt;&gt; iter(t) is t   # the iterator is self-iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The above answers are great, but as most of what I've seen, don't stress the <em>distinction</em> enough for people like me.</p>
<p>Also, people tend to get "too Pythonic" by putting definitions like "X is an object that has <code>__foo__()</code> method" before.  Such definitions are correct--they are based on duck-typing philosophy, but the focus on methods tends to get between when trying to understand the concept in its simplicity.</p>
<p>So I add my version.</p>
<hr/>
<p>In natural language,</p>
<ul>
<li><strong>iteration</strong> is the process of taking one element at a time in a row of elements.</li>
</ul>
<p>In Python,</p>
<ul>
<li><p><strong>iterable</strong> is an object that is, well, iterable, which simply put, means that
it can be used in iteration, e.g. with a <code>for</code> loop.  How?  By using <em>iterator</em>.
I'll explain below.</p></li>
<li><p>... while <strong>iterator</strong> is an object that defines <em>how to actually do</em> the
iteration--specifically <em>what is the next</em> element.  That's why it must have
<code>next()</code> method. </p></li>
</ul>
<p>Iterators are themselves also iterable, with the distinction that their <code>__iter__()</code> method returns the same object (<code>self</code>), regardless of whether or not its items have been consumed by previous calls to <code>next()</code>.</p>
<hr/>
<p>So what does Python interpreter think when it sees <code>for x in obj:</code> statement?</p>
<blockquote>
<p>Look, a <code>for</code> loop.   Looks like a job for an iterator...  Let's get one. ...
  There's this <code>obj</code> guy, so let's ask him.</p>
<p>"Mr. <code>obj</code>, do you have your iterator?" (... calls <code>iter(obj)</code>, which calls
  <code>obj.__iter__()</code>, which happily hands out a shiny new iterator <code>_i</code>.) </p>
<p>OK, that was easy... Let's start iterating then. (<code>x = _i.next()</code> ... <code>x = _i.next()</code>...)</p>
</blockquote>
<p>Since Mr. <code>obj</code> succeeded in this test (by having certain method returning a valid iterator), we reward him with adjective: you can now call him "iterable Mr. <code>obj</code>".</p>
<p>However, in simple cases, you don't normally benefit from having iterator and iterable separately.  So you define <em>only one</em> object, which is also its own iterator.  (Python does not really care that <code>_i</code> handed out by <code>obj</code> wasn't all that shiny, but just the <code>obj</code> itself.) </p>
<p>This is why in most examples I've seen (and what had been confusing me over and over),
you can see:</p>
<pre><code>class IterableExample(object):

    def __iter__(self):
        return self

    def next(self):
        pass
</code></pre>
<p>instead of</p>
<pre><code>class Iterator(object):
    def next(self):
        pass

class Iterable(object):
    def __iter__(self):
        return Iterator()
</code></pre>
<p>There are cases, though, when you can benefit from having iterator separated from the iterable, such as when you want to have one row of items, but more "cursors".  For example when you want to work with "current" and "forthcoming" elements, you can have separate iterators for both.  Or multiple threads pulling from a huge list: each can have its own iterator to traverse over all items. See <a href="https://stackoverflow.com/a/9884501/835945">@Raymond's</a> and <a href="https://stackoverflow.com/a/9884245/835945">@glglgl's</a> answers above.</p>
<p>Imagine what you could do:</p>
<pre><code>class SmartIterableExample(object):

    def create_iterator(self):
        # An amazingly powerful yet simple way to create arbitrary
        # iterator, utilizing object state (or not, if you are fan
        # of functional), magic and nuclear waste--no kittens hurt.
        pass    # don't forget to add the next() method

    def __iter__(self):
        return self.create_iterator()
</code></pre>
<p>Notes: </p>
<ul>
<li><p>I'll repeat again: <em>iterator is not iterable</em>.  Iterator cannot be used as
a "source" in <code>for</code> loop.  What <code>for</code> loop primarily needs is <code>__iter__()</code>
(that returns something with <code>next()</code>).</p></li>
<li><p>Of course, <code>for</code> is not the only iteration loop, so above applies to some other
constructs as well (<code>while</code>...).</p></li>
<li><p>Iterator's <code>next()</code> can throw StopIteration to stop iteration.  Does not have to,
though, it can iterate forever or use other means.</p></li>
<li><p>In the above "thought process", <code>_i</code> does not really exist.  I've made up that name.</p></li>
<li><p>There's a small change in Python 3.x: <code>next()</code> method (not the built-in) now
must be called <code>__next__()</code>.  Yes, it should have been like that all along.</p></li>
<li><p>You can also think of it like this: iterable has the data, iterator pulls the next
item</p></li>
</ul>
<p><em>Disclaimer:</em> I'm not a developer of any Python interpreter, so I don't really know what the interpreter "thinks".  The musings above are solely demonstration of how I understand the topic from other explanations, experiments and real-life experience of a Python newbie.</p>
</div>
<div class="post-text" itemprop="text">
<p>An iterable is a object which has a <code>__iter__()</code> method. It can possibly iterated over several times, such as <code>list()</code>s and <code>tuple()</code>s.</p>
<p>An iterator is the object which iterates. It is returned by an <code>__iter__()</code> method, returns itself via its own <code>__iter__()</code> method and has a <code>next()</code> method (<code>__next__()</code> in 3.x).</p>
<p>Iteration is the process of calling this <code>next()</code> resp. <code>__next__()</code> until it raises <code>StopIteration</code>.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3] # iterable
&gt;&gt;&gt; b1 = iter(a) # iterator 1
&gt;&gt;&gt; b2 = iter(a) # iterator 2, independent of b1
&gt;&gt;&gt; next(b1)
1
&gt;&gt;&gt; next(b1)
2
&gt;&gt;&gt; next(b2) # start over, as it is the first call to b2
1
&gt;&gt;&gt; next(b1)
3
&gt;&gt;&gt; next(b1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt; b1 = iter(a) # new one, start over
&gt;&gt;&gt; next(b1)
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don’t know if it helps anybody but I always like to visualize concepts in my head to better understand them. So as I have a little son I visualize iterable/iterator concept with bricks and white paper.</p>
<p>Suppose we are in the dark room and on the floor we have bricks for my son. Bricks of different size, color, does not matter now. Suppose we have 5 bricks like those. Those 5 bricks can be described as an <strong>object</strong> – let’s say <strong><em>bricks kit</em></strong>. We can do many things with this bricks kit – can take one and then take second and then third, can change places of bricks, put first brick above the second. We can do many sorts of things with those. Therefore this bricks kit is an <strong>iterable object</strong> or <strong>sequence</strong> as we can go through each brick and do something with it. We can only do it like my little son – we can play with <strong>one</strong> brick <strong>at a time</strong>. So again I imagine myself this bricks kit to be an <strong>iterable</strong>.</p>
<p>Now remember that we are in the dark room. Or almost dark. The thing is that we don’t clearly see those bricks, what color they are, what shape etc. So even if we want to do something with them – aka <strong>iterate through them</strong> – we don’t really know what and how because it is too dark.</p>
<p>What we can do is near to first brick – as element of a bricks kit – we can put a piece of white fluorescent paper in order for us to see where the first brick-element is. And each time we take a brick from a kit, we replace the white piece of paper to a next brick in order to be able to see that in the dark room. This white piece of paper is nothing more than an <strong>iterator</strong>. It is an <strong>object as well</strong>. But an object with what we can work and play with elements of our iterable object – bricks kit.</p>
<p>That by the way explains my early mistake when I tried the following in an IDLE and got a TypeError:</p>
<pre><code> &gt;&gt;&gt; X = [1,2,3,4,5]
 &gt;&gt;&gt; next(X)
 Traceback (most recent call last):
    File "&lt;pyshell#19&gt;", line 1, in &lt;module&gt;
      next(X)
 TypeError: 'list' object is not an iterator
</code></pre>
<p>List X here was our bricks kit but NOT a white piece of paper. I needed to find an iterator first:</p>
<pre><code>&gt;&gt;&gt; X = [1,2,3,4,5]
&gt;&gt;&gt; bricks_kit = [1,2,3,4,5]
&gt;&gt;&gt; white_piece_of_paper = iter(bricks_kit)
&gt;&gt;&gt; next(white_piece_of_paper)
1
&gt;&gt;&gt; next(white_piece_of_paper)
2
&gt;&gt;&gt;
</code></pre>
<p>Don’t know if it helps, but it helped me. If someone could confirm/correct visualization of the concept, I would be grateful. It would help me to learn more.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my cheat sheet:</p>
<pre><code> sequence
  +
  |
  v
   def __getitem__(self, index: int):
  +    ...
  |    raise IndexError
  |
  |
  |              def __iter__(self):
  |             +     ...
  |             |     return &lt;iterator&gt;
  |             |
  |             |
  +--&gt; or &lt;-----+        def __next__(self):
       +        |       +    ...
       |        |       |    raise StopIteration
       v        |       |
    iterable    |       |
           +    |       |
           |    |       v
           |    +----&gt; and +-------&gt; iterator
           |                               ^
           v                               |
   iter(&lt;iterable&gt;) +----------------------+
                                           |
   def generator():                        |
  +    yield 1                             |
  |                 generator_expression +-+
  |                                        |
  +-&gt; generator() +-&gt; generator_iterator +-+
</code></pre>
<p>Quiz: Do you see how...</p>
<ul>
<li>every iterator is an iterable?</li>
<li>a container object's <code>__iter__()</code> method can be implemented as a generator?</li>
<li>an iterable plus a <code>__next__</code> method is not necessarily an iterator?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I don't think that you can get it much simpler than the <a href="http://docs.python.org/tutorial/classes.html#iterators" rel="nofollow">documentation</a>, however I'll try:</p>
<ul>
<li><strong>Iterable</strong> is something that can be <em>iterated</em> over. In practice it <em>usually</em> means a <em>sequence</em> e.g. something that has a beginning and an end and some way to go through all the items  in it.</li>
<li><p>You can think <strong>Iterator</strong> as a helper pseudo-method (or pseudo-attribute) that gives (or holds) the next (or first) item in the <em>iterable</em>. (In practice it is just an object that defines the method <code>next()</code>)</p></li>
<li><p><strong>Iteration</strong> is probably best explained by the Merriam-Webster <a href="http://www.merriam-webster.com/dictionary/iteration" rel="nofollow">definition of the word </a>:</p></li>
</ul>
<blockquote>
<p>b : the repetition of a sequence of computer instructions a specified
  number of times or until a condition is met — compare recursion</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><strong>Iterable</strong>:- something that is iterable is iterable; like sequences like lists ,strings etc.
  Also it has either the <code>__getItem__()</code> method or an <code>iter()</code> function which returns an iterator.  </p>
<p><strong>Iterator</strong>:- When we get iterator object from the <code>iter()</code> method of iterable; we call <code>__next__()</code> method (in python3) or simply <code>next()</code> (in python2) to get elements one by one. This class or instance of this class is called an iterator.</p>
<p><strong>From docs:-</strong></p>
<p>The use of iterators pervades and unifies Python. Behind the scenes, the for statement calls <code>iter()</code> on the container object. The function returns an iterator object that defines the method <code>__next__()</code> which accesses elements in the container one at a time. When there are no more elements, <code>__next__()</code> raises a StopIteration exception which tells the for loop to terminate. You can call the <code>__next__()</code> method using the <code>next()</code> built-in function; this example shows how it all works:</p>
<pre><code>&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; it = iter(s)
&gt;&gt;&gt; it
&lt;iterator object at 0x00A1DB50&gt;
&gt;&gt;&gt; next(it)
'a'
&gt;&gt;&gt; next(it)
'b'
&gt;&gt;&gt; next(it)
'c'
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    next(it)
StopIteration
</code></pre>
<p>Ex of a class:- </p>
<pre><code>class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]


&gt;&gt;&gt; rev = Reverse('spam')
&gt;&gt;&gt; iter(rev)
&lt;__main__.Reverse object at 0x00A1DB50&gt;
&gt;&gt;&gt; for char in rev:
...     print(char)
...
m
a
p
s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>iterable = [1, 2] 

iterator = iter(iterable)

print(iterator.__next__())   

print(iterator.__next__())   
</code></pre>
<p>so,</p>
<ol>
<li><p><code>iterable</code> is an <strong>object</strong> that can be <strong>looped over</strong>. e.g. list , string , tuple etc.</p></li>
<li><p>using the <code>iter</code> function on our <code>iterable</code> object will return an <strong>iterator object.</strong></p></li>
<li><p>now this <strong>iterator object</strong> has method named <code>__next__</code> (in Python 3, or just <code>next</code> in Python 2) by which you can <strong>access each element of iterable.</strong></p></li>
</ol>
<p>so, 
    OUTPUT OF ABOVE CODE WILL BE:</p>
<p>1</p>
<p>2</p>
</div>
<div class="post-text" itemprop="text">
<p>Before dealing with the  iterables and iterator the major factor that decide the iterable and iterator is sequence</p>
<p>Sequence:Sequence is the collection of data</p>
<p>Iterable:Iterable are the sequence type object that support Iter method.</p>
<p>Iter method:Iter method take sequence as an input and create an object which is known as iterator</p>
<p>Iterator:Iterator are the object which call next method and transverse through the sequence.On calling the next method it returns the object that it transversed currently.</p>
<p>example:</p>
<pre><code>x=[1,2,3,4]
</code></pre>
<p>x is a sequence which consists of collection of data</p>
<pre><code>y=iter(x)
</code></pre>
<p>On calling iter(x) it returns a iterator only when the x object has iter method otherwise it raise an exception.If it returns iterator then y is assign like this:</p>
<pre><code>y=[1,2,3,4]
</code></pre>
<p>As y is a iterator hence it support next() method</p>
<p>On calling next method it returns the individual elements of the list one by one.</p>
<p>After returning the last element of the sequence if we again call the next method it raise an StopIteration error</p>
<p>example:</p>
<pre><code>&gt;&gt;&gt; y.next()
1
&gt;&gt;&gt; y.next()
2
&gt;&gt;&gt; y.next()
3
&gt;&gt;&gt; y.next()
4
&gt;&gt;&gt; y.next()
StopIteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Iterables</strong> have a <code>__iter__</code> method that instantiates a new iterator every time.  </p>
<p><strong>Iterators</strong> implement a <code>__next__</code> method that returns individual items, and a <code>__iter__</code> method that returns <code>self</code> .   </p>
<p>Therefore, iterators are also iterable, but iterables are not iterators.  </p>
</blockquote>
<p>Luciano Ramalho, Fluent Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python everything is an object. When an object is said to be iterable, it means that you can step through (i.e. iterate) the object as a collection.</p>
<p>Arrays for example are iterable. You can step through them with a for loop, and go from index 0 to index n, n being the length of the array object minus 1.</p>
<p>Dictionaries (pairs of key/value, also called associative arrays) are also iterable. You can step through their keys.</p>
<p>Obviously the objects which are not collections are not iterable. A bool object for example only have one value, True or False. It is not iterable (it wouldn't make sense that it's an iterable object).</p>
<p>Read more. <a href="http://www.lepus.org.uk/ref/companion/Iterator.xml" rel="nofollow">http://www.lepus.org.uk/ref/companion/Iterator.xml</a></p>
</div>
<span class="comment-copy">Note that <code>collections.abc.AsyncIterator</code> tests for <code>__aiter__</code> and <code>__anext__</code> methods. This is a new addition in 3.6.</span>
<span class="comment-copy">@jlh why would <code>__len__</code> be necessarily tied to iteration? How would knowing the length of something help you iterate over it?</span>
<span class="comment-copy">@shadowtalker it would help to know which indexes are valid, so you know which indexes can be used with <code>__getitem__</code>.</span>
<span class="comment-copy">@jlh it sounds like you are proposing a very opinionated dfeault behavior. Consider that <code>{'a': 'hi', 'b': 'bye'}</code> has length of 2, but cannot be indexed by 0, 1, or 2.</span>
<span class="comment-copy">@shadowtalker. But a dict has an <code>__iter__</code> method. I think jlh is referring to objects that are iterable specifically because they define: "a <code>__getitem__</code> method that can take sequential indexes starting from zero".</span>
<span class="comment-copy">what do you mean by fresh iterator?</span>
<span class="comment-copy">@lmiguelvargasf "Fresh" as in "new and unconsumed" as opposed to "exhausted or partially consumed".  The idea is that a new iterator starts at the beginning, while a partially used iterator picks up where it left off.</span>
<span class="comment-copy">Your 2nd, 3rd, and 4th bullets clearly indicate what you mean, in terms of specific python constructs or built-ins or method calls. But the 1st bullet ("anything that can be looped over") doesn't have that clarity. Also, the 1st bullet seems to have an overlap with the 2nd bullet, since the 2nd bullet is about <code>for</code> loops, and the 1st bullet is about "looping over". Could you pls address these?</span>
<span class="comment-copy">Pls consider re-phrasing "anything your can call with <code>iter()</code>" as "anything you can pass to <code>iter()</code>"</span>
<span class="comment-copy">This is great - but I'm still a little confused. I thought your yellow box was saying that a <code>for</code> loop needs an iterator ("Look, a for loop. Looks like a job for an iterator... Let's get one."). But then you say in the notes at the end that "Iterator cannot be used as a source in a <code>for</code> loop"...?</span>
<span class="comment-copy">Why do you put just <code>pass</code> in the code for those <code>next</code> definitions? I'll assume you just mean that someone has to implement a way to get the next one, since next has to return something.</span>
<span class="comment-copy">@nealmcb Yes, I think that's what past me meant.  (That's what <a href="https://docs.python.org/2/reference/simple_stmts.html#pass" rel="nofollow noreferrer"><code>pass</code> is for</a>, after all.)</span>
<span class="comment-copy">@AloisMahdal Ahh, I hadn't seen that use before. When I see <code>pass</code>, I think it is there for syntactic reasons. I just ran across the answers at <a href="http://stackoverflow.com/a/6189281/507544">ellipsis object</a> which are quite interesting: you can use <code>...</code> to indicate a "todo later" block. <code>NotImplemented</code> is also available.</span>
<span class="comment-copy">While I like that you're stressing the distinction between an iterator and an iterable, this answer contradicts itself. First you write, 'Iterators are themselves also iterable', (which matches what is written in <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">the Python documentation</a>). But then later on you write: '<i>iterator is not iterable</i>. Iterator cannot be used as a "source" in <code>for</code> loop'. I get the point of your answer, and like it otherwise, but I think it would benefit from fixing this.</span>
<span class="comment-copy">So really it's just a object that passes through container's? were would this be useful?</span>
<span class="comment-copy">Often, but not always. A generator, file or database cursor can only be iterated once and thus are their own iterators.</span>
<span class="comment-copy">I guess b2 doesn't have to independent of b1 ? for this special case, it's independent, sure I can make it not independent but also a valid <code>Iterable</code>.</span>
<span class="comment-copy">@Bin Yes. As and <code>Iterator</code> is always <code>Iterable</code> and is its own <code>Iterator</code>, two calls of <code>iter()</code> do not necessarily give two independent <code>Iterator</code>s.</span>
<span class="comment-copy">Just an observation: y=iter(x) is not exactly y=[1,2,3,4] since y is now an iterator object. Perhaps you should add a comment to clarify that is not a list but an iterator object or change the representation.</span>
<span class="comment-copy"><i>objects which are not collections are not iterable</i> is not generally true. To give just a couple of examples, generators are iterable but are not collections, and the iterator objects created by calling <code>iter()</code> on the standard collection types are iterable but are not, themselves, collections.</span>
