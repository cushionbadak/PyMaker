<div class="post-text" itemprop="text">
<p>I am trying to find a way to convert IP addresses to integers or real values so they can be mathematically grouped and plotted in a meaningful way. Ideally IPs with the same leftmost octet would be similar, IPs sharing the leftmost two octets would be more similar, and so on. </p>
<p>Is there a standard, accepted way to do this? Codified in, say, a Python library? Or am I just going to have to cook up my own algorithm?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You mean, like... the <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow"><code>ipaddress</code> module</a>?</p>
<pre><code>&gt;&gt;&gt; import ipaddress
&gt;&gt;&gt; i = ipaddress.ip_address('10.9.8.7')
&gt;&gt;&gt; int(i)
168364039
</code></pre>
<p>IP addresses with the same leftmost octet will be close, because if you convert an address to int, it just refers to the actual number an IP address represents (10.9.8.7 â‰™ 10*256^3 + 9*256^2 + 8*256^1 + 7*256^0).</p>
<p>It also works for IPv6:</p>
<pre><code>&gt;&gt;&gt; int(ipaddress.ip_address("2001:db8::1"))
42540766411282592856903984951653826561
</code></pre>
</div>
<span class="comment-copy">I had thought about this, but in practice this module generates numbers significantly different from one another that really should be grouped together. e.g. 10.255.35.2 == 184493058 and 10.1.1.2 == 167837954. This translation is a bit more noisy than I'd ideally like, but maybe it will have to do.</span>
<span class="comment-copy">It will still be pretty close, as you see. If you want to check whether, for example, the first octet matches, you can shift both values 24 to the right, i.e. <code>184493058&gt;&gt;24 == 167837954&gt;&gt;24</code>.</span>
