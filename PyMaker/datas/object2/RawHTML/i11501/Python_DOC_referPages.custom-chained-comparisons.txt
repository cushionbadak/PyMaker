<div class="post-text" itemprop="text">
<p>Python allows expressions like <code>x &gt; y &gt; z</code>, which, according to the docs, is equivalent to <code>(x &gt; y) and (y &gt; z)</code> except <code>y</code> is only evaluated once. (<a href="https://docs.python.org/3/reference/expressions.html">https://docs.python.org/3/reference/expressions.html</a>)</p>
<p>However, this seems to break if I customize comparison functions. E.g. suppose I have the following class: (Apologies for the large block, but once you read the <code>__eq__</code> method, the rest is trivial.)</p>
<pre><code>class CompareList(list):
    def __repr__(self):
        return "CompareList([" + ",".join(str(x) for x in self) + "])"

    def __eq__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] == other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x == other for x in self)

    def __ne__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] != other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x != other for x in self)

    def __gt__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] &gt; other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x &gt; other for x in self)

    def __ge__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] &gt;= other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x &gt;= other for x in self)

    def __lt__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] &lt; other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x &lt; other for x in self)

    def __le__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] &lt;= other[idx] for idx in xrange(len(self)))
        else:
            return CompareList(x &lt;= other for x in self)
</code></pre>
<p>Now I can do fun stuff like <code>CompareList([10, 5]) &gt; CompareList([5, 10])</code> and it will correctly return <code>CompareList([True,False])</code></p>
<p>However, chaining these operations doesn't work nicely:</p>
<pre><code>low = CompareList([1])
high = CompareList([2])
print(low &gt; high &gt; low) # returns CompareList([True])
</code></pre>
<p>Why not? What happens under the hood here? I know it isn't equivalent to <code>(low &gt; high) &gt; low</code> = <code>(False &gt; low)</code> (because that would return False). It could be <code>low &gt; (high &gt; low)</code> but that wouldn't make sense in terms of operator precedence (normally left-to-right).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python allows expressions like <code>x &gt; y &gt; z</code>, which, according to the docs, is equivalent to <code>(x &gt; y) and (y &gt; z)</code> except <code>y</code> is only evaluated once.</p>
</blockquote>
<p>According to this, <code>low &gt; high &gt; low</code> will be equivalent to <code>(low &gt; high) and (high &gt; low)</code>.</p>
<pre><code>&gt;&gt;&gt; x = low &gt; high   # CompareList([False])
&gt;&gt;&gt; y = high &gt; low   # CompareList([True]) 
&gt;&gt;&gt; x and y
CompareList([True])
</code></pre>
<p>More from the documentation on <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="nofollow noreferrer">x and y</a>:</p>
<blockquote>
<p><code>x and y</code>:    if <code>x</code> is false, then <code>x</code>, else <code>y</code></p>
</blockquote>
<p>In the above case:</p>
<pre><code>&gt;&gt;&gt; x is False
False
&gt;&gt;&gt; x if x is False else y     # x and y
CompareList([True])
</code></pre>
<p>so when you do <code>x and y</code> it returns the <code>y</code> which is <code>CompareList([True])</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers are right, but I wanted to address the actual <strike>lack of</strike> implementation for this problem, because, as I believe, what the OP would like to get as a result from <code>low &gt; high &gt; low</code> is a <code>CompareList([False])</code>.</p>
<p>Indeed, the <code>low &gt; high &gt; low</code> evaluates to <code>(low &gt; high) and (high &gt; low)</code> and since <code>CompareList([False]) is False</code> evaluates to <code>False</code> (which means that it is <code>True</code>), then the second operand of <code>and</code> operator gets evaluated and returned (as it also evaluates to <code>True</code>).</p>
<p>The key to implementing the chained comparison is to override the <code>and</code> boolean operator along <code>__gt__</code> and <code>__lt__</code>. </p>
<p>Unfortunately, there is no way to do this, and probably won't be. The <a href="https://www.python.org/dev/peps/pep-0335/" rel="nofollow"><code>PEP 335 - Overloadable Boolean Operators</code> proposal</a> was rejected by Guido, but he might consider making chained comparisons like a &lt; b &lt; c overloadable <a href="https://mail.python.org/pipermail/python-dev/2012-March/117510.html" rel="nofollow">[1]</a>.</p>
<p>Unless that moment, there is no way to get your example to work as expected when using chained comparisons.</p>
<p>The only way to achieve the correct result is by overriding the <code>__and__</code> method and writing your comparisons like this:</p>
<pre><code>def CompareList(list):
    ...
    def __and__(self, other):
        if isinstance(other, list):
            return CompareList(self[idx] and other[idx] for idx in range(len(self)))
        else:
            return CompareList(x and other for x in self)
</code></pre>
<p>Then, by writing in the form below, you'll get the correct answer:</p>
<pre><code>low = CompareList([1, 2])
high = CompareList([2, 2])
print((low &gt;= high) &amp; (high &gt;= low)) # returns CompareList([False, True])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should return a boolean value from your comparison methods.</p>
<p>To cite the <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow">documentation for "rich comparison" methods</a>:</p>
<blockquote>
<p>By convention, False and True are returned for a successful
  comparison. However, these methods can return any value, so if the
  comparison operator is used in a Boolean context (e.g., in the
  condition of an if statement), Python will call bool() on the value to
  determine if the result is true or false.</p>
</blockquote>
<p>To break it down for this case:</p>
<pre><code>exp1 = low &gt; high
print(exp1)
print(bool(exp1))
exp2 = high &gt; low
print(exp2)
print(bool(exp2))
</code></pre>
<p>Will give you </p>
<pre><code>CompareList([False])
True
CompareList([True])
True
</code></pre>
<p>Now we do the last operation and print out the result</p>
<pre><code>print(exp1 and exp2)
</code></pre>
<p>Because both values evaluate to <code>True</code> you'll get</p>
<pre><code>CompareList([True])
</code></pre>
</div>
<span class="comment-copy">Check out <code>functools.total_ordering</code> - if I recall correctly, you only need to supply one cmp eg <code>__eq__</code> and one ordering, eg <code>__lt__</code> and add <code>@functools.total_ordering</code> to the <b>class</b>, and it should fill in the rest for you.</span>
<span class="comment-copy">@dwanderson I remember reading Python would do the rest for you.</span>
<span class="comment-copy">That... is a surprisingly simple answer!</span>
<span class="comment-copy">Shouldn't it be "if <code>x</code> is falsy" with the code being either <code>if x</code> or <code>if bool(x) is False</code>? For example <code>'' and True</code> will return <code>''</code> despite <code>'' is not False</code>. Part of the issue here is that <code>bool(custom_object)</code> will return <code>True</code> unless <code>__nonzero__</code> is overridden, but filtering in the way OP intended is impossible, as noted in @iulian's answer.</span>
<span class="comment-copy"><code>'' and True</code> returns <code>''</code> because <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer"><code>bool('')</code></a> is <code>False</code>. so if you go by the logic <code>'' if '' is False else True</code> then <code>'' is False</code> evaluates to <code>True</code> and you get <code>''</code>.</span>
<span class="comment-copy">In the above case also, <code>CompareList</code> is already inheriting from builtin <code>list</code>. And according to <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer">docs</a> on evaluating the <code>bool(some_obj)</code>, _ if the <code>__bool__</code> is not defined then <code>__len__</code> will be called. Since it is a <code>list</code> and it has one element which is <code>False</code> it will always return the length 1 and hence will never evaluate to <code>False</code>.</span>
<span class="comment-copy">Not sure why this isn't higher up, very insightful, especially the PEP reference. I would note that <code>CompareList([False]) is False</code> should probably be changed to <code>bool(CompareList([False])) is False</code> since its truthiness is being checked, not its identity.</span>
<span class="comment-copy">@JaredGoguen Thank you! I've posted it 1 hour after other answers were posted, so that's why...</span>
<span class="comment-copy">I don't see how that has a relevance to the question of chaining comparisons. I'm aware that saying <code>if CompareList([True, False]):</code> doesn't make sense.</span>
<span class="comment-copy">I added some more explanations.</span>
