<div class="post-text" itemprop="text">
<p>I was wondering if some kind soul could explain why I have to convert a list that is already of type list before calling enumerate on it.</p>
<pre><code>&gt;&gt;&gt; l = ['russell', 'bird', 'thomas']
&gt;&gt;&gt; print(type(l))
Type is: `class 'list'`.
</code></pre>
<p>If I enumerate over this list without explicitly declaring it as such, this is the output: </p>
<pre><code>&gt;&gt;&gt; print(enumerate(l))
enumerate object at 0x00B1A0F8
</code></pre>
<p>When explicitly declaring this list as a list, the output is as expected:</p>
<pre><code>&gt;&gt;&gt; print(list(enumerate(l)))
[(0, 'russell'), (1, 'bird'), (2, 'thomas')]
</code></pre>
<p>If someone could help explain why this is the case, it'd be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two different objects here.  Let's say you define a function:</p>
<pre><code>def my_func(my_list):
    return 4
</code></pre>
<p>If you did <code>my_func(l)</code>, of course it wouldn't return a list.  Well, <code>enumerate()</code> is the same way.  It returns an <code>enumerate</code> object, not a list.  That object is iterable, however, so it can be converted to a list.  For example:</p>
<pre><code>def my_enumerate(my_list):
    index = 0
    for item in my_list:
        yield index, item
        index += 1
</code></pre>
<p>That is pretty much how <code>enumerate</code> works.  Our function is a generator function and returns a generator object.  Since generators are iterable, you can convert it to a list:</p>
<pre><code>print(list(my_enumerate(l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python docs tend to be pretty careful about saying what a function returns, and the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow">docs for <code>enumerate()</code></a> say that it returns an <em>enumerate object</em>, not a list. (Note that this was already the case in <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow">Python 2</a>.)</p>
<p>While it may seem like kind of a pain to have to create a fully-formed list explicitly, like</p>
<pre><code>print(list(enumerate(mylist)))
</code></pre>
<p>the advantage of <em>not</em> returning a list is that it can be quicker and use less memory. It is expected that in real-world use, you will generally not need the whole list at once, and will instead be looping over the elements one at a time, such as</p>
<pre><code>for i, elem in enumerate(mylist):
    print(i, '-&gt;', elem)
</code></pre>
<p>You might even not use all of the elements:</p>
<pre><code>mylist = ['russell', 'bird', 'thomas']
for i, elem in enumerate(mylist):
    if elem == 'bird':
        break
    print((i, elem))
</code></pre>
<p>So <code>enumerate()</code> gives you the efficiency of generating items only as needed instead of all at once. (Imagine if you were working with a list of every NBA player in history, not just the three in your example.) And on the rare occasions that you really do need all the items at once, it is not <em>that</em> annoying to have to type <code>list(enumerate(mylist))</code>.</p>
</div>
<span class="comment-copy">Where is this explicit declaration you're talking about? Python doesn't do that. Do you mean <code>list(enumerate(l))</code>? That isn't declaring <code>l</code> to be a list, it's producing a list object from the enumerate object which was created from the <code>l</code> list object.</span>
<span class="comment-copy">You expected the wrong output. <code>enumerate</code> isn't <i>supposed</i> to produce a list.</span>
<span class="comment-copy">Because an <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> object is an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer"><code>iterator</code></a> not a list, much like <code>iter(l)</code> is.</span>
<span class="comment-copy">reopening as it's no longer unclear</span>
