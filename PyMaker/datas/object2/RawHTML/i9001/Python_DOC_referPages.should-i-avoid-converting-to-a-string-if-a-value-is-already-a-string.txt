<div class="post-text" itemprop="text">
<p>Sometimes you have to use list comprehension to convert everything to string including strings themselves.</p>
<pre><code>b = [str(a) for a in l]
</code></pre>
<p>But do I have to do:</p>
<pre><code>b = [a if type(a)==str else str(a) for a in l]
</code></pre>
<p>I was wondering if <code>str</code> on a string is optimized enough to <em>not</em> create another copy of the string.</p>
<p>I have tried:</p>
<pre><code>&gt;&gt;&gt; x="aaaaaa"
&gt;&gt;&gt; str(x) is x
True
</code></pre>
<p>but that may be because Python can cache strings, and reuses them. But is that behaviour guaranteed for any value of a string?</p>
</div>
<div class="post-text" itemprop="text">
<p>Testing if an object is already a string is slower than just always converting to a string.</p>
<p>That's because the <code>str()</code> method also makes the exact same test (is the object already a string). You are a) doing double the work, and b) your test is slower to boot.</p>
<p>Note: for Python 2, using <code>str()</code> on <code>unicode</code> objects includes an implicit encode to ASCII, and this can fail. You may still have to special case handling of such objects. In Python 3, there is no need to worry about that edge-case.</p>
<p>As there is some discussion around this:</p>
<ul>
<li><code>isinstance(s, str)</code> has a  different meaning when <code>s</code> can be a <em>subclass</em> of <code>str</code>. As subclasses are treated exactly like any other type of object by <code>str()</code> (either <code>__str__</code> or <code>__repr__</code> is called on the object), this difference matters here.</li>
<li><p>You should use <code>type(s) is str</code> for exact type checks. Types are singletons, take advantage of this, <code>is</code> is faster:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("type(s) is str", "s = ''")
0.10074466899823165
&gt;&gt;&gt; timeit.timeit("type(s) == str", "s = ''")
0.1110201120027341
</code></pre></li>
<li><p>Using <code>s if type(s) is str else str(s)</code> is significantly slower for the <em>non-string case</em>:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("str(s)", "s = None")
0.1823573520014179
&gt;&gt;&gt; timeit.timeit("s if type(s) is str else str(s)", "s = None")
0.29589492800005246
&gt;&gt;&gt; timeit.timeit("str(s)", "s = ''")
0.11716728399915155
&gt;&gt;&gt; timeit.timeit("s if type(s) is str else str(s)", "s = ''")
0.12032335300318664
</code></pre>
<p>(The timings for the <code>s = ''</code> cases are very close and keep swapping places).</p></li>
</ul>
<p>All timings in this post were conducted on Python 3.6.0 on a Macbook Pro 15" (Mid 2015), OS X 10.12.3.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer"><i>For string objects, this is the string itself.</i></a> Looks like there should be no overhead.</span>
<span class="comment-copy">In Python 2 both snippets are not equivalent - <code>str(u"żółć")</code> raises <code>UnicodeEncodeError</code>.</span>
<span class="comment-copy">Note that checking the type using <code>type(a)==str</code> is not a good practice at all. Instead you should use <code>isinstance()</code> built-in function instead.</span>
<span class="comment-copy">@Kasramvd: unless you must test for the exact type, and not allow subclasses. In which case you should use <code>type(a) is str</code>, as it is faster. <code>str</code> is a singleton, you won't have two different types <code>str</code> lying around that this test both needs to produce <code>True</code> for.</span>
<span class="comment-copy">@MartijnPieters Yes Exactly.</span>
<span class="comment-copy">Can you please give a benchmark on short and large strings. Specially by checking the type using <code>isinstance()</code> function.</span>
<span class="comment-copy">Regarding (unlikely) Python 3 edge-cases: <a href="http://stackoverflow.com/a/38982099/6260170">stackoverflow.com/a/38982099/6260170</a></span>
<span class="comment-copy">@Chris_Rands: sure, you can break any dunder-method and thus anything that calls the method. <code>__str__</code> and <code>__repr__</code> are no exceptions there. :-) The implicit encode for <code>unicode</code> is part of the default implementation and thus needs calling out; as far as I am aware the Python 3 stdlib has no such edgecases.</span>
<span class="comment-copy">@Kasramvd I think the execution time is not related to the length of the string ;)</span>
<span class="comment-copy">@Kasramvd: at the very least use <code>type(s) is str</code>. <code>isinstance()</code> is one call, <code>type(s) == str</code> or <code>type(s) is str</code> is a call and an operator test, so you are asking the interpreter loop to do <i>more work</i>. <code>type(s)</code> is faster than <code>isinstance(s, str)</code>, it is the <code>== s</code> or <code>is s</code> that adds the extra time here, with <code>is s</code> being on-par, roughly. No, the string length has no bearing on either test.</span>
