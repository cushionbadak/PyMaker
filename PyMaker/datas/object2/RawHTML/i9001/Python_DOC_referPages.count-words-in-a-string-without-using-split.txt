<div class="post-text" itemprop="text">
<p>I have a problem on which I am working where I need to count the number of words in a string without using the <code>split()</code> function in Python.
I thought of an approach where I can take a variable <code>word=0</code> and increment it every time there's an empty space in the string, but it doesn't seems to work as it always gave a count less than the actual count.</p>
<pre><code>s="the sky is blue"

def countW(s):
    print(s)
    word=0
    for i in s:
        if i==" ":
            word=word+1
    print(word)
countW(s)
</code></pre>
<p>I know it's a simple question but I am struggling to understand what else I can keep into account to make sure I get the right count.
The second approach I was thinking of involves too much for loop and array creation and then back string conversion.
Can anyone point me to a simpler approach, where I don't increase the time complexity for this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Counting the number of spaces is a good approach and works most of the time. Of course you have to add 1 to get the correct number of words.</p>
<p>However, since you seem to be concerned about poorly formatted strings, you have to consider multiple whitespaces, whitespaces at the beginning and the end as well as punctuation.</p>
<p>If you do not want to use regular expressions (as in Ezsrac's answer), here is an alternative that considers combinations of characters, numbers and the underscore as word, just like <code>\w</code> does. It simply counts all transitions between word characters and non-word characters. The end requires special attention to consider non-word characters at the end (for example <code>"a a "</code> vs. <code>"a a"</code>).</p>
<pre><code>def is_word_character(c):
    return 'a' &lt;= c &lt;= 'z' or 'A' &lt;= c &lt;= 'Z' or '0' &lt;= c &lt;= '9' or c == '_'

def word_count(str):
    c = 0
    for i in range(1, len(str)):
        if not is_word_character(str[i]) and is_word_character(str[i-1]):
            c += 1
    if is_word_character(str[-1]):
        c += 1
    return c
</code></pre>
<p>Here are some test cases:</p>
<pre><code>&gt;&gt;&gt; word_count("the sky is blue")
4
&gt;&gt;&gt; word_count("the sky is blue.The")
5
&gt;&gt;&gt; word_count(" the sky is   blue ")
4
&gt;&gt;&gt; word_count(" the sky is   blue\nand not green ")
7
</code></pre>
<p>If you also want to include other characters you can simply extend the <code>is_word_character</code> function, but be aware that it is not possible to consider all corner cases without using very advanced techniques. For example, consider <code>"You are good-looking"</code> vs. <code>"This is good-looking into the sky"</code>. It is not possible for such a simple program to recognize that the first one is a compound adjective while the second one consists of two sentences which are poorly linked.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, grouping by whether the characters are alpha-numeric or not, and summing all the values (<code>True</code> equaling <code>1</code>).</p>
<pre><code>&gt;&gt;&gt; s = "the sky is blue"
&gt;&gt;&gt; sum(k for (k, g) in itertools.groupby(s, key=str.isalnum))
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest finite automata with states -  inside a word or outside. Pseudocode:</p>
<pre><code>InsideWord = false
Count = 0
for c in s
    if c is not letter
               InsideWord = false 
    else
         if not InsideWord
               Count++
               InsideWord = true
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you really don't want to use split you could try regex:</p>
<pre><code>import re
s= "the sky is blue"
count = len(re.findall(r'\w+', s))
print (count)
</code></pre>
</div>
<span class="comment-copy">def countW(s):     print(s)     word=0     for i in s:         if i==" ":             word=word+1     print(word) countW(s)</span>
<span class="comment-copy"><code>s.count(" ")+1</code> should do it.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1155617/count-occurrence-of-a-character-in-a-string">Count occurrence of a character in a string</a></span>
<span class="comment-copy">counting a string using split is ineffective because it creates a list. It's better to count spaces and add 1.</span>
<span class="comment-copy">If you are concerned about poorly formatted strings, wrong grammar etc. this question is clearly underspecified. In a general sense it is probably not even possible. For example consider: "You are good-looking" vs. "This is good-looking into the sky" How should the computer determine that the first one is a compound adjective while the second one consists of two sentences which are poorly linked?</span>
<span class="comment-copy">I tried that only but i am just wondering if it will fit all edge cases or if their's a better approach then this, avoiding use of Python direct functions like count() or split()</span>
<span class="comment-copy">@Faith lost Since you are concerned about edge cases, I added another solution</span>
<span class="comment-copy">well the code you mentioned will fail in a case where someone has entered a poorly formatted string. Ex: str="the sky is blue.The"</span>
<span class="comment-copy">You should surely refine your requirements in the question! What is a WORD for you?</span>
<span class="comment-copy">Keep in mind that a word can be separated by a slew of interpunction and whitespace characters so checking against space only is not really recommended. I'd create a set like <code>word_boundaries = set([" ", "\n", ".", ",", "!", ":"])</code> and then use if <code>if str[i] in word_boundaries...</code> to iron out the edge cases.</span>
<span class="comment-copy">hi thanks a lot regex one you mentioned is atleast passing the test case which direct space count fails. Ex -- s="the sky is blue.The" gives right answer of 5</span>
