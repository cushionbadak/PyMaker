<div class="post-text" itemprop="text">
<p>I have two arrays of 5 objects</p>
<blockquote>
<p>a = ['a', 'b', 'c', 'd', 'e', 'f', 'e', 'f']</p>
<p>b = ['a', 'b', 'd', 'f', 'e', 'f']</p>
</blockquote>
<p>I would like to identify the repeated patterns of more than one object and their occurrences like </p>
<blockquote>
<p>['a', 'b']: 2 </p>
<p>['e', 'f']: 3</p>
<p>['f', 'e', 'f']: 2</p>
</blockquote>
<p>The first sequence ['a', 'b'] appeared once in a and once in b, so total count 2. The 2nd sequence ['e', 'f'] appeared twice in a, once in b, so total 3. The 3rd sequence ['f', 'e', 'f'] appeared once in a, and once in b, so total 2. </p>
<p>Is there a good way to do this in Python?</p>
<p>Also the universe of objects is limited. Was wondering if there's an efficient solution that utilizes hash table?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the approach is only for two lists, the following approach should work. I am not sure if this is the most efficient solution though.</p>
<p>A nice description of find n-grams is given in <a href="http://locallyoptimal.com/blog/2013/01/20/elegant-n-gram-generation-in-python/" rel="nofollow noreferrer">this blog post</a>.</p>
<p>This approach provides the min length and determines the max length that a repeating sequence of a list might have (at most half the length of the list). </p>
<p>We then find all the sequences for each of the lists by combining the sequences for individual lists. Then we have a counter of every sequence and its count.</p>
<p>Finally we return a dictionary of all the sequences that occur more than once.</p>
<pre><code>def find_repeating(list_a, list_b):
    min_len = 2

    def find_ngrams(input_list, n):
        return zip(*[input_list[i:] for i in range(n)])

    seq_list_a = []
    for seq_len in range(min_len, len(list_a) + 1):
        seq_list_a += [val for val in find_ngrams(list_a, seq_len)]

    seq_list_b = []
    for seq_len in range(min_len, len(list_b) + 1):
        seq_list_b += [val for val in find_ngrams(list_b, seq_len)]

    all_sequences = seq_list_a + seq_list_b

    counter = {}
    for seq in all_sequences:
        counter[seq] = counter.get(seq, 0) + 1

    filtered_counter = {k: v for k, v in counter.items() if v &gt; 1}

    return filtered_counter
</code></pre>
<p>Do let me know if you are unsure about anything.</p>
<pre><code>&gt;&gt;&gt; list_a = ['a', 'b', 'c', 'd', 'e', 'f', 'e', 'f'] 
&gt;&gt;&gt; list_b = ['a', 'b', 'd', 'f', 'e', 'f']
&gt;&gt;&gt; print find_repeating(list_a, list_b)
{('f', 'e'): 2, ('e', 'f'): 3, ('f', 'e', 'f'): 2, ('a', 'b'): 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you mentioned that you were looking for an <em>efficient</em> solution, my first thought was of the approaches to solving the <a href="https://en.wikipedia.org/wiki/Longest_%E2%80%A6" rel="nofollow noreferrer">longest common subsequence problem</a>. But in your case, we actually do need to enumerate all common subsequences so that we can count them, so a dynamic programming solution will not do. Here's my solution. It's certainly shorter than SSSINISTER's solution (mostly because I use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> class).</p>
<pre><code>#!/usr/bin/env python3

def find_repeating(sequence_a, sequence_b, min_len=2):
    from collections import Counter

    # Find all subsequences
    subseq_a = [tuple(sequence_a[start:stop]) for start in range(len(sequence_a)-min_len+1) 
        for stop in range(start+min_len,len(sequence_a)+1)]
    subseq_b = [tuple(sequence_b[start:stop]) for start in range(len(sequence_b)-min_len+1) 
        for stop in range(start+min_len,len(sequence_b)+1)]

    # Find common subsequences
    common = set(tup for tup in subseq_a if tup in subseq_b)

    # Count common subsequences
    return Counter(tup for tup in (subseq_a + subseq_b) if tup in common)
</code></pre>
<p>Resulting in ...</p>
<pre><code>&gt;&gt;&gt; list_a = ['a', 'b', 'c', 'd', 'e', 'f', 'e', 'f'] 
&gt;&gt;&gt; list_b = ['a', 'b', 'd', 'f', 'e', 'f']
&gt;&gt;&gt; print(find_repeating(list_a, list_b))
Counter({('e', 'f'): 3, ('f', 'e'): 2, ('a', 'b'): 2, ('f', 'e', 'f'): 2})
</code></pre>
<p>The advantage to using <code>collections.Counter</code> is that not only do you not need to produce the actual code to iterate and count, you get access to all of the <code>dict</code> methods as well as a few specialized methods for using those counts.</p>
</div>
<span class="comment-copy">What is the actual problem you are trying to solve? Please review <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>: What types of objects, what the pattern of objects in these lists accomplishes.</span>
<span class="comment-copy">Thanks! I think you need to cast the max_len_a and max_len_b to integer right?</span>
<span class="comment-copy">Ah yes, thanks I ll fix that up.</span>
<span class="comment-copy">how would you modify this if I'm looking for the longest overlapping pattern? E.g. ('f', 'e', 'f') covers ('f', 'e') and ('e', 'f'). So if i expect the answer to be like {('e', 'f'): 1, ('f', 'e', 'f'): 2, ('a', 'b'): 2}, how should i modify the code?</span>
<span class="comment-copy">Counter example to the above code: <code>list_a = ['a','b','c','d','e','f','a']</code> <code>list_b = ['a','b','c','d','e','f','b']</code>. The common subsequence should be <code>abcdef</code>. However the code above limits search space to <code>int(len(list_a)/2)</code> and <code>int(len(list_b)/2)</code>, causing it to produce 9 subsequences total, and 4 longest subsequences of length 3 (<code>abc</code>, 'bcd<code>, </code>cde` and <code>def</code>).  It appears that this code fragment does not answer the question.</span>
<span class="comment-copy">@MatthewCole - Thanks for pointing out the error in my search space, changing <code>int(len(list_a)/2)</code> to <code>len(list_a)</code> solves that issue however. The edited code fragment does answer the question. @IanLin - I ll look into the problem and edit the fragment accordingly.</span>
