<div class="post-text" itemprop="text">
<p>I am searching for the most efficient tree search implementation in python.
I give the tree search a sequence of length n and it should detect if the branches are already created, or if this is not the case, generate the branches.</p>
<p>Example:</p>
<p><strong>i1:</strong> Sequence 1[0.89,0.43,0.28]</p>
<pre><code>      0.89   check
       |
      0.43   check
       |
      0.28   check(last branch, last number of sequence == found)
</code></pre>
<p><strong>i2:</strong> Sequence 2[0.89,0.43,0.99]</p>
<pre><code>      0.89   check
       |
      0.43   check
       |                                           |
      0.28   missing(Creating new branch)         0.99
</code></pre>
<p><strong>Considering the order within the sequences is important.</strong></p>
<p>The goal is to keep track of a huge range of sequence (seen, unseen).</p>
<p>Has anyone ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use an infinitely nested <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> for this. The following function will create a <code>defaultdict</code>, that whenever the requested value is not present will call the same function again, creating another <code>defaultdict</code>, ad infinitum.</p>
<pre><code>import collections
nested = lambda: collections.defaultdict(nested)
dic = nested()
</code></pre>
<p>Now, you can add the sequences to the nested defaultdict. You can do this in a loop, or recursively, or simply use <code>reduce</code>:</p>
<pre><code>s1 = [0.89,0.43,0.28]
s2 = [0.89,0.43,0.99]

from functools import reduce # Python 3
reduce(lambda d, x: d[x], s1, dic)
reduce(lambda d, x: d[x], s2, dic)
</code></pre>
<p>Afterwards, <code>dic</code> looks like this: (Actually, it looks a bit different, but that's only because of <code>defaultdict</code> also printing the function it was created with.)</p>
<pre><code>{0.89: {0.43: {0.28: {}, 0.99: {}}}}
</code></pre>
<hr/>
<p>If by "the order of the sequences is important" you mean the order in which the sequences are added, and not the order <em>within</em> the sequences, you will have to use a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> instead. In this case, the adding of new elements is a bit more involved, but not by much.</p>
<pre><code>dic = collections.OrderedDict()

def putall(d, s):
    for x in s:
        if x not in d:
            d[x] = collections.OrderedDict()
        d = d[x]

putall(dic, s1)
putall(dic, s2)
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3.5/library/heapq.html" rel="nofollow noreferrer">heapq</a> may be helpful. It works on ordered lists to implement a binary tree.</span>
<span class="comment-copy">Hi Tobias, nice solution. How can I see if a new defaultdict was created because of a input sequence that had new values in it? And how can I delete existing defaultdicts?</span>
<span class="comment-copy">@abcdef123e Using a defaultdict, you can't really find out (aside from an in-depth-comparison of the states before and after the update). But using the second method, you could easily set a <code>bool</code> flag to <code>True</code> when the <code>if x not in d</code> branch was executed and return it at the end. About deleting elements/branches: <code>del dic[a][b][c]</code> should work fine.</span>
<span class="comment-copy">The OrderedDict solution would be very nice if it would consider the order within the sequences. I need something like this but with the ability to keep track of the order of the sequences so that the function is able to say "I've seen exactly this sequence x times before.". Does anyone has an idea on how to accomplish this?</span>
<span class="comment-copy">@abcdef123e It <i>does</i> keep track of the order within the sequence. The first element is a key in the top-level dict, the second in the dict that is the value to that key, and so on.</span>
