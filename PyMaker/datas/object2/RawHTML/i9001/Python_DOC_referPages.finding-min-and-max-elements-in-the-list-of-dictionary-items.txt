<div class="post-text" itemprop="text">
<p>I have a list of elements stored in a dictionary format</p>
<p>for e.g.</p>
<pre><code>input_list = [ {'item1': 2, 'item2': 4, 'item3': 3, 'item4': 5, 'item5': 1, 'item6': 2, 'item7': 2, 'item8': 1, 'item9': 2, 'item10': 5, 'item11': 1, 'item12': 2},
  {'item1': 4, 'item2': 1, 'item3': 6, 'item4': 2, 'item5': 11, 'item6': 3, 'item7': 4, 'item8': 6, 'item9': 1, 'item10': 5, 'item11': 1, 'item12': 3}]
</code></pre>
<p>I have around 150 elements in the input_list and I need to create two output lists ( output_list_max and output_list_min ) which should have elements as the dictionary with the items (i.e. item1, item2..etc) as key and the max/min values ( w.r.t. to entries in input_list) for each item as values.</p>
<p>For.e.g</p>
<pre><code>output_list_max = [{'item1': 4, 'item2': 4, 'item3': 6, 'item4': 5, 'item5': 11, 'item6': 3, 'item7': 4, 'item8': 6, 'item9': 2, 'item10': 5, 'item11': 1, 'item12': 3}]

output_list_min = [{'item1': 2, 'item2': 1, 'item3': 3, 'item4': 2, 'item5': 1, 'item6': 2, 'item7': 2, 'item8': 1, 'item9': 1, 'item10': 5, 'item11': 1, 'item12': 2}]
</code></pre>
<p>I can do this by iterating through the list and dictionaries but I want to know the most efficient and pythonic way to do so as the list and the dictionary can be up to 1000.</p>
<p>I hope I was able to clear my intentions :)</p>
<p>Any help will be appreciated thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> and use the <code>&amp;</code> (element-wise minimum) and <code>|</code> (element-wise maximum) on them by using <a href="https://docs.python.org/3/library/functools.html?highlight=functools.reduce#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a>:</p>
<pre><code>from functools import reduce
from collections import Counter

output_list_max = dict(reduce(lambda x,y:x|y,map(Counter,input_list)))
output_list_min = dict(reduce(lambda x,y:x&amp;y,map(Counter,input_list)))
</code></pre>
<p>In the repl:</p>
<pre><code>&gt;&gt;&gt; output_list_max
{'item4': 5, 'item10': 5, 'item3': 6, 'item9': 2, 'item8': 6, 'item2': 4, 'item12': 3, 'item7': 4, 'item6': 3, 'item11': 1, 'item1': 4, 'item5': 11}
&gt;&gt;&gt; output_list_min
{'item4': 2, 'item10': 5, 'item3': 3, 'item9': 1, 'item8': 1, 'item2': 1, 'item12': 2, 'item7': 2, 'item6': 2, 'item11': 1, 'item1': 2, 'item5': 1}
</code></pre>
<p>Note that the result is a dictionary and <strong>not</strong> a list containing a single dictionary, but it is rather useless to put the result in a list.</p>
<p>This works because we first use <code>map</code> to convert the list of dictionaries to a list of <code>Counter</code>s. This is done by using <code>map(Counter,input_list)</code>.</p>
<p>Next <code>reduce(..)</code> is used (in some functional languages, this is called <code>fold</code>). If you feed <code>reduce(..)</code> a list of elements <code>[x1,x2,...,xn]</code> with function <code>f</code>, it returns <code>f(...f(f(x1,x2),x3)...,xn)</code>. In this case we thus calculate (for the first element <code>x1|x2|x3|...|xn</code>). Since <code>|</code> is the elementwise maximum, we thus have an accumulator (a counter that holds the maximums thus far) and for each new dictionary, we calculate the new maximums. This result is returned by <code>reduce</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>zip()</code> with <code>sorted()</code> to pair up your dictionary items:</p>
<pre><code>lst = list(zip(*[sorted(d.items()) for d in input_list]))

dict(max(item) for item in lst)
# {'item9': 2, 'item4': 5, 'item5': 11, 'item11': 1, 'item2': 4, 'item1': 4, 'item10': 5, 'item6': 3, 'item3': 6, 'item12': 3, 'item7': 4, 'item8': 6}

dict(min(item) for item in lst)
# {'item9': 1, 'item4': 2, 'item5': 1, 'item11': 1, 'item2': 1, 'item1': 2, 'item10': 5, 'item6': 2, 'item3': 3, 'item12': 2, 'item7': 2, 'item8': 1}
</code></pre>
</div>
<span class="comment-copy">So you want the <i>element-wise</i> minimum and maximum?</span>
<span class="comment-copy">What if a key is missing in one of the dictionaries? Like <code>[{'a':1,'b':2},{'a':3}]</code>?</span>
<span class="comment-copy">yes, exactly. element-wise max and min</span>
<span class="comment-copy">Key won't be missing as it's a generated data and the keys will be always same for all entries in the list.</span>
<span class="comment-copy">Does your data <i>have</i> to come in as a list of dicts?</span>
<span class="comment-copy">I'm willing to be proven wrong, but in a quick <code>timeit</code> test this ran about 5 times more slowly than just iterating over all the dicts. (Maybe I need to add more dicts in?)</span>
<span class="comment-copy">You are great! :) It works perfectly! Thanks! could explain how it works, if possible.</span>
<span class="comment-copy">@glibdud: what do you mean with iterating over the dictionaries? Since you are doing calculations of course it will be slower than simply iterating and doing nothing.</span>
<span class="comment-copy">This is pretty clever, but I also find it unreadable</span>
<span class="comment-copy">@WillemVanOnsem I mean iterating over the dict while keeping a running pair of dicts for the <code>min</code> and <code>max</code> of each key.</span>
<span class="comment-copy">+1 While Willem's is interesting and clever, this is easier to understand and appears to be several times faster in a quick <code>timeit</code> test.</span>
