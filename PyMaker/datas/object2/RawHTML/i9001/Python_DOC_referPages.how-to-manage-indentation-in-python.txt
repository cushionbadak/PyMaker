<div class="post-text" itemprop="text">
<p>I have a dictionary of lists and the lists are quite long. How can I print it in a way that only a few elements of the list show up? Obviously, I can write a custom function for that but is there any built-in way or library that can achieve this? For example when printing large data frames, <code>pandas</code> prints it nicely in a short way.   </p>
<p>This example better illustrates what I mean:</p>
<pre><code>obj = {'key_1': ['EG8XYD9FVN',
  'S2WARDCVAO',
  'J00YCU55DP',
  'R07BUIF2F7',
  'VGPS1JD0UM',
  'WL3TWSDP8E',
  'LD8QY7DMJ3',
  'J36U3Z9KOQ',
  'KU2FUGYB2U',
  'JF3RQ315BY'],
 'key_2': ['162LO154PM',
  '3ROAV881V2',
  'I4T79LP18J',
  'WBD36EM6QL',
  'DEIODVQU46',
  'KWSJA5WDKQ',
  'WX9SVRFO0G',
  '6UN63WU64G',
  '3Z89U7XM60',
  '167CYON6YN']}
</code></pre>
<p>Desired output: something like this:</p>
<pre><code>{'key_1':
    ['EG8XYD9FVN', 'S2WARDCVAO', '...'],
 'key_2':
    ['162LO154PM', '3ROAV881V2', '...']
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it weren't for the pretty printing, the <a href="https://docs.python.org/3/library/reprlib.html" rel="nofollow"><code>reprlib</code></a> module would be the way to go: Safe, elegant and customizable handling of deeply nested and recursive / self-referencing data structures is what it has been made for.</p>
<p>However, it turns out combining the <a href="https://docs.python.org/3/library/reprlib.html" rel="nofollow"><code>reprlib</code></a> and <a href="https://docs.python.org/2/library/pprint.html" rel="nofollow"><code>pprint</code></a> modules isn't trivial, at least I couldn't come up with a clean way without breaking (some) of the pretty printing aspects.</p>
<p>So instead, here's a solution that just subclasses <a href="https://hg.python.org/cpython/file/2.7/Lib/pprint.py#l84" rel="nofollow"><code>PrettyPrinter</code></a> to crop / abbreviate lists as necessary:</p>
<pre><code>from pprint import PrettyPrinter


obj = {
    'key_1': [
        'EG8XYD9FVN', 'S2WARDCVAO', 'J00YCU55DP', 'R07BUIF2F7', 'VGPS1JD0UM',
        'WL3TWSDP8E', 'LD8QY7DMJ3', 'J36U3Z9KOQ', 'KU2FUGYB2U', 'JF3RQ315BY',
    ],
    'key_2': [
        '162LO154PM', '3ROAV881V2', 'I4T79LP18J', 'WBD36EM6QL', 'DEIODVQU46',
        'KWSJA5WDKQ', 'WX9SVRFO0G', '6UN63WU64G', '3Z89U7XM60', '167CYON6YN',
    ],
    # Test case to make sure we didn't break handling of recursive structures
    'key_3': [
        '162LO154PM', '3ROAV881V2', [1, 2, ['a', 'b', 'c'], 3, 4, 5, 6, 7],
        'KWSJA5WDKQ', 'WX9SVRFO0G', '6UN63WU64G', '3Z89U7XM60', '167CYON6YN',
    ]
}


class CroppingPrettyPrinter(PrettyPrinter):

    def __init__(self, *args, **kwargs):
        self.maxlist = kwargs.pop('maxlist', 6)
        return PrettyPrinter.__init__(self, *args, **kwargs)

    def _format(self, obj, stream, indent, allowance, context, level):
        if isinstance(obj, list):
            # If object is a list, crop a copy of it according to self.maxlist
            # and append an ellipsis
            if len(obj) &gt; self.maxlist:
                cropped_obj = obj[:self.maxlist] + ['...']
                return PrettyPrinter._format(
                    self, cropped_obj, stream, indent,
                    allowance, context, level)

        # Let the original implementation handle anything else
        # Note: No use of super() because PrettyPrinter is an old-style class
        return PrettyPrinter._format(
            self, obj, stream, indent, allowance, context, level)


p = CroppingPrettyPrinter(maxlist=3)
p.pprint(obj)
</code></pre>
<hr/>
<p>Output with <code>maxlist=3</code>:</p>
<pre><code>{'key_1': ['EG8XYD9FVN', 'S2WARDCVAO', 'J00YCU55DP', '...'],
 'key_2': ['162LO154PM',
           '3ROAV881V2',
           [1, 2, ['a', 'b', 'c'], '...'],
           '...']}
</code></pre>
<p>Output with <code>maxlist=5</code> (triggers splitting the lists on separate lines):</p>
<pre><code>{'key_1': ['EG8XYD9FVN',
           'S2WARDCVAO',
           'J00YCU55DP',
           'R07BUIF2F7',
           'VGPS1JD0UM',
           '...'],
 'key_2': ['162LO154PM',
           '3ROAV881V2',
           'I4T79LP18J',
           'WBD36EM6QL',
           'DEIODVQU46',
           '...'],
 'key_3': ['162LO154PM',
           '3ROAV881V2',
           [1, 2, ['a', 'b', 'c'], 3, 4, '...'],
           'KWSJA5WDKQ',
           'WX9SVRFO0G',
           '...']}
</code></pre>
<hr/>
<p>Notes:</p>
<ul>
<li>This will create <strong>copies</strong> of lists. Depending on the size of the data structures, this can be very expensive in terms of memory use. </li>
<li>This only deals with the special case of <strong>lists</strong>. Equivalent behavior would have to be implemented for dicts, tuples, sets, frozensets, ... for this class to be of general use. </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> module:</p>
<pre><code>pprint.pprint(obj)
</code></pre>
<p>Would output:</p>
<pre><code>{'key_1': ['EG8XYD9FVN',
           'S2WARDCVAO',
           'J00YCU55DP',
           'R07BUIF2F7',
           'VGPS1JD0UM',
           'WL3TWSDP8E',
           'LD8QY7DMJ3',
           'J36U3Z9KOQ',
           'KU2FUGYB2U',
           'JF3RQ315BY'],
 'key_2': ['162LO154PM',
           '3ROAV881V2',
           'I4T79LP18J',
           'WBD36EM6QL',
           'DEIODVQU46',
           'KWSJA5WDKQ',
           'WX9SVRFO0G',
           '6UN63WU64G',
           '3Z89U7XM60',
           '167CYON6YN']}
</code></pre>
<p>And,</p>
<pre><code>pprint.pprint(obj,depth=1)
</code></pre>
<p>Would output:</p>
<pre><code>{'key_1': [...], 'key_2': [...]}
</code></pre>
<p>And, </p>
<pre><code>pprint.pprint(obj,compact=True)
</code></pre>
<p>would output:</p>
<pre><code>{'key_1': ['EG8XYD9FVN', 'S2WARDCVAO', 'J00YCU55DP', 'R07BUIF2F7',
           'VGPS1JD0UM', 'WL3TWSDP8E', 'LD8QY7DMJ3', 'J36U3Z9KOQ',
           'KU2FUGYB2U', 'JF3RQ315BY'],
 'key_2': ['162LO154PM', '3ROAV881V2', 'I4T79LP18J', 'WBD36EM6QL',
           'DEIODVQU46', 'KWSJA5WDKQ', 'WX9SVRFO0G', '6UN63WU64G',
           '3Z89U7XM60', '167CYON6YN']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.pretty.html" rel="nofollow noreferrer">IPython.lib.pretty</a>.</p>
<pre><code>from IPython.lib.pretty import pprint

&gt; pprint(obj, max_seq_length=5)
{'key_1': ['EG8XYD9FVN',
  'S2WARDCVAO',
  'J00YCU55DP',
  'R07BUIF2F7',
  'VGPS1JD0UM',
  ...],
 'key_2': ['162LO154PM',
  '3ROAV881V2',
  'I4T79LP18J',
  'WBD36EM6QL',
  'DEIODVQU46',
  ...]}

&gt; pprint(dict(map(lambda i: (i, range(i + 5)), range(100))), max_seq_length=10)
{0: [0, 1, 2, 3, 4],
 1: [0, 1, 2, 3, 4, 5],
 2: [0, 1, 2, 3, 4, 5, 6],
 3: [0, 1, 2, 3, 4, 5, 6, 7],
 4: [0, 1, 2, 3, 4, 5, 6, 7, 8],
 5: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
 6: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...],
 7: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...],
 8: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...],
 9: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...],
 ...}
</code></pre>
<hr/>
<p>For older versions of IPython, you might exploit <a href="https://github.com/ipython/ipython/blob/master/IPython/lib/pretty.py" rel="nofollow noreferrer">RepresentationPrinter</a>:</p>
<pre><code>from IPython.lib.pretty import RepresentationPrinter
import sys

def compact_pprint(obj, max_seq_length=10):
    printer = RepresentationPrinter(sys.stdout)
    printer.max_seq_length = max_seq_length
    printer.pretty(obj)
    printer.flush()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This recursive function I wrote does something you're asking for.. You can choose the indentation you want too</p>
<pre><code>def pretty(d, indent=0):
    for key in sorted(d.keys()):
        print '\t' * indent + str(key)
        if isinstance(d[key], dict):
            pretty(d[key], indent+1)
        else:
            print '\t' * (indent+1) + str(d[key])
</code></pre>
<p>The output of your dictionary is:</p>
<pre><code>key_1
    ['EG8XYD9FVN', 'S2WARDCVAO', 'J00YCU55DP', 'R07BUIF2F7', 'VGPS1JD0UM', 'WL3TWSDP8E', 'LD8QY7DMJ3', 'J36U3Z9KOQ', 'KU2FUGYB2U', 'JF3RQ315BY']
key_2
    ['162LO154PM', '3ROAV881V2', 'I4T79LP18J', 'WBD36EM6QL', 'DEIODVQU46', 'KWSJA5WDKQ', 'WX9SVRFO0G', '6UN63WU64G', '3Z89U7XM60', '167CYON6YN']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/reprlib.html" rel="nofollow">reprlib</a>. The formatting is not that pretty, but it actually abbreviates.</p>
<pre><code>&gt; import repr
&gt; repr.repr(map(lambda _: range(100000), range(10)))
'[[0, 1, 2, 3, 4, 5, ...], [0, 1, 2, 3, 4, 5, ...], [0, 1, 2, 3, 4, 5, ...], [0, 1, 2, 3, 4, 5, ...], [0, 1, 2, 3, 4, 5, ...], [0, 1, 2, 3, 4, 5, ...], ...]'
&gt; repr.repr(dict(map(lambda i: (i, range(100000)), range(10))))
'{0: [0, 1, 2, 3, 4, 5, ...], 1: [0, 1, 2, 3, 4, 5, ...], 2: [0, 1, 2, 3, 4, 5, ...], 3: [0, 1, 2, 3, 4, 5, ...], ...}'
</code></pre>
</div>
<span class="comment-copy">You may also want to take a look at the <a href="https://docs.python.org/2/library/repr.html" rel="nofollow noreferrer"><code>repr</code> module</a> (<code>reprlib</code> in Py3), particularly the <code>maxlist</code> setting: <code>rep = Repr(); rep.maxlist = 3; print rep.repr(obj)</code> Now combining that with <code>pprint</code> is the real challenge.</span>
<span class="comment-copy">Awesome! This is the best answer and exactly what I needed. Could you add as answer? @LukasGraf</span>
<span class="comment-copy">It seems Michael Hoff is already working on a reprlib answer, so I just upvoted that :)</span>
<span class="comment-copy">That doesn't abbreviate! Instantiating the <code>Repr</code> class and setting <code>maxlist</code> is the key!</span>
<span class="comment-copy">It does, it's just that the default of <code>maxlist</code> is <code>6</code>, so it's less obvious. Also note that <code>__builtins__.repr()</code> is not the same as <code>repr.repr()</code> (yeah, the naming really isn't helping in Python 2.x).</span>
<span class="comment-copy">Funny, I had a similar prototype. But I disliked the steps you had to undertake to implement the truncation of dictionaries. +1 for the effort!</span>
<span class="comment-copy"><code>pprint.pprint(obj,depth=1)</code> is the closest thing to what I need. I guess there is not a built in way to print only the first element of the list and then put <code>...</code> for the rest. like <code>{'key_': ['EG8XYD9FVN', ...]</code></span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">Probably because there are some jerks on the internet</span>
<span class="comment-copy">If you change the last line to <code>print '\t' * (indent+1) + str(d[key][:2]) + '...'</code> it would be similar to what I mean. Don't want the entire list</span>
<span class="comment-copy">Oh gotcha, I thought you wrote ... because you didn't wanna write the whole thing out again, my misunderstanding!</span>
<span class="comment-copy">Yep. The "abbreviation" part, or dealing with recursive / self referencing structures is exactly what it was made for. Unfortunately it's not obvious how to combine it with pretty printing (newlines, indentation, ...).</span>
