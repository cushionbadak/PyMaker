<div class="post-text" itemprop="text">
<p>I am trying to add the values of a dictionary of the same key(s). In my example below, I strip off the version numbering for each keys while trying to add the values of the 'same' key.</p>
<pre><code>item_dict = {
"item_C_v001" : 100,
"item_C_v002" : 100,
"item_A_v001" : 50,
"item_B_v001" : 75
}
</code></pre>
<p>My expected output should be:</p>
<pre><code>"item_C_v" : 200,
"item_A_v" : 50,
"item_B_v" : 75
</code></pre>
<p>but instead I got the following if I tried printing <code>item_dict</code>:</p>
<pre><code>"item_C_v" : 100,
"item_A_v" : 50,
"item_B_v" : 75
</code></pre>
<p>But the moment I tried to strip off, it seems that <code>item_C_v</code> is read once. How can I make it read 'twice' so that I can get <code>200</code> as the output for it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict(int)</code></a> to group and sum the result by a desired part of a key which you can get with, for example, a regular expression. Something along these lines:</p>
<pre><code>In [1]: from collections import defaultdict

In [2]: import re

In [3]: item_dict = {
   ...: "item_C_v001" : 100,
   ...: "item_C_v002" : 100,
   ...: "item_A_v001" : 50,
   ...: "item_B_v001" : 75
   ...: }

In [4]: result = defaultdict(int)

In [5]: for key, value in item_dict.items():
   ...:     result[re.search(r"(\w+?)\d+", key).group(1)] += value   

In [6]: dict(result)
Out[6]: {'item_A_v': 50, 'item_B_v': 75, 'item_C_v': 200}
</code></pre>
<hr/>
<p>You can approach extracting the desired part of a key differently - with the <a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow noreferrer"><code>str.partition()</code></a>:</p>
<pre><code>&gt;&gt;&gt; key = "item_C_v001"
&gt;&gt;&gt; "".join(key.partition("_v")[:-1])
'item_C_v'
</code></pre>
<p>Or, simply via slicing, if the length of the substring before the digits or the number of digits at the end of the string is constant:</p>
<pre><code>&gt;&gt;&gt; key = "item_C_v001"
&gt;&gt;&gt; key[:8]
'item_C_v'
&gt;&gt;&gt; key[:-3]
'item_C_v'
</code></pre>
<p>Or, by right-stripping the digits:</p>
<pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; key.rstrip(string.digits)
'item_C_v'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could iterate the original dictionary and append to the new dictionary the new keys, if the key already exists, add the current value to the original value.</p>
<pre><code>item_dict = {
"item_C_v001" : 100,
"item_C_v002" : 100,
"item_A_v001" : 50,
"item_B_v001" : 75
}

new_dict = {}

for k, v in item_dict.items():
    k_new = k[:-3]
    new_dict[k_new] = new_dict[k_new] + v if k_new in new_dict.keys() else v

print (new_dict)

&gt;&gt;&gt; {'item_A_v': 50, 'item_C_v': 200, 'item_B_v': 75}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby()</code> to collect all the similar keys and then construct a new dictionary summing up all the group values, e.g.:</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; {gk: sum(item_dict[k] for k in g) for gk, g in it.groupby(item_dict, lambda k: k[:-3])}
{'item_A_v': 50, 'item_B_v': 75, 'item_C_v': 200}
</code></pre>
<p>@alecxe describes several methods to getting the desired part of the key, above uses <code>key[-3]</code>.</p>
<p>There was a request to get both the <code>count</code> and <code>sum</code>, which you could implement in a simple loop and manage a counter but here's one way of doing it:</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; {key: deque(enumerate(it.accumulate(item_dict[k] for k in g), 1), maxlen=1).pop()
...     for key, g in it.groupby(item_dict, lambda key: key[:-3])}
{'item_A_v': (1, 50), 'item_B_v': (1, 75), 'item_C_v': (2, 200)}
</code></pre>
</div>
<span class="comment-copy">Cool, was not aware of using <code>string</code> module. Perhaps I am trying to reduce the use of any modules. Same goes for <code>partition</code>. Will try incorporating the use of <code>defaultdict</code> since I had that module. Just that I am not very strong in using regex</span>
<span class="comment-copy">Is there anyway that I can further refine <code>new_dict[k_new]</code> such that no '+' is used? Just curious about that. This may be a side question but how can I output in my code that <code>item_C_v</code> has been combined twice?</span>
<span class="comment-copy">You can replace it with <code>new_dict[k_new] = new_dict.get(k_new, 0) + v</code>, using <code>get()</code> allows you to provide a default value. Or you can use <code>defaultdict(int)</code> and then the line would read <code>new_dict[k_new] += v</code></span>
