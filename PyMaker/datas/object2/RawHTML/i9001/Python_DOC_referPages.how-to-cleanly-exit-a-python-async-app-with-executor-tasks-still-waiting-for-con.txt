<div class="post-text" itemprop="text">
<p>I'm trying to add a console input listener to an async app, and I've hit an interesting problem.</p>
<p>The following code doesn't terminate when it should, and instead continues waiting for input after the script has terminated:</p>
<pre><code>import asyncio


loop = asyncio.get_event_loop()

async def quit_after(timeout):
    await asyncio.sleep(timeout)
    print('main function terminating now') # this could simulate a crash, or a proper exit

async def print_input_loop():
    while True:
        # executor thread is daemon - should terminate when script ends, but doesn't
        text = await loop.run_in_executor(None, input, '&gt; ')
        print(text)

if __name__ == '__main__':
    loop.create_task(print_input_loop())

    try:
        loop.run_until_complete(quit_after(5))
    finally:
        loop.close()

    print('reached end of file - script should now terminate')
</code></pre>
<p>I've looked into other methods for getting input asynchronously, such as using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.add_reader" rel="nofollow noreferrer">add_reader()</a> on <a href="https://docs.python.org/3.6/library/sys.html#sys.stdin" rel="nofollow noreferrer">sys.stdin</a>, but this doesn't work on Windows, and I need my solution to be platform independent.</p>
<p>Does anyone know either a better way to get console input asynchronously that will gracefully halt when the app halts, or a way to fix my existing code so that it cleanly exits?</p>
</div>
<div class="post-text" itemprop="text">
<p>A possible workaround is to disable the <a href="https://github.com/python/cpython/blob/master/Lib/concurrent/futures/thread.py#L32" rel="nofollow noreferrer">exit function</a> for threads in <a href="https://docs.python.org/dev/library/concurrent.futures.html#concurrent.futures" rel="nofollow noreferrer">concurrent.futures</a>:</p>
<pre><code>def disable_exit_for_threadpool_executor():
    import atexit
    import concurrent.futures
    atexit.unregister(concurrent.futures.thread._python_exit)
</code></pre>
<p>Also, <a href="https://github.com/vxgmichel/aioconsole" rel="nofollow noreferrer">aioconsole</a> provides a cross-platform function for handling console input in asyncio:</p>
<pre><code>import aioconsole

async def echo_loop():
    while True:
        text = await aioconsole.ainput('&gt; ')
        print(text.strip())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although <a href="https://stackoverflow.com/a/42294554/57952">Vincent's answer above</a> does solve your problem, I would like to suggest trying not to use <code>input()</code> when building <code>asyncio</code> programs.</p>
<p>Instead, use a socket (or a signal) to supply input to your coroutines.</p>
<p>i.e., instead of:</p>
<pre><code>$ ./myprogram.py
&gt; command
&gt; command
&gt; command
</code></pre>
<p>Do:</p>
<pre><code>$ ./myprogram.py
myprogram listens on port 9876

$ # from a different terminal:
$ telnet localhost 9876
Connected!
&gt; command
&gt; command
&gt; command
</code></pre>
</div>
<span class="comment-copy">Try calling os's private exit: os._exit(0) . I wouldn't call that 'clean exit', tho.</span>
<span class="comment-copy">That works well, but I agree that it's not clean - I'll use that if no better options come along, thanks!</span>
<span class="comment-copy">Fantastic, these both work really well - to keep dependencies down I'm going to go for the first option, but I will definitely keep aioconsole in mind for future projects. Thank you!</span>
<span class="comment-copy">@Lev Cool! Note that the workaround is still needed if you use aioconcole on windows.</span>
<span class="comment-copy">This seems to be the accepted "best" way to do this, but it seems... wasteful to make an app listen through sockets when its only input will be coming from the same machine. I'll look into this too, but it seems like a lot of extra complexity for something as simple as console input.</span>
<span class="comment-copy">Console <code>input()</code> is a synchronous I/O operation, which does not fit an asynchronous I/O program.</span>
