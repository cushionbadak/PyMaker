<div class="post-text" itemprop="text">
<p>I am trying to create a window that has an optionmenu that is populated based on a fileselection dialog. I am able to make the optionmenu contain all options based on a previously selected file. However, no matter what option is selected by the user, the variable contains the last option that was read from the selected file.</p>
<p>I would love if someone can explain me why this happens. Therefore, I have included a minimal example below:</p>
<pre><code>from Tkinter import *
Tk()

class App():

    chunks = ['A','B','C'] # These are read from a file in the actual program
    testVariable = StringVar()

    def __init__(self,master):

        def initSummary():
            self.dataButton["menu"].delete(0, 'end')
            for i in self.chunks:
                print i # To demonstrate what's in there
                self.dataButton["menu"].add_command(label=i, command = lambda: self.testVariable.set(i))

        top = self.top = Toplevel()
        top.protocol("WM_DELETE_WINDOW", lambda: close(self))
        self.sumButton = Button(top, text="Test", width=25, command=lambda: initSummary())
        self.sumButton.grid(row=0, column=0, sticky=W)
        self.dataButton = OptionMenu(top, self.testVariable, "Stuff")
        self.dataButton.grid(row=0, column=1, sticky=W)

# Call the main app
root = Tk()
app = App(root)
root.mainloop()
</code></pre>
<p>This code will show <code>C</code> on the optionmenu, regardless of what the user has selected, while the <code>print</code> in the code produces the expected <code>A</code>, <code>B</code> and <code>C</code>. I would understand if the <code>print</code> also showed 3 times <code>C</code> but the mismatch of what is printed and what is shown in the GUI is throwing me off.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have fixed the issue of the lambda in a for loop (thanks to @j_4321) by adding an intermediate function as shown in the below code.</p>
<pre><code>from Tkinter import *

class App():

    chunks = ['A','B','C']

    def __init__(self,master):

        self.testVariable = StringVar()

        def refresh():
            # Prints what's in the variable
            print self.testVariable.get()

        def testFunc(x):
            return lambda: self.testVariable.set(x)

        def initSummary():
            self.dataButton["menu"].delete(0, 'end')
            for i in self.chunks:
                self.dataButton["menu"].add_command(label=i, command = testFunc(i))

        top = self.top = Toplevel()
        self.sumButton = Button(top, text="Test", width=25, command=lambda: initSummary())
        self.sumButton.grid(row=0, column=0, sticky=W)
        self.dataButton = OptionMenu(top, self.testVariable, "Stuff")
        self.dataButton.grid(row=0, column=1, sticky=W)
        self.testButton = Button(top, text="Variable", width=25, command = lambda: refresh())
        self.testButton.grid(row=1, column=0, sticky=W)

# Call the main app
root = Tk()
app = App(root)
root.mainloop()
</code></pre>
<p>Please comment if this is not the 'correct' way of addressing this issue.</p>
</div>
<span class="comment-copy">That's a classical issue when using lambdas in for loops: <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow noreferrer">docs.python.org/3/faq/â€¦</a></span>
<span class="comment-copy">Thank you for pointing me in the right direction @j_4321. I added an intermediate function to fix the mentioned problem, would you say that this is the 'correct' way of addressing such an issue?</span>
<span class="comment-copy">I don't know if there is one 'correct' way to address this issue. I used to add an intermediate function like you, but now I prefer using <code>lambda j=i: self.testVariable.set(j)</code>.</span>
<span class="comment-copy"><code>Tk() # Biggest mystery of Tkinter</code>: this is not a mystery, it's just that <code>testVariable = StringVar()</code> needs a master window. You should consider putting this inside <code>__init__</code>: <code>self.testVariable = StringVar()</code>, that way you won't need to create a window before declaring your class.</span>
<span class="comment-copy">I always expected that the <code>root - Tk()</code> is responsible for the master window. Hence I was surprised that I need the additional <code>Tk()</code> when I was creating the example for this question. The application for which this question was created has no need for the additional <code>Tk()</code> as my <code>StringVars</code> are always inside an <code>__init__</code> as you mentioned.</span>
<span class="comment-copy">@BasJansen: <code>Tk()</code> isn't <i>responsible</i> for the master window, it <i>is</i> the master window. You should not create two of them.</span>
<span class="comment-copy">Noted. I have fixed the answer to be more in line with correct Tkinter usage.</span>
