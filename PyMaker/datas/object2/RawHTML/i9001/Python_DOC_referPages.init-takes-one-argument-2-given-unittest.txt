<div class="post-text" itemprop="text">
<p>I get the following error</p>
<pre><code>TypeError: __init__() takes exactly 1 argument (2 given)
</code></pre>
<p>When I run the following python:</p>
<pre><code>import unittest
from unittest import TestCase

class myClass( unittest.TestCase ):

    def __init__( self ):
        pass

if __name__ == '__main__':
    unittest.main( argv=sys.argv, testRunner = unittest.TextTestRunner(verbosity=2))
</code></pre>
<p>Any ideas?  I need to run init since I want to ONLY do my setup work once.  Not once for each test.  That would be a big optimization for overall test run time.</p>
<p>Here is the rest of the stack crawl:</p>
<pre><code>Traceback (most recent call last):
File "./RestEditRecord.py", line 1439, in &lt;module&gt;
unittest.main( argv=sys.argv, testRunner = unittest.TextTestRunner(verbosity=2))
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py", line 94, in __init__
self.parseArgs(argv)
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py", line 149, in parseArgs
self.createTests()
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py", line 155, in createTests
self.test = self.testLoader.loadTestsFromModule(self.module)
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py", line 65, in loadTestsFromModule
tests.append(self.loadTestsFromTestCase(obj))
File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py", line 56, in loadTestsFromTestCase
loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))
TypeError: __init__() takes exactly 1 argument (2 given)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Read <a href="https://docs.python.org/3/library/unittest.html#test-cases" rel="nofollow noreferrer">the docs for the class you're extending</a>; <code>unittest.TestCase</code>'s initializer takes an optional argument, and if you don't accept it, and it gets passed, you'll get this error.</p>
<p>There's rarely a good reason to override <code>__init__</code> for a <code>TestCase</code> anyway; test setup is done in <code>setUp</code> (run once per test so changed state from one test doesn't influence the behavior of another test), not <code>__init__</code> (run once total). You'll inherit <code>__init__</code>, and since your <code>__init__</code> isn't doing anything extra, it's silly to have it at all.</p>
<p>If you <em>do</em> have a legitimate use for it, make sure you delegate initialization up the chain:</p>
<pre><code>class Suite_Edit_AutoEntry( unittest.TestCase ):

    def __init__(self, *args, **kwargs):  # Accept all unrecognized args for delegation
        # Delegate to parent initializer
        super().__init__(*args, **kwargs)  # On Py2, super(Suite_Edit_AutoEntry, self)...
        ... do additional initialization here ...
</code></pre>
<p>Of course, as noted in the comments, you can have separate class setup (as of Python 2.7/3.2) <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUpClass" rel="nofollow noreferrer">using <code>setupClass</code></a> so you don't have to deal with <code>__init__</code>'s finickiness at all.</p>
</div>
<span class="comment-copy">D you need to call the super constructor?</span>
<span class="comment-copy">Use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUpClass" rel="nofollow noreferrer"><code>setUpClass()</code></a> instead of <code>__init__()</code>.</span>
<span class="comment-copy">My example above only does a pass but my real test is doing some prep work for a database.  For instance truncating a table and creating a group of records that each of the tests can perform searches.  I'll play / read up on both init and setUpClass() to see what makes more sense.  TY for the help guys.  Have a nice evening.  Sorry, I'm used to C++ which does not require to calling the base class if you don't want it's functionality and I haven't done C++ in a while so maybe that has changed as well.</span>
<span class="comment-copy">OK the init method above doesn't work for me but the setUpClass() method compiles and runs without error.  I'll figure out the rest tomorrow.</span>
<span class="comment-copy">setupClass is confusing because it does not take an instance argument, so it's impossible to reference object instance data in setupClass, hence I also found <b>init</b> the only practical way to perform once-off object data setup. What was the class designers intentions?</span>
<span class="comment-copy">@ConradB: It's intended to set up the class itself, not a particular instance. Setting attributes on the class itself will create them exactly once, and they will still be accessible through instances (e.g. doing <code>cls.foo = 1</code> in <code>setupClass</code> will allow you to read <code>self.foo</code> in an instance method later). Unit tests are weird, and rarely need to worry about state leakage between instances (because it's not making multiple instances in the first place).</span>
<span class="comment-copy">Thanks the reply Shadow, took me a while to grasp. Yes unit tests should not leak per test, I am from a C++ background, so Python class data feels akin to statics. I have decided that classmethods in a unit test are only for on-time init/teardown, other uses of @classmethod become a test anitpattern.</span>
