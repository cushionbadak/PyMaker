<div class="post-text" itemprop="text">
<p>My problem looks quite simple but I can't figure out a clean (and efficient) solution.</p>
<p>I have a list of tuples corresponding to common groups of words:</p>
<pre><code>ngrams = [("data", "scientist"),
          ("machine", "learning"),
          ("c", "+"),
          ("+", "+"),
          ("c", "+", "+"),
          ("research", "and", "development"),
          ("research", "and")]
</code></pre>
<p>And a sentence:</p>
<pre><code>"i am a data scientist . i do machine learning and c + + but no deep learning . i like research and development"
</code></pre>
<p>I would like to merge the common groups of words in a single token like that:</p>
<pre><code>"i am a data_scientist . i do machine_learning and c_+_+ but no deep_learning . i like research_and_development"
</code></pre>
<p>I am sure there is an elegant way to do so but I haven't been able to find any..</p>
<p>If there were only 2-tuples, iterating on <code>zip(sentence, sentence[:1]</code> would do it, but I have up to 8-tuples in <code>ngrams</code> and this solution is not tractable!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can build a list of replacement strings from your words in <code>ngrams</code>:</p>
<pre><code>replace = [" ".join(x) for x in ngrams]
</code></pre>
<p>And then, for each element in that list, use <code>str.replace</code>:</p>
<pre><code>for r in replace:
    sentence = sentence.replace(r, r.replace(" ", "_"))
</code></pre>
<p>There might be a more one-liner-y way to do it, but that seems relatively terse and easy to understand to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>While Haldean Brown's answer is simpler, I think this is a more structured approach:</p>
<pre><code>ngrams = [("data", "scientist"),
          ("machine", "learning"),
          ("c", "+"),
          ("+", "+"),
          ("c", "+", "+"),
          ("research", "and", "development"),
          ("research", "and")]
sent = """
    i am a data scientist . i do machine learning and c + + but no deep
    learning . i like research and development
"""

ngrams.sort(key=lambda x: -len(x))
tokens = sent.split()

out_ngrams = []
i_token = 0
while i_token &lt; len(tokens):
    for ngram in ngrams:
        if ngram == tuple(tokens[i_token : i_token + len(ngram)]):
            i_token += len(ngram)
            out_ngrams.append(ngram)
            break
    else:
        out_ngrams.append((tokens[i_token],))
        i_token += 1

print(' '.join('_'.join(ngram) for ngram in out_ngrams))
</code></pre>
<p>Output:</p>
<pre><code>i am a data_scientist . i do machine_learning and c_+_+ but no deep learning . i like research_and_development
</code></pre>
<p><code>ngrams</code> after sorting:</p>
<pre><code>[('c', '+', '+'),
 ('research', 'and', 'development'),
 ('data', 'scientist'),
 ('machine', 'learning'),
 ('c', '+'),
 ('+', '+'),
 ('research', 'and')]
</code></pre>
<p>That's needed to try to apply <code>("c", "+", "+")</code> earlier than <code>("c", "+")</code> (or, in general, to try to apply a sequence earlier than its prefixes). Actually it's possible that non-greedy things like <code>[('c', '+'), ('+', 'a')]</code> are more desirable than <code>[('c', '+', '+'), ('a',)]</code>, but that's another story.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = ''
seq = ("c", "+", "+")
print(s.join(seq))
</code></pre>
<p>More in on join method:
Python docs</p>
<p>ttps://docs.python.org/3/library/stdtypes.html?highlight=join#str.join</p>
</div>
<span class="comment-copy">What are you trying to accomplish? If you're attempting to do a variation of TF-IDF, checkout the sklearn package for Python <a href="http://scikit-learn.org/0.18/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer" rel="nofollow noreferrer">scikit-learn.org/0.18/modules/generated/â€¦</a></span>
<span class="comment-copy"><code>joined_ngrams = ['_'.join(t) for t in ngrams]</code></span>
<span class="comment-copy">That doesn't help. What I would like is transforming any given sentence in input to a sentence where groups of words appearing in <code>ngrams</code> are joined.</span>
<span class="comment-copy">That works, thanks a lot! I think I was stuck because I was trying to find a solution that would work in O(len(sentence)) by turning <code>ngrams</code> in a set. I still think it is possible but maybe less elegant!</span>
<span class="comment-copy">I think it can be done in O(len(sentence)*len(longest_ngram)) by something like a dictionary that maps each shortest ngram in a family to its family (where family is a list of ngrams with a common prefix).</span>
<span class="comment-copy">Doesn't solve the problem at all..</span>
