<div class="post-text" itemprop="text">
<p>I have 2 nested dictionaries variable that have the similar keys, each defining different values :</p>
<pre><code>data1 = {
"2010":{
        'A':2,
        'B':3,
        'C':5
    },
"2011":{
        'A':1,
        'B':2,
        'C':3
    },
"2012":{
        'A':1,
        'B':2,
        'C':4
    }
}

data2 = {
"2010":{
        'A':4,
        'B':4,
        'C':5
    },
"2011":{
        'A':1,
        'B':1,
        'C':3
    },
"2012":{
        'A':3,
        'B':2,
        'C':4
    }
}
</code></pre>
<p>In my case, i need to sum both dictionaries values based on the same keys, so the answer will be like this:</p>
<pre><code>data3 = {
"2010":{
        'A':6,
        'B':7,
        'C':10
    },
"2011":{
        'A':2,
        'B':3,
        'C':6
    },
"2012":{
        'A':4,
        'B':4,
        'C':8
    }
}
</code></pre>
<p>How can i do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Given the structure of the two dictionaries is the same, you can use <em>dictionary comprehension</em> for that:</p>
<pre><code>data3 = {key:{key2:val1+data2[key][key2] for key2,val1 in subdic.items()} for key,subdic in data1.items()}
</code></pre>
<p>In the repl:</p>
<pre><code>&gt;&gt;&gt; {key:{key2:val1+data2[key][key2] for key2,val1 in subdic.items()} for key,subdic in data1.items()}
{'2010': {'B': 7, 'C': 10, 'A': 6}, '2012': {'B': 4, 'C': 8, 'A': 4}, '2011': {'B': 3, 'C': 6, 'A': 2}}
</code></pre>
<p>The comprehension works as follows: in the outerloop, we iterate over the <code>key,subdic</code> of <code>data1</code>. So in your case, <code>key</code> is a year and <code>subdic</code> is the dictionary (of <code>data1</code>) for that year.</p>
<p>Now for each of these years, we iterate over the items of the <code>subdic</code> and here <code>key2</code> is <code>'A'</code>, <code>'B'</code> and <code>'C'</code>. <code>val1</code> is the value that we find in <code>data1</code> for these keys. We get the other value by querying <code>data2[key][key2]</code>. We sum these up and construct new dictionaries for that.</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope this helps:</p>
<pre><code>    data1 = { "2010":{ 'A':2, 'B':3, 'C':5 }, "2011":{ 'A':1, 'B':2, 'C':3 }, "2012":{ 'A':1, 'B':2, 'C':4 } } 
    data2 = { "2010":{ 'A':4, 'B':4, 'C':5 }, "2011":{ 'A':1, 'B':1, 'C':3 }, "2012":{ 'A':3, 'B':2, 'C':4 } }

    data3 = {}

    for data in [data1,data2]:
        for year in data.keys():
                for x,y in data[year].items():
                    if not year in data3.keys():
                        data3[year] = {x:y}
                    else:
                        if not x in data3[year].keys():
                            data3[year].update({x:y})
                        else:
                            data3[year].update({x:data3[year][x] + y})
    print data3
</code></pre>
<p>This works for arbitrary lengths of the inner and outer dictionaries.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution :)
You can also use <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to get both <code>data1</code> and <code>data2</code> in the same <code>for</code> loop, and then use <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to add the value of each dicts.</p>
<pre><code>from collections import Counter

&gt;&gt; {k1: Counter(v1) + Counter(v2) for (k1, v1), (k2, v2) in zip(sorted(data1.items()), sorted(data2.items()))}
{'2011': Counter({'C': 6, 'B': 3, 'A': 2}), '2010': Counter({'C': 10, 'B': 7, 'A': 6}), '2012': Counter({'C': 8, 'A': 4, 'B': 4})}
</code></pre>
<p>You will ended with <code>Counter</code> dict but since it is a subclass of <code>dict</code> you can still use the same method as a regular <code>dict</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you add dict() to Max Chrétiens' nice short solution from above, you will end up with regular dictionaries:</p>
<pre><code>data3 = {k1: dict(Counter(v1) + Counter(v2)) for (k1, v1), (k2, v2) in
         zip(data1.items(), data2.items())}
</code></pre>
<p>This will, however, only work correctly if both dictionaries share exactly the same keys as already discussed above. Willem Van Onsem's solution will not work if there are any keys not shared by both dictionaries either (it will result in an error, whereas Max Chrétiens' solution will in this case merge items incorrectly). Now you mentioned you are using JSON data which always contains the same structure with similar keys, so this should not constitute a problem and Max Chrétien's solution should work nicely.</p>
<p>In case you do want to make sure only keys shared by both dictionaries (and their subdictionaries) are used, the following will work. Notice how I added 'X': 111111 as a key value pair to the 2012 subdictionary and "1999": { 'Z': 999999 } as an entire subdictionary.</p>
<pre><code>def sum_two_nested_dicts(d1, d2):
    dicts = [d1, d2]
    d_sum = {}
    for topkey in dicts[0]:
        if topkey in dicts[1]:
            d_sum[topkey] = {}
            for key in dicts[0][topkey]:
                if key in dicts[1][topkey]:
                    new_val = sum([d[topkey][key] for d in dicts])
                    d_sum[topkey][key] = new_val
    return d_sum


data1 = {
    "2010": {
        'A': 2,
        'B': 3,
        'C': 5
    },
    "2011": {
        'A': 1,
        'B': 2,
        'C': 3
    },
    "2012": {
        'A': 1,
        'B': 2,
        'C': 4,
        'X': 111111
    },
    "1999": {
        'Z': 999999
    }
}

data2 = {
    "2010": {
        'A': 4,
        'B': 4,
        'C': 5
    },
    "2011": {
        'A': 1,
        'B': 1,
        'C': 3
    },
    "2012": {
        'A': 3,
        'B': 2,
        'C': 4
    }
}

data3 = sum_two_nested_dicts(data1, data2)

print(data3)

# different order of arguments

data4 = sum_two_nested_dicts(data2, data1)

print(data4)

# {'2010': {'C': 10, 'A': 6, 'B': 7}, '2012': {'C': 8, 'A': 4, 'B': 4}, '2011': {'C': 6, 'A': 2, 'B': 3}}
# {'2010': {'C': 10, 'A': 6, 'B': 7}, '2012': {'C': 8, 'A': 4, 'B': 4}, '2011': {'C': 6, 'A': 2, 'B': 3}}
</code></pre>
<p>I realize this is far from as concise and elegant as can be, but as I already wrote it anyways, I post it here in case someone is trying to achieve this particular functionality.</p>
<p>Long and bloated version which retains unshared keys/values, just because I already wrote it...</p>
<pre><code>def sum_nested_dicts(dic1, dic2):
    # create list of both dictionaries
    dicts = [dic1, dic2]
    # create a set of all unique keys from both dictionaries
    topkeys = set(sum([list(dic.keys()) for dic in dicts], []))
    # this is the merged dictionary to be returned
    d_sum = {}
    for topkey in topkeys:
        # if topkey is shared by both dictionaries
        if topkey in dic1 and topkey in dic2:
            d_sum[topkey] = {}
            keys = set(sum([list(dic[topkey].keys()) for dic in
                            dicts], []))
            for key in keys:
                # if key is shared by both subdictionaries
                if key in dic1[topkey] and key in dic2[topkey]:
                    new_val = sum([d[topkey][key] for d in dicts])
                    d_sum[topkey][key] = new_val
                # if key is only contained in one subdictionary
                elif key in dic1[topkey]:
                    d_sum[topkey][key] = dic1[topkey][key]
                elif key in dic2[topkey]:
                    d_sum[topkey][key] = dic2[topkey][key]
        # if topkey is only contained in one dictionary
        elif topkey in dic1:
            d_sum[topkey] = dic1[topkey]
        elif topkey in dic2:
            d_sum[topkey] = dic2[topkey]
    return d_sum
</code></pre>
<p>See Crystal's solution for what seems to be the most concise and functional solution posted thus far.</p>
</div>
<span class="comment-copy">Is it guaranteed that the structure of the two dictionaries is the same?</span>
<span class="comment-copy">Thank you very much, Willem, it's solve my problem in more complex condition too..</span>
<span class="comment-copy">@Faizalprbw: mind however, as the answer says this only works if the structure is identical: so both dictionaries need to contain <code>2010</code> and <code>A</code>, <code>B</code>, and <code>C</code> into <code>2010</code> etc.</span>
<span class="comment-copy">Yes i do understand, actually i have two json data that contains the same structure with similar keys, just like my example above..</span>
<span class="comment-copy">Btw, How can i make that dictionary sorted just like my example (data3) below..? Thanks.. @Willem Van Onsem</span>
<span class="comment-copy">@Faizalprbw: dictionaries are <i>unsorted</i>. So there are no guarantees on the order at all. Usually if you add to the dictionary manually, it will keep the order for a while until it rehashes. But none of the answers can give guarantees. In order to solve it, you need an <a href="http://stackoverflow.com/questions/1867861/python-dictionary-how-to-keep-keys-values-in-same-order-as-declared"><code>OrderedDict</code></a>.</span>
<span class="comment-copy">This is great! It will also work if there are keys in one dictionary but not in the other. Furthermore, it will work if one subkey (key of a nested dictionary, i.e. a dictionary that is a value of the outer dictionary) is not shared by both dictionaries. Seems to cover all the cases I tested. :-)</span>
<span class="comment-copy">This will not always work since <code>k1</code> can be different than <code>k2</code>. Note that the keys are <b>not</b> ordered in a dictionary. If you however do a lookup in <code>dict2</code> it will work.</span>
<span class="comment-copy">Your remark is incorrect, <code>zip</code> will always iterate over the same <code>keys</code> on the dictionaries. Or maybe I misunderstood what you said. Can you please provide a simple example? Your solution is good also but the problem lays where there are <code>n</code> dictionary to concat between them.</span>
<span class="comment-copy">Just want to add, the <code>zip</code> will iterate over the same <code>keys</code> of the 2 dictionary if <i>and only if</i> they have <i>all</i> the <code>keys</code> in common, otherwise it won't work.</span>
<span class="comment-copy">I don't know if that is true and even if it is, it is as far as I know not documented, so you cannot guarantee that: a person that constructs a valid Python interpreter can freely implement this aspect.</span>
<span class="comment-copy">Ok I'm totaly wrong <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#mapping-types-dict</a> ... my bad sorry. It's very unlikely to happen on short dict but it could happen on huge ones. I updated my answer with <code>sorted()</code> but now the one-liner is getting too long. Another solution will be to recreate the list with <code>OrderedDict</code></span>
<span class="comment-copy">Thx for upgrading my solution :D Your solution looks like adapted to any situations, however I think it would be nice to be able to make a function that could merge <code>n</code> dictionaries when the keys are identical. Also, add the other values even if they doesnt both dict (e.g your <code>'X': 111111</code>)</span>
<span class="comment-copy">Added my for-loop-and-if-condition-frenzy version above. But see Crystal's solution for what seems to be the most elegant solution so far. :)</span>
