<div class="post-text" itemprop="text">
<p>I have been trying to figure this out for a while now and i just cannot figure out why my code only displays the first use of the word.If someone could suggest a quick and easy way that it would display both then that would be greatly appreciated.</p>
<pre><code>sentence = input("please insert a sentence").lower()
keyword = input ("please insert a keyword you would like to search for")
splitsentence = sentence.split(" ")
position = sentence.index(keyword)
if keyword in sentence:
    print(position)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's how <a href="https://docs.python.org/3/library/string.html#string.index" rel="nofollow noreferrer"><code>index()</code></a> is designed; to only return the first occurrence.</p>
<p>If you want to find all occurrences, you must call it multiple times in a loop or with recursion. Before we do that, you should know that you can provide <code>start</code> and <code>end</code> parameters to define where to search in the sentence:</p>
<pre><code>&gt;&gt;&gt; "cat cat".index("cat")
0
&gt;&gt;&gt; "cat cat".index("cat", 1)  # start search from index 1
4
&gt;&gt;&gt; "cat cat".index("cat", 1, 4)  # ...and stop search right before index 4
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: substring not found
</code></pre>
<p>This way we can avoid getting the same index all the time in our loop:</p>
<pre><code>s = "cat cat"
indexes = []

index = -1
while True:
    try:
        index = s.index("cat", index + 1)
    except ValueError:
        break
    indexes.append(index)

print(indexes)
# Output: [0, 4]
</code></pre>
<p>Here's a recursive generator if you want to go fancy:</p>
<pre><code>def find_indices(s, sub, start=0, end=None):
    if end is None:
        end = len(s)
    try:
        start = s.index(sub, start, end)
    except ValueError:
        return
    yield start
    yield from find_all_indexes(s, sub, start + 1, end)
</code></pre>
<p>Usage (also still supports <code>start</code> and <code>end</code> arguments):</p>
<pre><code>&gt;&gt;&gt; list(find_indices("cat cat cat cat", "cat"))
[0, 4, 8, 12]
</code></pre>
<p>Or if you want a non-recursive generator, you could use the original <code>while</code> loop and have it <code>yield</code> instead of append to a list:</p>
<pre><code>def find_indices(s, sub, start=0, end=None):
    if end is None:
        end = len(s)
    start -= 1
    while True:
        try:
            start = s.index(sub, start + 1, end)
        except ValueError:
            break
        yield start
</code></pre>
<p>Exact same usage as before.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because that is how <code>.index</code> is defined: the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=str.index#str.index" rel="nofollow noreferrer">documentation</a> says:</p>
<blockquote>
<p><strong><code>str.index(sub[, start[, end]])</code></strong></p>
<p>Like
  <a href="https://docs.python.org/3/library/stdtypes.html?highlight=str.index#str.find" rel="nofollow noreferrer"><code>find()</code></a>,
  but raise <code>ValueError</code> when the substring is not found.</p>
</blockquote>
<p>and <a href="https://docs.python.org/3/library/stdtypes.html?highlight=str.index#str.find" rel="nofollow noreferrer"><code>.find</code></a>:</p>
<blockquote>
<p><strong><code>str.find(sub[, start[, end]])</code></strong></p>
<p>Return the <strong>lowest index</strong> in the string where substring sub is found
  within the slice <code>s[start:end]</code>. Optional arguments start and end are
  interpreted as in slice notation. Return <code>-1</code> if sub is not found.</p>
</blockquote>
<p>(highlighting added)</p>
<p>An idea to find <strong>all</strong> indices is to use:</p>
<pre><code>[i for i in range(len(sentence)) if keyword == sentence[i:i+len(keyword)]]
</code></pre>
<p>Or perhaps more efficient: a generator that generates indices:</p>
<pre><code>def find_indices(sentence,keyword):
    idx = -1
    while True:
        idx = sentence.find(keyword,idx+1)
        if idx &lt; 0:
            break
        yield idx
</code></pre>
</div>
<span class="comment-copy">Because that's what the <code>index</code> function is meant to do.</span>
<span class="comment-copy">@Chris_Rands: this is not a list, but a string and it is a <i>substring</i>... But probably there is a dupe somewhere.</span>
<span class="comment-copy">@WillemVanOnsem You're right, was fooled because the OP makes a list but dosen't use it, perhaps this instead: <a href="http://stackoverflow.com/questions/3873361/finding-multiple-occurrences-of-a-string-within-a-string-in-python" title="finding multiple occurrences of a string within a string in python">stackoverflow.com/questions/3873361/â€¦</a></span>
