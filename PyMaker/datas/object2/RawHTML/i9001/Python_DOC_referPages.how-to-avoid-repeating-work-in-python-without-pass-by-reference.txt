<div class="post-text" itemprop="text">
<p>I am writing web endpoints that take a JSON Web Token (JWT) and have to check the signature on the token. Since I am going to check the signature every time it makes the most sense to me that I should break this step out into a function because DRY. </p>
<p>However, the only way to check whether a JWT is signed correctly is to decode it with its secret key and catch an error. This leads me to the following function:</p>
<pre><code>def is_valid_token(token_string, secret_key):
    try:
        jwt.decode(token_string, secret_key)
        return True
    except jwt.DecodeError:
        return False
</code></pre>
<p>This works fine in terms of validating the tokens, however it seems really wasteful that I have this function that will check if the token is valid by decoding and then immediately after this function I am going to have to decode again. That is to say I would do:</p>
<pre><code>if not is_valid_token(token_string, secret_key):
    # Respond with an error to the client
else:
    token_data = jwt.decode(token_string, secret_key)
</code></pre>
<p>In this case I am decoding to check if it's valid and then if it is I'm decoding again. In C/C++ I would pass a variable by reference to capture the decoded data and then return true or false. Is there any way to do such a thing in Python? </p>
<p>It occurred to me that I might be able to get away with this by passing in an empty list to capture the decoded data but that seems really inelegant. Is there a Pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>After discussing with Nullman we've come to the following solution</p>
<pre><code>def is_valid_token(jwt_string, secret_key, reference_list):
    try:
        data = jwt.decode(jwt_string, secret_key)
        reference_list.append(data) 
        return True
    except:
        return False

reference_var = []
if not is_valid_token(jwt_string, secret_key, reference_var):
    # Respond with an error to the client
else:
    data = reference_var[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your method is already using a good Pythonic <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> idiom, but it then shoehorns it into a <code>C</code> style <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow noreferrer">LBYL</a> return code checking pattern. Don't do that, keep using exceptions.</p>
<p>In this case <code>is_valid_token</code> is kind of pointless; it doesn't actually save anything when you still need the <code>if</code>/<code>else</code> based on its return value. Don't test at all, just do the parsing inline and handle the exception if it occurs:</p>
<pre><code>try:
    token_data = jwt.decode(token_string, secret_key)
except jwt.DecodeError:
    # respond with error to client
else:
    # Use token_data
</code></pre>
<p>It's not meaningfully more verbose (you could make it shorter by putting the contents of the <code>else</code> block in the <code>try</code> if nothing else could raise a <code>jwt.DecodeError</code> and it would be exactly as verbose as the <code>if</code>/<code>else</code>).</p>
<p>If this is in more deeply nested code, you might not even catch the exception here, but let it bubble up the stack until someone who knows how to respond to the client receives it.</p>
<p>Again, to reiterate, your problem is trying to use LBYL idioms to see if you're allowed to do something, then do it, when the simplest approach is to just do it and handle the exception if it occurs. You didn't actually avoid DRY, because instead of RY on the parsing, you end up RY on checking the return and using the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: as @ShadowRanger points out, the code below should work, but it doesn't actually improve anything, the exception needs to be reraise from <code>__init__</code> and the caller needs to check for it. So this wrapper doesn't really help. I'll leave the answer in for reference, but the right way to do it is probably <a href="https://stackoverflow.com/a/42264289/1138710">@ShadowRanger's answer</a>.</p>
<p>Maybe you can leverage class inheritance here:</p>
<pre><code>class WebEndPoint(object):
    def __init__(self, token_string, secret_key)
        try:
            self.data = jwt.decode(token_string, secret_key)
        except jwt.DecodeError as e:
            # respond with "invalid token"
            raise e
</code></pre>
<p>and then in your code, you can use the class like:</p>
<pre><code>class MyEndpoint(WebEndPoint):
    def handle_request(self,...):
        # do something with self.data, which you know is
        # valid if you reach this point

myendpoint = MyEndPoint(token, secret)
</code></pre>
<p>This way you don't even need to call <code>is_valid()</code> at all, but how you actually implement this may depend on the framework you're using, if any.</p>
</div>
<span class="comment-copy">why not return the decoded data on success? then in the calling function you just have to check for type or for False, or simply return empty on failure</span>
<span class="comment-copy">@Nullman I know this is one solution though typically I'm not a huge fan of having variable return types on functions since it can make debugging a nightmare.</span>
<span class="comment-copy">doesn't jwt.decode return a string? why not the empty string method then?</span>
<span class="comment-copy">@Nullman, jwt.decode returns a dictionary.</span>
<span class="comment-copy">ohh my bad, you could do an empty dict then and count keys or items etc... sorry, i don't have a clever solution for this</span>
<span class="comment-copy">While this works, you wanted a Pythonic solution. This is the opposite of Pythonic; in order to avoid repeating the 3-4 meaningful lines in <code>is_valid_token</code> (the <code>return</code>s not being meaningful, just boilerplate required because of factoring it out), you have to write four boilerplate lines every time you use the function, and the function grows more complexity. You're still repeating yourself, just a different sort of thing is being repeated, and the "populate <code>list</code> to get reference semantics" bit is confusing, at best.</span>
<span class="comment-copy">@ShadowRanger in reality the use case avoids the <code>else</code> after the <code>if</code> and the primary point of specific case for me is to improve the readability of this code for the people that come after me. Also, with this question I was also interested in figuring out whether pass by reference is even remotely possible in python.</span>
<span class="comment-copy">Avoiding the <code>else</code> syntactically or logically? If it's just "I return in the <code>if</code> case, so I don't need the indent' you're not really avoiding anything (an exception based approach can avoid an <code>else</code> case there as well by returning from the <code>except</code> block). You're not really aiding maintainability; if they know the <code>jwt</code> API already, you've just added one more function that they need to know (and a weird one at that). This is a perfectly valid learning exercise, but faking pass-by-reference with <code>list</code> is an anti-pattern that should <i>never</i> appear in production code.</span>
<span class="comment-copy">@ShadowRanger fair enough</span>
<span class="comment-copy">What exactly does catching the exception in the <code>__init__</code> function gain you? <code>__init__</code> can't indicate failure in any reasonable way aside from raising an exception (it has no return at all), so catching it still means you need to reraise it (or another exception) to avoid the caller silently receiving an uninitialized object with no indication that the token decode failed.</span>
<span class="comment-copy">You are right, indeed. I forgot that <code>__init__</code> will return regardless, unless the exception is reraise. So that means the user ends up having to check for an exception again, which defeats the purpose of OP...</span>
