<div class="post-text" itemprop="text">
<p>I'm trying to learn python. Here is the relevant part of the exercise: </p>
<blockquote>
<p>For each word, check to see if the word is already in a list. If the
  word is not in the list, add it to the list.</p>
</blockquote>
<p>Here is what I've got. </p>
<pre><code>fhand = open('romeo.txt')
output = []

for line in fhand:
    words = line.split()
    for word in words:
        if word is not output:
            output.append(word)

print sorted(output)
</code></pre>
<p>Here is what I get. </p>
<p><code>['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 'and', 'and', 'and', 'breaks', 'east', 'envious', 'fair', 'grief', 'is', 'is', 'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 'sun', 'sun', 'the', 'the', 'the', 'through', 'what', 'window', 'with', 'yonder']</code></p>
<p>Note duplication (and, is, sun, etc). </p>
<p>How do I get only unique values?</p>
</div>
<div class="post-text" itemprop="text">
<p>To eliminate duplicates from a list, you can maintain an auxiliary list and check against.</p>
<pre><code>myList = ['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 'and', 'and', 'and', 
     'breaks', 'east', 'envious', 'fair', 'grief', 'is', 'is', 'is', 'kill', 'light', 
     'moon', 'pale', 'sick', 'soft', 'sun', 'sun', 'the', 'the', 'the', 
     'through', 'what', 'window', 'with', 'yonder']

auxiliaryList = []
for word in myList:
    if word not in auxiliaryList:
        auxiliaryList.append(word)
</code></pre>
<p><strong>output:</strong></p>
<pre><code>['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 'and', 'breaks', 'east', 
  'envious', 'fair', 'grief', 'is', 'kill', 'light', 'moon', 'pale', 'sick',
  'soft', 'sun', 'the', 'through', 'what', 'window', 'with', 'yonder']
</code></pre>
<p>This is very simple to comprehend and code is self explanatory. However, code simplicity comes on the expense of code efficiency as linear scans over a growing list makes a linear algorithm degrade to quadratic. </p>
<hr/>
<p>Use <a href="https://docs.python.org/2/tutorial/datastructures.html#sets" rel="noreferrer">set()</a>!, a set is an unordered collection with no duplicate elements. <br/>Basic uses include membership testing and eliminating duplicate entries.</p>
<pre><code>auxiliaryList = list(set(myList))
</code></pre>
<p><strong>output:</strong></p>
<pre><code>['and', 'envious', 'already', 'fair', 'is', 'through', 'pale', 'yonder', 
 'what', 'sun', 'Who', 'But', 'moon', 'window', 'sick', 'east', 'breaks', 
 'grief', 'with', 'light', 'It', 'Arise', 'kill', 'the', 'soft', 'Juliet']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of <code>is not</code> operator, you should use <code>not in</code> operator to check whether the item is in the list:</p>
<pre><code>if word not in output:
</code></pre>
<p>BTW, using <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="noreferrer"><code>set</code></a> is a lot efficient (See <a href="https://wiki.python.org/moin/TimeComplexity" rel="noreferrer">Time complexity</a>):</p>
<pre><code>with open('romeo.txt') as fhand:
    output = set()
    for line in fhand:
        words = line.split()
        output.update(words)
</code></pre>
<p><strong>UPDATE</strong> The <code>set</code> does not preserve the original order. To preserve the order, use the set as an auxiliary data structure:</p>
<pre><code>output = []
seen = set()
with open('romeo.txt') as fhand:
    for line in fhand:
        words = line.split()
        for word in words:
            if word not in seen:  # faster than `word not in output`
                seen.add(word)
                output.append(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a "one-liner" which uses <a href="https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-whilst-preserving-order">this implementation</a> of removing duplicates while preserving order:</p>
<pre><code>def unique(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]

output = unique([word for line in fhand for word in line.split()])
</code></pre>
<p>The last line flattens <code>fhand</code> into a list of words, and then calls <code>unique()</code> on the resulting list.</p>
</div>
<div class="post-text" itemprop="text">
<p>One method is to see if it's in the list prior to adding, which is what Tony's answer does. If you want to delete duplicate values <strong><em>after</em></strong> the list has been created, you can use <code>set()</code> to convert the existing list into a set of unique values, and then use <code>list()</code> to convert it into a list again. All in just one line:</p>
<pre><code>list(set(output))
</code></pre>
<p>If you want to sort alphabetically, just add a <code>sorted()</code> to the above. Here's the result:</p>
<p><code>['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 'and', 'breaks', 'east', 'envious', 'fair', 'grief', 'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 'sun', 'the', 'through', 'what', 'window', 'with', 'yonder']</code></p>
</div>
<span class="comment-copy">The idiomatic way is to maintain a <i>set</i> of words to check against. All those linear scans over a growing list makes an otherwise linear algorithm degrade to quadratic.</span>
<span class="comment-copy">thanks guys. I appreciate the help</span>
<span class="comment-copy">The exercise calls for a list where the words will be ordered according to the order of their first appearance, so I don't see how <code>set()</code> could <i>replace</i> the list, though it would clearly be a helpful auxiliary data structure.</span>
<span class="comment-copy">@JohnColeman, Thanks for the comment. I thought it doesn't matter, because OP used <code>sorted</code> at the end of the code. I will update the answer to include the version that preserve the order.</span>
<span class="comment-copy">I see what you mean. I took that to be their way of checking for duplicates. The problem description itself didn't specify sorting the result.</span>
<span class="comment-copy">If order doesn't matter then IMO this is the best answer so far as it will perform linearly and is also more concise. It does produces extra objects but that i okay for a lab/one-off program. This list -&gt; set -&gt; list pattern is used quite commonly</span>
