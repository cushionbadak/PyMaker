<div class="post-text" itemprop="text">
<p>Here below when I try to hash a list, it gives me an error but works with a tuple. Guess it has something to do with immutability. Can someone explain this in detail ?</p>
<p>List</p>
<pre><code> x = [1,2,3]
 y = {x: 9}
  Traceback (most recent call last):
   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
 TypeError: unhashable type: 'list'
</code></pre>
<p>Tuple</p>
<pre><code>z = (5,6)
y = {z: 89}
print(y)
{(5, 6): 89}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dicts and other objects use <a href="https://stackoverflow.com/questions/14535730/what-do-you-mean-by-hashable-in-python">hashes</a> to store and retrieve items really quickly. The mechanics of this all happens "under the covers" - you as the programmer don't need to do anything and Python handles it all internally. The basic idea is that when you create a dictionary with <code>{key: value}</code>, Python needs to be able to hash whatever you used for <code>key</code> so it can store and look up the value quickly. </p>
<p>Immutable objects, or objects that can't be altered, are hashable. They have a single unique value that never changes, so python can "hash" that value and use it to look up dictionary values efficiently. Objects that fall into this category include strings, tuples, integers and so on. You may think, "But I can change a string! I just go <code>mystr = mystr + 'foo'</code>, but in fact what this does is create a <em>new</em> string instance and assigns it to <code>mystr</code>, it doesn't modify the <em>existing</em> instance. Immutable objects never change, so you can always be sure that when you generate a hash for an immutable object, looking up the object by its hash will always return the same object you started with, and not a modified version.</p>
<p>You can try this for yourself: <code>hash("mystring")</code>, <code>hash(('foo', 'bar'))</code>, <code>hash(1)</code></p>
<p>Mutable objects, or objects that <em>can</em> be modified, <em>aren't</em> hashable. A list can be modified in-place: <code>mylist.append('bar')</code> or <code>mylist.pop(0)</code>. You can't safely hash a mutable object because you can't guarantee that the object hasn't changed since you last saw it. You'll find that <code>list</code>, <code>set</code>, and other mutable types don't have a <code>__hash__()</code> method. Because of this, you can't use mutable objects as dictionary keys. </p>
<p>Edit: <a href="https://stackoverflow.com/users/6419007/eric-duminil">Eric Duminil</a>'s answer provides a great example of the unexpected behaviour that arises from using mutable objects as dictionary keys</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are examples why it might not be a good idea to allow mutable types as keys. This behaviour might be useful in some cases but it also might lead to suprising results or bugs.</p>
<h1>Python</h1>
<p>It's possible to use a numeric list as a key by defining <code>__hash__</code> on a subclass of <code>list</code> :</p>
<pre><code>class MyList(list):
    def __hash__(self):
        return sum(self)

my_list = MyList([1, 2, 3])

my_dict = {my_list: 'a'}

print my_dict.get(my_list)
# 'a'

my_list[2] = 4  # __hash__() becomes 7
print my_dict.keys()[0]
# [1, 2, 4]
print my_dict.get(my_list)
# None
print my_dict.get(MyList([1,2,3]))
# None

my_list[0] = 0  # __hash_() is 6 again, but for different elements
print my_dict.keys()[0]
# [0, 2, 4]
print my_dict.get(my_list)
# 'a'
</code></pre>
<h1>Ruby</h1>
<p>In Ruby, it's allowed to use a list as a key. A Ruby list is called an <code>Array</code> and a dict is a <code>Hash</code>, but the syntax is very similar to Python's :</p>
<pre><code>my_list = [1]
my_hash = { my_list =&gt; 'a'}
puts my_hash[my_list]
#=&gt; 'a'
</code></pre>
<p>But if this list is modified, the dict doesn't find the corresponding value any more, even if the key is still in the dict :</p>
<pre><code>my_list &lt;&lt; 2

puts my_list
#=&gt; [1,2]

puts my_hash.keys.first
#=&gt; [1,2]

puts my_hash[my_list]
#=&gt; nil
</code></pre>
<p>It's possible to force the dict to calculate the key hashes again :</p>
<pre><code>my_hash.rehash
puts my_hash[my_list]
#=&gt; 'a'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A hashset calculates the <em>hash</em> of an object and based on that hash, stores the object in the structure for fast lookup. As a result, by contract once an object is added to the dictionary, the <strong>hash is not allowed to change</strong>. Most good hash functions will depend on the number of elements and the elements itself.</p>
<p>A tuple is <em>immutable</em>, so after construction, the values cannot change and therefore the hash cannot change either (or at least a good implementation should not let the hash change).</p>
<p>A list on the other hand is <em>mutable</em>: one can later add/remove/alter elements. As a result the hash can change violating the contract.</p>
<p>So all objects that cannot guarantee a hash function that remains stable after the object is added, violate the contract and thus are no good candidates. Because for a <strong>lookup</strong>, the dictionary will first calculate the hash of the key, and determine the correct bucket. If the key is meanwhile changed, this could result in false negatives: the object is in the dictionary, but it can no longer be retrieved because the hash is different so a different bucket will be searched than the one where the object was originally added to.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because a list is mutable, while a tuple is not. When you store the hash of a value in, for example, a dict, if the object changes, the stored hash value won't find out, so it will remain the same. The next  time you look up the object, the dictionary will try to look it up by the old hash value, which is not relevant anymore.</p>
<p>To prevent that, python does not allow you to has mutable items.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would like to add the following aspect as it's not covered by other answers already.</p>
<p>There's nothing wrong about making mutable objects hashable, it's just not unambiguous and this is why it needs to be defined and implemented consistently by the programmer himself (not by the programming language).</p>
<p>Note that you can implement the <code>__hash__</code> method for any custom class which allows its instances to be stored in contexts where hashable types are required (such as dict keys or sets).</p>
<p>Hash values are usually used to decide if two objects represent the same thing. So consider the following example. You have a list with two items: <code>l = [1, 2]</code>. Now you add an item to the list: <code>l.append(3)</code>. And now you must answer the following question: Is it still the same thing? Both - yes and no - are valid answers. "Yes", it is still the same list and "no", it has not the same content anymore.</p>
<p>So the answer to this question depends on you as the programmer and so it is up to you to manually implement hash methods for your mutable types.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer">Python Glossary</a></p>
<blockquote>
<p>An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.</p>
<p>All of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not.</p>
</blockquote>
</div>
<span class="comment-copy">Yes it's about a list being mutable. If you store the hash value somewhere (as part of a <code>dict</code> for example) and then you modify the list then it's not a valid dict key anymore. That doesn't mean it makes no sense that mutable objects have hash values but that there is only no unambiguous interpretation of such a hash value and so it is up to the programmer to implement this consistently throughout the application.</span>
<span class="comment-copy">A tuple is not always hashable. (1, 2, [3]) is not hashable, because its third element is unhashable.</span>
<span class="comment-copy">There's nothing wrong about making mutable objects hashable, you just have to be consistent and precise about what that means within your application. You can implement the <code>__hash__</code> method for any custom class, making it hashable. You can even inherit from <code>list</code> and then make it hashable by implementing <code>__hash__</code>. It's just not unambiguous what the hash value of a mutable object is and this is why Python leaves it to the programmer to decide and define that.</span>
<span class="comment-copy">@a_guest You leave yourself open for unexpected behaviour - if your hash method doesn't depend on the contents of your object, it could be possible for two objects to share the same hash. On the flip side, if your object is mutable, you may run into situations where you set <code>{obj: value}</code> but later on cannot retrieve <code>mydict.get(obj)</code>, because the object - and therefore the hash - has changed. It's <i>possible</i> in python, and I'm sure you can find a scenario where it might even make sense … but as a general rule of thumb there <i>are</i> things wrong with making mutable objects hashable.</span>
<span class="comment-copy">No you didn't get the point. First of all, "clashes" of hash values can always occur (also for immutable) objects and this is why hashtables employ linked lists in order to store objects that clash. Secondly (the "flip side"), if the hash of a mutable object changes upon modification is up to the programmer. Both situations make sense (changing the hash or not) however it needs to be consistent throughout the <i>application</i>. Because Python is a <i>programming language</i> they decided to leave it to the programmer.</span>
<span class="comment-copy">Upvoted for the practical example of <i>why</i> it's not a good idea to use mutable objects for keys.</span>
<span class="comment-copy">It's a misconception that using mutable objects as dict keys is a bad idea. It really depends on the definitions within your application. The only thing you <i>need</i> to guarantee is that two objects that compare equal have the same hash value. Or the other way round: two objects with different hash values do not compare equal. Also note that a <i>list</i> is not the only mutable type that exists. Hashable mutable objects make more sense when it comes to custom types. So this example fails somehow in the sense that it seems to set "list" equal with "mutable type".</span>
<span class="comment-copy">@a_guest Thanks for the comment. I wrote that it <b>might</b> be a bad idea.</span>
<span class="comment-copy">During one minute, I didn't understand why my_dict.get(MyList([1,2,3])) is None ...</span>
<span class="comment-copy">"[...] once an object is added to the dictionary, the hash is not allowed to change."  This is a pure matter of definition and Python just decided against making lists hashable as it's not unambiguous what that means. From the Zen of Python: "In the face of ambiguity, refuse the temptation to guess." However such concepts exist as you can see from Ruby for example.</span>
<span class="comment-copy">@a_guest: no it is also a matter of efficiency. The only way you can make this work with mutable objects is adding a trigger that rehashes the object if it is modified. Most programming languages have decided against that. But evidently as they say: <i>every problem in computer science can be solved by another layer of indirection</i>.</span>
<span class="comment-copy">@a_guest: as you can see <a href="http://jafrog.com/2012/10/07/mutable-objects-as-hash-keys-in-ruby.html" rel="nofollow noreferrer">here</a> you can indeed allow it, but it creates all kinds of side effects that are rather error-prone and tend to introduce bugs.</span>
<span class="comment-copy">Only because an object is mutable doesn't mean its hash value changes upon modification. This is completely up to the programmer (meaning that you don't necessarily need to rehash). Even the opposite situation makes sense (hash changes upon modification). You just need to guarantee that two objects that compare equal have the same hash value. Or opposite: two objects with different hash values do not compare equal.</span>
<span class="comment-copy">@aguest you misread the order of x and y.</span>
<span class="comment-copy">In Python, when are dict hashes calculated? Defining <code>__hash__</code> might not help much if it's only called when a key-value pair is added to the dict.</span>
<span class="comment-copy">I don't get your point here. Staying with the list example, what's wrong with the following (apart from efficiency): <code>class MyList(list): def __hash__(self): return 0</code>. Has the exact same functionality as a list and fulfills all conditions to hash values. You can use it as a dict key without any problems (apart from dict access won't be <code>O(1)</code> anymore but this is efficiency).</span>
<span class="comment-copy">Efficient look-up is the whole point of a dictionary. A dict whose keys all have the same hash is basically a list. My question was about a non-constant hash, for example <code>sum(self)</code>.</span>
