<div class="post-text" itemprop="text">
<p>Can someone please explain why the following code results in a ValueError?</p>
<pre><code>import heapq
import numpy as np

a = np.ones((2, 2), dtype=int)

states = []
heapq.heappush(states, (0, a))
heapq.heappush(states, (0, a.copy()))
</code></pre>
<p>The error message is:</p>
<pre><code>Traceback (most recent call last):
  File "x.py", line 8, in &lt;module&gt;
    heapq.heappush(states, (0, a.copy()))
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>Running it without adding the <code>a.copy()</code> to the heap works fine, the second/subsequent one is for some reason a problem. I do understand that there is a unknown truth value aspect with an array of <code>[True, False, True]</code> and that it's not possible to determine a single <code>True</code> or <code>False</code> from that, but why does <code>heapq</code> need to do that? Especially only in the second case?</p>
</div>
<div class="post-text" itemprop="text">
<p>TL;DR: Because numpy arrays can't be cast to a boolean if they contain more than one element.</p>
<hr/>
<p>Some informations about heaps:</p>
<p>Heaps "order" their contents (so the items must implement <code>&lt;</code> but that's an implementation detail). </p>
<p>You however insert items into the <code>heap</code> by creating <code>tuple</code>s for the items, where the first elements is some value and the second one is the array. </p>
<p>Comparing tuples first checks if the first items are equal and if they are it checks if the second items are equal and so on until they are not equal, then it will check if it's smaller (when the operation was <code>&lt;</code>) or greater (for <code>&gt;</code>). However tuples are implemented in C and the <code>==</code> check there is a bit different than the one in Python. It uses <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a>. Especially the "note" is important here</p>
<blockquote>
<p>If <code>o1</code> and <code>o2</code> are the same object, <code>PyObject_RichCompareBool()</code> will always return 1 for <code>Py_EQ</code>and 0 for <code>Py_NE</code>.</p>
</blockquote>
<p>Now let's go to numpy arrays:</p>
<p>You can't convert a <code>numpy.array</code> to a <code>bool</code> if it contains more than one item:</p>
<pre><code>&gt;&gt;&gt; arr = np.array([1,2,3])
&gt;&gt;&gt; bool(arr)
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>An <code>if</code> check implicitly converts the condition to a boolean:</p>
<pre><code>&gt;&gt;&gt; if arr: pass
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>Even after comparing numpy-arrays they are still numpy arrays:</p>
<pre><code>&gt;&gt;&gt; arr &gt; arr
array([False, False], dtype=bool)
&gt;&gt;&gt; arr == arr
array([ True,  True], dtype=bool)
</code></pre>
<p>So these can't be evaluated with <code>==</code>:</p>
<pre><code>&gt;&gt;&gt; if arr == arr: pass
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<p>So you can't convert numpy-arrays with more than one element to a boolean! However now comes the interesting part: The <code>heapq</code>-module uses <code>PyObject_RichCompareBool()</code> so it can check if two arrays are equal but <strong>if and only if</strong> these are identical!</p>
<p>That's why it works with the same array passed in several times but it fails when you copy it:</p>
<pre><code>&gt;&gt;&gt; arr is arr
True
&gt;&gt;&gt; arr is arr.copy()
False
</code></pre>
</div>
<span class="comment-copy">heapq needs to compare the heap elements. The heap elements are tuples, and the first entries of the tuples are equal, so it compares the second elements. Comparing the second elements doesn't produce something that can be interpreted as a boolean.</span>
<span class="comment-copy">Note that <code>heapq.heappush(heap, (x, y))</code> doesn't mean "push thing <code>y</code> with priority <code>x</code>"; it means "push thing <code>(x, y)</code>". We don't have separate priorities and elements; we just have elements.</span>
<span class="comment-copy">"Heaps are stable and "order" their contents ... meaning that items that compare equal will be in the same order as they were originally" - what are you talking about? heapq doesn't guarantee that at all, and it doesn't do the value-position tuple thing you describe. If you want that behavior, you have to do it yourself.</span>
<span class="comment-copy">@user2357112 Thanks for the comment, I corrected the answer.</span>
