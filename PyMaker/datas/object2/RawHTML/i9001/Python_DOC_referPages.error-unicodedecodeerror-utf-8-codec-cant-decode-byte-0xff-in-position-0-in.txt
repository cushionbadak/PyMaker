<div class="post-text" itemprop="text">
<p><a href="https://github.com/affinelayer/pix2pix-tensorflow/tree/master/tools" rel="noreferrer">https://github.com/affinelayer/pix2pix-tensorflow/tree/master/tools</a></p>
<p>An error occurred when compiling "process.py" on the above site.</p>
<pre><code> python tools/process.py --input_dir data --            operation resize --outp
ut_dir data2/resize
data/0.jpg -&gt; data2/resize/0.png
</code></pre>
<p>Traceback (most recent call last):</p>
<pre><code>File "tools/process.py", line 235, in &lt;module&gt;
  main()
File "tools/process.py", line 167, in main
  src = load(src_path)
File "tools/process.py", line 113, in load
  contents = open(path).read()
      File"/home/user/anaconda3/envs/tensorflow_2/lib/python3.5/codecs.py", line 321, in decode
  (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode     byte 0xff in position 0: invalid start byte
</code></pre>
<p>What is the cause of the error?
Python's version is 3.5.2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python tries to convert a byte-array (a <code>bytes</code> which it assumes to be a utf-8-encoded string) to a unicode string (<code>str</code>).  This process of course is a decoding according to utf-8 rules.  When it tries this, it encounters a byte sequence which is not allowed in utf-8-encoded strings (namely this 0xff at position 0).</p>
<p>Since you did not provide any code we could look at, we only could guess on the rest.</p>
<p>From the stack trace we can assume that the triggering action was the reading from a file (<code>contents = open(path).read()</code>).  I propose to recode this in a fashion like this:</p>
<pre><code>with open(path, 'rb') as f:
  contents = f.read()
</code></pre>
<p>That <code>b</code> in the mode specifier in the <code>open()</code> states that the file shall be treated as binary, so <code>contents</code> will remain a <code>bytes</code>.  No decoding attempt will happen this way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use this solution it will strip out (ignore) the characters and return the string without them. Only use this if your need is to strip them not convert them.</p>
<pre><code>with open(path, encoding="utf8", errors='ignore') as f:
</code></pre>
<p>Using <code>errors='ignore'</code>
You'll just lose some characters. but if your don't care about them as they seem to be extra characters originating from a the bad formatting and programming of the clients connecting to my socket server.
Then its a easy direct solution.
<a href="https://docs.python.org/3/howto/unicode.html#the-unicode-type" rel="noreferrer">reference</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Had an issue similar to this, Ended up using UTF-16 to decode. my code is below.</p>
<pre><code>with open(path_to_file,'rb') as f:
    contents = f.read()
contents = contents.rstrip("\n").decode("utf-16")
contents = contents.split("\r\n")
</code></pre>
<p>this would take the file contents as an import, but it would return the code in UTF format. from there it would be decoded and seperated by lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've come across this thread when suffering the same error, after doing some research I can confirm, this is an error that happens when you try to decode a UTF-16 file with UTF-8.</p>
<p><a href="https://en.wikipedia.org/wiki/UTF-16#Byte_order_encoding_schemes" rel="noreferrer">With UTF-16 the first characther (2 bytes in UTF-16) is a Byte Order Mark (BOM)</a>, which is used as a decoding hint and doesn't appear as a character in the decoded string. This means the first byte will be either FE or FF and the second, the other.</p>
<p><em>Heavily edited after I found out the real answer</em></p>
</div>
<div class="post-text" itemprop="text">
<p>use only </p>
<pre><code>base64.b64decode(a) 
</code></pre>
<p>instead of </p>
<pre><code>base64.b64decode(a).decode('utf-8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Read(<strong>r</strong>) the CSV <strong>details.csv</strong> file and encode by <strong>utf8</strong>. if <strong>error</strong> occurs <strong>ignore</strong> the error, This simply done by the following code.</p>
<pre><code>with open('details.csv', 'r',encoding="utf8", errors='ignore') as csvDataFile:
    csvReader = csv.DictReader(csvDataFile)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check the path of the file to be read. My code kept on giving me errors until I changed the path name to present working directory. The error was:</p>
<pre><code>newchars, decodedbytes = self.decode(data, self.errors)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are on a mac check if you for a hidden file, .DS_Store. After removing the file my program worked. </p>
</div>
<div class="post-text" itemprop="text">
<p>HitHere,
you should load the "GoogleNews-vectors-negative300.bin.gz" file at first then extract it by this command in Ubuntu: gunzip -k GoogleNews-vectors-negative300.bin.gz. [ manually extracting is never recommended].
secondly, you should apply these commands in pyrhon 3: </p>
<p><code>import gensim
model = gensim.models.Word2Vec.load_word2vec_format('./model/GoogleNews-vectors-negative300.bin', binary=True) .</code>
I hope it will be useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have a similar problem. I try to run an example in tensorflow/models/objective_detection and met the same message.
Try to change Python3 to Python2</p>
</div>
<div class="post-text" itemprop="text">
<p>If possible, open the file in a text editor and try to change the encoding to UTF-8. Otherwise do it programatically at the OS level. </p>
</div>
<span class="comment-copy">I'm getting the error "ValueError: mode string must begin with one of 'r', 'w', 'a' or 'U', not 'br'"</span>
<span class="comment-copy">@Unnikrishnan Ok, then use <code>rb</code> (I thought order was of no importance, but it seems to be, at least in some systems/versions).  I changed my answer accordingly.</span>
<span class="comment-copy"><code>byte 0xff in position 0</code> could also mean the file is encoded in UTF-16, then you can do <code>with open(path, encoding='utf-16') as f:</code> instead</span>
<span class="comment-copy">Works for decode() as well: <code>contents = contents.decode('utf-8', 'ignore')</code> Source: <a href="https://docs.python.org/3/howto/unicode.html#the-string-type" rel="nofollow noreferrer">docs.python.org/3/howto/unicode.html#the-string-type</a></span>
<span class="comment-copy">In Python 3 you can simplify this by using the encoding param <code>with open(path, encoding='utf-16') as f</code></span>
<span class="comment-copy">Thank you! This answer was extremely helpful.</span>
<span class="comment-copy">This the real answer.</span>
<span class="comment-copy">its working but just to understand can you explian why please? :)</span>
