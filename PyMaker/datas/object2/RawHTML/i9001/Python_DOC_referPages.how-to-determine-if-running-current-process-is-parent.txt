<div class="post-text" itemprop="text">
<p>How is it possible to determine from the multiprocessing module in python if the current process is the parent or the child, from within imported modules?</p>
<p>Specifically, I have some lines of code in modules that i am importing, that only want running once - when the code is first run (i.e. not run ever time that a sub-process starts, and imports that module). </p>
<p>In the main module, i was able to achieve this using <code>if __name__ == '__main__':</code> , however this does not work in imported modules. </p>
<p>In case of relevant, current code includes:</p>
<pre><code>import multiprocessing as mp

pool = mp.Pool(processes=7, maxtasksperchild=1) 

all_items = [pool.apply_async(sub_process, args=(value,) for value in all_values]
for item in all_items:
    item.get()  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will print out <code>True</code> if current process is the parent process.</p>
<pre><code>from multiprocessing import current_process

print(current_process().name == 'MainProcess') 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Correct me if I am wrong. Based on my understanding, you want to know which process(main process or sub-processes) is running. You can achieve this using <code>logging</code> , in the format specify <code>%(processName)s %(threadName)s</code></p>
<pre><code>import multiprocessing
import logging
import sys
logger = logging.getLogger("mylogger")

formatter = logging.Formatter('%(processName)s %(threadName)s [%(levelname)s] %(message)s')

handler = logging.StreamHandler(stream=sys.stdout)
handler.setFormatter(formatter)
handler.setLevel(logging.DEBUG)

logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

def f(x):
    logger.info(multiprocessing.current_process())
    return x * x

if __name__ == "__main__":
    logger.info("get started")
    p = multiprocessing.Pool()
    p.map(f, range(6))
    logger.info("done")
</code></pre>
<p>Output:</p>
<pre><code>MainProcess MainThread [INFO] get started
ForkPoolWorker-1 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt;
ForkPoolWorker-2 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt;
ForkPoolWorker-3 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-3, started daemon)&gt;
ForkPoolWorker-1 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-1, started daemon)&gt;
ForkPoolWorker-4 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-4, started daemon)&gt;
ForkPoolWorker-2 MainThread [INFO] &lt;ForkProcess(ForkPoolWorker-2, started daemon)&gt;
MainProcess MainThread [INFO] done
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in linux every process except process 0 (swapper) has one parent and possibly many childs (<a href="https://en.wikipedia.org/wiki/Parent_process" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Parent_process</a>) so your main thread also has a parent </p>
<p>this is why you, if you start your program,  have to store the PID assigned to it from the os because it is the parent (or grandparent,...) of all your child processes.</p>
<pre><code>import os

parent_pid = os.getpid()
print "[parent] starts PID: %d" % (parent_pid, ) 
</code></pre>
<p>to get the parent process when you are in one o the childs you can use <code>os.getppid()</code>, to get the PID of the current process use <code>os.getpid()</code> </p>
<pre><code>from multiprocessing import Process
import os

def info(title):
    print(title)
    print('module name:', __name__)
    print('parent process:', os.getppid())
    print('process id:', os.getpid())
</code></pre>
<p><a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p><a href="https://docs.python.org/2/library/os.html" rel="nofollow noreferrer">https://docs.python.org/2/library/os.html</a></p>
<p><a href="http://www.programcreek.com/python/example/4464/os.getppid" rel="nofollow noreferrer">http://www.programcreek.com/python/example/4464/os.getppid</a>
<a href="http://nullege.com/codes/search/os.getppid" rel="nofollow noreferrer">http://nullege.com/codes/search/os.getppid</a></p>
</div>
<span class="comment-copy">Your question confuses me. <code>__name__</code> is a red herring in this case. Inside the function 'sub_process' you are in a child process. Outside that function you are in the parent process. Why don't you ask what you are trying to achieve?</span>
<span class="comment-copy">@RobertB - edited question accordingly.</span>
<span class="comment-copy">Can you segregate the code into a separate function, like "setup". Then you call the <code>module1.setup()</code> prior to launching your processes?</span>
<span class="comment-copy">I assume the subprocesses don't use the data. You could hide this data behind a factory function that generates it the first time it is called. This would protect any innocent importer who didn't really want the data.</span>
<span class="comment-copy">Where are you importing that module? If you're not importing it <i>inside</i> <code>sub_process</code>, the child processes will get a copy after the process is forked.</span>
