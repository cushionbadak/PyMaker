<div class="post-text" itemprop="text">
<p>Let's say we have a list of random ints</p>
<p>I want to get a new list (or change this list in place) where every element is either itself, or the previous element *2 (whichever is bigger)</p>
<p>One way to do this is:</p>
<pre><code>a = [-1, 0, 5, -2, 1]

for i in range(1:len(a)):
   a[i] = max(a[i], a[i-1] * 2)

#result should be [-1, 0, 5, 10, 20]
</code></pre>
<p>However, is there some creative way to do this in one line? Is there some clever use of something like lambda, map, or iterator use to get the same result?</p>
<p>I tried using zip to create pairs of every value and the previous value, but as soon as we change one element, the rest of the zip is useless since those values don't also change.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python3:</p>
<pre><code>a = [-1, 0, 5, -2, 1]
list(itertools.accumulate(a, lambda acc, x: max(2 * acc, x))
&gt;&gt;&gt; [-1, 0, 5, 10, 20]
</code></pre>
<p>No such easy luck with Python 2, though:</p>
<pre><code>def agg(acc, x):
    return acc + [max(2 * acc[-1], x)]
reduce(agg, a[1:], a[0:1])
&gt;&gt;&gt; [-1, 0, 5, 10, 20]
</code></pre>
<p>You can muck about with the sentinel to make this a little more pleasing to use:</p>
<pre><code>def agg(acc, x):
    return acc + [max(2 * acc[-1], x)] if acc else [x]
reduce(agg, a, None)
&gt;&gt;&gt; [-1, 0, 5, 10, 20]
</code></pre>
<p>The (sometimes) nice thing about the such "abused" <code>reduce()</code> is that <code>acc</code> has the full conversion history up so far.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the the <code>accumulate</code> function added to the <code>itertools</code> module in Python 3.2 or write your own:</p>
<pre><code>try:
    from itertools import accumulate  # added in Py 3.2
except ImportError:
    def accumulate(iterable):
        """Return running totals (simplified version)."""
        total = next(iterable)
        yield total
        for value in iterable:
            total += value
            yield total
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're going to roll your own generator function you could do this:</p>
<pre><code>def twice_if_bigger(iterable):
   preval = next(iterable)
   yield preval
   for value in iterable:
      preval=max(2*preval,value)
      yield preval 

a = [-1, 0, 5, -2, 1]
print([i for i in twice_if_bigger(a.__iter__())])

&gt;&gt; [-1, 0, 5, 10, 20]
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.accumulate</a></span>
