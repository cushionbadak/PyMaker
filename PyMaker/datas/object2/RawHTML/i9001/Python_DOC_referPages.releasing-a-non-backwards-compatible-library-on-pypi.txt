<div class="post-text" itemprop="text">
<p>I have a library on PyPI called <code>foobar</code> and it's currently at version <code>1.2.0</code> (using semantic versioning). </p>
<p>The next version doesn't preserve API compatibility with versions <code>1.x</code>, so I'll release it as <code>2.0.0</code>. </p>
<p>What is the best practice to publish this new version to PyPI, so that clients which are using the <code>1.x</code> versions don't accidentally upgrade to <code>2.0.0</code> and break their code? (I'm assuming that there are people who didn't enforce a version dependency like <code>&gt;=1.0.0, &lt;2.0.0</code> in their code).</p>
<p>Would it be better to create a completely new package called <code>foobar2</code> on PyPI and push the new version there? How do other projects handle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I assert: API changes normally fall into two categories.</p>
<ol>
<li><p>New API B replaces A but A can entirely be implemented using new API B. Therefore it is feasible to maintain the old API simultaneously with the new API. </p>
<p>This could be as simple as a new API being moved to tidy or rationalize your module, or more complex such as a conversion of args to kwargs or whatever.</p></li>
<li><p>New API replaces old API but cannot implement it for whatever technical reason.</p></li>
</ol>
<p>These are your options for categories IMO. Which one you take will depend a lot on what changes you are making and how much you a) care about or b) are in contact and can talk to your users (i.e. you can get away with a few unannounced breakages if it's just a few people on your team who you can subsequently help fix their issues).</p>
<h3>1. Provide both old and new in your new version.</h3>
<p>Implement the old API using the new one but mark it as deprecated using the <a href="https://docs.python.org/3/library/exceptions.html#DeprecationWarning" rel="nofollow noreferrer">warnings</a> module. You give people notice to convert and you can remove the old API at some point in the future.</p>
<p>This is best practice for API changes of the first type. It keeps everyone on the same stream and allows you to tidy up at some point in the future.</p>
<h3>2. Warn, then introduce new API.</h3>
<p>If you are in situation 2 or situation 1 but can't justify the resource to implement old using new, then you can easily release a version 1.2.1 that uses the warnings module to warn users that you are about to add a new version that will break their codez, and that they should quickly peg the version in their <code>requirements.txt</code>. </p>
<p>Say when you're going to release version 2.0, and then you've warned them.</p>
<p>But this is only really fair if it's not too much effort to migrate from 1.2.0 to 2.0 for your users.</p>
<h3>3. Add a completely new package.</h3>
<p>If there are profound differences, and it would be a right pain for your users to update their code to the point that they would essentially need to  rewrite it, then you shouldn't be afraid of just using a completely new package. We all make mistakes, and no one in the Python community is not aware of that given the differences between Python 2 and Python 3 :-). <code>unittest2</code> is also one such example from a while back.</p>
<h2>What will people expect.</h2>
<p>Personally, if I had automatic upgrades occurring on a system I cared about and if I didn't peg the versions to upgrade only maintenance releases, I would consider it my fault if someone released a major upgrade that my system automatically took but then stopped working because of it.</p>
<p>That gives you the moral highground IMO, but that isn't much consolation for your lazy users (or worse, customers) who didn't check and got burnt.</p>
<h2>What other people do</h2>
<ul>
<li><a href="http://www.paramiko.org/changelog.html#2.0.0" rel="nofollow noreferrer">paramiko</a> kept API back-compatibility on 1.x to 2.0 </li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#id17" rel="nofollow noreferrer">beautifulsoup</a> change name on PyPI (from BeautifulSoup to bs4)</li>
<li><a href="https://docs.djangoproject.com/en/1.10/releases/1.9/#django-contrib-auth" rel="nofollow noreferrer">django</a> tends to deprecate features and remove them in later feature releases, and in general I would never upgrade a django install I cared about from 1.X to 1.(X+1) without testing it first. (I consider this to be the best practice, like a lot of things the django folk do.)</li>
</ul>
<p>So the summary is: there is a mix, and it really is up to you. However the only completely safe ways to avoid user self-inflicted issues is to keep back-compatibility entirely or create a new package, as BeautifulSoup did.</p>
</div>
<span class="comment-copy">I can't use <code>warnings</code> because the API is the same (more or less), but the behaviour is different, e.g. now it raises exceptions instead of returning <code>None</code>. Providing both old and new versions wouldn't make much sense either. I guess what I need to know if it's expected (in the Python world) to have an API incompatibility when moving from an 1.x version to 2.x, as is with the semantic versioning convention.</span>
<span class="comment-copy">If the behaviour of the API is different, then that means the API is different. Certainly the difference between returning None and raising an exception is an API change. To get the same result your user must change their code! I've added some examples of what teams with well-used packages have done in the past. I don't think anything you have said precludes you from using warnings though... particularly in a number 2 style solution where you warn for a bit and then release your changes.</span>
<span class="comment-copy">Thanks! I'll award the bounty as soon as SO allows me to</span>
