<div class="post-text" itemprop="text">
<p>I have a loop from python that writes proxies to a file, one per line. That file is later used from a bash script via <code>curl -x $PROXY</code>, line by line using <code>cat proxies.txt</code>.</p>
<p>Could this approach be improved by launching the two scripts at the same time, and using a named pipe that can be consumed by <code>cat</code> only when python writes a new line/new proxy?</p>
<p>In my mind, I'd write something like</p>
<pre><code>f = open('/tmp/proxies', 'w') # but this call is blocking!
for proxy in ...:
    f.write(proxy)
</code></pre>
<p>and</p>
<pre><code>for PROXY in $(cat /tmp/proxies); do curl -x $PROXY example.com; done
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lots of comments about the blocking of the FIFO; I won't repeat them, but the main issue is: when no process reads, the writing process is blocked.</p>
<p>The code you might be looking for is something like this:</p>
<pre><code>#!/bin/bash
python the_python_script.py &amp;  # start in the background
tail -f /tmp/proxies| while read px; do 
    curl -x $px example.com
done
</code></pre>
<p>There should probably be some logic to terminate the bash script when the python script dies.</p>
</div>
<span class="comment-copy">Why not starting this curl call inside the python script? Or using a python curl API.</span>
<span class="comment-copy">@languitar the approach you suggest leave my code sequential, while I'd like to start the two process simultaneously</span>
<span class="comment-copy">A FIFO does not provide persistence.  Writing to a FIFO blocks if there is no reader.  Launch your reader from inside your Python program before starting to write, but make sure you launch the reader as a separate process, and do not wait for it to finish before starting to write.</span>
<span class="comment-copy">As an aside, <a href="http://mywiki.wooledge.org/DontReadLinesWithFor" rel="nofollow noreferrer">mywiki.wooledge.org/DontReadLinesWithFor</a></span>
<span class="comment-copy">In python 3 you could launch curl requests in parallel easily using <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.future</code></a>.</span>
