<div class="post-text" itemprop="text">
<p>Trying to use pyserial with asyncio on a windows machine.</p>
<p>Inspired by <a href="https://stackoverflow.com/a/27927704/1629704">https://stackoverflow.com/a/27927704/1629704</a> my code is constantly watching a serial port for incoming data.</p>
<pre><code># This coroutine is added as a task to the event loop.
@asyncio.coroutine
def get_from_serial_port(self):
    while 1:
        serial_data = yield from self.get_byte_async()
        &lt;doing other stuff with serial_data&gt;

# The method which gets executed in the executor
def get_byte(self):
    data = self.s.read(1)
    time.sleep(0.5)
    tst = self.s.read(self.s.inWaiting())
    data += tst
    return data

# Runs blocking function in executor, yielding the result
@asyncio.coroutine
def get_byte_async(self):
    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        res = yield from self.loop.run_in_executor(executor, self.get_byte)
        return res
</code></pre>
<p>After serial data has been returned. the coroutine <code>get_byte_async</code> is called inside the while loop creating a new executor. I always learned creating a new thread is expensive so I feel I should take another approach, but I am not sure how to do that.
I've been reading this article <a href="https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32#.964j4a5s7" rel="nofollow noreferrer">https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32#.964j4a5s7</a></p>
<p>And I guess I need to do the reading of the serial port in another thread. But how to get the serial data back to the "main" loop ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can either use the default executor and lock the access to <code>get_byte</code> with an <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Lock" rel="nofollow noreferrer">asyncio lock</a>:</p>
<pre><code>async def get_byte_async(self):
    async with self.lock:
        return await self.loop.run_in_executor(None, self.get_byte)
</code></pre>
<p>Or simply create your own executor once:</p>
<pre><code>async def get_byte_async(self):
    if self.executor is None:
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
    return await self.loop.run_in_executor(self.executor, self.get_byte)
</code></pre>
</div>
<span class="comment-copy">Check the implementation of aioserial. <a href="https://github.com/changyuheng/aioserial" rel="nofollow noreferrer">github.com/changyuheng/aioserial</a></span>
