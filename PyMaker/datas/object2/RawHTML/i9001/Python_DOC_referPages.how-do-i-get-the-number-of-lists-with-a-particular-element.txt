<div class="post-text" itemprop="text">
<p>I have a list of lists, which looks like</p>
<pre><code>listOfLists = [
    ['a','b','c','d'],
    ['a','b'],
    ['a','c'],
    ['c','c','c','c']  
 ] 
</code></pre>
<p>I want to count the number of lists which have a particular element. For Example, my output should be </p>
<pre><code>{'a':3,'b':2,'c':3,'d':1}
</code></pre>
<p>As you can see, I don't need the total count of an element. In the case of <code>"c"</code>, though its total count is 5, the output is 3 as it occurs only in 3 lists.</p>
<p>I am using a counter to get the counts. The same can be seen below.</p>
<pre><code>line_count_tags = []
for lists in lists_of_lists:
    s = set()
    for element in lists:
         s.add(t)
    lines_count_tags.append(list(s))

count = Counter([count for counts in lines_count_tags for count in counts])
</code></pre>
<p>So, when I print count, I get</p>
<pre><code>{'a':3,'c':3,'b':2,'d':1}
</code></pre>
<p>I want to know if there's a much better way to accomplish my goal.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <a href="https://docs.python.org/3/library/collections.html" rel="noreferrer"><code>Counter</code></a> and convert each list to a set. The <code>set</code> will remove any duplicates from each list so that you don't count duplicate values in the same list:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter

&gt;&gt;&gt; Counter(item for lst in listOfLists for item in set(lst))
Counter({'a': 3, 'b': 2, 'c': 3, 'd': 1})
</code></pre>
<p>If you like functional programming you can also feed a <code>chain</code> of <code>set</code>-<code>map</code>ped <code>listOfLists</code> to the <code>Counter</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from itertools import chain

&gt;&gt;&gt; Counter(chain.from_iterable(map(set, listOfLists)))
Counter({'a': 3, 'b': 2, 'c': 3, 'd': 1})
</code></pre>
<p>Which is totally equivalent (except maybe being a bit faster) to the first approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would convert each list as a set before counting in a generator comprehension passed to <code>Counter</code>:</p>
<pre><code>import collections
print(collections.Counter(y for x in listOfLists for y in set(x)))
</code></pre>
<p>result:</p>
<pre><code>Counter({'a': 3, 'c': 3, 'b': 2, 'd': 1})
</code></pre>
<p>(that's practically what you did, but the above code shorts a lot of loops and temporary list creations)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it without a <code>Counter</code>, too:</p>
<pre><code>result = {}
for lis in listOfLists:
    for element in set(lis):
        result[element] = result.get(element, 0) + 1
print result  # {'a': 3, 'c': 3, 'b': 2, 'd': 1}
</code></pre>
<p>Not the most elegant, but should be considerably faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>A bit of a stylistic difference on the <code>Counter</code> approach with <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable</code></a> may look like </p>
<pre><code>Counter(chain.from_iterable(map(set, listOfLists)))
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter(chain.from_iterable(map(set, listOfLists)))
Counter({'a': 3, 'b': 2, 'c': 3, 'd': 1})
</code></pre>
<hr/>
<p><strong>Rough benchmark</strong></p>
<pre><code>%timeit Counter(item for lst in listOfLists for item in set(lst))
100000 loops, best of 3: 13.5 µs per loop

%timeit Counter(chain.from_iterable(map(set, listOfLists)))
100000 loops, best of 3: 12.4 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just convert to <code>set</code>, flatten using <code>itertools.chain.from_iterable</code> and then feed into a <code>Counter</code>. </p>
<pre><code>from collections import Counter
from itertools import chain

inp = [
    ['a','b','c','d'],
    ['a','b'],
    ['a','c'],
    ['c','c','c','c']  
 ] 


print(Counter(chain.from_iterable(map(set, inp))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This approach calculates the unique entries in <code>listOfLists</code> using set comprehension, and then counts occurrences in each list using dictionary comprehension</p>
<pre><code>A = {val for s in listOfLists for val in s}
d = {i: sum( i in j for j in listOfLists) for i in A}
print(d) # {'a': 3, 'c': 3, 'b': 2, 'd': 1}
</code></pre>
<p>I'll admit it's a little ugly, but it's a possible solution (and a cool use of dictionary comprehension).
You could also make this a one-liner by moving the calculation of <code>A</code> right into the dictionary comprehension</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another version using loops:</p>
<pre><code>listOfLists = [
    ['a','b','c','d'],
    ['a','b'],
    ['a','c'],
    ['c','c','c','c']
    ]

final = {}
for lst in listOfLists:
    for letter in lst:
        if letter in final:
            final[letter] += 1
        else:
            final[letter] = 1
</code></pre>
<p>So create an empty dictionary called final. Then loop through each letter of each list. Create a new key and value = 1 if the letter does not yet exist in final as a key. Otherwise add 1 to the value for that key.</p>
</div>
<span class="comment-copy">I get much faster execution using <code>itertools.chain</code> (~40%!) on CPython 2.7.11. Still, <code>Counter</code> + <code>itertools.chain</code> execute 4 times slower than the <code>raw</code> method I presented.</span>
<span class="comment-copy">@zwer Eh, depends what input size we are discussing. My solution has more overhead, but if you increase the input size it shall be faster. That's why the benchmarking isn't all too important :)</span>
<span class="comment-copy">True that, I was just surprised at the stark difference in speed at my place, I'm not used to <code>itertools</code> actually outperforming, well, pretty much anything - they are usually the slower, but easier to read choice :D</span>
<span class="comment-copy">there is no need to cast your set <code>A</code> to a list again or feed the set with a list comprehension, a generation expression is better... actually you can build <code>A</code> as a set comprehension too</span>
<span class="comment-copy">@Copperfield Thanks for your suggestion. I've made a change.</span>
