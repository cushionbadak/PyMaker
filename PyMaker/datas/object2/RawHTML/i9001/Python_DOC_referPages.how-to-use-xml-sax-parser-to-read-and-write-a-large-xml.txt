<div class="post-text" itemprop="text">
<p>I'm trying to remove all the <code>project1</code> nodes (along with their child elements) from the below sample xml document (<em>original document is about 30 GB</em>) using SAX parser.It would be fine to have a separate modified file or ok with the in-line edit.</p>
<p><code>sample.xml</code></p>
<pre><code>&lt;ROOT&gt;
    &lt;test src="http://dfs.com"&gt;Hi&lt;/test&gt;
    &lt;project1&gt;This is old data&lt;foo&gt;&lt;/foo&gt;&lt;/project1&gt;
    &lt;bar&gt;
        &lt;project1&gt;ty&lt;/project1&gt;
        &lt;foo&gt;&lt;/foo&gt;
    &lt;/bar&gt;
&lt;/ROOT&gt;
</code></pre>
<p>Here is my attempt..</p>
<p><code>parser.py</code></p>
<pre><code>from xml.sax.handler import ContentHandler
import xml.sax

class MyHandler(xml.sax.handler.ContentHandler):
    def __init__(self, out_file):
        self._charBuffer = []
        self._result = []
        self._out = open(out_file, 'w')

    def _createElement(self, name, attrs):
        attributes = attrs.items()
        if attributes:
            out = ''
            for key, value in attributes:
                out += ' {}={}'.format(key, value)
            return '&lt;{}{}&gt;'.format(name, out)
        return '&lt;{}&gt;'.format(name)


    def _getCharacterData(self):
        data = ''.join(self._charBuffer).strip()
        self._charBuffer = []
        self._out.write(data.strip()) #remove strip() if whitespace is important

    def parse(self, f):
        xml.sax.parse(f, self)

    def characters(self, data):
        self._charBuffer.append(data)

    def startElement(self, name, attrs):
        if not name == 'project1': 
            self._result.append({})
            self._out.write(self._createElement(name, attrs))

    def endElement(self, name):
        if not name == 'project1': self._result[-1][name] = self._getCharacterData()

MyHandler('out.xml').parse("sample.xml")
</code></pre>
<p>I can't make it to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/xml.sax.utils.html#xml.sax.saxutils.XMLFilterBase" rel="nofollow noreferrer"><code>xml.sax.saxutils.XMLFilterBase</code></a> implementation to filter out your project1 nodes.</p>
<p>Instead of assembling the xml strings yourself you could use <a href="https://docs.python.org/3/library/xml.sax.utils.html#xml.sax.saxutils.XMLGenerator" rel="nofollow noreferrer"><code>xml.sax.saxutils.XMLGenerator</code></a>.</p>
<p>The following is Python3 code, adjust <code>super</code> if you require Python2. </p>
<pre><code>from xml.sax import make_parser
from xml.sax.saxutils import XMLFilterBase, XMLGenerator


class Project1Filter(XMLFilterBase):
    """This decides which SAX events to forward to the ContentHandler

    We will not forward events when we are inside any elements with a
    name specified in the 'tags_names_to_exclude' parameter
    """

    def __init__(self, tag_names_to_exclude, parent=None):
        super().__init__(parent)

        # set of tag names to exclude
        self._tag_names_to_exclude = tag_names_to_exclude

        # _project_1_count keeps track of opened project1 elements
        self._project_1_count = 0

    def _forward_events(self):
        # will return True when we are not inside a project1 element
        return self._project_1_count == 0

    def startElement(self, name, attrs):
        if name in self._tag_names_to_exclude:
            self._project_1_count += 1

        if self._forward_events():
            super().startElement(name, attrs)

    def endElement(self, name):
        if self._forward_events():
            super().endElement(name)

        if name in self._tag_names_to_exclude:
            self._project_1_count -= 1

    def characters(self, content):
        if self._forward_events():
            super().characters(content)

    # override other content handler methods on XMLFilterBase as neccessary


def main():
    tag_names_to_exclude = {'project1', 'project2', 'project3'}
    reader = Project1Filter(tag_names_to_exclude, make_parser())

    with open('out-small.xml', 'w') as f:
        handler = XMLGenerator(f)
        reader.setContentHandler(handler)
        reader.parse('input.xml')


if __name__ == "__main__":
    main()
</code></pre>
</div>
<span class="comment-copy">What's a problem to process data as text? Simply: check flag, is it down, grab line, is it project1, raise flag, write/append or not, repeat... Just an outline of strategy</span>
<span class="comment-copy">But this approach will results in loading the whole file into memory.</span>
<span class="comment-copy">I mean: read line - process line - update state - decide write or not. Don't work with whole file at once. There is no need.</span>
<span class="comment-copy">u can even use buffer to reduce write count. For example,  flush buffer only every 1000 lines. Measure it by yourself if it's important.</span>
<span class="comment-copy">@ar7max: The problem with processing XML as text is well know -- it leads to brittle solutions that break in a myriad ways when perfectly reasonable variations in the XML occur.   Please do not make such recommendations.  Thanks.</span>
<span class="comment-copy">Nice, even with empty lines. Want to check time cost.</span>
<span class="comment-copy">26 seconds slower on ~700mb file.</span>
<span class="comment-copy">Hi @Jeremy.. Your solution works for me.. May I know how I do the same for list of nodes, say <code>project1</code>, <code>project2</code>, <code>project3</code>?</span>
<span class="comment-copy">if name in ['project1','project2','project3']: self._project_1_count += 1 same for endElement method</span>
<span class="comment-copy">@AvinashRaj I have updated the code to exclude a set of tag names</span>
