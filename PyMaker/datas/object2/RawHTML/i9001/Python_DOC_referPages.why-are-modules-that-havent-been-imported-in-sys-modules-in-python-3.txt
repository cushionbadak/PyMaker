<div class="post-text" itemprop="text">
<p>I was reading <a href="https://stackoverflow.com/questions/30483246/how-to-check-if-a-python-module-has-been-imported">how to check if a python module has been imported</a> and the instructions seems clear, check for the module in the <code>sys.modules</code>. This works as I expected in Python 2, but not with Python 3 (3.5 and 3.6 tested). For example:</p>
<p>Python 3.6</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; 'itertools' in sys.modules
True
</code></pre>
<p>Python 2.7</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; 'itertools' in sys.modules
False
</code></pre>
<p>I note that, <code>itertools</code> is described as a 'built-in' in the Python 3 <code>sys.modules dict</code> (<code>&lt;module 'itertools' (built-in)&gt;</code>), and not in Python 2 so maybe that's why it's in <code>sys.modules</code> prior to being imported, but it's <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">not listed as a built-in</a>. Anyway, since <code>itertools</code> still needs importing in Python 3, I'd be grateful for an explanation.</p>
</div>
<div class="post-text" itemprop="text">
<p>They <em>have</em> been imported, just not by you. Exactly what parts of interpreter startup caused the module to be loaded are unimportant implementation details, but you can trace possible paths if you want. For example, <code>itertools</code> is imported by <a href="https://github.com/python/cpython/blob/3.6/Lib/reprlib.py#L6" rel="noreferrer"><code>reprlib</code></a></p>
<pre><code>from itertools import islice
</code></pre>
<p>which is imported by <a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py" rel="noreferrer"><code>functools</code></a>:</p>
<pre><code>from reprlib import recursive_repr
</code></pre>
<p>which is imported by <a href="https://github.com/python/cpython/blob/3.6/Lib/types.py" rel="noreferrer"><code>types</code></a>:</p>
<pre><code>import functools as _functools
</code></pre>
<p>which is imported by <a href="https://github.com/python/cpython/blob/3.6/Lib/importlib/__init__.py" rel="noreferrer"><code>importlib</code></a>:</p>
<pre><code>import types
</code></pre>
<p>which is bootstrapped at interpreter startup because it's where most of the implementation of importing is.</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that in Python 3, the itertools extension is actually compiled into the main Python binary unlike Python 2. If you do a</p>
<pre><code>import sys
</code></pre>
<p>and then a</p>
<pre><code>'itertools' in sys.builtin_module_names
&gt;&gt; True
</code></pre>
<p>it is clear. Doing the exact same steps in a Python 2.x console results in a <code>False</code>.</p>
<p><a href="https://docs.python.org/3/library/sys.html#sys.builtin_module_names" rel="nofollow noreferrer">As per the docs</a>, <code>builtin_module_names</code> comprises of <strong>'modules that are compiled into this Python interpreter'</strong>.</p>
</div>
<span class="comment-copy">If any modules that you've <i>already imported</i> need to import modules of their own, those modules will show as loaded. Perhaps a dependency was introduced in Python 3 that didn't exist in Python 2. P.S. even if a module is loaded, you need to <code>import</code> it to make it available in the current scope.</span>
<span class="comment-copy">I think you've answered the question yourself: if <code>itertools</code> has become a builtin, it will be loaded right at the interpreter's startup.</span>
<span class="comment-copy">is the question why <code>itertools</code> needs importing or why is it there and not listed as such in the docs?</span>
<span class="comment-copy">@ForceBru: No, built-in modules aren't all loaded at startup. You can check this by comparing <code>sys.builtin_module_names</code> against <code>sys.modules</code> in a fresh interpreter.</span>
<span class="comment-copy">@JimFasarakis-Hilliard The question is why is <code>itertools</code> (and some other modules I tested) in <code>sys.modules</code> prior to being imported in Python 3 and not in Python 2</span>
<span class="comment-copy">Great, thank you for the authoritative answer. So the interpreter imports <code>itertools</code> (and other modules like <code>os</code>) but doesn't add them to <code>globals()</code> so they're not accessible?</span>
<span class="comment-copy">@Chris_Rands: It follows the normal rules for importing. If module <code>foo</code> does <code>import bar</code>, that import only makes the <code>bar</code> module available for the <code>foo</code> module. Everyone that wants to use a module needs to import it themselves.</span>
<span class="comment-copy">and that's why you can't find it in <code>Py 2</code> I'm guessing, when the import mechanism was still implemented in <code>C</code> and (apparently) didn't indirectly import <code>itertools</code>.</span>
<span class="comment-copy">the question is <i>why</i> this is, not that it just is.</span>
<span class="comment-copy">@JimFasarakis-Hilliard The answer to "<i>why is itertools in sys.modules prior to being imported in Python 3 and not in Python 2</i>" is "<i>because it's a builtin which is proved by it's presence in</i> <code>builtin_module_names</code>".</span>
<span class="comment-copy">While the module does happen to be compiled into Python, such modules still need to be initialized and loaded by an import somewhere before they show up in <code>sys.modules</code>.</span>
<span class="comment-copy">I honestly don't see the logic behind a downvote, though..</span>
<span class="comment-copy">I downvoted because this answer implies that the reason <code>itertools</code> is loaded at startup is because it's built in. Not all built-in modules are loaded at interpreter startup.</span>
