<div class="post-text" itemprop="text">
<p>I have a list of dicts which specify flows (source to hop to destionation with their respective volume).
Now i want to split these flows into link (e.g. (source to hop with volume, hop to destination with volume) and merge all duplicate links together by summing up their volumes. </p>
<p>Since I'm new to python I'm wondering what a good approach would be. My first approach would be to loop through all flows and nest a loop through all links inside and check if the links already exists. </p>
<p>But if I have millions of flows, that might become quite ineffienct and slow I guess.</p>
<p>My starting data looks like this:</p>
<pre><code>flows = [
    {
        'source': 1,
        'hop': 2,
        'destination': 3,
        'volume': 100,
    },{
        'source': 1,
        'hop': 2,
        'destination': 4,
        'volume': 50,
    },{
        'source': 2,
        'hop': 2,
        'destination': 4,
        'volume': 200,
    },
]
</code></pre>
<p>What my result should be:</p>
<pre><code>links = [
    {
        'source': 1,
        'hop': 2,
        'volume': 150,
    },{
        'hop': 2,
        'destination': 3,
        'volume': 100,
    },{
        'hop': 2,
        'destination': 4,
        'volume': 250,
    },{
        'source': 2,
        'hop': 2,
        'volume': 200,
    },
]
</code></pre>
<p>Thanks a lot for your help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can collect the links to two different dictionaries, one between source &amp; hop and another one between hop &amp; destination. Then you can easily create the result list separately from both of the dicts. Below <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> is used which is <code>dict</code> like object with 0 as default value:</p>
<pre><code>import pprint
from collections import Counter

flows = [
    {
        'source': 1,
        'hop': 2,
        'destination': 3,
        'volume': 100.5,
    },{
        'source': 1,
        'hop': 2,
        'destination': 4,
        'volume': 50,
    },{
        'source': 2,
        'hop': 2,
        'destination': 4,
        'volume': 200.7,
    },
]

sources = Counter()
hops = Counter()

for f in flows:
    sources[f['source'], f['hop']] += f['volume']
    hops[f['hop'], f['destination']] += f['volume']

res = [{'source': source, 'hop': hop, 'volume': vol} for (source, hop), vol in sources.items()]
res.extend([{'hop': hop, 'destination': dest, 'volume': vol} for (hop, dest), vol in hops.items()])
pprint.pprint(res)
</code></pre>
<p>Output:</p>
<pre><code>[{'hop': 2, 'source': 1, 'volume': 150.5},
 {'hop': 2, 'source': 2, 'volume': 200.7},
 {'destination': 3, 'hop': 2, 'volume': 100.5},
 {'destination': 4, 'hop': 2, 'volume': 250.7}]
</code></pre>
<p>Above will run in <strong>O(n)</strong> time so it should work with millions of flows provided you have enough memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>pseudo algorithm:</p>
<ol>
<li>create an empty result list/set/dictionary </li>
<li>loop over de flows list</li>
<li>split up each single flow into 2 links </li>
<li>for each of these 2 links test if they are already in the result list (based on the 2 nodes). </li>
<li>if not: add them. if yes: upgrade the volume of the one already in the list.</li>
</ol>
</div>
<span class="comment-copy"><a href="http://pandas.pydata.org/" rel="nofollow noreferrer">python pandas</a> is your friend</span>
<span class="comment-copy">I like your approach, bu my volume is actually a float. So no easy counting I guess...  Any ideas how to solve that?</span>
<span class="comment-copy">@mxzwrnz Fixed the issue, for some reason I read the input like volume would have been a string which I then converted to int so that I could sum it. Remove the unnecessary code and it works fine.</span>
<span class="comment-copy">That's what I thought about too. But my main question is, how step 4 can be done efficiently. How can I check that besides looping through my result list every time?</span>
<span class="comment-copy">Use the <code>in</code> statement. Example: <code>(1, 2) in [(2, 3), (1, 2)]</code> will give <code>True</code>.</span>
<span class="comment-copy">But I can't compare it like that because a tuple would contain source and tagert but also the volume which is likely to differ from link to link (and needs to be summed up).</span>
<span class="comment-copy">Then you slice the tuple: <code>(1, 2, 98.7)[:2]</code> will give <code>(1, 2)</code>.</span>
<span class="comment-copy">Is it possible to write <code>(1, 2, 50.5)[:2] in [(2, 3), (1, 2)][:2]</code> ? How can I compare a (partial) tuple with a list of tuple partials without looping over them?</span>
