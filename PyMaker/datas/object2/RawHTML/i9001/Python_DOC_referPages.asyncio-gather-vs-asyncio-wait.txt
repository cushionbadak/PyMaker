<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="noreferrer"><code>asyncio.gather</code></a> and <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="noreferrer"><code>asyncio.wait</code></a> seem to have similar uses: I have a bunch of async things that I want to execute/wait for (not necessarily waiting for one to finish before the next one starts). They use a different syntax, and differ in some details, but it seems very un-pythonic to me to have 2 functions that have such a huge overlap in functionality. What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Although similar in general cases ("run and get results for many tasks"), each function has some specific functionality for other cases:</p>
<h1><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="noreferrer"><code>asyncio.gather()</code></a></h1>
<p>Returns a Future instance, allowing high level grouping of tasks:</p>
<pre><code>import asyncio
from pprint import pprint

import random


async def coro(tag):
    print("&gt;", tag)
    await asyncio.sleep(random.uniform(1, 3))
    print("&lt;", tag)
    return tag


loop = asyncio.get_event_loop()

group1 = asyncio.gather(*[coro("group 1.{}".format(i)) for i in range(1, 6)])
group2 = asyncio.gather(*[coro("group 2.{}".format(i)) for i in range(1, 4)])
group3 = asyncio.gather(*[coro("group 3.{}".format(i)) for i in range(1, 10)])

all_groups = asyncio.gather(group1, group2, group3)

results = loop.run_until_complete(all_groups)

loop.close()

pprint(results)
</code></pre>
<p>All tasks in a group can be cancelled by calling <code>group2.cancel()</code> or even <code>all_groups.cancel()</code>.  See also <code>.gather(..., return_exceptions=True)</code>,</p>
<h1><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="noreferrer"><code>asyncio.wait()</code></a></h1>
<p>Supports waiting to be stopped after the first task is done, or after a specified timeout, allowing lower level precision of operations:</p>
<pre><code>import asyncio
import random


async def coro(tag):
    print("&gt;", tag)
    await asyncio.sleep(random.uniform(0.5, 5))
    print("&lt;", tag)
    return tag


loop = asyncio.get_event_loop()

tasks = [coro(i) for i in range(1, 11)]

print("Get first result:")
finished, unfinished = loop.run_until_complete(
    asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED))

for task in finished:
    print(task.result())
print("unfinished:", len(unfinished))

print("Get more results in 2 seconds:")
finished2, unfinished2 = loop.run_until_complete(
    asyncio.wait(unfinished, timeout=2))

for task in finished2:
    print(task.result())
print("unfinished2:", len(unfinished2))

print("Get all other results:")
finished3, unfinished3 = loop.run_until_complete(asyncio.wait(unfinished2))

for task in finished3:
    print(task.result())

loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>asyncio.wait</code> is more low level than <code>asyncio.gather</code>.</p>
<p>As the name suggests, <code>asyncio.gather</code> mainly focuses on gathering the results. it waits on a bunch of futures and return their results in a given order.</p>
<p><code>asyncio.wait</code> just waits on the futures. and instead of giving you the results directly, it gives done and pending tasks. you have to mannually collect the values.</p>
<p>Moreover, you could specify to wait for all futures to finish or the just the first one with <code>wait</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I also noticed that you can provide a group of coroutines in wait() by simply specifying the list:</p>
<pre><code>result=loop.run_until_complete(asyncio.wait([
        say('first hello', 2),
        say('second hello', 1),
        say('third hello', 4)
    ]))
</code></pre>
<p>Whereas grouping in gather() is done by just specifying multiple coroutines:</p>
<pre><code>result=loop.run_until_complete(asyncio.gather(
        say('first hello', 2),
        say('second hello', 1),
        say('third hello', 4)
    ))
</code></pre>
</div>
<span class="comment-copy">"The single asterisk form ( *args ) is used to pass a non-keyworded, variable-length argument list, and the double asterisk form is used to pass a keyworded, variable-length argument list"</span>
<span class="comment-copy">Lists can also be used with <code>gather()</code>, e.g.: <code>asyncio.gather(*task_list)</code></span>
<span class="comment-copy">So can generators</span>
