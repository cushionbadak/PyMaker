<div class="post-text" itemprop="text">
<p>Recently i'm reading a book, it mentioned the mro in multiple inheritance, and give sample code:</p>
<pre><code>class A(object):
    def __init__(self):
        print "A"
        super(A, self).__init__()

class B(object):
    def __init__(self):
        print "B"
        super(B, self).__init__()

class C(A,B):
    def __init__(self):
        print "C"
        A.__init__(self)
        B.__init__(self)

C()
</code></pre>
<p>output:</p>
<pre><code>C
A
B
B
</code></pre>
<p>I wanna know why this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>This happens because you're mixing direct constructor calls and calls via <code>super</code>. Your class hierarchy should do either one or the other.</p>
<p>More precisely, the MRO for the class <code>C</code> is <code>C, A, B</code>. Thus, when you call <code>super(A, self).__init__()</code> in A's constructor, that calls the constructor for <code>B</code>, since <code>B</code> succeeds <code>A</code> in <code>C</code>'s MRO. In other words, it is inside <code>A</code>'s constructor that the first <code>B</code> is printed.</p>
<p>As an aside, writing out <code>super(A, self)</code> is superfluous in Python 3. <code>super()</code> is enough; the arguments are <a href="https://www.python.org/dev/peps/pep-3135/" rel="nofollow noreferrer">deduced</a> from the context.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code> documentation</a></li>
<li><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">Guide to using <code>super()</code></a></li>
<li><a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow noreferrer">The C3 method resolution order</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I've converted your code to Python3 (by changing <code>print</code> to <code>print()</code>) and added some more tracing statements:</p>
<pre><code>class A(object):
    def __init__(self):
        print("A", type(self).__mro__)
        super(A, self).__init__()
        print("/A")

class B(object):
    def __init__(self):
        print("B", type(self).__mro__)
        super(B, self).__init__()
        print("/B")

class C(A,B):
    def __init__(self):
        print("C")
        A.__init__(self)
        print("ca/b")
        B.__init__(self)
        print("/C")

C()
</code></pre>
<p>Here's the output:</p>
<pre><code>C
A (&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)
B (&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)
/B
/A
ca/b
B (&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)
/B
/C
</code></pre>
<p>Looking at the output, you can see the call to the <code>C.__init__</code> method is happening, and printing 'C'. It then calls <code>A.__init__</code> directly (which is a mistake- use <code>super</code>!).</p>
<p>The <code>A.__init__</code> call prints its message, including the <code>__mro__</code> attribute. You can see the sequence: C -&gt; A -&gt; B -&gt; Object. This is important, because it means that calls to <code>super()</code> from within <code>A.__init__</code> are going to refer to class <code>B</code>. Also, calls to <code>super</code> from inside <code>C.__init__</code> would have invoked <code>A.__init__</code> automatically, if you let them.</p>
<p>The next method, <code>B.__init__</code>, is invoked by the <code>super</code> reference inside <code>A.__init__</code>, as mentioned. It calls <code>Object.__init__</code>, presumably, which prints nothing. ;-)</p>
<p>Both <code>B.__init__</code> and <code>A.__init__</code> return, we see the midpoint message <code>ca/b</code>, and then your direct call to <code>B.__init__</code> is made. It prints a message, but again a reference to <code>super</code> form <code>B.__init__</code> does nothing, because <code>B</code> is at the tail end of the MRO.</p>
<p>The <code>super()</code> mechanism can deal with all this MRO stuff for you. You shouldn't have to invoke <code>A.__init__(self)</code>. Instead, you can just let <code>super</code> handle it, inside <code>C.__init__</code>, but doing this:</p>
<pre><code>class C(A,B):
    def __init__(self):
        print("C")
        super(C, self).__init__()
</code></pre>
</div>
<span class="comment-copy">That's so great!  Thank you</span>
