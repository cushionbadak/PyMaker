<div class="post-text" itemprop="text">
<p>In Haskell we have asynchronous exceptions; we can use <a href="https://www.stackage.org/haddock/lts-7.19/base-4.9.0.0/Control-Concurrent.html#v:throwTo" rel="nofollow noreferrer"><code>throwTo</code></a> to raise any exception in another thread:</p>
<blockquote>
<pre><code>throwTo :: Exception e =&gt; ThreadId -&gt; e -&gt; IO ()
</code></pre>
<p><code>throwTo</code> raises an arbitrary exception in the target thread (GHC only).</p>
</blockquote>
<p>To be able to write code with guarantees like "will always release a lock after acquiring it", we have <a href="https://www.stackage.org/haddock/lts-7.19/base-4.9.0.0/Control-Exception.html#v:mask" rel="nofollow noreferrer"><code>mask</code></a> to run code in which asynchronous exceptions may only be received while the computation is blocking:</p>
<blockquote>
<pre><code>mask :: ((forall a. IO a -&gt; IO a) -&gt; IO b) -&gt; IO b
</code></pre>
<p>Executes an IO computation with asynchronous exceptions <em>masked</em>. That is, any thread which attempts to raise an exception in the current thread with <code>throwTo</code> will be blocked until asynchronous exceptions are unmasked again.</p>
</blockquote>
<p>and a stronger <a href="https://www.stackage.org/haddock/lts-7.19/base-4.9.0.0/Control-Exception.html#v:uninterruptibleMask" rel="nofollow noreferrer"><code>uninterruptibleMask</code></a> in which async exceptions will not be raised <em>at all</em> during a masked computation:</p>
<blockquote>
<pre><code>uninterruptibleMask :: ((forall a. IO a -&gt; IO a) -&gt; IO b) -&gt; IO b
</code></pre>
<p>Like <code>mask</code>, but the masked computation is not interruptible</p>
</blockquote>
<p>Masking is used to implement higher-level abstractions like <a href="https://www.stackage.org/haddock/lts-7.19/base-4.9.0.0/Control-Exception.html#v:bracket" rel="nofollow noreferrer"><code>bracket</code></a>:</p>
<blockquote>
<pre><code>bracket
    :: IO a         -- computation to run first ("acquire resource")
    -&gt; (a -&gt; IO b)  -- computation to run last ("release resource")
    -&gt; (a -&gt; IO c)  -- computation to run in-between
    -&gt; IO c         -- returns the value from the in-between computation
</code></pre>
<p>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use <code>bracket</code>, because <code>bracket</code> will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then <code>bracket</code> will re-raise the exception (after performing the release).</p>
</blockquote>
<p>If I understand correctly, Python has a (less general) form of asynchronous exceptions, with the most notable manifestation being <a href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" rel="nofollow noreferrer"><code>KeyboardInterrupt</code></a>:</p>
<blockquote>
<p>Raised when the user hits the interrupt key (normally <kbd>Control</kbd>-<kbd>C</kbd> or <kbd>Delete</kbd>). During execution, a check for interrupts is made regularly.</p>
</blockquote>
<p>The documentation is imprecise about when the "check for interrupts" may occur, but it seems to imply that a <code>KeyboardInterrupt</code> may be raised at <em>any</em> point in a program's execution. So it seems, then, that Python's async exceptions come with all the same subtle difficulties of maintaining correctness.</p>
<p>For example, consider a pattern like this:</p>
<pre><code>x = None
try:
    x = acquire()
    do_something(x)    # (1)
finally:
    if x is not None:  # (2)
        release(x)
</code></pre>
<p>If any exception is raised during <code>(1)</code>, then we are assured that the contents of the <a href="https://docs.python.org/3/reference/compound_stmts.html#finally" rel="nofollow noreferrer"><code>finally</code></a> block will be executed. But what happens if a <code>KeyboardInterrupt</code> is during <code>(2)</code>?</p>
<p>It seems fundamentally impossible to guarantee resource cleanup in the presence of asyc exceptions without a way to mask them. Is there some facility for this, or do we rely on the <a href="https://en.wikipedia.org/wiki/Ostrich_algorithm" rel="nofollow noreferrer">ostrich algorithm</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what context managers are for.</p>
<pre><code>with acquire() as x:
    do_something(x)
</code></pre>
<p><code>acquire</code> returns an object whose type defines an <code>__enter__</code> method, which returns the value bound to <code>x</code>, and an <code>__exit__</code> method, which is executed at the end of the <code>with</code> statement regardless of how the statement is exited.</p>
</div>
<span class="comment-copy">I think you pretty much have to install your own signal handler for Ctrl-C if you want to do this.</span>
<span class="comment-copy">Can the <code>__exit__</code> method be interrupted if a further exception happens?</span>
<span class="comment-copy">@DanielWagner My vague memory from way back when I wrote Python: exceptions that occur during <code>__exit__</code> interrupt the <code>__exit__</code> method as normal; the exception that prompted the <code>__exit__</code> block becomes the later exception's <code>__cause__</code>.</span>
<span class="comment-copy">You do have to install a signal handler yourself, but the <code>__exit__</code> method provides a convenient scope for that: install the handler immediately upon entering the method, and restore the previous handler before exiting it.</span>
<span class="comment-copy">Same question: Can the execution of a signal handler be interrupted by another signal?</span>
