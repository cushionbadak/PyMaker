<div class="post-text" itemprop="text">
<p>I am fairly new to python and am using a list comprehension in the following snippet:</p>
<pre><code>while offset &lt; len(list)
    s = ['{:04x}'.format(i) for i in list[offset:offset+16]]
    do stuff with s
    offset += 16
</code></pre>
<p>The snippet loops through the <code>list</code> and adds <em>up to</em> 16 elements to s in a formatted manner, then adds 16 to the offset value to obtain the next 16 until all elements are seen. This works in my unsimplified code, but I'd like to impose a placeholder for when the slice exceeds the list size, instead of having it just stop adding elements to <code>s</code>. I know I can do this with a full for loop but would like to try and do this in comprehension for the sake of keeping this concise to one line. I imagine I would need an <code>if/else</code> in the comprehension but cannot seem to figure out what conditions are needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can dynamically pad the sliced chunk to a fixed size. For example:</p>
<pre><code>while offset &lt; len(l):
    s = ['{:04x}'.format(i) for i in l[offset:offset + 16] + [0] * max(0, offset + 16 - len(l))]
    offset += 16
    # Do something
</code></pre>
<p>For example with fixed size of 4, this code:</p>
<pre><code>WIDTH = 4
offset = 0
l = list(range(10))
while offset &lt; len(l):
    s = ['{:04x}'.format(i) for i in
         l[offset:offset + WIDTH] + [0] * max(0, offset + WIDTH - len(l))]
    offset += WIDTH
    print(s)
</code></pre>
<p>Yields:</p>
<pre><code>['0000', '0001', '0002', '0003']
['0004', '0005', '0006', '0007']
['0008', '0009', '0000', '0000']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Concatenate your slice with a  list containing  placeholders - thus when the slice is over, the placeholders will be fetched, and add to the loop a secondary iterator with the final size you want (a <code>range</code> will do), to limit the yielded items from the first part:</p>
<pre><code>s = ['{:04x}'.format(i) for i, j in in  zip(list[offset:offset+16] + ([placeholder] * 16)  , range(16) ) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way would be to use some sort of <code>grouper</code> that gives you the blocks. The <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code></a>-module presents such a function:</p>
<pre><code>from itertools import zip_longest  # or izip_longest in Python2

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>And with that function you can do it like this:</p>
<pre><code>lst = list(range(20))

for group in grouper(lst, n=8, fillvalue=0):
    print(['{:04x}'.format(i) for i in group])
</code></pre>
<p>yielding this output:</p>
<pre><code>['0000', '0001', '0002', '0003', '0004', '0005', '0006', '0007']
['0008', '0009', '000a', '000b', '000c', '000d', '000e', '000f']
['0010', '0011', '0012', '0013', '0000', '0000', '0000', '0000']
</code></pre>
</div>
<span class="comment-copy">Why are you doing this? What's the rationale behind this process? Remember, "clever" code is often less concise than pragmatic code.</span>
<span class="comment-copy">Can you give an example of an action you'd like to perform in that case?</span>
<span class="comment-copy">The purpose of the code is to create a table of data from an input file (there's quite a bit I removed from the working copy), so the placeholder values would fill in the void cells at the end and keep all rows 16 in length. The purpose of doing this with comprehension is simply to explore how/if it can be done.</span>
<span class="comment-copy">Do not <i>ever</i> call your variable <code>list</code>! <code>list()</code> is the list constructor. And, since the number of iterations of your loop is know, <code>for offset in range(0,len(list),16):</code> would be a more appropriate loop.</span>
<span class="comment-copy">I only called the variable <code>list</code> for the pseudocode, it's not called that in the working code</span>
<span class="comment-copy">Thanks for the help, hadn't even considered modifying the list itself to achieve this.</span>
