<div class="post-text" itemprop="text">
<p>(using 2.7) </p>
<p>Currently having an issue, and i've been attempting to go through the processes of os.walk / os.rename. But at the current time, only the main file is getting appended with _final, instead of all the files inside of that one as well. </p>
<p>So for example</p>
<blockquote>
<p>Main
  ---&gt; sub1
  -&gt; sub2
  -&gt; sub3</p>
</blockquote>
<p>Needs to be </p>
<blockquote>
<p>Main_final (currently stopping here)
  ----&gt; sub1_final
  -&gt; sub2_final
  -&gt; sub3_final</p>
</blockquote>
<p>Here's my code at the moment, </p>
<pre><code>import shutil
import sys
import os

def rename():
        ### pseudo
        for folderName, subfolders, filenames in os.walk(path, topdown=##???):
            for subfolder in subfolders:
                print subfolder
                os.rename(os.path.join(folderName, subfolders), os.path.join(folderName, subfolders + 'rename'))

            print('')

    else:
        print("Directory does not exist")

if __name__ == '__main__':
    copy()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Walk the tree with topdown set to False - Rename sub-directories first, and top-level directories last, renaming  top-level directories will no longer affect the sub-directories.</p>
<p>From <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer">Documentation</a> </p>
<blockquote>
<p>If optional argument topdown is True or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top-down). If topdown is False, the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom-up). No matter the value of topdown, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated.</p>
<p>When topdown is True, the caller can modify the dirnames list in-place (perhaps using del or slice assignment), and walk() will only recurse into the subdirectories whose names remain in dirnames; this can be used to prune the search, impose a specific order of visiting, or even to inform walk() about directories the caller creates or renames before it resumes walk() again. Modifying dirnames when topdown is False has no effect on the behavior of the walk, because in bottom-up mode the directories in dirnames are generated before dirpath itself is generated.</p>
</blockquote>
<pre><code>import os

path = "path/to/folder"
for root, dirs, files in os.walk(path, topdown=False):
    for dirname in dirs:
        print os.path.join(root, dirname)
        os.rename(os.path.join(root, dirname), os.path.join(root, dirname+"_Final"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>os.walk(fc)</code> returns a generator object, so if you edit the entries during the walk or iteration, the <code>os.walk</code> confuses(it uses a dfs traversal algorithm, so the previous stack entries doesn't exist anymore) and so it raises <code>StopIteration</code></p>
<p>you need to get all the entries and rename files in the order of deepest entries first.</p>
<pre><code>import shutil
import sys
import os
from operator import itemgetter

def copy():

    print("copy program")
    set_path = "D:\\test\\test1"
    os.chdir(set_path)

    if os.path.exists(set_path):
        fc ='D:\\test\\test1\\final'
        working = '_final'
        shutil.copytree(set_path, fc)
        os.chdir(fc)


        stack = [0]
        entries = []
        for folder, subfolders, files in os.walk(fc):
            lev = stack.pop()
            for subfolder in subfolders:
                entries.append((os.path.join(folder, subfolder), lev + 1))
            for file in files:
                entries.append((os.path.join(folder, file), lev + 1))
            stack.extend([lev + 1]*len(subfolders))
        for fpath in map(itemgetter(0), sorted(entries, key=lambda x: -x[1])):
            os.rename(fpath, fpath + working)

    else:
        print("Directory does not exist")

if __name__ == '__main__':
    copy()
</code></pre>
<p>it worked on my system
<a href="https://i.stack.imgur.com/wYkHm.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/wYkHm.png"/></a></p>
</div>
<span class="comment-copy">Hi,   It does not append _Final to the sub folders inside the main and stops at the first folder.</span>
<span class="comment-copy">updated the answer, we need to add topdown=False parameter to os.walk</span>
<span class="comment-copy">Thank you so much for your assistance in understanding topdown!!! Really helpful!</span>
<span class="comment-copy">it's throwing me an error from the rename, saying it cannot find file specified</span>
<span class="comment-copy">sorry about that, I've corrected it and tested the code on my system</span>
