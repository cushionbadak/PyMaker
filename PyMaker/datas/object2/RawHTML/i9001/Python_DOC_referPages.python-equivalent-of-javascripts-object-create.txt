<div class="post-text" itemprop="text">
<p>What would be the Python equivalent of JavaScript's <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="nofollow noreferrer">Object.create()</a> functionality?</p>
<p>For example, in JS this is possible:</p>
<pre class="lang-js prettyprint-override"><code>var s = { 'pots': 5, 'cups': 2 };
var t = Object.create( s );
console.log( t['pots'] );               // 5

t['pots'] = 9000;
console.log( t['pots'] );               // 9000
console.log( t['__proto__']['pots'] );  // 5, unchanged

s['pots'] = 33;
console.log( t['pots'] );               // 9000, unchanged
console.log( t['__proto__']['pots'] );  // 33
</code></pre>
<p>The closest thing I can think of is using <a href="https://docs.python.org/3/library/copy.htm" rel="nofollow noreferrer">copy</a>:</p>
<pre class="lang-py prettyprint-override"><code>s = { 'pots': 5, 'cups': 2 }
t = copy.copy( s )
</code></pre>
<p>It works, but it seems very wasteful to create a new copy of the reference object each time I want to inherit its properties.</p>
<p>Also I'm working with simple objects of the type seen above... not class instances.</p>
</div>
<div class="post-text" itemprop="text">
<p>The dictionary class <code>dict</code> accepts another dictionary in its constructor.</p>
<pre><code>s = { 'pots': 5, 'cups': 2 }
t = dict(s)
</code></pre>
<p>This is a shallow copy, which is fine when you're using immutable objects as values. (Keys must always be immutable types.) If you are using mutable containers such as other dictionaries (or lists, or various other types) as values, you should use <code>copy.deepcopy()</code>.</p>
<p>It's important to note that in Python, items in a container (like a <code>dict</code>) and attributes on an object are different things entirely, accessed in different ways, and neither is exactly like a property in JavaScript. What you are actually trying to do is better accomplished by classes in Python:</p>
<pre><code>class Thing(object):
    pots = 5
    cups = 2

s = Thing()
t = Thing()
</code></pre>
<p>In this case, <code>s.pots</code> accesses the value stored on the <code>Thing</code> class until you actually assign <code>s.pots</code>, at which point the instance's value of that attribute shadows the value stored on the class.  So space is used on the instance only for attributes that have actually been assigned. </p>
<p>You can also define <code>__slots__</code> on the class to allow only attributes of specific names to be assigned; this can reduce the memory overhead of instances, which is handy if you will be creating a lot of them.</p>
<p>The Python way of accessing attributes using a variable (or expression) rather than dot notation is the <code>getattr()</code> function. It is possible to create an object that can access the same data using either <code>.</code> or <code>[]</code>, but it's trickier than you might expect to get it to work <em>exactly</em> like it does in JavaScript.</p>
<p>When you are using classes, the closest equivalent to your example (given an <code>s</code>, create a <code>t</code> with <code>s</code>'s own attributes) is something like this:</p>
<pre><code>t = type(s)()
t.__dict__.update(s.__dict__)
</code></pre>
<p>You could provide a method to do this:</p>
<pre><code>class Cloneable(object):
    def clone(self):
        inst = type(self)()
        inst.__dict__.update(self.__dict__)
        return inst
</code></pre>
<p>Then derive <code>Thing</code> from <code>Cloneable</code> rather than <code>object</code> and you can do:</p>
<pre><code>s = Thing()
t = s.clone()
</code></pre>
</div>
<span class="comment-copy">There is no distinction between 'simple objects' and class instances - all objects behave in the same way. Python uses class-based inheritance not  prototype based inheritance.</span>
<span class="comment-copy">Huh. I like this perspective. Upvoted.</span>
