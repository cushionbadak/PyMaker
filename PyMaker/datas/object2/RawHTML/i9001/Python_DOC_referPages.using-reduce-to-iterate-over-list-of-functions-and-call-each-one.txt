<div class="post-text" itemprop="text">
<p>Currently i'm using a list of strings with names of functions to fix the flow of my software:</p>
<pre><code>flow = [
  "func1",
  "func2",
  "func3",
  "func4",
  "func5"
]
</code></pre>
<p>Then i iterate over the flow and call each one passing the options:</p>
<pre><code>options = {}
[getattr(__import__(phase), phase)(options) for phase in flow]
</code></pre>
<p>I would like to know if is it possible to do the same, but avoiding side effects, using reduce. Currently, this approach it's making the functions receive the option, but isn't necessary return the options for the next function, so i'm changing the options that is declared in other scope.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> (which is sometimes called <code>fold</code> in other functional programming languages like Haskell) to indeed call the function.</p>
<p>In that case however you will need to define a function <strong>taking</strong> two parameters: the <em>old accumulator</em> value and the element itself. You simply ignore the old value and call the function on the element.</p>
<p>So for a generic function <code>f(x)</code>, you can do this with:</p>
<pre><code>functools.reduce(lambda _,x:f(x),list,initializer=0)
</code></pre>
<p>So in your case that would be:</p>
<pre><code>options = {}
functools.reduce(lambda _,phase:getattr(__import__(phase),phase)(options),flow,initializer=0)
</code></pre>
<p><strong>EDIT</strong>:</p>
<p>after rereading your question, it appears to me that each of the functions takes as input <code>options</code>, and generates the "new" options that should be passed to the next function. Well the return of the first function, is the first parameter of the <code>lambda</code> of the next function. So you can fold it together like:</p>
<pre><code>first_options = {}
functools.reduce(lambda options,phase:getattr(__import__(phase),phase)(options),flow,initializer=first_options)
</code></pre>
<p>This will result in something equivalent to:</p>
<pre><code>options_0 = first_options
options_1 = getattr(__import__(phase),flow[0])(options_0)
options_2 = getattr(__import__(phase),flow[1])(options_1)
# ...
return options_n
</code></pre>
<p>but of course this happens <em>inside</em> the <code>reduce</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>so reduce takes one a function, say <code>reduce_func</code>, that takes on 2 arguments. When it goes through a list it takes the first two items as the params of <code>reduce_func</code> for the first call, then on each subsequent call, uses the return value as the first param, and the next value on the list as the second param. This means, for you, <code>reduce_func</code> needs to be the following</p>
<pre><code>def reduce_func(param, f):
   return f(param)
</code></pre>
<p>and your list needs to be the following:</p>
<pre><code>[options, func1, func2, func3, func4]
</code></pre>
<p>Now, I used a list of functions and didn't use import. In stead of <code>f</code>, you could pass in <code>[module].[function]</code> as a string (call the param something like <code>func_str</code>), and do some splitting and inside of <code>reduce_func</code> as some set up.</p>
</div>
<span class="comment-copy">How are you building that list?  Could you just place the function objects in that list <code>[func1, func2, ...]</code>  That would make it a lot simpler</span>
<span class="comment-copy">Why would be a lot simpler? I would just remove the get and import attributes.</span>
<span class="comment-copy">A for loop would have side effects, and i want end the software using the return code from the last function. I mean, if the software succeeds, the last function will return 0, meaning everything is ok</span>
<span class="comment-copy">And all the functions receive as input, the output from the previous function called</span>
<span class="comment-copy">I'm sorry, but where are the side-effects in your comprehension?</span>
<span class="comment-copy">What about using the options as initializer?</span>
<span class="comment-copy">@CelixOderix: you mean that the <i>old</i> function creates <i>new</i> options for the next one?</span>
<span class="comment-copy">Yes! Perfectly, that's exactly what i was trying to do!</span>
