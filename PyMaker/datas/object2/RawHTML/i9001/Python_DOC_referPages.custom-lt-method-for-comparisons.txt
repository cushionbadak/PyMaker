<div class="post-text" itemprop="text">
<p>I want to be able to sort a list of classes by one attribute, which happens to be another class Date. I have done some research and want to use the <code>sorted(list, key=lambda x:date)</code> method of sorting, but seeing as date is a class in itself how can I write an <code>__lt__</code> function in date to allow me to sort chronologically?</p>
<p>I want something along the lines of:</p>
<pre><code>if self.year!= other.year:
    return self.year &lt; other.year
elif self.month != pther.month
...
</code></pre>
<p>and so on.</p>
<p>Here is my Date class:</p>
<pre><code>class Date:
    def __init__(self, month, day, year, minute, hour, string):
        self.month = month
        self.day = day
        self.year = year
        self.minute = minute
        self.hour = hour
        self.string = string
</code></pre>
<p>I should probably mention that this is the first time I have ever used Python, so I'm not very good at this.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>The easy way to compare two complex data structures is to compare tuples of their attributes, in the proper sort order. Try this:</p>
<pre><code>class Date:
    def __init__(self, month, day, year, minute, hour, string):
        self.month = month
        self.day = day
        self.year = year
        self.minute = minute
        self.hour = hour
        self.string = string
    def __lt__(self, other):
        return (self.year, self.month, self.day, self.hour, self.minute) &lt; \
               (other.year, other.month, other.day, other.hour, other.minute)

assert Date(4, 15, 2016, 30, 12, '') &lt; \
       Date(4, 16, 2016, 0, 0, '') &lt; \
       Date (1, 1, 2017, 59, 23, '')

assert not (Date(4, 16, 2016, 0, 0, '') &lt; Date(4, 15, 2016, 30, 12, ''))
</code></pre>
<p>Of course, this only implements <code>&lt;</code>. Depending upon the nature of your code, you may want to implement all of the other comparison functions, <code>&gt;</code>, <code>==</code>, <code>!=</code>, etc. One convenient way to do this is to use the <a href="https://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>@functools.total_ordering</code></a> class decorator.</p>
<p>Reference:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5292303/how-does-tuple-comparison-work-in-python">How does tuple comparison work in Python?</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#common-sequence-operations</a></li>
<li><a href="https://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow noreferrer">https://docs.python.org/2/library/functools.html#functools.total_ordering</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I propose adding a <a href="https://docs.python.org/2/library/datetime.html" rel="nofollow noreferrer"><code>datetime</code></a> object to the class definition:</p>
<pre><code>import datetime as dt, operator as op

class MyDate(object):
    def __init__(self, month, day, year, minute, hour, string):
        self.month = month
        self.day = day
        self.year = year
        self.minute = minute
        self.hour = hour
        self.string = string
        self.dt = dt.datetime(self.year,self.month,self.day,self.hour,self.minute)

l = []
l.append(MyDate(2,17,2017,33,16,'somestring')) # not sure what `string` should be
l.append(MyDate(2,17,2017,37,16,'anotherstring'))
l.append(MyDate(2,17,2017,38,16,'yetanotherstring'))
</code></pre>
<p>Then you can use <a href="https://docs.python.org/2/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>operator.attgetter</code></a> to sort, e.g.:</p>
<pre><code>&gt;&gt;&gt; sorted(l,key=op.attrgetter('dt'),reverse=True)
[&lt;__main__.MyDate object at 0x000000000A4C84A8&gt;, 
 &lt;__main__.MyDate object at 0x000000000A4C8208&gt;, 
 &lt;__main__.MyDate object at 0x000000000A4C8978&gt;]
</code></pre>
</div>
<span class="comment-copy">Do you mean list of objects?</span>
<span class="comment-copy">Just curious: why are you storing dates like that instead of using the built-in dates?</span>
<span class="comment-copy">@Sebastian Wozny Sorry, yes I meant objects</span>
<span class="comment-copy">If you really want something of the sort, I think you're on a good track. Why not write it?</span>
<span class="comment-copy">@SebastianWozny I was more having trouble with the syntax. Do you just continue writing what I had there into an <code>__lt__</code> function? and that will sort it when I call sorted?</span>
<span class="comment-copy">I think you need parentheses there.</span>
<span class="comment-copy">Where, precisely? And why do you think so?</span>
<span class="comment-copy">Around your tuples. <code>&lt;</code> has higher precedence than the comma, so instead of a boolean, you're actually returning a 9-element tuple with a <code>self.minute &lt; other.year</code> boolean in the middle.</span>
<span class="comment-copy">I think you are right. I'll fix it.</span>
<span class="comment-copy">Also, it'd be a good idea to implement <code>__eq__</code> and put <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer"><code>functools.total_ordering</code></a> on this class to get the rest of the comparison methods, or at least mention that it's important to remember them in real code.</span>
