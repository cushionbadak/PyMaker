<div class="post-text" itemprop="text">
<p>I'm trying to map a list into hex, and then use the list elsewhere. In python 2.6, this was easy:</p>
<p><strong>A:</strong> Python 2.6:</p>
<pre><code>&gt;&gt;&gt; map(chr, [66, 53, 0, 94])
['B', '5', '\x00', '^']
</code></pre>
<p>However, in Python 3.1, the above returns a map object.</p>
<p><strong>B:</strong> Python 3.1:</p>
<pre><code>&gt;&gt;&gt; map(chr, [66, 53, 0, 94])
&lt;map object at 0x00AF5570&gt;
</code></pre>
<p>How do I retrieve the mapped list (as in <strong>A</strong> above) on Python 3.x? </p>
<p>Alternatively, is there a better way of doing this? My initial list object has around 45 items and id like to convert them to hex.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do this:</p>
<pre><code>list(map(chr,[66,53,0,94]))
</code></pre>
<p>In Python 3+, many processes that iterate over iterables return iterators themselves.  In most cases, this ends up saving memory, and should make things go faster.   </p>
<p>If all you're going to do is iterate over this list eventually, there's no need to even convert it to a list, because you can still iterate over the <code>map</code> object like so:</p>
<pre><code># Prints "ABCD"
for ch in map(chr,[65,66,67,68]):
    print(ch)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why aren't you doing this:</p>
<pre><code>[chr(x) for x in [66,53,0,94]]
</code></pre>
<p>It's called a list comprehension.  You can find plenty of information on Google, but <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">here's the link to the Python (2.6) documentation on list comprehensions</a>.  You might be more interested in <a href="http://docs.python.org/3.1/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">the Python 3 documenation</a>, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>New and neat in Python 3.5:</p>
<pre><code>[*map(chr, [66, 53, 0, 94])]
</code></pre>
<p>Thanks to <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="noreferrer">Additional Unpacking Generalizations</a></p>
<p><strong>UPDATE</strong></p>
<p>Always seeking for shorter ways, I discovered this one also works:</p>
<pre><code>*map(chr, [66, 53, 0, 94]),
</code></pre>
<p>Unpacking works in tuples too. Note the comma at the end. This makes it a tuple of 1 element. That is, it's equivalent to <code>(*map(chr, [66, 53, 0, 94]),)</code></p>
<p>It's shorter by only one char from the version with the list-brackets, but, in my opinion, better to write, because you start right ahead with the asterisk - the expansion syntax, so I feel it's softer on the mind. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>List-returning map function has the advantage of saving typing, especially during interactive sessions. You can define <code>lmap</code> function (on the analogy of python2's <code>imap</code>) that returns list:</p>
<pre><code>lmap = lambda func, *iterable: list(map(func, *iterable))
</code></pre>
<p>Then calling <code>lmap</code> instead of <code>map</code> will do the job: 
<code>lmap(str, x)</code> is shorter by 5 characters (30% in this case) than <code>list(map(str, x))</code> and is certainly shorter than <code>[str(v) for v in x]</code>.  You may create similar functions for <code>filter</code> too.</p>
<p>There was a comment to the original question:</p>
<blockquote>
<p>I would suggest a rename to Getting map() to return a list in Python 3.* as it applies to all Python3 versions. Is there a way to do this? –  meawoppl Jan 24 at 17:58</p>
</blockquote>
<p>It <em>is</em> possible to do that, but it is a very bad idea. Just for fun, here's how you may (<strong>but should not</strong>) do it:</p>
<pre><code>__global_map = map #keep reference to the original map
lmap = lambda func, *iterable: list(__global_map(func, *iterable)) # using "map" here will cause infinite recursion
map = lmap
x = [1, 2, 3]
map(str, x) #test
map = __global_map #restore the original map and don't do that again
map(str, x) #iterator
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not familiar with Python 3.1, but will this work?</p>
<pre><code>[chr(x) for x in [66, 53, 0, 94]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Converting <a href="https://stackoverflow.com/questions/1303347/getting-a-map-to-return-a-list-in-python-3-x/47171827#comment63702627_1303354">my old comment</a> for better visibility: For a "better way to do this" without <code>map</code> entirely, if your inputs are known to be ASCII ordinals, it's generally much faster to convert to <code>bytes</code> and decode, a la <code>bytes(list_of_ordinals).decode('ascii')</code>. That gets you a <code>str</code> of the values, but if you need a <code>list</code> for mutability or the like, you can just convert it (and it's still faster). For example, in <code>ipython</code> microbenchmarks converting 45 inputs:</p>
<pre><code>&gt;&gt;&gt; %%timeit -r5 ordinals = list(range(45))
... list(map(chr, ordinals))
...
3.91 µs ± 60.2 ns per loop (mean ± std. dev. of 5 runs, 100000 loops each)

&gt;&gt;&gt; %%timeit -r5 ordinals = list(range(45))
... [*map(chr, ordinals)]
...
3.84 µs ± 219 ns per loop (mean ± std. dev. of 5 runs, 100000 loops each)

&gt;&gt;&gt; %%timeit -r5 ordinals = list(range(45))
... [*bytes(ordinals).decode('ascii')]
...
1.43 µs ± 49.7 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)

&gt;&gt;&gt; %%timeit -r5 ordinals = list(range(45))
... bytes(ordinals).decode('ascii')
...
781 ns ± 15.9 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)
</code></pre>
<p>If you leave it as a <code>str</code>, it takes ~20% of the time of the fastest <code>map</code> solutions; even converting back to list it's still less than 40% of the fastest <code>map</code> solution. Bulk convert via <code>bytes</code> and <code>bytes.decode</code> then bulk converting back to <code>list</code> saves a lot of work, <em>but</em> as noted, only works if all your inputs are ASCII ordinals (or ordinals in some one byte per character locale specific encoding, e.g. <code>latin-1</code>).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>list(map(chr, [66, 53, 0, 94]))
</code></pre>
<blockquote>
<p>map(func, *iterables) --&gt; map object
     Make an iterator that computes the function using arguments from
     each of the iterables.  Stops when the shortest iterable is exhausted.</p>
<p>"Make an iterator"</p>
</blockquote>
<p>means it will return an iterator.</p>
<blockquote>
<p>"that computes the function using arguments from each of the iterables"</p>
</blockquote>
<p>means that the next() function of the iterator will take one value of each iterables and pass each of them to one positional parameter of the function.</p>
<p>So you get an iterator from the map() funtion and jsut pass it to the list() builtin function or use list comprehensions.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to above answers in <code>Python 3</code>, we may simply create a <code>list</code> of result values from a <code>map</code> as </p>
<pre><code>li = []
for x in map(chr,[66,53,0,94]):
    li.append(x)

print (li)
&gt;&gt;&gt;['B', '5', '\x00', '^']
</code></pre>
<p>We may generalize by another example where I was struck, operations on map can also be handled in similar fashion like in <code>regex</code> problem, we can write function to obtain <code>list</code> of items to map and get result set at the same time. Ex. </p>
<pre><code>b = 'Strings: 1,072, Another String: 474 '
li = []
for x in map(int,map(int, re.findall('\d+', b))):
    li.append(x)

print (li)
&gt;&gt;&gt;[1, 72, 474]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension in python and basic map function utility, one can do this also:</p>
<p><code>chi = [x for x in map(chr,[66,53,0,94])]</code></p>
</div>
<span class="comment-copy">Of course, you can iterate over this, too: (chr(x) for x in [65,66,67,68]). It doesn't even need map.</span>
<span class="comment-copy">@hughdbrown The argument for using 3.1's <code>map</code> would be lazy evaluation when iterating on a complex function, large data sets, or streams.</span>
<span class="comment-copy">@Andrew actually Hugh is uing a generator comprehension which would do the same thing. Note the parentheses rather than square brackets.</span>
<span class="comment-copy">Alternate solution (faster for large inputs too) when the values are known to be ASCII/latin-1 is to do bulk conversions at the C layer: <code>bytes(sequence_of_ints_in_range_0_to_256).decode('latin-1')</code> which makes a <code>str</code> faster by avoiding Python function calls for each element in favor of a bulk conversion of all elements using only C level function calls. You can wrap the above in <code>list</code> if you really need a <code>list</code> of the individual characters, but since <code>str</code> is already an iterable of its own characters, the only reason you'd do so is if you need mutability.</span>
<span class="comment-copy">This is super useful information. I was wondering what happened to the map :)</span>
<span class="comment-copy">Yes to list comprehensions.</span>
<span class="comment-copy">Hmmmm. Maybe there needs to be a general posting on list comprehensions, generators, map(), zip(), and a lot of other speedy iteration goodness in python.</span>
<span class="comment-copy">I guess because it's more verbose, you have to write an extra variable (twice)... If the operation is more complex and you end up writing a lambda, or you need also to drop some elements, I think a comprehension is definitively better than a map+filter, but if you already have the function you want to apply, map is more succinct.</span>
<span class="comment-copy">+1: Easier to read &amp; allows you to use functions with many parameters</span>
<span class="comment-copy"><code>map(chr, [66,53,0,94])</code> is definitely more concise than <code>[chr(x) for x in [66,53,0,94]]</code>.</span>
<span class="comment-copy">What's wrong with <code>list()</code>?</span>
<span class="comment-copy">@Quelklef <code>list()</code> doesn't look as neat</span>
<span class="comment-copy">@Quelklef: Also, the unpacking approach is trivially faster thanks to not needing to look up the <code>list</code> constructor and invoke general function call machinery. For a long input, it won't matter; for a short one, it can make a big difference. Using the above code with the input as a <code>tuple</code> so it's not repeatedly reconstructed, <code>ipython</code> microbenchmarks show the <code>list()</code> wrapping approach takes about 20% longer than unpacking. Mind you, in absolute terms, we're talking about 150 ns, which is trivial, but you get the idea.</span>
<span class="comment-copy">What was wrong with the old <code>map</code>? Maybe with a new name (<code>lmap</code>?) if the new default is to return an iterator?</span>
<span class="comment-copy">@ALH You missed the comma on the end of the command. Easy mistake to make!</span>
<span class="comment-copy">@miradulo I supposed in Python 2, a list was returned, but in Python 3, only type is returned and I just tried to give in same format. If you think its needless, there maybe people like me who can find it useful and thats why I added.</span>
<span class="comment-copy">When there is already a list comprehension, a list function, and an unpacking answer, an explicit for loop doesn’t add much IMHO.</span>
<span class="comment-copy">chi list will be containing, the ASIC value of the given elements.</span>
