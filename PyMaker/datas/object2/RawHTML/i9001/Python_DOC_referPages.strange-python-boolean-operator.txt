<div class="post-text" itemprop="text">
<p>I saw some variations of the following simple piece of code: </p>
<pre><code>if dist_1&gt;dist_2 :
    print enemy_2
else:
    print enemy_1
</code></pre>
<p>Variation 1:</p>
<pre><code>print (enemy_1, enemy_2)[dist_1 &gt; dist_2]
</code></pre>
<p>Variation 2:</p>
<pre><code>e1, d1, e2 = (raw_input() for _ in '123')
print (e1, e2)[d1 &gt; raw_input()]
</code></pre>
<p>Can someone please explain how this <code>print (x,y)[x&gt;y]</code> code works? </p>
</div>
<div class="post-text" itemprop="text">
<p>Booleans are actually a subclass of integers in Python:</p>
<pre><code>isinstance(True, int)
isinstance(False, int)
</code></pre>
<p>are both true statements. So you can index a two-element sequence with a boolean. If the boolean is <code>False</code>, you will get the first element. If the boolean is <code>True</code>, you will get the second element.</p>
<p>The expression <code>(enemy_1, enemy_2)</code> creates a two-element <code>tuple</code>. <code>[dist_1 &gt; dist_2]</code> provides the boolean index. The <code>print</code> is incidental; it is just used to output the result.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you put some element(s) in parens with at least one comma it becomes a tuple. Similar to a list, you can index a tuple. You index using integers, usually. However, if you index using a boolean then False will be interpreted as 0 and True will be interpreted as 1.</p>
<p>So the code:</p>
<pre><code>(enemy_1, enemy_2)[dist_1 &gt; dist_2]
</code></pre>
<p>Is interpreted in English as "if dist_1 &gt; than dist_2 give me item 1 from the tuple, else give me item 0."</p>
<p>If you want, you can do a tuple tutorial.</p>
</div>
<span class="comment-copy">I added a python 2 tag here because I am pretty sure this would not work in Python 3</span>
<span class="comment-copy">It's just a tuple and accesses either 0 or 1 based on the outcome of <code>x &gt; y</code>...</span>
<span class="comment-copy">@MadPhysicist it took no time to test this under 3.6.0. It works!</span>
<span class="comment-copy">@Jules. I don't believe you. <code>e1, e2, d1, d2 = 'a', 'b', 1, 2; print (e1, e2)[d1 &gt; d2]</code> raises a <code>TypeError: 'NoneType' is not subscriptable</code> error as expected. The parens are now function argument delimiters, not tuple delimiters.</span>
<span class="comment-copy">What an enormous nonsense to downvote this question, or label it off-topic. I think OP just shows he's willing to take the trouble to look it up. But the answer is far from trivial, and certainly isn't easy to find in a book if you're not a Python expert.</span>
<span class="comment-copy">To prevent confusion: type bool is derived from type int, so isinstance (2, bool) is False. So indeed bools are integers, but integers are not bools. Like a cat is an animal, but an animal isn't necessarily a cat.</span>
<span class="comment-copy">@JacquesdeHooge. I don't thing it's especially relevant that the converse is not true, but I did make my language more precise to indicate it.</span>
<span class="comment-copy">I'd love to know why the downvote. Is something untrue or fundamentally lacking in my explanation?</span>
<span class="comment-copy">Your language was concise enough. It was just a clarification. In daily language when people say 'is' they think of it as 'equals', rather than 'is a '. BTW, nothing lacking in your answer, just some funny people downvoting everything...</span>
<span class="comment-copy">"If you put something in parens it becomes a tuple". Not necessarily: is <code>(2)</code> a tuple?</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre Notpick: If it's part of a function call then yes, it could become part of a tuple (<a href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTupleAndKeywords" rel="nofollow noreferrer"><code>PyArg_ParseTupleAndKeywords</code></a> or if the function accepts <code>*args</code>) :-)</span>
