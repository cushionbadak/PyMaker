<div class="post-text" itemprop="text">
<p>I'm trying to split a list into two lists. Here's the list:</p>
<blockquote>
<p>L = [3.5, <strong>1</strong> ,7, <strong>2</strong> ,4.5, <strong>1</strong>, 6, <strong>2</strong>, 4.8, <strong>2</strong>
  ,3.1,<strong>1</strong>, 9, <strong>2</strong>]</p>
</blockquote>
<p>If I want to split the list based on the bold number (1 or 2), which are always the even number (2x) in the position, so the numbers before 1 go to one list, and the numbers before 2 go to another list:</p>
<pre><code>l1 = [3.5, 4.5, 3.1] #bold number = 1

l2 = [7, 6, 4.8, 9] #bold number = 2
</code></pre>
<p>Also, the question may be extend when there are <code>i+1</code> bold number and thus needs to be split to <code>i+1</code> list.</p>
<p>How should I use <code>if</code>-<code>else</code> statements for list?</p>
</div>
<div class="post-text" itemprop="text">
<p>Do that using ternary in a step 2 loop which dispatches the previous element in the relevant list (I took a shortcut: if value is <code>1</code>, it's <code>l1</code> else it's <code>l2</code>, so it's rather fragile):</p>
<pre><code>l=[3.5, 1 ,7, 2 ,4.5, 1, 6, 2, 4.8, 2 ,3.1,1, 9, 2]

l1,l2 = [],[]
for i in range(1,len(l),2):
    (l1 if l[i]==1 else l2).append(l[i-1])

print(l1,l2)
</code></pre>
<p>yields:</p>
<pre><code>[3.5, 4.5, 3.1] [7, 6, 4.8, 9]
</code></pre>
<p>General case: create a list of lists according to the maximum index, and dispatch the value according to the index in a loop (<code>l[i]-1</code> is the 0-starting index and <code>l[i]</code> is the value to insert)</p>
<pre><code>lists = [[] for _ in range(max(l[1::2]))]

for i in range(1,len(l),2):
    lists[l[i]-1].append(l[i-1])

print(lists)
</code></pre>
<p>result:</p>
<pre><code>[[3.5, 4.5, 3.1], [7, 6, 4.8, 9]]
</code></pre>
<p>more "pythonic" for the last part using <code>itertools.islice</code> instead of playing with indexes:</p>
<pre><code>import itertools
for i,v in zip(itertools.islice(l,1,len(l),2),itertools.islice(l,0,len(l),2)):
    lists[i-1].append(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary to hold the new lists, using the category number as the dictionary key. We use a defaultdict to simplify creating the lists in the dictionary.</p>
<pre><code>from collections import defaultdict

lst = [3.5, 1 ,7, 2, 4.5, 1, 6, 2, 4.8, 2, 3.1, 1, 9, 2]

# Separate data into different lists based on following number
d = defaultdict(list)
it = iter(lst)
for v, k in zip(it, it):
    d[k].append(v) 

# Display lists
for k in sorted(d.keys()):
    print(k, d[k])
</code></pre>
<p><strong>output</strong></p>
<pre><code>1 [3.5, 4.5, 3.1]
2 [7, 6, 4.8, 9]
</code></pre>
<p>This code copes with any number of categories.</p>
<p>As Jean-François Fabre mentions in the comments there's a slightly more efficient way to do the printing in sorted order.</p>
<pre><code>from collections import defaultdict

lst = [3.5, 1 ,7, 2, 4.5, 3, 6, 2, 4.8, 3, 3.1, 1, 9, 2]

# Separate data into different lists based on following number
d = defaultdict(list)
it = iter(lst)
for v, k in zip(it, it):
    d[k].append(v) 

# Display lists
for k, v in sorted(d.items()):
    print(k, v)
</code></pre>
<p><strong>output</strong></p>
<pre><code>1 [3.5, 3.1]
2 [7, 6, 9]
3 [4.5, 4.8]
</code></pre>
<p>The heart of this algorithm is</p>
<pre><code>it = iter(lst)
for v, k in zip(it, it):
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>it = iter(lst)</code></a> creates an iterator object from the list. We then pass two copies of that iterator to <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>. </p>
<p>Looping over <code>zip</code> yields tuples containing the successive items from each of the arguments you feed it. In other words, if you do <code>zip(a, b, c)</code> you get the first elements of each of <code>a</code>, <code>b</code>, <code>c</code>, then you get their 2nd elements, etc.  </p>
<p>But here we've passed <code>zip</code> two references to the <code>it</code> iterator. So when <code>zip</code> reads the next items from each of the two <code>it</code>s its really working its way through the pairs of items in <code>lst</code>. Thus on each loop of the <code>for</code> loop we get successive pairs of items from <code>lst</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>not the cleanest attempt, but here you go</p>
<pre><code>&gt;&gt;&gt; L=[3.5, 1 ,7, 2 ,4.5, 1, 6, 2, 4.8, 2 ,3.1,1, 9, 2]
&gt;&gt;&gt; o=zip(L, L[1:])[::2]
&gt;&gt;&gt; o
[(3.5, 1), (7, 2), (4.5, 1), (6, 2), (4.8, 2), (3.1, 1), (9, 2)]
&gt;&gt;&gt; map(lambda x: x[0], filter(lambda x: x[1]%2==0, o))
[7, 6, 4.8, 9]
&gt;&gt;&gt; map(lambda x: x[0], filter(lambda x: x[1]%2!=0, o))
[3.5, 4.5, 3.1]
</code></pre>
</div>
<span class="comment-copy">Please show your effort :) Pasting your code would be OK</span>
<span class="comment-copy">Like 0Tech said, show what you have so far. But also clarify, are these numbers 1 and 2 positions or flags.</span>
<span class="comment-copy">@Roxanne Your edit messed up the bold text in the <code>L</code> list.</span>
<span class="comment-copy">If one of the answers below fixes your issue, you should accept it (click the check mark next to the appropriate answer). That does two things. It lets everyone know your issue has been resolved to your satisfaction, and it gives the person that helps you credit for the assist. See <a href="http://meta.stackexchange.com/a/5235">here</a> for a full explanation.</span>
<span class="comment-copy">@PM2Ring my bad. I will double check next-time</span>
<span class="comment-copy"><code>for k in sorted(d.keys()):</code>: you'd better do <code>for k,v in sorted(d.items()):</code> so you don't need to do <code>d[k]</code> in your loop.</span>
<span class="comment-copy">@Jean-FrançoisFabre Thanks. Why didn't I think of that? ;) And <code>for t in sorted(d.items()): print(*t)</code> is another option.</span>
