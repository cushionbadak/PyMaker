<div class="post-text" itemprop="text">
<p>I want to loop through my 2D numpy array and check all its direct neighbors.
If I make a numpy array like so:</p>
<pre><code>tilemap = np.arange(16).reshape(4,4)
</code></pre>
<p>It will look something like this:</p>
<pre><code> [[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
</code></pre>
<p>The loop that I created to help me find the neighbors for each spot in the array looks like this:</p>
<pre><code> import numpy as np

 mapwidth = 4
 mapheight = 4

 tilemap = np.arange(mapwidth * mapheight).reshape(mapwidth, mapheight)

 row = 0
 for i in tilemap:
     count = 0
     for j in i:
         column = j % mapwidth
         check = tilemap[row-1:row+2, column-1:column+2]
         print(check)
         count += 1
         if count % mapheight == 0:
             row += 1
</code></pre>
<p>However, when I do this, I will not find any neighbors for the spot in the array with the values 0, 1, 2, 3, 4, 8, and 12. I understand why this is the case. for example, if I take the value of 8. it has the indices of [2,0]. the row-1 will result in -1, which is the same as index 3 in this example. the row+2 is 2. And slicing 2:3 will result in nothing because there is nothing between 2 and 3.</p>
<p>Anyway, the result I'm looking for is something like this (for value 8):</p>
<pre><code>[[4  5]
[ 8  9]
[12 13]]
</code></pre>
<p>I know I can achieve this by piling some if-statements but I wonder if there is a more elegant way of dealing with this.</p>
<p>Thanks for your time.</p>
<p><em>(For those who are curious to know this):
The neighbors for e.g. value 11 actually return like I want them to, without any errors. It returns this:</em></p>
<pre><code>[[6  7]
[10 11]
[14 15]]
</code></pre>
<p>EDIT:</p>
<p>I should also mention I tried this:</p>
<pre><code>check = np.take(tilemap, tilemap[row-1:row+2, column-1:column+2], mode = 'clip')
</code></pre>
<p>But this did not work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simplify the way your loop is written and not assume as much about the contents of the array, making your code more flexible. Numpy has an <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.html" rel="nofollow noreferrer"><code>nditer</code></a> class that can be used to iterate over an array. You can also use it to get the <a href="https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html#tracking-an-index-or-multi-index" rel="nofollow noreferrer">multi-dimensional index</a> of each element. Iteration can be further simplified using the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndenumerate.html" rel="nofollow noreferrer"><code>ndenumerate</code></a> class, similar to Pythons builtin <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>. If you do not need to get the elements back, just the index, you can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndindex.html" rel="nofollow noreferrer"><code>ndindex</code></a>. Here is an example using <code>ndindex</code>:</p>
<pre><code>for r, c in ndindex(tilemap.shape):
    check = tilemap[max(r-1, 0):min(r+1, mapheight), max(c-1, 0):min(c+1, mapwidth)]
    print(check)
</code></pre>
</div>
<span class="comment-copy">one trick would be to replace <code>row-1</code> with <code>row-(row!=0)</code> and similarly for <code>column</code></span>
<span class="comment-copy"><code>min(max(0, row-1), MAX_INDEX)</code></span>
<span class="comment-copy">@TadhgMcDonald-Jensen you don't need to cut off at the right side; when slicing a too large upper bound is handled gracefully.</span>
<span class="comment-copy">Thanks Paul, it works exectly like I'd hoped!</span>
<span class="comment-copy">This is useful. I came back to this thread because I wanted to know how to search a larger area around a specific index. I made it work, but the code was hideous. This works perfect for doing that too. Here's the code I used to search in all directions with a length of 3.       for i, j in np.ndindex(a.shape):          check = a[max(i-3, 0):min(i+4, height), max(j-3, 0):min(j+4, width)]          print(i, j)          print(check)</span>
<span class="comment-copy">@Tea. You should select answers that help you solve your issue. That is the standard operating procedure on this site. You can always change your selection later.</span>
