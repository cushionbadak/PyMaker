<div class="post-text" itemprop="text">
<p>I am checking the types of user input like so:</p>
<pre><code>PyObject *key = PyTuple_GetItem(tuple, 0);
if (!PyObject_TypeCheck(key, &amp;PyBaseString_Type) {
    PyErr_SetString(PyExc_TypeError, "Key must be str");
    return NULL;
}
</code></pre>
<p>However, In the exception message, I would like to include the bad type the user has submitted, to make debugging for him easier.</p>
<p>Is there a simple or otherwise idiomatic way to achieve this?</p>
<hr/>
<p>The only way I can think of is the following:</p>
<pre><code>PyObject *key = PyTuple_GetItem(tuple, 0);
if (!PyObject_TypeCheck(key, &amp;PyBaseString_Type) {
    // This returns a new reference which must be Py_DECREFed
    PyObject *bad_type_string = PyObject_Str((PyObject *)key-&gt;ob_type);
    char *bad_type_char = PyString_AsString(bad_type_string);
    PyErr_Format(PyExc_TypeError, "Key must be str, not %s", bad_type_char);
    Py_DECREF(bad_type_string);
    return NULL;
}
</code></pre>
<p>Which I suppose I could wrap in a macro:</p>
<pre><code># define CHECK_TYPE(expr, name, input) \
    do {    \
        if (!(expr)) {
            PyObject *bad_type_string = PyObject_Str((PyObject *)input-&gt;ob_type);  \
            char *bad_type_char = PyString_AsString(bad_type_string); \
            PyErr_Format(PyExc_TypeError, "%s must be str, not %s", name bad_type_char); \
            Py_DECREF(bad_type_string); \
            goto error; \
        }
    } while (0);
</code></pre>
<p>And used like such:</p>
<pre><code>static PyObject *foo(PyObject *self, PyObject *args) {
    // ...
    PyObject *key = PyTuple_GetItem(tuple, 0);
    CHECK_TYPE(PyObject_TypeCheck(key, &amp;PyBaseString_Type, 'key', key);
    // ...
error:
    return NULL;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could slightly misuse <a href="https://docs.python.org/2/c-api/arg.html#c.PyArg_ParseTuple" rel="nofollow noreferrer">the <code>PyArg_ParseTuple</code> mechanism</a>. The slight bit of non-neatness is that it outputs into a <code>const char*</code>, so you have to get the item from the tuple too.</p>
<pre><code>const char* out;
if (!PyArg_ParseTuple(tpl,"s", &amp;out)) {
    return NULL;
} else {
    key = PyTuple_GetItem(tpl,0); /* borrowed - remember to incref */
}
</code></pre>
<p>This generates something like </p>
<blockquote>
<p>TypeError: must be str, not int</p>
</blockquote>
<hr/>
<p>Note: This is fine for Python 2 since <code>"s"</code> matches both <code>str</code> or <code>unicode</code> object (i.e. effectively <code>basestring</code>). For Python 3 it will only accept <code>str</code> (not <code>bytes</code>) so you might have to follow <a href="https://docs.python.org/3/c-api/arg.html#strings-and-buffers" rel="nofollow noreferrer">the documented advice</a> and "to use the <code>O&amp;</code> format with <code>PyUnicode_FSConverter()</code> as converter." This gives an error of</p>
<blockquote>
<p>TypeError: Can't convert 'int' object to str implicitly</p>
</blockquote>
<p>Additionally, it's a bit nicer because the <code>out</code> is a <code>PyBytesObject</code> that you can use directly instead of having to do <code>PyTuple_GetItem</code></p>
</div>
<span class="comment-copy">Sorry for the confusion; I meant to ask for a generic solution that could apply to any PyObject, not necessarily a tuple. However you got me thinking, why not continue this like so: <code>PyArg_ParseTuple(Py_BuildValue("(o)", "s", &amp;out))</code> - What do you think?</span>
<span class="comment-copy">I think (but I'm not 100% sure) that <a href="https://docs.python.org/2/c-api/arg.html#c.PyArg_Parse" rel="nofollow noreferrer"><code>PyArg_Parse</code></a> can take either a tuple or a single argument (based on the description of the old function call method it was designed to be used on). I haven't tested this though</span>
