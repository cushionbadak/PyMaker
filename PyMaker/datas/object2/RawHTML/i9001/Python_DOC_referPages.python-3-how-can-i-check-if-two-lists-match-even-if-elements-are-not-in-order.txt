<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>original_list= [1,2,3,4,5]

new_list = [[1,7,3,4], [1,2,4,5,3]]
</code></pre>
<p>Other than using sort and then list in list, how can I compare the original_list values are in new_list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to sort each <code>list</code> in <code>new_list</code>, not <code>new_list</code> itself. Try this for instance using <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>:</p>
<pre><code>print(sorted(original_list) in map(sorted, new_list))
</code></pre>
<p>or if you only care for the existence of the same elements regardless of their count:</p>
<pre><code>print(set(original_list) in map(set, new_list))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>supposing your original list is already sorted (if not, just apply <code>sort</code>), you have to compare each element - sorted - using a loop or <code>any</code>:</p>
<pre><code>new_list = [[1,7,3,4],[1,2,4,5,3]]
original_list= [1,2,3,4,5]
original_list.sort()  # optional if the list is not sorted yet

print(any(sorted(x)==original_list for x in new_list))
</code></pre>
<p>prints <code>True</code> if a sub-list of <code>new_list</code> has the same elements as <code>original_list</code></p>
<p>That avoids to rebuild the original list using <code>new_list = [sorted(x) for x in new_list]</code> to get sorted items, since order may be important after all.</p>
</div>
<div class="post-text" itemprop="text">
<p>Besides <code>sorted</code> which has <code>O(n*log(n))</code> runtime behaviour (worst case I think) you can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> (almost guaranteed <code>O(n)</code> runtime behaviour):</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; lst_counts = Counter(original_list)
&gt;&gt;&gt; any(lst_counts == Counter(sublist) for sublist in new_list)
True
</code></pre>
<p>That uses the fact that Counter compare both keys and values and therefore are only equal if the dictionaries (inside the <code>Counter</code>) are identical</p>
<p>If you can exclude duplicates then instead of <code>Counter</code> you can also use <code>set</code>s.</p>
</div>
<span class="comment-copy">sort the items of your list, not the list itself. <code>new_list = [sorted(x) for x in new_list]</code> should do it.</span>
<span class="comment-copy">Why do you not want sort? Because it changes your original lists? Also, if the order doesn't matter for your collections, you may consider using <code>set</code>s rather than lists.</span>
<span class="comment-copy">Could you be more specific? Do you require both lists to have the same elements with same multiplicity? Or just that each value in original list is also in new_list? That would be set inclusion discarding multiplicities. Or something still different?</span>
<span class="comment-copy">Or <code>sorted(original_list) in map(sorted, new_list)</code></span>
<span class="comment-copy">every time <code>map</code> is used purposedly in python 3 I'm happy.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre You mean if it is not molested with some <code>lambda</code> expression?</span>
<span class="comment-copy">@schwobaseggl exactly :) when a function already exists and you don't need a <code>list</code> it's the best choice.</span>
