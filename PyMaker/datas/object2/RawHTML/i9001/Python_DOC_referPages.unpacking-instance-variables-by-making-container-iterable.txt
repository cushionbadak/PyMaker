<div class="post-text" itemprop="text">
<p>I just want to be able to unpack the instance variables of class foo, for example:</p>
<pre><code>x = foo("name", "999", "24", "0.222")
a, b, c, d = *x
a, b, c, d = [*x]
</code></pre>
<p>I am not sure as to which is the correct method for doing so when implementing my own <code>__iter__</code> method, however, the latter is the one that has worked with mixed "success".  I say mixed because doing so with the presented code appears to alter the original instance object <code>x</code>, such that it is no longer valid. </p>
<pre><code>class foo:
  def __init__(self, a, b, c, d):
    self.a = a
    self.b = b
    self.c = c
    self.d = d

  def __iter__(self):
    return iter([a, b, c, d])
</code></pre>
<p>I have read the myriad posts on this site regarding <code>__iter__</code>, <code>__next__</code>, generators etc., and also a python book and docs.python.org and seem unable to figure what I am not understanding. I've gathered that <code>__iter__</code> needs to return an iterable (which can be just be <code>self</code>, but I am not sure how that works for what I want). I've also tried various ways of playing around with implementing <code>__next__</code> and iterating over <code>vars(foo).items()</code>, either by casting to a list or as a dictionary, with no success. </p>
<p>I don't believe this is a duplicate post on account that the only similar questions I've seen present a single list sequence object attribute or employ a range of numbers instead of a four non-container variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the instance's variables, you should access them with <code>.self</code>:</p>
<pre><code>def __iter__(self):
    return iter([self.a, self.b, self.c, self.d])
</code></pre>
<p>with this change, </p>
<pre><code>a, b, c, d = list(x)
</code></pre>
<p>will get you the variables. </p>
<hr/>
<p>You could go to the more risky method of using <code>vars(x)</code> or <code>x.__dict__</code>, sort it by the variables name (and that's why it is also a limited one, the variables are saved in no-order), and extract the second element of each tuple. But I would say the iterator is definitely better.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can store the arguments in an attribute (<code>self.e</code> below) or return them on function call:</p>
<pre><code>class foo:
  def __init__(self, *args):
    self.a, self.b, self.c, self.d = self.e = args

  def __call__(self):
    return self.e

x = foo("name", "999", "24", "0.222")
a, b, c, d = x.e
# or
a, b, c, d = x()
</code></pre>
</div>
<span class="comment-copy">What makes you think returning a list from <code>__iter__</code> alters <code>x</code>? If whatever's iterating over it changes <code>a</code> etc. then <code>x</code> would change <i>however</i> you implement the iterator. Could you just make it a <code>Sequence</code> (i.e. implement <code>__getitem__</code> and <code>__len__</code> per <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">docs.python.org/3/library/collections.abc.html</a>)?</span>
<span class="comment-copy">Your first unpacking is missing a comma at the end, by the way. Also, could you elaborate on "alter the original instance object <code>x</code>"? How so?</span>
<span class="comment-copy">@jonrsharpe I assumed that I was returning an iterator for the explicitly defined list (i.e. allowing the obj's instance variables to be iterated over like a regular list - and unpacked similarly ). I can try to make it a Sequence sure, it'll just take more learning. I definitely appreciate that resource and will be checking it out. @Jim Fasarakis-Hilliard, as presently implemented if I attempt to do, say : <code>a, b, c, d = *x,</code> a, b, c, and d will hold the correct values, but then any attempt to access x - as  before the unpacking - raises "TypeError: 'float' object is not subscriptable"</span>
<span class="comment-copy">I was referring to <i>"the presented code appears to alter the original instance object x, such that it is no longer valid"</i> - could you show a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>? It's not behaviour I'd expect given you're creating a fresh list of immutable objects, so it might be useful to explore what exactly you're doing with it. You're missing a few <code>self.</code> references, though.</span>
