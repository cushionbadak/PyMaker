<div class="post-text" itemprop="text">
<p>I have a set of 3 list widgets all with drag and drop capabilities.  I am looking to eliminate repeated code and am looking for some help. As you can see in my Dialog class I create 3 Image classes that are drag and drog lists.  As of right now each List Widget corresponds to a connect function. </p>
<p><code>self.connect(self.one, SIGNAL("dropped"), self.oneDropped)</code></p>
<p>It seems to me that the function <code>def oneDropped()</code>could be turned into a function where <code>self.oneDropped</code> is an argument, but I am having trouble setting that up and could use some help. Here is my code. </p>
<p>I have only been working with Python for a few weeks so apologies if this is a simple question. </p>
<pre><code>import sys
import os
from PyQt4 import uic
from PyQt4.QtGui import *
from PyQt4.QtCore import * 

class Image(QListWidget):
    def __init__(self, type, parent=None):
        super(Image, self).__init__(parent)
        self.setAcceptDrops(True)
        self.setIconSize(QSize(72, 72))

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls:
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls:
            event.setDropAction(Qt.CopyAction)
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        if event.mimeData().hasUrls:
            event.setDropAction(Qt.CopyAction)
            event.accept()
            links = []
            for url in event.mimeData().urls():
                links.append(str(url.toLocalFile()))
            self.emit(SIGNAL("dropped"), links)
        else:
            event.ignore()

class Dialog(QDialog):
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)

        self.ui = uic.loadUi('./qt/default.ui', self)

        self.one = Image(self)
        self.two = Image(self)
        self.three = Image(self)
        self.connect(self.one, SIGNAL("dropped"), self.oneDropped)
        self.connect(self.two, SIGNAL("dropped"), self.twoDropped)
        self.connect(self.three, SIGNAL("dropped"), self.threeDropped)
        self.baseimage_layout.addWidget(self.one)
        self.redimage_layout.addWidget(self.two)
        self.greenimage_layout.addWidget(self.three)


    def oneDropped(self, l):
        for url in l:
            if os.path.exists(url):
                print(url)
                icon = QIcon(url)
                pixmap = icon.pixmap(72, 72)
                icon = QIcon(pixmap)
                item = QListWidgetItem(url, self.one)
                item.setIcon(icon) 

    def twoDropped(self, l):
        for url in l:
            if os.path.exists(url):
                print(url)
                icon = QIcon(url)
                pixmap = icon.pixmap(72, 72)
                icon = QIcon(pixmap)
                item = QListWidgetItem(url, self.two)
                item.setIcon(icon) 

    def threeDropped(self, l):
        for url in l:
            if os.path.exists(url):
                print(url)
                icon = QIcon(url)
                pixmap = icon.pixmap(72, 72)
                icon = QIcon(pixmap)
                item = QListWidgetItem(url, self.three)
                item.setIcon(icon) 

def main():
    app = QApplication(sys.argv)
    form = Dialog()
    form.show()
    app.exec_()

if __name__=="__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you are using old-style signals and slots, which are outdated and have been removed in more recent versions of PyQt. You should use the <a href="http://pyqt.sourceforge.net/Docs/PyQt4/new_style_signals_slots.html" rel="nofollow noreferrer">new-style mechanism</a> if possible. </p>
<p>Your example would become:</p>
<pre><code>self.one.dropped.connect(self.oneDropped)
</code></pre>
<hr/>
<p>To answer your question, in python you can use a <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer">lambda expression</a> to add additional arguments when a slot is called.</p>
<p>First you would define a generic handler that takes an <code>Image</code> instance as an argument.</p>
<pre><code>def imgDropped(self, l, img):
    for url in l:
        if os.path.exists(url):
            print(url)
            icon = QIcon(url)
            pixmap = icon.pixmap(72, 72)
            icon = QIcon(pixmap)
            item = QListWidgetItem(url, img)
            item.setIcon(icon) 
</code></pre>
<p>Then the signals are connected like this</p>
<pre><code>self.one.dropped.connect(lambda l: self.imgDropped(l, self.one))
self.two.dropped.connect(lambda l: self.imgDropped(l, self.two))
self.three.dropped.connect(lambda l: self.imgDropped(l, self.three))
</code></pre>
<p>If you are unfamiliar with lambdas, they can be a powerful tool when used like this, but beware of potential unintended behaviour due to <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#late-binding-closures" rel="nofollow noreferrer">late binding</a> of variables. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can include the dropped function and its signal in your image class so you do not have to repeat this function for each class, here is an example :</p>
<pre><code>import sys
import os
from PyQt4 import uic
from PyQt4.QtGui import *
from PyQt4.QtCore import * 

class Image(QListWidget):
    def __init__(self, type, parent=None):
        super(Image, self).__init__(parent)
        self.setAcceptDrops(True)
        self.setIconSize(QSize(72, 72))
        self.connect(self, SIGNAL("dropped"), self.onDropped)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls:
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls:
            event.setDropAction(Qt.CopyAction)
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        if event.mimeData().hasUrls:
            event.setDropAction(Qt.CopyAction)
            event.accept()
            links = []
            for url in event.mimeData().urls():
                links.append(str(url.toLocalFile()))
            self.emit(SIGNAL("dropped"), links)
        else:
            event.ignore()

    def onDropped(self, l):
        for url in l:
            if os.path.exists(url):
                print(url)
                icon = QIcon(url)
                pixmap = icon.pixmap(72, 72)
                icon = QIcon(pixmap)
                item = QListWidgetItem(url, self)
                item.setIcon(icon) 

class Dialog(QDialog):
    def __init__(self, parent=None):
        super(Dialog, self).__init__(parent)

        self.ui = uic.loadUi('./qt/default.ui', self)

        self.one = Image(self)
        self.two = Image(self)
        self.three = Image(self)
        self.baseimage_layout.addWidget(self.one)
        self.redimage_layout.addWidget(self.two)
        self.greenimage_layout.addWidget(self.three)


def main():
    app = QApplication(sys.argv)
    form = Dialog()
    form.show()
    app.exec_()

if __name__=="__main__":
    main()
</code></pre>
</div>
<span class="comment-copy">I've accepted the other answer as it seemed to work well with my current setup. That being said, your answer appears to be more modern. I am still reading up on how to implement the new-style.   Is your response with the lambda a separate solution to the new-style mechanism or is that intended to work with my outdated code?  Again apologies if this is a simple question.</span>
<span class="comment-copy">It should work with the old mechanism too. Just replace the <code>self.oneDropped</code> etc reference with the lambda expression.</span>
<span class="comment-copy">Ah I see now, thanks!</span>
<span class="comment-copy">Moving everything into the <code>Image</code> class is good, but then what's the point of the signal? You might as well move the <code>onDropped</code> code into <code>dropEvent</code> and refactor it as a single loop.</span>
<span class="comment-copy">I agree with you, I tried to stay close from the implementation, maybe he will need this specific signal to be emitted from somewhere else.</span>
