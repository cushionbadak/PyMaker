<div class="post-text" itemprop="text">
<p>Here is my codes.</p>
<pre><code>import unittest
import warnings

def function_that_raises_CustomWarning():
    warnings.warn("warning")
    return True

class test(unittest.TestCase):

    def test(self):
        is_this_True = False
        is_CustomWarning_raised = False

        try:
            is_this_True = function_that_raises_CustomWarning()
        except Warning:
            is_CustomWarning_raised = True

        self.assertTrue(is_this_True)
        self.assertTrue(is_CustomWarning_raised)

if __name__ == "__main__":
    unittest.main()
</code></pre>
<p><code>is_this_True</code> in <code>self.assertTrue(is_this_True)</code> is <code>False</code>, hence failed the test.</p>
<p>What I want is for <code>is_this_True</code> in <code>self.assertTrue(is_this_True)</code> to be <code>True</code>. However, the return value is not "captured" since the value is returned <strong>after</strong> a warning is raised in <code>function_that_raises_CustomWarning()</code>.</p>
<p>How can I return the value in <code>function_that_raises_CustomWarning()</code> but also "captured" the warning in <code>except</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>When I run your code with 3.6 on Windows, the failure is with <code>self.assertTrue(is_CustomWarning_raised)</code>.  By default, a warning is not an exception and cannot be caught with <code>except:</code>.  The solution is to use <code>assertWarns</code> or <code>assertWarnsRegex</code>.  I used the latter to show how it might be used to add an extra test.</p>
<pre><code>import unittest
import warnings

def function_that_raises_CustomWarning():
    warnings.warn("my warning")
    return True

class test(unittest.TestCase):

    def test(self):
        is_this_True = False

        with self.assertWarnsRegex(Warning, 'my warning'):
            is_this_True = function_that_raises_CustomWarning()
        self.assertTrue(is_this_True)


if __name__ == "__main__":
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">Oh thanks! Did know that I can assert based on warning raised as well. In my experience <code>except</code> does work with <code>Warning</code> as well. In this case I prefer to use <code>self.assertWarns(MoreSpecificWarning)</code> instead, since I do not want to deal with regex.</span>
<span class="comment-copy">Warnings should not be catchable exceptions unless one starts python with <code>-W error</code> <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-W" rel="nofollow noreferrer">docs.python.org/3/using/cmdline.html#cmdoption-W</a> or add a warning filter with the <code>'error'</code> action <a href="https://docs.python.org/3/library/warnings.html#warnings.filterwarnings" rel="nofollow noreferrer">docs.python.org/3/library/warnings.html#warnings.filterwarnings</a>.  Perhaps the systems you use have 'error' turned on somehow in a startup script.  Using assertWarns should work everywhere.</span>
