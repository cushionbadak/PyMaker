<div class="post-text" itemprop="text">
<p>I have a bunch of classes which I'm using as singletons / enums / dict keys, e. g. like this:</p>
<pre><code>class Side(object): pass

class Left(Side): pass
class Right(Side): pass

def show_state(distribution):
    print "left is", distribution[Left]
    print "right is", distribution[Right]

distribution = { Left: 3, Right: 7 }
show_state(distribution)
</code></pre>
<p>This works fine for me.  But I'm having a small issue with debug output I sometimes do.  Normally I use just <code>print</code> for this like in <code>print distribution</code> in the <code>show_state()</code> function.  I would love to have an output like:</p>
<pre><code>{ Left: 3, Right: 7 }
</code></pre>
<p>But when I do this with these classes they are given out as something like this:</p>
<pre><code>{&lt;class '__main__.Right'&gt;: 7, &lt;class '__main__.Left'&gt;: 3}
</code></pre>
<p>I tried to override the <code>__repr__()</code> method of my classes to achieve this, but when I do it only influences <em>instances</em> of my classes (which I never create).  I tried to use <code>@classmethod</code> and <code>@staticmethod</code> but nothing worked.</p>
<p>I assume that what I print is a <code>Left</code> and therefore an instance of <code>&lt;type 'type'&gt;</code>, so I would have to override the <code>__repr__()</code> method of the <code>type</code> class which is immutable, unfortunately.</p>
<p>Is there any other trick I could use so that <code>print distribution</code> would print what I want?</p>
<p>Btw, according to the documentation, the <code>__repr__()</code> method should return something which the Python parser would turn into an equal object again; this is definitely not the case with an output like <code>&lt;class '__main__.Right'&gt;</code> but would definitely be the case with an output like <code>Right</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are correct that you'd have to override the <code>__repr__</code> of the type of a class; you don't need to edit <code>type</code>, you'd <em>subclass</em> <code>type</code> to create a <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">new metaclass</a>:</p>
<pre><code>class SimpleRepr(type):
    def __repr__(cls):
        return cls.__name__
</code></pre>
<p>then use that as your class metaclass; assuming you are using Python 3:</p>
<pre><code>class Side(metaclass=SimpleRepr): pass
</code></pre>
<p>or if you are using Python 2 still:</p>
<pre><code>class Side(object):
    __metaclass__ = SimpleRepr
</code></pre>
<p>Subclasses of <code>Side</code> inherit the metaclass too:</p>
<pre><code>&gt;&gt;&gt; class SimpleRepr(type):
...     def __repr__(cls):
...         return cls.__name__
...
&gt;&gt;&gt; class Side(metaclass=SimpleRepr): pass
...
&gt;&gt;&gt; class Left(Side): pass
...
&gt;&gt;&gt; class Right(Side): pass
...
&gt;&gt;&gt; { Left: 3, Right: 7 }
{Left: 3, Right: 7}
</code></pre>
<p>However, you could just have used instances:</p>
<pre><code>class Side(object):
    __slots__ = ('name',)
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return self.name

Left = Side('Left')
Right = Side('Right')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not use an Enum with <strong>repr</strong></p>
<pre><code>from enum import Enum

class Side(Enum):
  Left = 'Left'
  Right = 'Right'

  def __repr__(self):
    return self.name


distribution = { Side.Left: 3, Side.Right: 7 }

print distribution  # {Right: 7, Left: 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason you're finding this difficult is that this is a strange use of classes, really. Have you considered just having one class, Side, and having left and right as instances?</p>
<pre><code>class Side(object):
    def __init__(self, direction):
        self.direction = direction

    def __repr__(self):
        return self.direction

left = Side(left)
right = Side(right)
</code></pre>
</div>
<span class="comment-copy">And I guess you could save a few bytes by defining <code>__slots__</code></span>
<span class="comment-copy">Sure, but I was referring to the 2nd version, where you do create instances.</span>
<span class="comment-copy">Duh, of course you are. <i>facepalm</i>.</span>
<span class="comment-copy">@PM2Ring: not that it makes all that much difference across 2 objects, though.</span>
<span class="comment-copy">True, it's not like they're creating lots of instances.</span>
<span class="comment-copy">I'd have the <code>__repr__</code> return <code>'{}.{}'.format(self.__class__, self.__name__)</code> in that case, but otherwise good idea!</span>
<span class="comment-copy">@MartijnPieters Thanks. OP s requirement is just to print the name of the side.</span>
<span class="comment-copy">Not <i>quite</i>. They want to show the same Python expression as was used to create the dictionary in the first place. In the case of an Enum, that's <code>Side.Left</code>, not <code>Left</code>.</span>
<span class="comment-copy">@MartijnPieters Make sense. I'll leave my answer as such and OP will get the idea anyway from your comments. Thanks.</span>
<span class="comment-copy">Enums are not suiting me in all aspects here.  I want to have an inheritance tree below Side: Left, Right, Front, Back, and then stuff like FrontLeft which inherits two of the other.  That's not possible with mere enums.</span>
