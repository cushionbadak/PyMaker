<div class="post-text" itemprop="text">
<p>I'm writing a small Python application that contains a few nested classes, like the example below:</p>
<pre><code>class SuperBar(object):
    pass

class Foo(object):
    NAME = 'this is foo'

    class Bar(SuperBar):
        MSG = 'this is how Bar handle stuff'

    class AnotherBar(SuperBar):
        MSG = 'this is how Another Bar handle stuff'
</code></pre>
<p>I'm using nested classes to create some sort of hierarchy and to provide a clean way to implement features for a parser.</p>
<p>At some point, I want to create a list of the inner classes. I'd like to have the following output:</p>
<pre><code>[&lt;class '__main__.Bar'&gt;, &lt;class '__main__.AnotherBar'&gt;]
</code></pre>
<p>The question is: <strong>What is the recommended method to get a list of inner classes in a pythonic way?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>I managed to get a list of inner class objects with the method below:</p>
<pre><code>import inspect

def inner_classes_list(cls):
    return [cls_attribute for cls_attribute in cls.__dict__.values()
            if inspect.isclass(cls_attribute)
            and issubclass(cls_attribute, SuperBar)]
</code></pre>
<p><strong>It works</strong>, but I'm not sure if using <code>__dict__</code> directly is a good thing to do. I'm using it because it contains the actual <code>class</code> instances that I need and seems to be portable across Python 2 and 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>First: I can't see how nested classes can be of any use for you. Once you have an instance <code>f</code> of <code>Foo</code>, do you realize that <code>f.Bar</code> and <code>f.AnotherBar</code> will be the same object for all instances? That is - you can't record any attribute specific from <code>f</code> on <code>f.Bar</code>, like <code>f.Bar.speed</code> - or it will collide with an attribute from another instance <code>g.Bar.speed</code>.</p>
<p>To overcome this, and actually, the only thing that makes sense, you'd need to have instances of <code>Bar</code> and <code>AnotherBar</code> attached to the instance <code>f</code>. These instances usually can't be declared on the class body - you have to create them on your Foo's <code>__init__</code> method.</p>
<p>The only thing that Bar and AntherBar can do doing there is: (1) to have a lot of class and static methods, then they work as namespaces only.  </p>
<p>Or, if a metaclass for <code>SuperBar</code> or themselves implement the descriptor protocol - <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#implementing-descriptors</a>  - but them, you'd be much better if <code>superbar</code> itself would implement the descriptor prootocol (by having either <code>__get__</code> or <code>__set__</code> methods), and attached to Foo's body you'd have <em>instances</em>  of these classes, not the classes themselves.</p>
<p>That said, you came with the solution of using <code>__dict__</code> to getting the inner classes: that won't work if <code>Foo</code> itself inherit from other classes that also have nested classes. The Superclasses of <code>Foo</code> are never searched. You can have a method to either look on all classes on  Foo's <code>__mro__</code>, or simply use  <code>dir</code> and <code>issubclass</code> :</p>
<pre><code>class Foo:
     @classmethod
     def inner_classes_list(cls):
          results = []
          for attrname in dir(cls):
              obj = getattr(cls, attrname)
              if isinstance(obj, type) and issubclass(obj, SuperBar):
                   results.append(obj)
          return results
</code></pre>
<p>(If you want this to work to all classes like Foo that does not share a common base, the same code will work if it is nto declared as a class method, of course - and also, <code>SuperBar</code> can be a parameter to this function, if you have more than one nested-class hierarchy.) </p>
<p>Now you have this, we urge you to ask other questions saying what do you want to actually do - and to read about "descriptors" - and even "properties". Really: there is very little use one can think of to nested subclasses. </p>
</div>
<span class="comment-copy">1. Why are you nesting classes, could you give more context on that? 2. Don't you just want all subclasses of <code>SuperBar</code> (in which case see <a href="http://stackoverflow.com/q/3862310/3001761">stackoverflow.com/q/3862310/3001761</a>)?</span>
<span class="comment-copy">It's not enough. In the actual application I have more root classes like <code>Foo</code>, with more inner classes to complete the parsing tree. I also need to enforce that a given token found (like <code>Bar</code>) is coming in the context of the root token <code>Foo</code>. To capture this kind of hierarchy I'm using these inner classes. -- thanks</span>
<span class="comment-copy">Then <a href="https://stackoverflow.com/posts/42326408/edit">edit</a> to give more context. It's possible you're trying to solve entirely the wrong problem.</span>
<span class="comment-copy">Yes - you can use <b>dict</b> - it is much more common place and usefull thna using nested classes. â€“ but there is a catch that by looking at <code>__dict__</code>  you don't  see any attribut from the superclasses. Check my answer.</span>
