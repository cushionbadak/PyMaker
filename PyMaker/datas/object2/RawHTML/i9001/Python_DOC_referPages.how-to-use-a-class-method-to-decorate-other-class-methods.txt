<div class="post-text" itemprop="text">
<p>When designing a class, I find that in the class methods, there are repeated steps are called each time when invoke the class method. For example:</p>
<pre><code>class Queue(object):
    def __init__(self):
        self.connection = Connection()

    def create(self, name):
        self.probe = self.connection.plug()
        self.probe.create(name)
        self.probe.unplug()

    def delete(self, name):
        self.probe = self.connection.plug()
        self.probe.delete(name)
        self.probe.unplug()
</code></pre>
<p>And there are many methods require the similar steps to 'plug' and 'unplug' the 'probe'. In this design we need to 'plug' and 'unplug' the 'probe' each time we perform the actions.</p>
<p>Thus I am thinking about the wrap those functions by decorator to make the code looking less repeated.</p>
<pre><code>class Queue(object):
    def __init__(self):
        self.connection = Connection()

    def _with_plug(self, fn):
        def wrapper(*args, **kwargs):
            self.probe = self.connection.plug()
            fn(*args, **kwargs)
            self.probe.unplug()

    @_with_plug        
    def create(self, name):
        self.probe.create(name)

    @_with_plug
    def delete(self, name):
        self.probe.delete(name)
</code></pre>
<p>But this strategy is not working. How could I use a method in the class to decorate other methods to perform such actions before and after calling a method?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should define your decorator function outside of the class body and your decorator function should return the wrapped function in order for it to work. Something like:</p>
<pre><code>def _with_plug(fn):
    def wrapper(self, *args, **kwargs):
        self.probe = self.connection.plug()
        fn(self, *args, **kwargs)
        self.probe.unplug()
    return wrapper


class Queue(object):
    def __init__(self):
        self.connection = Connection()

    @_with_plug        
    def create(self, name):
        self.probe.create(name)

    @_with_plug
    def delete(self, name):
        self.probe.delete(name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems like a bit of muddled arguments to me:</p>
<p>file deco.py, say</p>
<pre><code>def _with_plug(fn): # decorator takes exactly one argument, the function to wrap
    print("wrapping", fn.__name__)
    def wrapper(self, *args, **kwds):
        print("wrapper called")
        self.probe = [self.connection, ".plug()"]
        fn(self, *args, **kwds)
        self.probe.append(".unplug()")
    return wrapper # decorator must return the wrapped function


class Queue(object):
    def __init__(self):
        self.connection = "Connection()"

    @_with_plug
    def create(self, name):
        self.probe.append("create(name)")

    @_with_plug
    def delete(self, name):
        self.probe.append("delete(name)")
</code></pre>
<p>Check:</p>
<pre><code>&gt;&gt;&gt; import deco
wrapping create
wrapping delete
&gt;&gt;&gt; q = deco.Queue()
&gt;&gt;&gt; q.create("name")
wrapper called
&gt;&gt;&gt; q.probe
['Connection()', '.plug()', 'create(name)', '.unplug()']
</code></pre>
<p>Observe that the decorator function is called at <em>definition</em> time of the to-be-wrapped function, i.e. before the class definition is completed and long before the first instance is created. Therefore you can't reference <code>self</code> in the way you tried.</p>
</div>
<span class="comment-copy">What does "But this strategy is not working." mean?</span>
<span class="comment-copy">looks like using a method as a decorator - shown in code - always gives errors saying number of parameters. I think it is the way I use the decorator is not correct.</span>
<span class="comment-copy">Your class decorator methods <b>aren't</b> class methods in the Python sense of the <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">term</a>, but need to be.</span>
