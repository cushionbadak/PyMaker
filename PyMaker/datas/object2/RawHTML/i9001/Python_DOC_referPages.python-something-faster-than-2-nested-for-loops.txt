<div class="post-text" itemprop="text">
<pre><code>def fancymatching(fname1, fname2):
#This function will do much smarter and fancy kinds of compares
    if (fname1 == fname2):
        return 1
    else:
        return 0

personlist = [
{ 
'pid':'1',
'fname':'john',
'mname':'a',
'lname':'smyth',
},{ 
'pid':'2',
'fname':'john',
'mnane':'a',
'lname':'smith',
},{ 
'pid':'3',
'fname':'bob',
'mname':'b',
'lname':'nope',
}
]

for person1 in personlist:
    for person2 in personlist:
        if person1['pid'] &gt;= person2['pid']:
            #don't check yourself, or ones that have been
        continue
        if fancymatching(person1['fname'], person2['fname']):
            print (person1['pid'] + " matched " + person2['pid'])
</code></pre>
<p>I'm trying to improve on the idea of the above code.  It works, but if <code>personlist</code> becomes very large (say millions) I feel there must be something faster than 2 for loops.</p>
<p>What the code is doing is taking a list of dictionaries and running a fancy fuzzy matching function on the values of each dictionary against each other dictionary.  So it's not as simple as just comparing all the dictionaries to the other ones.  I'd like a way to run a function on each dictionary, maybe 2 for loops is the right way to do this?  Any suggestions would be helpful!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> which is essentially the same double loop but it iterates faster because it's written in C (that only reduces the constant factor, you still have the <code>O(n**2)</code> runtime behaviour) and you don't need the <code>if person1['pid'] &gt;= person2['pid']: continue</code> anymore (that's built into the <code>combinations</code> function already).</p>
<pre><code>from itertools import combinations

for person1, person2 in combinations(personlist, 2):
    print(person1['fname'], person2['fname'])
</code></pre>
<p>which prints:</p>
<pre><code>('john', 'john')
('john', 'bob')
('john', 'bob')
</code></pre>
<hr/>
<p>However <strong>if your <code>fancymatching</code> allows it</strong> then you could also group (<code>O(n)</code> runtime) your values. For example in your case you only match identical <code>'fname'</code>-values.</p>
<pre><code>&gt;&gt;&gt; matches = {}
&gt;&gt;&gt; for person in personlist:
...     matches.setdefault(person['fname'], []).append(person)
&gt;&gt;&gt; matches
{'bob': [{'fname': 'bob', 'lname': 'nope', 'mname': 'b', 'pid': '3'}],
 'john': [{'fname': 'john', 'lname': 'smyth', 'mname': 'a', 'pid': '1'}, 
          {'fname': 'john', 'lname': 'smith', 'mnane': 'a', 'pid': '2'}]}
</code></pre>
<p>But that's only possible if your <code>fancymatching</code> allows such a grouping. Which is True for your case but if it's more complicated it might not be.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding to MSeifert's answer, if your matching depends on fname1 == fname2 then you can sort and then group your list: ie:</p>
<pre><code>from itertools import combinations, groupby

keyfunc = lambda x: x['fname']
data = sorted(personlist, key= keyfunc)
for key, group in groupby(data, key):
    #every element in group will now match
    for person1, person2 in combinations(group, 2):
        print(person1['fname'], person2['fname'])
</code></pre>
<p>Obviously if you change your matching function you will need to change your key function so that it returns the same value for any elements that match and returns a different value for any elements that don't. This does rely on the fact that such a key function exists, which will not always be the case for an arbitrary matching function.</p>
</div>
<span class="comment-copy">If nothing is known about the fuzzy matching, you cannot do it faster than nested loops (you can however boost it with 2x if your second loop starts iterating from the next of <code>person1</code>. Such that if <code>(a,b)</code> is evaluated <code>(b,a)</code> is not evaluated. Is the matching somehow transitive?</span>
<span class="comment-copy">Using <code>itertools.combinations</code> might be a little bit faster than writing out your own loops, but not by a large amount (same <code>O(N**2)</code> asymptotic performance).</span>
<span class="comment-copy">Did you forget an if condition for selective printing?</span>
<span class="comment-copy">@Spade What do you mean?</span>
<span class="comment-copy">I thought the OP only wanted it printed when matched <code>if fancymatching(person1['fname'], person2['fname']):</code></span>
<span class="comment-copy">Ah, I didn't include that on purpose, I just wanted to demonstrate how <code>combinations</code> works. How it reduces the two loops and the first <code>if</code> to one loop. :)</span>
<span class="comment-copy">This works perfect for me.  I can throw any kind of fancy match in there now like:   if person1['fname'][:1] == person2['fname'][:1]:         print (person1['fname'], person2['fname'])     else:         print ('nope')  Thank you very much!</span>
