<div class="post-text" itemprop="text">
<p>It's my first time playing around with Python's unittest for an assignment in school. I basically have a Circle Object, where I am using pyunit to make sure the data is stored properly. </p>
<p>I noticed that Python only counts the number of methods as test cases as opposed to the number of assert statements. </p>
<p>For instance I want to test that methods are working correctly, Python only counts the following as 2 tests, despite having 4 assert statements. It really caught me off guard, as with Java's JUnit it will count the number of assert statements instead. </p>
<pre><code>def test_xcrd(self): 
    self.assertTrue(self.point.xcrd() == 1) 
    self.assertFalse(self.point.xcrd() == 5)

def test_ycrd(self): 
    self.assertTrue(self.point.ycrd() == 2) 
    self.assertFalse(self.point.ycrd() == 10)
</code></pre>
<p>What's the "norm" in python? Should there only be one assert statement per method?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>unittest</code> package allows you to structure your unit tests in separate methods like you are noticing. This is useful in cases where you want to tests things which are very closely related and don't require separate unit tests.</p>
<p><code>unittest</code> tests start by subclassing <code>unittest.Test</code>, and then adding methods to this. So, you can add several layers separation between different unittests which are more less related. </p>
<p>An example from the <a href="https://docs.python.org/3/library/unittest.html" rel="nofollow noreferrer">Python Docs</a> demonstrates what is considered to be best practice for Python unit tests:</p>
<pre><code>import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>There are a number of things you can observe here:</p>
<ol>
<li>The three methods of <code>TestStringMethods</code> are the separate unittests. </li>
<li><code>test_isupper</code> and <code>test_split</code> both contain two asserts, since they are very closely related. Adding separate tests for the two asserts present in <code>test_isupper</code> would be adding lots of bloat to the code, and it could lead to very weird problems. </li>
</ol>
<p>For example, if <code>str.isupper()</code> would break in a weird way, the single unittest covering this single function would break. However, if the two tests for <code>"FOO"</code> and <code>"Foo"</code> were separate, one test might pass, and the other fail. So, testing the functionality of a single function is better kept in a single unittest with several asserts. </p>
<p>The same applies to the <code>test_split</code> method; checking that <code>str.split()</code> works and checking that it raises a <code>TypeError</code> are closely related, and should therefore best be kept close together in code as well.</p>
<p>So, to come back to your question: There can (and sometimes should) be more than one assert per method, since it leads to simpler and clearer code, and less confusion. To quote the "Zen of Python" (found by running <code>import this</code> in a python shell): "Simple is better than complex". So, keep your unittests simple and structured by grouping similar asserts in a single method.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer to your question '''What's the "norm" in python? Should there only be one assert statement per method?''' is "No".  Some people might say 'yes' but CPython core developers, including me, routinely use multiple asserts in test methods.  Take a look at the <code>test_xyz</code> files in <code>Lib/test</code> (if your installation includes that directory).</p>
<p>It is true that one method should test one unit or even one behavior of one unit.</p>
</div>
<span class="comment-copy">"as with Java's JUnit, it will count the number of assert statements, instead" - what? Since when?</span>
<span class="comment-copy">In past experience, as long as I have @Test above methods I want to test, all assertion statements in the respective method will show up in the JUnit Testing panel of Eclipse. For instance, a method with 4 assertion statements written in Java - all four asserts will show up in Eclipse. These same assertions written in Python, with pyunit, say "Ran 1 test in 0.001s, OK."</span>
<span class="comment-copy"><code>pyunit</code> is a 3rd party testing module that is distinct from the <code>unittest</code> module that comes with CPython in the standard library.  If you are using <code>unittest</code>, then you should edit the text to remove <code>pyunit</code> and the <code>pyunit</code> tag.  If you had posted an MCVE <a href="https://stackoverflow.com/help/mcve">stackoverflow.com/help/mcve</a>, there would be no question about which module you are using.</span>
<span class="comment-copy">@TerryJanReedy <a href="https://wiki.python.org/moin/PyUnit" rel="nofollow noreferrer">wiki.python.org/moin/PyUnit</a> begs to differ? <a href="https://docs.python.org/2/library/unittest.html" rel="nofollow noreferrer">The docs</a> also say that <code>unittest</code> is sometimes referred to as PyUnit. That part is gone in the docs for Python 3 though...</span>
<span class="comment-copy">It appears that unittest began as the 3rd party module called pyunit, after Junit.  That page and the separate release, last updated in 2001, is a bit of a fossil.  Unittest, in the stdlib, has seen many fixes and updates and has a different primary maintainer.</span>
