<div class="post-text" itemprop="text">
<p>I'm trying to create a subclass of threading.Thread whose methods are threaded. I'm using it for video, but I suspect that a working example will be generally useful for folks.</p>
<p>I realized here that I never instantiated a thread and never called the <code>start()</code> method, but I don't know where to call it from or how. I also want to save the thread handle so I can stop it if I receive a <code>stop()</code> signal.</p>
<pre><code>import threading

class VideoThread(threading.Thread):
    """Thread class with a stop() method. The thread itself checks
    regularly for the stopped() condition."""

    def __init__(self, playlist=None):
        super(VideoThread, self).__init__()
        self._stop = threading.Event()
        self._player_pgid_list = []
        if playlist:
            self.start_sequence(playlist)

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.isSet()

    def start_sequence(self, playlist):
        if not isinstance(playlist, list):
            raise ValueError("Expecting a list")
        for video in playlist:
            if not self.stopped():
                self.__start_video__(video)

    def __start_video__(self, video):
        if not isinstance(video, dict):
            raise ValueError("Expecting a dictionary of video data")
        # start the video
        # store the video pgid so we can kill it if we have to
        # tight wait loop to check for stopped condition
        # kill all video(s) if necessary using the stored pgids
</code></pre>
<p>The class works as far as it goes, but of course, none of the methods are actually threaded.</p>
<p><code>start_sequence()</code> is public so I can start a threaded sequence of videos like this:</p>
<pre><code>video = VideoThread()
video.start_sequence([films[1], films[3], films[2]])
</code></pre>
<p>Or when I instantiate the class like this:</p>
<pre><code>video = VideoThread([films[1], films[3], films[2]])
</code></pre>
<p>Later, if I need to stop it, I can:</p>
<pre><code>video.stop()
</code></pre>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should rename the <code>start_sequence</code> method to <code>run</code> and delete the <code>playlist</code> parameter (use <code>self.playlist</code> instead). Also, delete those two last lines in <code>__init__</code> method. I mean:</p>
<pre><code>class VideoThread(threading.Thread):


    def __init__(self, playlist=None):
        super().__init__()
        self._stop = threading.Event()
        self._player_pgid_list = []
        self.playlist = playlist

    def run(self):
        if not isinstance(self.playlist, list):
            raise ValueError("Expecting a list")
        for video in self.playlist:
            if not self.stopped():
                self.__start_video__(video)

    ...
</code></pre>
<p>Then, to use your class just do:</p>
<pre><code>playlist = VideoThread(films)
playlist.start()
</code></pre>
<p>And you can stop it using:</p>
<pre><code>playlist.stop()
</code></pre>
<p>Note that when you call <code>.start</code>, it invokes the <code>run</code> method in a separate thread of control, check the <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow noreferrer">official documentation</a> for more information.</p>
</div>
<span class="comment-copy">Using this method, can I chain <code>start()</code>, as in <code>VideoThread(films).start()</code>?</span>
<span class="comment-copy">Yes, you can, but if you do so you are loosing the reference to the thread and that means you won't be able to stop it later. Personally, is something I wouldn't do.</span>
