<div class="post-text" itemprop="text">
<p>I'm trying to create a simple game that creates math problems and the users task is to decide if they are true or false. (eg. 2 + 2 = 6, True or False?)
I am using the keyboard module and I want to have the user press the left arrow key if he thinks that the problem is true, and the right one if he thinks that it's false.</p>
<pre><code>import random
import keyboard


def addition_easy():
    x = random.randint(1, 6)
    y = random.randint(1, 6)
    z = x + y
    answer_correct = random.choice([True, False])
    if answer_correct == False:
        answer = (random.randint(2, 12))
    else:
        answer = z
    if answer == z:
        answer_correct = True

    print(f"{x} + {y} = {answer}")
    print("True or False?")

    while True:
        if keyboard.is_pressed('left'):
            user_answer = True
            break
        elif keyboard.is_pressed('right'):
            user_answer = False
            break

    if user_answer == answer_correct:
        return True
    else:
        return False
</code></pre>
<p>The thing is, after I paste this function into a loop, I can only press left or right once. After that the rest of the code is executed without waiting for my keypress.</p>
<pre><code>from problems import addition_easy

exercise_amount = int(input("How many exercises would you like to solve?"))

for exercise in range(1, exercise_amount + 1):
    addition_easy()
</code></pre>
<p>This returns (for input of 5):</p>
<p>How many exercises would you like to solve? 5</p>
<p>6 + 1 = 9</p>
<p>True or False?            //(Here it waits for me to press "left" or "right")</p>
<p>3 + 3 = 8</p>
<p>True or False?            //(From here it doesn't stop to wait for a keypress)</p>
<p>4 + 3 = 7</p>
<p>True or False?             //(Same here and so on...)</p>
<p>2 + 3 = 3</p>
<p>True or False?</p>
<p>1 + 2 = 3</p>
<p>True or False?</p>
<p>How can I make it wait for a keypress every time it prints out a math problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the user holds down "left" for half a second, and <code>addition_easy</code> executes a hundred times in that half second, then <code>keyboard.is_pressed('left')</code> will evaluate to True for every one of them, even though the user only pressed "left" once.</p>
<p>You can verify that <code>is_pressed</code> doesn't <em>permanently</em> consider "left" to be pressed by telling your program to do 1000 problems. Pressing left will only answer about 20 of them.</p>
<p>One possible solution is to alter your loop so it waits until the key is subsequently released before continuing.</p>
<pre><code>while True:
    if keyboard.is_pressed('left'):
        user_answer = True
        while keyboard.is_pressed("left"):
            pass
        break
    elif keyboard.is_pressed('right'):
        user_answer = False
        while keyboard.is_pressed("right"):
            pass
        break
</code></pre>
<p>Another possible design is to use <code>keyboard.on_press_key</code>, which should only fire when the key changes state from "not pressed" to "pressed" (or when the auto repeat time elapses, which probably won't happen unless the user is doing it intentionally). You can abstract this out to a function to keep your <code>addition_easy</code> function clean:</p>
<pre><code>import random
import keyboard
import time

def wait_for_keys(keys):
    key_pressed = None
    def key_press_event(key):
        nonlocal key_pressed
        key_pressed = key.name

    for key in keys:
        keyboard.on_press_key(key, key_press_event)

    while key_pressed is None:
        time.sleep(0.01)
    return key_pressed

def addition_easy():
    x = random.randint(1, 6)
    y = random.randint(1, 6)
    z = x + y
    answer_correct = random.choice([True, False])
    if answer_correct == False:
        answer = (random.randint(2, 12))
    else:
        answer = z
    if answer == z:
        answer_correct = True

    print(f"{x} + {y} = {answer}")
    print("True or False?")

    key = wait_for_keys(["left", "right"])
    user_answer = (key == "left")

    if user_answer == answer_correct:
        return True
    else:
        return False

exercise_amount = 1000

for exercise in range(1, exercise_amount + 1):
    addition_easy()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if you indented your function correctly. Try:</p>
<pre><code>import random
import keyboard
def addition_easy():
    x = random.randint(1, 6)
    y = random.randint(1, 6)
    z = x + y
    answer_correct = random.choice([True, False])
    if answer_correct == False:
        answer = (random.randint(2, 12))
    else:
        answer = z
    if answer == z:
        answer_correct = True

    print(f"{x} + {y} = {answer}")
    print("True or False?")

    while True:
        if keyboard.is_pressed('left'):
            user_answer = True
            break
        elif keyboard.is_pressed('right'):
            user_answer = False
            break

    if user_answer == answer_correct:
        return True
    else:
        return False

exercise_amount = int(input("How many exercises would you like to solve?"))

for exercise in range(1, exercise_amount + 1):
    addition_easy()
</code></pre>
</div>
<span class="comment-copy">How about <code>keyboard.wait()</code> after <code>if keyboard.is_pressed('left')</code> and <code>elif keyboard.is_pressed('right')</code>?</span>
<span class="comment-copy">@amanb, If the <a href="https://github.com/boppreh/keyboard#keyboardwaithotkeynone-suppressfalse-trigger_on_releasefalse" rel="nofollow noreferrer">documentation</a> is to be believed, <code>keyboard.wait()</code> with no arguments makes the program pause forever. (No, I don't know why that's even an option)</span>
<span class="comment-copy">Yeah, it was just a guess, I haven't used it myself.</span>
<span class="comment-copy">If the module <i>does</i> have some kind of "wait until any key becomes unpressed" method, that would be a nice concise solution. But I don't think anything quite fits that bill.</span>
<span class="comment-copy">I agree that the indentation in the original draft of the question was a problem. But it wasn't the <i>only</i> problem. After fixing the indentation, the program would still rush through several questions per keystroke.</span>
