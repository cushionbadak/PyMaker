<div class="post-text" itemprop="text">
<p>I have a python class object and I want to assign the value of one class variable</p>
<pre><code>class Groupclass(Workerclass):
    """worker class"""
    count = 0

    def __init__(self):
        """initialize time"""
        Groupclass.count += 1
        self.membercount = 0;
        self.members = []

    def __del__(self):
        """delte a worker data"""
        Groupclass.count -= 1


if __name__ == "__main__":
    group1 = Groupclass()
</code></pre>
<p>This execution result is correct, but there's an error message that says:</p>
<pre><code>Exception AttributeError: "'NoneType' object has no attribute 'count'" in &lt;bound method Groupclass.__del__ of &lt;__main__.Groupclass instance at 0x00BA6710&gt;&gt; ignored
</code></pre>
<p>Can someone tell me what me I did wrong?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>__del__</code> method assumes that the class is still present by the time it is called.</p>
<p>This assumption is incorrect. <code>Groupclass</code> has already been cleared when your Python program exits and is now set to <code>None</code>.</p>
<p>Test if the global reference to the class still exists first:</p>
<pre><code>def __del__(self):
    if Groupclass:
        Groupclass.count -= 1
</code></pre>
<p>or use <code>type()</code> to get the local reference:</p>
<pre><code>def __del__(self):
    type(self).count -= 1
</code></pre>
<p>but do note that this means that the semantics for <code>count</code> change if <code>Groupclass</code> is subclassed (each subclass gets a <code>.count</code> attribute versus only <code>Groupclass</code> having a <code>.count</code> attribute).</p>
<p>Quoting from the <code>__del__</code> hook documentation:</p>
<blockquote>
<p><strong>Warning</strong>: Due to the precarious circumstances under which <code>__del__()</code> methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to <code>sys.stderr</code> instead. Also, when <code>__del__()</code> is invoked in response to a module being deleted (e.g., when execution of the program is done), other globals referenced by the <code>__del__()</code> method may already have been deleted or in the process of being torn down (e.g. the import machinery shutting down). For this reason, <code>__del__()</code> methods should do the absolute minimum needed to maintain external invariants. Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the <code>__del__()</code> method is called.</p>
</blockquote>
<p>If you are using Python 3, two additional notes apply:</p>
<ul>
<li><p>CPython 3.3 automatically applies a <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="noreferrer">randomized hash salt</a> to the <code>str</code> keys used in a <code>globals</code> dictionary; this also affects the order in which globals are cleaned up, and it <em>could</em> be that you see the problem on only <em>some</em> of the runs.</p></li>
<li><p>CPython 3.4 no longer sets globals to <code>None</code> (in most cases), as per <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-pep-442" rel="noreferrer">Safe Object Finalization</a>; see <a href="http://www.python.org/dev/peps/pep-0442/" rel="noreferrer">PEP 442</a>.</p></li>
</ul>
</div>
<span class="comment-copy">Your <code>Workerclass</code> base class appears to have a <code>__del__</code> method that is trying to do something with <code>count</code>, but you didn't share that method here.</span>
<span class="comment-copy">sorry I don't know that's related...</span>
<span class="comment-copy">Your message is a warning only, it is not an error. <b>Something</b> in the <code>__del__</code> method tried to do something with the <code>count</code> attribute and failed.</span>
<span class="comment-copy">there's actually nothing inside <code>__del__</code> except <code>Groupclass.count -= 1</code>.   So is what bothers me because I haven't done anything yet.</span>
<span class="comment-copy">But that is the code that generates that error message; it is rather relevant.</span>
<span class="comment-copy">Thank you it's working now.   Now my question is if I want to <code>del</code> a <code>Groupclass</code> object, <code>Groupclass</code> object or 'Groupclass' itself must exist before the <code>del</code> will be executed so it seems the statement is somehow redundant?</span>
<span class="comment-copy">@Chandler: No, when the interpreter exists, global names can be cleaned up before instances are; the <code>Groupclass</code> name has been cleaned up already. You can also use <code>type(self).count</code> instead, unless you have subclasses that do not have their own count.</span>
<span class="comment-copy">still don't quite understand about this concept but thanks I'll look into this!</span>
<span class="comment-copy">"Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the __del__() method is called." Does this imply that if I rename to _Groupclass, the problem is solved?</span>
<span class="comment-copy">@acai: no. It means that objects bound to names with <code>_</code> at the start can count on names that do not start with <code>_</code> to be deleted later, so you can still rely on imported modules (which typically have non-private names) are still available.</span>
