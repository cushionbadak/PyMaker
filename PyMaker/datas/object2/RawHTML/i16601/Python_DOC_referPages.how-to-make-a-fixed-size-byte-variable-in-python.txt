<div class="post-text" itemprop="text">
<p>Let's say, I have a string (unicode if it matters) variable which is less than 100 bytes. I want to create another variable with exactly 100 byte in size which includes this string and is padded with zero or whatever. How would I do it in Python 3?</p>
</div>
<div class="post-text" itemprop="text">
<p>For assembling packets to go over the network, or for assembling byte-perfect binary files, I suggest using the <code>struct</code> module.</p>
<ul>
<li><a href="https://docs.python.org/3.3/library/struct.html" rel="nofollow">struct — Interpret bytes as packed binary data</a></li>
</ul>
<p>Just for the string, you might not need <code>struct</code>, but as soon as you start also packing binary values, <code>struct</code> will make your life much easier.</p>
<p>Depending on your needs, you might be better off with an off-the-shelf network serialization library, such as Protocol Buffers; or you might even just use JSON for the wire format.</p>
<ul>
<li><a href="https://developers.google.com/protocol-buffers/docs/pythontutorial" rel="nofollow">Protocol Buffer Basics: Python</a></li>
<li><a href="http://pymotw.com/2/json/" rel="nofollow">PyMOTW - JavaScript Object Notation Serializer</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Something like this should work:</p>
<pre><code>st = "具有"
by = bytes(st, "utf-8")
by += b"0" * (100 - len(by))
print(by)
# b'\xe5\x85\xb7\xe6\x9c\x890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
</code></pre>
<p>Obligatory addendum since your original post seems to conflate strings with the length of their encoded byte representation: <a href="http://nedbatchelder.com/text/unipain.html" rel="nofollow">Python unicode explanation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="https://docs.python.org/3/library/stdtypes.html#bytes.zfill" rel="nofollow noreferrer"><code>bytes.zfill</code></a> method to add the required number of zeroes:</p>
<pre><code>In [19]: result = bytes('おくりびと', 'utf-8').zfill(100)

In [20]: result
Out[20]: b'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000\xe3\x81\x8a\xe3\x81\x8f\xe3\x82\x8a\xe3\x81\xb3\xe3\x81\xa8'

In [21]: len(result)
Out[21]: 100
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To pad with null bytes you can do it the way they do it in the stdlib <a href="http://hg.python.org/cpython/file/4fc571a04c9c/Lib/base64.py#l160" rel="nofollow">base64</a> module.</p>
<pre><code>some_data = b'foosdsfkl\x05'
null_padded = some_data + bytes(100 - len(some_data))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a roundabout way of doing it:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; a = "a"
&gt;&gt;&gt; sys.getsizeof(a)
22
&gt;&gt;&gt; a = "aa"
&gt;&gt;&gt; sys.getsizeof(a)
23
&gt;&gt;&gt; a = "aaa"
&gt;&gt;&gt; sys.getsizeof(a)
24
</code></pre>
<p>So following this, an <strong>ASCII</strong> string of 100 bytes will need to be 79 characters long</p>
<pre><code>&gt;&gt;&gt; a = "".join(["a" for i in range(79)])
&gt;&gt;&gt; len(a)
79
&gt;&gt;&gt; sys.getsizeof(a)
100
</code></pre>
<p>This approach above is a fairly simple way of "calibrating" strings to figure out their lengths.  You could automate a script to pad a string out to the appropriate memory size to account for other encodings.  </p>
<pre><code>def padder(strng):
    TARGETSIZE = 100
    padChar = "0"

    curSize = sys.getsizeof(strng)

    if curSize &lt;= TARGETSIZE:
        for i in range(TARGETSIZE - curSize):
            strng = padChar + strng

        return strng
    else:
        return strng  # Not sure if you need to handle strings that start longer than your target, but you can do that here
</code></pre>
</div>
<span class="comment-copy">Is this for displaying the string, or for some other reason?</span>
<span class="comment-copy">@CodyPiersall, I need to send fixed-size byte over network so I can assemble the packet on the other side.</span>
<span class="comment-copy">the byte-size of a string depends on the encoding... Are you talking about strings in the sense of 'text' or strings in the sense of data b'\x00' ?</span>
<span class="comment-copy">Using Python 2 or 3?</span>
<span class="comment-copy">If you don't know what it is padded with, how can you distinguish the padding from the actual data on the receiving end?</span>
<span class="comment-copy">Although this is not directly an answer to my question but that's exactly what I wanted. Thanks.</span>
<span class="comment-copy">Officially <code>str.zfill()</code> is deprecated</span>
<span class="comment-copy">This is 100 long string and not exactly 100 byte.</span>
<span class="comment-copy">@wnnmaw: where did you get <i>that</i> idea? <a href="https://docs.python.org/3/library/stdtypes.html#str.zfill" rel="nofollow noreferrer">It most certainly is <i>not</i></a>. Are you thinking of the <a href="https://docs.python.org/2/library/string.html#deprecated-string-functions" rel="nofollow noreferrer">deprecated functions in the <code>string</code> module</a> perhaps?</span>
<span class="comment-copy">No, you are confused. <code>str</code> is the type. <code>string</code> is a <i>module</i>.</span>
<span class="comment-copy">@wnnmaw: and now that I am back on a laptop: the <i>module functions</i> have been deprecated, because the <i><code>str</code> type</i> now has methods for the same things. Don't confuse the module functions with the methods. In Python 3, the <a href="https://docs.python.org/3/library/string.html#deprecated-string-functions" rel="nofollow noreferrer"><code>string</code> module</a> no longer has those functions, because of that.</span>
<span class="comment-copy">Thanks but the size of <code>a = "具有"</code> is 42.</span>
<span class="comment-copy">@MikaelS., see my edit</span>
<span class="comment-copy">Doesn't <code>sys.getsizeof</code> try to show the size of some object in the vm's memory? That varies from platform to platform and implementation to implementation. On my machine it varies from <code>43</code> in python2.7, to <code>78</code> in python3.3 to <code>TypeError: sys.getsizeof() not implemented on PyPy</code>. I doubt this is what @MikaelS. was after...</span>
<span class="comment-copy">@ChrisWesseling: Yeah. As if it's not bad enough that the answer's own text starts with "Here's a roundabout way of doing it", that way turns out to be completely wrong anyway.</span>
<span class="comment-copy">@JohnY, thanks for your constructive input.</span>
