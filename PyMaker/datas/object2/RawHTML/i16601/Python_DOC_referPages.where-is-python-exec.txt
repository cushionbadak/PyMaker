<div class="post-text" itemprop="text">
<p>I know it is possible to get access to builtin functions with something like:</p>
<p><code>object().__reduce__()[0].__globals__["__builtins__"]</code></p>
<p>And this seems to work for most functions. However, I cannot seem to be able to find <code>exec()</code>. I am pretty certain it is a builtin function, so why wouldn't it appear in <code>__builtins__</code>? Both <code>eval()</code> and <code>execfile()</code> are there.</p>
<p>I am using python 2.7</p>
<h1>[EDIT]</h1>
<p>A much simpler way to get to globals is with the builtin function <code>globals()</code> :) So the above can be reduced to:
<code>globals()['__builtins__'].__dict__</code></p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.x, <a href="https://docs.python.org/2/reference/simple_stmts.html#the-exec-statement" rel="nofollow"><code>exec</code> is a statement</a>, not a function:</p>
<pre><code>&gt;&gt;&gt; # Python 2.x interpreter
&gt;&gt;&gt; 'exec' in dir(__builtins__)
False
&gt;&gt;&gt; callable(exec)  # This would return True if exec was a function
  File "&lt;stdin&gt;", line 1
    callable(exec)
                ^
SyntaxError: invalid syntax
&gt;&gt;&gt;
</code></pre>
<p>In Python 3.x however, <code>exec</code> was <a href="https://docs.python.org/3/whatsnew/3.0.html#removed-syntax" rel="nofollow">converted into a function</a>:</p>
<pre><code>&gt;&gt;&gt; # Python 3.x interpreter
&gt;&gt;&gt; 'exec' in dir(__builtins__)
True
&gt;&gt;&gt; callable(exec)
True
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>exec</code> is a <em>keyword</em>, like <code>print</code>. Therefore it is <em>not</em> a function.</p>
<p>You can see this if you attempt to assign to it:</p>
<pre><code>&gt;&gt;&gt; print = 3
  File "&lt;stdin&gt;", line 1
    print = 3
          ^
SyntaxError: invalid syntax
&gt;&gt;&gt; exec = 3
  File "&lt;stdin&gt;", line 1
    exec = 3
         ^
SyntaxError: invalid syntax
&gt;&gt;&gt; eval = 3
&gt;&gt;&gt; 
</code></pre>
<hr/>
<p>If you're hellbent on calling <code>exec</code> without using the word <code>exec</code>, you can do something like this:</p>
<pre><code>import ctypes

ctypes.pythonapi.PyRun_SimpleString("print 'hello world'")
</code></pre>
<p>which abuses the CPython API to execute a piece of code (which can be arbitrarily long).</p>
<p>And if you need control over the globals and locals, use <code>PyRun_String</code>:</p>
<pre><code>Py_file_input = 257 # Include/Python.h
def my_exec(s, _globals, _locals):
    return ctypes.pythonapi.PyRun_String(s, Py_file_input, ctypes.py_object(_globals), ctypes.py_object(_locals))

my_exec("print 3 + 3", globals(), locals())
</code></pre>
</div>
<span class="comment-copy">Why do you need to do this?</span>
<span class="comment-copy">I understand how this looks suspicious :). It is so I can obfuscate proprietary code. I know it won't be impossible to figure out, but it won't be easy.</span>
<span class="comment-copy">Is there any way to access it without calling it the conventional way? (in 2.7)</span>
<span class="comment-copy">If not in <code>__builtins__</code> where is it? Is there a similar way to call a statement to the one I specified in my question?</span>
<span class="comment-copy">No, there isn't really any meaning to accessing a statement.  It would be like wanting to access <code>if</code> or <code>for</code> or <code>return</code>, it is a language construct that isn't represented by an object.</span>
<span class="comment-copy">Is there any other function that would allow me to execute code from a string? Even if it contained multiple statements?</span>
<span class="comment-copy">Why can't you just use the <code>exec</code> statement?  If you really need a function I suppose you could use <code>def exec_function(*args): exec args</code>.  Although a better question would maybe be do you really need to execute code from a string in the first place?</span>
<span class="comment-copy">wow ... didn't know about <code>ctypes.pythonapi</code>  (+1 for that).  However, that really doesn't replace <code>exec</code> -- I assume that you don't somehow magically gain access to the global and local namespaces the way you can with exec.</span>
<span class="comment-copy">@mgilson: See update. <code>PyRun_String</code> gives you globals and locals.</span>
<span class="comment-copy">Here's what I was able to do: <a href="http://pastebin.com/VZZ41MN9" rel="nofollow noreferrer">pastebin.com/VZZ41MN9</a> (that first line was me making sure <code>code</code> wasn't reserved)</span>
<span class="comment-copy">Oh and here's the most shady looking version of <code>print 'Hello World!'</code>  (after running it through the program I wrote) <a href="http://pastebin.com/vY8fyEL2" rel="nofollow noreferrer">pastebin.com/vY8fyEL2</a></span>
<span class="comment-copy">Can't tell if you're using it or not, but <code>str.encode('zip')</code> and <code>str.encode('base64')</code> are wonderfully efficient obfuscation techniques, especially since you can obfuscate the encoding string itself.</span>
