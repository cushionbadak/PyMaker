<div class="post-text" itemprop="text">
<p>I feel like I have a pretty good grasp on using decorators when dealing with regular functions, but between using methods of base classes for decorators in derived classes, and passing parameters to said decorators, I cannot figure out what to do next.
Here is a snippet of code.</p>
<pre>
class ValidatedObject:
    ...

    def apply_validation(self, field_name, code):
        def wrap(self, f):
            self._validations.append(Validation(field_name, code, f))
            return f
        return wrap


class test(ValidatedObject):
    ....
    @apply_validation("_name", "oh no!")
    def name_validation(self, name):
        return name == "jacob"

</pre>
<p>If I try this as is, I get an "apply_validation" is not found.<br/>
If I try it with <code>@self.apply_validation</code> I get a "self" isn't found.<br/>
I've also been messing around with making <code>apply_validation</code> a class method without success. </p>
<p>Would someone please explain what I'm doing wrong, and the best way to fix this?  Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>The issue you're having is that <code>apply_validation</code> is a method, which means you need to call it on an instance of <code>ValidatedObject</code>. Unfortunately, at the time it is being called (during the definition of the <code>test</code> class), there is no appropriate instance available. You need a different approach.</p>
<p>The most obvious one is to use a metaclass that searches through its instance dictionaries (which are really class dictionaries) and sets up the <code>_validations</code> variable based on what it finds. You can still use a decorator, but it probably should be a global function, or perhaps a static method, and it will need to work differently. Here's some code, that uses a metaclass and a decorator that adds function attributes:</p>
<pre><code>class ValidatedMeta(type):
    def __new__(meta, name, bases, dct):
        validations = [Validation(f._validation_field_name, f._validation_code, f)
                       for f in dct.values if hasattr(f._validation_field_name)]
        dct["_validations"] = validations
        super(ValidatedMeta, meta).__new__(meta, name, bases, dct)

def apply_validation(field_name, code):
    def decorator(f):
        f._validation_field_name = field_name
        f._validation_code = code
        return f
    return decorator

def ValidatedObject(metaclass=ValidatedMeta):
    pass

class test(ValidatedObject):
    @apply_validation("_name", "oh no!")
    def name_validation(self, name):
        return name == "jacob"
</code></pre>
<p>After this code runs, <code>test._validations</code> will be <code>[Validation("_name", "oh no!", test.name_validation)]</code>. Note that the method that is be passed to <code>Validation</code> is unbound, so you'll need to pass it a <code>self</code> argument yourself when you call it (or perhaps drop the <code>self</code> argument and change the decorator created in <code>apply_validation</code> to return <code>staticmethod(f)</code>).</p>
<p>This code may not do what you want if you have validation methods defined at several levels of an inheritance hierarchy. The metaclass as written above only checks the immediate class's dict for methods with the appropriate attributes. If you need it include inherited methods in <code>_validations</code> too, you may need to modify the logic in <code>ValidatedMeta.__new__</code>. Probably the easiest way to go is to look for <code>_validations</code> attributes in the <code>bases</code> and concatenate the lists together.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just an example for using decorators on class method:</p>
<pre><code>from functools import wraps

def VALIDATE(dec):
    @wraps(dec)
    def _apply_validation(self, name):
        self.validate(name)
        return dec(self, name)
    return _apply_validation

class A:
    def validate(self, name):
        if name != "aamir":
            raise Exception, 'Invalid name "%s"' % name

class B(A):

    @VALIDATE
    def name_validation(self, name):
        return name

b = B()
b.name_validation('jacob') # should raise exception
</code></pre>
</div>
<span class="comment-copy">Does each instance need its own <code>Validation</code> object for each method?</span>
<span class="comment-copy">@user2357112 I was thinking it would just be one Validation object per test object.  The Validation object contains a list of all the validations test, and when you call a method to run all the validations, it just goes through the list.</span>
<span class="comment-copy">@jacobcase94 check my answer. Does that help? I don't know whats <code>ValidatedObject</code> is so I have tried to be as simple as I can. Or if I have misunderstood your question?</span>
<span class="comment-copy">Should <code>ValidatedObject</code> subclasses inherit validations from each other? That is, if a class <code>test2</code> inherits from <code>test</code> in your example code, should <code>test2._validations</code> include the <code>Validation</code> instance created for <code>"_name"</code> or should it leave that to other inherited methods?</span>
<span class="comment-copy">@Blckknght that would be preferable.</span>
<span class="comment-copy">Python just got a lot more complicated.  This is very helpful though, I have some processing to do.</span>
<span class="comment-copy">Why does the <b>new</b> take 4 parameters.  I've having trouble understanding it.  I've been reading this question: <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" title="what is a metaclass in python">stackoverflow.com/questions/100003/â€¦</a> Thanks.</span>
<span class="comment-copy">@jacobcase94: The metaclass accepts those arguments to match the call syntax of its superclass, <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a> (the <code>meta</code> parameter gets supplied automatically, like <code>cls</code> in a regular <code>__new__</code> method). When the <code>ValidatedObject</code> and <code>test</code> classes are defined, <code>ValidatedMeta</code> is called to construct the class objects. You could do it manually. The <code>ValidatedObject</code> class statement is equivalent to:  <code>ValidatedObject = ValidatedMeta("ValidatedObject", (), {})</code>.</span>
