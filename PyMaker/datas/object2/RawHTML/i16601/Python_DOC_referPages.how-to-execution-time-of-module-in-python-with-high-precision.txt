<div class="post-text" itemprop="text">
<p>Which is better to use for timing in Python? time.clock() or time.time()? Which one provides more accuracy?</p>
<p>for example:</p>
<pre><code>start = time.clock()
... do something
elapsed = (time.clock() - start)
</code></pre>
<p>vs.</p>
<pre><code>start = time.time()
... do something
elapsed = (time.time() - start)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of 3.3, <a href="https://docs.python.org/3/library/time.html#time.clock" rel="noreferrer"><em>time.clock()</em> is deprecated</a>, and it's suggested to use <strong><a href="https://docs.python.org/3/library/time.html#time.process_time" rel="noreferrer">time.process_time()</a></strong> or <strong><a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="noreferrer">time.perf_counter()</a></strong> instead.</p>
<p>Previously in 2.7, according to the <strong><a href="https://docs.python.org/2.7/library/time.html#time.clock" rel="noreferrer">time module docs</a></strong>:</p>
<blockquote>
<p><strong>time.clock()</strong></p>
<p>On Unix, return the current processor time as a floating point number
  expressed in seconds. The precision, and in fact the very definition
  of the meaning of “processor time”, depends on that of the C function
  of the same name, but in any case, <strong>this is the function to use for
  benchmarking Python or timing algorithms.</strong></p>
<p>On Windows, this function returns wall-clock seconds elapsed since the
  first call to this function, as a floating point number, based on the
  Win32 function QueryPerformanceCounter(). The resolution is typically
  better than one microsecond.</p>
</blockquote>
<p>Additionally, there is the <a href="https://docs.python.org/2/library/timeit.html" rel="noreferrer">timeit</a> module for benchmarking code snippets.</p>
</div>
<div class="post-text" itemprop="text">
<p>The short answer is: most of the time <code>time.clock()</code> will be better.
However, if you're timing some hardware (for example some algorithm you put in the GPU), then <code>time.clock()</code> will get rid of this time and <code>time.time()</code> is the only solution left.</p>
<p>Note: whatever the method used, the timing will depend on factors you cannot control (when will the process switch, how often, ...), this is worse with <code>time.time()</code> but exists also with <code>time.clock()</code>, so you should never run one timing test only, but always run a series of test and look at mean/variance of the times.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/85451#85511">Others</a> have answered re: <code>time.time()</code> vs. <code>time.clock()</code>. </p>
<p>However, if you're timing the execution of a block of code for benchmarking/profiling purposes, you should take a look at the <a href="https://docs.python.org/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One thing to keep in mind:
  Changing the system time affects <code>time.time()</code> but not <code>time.clock()</code>.</p>
<p>I needed to control some automatic tests executions. If one step of the test case took more than a given amount of time, that TC was aborted to go on with the next one.</p>
<p>But sometimes a step needed to change the system time (to check the scheduler module of the application under test), so after setting the system time a few hours in the future, the TC timeout expired and the test case was aborted. I had to switch from <code>time.time()</code> to <code>time.clock()</code> to handle this properly.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>clock()</code> -&gt; floating point number</p>
<p>Return the CPU time or real time since the start of the process or since
the first call to <code>clock()</code>.  This has as much precision as the system
records.</p>
<p><code>time()</code> -&gt; floating point number</p>
<p>Return the current time in seconds since the Epoch.
Fractions of a second may be present if the system clock provides them.</p>
<p>Usually <code>time()</code> is more precise, because operating systems do not store the process running time with the precision they store the system time (ie, actual time)</p>
</div>
<div class="post-text" itemprop="text">
<p>Depends on what you care about. If you mean WALL TIME (as in, the time on the clock on your wall), time.clock() provides NO accuracy because it may manage CPU time. </p>
</div>
<div class="post-text" itemprop="text">
<p>For my own <code>practice. time()</code> has better precision than <code>clock()</code> on Linux. <code>clock()</code> only has precision less than 10 ms. While <code>time()</code> gives prefect precision.
My test is on CentOS 6.4， python 2.6</p>
<pre><code>using time():

1 requests, response time: 14.1749382019 ms
2 requests, response time: 8.01301002502 ms
3 requests, response time: 8.01491737366 ms
4 requests, response time: 8.41021537781 ms
5 requests, response time: 8.38804244995 ms
</code></pre>
<p><code>using clock():</code></p>
<pre><code>1 requests, response time: 10.0 ms
2 requests, response time: 0.0 ms 
3 requests, response time: 0.0 ms
4 requests, response time: 10.0 ms
5 requests, response time: 0.0 ms 
6 requests, response time: 0.0 ms
7 requests, response time: 0.0 ms 
8 requests, response time: 0.0 ms
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The difference is very platform-specific.</p>
<p>clock() is very different on Windows than on Linux, for example.</p>
<p>For the sort of examples you describe, you probably want the "timeit" module instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>On Unix time.clock() measures the amount of CPU time that has been used by the current process, so it's no good for measuring elapsed time from some point in the past. On Windows it will measure wall-clock seconds elapsed since the first call to the function. On either system time.time() will return seconds passed since the epoch. </p>
<p>If you're writing code that's meant only for Windows, either will work (though you'll use the two differently - no subtraction is necessary for time.clock()). If this is going to run on a Unix system or you want code that is guaranteed to be portable, you will want to use time.time().</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer: use <strong>time.clock()</strong> for timing in Python.</p>
<p>On *nix systems, clock() returns the processor time as a floating point number, expressed in seconds. On Windows, it returns the seconds elapsed since the first call to this function, as a floating point number.</p>
<p>time() returns the the seconds since the epoch, in UTC, as a floating point number. There is no guarantee that you will get a better precision that 1 second (even though time() returns a floating point number). Also note that if the system clock has been set back between two calls to this function, the second function call will return a lower value.</p>
</div>
<div class="post-text" itemprop="text">
<p>To the best of my understanding, time.clock() has as much precision as your system will allow it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use this code to compare 2 methods .My OS is windows 8 , processor core i5 , RAM 4GB</p>
<pre><code>import time

def t_time():
    start=time.time()
    time.sleep(0.1)
    return (time.time()-start)


def t_clock():
    start=time.clock()
    time.sleep(0.1)
    return (time.clock()-start)




counter_time=0
counter_clock=0

for i in range(1,100):
    counter_time += t_time()

    for i in range(1,100):
        counter_clock += t_clock()

print "time() =",counter_time/100
print "clock() =",counter_clock/100
</code></pre>
<p>output:</p>
<p>time() = 0.0993799996376</p>
<p>clock() = 0.0993572257367</p>
</div>
<div class="post-text" itemprop="text">
<p>Right answer : <strong>They're both the same length of a fraction.</strong></p>
<p>But which faster if <code>subject</code> is <code>time</code> ?</p>
<p><strong>A little test case</strong> :</p>
<pre><code>import timeit
import time

clock_list = []
time_list = []

test1 = """
def test(v=time.clock()):
    s = time.clock() - v
"""

test2 = """
def test(v=time.time()):
    s = time.time() - v
"""
def test_it(Range) :
    for i in range(Range) :
        clk = timeit.timeit(test1, number=10000)
        clock_list.append(clk)
        tml = timeit.timeit(test2, number=10000)
        time_list.append(tml)

test_it(100)

print "Clock Min: %f Max: %f Average: %f" %(min(clock_list), max(clock_list), sum(clock_list)/float(len(clock_list)))
print "Time  Min: %f Max: %f Average: %f" %(min(time_list), max(time_list), sum(time_list)/float(len(time_list)))
</code></pre>
<p>I am not work an Swiss labs but I've tested.. </p>
<p><strong>Based of this question : <code>time.clock()</code> is better than <code>time.time()</code></strong></p>
<p>Edit : <code>time.clock()</code> is internal counter so can't use outside, got limitations <code>max 32BIT FLOAT</code>, can't continued counting if not store first/last values. Can't merge another one counter... </p>
</div>
<div class="post-text" itemprop="text">
<p>As others have noted <code>time.clock()</code> is deprecated in favour of  <code>time.perf_counter()</code> or <code>time.process_time()</code>, but Python 3.7 introduces nanosecond resolution timing with <a href="https://docs.python.org/3.7/library/time.html#time.perf_counter_ns" rel="nofollow noreferrer"><code>time.perf_counter_ns()</code></a>, <a href="https://docs.python.org/3.7/library/time.html#time.process_time_ns" rel="nofollow noreferrer"><code>time.process_time_ns()</code></a>, and <a href="https://docs.python.org/3.7/library/time.html#time.time_ns" rel="nofollow noreferrer"><code>time.time_ns()</code></a>, along with 3 other functions.</p>
<p>These 6 new nansecond resolution functions are detailed in <a href="https://www.python.org/dev/peps/pep-0564/" rel="nofollow noreferrer">PEP 564</a>:</p>
<blockquote>
<p><code>time.clock_gettime_ns(clock_id)</code></p>
<p><code>time.clock_settime_ns(clock_id, time:int)</code></p>
<p><code>time.monotonic_ns()</code></p>
<p><code>time.perf_counter_ns()</code></p>
<p><code>time.process_time_ns()</code></p>
<p><code>time.time_ns()</code></p>
<p>These functions are similar to the version without the _ns suffix, but
  return a number of nanoseconds as a Python int.</p>
</blockquote>
<p>As others have also noted, use the <a href="https://docs.python.org/3.7/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code> module</a> to time functions and small code snippets.</p>
</div>
<div class="post-text" itemprop="text">
<p>Comparing test result between Ubuntu Linux and Windows 7.</p>
<p><strong>On Ubuntu</strong></p>
<pre><code>&gt;&gt;&gt; start = time.time(); time.sleep(0.5); (time.time() - start)
0.5005500316619873
</code></pre>
<p><strong>On Windows 7</strong></p>
<pre><code>&gt;&gt;&gt; start = time.time(); time.sleep(0.5); (time.time() - start)
0.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the time.time() is preferred.</p>
</div>
<span class="comment-copy">Note that as of Python 3.3, <a href="http://docs.python.org/3.3/library/time.html#time.clock" rel="nofollow noreferrer">the use of <code>time.clock()</code> is deprecated</a>, and it is recommended to use <code>perf_counter()</code> or <code>process_time()</code> instead.</span>
<span class="comment-copy">@CodyPiersall: even on Python 2, you should <a href="http://stackoverflow.com/questions/85451/python-time-clock-vs-time-time-accuracy#comment18341094_85536">use <code>timeit.default_timer()</code> to measure performance (it is assigned to time.time() or time.clock() depending on OS)</a>.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/27863717/why-is-time-clock-giving-a-greater-elapsed-time-than-time-time#comment44277144_27865455">this comment</a> about how all cores used by a process are summed in <code>time.clock</code> and <code>time.process_time</code>, but child processes are not.  Also see <a href="https://www.webucator.com/blog/2015/08/python-clocks-explained/" rel="nofollow noreferrer">this discussion of precision</a> (of course, varies by system).</span>
<span class="comment-copy">"this is the function to use for benchmarking Python or timing algorithms."&lt;br&gt; The Python docs don't seem to be accurate based on the answers given here. time.clock() is not always what you want for benchmarking. especially with the existence of the timeit module</span>
<span class="comment-copy">@Corey Goldberg: so did you <a href="http://docs.python.org/2/bugs.html" rel="nofollow noreferrer">submit a documentation bug</a>? (They meant "use <i>clock()</i> rather than <i>time()</i>:, but yeah it's sloppy)</span>
<span class="comment-copy">@smci: <a href="http://bugs.python.org/issue22749" rel="nofollow noreferrer">Python bug: remove obsolete remark in time.clock() docs</a></span>
<span class="comment-copy">As can be read <a href="https://docs.python.org/3/library/time.html#time.clock" rel="nofollow noreferrer">here</a> it seems the behaviour of <code>time.clock()</code> was depedent on the platform, and <code>time.process_time()</code> is not. This is the reason why <code>time.clock()</code> was deprecated.</span>
<span class="comment-copy">The phrase on GPU helped a lot!</span>
<span class="comment-copy">also when requesting network resource by an async way(process will be blocked to wait), the network time will be got rid of.</span>
<span class="comment-copy">+1: <a href="http://docs.python.org/2/library/timeit.html#timeit.default_timer" rel="nofollow noreferrer"><code>timeit.default_timer</code></a> is assigned to <code>time.time()</code> or <code>time.clock()</code> depending on OS. On Python 3.3+ <a href="http://docs.python.org/3/library/timeit#timeit.default_timer" rel="nofollow noreferrer"><code>default_timer</code></a> is <a href="http://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>time.perf_counter()</code></a> on all platforms.</span>
<span class="comment-copy">I was looking for this. Thanks :) It will help me even if a user changes his time from OS.</span>
<span class="comment-copy">How can I compare this time and the one stored by user in hour:minute format?</span>
<span class="comment-copy">exactly, I just used <code>time.clock()</code> on a Linux servers and the numbers I got definitely weren't seconds</span>
<span class="comment-copy">so I assume time() on wine??</span>
<span class="comment-copy">could you expand, in what ways <code>clock</code> is <code>"very different"</code>?</span>
<span class="comment-copy">this doesn't answer the question.  downvoted.</span>
<span class="comment-copy">please read the other answers to understand the difference on windows vs. unix/linux.</span>
<span class="comment-copy">My Avast found a virus in that link, you would better not access there</span>
<span class="comment-copy">The link has gone bad, but archive.org has a copy, here: <a href="http://web.archive.org/web/20100825233709/http://www.techarticles.zeromu.net/programming/keeping-track-of-elapsed-time-in-python/" rel="nofollow noreferrer">web.archive.org/web/20100825233709/http://…</a></span>
