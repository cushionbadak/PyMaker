<div class="post-text" itemprop="text">
<p>I need to know if a python module exists, without importing it.</p>
<p>Importing something that might not exist (not what I want):</p>
<pre><code>try:
    import eggs
except ImportError:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python2</h2>
<p>To check if import can find something in python2, using <code>imp</code></p>
<pre><code>import imp
try:
    imp.find_module('eggs')
    found = True
except ImportError:
    found = False
</code></pre>
<p>To find dotted imports, you need to do more:</p>
<pre><code>import imp
try:
    spam_info = imp.find_module('spam')
    spam = imp.load_module('spam', *spam_info)
    imp.find_module('eggs', spam.__path__) # __path__ is already a list
    found = True
except ImportError:
    found = False
</code></pre>
<p>You can also use <code>pkgutil.find_loader</code> (more or less the same as the python3 part</p>
<pre><code>import pkgutil
eggs_loader = pkgutil.find_loader('eggs')
found = eggs_loader is not None
</code></pre>
<h2>Python3</h2>
<h3>Python3 ≤ 3.3</h3>
<p>You should use <code>importlib</code>, How I went about doing this was:</p>
<pre><code>import importlib
spam_loader = importlib.find_loader('spam')
found = spam_loader is not None
</code></pre>
<p>My expectation being, if you can find a loader for it, then it exists.  You can also be a bit more smart about it, like filtering out what loaders you will accept.  For example:</p>
<pre><code>import importlib
spam_loader = importlib.find_loader('spam')
# only accept it as valid if there is a source file for the module - no bytecode only.
found = issubclass(type(spam_loader), importlib.machinery.SourceFileLoader)
</code></pre>
<h3>Python3 ≥ 3.4</h3>
<p>In Python3.4 <code>importlib.find_loader</code> <a href="https://docs.python.org/3/library/importlib.html#importlib.find_loader" rel="noreferrer">python docs</a> was deprecated in favour of <code>importlib.util.find_spec</code>.  The recommended method is the <code>importlib.util.find_spec</code>. There are others like <code>importlib.machinery.FileFinder</code>, which is useful if you're after a specific file to load.  Figuring out how to use them is beyond the scope of this.</p>
<pre><code>import importlib
spam_spec = importlib.util.find_spec("spam")
found = spam_spec is not None
</code></pre>
<p>This also works with relative imports but you must supply the starting
package, so you could also do:</p>
<pre><code>import importlib
spam_spec = importlib.util.find_spec("..spam", package="eggs.bar")
found = spam_spec is not None
spam_spec.name == "eggs.spam"
</code></pre>
<p>While I'm sure there exists a reason for doing this - I'm not sure what it would be.</p>
<h3>WARNING</h3>
<p>When trying to find a submodule, it will import the parent module (for <em>all</em> of the above methods)!</p>
<pre><code>food/
  |- __init__.py
  |- eggs.py

## __init__.py
print("module food loaded")

## eggs.py
print("module eggs")

were you then to run
&gt;&gt;&gt; import importlib
&gt;&gt;&gt; spam_spec = importlib.find_spec("food.eggs")
module food loaded
ModuleSpec(name='food.eggs', loader=&lt;_frozen_importlib.SourceFileLoader object at 0x10221df28&gt;, origin='/home/user/food/eggs.py')
</code></pre>
<p><em>comments welcome on getting around this</em></p>
<h2>Acknowledgements</h2>
<ul>
<li>@rvighne for importlib</li>
<li>@lucas-guido for python3.3+ depricating <code>find_loader</code></li>
<li>@enpenax for pkgutils.find_loader behaviour in python2.7</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>After use yarbelk's response, I've made this for don't have to import <code>ìmp</code>.</p>
<pre><code>try:
    __import__('imp').find_module('eggs')
    # Make things with supposed existing module
except ImportError:
    pass
</code></pre>
<p>Useful in Django's <code>settings.py</code>for example.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Python 2, without relying ImportError</h1>
<p>Until the current answer is updated, here is the way for <strong>Python 2</strong></p>
<pre><code>import pkgutil
import importlib

if pkgutil.find_loader(mod) is not None:
    return importlib.import_module(mod)
return None
</code></pre>
<h3>Why another answer?</h3>
<p>A lot of answers make use of catching an <code>ImportError</code>. The problem with that is, that we cannot know what throws the <code>ImportError</code>.</p>
<p>If you import your <em>existant</em> module and there happens to be an <code>ImportError</code> in your module (e.g. typo on line 1), the result will be that your module does not exist. It will take you quite the amount of backtracking to figure out that your module exists and the <code>ImportError</code> is caught and makes things fail silently.</p>
</div>
<div class="post-text" itemprop="text">
<p>go_as's answer as a one liner</p>
<pre><code> python -c "help('modules');" | grep module
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I came across this question while searching for a way to check if a module is loaded from the <strong>command line</strong>  and would like to share my thoughts for the ones coming after me and looking for the same:  </p>
<p><strong>Linux/UNIX script file method</strong>: make a file <code>module_help.py</code>:  </p>
<pre><code>#!/usr/bin/env python

help('modules')
</code></pre>
<p>Then make sure it's executable: <code>chmod u+x module_help.py</code> </p>
<p>And call it with a <code>pipe</code> to <code>grep</code>:</p>
<pre><code>./module_help.py | grep module_name
</code></pre>
<blockquote>
<p>Invoke the built-in <a href="https://docs.python.org/2/library/functions.html#help" rel="noreferrer">help system</a>. (This function is <strong>intended for interactive use</strong>.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a <strong>string</strong>, then the string is looked up as the name of a <strong>module</strong>, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated.</p>
</blockquote>
<p><strong>Interactive method</strong>: in the console load <code>python</code> </p>
<pre><code>&gt;&gt;&gt; help('module_name')
</code></pre>
<p>If found quit reading by typing <code>q</code><br/>
To exit the python interactive session press <kbd>Ctrl</kbd> + <kbd>D</kbd> </p>
<p><strong>Windows script file method</strong> also Linux/UNIX compatible, <em>and better overall</em>:  </p>
<pre><code>#!/usr/bin/env python

import sys

help(sys.argv[1])
</code></pre>
<p>Calling it from the command like:  </p>
<pre><code>python module_help.py site  
</code></pre>
<p>Would output:  </p>
<blockquote>
<p>Help on module site:  </p>
<p><code>NAME</code>
     site - Append module search paths for third-party packages to sys.path.</p>
<p><code>FILE</code>
     /usr/lib/python2.7/site.py</p>
<p><code>MODULE DOCS</code>
<a href="http://docs.python.org/library/site" rel="noreferrer">http://docs.python.org/library/site</a></p>
<p><code>DESCRIPTION</code><br/>
  ...<br/>
  :</p>
</blockquote>
<p>and you'd have to press <code>q</code> to exit interactive mode.  </p>
<p>Using it unknown module:  </p>
<pre><code>python module_help.py lkajshdflkahsodf
</code></pre>
<p>Would output:  </p>
<blockquote>
<p>no Python documentation found for 'lkajshdflkahsodf'</p>
</blockquote>
<p>and exit.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use one of the <a href="https://docs.python.org/2/library/pkgutil.html#pkgutil.iter_modules" rel="nofollow">functions from pkgutil</a>, for example:</p>
<pre><code>from pkgutil import iter_modules

def module_exists(module_name):
    return module_name in (name for loader, name, ispkg in iter_modules())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could just write a little script that would try to import all the modules and tell you which ones are failing and which ones are working:</p>
<pre><code>import pip


if __name__ == '__main__':
    for package in pip.get_installed_distributions():
        pack_string = str(package).split(" ")[0]
        try:
            if __import__(pack_string.lower()):
                print(pack_string + " loaded successfully")
        except Exception as e:
            print(pack_string + " failed with error code: {}".format(e))
</code></pre>
<p>Output:</p>
<pre><code>zope.interface loaded successfully
zope.deprecation loaded successfully
yarg loaded successfully
xlrd loaded successfully
WMI loaded successfully
Werkzeug loaded successfully
WebOb loaded successfully
virtualenv loaded successfully
...
</code></pre>
<p>Word of warning this will try to import <em>everything</em> so you'll see things like <code>PyYAML failed with error code: No module named pyyaml</code> because the actual import name is just yaml. So as long as you know your imports this should do the trick for you.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Python 3 &gt;= 3.6: ModuleNotFoundError</h1>
<p>The <a href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError" rel="nofollow noreferrer"><code>ModuleNotFoundError</code></a> has been introduced in <strong>python 3.6</strong> and can be used for this purpose</p>
<pre><code>try:
    import eggs
except ModuleNotFoundError:
    # Error handling
    pass
</code></pre>
<p>The error is raised when a <strong>module or one of its parents</strong> cannot be found. So</p>
<pre><code>try:
    import eggs.sub
except ModuleNotFoundError as err:
    # Error handling
    print(err)
</code></pre>
<p>would print a message that looks like <code>No module named 'eggs'</code> if the <code>eggs</code> module cannot be found; but would print something like <code>No module named 'eggs.sub'</code> if only the <code>sub</code> module couldn't be found but the <code>eggs</code> package could be found.</p>
<p>See the <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">documentation of the import system</a> for more info on the <code>ModuleNotFoundError</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use <code>importlib</code> directly </p>
<pre><code>import importlib

try:
    importlib.import_module(module_name)
except ImportError:
    # Handle error
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simpler if statement from AskUbuntu: <a href="https://askubuntu.com/questions/588390/how-do-i-check-whether-a-module-is-installed-in-python-and-install-it-if-needed">How do I check whether a module is installed in Python?</a></p>
<pre><code>import sys
print('eggs' in sys.modules)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in django.utils.module_loading.module_has_submodule</p>
<pre><code>
import sys
import os
import imp

def module_has_submodule(package, module_name):
    """
    check module in package
    django.utils.module_loading.module_has_submodule
    """
    name = ".".join([package.__name__, module_name])
    try:
        # None indicates a cached miss; see mark_miss() in Python/import.c.
        return sys.modules[name] is not None
    except KeyError:
        pass
    try:
        package_path = package.__path__   # No __path__, then not a package.
    except AttributeError:
        # Since the remainder of this function assumes that we're dealing with
        # a package (module with a __path__), so if it's not, then bail here.
        return False
    for finder in sys.meta_path:
        if finder.find_module(name, package_path):
            return True
    for entry in package_path:
        try:
            # Try the cached finder.
            finder = sys.path_importer_cache[entry]
            if finder is None:
                # Implicit import machinery should be used.
                try:
                    file_, _, _ = imp.find_module(module_name, [entry])
                    if file_:
                        file_.close()
                    return True
                except ImportError:
                    continue
            # Else see if the finder knows of a loader.
            elif finder.find_module(name):
                return True
            else:
                continue
        except KeyError:
            # No cached finder, so try and make one.
            for hook in sys.path_hooks:
                try:
                    finder = hook(entry)
                    # XXX Could cache in sys.path_importer_cache
                    if finder.find_module(name):
                        return True
                    else:
                        # Once a finder is found, stop the search.
                        break
                except ImportError:
                    # Continue the search for a finder.
                    continue
            else:
                # No finder found.
                # Try the implicit import machinery if searching a directory.
                if os.path.isdir(entry):
                    try:
                        file_, _, _ = imp.find_module(module_name, [entry])
                        if file_:
                            file_.close()
                        return True
                    except ImportError:
                        pass
                # XXX Could insert None or NullImporter
    else:
        # Exhausted the search, so the module cannot be found.
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no way to reliably check if "dotted module" is importable without importing its parent package. Saying this, there are many solutions to problem "how to check if Python module exists".</p>
<p>Below solution address the problem that imported module can raise ImportError even it exists. We want to distinguish that situation from such in which module does not exist.</p>
<p><strong>Python 2</strong>:</p>
<pre class="lang-python prettyprint-override"><code>import importlib
import pkgutil
import sys

def find_module(full_module_name):
    """
    Returns module object if module `full_module_name` can be imported. 

    Returns None if module does not exist. 

    Exception is raised if (existing) module raises exception during its import.
    """
    module = sys.modules.get(full_module_name)
    if module is None:
        module_path_tail = full_module_name.split('.')
        module_path_head = []
        loader = True
        while module_path_tail and loader:
            module_path_head.append(module_path_tail.pop(0))
            module_name = ".".join(module_path_head)
            loader = bool(pkgutil.find_loader(module_name))
            if not loader:
                # Double check if module realy does not exist
                # (case: full_module_name == 'paste.deploy')
                try:
                    importlib.import_module(module_name)
                except ImportError:
                    pass
                else:
                    loader = True
        if loader:
            module = importlib.import_module(full_module_name)
    return module
</code></pre>
<p><strong>Python 3</strong>:</p>
<pre class="lang-python prettyprint-override"><code>import importlib

def find_module(full_module_name):
    """
    Returns module object if module `full_module_name` can be imported. 

    Returns None if module does not exist. 

    Exception is raised if (existing) module raises exception during its import.
    """
    try:
        return importlib.import_module(full_module_name)
    except ImportError as exc:
        if not (full_module_name + '.').startswith(exc.name + '.'):
            raise
</code></pre>
</div>
<span class="comment-copy">I'm curious, what are the downsides to using import?</span>
<span class="comment-copy">If your module has side effects, calling import might have unwanted consequences.  So, if you wanted to check which version of a file to run first, you can do check with the below answer, and do the import later.  I'm not suggesting it is a good idea to write modules with side effects - but we are all adults and can make our own decisions around how dangerously we want to code.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/5847934/how-to-check-if-python-module-exists-and-can-be-imported">How to check if python module exists and can be imported</a></span>
<span class="comment-copy">@ArtOfWarfare I just closed <i>that</i> question you linked as a duplicate of <i>this</i> one. Because this question is clearer and also the solution proposed here is better than all other listed there. I'd rather point whoever wants an answer to this better solution than pointing people away from it.</span>
<span class="comment-copy">@Chuck Additionally the module may exist, but may itself contain import errors. Catching ImportErrors as in the code above could lead to indicating the module does not exist, when if fact it does but has errors.</span>
<span class="comment-copy">This only works for top-level modules, not for <code>eggs.ham.spam</code>.</span>
<span class="comment-copy">@hemflit if you want to find <code>spam</code> in <code>eggs.ham</code> you would use <code>imp.find_module('spam', ['eggs', 'ham'])</code></span>
<span class="comment-copy">+1, but <code>imp</code> is <a href="https://docs.python.org/3/library/imp.html" rel="nofollow noreferrer">deprecated</a> in favor of <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>importlib</code></a> in Python 3.</span>
<span class="comment-copy">What if the imported module contains an actual "ImportError". That's what was happening to me. Then the module exists but will not be "found".</span>
<span class="comment-copy">After a year I came across the same problem I mentioned just above and was digging for a solution for Python 2: <code>pkgutil.find_loader("my.package.module")</code> returns a loader if the package/module exists and <code>None</code> if not. Please update your answer for Python 2, as masking the ImportError drove me crazy yesterday xP</span>
<span class="comment-copy">I downvoted, because this masks import errors in the module, which makes it really hard to spot the error.</span>
<span class="comment-copy">Downvote is a bad idea, a good pratice is "always log catched errors". This is an example after you write how you want it.</span>
<span class="comment-copy">How would you log an error if the imported module fails on line 1 with an ImportError and your try catch makes it fail silently?</span>
<span class="comment-copy">I've just run into the masking-import-errors issue in real life, and it was bad (causing tests which should have been failing to pass!).</span>
<span class="comment-copy">It might have been unclear, but all but the first code blocks do not rely on <code>ImportError</code>- please edit if it was unclear to you.</span>
<span class="comment-copy">I see you using the ImportError catch in the first two Python 2 examples. Why are they there, then?</span>
<span class="comment-copy">This throws ImportError if mod == 'not_existing_package.mymodule'. See my full <a href="http://stackoverflow.com/a/35037157/1763149">solution below</a></span>
<span class="comment-copy">Of course it throws an import error. It is supposed to throw an import error if a module does not exist. That way you can catch it if  you need to. The problem with the other solutions is that they mask other errors.</span>
<span class="comment-copy">Try/except doesn't mean you mustn't not log or ensure things. You can fully catch any underlying traceback and do anything you want with.</span>
<span class="comment-copy">This only tests whether it's installed, not whether it's installable.</span>
