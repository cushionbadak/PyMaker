<div class="post-text" itemprop="text">
<pre><code>def decorator(fn):
    def wrapper(*args, **kwargs):
        print 'With sour cream and chives!',
        return fn(*args, **kwargs)
    return wrapper

class Potato(object):
    def __call__(self):
        print 'Potato @ {} called'.format(id(self))

spud = Potato()
fancy_spud = decorator(Potato())
</code></pre>
<p>With this code we have two instances of callable class, one is decorated and one is plain:</p>
<pre><code>&gt;&gt;&gt; spud()
Potato @ 140408136280592 called
&gt;&gt;&gt; fancy_spud()
With sour cream and chives! Potato @ 140408134310864 called
</code></pre>
<p>I wonder if it is somehow supported to use the <code>@decorator</code> syntax on a callable for just one instance - as opposed to decorating the class / method, which would apply to every instance.  According to <a href="https://stackoverflow.com/a/1594484/674039">this</a> popular answer, the @syntax is just sugar for:</p>
<pre><code>function = decorator(function)
</code></pre>
<p>But is it an over-simplification?  With all my half-baked attempts it seems only to work when the syntax occurs before <code>def</code>, <code>class</code>, whitespace or <code>@another_decorator</code>.</p>
<pre><code>@decorator
baked = Potato()
</code></pre>
<p>That's a <code>SyntaxError</code>. </p>
<pre><code>baked = Potato()
@decorator
baked
</code></pre>
<p>Also <code>SyntaxError</code>. </p>
<pre><code>@decorator
def baked(_spud=Potato()):
    return _spud()
</code></pre>
<p>Works, but is ugly and kinda cheating.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You question states:</p>
<blockquote>
<p>According to this popular answer, the @syntax is just sugar for:</p>
<p><code>function = decorator(function)</code></p>
</blockquote>
<p>However, it's more accurate to say that</p>
<pre><code>@decorator
def function():
    pass
</code></pre>
<p>Is syntactic sugar for:</p>
<pre><code>def function():
    pass
function = decorator(function)
</code></pre>
<p>Decorators are designed to decorate function, method or class <em>definitions</em>, specifically. The <a href="http://legacy.python.org/dev/peps/pep-3129/#id12" rel="nofollow">PEP that introduced class decorators</a> describes the grammar:</p>
<pre><code>decorated: decorators (classdef | funcdef)

funcdef: 'def' NAME parameters ['-&gt;' test] ':' suite
</code></pre>
<p>As you can see, a decorator must come immediately before a <code>classdef</code> or <code>funcdef</code>, so there is no way to use it directly on an instance of a callable class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's an oversimplification.  If we look at <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">the grammar</a>, <code>decorator</code> only appears in the rule <code>decorators</code>, which only appears as part of a <code>classdef</code> or <code>funcdef</code>:</p>
<pre><code>decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
decorators: decorator+
decorated: decorators (classdef | funcdef)
</code></pre>
<p>What the <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow">language reference says</a> (and I think this is what's being repeated in the linked answer) is that</p>
<pre><code>@f1(arg)
@f2
def func(): pass
</code></pre>
<p>is equivalent to</p>
<pre><code>def func(): pass
func = f1(arg)(f2(func))
</code></pre>
<p>and similarly for class definitions.  But that doesn't mean that the <code>@decorator</code> syntax can be applied just anywhere; it's only valid immediately before a function or class definition.</p>
<p>As an aside, even the official docs aren't strictly correct; at the time the decorator is called the function (or class) isn't bound into the enclosing namespace or scope, so the given syntaxes are not entirely equivalent.</p>
<p>There's something interesting about the <code>def</code> and <code>class</code> statements, which I think is part of the reason that they're the only statements supported by <code>@decorator</code> syntax: they're the only way in Python to bind a name to an object that <em>knows what that name is</em>.</p>
<p>Finally, here's another way to invoke a decorator that you might like:</p>
<pre><code>@decorator
class baked:
    __metaclass__ = lambda *_: Potato()
</code></pre>
</div>
