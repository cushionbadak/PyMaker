<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/443967/how-to-create-python-bytes-object-from-long-hex-string">How to create python bytes object from long hex string?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>I have a list of bytes that are represented in string format, for example, when I print the list in Python3.3 I get the following output:</p>
<pre><code>DATA =  ['FF', 'FF', 'FF', 'FF']
</code></pre>
<p>I would like to convert these into bytes, for example 0xFF,0xFF,0xFF,0xFF. I have tried the bytearray() function but this returns an error.</p>
<p>I'm guessing that I am missing something simple here, but I have looked around SO and Google and have so far had no luck</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/binascii.html#binascii.unhexlify" rel="nofollow"><code>binascii.unhexlify()</code></a> on the joined 'bytes':</p>
<pre><code>import binascii

bytestring = binascii.unhexlify(''.join(DATA))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import binascii
&gt;&gt;&gt; DATA =  ['FF', 'FF', 'FF', 'FF']
&gt;&gt;&gt; binascii.unhexlify(''.join(DATA))
b'\xff\xff\xff\xff'
</code></pre>
<p>Note that this is <em>way faster</em> than using manual conversion to integers:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("bytes(int(x, 16) for x in DATA)", 'from __main__ import DATA')
1.7035537050105631
&gt;&gt;&gt; timeit.timeit("unhexlify(''.join(DATA))", 'from __main__ import DATA; from binascii import unhexlify')
0.2515432750224136
</code></pre>
<p>That's a 7x speed difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <a href="https://docs.python.org/3/library/functions.html#bytes" rel="nofollow"><code>bytes</code></a> function accepts an iterable, you can pass there a generator</p>
<pre><code>&gt;&gt;&gt; bytes(int(x, 16) for x in DATA)
b'\xff\xff\xff\xff'
</code></pre>
<p>That's slower than Martijn's approach, but shorter. </p>
<p><strong>Update</strong>:
Alternatively, you can use <a href="https://docs.python.org/3/library/stdtypes.html#bytes.fromhex" rel="nofollow"><code>bytes.fromhex</code></a> method</p>
<pre><code>&gt;&gt;&gt; bytes.fromhex(''.join(DATA))
b'\xff\xff\xff\xff'
</code></pre>
<p>It appears to be <strong>faster</strong> than Martijn's solution</p>
<pre><code>In [24]: %timeit bytes(int(x, 16) for x in DATA)
100000 loops, best of 3: 2.84 Âµs per loop

In [25]: %timeit bytes.fromhex(''.join(DATA))
1000000 loops, best of 3: 377 ns per loop

In [26]: %timeit binascii.unhexlify(''.join(DATA))
1000000 loops, best of 3: 403 ns per loop
</code></pre>
</div>
<span class="comment-copy">This is a really slow option though.</span>
<span class="comment-copy">@MartijnPieters 7x speed difference confirmed. But I still don't understand why should this answer be downvoted.</span>
<span class="comment-copy">No idea, I didn't vote on your post. It is correct enough, it is helpful enough, so the downvoter might want to explain themselves.</span>
<span class="comment-copy">@MartijnPieters updated, take a look.</span>
