<div class="post-text" itemprop="text">
<p>Consider a function <code>f(*x)</code> which takes a lot of arguments <code>*x</code>. Based on these arguments (objects), the function <code>f</code> composes a rather complex object <code>o</code> and returns it. <code>o</code> implements <code>__call__</code>, so <code>o</code> itself serves as a function. Since the composition of <code>o</code> is pretty time consuming and in my scenario there is no point in having multiple instances of <code>o</code> based on the same arguments <code>*x</code>, they are to be cached.</p>
<p>The question is now: How to efficiently compute a hash based on multiple arguments <code>*x</code>? Currently I am using a python dictionary, and i concatenate the <code>str()</code> representations of each <code>x</code> to build each key. It works in my scenario, but it feels rather awkward. I need to call the resulting objects <code>o</code> in a very high frequency, so I suspect the repeated call of <code>str()</code> and the string concatenations waste a lot of computation time.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash</code></a> built-in function, combining the hashes of the items in <code>x</code> together. The typical way to do this (see e.g. <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the documentation</a>) would be an <code>xor</code> across all the hashes of the individual objects:</p>
<blockquote>
<p>it is advised to somehow mix together (e.g. using exclusive or) the hash values for the components of the object that also play a part in comparison of objects</p>
</blockquote>
<p>To implement that in a functional way, using <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a> and <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a>:</p>
<pre><code>from functools import reduce # only required in Python 3.x
from operator import xor

def hashed(*x):
    return reduce(xor, map(hash, x))
</code></pre>
<p>See also <a href="https://stackoverflow.com/q/2909106/3001761">this question</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since version 3.2, Python already contains an implementation of an LRU cache that you can use
to cache your functions' results based on their arguments: 
<a href="https://docs.python.org/dev/library/functools.html#functools.lru_cache" rel="nofollow"><code>functools.lru_cache</code></a></p>
<p>Example:</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=32)
def f(*args):
    """Expensive function
    """
    print("f(%s) has been called." % (args, ))
    return sum(args)


print(f(1, 2, 3))
print(f(1, 2, 3, 4))
print(f(1, 2, 3))
print(f.cache_info())
</code></pre>
<p>Output:</p>
<pre><code>f((1, 2, 3)) has been called.
6
f((1, 2, 3, 4)) has been called.
10
6
CacheInfo(hits=1, misses=2, maxsize=32, currsize=2)
</code></pre>
<p><em>(Notice how <code>f(1, 2, 3)</code> only got called once)</em></p>
<p>As suggested in the comments, it's probably best to simply use  the <a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow"><code>hash()</code></a>es of your arguments to build the cache-key for your arguments - that's what <code>lru_cache</code> already does for you.</p>
<p>If you're still on Python 2.7, Raymond Hettinger has posted some <a href="http://code.activestate.com/recipes/498245/" rel="nofollow">recipes with LRU caches</a> that you could use in your own code.</p>
</div>
<span class="comment-copy">What are the types of the arguments in <code>*x</code>?</span>
<span class="comment-copy">In my case, the arguments have a variety of types. I usually have tuples of integers, some floats and at least one str() representation of a context object coming from another library.</span>
<span class="comment-copy">Then I would recommend simply calling <a href="https://docs.python.org/2/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code></a> on the individual arguments in order to use the same hash Python uses internally to compare dictionary keys for example.</span>
