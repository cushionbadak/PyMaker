<div class="post-text" itemprop="text">
<p>Let's say I have the following script, <code>test.py</code>:</p>
<pre><code>import my_library

bar = 12

def foo():
    nested_bar = 21

    my_library.do_things()

    def nested_foo():
        nested_bar += 11
        not_a_variable += 1
            {$ invalid_syntax

bar = 13
foo()
bar = 14
</code></pre>
<p>I'm curious as to what exactly happens when I run <code>python test.py</code>. Obviously Python doesn't just read programs line-by-line - otherwise it wouldn't catch syntax errors before actually executing the program. But this makes the workings of the interpreter seem somewhat nebulous. I was wondering if someone would help clear things up for me. In particular, I would like to know:</p>
<ol>
<li><p>At what point does Python realize there is a syntax error on line 13?</p></li>
<li><p>At what point does Python read the nested functions and add them to the scope of <code>foo</code>?</p></li>
<li><p>Similarly, how does Python add the function <code>foo</code> to its namespace when it encounters it, without executing it?</p></li>
<li><p>Suppose <code>my_library</code> were an invalid import. Would Python necessarily raise an <code>ImportError</code> before executing any other commands?</p></li>
<li><p>Suppose <code>my_library</code> were a valid module, but it has no function <code>do_things</code>. At what point would Python realize this, during execution of <code>foo()</code> or before?</p></li>
</ol>
<p>If anyone could point me to documentation on how Python parses and executes scripts it would be very much appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>There's some information in the tutorial's section on <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow">modules</a>, but I don't think the documentation has a complete reference for this.  So, here's what happens.</p>
<p>When you first run a script <em>or</em> import a module, Python parses the syntax into an AST and then compiles that into bytecode.  It hasn't executed anything yet; it's just compiled your code into instructions for a little stack-based machine.  This is where syntax errors are caught.  (You can see the guts of all this in the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow"><code>ast</code></a> module, the <code>token</code> module, the <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow"><code>compile</code></a> builtin, the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">grammar reference</a>, and sprinkled around various other places.)</p>
<p>You can actually compile a module independently of running the generated code; that's what the builtin <a href="https://docs.python.org/3/library/compileall.html" rel="nofollow"><code>compileall</code></a> method does.</p>
<p>So that's the first phase: compiling.  Python only has one other phase, which is actually running the code.  Every statement in your module, <em>except those contained within <code>def</code> or <code>lambda</code></em>, is executed in order.  That means that <code>import</code>s happen at runtime, wherever you happen to put them in your module.  Which is part of the reason it's good hygiene to put them all at the top.  Same for <code>def</code> and <code>class</code>: these are just statements that create a specific type of object, and they're executed as they're encountered, like anything else.</p>
<p>The only tricky bit here is that the phases can happen more than once — for example, an <code>import</code> is only executed at runtime, but if you've never imported that module before, then it has to be compiled, and now you're back in compile time.  But "outside" the import it's still runtime, which is why you can catch a <code>SyntaxError</code> thrown by an <code>import</code>.</p>
<p>Anyway, to answer your specific questions:</p>
<ol>
<li><p>At compile time.  When you run this as a script, or when you import it as a module, or when you compile it with <code>compileall</code>, or otherwise ask Python to make any sense of it.  In practical terms, this can happen at any time: if you tried to import this module within a function, you'd only get a <code>SyntaxError</code> when calling that function, which might be halfway through your program.</p></li>
<li><p>During the execution of <code>foo</code>, because <code>def</code> and <code>class</code> just create a new object and assign it to a name.  But Python still knows <em>how</em> to create the nested function, because it's already compiled all the code within it.</p></li>
<li><p>The same way it would add <code>foo = lambda: 1 + 2</code> to a namespace without executing it.  A function is just an object that contains a "code" attribute — literally just a block of Python bytecode.  You can manipulate the <code>code</code> type as data, because it <em>is</em> data, independently of executing it.  Try looking at a function's <code>.__code__</code>, read the "code objects" section of <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">the data model</a>, or even play around with the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow">disassembler</a>.  (You can even execute a code object directly with custom locals and globals using <code>exec</code>, or change the code object a function uses!)</p></li>
<li><p>Yes, because <code>import</code> is a plain old statement like any other, executed in order.  But if there were other code <em>before</em> the <code>import</code>, that would run first.  And if it were in a function, you wouldn't get an error until that function ran.  Note that <code>import</code>, just like <code>def</code> and <code>class</code>, is just a fancy form of assignment.</p></li>
<li><p>Only during the execution of <code>foo()</code>.  Python has no way of knowing whether other code will add a <code>do_things</code> to your module before that point, or even change <code>my_library</code> to some other object entirely.  Attribute lookups are always done just-in-time, when you ask for them, never in advance.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>As a general rule, python first parses the file, compiles the abstract syntax tree to byte code, then attempt to execute it sequentially. That means all statements are executed line by line. Thus, this means:</p>
<ol>
<li>Syntax errors are caught at parse time, before anything is executed. If you add some side effect to the script, e.g. create a file, you will see that it never gets executed.</li>
<li>A function becomes defined in the scope after the definition. If you try to call <code>nested_foo</code> right before <code>def nested_foo()</code> you will see that it would fail because <code>nested_foo</code> has not been defined at that point.</li>
<li>Same as 2.</li>
<li>If python cannot import a library, where import means it tries to execute the module, then it fails with an <code>ImportError</code>.</li>
<li>Since you don't try to access <code>do_things</code> at import time (i.e. you are not doing <code>from my_library import do_things</code>), an error only occurs when you attempt to call <code>foo()</code>.</li>
</ol>
</div>
<span class="comment-copy">1. never, because there's a syntax error on line 5  :)</span>
<span class="comment-copy">Haha that's what I get for not reading through my program carefully enough. Fixed</span>
<span class="comment-copy">I don't think this question is too broad at all - Eevee's answer fully covered it. I just wanted to know the steps the interpreter takes during parsing / execution.</span>
