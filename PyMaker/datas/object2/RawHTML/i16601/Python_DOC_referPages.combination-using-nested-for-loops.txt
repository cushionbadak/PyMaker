<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/4928297/all-permutations-of-a-binary-sequence-x-bits-long">all permutations of a binary sequence x bits long</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/464864/how-to-get-all-possible-combinations-of-a-list-s-elements">How to get all possible combinations of a list’s elements?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>A simplified version of my question is: 
I wrote this code:</p>
<pre><code>string = ['A','A','A','A']
temp=string[:]

f=open('combin.txt', 'a')

for x1 in range(0,2):
    if x1==1:
        temp[0]='X'
    for x2 in range(0,2):
        if x2==1:
            temp[1]='X'
        for x3 in range(0,2):
            if x3==1:
                temp[2]='X'
            for x4 in range(0,2):
                if x4==0:
                    f.write(''.join(temp)+'\n')
                if x4==1:
                    temp[3]='X'
                    f.write(''.join(temp)+'\n')
</code></pre>
<p>And the result is:</p>
<pre><code>AAAA
AAAX
AAXX
AAXX
AXXX
AXXX
AXXX
AXXX
XXXX
XXXX
XXXX
XXXX
XXXX
XXXX
XXXX
XXXX
</code></pre>
<p>But what I expect is the combinations:
AAAA
AAAX
AAXA
AXAA
XAAA
AAXX
AXAX
XAAX
XXAA
XAXA
AXXA
AXXX
XAXX
XXAX
XXXA
XXXX</p>
<p>Notice that in the final program I shall need to do a lot of operations under each if condition, so it will not be a simple string character iteration, but first I want to get this combination part working. Thank you very much for your help.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really need all the <code>for</code> loops in your actual program, you could fix it like this:</p>
<pre><code>for x1 in range(0,2):
    if x1==0:
        temp[0]='A'
    if x1==1:
        temp[0]='X'
    for x2 in range(0,2):
        if x2==0:
            temp[1]='A'
        if x2==1:
            temp[1]='X'
        for x3 in range(0,2):
            if x3==0:
                temp[2]='A'
            if x3==1:
                temp[2]='X'
            for x4 in range(0,2):
                if x4==0:
                    temp[3]='A'
                if x4==1:
                    temp[3]='X'
                print(''.join(temp))
</code></pre>
<p>It gives the following output:</p>
<pre><code>AAAA
AAAX
AAXA
AAXX
AXAA
AXAX
AXXA
AXXX
XAAA
XAAX
XAXA
XAXX
XXAA
XXAX
XXXA
XXXX
</code></pre>
<p>Notice that the last letter changes the fastest, because it's set by the most inner <code>for</code> loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the built-in library itertools, which has the 'combinations' function, or you could recognize that you're essentially expressing binary numbers:</p>
<pre><code>for s in [bin(n)[2:].zfill(4) for n in xrange(2 ** 4)]:
    print s.replace('0','A').replace('1','X')
</code></pre>
<p>The above code:</p>
<ol>
<li>Takes a range of numbers from zero (0b0000) to 2^4 - 1 (0b1111), </li>
<li>Converts each to its binary representation in a string (built-in bin function)</li>
<li>Chops off the leading '0b'</li>
<li>Makes sure the resulting string has enough leading zeros</li>
<li>Then in the for-loop body, converts the 1's and 0's to your format.</li>
</ol>
<p>The operations you do could be based on the number of the range, in which case you can move the string formatting into the body of the loop (of course it would help if you gave an idea of what kind of operations you'd be doing)</p>
<pre><code>for n in xrange(2 ** 4):
    if n &amp; 0b1000:    # If the first character is 'X'
        # operations here
    if n &amp; 0b0100:    # If the second character is 'X'
        # other operations
    # ... more checks/operations ...
    print bin(n)[2:].zfill(4).replace('0','A').replace('1','X')
</code></pre>
<p>Here's a not-so-intuitive way for displaying combinations:</p>
<pre><code>def gen(s):
    if len(s) == 4:
        print s
        return 
    gen(s+'A')
    gen(s+'X')
# which you would run with:
gen('')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that you set the items of <code>temp</code> to <code>X</code>, but never set them back to <code>A</code>. See <em>moarningsun</em>'s answer for a straight-forward way to fix this. You can, however, make this a whole lot shorter: Instead of looping over <code>range(0, 2)</code> and setting, e.g., <code>temp[0]</code> to either <code>X</code> or <code>A</code> depending on the value of <code>x1</code>, you can directly loop over the characters in the string <code>AX</code> and set <code>temp[0]</code> accordingly.</p>
<pre><code>for x1 in 'AX':
    temp[0] = x1
</code></pre>
<p>You can even make this into one big <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; [x1+x2+x3+x4 for x1 in 'AX' for x2 in 'AX' for x3 in 'AX' for x4 in 'AX']
['AAAA', 'AAAX', 'AAXA', 'AAXX', 'AXAA', 'AXAX', 'AXXA', 'AXXX', 
 'XAAA', 'XAAX', 'XAXA', 'XAXX', 'XXAA', 'XXAX', 'XXXA', 'XXXX']
</code></pre>
<p>The proper way to do it is, of course, to use the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> module. Note, however, that what you are looking for are actually <em>not</em> <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>combinations</code></a>, but a <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>product</code></a>.</p>
<pre><code>&gt;&gt;&gt; [''.join(comb) for comb in itertools.product('AX', repeat=4)]
['AAAA', 'AAAX', 'AAXA', 'AAXX', 'AXAA', 'AXAX', 'AXXA', 'AXXX', 
 'XAAA', 'XAAX', 'XAXA', 'XAXX', 'XXAA', 'XXAX', 'XXXA', 'XXXX']
</code></pre>
<p>You can thus create the 'combinations' in just one readable line of code and then iterate that list and do whatever you need to do in a much cleaner loop.</p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/464864/python-code-to-pick-out-all-possible-combinations-from-a-list" title="python code to pick out all possible combinations from a list">stackoverflow.com/questions/464864/…</a> ?</span>
<span class="comment-copy">It would be useful to provide some more context as it will most probably affect what kind of solution you're looking for</span>
<span class="comment-copy">@limelights I fail to see how the answers to that question apply to this one. Although it may be related, it seems like a different problem to me.</span>
<span class="comment-copy">I cannot use iteration. As I said this is a simplified version of my problem. In the real problem, I am not dealing with string but different groups of operations. Anyway, Moarningsun has provided the solution that I need.</span>
<span class="comment-copy">You could change all those <code>range(0,2)</code> calls to <code>range(2)</code> (or even <code>[0,1]</code>). Also there's no need to use two independent <code>if</code> statements; the two conditions are mutually exclusive so you should use <code>else</code>.</span>
<span class="comment-copy">Thanks @TomFenech, these are all good points. But in OP's actual code the ranges could be different and the conditions may not be mutually exclusive. The quadruple <code>for</code> loop is probably not the best solution anyway. I just wanted to show a simple, understandable fix for the example posted.</span>
<span class="comment-copy">Yes this is the solution I want. So Python is different from C? It cannot skip and do nothing but I need to define clearly the values for each if condition? Thank you very much anyway. Well done Moarningsun, you are the only one who really understand my question :-)</span>
<span class="comment-copy">@user3733302, not really. Have a look at the output. The second line is <code>AAAX</code> and the third is <code>AAXA</code>, so you also sometimes need to change an <code>X</code> back to an <code>A</code>. That's why you need the extra conditions.</span>
<span class="comment-copy">+1 for two interesting approaches. I'm still trying to get my head round the recursive one! Perhaps it would be useful to provide some explanation of how it works. You could set a default argument <code>def gen(s=''):</code> so it could be called simply like <code>gen()</code>.</span>
<span class="comment-copy">Good idea, edited to include how to actually run it... it should be noted that for either solution, you can produce a result of any amount of digits by replacing '4' with a variable (and in the recursive case, by passing that variable as an argument)</span>
