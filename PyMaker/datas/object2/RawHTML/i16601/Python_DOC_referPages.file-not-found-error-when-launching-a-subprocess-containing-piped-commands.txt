<div class="post-text" itemprop="text">
<p>I need to run the command  <code>date | grep -o -w '"+tz+"'' | wc -w</code> using Python on my localhost. I am using <code>subprocess</code> module for the same and using the <code>check_output</code> method as I need to capture the output for the same.</p>
<p>However it is throwing me an error :</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 47, in &lt;module&gt;
    check_timezone()
  File "test.py", line 40, in check_timezone
    count = subprocess.check_output(command)
  File "/usr/lib/python2.7/subprocess.py", line 537, in check_output
    process = Popen(stdout=PIPE, *popenargs, **kwargs)
  File "/usr/lib/python2.7/subprocess.py", line 679, in __init__
    errread, errwrite)
  File "/usr/lib/python2.7/subprocess.py", line 1249, in _execute_child
    raise child_exception-
OSError: [Errno 2] No such file or directory
</code></pre>
<p>Please help where am I going wrong. I'm new to python</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to add <code>shell=True</code> to execute a shell command. <code>check_output</code> is trying to find an executable called: <code>date | grep -o -w '"+tz+"'' | wc -w</code> and he cannot find it. (no idea why you removed the essential information from the error message).</p>
<p>See the difference between:</p>
<pre><code>&gt;&gt;&gt; subprocess.check_output('date | grep 1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.4/subprocess.py", line 603, in check_output
    with Popen(*popenargs, stdout=PIPE, **kwargs) as process:
  File "/usr/lib/python3.4/subprocess.py", line 848, in __init__
    restore_signals, start_new_session)
  File "/usr/lib/python3.4/subprocess.py", line 1446, in _execute_child
    raise child_exception_type(errno_num, err_msg)
FileNotFoundError: [Errno 2] No such file or directory: 'date | grep 1'
</code></pre>
<p>And: </p>
<pre><code>&gt;&gt;&gt; subprocess.check_output('date | grep 1', shell=True)
b'gio 19 giu 2014, 14.15.35, CEST\n'
</code></pre>
<p>Read the documentation about the <a href="https://docs.python.org/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">Frequently Used Arguments</a> for more information about the <code>shell</code> argument and how it changes the interpretation of the other arguments.</p>
<hr/>
<p>Note that you should try to avoid using <code>shell=True</code> since spawning a shell can be a security hazard (even if you do not execute untrusted input attacks like Shellshock can still be performed!). </p>
<p>The documentation for the subprocess module has a little section about <a href="https://docs.python.org/library/subprocess.html#replacing-shell-pipeline" rel="nofollow noreferrer">replacing the shell pipeline</a>.
You can do so by spawning the two processes in python and use <code>subprocess.PIPE</code>:</p>
<pre><code>date_proc = subprocess.Popen(['date'], stdout=subprocess.PIPE)
grep_proc = subprocess.check_output(['grep', '1'], stdin=date_proc.stdout, stdout=subprocess.PIPE)
date_proc.stdout.close()
output = grep_proc.communicate()[0]
</code></pre>
<p>You can write some simple wrapper function to easily define pipelines:</p>
<pre><code>import subprocess
from shlex import split
from collections import namedtuple
from functools import reduce

proc_output = namedtuple('proc_output', 'stdout stderr')


def pipeline(starter_command, *commands):
    if not commands:
        try:
            starter_command, *commands = starter_command.split('|')
        except AttributeError:
            pass
    starter_command = _parse(starter_command)
    starter = subprocess.Popen(starter_command, stdout=subprocess.PIPE)
    last_proc = reduce(_create_pipe, map(_parse, commands), starter)
    return proc_output(*last_proc.communicate())

def _create_pipe(previous, command):
    proc = subprocess.Popen(command, stdin=previous.stdout, stdout=subprocess.PIPE)
    previous.stdout.close()
    return proc

def _parse(cmd):
    try:
        return split(cmd)
    except Exception:
        return cmd
</code></pre>
<p>With this in place you can write <code>pipeline('date | grep 1')</code> or <code>pipeline('date', 'grep 1')</code> or <code>pipeline(['date'], ['grep', '1'])</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The most common cause of FileNotFound with subprocess, in my experience, is the use of spaces in your command. Use a list, instead.</p>
<pre><code># Wrong, even with a valid command string
subprocess.run(["date | grep -o -w '\"+tz+\"' | wc -w"])

# Fixed
subprocess.run(["date", "|", "grep", "-o", "-w", "'\"+tz+\"'", "|", "wc", "-w"])
</code></pre>
<p>This change results in no more FileNotFound errors, and is a nice solution if you got here searching for that exception with a simpler command. If you are using python 3.5 or greater, try using this approach:</p>
<pre><code>import subprocess

a = subprocess.run(["date"], stdout=subprocess.PIPE)
print(a.stdout.decode('utf-8'))

b = subprocess.run(["grep", "-o", "-w", "'\"+tz+\"'"],
                   input=a.stdout, stdout=subprocess.PIPE)
print(b.stdout.decode('utf-8'))    

c = subprocess.run(["wc", "-w"],
                   input=b.stdout, stdout=subprocess.PIPE)
print(c.stdout.decode('utf-8'))
</code></pre>
<p>You should see how one command's output becomes another's input just like using a shell pipe, but you can easily debug each step of the process in python. Using <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">subprocess.run</a> is recommended for python &gt; 3.5, but not available in prior versions.</p>
</div>
<span class="comment-copy">Can you post the line(s) which throws the error?</span>
<span class="comment-copy">@wnnmaw <code>subprocess.check_output(command) </code> where command is as mentioned in OP</span>
<span class="comment-copy">How are you setting the value of <code>command</code>? (It's not clear how all the single and double quotes in the OP line up.) What's the value of <code>tz</code>?</span>
<span class="comment-copy">Its a value im getting from optparser. ANyways the issue is resolved. Thanks</span>
<span class="comment-copy">Just FYI, certain implementations (possibly versions?) do not raise a "FileNotFoundError", but an "OS Error" with no helpful information, just as he pasted. So that is why he "removed the essential information"</span>
<span class="comment-copy">"Warning: Passing shell=True can be a security hazard if combined with untrusted input. See the warning under Frequently Used Arguments for details." - <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">docs.python.org/2/library/subprocess.html#popen-constructor</a></span>
<span class="comment-copy">@Jivan You are right. Updated the answer with that note and also a way to easily define pipelines without using <code>shell=True</code>.</span>
<span class="comment-copy">All of this can easily be done natively in Python. Spawning a shell to do something Python can trivially do is just wasteful, as well as somewhat more error prone (more corner cases and opaque behavior).</span>
<span class="comment-copy">@tripleee Did you carefully read the question and the answer?. The question is about a <code>FileNotFoundError</code>, my answer exaplain why that error happens, a simple way to fix this to do what the OP wants and also a way to do it without spawning shells.</span>
<span class="comment-copy">The "fixed" command is completely wrong, it will attempt to run <code>date</code> with the strings <code>"|"</code>, <code>"grep"</code> etc as parameters. The <code>a</code> | <code>b</code> | <code>c</code> pipeline is the way to go if you really cannot translate these commands into Python, but performing most or all of this in native Python code is trivial as well as more elegant and more efficient.</span>
