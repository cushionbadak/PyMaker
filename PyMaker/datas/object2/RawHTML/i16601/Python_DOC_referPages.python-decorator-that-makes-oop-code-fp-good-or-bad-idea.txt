<div class="post-text" itemprop="text">
<p>Recently I've been trying to figure out a solution to the 'expression problem' of choosing between implementing my code in OOP or FP (functional programming). The example I used to illustrate my problem was a Vector2D class. I could make a class that contains all the necessary functions for a 2D vector (dot product, magnitude, etc.), or I could make a set of functions that take a 2-tuple representing a vector. Which option do I chose?</p>
<p>To cope with this problem, I thought it might be nice to make a decorator that takes a class's methods and turns them into global functions. This is how I did it:</p>
<pre><code>import types

def function(method):
    method._function = True
    return method

def make_functions(cls):
    for key in cls.__dict__:
        method = getattr(cls, key)
        if not isinstance(method, types.FunctionType):
            continue
        if hasattr(method, '_function') and method._function:
            globals()[method.__name__] = method
    return cls

@make_functions
class Vector2D:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Vector(%g, %g)' % (self.x, self.y)

    def __iter__(self):
        for component in self.x, self.y:
            yield component

    def __getitem__(self, key):
        return (self.x, self.y)[key]

    def __setitem__(self, key, val):
        if key == 0:
            self.x = val
        elif key == 1:
            self.y = val
        else:
            print('not cool man')

    def __add__(self, other):
        x = self[0] + other[0]
        y = self[1] + other[1]
        return self.__class__(x, y)
    __radd__ = __add__

    def __sub__(self, other):
        x = self[0] - other[0]
        y = self[1] - other[1]
        return self.__class__(x, y)

    def __rsub__(self, other):
        x = other[0] - self[0]
        y = other[1] - self[1]
        return self.__class__(x, y)

    def __mul__(self, other):
        x = other * self[0]
        y = other * self[1]
        return self.__class__(x, y)
    __rmul__ = __mul__

    @function
    def dot_product(self, other):
        return self[0]*other[1] + self[1]*other[0]
</code></pre>
<p>Now, <code>dot_product</code> is not only a method of the <code>Vector2D</code> class, but it is also a global function that takes in two vectors (or vector-like objects). This satisfies both the functional and object-oriented approaches to implementing an object like this. The only problem I can foresee this approach making is that any class that can be represented as another object like a tuple or a list, must be defined to work in the same ways as the objects which act like it. This is not so bad for a Vector that can also be a tuple, since all we have to do is define the <code>__getitem__</code> and <code>__iter__</code> methods, however I can see this getting wildly out of control for classes that have multiple contrasting implementations</p>
<p>Is this a fair solution to the problem? Is it bad practice or technique? Should I solely provide one or the other?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow"><code>@staticmethod</code></a> decorator for using class methods without an instantiation of that class. Simply annotate a class method with the static method wrapper (note the method now does not take a self reference), and you can call it from the class itself.</p>
<p>In your case, for the dot product, simply do:</p>
<pre><code>class Vector2D():
    # Magic methods here...

    @staticmethod
    def dot_product(a, b):
        return a[0]*b[1] + a[1]*b[0]
</code></pre>
<p>Then, simply call <code>Vector2D.dot_product(my_vector1, my_vector2)</code> to use the function from the <code>Vector2D</code> class itself.</p>
<p>Assigning class methods to global functions sounds like a very dangerous, buggy, complex, and verbose solution. I would avoid it at all costs.</p>
</div>
<span class="comment-copy">This is a dubious use of the term <a href="http://en.wikipedia.org/wiki/Functional_programming" rel="nofollow noreferrer">Functional programming</a> :|</span>
<span class="comment-copy">@user2864740 My apologies. I'm not too familiar with the term and should have looked up a thorough definition before using it to describe my situation.</span>
<span class="comment-copy">@user2864740 For future reference what might be the proper term to describe this concept?</span>
<span class="comment-copy">Procedural (as in the sense of <a href="http://en.wikipedia.org/wiki/Procedural_programming" rel="nofollow noreferrer">Procedural programming</a>) <i>might</i> be a better "name", if any is to be given; but such is also a broad term.</span>
<span class="comment-copy">What problems in specific could you see arising with using class methods as global functions?</span>
<span class="comment-copy">@user3002473 It makes it impossible to know where the actual implementation is, even more so when you have functions with the same name in different classes. Why not use <code>Vector2D.dot_product(a, b)</code> instead?</span>
<span class="comment-copy">Oh I have nothing against using <code>Vector2D.dot_product(a, b)</code>, I was just curious. Thanks for elaborating :)</span>
