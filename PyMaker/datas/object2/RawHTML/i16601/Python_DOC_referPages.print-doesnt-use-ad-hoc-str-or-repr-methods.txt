<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10376604/overriding-special-methods-on-an-instance">Overriding special methods on an instance</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>I'm having a problem in Python 3.4 and would appreciate any help and/or explanation:</p>
<p>Basically I have a class with a function that should return an instance of another class, but with a modified string representation so that I can later print() that instance and see the Stuff added in that function.</p>
<p>What I don't understand is that even though I seem to be able to change the <strong>str</strong> and <strong>repr</strong> methods of that instance, print() will still use the original representation.</p>
<p>This is a boiled-down example that essentially shows what I tried:</p>
<pre><code>class A():
  def __str__(self):
    return('AAA')
class B():
  def output(self):
    return('BBB')
  def run(self):
    a = A()
    print("if str(a)({}) equals a.__str__()({})...".format(str(a), a.__str__()))
    a.__str__ = self.output
    a.__repr__ = self.output
    print("... why not now? (str(a) = {} while a.__str__() = {}".format(str(a), a.__str__()))
    return a
b = B()
a=b.run()
print("print a: {}, str(a): {}, a.__str__(): {}, a.__repr__():{}".format(a, str(a), a.__str__(), a.__repr__()))
</code></pre>
<p>Can someone please explain this to me?
Thanks for your time, guys!</p>
<p>Edit: forgot the output, sorry:</p>
<pre><code>[xxx@localhost ~]$ python test.py
if str(a)(AAA) equals a.__str__()(AAA)...
... why not now? (str(a) = AAA while a.__str__() = BBB
print a: AAA, str(a): AAA, a.__str__(): BBB, a.__repr__():BBB
</code></pre>
<p>Edit: Thanks Martijn Pieters for the explanation!</p>
<pre><code>I changed my code to :

class A():
  def __init__(self):
    self.str = 'AAA'

  def __str__(self):
    return(self.str)

class B():

  def run(self):
    a = A()
    a.str = 'BBB'
    print(a, str(a), a.__str__())
    return a

b = B()
a=b.run()

print("print a: {}, str(a): {}, a.__str__(): {}".format(a, str(a), a.__str__()))
</code></pre>
<p>And I now get the output I want:</p>
<pre><code>python test.py
BBB BBB BBB
print a: BBB, str(a): BBB, a.__str__(): BBB
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Special methods are always called on the <em>type</em>; for instances, that is the class. See the <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">Special method lookup</a>:</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
<p>This means that you cannot add <code>__str__</code> or <code>__repr__</code> methods to the <em>instance</em> and expect those to be used.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a.__class__.__str__ = self.output
a.__class__.__repr__ = self.output
</code></pre>
<p>But in Python2.7 your original code works correctly. Hmm.</p>
</div>
<span class="comment-copy">It'd be helpful if you included the output of running the code in your question.</span>
<span class="comment-copy">Uh, I didn't know that, thank you.</span>
