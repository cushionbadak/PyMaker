<div class="post-text" itemprop="text">
<p>Given:</p>
<pre><code>In [37]: class A:
   ....:     f = 1
   ....:

In [38]: class B(A):
   ....:     pass
   ....:

In [39]: getattr(B, 'f')
Out[39]: 1
</code></pre>
<p>Okay, that either calls super or crawls the mro?</p>
<pre><code>In [40]: getattr(A, 'f')
Out[40]: 1
</code></pre>
<p>This is expected.</p>
<pre><code>In [41]: object.__getattribute__(A, 'f')
Out[41]: 1

In [42]: object.__getattribute__(B, 'f')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-42-de76df798d1d&gt; in &lt;module&gt;()
----&gt; 1 object.__getattribute__(B, 'f')

AttributeError: 'type' object has no attribute 'f'
</code></pre>
<p>What is getattribute not doing that getattr does? </p>
<pre><code>In [43]: type.__getattribute__(B, 'f')
Out[43]: 1
</code></pre>
<p>What?!  <code>type.__getattribute__</code> calls super but <code>object</code>'s version doesn't?</p>
<pre><code>In [44]: type.__getattribute__(A, 'f')
Out[44]: 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are operating directly <em>on classes</em>. <code>object.__getattribute__</code> is only used <em>on instances</em> of <code>A</code> and <code>B</code> instead. That's because <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow">special methods are looked up on the type</a>; for instances the type is the class.</p>
<p>For classes then, the type is.. <code>type</code>:</p>
<pre><code>&gt;&gt;&gt; class A:
...     f = 1
... 
&gt;&gt;&gt; class B(A):
...     pass
... 
&gt;&gt;&gt; type(B)
&lt;class 'type'&gt;
</code></pre>
<p>so <code>type.__getattribute__</code> is used:</p>
<pre><code>&gt;&gt;&gt; type.__getattribute__(B, 'f')
1
</code></pre>
<p>and <code>object.__getattribute__</code> works fine on instances:</p>
<pre><code>&gt;&gt;&gt; object.__getattribute__(B(), 'f')
1
</code></pre>
<p>For instances attributes are looked up first on the class (in the case of <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow">data descriptors</a>), then on the instance, then if the instance doesn't have the attribute, the class hierarchy is searched in MRO order. This is the job of <code>object.__getattribute__</code>. So <code>object.__getattribute__</code> looks at the first argument (e.g. <code>self</code>, the instance object) for the attribute, <em>and</em> at objects in <code>type(self).__mro__</code>.</p>
<p>For classes, attributes are looked up on the class itself and all its bases; <code>type.__getattribute__</code> looks directly at <code>self.__mro__</code> for these; <code>self</code> being a class object here.</p>
<p>If you use <code>object.__getattribute__</code> for <em>classes</em> then, there is no <code>f</code> attribute on <code>B</code> <em>directly</em>, and no <code>f</code> anywhere in <code>type(B).__mro__</code>. If you use <code>type.__getattribute__</code>, <code>A</code> is a member of <code>B.__mro__</code> so <code>f</code> is found there:</p>
<pre><code>&gt;&gt;&gt; type(B).__mro__
(&lt;class 'type'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; B.__mro__
(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
</code></pre>
</div>
<span class="comment-copy">Is it python 2 or 3?</span>
<span class="comment-copy">@thecoder16: Python 3.</span>
<span class="comment-copy">Would you mind explaining why object.__getattribute__(A, 'f') works then? I'm a little confused.</span>
<span class="comment-copy">I'm sure you're right, but I'm still a bit lost.  What is <code>object.__getattribute__(B, 'f')</code> doing?  Is it necessarily bad code?  It might solve my other problem: <a href="http://stackoverflow.com/questions/24150636/class-properties-without-superclass-properties" title="class properties without superclass properties">stackoverflow.com/questions/24150636/â€¦</a></span>
<span class="comment-copy">@NeilG: <code>object.__getattribute__</code> is the <i>wrong method</i> for looking at attributes on a class hierachy. Use <code>type.__getattribute__</code> instead. Or better still, just use <code>type(B).__getattribute__</code> directly and get the right special method, always.</span>
<span class="comment-copy">So when accessing <code>X.attr</code>, <code>object.__getattribute__</code> searches <code>X.__dict__</code> -&gt; <code>type(X).__mro__.__dict__</code>, while <code>type.__getattribute__</code> searches <code>X.__dict__</code> -&gt; <code>X.__mro__.__dict__</code> -&gt; <code>type(X).__mro__.__dict__</code>. Am I right?</span>
<span class="comment-copy">@sunqingyao: yeah; <code>object.__getattribute__</code> is for instances, <code>type.__getattribute__</code> for classes, and the latter must look for attributes on the metaclass hierarchy too.</span>
