<div class="post-text" itemprop="text">
<p>I'm writing a code to analyze PDF file. I want to display the output on the console as well as to have a copy of the output in a file, I used this code save the output in a file:</p>
<pre><code>import sys
sys.stdout = open('C:\\users\\Suleiman JK\\Desktop\\file.txt',"w")
print "test"
</code></pre>
<p>but could I display the output into console as well but without using classes because I'm not good with them?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could make a function which prints both to console and to file. You can either do it by switching stdout, e.g. like this:</p>
<pre><code>def print_both(file, *args):
    temp = sys.stdout #assign console output to a variable
    print ' '.join([arg for arg in args]) 
    sys.stdout = file 
    print ' '.join([arg for arg in args])
    sys.stdout = temp #set stdout back to console output
</code></pre>
<p>or by using file write method (I suggest using this unless you have to use stdout)</p>
<pre><code>def print_both(file, *args):
    toprint = ' '.join([arg for arg in args])
    print toprint
    file.write(toprint)
</code></pre>
<p>Note that:</p>
<ol>
<li>The file argument passed to the function must be opened outside of the function (e.g. at the beginning of the program) and closed outside of the function (e.g. at the end of the program). You should open it in append mode.</li>
<li>Passing *args to the function allows you to pass arguments the same way you do to a print function. So you pass arguments to print...</li>
</ol>
<p>...like this:</p>
<pre><code>print_both(open_file_variable, 'pass arguments as if it is', 'print!', 1, '!')
</code></pre>
<p>Otherwise, you'd have to turn everything into a single argument i.e. a single string. It would look like this:</p>
<pre><code> print_both(open_file_variable, 'you should concatenate'+str(4334654)+'arguments together')
</code></pre>
<p>I still suggest you learn to use classes properly, you'd benefit from that very much. Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sys.stdout</code> can point to any object that has a write method, so you can create a class that writes to both a file and the console.</p>
<pre><code>import sys

class LoggingPrinter:
    def __init__(self, filename):
        self.out_file = open(filename, "w")
        self.old_stdout = sys.stdout
        #this object will take over `stdout`'s job
        sys.stdout = self
    #executed when the user does a `print`
    def write(self, text): 
        self.old_stdout.write(text)
        self.out_file.write(text)
    #executed when `with` block begins
    def __enter__(self): 
        return self
    #executed when `with` block ends
    def __exit__(self, type, value, traceback): 
        #we don't want to log anymore. Restore the original stdout object.
        sys.stdout = self.old_stdout

print "Entering section of program that will be logged."
with LoggingPrinter("result.txt"):
    print "I've got a lovely bunch of coconuts."
print "Exiting logged section of program."
</code></pre>
<p>Result:</p>
<p>Console:</p>
<pre><code>Entering section of program that will be logged.
I've got a lovely bunch of coconuts.
Exiting logged section of program.
</code></pre>
<p>result.txt:</p>
<pre><code>I've got a lovely bunch of coconuts.
</code></pre>
<p>This method may be preferable to codesparkle's in some circumstances, because you don't have to replace all your existing <code>print</code>s with <code>logging.info</code>. Just put everything you want logged into a <code>with</code> block.</p>
</div>
<div class="post-text" itemprop="text">
<p>(This answer uses Python 3 and you will have to adapt it if you prefer Python 2.)</p>
<p>Start by importing the Python <a href="https://docs.python.org/3/library/logging.html" rel="nofollow"><code>logging</code></a> package (and <code>sys</code> for accessing the standard output stream):</p>
<pre><code>import logging
import sys
</code></pre>
<p>In your entry point, <a href="https://docs.python.org/3/howto/logging.html#useful-handlers" rel="nofollow">set up a handler</a> for both the standard output stream and your output file:</p>
<pre><code>targets = logging.StreamHandler(sys.stdout), logging.FileHandler('test.log')
</code></pre>
<p>and <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow">configure the logging package</a> to output only the message without the log level:</p>
<pre><code>logging.basicConfig(format='%(message)s', level=logging.INFO, handlers=targets)
</code></pre>
<p>Now you can use it:</p>
<pre><code>&gt;&gt;&gt; logging.info('testing the logging system')
testing the logging system
&gt;&gt;&gt; logging.info('second message')
second message
&gt;&gt;&gt; print(*open('test.log'), sep='')
testing the logging system
second message
</code></pre>
</div>
<span class="comment-copy">You can store the output on a file with <code>f.write(data)</code> and then print to the console with <code>print(data)</code>. I don't understand the classes reference in the question.</span>
<span class="comment-copy">Python <a href="https://docs.python.org/2/library/logging.html" rel="nofollow noreferrer">logging</a> module comes to the rescue!</span>
<span class="comment-copy">@Llopis I mean I know how to work with classes. If I want to use that in my example above how could I use write</span>
<span class="comment-copy">With a method of class X that does that. <code>X.write(): .....</code> where .... are the code you posted or any variant of it. Although I don't know why you want to do so the logging package could solve also your problems.</span>
<span class="comment-copy">what if I have many "print" command in my code how could I deal with this ?</span>
<span class="comment-copy">instead of print use print_both e.g. <code>print_both(file, 'print stuff'); print_both(file, 'print something else')</code></span>
