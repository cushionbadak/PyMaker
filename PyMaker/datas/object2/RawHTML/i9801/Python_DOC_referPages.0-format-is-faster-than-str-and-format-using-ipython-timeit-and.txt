<div class="post-text" itemprop="text">
<p>So it's a CPython thing, not quite sure that it has same behaviour with other implementations. </p>
<p>But <code>'{0}'.format()</code> is faster than <code>str()</code> and <code>'{}'.format()</code>. I'm posting results from <em>Python 3.5.2</em>, but, I tried it with <em>Python 2.7.12</em> and the trend is the same.</p>
<pre><code>%timeit q=['{0}'.format(i) for i in range(100, 100000, 100)]
%timeit q=[str(i) for i in range(100, 100000, 100)]
%timeit q=['{}'.format(i) for i in range(100, 100000, 100)]

1000 loops, best of 3: 231 µs per loop
1000 loops, best of 3: 298 µs per loop
1000 loops, best of 3: 434 µs per loop
</code></pre>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="noreferrer">docs</a> on <code>object.__str__(self)</code></p>
<blockquote>
<p>Called by <code>str(object)</code> and the built-in functions <code>format()</code> and <code>print()</code> to compute the “informal” or nicely printable string representation of an object.</p>
</blockquote>
<p>So, <code>str()</code> and <code>format()</code> call same <code>object.__str__(self)</code> method, but where does that difference in speed come from?</p>
<p><strong>UPDATE</strong>
as @StefanPochmann and @Leon noted in comments, they get different results. I tried to run it with <code>python -m timeit "..."</code> and, they are right, because the results are:</p>
<pre><code>$ python3 -m timeit "['{0}'.format(i) for i in range(100, 100000, 100)]"
1000 loops, best of 3: 441 usec per loop

$ python3 -m timeit "[str(i) for i in range(100, 100000, 100)]"
1000 loops, best of 3: 297 usec per loop

$ python3 -m timeit "['{}'.format(i) for i in range(100, 100000, 100)]"
1000 loops, best of 3: 420 usec per loop
</code></pre>
<p>So it seems that IPython is doing something strange...</p>
<p><strong>NEW QUESTION</strong>: What is preferred way to convert an object to <code>str</code> by speed? </p>
</div>
<div class="post-text" itemprop="text">
<p>The IPython timing is just off for some reason (though, when tested with a longer format string in different cells, it behaved <em>slightly better</em>). Maybe executing in the same cells isn't right, don't really know.</p>
<p>Either way, <code>"{}"</code> is a bit faster than <code>"{pos}"</code> which is faster than <code>"{name}"</code> while they're all slower than <code>str</code>.</p>
<p><code>str(val)</code> is the fastest way to transform an object to <code>str</code>; it directly calls the objects' <code>__str__</code>, if one exists, and returns the resulting string. Others, like <code>format</code>, (or <code>str.format</code>) include additional overhead due to an extra function call (to <code>format</code> itself); handling any arguments, parsing the format string and <em>then</em> invoking the <code>__str__</code> of their <code>args</code>.</p>
<p>For the <code>str.format</code> methods <code>"{}"</code> uses automatic numbering; from a small section in the <a href="https://docs.python.org/3/library/string.html#format-string-syntax" rel="nofollow noreferrer">docs on the format syntax</a>:</p>
<blockquote>
<p>Changed in version 3.1: The positional argument specifiers can be omitted, so <code>'{} {}'</code> is equivalent to <code>'{0} {1}'</code>.</p>
</blockquote>
<p>that is, if you supply a string of the form:</p>
<pre><code>"{}{}{}".format(1, 2, 3)
</code></pre>
<p>CPython <em>immediately</em> knows that this is equivalent to:</p>
<pre><code>"{0}{1}{2}".format(1, 2, 3)
</code></pre>
<p>With a format string that contains numbers indicating positions; CPython can't assume a strictly increasing number (that starts from <code>0</code>) and must parse every single bracket in order to get it right, slowing things down a bit in the process:</p>
<pre><code>"{1}{2}{0}".format(1, 2, 3)
</code></pre>
<p>That's why it also is not allowed to mix these two together:</p>
<pre><code>"{1}{}{2}".format(1, 2, 3)
</code></pre>
<p>you'll get a nice <code>ValueError</code> back when you attempt to do so:</p>
<pre><code>ValueError: cannot switch from automatic field numbering to manual field specification
</code></pre>
<p>it also grabs these <a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/stringlib/unicode_format.h#L440" rel="nofollow noreferrer">positionals with <code>PySequence_GetItem</code></a> which I'm pretty sure is fast, at least, in comparison to <code>PyObject_GetItem</code> [see next].</p>
<p>For <code>"{name}"</code> values, CPython always has extra work to do due to the fact that we're dealing with keyword arguments rather than positional ones; this includes things like building the dictionary for the calls and generating way more <code>LOAD</code> byte-code instructions for loading <code>key</code>s and values. The keyword form of function calling always introduces some overhead. In addition, it seems that the grabbing actually uses <a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/stringlib/unicode_format.h#L421" rel="nofollow noreferrer"><code>PyObject_GetItem</code></a> which incurs some extra overhead due to its generic nature.</p>
</div>
<span class="comment-copy">To be faster, you could also try using <code>i.__str__()</code> directly. Though <code>str</code> is really the proper way. Is it not fast enough for you?</span>
