<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/33778471/longest-increasing-unique-subsequence">Longest increasing unique subsequence</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I have a sequence of values [1,2,3,4,1,5,1,6,7], and I have to find the longest subsequence of increasing length. However, the function needs to stop counting once it reaches a number lower than the previous one. The answer in this sequence in that case is [1,2,3,4]. As it has 4 values before being reset. How would I write the Python code for this?</p>
<p>Note: Finding the "longest increasing subsequence" seems to be a common challenge and so searching online I find a lot of solutions that would count for the entire length of the sequence, and return a subsequence of increasing values, ignoring any decrease, so in this case it would return [1,2,3,4,5,6,7]. That is not what I'm looking for. </p>
<p>It needs to count each subsequence, and reset the count upon reaching a number lower than the previous one. It then needs to compare all the subsequences counted, and return the longest one.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider a function that generates all possible ascending subsequences, you would start with an empty list, add items until one element was less (or equal to?) the the previous at which point you save (<code>yield</code>) the subsequence and restart with a new subsequence.  </p>
<p>One implementation using a generator could be this:</p>
<pre><code>def all_ascending_subsequences(sequence):
    #use an iterator so we can pull out the first element without slicing
    seq = iter(sequence)

    try: #NOTE 1
        last = next(seq)  # grab the first element from the sequence
    except StopIteration: # or if there are none just return
        #yield [] #NOTE 2
        return

    sub = [last]
    for value in seq:
        if value &gt; last: #or check if their difference is exactly 1 etc.
            sub.append(value)
        else: #end of the subsequence, yield it and reset sub
            yield sub
            sub = [value]
        last = value

    #after the loop we send the final subsequence
    yield sub
</code></pre>
<p>two notes about the handling of empty sequences:</p>
<ol>
<li>To finish a generator a <code>StopIteration</code> needs to be
raised so we could just let the one from <code>next(seq)</code> propegate out - however when <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer"><code>from __future__ import generator_stop</code></a> is in
effect it would cause a <code>RuntimeError</code> so to be future compatible we
need to catch it and explicitly <code>return</code>.</li>
<li>As I've written it passing an empty list to
<code>all_ascending_subsequences</code> would generate no values, which may not
be the desired behaviour.  Feel free to uncomment the <code>yield []</code> to
generate an empty list when passed an empty list.</li>
</ol>
<p>Then you can just get the longest by calling <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer"><code>max</code></a> on the result with <code>key=len</code></p>
<pre><code>b =  [1,2,3,4,1,5,1,6,7]

result = max(all_ascending_subsequences(b),key=len)
print("longest is", result)

#print(*all_ascending_subsequences(b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>b = [4,1,6,3,4,5,6,7,3,9,1,0]

def findsub(a):
  start = -1
  count = 0
  cur = a[0]
  for i, n in enumerate(a):
    if n is cur+1:
      if start is -1:
        start = i - 2
        count=1
      count+=1
      cur = n
    if n &lt; cur and count &gt; 1:
      return [a[j] for j in range(start,start+count+1)]


print findsub(b)
</code></pre>
<p>A somewhat sloppy algorithm, but I believe it does what you want. Usually i would not have simply shown you code, but I suspect that is what you wanted, and I hope you can learn from it, and create your own from what you learn.</p>
<p>a slightly better looking way because I didn't like that:</p>
<pre><code>b = [1,2,0,1,2,3,4,5]

def findsub(a):
  answer = [a[0]]
  for i in a[1:]:
    if answer[-1] + 1 is i:
      answer.append(i)
    if not len(answer) &gt; 1:
      answer = [i]
    elif i &lt; answer[-1] and len(answer) &gt; 1:
      return answer
  return answer



print findsub(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to do the following:</p>
<ol>
<li><p>Create a function <code>W</code> that given a list, returns the index of the last item which is not strictly increasing from the start of the list.</p>
<ul>
<li>For example, given the following lists: <code>[1,2,3,4,1,2,3], [4,2,1], [5,6,7,8]</code>, it should return <code>4</code>, <code>1</code>, <code>4</code>, respectively for each list</li>
</ul></li>
<li><p>Create a variable <code>maxim</code> and set the value to <code>0</code></p></li>
<li>Repeatedly do the following until your list is empty

<ul>
<li>Call your function <code>W</code> on your list, and let's call the return value <code>x</code></li>
<li>if <code>x</code> is greater than <code>maxim</code>
<ul>
<li>set <code>maxim</code> to <code>x</code></li>
<li>At this point if you wish to store this sequence, you can use the <a href="https://stackoverflow.com/questions/509211/explain-pythons-slice-notation">list-slice notation</a> to get that portion of your list which contains the sequence.</li>
</ul></li>
<li>delete that portion of your list from the list</li>
</ul></li>
</ol>
<p>Finally, print <code>maxim</code> and if you were storing the parts of your list containing the longest sequence, then print the last one you got</p>
</div>
<span class="comment-copy">this seems pretty trivial algorithm-wise, have you tried to solve it? StackOverflow isn't a code writing service.</span>
<span class="comment-copy">what should be returned with input: <code>[1,2,3,9,2,3,4,5,3,0,1,2,3,4,5,6]</code></span>
<span class="comment-copy">Well as it was described to me the algorithm would store the length of each subsequence so 1,2,3, 9 is 4 values, 2,3,4,5 is 4, 3 is 1 value, and 0,1,2,3,4,5,6 is 6 values, so it would return the final, longest sub-sequence only.</span>
<span class="comment-copy">This is not a duplicate of the marked question, this is actually a significantly simpler problem that is not at all solved by that "duplicate"</span>
<span class="comment-copy">Thanks for this, you described it in a way that I can actually understand it which helps a lot as I'm never comfortable with just <i>using</i> things if I don't know what i'm talking about.</span>
<span class="comment-copy">I'm glad this helped, however the way you asked your question really lends itself to just "here is the code that does it" type of solutions - You would be more likely to get (more) helpful explanatory answers like mine (sooner) if you had shown what you had tried or talked about <i>specifically</i> what you were having trouble with.</span>
<span class="comment-copy">I think this would find the first valid subsequence, not the longest.  try with <code>[1,2,0,1,2,3,4,5]</code>.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen we have to stop after the first time a new value is less than our current one.</span>
<span class="comment-copy">Thanks, nephi12! It works the way i need it to in that it stops counting once it reaches a number lower than the previous one. I need it to return the <i>longest</i> subsequence however, not necessarily the first. Since I am actually trying to learn from this though, could you maybe give me a hint as to what i need to change to do this, and i'll figure it out myself?</span>
<span class="comment-copy">how is it supposed to both stop before the end and find the longest? not sure i understand.</span>
