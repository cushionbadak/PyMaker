<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">Dictionary views</a> "are set-like objects" and can thus be used to compare dictionary contents with other objects.  Specifically,</p>
<ul>
<li><em>key-views</em>: set-like</li>
<li><em>value-views</em>: not set-like</li>
<li><em>item-views</em>: set-like if (key, value) pairs are unique and hashable</li>
</ul>
<p>The set-like nature of key-views allows bitwise comparisons.  In Python 3, we can find the intersection using the <code>&amp;</code> operator. </p>
<pre><code>hex_ids = {'#b0a7aa': '9976', '#595f5b': '19367', '#9a8f6a': '24095'}
hex_ids.keys()
# dict_keys(['#595f5b', '#9a8f6a', '#b0a7aa'])

{'#c7ccc0', '#9a8f6a', '#8a8e3e'} &amp; hex_ids.keys()
# {'#9a8f6a'}
</code></pre>
<p>Oddly, comparing a <code>list</code> and key-view is also possible:</p>
<pre><code>['#c7ccc0', '#9a8f6a', '#8a8e3e'] &amp; hex_ids.keys()
# {'#9a8f6a'}
</code></pre>
<p>whereas <code>list</code> and <code>set</code> objects normally cannot be compared this way.</p>
<pre><code>['#c7ccc0', '#9a8f6a', '#8a8e3e'] &amp; set(['#595f5b', '#9a8f6a', '#b0a7aa'])
# TypeError: unsupported operand type(s) for &amp;: 'list' and 'set'

['#c7ccc0', '#9a8f6a', '#8a8e3e'] &amp; {['#595f5b', '#9a8f6a', '#b0a7aa']}
# TypeError: unhashable type: 'list'
</code></pre>
<p>Aside from being set-like, <strong>why can key-views be compared to lists using bitwise operators?</strong></p>
<hr/>
<p>Tested on: |Python 3.5.2|Python 3.4.4|Python 2.7.12 (using <code>viewkeys()</code>)|IPython 5.0.0| </p>
</div>
<div class="post-text" itemprop="text">
<p>It uses the <a href="https://docs.python.org/3/reference/datamodel.html#object.__rand__" rel="nofollow noreferrer"><code>__rand__</code></a> method (short for "reflected and", not "random") on the <code>dict_keys</code> type.   Note that the reflected functions are only called if the left operand does not support the corresponding operation and the operands are of different types, which is the case here. </p>
<pre><code>&gt;&gt;&gt; {}.keys().__rand__
&lt;method-wrapper '__rand__' of dict_keys object at 0x109948f18&gt;
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; {0:0, 1:1}.keys().__rand__([1, 2])
{1}
</code></pre>
<p>For some reason this method was not implemented for sets, which is why that doesn't work:</p>
<pre><code>&gt;&gt;&gt; {0, 1}.__rand__([1, 2])
NotImplemented
</code></pre>
<p>I don't know the reason for this omission on sets, but I suspect it's probably "nobody has bothered to write it" because you can use <a href="https://docs.python.org/3/library/stdtypes.html#set.intersection" rel="nofollow noreferrer"><code>set.intersection</code></a> explicitly instead.</p>
</div>
