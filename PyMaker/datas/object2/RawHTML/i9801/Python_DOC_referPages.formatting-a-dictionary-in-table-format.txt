<div class="post-text" itemprop="text">
<p>I need to show my dictionary in table format:</p>
<pre><code>res = OrderedDict([('Release', '3.7.3'), ('REFDB', ['1234', '4567', '4567']), ('URL', ['http://www.test.com', 'http://www.foo.com', 'http://www.bar.com'])])
</code></pre>
<p>I am able to print the values in list format with this code  </p>
<pre><code>if res:
    for key, val in res.items():
        print (key, '-''\n', val)
else:
    print ('Version not found')
</code></pre>
<p>My expected format is - </p>
<pre><code>Release  REFDB     SVN
3.7.3    12345     http://google.com   
         232323    http://www.yahoo.com
         4343454   http://www.test.com
         5454554   http://www.bar.com
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to do it with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a>:</p>
<pre><code>from collections import OrderedDict
from itertools import zip_longest

d = OrderedDict([('Release', '3.7.3'), ('REFDB', ['1234', '4567', '4567']), ('URL', ['http://www.test.com', 'http://www.foo.com', 'http://www.bar.com'])])

f = lambda x: x if isinstance(x, list) else [x]

for tup in zip(*d.items()):
    for a, b, c in zip_longest(*map(f, tup), fillvalue=''):
        print('{:15}{:15}{:15}'.format(a, b, c))
</code></pre>
<hr/>
<pre><code>Release        REFDB          URL            
3.7.3          1234           http://www.test.com
               4567           http://www.foo.com
               4567           http://www.bar.com
</code></pre>
<p>You can change the intercolumn spacing in the string formatting if you wish to have or more less spacing.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://pandas.pydata.org/pandas-docs/stable/" rel="nofollow noreferrer">pandas</a> library to transform the dictionary into a data-frame.</p>
<pre><code>from collections import OrderedDict
import pandas as pd

d = OrderedDict([('Release', '3.7.3'), ('REFDB', '12345 \n 232323 \n 4343454 \n 5454554'), ('URL', 'http://google.com \n http://www.yahoo.com \n http://www.test.com \n http://www.bar.com')])

for key in d.keys():
    d[key] =  d[key].split('\n')

df = pd.DataFrame.from_dict(d, orient='index').transpose()
</code></pre>
<p>The output will be:</p>
<pre><code>  Release      REFDB                     URL
0   3.7.3     12345       http://google.com 
1    None    232323    http://www.yahoo.com 
2    None   4343454     http://www.test.com 
3    None    5454554      http://www.bar.com
</code></pre>
</div>
<span class="comment-copy">You're going to have to <code>split</code> those strings into lists of strings, then use <code>itertools.zip_longest</code> to yield tuples.  Use <code>''</code> as the fill value.</span>
<span class="comment-copy">I am getting the dictionary in a different format (updated in original question). The code fails for the current format.</span>
<span class="comment-copy">@vpd Updating your question after receiving a working answer is not fair. Editing the dataset in my answer to match your new question even makes it worse. In any case, I updated the answer to match your new requirements. Next time, you should leave a comment on the answer stating your new requirement if it's not very different from the first. Otherwise, you may consider asking the question in a new post.</span>
