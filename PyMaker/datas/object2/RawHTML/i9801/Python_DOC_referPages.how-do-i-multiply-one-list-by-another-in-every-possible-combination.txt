<div class="post-text" itemprop="text">
<p>For example:</p>
<pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
</code></pre>
<p>Wanted result:</p>
<pre><code>NewList = [4, 5, 6, 8, 10, 12, 12, 15, 18]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Three possible approaches:</p>
<ol>
<li><p><strong>Readable</strong></p>
<pre><code>new_list = []
for a in list1:
    for b in list2:
        new_list.append(a * b)
</code></pre>
<p>This makes it very clear what's going on, but requires four lines and repeated calls to <code>new_list.append()</code>, which is slightly inefficient.</p></li>
<li><p><strong>Concise</strong></p>
<pre><code>new_list = [a * b for a in list1 for b in list2]
</code></pre>
<p>This is very compact, but for many people it takes a moment or two to remember whether the nesting of multiple-<code>for</code> <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehensions</a> goes left-to-right or right-to-left.</p></li>
<li><p><strong>Lazy</strong></p>
<pre><code>from itertools import product

new_list = [a * b for a, b in product(list1, list2)]
</code></pre>
<p>This will work correctly even if <code>list1</code> and <code>list2</code> are <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generators</a> or other one-shot, lazily-evaluated iterables, e.g.</p>
<pre><code>&gt;&gt;&gt; from itertools import count, islice
&gt;&gt;&gt; list1 = islice(count(1), 3)
&gt;&gt;&gt; list2 = islice(count(4), 3)
&gt;&gt;&gt; [a * b for a, b in product(list1, list2)]
[4, 5, 6, 8, 10, 12, 12, 15, 18]
</code></pre>
<p>... which won't work with the first two approaches.</p></li>
</ol>
<p>Note that I've used <code>new_list</code> rather than <code>NewList</code> in these examples, which is the conventional way to name variables in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check the result by printing <code>NewList</code>, which in this case can give you what you had above. Your <code>list1</code> and <code>list2</code> are initialized above this code just like you have above.</p>
<pre><code>NewList = []
for item1 in list1:
    for item2 in list2:
        NewList.append(item1*item2)
</code></pre>
</div>
<span class="comment-copy">NewList =[] for item in list1: for item2 in list2: NewList.append(item1*item2)</span>
<span class="comment-copy">Just for fun, pushing all the work to the C layer in CPython, to avoid byte code execution: <code>from itertools import product, starmap</code>, <code>from operator import mul</code>, <code>new_list = list(starmap(mul, product(list1, list2)))</code>. In a local test case (with two 10 element inputs with small <code>int</code> values), pushing the work to the C layer like that reduced runtime by ~1/6 (and that stayed the case for 50x50; it might lose out for very small inputs, but that's it). General caveat applies: This is premature optimization, and the list comprehension is more Pythonic.</span>
