<div class="post-text" itemprop="text">
<p>Is there any way I can only replace only the first argument only in string formatting? Like in this:</p>
<pre><code>"My quest is {test}{}".format(test="test")
</code></pre>
<p>I want the output to be:</p>
<pre><code>"My quest is test {}
</code></pre>
<p>The second <code>{}</code> arg I will replace later.</p>
<p>I know I can create a string like: </p>
<pre><code>"My quest is {test}".format(test="test")
</code></pre>
<p>and later combine it with remaining string and create new string, but can I do it in one go?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know when you set up the format string that you'll only be replacing a subset of the values, and you want some other set to remain, you can escape the ones you're not going to fill right away by doubling the brackets:</p>
<pre><code>x = "foo {test} bar {{other}}".format(test="test") # other won't be filled in here
print(x)                              # prints "foo test bar {other}"
print(x.format(other="whatever"))     # prints "foo test bar whatever"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only way you can replace it in the same line is if you replace <code>"{test}"</code> with another bracket. I.e:</p>
<pre><code>s = "My quest is {test}".format(test="test {}").format('testing')
</code></pre>
<p>but that doesn't make much sense because you could've just done:</p>
<pre><code>s = "My quest is {test} {}".format('testing', test="test {}")
</code></pre>
<p>immediately. </p>
<p>You could keep the result of:</p>
<pre><code>s = "My quest is {test}".format(test="test {}")
</code></pre>
<p>So <code>s</code> has a bracket inside it waiting to get replaced and call <code>format</code> on it later on if you need to. </p>
</div>
<div class="post-text" itemprop="text">
<p>You would have to write your own format function that only makes a single replacement. For example, to give you something to start with (note that this is somewhat vulnerable to bad format strings):</p>
<pre><code>import re
def formatOne(s, arg):
    return re.sub('\{.*?\}', arg, s, count=1)
</code></pre>
<p>Used like this:</p>
<pre><code>&gt;&gt;&gt; s = "My quest is {test}{}"
&gt;&gt;&gt; formatOne(s, 'test')
'My quest is test{}'
&gt;&gt;&gt; formatOne(_, ' later')
'My quest is test later'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The correct way to achieve this would probably be to subclass <a href="https://docs.python.org/3/library/string.html#string.Formatter" rel="nofollow noreferrer">string.Formatter</a> class and use its instance instead of the string method:</p>
<pre><code>from string import Formatter
class IncrementalFormatter(Formatter):
    pass  # your implementation
f = IncrementalFormatter()
f.format("hello {name}", name="Tom")
</code></pre>
<p>The following <code>Formatter</code> methods would have to be overwritten:</p>
<ol>
<li><code>get_value()</code> should return some special object instead of raising <code>LookupError</code>.</li>
<li><code>get_field()</code> should save <code>field_name</code> argument into this object (or proceed normally if the object is not our special object).</li>
<li><code>convert_field()</code> should just save <code>conversion</code> argument into this object and do no conversion (or proceed normally...).</li>
<li><code>format_field()</code> should reconstruct field format string from the special object using its <code>field_name</code> and <code>conversion</code> attributes and <code>format_spec</code> argument of this method (or proceed normally...).</li>
</ol>
<p>So, for example:</p>
<pre><code>f.format("{greet} {who.name!r:^16s}", greet="hello")
</code></pre>
<p>should result in <code>"hello {who.name!r:^16s}"</code>, where <code>"who.name"</code> is <code>field_name</code>, <code>"r"</code> is <code>conversion</code>, <code>"^16s"</code> is <code>format_spec</code> and all these three values were re-combined back into <code>"{who.name!r:^16s}"</code>, so that it can be used in the next formatting pass.</p>
<p>Additional note: the special object should return itself upon access of any attribute (with <code>.</code>) or item (with <code>[]</code>).</p>
</div>
<span class="comment-copy">Can you give more clear example to demonstrate what you want? Your question is not clear.</span>
