<div class="post-text" itemprop="text">
<p>I wrote a program to reverse the words in a given sentence here:</p>
<pre><code>def rev_each_word_in(Sentence):

print(' '.join(Word[::-1] for Word in Sentence.split()))
</code></pre>
<p>As my input for Sentence I used "to be or not to be that is the question." This returns the following:</p>
<pre><code>ot eb ro ton ot eb taht si eht .noitseuq
</code></pre>
<p>It's almost exactly what I want, but is there a way that the period could remain at the end of the sentence, so the return would be:</p>
<pre><code>ot eb ro ton ot eb taht si eht noitseuq.
</code></pre>
<p>Thank you in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>It's possible to pass a function as the <code>repl</code> argument to <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub()</code></a>, so we can use that to match words and reverse them:</p>
<pre><code>import re

def rev_each_word_in(sentence):
    return re.sub(r'\b\S*\b', lambda m: m.group(0)[::-1], sentence)
</code></pre>
<p>The pattern <code>\b\S*\b</code> matches a word boundary, followed by an arbitrary number of non-whitespace characters, followed by a word boundary.</p>
<p>The function (a lambda, for brevity) takes <a href="https://docs.python.org/3/library/re.html#re.match.group" rel="nofollow noreferrer"><code>group(0)</code></a> (the complete text of the match) for each match, and reverses it the usual way using slicing.</p>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; rev_each_word_in('to be or not to be that is the question.')
'ot eb ro ton ot eb taht si eht noitseuq.'
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; rev_each_word_in("whether 'tis nobler in the mind to suffer")
"rehtehw 'sit relbon ni eht dnim ot reffus"
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; rev_each_word_in("aye, there's the rub")
"eya, s'ereht eht bur"
</code></pre>
<p>As you can see, this preserves the position of punctuation immediately before or after words, while maintaining it in the "correct" position inside each reversed word.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your specifications are still unclear, but if you want only the letters to be reversed within a word, maybe you could try something like</p>
<pre><code>def reverse_letters(word):
    lets = (c for c in reversed(word) if c.isalpha())
    return ''.join([c if not c.isalpha() else next(lets)
                    for c in word])

def reverse_sentence(sentence):
    words = sentence.split()
    return ' '.join([reverse_letters(word) for word in words])
</code></pre>
<p>which gives me</p>
<pre><code>In [23]: reverse_sentence("to be or not to be, that is the question.")
Out[23]: 'ot eb ro ton ot eb, taht si eht noitseuq.'

In [24]: reverse_sentence("Don't try this at home!")
Out[24]: "tno'D yrt siht ta emoh!"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here comes some ugliness that takes care of this in one line:</p>
<pre><code>from string import punctuation as p
print(' '.join(w[::-1] if w[-1] not in p else w[:-1][::-1] + w[-1] for w in Sentence.split()))
</code></pre>
<p>Where we reverse fully if the last character in a word is not in the punctuation string and if it is we reverse the string up until the punctuation and then add the punctuation to it. prints out:</p>
<pre><code>ot eb ro ton ot eb taht si eht noitseuq.
</code></pre>
<p>Slimming it down as much as I can because I'm ashamed of it:</p>
<pre><code># similar to  [::-1]
r = slice(None, None,-1)
# cut down chars!    
l = Sentence.split()
# reverse condition too and use shorter names
print(' '.join(w[:-1][r] + w[-1] if w[-1] in p else w[r] for w in l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Change your method to this:</p>
<pre><code>def rev_each_word_in(Sentence):
    if Sentence[-1] == '.':
        Sentence = Sentence[:-1]
        print(' '.join(Word[::-1] for Word in Sentence.split())+".")
    else:
        print(' '.join(Word[::-1] for Word in Sentence.split()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import string

def reverse(sentence):
    punctuation = set(string.punctuation)
    words = []
    for word in sentence.split():
        words.append(word.rstrip(string.punctuation)[::-1])
        if word[-1] in punctuation:
           words[-1] = words[-1]+word[-1]
    return ' '.join(words)
</code></pre>
<p>Output:</p>
<pre><code>In [152]: reverse("to be or not to be that is the question.")
Out[152]: 'ot eb ro ton ot eb taht si eht noitseuq.'
</code></pre>
<p>And this will work for any punctuation in your sentence:</p>
<pre><code>In [153]: reverse("to be or not to be; that is the question.")
Out[153]: 'ot eb ro ton ot eb; taht si eht noitseuq.'
</code></pre>
</div>
<span class="comment-copy">So you want "don't" to become "tno'd"?</span>
<span class="comment-copy">Do you essentially want all punctuation to remain in the same position?</span>
<span class="comment-copy">Nice! (at least, if you've interpreted what OP wants correctly ...)</span>
<span class="comment-copy">This only works for a single period at the end of a sentence.</span>
<span class="comment-copy">Correct. That appears to be what the OP wanted.</span>
