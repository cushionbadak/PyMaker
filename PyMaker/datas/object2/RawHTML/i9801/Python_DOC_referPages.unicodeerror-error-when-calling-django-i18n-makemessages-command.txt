<div class="post-text" itemprop="text">
<p>I'm working with Django's internationalisation features to generate translation strings for a webapp. </p>
<p>A problem is arising where I try and call <code>makemessages</code>, and the existing language <code>.po</code> file contains a special character (such as <code>$</code>, <code>£</code>, etc). </p>
<p>Where one of these exists, makemessages tries to load the existing <code>.po</code> file and to decode it. When it does this, I get an error:</p>
<pre><code>Traceback (most recent call last):
 File "manage.py", line 18, in &lt;module&gt;
   execute_from_command_line(sys.argv)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/__init__.py", line 354, in execute_from_command_line
   utility.execute()
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/__init__.py", line 346, in execute
   self.fetch_command(subcommand).run_from_argv(self.argv)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/base.py", line 394, in run_from_argv
   self.execute(*args, **cmd_options)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/base.py", line 445, in execute
   output = self.handle(*args, **options)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/commands/makemessages.py", line 325, in handle
   self.write_po_file(potfile, locale)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/commands/makemessages.py", line 458, in write_po_file
   msgs, errors, status = gettext_popen_wrapper(args)
 File "/usr/local/lib/python2.7/dist-packages/django/core/management/commands/makemessages.py", line 51, in gettext_popen_wrapper
   stdout = stdout.decode(stdout_encoding)
 File "/usr/lib/python2.7/encodings/utf_8.py", line 16, in decode
   return codecs.utf_8_decode(input, errors, True)
UnicodeEncodeError: 'ascii' codec can't encode character u'\xa2' in position 2105: ordinal not in range(128)
</code></pre>
<p>I've tried to dig back through the traceback here, but I'm at a loss as to what's happening. </p>
<p>It seems as though Django tries to decode the existing <code>.po</code> file as <code>UTF8</code>, but then when re-encoding it, it's using an <code>ASCII</code> codec. </p>
<p>Any insights as to what's wrong would be massively appreciated.</p>
<hr/>
<p><strong>Edit:</strong></p>
<ul>
<li>OS: Ubuntu 15.10 and OS X 10.11.6</li>
<li>Python: 2.7.10 and 2.7.11</li>
<li>Django: 1.8.14</li>
<li>Six: 1.10.0</li>
</ul>
<p>I've tried reinstalling Django/Six as suggested, but the error is still there.</p>
<p>Ubuntu's <code>localedef --list-archive</code>:</p>
<pre><code>en_AG
en_AG.utf8
en_AU.utf8
en_BW.utf8
en_CA.utf8
en_DK.utf8
en_GB.utf8
en_HK.utf8
en_IE.utf8
en_IN
en_IN.utf8
en_NG
en_NG.utf8
en_NZ.utf8
en_PH.utf8
en_SG.utf8
en_US.utf8
en_ZA.utf8
en_ZM
en_ZM.utf8
en_ZW.utf8
</code></pre>
<p>Content-type of the problematic translation file:</p>
<pre><code> "Content-Type: text/plain; charset=UTF-8\n"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Note this is a different exception location from <a href="https://stackoverflow.com/questions/22106777/unicode-issue-with-makemessages-all-django-1-6-2-python-3-3">this similar question</a> mentioned in the comments.</em></p>
<p>It seems to me the only way this can happen is if there's been a modification to your django install or there's a bug in the python 2.7 version.</p>
<p>Your stack is:</p>
<pre><code>&gt; msgs, errors, status = gettext_popen_wrapper(args)
&gt; stdout = stdout.decode(stdout_encoding)
</code></pre>
<p><code>gettext_popen_wrapper</code> (on <strong>django 1.8</strong>, which is what I think you're using, can you confirm?) and <code>popen_wrapper</code> which creates <code>stdout</code> (after removing comments/docstrings and reindenting for clarity, see <a href="https://github.com/django/django/blob/1.8.16/django/core/management/utils.py#L13" rel="nofollow noreferrer">popen_wrapper</a> and <a href="https://github.com/django/django/blob/1.8.16/django/core/management/commands/makemessages.py#L35" rel="nofollow noreferrer">gettext_popen_wrapper</a> on github for the unadulterated code):</p>
<pre><code>def popen_wrapper(args, os_err_exc_type=CommandError, universal_newlines=True):
    try:
        p = Popen(args, shell=False, stdout=PIPE, stderr=PIPE,
                close_fds=os.name != 'nt', universal_newlines=universal_newlines)
    except OSError as e:
        strerror = force_text(e.strerror, DEFAULT_LOCALE_ENCODING,
                              strings_only=True)
        six.reraise(os_err_exc_type, os_err_exc_type('Error executing %s: %s' %
                    (args[0], strerror)), sys.exc_info()[2])
    # NB: subprocess.Popen.communicate() should return two bytes 
    # (i.e. str in python 2) objects
    output, errors = p.communicate()
    return (
        output,
        force_text(errors, DEFAULT_LOCALE_ENCODING, strings_only=True),
        p.returncode
    )

def gettext_popen_wrapper(args, 
                          os_err_exc_type=CommandError, 
                          stdout_encoding="utf-8"):
    manual_io_wrapper = six.PY3 and stdout_encoding != DEFAULT_LOCALE_ENCODING

    stdout, stderr, status_code = popen_wrapper(
        args, os_err_exc_type=os_err_exc_type,
        universal_newlines=not manual_io_wrapper)

    if manual_io_wrapper:
        stdout = io.TextIOWrapper(io.BytesIO(stdout), encoding=stdout_encoding).read()
    if six.PY2:
        # EXCEPTION HIT ON THE FOLLOWING LINE
        stdout = stdout.decode(stdout_encoding)
    return stdout, stderr, status_code
</code></pre>
<p>So <code>stdout</code> should be a plain <code>str</code> object (i.e. a bunch of bytes needing decoding) by the time we call <code>stdout.decode()</code>. However, if that were the case then why is the exception in <strong>en</strong>coding? We would only need to encode if the object already was a unicode object, i.e. if it was of type <code>unicode</code>. And sure enough, if we add the line</p>
<pre><code>stdout = stdout.decode('utf-8')
</code></pre>
<p>before </p>
<pre><code>stdout = stdout.decode(stdout_encoding)
</code></pre>
<p>Then now the <code>decode</code> method first attempts to <code>encode</code> the unicode <code>stdout</code>, using the <a href="https://docs.python.org/2/library/codecs.html#codecs.encode" rel="nofollow noreferrer">default encoding of ascii</a>, which causes the exception you've seen. I also got the same error by setting <code>manual_io_wrapper</code> to <code>True</code>, which caused the <code>stdout = io.TextWrapper(...)</code> line to happen as well (which produces a unicode as well), but that shouldn't be <code>True</code> because you're on python 2 not 3.</p>
<p>So I think either:</p>
<ul>
<li>You've got a bad install of <code>django</code> or <code>six</code>, or it's been edited. Try reinstalling them.</li>
<li>You've hit a bug in <code>subprocess.Popen.communicate()</code> and for some reason it's returning a <code>unicode</code> not a <code>str</code> (I believe in python 3 that is possible if <a href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer"><code>universal_newlines</code> are turned on</a>. You may get mileage by reinstalling python or upgrading to a later version.</li>
</ul>
<p>My main point though is that I don't think it's an environment issue. It would be interesting to know for any follow-ups:</p>
<ul>
<li>what platform you're on</li>
<li>what python 2.7 you're using</li>
<li>what django you're using.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>At the following line, somehow, <code>stdout</code> is not byte <code>str</code> but its <code>unicode</code> and you are getting exception during implicit encoding of that <code>unicode</code>.</p>
<pre><code>stdout = stdout.decode('utf-8')
</code></pre>
<p>That's because of the fact that <code>decode()</code> should be performed on byte <code>str</code> and when we try calling <code>decode</code> on <code>unicode</code>, in python 2.7, there will be an implicit call to <code>encode</code> with that <code>unicode</code> before the <code>decode</code>, and this call to <code>encode</code> will be using default <code>charset</code> which is <code>ascii</code> in python. </p>
<pre><code>unicode.encode() --&gt; byte   # results in str
byte.decode() --&gt; unicode   # results in unicode
unicode.decode() --&gt; unicode.encode().decode()  # implicit encode call
</code></pre>
<p>So, start investigation with what's causing stdout to be <code>unicode</code>.</p>
<p>Thanks.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/22106777/unicode-issue-with-makemessages-all-django-1-6-2-python-3-3" title="unicode issue with makemessages all django 1 6 2 python 3 3">stackoverflow.com/questions/22106777/…</a></span>
<span class="comment-copy">Try this: <code>LC_CTYPE=en_US.UTF-8 python manage.py makemessages</code>; does it work?</span>
<span class="comment-copy">@nobe4: Does it make a difference when you run it with <code>LC_CTYPE=en_US.UTF-8 python manage.py makemessages</code>? And, BTW, what is your operating system and version?</span>
<span class="comment-copy">@AntonisChristofides: sorry for the delay, this command doesn't solve the problem. I've updated my question with details.</span>
<span class="comment-copy">Could you show the output of <code>localedef --list-archive</code>? This will work on the Ubuntu; I'm not certain about the Mac OS X.</span>
<span class="comment-copy">Thanks for the answer, I'll update my question.</span>
