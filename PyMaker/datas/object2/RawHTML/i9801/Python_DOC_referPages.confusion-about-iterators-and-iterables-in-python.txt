<div class="post-text" itemprop="text">
<p>I am currently reading in the official documentation of Python 3.5.</p>
<p>It states that <code>range()</code> is iterable, and that <code>list()</code> and <code>for</code> are iterators.<a href="https://docs.python.org/3/tutorial/controlflow.html" rel="nofollow noreferrer"> [section 4.3]</a></p>
<p>However, <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">here</a> it states that <code>zip()</code> makes an iterator.</p>
<p>My question is that when we use this instruction:</p>
<pre><code>list(zip(list1, list2))
</code></pre>
<p>are we using an iterator (<code>list()</code>) to iterate through another iterator?</p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation is creating some confusion here, by re-using the term 'iterator'.</p>
<p>There are three components to the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">iterator protocol</a>:</p>
<ol>
<li><p>Iterables; things you can <em>potentially</em> iterate over and get their elements, one by one.</p></li>
<li><p>Iterators; things that do the iteration. Every time you want to step through all items of an iterable, you need one of these to keep track of where you are in the process. These are not re-usable; once you reach the end, that's it. For most iterables, you can create multiple indepedent iterators, each tracking position independently.</p></li>
<li><p>Consumers of iterators; those things that want to do something with the items.</p></li>
</ol>
<p>A <code>for</code> loop is an example of the latter, so #3. A <code>for</code> loop uses the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> function</a> to produce an <em>iterator</em> (#2 above) for whatever you want to loop over, so that "whatever" must be an iterable (#1 above).</p>
<p><code>range()</code> is an example of #1; it is iterable object. You can iterate over it multiple times, independently:</p>
<pre><code>&gt;&gt;&gt; r = range(5)
&gt;&gt;&gt; r_iter_1 = iter(r)
&gt;&gt;&gt; next(r_iter_1)
0
&gt;&gt;&gt; next(r_iter_1)
1
&gt;&gt;&gt; r_iter_2 = iter(r)
&gt;&gt;&gt; next(r_iter_2)
0
&gt;&gt;&gt; next(r_iter_1)
2
</code></pre>
<p>Here <code>r_iter_1</code> and <code>r_iter_2</code> are two separate iterators, and each time you ask for a next item they do so based on their own internal bookkeeping.</p>
<p><code>list()</code> is an example of <em>both an iterable (#1) and a iteration consumer (#3)</em>. If you pass another iterable (#1) to the <code>list()</code> call, a list object is produced containing all elements from that iterable. But list objects themselves are also iterables.</p>
<p><code>zip()</code>, in Python 3, takes in multiple iterables (#1), and is itself an iterator (#2). <code>zip()</code> stores a new iterator (#2) for each of the iterables you gave it. Each time you ask <code>zip()</code> for the next element, <code>zip()</code> builds a new tuple with the next elements from each of the contained iterables:</p>
<pre><code>&gt;&gt;&gt; lst1, lst2 = ['foo', 'bar'], [42, 81]
&gt;&gt;&gt; zipit = zip(lst1, lst2)
&gt;&gt;&gt; next(zipit)
('foo', 42)
&gt;&gt;&gt; next(zipit)
('bar', 81)
</code></pre>
<p>So in the end, <code>list(zip(list1, list2))</code> uses both <code>list1</code> and <code>list2</code> as iterables (#1), <code>zip()</code> consumes those (#3) when it itself is being consumed by the outer <code>list()</code> call. </p>
</div>
<div class="post-text" itemprop="text">
<p>The documentation is badly worded. Here's the section you're referring to:</p>
<blockquote>
<p>We say such an object is <em>iterable</em>, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive items until the supply is exhausted. We have seen that the <a href="https://docs.python.org/3/reference/compound_stmts.html#for" rel="nofollow noreferrer"><code>for</code></a> statement is such an <em>iterator</em>. The function <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list()</code></a> is another; it creates lists from iterables:</p>
</blockquote>
<p>In this paragraph, <em>iterator</em> does not refer to a Python iterator object, but the general idea of "something which iterates over something". In particular, the <code>for</code> statement cannot be an iterator object because it isn't an object at all; it's a language construct.</p>
<p>To answer your specific question:</p>
<blockquote>
<p>... when we use this instruction:</p>
<pre><code>list(zip(list1, list2))
</code></pre>
<p>are we using an iterator (<code>list()</code>) to iterate through another iterator?</p>
</blockquote>
<p>No, <a href="https://docs.python.org/3/library/stdtypes.html#list" rel="nofollow noreferrer"><code>list()</code></a> is not an iterator. It's the constructor for the <code>list</code> type. It can accept any iterable (including an iterator) as an argument, and uses that iterable to construct a list.</p>
<p><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> is an iterator function, that is, a function which returns an iterator. In your example, the iterator it returns is passed to <code>list()</code>, which constructs a <code>list</code> object from it.</p>
<p>A simple way to tell whether an object is an iterator is to call <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code></a> with it, and see what happens:</p>
<pre><code>&gt;&gt;&gt; list1 = [1, 2, 3]
&gt;&gt;&gt; list2 = [4, 5, 6]
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; zipped = zip(list1, list2)
&gt;&gt;&gt; zipped
&lt;zip object at 0x7f27d9899688&gt;
&gt;&gt;&gt; next(zipped)
(1, 4)
</code></pre>
<p>In this case, the next element of <code>zipped</code> is returned.</p>
<pre><code>&gt;&gt;&gt; list3 = list(zipped)
&gt;&gt;&gt; list3
[(2, 5), (3, 6)]
</code></pre>
<p>Notice that only the last two elements of the iterator are found in <code>list3</code>, because we already consumed the first one with <code>next()</code>.</p>
<pre><code>&gt;&gt;&gt; next(list3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'list' object is not an iterator
</code></pre>
<p>This doesn't work, because lists are not iterators.</p>
<pre><code>&gt;&gt;&gt; next(zipped)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>This time, although <code>zipped</code> is an iterator, calling <code>next()</code> with it raises <code>StopIteration</code> because it's already been exhausted to construct <code>list3</code>.</p>
</div>
<span class="comment-copy"><code>for</code> is not an iterator. <code>range()</code> is a <i>sequence</i>, just like <code>list</code> is, and both are iterable. You create a new iterator for an iterable to do the actual iteration.</span>
<span class="comment-copy">The word iterator has actually been used with two different meanings. I recommend not fussing about the exact meanings of the words.</span>
<span class="comment-copy"><code>list()</code> and <code>for</code> both ask an iterable for an iterator. Iterators are their own iterators. <code>zip()</code> is an iterator, not an iterable, because it can't produce new iterators (it can only be iterated over once).</span>
<span class="comment-copy">@MartijnPieters Well that official Python tutorial page does say <i>"the for statement is such an iterator. The function list() is another"</i>. I guess they mean it's a thing that iterates (over the given thing).</span>
<span class="comment-copy">I think the confusion here is between the consumer (<i>driving</i> the iteration) and the producer (<i>can be used as</i>).</span>
<span class="comment-copy">Goddamn it, how do you <i>do</i> that? ;-)</span>
<span class="comment-copy">@Zero: by travelling by plane to another country; I jump in on the short bursts of connectivity ;-)</span>
<span class="comment-copy">From your answer and @ZeroPiraeus answer, I can see that the documentation uses the term <code>iterator</code> sometimes to refer to the technical actual meaning of <code>iterator</code>, and other times to refer to the consumers of iterators.</span>
<span class="comment-copy">But why isn't <code>range()</code> considered to be an <code>iterator</code> instead of <code>iterable</code>? Doesn't it work in the same way <code>zip()</code> works?</span>
<span class="comment-copy">No, it is a virtual sequence. It has a length, containment tests work, you can compare two ranges and you can reverse it. You can't do that with an iterator.</span>
