<div class="post-text" itemprop="text">
<p>I'm working on Huffman Encoding and Decoding. I have encoded a string into binary using Huffman Algorithm and now i want to send it over to another computer over sockets using Python 3 where the encoded data will be decoded back. What would be the most efficient way of doing so ? </p>
<p>Encoder part of code : </p>
<pre><code>import heapq
import socket

class HuffmanEncoder:
    output = {};
    class Node:
        def __init__(self,data,freq,left=None,right=None):
            self.data = data
            self.freq = freq
            self.left = left
            self.right = right

    def __init__(self,root):
        self.root = root

    def isLeaf(root):
        return not root.left and not root.right

    def buildHuffman(p):
        while len(p) != 1:
            left = heapq.heappop(p)[1]
            right = heapq.heappop(p)[1]
            top = HuffmanEncoder.Node('$',left.freq + right.freq)
            top.left = left
            top.right = right
            heapq.heappush(p,(top.freq,top))
        return heapq.heappop(p)[1]

    def printCodes(root,arr,top):
        if root.left:
            arr.insert(top,'0')
            HuffmanEncoder.printCodes(root.left,arr,top + 1)

        if root.right:
            arr.insert(top,'1')
            HuffmanEncoder.printCodes(root.right,arr,top + 1)

        if HuffmanEncoder.isLeaf(root):
            s = ""
            for i in range(0,top):
                s += arr[i]
            HuffmanEncoder.output[root.data] = s
        return HuffmanEncoder.output

def main():
    p = []
    arr = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ']
    freq = [8.167,1.492,2.782,4.253,12.702,2.228,2.015,6.094,6.966,0.153,0.772,4.025,2.406,6.749,7.507,1.929,0.095,5.987,6.327,9.056,2.758,0.978,2.360,0.150,1.974,0.074,25.422]
    for i in range(0,len(arr)):
        x = HuffmanEncoder.Node(arr[i],freq[i])
        heapq.heappush(p,(x.freq,x))

    root = HuffmanEncoder.buildHuffman(p)
    arr = []
    top = 0
    codes = HuffmanEncoder.printCodes(root,arr,top)
    for key in sorted(codes):
        print(key,codes[key])
    s = input()
    for i in range(0,len(s)):
        print(codes[s[i]])

if __name__ == '__main__':
                 main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to send string values in bytecode, then you can do: <code>socket.send(byte(message,'utf-8'))</code>
Or <code>socket.send(message.encode())</code></p>
<p>If you want to send some plain text you can send directly: <code>b'Spain'</code> but if your text is in utf-8 (non-ascii) you must do: <code>'España'.encode()</code></p>
<p><strong>Look this example of client, and watch <code>.encode()</code> and <code>.decode()</code> which uses UTF-8 by default:</strong></p>
<pre><code>#!/usr/bin/python3
import socket

s = socket.socket()
s.connect(("localhost", 9999))

while True:
    msg = input("&gt; ")
    s.send(msg.encode())
    if msg == "quit":
        break
    received=s.recv(1024)
    print(received.decode())

print("Bye")

s.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at <a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/unicode.html</a>
when trying to send raw 8-bit binary data, Python will encode it before sending it through the socket following this rule:</p>
<blockquote>
<p>"if the value is &lt; 128, it’s represented by the corresponding byte
  value. If the value is &gt;= 128, it’s turned into a sequence of two,
  three, or four bytes, where each byte of the sequence is between 128
  and 255."</p>
</blockquote>
<p>Once you have managed to convert an array of 8-bit data into a string, send out the string using</p>
<pre><code>socket.send_string(yourstring.encode('latin-1')
</code></pre>
</div>
<span class="comment-copy">Possibly have a look at zeroMQ bindings for python: <a href="http://zeromq.org/bindings:python" rel="nofollow noreferrer">zeromq.org/bindings:python</a></span>
<span class="comment-copy">Can you indent your code for us?</span>
<span class="comment-copy">yeah of course sry i forgot.</span>
<span class="comment-copy">I'm not sure I understand your question. Are you asking for help with your client (which you haven't shown), or are you asking about the server code you have shown (which seems to work just fine, if you fix the import to <code>from socket import socket, AF_INET, SOCK_STREAM</code>). The server isn't doing any encoding or decoding of bytes at all, so if you're asking about that, it seems a bit of a non-sequitur. What do you think the difference is between a byte string and the "raw binary data" you have?</span>
<span class="comment-copy">@Blckkknght i have added my encoder code above. Now that i see its not binary data in the first place its just a binary string. Does this save me any bandwidth ? I mean its just characters after all and i seem to get more characters than the actual message.</span>
