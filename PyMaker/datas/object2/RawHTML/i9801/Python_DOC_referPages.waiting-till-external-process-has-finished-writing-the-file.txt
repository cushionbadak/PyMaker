<div class="post-text" itemprop="text">
<p>I am using <a href="https://metamap.nlm.nih.gov" rel="nofollow noreferrer">metamap</a> in a project as an external program. Complete code in the project is written in Python. At one place in my code I have to pass input file as an argument to metamap and then read the output file metamap generates. I am calling metamap as follows:</p>
<pre><code>command = '/bin/metamap --silent --sldiID temp_input'
subprocess.call(command, shell=True)
</code></pre>
<p>In above case, output file is generated by the name temp_input.out in current working directory. I then need to process the contents of this output file. Issue I am currently facing is that python code moves forward considering output file to be empty. How can I ensure that output file is completely written and only then python code moves forward. </p>
<p>As of now, I am doing following which I feel is not the right way or cleanest way to achieve the above.</p>
<pre><code>while fileExists == False:
    if os.path.isfile(outputFileName):
        fileExists = os.stat(outputFileName).st_size != 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could deadlock the child process using "subprocess.Popen.wait(timeout=None)".
<a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer">https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait</a></p>
</div>
<div class="post-text" itemprop="text">
<p><em>How can I ensure that output file is completely written and only then python code moves forward.</em></p>
<p>In general, if you want the processing to be reliable, you need to have the process writing the file send some sort of signal that it has successfully written the input file.  For example, it can start with the file having a name such a <code>datafile.copying</code>, then when it's complete rely upon the fact that most systems implement <code>rename()</code> atomically and <code>rename()</code> the file to <code>datafile</code>.  Your code won't process any file that has the <code>*.copying</code> pattern of a name.  Or, after successfully writing the file, the writing process can create a flag file called <code>filename.done</code> to signal that <code>filename</code> is, well, done copying.</p>
<p>In this case, since you spawn the child process, you need to not only (presumably) wait for the child process to finish, you also need to somehow determine that it ran successfully to completion.  Does the <code>metamap</code> process provide a return code that you can use?  Most utilities return <code>0</code> when they're successful and non-zero when they fail for some reason.</p>
<p>There's no other way to do it reliably.  Because there's no way without additional information that the reading process can know that the input file has been fully copied.  The writing process can fail halfway through writing the file - network connections can fail, for example.</p>
<p>Again - there's no other way to do this reliably.</p>
</div>
<div class="post-text" itemprop="text">
<p>In linux there is a set of events called <a href="http://man7.org/linux/man-pages/man7/inotify.7.html" rel="nofollow noreferrer">inotify</a> that you can use to detect if a file is being accessed by a process or not.
There's a python lib for accessing this called <a href="https://github.com/seb-m/pyinotify" rel="nofollow noreferrer">pyinotify</a>.</p>
<p>This blog post explains how to check a file with pyinotify.</p>
<p><a href="http://www.saltycrane.com/blog/2010/04/monitoring-filesystem-python-and-pyinotify/" rel="nofollow noreferrer">http://www.saltycrane.com/blog/2010/04/monitoring-filesystem-python-and-pyinotify/</a></p>
<p>Also, <code>lsof</code> might be an option, in which case you could use <a href="http://pythonhosted.org/psutil/index.html?highlight=lsof#psutil.Process.open_files" rel="nofollow noreferrer">http://pythonhosted.org/psutil/index.html?highlight=lsof#psutil.Process.open_files</a>.</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import psutil
&gt;&gt;&gt; f = open('file.test', 'w')
&gt;&gt;&gt; p = psutil.Process()
&gt;&gt;&gt; p.open_files()
[popenfile(path='/Users/username/file.test', fd=3)]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Can you please explain how you would do that in above code ?</span>
<span class="comment-copy">Since, you are saying that there is no reliable way of doing it. I am thinking in different direction now. In above question i posted, another way of thinking is to find out a way for python code to wait till output file generated is closed (in above case <b>temp_input.out</b> is closed). Can we do that reliably ?</span>
<span class="comment-copy">Although I have not actually implemented it but pynotify would give me notifications of events on filesystem. I want to my python program to wait till the external file is completely written and then move forward. How could pynotify help me in doing that ?</span>
<span class="comment-copy">With pynotify, you should be able to capture the event of when the file handle has been closed and at that point the process should be done writing to that file. If that can't be guaranteed then you would have to somehow notify, across the processes, that the file is done being written to.  Possibly writing a finished bit to the file or passing a message in a queue or some strategy like that.</span>
