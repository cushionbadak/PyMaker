<div class="post-text" itemprop="text">
<p>In an asynchronous program (e.g., asyncio, twisted etc.), all system calls must be non-blocking. That means a non-blocking <code>select</code> (or something equivalent) needs be executed in every iteration of the main loop. That seems more wasteful than the multi-threaded approach where each thread can use a blocking call and sleep (without wasting CPU resource) until the socket is ready.</p>
<p>Does this sometimes cause asynchronous programs to be slower than their multi-threaded alternatives (despite thread switching costs), or is there some mechanism that makes this not a valid concern?</p>
</div>
<div class="post-text" itemprop="text">
<p>When working with <code>select</code> in a single thread program, you do not have to continuously check the results. The right way to work with it is to let it block until the relevant I/O has arrived, just like in the case of multi threads.
However, instead of waiting for a single socket (or other I/O), the <code>select</code> call gets a list of relevant sockets, and blocks until any of them is interrupted.</p>
<p>Once that happens, <code>select</code> wakes-up and returns a list of the sockets (or I/Os) that are ready. It is up to the coder to handle those ready sockets in the required way, and then, if the code has nothing else to do, it might start another iteration of the <code>select</code>.</p>
<p>As you can see, no polling loop is required; the program does not require CPU resources until one or more of the required sockets are ready. Moreover, if a few sockets were ready almost together, then the code wakes-up once, handle all of them, and only then start <code>select</code> again. Add to that the fact that the program does not requires the resources overhead of a few threads, and you can see why this is more effective in terms of OS resources.</p>
</div>
<div class="post-text" itemprop="text">
<p>In my question I separated the I/O handling into two categories: polling represented by non-blocking <code>select</code>, and "callback" represented by the blocking <code>select</code>. (The blocking <code>select</code> sleeps the thread, so it's not strictly speaking a callback; but conceptually it is similar to a callback, since it doesn't use CPU cycles until the I/O is ready. Since I don't know the precise term, I'll just use "callback").</p>
<p>I assumed that asynchronous model cannot use "callback" I/O. It now seems to me that this assumption was incorrect. While an asynchronous program should not be using non-blocking <code>select</code>, and it cannot strictly request a traditional callback from the OS either, it can certainly provide OS with its main event loop and say a coroutine, and ask the OS to create a task in that event loop using that coroutine when an I/O socket is ready. This would not use any of the program's CPU cycles until the I/O is ready. (It might use OS kernel's CPU cycles if it uses polling rather than interrupts for I/O, but that would be the case even with a multi-threaded program.)</p>
<p>Of course, this requires that the OS supports the asynchronous framework used by the program. It probably doesn't. But even then, it seems quite straightforward to add an middle layer that uses a single separate thread and blocking <code>select</code> to talk to the OS, and whenever I/O is ready, creates a task to the program's main event loop. If this layer is included in the interpreter, the program would look perfectly asynchronous. If this layer is added as a library, the program would be largely asynchronous, apart from a simple additional thread that converts synchronous I/O to asynchronous I/O.</p>
<p>I have no idea whether any of this is done in python, but it seems plausible conceptually.</p>
</div>
<span class="comment-copy">But AFAIK <i>any</i> blocking call <a href="https://docs.python.org/3/library/asyncio-dev.html#handle-blocking-functions-correctly" rel="nofollow noreferrer">is unacceptable</a> in an asynchronous program because it would tie up the entire thread. What if another task needs to be done while you're waiting? It could be a task that was set start at a certain time, or a task to react to some other interrupt unrelated to the sockets you're monitoring in the <code>select</code> call.</span>
<span class="comment-copy">@max Of course, waiting on the <code>select</code> will only takes place if the program has nothing else to do. If there are other tasks to be done, then the program will use unblocking select, and will call it in a loop, after finishing the other stuff it has to do (of course, it should do it in small portions in order to react to a ready socket on a reasonable time). However, in this case there is no waste of CPU cycles - the program continues doing what it had to do. If there is nothing else left - it will again use the blocking form.</span>
<span class="comment-copy"><code>However, in this case there is no waste of CPU cycles - the program continues doing what it had to do.</code> I guess if <code>the other stuff it has to do</code> is big enough compared to the time <code>select</code> takes, it works well. Is it possible though that a nonblocking <code>select</code> call takes as much (or more) time than the real work done in each iteration of the main loop? Or there's some mechanism that makes it impossible?</span>
<span class="comment-copy">Non-blocking select should return immediately with the current state of each socket in the provided list. So what you have to make sure of is that it is being read in periods that are satisfying enough for you. For example, if a 0.01sec delay in reading a socket is OK for your application, make sure that the "other work" between each consecutive call to select takes less than 0.01sec.</span>
