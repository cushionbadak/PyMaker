<div class="post-text" itemprop="text">
<p>I'm working with some text in python, it's already in unicode format internally but I would like to get rid of some special characters and replace them with more standard versions.</p>
<p>I currently have a line that looks like this, but it's getting ever more complex and I see it will eventually bring more trouble.</p>
<pre><code>tmp = infile.lower().replace(u"\u2018", "'").replace(u"\u2019", "'").replace(u"\u2013", "").replace(u"\u2026", "")
</code></pre>
<p>for example the u\2018 and \u2019 are <a href="http://www.fileformat.info/info/unicode/char/2018/index.htm" rel="nofollow noreferrer">left</a> and <a href="http://www.fileformat.info/info/unicode/char/2019/index.htm" rel="nofollow noreferrer">right</a> single quotes. Those are somewhat acceptable but for this type of text processing I don't think they are needed.</p>
<p>Things like <a href="http://www.fileformat.info/info/unicode/char/2013/index.htm" rel="nofollow noreferrer">this</a> u\2013 EN DASH and <a href="http://www.fileformat.info/info/unicode/char/2026/index.htm" rel="nofollow noreferrer">this</a> HORIZONTAL ELLIPSIS are definitely not needed.</p>
<p>Is there a way to remove those quotation marks and use simple standard quotes that won't break text processing 'with nltk' and remove things like those EN DASH, HORIZONTAL ELLIPSIS without making such a monster call like I see starting to rear it's head in the sample code above?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your text is in English and you want to clean it up in a human-readable way, use the third-party module <a href="https://pypi.python.org/pypi/Unidecode" rel="nofollow noreferrer"><code>unidecode</code></a>. It replaces a wide range of characters with their nearest ascii look-alike. Just apply <code>unidecode.unidecode()</code> to any string to make the substitutions:</p>
<pre><code>from unidecode import unidecode
clean = unidecode(u'Some text: \u2018\u2019\u2013\u03a9')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need to do this kind of characters "normalisation" you may consider implementing a <strong>codec</strong> for the <a href="https://docs.python.org/3/library/codecs.html" rel="nofollow noreferrer">Codec registry</a>.</p>
<p>The implementation is similar as the one proposed by @RomanPerekhrest with a table of substitution characters.</p>
<h3>Implementing a codec</h3>
<p>Import the <code>codecs</code> module, give a name to your codec (avoid existing names).
Create the <strong>encoding</strong> table (the one you'll use when you do <code>u"something".encode(...)</code>:</p>
<pre><code>import codecs

NAME = "normalize"

_ENCODING_TABLE = {
    u'\u2002': u' ',
    u'\u2003': u' ',
    u'\u2004': u' ',
    u'\u2005': u' ',
    u'\u2006': u' ',
    u'\u2010': u'-',
    u'\u2011': u'-',
    u'\u2012': u'-',
    u'\u2013': u'-',
    u'\u2014': u'-',
    u'\u2015': u'-',
    u'\u2018': u"'",
    u'\u2019': u"'",
    u'\u201a': u"'",
    u'\u201b': u"'",
    u'\u201c': u'"',
    u'\u201d': u'"',
    u'\u201e': u'"',
    u'\u201f': u'"',
    }
</code></pre>
<p>The table above can "normalize" spaces, hyphens, quotation marks.
This is where normalisation rules go…</p>
<p>Then, implement the function used to normalize your string:</p>
<pre><code>def normalize_encode(input, errors='strict'):
    output = u''
    for char in input:
        output += _ENCODING_TABLE.get(char, char)
    return output, len(input)
</code></pre>
<p>You can also implement the decoding, but you need to reverse the <code>_ENCODING_TABLE</code>,
the best practice is to prepare the reversed table and fill the missing characters later.</p>
<pre><code>_DECODING_TABLE = {v: k for k, v in _ENCODING_TABLE.items()}
# missing characters...

def normalize_decode(input, errors='strict'):
    output = u''
    for char in input:
        output += _DECODING_TABLE.get(char, char)
    return output, len(input)
</code></pre>
<p>Now, everything is ready, you can implements the <strong>codec</strong> protocol:</p>
<pre><code>class Codec(codecs.Codec):
    def encode(self, input, errors='strict'):
        return normalize_encode(input, errors)

    def decode(self, input, errors='strict'):
        return normalize_decode(input, errors)


class IncrementalEncoder(codecs.IncrementalEncoder):
    def encode(self, input, final=False):
        assert self.errors == 'strict'
        return normalize_encode(input, self.errors)[0]


class IncrementalDecoder(codecs.IncrementalDecoder):
    def decode(self, input, final=False):
        assert self.errors == 'strict'
        return normalize_decode(input, self.errors)[0]


class StreamWriter(Codec, codecs.StreamWriter):
    pass


class StreamReader(Codec, codecs.StreamReader):
    pass


def getregentry():
    return codecs.CodecInfo(name=NAME,
                            encode=normalize_encode,
                            decode=normalize_decode,
                            incrementalencoder=IncrementalEncoder,
                            incrementaldecoder=IncrementalDecoder,
                            streamreader=StreamReader,
                            streamwriter=StreamWriter)
</code></pre>
<p>How to register the newly created codec?</p>
<p>If you have several normalisation codecs, the best practice is to gather
them in the <code>__init__.py</code> file of a dedicated package
(for instance: <code>my_app.encodings</code>.</p>
<pre><code># -*- coding: utf-8 -*-
import codecs

import normalize


def search_function(encoding):
    if encoding == normalize.NAME:
        return normalize.getregentry()
    return None


# Register the search_function in the Python codec registry
codecs.register(search_function)
</code></pre>
<p>Whenever you need your codec, you write:</p>
<pre><code>import my_app.encodings

normalize = my_app.encodings.normalize.NAME

def my_function():
    normalized = my_string.encode(normalize)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The unified solution would be using a predefined dict of replacement pairs. Such a dict can be easily extended(modified). <br/>The solution using <code>re.complile</code> and <code>re.sub</code> functions:</p>
<pre><code>import re

d = {
    u"\u2018" : "'", u"\u2019" : "'", u"\u2013" : "", u"\u2026" : ""
}

pattern = re.compile(r'(' + '|'.join(re.escape(k) for k in d.keys()) + ')')
replaced = pattern.sub(lambda c: d[c.group()], infile.lower())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the built-in string method <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer">translate</a>.  It takes a dictionary of Unicode ordinals as keys and translates to the values, which can be Unicode ordinals, strings or None.  The value None deletes characters:</p>
<pre><code>sample = '\u2018hello\u2019\u2013there\u2026'
print(sample)
replacements = { 0x2018 : "'",
                 0x2019 : "'",
                 0x2013 : '-',
                 0x2026 : '...' }
print(sample.translate(replacements))
</code></pre>
<p>Output:</p>
<pre><code>‘hello’–there…
'hello'-there...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer">re.sub</a> will do it too:</p>
<pre><code>import re
tmp = re.sub(u'\u2019|\u2018', '\'', infile.lower())
tmp = re.sub(u'\u2013|\u2026', '', tmp)
</code></pre>
</div>
<span class="comment-copy">how do you get this text ? did you <code>decode()</code> it ? do you see this code when you use <code>print()</code> ?</span>
<span class="comment-copy">Overkill.  Use <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer">translate</a>.</span>
<span class="comment-copy">Reinventing the wheel. Use <code>unidecode</code> instead of an ad hoc substitution table.</span>
<span class="comment-copy">Make this approach more robust by escaping the keys in <code>d</code> with <code>re.escape()</code> before compiling the pattern. Otherwise, for example, adding the entry <code>".": ""</code> to <code>d</code> will delete the entire input.</span>
<span class="comment-copy">@lenz, ok, done it</span>
