<div class="post-text" itemprop="text">
<p>I wanted to compare different to build a string in Python from different variables:</p>
<ul>
<li>using <code>+</code> to concatenate (referred to as 'plus')</li>
<li>using <code>%</code></li>
<li>using <code>"".join(list)</code></li>
<li>using <code>format</code> function</li>
<li>using <code>"{0.&lt;attribute&gt;}".format(object)</code></li>
</ul>
<p>I compared for 3 types of scenari</p>
<ul>
<li>string with 2 variables</li>
<li>string with 4 variables</li>
<li>string with 4 variables, each used twice</li>
</ul>
<p>I measured 1 million operations of each time and performed an average over 6 measures. I came up with the following timings:</p>
<p><a href="https://i.stack.imgur.com/zDFk1.png" rel="noreferrer"><img alt="Timings" src="https://i.stack.imgur.com/zDFk1.png"/></a></p>
<p>In each scenario, I came up with the following conclusion</p>
<ul>
<li>Concatenation seems to be one of the fastest method</li>
<li>Formatting using <code>%</code> is much faster than formatting with <code>format</code> function </li>
</ul>
<p>I believe <code>format</code> is much better than <code>%</code> (e.g. in <a href="https://stackoverflow.com/questions/5082452/python-string-formatting-vs-format">this question</a>) and <code>%</code> was almost deprecated. </p>
<p>I have therefore several questions:</p>
<ol>
<li>Is <code>%</code> really faster than <code>format</code>?</li>
<li>If so, why is that?</li>
<li>Why is <code>"{} {}".format(var1, var2)</code> more efficient than <code>"{0.attribute1} {0.attribute2}".format(object)</code>?</li>
</ol>
<hr/>
<p>For reference, I used the following code to measure the different timings.</p>
<pre><code>import time
def timing(f, n, show, *args):
    if show: print f.__name__ + ":\t",
    r = range(n/10)
    t1 = time.clock()
    for i in r:
        f(*args); f(*args); f(*args); f(*args); f(*args); f(*args); f(*args); f(*args); f(*args); f(*args)
    t2 = time.clock()
    timing = round(t2-t1, 3)
    if show: print timing
    return timing


#Class
class values(object):
    def __init__(self, a, b, c="", d=""):
        self.a = a
        self.b = b
        self.c = c
        self.d = d


def test_plus(a, b):
    return a + "-" + b

def test_percent(a, b):
    return "%s-%s" % (a, b)

def test_join(a, b):
    return ''.join([a, '-', b])

def test_format(a, b):
    return "{}-{}".format(a, b)

def test_formatC(val):
    return "{0.a}-{0.b}".format(val)


def test_plus_long(a, b, c, d):
    return a + "-" + b + "-" + c + "-" + d

def test_percent_long(a, b, c, d):
    return "%s-%s-%s-%s" % (a, b, c, d)

def test_join_long(a, b, c, d):
    return ''.join([a, '-', b, '-', c, '-', d])

def test_format_long(a, b, c, d):
    return "{0}-{1}-{2}-{3}".format(a, b, c, d)

def test_formatC_long(val):
    return "{0.a}-{0.b}-{0.c}-{0.d}".format(val)


def test_plus_long2(a, b, c, d):
    return a + "-" + b + "-" + c + "-" + d + "-" + a + "-" + b + "-" + c + "-" + d

def test_percent_long2(a, b, c, d):
    return "%s-%s-%s-%s-%s-%s-%s-%s" % (a, b, c, d, a, b, c, d)

def test_join_long2(a, b, c, d):
    return ''.join([a, '-', b, '-', c, '-', d, '-', a, '-', b, '-', c, '-', d])

def test_format_long2(a, b, c, d):
    return "{0}-{1}-{2}-{3}-{0}-{1}-{2}-{3}".format(a, b, c, d)

def test_formatC_long2(val):
    return "{0.a}-{0.b}-{0.c}-{0.d}-{0.a}-{0.b}-{0.c}-{0.d}".format(val)


def test_plus_superlong(lst):
    string = ""
    for i in lst:
        string += str(i)
    return string


def test_join_superlong(lst):
    return "".join([str(i) for i in lst])


def mean(numbers):
    return float(sum(numbers)) / max(len(numbers), 1)


nb_times = int(1e6)
n = xrange(5)
lst_numbers = xrange(1000)
from collections import defaultdict
metrics = defaultdict(list)
list_functions = [
    test_plus, test_percent, test_join, test_format, test_formatC,
    test_plus_long, test_percent_long, test_join_long, test_format_long, test_formatC_long,
    test_plus_long2, test_percent_long2, test_join_long2, test_format_long2, test_formatC_long2,
    # test_plus_superlong, test_join_superlong,
]
val = values("123", "456", "789", "0ab")
for i in n:
    for f in list_functions:
        print ".",
        name = f.__name__
        if "formatC" in name:
            t = timing(f, nb_times, False, val)
        elif '_long' in name:
            t = timing(f, nb_times, False, "123", "456", "789", "0ab")
        elif '_superlong' in name:
            t = timing(f, nb_times, False, lst_numbers)
        else:
            t = timing(f, nb_times, False, "123", "456")
        metrics[name].append(t) 

#Get Average
print "\n===AVERAGE OF TIMINGS==="
for f in list_functions:
    name = f.__name__
    timings = metrics[name]
    print "{:&gt;20}:\t{:0.5f}".format(name, mean(timings))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Yes, <code>%</code> string formatting is faster than the <code>.format</code> method</li>
<li>most likely (this may have a much better explanation) due to <code>%</code> being a syntactical notation (hence fast execution), whereas <code>.format</code> involves <em>at least</em> one extra method call</li>
<li>because attribute value access also involves an extra method call, viz. <code>__getattr__</code></li>
</ol>
<p>I ran a slightly better analysis (on Python 3.6.0) using <code>timeit</code> of various formatting methods, results of which are as follows (pretty-printed with <a href="http://beautifultable.readthedocs.io/en/latest/" rel="nofollow noreferrer">BeautifulTable</a>) -</p>
<pre>
+-----------------+-------+-------+-------+-------+-------+--------+
| Type \ num_vars |   1   |   2   |   5   |  10   |  50   |  250   |
+-----------------+-------+-------+-------+-------+-------+--------+
|    f_str_str    | 0.306 | 0.064 | <b>0.106</b> | <b>0.183</b> | <b>0.737</b> | <b>3.422</b>  |
+-----------------+-------+-------+-------+-------+-------+--------+
|    f_str_int    | 0.295 | 0.174 | 0.385 | 0.686 | 3.378 | 16.399 |
+-----------------+-------+-------+-------+-------+-------+--------+
|   concat_str    | 0.012 | <b>0.053</b> | 0.156 | 0.31  | 1.707 | 16.762 |
+-----------------+-------+-------+-------+-------+-------+--------+
|    pct_s_str    | <b>0.056</b> | 0.178 | 0.275 | 0.469 | 1.872 | 9.191  |
+-----------------+-------+-------+-------+-------+-------+--------+
|    pct_s_int    | 0.128 | 0.208 | 0.343 | 0.605 | 2.483 | 13.24  |
+-----------------+-------+-------+-------+-------+-------+--------+
| dot_format_str  | 0.418 | 0.217 | 0.343 | 0.58  | 2.241 | 11.163 |
+-----------------+-------+-------+-------+-------+-------+--------+
| dot_format_int  | 0.416 | 0.277 | 0.476 | 0.811 | 3.378 | 17.829 |
+-----------------+-------+-------+-------+-------+-------+--------+
| dot_format2_str | 0.433 | 0.242 | 0.416 | 0.675 | 3.152 | 16.783 |
+-----------------+-------+-------+-------+-------+-------+--------+
| dot_format2_int | 0.428 | 0.298 | 0.541 | 0.933 | 4.444 | 24.767 |
+-----------------+-------+-------+-------+-------+-------+--------+
</pre>
<p>The trailing <code>_str</code> &amp; <code>_int</code> represent the operation was carried out on respective value types.</p>
<p><strong>Kindly note</strong> that the <code>concat_str</code> result for a single variable is essentially just the string itself, so it shouldn't really be considered.</p>
<p>My setup for arriving at the results -</p>
<pre><code>from timeit import timeit
from beautifultable import BeautifulTable  # pip install beautifultable

times = {}

for num_vars in (1, 2, 5, 10, 50, 250):
    f_str = "f'{" + '}{'.join([f'x{i}' for i in range(num_vars)]) + "}'"
    # "f'{x0}{x1}"
    concat = '+'.join([f'x{i}' for i in range(num_vars)])
    # 'x0+x1'
    pct_s = '"' + '%s'*num_vars + '" % (' + ','.join([f'x{i}' for i in range(num_vars)]) + ')'
    # '"%s%s" % (x0,x1)'
    dot_format = '"' + '{}'*num_vars + '".format(' + ','.join([f'x{i}' for i in range(num_vars)]) + ')'
    # '"{}{}".format(x0,x1)'
    dot_format2 = '"{' + '}{'.join([f'{i}' for i in range(num_vars)]) + '}".format(' + ','.join([f'x{i}' for i in range(num_vars)]) + ')'
    # '"{0}{1}".format(x0,x1)'

    vars = ','.join([f'x{i}' for i in range(num_vars)])
    vals_str = tuple(map(str, range(num_vars)))
    setup_str = f'{vars} = {vals_str}'
    # "x0,x1 = ('0', '1')"
    vals_int = tuple(range(num_vars))
    setup_int = f'{vars} = {vals_int}'
    # 'x0,x1 = (0, 1)'

    times[num_vars] = {
        'f_str_str': timeit(f_str, setup_str),
        'f_str_int': timeit(f_str, setup_int),
        'concat_str': timeit(concat, setup_str),
        # 'concat_int': timeit(concat, setup_int), # this will be summation, not concat
        'pct_s_str': timeit(pct_s, setup_str),
        'pct_s_int': timeit(pct_s, setup_int),
        'dot_format_str': timeit(dot_format, setup_str),
        'dot_format_int': timeit(dot_format, setup_int),
        'dot_format2_str': timeit(dot_format2, setup_str),
        'dot_format2_int': timeit(dot_format2, setup_int),
    }

table = BeautifulTable()
table.column_headers = ['Type \ num_vars'] + list(map(str, times.keys()))
# Order is preserved, so I didn't worry much
for key in ('f_str_str', 'f_str_int', 'concat_str', 'pct_s_str', 'pct_s_int', 'dot_format_str', 'dot_format_int', 'dot_format2_str', 'dot_format2_int'):
    table.append_row([key] + [times[num_vars][key] for num_vars in (1, 2, 5, 10, 50, 250)])
print(table)
</code></pre>
<p>I couldn't go beyond <code>num_vars=250</code> because of some max arguments (255) limit with <code>timeit</code>.</p>
<p><strong>tl;dr</strong> - Python string formatting performance : <code>f-strings</code> are fastest and more elegant, but at times (due to some <a href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals" rel="nofollow noreferrer">implementation restrictions</a> &amp; being Py3.6+ only), you might have to use other formatting options as necessary.</p>
</div>
<span class="comment-copy">Use <code>timeit</code> instead of your custom function, it might that the first execution is slow but the subsequent function execution are faster but in reality you would only call the function once. <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer">docs.python.org/2/library/timeit.html</a></span>
<span class="comment-copy">As mentioned by @MaximilianPeters you should be using <code>timeit</code> for getting the trust-worthy results</span>
<span class="comment-copy">Thanks guys. I checked <code>timeit</code> but I should have been high that day because I believed it was only supported on Python 3.x and I am mainly using 2.7.</span>
<span class="comment-copy">Consider adding <a href="https://docs.python.org/3.6/whatsnew/3.6.html#pep-498-formatted-string-literals" rel="nofollow noreferrer">f-strings</a> to you analysis from Python 3.6.  It would be interesting to compare those results too.  Nice code!</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/1316887/what-is-the-most-efficient-string-concatenation-method-in-python/">related</a></span>
<span class="comment-copy">Python: where it's OK to build strings to use to do timing tests on various methods for building strings... and then import an external library that builds a custom object with it's own <code>__str__</code> that builds a string (and likely building that string out of strings that build strings within the process) out of all the results of your timing tests.</span>
