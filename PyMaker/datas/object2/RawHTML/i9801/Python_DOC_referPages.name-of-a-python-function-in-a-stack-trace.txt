<div class="post-text" itemprop="text">
<p>In both Python2 and Python3, in the stack trace the <code>__name__</code> of a function is not used, the original name (the one that is specified after <code>def</code>) is used instead.</p>
<p>Consider the example:</p>
<pre><code>import traceback

def a():
    return b()

def b():
    return c()

def c():
    print("\n".join(line.strip() for line in traceback.format_stack()))

a.__name__ = 'A'
b.__name__ = 'B'
c.__name__ = 'C'

a();
</code></pre>
<p>The output is:</p>
<pre><code>File "test.py", line 16, in &lt;module&gt;
    a();
File "test.py", line 4, in a
    return b()
File "test.py", line 7, in b
    return c()
File "test.py", line 10, in c
    print("\n".join(line.strip() for line in traceback.format_stack()))
</code></pre>
<p>Why so? How do I change the name that is used in the stack trace? Where is the <code>__name__</code> attribute used then?</p>
</div>
<div class="post-text" itemprop="text">
<p>So, basically every function has three things that can be considered being <em>name</em> of the function:</p>
<h3>The original name of the code block</h3>
<p>It's stored in the <code>f.__code__.co_name</code> (where <code>f</code> is the function object). If you use <code>def orig_name</code> to create function, <code>orig_name</code> is that name. For lambas it's <code>&lt;lambda&gt;</code>.</p>
<p>This attribute is readonly and can't be changed. So the only way to create function with the custom name in runtime I'm aware of is <code>exec</code>:</p>
<pre><code>exec("""def {name}():
  print '{name}'
""".format(name='any')) in globals()

any()  # prints 'any'
</code></pre>
<p>(There is also more low-level <a href="https://stackoverflow.com/questions/16064409/how-to-create-a-code-object-in-python">way to do this</a> that was mentioned in a comment to the question.)</p>
<p>The immutability of <code>co_name</code> actually makes sense: with that you can be sure that the name you see in the debugger (or just stack trace) is exactly the same you see in the source code (along with the filename and line number).</p>
<h3>The <code>__name__</code> attribute of the function object</h3>
<p>It's also aliased to <code>func_name</code>.</p>
<p>You can modify it (<code>orig_name.__name__ = 'updated name'</code>) and you surely do on a daily basis: <a href="https://docs.python.org/2/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>@functools.wraps</code></a> copies the <code>__name__</code> of the decorated function to the new one.</p>
<p><code>__name__</code> is used by tools like <code>pydoc</code>, that's why you need <code>@functools.wraps</code>: so you don't see the technical details of every decorator in your documentation. Look at the example:</p>
<pre><code>from functools import wraps

def decorator1(f):
    def decorated(*args, **kwargs):
        print 'start1'
        f(*args, **kwargs)
    return decorated

def decorator2(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        print 'start2'
        f(*args, **kwargs)
    return decorated

@decorator1
def test1():
    print 'test1'

@decorator2
def test2():
    print 'test2'
</code></pre>
<p>Here is the <code>pydoc</code> output:</p>
<pre><code>FUNCTIONS
    decorator1(f)

    decorator2(f)

    test1 = decorated(*args, **kwargs)

    test2(*args, **kwargs)
</code></pre>
<p>With <code>wraps</code> there is no sign of <code>decorated</code> in the documentation.</p>
<h3>Name of the reference</h3>
<p>One more thing that can be called <em>function name</em> (though it hardly is) is the name of a variable or an attribute where reference to that function is stored.</p>
<p>If you create function with <code>def name</code>, the <code>name</code> attribute will be added to the current scope. In case of <code>lambda</code> you should assign the result to some variable: <code>name = lambda: None</code>.</p>
<p>Obviously you can create more than one reference to the same function and all that references can have different names.</p>
<hr/>
<p>The only way all that three things are connected to each other is the <code>def foo</code> statement that creates function object with both <code>__name__</code> and <code>__code__.co_name</code> equal to <code>foo</code> and assign it to the <code>foo</code> attribute of the current scope. But they are not bound in any way and can be different from each other:</p>
<pre><code>import traceback                             

def make_function():                         
    def orig_name():                         
        """Docstring here                    
        """                                  
        traceback.print_stack()              
    return orig_name                         

globals()['name_in_module'] = make_function()
name_in_module.__name__ = 'updated name'     

name_in_module()                             
</code></pre>
<p>Output:</p>
<pre><code>  File "my.py", line 13, in &lt;module&gt;
    name_in_module()
  File "my.py", line 7, in orig_name
    traceback.print_stack()
</code></pre>
<p>Pydoc:</p>
<pre><code>FUNCTIONS
    make_function()

    name_in_module = updated name()
        Docstring here
</code></pre>
<hr/>
<p><em>I thank other people for comments and answers, they helped me to organize my thoughts and knowledge</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Tried to explore the <a href="https://github.com/python/cpython" rel="nofollow noreferrer">CPython</a> implementation, definitely not an expert. As pointed out in the comments, when the stack entry of f is printed, the attribute <code>f.__code__.co_name</code> <a href="https://github.com/python/cpython/blob/master/Lib/traceback.py#L342" rel="nofollow noreferrer">is used</a>. Also, <code>f.__name__</code> <a href="https://github.com/python/cpython/blob/4106e4237df5397efc785ce4daa257aecb5bff75/Objects/funcobject.c#L30" rel="nofollow noreferrer">is initially set</a> to <code>f.__code__.co_name</code>, <a href="https://github.com/python/cpython/blob/4106e4237df5397efc785ce4daa257aecb5bff75/Objects/funcobject.c#L285" rel="nofollow noreferrer">but when you modify</a> the former, the latter is not modified accordingly.</p>
<p>Therefore, I tried to modify that directly, but it is not possible:</p>
<pre><code>&gt;&gt;&gt; f.__code__.co_name = 'g'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: readonly attribute
&gt;&gt;&gt;
</code></pre>
<p>Why are there two ways to say a function's name? Well, <a href="https://docs.python.org/3/library/stdtypes.html#definition.__name__" rel="nofollow noreferrer">according to the documentation</a>, <code>__name__</code> is defined for "class, function, method, descriptor, or generator instance", so in the case of functions it maps to that attribute, for other objects it will map to something else.</p>
</div>
<span class="comment-copy">a.__name__ seems to be an alias for a.func_name. Neither of them seems to be used by the stack trace.</span>
<span class="comment-copy">The code object of a function also stores the name but that property is read-only. And I think that is the property that is used in the traceback. To change that name you would need to recreate the code object from its properties and assign it back to the code property of the function object. See <a href="http://stackoverflow.com/questions/16064409/how-to-create-a-code-object-in-python" title="how to create a code object in python">stackoverflow.com/questions/16064409/â€¦</a></span>
<span class="comment-copy">That's interesting - it looks like it's using the code object's name, <code>a.__code__.co_name</code>, instead of the function object's name.</span>
<span class="comment-copy">@hivert <code>func_name</code> is indeed a <code>__name__</code> alias, it's clearly documented: <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">docs.python.org/2/library/inspect.html</a></span>
<span class="comment-copy">@DanD. I would even be OK with creating new function with the dynamic name, but I don't know how to do it (save <code>eval</code>)</span>
<span class="comment-copy">So, what about <code>__name__</code>? How is it used?</span>
<span class="comment-copy">"it is never modified by CPython" - no, it totally is. You're just looking for the wrong things. Heck, if you only looked for direct references to <code>long_add</code>, it'd look like CPython never adds integers. Off the top of my head, <code>functools.wraps</code> sets a function's <code>__name__</code>, and <code>functools.wraps</code> is used in a number of places in the CPython source code.</span>
<span class="comment-copy">@user2357112 interesting, I totally didn't expect that. Removed from answer</span>
