<div class="post-text" itemprop="text">
<p>I have two list that I want to zip:</p>
<pre><code>a = ((1,2,3), (4,5,6), ... )
h = ('a','b', ... )
</code></pre>
<p>A simple <code>zip(a,h)</code> returns this:</p>
<pre><code>[ ((1,2,3),'a'), ((4,5,6),'b'), ... ]
</code></pre>
<p>Is there any clever way to return this?</p>
<pre><code>[ (1,2,3,'a'), (4,5,6,'b'), ... ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use tuple concatenation in a list comprehension:</p>
<pre><code>&gt;&gt;&gt; a = ((1, 2, 3), (4, 5, 6))
&gt;&gt;&gt; h = ('a', 'b')
&gt;&gt;&gt; [x + (y,) for x, y in zip(a, h)]
[(1, 2, 3, 'a'), (4, 5, 6, 'b')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using python 3.5 or higher, you can use the <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="noreferrer">additional unpacking generalizations (PEP 448)</a>: </p>
<pre><code>    In [24]: [(*one,two) for one, two in zip(((1, 2, 3), (4, 5, 6)) ,('a','b'))]
    Out[24]: [(1, 2, 3, 'a'), (4, 5, 6, 'b')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a "nested" tuple destructuring:</p>
<pre><code>a = ((1, 2, 3), (4, 5, 6))
h = ('a', 'b')
out = [(x, y, z, c) for (x, y, z), c in zip(a, h)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution if <code>a</code> items' length is fixed to 3:</p>
<pre><code>a = ((1, 2, 3), (4, 5, 6))
h = ('a', 'b')

[(x[0], x[1], x[2], y) for x, y in zip(a, h)] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may use chain from itertools:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; a = ((1,2,3), (4,5,6), (7,8,9) )
&gt;&gt;&gt; h = ('a','b', 'c' )
&gt;&gt;&gt; [ tuple(chain(x,y)) for x,y in zip(a,h) ]
[(1, 2, 3, 'a'), (4, 5, 6, 'b'), (7, 8, 9, 'c')]
</code></pre>
</div>
<span class="comment-copy">Definitely not the best way, but probably the shortest: <code>zip(*(zip(*a)+[h]))</code></span>
<span class="comment-copy">Uch. Of course. Thank you.</span>
<span class="comment-copy">Yeah that's what I tried. But <code>SyntaxError</code></span>
<span class="comment-copy">Works only with Python 3.4+</span>
<span class="comment-copy">ah yes, my ipython defaults to 3.x</span>
<span class="comment-copy">@Daniel: <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="nofollow noreferrer">Python 3.5+</a> perhaps?</span>
<span class="comment-copy">Clever. Thank you.</span>
<span class="comment-copy">But this assumes <code>a</code> will hold tuples of only 3 elements</span>
<span class="comment-copy">@MoinuddinQuadri I believe that is a fair assumption to make given the OPs question. If you are dealing with a list of tuples of different lengths or with tuples with more than five or so elements, eugene y's answer is the way to go.</span>
<span class="comment-copy">@pzp I would also mark this one as correct, but the other guy was faster. They're both good solutions.</span>
<span class="comment-copy">This relies on elements of <code>h</code> being iterable. Try <code>h = ('a', 'b', 3)</code> for example.</span>
