<div class="post-text" itemprop="text">
<p>I have a data structure L = [(int, dict{key: values}), (int,dict{key: values})...].</p>
<p>Given an input list [0,1] I want to find <strong><em>any</em></strong> dictionary key where both/all values of the input list [0,1] exist.</p>
<p>Currently, my bug is that if I use input_list = [0,1], the function will return a match where the dictionary values are just [0] and where values are [0,1]. Only this second result is desirable. I feel like this is a minute change, but I can't grasp it. What do I change to make this happen?</p>
<p><strong>Code</strong></p>
<pre><code>#Python3
L = [(0, {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4]}), (1, {0: [1, 0], 1: [1], 2: [5, 1, 2,], 3: [1, 3], 4: [1, 4]}), (2, {0: [2, 0], 1: [2, 1], 2: [2], 3: [2, 3], 4: [2, 4]}), (3, {0: [3, 0], 1: [3, 1], 2: [3, 2], 3: [3], 4: [3, 4]}), (4, {0: [4, 0], 1: [4, 1], 2: [4, 2], 3: [4, 3], 4: [4]})]

#input_list = (eval(input('Enter your list: ')))
#input_list = ([0,1])
print('Input: ' + str(input_list))
for tupl in L:
    dict_a = (tupl[1])
    matching_key = ([key for key, value in dict_a.items() if all(v in input_list for v in value)])
    print('Node: ' + str(tupl[0]) + ' Match at key(s): ' + str(matching_key))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>L = [(0, {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4]}), (1, {0: [1, 0], 1: [1], 2: [5, 1, 2,], 3: [1, 3], 4: [1, 4]}), (2, {0: [2, 0], 1: [2, 1], 2: [2], 3: [2, 3], 4: [2, 4]}), (3, {0: [3, 0], 1: [3, 1], 2: [3, 2], 3: [3], 4: [3, 4]}), (4, {0: [4, 0], 1: [4, 1], 2: [4, 2], 3: [4, 3], 4: [4]})]

Enter your list: [0,1]
Input: [0, 1]
Node: 0 Match at key(s): [0, 1]
Node: 1 Match at key(s): [0, 1]
Node: 2 Match at key(s): []
Node: 3 Match at key(s): []
Node: 4 Match at key(s): []

Enter your list: [1,5,2]
Input: [1, 5, 2]
Node: 0 Match at key(s): []
Node: 1 Match at key(s): [1, 2]
Node: 2 Match at key(s): [1, 2]
Node: 3 Match at key(s): []
Node: 4 Match at key(s): []
</code></pre>
<p>Thank you:)</p>
</div>
<div class="post-text" itemprop="text">
<p>You have the code checking if <code>value</code> contains all the items in <code>input_list</code> the wrong way around. <code>all(v in input_list for v in value)</code> checks that all the items in <code>value</code> can be found from <code>input_list</code>. If you change it the other way around it will work as you expected:</p>
<pre><code>all(v in value for v in input_list)
</code></pre>
<p>Note that if you would convert <code>input_list</code> to <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set</code></a> you could easily check if <code>input_list</code> is a subset of <code>value</code>. That would be easier to understand and more efficient:</p>
<pre><code>L = [(0, {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4]}), (1, {0: [1, 0], 1: [1], 2: [5, 1, 2,], 3: [1, 3], 4: [1, 4]}), (2, {0: [2, 0], 1: [2, 1], 2: [2], 3: [2, 3], 4: [2, 4]}), (3, {0: [3, 0], 1: [3, 1], 2: [3, 2], 3: [3], 4: [3, 4]}), (4, {0: [4, 0], 1: [4, 1], 2: [4, 2], 3: [4, 3], 4: [4]})]

input_list = set([0,1])

for tupl in L:
    dict_a = tupl[1]
    matching_key = [key for key, value in dict_a.items() if input_list &lt;= set(value)]
    print('Node: ' + str(tupl[0]) + ' Match at key(s): ' + str(matching_key))
</code></pre>
<p>Output:</p>
<pre><code>Node: 0 Match at key(s): [1]
Node: 1 Match at key(s): [0]
Node: 2 Match at key(s): []
Node: 3 Match at key(s): []
Node: 4 Match at key(s): []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use set subtraction to solve:</p>
<pre><code>#Python3
L = [(0, {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4]}), (1, {0: [1, 0], 1: [1], 2: [5, 1, 2,], 3: [1, 3], 4: [1, 4]}), (2, {0: [2, 0], 1: [2, 1], 2: [2], 3: [2, 3], 4: [2, 4]}), (3, {0: [3, 0], 1: [3, 1], 2: [3, 2], 3: [3], 4: [3, 4]}), (4, {0: [4, 0], 1: [4, 1], 2: [4, 2], 3: [4, 3], 4: [4]})]

input_list = (eval(input('Enter your list: ')))
#input_list = [1,5,2]
print('Input: ' + str(input_list))
for tupl in L:
    dict_a = (tupl[1])
    matching_key = []
    for key, lst in tupl[1].items():
        if not (set(lst) - set(input_list)):
            matching_key.append(key)
    print('Node: ' + str(tupl[0]) + ' Match at key(s): ' + str(matching_key))
</code></pre>
<p>And I would recommend you to avoid constructions like this <code>[key for key, value in dict_a.items() if all(v in input_list for v in value)]</code> because it confuses, it makes your code hard to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please read:</p>
<p><a href="https://stackoverflow.com/questions/9623114/check-if-two-unordered-lists-are-equal">Check if two unordered lists are equal</a>
and <a href="https://stackoverflow.com/questions/36420022/how-can-i-compare-two-ordered-lists-in-python">How can I compare two ordered lists in python?</a></p>
<p>Depending on the semantics you want to use when checking for equality you can use one solution or the other. If you are going for a simple ordered list comparison, I would go with:</p>
<pre><code>for tupl in L:
    dict_a = (tupl[1])
    if dict_a != input_list:
        continue
    print('Node: ' + str(tupl[0]) + ' Match at key(s): ' + str(matching_key))
</code></pre>
</div>
<span class="comment-copy">Do you actually want <code>input_list == value</code>?  Or if <code>value</code> contains all items in <code>input_list</code>?</span>
<span class="comment-copy">Thank you! This worked perfectly. I see what you did, good lesson</span>
<span class="comment-copy">How would you edit this to improve readability, and keep it efficient? (in reference to niemmi's sollution)</span>
<span class="comment-copy">I think Niemmi's solution is pretty good. Sometimes it's better to avoid expressions like <code>[key for key, value in dict_a.items() if input_list &lt;= set(value)]</code>. They are readable though but also they may confuse especially if you want to make some changes in your scipt. The other disadvantage is if you have an error in a line like <code>[key for key, value in dict_a.items() if input_list &lt;= set(value)]</code> you don't know exactly which operation led to the exception. But if you do as I showed, the traceback will show you the exact line with the error.</span>
<span class="comment-copy"><code>dict_a</code> is a dictionary, when would it be equal to a list?</span>
<span class="comment-copy">oops, my bad. Then we would go back to:</span>
<span class="comment-copy">oops again, we would go back to:     for tupl in L:         dict_a = (tupl[1])         matching_key = ([key for key, value in dict_a.items() if v == iinput_list ])         print('Node: ' + str(tupl[0]) + ' Match at key(s): ' + str(matching_key))</span>
