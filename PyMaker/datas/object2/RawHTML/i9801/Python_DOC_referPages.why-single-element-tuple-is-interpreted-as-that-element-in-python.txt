<div class="post-text" itemprop="text">
<p>Could anyone explain why single element tuple is interpreted as that element in Python?</p>
<p>And</p>
<p>Why don't they just print the tuple <code>(1,)</code> as <code>(1)</code>?</p>
<p>See the examples below:</p>
<pre><code>&gt;&gt;&gt; (1)
1
&gt;&gt;&gt; ((((1))))
1
&gt;&gt;&gt; print(1,)
1
&gt;&gt;&gt; print((1,))
(1,)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A single element tuple is never treated as the contained element. Parentheses are mostly useful for grouping, not for creating tuples; a comma does that.</p>
<blockquote>
<p>Why don't they just print (1,) as (1)?</p>
</blockquote>
<p>Probably because printing a builtin container type gives a representation that can be used to recreate the container object via , say <code>eval</code>:</p>
<p>The docs for <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__</code></a> provides some clarity on this:</p>
<blockquote>
<p>If at all possible, this should look like a valid Python expression
  that could be used to recreate an object with the same value</p>
</blockquote>
<p>Answering your question, <code>(1)</code> is just integer <code>1</code> with a grouping parenthesis. In order to recreate the singleton tuple via its representation, it has to be printed as <code>(1,)</code> which is the valid syntax for creating the tuple.</p>
<pre><code>&gt;&gt;&gt; t = '(1,)'
&gt;&gt;&gt; i = '(1)'
&gt;&gt;&gt; eval(t)
(1,) # tuple
&gt;&gt;&gt; eval(i)
1    # int
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because only <code>(1, )</code> in your examples is tuple. The rest are expressions.</p>
<pre><code>In [4]: type(1,)
Out[4]: int

In [5]: type((1,))
Out[5]: tuple

In [6]: type((1))
Out[6]: int
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's because <code>(1)</code> is not a tuple. <code>(1)</code> is <code>1</code> with parentheses surrounding it. As the python documentation states</p>
<blockquote>
<p>it is the comma, not the parentheses, that define the tuple.</p>
</blockquote>
<p><a href="https://wiki.python.org/moin/TupleSyntax" rel="nofollow noreferrer">Source</a></p>
<p>The only tuple without a comma is a 0-tuple, which is <code>()</code>. Note, you can check this by running <code>type((1))</code> and seeing that it returns <code>&lt;type 'int'&gt;</code> not <code>&lt;type 'tuple'&gt;</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>(1)</code> is not a tuple, it's just parentheses around a number.  This is because sometimes you want to use parentheses to indicate order of operations, for example: (x+y)*z.  This obviously doesn't refer to a tuple containing <code>x+y</code>, it's just to show that the addition should happen before the multiplication.</p>
<p><code>(((1)))</code> is not a tuple for the same reason, the parentheses are just saying "evaluate what's inside before moving on".</p>
<p><code>print(1,)</code> is just calling the print function on the number 1.  When calling a function, a trailing comma is allowed. However, in python2, this will probably pring <code>(1,)</code>, because <code>print</code> isn't a function.</p>
<p><code>print((1,))</code> is the only thing that prints a tuple, because we are now actually passing a tuple into the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is very detailed <a href="https://stackoverflow.com/a/40710247/1398479">answer</a> from @Ray Total</p>
<blockquote>
<p>Sure, in general parentheses don't change the meaning of an expression. For example you can say 4+(1) and it will be 5, the same way 4*(2-1) would be 4. Because the convention is to use parentheses for grouping of subexpressions, the designer of Python thought it would be too confusing to overload the meaning to mean both grouping and single-element tuples. Also Python has a type function. In fact type((2)) is int and type((2,)) is tuple. We don't want there to be any ambiguity, which there would be if (2) were treated as a tuple</p>
</blockquote>
</div>
<span class="comment-copy"><i>Could anyone explain me why single element tuple is interpreted as that element Python?</i> Itâ€™s not.</span>
<span class="comment-copy">Go back to your interpreter and do this <code>x = (1)</code> and then do <code>type(x)</code>.</span>
<span class="comment-copy">I thought that it is no more than a CONVENTION. <i>recreate via its representation</i> is very helpful</span>
