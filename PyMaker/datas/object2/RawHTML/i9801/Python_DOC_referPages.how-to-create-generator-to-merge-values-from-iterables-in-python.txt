<div class="post-text" itemprop="text">
<p>I want to create generator, which can merge values from iterables on fly (continuously) in endless look.</p>
<p>The main idea, that generator will produce the values into output each time, when you ask it. So, the main function is endless loop, where you ask generator for values one by one and print them into output.</p>
<p>While values comes from iterators generator returns values one by one to print them into output.</p>
<p>Now, in my code I'm passing values into one list . but It is not necessary to collect all values into one single list before print.</p>
<pre><code>def merge(*iterables):
# create a generator
generator = (iter(current) for current in iterables)
# convert generator to a list
iters = list(generator)
# while we have a iterable
while iters:
    #loop through each iterable
    for i in iters:
        try:
            # yields the values one by one 
            yield i.__next__()
        except StopIteration:
            iters.remove(i)
</code></pre>
<p>when I'm running like this:</p>
<pre><code>&gt;&gt;&gt; callmerge([1,5,9],[2,5],[1,6,10,11])
Result is:
[1, 1, 2, 5, 5, 6, 9, 10, 11]
</code></pre>
<p>To be clear I have an example:</p>
<p>Lets imagine that we are taking balls with numbers (like bingo) from several black boxes.</p>
<p>we don't really know the number of balls in each box. we can take the balls from boxes one by one.</p>
<p>We know, that each next ball from the same black box will have number greater than previous.</p>
<p>So, we should takes balls from black boxes and give on each step one ball with the smallest number to our assistant.</p>
<p>So, my question is how I can create generator, which can merge values from iterables on fly (continuously) in endless look?  (also I won't to be use list because of memory- I know maybe  itertools.chain(*iterables) is good option but don't know how to use)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def get_vals(*iterables):
    vals = []
    for it in iterables:
        try:
            vals.append(next(it))
        except StopIteration:
            vals.append(None) #Keep indices the same
    return vals

def sort_merge(*iterables):
    iterables = [iter(it) for it in iterables]
    vals = get_vals(*iterables)
    while any(v is not None for v in vals):
        i, m = min(filter(lambda x: x[1] is not None, enumerate(vals)), key=lambda x: x[1])
        yield m
        try:
            vals[i] = next(iterables[i])
        except StopIteration:
            vals[i] = None
</code></pre>
<p>You do have to actually compare the values in order to sort them.  I'm not sure this is going to give you any real benefit over just doing <code>sorted(itertools.chain(...))</code>, but this only keeps <code>len(iterables)</code> items in memory at any given time.</p>
<p>Edit: To make this (or any other iterator for that matter) repeat indefinitely use <code>itertools.cycle</code></p>
<pre><code>itertools.cycle(sort_merge([1,5,9],[2,5],[1,6,10,11])) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this is a task for itertools(<a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">Python3</a>, <a href="https://docs.python.org/2/library/itertools.html?highlight=itertools#itertools.chain.from_iterable" rel="nofollow noreferrer">Python2</a>). Example</p>
<pre><code>from itertools import chain

list(chain.from_iterable(([1,5,9],[2,5],[1,6,10,11])))

[1, 5, 9, 2, 5, 1, 6, 10, 11]
</code></pre>
<p>if you need them in order you can apply <code>sorted</code> on list</p>
<pre><code>sorted(list(chain.from_iterable(([1,5,9],[2,5],[1,6,10,11]))))
</code></pre>
<p>From docs:</p>
<blockquote>
<p>Make an iterator that returns elements from the first iterable until
  it is exhausted, then proceeds to the next iterable, until all of the
  iterables are exhausted. Used for treating consecutive sequences as a
  single sequence</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If I understood correctly what I believe you're after is <code>itertools.chain</code> <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">Python 3</a>, <a href="https://docs.python.org/2/library/itertools.html?highlight=itertools#itertools.chain" rel="nofollow noreferrer">Python 2</a> which allows you to combine iterables together.</p>
<pre><code>def merge(*iterables):
    for i, inner in enumerate(iterables):
        for j, item in enumerate(inner):
            yield i, j, item
</code></pre>
<hr/>
<pre><code># Test Data
x = merge(list(range(3)), list(range(3, 5)))
y = merge(list(range(5, 7)), list(range(8, 10)))

for item in x:
    print(item)

for item in y:
    print(item)

# Output
(0, 0, 0)
(0, 1, 1)
(0, 2, 2)
(1, 0, 3)
(1, 1, 4)

(0, 0, 5)
(0, 1, 6)
(1, 0, 8)
(1, 1, 9)
</code></pre>
<hr/>
<p>Then combining two or more generators.</p>
<pre><code>z = itertools.chain(x, y)

for item in z:
    print(item)

# Output
(0, 0, 0)
(0, 1, 1)
(0, 2, 2)
(1, 0, 3)
(1, 1, 4)
(0, 0, 5)
(0, 1, 6)
(1, 0, 8)
(1, 1, 9)
</code></pre>
<hr/>
<p>If you want sorting with it then I have this solution, however I can't vouch for its efficiency, I haven't timed it (since I don't have anything to compare it to) but I feel the multiple <code>list</code> calls may not be best for really large iterables.</p>
<pre><code>def sort(*iterables):
    while True:
        lst = list(merge(*iterables))
        if not lst:
            return
        i, j, v = min(lst, key = lambda tup: tup[2])
        yield iterables[i].pop(j)

&gt;&gt;&gt; list(sort([1,5,9],[2,5],[1,6,10,11]))
[1, 1, 2, 5, 5, 6, 9, 10, 11]
</code></pre>
<p>if you want it to continue indefinitely then <code>itertools.cycle</code> is an infinite generator that loops back to the start after reaching the end.</p>
</div>
<span class="comment-copy">You could read the documentation on itertools.chain...</span>
<span class="comment-copy">I don't want save in memory for that reason I think itertools.chain is one option! also I have to run it in  endless loop.</span>
<span class="comment-copy">in that case something like <code>cycle(sorted(chain(*iterables)))</code> might be all you need.  <code>cycle</code> and <code>chain</code> are both from itertools.  If you wanted to cycle mine, <code>cycle(sort_merge(*iterables))</code> should also suffice.</span>
<span class="comment-copy">would you please update your code with your last solution that you explained.</span>
<span class="comment-copy">this cycle is just for fixed list, in other words I want to create generator, which can merge values from iterables on fly (continuously) in endless look. While values comes from iterators generator returns values one by one to print them into output.</span>
<span class="comment-copy">Do you expect the contents of the iterables to be changing?  Might be something like <code>def g(*iterables): while True: yield from sort_merge(*iterables)</code> could work for what you want.</span>
<span class="comment-copy">Note the order of his outputs.  I think that's the whole point of the question.</span>
<span class="comment-copy">@patrickhaugh thanks, missed that point. updated</span>
<span class="comment-copy">Thanks guys, but as I mentioned "how I  can merge values from iterables on fly (continuously) in endless look." ?</span>
<span class="comment-copy">@BigData can you explain more?</span>
<span class="comment-copy">@wolendranh I explained what I want in my question post, read my comments again.</span>
<span class="comment-copy">list(merge(*iterables)) tooks the huge volume of memory if our iterables are big!</span>
