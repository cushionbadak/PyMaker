<div class="post-text" itemprop="text">
<p>Given the following class:</p>
<pre><code>from abc import ABCMeta, abstractmethod
from time import sleep
import threading
from threading import active_count, Thread

class ScraperPool(metaclass=ABCMeta):
    Queue = []
    ResultList = []

    def __init__(self, Queue, MaxNumWorkers=0, ItemsPerWorker=50):
        # Initialize attributes
        self.MaxNumWorkers = MaxNumWorkers
        self.ItemsPerWorker = ItemsPerWorker
        self.Queue = Queue # For testing purposes.

    def initWorkerPool(self, PrintIDs=True):
        for w in range(self.NumWorkers()):
            Thread(target=self.worker, args=(w + 1, PrintIDs,)).start()
            sleep(1) # Explicitly wait one second for this worker to start.

    def run(self):
        self.initWorkerPool()

        # Wait until all workers (i.e. threads) are done.
        while active_count() &gt; 1:
            print("Active threads: " + str(active_count()))
            sleep(5)

        self.HandleResults()

    def worker(self, id, printID):
        if printID:
            print("Starting worker " + str(id) + ".")

        while (len(self.Queue) &gt; 0):
            self.scraperMethod()

        if printID:
            print("Worker " + str(id) + " is quiting.")

        # Todo Kill is this Thread.

        return

    def NumWorkers(self):
        return 1 # Simplified for testing purposes.

    @abstractmethod
    def scraperMethod(self): 
        pass

class TestScraper(ScraperPool):
    def scraperMethod(self):
        # print("I am scraping.")
        # print("Scraping. Threads#: " + str(active_count()))
        temp_item = self.Queue[-1]
        self.Queue.pop()

        self.ResultList.append(temp_item)

    def HandleResults(self):
        print(self.ResultList)

ScraperPool.register(TestScraper)

scraper = TestScraper(Queue=["Jaap", "Piet"])
scraper.run()
print(threading.active_count())
# print(scraper.ResultList)
</code></pre>
<p>When all the threads are done, there's still one active thread - <code>threading.active_count()</code> on the last line gets me that number.</p>
<p>The active thread is <code>&lt;_MainThread(MainThread, started 12960)&gt;</code> - as printed with <code>threading.enumerate()</code>.</p>
<p>Can I assume that all my threads are done when <code>active_count() == 1</code>?
Or can, for instance, imported modules start additional threads so that my threads are actually done when <code>active_count() &gt; 1</code> - also the condition for the loop I'm using in the run method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can assume that your threads are done when <code>active_count()</code> reaches 1. The problem is, if any other module creates a thread, you'll never get to 1. You should manage your threads explicitly.</p>
<p>Example: You can put the threads in a list and join them one at a time. The relevant changes to your code are:</p>
<pre><code>def __init__(self, Queue, MaxNumWorkers=0, ItemsPerWorker=50):
    # Initialize attributes
    self.MaxNumWorkers = MaxNumWorkers
    self.ItemsPerWorker = ItemsPerWorker
    self.Queue = Queue # For testing purposes.
    self.WorkerThreads = []

def initWorkerPool(self, PrintIDs=True):
    for w in range(self.NumWorkers()):
        thread = Thread(target=self.worker, args=(w + 1, PrintIDs,))
        self.WorkerThreads.append(thread)
        thread.start()
        sleep(1) # Explicitly wait one second for this worker to start.

def run(self):
    self.initWorkerPool()

    # Wait until all workers (i.e. threads) are done. Waiting in order
    # so some threads further in the list may finish first, but we
    # will get to all of them eventually
    while self.WorkerThreads:
        self.WorkerThreads[0].join()

    self.HandleResults()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>according to <a href="https://docs.python.org/3/library/threading.html#threading.enumerate" rel="nofollow noreferrer">docs</a> <code>active_count()</code> includes the main thread, so if you're at 1 then you're most likely done, but if you have another source of new threads in your program then you may be done before <code>active_count()</code> hits 1. </p>
<p>I would recommend implementing explicit <code>join</code> method on your <code>ScraperPool</code> and keeping track of your workers and explicitly joining them to main thread when needed instead of checking that you're done with <code>active_count()</code> calls.</p>
<p>Also remember about GIL...</p>
</div>
<span class="comment-copy">The <code>class TestScraper():</code> line is absent?</span>
<span class="comment-copy">To keep things simple I only posted a part of the code. I've now added a pastebin link to the full script.</span>
<span class="comment-copy">The code you post needs to be Minimal, Complete and Verifiable (<a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>), and this seems to miss imports and definitions</span>
<span class="comment-copy">Thanks. I hope my post is now up to par.</span>
<span class="comment-copy">Imported modules can start background threads and so no, you can't wait until the thread count is 1.</span>
<span class="comment-copy">I was originally keeping track of the active scrapers in an integer <code>scraperpool.ActiveWorkersCount</code>, which got incremented/decremented when a worker started/stopped. I then ran into <code>threading.active_count()</code> and tried to use that method.  Is my original approach what you mean with "manage your threads"?</span>
<span class="comment-copy">he means you should join them explicitly....</span>
<span class="comment-copy">I don't think I quiet understand <code>threading.join()</code> yet, I'll have to look into that. Could you given an example?</span>
<span class="comment-copy">I'll post some code but it looks like what you want is already implemented in <code>multiprocessing.pool.ThreadPool</code>. You may want to check that out.</span>
<span class="comment-copy">"joining" just means waiting for the thread to complete. Some thread objects are cleaned up under the covers so there is a minor technical reason for doing it, but mostly its just the way you make sure the thread has completed its work.</span>
<span class="comment-copy">Its true that if you are at 1, you are done. But if any other module creates a thread, you'll never get to 1. That's what OP is asking.</span>
<span class="comment-copy">@tdelaney that's what I said...</span>
