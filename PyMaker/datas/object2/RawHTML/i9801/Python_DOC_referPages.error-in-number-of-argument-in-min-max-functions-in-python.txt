<div class="post-text" itemprop="text">
<p>I am running a very simple example in Python but I get some errors.
When I run this piece of code:</p>
<pre><code>lst = [1, 3, 4, 6, 7]
maxLSt = max(lst)
print(maxLSt)
</code></pre>
<p>I get this error:</p>
<pre><code>  maxLSt = max(lst)
  TypeError: max() takes exactly 2 arguments (1 given) 
</code></pre>
<p>What is the cause of this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you did </p>
<pre><code>from audioop import max
</code></pre>
<p>you explicitly told Python that the name <code>max</code> refers to that <code>max</code> from <code>audioop</code>. There's no way you can have one name that refers to two different things, so the built-in <code>max</code> function became "masked" or "shadowed" by the one from <code>audioop</code>. The masked function object is still accessible by its full name <code>__builtins__.max</code>, but we generally avoid using the full name for built-in objects, since they just make the code look cluttered, but they're handy in emergencies, and other special situations.</p>
<p>The way to avoid name collisions like that is to use the simplest form of the <code>import</code> statement:</p>
<pre><code>import audioop
</code></pre>
<p>and then you can access it's <code>max</code> function using the fully-qualified name <code>audioop.max</code>. If you want to frequently use names from a module and don't want to type its full name all the time you can give the module a short name when you import it, eg:</p>
<pre><code>import audioop as au
</code></pre>
<p>And then you'd refer to it's <code>max</code> function with <code>au.max</code>.</p>
<hr/>
<p>I suggest that you read the section on <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">Python Scopes and Namespaces</a> in the official Python tutorial. In fact, it's a good idea to read the whole tutorial. It's not aimed at someone who is totally new to programming, it assumes that you already have some coding experience (preferably in the C / C++ / Java family), so you shouldn't find it too simple. :)</p>
<p>I also recommend that you read this article: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder. It is a good explanation of Python's data model, which works quite differently to what you are used to in Java. A brief summary of these essential ideas, with nice diagrams can be found at <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Other languages have "variables", Python has "names"</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code works fine. Is this the entire program or is it a part of a huge one. If so provide the entire code.
In case if it's the entire program you should try <code>Restarting your Kernel.</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This is something I just found on the Internet to unload an import, Hope this'll do the trick</p>
<pre><code>import gc, sys

print len(gc.get_objects()) 

# Attempt to unload the module

import audioop
del sys.modules["audioop"]
audioop = None

gc.collect()
print len(gc.get_objects()) 
</code></pre>
</div>
<span class="comment-copy">You masked <code>max</code> earlier.</span>
<span class="comment-copy">You code is fine with the built-in <code>max</code> function. It appears that you've somehow bound a different function to that name. Is that the only code in that script, or do you have other function definitions written in the script itself? Or does the script contain any <code>from somemodule import *</code> statements?</span>
<span class="comment-copy">Are you typing that code directly into an interpreter? If so, you should close it and restart, because you've probably messed up other stuff apart from <code>max</code>. :) However, you can probably recover the original <code>max</code> in your current session by doing <code>max = __builtins__.max</code>... unless you've also masked <code>__builtins__</code>.</span>
<span class="comment-copy">Thanks @PM2Ring, yes it was exactly some unwanted things imported here. I am new to Python and I did not know Python cares about them. Problem was with this: from audioop import max But why? Why python cannot handle ignoring them?</span>
<span class="comment-copy">Please see my answer, and let me know if you need further clarification.</span>
<span class="comment-copy">Wonderful! Now I am understanding why people alarmed me to be careful about the unwanted imported modules! Thank you so much for  this explanation! I think the best way of avoiding this stuffs for beginners is using Pydev code recommendation editor very carefully!  I guess, I used the recommended "max" function by editor and I wasn't careful about this! Thanks!</span>
<span class="comment-copy">Yes, Thanks! Problem was with this piece of unwanted imported thing:      from audioop import max  I did not know Python cannot handle ignoring imported unwanted libraries that are now used in the code! I am java programmer and just started Python a week ago. What is difference between Python and Java in these stuffs?</span>
<span class="comment-copy">This is what I found on Internet to unload an import, Try the following code:</span>
<span class="comment-copy">This is something I just found on the Internet to unload an import,</span>
<span class="comment-copy">import gc, sys  print len(gc.get_objects()) # 4073 objects in memory  # Attempt to unload the module  import audioop del sys.modules["audioop"] audioop = None  gc.collect() print len(gc.get_objects()) # 6745 objects in memory</span>
<span class="comment-copy">'import gc, sys  print len(gc.get_objects()) # 4073 objects in memory  # Attempt to unload the module  import audioop del sys.modules["audioop"] audioop = None  gc.collect() print len(gc.get_objects()) # 6745 objects in memory'</span>
<span class="comment-copy">It's rather unusual in Python to unload a loaded module, and as the comment indicates, the attempt may not succeed. I guess it could be useful when debugging (although attempting to reload an altered version of the module would generally be more useful). For the OP's situation, the best option is to simply load the module in such a way that name collisions cannot occur.</span>
