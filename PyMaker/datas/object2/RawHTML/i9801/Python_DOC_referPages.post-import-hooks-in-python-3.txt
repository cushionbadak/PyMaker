<div class="post-text" itemprop="text">
<p>I would like to have some callback run whenever a particular module is imported. For example (using a fake <code>@imp.when_imported</code> function that does not really exist):</p>
<pre><code>@imp.when_imported('numpy')
def set_linewidth(numpy):
    import shutil
    numpy.set_printoptions(linewidth=shutil.get_terminal_size()[0])
</code></pre>
<p>This feature was designed in <a href="https://www.python.org/dev/peps/pep-0369/" rel="nofollow noreferrer">PEP 369: Post import hooks</a> but was withdrawn with the reason:</p>
<blockquote>
<p>This PEP has been withdrawn by its author, as much of the detailed design is no longer valid following the migration to importlib in Python 3.3.</p>
</blockquote>
<p>But <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">importlib</a> has no clear solution. How does one use <code>importlib</code> to implement a post-import hook?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>wrapt</code> module provides an implementation of this.</p>
<ul>
<li><a href="https://pypi.python.org/pypi/wrapt" rel="nofollow noreferrer">https://pypi.python.org/pypi/wrapt</a></li>
</ul>
<p>Watch this video about <code>wrapt</code>, including this feature:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=u7oj-ghfhUk" rel="nofollow noreferrer">https://www.youtube.com/watch?v=u7oj-ghfhUk</a></li>
</ul>
<p>Don't think the documentation for <code>wrapt</code> mentions it yet.</p>
<p>Some of the blogs posts at end of:</p>
<ul>
<li><a href="http://blog.dscpl.com.au/p/decorators-and-monkey-patching.html" rel="nofollow noreferrer">http://blog.dscpl.com.au/p/decorators-and-monkey-patching.html</a></li>
</ul>
<p>talk about it though.</p>
<p>There is a companion module for <code>wrapt</code> called <code>autowrapt</code> which allows you to do monkey patching using this mechanism without needing to change the application code itself to trigger it.</p>
<ul>
<li><a href="https://pypi.python.org/pypi/autowrapt" rel="nofollow noreferrer">https://pypi.python.org/pypi/autowrapt</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I would be shocked to find out that this is the <em>best</em> way to do this ... However, since early python2.x versions, monkey patching <code>__import__</code> has been supported.  We can take advantage of that here:</p>
<pre><code>try:
    import builtins  # python3.x
except ImportError:
    import __builtin__ as builtins  # python2.x
import sys
import collections

_builtin_import = builtins.__import__

def _my_import(name, globals=None, locals=None, fromlist=(), level=0):
    already_imported = name in sys.modules

    mod = _builtin_import(
        name,
        globals=globals,
        locals=locals,
        fromlist=fromlist,
        level=level)

    if not already_imported and name in _post_import_hooks:
        for hook in _post_import_hooks[name]:
            hook()
    return mod

builtins.__import__ = _my_import

_post_import_hooks = collections.defaultdict(list)

def on_import(name):
    def decorator(func):
        _post_import_hooks[name].append(func)
        return func
    return decorator

@on_import('numpy')
def print_hi():
    print('Hello Numpy')

print('before numpy')
import numpy
print('after numpy')
</code></pre>
<p>This answer makes a <em>super</em> simple registry for registering callbacks.  The decorator just registers the function and then returns it.  It doesn't do any fancy checking (for whether the module is already loaded, for example), but could easily be extended to do that.</p>
<p>Obviously the downside is if some other module decides to monkey patch <code>__import__</code>, then you're out of luck -- Either this module or the other one is likely to end up broken.</p>
<p>I've tested this and it seems to work on both python2.x and python3.x.</p>
</div>
<div class="post-text" itemprop="text">
<p>Does this work?</p>
<pre><code>import importlib

class ImportHook:

    def __init__(self, func):
        self.func = func
        self.module = None

    def __enter__(self):
        return self

    def get_module(self, module_name):
        self.module = importlib.import_module(module_name)
        return self.module

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.module is not None:
            self.func(self.module)

def set_linewidth(module):
    import shutil
    module.set_printoptions(linewidth=shutil.get_terminal_size()[0])

with ImportHook(set_linewidth) as hook:
    numpy = hook.get_module('numpy')
</code></pre>
</div>
<span class="comment-copy">Could you just add the code at the very end of the module?</span>
<span class="comment-copy">No, I want to do this for modules I don't own (particularly <a href="http://www.numpy.org" rel="nofollow noreferrer">numpy</a>).</span>
<span class="comment-copy">Does it have to be right after the import or can it be before the main code?</span>
<span class="comment-copy">If you have the <code>on_import</code> hook in the module you provide, you might as well import numpy and run that function right away (since modules are global across the entire interpreter).  The other consideration is that this "feature" is implicit and hidden to users of the module you provide, which they may not desire.</span>
<span class="comment-copy">There is no <code>on_import</code> hook - that is what I'm asking. And I don't want to always import numpy because it is slow or may be unavailable.</span>
<span class="comment-copy">Thanks for the tip! I'd like to avoid relying on third-party modules so I was looking for a simple solution using <code>importlib</code>, since PEP 369 implied that one was easy. However, looking at <a href="https://github.com/GrahamDumpleton/wrapt/blob/develop/src/wrapt/importer.py" rel="nofollow noreferrer">wrapt's implementation</a> it seems that the answer to my question is not so simple.</span>
<span class="comment-copy">I suggest updating the solution to link to <a href="https://github.com/GrahamDumpleton/wrapt/blob/master/src/wrapt/importer.py" rel="nofollow noreferrer">github.com/GrahamDumpleton/wrapt/blob/master/src/wrapt/â€¦</a>, which is full implementation of PEP 369. I suppose I could copy the file and strip it down to the bare essentials, but for now I'll just use wrapt. Thanks!</span>
<span class="comment-copy">Replacing <code>__import__</code> has been frowned upon almost as long as it existed. One of the reasons that the import machinery was changed and <code>sys.meta_path</code> introduced was to stop people doing that.</span>
<span class="comment-copy">@GrahamDumpleton -- Sure.  I even state at least one reason why it's bad in my answer (if multiple modules try to replace it, frequently only one will succeed).  I also state that I'd be shocked if this is the best way.  I'm still waiting to figure out what the best way <i>is</i> though.  Perhaps I need to spend some time trying to figure out the source code of wrapt as you propose above...</span>
<span class="comment-copy">No. I don't see how this would work. AFAICT, all this is do is creating a <code>numpy</code> variable. I'm pretty sure the solution involves setting either <code>sys.path_hooks</code> or <code>sys.meta_path</code>.</span>
<span class="comment-copy">The <code>with as</code> block imports numpy and calls the hook when finished.</span>
<span class="comment-copy">@BallpointBen: But you don't need a hook for that. If you're importing <code>numpy</code> anyway, you can just run the "hook" code after. The goal is to register a hook <i>in case</i> someone imports <code>numpy</code> later, but not to import <code>numpy</code> at all unless someone else imports it. And the code that imports <code>numpy</code> doesn't know about your hook, and can't be changed to add support for it.</span>
