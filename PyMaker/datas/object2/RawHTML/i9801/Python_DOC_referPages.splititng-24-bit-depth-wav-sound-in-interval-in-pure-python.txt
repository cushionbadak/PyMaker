<div class="post-text" itemprop="text">
<p>Currently I'm making some small research on wave files using only Python.
One problem I can't solve right now, is splitting wav data. format file with 24 bit sound depth correctly.</p>
<p>So the basic idea is: given <code>t1</code> - start and <code>t2</code> -end, and I need to get the <code>slice</code>, which is quite clear.</p>
<pre><code>def split_in_interval(self, start, end):
    start *= ONE_SEC_MS
    end *= ONE_SEC_MS
    header = self.wav_header.header_description
    infile = open(self.file_name, 'rb')

    rate = header['sample_rate']
    frames_per_m_sec = rate // 1000
    length = (end - start) * frames_per_m_sec
    start_ms = start * frames_per_m_sec

    name_str = self._naming_fragment(start, end)
    out_file = open(name_str, 'wb')

    # as the size changes - need to recalculate only last part of header,
    # it takes 4 last bytes of header
    out_file.write(infile.read(WAV_HEADER - 4))

    size = length * header['block_align']
    # header['num_channels'] * width
    packed_size = struct.pack('&lt;L', size)
    out_file.write(packed_size)

    anchor = infile.tell()
    infile.seek(anchor + start_ms)

    out_file.write(infile.read(size))
    out_file.close()
    infile.close()
</code></pre>
<p>I think my code is quite straight forward and it works fine with 16 and 8 bits depth sounds, but after I tried 24 - it fails.</p>
<p>I take rate and convert it into milliseconds, my Start and End parameters also convert to ms.
And after, basis on this calculations, assuming they're right I'm finding start_point in my source audio and then write from this point to the end.
What may I do wrong?
How to solve this problem, using <strong>only</strong> Python without any external libraries.</p>
<p>Thanks, in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you could use an external library, I'd recommend the <a href="http://pysoundfile.readthedocs.io/" rel="nofollow noreferrer">soundfile</a> module, which handles 24-bit files out-of-the-box.</p>
<p>If you really want to use pure Python, you should at least use the built-in <a href="https://docs.python.org/3/library/wave.html" rel="nofollow noreferrer">wave</a> module, which at least takes care of the header for you. You'll still have to convert the raw bytes into something meaningful on your own.</p>
<p>It's hard to tell what's going wrong in your case, because you are showing only a part of your code. You should show the code that works for 16 and 8 bit and doesn't work for 24. I don't see any mention of bit depth in your code.</p>
<p>It probably helps if you have a look at my <a href="http://nbviewer.jupyter.org/github/mgeier/python-audio/blob/master/audio-files/audio-files-with-wave.ipynb" rel="nofollow noreferrer">tutorial about the <code>wave</code> module</a>.</p>
</div>
<span class="comment-copy">Not sure if this is directly related to your problem, but <code>frames_per_m_sec = rate // 1000</code> looks problematic to me, due to the integer division, which can lose you numerical precision.  If the sample rate is, e.g., 44.1 kHz, which is not uncommon, you'll get <code>frames_per_m_sec = 44</code>, and your conversion of time into frame offsets will be off by a few percent.</span>
<span class="comment-copy">Can you be more specific in describing how your code "fails" on 24-bit files?  How does your problem manifest?</span>
<span class="comment-copy">I think your note about precision might be useful for absolutely non noize sound, but I have it all fine in 16 bit compositions. However, 24 bit try produces as the result file full of noize and no original sound</span>
