<div class="post-text" itemprop="text">
<p>I am writing a simple multithreaded chat server in Python3. Sometimes i want to interrupt another thread that is waiting in <a href="https://docs.python.org/3.5/library/socket.html#socket.socket.recv" rel="nofollow noreferrer">socket.recv()</a> to allow the theread to perform cleanup tasks.</p>
<p>Is calling <a href="https://docs.python.org/3.5/library/socket.html#socket.socket.shutdown" rel="nofollow noreferrer">socket.shutdown(socket.SHUT_RDWR)</a> from another thread safe?</p>
</div>
<div class="post-text" itemprop="text">
<p>Calling <code>socket.shutdown</code> from another thread is reasonably safe, and, as @kinokikuf mentioned, is an appropriate way to terminate a blocking <code>recv()</code> in another thread, as long as you can guarantee that the socket is not yet closed when the call to <code>shutdown()</code> happens.</p>
<p>If you cannot guarantee that the socket isn't yet closed, you may get an exception when calling shutdown or you might even terminate another unrelated connection if a race-condition happens and the socket handle is reused by the OS!</p>
<p>The <a href="https://linux.die.net/man/2/shutdown" rel="nofollow noreferrer">Linux man page</a> for the <code>shutdown()</code> system call doesn't explicitly state that blocking recv() calls will be terminated, only that "further receptions and transmissions will be disallowed". But in practice this seems to include blocking <code>recv()</code> calls on the same socket on both Unixoid systems and Windows.</p>
<p>Another way would be to use <a href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" rel="nofollow noreferrer">socket.settimeout()</a> to circumvent the indefinite blocking problem and regularly check (e.g. with global variables) inside the thread if the connection should be closed.</p>
<p>Yet another reasonable way to interrupt the <code>recv()</code> would be to send a non-lethal signal to the thread, which will interrupt the recv() system call, but there seems to be no wrapper for the low-level <code>pthread_kill</code> function in Python and since Python 3.5 <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-475-retry-system-calls-failing-with-eintr" rel="nofollow noreferrer">system calls will be automatically restarted if interrupted</a>, which makes this option unusable.</p>
</div>
<span class="comment-copy">You may want to look into <a href="https://docs.python.org/3/library/select.html" rel="nofollow noreferrer">select()</a> You can then listen to multiple inputs and choose whichever is ready to provide you with data.</span>
<span class="comment-copy">@TemporalWolf I know about selectors. Unfortunately, this is a homework assignment, and we must use multithreaded raw sockets.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/27790293/1005379">This answer</a> and <a href="http://stackoverflow.com/a/8050401/1005379">this one</a> seems to indicate that this is in fact the recommended way, but i'm not sure how it works in a high-level language such as Python</span>
<span class="comment-copy">I'd encourage you to review <a href="http://meta.stackoverflow.com/questions/334822/how-do-i-ask-and-answer-homework-questions">how to ask homework questions</a>. Show us what you've done/tried.</span>
<span class="comment-copy">Thanks! I'm only calling close() from the thread that manages the function, so i'm always shutting down a open socket.</span>
