<div class="post-text" itemprop="text">
<p>I'm stuck on a question where I have to add 2 lists together while factoring in the length. For example, if <code>list1 = [1,2]</code> and <code>list2 = [3,4,5]</code> the answer would be <code>[1+3,2+4,5]</code> or <code>[4,6,5]</code>. </p>
<p>What I have so far is:</p>
<pre><code>def addsum(list1,list2):
    new_list = []
    if len(list1) &gt; len(list2):
       new_list = list1[0:]+list2[0:]
</code></pre>
<p>I'm not really sure how to appraoch this question since I'm new to lists. Would appreciate the help!</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a> from itertools with a <code>fillvalue</code> of <code>0</code> in a list comprehension:</p>
<pre><code>r = [sum(i) for i in zip_longest(list1, list2, fillvalue=0)]
</code></pre>
<p><code>zip_longest</code> pairs the elements in the input lists (<code>list1</code> and <code>list2</code> here). If one list is smaller, pairs the remainding elements of the larger list with the value supplied as the <code>fillvalue</code> (which we assign to <code>0</code> here).</p>
<p>Now, <code>r</code> equals:</p>
<pre><code>print(r) # [4, 6, 5]
</code></pre>
<p>Similarly, you could utilize <code>map</code> instead of the list-comp:</p>
<pre><code># Python 3.x
r = list(map(sum, zip_longest(list1, list2, fillvalue=0)))
# Python 2.7
r = map(sum, zip_longest(list1, list2, fillvalue=0))
</code></pre>
<p>and get the same result for <code>r</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Poor man's approach:</p>
<pre><code>def addsum(list1,list2):
    if len(list1) &gt;= len(list2): 
        for i in range(len(list2)):
            list1[i]=list1[i]+list2[i]
        return list1
    else:
        for i in range(len(list1)):
            list2[i]=list1[i]+list2[i]
        return list2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use the <code>zip_longest</code> solution too, but building in your code this is what I would do</p>
<pre><code>def addsum(list1, list2):
    if len(list1) &lt; len(list2):
        list1, list2 = list2, list1
    result=list(list1)
    for i,x in enumerate(list2):
        result[i] += x
    return result
</code></pre>
<p>first make sure that the first list is the longest, and if that is not the case exchange them, then make a copy of longest list and finally add the elements of the shorter list position-wise to the copy and return it</p>
<pre><code>&gt;&gt;&gt; addsum([1,2],[3,4,5])
[4, 6, 5]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although <code>zip_longest</code> is more neat, another possibility is to use a trial/error approach (if you are tired of "ifs"), as shown here:</p>
<pre><code>def addsum(list1, list2):
    res = []
    i = 0
    while i &lt; len(list1) or i &lt; len(list2):
        try:
            res.append(list1[i]+list2[i])
        except IndexError:
            try: res.append(list1[i])
            except IndexError: res.append(list2[i])
        i += 1
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Documentation on <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>zip_longest</code></a>:</p>
<blockquote>
<p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with <code>fillvalue</code>. Iteration continues until the longest iterable is exhausted.</p>
</blockquote>
<p>Here's the code:</p>
<pre><code>from itertools import zip_longest
[x + y for x, y in zip_longest([1,2], [3,4,5], fillvalue=0)]
</code></pre>
<p>Output:</p>
<pre><code>[4, 6, 5]
</code></pre>
</div>
