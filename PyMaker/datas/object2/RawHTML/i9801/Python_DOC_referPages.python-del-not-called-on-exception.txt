<div class="post-text" itemprop="text">
<p>I'm attempting to wrap a poorly written Python module (that I have no control of) in a class. The issue is that if I don't explicitly call that module's close function then the python process hangs on exit, so I've attempted to wrap the module with a class that has a <strong>del</strong> method, however the <strong>del</strong> method does not seem to be called on exceptions.</p>
<p>Example:</p>
<pre><code>class Test(object):
    def __init__(self):
        # Initialize the problematic module here
        print "Initializing"

    def __del__(self):
        # Close the problematic module here
        print "Closing"

t = Test()
# This raises an exception
moo()
</code></pre>
<p>In this case <strong>del</strong> is not called and python hangs. I need somehow to force Python to call <strong>del</strong> immediately whenever the object goes out of scope (like C++ does).
Please note that I have no control over the problematic module (i.e. cannot fix the bug that causes this in the first place) and also no control over whoever uses the wrapper class (can't force them to use "with" so I can't use <strong>exit</strong> either).</p>
<p>Is there any decent way to solve this?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want some resource to be released on an exception, think about __enter__ + __exit__ paradigm.</p>
<pre><code>class Test(object):
    def __enter__(self):
        pass

    def __exit__(self):
        pass  # Release your resources here

with Test() as t:
    moo()
</code></pre>
<p>When the execution goes into the 'with' block, the method __enter__() of 't' is called, and then it leaves the block due to either normal flow, or an exception, the method __exit__() of 't' is called.</p>
</div>
<div class="post-text" itemprop="text">
<p>A possible solution is to use <a href="https://docs.python.org/3/library/sys.html" rel="nofollow noreferrer">sys.excepthook</a>, which allows you to introduce custom login to the global exception handler. You can add some code there to close your module's leftovers.</p>
</div>
<span class="comment-copy">Don't use <b>del</b>. This is not C++ or a language built for destructors. The <b>del</b> method really should be gone in Python 3.x, though I'm sure someone will find a use case that makes sense. If you need to use <b>del</b>, be aware of the basic limitations per <a href="http://docs.python.org/reference/datamodel.html" rel="nofollow noreferrer">docs.python.org/reference/datamodel.html</a></span>
<span class="comment-copy">Wrap it with a context manager?</span>
<span class="comment-copy">As I said, I have no control over whoever uses the class. I can't force them to use "with".</span>
<span class="comment-copy">@harshil9968 no reason not to call del. Its behavior is deterministic. You just need to be aware of how it works. But, in the context of this question, it won't work as expected :)</span>
<span class="comment-copy">Please note my last part of the comment - I have no control on whoever uses the wrapper class or how it will be used, i.e. I can't force them to use "with". Any solution must be implemented only inside the wrapper class code.</span>
<span class="comment-copy">OK, but you have control over the code that uses the class? You can use __enter__ / __exit__ in that client code. I put the Test class just to illustrate the idea. There are also other ways of implementing enter/exit things, e.g. using @contextlib.contextmanger.</span>
<span class="comment-copy">Hi, I don't have any control over the code that uses the class.</span>
<span class="comment-copy"><code>__exit__</code> has longer signature, not only <code>self</code></span>
