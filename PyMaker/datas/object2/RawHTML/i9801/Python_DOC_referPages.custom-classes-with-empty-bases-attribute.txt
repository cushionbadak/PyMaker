<div class="post-text" itemprop="text">
<p>In the section on <a href="https://docs.python.org/3/reference/datamodel.html#index-47" rel="nofollow noreferrer">Custom Classes</a> of <a href="https://docs.python.org/3/reference/" rel="nofollow noreferrer"><em>The Python Language Reference</em></a> it is stated that:</p>
<blockquote>
<p>Special attributes: <code>__name__</code> is the class name; <code>__module__</code> is the module name in which the class was defined; <code>__dict__</code> is the dictionary containing the class’s namespace; <code>__bases__</code> is a tuple (possibly empty or a singleton) containing the base classes, in the order of their occurrence in the base class list; <code>__doc__</code> is the class’s documentation string, or <code>None</code> if undefined.</p>
</blockquote>
<p>So, <code>__bases__</code> for a custom class can "possibly be empty"? How can that be achieved if everything implicitly inherits from <code>object</code> in Python <code>3</code>?</p>
<p>The only class with an empty <code>__bases__</code> is <code>object</code> itself:</p>
<pre><code>&gt;&gt;&gt; object.__bases__
()
</code></pre>
<p>Am I missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p>The line has been there since before Python 3 was released.  Here's the 2007 <a href="https://github.com/python/cpython/commit/e395d9483cba40d328a49a42c75b79e3ef1dd770" rel="nofollow noreferrer">commit</a>.  When the object model was revamped to get rid of old-style classes, it looks like that information in the docs slipped through review and is likely just misinformation now.  </p>
<p>May I suggest you raise a <a href="http://bugs.python.org" rel="nofollow noreferrer">documentation issue</a> to clear up whether it is incorrect/outdated.  </p>
</div>
<div class="post-text" itemprop="text">
<p>That paragraph isn't so much <em>wrong</em> as misleading, due to where it appears:  "Custom classes" is the only place in the Data Model docs where <code>__bases__</code> is addressed at all.  Since working with custom classes is the only time you're likely to care about the content of <code>__bases__</code>, I guess that makes some sense.</p>
<p>The surprise is that it gives a complete description of <code>__bases__</code>, including details that only apply to <em>non</em>-custom classes like the builtin, <code>object</code>.  As you pointed out, <code>object.__bases__</code> <em>is</em> empty:</p>
<pre><code>&gt;&gt;&gt; object.__bases__
()
</code></pre>
<p>I think that phrase was supposed to be a heads-up that <code>unknown_class.__bases__[0]</code> could raise an <code>IndexError</code>, because even in Python 3, <code>__bases__</code> <em>could</em> be empty.</p>
<p><code>__bases__</code> can also be a singleton, apparently.  Why anyone would care a bout <em>that</em>, I can't imagine.  Maybe by "singleton", they meant "1-tuple"?  Er, OK...  I still don't care.</p>
<blockquote>
<p><strong>Update:</strong>  As <a href="https://stackoverflow.com/questions/40755553">wim has pointed out</a>, the paragraph in question was imported along with <a href="https://github.com/python/cpython/blob/e395d9483cba40d328a49a42c75b79e3ef1dd770/Doc/reference/datamodel.rst" rel="nofollow noreferrer">all of Python 2's <code>Docs/reference/datamodel.rst</code></a> on Wed 15 Aug 2007, and has remained basically unchanged since then.  The section it's in, however, was just "Classes" back then.  That section was <a href="https://github.com/python/cpython/commit/8fdc492857fac72cd772a570530203f15d55b16f#diff-d5e89d1a65b9139a323373b4dbf9144bR743" rel="nofollow noreferrer">renamed to "Custom classes"</a> on Fri 31 Aug 2007, as part of the effort to remove the "old-style" / "new-style" distinction.</p>
<p>The addition of the word "Custom" does not seem like an improvement, since the bulk of that section applies to most or maybe all classes (I don't know to what extent it applies to classes compiled from another language).</p>
</blockquote>
<p>PS:  In case anyone's tempted to sneakily replace the <code>__bases__</code> attribute after class creation, Python 3's got a special error message just for you...</p>
<pre><code>&gt;&gt;&gt; class A: pass
...
&gt;&gt;&gt; A.__bases__
(&lt;class 'object'&gt;,)
&gt;&gt;&gt; A.__bases__ = ()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only assign non-empty tuple to A.__bases__, not ()
</code></pre>
</div>
<span class="comment-copy">This looks like an omission in the docs that wasn't removed when Python <code>3</code> was launched. <code>class Foo: pass</code> in Python <code>2.x</code> yields <code>()</code> for <code>Foo.__bases__</code>.</span>
<span class="comment-copy">Of course, I'm just guessing; I don't know if any black magic is possible here that allows you to define a class with an empty <code>__bases__</code> in <code>Py3</code>.</span>
<span class="comment-copy">Git Hub won't display or even name all (400-plus) files of that commit.  The quoted paragraph was in <a href="https://github.com/python/cpython/blob/e395d9483cba40d328a49a42c75b79e3ef1dd770/Doc/reference/datamodel.rst" rel="nofollow noreferrer">commit <code>e395d94</code>'s <code>Doc/reference/datamodel.rst</code></a>.</span>
