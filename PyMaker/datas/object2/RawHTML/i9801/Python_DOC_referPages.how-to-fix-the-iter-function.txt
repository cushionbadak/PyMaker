<div class="post-text" itemprop="text">
<pre><code> {'a': [{'c','d'},  {'d'}        ],
 'b': [{'c','d'},  set()        ],
 'c': [set(),      {'a','b','d'}],
 'd': [{'a','c'},  {'a','b'}    ],
 'e': [set(),      set()        ]}

class Graph:
    def __init__(self,*args):
        self.edges = {}

    def degree(self,n):
        count = 0
        if n not in self.edges.keys():
            raise GraphError
        for key,value in self.edges.items():
            if key == n:
                for c in value:
                    for x in c:
                        count += 1
        return count

    def __iter__(self):
        l=[]
        for key,value in self.edges.items():
            for item in value[0]:
                l.append((key,item))
        return sorted(l, key = degree(l[0]))
</code></pre>
<p>Define an <strong>iter</strong> method so that each call to next produces a value that is a 2-tuple repesenting an edge in the Graph: an origin node followed by one of its destination nodes. The origin nodes are produced in increasing order of their degree (how many edges, both incoming and outgoing, they have). And, if two nodes have the same degree, they should be produced in alphabetical order. The destination nodes for each origin node should appear in alphabetical order.
For example, iterating over the original Graph above produces 6 values in the following order: ('b', 'c'), ('b', 'd'), ('a', 'c'), ('a', 'd'), ('d', 'a'), and ('d', 'c'). This is the ordering, because node b has degree 2, so it and its two destination nodes, appearing alphabetically, are first; node a has degree 3, so it and its two destination nodes, appearing alphabetically, are next; and finally node d has degree 4, so it and its two destination nodes, appearing alphabetically, are last.</p>
<p><a href="https://i.stack.imgur.com/PgcWS.jpg" rel="nofollow noreferrer"><img alt="node" src="https://i.stack.imgur.com/PgcWS.jpg"/></a></p>
<p>I am working in the iter function, when it calls</p>
<pre><code>g = Graph()
g.edges = {'a': [{'c','d'},{'d'}], 'b': [{'c','d'}, set()], 'c': [set(),{'a','b','d'}], 'd': [{'a','c'},{'a','b'}], 'e': [set(),set()]}
</code></pre>
<p>it should return</p>
<pre><code>[t for t in g]--&gt;[('b', 'c'), ('b', 'd'), ('a', 'c'), ('a', 'd'), ('d', 'a'), ('d', 'c')]
</code></pre>
<p>but when I call me iter function, it produces the following error:</p>
<pre><code>   96 *Error: [t for t in g] raised exception TypeError: iter() returned non-iterator of type 'list'
   99 *Error: [t for t in g] raised exception TypeError: iter() returned non-iterator of type 'list'
   102 *Error: [t for t in g] raised exception TypeError: iter() returned non-iterator of type 'list'
</code></pre>
<p>can someone help me to fix my iter function? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow noreferrer">generator</a> to implement <code>__iter__</code> for <code>Graph</code>. Then you just need to sort the vertices with tuple key <code>(degree, name)</code>, iterate over them and <code>yield</code> the edges in alphabetical order:</p>
<pre><code>EDGES =  {
    'a': [{'c','d'},  {'d'}        ],
    'b': [{'c','d'},  set()        ],
    'c': [set(),      {'a','b','d'}],
    'd': [{'a','c'},  {'a','b'}    ],
    'e': [set(),      set()        ]
}

class Graph:
    def __init__(self, edges):
        self.edges = edges

    def degree(self,n):
        if n not in self.edges:
            raise GraphError
        return sum(len(s) for s in self.edges[n])

    def __iter__(self):
        # Iterate over vertices, primary key is degree and 
        # secondary is name 
        for v in sorted(self.edges, key=lambda x: (self.degree(x), x)):
            # Iterate over outgoing edges in alphabetical order
            for other in sorted(self.edges[v][0]):
                yield v, other

g = Graph(EDGES)
print(list(iter(g)))
</code></pre>
<p>Output:</p>
<pre><code>[('b', 'c'), ('b', 'd'), ('a', 'c'), ('a', 'd'), ('d', 'a'), ('d', 'c')]
</code></pre>
</div>
