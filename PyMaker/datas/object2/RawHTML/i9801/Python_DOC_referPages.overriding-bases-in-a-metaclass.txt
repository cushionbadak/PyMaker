<div class="post-text" itemprop="text">
<p>Is it possible to override the <code>__bases__</code> field of a metaclass (i.e. class deriving from <code>type</code>) using a get-set property? The following code works for <em>getting</em> <code>C.__bases__</code>, but not <em>setting</em> it:</p>
<pre><code>class Meta(type):
    @property
    def __bases__(cls):
        print('Getting __bases__ via Meta.__bases__')
        return super().__bases__

    @__bases__.setter
    def __bases__(cls, value):
        print('Setting __bases__ via Meta.__bases__')
        super().__bases__ = value

class A: pass
class B: pass
class C(A, B, metaclass=Meta): pass

# &gt;&gt;&gt; C.__bases__
# Getting __bases__ via Meta.__bases__
# (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)
# &gt;&gt;&gt; C.__bases__ = (B, A)
# Setting __bases__ via Meta.__bases__
# AttributeError: 'super' object has no attribute '__bases__'
</code></pre>
<p>I've tried a few substitutions for <code>super()</code> in the setter function, but none of them work:</p>
<p><code>type.__setattr__(cls, '__bases__', value)</code> leads to recursion.</p>
<p><code>object.__setattr__(cls, '__bases__', value)</code> gives <code>TypeError: can't apply this __setattr__ to type object</code></p>
<p>So, what this boils down to is how to set the <code>cls.__bases__</code> field when it is
shadowed by a property on the metaclass. Any ideas?</p>
<hr/>
<p><sup>(Yes, I am aware that defining the <code>__bases__</code> property has no effect on the actual <code>__mro__</code> of the class, although that can be arranged by overriding <code>mro()</code>)</sup></p>
</div>
<div class="post-text" itemprop="text">
<p><code>super()</code> doesn't support data descriptors, only plain descriptors, as only <code>super().__get__</code> is implemented.</p>
<p>Put differently, the assignment</p>
<pre><code>super().__bases__ = value
</code></pre>
<p>fails because the <code>super()</code> proxy object does not implement the <a href="https://docs.python.org/3/reference/datamodel.html#object.__set__" rel="nofollow noreferrer"><code>descriptor.__set__()</code> method</a>, and thus that assignment tries to set <code>__bases__</code> as an attribute on that proxy object.</p>
<p>You'd have to manually access the descriptor on the <code>type</code> object:</p>
<pre><code>class Meta(type):
    @property
    def __bases__(cls):
        print('Getting __bases__ via Meta.__bases__')
        return type.__dict__['__bases__'].__get__(cls)

    @__bases__.setter
    def __bases__(cls, value):
        print('Setting __bases__ via Meta.__bases__')
        return type.__dict__['__bases__'].__set__(cls, value)
</code></pre>
<p>For symmetry's sake, I've used the same manual descriptor access in the getter, although <code>super().__bases__</code> would work too.</p>
<p>Above, I hardcoded <code>type</code> rather than search the MRO; you could also use a helper function to find the right descriptor with a full MRO search:</p>
<pre><code>class Meta(type):
    def _find_super(cls, name):
        mro = type(cls).__mro__
        idx = mro.index(__class__)
        for base in mro[idx + 1:]:
            if name in base.__dict__:
                return base.__dict__[name]
        return

    @property
    def __bases__(cls):
        print('Getting __bases__ via Meta.__bases__')
        return cls._find_super('__bases__').__get__(cls)

    @__bases__.setter
    def __bases__(cls, value):
        print('Setting __bases__ via Meta.__bases__')
        return cls._find_super('__bases__').__set__(cls, value)
</code></pre>
<p>Either way, now you can intercept <code>__bases__</code> being set:</p>
<pre><code>&gt;&gt;&gt; class A: pass
...
&gt;&gt;&gt; class B: pass
...
&gt;&gt;&gt; class C(A, B, metaclass=Meta): pass
...
&gt;&gt;&gt; C.__bases__
Getting __bases__ via Meta.__bases__
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)
&gt;&gt;&gt; C.__bases__ = (B, A)
Setting __bases__ via Meta.__bases__
&gt;&gt;&gt; C.__bases__
Getting __bases__ via Meta.__bases__
(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;)
</code></pre>
</div>
<span class="comment-copy">No, you can't. Why would you want to do this, what problem does this solve?</span>
<span class="comment-copy">And <code>super()</code> only supports non-data descriptors (so only <code>__get__</code>). No <code>__set__</code> is supported, so <code>super().__bases__ = value</code> will try to se the <code>__bases__</code> attribute on the super proxy, not on any base class. <code>__bases__</code> can't be altered.</span>
<span class="comment-copy">Re: why I want to do this: the idea is to implement a sort of "class proxy", which forwards method and attribute access to the proxied class by copying its <code>__mro__</code>. It would then be nice if the <code>__bases__</code> of the class proxy would also correspond to the <code>__bases__</code> of the proxied class, hence the need for overriding it.</span>
<span class="comment-copy">Setting <code>__bases__</code> is so very rare that not supporting that should be fine, though.</span>
<span class="comment-copy"><code>__bases__</code> <i>is</i> writable. For example, defining C without the metaclass:       <code>&gt;&gt;&gt; class C(A, B): pass     &gt;&gt;&gt; C.__bases__ = (B, A)</code>  But your point about <code>super()</code> not supporting data descriptors explains the <code>AttributeError</code>. Thanks.</span>
<span class="comment-copy">@SJPalt: I stand corrected! And on that note, I've included how to directly access the descriptor.</span>
<span class="comment-copy">This is excellent, and works as expected. I hadn't thought of re-implementing <code>super()</code> like that. Thank you for your answer.</span>
