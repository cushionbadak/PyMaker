<div class="post-text" itemprop="text">
<p>What's the result of returning <code>NotImplemented</code> from <code>__eq__</code> special method in python 3 (well 3.5 if it matters)?</p>
<p>The documentation isn't clear; the <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer">only relevant text I found</a> only vaguely refers to "some other fallback":</p>
<blockquote>
<p>When <code>NotImplemented</code> is returned, the interpreter will then try the reflected operation on the other type, or some other fallback, depending on the operator. If all attempted operations return <code>NotImplemented</code>, the interpreter will raise an appropriate exception. See <a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations" rel="nofollow noreferrer">Implementing the arithmetic operations</a> for more details.</p>
</blockquote>
<p>Unfortunately, the "more details" link doesn't mention <code>__eq__</code> at all.</p>
<p>My reading of this excerpt suggests that the code below should raise an "appropriate exception", but it does not:</p>
<pre><code>class A:
  def __eq__(self, other):
    return NotImplemented

class B:
  def __eq__(self, other):
    return NotImplemented

# docs seems to say these lines should raise "an appropriate exception"
# but no exception is raised
a = A()
b = B()
a == b # evaluates as unequal
a == a # evaluates as equal
</code></pre>
<p>From experimenting, I think that when <code>NotImplemented</code> is returned from <code>__eq__</code>, the interpreter behaves as if <code>__eq__</code> wasn't defined in the first place (specifically, it first swaps the arguments, and if that doesn't resolve the issue, it compares using the default <code>__eq__</code> that evaluates "equal" if the two objects have the same identity). If that's the case, where in the documentation can I find the confirmation of this behavior?</p>
<p>Edit: see <a href="http://bugs.python.org/issue28785" rel="nofollow noreferrer">Python issue 28785</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Actually the <code>==</code> and <code>!=</code> check work identical to the ordering comparison operators (<code>&lt;</code> and similar) except that they don't raise the <strong>appropriate exception</strong> but fall-back to identity comparison. That's the only difference.</p>
<p>This can be easily seen in the <a href="https://github.com/python/cpython/blob/3.5/Objects/object.c#L679" rel="nofollow noreferrer">CPython source code</a>. I will include a Python version of that source code (at least as far as it's possible):</p>
<pre><code>_mirrored_op = {'__eq__': '__eq__',  # a == b =&gt; b == a
                '__ne__': '__ne__',  # a != b =&gt; b != a
                '__lt__': '__ge__',  # a &lt; b  =&gt; b &gt;= a
                '__le__': '__gt__',  # a &lt;= b =&gt; b &gt; a
                '__ge__': '__lt__',  # a &gt;= b =&gt; b &lt; a
                '__gt__': '__le__'   # a &gt; b  =&gt; b &lt;= a
               }

def richcmp(v, w, op):
    checked_reverse = 0
    # If the second operand is a true subclass of the first one start with
    # a reversed operation.
    if type(v) != type(w) and issubclass(type(w), type(v)) and hasattr(w, op):
        checked_reverse = 1
        res = getattr(w, _mirrored_op[op])(v)     # reversed
        if res is not NotImplemented:
            return res
    # Always try the not-reversed operation
    if hasattr(v, op):
        res = getattr(v, op)(w)      # normal
        if res is not NotImplemented:
            return res
    # If we haven't already tried the reversed operation try it now!
    if not checked_reverse and hasattr(w, op):
        res = getattr(w, _mirrored_op[op])(v)      # reversed
        if res is not NotImplemented:
            return res
    # Raise exception for ordering comparisons but use object identity in 
    # case we compare for equality or inequality
    if op == '__eq__':
        res = v is w
    elif op == '__ne__':
        res = v is not w
    else:
        raise TypeError('sth')

    return res
</code></pre>
<p>and calling <code>a == b</code> then evaluates as <code>richcmp(a, b, '__eq__')</code>. The <code>if op == '__eq__'</code> is the special case that makes your <code>a == b</code> return <code>False</code> (because they aren't identical objects) and your <code>a == a</code> return <code>True</code> (because they are).</p>
<p>However the behaviour in Python 2.x was completly different. You could have up to 4 (or even 6, I don't remember exactly) comparisons before falling back to identity comparison!</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure where (or if) it is in the docs, but the basic behavior is:</p>
<ul>
<li>try the operation: <code>__eq__(lhs, rhs)</code></li>
<li>if result is not <code>NotImplemented</code> return it</li>
<li>else try the reflected operation:  <code>__eq__(rhs, lhs)</code></li>
<li>if result is not <code>NotImplemented</code> return it</li>
<li><p>otherwise use appropriate fall back:</p>
<p>eq -&gt; same objects? -&gt; True, else False</p>
<p>ne -&gt; different objects? True, else False</p>
<p>many others -&gt; raise exception</p></li>
</ul>
<p>The reason that <code>eq</code> and <code>ne</code> do <em>not</em> raise exceptions is:</p>
<ul>
<li>they can always be determined (apple == orange? no)</li>
</ul>
</div>
<span class="comment-copy">to raise exception you will need <code>raise NotImplementedError</code> in your code.</span>
<span class="comment-copy">in my Python 3 both evaluate as unequal. Put <code>print("A.eq")</code> and <code>print("A.eq")</code> and see what's happen. First is called "A.eq", later "B.eq". And later probably is called <code>eq</code> in other data type which can compares it and returns result - so it doesn't raise error. Probably it compares <code>id(A())</code> and <code>id(B())</code>.</span>
<span class="comment-copy"><code>id()</code> can work with every objects so you don't get error. <code>__add__</code> doesn't have some universal method which always works so it can raise exception.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror?rq=1" title="why return notimplemented instead of raising notimplementederror">stackoverflow.com/questions/878943/…</a> - first answer confirms that it uses identity. I'm not sure about relevant interpreter code snippet or official docs link.</span>
<span class="comment-copy">@ŁukaszRogalski makes sense, but the link is about python 2 as of 2009, and is based on a blog post rather than documentation. Shouldn't it be in the official python 3 documentation? Maybe I should make an issue on bugs.python.org?</span>
<span class="comment-copy">Ahh ... Ok, I was confused when you talked about "same objects" in your comment.  The new (sticky) header on StackOverflow blocked me from seeing that you'd edited the post.  Oops.</span>
