<div class="post-text" itemprop="text">
<p>So I have the following function : </p>
<pre><code>def find_by_name(self, name):
    fitting_list = [p for p in self.__persons if name.lower() in p.name.lower()]
    return fitting_list
</code></pre>
<p>And I get the following output when I want to print the list : </p>
<pre><code>[&lt;src.store.domain.person.Person object at 0x000001F88705B128&gt;]
</code></pre>
<p>Why does this happen and how can I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list</code> doesn't care that your class has a <code>__str__</code> method. </p>
<p>When you print an object, <code>print</code> calls <code>str</code> on the object to get a suitable string. The <code>str</code> function attempts to call the object's <code>__str__</code> method, but if it doesn't <em>have</em> one then it calls the object's <code>__repr__</code> method instead. And if their isn't a definition for <code>__repr__</code> in that object's class definition then you'll get the one inherited from the parent class, typically that will be the default  <code>__repr__</code> from the base <code>object</code> type.</p>
<p><code>list</code> and the other built-in collections like <code>tuple</code>, <code>set</code> and <code>dict</code> don't have a <code>__str__</code> method, so when you try to convert them to strings (either explicitly using the <code>str</code> function, or implicitly via <code>print</code>) their <code>__repr__</code> method is called. And those <code>__repr__</code> methods in turn call <code>repr</code> on each item in the collection. So when you pass any of those collection objects to <code>print</code> you will always see the <code>__repr__</code> of the items. And explictly calling <code>str</code> on the collection will make no difference. </p>
<p>If you want to see the <code>__str__</code> representation of the items in a <code>list</code> or collection you will need to iterate over the collection, calling <code>str</code> explicitly on each item.</p>
<p>Here's a tiny code snippet (suitable for Python 2 &amp; 3) that illustrates these points.</p>
<pre><code>from __future__ import print_function

class Test(object):
    def __str__(self):
        return 'Test str'
    def __repr__(self):
        return 'Test repr'

a = [Test(), Test()]
print(id(a.__repr__), id(a.__str__))
print(a, str(a), repr(a))

for u in a:
    print(u, str(u), repr(u))
</code></pre>
<p><strong>output</strong></p>
<pre><code>3075508812 3075508812
[Test repr, Test repr] [Test repr, Test repr] [Test repr, Test repr]
Test str Test str Test repr
Test str Test str Test repr
</code></pre>
<p>So if you want to be able to print a list of your objects as a single entity and have the object's strings be more human-friendly, you have a couple of choices:</p>
<ol>
<li><p>Change the name of your <code>__str__</code> method to <code>__repr__</code>. This is the simplest way, and as I said earlier, the <code>__repr__</code> will be used if a <code>__str__</code> can't be found when the object gets passed to <code>str</code>.</p></li>
<li><p>Leave the existing <code>__str__</code> method alone and create a <code>__repr__</code> that's more human-friendly. However, it's suggested that the <code>__repr__</code> display useful info to a programmer who sees it, and if practical it's nice if the <code>__repr__</code> string can be copy &amp; pasted into the interpreter or script to recreate the object.</p></li>
<li><p>Leave the existing <code>__str__</code> method alone and create a <code>__repr__</code> that calls <code>__str__</code>. While valid, this is a bit silly. A related strategy is to set <code>__repr__</code> as a class attribute that references <code>__str__</code>. See below for an example.</p></li>
</ol>
<pre><code>class Test(object):
    def __str__(self):
        return 'Test str'
    __repr__ = __str__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is just the <code>__repr__</code> of the object. The <code>__repr__</code> is meant to be a machine readable representation of the object and you can change it by overiding it.</p>
</div>
<span class="comment-copy">What do you expect instead?</span>
<span class="comment-copy">I expect to print the list of objects with respect to the if condition. I have implemented <b>str</b> method. Shouldn't that be enough?</span>
<span class="comment-copy">That's what is does. It prints a list with one Person object. You see the default way Python prints objects.</span>
<span class="comment-copy">BTW, that "persons" attribute should probably be called <code>.persons</code>, or maybe <code>._persons</code> if you want to indicate that it's a private name for use by your class's methods and that  code external to the class shouldn't touch it directly. Names that begin with double underscores (and end with at most a single underscore) invoke Python's <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">name mangling</a> machinery, and that should only be used when you <i>really</i> need it. And if you have to ask "Do I need name mangling here?", you probably don't. ;)</span>
<span class="comment-copy">Thank you so much. This made me understand the <b>str</b> methoc a lot better than any other tutorial I've found.</span>
