<div class="post-text" itemprop="text">
<p>I started reading about python's += syntax and stumbled onto the following post/answer:
<a href="https://stackoverflow.com/a/13329969/7143036">Interactive code about +=</a></p>
<p>So what I noticed was that there seems to be a difference between frames and objects.</p>
<p><a href="https://i.stack.imgur.com/0YVoy.png" rel="nofollow noreferrer"><img alt="Frames and Objects" src="https://i.stack.imgur.com/0YVoy.png"/></a></p>
<p>In the global frame, they point to the same object even though they're different variables; if the line</p>
<pre><code>l2 += [item]
</code></pre>
<p>was instead</p>
<pre><code>l2 = l2 + [item]
</code></pre>
<p>then 'l2' becomes a separate object when that line runs. My biggest question is when would you want a variable to point to a separate object? Also, why and when would you want to keep them pointed at the same object?</p>
<p>Any explanation or use cases would be greatly appreciated! Extra thanks if you can mention anything relevant to data science :)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>frame</code> and <code>object</code> don't mean what you think they mean.</p>
<p>In programming you have something called a <strong>stack</strong>. In Python, when you call a function you create something called a <strong>stack frame</strong>. This frame is (as you see in your example) basically just a table of all of the variables that are local to your function.</p>
<p>Note that <em>defining</em> a function doesn't create a new stack frame, it's the <em>calling</em> a function. For instance something like this:</p>
<pre><code>def say_hello():
    name = input('What is your name?')
    print('Hello, {}'.format(name))
</code></pre>
<p>Your global frame is just going to hold one reference: <code>say_hello</code>. You can see that by checking out what's in the local namespace (in Python you pretty much have a 1:1 relationship between namespace, scope, and stack frames):</p>
<pre><code>print(locals())
</code></pre>
<p>You'll see something that looks like this:</p>
<pre><code>{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x1019bb320&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/private/tmp/fun.py', '__cached__': None, 'say_hello': &lt;function say_hello at 0x101962d90&gt;}
</code></pre>
<p>Note the dunder (short for double underscore  double underscore) names - those are automagically provided, and for the purposes of our discussion you can ignore them. That leaves us with:</p>
<pre><code>{'say_hello': &lt;function say_hello at 0x101962d90&gt;}
</code></pre>
<p>That <code>0x</code> bit is the memory address where the function itself lives. So here, our global stack/frame contains just that one value. If you call your function and then check <code>locals()</code> again, you'll see that <code>name</code> isn't there. That's because when you call the function you create a new stack frame and the variable is assigned there. You can prove this by adding <code>print(locals())</code> at the end of your function. Then you'll see something like this:</p>
<pre><code>{'name': 'Arthur, King of the Brits'}
</code></pre>
<p>No dunder names here. You'll also note that this doesn't show a memory address. If you want to know where this value lives, there's a function for that.</p>
<pre><code>def say_hello():
    name = input('What is your name?')
    print('hello {}'.format(name))
    print(locals())
    print(id(name))
    return name

print(id(say_hello()))
</code></pre>
<p>That's what the example means when it's talking about a <strong>frame</strong>.</p>
<p>But what about objects? Well, in Python, <em>everything</em> is an object. Just try it:</p>
<pre><code>&gt;&gt;&gt; isinstance(3, object)
True
&gt;&gt;&gt; isinstance(None, object)
True
&gt;&gt;&gt; isinstance('hello', object)
True
&gt;&gt;&gt; isinstance(13.2, object)
True
&gt;&gt;&gt; isinstance(3j, object)
True
&gt;&gt;&gt; def fun():
...  print('hello')
... 
&gt;&gt;&gt; isinstance(fun, object)
True
&gt;&gt;&gt; class Cool: pass
... 
&gt;&gt;&gt; isinstance(Cool, object)
True
&gt;&gt;&gt; isinstance(Cool(), object)
True
&gt;&gt;&gt; isinstance(object, object)
True
&gt;&gt;&gt; isinstance(isinstance, object)
True
&gt;&gt;&gt; isinstance(True, object)
True
</code></pre>
<p>They're <em>all</em> objects. But they may be different objects. And how can you tell? With <code>id</code>:</p>
<pre><code>&gt;&gt;&gt; id(3)
4297619904
&gt;&gt;&gt; id(None)
4297303920
&gt;&gt;&gt; id('hello')
4325843048
&gt;&gt;&gt; id('hello')
4325843048
&gt;&gt;&gt; id(13.2)
4322300216
&gt;&gt;&gt; id(3j)
4325518960
&gt;&gt;&gt; id(13.2)
4322300216
&gt;&gt;&gt; id(fun)
4322635152
&gt;&gt;&gt; id(isinstance)
4298988640
&gt;&gt;&gt; id(True)
4297228640
&gt;&gt;&gt; id(False)
4297228608
&gt;&gt;&gt; id(None)
4297303920
&gt;&gt;&gt; id(Cool)
4302561896
</code></pre>
<p>Note that you also can compare whether or not two objects are the <em>same</em> object by using <code>is</code>.</p>
<pre><code>&gt;&gt;&gt; True is False
False
&gt;&gt;&gt; True is True
True
&gt;&gt;&gt; 'hello world' is 'hello world'
True
&gt;&gt;&gt; 'hello world' is ('hello ' + 'world')
False
&gt;&gt;&gt; 512 is (500+12)
False
&gt;&gt;&gt; 23 is (20+3)
True
</code></pre>
<p>Ehhhhh...? Wait a minute, what happened there? Well, as it turns out, <code>python</code>(that is, CPython) <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">caches small integers</a>. So the object <code>512</code> is different from the object that is the result of the object <code>500</code> added to the object <code>12</code>.</p>
<p>One important thing to note is that the assignment operator <code>=</code> <em>always</em> assigns a new name to the <em>same object</em>. For example:</p>
<pre><code>&gt;&gt;&gt; x = 592
&gt;&gt;&gt; y = 592
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x = y
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; x == y
True
</code></pre>
<p>And it doesn't matter how many other names you give an object, or even if you pass the <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument">object around to different frames</a>, you still have the same object.</p>
<p>But as you're starting to gather, it's important to understand the difference between operations that <em>change</em> an object and operations that produce a <em>new</em> object. Generally speaking you have a <a href="https://docs.python.org/3/reference/datamodel.html" rel="noreferrer">few immutable types</a> in Python, and operations on them will produce a new object.</p>
<p>As for your question, when do you want to change objects and when do you want to keep them the same is actually looking at it the wrong way. You want to use a mutable type when you want to change things, and you want to use an immutable type if you don't want things to change.</p>
<p>For instance, say you've got a group, and you want to add members to the group. You might use a mutable type like a list to keep track of the group, and an immutable type like strings to represent the members. Like this:</p>
<pre><code>&gt;&gt;&gt; group = []
&gt;&gt;&gt; id(group)
4325836488
&gt;&gt;&gt; group.append('Sir Lancelot')
&gt;&gt;&gt; group.append('Sir Gallahad')
&gt;&gt;&gt; group.append('Sir Robin')
&gt;&gt;&gt; group.append("Robin's Minstrels")
&gt;&gt;&gt; group.append('King Arthur')
&gt;&gt;&gt; group
['Sir Lancelot', 'Sir Gallahad', 'Sir Robin', "Robin's Minstrels", 'King Arthur']
</code></pre>
<p>What happens when a member of the group is eaten?</p>
<pre><code>&gt;&gt;&gt; del group[-2]  # And there was much rejoicing
&gt;&gt;&gt; id(group)
4325836488
&gt;&gt;&gt; group
['Sir Lancelot', 'Sir Gallahad', 'Sir Robin', 'King Arthur']
</code></pre>
<p>You'll notice that you still have the same group, just the members have changed.</p>
</div>
<span class="comment-copy">If we're talking about the call stack, a <a href="https://en.wikipedia.org/wiki/Call_stack#STACK-FRAME" rel="nofollow noreferrer">frame</a> is the thing that contains all of the locally created objects of your most immediate scope. In your screenshot, the whole blue box is one frame, and contains the objects associated to the names <code>l1</code>, <code>l2</code>, and <code>item</code>. You don't have direct control over the frame; you only have control over objects and their names.</span>
<span class="comment-copy">Very instructive answer. Follow-up question: do all objects live on the heap?</span>
