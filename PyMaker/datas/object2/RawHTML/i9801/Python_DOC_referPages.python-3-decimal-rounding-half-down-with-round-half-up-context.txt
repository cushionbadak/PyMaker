<div class="post-text" itemprop="text">
<p>Can anybody explain or propose a fix for why when I round a decimal in Python 3 with the context set to round half up, it rounds 2.5 to 2, whereas in Python 2 it rounds correctly to 3:</p>
<p>Python 3.4.3 and 3.5.2:</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; context = decimal.getcontext()
&gt;&gt;&gt; context.rounding = decimal.ROUND_HALF_UP
&gt;&gt;&gt; round(decimal.Decimal('2.5'))
2
&gt;&gt;&gt; decimal.Decimal('2.5').__round__()
2
&gt;&gt;&gt; decimal.Decimal('2.5').quantize(decimal.Decimal('1'), rounding=decimal.ROUND_HALF_UP)
Decimal('3')
</code></pre>
<p>Python 2.7.6:</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; context = decimal.getcontext()
&gt;&gt;&gt; context.rounding = decimal.ROUND_HALF_UP
&gt;&gt;&gt; round(decimal.Decimal('2.5'))
3.0
&gt;&gt;&gt; decimal.Decimal('2.5').quantize(decimal.Decimal('1'), rounding=decimal.ROUND_HALF_UP)
Decimal('3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Notice that when you call <code>round</code> you are getting a float value as a result, not a <code>Decimal</code>. <code>round</code> is coercing the value to a float and then rounding that according to the rules for rounding a float.</p>
<p>If you use the optional <code>ndigits</code> parameter when you call <code>round()</code> you will get back a Decimal result and in this case it will round the way you expected.</p>
<pre><code>Python 3.4.1 (default, Sep 24 2015, 20:41:10) 
[GCC 4.9.2 20150212 (Red Hat 4.9.2-6)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import decimal
&gt;&gt;&gt; context = decimal.getcontext()
&gt;&gt;&gt; context.rounding = decimal.ROUND_HALF_UP
&gt;&gt;&gt; round(decimal.Decimal('2.5'), 0)
Decimal('3')
</code></pre>
<p>I haven't found where it is documented that <code>round(someDecimal)</code> returns an int but <code>round(someDecimal, ndigits)</code> returns a decimal, but that seems to be what happens in Python 3.3 and later. In Python 2.7 you always get a float back when you call <code>round()</code> but Python 3.3 improved the integration of <code>Decimal</code> with the Python builtins.</p>
<p>As noted in a comment, <code>round()</code> delegates to <code>Decimal.__round__()</code> and that indeed shows the same behaviour:</p>
<pre><code>&gt;&gt;&gt; Decimal('2.5').__round__()
2
&gt;&gt;&gt; Decimal('2.5').__round__(0)
Decimal('3')
</code></pre>
<p>I note that the documentation for <code>Fraction</code> says:</p>
<pre><code>__round__()
__round__(ndigits)
The first version returns the nearest int to self, rounding half to even.
The second version rounds self to the nearest multiple of Fraction(1, 10**ndigits)
(logically, if ndigits is negative), again rounding half toward even. 
This method can also be accessed through the round() function.
</code></pre>
<p>Thus the behaviour is consistent in that with no argument it changes the type of the result and rounds half to even, however it seems that <code>Decimal</code> fails to document the behaviour of its <code>__round__</code> method.</p>
<p>Edit to note as Barry Hurley says in the comments, <code>round()</code> is documented as returning a <code>int</code> if called without the optional arguments and a "floating point value" if given the optional argument. <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#round</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on @Duncan's answer, the <code>round</code> builtin function changed between python 2 and python 3 to round to the nearest even number (which is the norm in statistics).  </p>
<p>Python2 docs:</p>
<blockquote>
<p>...if two multiples are equally close, rounding is done away
  from 0 (so, for example, round(0.5) is 1.0 and round(-0.5) is -1.0).</p>
</blockquote>
<p>Python3 docs:</p>
<blockquote>
<p>...if two multiples are equally close, rounding is done toward the even
  choice (so, for example, both round(0.5) and round(-0.5) are 0, and
  round(1.5) is 2)</p>
</blockquote>
<p>Since <code>round</code> converts to <code>float</code> if no argument is given for <code>ndigits</code> (credit to @Duncan's answer), <code>round</code> behaves the same way as it would for <code>float</code>s.</p>
<p>Examples (in python3):</p>
<pre><code>&gt;&gt;&gt; round(2.5)
2
&gt;&gt;&gt; round(2.500000001)
3
&gt;&gt;&gt; round(3.5)
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a combination of changes between the rounding mode of <code>round</code> in Python 2 vs 3 and the re-implementation of <code>Decimal</code> from Python to <code>C</code> (See <em>"Other final large-scale changes"</em> in the <a href="https://www.python.org/dev/peps/pep-0398/#features-for-3-3" rel="nofollow noreferrer">Features for 3.3 section PEP 398</a>).</p>
<p>For <code>round</code>, the rounding strategy changed as can be seen in <a href="http://docs.python.org/py3k/whatsnew/3.0.html" rel="nofollow noreferrer">What's New In Python 3.0</a> [Also see <a href="https://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior">Python 3.x rounding behavior</a> ]. Additionally, <code>round</code> in Python <code>3</code> first tries to <a href="https://github.com/python/cpython/blob/ee1e01ceb00e29487c229246bbae0c63da135cb3/Python/bltinmodule.c#L2037" rel="nofollow noreferrer">find an appropriate <code>__round__</code></a> method defined for the object passed:</p>
<pre><code>&gt;&gt;&gt; round('1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: type str doesn't define __round__ method
</code></pre>
<p>While in Python <code>2.x</code> it first tries to <a href="https://hg.python.org/cpython/file/2.7/Python/bltinmodule.c#l2182" rel="nofollow noreferrer">coerce it specifically to a <code>float</code></a> and then round it: </p>
<pre><code>&gt;&gt;&gt; round('1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: a float is required
</code></pre>
<p>For <code>Decimal</code>, in Python <code>2</code>, the implementation even lacked a <code>__round__</code> method to be called: </p>
<pre><code>&gt;&gt;&gt; Decimal.__round__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'Decimal' has no attribute '__round__'
</code></pre>
<p>So, calling <code>round</code> on a <code>Decimal</code> object coerced it to a <code>float</code> which  got <a href="https://hg.python.org/cpython/file/2.7/Python/bltinmodule.c#l2215" rel="nofollow noreferrer">rounded using <code>_Py_double_round</code></a>; this resulted in a <code>float</code> always getting returned irregardless of if a value for <code>ndigits</code> was supplied. <code>decimal</code> is implemented in pure Python for <code>2.x</code> and (was?) for Python <code>3</code> until <code>3.2</code>.</p>
<p><a href="https://github.com/python/cpython/blob/1d0d35423dd0c13cd8306f3351e86873e6af5c5f/Modules/_decimal/_decimal.c#L3614" rel="nofollow noreferrer">In Python <code>3.3</code> it got shinny new <code>__round__</code> method</a> as it was re-implemented in <code>C</code>:</p>
<pre><code>&gt;&gt;&gt; Decimal.__round__
&lt;method '__round__' of 'decimal.Decimal' objects&gt;
</code></pre>
<p>and now, it gets picked up by <code>round</code> when <code>round(&lt;Decimal_object&gt;)</code> is invoked.</p>
<p>This, mapped to <code>PyDec_Round</code> in <code>C</code>, now <a href="https://github.com/python/cpython/blob/1d0d35423dd0c13cd8306f3351e86873e6af5c5f/Modules/_decimal/_decimal.c#L3657" rel="nofollow noreferrer">returns a PyLong</a> (an integer) using the default context (<code>ROUND_HALF_EVEN</code>) if the argument <code>ndigits</code> is not supplied and, if it is, calls <a href="https://github.com/python/cpython/blob/1d0d35423dd0c13cd8306f3351e86873e6af5c5f/Modules/_decimal/_decimal.c#L3648" rel="nofollow noreferrer"><code>quantize</code></a> on it and returns a new rounded <code>Decimal</code> object.</p>
</div>
<span class="comment-copy">Thanks @Duncan for the explanation, it is always good to try understand these things. It seems very odd that a different <i>type</i> is returned depending on whether you specify ndigits or not.</span>
<span class="comment-copy">As an add-on, python 3 docs state that it delegates to <code>number.__round__(ndigits)</code> and the <code>decimal</code> module implements has it's own <code>__round__</code> method</span>
<span class="comment-copy">@Dunca, it looks to be an int, rather than float though: "If ndigits is omitted or is None, it returns the nearest integer to its input." <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#round</a></span>
<span class="comment-copy">@BarryHurley right you are, so that's the documentation link that I didn't spot (though 'floating point value' isn't perhaps the best way to express it). I've updated my answer to include this.</span>
<span class="comment-copy">Thanks @Billy, but both round(1.5) and round(2.5) give 2 in Python 3, which I presume is due to how those 1.5 and 2.5 floats are represented internally. round in Python 2 returns floats for these, versus ints int Python 3.</span>
<span class="comment-copy">It has nothing to do with internal representations.  Python's floating point implementation can represent 1.5 and 2.5 <i>precisely</i> (i.e. no floating-point rounding errors like you would get with the number 1.1).  Since 1.5 is <i>exactly</i> equal in distance from 1 and 2, python 3 rounds to the nearest even number, which is 2.  Similarly, 2.5 is <i>exactly</i> between 2 and 3, so it is rounded to the nearest even number, which is again 2.</span>
