<div class="post-text" itemprop="text">
<p>I have query resultset data in format of tuple of dict. I want to group the data into tuple of tuple of dict based on specific condition.</p>
<p>Real Output:</p>
<pre><code>({'col1': 2014},
 {'col1': 2013},
 {'col1': 2014},
 {'col1': 2013},
 {'col1': 2015},
 {'col2': '24'})
</code></pre>
<p>Expected output: Here we are grouping base on year</p>
<pre><code>(({'col1': 2014}, {'col1': 2014}),
 ({'col1': 2013}, {'col1': 2013}),
 ({'col1': 2015}, {'col2': '24'}))
</code></pre>
<p>Please guide us to get the data, while we are processing the query instead of processing one by one records and converting into specific formate.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can sort the dicts based on the year and then use <a href="https://docs.python.org/3.5/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> with year as <code>key</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; t = ({'col1':2014},{'col1':2013},{'col1':2014},{'col1':2013},{'col1':2015})
&gt;&gt;&gt; key = lambda x: x['col1']
&gt;&gt;&gt; tuple(tuple(g) for k, g in groupby(sorted(t, key=key), key))
(({'col1': 2013}, {'col1': 2013}), ({'col1': 2014}, {'col1': 2014}), ({'col1': 2015},))
</code></pre>
<p><code>groupby</code> will group the consecutive elements with same key and return <code>(key, iterable)</code> tuples. Then each iterable is converted to tuple within generator expression which is given as a parameter to <a href="https://docs.python.org/3/library/functions.html#func-tuple" rel="nofollow noreferrer"><code>tuple</code></a>. </p>
<p><strong>Update</strong>: The above one-liner has <strong>O(n log n)</strong> time complexity since it sorts the data. With couple more lines the task can be completed <strong>O(n)</strong> time by utilizing <a href="https://docs.python.org/3.5/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; t = ({'col1':2014},{'col1':2013},{'col1':2014},{'col1':2013},{'col1':2015})
&gt;&gt;&gt; dd = defaultdict(list)
&gt;&gt;&gt; for d in t:
...     dd[d['col1']].append(d)
...
&gt;&gt;&gt; tuple(tuple(v) for k, v in dd.items())
(({'col1': 2013}, {'col1': 2013}), ({'col1': 2014}, {'col1': 2014}),({'col1': 2015},))
</code></pre>
<p>Note that this will return the groups in arbitrary order since <code>dict</code> is unordered collection. If you need to process the data in "full" groups (only one group for each year) and you can't get the DB to return the data in sorted order this is the best you can do.</p>
<p>In case you can get the data from DB by batches in sorted order then you can still use <code>groupby</code> without needing to pull everything before:</p>
<pre><code>from itertools import groupby

cursor = iter([2013, 2013, 2014, 2014, 2014, 2015, 2015])

def get_batch():
    batch = []
    try:
        for _ in range(3):
            batch.append({'col1': next(cursor)})
    except StopIteration:
        pass

    print('Got batch')
    return batch

def fetch():
    while True:
        batch = get_batch()
        if not batch:
            break

        yield from batch

for k, g in groupby(fetch(), lambda x: x['col1']):
    print('Group: {}'.format(tuple(g)))
</code></pre>
<p>Output:</p>
<pre><code>Got batch
Group: ({'col1': 2013}, {'col1': 2013})
Got batch
Group: ({'col1': 2014}, {'col1': 2014}, {'col1': 2014})
Got batch
Got batch
Group: ({'col1': 2015}, {'col1': 2015})
</code></pre>
</div>
<span class="comment-copy">Why do you want <code>{'col2': '24'}</code> to be in the same group as <code>2015</code>?</span>
<span class="comment-copy">same row may have more the one column, so i need to group the rest of the column as well, but as of now, I need to group the data based on year, just ignore 24. I need the output as (({'col1': 2014}, {'col1': 2014}),  ({'col1': 2013}, {'col1': 2013}),  ({'col1': 2015}))</span>
<span class="comment-copy">Then please <a href="https://stackoverflow.com/posts/40783003/edit">edit</a> your question.</span>
<span class="comment-copy">Thanks, the given solution is working fine. but may i get the data in the specified at the time of fetching the data from db, instead of traversing each and every record and sorting the data and grouping the same, because we have huge amount of data, so it will be time taken process.</span>
<span class="comment-copy">@AsifNawaz Expanded the answer a bit. In short if you can get the DB to return the data in sorted order then you can use <code>groupby</code> without having to pull everything before. In case the data comes in random order then you have to pull everything but you can skip sorting unless the order of the groups matters to you.</span>
<span class="comment-copy">Are you not missing the <code>24</code> entry, e.g. <code>({'col1': 2015}, {'col2': '24'}))</code>?</span>
<span class="comment-copy">@pylang Yes, it's intentionally ignored based on the comments in the original question. Examples in the answer could be expanded to do the filtering before other processing: <code>(d for d in t if 'col1' in d)</code></span>
