<div class="post-text" itemprop="text">
<p>I am trying to create a polygon class that returns the area and perimeter when given the sides and length from user input. However, it doesn't take the two variables I'm trying to pass into the <code>__init__</code> method. The sides and length must be private and must be received through user input.</p>
<pre><code>import math

class Polygon:
    use = (input("Enter in the sides and length of sides seperated by a comma"))
    ans = use.split(",")
    __numofSides = ans[0]
    __sideLength = ans[1]

    def __init__(self, __numofSides, __sideLength):
        self.__numofSides = __numofSides
        self.__sideLength = __sideLength

    def get__numofSides(self):
        self.__numofSides = ans[0]
        return __numofSides

    def get__sideLength(self):
        self.__sideLength = ans[1]
        return __sideLength

    def perimeter(self, __numofSides,__sideLength):
        peri = self. __numofSides * self.__sideLength
        return peri

    def area(self, __numofSides, __sideLength):
        area = (((__sideLength **2) * __numofSides) / (tan(4) *(math.pi/__numofSides))) 
        return area

    def __str___(self,):
        print("Number of Sides: {}\n Length of Sides: {}\n" \
              "Perimeter is: {}\n Area is: {}".format(__numofSides,__sideLength,peri,area))

def main():
    p1 = Polygon()
    p1.perimeter()
    p1.area()
    p1.__str__()

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that you're not passing anything to <code>__init__</code>, you're creating class level variables when you do this:</p>
<pre><code>class Foo:
    x = 42
    y = input("Don't do this, this is bad")
</code></pre>
<p>These will <em>only</em> be called once per program* as well, so you'll never be able to provide different values, if that's something you need.
If you want to pass arguments to a function, you do that when you create the instance of the class:</p>
<pre><code>class Polygon:
    def __init__(self, num_of_sides, side_length):
        self._num_of_sides = num_of_sides
        self._side_length = side_length
</code></pre>
<p>As others have mentioned, private variables in Python aren't <em>actually</em> inaccessible, though there are ways to enforce that they are immutable, as jonrsharpe pointed out it his answer. You could also investigate <code>__slots__</code> for other options.</p>
<blockquote>
<p>*<sup><sub>Per import, which is <em>usually</em> once per program, but there are ways you can get around that, but that's even worse. Unless you're going for an obfuscated Python contest, don't do that.</sub></sup></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You seem to have a fundamental misunderstanding of how OOP works in Python. When you instantiate a class, the <code>__init__()</code> method is called, and usually you assign the arguments given to instance variables, like so:</p>
<pre><code>class Pet(object):

    def __init__(self, name):
        self._name = name # argument stored in self._name
</code></pre>
<p>Then in whatever methods you'd like to make use of those, you can access them through the instance:</p>
<pre><code>def get_name(self):
    return self._name
</code></pre>
<p>Notice that all this method does is return <code>self._name</code> back to the caller. There's a common idiom for this situation using <a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html" rel="nofollow noreferrer">decorators</a>:</p>
<pre><code>@property
def name(self):
    return self._name
</code></pre>
<p>The advantage of this compared to  <code>get_name()</code> is twofold. First, you can call  the method without parentheses as if it was an instance variable:</p>
<pre><code>my_pet = Pet('Rosita')
print(my_pet.name) 

&gt;&gt; Rosita
</code></pre>
<p>Secondly, if the user later tried to overwrite it with something else Python would raise an AttributeError:</p>
<pre><code>my_pet = Pet('Rosita')
my_pet.name = 'Maggie'

&gt;&gt; Traceback (most recent call last):
&gt;&gt; File "&lt;stdin&gt;", line 1, in &lt;module&gt;
&gt;&gt; AttributeError: can't set attribute
</code></pre>
<p>In regards to your <code>__repr__</code> method, what I think you meant was this:</p>
<pre><code>def __repr__(self):
    return "&lt;Polygon sides={}; length={}; perimeter={}; area={}&gt;".format(
        self.sides, self.side_length, self.perimeter, self.area)
</code></pre>
<p><code>__repr__</code> is called when you do <code>print(my_polygon)</code> or <code>str(my_polygon)</code> so it should return a string.</p>
<p>Finally, you may have noticed I have named the instance variables with one leading underscore rather than two. If you want the users of your class to know that a particular instance variable is "private" and they should not mess with it, it's better to prefix its name with only one underscore. The reason for that is that it allows you to have acessor methods and instance variables with the same name, while at the same time avoiding <a href="https://stackoverflow.com/questions/7456807/python-name-mangling">name mangling</a>. Names with two leading underscores are mangled, and thus generally not recommended. </p>
<p>Taking all of this into account, here's a rewrite of your code:</p>
<pre><code>import math

class RegularPolygon(object):

    def __init__(self, sides, side_length):
        self._sides = sides
        self._side_length = side_length

    @property
    def sides(self):
        return self._sides

    @property
    def side_length(self):
        return self._side_length

    @property
    def perimeter(self):
        return self.sides * self.side_length

    @property
    def area(self):
        return ((self.side_length**2 * self._sides) 
                / (4 * math.tan(math.pi / self.sides)))

    def __repr__(self):
        return "&lt;Polygon sides={}; length={}; perimeter={}; area={}&gt;".format(
            self.sides, self.side_length, self.perimeter, self.area)


if __name__ == '__main__':
    poly = RegularPolygon(5, 7)
    print(poly)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a quick code review of your code (no math consideration):</p>
<p>You can inherit from <code>object</code> (to be compatible with Python 2):</p>
<pre><code>class Polygon(object):
</code></pre>
<p>Simplify the parameters names, don't use double underscores:</p>
<pre><code>    def __init__(self, sides, length):
        self.sides = sides
        self.length = length
</code></pre>
<p>Use the instance variable <code>self.sides</code> and <code>self.length</code>, drop the parameters:</p>
<pre><code>    def perimeter(self):
        return self.sides * self.length
</code></pre>
<p>Replace <code>tan()</code> by <code>math.tan()</code></p>
<pre><code>    def area(self):
        return ((self.length ** 2) * self.sides) / (math.tan(4) * (math.pi / self.sides))
</code></pre>
<p>In your <code>main()</code> function:</p>
<p>(With Python 2, use <code>raw_input</code> instead of <code>input</code>.)</p>
<pre><code>use = input("Enter in the sides and length of sides separated by a comma: ")
ans = use.split(",")
</code></pre>
<p>Convert string values to <code>int</code></p>
<pre><code>sides = int(ans[0])
length = int(ans[1])

p1 = Polygon(sides, length)
</code></pre>
<p>Use <code>print()</code> function to print the result</p>
<pre><code>print(p1.perimeter())
print(p1.area())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I would write this:</p>
<pre><code>from collections import namedtuple
from math import pi, tan

class Polygon(namedtuple('Polygon', 'sides,length')):

    PROMPT = 'Enter in the number and length of sides, separated by a comma'

    @property
    def perimeter(self):
        return self.sides * self.length

    @property
    def area(self):
        return (self.sides * (self.length ** 2)) / (4 * tan(pi / self.sides))

    @classmethod
    def from_input(cls):
        return cls(*map(int, input(cls.PROMPT).split(',')))
</code></pre>
<p>Why? Because:</p>
<ul>
<li><p>inheriting from a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a> makes the instance immutable, so you can't reassign <code>sides</code> and <code>length</code> after initial creation, while giving you sensible equality comparison and <code>__repr__</code> formatting for free:</p>
<pre><code>&gt;&gt;&gt; square = Polygon(4, 1)
&gt;&gt;&gt; square
Polygon(sides=4, length=1)
&gt;&gt;&gt; square.sides = 5
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre></li>
<li><p>Using <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>@property</code></a> means you can easily access the calculated attributes, again in a read-only way:</p>
<pre><code>&gt;&gt;&gt; square.area
1.0000000000000002
&gt;&gt;&gt; square.perimeter
4
&gt;&gt;&gt; square.area = 7
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre></li>
<li><p>Using <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>@classmethod</code></a> keeps the logic for creating an object from user input within the class, where it belongs:</p>
<pre><code>&gt;&gt;&gt; hexagon = Polygon.from_input()
Enter in the number and length of sides, separated by a comma 6,2
&gt;&gt;&gt; hexagon
Polygon(sides=6, length=2)
&gt;&gt;&gt; hexagon.area
10.392304845413264
&gt;&gt;&gt; hexagon.perimeter
12
</code></pre>
<p>In your current implementation, your input runs once when the class is defined, not when the user actually wants to create an instance.</p></li>
</ul>
<blockquote>
<p><strong>Note</strong>: I've assumed you're using Python 3.x - if not you should use <code>raw_input</code>. Also your classes should inherit from <code>object</code>, when
  you're not using e.g. <code>namedtuple</code>.</p>
</blockquote>
</div>
<span class="comment-copy">If you're going to post Python code, make sure that you reproduce your indentation accurately. Badly indented Python code is nonsense.</span>
<span class="comment-copy">Don't use two underscores, it makes the Python interpreter mangle the name.</span>
<span class="comment-copy"><i>'The sides and length must be private"</i> - then Python is probably not the language for you, even with <code>__name_mangling</code> they're accessible. If you want it to be immutable, consider subclassing a <code>namedtuple</code>. If you want protected attributes, use <code>@property</code>.</span>
<span class="comment-copy">Also you're not using <code>self</code> within half of the methods and <code>__str__</code> is misspelled. And the area formula isn't correct.</span>
<span class="comment-copy">What class is this for? It looks suspiciously like homework. We like to know what classes and teachers we can recommend people avoid ;)</span>
