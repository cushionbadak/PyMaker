<div class="post-text" itemprop="text">
<p>I have the following files in a directory</p>
<pre><code>Co-sqp-C70.pdos_atm*5*C*_wfc*2*p*
Copilot
</code></pre>
<p>Using <code>ls Co-sqp*</code> filters so that the output is</p>
<pre><code>Co-sqp-C70.pdos_atm*5*C*_wfc*2*p*
</code></pre>
<p>However, in a python script, I used</p>
<pre><code>cmd = ["ls", self.prefix+".pdos_atm*wfc*"]
output = subprocess.Popen(cmd,stdout=subprocess.PIPE,shell=True).communicate()[0]
print(output)
return output.splitlines()
</code></pre>
<p>and the output contains both files</p>
<pre><code>Co-sqp-C70.pdos_atm*5*C*_wfc*2*p*
Copilot
</code></pre>
<p>What am I doing wrong in the python code that causes the script to not filter the ls output correctly?</p>
</div>
<div class="post-text" itemprop="text">
<p>To expand on IanAuld's comment, I would like to offer you two solutions that solve your problem without relying on calling a subprocess. Using subprocesses is kind of clunky and for finding files, python offers several powerful and more pythonic options.</p>
<p>I created a folder named files containing two files with the names you described and a python script in the parent folder:</p>
<pre><code>find_files.py
files/
    Co-sqp-C70.pdos_atm*5*C*_wfc*2*p*
    Copilot
</code></pre>
<p>Now there are several options to do this:</p>
<pre><code>import glob
import os

# a glob solution
# you can use wildcards etc like in the command line
print(glob.glob("files/Co-sq*"))

# an os solution
# you can walk through all files and only print/ keep those that start with your desired string
for root, dirs, files in os.walk("files/"):
    for file in files:
        if file.startswith("Co-sq"):
            print(file)
</code></pre>
<p>I would prefer the <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">glob</a> solution for finding files, because it is quite flexible and easy to use. As the name suggests, glob allows you to use <a href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="nofollow noreferrer">glob patterns</a> as you know them from the command line.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your command isn't <code>bash</code> it's <code>ls</code>.  There's no shell involved to expand your filename pattern <code>self.prefix+".pdos_atm*wfc*"</code>, so <code>ls</code> gets that as a literal argument, as if you'd entered (in a shell)</p>
<pre class="lang-sh prettyprint-override"><code>ls 'Co-sqp-C70.pdos_atm*wfc*'
</code></pre>
<p>You have at least these options:</p>
<ol>
<li><p>Invoke a shell to expand the pattern:</p>
<pre><code>cmd = [ "sh", "-c", "ls " + self.prefix + ".pdos_atm*wfc*"]
</code></pre>
<p>Equivalently:</p>
<pre><code>cmd = "ls " + self.prefix + ".pdos_atm*wfc*"
</code></pre>
<p>This is risky if <code>self.prefix</code> isn't guaranteed to be shell-clean.</p></li>
<li><p>Expand the glob, and pass the results to <code>ls</code>:</p>
<pre><code>import glob
cmd = ["ls"] + glob.glob(self.prefix+".pdos_atm*wfc*")
</code></pre>
<p>You're still using <code>ls</code>, which is not intended to give parseable output.  Don't do any more than simply passing the output to a user (e.g. in a log file).</p></li>
<li><p>Expand the glob, and process the results in python:</p>
<pre><code>import glob
for file in glob.glob(self.prefix+".pdos_atm*wfc*"):
    some_function(file)
</code></pre>
<p>You should do this if you want to examine the file entries in any way.</p></li>
</ol>
</div>
<span class="comment-copy">You have a filename with embedded asterisks?</span>
<span class="comment-copy">Don't use bash (unless you absolutely need to) in Python use Python. Look in to the <code>os</code> and <code>glob</code> libraries</span>
<span class="comment-copy">@cdarke it's an output file from a program that runs calculations. I have no way of editing the output file name format, so the script is meant to neaten up file names</span>
<span class="comment-copy">Use a string instead of a list for your <code>cmd</code>:  <code>cmd = "ls " + prefix + ".pdos_atm*wfc*"</code>   (Note the space after the <code>ls</code>)</span>
