<div class="post-text" itemprop="text">
<pre><code>class person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__ (self, name, age):
        return ('name: {}\nage: '.format(self.name,self.age))

class teacher(person):
    def __init__(self,name,age,sub):
        person.__init__(self,name,age)
        self.sub = sub
    def __str__(self):
        return (person.__str__(self)+'sub: {}'.format(self.sub))

class student(person):
    def __init__(self,name,age,loan):
        person.__init__(self,name,age)
        self.loan = loan
    def __str__(self):
        return (person.__str__(self)+'loan: {}'.format(self.loan))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__()</code></a> is called by <code>print()</code>, and it only takes one parameter, <code>self</code>.</p>
<p>I guess you're misunderstanding something about the use of classes. <code>__str__(self)</code> is supposed to print its own already-stored representation of the person, not take new parameters to print. e.g.</p>
<pre><code>class person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):   # &lt;-- changed this line
        return ('name: {}\nage: {}'.format(self.name,self.age)) # &lt;-- added another {} here, too
</code></pre>
<p>Or that was just a typo in the method definition?</p>
<p><a href="https://repl.it/E5eI/0" rel="nofollow noreferrer">Try online at http://repl.it</a></p>
</div>
<span class="comment-copy">Welcome to SO, its usually nice to actually include your question in the text, it make a question more readable.</span>
<span class="comment-copy">It doesn't take only one parameter, <code>print</code> (which in effect calls <code>str(obj)</code> only supplies it with one parameter; you could <i>legally</i> do <code>person().__str__(1, 2)</code> but that is just wrong on so many different levels!</span>
