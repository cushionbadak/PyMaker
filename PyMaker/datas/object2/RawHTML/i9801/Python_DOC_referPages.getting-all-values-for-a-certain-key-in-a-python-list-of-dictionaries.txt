<div class="post-text" itemprop="text">
<p>I have a list in Python which contains a "nested" dictionary in it. So my list looks like follows:</p>
<pre><code>List = [{'entry' : {'Name' : 'Smith', 'Age' : 25}}, {'entry' : {'Name' : 'Mary', 'Age' : 28}}]
</code></pre>
<p>I would like to return all the values of the key 'Name' from my list without using a loop. So if I use a loop it works since this works for single entries of the list. For example: <code>List[0]['entry']['Name']</code> works and returns 'Smith'. However, I need something like <code>List[:]['entry']['Name']</code> which should return a List with the entries 'Smith' and 'Mary' in it. Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>I had posted the <code>reduce()</code> method as a curiosity, but since the answer was accepted, I'm posting the <code>timeit</code> results, to compare the performance with the other answers on this ticket.</p>
<pre><code>from timeit import timeit
import functools

def _reduce_py2(the_list):

    return reduce(lambda l, src: l.append(src['entry']['Name']) or l, the_list, [])

def _reduce_py3(the_list):

    return functools.reduce(lambda l, src: l.append(src['entry']['Name']) or l, the_list, [])

def _map_py2(the_list):

    return map(lambda d: d['entry']['Name'], the_list)

def _map_py3(the_list):

    return [i for i in map(lambda d: d['entry']['Name'], the_list)]

def _list(the_list):

    return [d['entry']['Name'] for d in the_list]

the_list = []
for i in range(1000):
    the_list += [{'entry' : {'Name' : 'Smith%s' % i, 'Age' : i}}]


reps = 1000

# Compare timings

print('Reduce:              ', timeit('c(the_list)', 'from __main__ import _reduce_py2 as c, the_list', number=reps))
print('Map:                 ', timeit('c(the_list)', 'from __main__ import _map_py2 as c, the_list', number=reps))
print('List comprehension:  ', timeit('c(the_list)', 'from __main__ import _list as c, the_list', number=reps))
</code></pre>
<p>Results:</p>
<pre><code>Py 2
Reduce:               0.2090609073638916
Map:                  0.136185884475708
List comprehension:   0.07403087615966797

Py 3
Reduce:               0.20160907896934077
Map:                  0.17127344600157812
List comprehension:   0.06799810699885711
</code></pre>
<p>Conclusion, <code>list comprehension</code> is the fastest method. <code>map</code> on python 3 returns a generator, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" rel="nofollow noreferrer"><em>lambda expression</em></a> with <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a> as:</p>
<pre><code>&gt;&gt;&gt; map(lambda d: d['entry']['Name'], List)
['Smith', 'Mary']
</code></pre>
<p>Even though you do not see loop over here, but internally <code>map()</code> also iterates over the list. You can not skip iterating over the list in order to achieve what you want.</p>
<p>Better way will be to use <em>list comprehension</em> as:</p>
<pre><code>&gt;&gt;&gt; [d['entry']['Name'] for d in List]
['Smith', 'Mary']
</code></pre>
<p>OR, if there is a possibility of any key missing in the nested dict, you may add filter as:</p>
<pre><code>&gt;&gt;&gt; [d['entry']['Name'] for d in List if 'entry' in d and 'Name' in d['entry']]
['Smith', 'Mary']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code> [o['entry']['Name'] for o in List]
</code></pre>
<p>Result: ['Smith', 'Mary']</p>
<p>Note that it is still loop. You can't do such thing without loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately this is not possible in python, although it would be a very useful feature. Similar features are often available only in domain-specific query languages (for example, I think the Django ORM supports similar indexing), but not in any general purpose language I can think of. </p>
<p>Your best approach is</p>
<pre><code>[item['Entry']['Name'] for item in List]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure why you can't use loops but would list comprehension work?  Let me know as to the reason and perhaps I could recommend something else.</p>
<pre><code>a = [{'entry' : {'Name' : 'Smith', 'Age' : 25}}, {'entry' : {'Name' : 'Mary', 'Age' : 28}}]
b = [a[i]['entry']['Name'] for i in range(len(a))]
</code></pre>
<p>result:
b = ['Smith', 'Mary']</p>
</div>
<span class="comment-copy">You say you don't want to use a for-loop or list comprehension for performance reasons, because your data has "millions" of entries. How many millions -- 1, 10, 100? If the answer is 1 million, that iteration takes about 0.13 seconds on my basic desktop machine. If your answer is 10 million or 100 million, I suggest that you need a different strategy altogether -- one where the data is not necessarily held in memory and where the data is stored in way that your primary queries can be answered rapidly.</span>
<span class="comment-copy">Love the timeits.</span>
<span class="comment-copy">I don't want to use loops for performance reasons (in order to keep it quicker) since my actual list contains millions of entries.</span>
