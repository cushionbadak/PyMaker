<div class="post-text" itemprop="text">
<p>Why is it that byte strings <code>b'string'</code> cannot be used as docstrings for classes or functions (and by extent I'm guessing modules)?</p>
<p>Case in point:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     b"""My Foo class for Fooing"""
&gt;&gt;&gt; Foo.__doc__ is None
True
</code></pre>
<p>Similarly with functions.</p>
<p>For <code>r''</code>, <code>u''</code> (expected) strings it works okay. I couldn't find anything in the documentation either. Any idea why this is?</p>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out by <strong>@IgnacioVazquez-Abrams</strong>, <code>b'string'</code> is not text, or more specifically it is not a string, it is a <a href="https://docs.python.org/3/library/functions.html#bytes" rel="nofollow noreferrer">bytes object</a>, and I don't think you will see these referred to as "byte strings" anywhere in the Python documentation (though I could be wrong); in fact this sounds like a contradiction to me personally. </p>
<p>On the other hand, <code>r''</code> and <code>u''</code>, and <code>''</code> are strings (raw string literals, Unicode string literals, and string literals respectively). The first sentence for <a href="https://www.python.org/dev/peps/pep-0257/#specification" rel="nofollow noreferrer">the spec for docstrings</a> states:</p>
<blockquote>
<p>A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the <code>__doc__</code> special attribute of that object.</p>
</blockquote>
<p>It also specifies:</p>
<blockquote>
<p>Use <code>r"""raw triple double quotes"""</code> if you use any backslashes in your docstrings. For Unicode docstrings, use <code>u"""Unicode triple-quoted strings"""</code>.</p>
</blockquote>
<p>This might not be a satisfying answer since it doesn't explain the internals of why <code>__doc__</code> in one case will return a string and in the other return <code>None</code>, or how docstrings are formed/parsed. However, I think what is happening is that you are getting <code>None</code> because you just haven't defined a docstring, but only a bytes object which you have not assigned to any variable in your class. The same thing will happen if you do:</p>
<pre><code>class Foo:
    1
</code></pre>
<p><code>1</code> is not being parsed as the docstring (or the <code>__doc__</code> attribute) of the class since it is not a string, and I think the same happens with the bytes literal in your example. Regardless, I think the documentation makes it clear that only "strings" can be used as docstrings, so it seems logical that bytes objects would make just as poor docstrings as an <code>int</code> or a <code>bool</code>, or any other non-string datatype. I can understand your curiosity however, especially since the <a href="https://www.python.org/dev/peps/pep-3112/" rel="nofollow noreferrer">byte literals</a> and string literals are so visually similar. </p>
<h1>tl;dr:</h1>
<p>Bytes objects are not strings, and only strings can be used for Python docstrings.</p>
</div>
<span class="comment-copy">Probably because they're not actually text.</span>
