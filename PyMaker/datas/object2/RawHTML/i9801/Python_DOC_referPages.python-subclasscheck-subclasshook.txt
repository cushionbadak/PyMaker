<div class="post-text" itemprop="text">
<p>The methods <code>__subclasscheck__</code> and <code>__subclasshook__</code> are used to determine if a class is regarded as subclass of another. However, their documentation is very limited, even in advanced python books. How are they meant to be used and what is their difference (higher priority, side of relationship they refer to etc...)</p>
</div>
<div class="post-text" itemprop="text">
<p>Both methods can be used to customize the result of the <a href="https://docs.python.org/library/functions.html#issubclass" rel="noreferrer"><code>issubclass()</code></a> built-in function.</p>
<h1><a href="https://docs.python.org/reference/datamodel.html#class.__subclasscheck__" rel="noreferrer"><code>__subclasscheck__</code></a></h1>
<blockquote>
<p><code>class.__subclasscheck__(self, subclass)</code></p>
<p>Return true if subclass should be considered a (direct or indirect) subclass of class. If defined, called to implement <code>issubclass(subclass, class)</code>.</p>
<p>Note that these methods are looked up on the type (metaclass) of a class. They cannot be defined as class methods in the actual class. This is consistent with the lookup of special methods that are called on instances, only in this case the instance is itself a class.</p>
</blockquote>
<p>This method is the special method that is responsible for the customization of the <code>issubclass</code> check. Like the "Note" states it has to implemented on the metaclass!</p>
<pre><code>class YouWontFindSubclasses(type):
    def __subclasscheck__(cls, subclass):
        print(cls, subclass)
        return False

class MyCls(metaclass=YouWontFindSubclasses):
    pass

class MySubCls(MyCls):
    pass
</code></pre>
<p>This implementation will return False even if you have genuine subclasses:</p>
<pre><code>&gt;&gt;&gt; issubclass(MySubCls, MyCls)
&lt;class '__main__.MyCls'&gt; &lt;class '__main__.MySubCls'&gt;
False
</code></pre>
<p>There are actually more interesting uses for <code>__subclasscheck__</code> implementations. For example:</p>
<pre><code>class SpecialSubs(type):
    def __subclasscheck__(cls, subclass):
        required_attrs = getattr(cls, '_required_attrs', [])
        for attr in required_attrs:
            if any(attr in sub.__dict__ for sub in subclass.__mro__):
                continue
            return False
        return True

class MyCls(metaclass=SpecialSubs):
    _required_attrs = ['__len__', '__iter__']
</code></pre>
<p>With this implementation any class that defines <code>__len__</code> and <code>__iter__</code> will return <code>True</code> in a <code>issubclass</code> check:</p>
<pre><code>&gt;&gt;&gt; issubclass(int, MyCls)  # ints have no __len__ or __iter__
False
&gt;&gt;&gt; issubclass(list, MyCls)  # but lists and dicts have
True
&gt;&gt;&gt; issubclass(dict, MyCls)
True
</code></pre>
<p>In these examples I haven't called the superclasses <code>__subclasscheck__</code> and thereby disabled the normal <code>issubclass</code> behavior (which is implemented by <code>type.__subclasscheck__</code>). But it's important to know that you can also choose to just <em>extend</em> the normal behavior instead of completely overriding it:</p>
<pre><code>class Meta(type):
    def __subclasscheck__(cls, subclass):
        """Just modify the behavior for classes that aren't genuine subclasses."""
        if super().__subclasscheck__(subclass):
            return True
        else:
            # Not a normal subclass, implement some customization here.
</code></pre>
<h1><a href="https://docs.python.org/library/abc.html#abc.ABCMeta.__subclasshook__" rel="noreferrer"><code>__subclasshook__</code></a></h1>
<blockquote>
<p><code>__subclasshook__(subclass)</code></p>
<p>(Must be defined as a class method.)</p>
<p>Check whether subclass is considered a subclass of this ABC. This means that you can customize the behavior of <code>issubclass</code> further without the need to call <code>register()</code> on every class you want to consider a subclass of the ABC. (This class method is called from the <code>__subclasscheck__()</code> method of the ABC.)</p>
<p>This method should return <code>True</code>, <code>False</code> or <code>NotImplemented</code>. If it returns <code>True</code>, the subclass is considered a subclass of this ABC. If it returns <code>False</code>, the subclass is not considered a subclass of this ABC, even if it would normally be one. If it returns <code>NotImplemented</code>, the subclass check is continued with the usual mechanism.</p>
</blockquote>
<p>The important bit here is that it's defined as <code>classmethod</code> on the class and it's called by <code>abc.ABC.__subclasscheck__</code>. So you can only use it if you're dealing with classes that have an <code>ABCMeta</code> metaclass:</p>
<pre><code>import abc

class MyClsABC(abc.ABC):
    @classmethod
    def __subclasshook__(cls, subclass):
        print('in subclasshook')
        return True

class MyClsNoABC(object):
    @classmethod
    def __subclasshook__(cls, subclass):
        print('in subclasshook')
        return True
</code></pre>
<p>This will only go into the <code>__subclasshook__</code> of the first:</p>
<pre><code>&gt;&gt;&gt; issubclass(int, MyClsABC)
in subclasshook
True

&gt;&gt;&gt; issubclass(int, MyClsNoABC)
False
</code></pre>
<p>Note that subsequent <code>issubclass</code> calls don't go into the <code>__subclasshook__</code> anymore because <code>ABCMeta</code> caches the result:</p>
<pre><code>&gt;&gt;&gt; issubclass(int, MyClsABC)
True
</code></pre>
<p>Note that you generally check if the first argument is the class itself. That's to avoid that subclasses "inherit" the <code>__subclasshook__</code> instead of using normal subclass-determination.</p>
<p>For example (from the CPython <code>collections.abc</code> module):</p>
<pre><code>from abc import ABCMeta, abstractmethod

def _check_methods(C, *methods):
    mro = C.__mro__
    for method in methods:
        for B in mro:
            if method in B.__dict__:
                if B.__dict__[method] is None:
                    return NotImplemented
                break
        else:
            return NotImplemented
    return True

class Hashable(metaclass=ABCMeta):

    __slots__ = ()

    @abstractmethod
    def __hash__(self):
        return 0

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Hashable:
            return _check_methods(C, "__hash__")
        return NotImplemented
</code></pre>
<p>So if you check if something is a subclass of <code>Hashable</code> it will use the custom <code>__subclasshook__</code> implementation that is guarded by the <code>if cls is Hashable</code>. However if you have an actual class implementing the <code>Hashable</code> interface you don't want it to inherit the <code>__subclasshook__</code> mechanism but you want the normal subclass mechanism.</p>
<p>For example:</p>
<pre><code>class MyHashable(Hashable):
    def __hash__(self):
        return 10

&gt;&gt;&gt; issubclass(int, MyHashable)
False
</code></pre>
<p>Even though <code>int</code> implements <code>__hash__</code> and the <code>__subclasshook__</code> checks for an <code>__hash__</code> implementation the result in this case is <code>False</code>. It still enters the <code>__subclasshook__</code> of <code>Hashable</code> but it immediately returns <code>NotImplemented</code> which signals to <code>ABCMeta</code> that it should proceed using the normal implementation. If it didn't have the <code>if cls is Hashable</code> then <code>issubclass(int, MyHashable)</code> would return <code>True</code>!</p>
<h1>When should you use <code>__subclasscheck__</code> and when <code>__subclasshook__</code>?</h1>
<p>It really depends. <code>__subclasshook__</code> can be implemented on the class instead of the metaclass, but requires that you use <code>ABCMeta</code> (or a subclass of <code>ABCMeta</code>) as metaclass because the <code>__subclasshook__</code> method is actually just a convention introduced by Pythons <code>abc</code> module. </p>
<p>You can always use <code>__subclasscheck__</code> but it has to be implemented on the metaclass.</p>
<p>In practice you use <code>__subclasshook__</code> if you implement interfaces (because these normally use <code>abc</code>) and want to customize the subclass mechanism. And you use <code>__subclasscheck__</code> if you want to invent your own conventions (like <code>abc</code> did). So in 99.99% of the normal (not fun) cases you only need <code>__subclasshook__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta.__subclasshook__" rel="nofollow noreferrer"><code>__subclasshook__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html?#class.__subclasscheck__" rel="nofollow noreferrer"><code>__subclasscheck__</code></a> are used to customize the behavior of <code>issubclass</code> function.
A lot more information in <a href="https://hg.python.org/cpython/file/3.5/Lib/abc.py#l194" rel="nofollow noreferrer">abc source code</a>.</p>
<p><code>__subclasscheck__</code> is looked up on the type (metaclass) of a class. It shouldn't be defined for an ordinary class.</p>
<p><code>__subclasshook__</code> check whether subclass is considered a subclass of some ABC. This means that you can customize the behavior of <code>issubclass</code> further without the need to call register() on every class you want to consider a subclass of the ABC.</p>
<p>Which means you can define <code>__subclasshook__</code> in your ABC class with some condition and all classes that satisfy that condition will be considerate as a subclass.</p>
<p>For example:</p>
<pre><code>from abc import ABCMeta

class Sized(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C):
        if cls is Sized:
            if any("__len__" in B.__dict__ for B in C.__mro__):
                return True
        return NotImplemented

class A(object):
    pass

class B(object):
    def __len__(self):
        return 0

issubclass(A, Sized)  # False
issubclass(B, Sized)  # True
</code></pre>
</div>
<span class="comment-copy">Great answer, lots of good info!</span>
<span class="comment-copy">why is the <code>if cls is Sized:</code> line needed ?</span>
<span class="comment-copy">@vikkyhacks such that when you subclass <code>Sized</code> and inherit <code>__subclasshook__</code> not every class with a <code>__len__</code> method is considered a subclass of that child.</span>
