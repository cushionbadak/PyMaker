<div class="post-text" itemprop="text">
<p>I am looking for a way to measure the CPU time of the part of my python program. I was looking around and it seems all the time measuring functions that I could find measure the wall clock time on windows. Is there a way to measure the CPU time on windows for python ? Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>time.process_time()</strong></p>
<p><a href="https://www.python.org/dev/peps/pep-0418/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0418/</a></p>
<blockquote>
<p>The new time.process_time() function acts as a portable counter that
  always measures CPU time (excluding time elapsed during sleep) and has
  the best available resolution.</p>
</blockquote>
<p><strong>Earlier answer</strong> for anyone wanting to use timeit() to <strong>average</strong>:</p>
<p>I wrote this while recently learning Python. It's a <a href="https://docs.python.org/3.0/library/timeit.html" rel="nofollow noreferrer">timeit.Timer</a> class iterating <strong>timeit()</strong> over functions for averaging; in my research timing seemed to be easy to mess up and timeit() apparently tricky to get working (though easier to get working on command line). This works.</p>
<p>Also note this answer suggests the best bet is <a href="http://%20https://docs.python.org/3/library/time.html" rel="nofollow noreferrer">time.process_time()</a> for Python 3.3+ and reminds that .default_timer() is wall time:</p>
<p><a href="https://stackoverflow.com/a/15176730/3981745">https://stackoverflow.com/a/15176730/3981745</a></p>
<pre><code>""" Sum a range with timing/comparisons.

    - Manually summing from low..high : a beginner's loop with no algorithms experience
    - Python's sum() - does the same thing for an "efficient" programmer
    - Fast sum - a programmer with math focus 
    - Timing calls (easy to do wrong)

    This is a trivial formula to demonstrate what a little math can do; for games this type of optimization is critical. It could probably be even more optimized.
"""

def slow_way(lo, hi):
    s=0
    for i in range(lo, hi+1):
        s+=i
    return s

def fast_way(lo, hi):
    lph=lo+hi        # lo plus hi
    hmlpo=hi-lo+1    # hi minus lo plus one
    pairs=hmlpo//2

    #print("-", lo,hi,pairs, pairs*lph, (lo+pairs)*(hmlpo%2))

    return (pairs*lph + (lo+pairs)*(hmlpo%2))

import timeit
# 'builtin' hack doesn't seem to work
#import __builtin__
#__builtin__.__dict__.update(locals()) 

ranges=[]
ranges.append((1,10,))
ranges.append((2,10,))
ranges.append((3,10,))
ranges.append((4,10,))
ranges.append((5,10,))
ranges.append((32,10032,))

print("Calculation check...")
print("slow : sum : fast : should all match")
for tupl in ranges:
    l=tupl[0]; h=tupl[1]
    print("{} : {} : {}".format(slow_way(l,h), sum(range(l, h+1)), fast_way(l,h)))

iters=100000
print("-"*20 +"\nTime compare ({} iterations) : lower is better".format(iters))
slow=timeit.Timer("slow_way(1,101)", "from __main__ import slow_way")
print("slow: {0:.6f}".format(slow.timeit(number=iters)))

# functions include last number, range should be +1
s=timeit.Timer("sum(range(1,102))", "")
print(" sum: {0:.6f}".format(s.timeit(number=iters)))

fast=timeit.Timer("fast_way(1,101)", "from __main__ import fast_way")
print("  fast: {0:.6f}".format(fast.timeit(number=iters)))
</code></pre>
<p>Output</p>
<pre><code>Calculation check...
slow : sum : fast : should all match
55 : 55 : 55
54 : 54 : 54
52 : 52 : 52
49 : 49 : 49
45 : 45 : 45
50325032 : 50325032 : 50325032
--------------------
Time compare (100000 iterations) : lower is better
slow: 4.719885
 sum: 0.963886
  fast: 0.343524
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>time.clock()</strong></p>
<p>On windows you can use <code>time.clock()</code> which basically uses <code>QueryPerformanceCounter()</code> from the Windows API. </p>
<p>QueryPerformanceCounter():</p>
<blockquote>
<p>Retrieves the current value of the performance counter, which is a high resolution (&lt;1us) time stamp that can be used for time-interval measurements.</p>
</blockquote>
<p>Here is a detailed explanation for time.clock from the python docs:</p>
<blockquote>
<p>On Unix, return the current processor time as a floating point number expressed in seconds. The precision, and in fact the very definition of the meaning of “processor time”, depends on that of the C function of the same name, but in any case, this is the function to use for benchmarking Python or timing algorithms.
  On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function QueryPerformanceCounter(). The resolution is typically better than one microsecond.</p>
</blockquote>
<p><strong>timeit</strong></p>
<p>If you need something even more accurate there is <code>timeit</code>. This answer explains the benefits of <code>timeit</code>: <a href="https://stackoverflow.com/a/17579466/2394967">https://stackoverflow.com/a/17579466/2394967</a></p>
</div>
<span class="comment-copy">I don't mind your edits...or I can remove the extraneous myself if people think that's better.</span>
<span class="comment-copy">Here is the problem. I am currently using timeit with this functions. start_time = timeit.default_timer() elapsed = (timeit.default_timer() - start_time). But when I put pause in between these, it still counts the pause time as well. Isnt this makes it into a wall clock timer instead of CPU timer ?</span>
<span class="comment-copy">Yes. default_timer is wall clock (it's in the docs).</span>
<span class="comment-copy">but time.clock() gives me a wall clock as well and it seems like it will give CPU time only when used on Unix. How do I get it to give me CPU time on windows :)</span>
<span class="comment-copy">Verifying timeit's clock choices...in the meantime what about  <a href="https://docs.python.org/3/library/time.html" rel="nofollow noreferrer">docs.python.org/3/library/time.html</a> : process_time()</span>
<span class="comment-copy">Ok, process_time() seem to give the desired result. Documentation states that it gives the sum of the system and user CPU time, which works for me. Thank you.</span>
