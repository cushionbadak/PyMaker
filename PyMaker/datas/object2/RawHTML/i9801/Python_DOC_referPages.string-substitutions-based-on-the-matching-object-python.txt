<div class="post-text" itemprop="text">
<p>I struggle to understand the <code>group</code> method in Python's regular expressions library. In this context, I try to do substitutions on a string depending on the matching object.</p>
<p>That is, I want to replace the matched objects (<code>+</code> and <code>\n</code> in this example) with a particular string in the <code>my_dict</code> dictionary (with <code>rep1</code> and <code>rep2</code> respectively).</p>
<p>As seen from this <a href="https://stackoverflow.com/q/36507840/6167676">question</a> and <a href="https://stackoverflow.com/a/36508011">answer</a>,
I have tried this:</p>
<pre><code>content = '''
Blah - blah \n blah * blah + blah.
'''

regex = r'[+\-*/]'

for mobj in re.finditer(regex, content):
    t = mobj.lastgroup
    v = mobj.group(t)

    new_content = re.sub(regex, repl_func(mobj), content)

def repl_func(mobj):
    my_dict = { '+': 'rep1', '\n': 'rep2'}
    try:
        match = mobj.group(0)
    except AttributeError:
        match = ''
    else:
        return my_dict.get(match, '')

print(new_content)
</code></pre>
<p>But I get <code>None</code> for <code>t</code> followed by an <code>IndexError</code> when computing <code>v</code>.</p>
<p>Any explanations and example code would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>r'[+\-*/]'</code> regex does not match a newline, so your <code>'\n': 'rep2'</code> would not be used. Else, add <code>\n</code> to the regex: <code>r'[\n+*/-]'</code>.</p>
<p>Next, you get <code>None</code> because your regex does not contain any <a href="http://www.regular-expressions.info/named.html" rel="nofollow noreferrer"><em>named capturing groups</em></a>, see <a href="https://docs.python.org/3/library/re.html#re.match.lastgroup" rel="nofollow noreferrer"><code>re</code> docs</a>:</p>
<blockquote>
<p><strong><code>match.lastgroup</code></strong><br/>
  The name of the last matched capturing group, or <strong><code>None</code> if the group didnâ€™t have a name, or if no group was matched at all</strong>.</p>
</blockquote>
<p>To replace using the match, you do not even need to use <code>re.finditer</code>, use <code>re.sub</code> with a lambda as the replacement:</p>
<pre><code>import re
content = '''
Blah - blah \n blah * blah + blah.
'''

regex = r'[\n+*/-]'
my_dict = { '+': 'rep1', '\n': 'rep2'}
new_content = re.sub(regex, lambda m: my_dict.get(m.group(),""), content)
print(new_content)
# =&gt; rep2Blah  blah rep2 blah  blah rep1 blah.rep2
</code></pre>
<p>See the <a href="http://ideone.com/5Y83Tn" rel="nofollow noreferrer">Python demo</a></p>
<p>The <code>m.group()</code> gets the <em>whole match</em> (the whole match is stored in <code>match.group(0)</code>). If you had a pair of unescaped parentheses in the pattern, it would create a <a href="http://www.regular-expressions.info/brackets.html" rel="nofollow noreferrer">capturing group</a> and you could access the first one with <code>m.group(1)</code>, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Despite of Wiktor's truly pythonic answer, there's still the question why the OP's orginal algorithm wouldn't work.
Basically there are 2 issues:</p>
<p>The call of <code>new_content = re.sub(regex, repl_func(mobj), content)</code> will substitute <em>all matches</em> of <code>regex</code> with the replacement value of <em>the very first match</em>.</p>
<p>The correct call has to be <code>new_content = re.sub(regex, repl_func, content)</code>.
As documented <a href="https://docs.python.org/2/library/re.html" rel="nofollow noreferrer">here</a>, <code>repl_func</code> gets invoked dynamically with the current match object!</p>
<p><code>repl_func(mobj)</code> does some unnecessary exception handling, which can be simplified:</p>
<pre><code>my_dict = {'\n': '', '+':'rep1', '*':'rep2', '/':'rep3', '-':'rep4'}
def repl_func(mobj):
    global my_dict
    return my_dict.get(mobj.group(0), '')
</code></pre>
<p>This is equivalent to Wiktor's solution - he just got rid of the function definition itself by using a lambda expression.</p>
<p>With this modification, the <code>for mobj in re.finditer(regex, content):</code> loop has become superfluos, as it does the same calculation multiple times.</p>
<p>Just for the sake of completeness here is a working solution using <code>re.finditer()</code>. It builds the result string from the <em>matched slices</em> of <code>content</code>:</p>
<pre><code>my_regx = r'[\n+*/-]'
my_dict = {'\n': '', '+':'rep1'     , '*':'rep2', '/':'rep3', '-':'rep4'}
content = "A*B+C-D/E"
res = ""
cbeg = 0
for mobj in re.finditer(my_regx, content):
    # get matched string and its slice indexes
    mstr = mobj.group(0)
    mbeg = mobj.start()
    mend = mobj.end()

    # replace matched string
    mrep = my_dict.get(mstr, '')

    # append non-matched part of content plus replacement
    res += content[cbeg:mbeg] + mrep

    # set new start index of remaining slice
    cbeg = mend

# finally add remaining non-matched slice
res += content[cbeg:]
print (res)
</code></pre>
</div>
<span class="comment-copy">It's hard to guess what your code is supposed to do (there's many syntactic errors, indentation is broken, logic unclear). Better you provide an example describing what you'd like to achieve.</span>
<span class="comment-copy">@TomR8 Apologies! I fixed all syntax issues &amp; typos (hopefully).</span>
