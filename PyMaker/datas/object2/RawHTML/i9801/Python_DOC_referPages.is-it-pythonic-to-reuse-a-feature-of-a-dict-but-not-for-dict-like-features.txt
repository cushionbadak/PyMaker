<div class="post-text" itemprop="text">
<p>I would like to use the bracket expression used to access a value in a <code>dict</code>, but without any other <code>dict</code> features.</p>
<p>In the example below, I use the expression <code>variable[something]</code> to query <code>variable</code> in the same way as a <code>dict</code>. There are no other functionalities of a <code>dict</code> behind, what is returned is computed (it is either a color when <code>something</code> is <code>'color'</code>, or <code>"hello"</code> for anything else).</p>
<pre><code>import random

class ColDict(dict):
    def __init__(self, *args):
        dict.__init__(self, args)
        self.colors = ['blue', 'white', 'red']
    def __getitem__(self, item):
        if item == 'color':
            random.shuffle(self.colors)
            return(self.colors[0])
        else:
            return("hello")

if __name__ == "__main__":
    col = ColDict()
    print(col['color'], col['color'], col['something']) # red white hello (changes on each call)
</code></pre>
<p>This code works as expected.</p>
<p>What I would like to understand is <strong>whether the reuse of a dict functionality (the bracket call) is pythonic, or at last acceptable.</strong></p>
<p>Note: I understand that this could be accomplished though other means (liek a function) but I am specifically instersted in reusing the brackets call. <strong>Reusing, not misusing</strong> (which is the core of my question)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need any functionality from dict, just provide <code>__getitem__()</code></p>
<pre><code>import random

class ColDict:
    def __init__(self, *args):
        self.colors = ['blue', 'white', 'red']
    def __getitem__(self, item):
        if item == 'color':
            return random.choice(self.colors)
        else:
            return("hello")

if __name__ == "__main__":
    col = ColDict()
    print(col['color'], col['color'], col['something']) # red white hello (changes on each call)
</code></pre>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">read more about it</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is unpythonic. There's no need to inherit from a dictionary, as all you gain is slightly longer method names and attribute access syntax. Make an ordinary class with no explicit inheritance to return a random color. Since your class's <code>__getitem__</code> was returning a constant for every other value, make a class or instance variable with a constant that can be retrieved with a specific name instead of just "anything that isn't <code>color</code>." If you're worried about the user not being able to enter random attribute names to access that constant, remember that "There should be one – and preferably only one – obvious way to do it" (from <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">PEP-20, The Zen of Python</a>).</p>
<pre><code>import random

class ColObj:
    other = 'hello'
    def __init__(self, *args):
        self.colors = ['blue', 'white', 'red']
    def color(self):
            return random.choice(self.colors)

if __name__ == "__main__":
    col = ColObj()
    print(col.color, col.color, col.other)
</code></pre>
<p>If this is all the class does, I don't see much need for a class at all - you could simply define a function <code>color</code> and a string (or other constant) <code>other</code>.</p>
<pre><code>import random

other = 'hello'
def color(colors=('blue', 'white', 'red')):
        return random.choice(colors)

if __name__ == "__main__":
    print(color(), color(), other)
</code></pre>
</div>
<span class="comment-copy">I see no reason why you would want that class to derive from <code>dict</code>.  What's that buying you?</span>
<span class="comment-copy">This question is pretty much opinion-based. <b><i>In my opinion.</i></b></span>
<span class="comment-copy">You're adding underscores around your method names just so you have to do <code>instance['attribute']</code> rather than <code>instance.attribute</code>. Doesn't look too Pythonic.</span>
<span class="comment-copy">(Also, you're looking for <code>return random.choice(self.colors)</code>.)</span>
<span class="comment-copy">@WoJ What gives you ability to use a bracket call is <code>__getitem__</code> function, not inheritance from <code>dict</code>. The only unpythonic thing is "explicit is better then implicit" (Zen of Python) so I suggest you simply create a method doing that. Immitating a dict will simply be confusing to others. But if for example you want to use your object as a replacement for dict somewhere else then this is completely fine.</span>
<span class="comment-copy">And since OP is using Python 3, inheritance from <code>object</code> isn't necessary either.</span>
<span class="comment-copy">thx, you're right</span>
<span class="comment-copy">Thank you for the extended explanation - the actual use case is more complicated, I just wrote a working example to base the question on.</span>
<span class="comment-copy">@WoJ - I expected as much. I just wanted to emphasize that OOP should be used only when it adds value.</span>
<span class="comment-copy">@WoJ: As TigerhawkT3 mentioned, you do not need a class here</span>
