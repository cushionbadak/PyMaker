<div class="post-text" itemprop="text">
<p>Say I have a script like this:</p>
<pre><code>p = subprocess.Popen(['python forked_job.py'], shell=True)
status = p.wait()
# Do something with status
</code></pre>
<p>And then forked_job.py looks like this:</p>
<pre><code>import os
import sys

print 'hi'
pid = os.fork()
if pid == 0:
    sys.exit(do_some_work())
else:
    sys.exit(do_other_work())
</code></pre>
<p>How can I make sure both processes return a 0 status code?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you fork, you have a parent and a non-parent process.  When pid == 0, you are in the child process; your else statement is when you're within the parent process.</p>
<p>Similar to calling <code>Popen.wait</code>, as you do in the first script, you want to call <code>os.wait</code> in the second one.</p>
<p>From <a href="https://docs.python.org/3/library/os.html" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p><strong>os.wait()</strong></p>
<p>Wait for completion of a child process, and return a tuple
  containing its pid and exit status indication: a 16-bit number, whose
  low byte is the signal number that killed the process, and whose high
  byte is the exit status (if the signal number is zero); the high bit
  of the low byte is set if a core file was produced.</p>
<p>Availability: Unix</p>
</blockquote>
<p>As you can see, this of course assumes that you're running unix.  Since <code>os.fork</code> is also Unix-only, this seems likely.</p>
<p>So, have the parent call <code>os.wait</code> and reflect the status back up in what the parent returns.</p>
<p>One thing to note, though it probably doesn't matter, and you're probably aware.  You're technically not doing this:</p>
<pre><code>    main_script
     /       \
forked_job   forked_job
</code></pre>
<p>But instead:</p>
<pre><code>        main_script
            |
      forked_job_parent
            |
       forked_job_child
</code></pre>
<p>(I'm attempting to show the "ownership", and hence the usage of the second wait.)</p>
</div>
<span class="comment-copy">Thanks!  That's exactly what I was looking for.</span>
<span class="comment-copy">Follow up question.  What if the child finishes before the parent gets to os.wait?  How is the parent able to still get the exit status?</span>
<span class="comment-copy"><a href="https://linux.die.net/man/3/wait" rel="nofollow noreferrer">man 3 wait</a>  I hate to say it, but just treat it as magic. :-)  The whole concept of child processes is built to handle exactly what you're worried about.  wait will block for the child, or if the child is done, will automatically return with the status you need.  If you don't like "magic", just know that it's built into the kernel.  Which for most people, including me, comes out to the same thing.</span>
<span class="comment-copy">Actually, this seems like a concise way of demystifying the magic: <a href="http://www.thegeekstuff.com/2013/07/linux-process-life-cycle" rel="nofollow noreferrer">thegeekstuff.com/2013/07/linux-process-life-cycle</a></span>
<span class="comment-copy">Excellent thanks!  From your article, I guess this is the part that answers my question "An entry containing some information related to it is kept in the Kernel process address table till the parent process explicitly calls wait() or waitpid() functions to get the exit status of child process."</span>
