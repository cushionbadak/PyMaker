<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7042152/how-do-i-properly-override-setattr-and-getattribute-on-new-style-classes">How do I properly override __setattr__ and __getattribute__ on new-style classes in Python?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I want to override the <code>__setattr__</code> method on python classes using python 3.4.3. I found <a href="https://stackoverflow.com/questions/7042152/how-to-i-properly-override-setattr-and-getattribute-on-new-style-classes">this answer</a> but it does not seem to work as I get an error. </p>
<p>The full code is as follows: </p>
<pre><code>class TestClass(object):

    def __init__(self):
        self.x = 4

    def __setattr__(self, name, value):
        # do something special given the 'name'

        #default behavior below
        super(TestClass).__setattr__(name, value)

test = TestClass()
</code></pre>
<p>and the error is</p>
<pre><code>Traceback (most recent call last):
  File "client_1.py", line 26, in &lt;module&gt;
    test = TestClass()
  File "client_1.py", line 17, in __init__
    self.x = None
  File "client_1.py", line 23, in __setattr__
    super(TestClass).__setattr__(name, value)
AttributeError: 'super' object has no attribute 'x'
</code></pre>
<p>I assume the attribute <code>x</code> cannot be set as it is not yet defined. And the line trying to define this atribute (in <code>__init__</code>) cannot define the attribute, as it calls the overwritten method...</p>
<p>How to define the attribute <code>x</code> without implicity calling the overwritten <code>__setattr__</code> method then?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow"><code>super</code></a> doesn't need arguments in Python3 (at least in the case of overriding instance methods):</p>
<pre><code>super().__setattr__(name, value)
</code></pre>
<p>is the equivalent of Python2's</p>
<pre><code>super(MyClass, self).__setattr__(name, value)
</code></pre>
<p>which still works though.</p>
</div>
<div class="post-text" itemprop="text">
<p>You called super with just the class, which is valid in some cases, but in this case you wanted super for the instance.  In Python 2, you would call it with the class and <code>self</code>, in Python 3 you can call it without arguments.</p>
<pre><code>class Spam:
    def __setattr__(self, name, value):
        # super(Spam, self).__setattr__(name, value)  # old, but still works
        super().__setattr__(name, value)  # new and cool

spam = Spam()
spam.eggs = 'python'  # works
</code></pre>
</div>
<span class="comment-copy">Compare your call to the ones in your link. You're passing different arguments.</span>
<span class="comment-copy">Never pass <code>self.__class__</code> to <code>super</code>. <code>self.__class__</code> is the wrong class if you create a grandchild class.</span>
<span class="comment-copy">I must have called it with python2 by accident. Your suggestion (and the one I linked) works fine...</span>
