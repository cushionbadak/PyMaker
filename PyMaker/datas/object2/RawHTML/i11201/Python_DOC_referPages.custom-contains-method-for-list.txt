<div class="post-text" itemprop="text">
<p>I'd like to get a better handle on the doubly-linked structure. The goal in this scenario is to append a range of values to the end of a list. I then would like to test for a value I know should be in the list, this should return true, and vice versa for a value that I know shouldn't be in the list. So here's what I have thus far.</p>
<pre><code>class LinkedList:
    class Node:
        def __init__(self, val, prior=None, next=None):
            self.val = val
            self.prior = prior
            self.next  = next

    def __init__(self):
        self.head = LinkedList.Node(None) # sentinel node (never to be removed)
        self.head.prior = self.head.next = self.head # set up "circular" topology
        self.length = 0

    def append(self, value):
        n = LinkedList.Node(value, prior=self.head.prior, next=self.head)
        n.prior.next = n.next.prior = n
        self.length += 1

    def _normalize_idx(self, idx):
        nidx = idx
        if nidx &lt; 0:
            nidx += len(self)
            if nidx &lt; -1:
                raise IndexError  
        return nidx

    def __getitem__(self, idx):
        """Implements `x = self[idx]`"""
        nidx = self._normalize_idx(idx)
        currNode = self.head.next
        for i in range(nidx):
            currNode = currNode.next
        if nidx &gt;= len(self):
            raise IndexError
        return currNode.val


    def __setitem__(self, idx, value):
        """Implements `self[idx] = x`"""
        nidx = self._normalize_idx(idx)
        currNode = self.head.next
        if nidx &gt;= len(self):
            raise IndexError
        for i in range(nidx):
            currNode = currNode.next
        currNode.val = value

    def __iter__(self):
        """Supports iteration (via `iter(self)`)"""
        cursor = self.head.next
        while cursor is not self.head:
            yield cursor.val
            cursor = cursor.next

    def __len__(self):
        """Implements `len(self)`"""
        return self.length

    def __eq__(self, other):
        return len(self) == len(other) and all(
            val1 == val2 for val1, val2 in zip(self, other))

    def __contains__(self, value):
        """Implements `val in self`. Returns true if value is found in this list."""
        return all(val1 == value for val1 in zip(self))
</code></pre>
<p>Test:</p>
<pre><code>    lst = LinkedList()
    for i in range(100):
        lst.append(i)
    tc.assertFalse(100 in lst)
    tc.assertTrue(50 in lst)
</code></pre>
<p>When I test this code I get I get an Assertion error saying " False is not true " I'm unsure why my code is able to recognize that the value 100 isn't in the list, whereas it also says 50 isn't and returns False when it should return True.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your implementation is wrong. Your <code>__contains__</code> function only returns true if <strong>all</strong> values in your linked list are equal to a given test value. I.e. it'd only be true if all values in your linked list are equal to one another <em>as well</em>:</p>
<pre><code>&gt;&gt;&gt; value = 'foo'
&gt;&gt;&gt; all(val1 == value for val1 in ['foo', 'bar', 'baz'])
False
&gt;&gt;&gt; all(val1 == value for val1 in ['foo', 'foo', 'foo'])
True
</code></pre>
<p>Moreover, the <code>zip()</code> call in that generator expression is entirely redundant, you are not pairing up elements from multiple iterables here.</p>
<p>Use the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any()</code> function</a> instead:</p>
<pre><code>return any(v == value for v in self)
</code></pre>
<p><code>all()</code> will only return <code>True</code> if <em>all</em> items in the iterable are true (it'll return <code>False</code> early). <code>any()</code> will return <code>True</code> as soon as it finds <em>any one</em> item in the iterable that is true:</p>
<pre><code>&gt;&gt;&gt; any(val1 == value for val1 in ['foo', 'bar', 'baz'])
True
&gt;&gt;&gt; any(val1 == value for val1 in ['foo', 'foo', 'foo'])
True
&gt;&gt;&gt; any(val1 == value for val1 in ['spam', 'bar', 'baz'])
False
</code></pre>
</div>
<span class="comment-copy">Use any instead of all. Also, you don't need the zip.</span>
