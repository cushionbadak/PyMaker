<div class="post-text" itemprop="text">
<p>I have a dictionary <code>dct</code> for which I want each of its values to be summed provided their corresponding keys exist in a specified list <code>lst</code>.</p>
<p>The code I am using so far is:</p>
<pre><code>sum(dct[k] for k in lst)
</code></pre>
<p>In the above generator expression I would like to handle the <code>KeyError</code> in case a key from the list is not found inside the dictionary. I cannot seem to find how to implement (syntax-wise) either a <code>try</code>-<code>except</code> approach, nor an <code>if</code>-<code>else</code> approach inside this generator expression.</p>
<p>In case a <em>key from the list is not found inside the dictionary, then it should carry on getting the other values</em>. <em>The end result of the sums should not be affected by any missing keys</em>. In case none of the keys exist, then zero should be the sum's result.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, there are few options, preferred one is to use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get()</code></a>:</p>
<pre><code># 1
sum(dct.get(k, 0) for k in lst)
# 2
sum(dct[k] for k in lst if k in dct)
</code></pre>
<p>Also one of the option is to filter <code>lst</code> before iteraring over it:</p>
<pre><code>sum(dct[k] for k in filter(lambda i: i in dct, lst))
</code></pre>
<p>And you can use <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow">reduce function</a> on filtered list as an alternative to <code>sum</code>:</p>
<pre><code>reduce(lambda a, k: a + dct[k], filter(lambda i: i in dct, lst))
</code></pre>
<p>Now let's find fastest approach with <a href="https://docs.python.org/2/library/timeit.html#timeit.timeit" rel="nofollow">timeit</a>:</p>
<pre><code>from timeit import timeit
import random

lst = range(0, 10000)
dct = {x:x for x in lst if random.choice([True, False])}

via_sum = lambda:(sum(dct.get(k, 0) for k in lst))
print("Via sum and get: %s" % timeit(via_sum, number=10000))
# Via sum and get: 16.725695848464966

via_sum_and_cond = lambda:(sum(dct[k] for k in lst if k in dct))
print("Via sum and condition: %s" % timeit(via_sum_and_cond, number=10000))
# Via sum and condition: 9.4715681076

via_reduce = lambda:(reduce(lambda a, k: a + dct[k], filter(lambda i: i in dct, lst)))
print("Via reduce: %s" % timeit(via_reduce, number=10000))
# Via reduce: 19.9522120953
</code></pre>
<p>So the fastest option is to sum items via if statement within generator expression</p>
<pre><code>sum(dct[k] for k in lst if k in dct) # Via sum and condition: 9.4715681076
</code></pre>
<p><strong>Good Luck !</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You have two options:</p>
<p>Checking if the key exists</p>
<pre><code>sum(dct[k] for k in lst if k in dct)
</code></pre>
<p>or using <code>get</code></p>
<pre><code>sum(dct.get(k, 0) for k in lst)
</code></pre>
<p>where <code>dct.get(k, 0)</code> returns <code>dct[k]</code> if <code>k</code> is a key in <code>dct</code> or <code>0</code> if not.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>.get()</code></a> to attempt to get the value for the key from the dictionary, and should it not be found will return <code>None</code>, or your provided default parameter which would be 0 in this case. </p>
<pre><code>&gt;&gt;&gt; dct = {1:2, 3:4, 5:6}
&gt;&gt;&gt; lst = [1,5]
&gt;&gt;&gt; sum(dct.get(k, 0) for k in lst)
8    
</code></pre>
<p>Should some (<em>or all</em>) of the keys not exist, the sum will still function properly. </p>
<pre><code>&gt;&gt;&gt; lst = [10, 11]
&gt;&gt;&gt; sum(dct.get(k, 0) for k in lst)
0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>sum(dct[k] for k in lst if k in dct)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>get</code>-method of dictionaries, to provide a default value if not found:</p>
<pre><code>sum(dct.get(k, 0) for k in lst)
</code></pre>
</div>
<span class="comment-copy">You can't use <code>try</code> in a generator expression. Why not use <code>dct.get(k)</code>, which will give you <code>None</code> instead of an error if the key isn't found? What is the correct behaviour for your code in the case where a key isn't found (e.g. should it count as <code>0</code>)?</span>
<span class="comment-copy">If a key is not found then it should carry on with the remaining keys. (I will update my description to explain this case - thanks for noting this)</span>
<span class="comment-copy">Great and complete answer. Curious if you could offer some insight in comparing these 4 options; specifically, how the 3rd option compares to the first two. Is there any efficiency gains or a more 'Pythonic' approach among them?</span>
<span class="comment-copy">@Yannis thanks,  sure ) see updated answer with time metrics :) My guess  winner method is most 'Pythonic' to )</span>
<span class="comment-copy">Helpful answer indeed; other people mentioned this approach as well and from what I can see, yours was not the fastest one. Sorry</span>
