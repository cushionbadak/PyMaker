<div class="post-text" itemprop="text">
<p>For lack of a better title, this is what I got so far.</p>
<pre><code>class cordinate(int):
    def __new__(self, *args, **kwargs):
        self.x = args[0]
        self.y = args[1]

        ## Try to get pixel [0,0] and see what it got:
        if self.x == 0 and self.y == 0:
            print('New Here')
            print(self.x, self.y, self.angle, self.distance_from_edge)

        self.angle = 225
        self.distance_from_edge = 13

        args = [self.distance_from_edge,]
        return super(cordinate, self).__new__(self, *args, **kwargs)

cordinates = [cordinate(0,0), cordinate(2,10), cordinate(3,8)]
</code></pre>
<p>As expected, this code throws an error:</p>
<pre><code>New Here
Traceback (most recent call last):
  File "test.py", line 17, in &lt;module&gt;
    cordinates = [cordinate(0,0), cordinate(2,10), cordinate(3,8)]
  File "test.py", line 9, in __new__
    print(self.x, self.y, self.angle, self.distance_from_edge)
AttributeError: type object 'cordinate' has no attribute 'angle'
</code></pre>
<p>For whatever reason, I tried the following:</p>
<pre><code>if self.x == 2 and self.y == 10:
</code></pre>
<p>This code will output:</p>
<pre><code>New Here
2 10 225 13
</code></pre>
<p>Now, I am sure there's a simple explanation to this and there's no need for panic or start to believe in ghosts..</p>
<p>But I've played around with it but can't make sense of it. What's the explanation of this behavior - does it have a name? How come a newly created instance can have a value that is about to be set 2 rows under?</p>
<p><strong>Expected value:</strong> Always crashing - Because I purposely placed a print with a not-defined key at the top.<br/>
<strong>Python:</strong> 3.5.1 (Windows 8)</p>
</div>
<div class="post-text" itemprop="text">
<p>As you can see from <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow">the data model documentation</a>, the first argument to <code>__new__</code> is the class (conventionally <code>cls</code>), not the instance (conventionally <code>self</code>). Therefore you are setting class attributes on the <code>cordinate</code> class (note that that's a typo, and class names should be <code>CamelCased</code>) not each instance. As long as the <em>first</em> call to <code>__new__</code> succeeds, those attributes are set on the class for all subsequent calls.</p>
<p>If you want to set instance attributes in <code>__new__</code>, do it <em>once you have the instance</em>, e.g.:</p>
<pre><code>class Coordinate(int):

    def __new__(cls, *args, **kwargs):
        self = super(Coordinate, cls).__new__(cls, *args[2:], **kwargs)
      # ^ or 'inst' or whatever you like
        self.x, self.y = args[:2]
        ...
        return self
</code></pre>
</div>
<span class="comment-copy">The first argument to <code>__new__</code> is <b>the class</b> (conventionally <code>cls</code>), not the instance (conventionally <code>self</code>). Therefore those attributes are already set as long as the <i>first</i> call doesn't crash.</span>
<span class="comment-copy">@jonrsharpe You're janking my chain? haha. If it's that simple I'll have to re-evaluate how I assign <code>x</code> and <code>y</code> to this class upon creation.</span>
<span class="comment-copy">Out of interest, is there a reason you're using <code>__new__</code> rather than <code>__init__</code>?</span>
<span class="comment-copy">@Holloway presumably because they're subclassing <code>int</code>, which is immutable.</span>
<span class="comment-copy">@Holloway as JonrSharpe said, it's because I'm subclassing <code>int</code>, the real reason for why I'm using it tho is because this is how i was tought these specific inheritance cases works. Wasn't aware of how they actually worked : )</span>
<span class="comment-copy">You are absoluteley correct and thank you for explaining in layman terms and also for including a direct pointer to the documentation. Easy yet fully qualified answer! Cheers!</span>
