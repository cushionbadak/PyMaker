<div class="post-text" itemprop="text">
<p>So, I was playing around with Python while answering <a href="https://stackoverflow.com/questions/1528932/how-to-create-inline-objects-with-properties-in-python/">this question</a>, and I discovered that this is not valid:</p>
<pre><code>o = object()
o.attr = 'hello'
</code></pre>
<p>due to an <code>AttributeError: 'object' object has no attribute 'attr'</code>. However, with any class inherited from object, it is valid:</p>
<pre><code>class Sub(object):
    pass

s = Sub()
s.attr = 'hello'
</code></pre>
<p>Printing <code>s.attr</code> displays 'hello' as expected. Why is this the case? What in the Python language specification specifies that you can't assign attributes to vanilla objects?</p>
</div>
<div class="post-text" itemprop="text">
<p>To support arbitrary attribute assignment, an object needs a <code>__dict__</code>: a dict associated with the object, where arbitrary attributes can be stored. Otherwise, there's nowhere to <em>put</em> new attributes.</p>
<p>An instance of <code>object</code> does <strong>not</strong> carry around a <code>__dict__</code> -- if it did, before the horrible circular dependence problem (since <code>dict</code>, like most everything else, inherits from <code>object</code>;-), this would saddle <em>every</em> object in Python with a dict, which would mean an overhead of <em>many</em> bytes per object that currently doesn't have or need a dict (essentially, all objects that don't have arbitrarily assignable attributes don't have or need a dict).</p>
<p>For example, using the excellent <code>pympler</code> project (you can get it via svn from <a href="http://code.google.com/p/pympler/source/checkout" rel="noreferrer">here</a>), we can do some measurements...:</p>
<pre><code>&gt;&gt;&gt; from pympler import asizeof
&gt;&gt;&gt; asizeof.asizeof({})
144
&gt;&gt;&gt; asizeof.asizeof(23)
16
</code></pre>
<p>You wouldn't want every <code>int</code> to take up 144 bytes instead of just 16, right?-)</p>
<p>Now, when you make a class (inheriting from whatever), things change...:</p>
<pre><code>&gt;&gt;&gt; class dint(int): pass
... 
&gt;&gt;&gt; asizeof.asizeof(dint(23))
184
</code></pre>
<p>...the <code>__dict__</code> <em>is</em> now added (plus, a little more overhead) -- so a <code>dint</code> instance can have arbitrary attributes, but you pay quite a space cost for that flexibility.</p>
<p>So what if you wanted <code>int</code>s with just <em>one</em> extra attribute <code>foobar</code>...? It's a rare need, but Python does offer a special mechanism for the purpose...</p>
<pre><code>&gt;&gt;&gt; class fint(int):
...   __slots__ = 'foobar',
...   def __init__(self, x): self.foobar=x+100
... 
&gt;&gt;&gt; asizeof.asizeof(fint(23))
80
</code></pre>
<p>...not <em>quite</em> as tiny as an <code>int</code>, mind you! (or even the two <code>int</code>s, one the <code>self</code> and one the <code>self.foobar</code> -- the second one can be reassigned), but surely much better than a <code>dint</code>.</p>
<p>When the class has the <code>__slots__</code> special attribute (a sequence of strings), then the <code>class</code> statement (more precisely, the default metaclass, <code>type</code>) does <strong>not</strong> equip every instance of that class with a <code>__dict__</code> (and therefore the ability to have arbitrary attributes), just a finite, rigid set of "slots" (basically places which can each hold one reference to some object) with the given names.</p>
<p>In exchange for the lost flexibility, you gain a lot of bytes per instance (probably meaningful only if you have zillions of instances gallivanting around, but, there <em>are</em> use cases for that).</p>
</div>
<div class="post-text" itemprop="text">
<p>As other answerers have said, an <code>object</code> does not have a <code>__dict__</code>. <code>object</code> is the base class of <strong>all</strong> types, including <code>int</code> or <code>str</code>. Thus whatever is provided by <code>object</code> will be a burden to them as well. Even something as simple as an <em>optional</em> <code>__dict__</code> would need an extra pointer for each value; this would waste additional 4-8 bytes of memory for each object in the system, for a very limited utility.</p>
<hr/>
<p>Instead of doing an instance of a dummy class, in Python 3.3+, you can (and should) use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace"><code>types.SimpleNamespace</code></a> for this.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is simply due to optimization.</p>
<p>Dicts are relatively large.</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof((lambda:1).__dict__)
140
</code></pre>
<p>Most (maybe all) classes that are defined in C do not have a dict for optimization.</p>
<p>If you look at the <a href="http://svn.python.org/view/python/trunk/Objects/object.c?revision=74457&amp;view=markup" rel="nofollow noreferrer">source code</a> you will see that there are many checks to see if the object has a dict or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, investigating my own question, I discovered this about the Python language: you can inherit from things like int, and you see the same behaviour:</p>
<pre><code>&gt;&gt;&gt; class MyInt(int):
       pass

&gt;&gt;&gt; x = MyInt()
&gt;&gt;&gt; print x
0
&gt;&gt;&gt; x.hello = 4
&gt;&gt;&gt; print x.hello
4
&gt;&gt;&gt; x = x + 1
&gt;&gt;&gt; print x
1
&gt;&gt;&gt; print x.hello
Traceback (most recent call last):
  File "&lt;interactive input&gt;", line 1, in &lt;module&gt;
AttributeError: 'int' object has no attribute 'hello'
</code></pre>
<p>I assume the error at the end is because the add function returns an int, so I'd have to override functions like <code>__add__</code> and such in order to retain my custom attributes. But this all now makes sense to me (I think), when I think of "object" like "int". </p>
</div>
<div class="post-text" itemprop="text">
<p>It's because object is a "type", not a class. In general, all classes that are defined in C extensions (like all the built in datatypes, and stuff like numpy arrays) do not allow addition of arbitrary attributes.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is (IMO) one of the fundamental limitations with Python - you can't re-open classes. I believe the actual problem, though, is caused by the fact that classes implemented in C can't be modified at runtime... subclasses can, but not the base classes.</p>
</div>
<span class="comment-copy">Pure guesswork: The <code>object</code> type is immutable and new attributes cannot be added? This seems like it would make the most sense.</span>
<span class="comment-copy">@ S.Lott: See the very first line of this question. Purely curiosity.</span>
<span class="comment-copy">Your title is misleading, you are trying to set attributes on <code>object</code> class instances, not on <code>object</code> class.</span>
<span class="comment-copy">This explains how the mechanism is implemented but does not explain why is it implemented in this way. I can think of at least two or three ways to implement adding <b>dict</b> on the fly which will not have the overhead downside but will add some simplicity.</span>
<span class="comment-copy">Note that non-empty <code>__slots__</code> do not work with variable-length types such as  <code>str</code>, <code>tuple</code>, and in Python 3 also <code>int</code>.</span>
<span class="comment-copy">Nice and thanks! <a href="https://stackoverflow.com/q/46575174/156458">If an object doesn't have <code>__dict__</code>, does its class must have a <code>__slot__</code> attribute?</a></span>
<span class="comment-copy">It's a great explanation, but still doesn't answer why (or how) <code>Sub</code> has the <code>__dict__</code> attribute and object doesn't, being that <code>Sub</code> inherit from <code>object</code>, how is that attribute (and others like <code>__module__</code>) added in the inheritance? May be this could be a new question</span>
<span class="comment-copy">An object's <code>__dict__</code> is only created the first time it's needed, so the memory cost situation isn't quite as simple as the <code>asizeof</code> output makes it look. (<code>asizeof</code> doesn't know how to avoid <code>__dict__</code> materialization.) You can see the dict not getting materialized until needed in <a href="https://ideone.com/xVKqMC" rel="nofollow noreferrer">this example</a>, and you can see one of the code paths responsible for <code>__dict__</code> materialization <a href="https://github.com/python/cpython/blob/v3.7.2/Objects/dictobject.c#L4288" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">But object() is an object, just like Sub() is an object. My understanding is that both s and o are objects. So what is the fundamental difference between s and o? Is it that one is an instantiated type and the other is an instantiated class?</span>
<span class="comment-copy">Bingo. That's exactly the issue.</span>
