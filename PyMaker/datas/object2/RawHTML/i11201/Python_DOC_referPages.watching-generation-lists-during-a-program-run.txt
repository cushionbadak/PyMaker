<div class="post-text" itemprop="text">
<p><strong>The Story:</strong></p>
<p>During <a href="https://www.youtube.com/watch?v=F6u5rhUQ6dU" rel="noreferrer">Nina Zakharenko's PyCon talk</a> on Memory Management in Python, she explains the way the <em>generational garbage collection</em> works in Python noting that:</p>
<blockquote>
<p>Python maintains a list of every object created as a program is run. Actually, it makes 3: </p>
<ul>
<li><code>generation 0</code></li>
<li><code>generation 1</code></li>
<li><code>generation 2</code></li>
</ul>
</blockquote>
<p><strong>The question:</strong></p>
<p>To gain more understanding in Memory Management in Python and for the purpose of debugging memory leaks, <em>how can I observe/watch what objects are added and removed from all the 3 generation lists during a program run</em>?</p>
<p>I've looked through the <a href="https://docs.python.org/2/library/gc.html" rel="noreferrer"><code>gc</code> module</a>, but have not found a relevant method to get the current generation lists values.</p>
</div>
<div class="post-text" itemprop="text">
<p>As we discussed in the comments, I don't think there is a way to access the generation lists directly from python, you can set some debug flags, in python2 you can use the following to report objects that can or cannot be collected:</p>
<pre><code>import gc

gc.set_debug(gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_COLLECTABLE | gc.DEBUG_OBJECTS )
</code></pre>
<p>In python3, using the following will give you some generation output and info on collectable and uncollectable objects:</p>
<pre><code>import gc

gc.set_debug(gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_COLLECTABLE  | gc.DEBUG_STATS)
</code></pre>
<p>You get output like:</p>
<pre><code>gc: collecting generation 2...
gc: objects in each generation: 265 4454 0
gc: collectable &lt;function 0x7fad67f77b70&gt;
gc: collectable &lt;tuple 0x7fad67f6f710&gt;
gc: collectable &lt;dict 0x7fad67f0e3c8&gt;
gc: collectable &lt;type 0x285db78&gt;
gc: collectable &lt;getset_descriptor 0x7fad67f095e8&gt;
gc: collectable &lt;getset_descriptor 0x7fad67f09630&gt;
gc: collectable &lt;tuple 0x7fad67f05b88&gt;
gc: done, 7 unreachable, 0 uncollectable, 0.0028s elapsed.
gc: collecting generation 2...
</code></pre>
<p>For leaks as per the <a href="https://docs.python.org/3/library/gc.html#gc.DEBUG_SAVEALL" rel="nofollow"><code>gc.DEBUG_SAVEALL</code></a> <em>when set, all unreachable objects found will be appended to garbage rather than being freed. This can be useful for debugging a leaking program</em>:</p>
<pre><code>import gc

gc.set_debug(gc.DEBUG_SAVEALL)
</code></pre>
<p>In python3, you can also append a callback that is run when the gc starts and finishes, a simple example:</p>
<pre><code>def f(phase, info):
    if phase == "start":
        print("starting garbage collection....")
    else:
        print("Finished garbage collection.... \n{}".format("".join(["{}: {}\n".format(*tup) for tup in info.items()])))

        print("Unreachable objects: \n{}".format(
            "\n".join([str(garb) for garb in gc.garbage])))
        print()


 gc.callbacks.append(f)
</code></pre>
<p>Combining <code>gc.DEBUG_SAVEALL</code> with the function will show you any unreachable objects, not much different to setting the <code>DEBUG_COLLECTABLE</code> or <a href="https://docs.python.org/3/library/gc.html#gc.DEBUG_LEAK" rel="nofollow">DEBUG_LEAK</a> but one example of adding a <a href="https://docs.python.org/3/library/gc.html#gc.callbacks" rel="nofollow">callback</a>. </p>
</div>
<span class="comment-copy">Do you mean setting <code>gc.set_debug(flags...)</code>?</span>
<span class="comment-copy">@PadraicCunningham at this point, I don't know what I mean exactly since this is very new to me. I have not tried setting the debug mode..let me see if it helps to view the generation lists. Thanks!</span>
<span class="comment-copy">@alexce, I could be wrong but I am not sure the generation lists are accessible directly, you would use the debug flags and the other gc methods to gather info.</span>
<span class="comment-copy">@PadraicCunningham okay, feel free to post that as an answer. No, it is not possible is a valid answer as well. Thanks.</span>
<span class="comment-copy">@alexce, I will try to throw something together that at least gets some way to what you want.</span>
