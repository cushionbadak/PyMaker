<div class="post-text" itemprop="text">
<p>I'm searching an elegant (an efficient) way to implement the following:</p>
<p>I have a class storing a list of values as a <strong>string</strong> (with a separator, eg.: " - "). I use a property (getter and setter) to convert this string into a Python <code>list</code>.</p>
<pre><code>class C(object):
    def __init__(self, values):
        """
        Construct C with a string representing a list of values.

        :type values: str
        :param values: List of values
        """
        self.values = values

    @property
    def value_list(self):
        """ Values as list """
        return self.values.split(" - ")

    @value_list.setter
    def value_list(self, seq):
        self.values = " - ".join(seq)
</code></pre>
<p>Getting / Setting the property is OK:</p>
<pre><code>c = C("one - two")
assert c.value_list == ["one", "two"]

c.value_list = ["one", "two", "three"]
assert c.values == "one - two - three"
</code></pre>
<p>But I'm looking for something (may be another kind of <strong>list</strong>) to automatically reflect the changes in the <code>list</code>.</p>
<pre><code>c.value_list.append("four")
assert c.values == "one - two - three - four"

Traceback (most recent call last):
...
AssertionError
</code></pre>
<p>Currently, I implement my own <code>list</code> class inheriting <code>collections.MutableSequence</code> with a callback system.
Is there a better way to do that?</p>
<p><strong>EDIT: my current solution</strong></p>
<p>I use a <strong>list</strong> with a "on_change" handler, like this:</p>
<pre><code>class MyList(collections.MutableSequence):
    """ A ``list`` class with a "on_change" handler. """

    def __init__(self, *args):
        self._list = list(*args)

    def on_change(self, seq):
        pass

    def __getitem__(self, index):
        return self._list.__getitem__(index)

    def __len__(self):
        return self._list.__len__()

    def __setitem__(self, index, value):
        self._list.__setitem__(index, value)
        self.on_change(self._list)

    def __delitem__(self, index):
        self._list.__delitem__(index)
        self.on_change(self._list)

    def insert(self, index, value):
        self._list.insert(index, value)
        self.on_change(self._list)
</code></pre>
<p>Then I need to modify my <code>C</code> class to implement this handler to reflect the changes.</p>
<p>The new version of the class is:</p>
<pre><code>class C(object):
    def __init__(self, values):
        """
        Construct C with a string representing a list of values.

        :type values: str
        :param values: List of values
        """
        self.values = values

    def _reflect_changes(self, seq):
        self.values = " - ".join(seq)

    @property
    def value_list(self):
        """ Values as list """
        my_list = MyList(self.values.split(" - "))
        my_list.on_change = self._reflect_changes
        return my_list

    @value_list.setter
    def value_list(self, seq):
        self.values = " - ".join(seq)
</code></pre>
<p>That way, any change in the list in reflected in the <code>values</code> attribute:</p>
<pre><code>c = C("one - two")

c.value_list.append("three")
assert c.values == "one - two - three"

c.value_list += ["four"]
assert c.values == "one - two - three - four"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe I'm oversimplifying your problem because you've oversimplified your first example, but I'm going to agree with some of the commenters and propose that you change around the way you store this. <strong>Store the list, produce the string on demand.</strong></p>
<pre><code>In [1]: class C(object):
   ...:     def __init__(self, values):
   ...:         self.values = values.split(' - ')
   ...:     @property
   ...:     def value_str(self):
   ...:         return ' - '.join(self.values)
   ...:

In [2]: c = C('one - two - three')

In [3]: c.values
Out[3]: ['one', 'two', 'three']

In [4]: c.values.append('four')

In [5]: c.value_str
Out[5]: 'one - two - three - four'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would approach this by overloading certain operators you want to support, for example the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow">+= operator by defining <code>__iadd__</code></a>. You would then be able to do something like:</p>
<pre><code>class C(object):
    def __init__(self, values):
        self._values = values

    def __iadd__(self, value):
        self._values += " - " + str(value)
        return self

obj = C("one - two")
obj += "three"

print(obj.values) # "one - two - three"
</code></pre>
<p>See the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow">docs</a> for more info on operator overloading.</p>
</div>
<span class="comment-copy">Why not store the list and generate the string, rather than the other way around?</span>
<span class="comment-copy">How about <code>c.value_list += ["four"]</code>?</span>
<span class="comment-copy">@BrenBam: In fact I simplify the problem drastically. I get <b>string</b> values from parsed data (a file). Some values are scalar/non mutable data (no problem here) but some represent collections. I choose the most common one: a <b>list</b>.</span>
<span class="comment-copy">Updated example with operator overloading</span>
<span class="comment-copy">Of course you can add operators. But this solution is not generic. What about multiple attributes like <code>_values</code>?</span>
