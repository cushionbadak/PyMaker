<div class="post-text" itemprop="text">
<p>I want to test that the <code>ftp.storbinary()</code> function is called with the right arguments. This however is part of a different module from the one were the test live.</p>
<p>In the <code>io.py</code> module I have this method (which is part of a class):</p>
<pre><code>def to_ftp(self, output_path, file_name, host, username, password):
    """Upload file to FTP server."""

    ftp = ftplib.FTP(host)
    ftp.login(username, password)
    full_path = os.path.join(output_path, file_name)
    with open(full_path, "r") as ftp_file:
        ftp.storbinary(" ".join(["STOR", file_name]), ftp_file.read)
</code></pre>
<p>I've create a <code>test_io.py</code> module where I have a series of unittests. I was thinking to patch both <code>open</code> and <code>ftplib.FTP</code>, because I'm passing to <code>ftp.storbinary()</code> <code>ftp_file.read()</code>. </p>
<pre><code>@patch("ppc_model.io.ftplib.FTP")
def test_store_call(self, mock_ftp):
    """The *storbinary* call must use the right arguments."""

    with patch("ppc_model.io.open", mock_open(read_data=None)) as m:
        self.writer.to_ftp(output_path="./output", file_name="output.zip",
                       host="myftp", username="username", password="password")
    mock_ftp.return_value.storbinary.assert_called_once_with(
    "STOR output.zip", m.read())
</code></pre>
<p>This however returns an AttributeError because the module doesn't have an attribute <code>open</code>. How can I make sure Mock understand I'm trying to mock the builtin function?</p>
<p>Is there also a better way to test I'm passing the right arguments to <code>ftp.storbinary</code>? I'm kinda new to mocking. </p>
<p><strong>EDIT:</strong> I've made some progress. I think the issue was that I was trying to patch the wrong object. With <code>open</code> I think I have to patch <code>builtins.open</code>. A bit counter-intuitive.</p>
<pre><code>@patch("ppc_model.io.ftplib.FTP")
def test_store_call(self, mock_ftp):
    """The *storbinary* call must use the right arguments."""

    with patch("builtins.open", mock_open(read_data=None), create=True) as m:
        self.writer.to_ftp(output_path="./output", file_name="output.zip",
                       host="myftp", username="username", password="password")
    mock_ftp.return_value.storbinary.assert_called_once_with(
    "STOR output.zip", m.read())
</code></pre>
<p>Unfortunately now the compiler is complaining about the fact that the Mock object doesn't have a <code>read</code> method. </p>
<p><code>AttributeError: Mock object has no attribute 'read'</code></p>
<p><strong>EDIT 2:</strong> Following RedCraig's advice I've patched the <code>open</code> method in the local namespace and passed to <code>ftp.storbinary</code> ftp_file instead of ftp_file.read()). So the current unit test is:</p>
<pre><code>@patch("ppc_model.io.ftplib.FTP")
def test_store_call(self, mock_ftp):
    """The *storbinary* call must use the right arguments."""

with patch("{}.open".format(__name__), mock_open(read_data=None),
           create=True) as m:
    self.writer.to_ftp(output_path="./output", file_name="output.zip",
                   host="myftp", username="username", password="password")
mock_ftp.return_value.storbinary.assert_called_once_with(
"STOR output.zip", m)
</code></pre>
<p>And the code I'm trying to test:</p>
<pre><code>def to_ftp(self, output_path, file_name, host, username, password):
    """Upload file to FTP server."""

    ftp = ftplib.FTP(host)
    ftp.login(username, password)
    full_path = os.path.join(output_path, file_name)
    with open(full_path, "r") as ftp_file:
        ftp.storbinary(" ".join(["STOR", file_name]), ftp_file)
</code></pre>
<p>The current error I get is:</p>
<pre><code>AssertionError: Expected call: storbinary('STOR output.zip', &lt;MagicMock name='open' spec='builtin_function_or_method' id='140210704581632'&gt;)
Actual call: storbinary('STOR output.zip', &lt;_io.TextIOWrapper name='./output/output.zip' mode='r' encoding='UTF-8'&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>AssertionError: Expected call: storbinary('STOR output.zip', )</p>
<p>Actual call: storbinary('STOR output.zip', &lt;_io.TextIOWrapper name='./output/output.zip' mode='r' encoding='UTF-8'&gt;)</p>
</blockquote>
<p>For the actual call <code>storbinary</code> was given <code>&lt;_io.TextIOWrapper...</code> rather than the mocked object. Seems like the mocking of <code>open</code> isn't working, perhaps your module name is incorrect.</p>
<p>Here are the <a href="https://docs.python.org/3/library/unittest.mock-examples.html" rel="nofollow noreferrer">unittest.mock examples</a>, this page has an example of mocking open:</p>
<pre><code>&gt;&gt;&gt; mock = MagicMock(return_value=sentinel.file_handle)
&gt;&gt;&gt; with patch('builtins.open', mock):
...     handle = open('filename', 'r')
...
&gt;&gt;&gt; mock.assert_called_with('filename', 'r')
&gt;&gt;&gt; assert handle == sentinel.file_handle, "incorrect file handle returned"
</code></pre>
<p>I tried mocking open in another module and it works, there's a catch when using it with <code>assert_called_once_with()</code>. When patching open mock uses a MagicMock object, every call to <code>open()</code> returns a new object. So the test case which patches <code>open</code> using a <code>with as m</code> style statement will have a different value for <code>m</code> than the open call from <code>to_ftp</code> ad <code>assert_called_once_with()</code> will fail.</p>
<p>While I'm sure there's a better way with <code>Mock</code> and <code>assert_called_once_with</code>, I resorted to using a <code>StringIO</code> object when mocking <code>open</code> so that each call returns the <em>same</em> <code>StringIO</code> instance:</p>
<pre><code>import ftplib
import os

from io import StringIO
from unittest import TestCase
from unittest.mock import patch


def to_ftp(output_path, file_name, host, username, password):
    """Upload file to FTP server."""
    ftp = ftplib.FTP(host)
    ftp.login(username, password)
    full_path = os.path.join(output_path, file_name)
    with open(full_path, "r") as ftp_file:
        ftp.storbinary(" ".join(["STOR", file_name]), ftp_file)


class TestOpenMock(TestCase):
    @patch("ftplib.FTP")
    def test_store_call(self, mock_ftp):
        """The *storbinary* call must use the right arguments."""
        open_file = StringIO('test_data')
        with patch('%s.open' % __name__, return_value=open_file):
            to_ftp(output_path="./output", file_name="output.zip",
                   host="myftp", username="username", password="password")

        mock_ftp.return_value.storbinary.assert_called_once_with(
            "STOR output.zip", open_file)
</code></pre>
<p>This passes. Obviously you'll have to change your <code>'%s.open' % __name__</code> to your module containing <code>to_ftp</code>.</p>
<hr/>
<h2>Original Answer (@any so mod: should I just delete this?):</h2>
<p>1) This looks like the answer you're looking for:
<a href="https://stackoverflow.com/a/6112456/2175385">How do I mock an open used in a with statement (using the Mock framework in Python)?</a>
It mocks <code>open</code> using <code>&lt;local module name&gt;.open</code>.</p>
<p>2)  </p>
<blockquote>
<p>AttributeError: Mock object has no attribute 'read'</p>
</blockquote>
<p>It's complaining about the read because you're passing the read method to <code>storbinary</code>:</p>
<pre><code>ftp.storbinary(" ".join(["STOR", file_name]), ftp_file.read)
</code></pre>
<p>and your mocked instance of open <code>ftp_file</code> doesn't have that method.</p>
<p>3) You're checking that <code>storbinary</code> was called with <code>m.read()</code> but you're passing in <code>m.read</code>. <code>m.read()</code> invokes the read method whereas <code>m.read</code> is a reference to the method.</p>
<pre><code>mock_ftp.return_value.storbinary.assert_called_once_with("STOR output.zip", m.read())
</code></pre>
<p>4) Looking at the docs for <a href="https://docs.python.org/2.7/library/ftplib.html#ftplib.FTP.storbinary" rel="nofollow noreferrer"><code>ftp.storbinary</code></a>, it expects the file object itself, not a reference to the file objects <code>read</code> method. It should be:</p>
<pre><code>ftp.storbinary(" ".join(["STOR", file_name]), ftp_file)
</code></pre>
<p>Passing in the (mocked) file object will address point 3) above.</p>
</div>
<span class="comment-copy">If <code>open</code> is the python builtin, then does: <code>with patch("open", ...</code> work? The way you're testing the args looks fine.</span>
<span class="comment-copy">Yes <code>open</code> is the python builtin, however <code>with patch("open", ...</code> doesn't work.</span>
<span class="comment-copy">I've edited the question to reflect your suggestions. Thanks!</span>
