<div class="post-text" itemprop="text">
<p>I have two lists </p>
<pre><code>x = [ None , None , "foo" , "bar" ]
y = [ "bar" , "foo" , "foo" ,"bar"]

len(x) == len(y)
</code></pre>
<p>I want to check if there exists an element in list <code>x</code> that is <code>None</code> then remove that element and remove corresponding element in y too .
like remove <code>x[0] == None</code> , so remove <code>x[0]</code> and <code>y[0]</code> from <code>x</code> and <code>y</code> </p>
<p>the result should be:</p>
<pre><code>x = ["foo","bar"]
y = ["foo","bar"]
</code></pre>
<p>i tried a quite non-pythonic way which gave me a "list index out of range " error:</p>
<pre><code>for i in range(0,len(x)):
    if(x[i] == None):
        x.remove(x[i])
        y.remove(y[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip</a> method you can do this very nicely:</p>
<pre><code>x, y = zip(*[(e_x, e_y) for e_x, e_y in zip(x, y) if e_x is not None])
</code></pre>
<p>Here you iterate over both lists at once, creating a new list with tuples containing the elements of x and y. These tuples are only added if the element from x <code>e_x</code> is not <code>None</code>.
The outer <code>zip</code> converts the list of tuples back in two separate lists.</p>
<p>Edit: As Donkey Kong pointed out in a comment, it is better to use <code>is not None</code> instead of <code>!= None</code>. I updated the code accordingly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's call your lists xs and ys.</p>
<pre><code>ys = [y for (x, y) in zip(xs, ys) if x]
xs = [x for x in xs if x]
</code></pre>
<p>should do the trick. </p>
</div>
<div class="post-text" itemprop="text">
<p>First go through and figure out what you need to remove:</p>
<pre><code>remove_ix = {ix for ix, val in enumerate(x) if val is None}
</code></pre>
<p>Now you can use it to filter <code>x</code> and <code>y</code>:</p>
<pre><code>x = [item for ix, item in enumerate(x) if ix not in remove_ix]
y = [item for ix, item in enumerate(y) if ix not in remove_ix]
</code></pre>
<hr/>
<p>Note that with your version, you'll end up skipping indices and probably having <code>IndexError</code>s because if the initial length of the list is <code>N</code> and you remove a single item, then you'll still be looping <code>N</code> times, but the list is now <code>N-1</code> items long.  Also with <code>list.remove</code>, you can't guarantee that you're removing the <em>correct</em> item if there are duplicates (which there are in your example)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>zip</code> to remove items that are <code>None</code> (in x) from matching pairs of x and y, then use another  <code>zip(*...)</code> to transpose the list of lists back to the references x and y:</p>
<pre><code>x, y = zip(*[[ix, iy] for ix, iy in zip(x, y) if ix is not None])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the most performant way to achieve desired output would be dict comprehension. In that case you avoid avoid 2 list comprehension expressions:</p>
<pre><code>x_list = [ None , None , "foo" , "bar" ]
y_list = [ "bar" , "foo" , "foo" ,"bar"]
d = {val:y_list[i] for i,val in enumerate(x_list) if val is not None}
new_l_y = d.values()
new_l_x = d.keys()
</code></pre>
<p><strong>NOTE:</strong> You would miss order of elements but keep correspondence of items. If order matters you can use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow">OrderedDict</a>.</p>
<pre><code>from collections import OrderedDict
d = OrderedDict((val,y_list[i]) for i,val in enumerate(x_list) if val is not None)
new_l_y = d.keys()
new_l_y = d.values()
</code></pre>
</div>
<span class="comment-copy">"list index out of range" error is thrown, since you decide in your for loop that the index goes from 0...len(x) - 1. Then you go on and delete elements from the list, which reduces the length of the list. So you try to access more elements than it contains if you ever delete an element.</span>
<span class="comment-copy">Nice, though better to use <code>is not None</code>, generally speaking. <a href="http://jaredgrubb.blogspot.nl/2009/04/python-is-none-vs-none.html" rel="nofollow noreferrer">See here</a>.</span>
<span class="comment-copy">I like this answer ... Maybe more than mine :-)</span>
<span class="comment-copy">Why not just <code>xs,ys = [(x,y) for (x,y) in zip(xs,ys) if x]</code>? Saves you doing another loop.</span>
<span class="comment-copy">And the condition is better off as <code>if x is not None</code> to avoid skipping <code>0</code>s</span>
<span class="comment-copy">Your first optimization won't work. Returning a (x, y) in the list comprehension will return a tuple, i.e. a list of tuples. Your code only executes if a list of two tuples will be returned and instantly unpacked into xs, ys.  The other thing 'x is not None' might be a good thing, depending on the type of lists you want to cover.</span>
<span class="comment-copy">@SvbZ3r0 dict comprehension can be used to avoid two loops. See my answer</span>
