<div class="post-text" itemprop="text">
<p>Is it possible to print my environment variable memory address ?</p>
<p>With <code>gdb-peda</code> i have a memory address looking like <code>0xbffffcd6</code> with <code>searchmem</code> and i know it's the right form. (<code>0xbfff????</code>) but gdb moved the stack with some other environment variable.</p>
<p>I would like with my python script to get this address and then do my trick and include my shellcode.</p>
<p>i tried (with Python):</p>
<pre><code>print hex(id(os.environ["ENVVAR"]))
print memoryview(os.environ["ENVVAR"])

# output :
# 0xb7b205c0L
# &lt;memory at 0xb7b4dd9c&gt;
</code></pre>
<p>With Ruby :</p>
<pre><code>puts (ENV['PATH'].object_id &lt;&lt; 1).to_s(16)
# output :
# -4836c38c
</code></pre>
<p>If anyone have an idea, with python or ruby.</p>
</div>
<div class="post-text" itemprop="text">
<p>The cpython built in function id() returns a unique id for any object, which is not exactly it's memory address but is as close as you can get to such.</p>
<p>For example, we have variable x.  id(x) does not return the memory address of the variable x, rather it returns the memory address of the object that x points to.</p>
<p>There's a strict separation between 'variables' and 'memory objects'.  In the standard implementation, python allocates a set of locals and a stack for the virtual machine to operate on. All local slots are disjoint, so if you load an object from local slot x onto the stack and modify that object, the "location" of the x slot doesn't change.</p>
<p><a href="https://i.stack.imgur.com/3Dg6I.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/3Dg6I.png"/></a>
<a href="http://docs.python.org/library/functions.html#id" rel="nofollow noreferrer">http://docs.python.org/library/functions.html#id</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This seems an impossible task at least in python.
There are few things to take in consideration from this question:</p>
<ul>
<li>ASLR would make this completely impossible</li>
<li>Every binary can have it's own overhead, different argv, so, the only reliable option is to execute the binary and trace it's memory until we found the environment variable we are looking for. Basically, even if we can find the environment address in the python process, it would be at a different position in the binary you are trying to exploit.</li>
</ul>
<p>Best fit to answer this question is to use <a href="http://python3-pwntools.readthedocs.io/en/latest/elf.html" rel="nofollow">http://python3-pwntools.readthedocs.io/en/latest/elf.html</a> which is taking a coredump file where it's easy to find the address.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose you could do that using the <a href="https://docs.python.org/2/library/ctypes.html" rel="nofollow"><code>ctypes</code></a> module to call the native <code>getenv</code> directly :</p>
<pre><code>import ctypes

libc = ctypes.CDLL("libc.so.6")

getenv = libc.getenv
getenv.restype = ctypes.c_voidp

print('%08x' % getenv('PATH'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please keep in mind that system environment variable is not an object you can access by its memory address. Each process, like Python or Ruby process running your script will receive its own copy of environment. Thats why results returned by Python and Ruby interpreters are so different.</p>
<p>If you would like to modify system environment variable you should use API provided by your programming language.
Please see <a href="http://code.activestate.com/recipes/416087/" rel="nofollow noreferrer">this</a> or <a href="https://stackoverflow.com/questions/5971312/how-to-set-environment-variables-in-python">that</a> post for Python solution.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The getenv() function is inherently not reentrant because it returns a value pointing to <strong>static</strong> data.  </p>
<p>In fact, for higher performance of getenv(), the implementation could also maintain a separate copy of the environment in a data structure that could be searched much more quickly (such as an indexed hash table, or a binary tree), and update both it and the linear list at environ when setenv() or unsetenv() is invoked.  </p>
</blockquote>
<p>So the address returned by <a href="http://man.cx/getenv%283%29" rel="nofollow noreferrer">getenv</a> is not necessarily from the environment.</p>
<p>Process memory layout;  </p>
<p><a href="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" rel="nofollow noreferrer">http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png</a></p>
<p><a href="http://d1gjlxt8vb0knt.cloudfront.net//wp-content/uploads/Memory-Layout-300x255.gif" rel="nofollow noreferrer">http://d1gjlxt8vb0knt.cloudfront.net//wp-content/uploads/Memory-Layout-300x255.gif</a></p>
<p>Memory map</p>
<pre><code>import os

def mem_map():
    path_hex = hex(id(os.getenv('PATH'))).rstrip('L')
    path_address = int(path_hex, 16)
    for line in open('/proc/self/maps'):
        if 'stack' in line:
            line = line.split()
            first, second = line[0].split('-')
            first, second = int(first, 16), int(second, 16)
            #stack grows towards lower memory address
            start, end = max(first, second), min(first, second)
            print('stack:\n\tstart:\t0x{}\n\tend:\t0x{}\n\tsize:\t{}'.format(start, end, start - end))
            if path_address in range(end, start+1):
                print('\tgetenv("PATH") ({}) is in the stack'.format(path_hex))
            else:
                print('\tgetenv("PATH") ({}) is not in the stack'.format(path_hex))
            if path_address &gt; start:
                print('\tgetenv("PATH") ({}) is above the stack'.format(path_hex))
            else:
                print('\tgetenv("PATH") ({}) is not above the stack'.format(path_hex))
            print('')
            continue
        if 'heap' in line:
            line = line.split()
            first, second = line[0].split('-')
            first, second  = int(first, 16), int(second, 16)
            #heap grows towards higher memory address
            start, end = min(first, second), max(first, second)
            print('heap:\n\tstart:\t0x{}\n\tend:\t0x{}\n\tsize:\t{}'.format(start, end, end - start))
            if path_address in range(start, end+1):
                print('\tgetenv("PATH") ({}) in the heap'.format(path_hex))
            else:
                print('\tgetenv("PATH") ({}) is not in the heap'.format(path_hex))
            print('')
</code></pre>
<p>Output;</p>
<pre><code>heap:
        start:  0x170364928
        end:    0x170930176
        size:   565248
        getenv("PATH") (0xb74d2330) is not in the heap

stack:
        start:  0x0xbffa8000L
        end:    0x0xbff86000L
        size:   139264
        getenv("PATH") (0xb74d2330) is not in the stack
        getenv("PATH") (0xb74d2330) is not above the stack
</code></pre>
<p>Environment is above the stack. So its address should be higher than the stack. But the address <code>id</code> shows is not in the stack, not in the heap and not above the stack. Is it really an address? or my calculation is wrong!</p>
<p>Here's the code to check where an object lies in memory.</p>
<pre><code>def where_in_mem(obj):
    maps = {}
    for line in open('/proc/self/maps'):
        line = line.split()
        start, end = line[0].split('-')

        key = line[-1] if line[-1] != '0' else 'anonymous'
        maps.setdefault(key, []).append((int(start, 16), int(end, 16)))

    for key, pair in maps.items():
        for start, end in pair:
            # stack starts at higher memory address and grows towards lower memory address
            if 'stack' in key:
                if start &gt;= id(obj) &gt;= end:
                    print('Object "{}" ({}) in the range {} - {}, mapped to {}'.format(obj, hex(id(obj)), hex(start), hex(end), key))
                    continue
            if start &lt;= id(obj) &lt;= end:
                print('Object "{}" ({}) in the range {} - {}, mapped to {}'.format(obj, hex(id(obj)), hex(start), hex(end), key))

where_in_mem(1)
where_in_mem(os.getenv('PATH'))
</code></pre>
<p>Output;</p>
<pre><code>Object "1" (0xa17f8b0) in the range 0xa173000 - 0xa1fd000, mapped to [heap]
Object "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" (0xb74a1330L) in the range 0xb7414000L - 0xb74d6000L, mapped to anonymous
</code></pre>
<p>What's <em>anonymous</em> in the above output?</p>
<blockquote>
<p>It is also possible to create an <strong>anonymous memory mapping</strong> that does not correspond to any files, being used instead for program data. In Linux, if you request a large block of memory via malloc(), the C library will create such an anonymous mapping instead of using heap memory. ‘Large’ means larger than MMAP_THRESHOLD bytes, 128 kB by default and adjustable via mallopt().</p>
</blockquote>
<p><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" rel="nofollow noreferrer">Anatomy of a Program in Memory</a></p>
<p>So the <code>os.environ['PATH']</code> is in the <code>malloc</code>ed region.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for @mickael9, I have writen a function to calculate address of an environment variable in a program:</p>
<pre><code>def getEnvAddr(envName, ELFfile):
  import ctypes
  libc = ctypes.CDLL('libc.so.6')
  getenv = libc.getenv
  getenv.restype = ctypes.c_voidp

  ptr = getenv(envName)
  ptr += (len('/usr/bin/python') - len(ELFfile)) * 2
  return ptr
</code></pre>
<p>For example:</p>
<pre><code>user@host:~$ ./getenvaddr.elf PATH /bin/ls
PATH will be at 0xbfffff22 in /bin/ls
user@host:~$ python getenvaddr.py PATH /bin/ls
PATH will be at 0xbfffff22 in /bin/ls
user@host:~$
</code></pre>
<p><strong>Note</strong>: This function only works in Linux system.</p>
</div>
<div class="post-text" itemprop="text">
<p>In ruby it's possible - this post covers the general case:
<a href="https://stackoverflow.com/questions/2402228/accessing-objects-memory-address-in-ruby">Accessing objects memory address in ruby..?</a> "You can get the actual pointer value of an object by taking the object id, and doing a bitwise shift to the left"</p>
<pre><code>puts (ENV['RAILS_ENV'].object_id &lt;&lt; 1).to_s(16)
&gt; 7f84598a8d58
</code></pre>
</div>
<span class="comment-copy">I'd be curious to hear more about the reason for needing/doing this. What is the trick? What is the shell code you want to include? Why does the shell code need the memory address of an environment variable. etc</span>
<span class="comment-copy">@ScottS. Thanks for yout interest, it is for a simple BSS overflow exploit, i know i could use another solution, i found the way to get it in C, but it's much easier to access and work with my script with python. To get my environment variable address, concat it to my shellcode and do all my stuff. I start watching the code of <code>gdb-peda</code> for searching how it does.</span>
<span class="comment-copy">@eki-al Could you send a link to the example in C?</span>
<span class="comment-copy"><a href="http://pastebin.com/3DTJB9cY" rel="nofollow noreferrer">pastebin.com/3DTJB9cY</a></span>
<span class="comment-copy">@eki-al May be loading <code>libc</code> with <code>ctypes</code> and calling to C getenv from Python is an option. See docs on <code>ctypes</code> here: <a href="https://docs.python.org/2/library/ctypes.html" rel="nofollow noreferrer">docs.python.org/2/library/ctypes.html</a></span>
<span class="comment-copy">Thank you for this nice explanation, but i think it might be another way to access to memory address, i took a quick look at <code>peda</code> github, for the <code>searchmem</code> function this is how it's handle, i will test this weekend : <a href="https://github.com/longld/peda/blob/b7c7d7aeeba65a467fe982787b4f72e017774905/peda.py#L1889" rel="nofollow noreferrer">github.com/longld/peda/blob/…</a></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">CPython implementation detai</a>l: This is the address of the object in memory.</span>
<span class="comment-copy">Thank you, nice answer, just discover ASLR, but if I don't have ASLR set, it's compile with the stack protector flag?</span>
<span class="comment-copy">Not sure to understand your comment. ASLR is a system wide protection, it's not configured in the binary. You can do <code>cat /proc/sys/kernel/randomize_va_space</code> to see if it's enabled (value &gt; 0). Otherwise, you have also the PIE protection that could shuffle the emplacement of the ENV in the memory. No other protection should make it be at other places. Most binaries though are using the NX protection and the stack is marked as not executable, so you won't be able to place a shellcode in the env in that case.</span>
<span class="comment-copy">is ENV in the stack?</span>
<span class="comment-copy">ENV is always in the stack on Linux. Stack layout is as follow, starting from highest address : [kernel reserved space (process can't see it)] [ENV] [arguments of program] [program stack].</span>
<span class="comment-copy">It's not working, i get a negative value <code>-4836c38c</code></span>
