<div class="post-text" itemprop="text">
<p>I am trying to unit test a piece of code:</p>
<pre><code>def _parse_results(self, file_name):
    results_file = open(file_name)
    results_data = list(csv.reader(results_file))
    index = len(results_data[1])-1
    results_file.close()
    return float(results_data[1][index])
</code></pre>
<p>by using mock_open like so:</p>
<pre><code>@mock.patch('path.open', mock.mock_open(read_data='test, test2, test3, test4'))
def test_parse_results(self):
    cut = my_class(emulate=True)
    self.assertEqual(VAL, cut._parse_results('file'))
</code></pre>
<p>The problem I am running into is that I do not get any data when running csv.reader. If I run results_file.readlines() I get 'test, test2, test3, test4' which means that mock_open is working properly. But when I run csv.reader(results_file) I lose all the data.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because <code>mock_open</code> doesn't implement every feature that a file has, and notably not some of the ones that <code>csv</code> needs.</p>
<p><code>mock_open</code> implements the methods <code>read()</code>, <code>readline()</code> and <code>readlines()</code>, and works both as a function and when called as a context manager (<a href="https://docs.python.org/3/library/unittest.mock.html#mock-open" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#mock-open</a>), whereas <code>csv.reader</code> works with…</p>
<blockquote>
<p>any object which supports the iterator protocol and returns a string each time its <code>__next__()</code> method is called — file objects and list objects are both suitable</p>
<p>— <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="nofollow noreferrer">https://docs.python.org/3/library/csv.html#csv.reader</a></p>
</blockquote>
<p>Note that <code>mock_open</code> doesn't implement the <code>__next__()</code> method, and doesn't raise <code>StopIteration</code> when the end is reached, so it won't work with <code>csv.reader</code>.</p>
<p>The solution, as @Emily points out in her answer, is to turn the file into a list of its lines. This is possible because <code>mock_open</code> implements <code>readlines()</code>, and the resulting list <em>is</em> suitable for reading into <code>csv.reader</code> as the documentation says.</p>
</div>
<div class="post-text" itemprop="text">
<p>This really got me too, and was a nightmare to pinpoint.  To use your example code, this works</p>
<pre><code>results_data = list(csv.reader(results_file.read()))
</code></pre>
<p>and this works</p>
<pre><code>results_data = list(csv.reader(results_file.readlines()))
</code></pre>
<p>but this doesn't work</p>
<pre><code>results_data = list(csv.reader(results_file))
</code></pre>
<p>using Python 3.4.</p>
<p>It seems counter to the documented interface of <code>csv.reader</code> so maybe an expert can elaborate on why.</p>
</div>
<span class="comment-copy">I think this is because the csv is actually a _csv.c, a compiled c module, so it looks like the mocks are not carried over?</span>
<span class="comment-copy">Another solution to testing csv.reader (and csv.DiscReader) is to implement the __next__() method on the MagicMock mock_open returns. As seen here: <a href="https://stackoverflow.com/a/24779923/484127">stackoverflow.com/a/24779923/484127</a></span>
<span class="comment-copy">Agreed. Implementing <code>__next__()</code> is a tidy approach.</span>
