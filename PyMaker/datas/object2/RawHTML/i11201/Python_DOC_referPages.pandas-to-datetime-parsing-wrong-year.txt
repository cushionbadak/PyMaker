<div class="post-text" itemprop="text">
<p>I'm coming across something that is almost certainly a stupid mistake on my part, but I can't seem to figure out what's going on. </p>
<p>Essentially, I have a series of dates as strings in the format <code>"%d-%b-%y"</code>, such as <code>26-Sep-05</code>. When I go to convert them to datetime, the year is sometimes correct, but sometimes it is not. </p>
<p>E.g.: </p>
<pre><code>dates = ['26-Sep-05', '26-Sep-05', '15-Jun-70', '5-Dec-94', '9-Jan-61', '8-Feb-55']

pd.to_datetime(dates, format="%d-%b-%y")
DatetimeIndex(['2005-09-26', '2005-09-26', '1970-06-15', '1994-12-05',
               '2061-01-09', '2055-02-08'],
              dtype='datetime64[ns]', freq=None)
</code></pre>
<p>The last two entries, which get returned as 2061 and 2055 for the years, are wrong. But this works fine for the <code>15-Jun-70</code> entry. What's going on here?</p>
</div>
<div class="post-text" itemprop="text">
<p>That seems to be the behavior of the Python library datetime, I did a test to see where the cutoff is 68 - 69:</p>
<pre><code>datetime.datetime.strptime('31-Dec-68', '%d-%b-%y').date()
&gt;&gt;&gt; datetime.date(2068, 12, 31)

datetime.datetime.strptime('1-Jan-69', '%d-%b-%y').date()
&gt;&gt;&gt; datetime.date(1969, 1, 1)
</code></pre>
<p><strong>Two digits year ambiguity</strong></p>
<p>So it seems that anything with the %y year below 69 will be attributed a century of 2000, and 69 upwards get 1900</p>
<p>The <code>%y</code> two digits can only go from <code>00</code> to <code>99</code> which is going to be ambiguous if we start crossing centuries.</p>
<p><strong>If there is no overlap, you could manually process it and annotate the century (kill the ambiguity)</strong></p>
<p>I suggest you process your data manually and specify the century, e.g. you can decide that anything in your data that has the year between 17 and 68 is attributed to 1917 - 1968 (instead of 2017 - 2068).</p>
<p><strong>If you have overlap then you can't process with insufficient year information, unless e.g. you have some ordered data and a reference</strong></p>
<p>If you have overlap e.g. you have data from both 2016 and 1916 and both were logged as '16', that's ambiguous and there isn't sufficient information to parse this, unless the data is ordered by date in which case you can use heuristics to switch the century as you parse it.</p>
</div>
<div class="post-text" itemprop="text">
<p>from the <a href="https://docs.python.org/3/library/time.html" rel="nofollow">docs</a></p>
<blockquote>
<p><strong>Year 2000 (Y2K) issues:</strong> Python depends on the platform’s C library,
  which generally doesn’t have year 2000 issues, since all dates and
  times are represented internally as seconds since the epoch. Function
  strptime() can parse 2-digit years when given %y format code. When
  2-digit years are parsed, they are converted according to the POSIX
  and ISO C standards: values <strong>69–99</strong> are mapped to <strong>1969–1999</strong>, and values
  <strong>0–68</strong> are mapped to <strong>2000–2068</strong>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For anyone looking for a quick and dirty code snippet to fix these cases, this worked for me:</p>
<pre><code>from datetime import timedelta, date
col = 'date'
df[col] = pd.to_datetime(df[col])
future = df[col] &gt; date(year=2050,month=1,day=1)
df.loc[future, col] -= timedelta(days=365.25*100)
</code></pre>
<p>You may need to tune the threshold date closer to the present depending on the earliest dates in your data.</p>
</div>
<span class="comment-copy">your dates are ambiguous, so Python doesn't know whether it's 1965 or 2065. Are you sure you won't have any dates in future?</span>
<span class="comment-copy">70 is no less ambiguous than 65 though - the question is partly why one choice is made in one scenario and not the other</span>
<span class="comment-copy">This is what I was figuring was going on. Do you have any insight into why the cutoff is where it is? I was thinking it might have something to do with when Unix time starts,  but since 69 works that's not it.</span>
