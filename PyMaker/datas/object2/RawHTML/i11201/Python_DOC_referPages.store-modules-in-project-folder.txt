<div class="post-text" itemprop="text">
<p>Some times i need to use modules which are not a part of default python installation and some times even packages like Anaconda or Canopy does not include them. So  every time I move my project to another machine or just reinstall python i need to download them again. So my question is. Is there a way to store necessory modules in the project folder and use them from it without moving to default python installation folder. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/venv.html" rel="nofollow">virtual environment</a> or <a href="https://www.docker.com" rel="nofollow">docker</a> to install the required modules in your project dir so it is isolated from your system Python installation. In fact, you don't need Python installed on your machine when using docker.</p>
<p>Here is my workflow when developing Django web app with Docker. If your project dir is in <code>/Projects/sampleapp</code>, change the current working directory to the project dir and run the following.</p>
<ol>
<li><p>Run a docker container from your terminal:</p>
<pre><code>docker run \
    -it --rm \
    --name django_app \
    -v ${PWD}:/app \
    -w /app \
    -e PYTHONUSERBASE=/app/.vendors \
    -p 8000:8000 \
    python:3.5 \
    bash -c "export PATH=\$PATH:/app/.vendors/bin &amp;&amp; bash"

# Command expalanation:
#
# docker run                         Run a docker container
# -it                                Set interactive and allocate a pseudo-TTY
# -rm                                Remove the container on exit
# --name django_app                  Set the container name
# -v ${PWD}:/app                     Mount current dir as /app in the container
# -w /app                            Set the current working directory to /app
# -e PYTHONUSERBASE=/app/.vendors    pip will install packages to /app/.vendors
# -p 8000:8000                       Open port 8000
# python:3.5                         Use the Python:3.5 docker image
# bash -c "..."                      Add /app/.vendors/bin to PATH and open the shell
</code></pre></li>
<li><p>On the container's shell, install the required packages:</p>
<pre><code>pip install django celery django-allauth --user
pip freeze &gt; requirements.txt
</code></pre>
<p>The <code>--user</code> options along with the <code>PYTHONUSERBASE</code> environment variable will make pip installs the packages in <code>/app/.vendors</code>.</p></li>
<li><p>Create the django project and develop the app as usual:</p>
<pre><code>django-admin startproject sampleapp
cd sampleapp
python manage.py runserver 0.0.0.0:8000
</code></pre>
<p>The directory structure will look like this:</p>
<pre><code>Projects/
    sampleapp/
        requirements.txt
        .vendors/           # Note: don't add this dir to your VCS
        sampleapp/
            manage.py
            ...
</code></pre></li>
</ol>
<p>This configuration enables you to install the packages in your project dir, isolated from your system. Note that you need to add <code>requirements.txt</code> to your VCS, but remember to exclude <code>.vendors/</code> dir.</p>
<p>When you need to move and run the project on another machine, run the docker command above and reinstall the required packages on the container's shell:</p>
<pre><code>pip install -r requirements.txt --user
</code></pre>
</div>
<span class="comment-copy">I advise to reinstall the modules; it's relatively quick and painless with <code>pip</code>. Putting them in your project folder is just going to mess up your project and those modules at some point. Also, do you really move machine or reinstall Python that often?</span>
<span class="comment-copy">You need <code>pip install requirements.txt</code> and <code>virtualenv</code></span>
<span class="comment-copy">Yes, it's called virtual environments: <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">docs.python-guide.org/en/latest/dev/virtualenvs</a></span>
<span class="comment-copy">You can't just move a virtualenv around from machine to machine: the Python executable in the virtualenv is linked to the Python executable on the machine, so the link might be broken or otherwise invalid.</span>
