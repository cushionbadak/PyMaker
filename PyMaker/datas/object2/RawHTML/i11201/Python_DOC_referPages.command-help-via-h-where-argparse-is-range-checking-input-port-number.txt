<div class="post-text" itemprop="text">
<p>I'm using <code>argparse</code> to parse the inputs to my python3 program.  I was recently asked to range check some of the numeric inputs, a seemingly good idea.  Argparse has a facility to do just that. </p>
<p>The numeric inputs are port numbers, in the usual range 0-65535, so I altered my parse command line to :</p>
<pre><code>import argparse
cmd_parser = argparse.ArgumentParser()
cmd_parser = add_argument('-p', help='Port number to connect to', dest='cmd_port', default=1234, type=int, choices=range(0,65536))
cmd_parser.parse_args(['-h'])
</code></pre>
<p>Now, however, when I request the help, I get flooded with all the possible values from argparse.   eg.</p>
<pre><code>optional arguments:
    -h, --help            show this help message and exit
    -p {0,1,2,3,4,5,6,7,8,9,10,11,12,13 ...
    65478,65479,65480,65481,65482,65483,65484,65485,65486,65487,65488,65489,
    65490,65491,65492,65493,65494,65495,65496,65497,65498,65499,65500,65501,
    65502,65503,65504,65505,65506,65507,65508,65509,65510,65511,65512,65513,
    65514,65515,65516,65517,65518,65519,65520,65521,65522,65523,65524,65525,
    65526,65527,65528,65529,65530,65531,65532,65533,65534,65535}
                    Port number to connect to
...
</code></pre>
<p>It lists every single port in that range.   Is there a way to truncate this or make it realize its a range (0-65535) or for it to use ellipsis or something to make it a bit prettier?   Is my only option to explicitly range check my inputs with if statements?</p>
<p>I've been googling this but I'm having trouble finding examples where people used argparse and specified choices.   I also checked the documentation on argparse but didn't see anything useful.    <a href="https://docs.python.org/2/library/argparse.html" rel="nofollow">https://docs.python.org/2/library/argparse.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Use custom action...</p>
<pre><code>import argparse

class PortAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if not 0 &lt; values &lt; 2**16:
            raise argparse.ArgumentError(self, "port numbers must be between 0 and 2**16")
        setattr(namespace, self.dest, values)

cmd_parser = argparse.ArgumentParser()
cmd_parser.add_argument('-p',
                        help='Port number to connect to',
                        dest='cmd_port',
                        default=1234,
                        type=int,
                        action=PortAction,
                        metavar="{0..65535}")
</code></pre>
<p>An invalid port number will display the error message based on the raised ArgumentError. If you enter a value of 65536, the following line will be printed:</p>
<pre><code>error: argument -p: port numbers must be between 0 and 2**16
</code></pre>
<p>The usage and help messages will be printed based on the metavar displayed</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <code>int</code> as <a href="https://docs.python.org/3/library/argparse.html#type" rel="nofollow">type</a> in <code>add_argument</code>, and manually verify it's in the permitted range. Or, use a type of your own, which has a constructor that does the checking for you, and a <code>__int__</code> method for implicit conversion:</p>
<pre><code>class portnumber:
    def __init__(self, string):
        self._val = int(string)
        if (not self._val &gt; 0) or (not self.val &lt; 2**16):
            raise argparse.ArgumentTypeError("port numbers must be integers between 0 and 2**16")
    def __int__(self):
        return self._val

...

parser.add_argument("-p",type=portnumber)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Supply an explicit <code>metavar</code> argument instead of letting <code>argparse</code> produce one for you.</p>
<pre><code>cmd_parser.add_argument('-p',
                        help='Port number to connect to',
                        dest='cmd_port',
                        default=1234,
                        type=int,
                        choices=range(0,65536),
                        metavar="{0..65535}")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a Python bug/issue regarding the formatting of large <code>choices</code> lists.  Currently <code>choices</code> in the help is formatted with</p>
<pre><code>    def _metavar_formatter: ...
        choice_strs = [str(choice) for choice in action.choices]
        result = '{%s}' % ','.join(choice_strs)
</code></pre>
<p>and for errors with:</p>
<pre><code>def _check_value(self, action, value):
    # converted value must be one of the choices (if specified)
    if action.choices is not None and value not in action.choices:
        args = {'value': value,
                'choices': ', '.join(map(repr, action.choices))}
        msg = _('invalid choice: %(value)r (choose from %(choices)s)')
        raise ArgumentError(action, msg % args)
</code></pre>
<p>So it expects <code>choices</code> to be an iterable, but does nothing to compress the list or make it pretty.  Note that the only test is that <code>value not in action.choices</code>.  <code>choices</code> is a very simple feature.</p>
<p>I mentioned this issue in a previous SO question:   <a href="http://bugs.python.org/issue16468" rel="nofollow noreferrer">http://bugs.python.org/issue16468</a>.  Proposed patches are involved, so don't expect any fix soon.</p>
<p>I would recommend using your own <code>type</code> testing rather than <code>choices</code>.  Or do your own range testing after parsing.</p>
<pre><code>def myrange(astring):
   anint = int(astring)
   if anint in range(0,1000):
        return anint
   else:
        raise ValueError()
        # or for a custom error message
        # raise argparse.ArgumentTypeError('valid range is ...')

parser.add_argument('value',type=myrange,metavar='INT',help='...')
</code></pre>
<p>Another old (2012) SO question that addresses the range choices.  The answer suggests both a help-formatter fix and the custom type</p>
<p><a href="https://stackoverflow.com/questions/11272806/pythons-argparse-choices-constrained-printing">Python's argparse choices constrained printing</a></p>
<p>and</p>
<p><a href="https://stackoverflow.com/questions/13833566/python-argparse-choices-from-an-infinite-set">Python argparse choices from an infinite set</a></p>
<p>============================</p>
<p>Out of curiosity I defined a custom <code>range</code> class.  It behaves like a regular range (without the <code>step</code>) for the <code>in</code> test, but returns custom values when used as an iterator.</p>
<pre><code>class Range(object):
    def __init__(self, start, stop, n=3):
        self.start = start
        self.stop = stop
        self.n = n
    def __contains__(self, key):
        return self.start&lt;=key&lt;self.stop   
    def __iter__(self):
        if self.stop&lt;(self.start+(self.n*3)):
            for i in range(self.start, self.stop):
                yield i
        else:
            for i in range(self.start, self.start+self.n):
                yield i
            yield '...'
            for i in range(self.stop-self.n, self.stop):
                yield i
</code></pre>
<p>When used with an argument as</p>
<pre><code>parser.add_argument("-p",type=int, choices=Range(2,10,2))
</code></pre>
<p>It produces</p>
<pre><code>1455:~/mypy$ python stack37680645.py -p 3
Namespace(p=3)

1458:~/mypy$ python stack37680645.py -h
usage: stack37680645.py [-h] [-p {2,3,...,8,9}]

optional arguments:
  -h, --help        show this help message and exit
  -p {2,3,...,8,9}
</code></pre>
<p>The error message isn't quite what I'd want, but close</p>
<pre><code>1458:~/mypy$ python stack37680645.py -p 30
usage: stack37680645.py [-h] [-p {2,3,...,8,9}]
stack37680645.py: error: argument -p: invalid choice: 30 (choose from 2, 3, '...', 8, 9)
</code></pre>
<p>It would be better if the <code>choices</code> formatting allowed the <code>action.choices</code> object to create its own <code>str</code> or <code>repr</code> string.</p>
<p>Actually the <code>iter</code> could be as simple as (just one string):</p>
<pre><code>def __iter__(self):
    yield 'a custom list'
</code></pre>
<p>Another option is to use <code>metavar</code> to control the usage/help display, and this <code>__iter__</code> to control the error display.</p>
<p>One thing to watch out for when using <code>metavar</code>.  The <code>usage</code> formatter does not behave when there are special characters like space, '()' and '[]' in the metavar, especially when the usage line extends to 2 or more lines.  That's a known bug/issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>Monkey patch the <code>print_help</code> to get the desired output</p>
<pre><code>def my_help(): print "0-65535 range"
cmd_parser = argparse.ArgumentParser()
cmd_parser.add_argument('-p', help='Port number to connect to',   dest='cmd_port', default=1234, type=int, choices=range(0,65536))
cmd_parser.print_help = my_help
cmd_parser.parse_args()
</code></pre>
</div>
<span class="comment-copy">did you try monkey patching <code>parser.print_help()</code> to get the required output ?</span>
<span class="comment-copy">The print_help() command shows the same exaggerated output (every number between 0 and 65535 is shown).</span>
<span class="comment-copy">I'd try to open a bug in python's issue tracker. When generating the output it seems like <code>argparse</code> is iterating over all possible choices and displaying all of them. They could add an option to only show up to <code>N</code> choices if they are available (like first <code>N-1</code> and the last one).</span>
<span class="comment-copy">BTW: pretty closely related question: <a href="http://stackoverflow.com/questions/9366369/python-argparse-lots-of-choices-results-in-ugly-help-output" title="python argparse lots of choices results in ugly help output">stackoverflow.com/questions/9366369/â€¦</a>    I'm not closing as a duplicate since I don't find those answers satisfying and years have passed.</span>
<span class="comment-copy">I see I mentioned the bug/issue in that SO link as well.  Anyways, with your numeric range I think it's easier to test with a custom <code>type</code> rather than patch the <code>choices</code> listings.</span>
<span class="comment-copy">Why not <code>if not 0 &lt; self._val &lt; 2**16</code>?  Reads better: if the value is not in the range <code>0</code>-<code>2**16</code></span>
<span class="comment-copy">Use <code>class portnumber(int)</code> instead.</span>
<span class="comment-copy">So I'm supposed to access this argument with <code>int(args.p)</code>?  Because what appears in the Namespace is a <code>portnumber</code> instance.</span>
<span class="comment-copy">This doesn't quite do it. For alphanumeric inputs, it is fine. For the help, it makes it look nicer, but if I provide a parameter out of range it still displays the full list of options.   eg. -p -5, then it shows all the numbers.   I think I'll have to combine this with the port number class to achieve the best results.</span>
<span class="comment-copy">Oh, good grief. I'm converted; this should be fixed in <code>argparse</code> itself :)</span>
<span class="comment-copy">@LawfulEvil, see my answer to solve the parameter out of range issue. It is similar to the port number class, but I feel like it is more argparsey...</span>
