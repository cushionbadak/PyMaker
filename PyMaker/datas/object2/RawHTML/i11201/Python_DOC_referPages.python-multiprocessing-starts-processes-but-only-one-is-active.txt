<div class="post-text" itemprop="text">
<p>I got the following code from the accepted answer in the following question.  When I run it up on my windows 10 x64bit machine, in Python 3.5.1 it starts the threads but only one of them shows any CPU usage, and it is very little at that.  While this is happening the terminal is scrolling up numbers from the print statement so it is running... When I run other python scripts that use loops I see 13.5% CPU usage for the script.  I expected to see this spin up 4 threads each with 13.5% CPU usage.
I am running the script via windows command prompt and and these are the only 5 python processes running.  When I exist the script by pressing Ctrl+C all the processes stop.</p>
<p>Why is this not working as expected?</p>
<p><a href="https://i.stack.imgur.com/1cRvq.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/1cRvq.png"/></a></p>
<p>Question:
<a href="https://stackoverflow.com/questions/10262138/how-do-i-multi-process-the-itertools-product-module">How do I "multi-process" the itertools product module?</a></p>
<p>Code From Accepted Answer:</p>
<pre><code>#!/usr/bin/env python3.5
import sys, itertools, multiprocessing, functools


alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ12234567890!@#$%^&amp;*?,()-=+[]/;"
num_parts = 4
part_size = len(alphabet) // num_parts

def do_job(first_bits):
    for x in itertools.product(first_bits, alphabet, alphabet, alphabet):
        print(x)

if __name__ == '__main__':
    pool = multiprocessing.Pool(processes=4)
    results = []
    for i in range(num_parts):
        if i == num_parts - 1:
            first_bit = alphabet[part_size * i :]
        else:
            first_bit = alphabet[part_size * i : part_size * (i+1)]
        results.append(pool.apply_async(do_job(first_bit)))

    pool.close()
    pool.join()
</code></pre>
<p>Thanks for your time.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not running anything asynchronously here; you call the functions before passing to the async workers. You should pass the callable, not the result:</p>
<pre><code>pool.apply_async(do_job, (first_bit,))
</code></pre>
<p>Also note that the return value from <code>apply_async</code> is an <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.AsyncResult" rel="nofollow">AsyncResult</a> instance: when you do come to calculating things in the workers, you'll need to call <code>get()</code> on those values - again, after all the processes have finished - to actually get the results.</p>
</div>
<span class="comment-copy">Daniel, thanks for the response.  what does "You should pass the callable, not the result" mean exactly?  Are you saying I should just change this: results.append(pool.apply_async(do_job(first_bit))) to this: pool.apply_async(do_job(first_bit)) ?</span>
<span class="comment-copy">No, you should use the code that I showed in my answer.</span>
<span class="comment-copy">Sorry I didn't notice the extra set of brackets... what I meant was are you saying I should use the code you provided.  I tried this, and when I run it, it starts and ends a second later without error, but nothing is printed to the console and no threads are started.</span>
<span class="comment-copy">apologies, the second parameter should be a tuple; try it now.</span>
<span class="comment-copy">Perfect!! thanks very much for your help.</span>
