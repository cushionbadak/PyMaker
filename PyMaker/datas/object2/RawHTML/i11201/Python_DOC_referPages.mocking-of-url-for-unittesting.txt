<div class="post-text" itemprop="text">
<p>I want to mock urllib.urlopen for creating unit test</p>
<pre><code>def url_test(self):
  response = urllib2.urlopen(test_url)
  body = response.read()
  if body:
    return body.split(':')[0]
</code></pre>
<p>config.py</p>
<pre><code> test_url = "localhost"
</code></pre>
<p>I want to mock the url_test() function but I do not understand how to mock the value of test_url. Because when I am trying to unit test the function it says me "connection refused"</p>
<p>this is what i tried.</p>
<pre><code>@patch('urllib.urlopen')
def url_test(self, m_url):
  m_response = m_url.return_value
  m_response.read.return_value = 'Some body value:you wanted to return'
  self.assertTrue(url_test(), "Failed")
  m_url.assert_called_with('localhost')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would mock <em>any external system</em>, which here is <code>urllib2</code>. Assuming you are using the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unittest.mock</code> library</a> (backported to Python 2 as the <a href="https://pypi.python.org/pypi/mock" rel="nofollow"><code>mock</code> project</a>):</p>
<pre><code>with mock.patch('urllib2.urlopen') as urlopen_mock:
    mock_response = urlopen_mock.return_value
    mock_response.read.return_value = 'Some body value:you wanted to return'

    # call the method being tested
    result = someobject.url_test()

    # make assertion about the return value and that the code tried to use 
    # a specific URL
    urlopen_mock.assert_called_with('localhost')
    self.assertEqual(result, 'Some body value')
</code></pre>
<p>In your update you mock the wrong location:</p>
<pre><code>@patch('urllib.urlopen')
</code></pre>
<p>Your code uses <code>urllib2</code>, not <code>urllib</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For mocking web requests in Python, I highly recommend <a href="https://github.com/gabrielfalcao/HTTPretty" rel="nofollow">HTTPretty</a>.</p>
<p>A simple example for what you want to do would look something like:</p>
<pre><code>@httpretty.activate
def test_url():
    httpretty.register_uri(httpretty.GET, test_url,
                           body='some body value:some other value',
                           content_type="text/plain")

    self.assertEqual(url_test(), 'some_body_value')
</code></pre>
<p>There are a lot of complicated things and gotchas that come with mocking URL requests, and HTTPretty does a pretty good job of making them happen behind the scenes.</p>
<p>In terms of your function, consider making <code>test_url</code> a parameter of the method instead of a global variable - it makes testing significantly easier.</p>
</div>
<span class="comment-copy">You don't mock <code>test_url</code>, you mock <code>urllib2.urlopen</code> and assert that it gets <i>called</i> with <code>test_url</code>.</span>
<span class="comment-copy">Try getting hints from <a href="http://stackoverflow.com/questions/19203627/mocking-urllib2-urlopen-read-for-different-responses">Mocking urllib2.urlopen().read() for different responses</a> and a search on the terms <code>mock urllib2.urlopen</code> and I suggest also to understand the comment from @jonrsharpe as what you really want to mock ;-)</span>
<span class="comment-copy">it gives me connection refused error when I am calling the method to be tested !</span>
<span class="comment-copy">@sam: then you are not mocking the right place or not at the right time. Are you sure you have a mock in place for <code>urllib2.urlopen()</code> when that error happens?</span>
<span class="comment-copy">when the actual method to be tested is getting called, its calling localhost and not mocked response is retrieved. :(</span>
<span class="comment-copy">@sam: right, so the mock is not in place. There are 3 possibilities here: Something <i>else</i> is calling that method at some other point when there is no mock in place, you haven't understood how I used <code>with</code> here to use <code>mock.patch()</code> as a context manager and you didn't keep the indentation (so the mock is no longer in place by the time the method is called) or the wrong place was patched (e.g. you are using a wrapper around <code>urllib2.url_open</code> in a submodule of a package that just happens to also be called <code>urllib2</code>).</span>
<span class="comment-copy">@sam: In your question, you mocked <code>urllib.urlopen</code>, not <code>urllib2.urlopen</code>, by the way (only noticed that now). If you corrected that and still see a mock being returned, what is the <code>repr()</code> value of that mock object? It tells me what path was taken to get it, and that helps me diagnose what may be wrong.</span>
