<div class="post-text" itemprop="text">
<pre><code>group = range(1, 1001)

for num in group:
    num_length = len(str(num))
    for i in range(num_length):
        if str(num)[i] == '1' or str(num)[i] == '7':
            group.remove(num)
        except ValueError:
            pass
        else:
            pass
</code></pre>
<p>I am trying to remove numbers that contain the 1 or 7 digits in them. To avoid
    <code>"ValueError: list.remove(x): x not in list"</code>, I added the <code>"except ValueError: pass"</code>. However, I now have the <code>"SyntaxError: invalid syntax"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, <code>range</code> objects are immutable, which means you cannot remove an element from a <code>range</code> object. Moreover, it is now possible to remove elements from a sequence you are iterating over.</p>
<p>Second, the <code>except</code> block must be related to a <code>try</code> block containing the code that may generated the error that is caught with the <code>except</code>.</p>
<p>What I suggest you is to create a new list with the elements you want to keep (that is without 1 and 7 in it). You can also simplify the check for inclusion of 1 and 7 using the <code>in</code> operator.</p>
<pre><code>group = range(1, 1001)
data = []

for num in group:
    s = str(num)
    if not ('1' in s or '7' in s):
        data.append(num)

print(data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>except</code> is part of a special block called <code>try-except</code>. This is an example of usage:</p>
<pre><code>n = int(input())
try:
    print(5 // n)
except ZeroDivisionError:
    print("You entered zero!")
</code></pre>
<p>So to make your block actually catch raised exceptions, you need to wrap the part that can possibly cause an exception in a <code>try</code> block and follow it up with one or more <code>except</code> blocks, like this:</p>
<pre><code>for num in group:
    num_length = len(str(num))
    for i in range(num_length):
        if str(num)[i] == '1' or str(num)[i] == '7':
            try:
                group.remove(num)
            except ValueError:
                pass
        else:
            pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use except you also need try. For in depth information, check the <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow">documentation on error handling</a> out. </p>
<p>Also, to check if a character is in a string you can use the in keyword. </p>
<p>Additionally changing a list while iterating over it can have strange effects. So you should collect all numbers you want to remove in the first run and then iterate over the list of numbers to remove and remove them from the list.</p>
<p>Last you cannot remove from a range object, only from a list, that's why you have to turn it into one. The final code can look something like this:
</p>
<pre><code>group = list(range(1, 100))
to_remove = []

for num in group:
    if '1' in str(num) or '7' in str(num):        
            to_remove.append(num)

for num in to_remove:
    try:
        group.remove(num)
    except ValueError:
        pass

print(group)
</code></pre>
<p>Edit: As Donkey Kong pointed out, it can also be done using pythons list comprehension and checking if 1 or 7 is in the number can be accomplished using the build-in any function. This way it it easy to check for more and other digits as well. The the code provided by Donkey Kong looks like this:
</p>
<pre><code>group = [x for x in range(1, 100) if not any(s in str(x) for s in ['1', '7'])]
print(group)
</code></pre>
<p>Edit 2: Using if instead of any in the list comprehension is faster. This was pointed out by juanpa.arrivillaga. Here is his the code for this:
</p>
<pre><code>group = [x for x in range(1,100) if not ('7' in str(x) or '3' in str(x))]
print(group)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>ValueError</code> shows the element you trying to remove in the list not exists in the list. And You have to use <code>try</code> and <code>execpt</code>. That's why it's shows <code>invalid syntax</code>.</p>
<pre><code>try:
    #Your action
except ValueError:
    pass
</code></pre>
<p>But your problem you can implement like this. Check the first 10 elements of filtered list. </p>
<pre><code>In [1]: num = range(1, 1001)
In [2]: filtered_num = [i for i in num if '1' not in str(i) and '7' not in str(i)]
In [3]: filtered_num[0:10]
Out[1]: [2, 3, 4, 5, 6, 8, 9, 20, 22, 23]
</code></pre>
</div>
<span class="comment-copy">When I run the code with directly removing elements, instead of using <code>to_remove</code>, every time a number is removed, the following number isn't checked. The filter method is a good alternative and I'll add it to my answer.</span>
<span class="comment-copy">This approach is faster: <code>[x for x in range(1,100) if not ('7' in str(x) or '3' in str(x))]</code></span>
