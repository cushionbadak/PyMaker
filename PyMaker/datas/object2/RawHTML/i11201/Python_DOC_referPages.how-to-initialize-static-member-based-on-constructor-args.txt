<div class="post-text" itemprop="text">
<p>I need to have static or external list, that will be used by every object of <code>A</code> class. The values of the list need to be initialized only once and should be taken from constructor parameters, e.g:</p>
<pre><code>def initialize(x, y):
    for i in range(0, x):
        static_to_return.append([])
        for j in range(0, y):
            static_to_return[i].append((i * x) + 1 + y)
    return static_to_return


class A:
    static_member = initialize(x, y)

    def __init__(self, x, y):
        self.x = x
        self.y = y
</code></pre>
<p>How to make this work? Maybe it is better to move the <code>static_member</code> to another module? Or is it possible to write to <code>static_member</code> in <code>__init__</code> function?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the static member to be initialized from the <strong>first</strong> object of the class, you could initialize it to <code>None</code> in class definition, and test its value in instance constructor:</p>
<pre><code>class A:
    static_member = None

    def __init__(self, x, y):
        self.x = x
        self.y = y
        if A.static_member is None:  # still not initialized?
            A.static_member = initialize(x, y)  # ok, here it is
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like you actually want to provide <code>x</code> and <code>y</code> when the <em>class</em> is created, not when an <em>instance</em> is created. If all instances will share the same values, you do not need to provide them as parameters to <code>__init__</code>.</p>
<p>Depending on how complex your class is you may need to use <a href="https://stackoverflow.com/q/100003/3001761">a metaclass</a> for this, but with such a simple example you can just use <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer"><code>type</code></a>:</p>
<pre><code>x = 1
y = 2
A = type('A', (object,), dict(x=x, y=y, static_member=initialize(x, y)))  # *
</code></pre>
<p>This creates the class you want and all of the instances share the state you're expecting:</p>
<pre><code>&gt;&gt;&gt; a = A()
&gt;&gt;&gt; b = A()
&gt;&gt;&gt; a.static_member
[[3, 3]]
&gt;&gt;&gt; b.static_member
[[3, 3]]
&gt;&gt;&gt; a.static_member.append(['foo', 'bar'])
&gt;&gt;&gt; a.static_member
[[3, 3], ['foo', 'bar']]
&gt;&gt;&gt; b.static_member
[[3, 3], ['foo', 'bar']]
&gt;&gt;&gt; A.static_member
[[3, 3], ['foo', 'bar']]
</code></pre>
<hr/>
<p><em>* Note that I needed to add the line <code>static_to_return = []</code> to <code>initialize</code> to get this to run.</em></p>
</div>
<span class="comment-copy">It's not clear what you're expecting to happen. Should this be a static member (actually: class attribute) or initialised from the constructor parameters, which are provided for every instance? What happens when you create a second instance of <code>A</code>? Would a class factory (<code>A = build_A_with(x, y)</code>) be a better approach? Where (and when) do <code>x</code> and <code>y</code> even come from?</span>
<span class="comment-copy">There will be a lot of <code>A</code> class objects and every one of them will have the same <code>x</code> and <code>y</code> values. What I need is to initialize this attribute with first instantiation of <code>A</code> class, based on the constructor parameters.</span>
<span class="comment-copy">If they all have the same <code>x</code> and <code>y</code>, why are they <code>__init__</code> parameters? Those are used to set things that are different for every instance. Where will the values come from, exactly? Could you give some more context, this seems likely to be an <a href="http://meta.stackexchange.com/q/66377/248731">XY (hah!) problem</a>.</span>
