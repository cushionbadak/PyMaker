<div class="post-text" itemprop="text">
<p><p>Hi there,
I found this really helpful topic on <a href="https://stackoverflow.com/questions/16974047/efficient-way-to-find-missing-elements-in-an-integer-sequence">finding missing elements in a list of integers</a>.
<br/>I found the second answer most useful and am applying it now to my code:</p>
<pre><code>def missing_elements(X):
    start, end = X[0], X[-1]
    return sorted(set(range(start, end + 1)).difference(X))
</code></pre>
<p>Now, the problem is that I do not have a list, but a series of list of which this is a snapshot:</p>
<pre><code>[716, 717, 718, 719, 720, 721]
[761, 762, 763, 764, 765, 766, 767, 768]
[988, 989, 990, 993, 994]
</code></pre>
<p><p>I would like to see as a result something like:</p>
<pre><code>[0]
[0]
[991, 992]
</code></pre>
<p><p>Obviously, the above code is not working. But I have no idea of how to get it working. I get the impression that I might want to make this into a set and do something with <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">set type features</a>, but that's only a guess...</p>
</p></p></p></div>
<div class="post-text" itemprop="text">
<p>Just <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map</code></a> your existing function onto the series of lists:</p>
<pre><code>&gt; lsts = [[716, 717, 718, 719, 720, 721],
          [761, 762, 763, 764, 765, 766, 767, 768],
          [988, 989, 990, 993, 994]]
&gt; map(missing_elements, lsts)
[[], [], [991, 992]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First off, as a more pythonic way you can use following function in order to detect your missing items, then use a list comprehension to apply the function on your lists:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; def missing(iterable):
...     return chain.from_iterable(range(i+1, j) for i, j in zip(iterable, iterable[1:]) if j &gt; i + 1)
</code></pre>
<p>Demo :</p>
<pre><code>&gt;&gt;&gt; lst = [[716, 717, 718, 719, 720, 721],
... [761, 762, 763, 764, 765, 766, 767, 768],
... [988, 989, 990, 993, 994]]
... 
&gt;&gt;&gt; [list(missing(i)) for i in lst]
[[], [], [991, 992]]
&gt;&gt;&gt; 
</code></pre>
<p>Here is a benchmark with your suggested function, that shows this function is almost 2 time faster:</p>
<pre><code>~ $ python -m timeit --setup "from itertools import chain; iterable=range(100)" "chain.from_iterable(range(i+1, j) for i, j in zip(iterable, iterable[1:]) if j &gt; i + 1)"
100000 loops, best of 3: 3.68 usec per loop
~ $ python -m timeit --setup "iterable=range(100)" "start, end = iterable[0], iterable[-1]; sorted(set(range(start, end + 1)).difference(iterable))"
100000 loops, best of 3: 6.94 usec per loop
</code></pre>
</div>
<span class="comment-copy">The code above is working. See <a href="http://ideone.com/GhbqGv" rel="nofollow noreferrer">ideone.com/GhbqGv</a> Applying this function to a list of lists is easy: either use <code>for a in list_of_lists: print missing_elements(a)</code> or <code>map</code></span>
<span class="comment-copy">You just forget to add indentation for lines in function. It is work fine.</span>
