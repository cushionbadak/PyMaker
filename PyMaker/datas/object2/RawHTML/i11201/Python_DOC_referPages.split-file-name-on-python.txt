<div class="post-text" itemprop="text">
<p>I'm trying to split a filename use it by parts. <br/>
The file is always an apache binary (for example, httpd-2.2.31.tar.gz) and I only need the version (in this case 22) in that specific format.<br/>
I have done it and it works, but I believe there should be a better way</p>
<pre><code>binary_name = "httpd-2.2.31.tar.gz"
app, ver_tar = binary_name.split("-")
version = ver_tar.split(".")
print ("Version %s%s" % (version[0], version[1]))
</code></pre>
<p>Is it possible to do it in a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>if you want to do it in one line,may be it will help :</p>
<pre><code>binary_name = "httpd-2.2.31.tar.gz"
print binary_name.split("-")[1][:3].replace('.','')
</code></pre>
<p>will return 22</p>
</div>
<div class="post-text" itemprop="text">
<p>use <code>re</code></p>
<pre><code>(?&lt;=-)(\d+)\.(\d+)
</code></pre>
<p>See demo.</p>
<p><a href="https://regex101.com/r/oS7mT8/1" rel="nofollow">Regex101 demo</a></p>
<p>or</p>
<p><a href="http://pythex.org/?regex=%28%3F%3C%3D-%29%28%5Cd%2B%29%5C.%28%5Cd%2B%29&amp;test_string=httpd-2.2.31.tar.gz&amp;ignorecase=0&amp;multiline=0&amp;dotall=0&amp;verbose=0" rel="nofollow">Pythex demo</a></p>
<pre><code>import re
x= "httpd-2.2.31.tar.gz"
print re.findall(r"(?&lt;=-)(\d+)\.(\d+)", x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could make it a little easier by using <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regular expressions</a>. There's a nifty site called <a href="http://pythex.org/" rel="nofollow">Pythex</a> where you can experiment with these yourself. To fix your example:</p>
<pre><code>import re
r = re.compile(".*-(\d+\.\d+\.\d+).tar.gz")
print(r.match("httpd-2.2.21.tar.gz").groups()[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As far as a better way there is no such thing as long as your code solves the problem you set out to solve, and in this case it does. As far as performance goes there are probably faster ways to achieve the same thing but even with a list of thousands of string to parse the difference in speed would be minimal or indistinguishable. Therefore I assume you are instead asking for a different way to accomplish the same goal, so I have written a small function and several test segments. The function gives slightly more control.</p>
<pre><code>def get_version(file_name, accuracy=0, sep=None):
    '''
        :string file_name is the string you want to parse
        :int accuracy is the length of the output format 
            1 = 1 of 1.23.3
            2 = 1.2 of 1.23.3
            3 = 1.23 of 1.23.3
            0 = 1.23.3 or full length
        :string sep, is the string seperator you wish to use, 1.1, 1_1, 11 etc...
        '''

    if not sep:
        sep = ''
    data = file_name.split('.')
    str_ver = data[0:-2]
    ver = []
    for i in str_ver:
        if len(ver) &lt; accuracy or accuracy == 0:
            try:
                if len(i)&gt;1:
                    n = ''
                    for x in i:
                        try:
                            n+=str(int(x))
                        except:
                            pass
                else:
                    n = str(int(i))
                ver.append(n)
            except:
                pass
    return sep.join(ver)

print get_version("httpd-2.2.31.tar.gz", 1, '--')
print get_version("httpd-2.2.31.tar.gz", 2, '::')
print get_version("httpd-2.2.31.tar.gz", 3, '_')
print get_version("httpd-2.2.31.tar.gz", 2)#what you were asking for
print get_version("httpd-2.2.31.tar.gz")
</code></pre>
</div>
<span class="comment-copy">Just to add another option because it's a personal favourite: regex101.com is a great one as well.</span>
<span class="comment-copy">This looks like a great site as well.</span>
