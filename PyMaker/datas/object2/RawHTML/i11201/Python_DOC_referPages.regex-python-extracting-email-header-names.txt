<div class="post-text" itemprop="text">
<p>hi am looking for a way to extract header names (what is in bold) from this block of text (originaly from mbox file)
i tried this regex that worked on sublime text regex search but didnt work on python
^\w+-?(\w+)?-?(\w+)?:</p>
<pre><code>rgex = re.findall('^\w+-?(\w+)?-?(\w+)?:', mail);
</code></pre>
<p>THIS IS WHAT IS INSIDE mail</p>
<blockquote>
<p><strong>X-Apparently-To</strong>: test@yahoo.com; Thu, 09 Jun 2016 13:41:21 +0000
  <br/> <strong>Return-Path</strong>: 
  <br/> <strong>Received-SPF</strong>: pass (domain of yahoo.com designates 72.30.235.45 as permitted sender)
  <br/> <strong>Received</strong>: from 127.0.0.1  (EHLO n3-vm9.bullet.mail.bf1.yahoo.com) (72.30.235.45)   by mta1287.mail.ne1.yahoo.com with SMTPS; Thu, 09 Jun
  <br/> 2016 13:41:21 +0000
  <br/> <strong>DKIM-Signature</strong>: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo-inc.com; s=yibm; t=1465479679; 
  <br/> <strong>To</strong>: test@yahoo.com
  <br/> <strong>From</strong>: "Yahoo" 
  <br/> <strong>Reply-To</strong>: "Yahoo" 
  <br/> <strong>X-YMailISG</strong>: PCypxycWLDvGv4Bg8ShrtzVYi3vpFMAjYaqWyWybcVJ_ZQff  eyquyqb..Qu6UKhX_Tyz5b3da2iDtRStJpVnNulZHOb8GznJQTCKk9sjvboS 
  KsbzY4E1uScWz0Ieo0jjG0YHrB1dTCzOSeMiPNumCCFS1sR3_SkyMBGG_D2D 
  wWtdRducxLa2YgEMMubVpMtNJMBv.bwk0.E.jQNEy8I3LnJEqcDpmIUM7bZL 
  XgkEFz7yl1Zo6Sj4r0z6pGlVIFOql7uG9Bwq2VJoK1Q1upKJUOBfQqzf64y2 
  9fXLnQsWENpZloxwncGzLhdzEYGgE3xNuFV8QFxZGXyvtKZFoykH49M03URN 
  jtx8Yg6ypjyRbBIRVJGVFbjAvW6io3yeyIFh042jlgYQtLxbneFA60hn9ifT 
  Mit3bQ5l7Tginw0OgRM2cbqLo0tEZFt9vlN597Z3vPGwsVdBcTp9wnk6orj2 
  TqjEpAmODy3Yru2HzDP7Dbwq9CGaIozUm91VNWqw5Dy7AMQEsuvnBop7Fflk 
  G21m1WKMBgrS.2bOLQ4797E09LjlyyoWI9FouUNNhDljnPPf2AeKUKzauctw 
  ULOQPveWAm4lDsNLMp5yvXDYNIe5HMor84SVd8_xF3Icna1PAftXGzJUHrXK 
  NZSEN_VO0GprGfaNQg4uSW_0wXFXwC6TYQ4CMjz53o0qNGpILogVfRLwFCFL 
  DtW8nimkLLsNzmDajzJsR_juA86Orw2NE5ED4qdpPxmyxyrXYOQPu3O6zeYf 
  7mBzU0aX7VHJUxJ4L3HdB9qTjbTaCdnySrnjGtd7u9Cn9yRJirDNeg3UA82P 
  PeA1ZDfc0vKdrn5QI6e6YKa2TTt7Dspy3jObgSapH5epc3LyQVyN7yjpxrq_ 
  MXAbpqedjUfcwq3c7lpt8xxUxy.MXWg0fJO059xijvb_sYTaQTGUWAMeVU.6 
  IW.hSksejwpn._CgE9Kqabbk5qgYIdYRW1pmz5OBYh0skCX1TrFRuxbGvDit 
  R_wr.wbTpJGiSST.b0ZetmgN72bVvlRtmNPw1Dk.zxaacXxhGSMWupPUDLJZ 
  OMrap2ax8oiQrxT3jIhk8seIkaNJ.tGUhlPx6G4lJJaz0g89LmjBaEjGUG8P 
  W3Phh9db3hjxUIX5UC0jg5ai2XZ7u_wXn2Muk61N1eRCZ0oA2S25YDPK1dh. 
  3VQ6pH8SSBxVkQHUJXbZUNqLAzi5V5wRS7oeitXERGgA2DiZB268.rJxS7di 
  OMT5eGoITG4LnAo1M3nsVQ6xceHDd4v6KD9KfBgTHX_iLUv_skCv4dVUgVvj 
  edKOFiOMHBTpJ9J9BECjTTzEUpc.fCNUcRwSsiSkqbRhUsAdCbxQZir3Nb1Z 
  6FzI6J2eNqpj4azjmDeI15R8MyN7VFc6bl6pCZySk2Tx5SQESDm.sVkADSVR 
  pI2nuscEjU3xo_qGUxbh5mbAA17K2zYpcFXaOce8_9Eszos5pURCcdtBYUqI 
  I_DOtvNe.zWY1ShRcr9ZzTj3ibmc7NBmvumhVMjqirb12mfJ6oxHv8d86gze 
  HtAJmJghczUg5otSzdxSgEJJxjMZrzSidJ9FP.gPiPWtuukz82YpZ32MnCVs
   6.V2DRxpUmZa31KH93QSEzwMlCn3FFTLBv9izcjoFP81yeAn.3QloF8XIC3K  WmtXtloyeGjuygAhlkd_prXmMGGC5JmPlY8xu4k1NavkdDh6pG6zIkt83Wsd  p.D.0BgM
  <br/> <strong>X-Originating-IP</strong>: [75.30.245.45]
  <br/> <strong>Authentication-Results</strong>: mta1287.mail.ne1.yahoo.com  from=yahoo-inc.com; domainkeys=neutral (no sig);  from=yahoo-inc.com;
  dkim=pass (ok)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>A simpler approach than devising an appropriate regex might be to use a more appropriate tool that comes with python ... the <a href="https://docs.python.org/3/library/email.parser.html" rel="nofollow"><code>email.parser</code></a> module, which is designed to parse rcf822 messages such as this.</p>
<pre><code>&gt;&gt;&gt; from email import parser
&gt;&gt;&gt; txt = """X-Apparently-To: test@yahoo.com; Thu, 09 Jun 2016 13:41:21 +0000 
... Return-Path: 
... Received-SPF: pass (domain of yahoo.com designates 72.30.235.45 as permitted sender) 
... Received: from 127.0.0.1 (EHLO n3-vm9.bullet.mail.bf1.yahoo.com) (72.30.235.45) by mta1287.mail.ne1.yahoo.com with SMTPS; Thu, 09 Jun 2016 13:41:21 +0000
... DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo-inc.com; s=yibm; t=1465479679; 
... To: test@yahoo.com 
... From: "Yahoo" 
... Reply-To: "Yahoo"
... X-YMailISG: PCypxy...
... X-Originating-IP: [75.30.245.45] 
... Authentication-Results: mta1287.mail.ne1.yahoo.com from=yahoo-inc.com; domainkeys=neutral (no sig); from=yahoo-inc.com; dkim=pass (ok)
... """
&gt;&gt;&gt; msg = parser.Parser().parsestr(txt, headersonly=True)
&gt;&gt;&gt; print(msg.keys())
['X-Apparently-To', 'Return-Path', 'Received-SPF', 'Received', 'DKIM-Signature', 'To', 'From', 'Reply-To' 'X-YMailISG', 'X-Originating-IP', 'Authentication-Results']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're running a regex over the entire mbox file then a regex will not work - you're going to have to write a program.  The reason is that the body of the message has the potential to have tokens that will match exactly what a header token will look like.</p>
<p>Assuming that you're ONLY running the regex over the header portion of the mbox file(s) then, looking at the <a href="https://tools.ietf.org/html/rfc2822#page-7" rel="nofollow">email RFC</a> (section 2.2.) then the following regex should work:</p>
<blockquote>
<p>'^([^:]+):'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Python provides the email package that can do those low-level tasks for you, but if you want to learn email headers the hard way, the reference is the <a href="https://tools.ietf.org/html/rfc5322" rel="nofollow">RFC5322</a> (formely RFC822)</p>
<p>Among other sensible information, you find the definition of header fields:</p>
<blockquote>
<p>Header fields are lines beginning with a field name, followed by a
     colon (":"), followed by a field body, and terminated by CRLF.  A
     field name MUST be composed of printable US-ASCII characters (i.e.,
     characters that have values between 33 and 126, inclusive), except
     colon.  A field body may be composed of printable US-ASCII characters
     as well as the space (SP, ASCII value 32) and horizontal tab (HTAB,
     ASCII value 9) characters (together known as the white space
     characters, WSP).  A field body MUST NOT include CR and LF except
     when used in "folding" and "unfolding"</p>
</blockquote>
<p>Folding is later defined by:</p>
<blockquote>
<p>the field body portion of a header field can be split into a
     multiple-line representation; this is called "folding".  The general
     rule is that wherever this specification allows for folding white
     space (not simply WSP characters), a CRLF may be inserted before any
     WSP.</p>
</blockquote>
<p>That means that:</p>
<ul>
<li>when a line does not start with a WSP (<code>\s</code> in a regex) the start of line up to a column is the header name.</li>
<li>when a line starts with a WSP, it is a continuation line.</li>
</ul>
<p>So this regex should be enough: <code>'([\x21-\x7e]+?):'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>'^\w+-?(\w+)?-?(\w+)?:'</code> regex matches the beginning of a string (<code>^</code>), then 1+ word chars, followed by an optional <code>-</code>, then 1+ word chars are captured into an optional Group 1 (and those are returned by <code>re.findall</code> as the first item in each tuple returned as a list), followed with an optional hyphen, again a capture group matching 1+ word chars (optional, but still returned as the 2nd item in the tuple), and a <code>:</code> at the end. It would not work because of <code>^</code>, optional <code>-</code> between <code>\w</code> and 2 capture groups.</p>
<p><strong>If the input you get complies with the rfc 8222 message style, you should consider switching to a <code>from email import parser</code> solution given above.</strong></p>
<p>Alternatively, it seems to me you can just capture all characters other than whitespace and a colon up to a colon that is followed with whitespace <em>at the beginning of a line</em>:</p>
<pre><code>r"^([^\s:]+):\s"
</code></pre>
<p>And use it with <code>re.findall</code> and <code>re.M</code> flag.</p>
<p><strong>Regex explanation</strong>:</p>
<ul>
<li><code>^</code> - start of line (as <code>re.M</code> makes <code>^</code> match the position after a newline) or start of string)</li>
<li><code>([^\s:]+)</code> - Capture group 1 matching 1+ characters other than whitespace and a colon</li>
<li><code>:</code> - a colon</li>
<li><code>\s</code> - a whitespace character.</li>
</ul>
<p>See the <a href="https://regex101.com/r/dT2sE5/1" rel="nofollow">regex demo</a></p>
<p><a href="https://ideone.com/ni3MkV" rel="nofollow">Python demo</a> where <code>re.findall</code> returns only the <em>captured</em> texts:</p>
<pre><code>import re
p = re.compile(r'^([^\s:]+):\s', re.MULTILINE)
test_str = "X-Apparently-To: test@yahoo.com; Thu, 09 Jun 2016 13:41:21 +0000 \nReturn-Path: \nReceived-SPF: pass (domain of yahoo.com designates 72.30.235.45 as permitted sender) \nReceived: from 127.0.0.1 (EHLO n3-vm9.bullet.mail.bf1.yahoo.com) (72.30.235.45) by mta1287.mail.ne1.yahoo.com with SMTPS; Thu, 09 Jun \n2016 13:41:21 +0000 \nDKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo-inc.com; s=yibm; t=1465479679; \nTo: test@yahoo.com \nFrom: \"Yahoo\" \nReply-To: \"Yahoo\" \nX-YMailISG: PCypxycWLDvGv4Bg8ShrtzVYi3vpFMAjYaqWyWybcVJ_ZQff eyquyqb..Qu6UKhX_Tyz5b3da2iDtRStJpVnNulZHOb8GznJQTCKk9sjvboS KsbzY4E1uScWz0Ieo0jjG0YHrB1dTCzOSeMiPNumCCFS1sR3_SkyMBGG_D2D wWtdRducxLa2YgEMMubVpMtNJMBv.bwk0.E.jQNEy8I3LnJEqcDpmIUM7bZL XgkEFz7yl1Zo6Sj4r0z6pGlVIFOql7uG9Bwq2VJoK1Q1upKJUOBfQqzf64y2 9fXLnQsWENpZloxwncGzLhdzEYGgE3xNuFV8QFxZGXyvtKZFoykH49M03URN jtx8Yg6ypjyRbBIRVJGVFbjAvW6io3yeyIFh042jlgYQtLxbneFA60hn9ifT Mit3bQ5l7Tginw0OgRM2cbqLo0tEZFt9vlN597Z3vPGwsVdBcTp9wnk6orj2 TqjEpAmODy3Yru2HzDP7Dbwq9CGaIozUm91VNWqw5Dy7AMQEsuvnBop7Fflk G21m1WKMBgrS.2bOLQ4797E09LjlyyoWI9FouUNNhDljnPPf2AeKUKzauctw ULOQPveWAm4lDsNLMp5yvXDYNIe5HMor84SVd8_xF3Icna1PAftXGzJUHrXK NZSEN_VO0GprGfaNQg4uSW_0wXFXwC6TYQ4CMjz53o0qNGpILogVfRLwFCFL DtW8nimkLLsNzmDajzJsR_juA86Orw2NE5ED4qdpPxmyxyrXYOQPu3O6zeYf 7mBzU0aX7VHJUxJ4L3HdB9qTjbTaCdnySrnjGtd7u9Cn9yRJirDNeg3UA82P PeA1ZDfc0vKdrn5QI6e6YKa2TTt7Dspy3jObgSapH5epc3LyQVyN7yjpxrq_ MXAbpqedjUfcwq3c7lpt8xxUxy.MXWg0fJO059xijvb_sYTaQTGUWAMeVU.6 IW.hSksejwpn._CgE9Kqabbk5qgYIdYRW1pmz5OBYh0skCX1TrFRuxbGvDit R_wr.wbTpJGiSST.b0ZetmgN72bVvlRtmNPw1Dk.zxaacXxhGSMWupPUDLJZ OMrap2ax8oiQrxT3jIhk8seIkaNJ.tGUhlPx6G4lJJaz0g89LmjBaEjGUG8P W3Phh9db3hjxUIX5UC0jg5ai2XZ7u_wXn2Muk61N1eRCZ0oA2S25YDPK1dh. 3VQ6pH8SSBxVkQHUJXbZUNqLAzi5V5wRS7oeitXERGgA2DiZB268.rJxS7di OMT5eGoITG4LnAo1M3nsVQ6xceHDd4v6KD9KfBgTHX_iLUv_skCv4dVUgVvj edKOFiOMHBTpJ9J9BECjTTzEUpc.fCNUcRwSsiSkqbRhUsAdCbxQZir3Nb1Z 6FzI6J2eNqpj4azjmDeI15R8MyN7VFc6bl6pCZySk2Tx5SQESDm.sVkADSVR pI2nuscEjU3xo_qGUxbh5mbAA17K2zYpcFXaOce8_9Eszos5pURCcdtBYUqI I_DOtvNe.zWY1ShRcr9ZzTj3ibmc7NBmvumhVMjqirb12mfJ6oxHv8d86gze HtAJmJghczUg5otSzdxSgEJJxjMZrzSidJ9FP.gPiPWtuukz82YpZ32MnCVs 6.V2DRxpUmZa31KH93QSEzwMlCn3FFTLBv9izcjoFP81yeAn.3QloF8XIC3K WmtXtloyeGjuygAhlkd_prXmMGGC5JmPlY8xu4k1NavkdDh6pG6zIkt83Wsd p.D.0BgM \nX-Originating-IP: [75.30.245.45] \nAuthentication-Results: mta1287.mail.ne1.yahoo.com from=yahoo-inc.com; domainkeys=neutral (no sig); from=yahoo-inc.com; dkim=pass (ok)"
print(p.findall(test_str))
</code></pre>
<p><strong>UPDATE</strong></p>
<p>Now, since you requested to get values only, you can use the same approach, but just strip the keys when found and add the values to the resulting list:</p>
<pre><code>txt = "YOUR_STRING_HERE"
values = []                    # Resulting value list
start_matching = False         # Bool flag to start matching the key-value pairs
val = ""                       # Temp string to keep multiline values
for line in txt.split("\n"):   #  Split the input into lines
    if re.match(r"[^\s:]+:\s", line.strip()): # Check if the entry is found
        start_matching = True   # Start matching
        if val:                 # If a val is initialized, 
            values.append(val)  #    we save it to our list
            val = ""            # Reset the temp string value
        val += re.sub(r"^[^\s:]+:\s", "", line.strip()) # Append the value string start
    else:
        if start_matching:      # If matching has started,
            val += "{}\n".format(line.strip()) # add the line to the value found
print(values)
</code></pre>
<p>See the <a href="https://ideone.com/o4KtM7" rel="nofollow">IDEONE demo</a></p>
</div>
<span class="comment-copy">Well... Try something like <a href="https://regex101.com/r/wY3qH2/1" rel="nofollow noreferrer"><code>(?![^\s:]*\d+:\d+)([^\s:]+):</code></a>.</span>
<span class="comment-copy">Is there a reason not to just use the <code>email</code> package to parse the headers (and thus get header names) ?</span>
<span class="comment-copy">donkopotamus- yes in my case it has to be from a certain file</span>
<span class="comment-copy">Wiktor Stribiżew- thanks that will do :)</span>
<span class="comment-copy">@user1731805 You can just read the file and pass the text to an <code>email.Parser</code> (which will read rfc822 style messages)</span>
<span class="comment-copy">@WiktorStribiżew because I couldn't be bothered polluting the answer with the next three very large headers ...</span>
<span class="comment-copy">:) You could truncate them at least, that baffled me a bit.</span>
<span class="comment-copy">@WiktorStribiżew That's a better idea :-)</span>
<span class="comment-copy">@donkopotamus i keep getting empty list with this <a href="http://pastebin.com/8H0kHv00" rel="nofollow noreferrer">pastebin.com/8H0kHv00</a></span>
<span class="comment-copy">@user1731805 That's because the first three lines in this pastebin are <b>not part of the email message</b> ...  if you strip those it parses just fine.  (the first two lines are part of the mbox format, not sure about the other extra line)</span>
