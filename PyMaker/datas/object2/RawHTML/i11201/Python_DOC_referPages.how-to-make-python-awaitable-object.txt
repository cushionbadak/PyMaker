<div class="post-text" itemprop="text">
<p>In <strong>python 3.5.1</strong> one can make use of await/async, however, to use it (as I undestand), you need to have <em>awaitable object</em>.
An awaitable object is an object that defines <code>__await__()</code> method returning an iterator. More info <a href="https://www.python.org/dev/peps/pep-0492/#await-expression" rel="noreferrer">here</a>.
But I can not google out any example of having this, since most examples have some sort of asyncio.sleep(x) to mimic awaitable object.</p>
<p>My ultimate goal is to make simple websocket serial server, however, I can't pass this first step.
This is my (non working code).</p>
<pre><code>import serial
import asyncio

connected = False
port = 'COM9'
#port = '/dev/ttyAMA0'
baud = 57600
timeout=1

class startser(object):

    def __init__(self, port, baud):
        self.port = port
        self.baud = baud       

    def openconn(self):       
        self.ser = serial.Serial(port, baud)

    async def readport(self):
        #gooo= await (self.ser.in_waiting &gt; 0)
        read_byte = async self.ser.read(1).decode('ascii')        
        self.handle_data(read_byte)
        print ("42")  

    def handle_data(self, data):
        print(data)

serr=startser(port,baud)
serr.openconn()

loop = asyncio.get_event_loop()
#loop.run_forever(serr.readport())
loop.run_until_complete(serr.readport())
loop.close()

print ("finitto")

#with serial.Serial('COM9', 115200, timeout=1) as ser:
    #x = ser.read()          # read one byte
    #s = ser.read(10)        # read up to ten bytes (timeout)
    #line = ser.readline()   # read a '\n' terminated line`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess there is still no answer because the question is not pretty clear.
You correctly said that </p>
<blockquote>
<p>An awaitable object is an object that defines <code>__await__()</code> method returning an iterator</p>
</blockquote>
<p>Not much to add here. Just return an iterator from that method.</p>
<p>The only thing you need to understand is how does it work. I mean, how asyncio or another similar framework achieves concurrency in a single thread. This is simple on a high level: just get all your code organized as iterators, then call them one-by-one until the values are exhausted.</p>
<p>So, for example, if you have two iterators, let's say first one yields letters and the second one yields numbers, event loop calls first one and gets <code>'A'</code>, then it calls the second one and gets <code>1</code> then it calls first one again and gets <code>'B'</code> and so on and so on, until the iterators are completed. Of course, each of these iterators can do whatever you want before yielding the next value. But, the longer it takes - the longer pause between 'switching tasks' would be. You <strong>MUST</strong> keep every iteration short:</p>
<ol>
<li>If you have inner loops, use <code>async for</code> - this will allow switching task without explicit yielding.</li>
<li>If you have a lot of code which executes for tens or even hundreds of milliseconds, consider rewriting it in smaller pieces. In a case of legacy code, you can use hacks like <code>asyncio.sleep(0)</code> ← this is an allowance for asyncio to switch task here.</li>
<li>No blocking operations! This is most important. Consider you do something like <code>socket.recv()</code>. All tasks will be stopped until this call ends. This is why this is called <code>async io</code> in the standard library: you must use theirs implementation of all I/O functions like <code>BaseEventLoop.sock_recv()</code>.</li>
</ol>
<p>I'd recommend you to start (if you didn't yet) with the following docs:</p>
<ul>
<li><a href="https://pymotw.com/3/asyncio/" rel="nofollow noreferrer">https://pymotw.com/3/asyncio/</a></li>
<li><a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio.html</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0492" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-0492</a></li>
</ul>
</div>
<span class="comment-copy"><code>serial.Serial()</code> is not an awaitable object. Ultimately, you need to create awaitable I/O primitives that know how to defer execution until data is available. This is not for the faint of heart. I don't think there is a serial port awaitable yet.</span>
<span class="comment-copy">@MartijnPieters I think the principle with serial is the same as if we were dealing with some long lasting math algorithm. The thing that I don't know is how to create awaitable object itself (as described in docs link given). Because, although serial is not awaitable, it could "possibly" be wrapped. I admit that I don't know python that well, but I will try, an I was hoping at least this first step (of creating awaitable object) to be a bit more explained here.</span>
<span class="comment-copy">Since, it hasn't been suggested yet, you should look at: <a href="https://docs.python.org/3.5/library/collections.abc.html#collections.abc.Awaitable" rel="nofollow noreferrer">docs.python.org/3.5/library/…</a>.  I am not entirely certain what you are trying to achieve, but subclassing the Awaitable abstract class from the docs would allow you to create a custom "awaitable" object.</span>
