<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6269765/what-does-the-b-character-do-in-front-of-a-string-literal">What does the 'b' character do in front of a string literal?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I read line from a file like:</p>
<blockquote>
<p>The Little Big Things: 163 Wege zur Spitzenleistung (Dein Leben) (German Edition) (Peters, Tom)</p>
<p>Die virtuelle Katastrophe: So führen Sie Teams über Distanz zur
  Spitzenleistung (German Edition) (Thomas, Gary)</p>
</blockquote>
<p>I read / encode them with:</p>
<pre><code>title = line.encode('utf8')
</code></pre>
<p>but the output is:</p>
<blockquote>
<p>b'Die virtuelle Katastrophe: So f\xc3\xbchren Sie Teams \xc3\xbcber
  Distanz zur Spitzenleistung (German Edition) (Thomas, Gary)' </p>
<p>b'The Little Big Things: 163 Wege zur Spitzenleistung (Dein Leben)
  (German Edition) (Peters, Tom)'</p>
</blockquote>
<p>Why is the "b'" always added?
How do I properly read the files so that the "Umlauts" are preserved?</p>
<p>Here is the complete relevant code snippet:</p>
<pre><code># Parse the clippings.txt file
lines = [line.strip() for line in codecs.open(config['CLIPPINGS_FILE'], 'r', 'utf-8-sig')]
for line in lines:
    line_count = line_count + 1
    if (line_count == 1 or is_title == 1):
        # ASSERT: this is a title line
        #title = line.encode('ascii', 'ignore')
        title = line.encode('utf8')
        prev_title = 1
        is_title = 0
        note_type_result = note_type = l = l_result = location = ""
        continue
</code></pre>
<p>thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The method <code>str.encode</code> turns a unicode string into a <code>bytes</code> object:</p>
<blockquote>
<p><strong><code>str.encode(encoding="utf-8", errors="strict")</code></strong><br/>
  Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Error Handlers. For a list of possible encodings, see section Standard Encodings.</p>
</blockquote>
<p>So what you get is exactly what is expected.</p>
<p>On most machines, you can just <code>open</code> the files and read. If the file encoding is not the system default, you can pass it as keyword argument:</p>
<pre><code>with open(filename, encoding='utf8') as f:
    line = f.readline()
</code></pre>
</div>
<span class="comment-copy"><code>b''</code>means that you got a byte buffer, not an (unicode) string as is to be expected from <code>encode()</code>, which turns a string into an encoded byte sequence. In your case, you need to <code>decode()</code> <i>from</i> utf-8, not encode <i>to</i> utf-8. Or even better, use <a href="https://docs.python.org/3/library/codecs.html#codecs.open" rel="nofollow noreferrer"><code>codecs.open(..., encoding='utf-8')</code></a>. For a proper answer I'd like to see more of your code, though.</span>
<span class="comment-copy">@dhke It might be enough just to remove that <code>.encode</code> line, because the output looks like correct UTF-8, meaning <code>line</code> was already a valid Unicode string.</span>
<span class="comment-copy">@f0rd42 I see. And looking at the snippet, you should be able to simply drop the encode part altogether. At this point, <code>line</code> is already a (decoded) Python string. <code>'\xc3\xb'</code> is also correct <i>utf-8</i> for German <code>ü</code>. What did make you think, the umlauts are not read correctly? Do they display incorrectly on output?</span>
<span class="comment-copy">@melpomene <code>AttributeError: 'str' object has no attribute 'decode'</code> ;-). It's Python 3 and the Python 3 string doesn't have a <code>decode()</code>, because it's already decoded.</span>
<span class="comment-copy">just doing a "title = line" does anything I need. I looked the code as a basis for my needs. Thanks to you both</span>
