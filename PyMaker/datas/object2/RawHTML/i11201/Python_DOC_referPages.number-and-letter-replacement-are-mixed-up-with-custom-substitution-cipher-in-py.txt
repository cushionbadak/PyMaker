<div class="post-text" itemprop="text">
<p>This part of the code transfers the letters to numbers and then multiply it by the key (datetime*ip (replaced(.,5)</p>
<pre><code>import datetime
import time 
import socket
while (True):
IP=int(socket.gethostbyname(socket.gethostname()).replace(".","5"))
time=(int(datetime.datetime.now().strftime("%Y%m%d%H%M%S")))
qw=(int(str((time)+(IP))))
a=int("934")*1
b=int("346")*1
c=int("926")*1
d=int("9522")*1
e=int("7334")*1
f=int("5853")*1
g=int("2432")*1
h=int("2027")*1
i=int("7024")*1
j=int("828")*1
k=int("798")*1
m=int("593")*1
n=int("662")*1
l=int("5950")*1
o=int("357")*1
p=int("506")*1
q=int("239")*1
r=int("99")*1
s=int("372")*1
t=int("636")*1
u=int("553")*1
v=int("255")*1
w=int("298")*1
x=int("8822")*1
y=int("458")*1
z=int("659")*1
space=("633")
msg=input("")
msg=msg.replace("a",(str(a)))
msg=msg.replace("b",(str(b)))
msg=msg.replace("c",(str(c)))
msg=msg.replace("d",(str(d)))
msg=msg.replace("e",(str(e)))
msg=msg.replace("f",(str(f)))
msg=msg.replace("g",(str(g)))
msg=msg.replace("h",(str(h)))
msg=msg.replace("i",(str(i)))
msg=msg.replace("j",(str(j)))
msg=msg.replace("k",(str(k)))
msg=msg.replace("m",(str(m)))
msg=msg.replace("n",(str(n)))
msg=msg.replace("l",(str(l)))
msg=msg.replace("o",(str(o)))
msg=msg.replace("p",(str(p)))
msg=msg.replace("q",(str(q)))
msg=msg.replace("r",(str(r)))
msg=msg.replace("s",(str(s)))
msg=msg.replace("t",(str(t)))
msg=msg.replace("u",(str(u)))
msg=msg.replace("v",(str(v)))
msg=msg.replace("w",(str(w)))
msg=msg.replace("x",(str(x)))
msg=msg.replace("y",(str(y)))
msg=msg.replace("z",(str(z)))
msg=msg.replace(" ",(str(space)))
msg=int(msg)
msg=int(msg)*(qw)
fileb=open("key.txt","w")
filec=fileb.write(str(qw))
fileb.close()
file=open("msg decrypt.txt","w")
filea=file.write(str(msg))
file.close()
print (msg)
</code></pre>
<p>decryption code this is where the problem is when replacing the number back to letters</p>
<pre><code>file=open("msg decrypt.txt","r")
encrypted_msg=int(file.read())
print(encrypted_msg)
file.close()
fileb=open("key.txt","r")
key=int(fileb.read())
fileb.close()
encrypted_msg=(int(encrypted_msg)-(key))
encrypted_msg=(int(encrypted_msg)/(key))
encrypted_msg=(int(encrypted_msg)+1)
print(encrypted_msg)
a=("934")
b=("346")
c=("926")
d=("9522")
e=("7334")
f=("5853")
g=("2432")
h=("2027")
i=("7024")
j=("828")
k=("798")
m=("593")
n=("662")
l=("5950")
o=("357")
p=("506")
q=("239")
r=("99")
s=("372")
t=("63")
u=("55")
v=("255")
w=("298")
x=("8822")
y=("458")
z=("659")
space=("633")
ab=str(encrypted_msg)
if (a) in ab:
    ab=ab.replace(str(a),"a")
if ("346") in ab:    
    ab=ab.replace(str(b),"b")    
if ("926") in ab:    
    ab=ab.replace(str(c),"c")
if ("9522") in ab:
    ab=ab.replace(str(d),"d")
if ("7334") in ab:
    ab=ab.replace(str(e),"e")
if ("5853") in ab:
    ab=ab.replace(str(f),"f")
if ("2432") in ab:    
    ab=ab.replace(str(g),"g")
if ("2027") in ab:
    ab=ab.replace(str(h),"h")
if ("7024") in ab:
    ab=ab.replace(str(i),"i")
if ("828") in ab:
    ab=ab.replace(str(j),"j")
if ("798") in ab:
    ab=ab.replace(str(k),"k")
if ("593") in ab:
    ab=ab.replace(str(m),"m")
if ("662") in ab:
    ab=ab.replace(str(n),"n")
if ("5950") in ab:
    ab=ab.replace(str(l),"l")
if ("357") in ab:
    ab=ab.replace(str(o),"o")
if ("506") in ab:
    ab=ab.replace(str(p),"p")
if ("239") in ab:
    ab=ab.replace(str(q),"q")
if ("99") in ab:
    ab=ab.replace(str(r),"r")
if ("372") in ab:
    ab=ab.replace(str(s),"s")
if ("636") in ab:
    ab=ab.replace(str(t),"t")
if ("553") in ab:    
    ab=ab.replace(str(u),"u")
if ("255") in ab:
    ab=ab.replace(str(v),"v")
if ("298") in ab:
    ab=ab.replace(str(w),"w")
if ("8822") in ab:
    ab=ab.replace(str(x),"x")
if ("458")in ab:
    ab=ab.replace(str(y),"y")
if ("659") in ab:
    ab=ab.replace(str(z),"z")
if ("633") in ab:
    ab=ab.replace(str(space)," ")          
print(ab)
</code></pre>
<p>The program encrypts just fine. However, it only decrypts 4 letters anything more it comes out as jumbled letters and numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your "decryption" cannot work, because not every character has its own slot. Let's say the key is <code>1</code> and an example ciphertext is <code>7334662</code> which "clearly" represents <code>en</code>. Since your decryption starts replacing <code>346</code> to <code>b</code>, the ciphertext will result in <code>73b62</code> and then terminate, because there isn't anything to replace anymore. </p>
<p>There are many fixes to this:</p>
<ul>
<li><p>You could remove the use of <code>replace</code> and instead iterate over the ciphertext and try to find a prefix that corresponds to one of the possible mappings. Although, this will quickly break when you actually introduce the key through simple multiplication, because then it is possible that multiple mappings have the same prefix.</p></li>
<li><p>Add delimiters such as <code>,</code>, which enables you to split the ciphertext at <code>,</code> and iterate over all the ciphertext "characters" to apply the mapping to plaintext separately. So, the above example would look like <code>7334,662</code></p></li>
</ul>
</div>
<span class="comment-copy">Can you give an example when it doesn't work?</span>
<span class="comment-copy">the program encrypts just fine however it only decrypts 4 letters anything more it comes out as jumbled letters and numbers</span>
<span class="comment-copy">ok, I have managed to add delimiters however once in cipher text how do I individually divide each number without delimiters ?</span>
<span class="comment-copy">I suggest that you <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">split</a> the ciphertext into the individual "characters" and then iterate over them to transform each of them separately.</span>
