<div class="post-text" itemprop="text">
<p>I'm in the process of trying to engineer a data structure for a game engine, and allow a scripting language to grab data from it. Due to some limitations of design, the data would need to be stored on the C++ side of the program in a database like structure. Main reason being that I'm not sure if Python's serialization base can compensate for modders suddenly adding and removing data fields.</p>
<p>I am wondering if is possible to call a python script, and have it act as it's own object with it's own data? If not, can you instantiate a python class from C++ without knowing the class's name until runtime?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are describing is called <em>embedding the Python interpreter</em>.  CPython is suitable for this kind of embedding, and provides <a href="https://docs.python.org/3/extending/index.html" rel="nofollow">a nice tutorial</a> on some of the higher-level points (though it is primarily focused on extending rather than embedding, most of the concepts are relevant to both areas).</p>
<p>There are a number of drawbacks to this approach, however.  In particular, CPython is quite slow compared to C++.  You should assume that executing arbitrary Python bytecode will block for an unreasonable amount of time unless you have profiled it and know you can get away with it.  Worse, each Python interpreter (you <a href="https://docs.python.org/3/c-api/init.html#sub-interpreter-support" rel="nofollow">can have more than one</a> in a process, with some caveats) has a global interpreter lock (GIL), and you generally cannot interact with a Python interpreter unless you hold its GIL.  In other words, only one thread is allowed to call into a given Python interpreter at a time, which makes it harder to manage the execution speed of Python with threads.  It also means you will gain <em>no speed bonus by giving Python extra threads</em>, even if the Python code is <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="nofollow">embarrassingly parallel</a>.  The only major exception is I/O-bound operation, which Python can usually do without holding the GIL.</p>
<p>Another difficulty is that Python objects are all of type <code>PyObject*</code>.  These are (pointers to) reference counted objects with a number of interesting properties, but the point is that you can't just give raw memory directly to a Python script and expect it to work.  You will at a minimum have to wrap it in an <a href="https://docs.python.org/3/library/array.html" rel="nofollow"><code>array</code></a> or some other suitable Python object.  If you want the underlying memory to still "belong" to your application, you may want to use the <a href="https://docs.python.org/3/c-api/buffer.html#bufferobjects" rel="nofollow">buffer protocol</a> to expose this memory in a standard fashion that <code>array</code> and friends can work with (so that you don't end up copying memory unnecessarily).</p>
<p>At a high level, I would recommend having one or several dedicated Python worker threads (one per interpreter, and try not to spin up too many interpreters since they are heavy objects), and asynchronously passing work objects between these threads and the rest of your application.  The worker threads are responsible for converting between C++ objects and Python objects, holding the GIL(s), and running slow Python code.  You should also bear in mind that Python will consume the same computational resources (CPU, memory, perhaps disk I/O) the rest of your application is using.  Threading may help you make use of multiple cores, but it won't buy you more CPU than you actually have to play with.  You may simply find that Python is too slow for your application, depending on how responsive you need your scripting system to be and how much the rest of your game engine can tolerate the performance pressure of an extra CPU-bound thread.  You should start by building a small prototype and verifying that it has acceptable performance characteristics before you try to build the real thing, or if you already have a complete game engine, try bolting a minimal Python interpreter onto it and run some benchmarks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I never worked with python. But I think this is one of the main features of any programming/script languages: Call a function multiple times with it's own instances as many times as you need.</p>
</div>
<span class="comment-copy">"I am wondering if is possible to call a python script, and have it act as it's own object with it's own data?" - Do you need the script to be in the same process as the rest of your program?  If not, this is trivial; just launch a whole Python process.  Otherwise, you're in the hairy business of <a href="https://docs.python.org/3/extending/index.html#embedding-the-cpython-runtime-in-a-larger-application" rel="nofollow noreferrer">embedding the Python interpreter</a>; the answers to your questions are "yes, but it's annoying" and "easily."</span>
<span class="comment-copy">What do you mean data? Is it loaded runtime or just hard coded? I mean how you put the data. Actually if you dynamically set the data, you are able to run whatever number of instances and put whatever data in each of them. But there should not have unexpected static data shared through these multiple processes.</span>
<span class="comment-copy">@Kevin I need it to be in the same process and be able to access the memory address of the program. But how is it annoying?</span>
<span class="comment-copy">@Gemini Keith I'd suppose that's true. But for each actor to access it's data from the database, it needs to at least store it's own ID that can be used to quickly do some look ups. The data is sort of dynamic, it'll be defined before the next time the program becomes live. And it's defined by a JSON metafile.</span>
<span class="comment-copy">But if all of your processes is from same source code, you don't even need to specify the identity. Just dealing each data block one by one. You can use local database or cache such as redis to store these data and work with it later simultaneously. Of course, you might need mark the status of each data block to indicate whether it has been dealt or not.</span>
<span class="comment-copy">I'd give you a plus one, but Stack Overflow apparently does not allow you to do so without a decent reputation in any of it's sub categories. I'll agree that Python is slow, but in it's usecase it might not be a problem if all it's doing is game logic. But geeze, this has actually given me even more to contemplate now as it looks like inplementing python is more intrusive than I had origionally thought.</span>
