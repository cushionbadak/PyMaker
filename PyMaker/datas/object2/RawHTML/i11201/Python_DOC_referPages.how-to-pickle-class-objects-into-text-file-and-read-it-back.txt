<div class="post-text" itemprop="text">
<pre><code>if __name__ == "__main__":  
    h1 = Person(5)
    print (h1)
</code></pre>
<p>As shown above, I have a object <code>h1</code> of class <code>Person</code> needed to be saved as text file (.txt). I'm wondering how to fulfill this persistence and read it back?</p>
<p>Some users suggested to use pickle, I think I probably need more detail here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a possible solution to get you started. I renamed the person instance name and changed the parameter to a name ;-)</p>
<pre><code>#! /usr/bin/env python
"""Note: Documentation clearly states, that classes can be pickled,
but only iff they "are defined at the top level of a module"."""
from __future__ import print_function

import pickle


class Person(object):
    """Minimal class to showcase (un)pickle."""
    FULL_NAME_DEFAULT = 'N.N.'

    def __init__(self, full_name=None):
        """Detected initializer (show unpickling behaviour)."""
        if full_name is not None:
            self.full_name = full_name
        else:
            self.full_name = self.FULL_NAME_DEFAULT
        print("Initializer called!")
        self.say_hello()

    def say_hello(self):
        """A method to say a personalized hello."""
        print("Hello! My name is '%s'" % (self.full_name,))


def main():
    """Drive the dumps and loads of Person instances."""
    number_one = Person("Jane Awsome")
    print(number_one)
    print("# Serialize the person number_one ... with default protocol:")
    serialized_person = pickle.dumps(number_one)
    print("# Dump of the data representing the serialized_person:")
    print(serialized_person)
    print("# Now for something completely different ...")
    reborn = pickle.loads(serialized_person)
    print("# Back again a copy of number_one, no __init__ called ;-)")
    reborn.say_hello()

if __name__ == "__main__":
    main()
</code></pre>
<p>when being run on my machine and with python v2 this results in:</p>
<pre><code>Initializer called!
Hello! My name is 'Jane Awsome'
&lt;__main__.Person object at 0x102e730d0&gt;
# Serialize the person number_one ... with default protocol:
# Dump of the data representing the serialized_person:
ccopy_reg
_reconstructor
p0
(c__main__
Person
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'full_name'
p6
S'Jane Awsome'
p7
sb.
# Now for something completely different ...
# Back again a copy of number_one, no __init__ called ;-)
Hello! My name is 'Jane Awsome'
</code></pre>
<p>Executed with Python v3:</p>
<pre><code>Initializer called!
Hello! My name is 'Jane Awsome'
&lt;__main__.Person object at 0x1010c8780&gt;
# Serialize the person number_one ... with default protocol:
# Dump of the data representing the serialized_person:
b'\x80\x03c__main__\nPerson\nq\x00)\x81q\x01}q\x02X\t\x00\x00\x00full_nameq\x03X\x0b\x00\x00\x00Jane Awsomeq\x04sb.'
# Now for something completely different ...
# Back again a copy of number_one, no __init__ called ;-)
Hello! My name is 'Jane Awsome'
</code></pre>
<p>The default protocol has changed I guess :-)</p>
<p>Please try to look up the details you might need for extending and fitting your use case at the normative documentation eg. <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow">12.1. pickle â€” Python object serialization</a></p>
<p>... and always take care, when unpickling, if the data might have been tempered with, as you have to rely on your trust what goes in through this channel. It is a powerful one.</p>
<p>So like with JSON and other (de)serializing modules, there are methods optimized for strings, files etc. You can easily read that up in the docs. Here I used dumps() and loads() where the postfix s stands for string.</p>
<p>For output of the content of the serialized person (here in a string variable) to a file and reading back in xou can easily look that up in aforementiioned excellent Python documentation.</p>
</div>
<span class="comment-copy">Use the <code>pickle</code> module.</span>
<span class="comment-copy">Iff you really need a text file (meaning something like the output from <code>h1.__repr__()</code> stored) than "reading it back" understood as evaluating the text as a python declaration to get back a copy of the <code>h1</code> object that is possible, but as @ppperry suggests I rarely had a reason to avoid pickling. Just take care (as with text stored serializations of code) to only consume and evaluate what you trus or have checked. Evil things may happen after injection or tampering with the stored items ...</span>
<span class="comment-copy">@ppperry like how? Could you explain it with more detail?</span>
<span class="comment-copy">@Dilettant Could you provide more detail on this "pickle solution"?</span>
<span class="comment-copy">Yes, sure. Please cf. my answer and if it fits your needs, you could accept it and  when along the way of further learning python you find other questions you can't solve from existing material, you may well pose another specific question.  We're all here to help each other.</span>
