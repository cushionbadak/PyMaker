<div class="post-text" itemprop="text">
<p>While this question is formulated using the Python programming language, I believe it is more of a programming logic problem. </p>
<p>I have a list of all possible combinations, i.e.: n choose k</p>
<p>I can prepare such a list using</p>
<pre><code>import itertools
bits_list = list(itertools.combinations(range(n), k))
</code></pre>
<p>If 'n' is 100, and `k' is 5, then the length of 'bits_list' will be 75287520.</p>
<p>Now, I want to prune this list, such that numbers appear in groups, or they don't. Let's use the following sets as an example:</p>
<p>Set 1: [0, 1, 2] <br/>
Set 2: [57, 58] <br/>
Set 3: [10, 15, 20, 25] <br/>
Set 4: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</p>
<p>Here each set needs to appear in any member of the bits_list together, or not at all. </p>
<p>So far, I only have been able to think of a brute-force if-else method of solving this problem, but the number of if-else conditions will be very large this way. </p>
<p>Here's what I have:</p>
<pre><code>bits_list = [x for x in list(itertools.combinations(range(n), k)) 
             if all(y in x for y in [0, 1, 2]) or
             all(y not in x for y in [0, 1, 2])]
</code></pre>
<p>Now, this only covered Set 1. I would like to do this for many sets. If the length of the set is longer than the value of k, we can ignore the set (for example, k = 5 and Set 4).  </p>
<p>Note, that the ultimate aim is to have 'k' iterate over a range, say [5:25] and work on the appended list. The size of the list grows exponentially here and computationally speaking, very expensive!</p>
<p>With 'k' as 10, the python interpreter interrupts the process before completion on any average laptop with 16 GB RAM. I need to find a solution that fits in the memory of a relatively modern server (not a cluster or a server farm). </p>
<p>Any help is greatly appreciated! </p>
<p>P.S.: Intuitively, think of this problem as generating all the possible cases for people boarding a public bus or train system. Usually, you board an entire group or you don't board anyone.</p>
<p><hr/>
UPDATE:</p>
<ol>
<li><p>For the given sets above, if k = 5, then a valid member of bits_list would be [0, 1, 2, 57, 58], i.e.: a combination of Set1 and Set2. If k = 10, then we could have built Set1 + Set2 + Set3 + NoSetElement as a possible member. @DonkeyKong's solution made me realize I haven't mentioned this explicitly in my question. </p></li>
<li><p>I have a lot of sets; I intend to use enough sets to prune the full list of combinations such that the bits_list eventually fits into memory. </p></li>
<li><p>@9000's suggestion is perfectly valid here, that during each iteration, I can save the combinations as actual bits. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>This still gets crushed by a memory error (<em>which I don't see how you're getting away from if you insist on a list</em>) at a certain point (around n=90, k=5), but it is much faster than your current implementation. For <code>n=80</code> and <code>k=5</code>, my rudimentary benchmarking had my solution at 2.6 seconds and yours around 52 seconds. </p>
<p>The idea is to construct the disjoint and subset parts of your filter separately. The disjoint part is trivial, and the subset part is calculated by taking the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> of all disjoint combinations of length <code>k - set_len</code> and the individual elements of your set. </p>
<pre><code>from itertools import combinations, product, chain
n = 80
k = 5
set1 = {0,1,2}

nots = set(range(n)) - set1
disj_part = list(combinations(nots, k))
subs_part = [tuple(chain(x, els)) for x, *els in 
              product(combinations(nots, k - len(set1)), *([e] for e in set1))]
full_l = disj_part + subs_part
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you actually represented your bits as bits, that is, 0/1 values in a binary representation of an integer n bits long with exactly k bits set, the amount of RAM you'd need to store the data would be drastically smaller. </p>
<p>Also, you'd be able to use bit operations to look check if all  bits in a <code>mask</code> are actually set (<code>value &amp; mask == mask</code>), or all unset (<code>value | ~mask == value</code>).</p>
<p>The brute-force will probably take shorter that the time you'd spend thinking about a more clever algorithm, so it's totally OK for a one-off filtering.</p>
<p>If you must execute this often and quickly, and your <code>n</code> is in small hundreds or less, I'd rather use cython to describe the brute-force algorithm efficiently than look at algorithmic improvements. Modern CPUs can efficiently operate on 64-bit numbers; you won't benefit much from not comparing a part of the number.</p>
<p>OTOH if your <code>n</code> is really large, and the number of sets to compare to is also large, you could partition your bits for efficient comparison.</p>
<p>Let's suppose you can efficiently compare a chunk of 64 bits, and your bit lists contain e.g. 100 chunks each. Then you can do the same thing you'd do with strings: compare chunk by chunk, and if one of the chunks fails to match, do not compare the rest.</p>
</div>
<div class="post-text" itemprop="text">
<p>A faster implementation would be to replace the if and all() statements in:</p>
<pre><code>bits_list = [x for x in list(itertools.combinations(range(n), k)) 
             if all(y in x for y in [0, 1, 2]) or
             all(y not in x for y in [0, 1, 2])]
</code></pre>
<p>with python's set operations <code>isdisjoint()</code> and <code>issubset()</code> operations. </p>
<pre><code>bits_generator = (set(x) for x in itertools.combinations(range(n), k))
first_set = set([0,1,2])
filter_bits = (x for x in bits_generator 
             if x.issubset(first_set) or
             x.isdisjoint(first_set))
answer_for_first_set = list(filter_bits)
</code></pre>
<p>I can keep going using generators and with generators you won't run out of memory but you will be waiting and hastening the heat death of the universe.  Not because of python's runtime or other implementation details but because there are some problems that are just not feasible even in computer time if you pick a large N and K values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the ideas from <a href="https://stackoverflow.com/a/37797756/3919475">@Mitch's answer</a>, I created a solution with a slightly different thinking than originally presented in the question. Instead of creating the list (<code>bits_list</code>) of all combinations and then pruning those combinations that do not match the sets listed, I built <code>bits_list</code> from the sets. </p>
<pre><code>import itertools
all_sets = [[0, 1, 2], [3, 4, 5], [6, 7], [8], [9, 19, 29], [10, 20, 30], 
            [11, 21, 31], [12, 22, 32], ...[57, 58], ... [95], [96], [97]]
bits_list = [list(itertools.chain.from_iterable(x)) for y in [1, 2, 3, 4, 5] 
             for x in itertools.combinations(all_sets, y)]
</code></pre>
<p>Here, instead of finding n choose k, and then looping for all k, and finding combinations which match the sets, I started from the sets, and even included the individual members as sets by themselves and therefore removing the need for the 2 components - the disjoint and the subset parts - discussed in <a href="https://stackoverflow.com/a/37797756/3919475">@Mitch's answer</a>. </p>
</div>
<span class="comment-copy">This problem is probably more suitable in the computer science stack exchange</span>
<span class="comment-copy">Are you the conductor boarding the people on the train or are you a person boarding the transportation links?</span>
<span class="comment-copy">So you definitely need an actual list, in memory, with that many items?  Because that is what your bottleneck becomes here.</span>
<span class="comment-copy">Are you trying to count the combinations which work or output them?</span>
<span class="comment-copy">@DaveGalvin, I am performing further operations on items that I select using these combinations.</span>
<span class="comment-copy">I am working on a solution based on this. Thank you for a fantastic answer. With enough sets to work with, the memory error won't happen. The advantage with this solution is that we are not building the list and then pruning, but rather, just building the list from the sets! P.S.: See update to the question about using set combinations.</span>
<span class="comment-copy">@RahulMurmuria Yes, precisely, constructing from the sets reduces costs enormously. You're welcome. I'm not entirely sure what you mean with your update regarding set combinations, could you try clarifying a bit? Are you just combining sets for your 'all or none' cases?</span>
<span class="comment-copy">If you think using the intuitive example I gave, having 1 family in the bus does not mean the remaining people in the bus have to be singles. You can have as many families in the bus as you like. Similarly, if k = 10, then a valid member of bits_list would be [0, 1, 2, 57, 58, 10, 15, 20, 25, <i>33</i>]</span>
<span class="comment-copy">We would not have needed to consider this case, if we were pruning. These combination members would not be removed from bits_list. however, if we are building the list starting with the sets, then we need to explicitly handle this case.</span>
<span class="comment-copy">@RahulMurmuria Cheers, check back here tomorrow and I may have an updated answer for you when I have a bit of time.</span>
<span class="comment-copy">I am in fact representing each member of bits_list later in my program as <a href="https://pypi.python.org/pypi/bitarray/0.8.1" rel="nofollow noreferrer">bitarray</a> for something unrelated. Instead, representing them as bitarray while preparing this bits_list is definitely good design. Thank you for this suggestion!</span>
