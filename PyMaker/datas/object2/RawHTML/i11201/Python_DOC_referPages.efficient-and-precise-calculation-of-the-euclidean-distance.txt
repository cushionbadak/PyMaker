<div class="post-text" itemprop="text">
<p>Following some online research (<a href="https://stackoverflow.com/a/1401828/6182051">1</a>, <a href="http://www.codehamster.com/2015/03/09/different-ways-to-calculate-the-euclidean-distance-in-python/" rel="nofollow noreferrer">2</a>, <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html" rel="nofollow noreferrer">numpy</a>, <a href="http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.spatial.distance.euclidean.html" rel="nofollow noreferrer">scipy</a>, <a href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.euclidean_distances.html" rel="nofollow noreferrer">scikit</a>, <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer">math</a>), I have found several ways for calculating the <strong>Euclidean Distance in Python</strong>: </p>
<pre><code># 1
numpy.linalg.norm(a-b)

# 2
distance.euclidean(vector1, vector2)

# 3
sklearn.metrics.pairwise.euclidean_distances  

# 4
sqrt((xa-xb)^2 + (ya-yb)^2 + (za-zb)^2)

# 5
dist = [(a - b)**2 for a, b in zip(vector1, vector2)]
dist = math.sqrt(sum(dist))

# 6
math.hypot(x, y)
</code></pre>
<p>I was wondering if someone could provide an insight on which of the above (<em>or any other that I have not found</em>) is considered the best in terms of <strong>efficiency</strong> and <strong>precision</strong>. If someone is aware of any <em>resource(s)</em> which discusses the subject that would also be great.</p>
<p>The <em>context</em> I am interesting in is in calculating the Euclidean Distance between pairs of number-tuples, e.g. the distance between <code>(52, 106, 35, 12)</code> and <code>(33, 153, 75, 10)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Conclusion first:</h3>
<p>From the test result by using <code>timeit</code> for efficiency test, we can conclude that <strong>regarding the efficiency</strong>:</p>
<p><strong><code>Method5 (zip, math.sqrt)</code> &gt; <code>Method1 (numpy.linalg.norm)</code> &gt; <code>Method2 (scipy.spatial.distance)</code> &gt; <code>Method3 (sklearn.metrics.pairwise.euclidean_distances )</code></strong></p>
<p>While I didn't really test your <code>Method4</code> as it is not suitable for general cases and it is generally equivalent to <code>Method5</code>. </p>
<p>For the rest, quite surprisingly, <code>Method5</code> is the fastest one. While for <code>Method1</code> which uses <code>numpy</code>, as what we expected, which is heavily optimized in C, is the second fastest. </p>
<p>For <code>scipy.spatial.distance</code>, if you go directly to the function definition, you will see that it is actually using <code>numpy.linalg.norm</code>, except it will perform the validation on the two input vectors before the actual <code>numpy.linalg.norm</code>. That's why it is slightly slower thant <code>numpy.linalg.norm</code>.</p>
<p>Finally for <code>sklearn</code>, according to the documentation:</p>
<blockquote>
<p>This formulation has two advantages over other ways of computing distances. First, it is computationally efficient when dealing with sparse data. Second, if one argument varies but the other remains unchanged, then dot(x, x) and/or dot(y, y) can be pre-computed.
  However, this is not the most precise way of doing this computation, and the distance matrix returned by this function may not be exactly symmetric as required</p>
</blockquote>
<p>Since in your question you would like to use a fixed set of data, the advantage of this implementation is not reflected. And due to the trade off between the performance and precision, it also gives the worst precision among all of the methods.</p>
<p><strong>Regarding the precision</strong>, <strong><code>Method5</code>=<code>Metho1</code>=<code>Method2</code>&gt;<code>Method3</code></strong></p>
<h3>Efficiency Test Script:</h3>
<pre><code>import numpy as np
from scipy.spatial import distance
from sklearn.metrics.pairwise import euclidean_distances
import math

# 1
def eudis1(v1, v2):
    return np.linalg.norm(v1-v2)

# 2
def eudis2(v1, v2):
    return distance.euclidean(v1, v2)

# 3
def eudis3(v1, v2):
    return euclidean_distances(v1, v2)

# 5
def eudis5(v1, v2):
    dist = [(a - b)**2 for a, b in zip(v1, v2)]
    dist = math.sqrt(sum(dist))
    return dist

dis1 = (52, 106, 35, 12)
dis2 = (33, 153, 75, 10)
v1, v2 = np.array(dis1), np.array(dis2)

import timeit

def wrapper(func, *args, **kwargs):
    def wrapped():
        return func(*args, **kwargs)
    return wrapped

wrappered1 = wrapper(eudis1, v1, v2)
wrappered2 = wrapper(eudis2, v1, v2)
wrappered3 = wrapper(eudis3, v1, v2)
wrappered5 = wrapper(eudis5, v1, v2)
t1 = timeit.repeat(wrappered1, repeat=3, number=100000)
t2 = timeit.repeat(wrappered2, repeat=3, number=100000)
t3 = timeit.repeat(wrappered3, repeat=3, number=100000)
t5 = timeit.repeat(wrappered5, repeat=3, number=100000)

print('\n')
print('t1: ', sum(t1)/len(t1))
print('t2: ', sum(t2)/len(t2))
print('t3: ', sum(t3)/len(t3))
print('t5: ', sum(t5)/len(t5))
</code></pre>
<h3>Efficiency Test Output:</h3>
<pre><code>t1:  0.654838958307
t2:  1.53977598714
t3:  6.7898791732
t5:  0.422228400305
</code></pre>
<h3>Precision Test Script &amp; Result:</h3>
<pre><code>In [8]: eudis1(v1,v2)
Out[8]: 64.60650122085238

In [9]: eudis2(v1,v2)
Out[9]: 64.60650122085238

In [10]: eudis3(v1,v2)
Out[10]: array([[ 64.60650122]])

In [11]: eudis5(v1,v2)
Out[11]: 64.60650122085238
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know how the precision and speed compares to the other libraries you mentioned, but you can do it for 2D vectors using the built-in <code>math.hypot()</code> function:</p>
<pre><code>from math import hypot

def pairwise(iterable):
    "s -&gt; (s0, s1), (s1, s2), (s2, s3), ..."
    a, b = iter(iterable), iter(iterable)
    next(b, None)
    return zip(a, b)

a = (52, 106, 35, 12)
b = (33, 153, 75, 10)

dist = [hypot(p2[0]-p1[0], p2[1]-p1[1]) for p1, p2 in pairwise(tuple(zip(a, b)))]
print(dist)  # -&gt; [131.59027319676787, 105.47511554864494, 68.94925670375281]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a general rule of thumb, stick to the <code>scipy</code> and <code>numpy</code> implementations where possible, as they're vectorized and much faster than native Python code. (Main reasons are: implementations in C, vectorization eliminates type checking overhead that looping does.)</p>
<p>(Aside: My answer doesn't cover precision here, but I think the same principle applies for precision as for efficiency.)</p>
<p>As a bit of a bonus, I'll chip in with a bit of information on how you can profile your code, to measure efficiency. If you're using the IPython interpreter, the secret is to use the <code>%prun</code> line magic.</p>
<pre><code>In [1]: import numpy

In [2]: from scipy.spatial import distance

In [3]: c1 = numpy.array((52, 106, 35, 12))

In [4]: c2 = numpy.array((33, 153, 75, 10))

In [5]: %prun distance.euclidean(c1, c2)
         35 function calls in 0.000 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 linalg.py:1976(norm)
        1    0.000    0.000    0.000    0.000 {built-in method numpy.core.multiarray.dot}
        6    0.000    0.000    0.000    0.000 {built-in method numpy.core.multiarray.array}
        4    0.000    0.000    0.000    0.000 numeric.py:406(asarray)
        1    0.000    0.000    0.000    0.000 distance.py:232(euclidean)
        2    0.000    0.000    0.000    0.000 distance.py:152(_validate_vector)
        2    0.000    0.000    0.000    0.000 shape_base.py:9(atleast_1d)
        1    0.000    0.000    0.000    0.000 misc.py:11(norm)
        1    0.000    0.000    0.000    0.000 function_base.py:605(asarray_chkfinite)
        2    0.000    0.000    0.000    0.000 numeric.py:476(asanyarray)
        1    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}
        1    0.000    0.000    0.000    0.000 linalg.py:111(isComplexType)
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)
        2    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}
        4    0.000    0.000    0.000    0.000 {built-in method builtins.len}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        2    0.000    0.000    0.000    0.000 {method 'squeeze' of 'numpy.ndarray' objects}


In [6]: %prun numpy.linalg.norm(c1 - c2)
         10 function calls in 0.000 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 linalg.py:1976(norm)
        1    0.000    0.000    0.000    0.000 {built-in method numpy.core.multiarray.dot}
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 numeric.py:406(asarray)
        1    0.000    0.000    0.000    0.000 {method 'ravel' of 'numpy.ndarray' objects}
        1    0.000    0.000    0.000    0.000 linalg.py:111(isComplexType)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.issubclass}
        1    0.000    0.000    0.000    0.000 {built-in method numpy.core.multiarray.array}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
</code></pre>
<p>What <code>%prun</code> does is tell you how long a function call takes to run, including a bit of trace to figure out where the bottleneck might be. In this case, both the <code>scipy.spatial.distance.euclidean</code> and <code>numpy.linalg.norm</code> implementations are pretty fast. Assuming you defined a function <code>dist(vect1, vect2)</code>, you can profile using the same IPython magic call. As another added bonus, <code>%prun</code> also works inside the Jupyter notebook, and you can do <code>%%prun</code> to profile an entire cell of code, rather than just one function, simply by making <code>%%prun</code> the first line of that cell.</p>
</div>
<span class="comment-copy">Don't forget the built-in <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>math.hypot()</code></a>. You can easily test the speeds using the <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> module.</span>
<span class="comment-copy">@martineau Great suggestion, had no idea that such a built-in method existed! (edited my question to include it)</span>
<span class="comment-copy">Possible caveat with <code>math.hypot()</code> is that it only does 2D vectors, whereas many of the others you mention can handle vectors of 3 or more dimensions. On the other hand, if all you're doing is 2D, the non-generalized built-in might have a speed advantage.</span>
<span class="comment-copy">@martineau Interesting caveat although for my case it may be ideal. Possibly naive question: when calculating the euclidean distance between <code>(52, 106, 35, 12)</code> and <code>(33, 153, 75, 10)</code>, these two are 4D vectors??</span>
<span class="comment-copy">All depends on how you're interpreting them in the program. Could be two 4D vectors or four 2D vectors...the former seems most likely â€” I can't tell from your sample code.</span>
<span class="comment-copy">Please add the built-in <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>math.hypot()</code></a>. (The OP is using Python 3, BTW).</span>
<span class="comment-copy">@MaThMaX Great stuff! As @martineau suggests, if you could add the built-in <code>math.hypot()</code> that would be amazing. Especially since I have never used/heard of it before.</span>
<span class="comment-copy">Thanks for this, I will try to test and time it. Could you briefly explain what the <code>pairwise</code> method does?</span>
<span class="comment-copy">Sure. The <code>pairwise()</code> function is a slight variation on the one shown in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> documentation. It and the original return pairs of values from the iterable argument it's passed in the order shown in its doc string at the very beginning of the function.</span>
