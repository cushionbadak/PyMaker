<div class="post-text" itemprop="text">
<p>I`d like to transform the following python input:</p>
<pre><code>[{'paramA': ['valA1','valA2','valA3','valA4']},
 {'paramB': ['valB1','valB2','valB3','valB4']},
 {'paramC': ['valC1','valC2','valC3','valC4']},
 # ...........................................,
 {'paramN': ['valN1', 'valN2','valN3','valN4']}]
</code></pre>
<p>To the following output:</p>
<pre><code>[{'paramA': 'valA1','paramB': 'valB1', 'paramC': 'valC1', ...,'paramN':'valN1' }
 {'paramA': 'valA2','paramB': 'valB2', 'paramC': 'valC2', ...,'paramN':'valN2' }
 {'paramA': 'valA3','paramB': 'valB3', 'paramC': 'valC3', ...,'paramN':'valN3' }
 {'paramA': 'valA4','paramB': 'valB4', 'paramC': 'valC4', ...,'paramN':'valN4' } ]
</code></pre>
<p>The only function I could  think of is the following:</p>
<pre><code>def transformParams( inputParams ):
    res = []
    for i in inputParams:
        for k,v in i.items():
            for ind, inv in enumerate(v):
                if len(res) &lt;= ind:
                    res.append({})
                res[ind][k] = inv
    return res
</code></pre>
<p>I am new to Python and I think this can be done in an easier Pythonic way using list comprehensions. Can anyone please come with a better answer?</p>
</div>
<div class="post-text" itemprop="text">
<p>First join everything in the input list into <em>one</em> dictionary; that way you can use <code>zip()</code> to transform all values into rows, and re-combine that with the keys:</p>
<pre><code>try:
   # use efficient Python 3 version in Python 2
   from future_builtins import zip
except ImportError:
   # Python 3
   pass

combined = reduce(lambda d1, d2: dict(d1, **d2), inputlist)
result = [dict(zip(combined, col)) for col in zip(*combined.values())]
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code> function</a> pairs up elements from the input lists together, producing a tuple with all first elements, then all second, etc. The <code>*</code> in a <code>zip(*list_of_lists)</code> call applies all contained sequences (here all lists from the combined dictionary values) as separate arguments, which <code>zip()</code> then proceeds to pair up. In essence this transposes the rows to column sequences.</p>
<p>Those column sequences are then re-combined with the keys (again using <code>zip()</code> to do the pairing) to form the output dictionaries.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; inputlist = [
...     {'paramA': ['valA1','valA2','valA3','valA4']},
...     {'paramB': ['valB1','valB2','valB3','valB4']},
...     {'paramC': ['valC1','valC2','valC3','valC4']},
...     # ...........................................,
...     {'paramN': ['valN1', 'valN2','valN3','valN4']}]
&gt;&gt;&gt; combined = reduce(lambda d1, d2: dict(d1, **d2), inputlist)
&gt;&gt;&gt; [dict(zip(combined, col)) for col in zip(*combined.values())]
[{'paramN': 'valN1', 'paramC': 'valC1', 'paramB': 'valB1', 'paramA': 'valA1'}, {'paramN': 'valN2', 'paramC': 'valC2', 'paramB': 'valB2', 'paramA': 'valA2'}, {'paramN': 'valN3', 'paramC': 'valC3', 'paramB': 'valB3', 'paramA': 'valA3'}, {'paramN': 'valN4', 'paramC': 'valC4', 'paramB': 'valB4', 'paramA': 'valA4'}]
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(_)
[{'paramA': 'valA1', 'paramB': 'valB1', 'paramC': 'valC1', 'paramN': 'valN1'},
 {'paramA': 'valA2', 'paramB': 'valB2', 'paramC': 'valC2', 'paramN': 'valN2'},
 {'paramA': 'valA3', 'paramB': 'valB3', 'paramC': 'valC3', 'paramN': 'valN3'},
 {'paramA': 'valA4', 'paramB': 'valB4', 'paramC': 'valC4', 'paramN': 'valN4'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [
    {"paramA": ["valA1","valA2","valA3","valA4"]},
    {"paramB": ["valB1","valB2","valB3","valB4"]},
    {"paramC": ["valC1","valC2","valC3","valC4"]},
]

output = [dict([(line.keys()[0], line.values()[0][index]) for line in l]) for index in range(len(l[0].values()[0]))]

print(output)
</code></pre>
<p>This is what I came up with. Not very pretty but gets the job done. Also, this requires that the length of the values is always the same and that the first key and value of the dictionary are the wanted param and val.</p>
<p>Edit: Ignore this answer. <a href="https://stackoverflow.com/a/37774144/2607571">Martijn Pieters answer</a> is way more beautiful and readable!</p>
</div>
<span class="comment-copy">I think at your output, at the last key-value pairs of every dictionary, you mean <code>'paramN: valueN1'..'paramN':'valueN2'....'paramN':'valueNm'</code> ?</span>
<span class="comment-copy">Yes, thanks for noticing :)</span>
<span class="comment-copy">Thanks, that's exactly what I was looking for though I cannot understand it fully yet. Will go over your explanation until it`s clear ;)</span>
<span class="comment-copy">Note that indexing on <code>dict.keys()</code> and <code>dict.values()</code> only works in Python 2; for Python 3 you'd have to replace that with <code>next(iter(line))</code> and <code>next(iter(line.items()))</code>.</span>
