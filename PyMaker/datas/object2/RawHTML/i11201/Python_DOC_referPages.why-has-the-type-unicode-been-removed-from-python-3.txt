<div class="post-text" itemprop="text">
<p>If we compare the types <code>bytes</code>, <code>str</code> and <code>unicode</code> in python versions 2 and 3, we can see that </p>
<ul>
<li>the type <code>bytes</code> can be used in the very same way.</li>
<li>the type <code>str</code> changed its meaning from being an alias for <code>bytes</code> to an encoded unicode string (replacement for the former <code>unicode</code> type)</li>
<li>the type <code>unicode</code> is only used in python 2 whereas in python 3 it is removed in favor of a redefined meaning of <code>str</code></li>
</ul>
<p>When writing code that should be compatible with python 2 and python 3 one of the most difficult tasks is to get unicode string handling right, because there is no type which works in both versions. On the other hand, dealing with byte arrays is trivial because there is a <code>bytes</code> type in both versions.</p>
<p>As far as I understand, it would have been very easy to just introduce the type <code>unicode</code> as an alias for <code>str</code> in python 3. This way, a developer could use an unambiguous type name across both versions. Once there is no longer a need for python 2 compatibility, refactoring <code>unicode</code> to <code>str</code> would be straightforward.</p>
<p>The question here is not the best approach to overcome the problems. What I am looking for is an explanation for why the type <code>unicode</code> had to disappear.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Ignacio Vazquez-Abrams already gave you the basic answer to the question you stated:</p>
<p>Q: "...why the type unicode had to disappear"?</p>
<p>A: "Because it never should have existed in the first place. Python 3000 is/was about fixing mistakes."</p></li>
<li><p>Wayne Werner elaborated:</p>
<p>A: "The u prefix is just a noop in Python 3 - which helps people writing 2/3 apps always use unicode. Who objects to that?"</p></li>
<li><p>Which begs the question "Q: <em>WHY</em> you are you trying to write "code that's "compatible between Python 2 and Python 3"" anyway???  That's <em>NOT</em> a reasonable thing to necessarily want to do. The incompatibilities between Python 2 and Python 3 were <em>NOT</em> arbitrary - they were <em>DELIBERATE</em>.  <em>Especially</em> with regard to "Unicode"!</p></li>
<li><p>Here is  Guido van Rossum's rationale for completely re-thinking "Unicode" for Python 3:</p>
<ul>
<li><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit" rel="nofollow">Text Vs. Data Instead Of Unicode Vs. 8-bit</a></li>
</ul></li>
<li><p>And here is how you should be treating Unicode - in any new, Python 3.0 only code - going forward:</p>
<ul>
<li><a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow">Python 3: Unicode Howto</a></li>
</ul></li>
</ol>
<p>I hope that helps!</p>
</div>
<span class="comment-copy">Because it never should have existed in the first place. Python 3000 is/was about fixing mistakes.</span>
<span class="comment-copy">Yes, and not everyone is convinced that adding it was a change for the better.</span>
<span class="comment-copy">"When writing code that should be compatible with python 2 and python 3 ..."  Q: Are you sure that's even a reasonable goal?  <i>ESPECIALLY</i> with regard to Unicode????</span>
<span class="comment-copy">the <code>u</code> prefix is just a noop in Python 3 - which helps people writing 2/3 apps always use unicode. Who objects to that?</span>
<span class="comment-copy"><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit" rel="nofollow noreferrer">docs.python.org/3.0/whatsnew/â€¦</a>, <a href="https://docs.python.org/3/howto/unicode.html" rel="nofollow noreferrer">docs.python.org/3/howto/unicode.html</a>, ...</span>
<span class="comment-copy">3. because there is a good reason to offer 3rd party plugins and users a smooth transition period and there is no reason to deliberately create obstacles for them. No objection that unmixing data and text is a good thing. But that does not explain why there is no type that works consistently across both versions (whatever name this type may have).</span>
<span class="comment-copy">If you want to do right by your customers, you should really offer <i>two</i> versions of each plugin: one for Python2, the other for Python3.  It's like trying to sell one blend of automobile fuel - one that will work for gas cars, as well as for diesel engines. Just don't do it. IMHO...</span>
<span class="comment-copy">PS: An interesting article on the Python2 vs. Python3 debate: <a href="http://blog.startifact.com/posts/python-2-gravity.html" rel="nofollow noreferrer">The Gravity of Python 2</a></span>
<span class="comment-copy">Really interesting thoughts in this article. It also mentions polyglot applications as a way forward. When writing polyglot code wouldn't an unambiguous type only have advantages while there are no disadvantages? The only reason I see to not offer one is to deliberately force people not to write polyglot code. But it's not even made impossible, just a lot worse.</span>
<span class="comment-copy">Actually, I did <i>not</i> interpret Martijn Faassen's comments about polyglot applications as "a way forward".  Quite the opposite.He says if you <i>can</i> write to Python3, then you <i>should</i> (no polyglot).  And if you're considering polyglot, but you don't absolutely <i>need</i> Python3, then you should instead just write Python2 (again, no polyglot).  My understanding is that Faassen views polyglot as a sometimes-necessary-evil, a solution of last resort.  IMHO.  Again: my strong feeling is that - all things being equal - parallel libraries are preferable to polyglot libraries.,.</span>
