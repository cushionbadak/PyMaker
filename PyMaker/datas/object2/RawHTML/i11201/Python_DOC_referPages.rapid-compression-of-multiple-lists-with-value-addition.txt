<div class="post-text" itemprop="text">
<p>I am looking for a pythonic way to iterate through a large number of lists and use the index of repeated values from one list to calculate a total value from the values with the same index in another list.</p>
<p>For example, say I have two lists</p>
<pre><code>a = [ 1, 2, 3, 1, 2, 3, 1, 2, 3]
b = [ 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>What I want to do is find the unique values in a, and then add together the corresponding values from b with the same index. My attempt, which is quite slow, is as follows:</p>
<pre><code>a1=list(set(a))
b1=[0 for y in range(len(a1))] 
    for m in range(len(a)):
        for k in range(len(a1)):
            if a1[k]==a[m]:
                b1[k]+=b[m]
</code></pre>
<p>and I get</p>
<pre><code>a1=[1, 2, 3]
b1=[12, 15, 18]
</code></pre>
<p>Please let me know if there is a faster, more pythonic way to do this.
Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code> function</a> and a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code> dictionary</a> to collect values per unique value:</p>
<pre><code>from collections import defaultdict
try:
    # Python 2 compatibility
    from future_builtins import zip
except ImportError:
    # Python 3, already there
    pass

values = defaultdict(int)
for key, value in zip(a, b):
    values[key] += value

a1, b1 = zip(*sorted(values.items()))
</code></pre>
<p><code>zip()</code> pairs up the values from your two input lists, now all you have to do is sum up each value from <code>b</code> per unique value of <code>a</code>.</p>
<p>The last line pulls out the keys and values from the resulting dictionary, sorts these, and puts just the keys and just the values into <code>a1</code> and <code>b1</code>, respectively.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; a = [ 1, 2, 3, 1, 2, 3, 1, 2, 3]
&gt;&gt;&gt; b = [ 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; values = defaultdict(int)
&gt;&gt;&gt; for key, value in zip(a, b):
...     values[key] += value
...
&gt;&gt;&gt; zip(*sorted(values.items()))
[(1, 2, 3), (12, 15, 18)]
</code></pre>
<p>If you don't care about output order, you can drop the <code>sorted()</code> call altogether.</p>
</div>
<span class="comment-copy">This seems to work great! I was wondering if would be possible to add another level of complexity to this. That is, a third list, say c=[0,1,0,1,0,1,0,1,0], so that the value is only added when c[key]=1??</span>
<span class="comment-copy">@MicahJ: just add <code>c</code> to the first <code>zip()</code>: <code>for key, value, add in zip(a, b, c):</code>, then insert an <code>if add:</code> in between.</span>
