<div class="post-text" itemprop="text">
<p>I have a list of dicts and I need to access dicts values as attributes.</p>
<p>My code:</p>
<pre><code>class Comments:

    def __init__(self):
        self.comments = [{'id': 1, 'title': 'bla'},
                         {'id': 2, 'title': 'bla2'},
                         {'id': 3, 'title': 'bla3'}]

    def __iter__(self):
        return iter(self.comments)
</code></pre>
<p>So, when I write something like:</p>
<pre><code>comment_list = Comments()
for comment in comment_list:
    print comment['id']
</code></pre>
<p>It works.</p>
<p>But I want to use attributes as <code>comment.id</code> instead of <code>comment['id']</code>.</p>
<p>How to realize that?</p>
</div>
<div class="post-text" itemprop="text">
<p>As @Tim Castelijns said, that's not how dicts work.</p>
<p>The behavior you seek can be achieved by having a <code>Comment</code> class which holds the <code>id</code> and <code>title</code> as members.</p>
<pre><code>class Comment

    def __init__(self, id, title):
       self.id = id
       self.title = title

class CommentsHolder:

    def __init__(self):
        self.comments = [Comment(1,'bla'),
                         Comment(2,'bla2'),
                         Comment(3, 'bla3')]

    def __iter__(self):
        return iter(self.comments)
</code></pre>
<p>You can then do:</p>
<pre><code>for comment in CommentsHolder():
    print(comment.id)
</code></pre>
<p>Furthermore, you can take a look at the <a href="https://pypi.python.org/pypi/bunch/1.0.0" rel="nofollow">Bunch module</a>, which is a dot-accessible dictionary. However if you are using python 3, be aware that it might not work. (at least it didn't for me.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can probably use <a href="https://pypi.python.org/pypi/bunch" rel="nofollow">Bunch</a> for this.</p>
<blockquote>
<p>Bunch is a dictionary that supports attribute-style access, a la JavaScript</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Another approach for completeness - use a <code>namedtuple</code>.</p>
<pre><code>from collections import namedtuple

Comment = namedtuple('Comment', ('id', 'title'))
comments = [Comment(42, 'What is the answer to life, the universe, and everything?'),
            Comment(13, 'What is your favorite color?'),
            Comment(14, 'What is your quest?'),
            Comment(15, 'What is the airspeed velocity of an unladen swallow?'),
            ]

for comment in comments:
    print('{}: {}'.format(comment.id, comment.title))

# or
for comment in comments:
    comment = comment._asdict()
    print('{}: {}'.format(comment['id'], comment['title']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class AttrDict(dict):
    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self

class Comments:
    def __init__(self):
        self.comments = [{'id': 1, 'title': 'bar'},
                         {'id': 2, 'title': 'foo'},
                         {'id': 3, 'title': 'spam'}]

    def __iter__(self):
        return iter(self.comments)

comment_list = Comments()
for comment in comment_list:
    print(AttrDict(comment).id)
</code></pre>
<p>AttrDict used from <a href="https://stackoverflow.com/a/14620633/6464041">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make the comments instances of a dictionary subclass that allows normal access as well as dotted attribute-style access. There are several ways of implementing it, but the following is one of the simplest, which is to make the each instance its own <code>__dict__</code>:</p>
<pre><code>class Comment(dict):
    def __init__(self, *args, **kwargs):
        super(Comment, self).__init__(*args, **kwargs)
        self.__dict__ = self

class Comments(object):
    def __init__(self):
        self.comments = [Comment({'id': 1, 'title': 'bla'}),
                         Comment({'id': 2, 'title': 'bla2'}),
                         Comment({'id': 3, 'title': 'bla3'})]

    def __iter__(self):
        return iter(self.comments)

comment_list = Comments()
for comment in comment_list:
    print(comment.id)
</code></pre>
<p>Note that <code>Comment</code> dictionaries can be created any of the <a href="https://docs.python.org/2/library/stdtypes.html#dict" rel="nofollow">many ways regular dictionaries can</a>, so in addition to what is shown above, the instances in the <code>comments</code> list could have been created like this which uses keywords to define their contents:</p>
<pre><code>class Comments(object):
    def __init__(self):
        self.comments = [Comment(id=1, title='bla'),
                         Comment(id=2, title='bla2'),
                         Comment(id=3, title='bla3')]
</code></pre>
</div>
<span class="comment-copy">Why would you want that? That is not how dicts work. It will confuse people who read your code</span>
<span class="comment-copy">You would use <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer">setattr()</a>.</span>
