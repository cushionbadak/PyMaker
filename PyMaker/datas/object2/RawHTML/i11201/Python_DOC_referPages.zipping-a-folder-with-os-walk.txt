<div class="post-text" itemprop="text">
<p>I'm trying to zip a folder and every contained subfolder and file using <code>os.walk()</code>, but I am having trouble removing the folder path to the root folder - meaning I would like to remove <code>D:\\Users\\Username\\Desktop</code> when opening up the zipfile, but instead open straight to the root folder. </p>
<p>I've been trying to use <code>os.path.basename()</code> and zipfile's <code>arcname</code> argument, but just can't seem to get it right:</p>
<pre><code>def backupToZip(folder):

    import zipfile, os

    folder = os.path.abspath(folder) # make sure folder is absolute

    # Walk the entire folder tree and compress the files in each folder.  
    for foldername, subfolders, filenames in os.walk(folder):

        # Add the current folder to the ZIP file.
        backupZip.write(foldername)

        # Add all the files in this folder to the ZIP file.
        for filename in filenames:
            backupZip.write(os.path.join(foldername, filename))
    backupZip.close()

backupToZip('Sample Folder')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid chdir, which impacts the whole process, you can use <a href="https://docs.python.org/3/library/os.path.html#os.path.relpath" rel="nofollow">relpath</a> to get the relative path starting from your top folder.</p>
<p>You could use something like</p>
<pre><code>def backupToZip(folder):

    import zipfile, os

    folder = os.path.abspath(folder) # make sure folder is absolute

    # Walk the entire folder tree and compress the files in each folder.  
    for foldername, subfolders, filenames in os.walk(folder):

        if foldername == folder:
             archive_folder_name = ''
        else:
             archive_folder_name = os.path.relpath(foldername, folder)

             # Add the current folder to the ZIP file.
             backupZip.write(foldername, arcname=archive_folder_name)

        # Add all the files in this folder to the ZIP file.
        for filename in filenames:
            backupZip.write(os.path.join(foldername, filename), arcname=os.path.join(archive_folder_name, filename))
    backupZip.close()

backupToZip('Sample Folder')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Use <code>os.chdir</code> to change your current path</li>
<li>Make sure that the parameter of <code>os.walk</code> is relative path</li>
</ol>
<p>*Should be careful when using <code>os.chdir</code></p>
<hr/>
<pre><code>import zipfile, os

def backupToZip(folder):

    cwdpath = os.getcwd() # save original path (*where you run this py file)

    saveToWhere = "tmp.zip"
    zf = zipfile.ZipFile(saveToWhere, mode='w')

    folder = os.path.abspath(folder) # make sure folder is absolute
    os.chdir(folder) # change to that absolute path

    # os.walk(relative_path)
    for foldername, subfolders, filenames in os.walk("./"):
        for filename in filenames:
            zf.write(os.path.join(foldername, filename))    
    zf.close()

    os.chdir(cwdpath) # back to original path
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Made some revisions based on user2313067's answer above and finally got what I wanted in case anyone was curious:</p>
<pre><code>import zipfile, os

def backupToZip(folder):

    # Make sure folder is absolute.
    folder = os.path.abspath(folder) 

    backupZip = zipfile.ZipFile('backup.zip', 'w')

    backupZip.write(folder, arcname=os.path.basename(folder))


    # Walk the entire folder tree and compress the files in each folder.  
    for foldername, subfolders, filenames in os.walk(folder):

        # Add the current folder to the ZIP file if not root folder
        if foldername != folder:
            backupZip.write(foldername, arcname=os.path.relpath(foldername, os.path.dirname(folder)))

        # Add all the files in this folder to the ZIP file.
        for filename in filenames:
            backupZip.write(os.path.join(foldername, filename), arcname=os.path.join(os.path.relpath(foldername, os.path.dirname(folder)), filename))
    backupZip.close()
</code></pre>
</div>
<span class="comment-copy">Could you post what you would like the zipped archive structure to look like? Your code as you posted it is a bit confusing because it's recursive without an initial call to the function.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/2212643/python-recursive-folder-read" title="python recursive folder read">stackoverflow.com/questions/2212643/â€¦</a>?</span>
<span class="comment-copy">@hobenkr: Sorry for any confusion - I would like the zip folder structure to be <code>Sample Folder\Subfolders and Files\Subfolders and Files</code> instead of <code>D:\\Users\\Username\\Desktop\\Sample Folder\\Subfolders and Files\\Subfolders and Files</code></span>
<span class="comment-copy">Thanks! This is very close, just had to add in <code>backupZip = zipfile.ZipFile('backup.zip', 'w')</code>. Also, it removed the root folder being zipped, ie it went straight from zipfile to subfolders - anyway to retain the root folder?</span>
<span class="comment-copy">Figured out how to retain root folder per answer below - thanks everyone.</span>
<span class="comment-copy">Thanks! - this was really close, but besides missing a <code>zf.write(foldername)</code> before <code>for filename in filesnames</code>, it also zipped the local disk for some reason I could figure out.</span>
<span class="comment-copy">Note: you should avoid <code>import</code>s inside functions. Put the at the start of your module/script.</span>
<span class="comment-copy">@Bakuriu Thanks for the input - could you please help explain why this is better practice? Any other input on shortening/optimizing would be much appreciated as well.</span>
<span class="comment-copy">First of all to avoid repetition. If in a module you have 3 functions that need module <code>os</code> you don't want to add <code>import os</code> three times. Moreover putting the imports at the beginning of the file shows clearly the dependencies of a program. Anybody reading it can immediately know if some 3rd party libraries are required and which ones. Finally: hiding the imports means that if the user does not have that required library installed the <code>ImportError</code> gets triggered only when the function is called, which may make debugging harder; it's better to fail as early as possible.</span>
<span class="comment-copy">Also inside functions you cannot use the wildcard form: <code>from os import *</code> does not work inside a function definition but does at the module level.</span>
<span class="comment-copy">@Bakuriu Great explanation - thank you so much.</span>
