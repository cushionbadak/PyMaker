<div class="post-text" itemprop="text">
<p>I have read some posts on stackoverflow about how to check an object is an iterator in Python but it seems that they did not solve my question. I have this example from the book <em>Effective Python</em></p>
<pre><code>def normalize_defensive(numbers):
   if iter(numbers) is iter(numbers):  # An iterator — bad!
       raise TypeError(‘Must supply a container’)
   total = sum(numbers)
   result = []
   for value in numbers:
       percent = 100 * value / total
       result.append(percent)
   return result
</code></pre>
<p>To use:</p>
<pre><code>visits = [15, 35, 80]
normalize_defensive(visits)  # No error
visits = ReadVisits(path)  # ReadVisits is a class with an __iter__ method.
normalize_defensive(visits)  # No error
it = iter(visits)
normalize_defensive(it)
&gt;&gt;&gt;
TypeError: Must supply a container
</code></pre>
<p>So my question is in this line:</p>
<pre><code>if iter(numbers) is iter(numbers):  # An iterator — bad!
</code></pre>
<p>Why this line check if the variable numbers is an iterator? When visits = [15, 35, 80], should it be true that <code>iter(numbers) is iter(numbers)</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you call an <em>iterable</em>, calling <code>iter()</code> on such an object will always produce a <em>new</em> iterator object. But calling <code>iter()</code> on an <em>iterator</em> will always return the same object; it is a requirement of the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow">iterator protocol</a> that they do.</p>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="nofollow"><code>iterator.__iter__()</code> documentation</a>:</p>
<blockquote>
<p>Return the iterator object itself. This is required to allow both containers and iterators to be used with the <code>for</code> and <code>in</code> statements.</p>
</blockquote>
<p>Because <code>iter(iterable)</code> always returns <em>itself</em>, the test <code>iter(obj) is iter(obj)</code> will be true; the same object is returned in both cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>To help you understand Martijn's explanation, take a look at the following:</p>
<pre><code>&gt;&gt;&gt; numbers = [15, 35, 80]
&gt;&gt;&gt; it  = iter(numbers)
&gt;&gt;&gt; it2 = iter(numbers)
&gt;&gt;&gt; it3 = iter(it)
&gt;&gt;&gt; id(it1)
51123792
&gt;&gt;&gt; id(it2)
51056464    # id of it2 is different from it1
&gt;&gt;&gt; id(it3) 
51123792    # iterator of iterator it3 has the same id as iterator it1
</code></pre>
<p>So if <code>numbers</code> was an <code>iterator</code>, calling <code>iter</code> on <code>numbers</code> will always return objects that are internally identical: <code>iter(numbers) is iter(numbers)</code> will be <code>True</code>.</p>
</div>
<span class="comment-copy">Would <code>iter(obj) is obj</code> work as well?</span>
<span class="comment-copy">@StefanPochmann: it would.</span>
