<div class="post-text" itemprop="text">
<p>I am trying to loop between 0.01 and 10, but between 0.01 and 0.1 use 0.01 as the step, then between 0.1 and 1.0 use 0.1 as step, and between 1.0 and 10.0 use 1.0 as step.</p>
<p>I have the while loop code written, but want to make it more pythonic.</p>
<pre><code>i = 0.01
while i &lt; 10:
   # do something
   print i
   if i &lt; 0.1:
       i += 0.01
   elif i &lt; 1.0:
       i += 0.1
   else:
       i += 1
</code></pre>
<p>This will produce </p>
<pre><code>0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2, 3, 4, 5, 6, 7, 8, 9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A special-purse generator function might be the right way to go. This would effectively separate the boring part (getting the list of numbers right) from the interesting part (the <code># do something</code> in your example).</p>
<pre><code>def my_range():
    for j in .01, .1, 1.:
        for i in range(1, 10, 1):
            yield i * j

for x in my_range():
    print x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach would be to use two loops:  one for the order of magnitude, and one for the values from 1 to 9:</p>
<pre><code>for exp in range(-2, 1):
    for i in range(1, 10):
        print("{:.2f}".format(i * 10 ** exp))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could have a nested loop, the outer one that iterates over the precision and inner one that is just <code>range(1,10)</code>:</p>
<pre><code>for precision in (0.01, 0.1, 1):
    for i in range(1,10):
        i*=precision
        print(i)
</code></pre>
<p>However floats are probably not going to work in this case as this shows values like <code>0.30000000000000004</code> on my machine, for precise decimal values you would want to use the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow"><code>decimal</code></a> module:</p>
<pre><code>import decimal
for precision in ("0.01", "0.1", "1"):
    for i in range(1,10):
        i*=decimal.Decimal(precision)
        print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just a single line of code through list comprehension - </p>
<pre><code>for k in [i*j for j in (0.01, 0.1, 1) for i in range(1, 10)]
</code></pre>
<p>Can't be more pythonic!</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend a generator function as well, but if the steps are not such convenient powers of each other I'd write it like</p>
<pre><code>def my_range():
    i = 0
    while i &lt; 0.1:
        i += 0.01
        yield i
    while i &lt; 1:
        i += 0.1
        yield i
    while i &lt; 10:
        i += 1
        yield i

for x in my_range():
    print x
</code></pre>
<p>It might be a bit more repetitive, but illustrates much better what is going on and that the yielded values are monotonically increasing (regardless what numbers you put in).</p>
<p>If it gets too repetitive, use</p>
<pre><code>def my_range():
    i = 0
    for (end, step) in [(0.1, 0.01), (1, 0.1), (10, 1)]:
        while i &lt; end:
            i += step
            yield i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like:</p>
<pre><code>import numpy as np
list1 = np.arange(0.01, 0.1, 0.01)
list2 = np.arange(0.1, 1, 0.1)
list3 = np.arange(1, 10, 1)
i_list = np.concatenate((list1, list2, list3))  # note the double parenthesis
for i in i_list:
    ...
</code></pre>
<p>Basically you create the entire list of values that you need up front, <code>i_list</code>, then just iterate through them in your <code>for</code> loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just in case you wished to replace the loop with <strong>vectorized</strong> code...</p>
<pre><code>In [63]: np.ravel(10.**np.arange(-2, 1)[:,None] * np.arange(1, 10)[None,:])
Out[64]: 
array([ 0.01,  0.02,  0.03,  0.04,  0.05,  0.06,  0.07,  0.08,  0.09,
        0.1 ,  0.2 ,  0.3 ,  0.4 ,  0.5 ,  0.6 ,  0.7 ,  0.8 ,  0.9 ,
        1.  ,  2.  ,  3.  ,  4.  ,  5.  ,  6.  ,  7.  ,  8.  ,  9.  ])
</code></pre>
</div>
<span class="comment-copy">put that in a function and add a <code>yield i</code> as last instruction of the loop. That would be a generator, which you can iterate</span>
<span class="comment-copy">Watch out - incrementing by steps doesn't work very well with floating-point rounding constraints. You're likely to have boundary errors.</span>
<span class="comment-copy">@njzk2 - <code>yield</code> should be the <b>first</b> instruction in his loop, where the <code># do something</code> is now. His first value needs to be <code>.01</code>.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer">docs.python.org/2/library/decimal.html</a></span>
<span class="comment-copy">This mostly works. You do get odd results like <code>0.30000000000000004</code> though.</span>
<span class="comment-copy">Of course. That's the nature of floating-point arithmetic. <code>0.3</code> isn't  representable in a <code>float</code>.</span>
<span class="comment-copy">Yup, no surprise on my part. I made this comment for the OP.</span>
<span class="comment-copy">You can get slightly better results at the expense of a slight bit of clarity by using division instead of multiplication: <code>for j in 100., 10., 1.: for i in range(1, 10): yield i / j</code>. It doesn't matter much. The important thing is to avoid floating-point steps, and you're already doing that.</span>
<span class="comment-copy">yeah fixed that now too, jeez my head just isn't in it today.</span>
<span class="comment-copy">You don't need the assignment. OP wants to use this to drive a loop: <code>for x in (i*j for j in (.01, .1, 1.) for i in range(1,10)): print x</code></span>
<span class="comment-copy">Yeah right, just fixed it.</span>
<span class="comment-copy">:( it seems pretty contrived to have 3 <code>for</code> statements in a single line. I preferred it the other way.</span>
<span class="comment-copy">Like any other assignment, <code>+=</code> assignments are statements in Python; you can't <code>yield</code> them.</span>
<span class="comment-copy">@user2357112: Right, fixed.</span>
<span class="comment-copy">Numpy is way overkill for this problem</span>
<span class="comment-copy">Yes, my code can be regarded as kind of overkill if you just need to print out the numbers (BTW, mine isn't the only one NumPy-based solution proposed here). However, if the <code># do something</code> block involves a call to a time-consuming function which takes the generated values as argument, I think the vectorized code might be more efficient. Anyway, it is simply another possible approach that some users of SO could find useful.</span>
