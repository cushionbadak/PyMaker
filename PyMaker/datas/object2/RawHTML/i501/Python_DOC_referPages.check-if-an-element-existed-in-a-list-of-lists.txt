<div class="post-text" itemprop="text">
<p>The <code>group</code> function picks up <code>pp</code> from another big group. I want the program to say if any elements from <code>pp</code> existed in <code>rr</code>, I want to refuse it and call pick function again. If not append <code>rr</code> list with <code>pp</code>.</p>
<p>I have two lists like this:</p>
<pre><code>rr = [[1,2], [3,4], [5,6], [7,8]]
pp = [[7,9], [10, 11]]
</code></pre>
<p>and I have this function:</p>
<pre><code>for i in pp:
    for j in i:
        for k in rr:
            for h in k:
                while h == j:
                    pp = group(seq, 2)
    else:
        rr.append(pp)
</code></pre>
<p>Here <code>rr</code> contains 7 which existed in <code>pp</code>, must be refused. but the problem that it is still accepted. and <code>rr</code> still appended by this wrong <code>pp</code>.</p>
<p>If I do like this:</p>
<pre><code>for i in pp:
    for j in i:
        for k in rr:
            for h in k:
                while h == j:
                    pp = group(seq, 2)
                rr.append(pp)
    else:
        rr.append(pp)
</code></pre>
<p>It will still run forever without any output.</p>
<p>this is my soloution, it works, but i can't put it in answer:</p>
<pre><code>rr1 = [[1,2], [3,4], [5,6], [7,8]]
pp1 = [[7,9], [10, 11]]



# if any(p in rr for p in pp):
#    print("cant append")  #this will send it back to the function to pick up new pp
# elif any((i in p for i in range(len(pp))) in (j in rr for j in range(len(rr))) for p in pp ):
#     print("cant append")
# else:
#      rr.extend(pp)



def is_true(pp , rr):
    for i in pp:
        for j in rr:
            if any(p in j for p in i):
                return False 
    return True



def ext (pp , rr , tt ):
    if tt == True:
        rr.extend(pp)
    else:
        print("cant append")



tt = is_true(pp1, rr1)
ext(pp1, rr1, tt)
print(rr1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are checkin single integers from both lists of lists, you can do something like:</p>
<pre><code>from itertools import chain

def are_common_elements(rr, qq):
    return bool(set(chain(*rr))  &amp; set(chain(*qq)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not entirely sure what you're after.<br/>
But maybe this is something that you can work with:</p>
<pre><code>import itertools

rr = [[1,2], [3,4], [5,6], [7,8]]
pp = [[7,9], [10, 11]]  
result = []
ignore = []

for item in itertools.chain.from_iterable(pp):
    for pair in rr:
        if item in pair:
            print('Yepp, {} is in {}. Ignoring!'.format(item, pair))
            ignore.append(pair)
        elif not pair in result and pair not in ignore:
            result.append(pair)

print('Result: {}'.format(result))
</code></pre>
<p>itertools just flattens the "check list", so it's easier to work with the numbers. Then simply iterate over those and check which <code>rr</code> pairs contain invalid numbers. Store those invalid pairs in <code>ignore</code>.</p>
<p>If you don't want to ignore a pair, simply skip the ignore part.<br/>
But it will make sure that <code>[7, 8]</code> doesn't belong in your results - if for instance your <code>pp</code> looked like this: <code>pp = [[7,9], [8, 11]]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here another approach [<strong>Disclaimer</strong>: As the others I'm not entirely sure I understood your question correctly, please leave a comment if it is not what you want].</p>
<p>If any value in <code>rr</code> appears in <code>pp</code>,too, <code>pp</code> will not be appended, else <code>pp</code> will be appended.</p>
<pre><code>rr = [[1,2], [3,4], [5,6], [7,8]]
pp = [[7,9], [10, 11]]
do_append = 1
for rr_sublist in rr:
    for j in range(len(rr_sublist)):
        for pp_sublist in pp:
            for i in range(len(pp_sublist)):
                if pp_sublist[i] == rr_sublist[j]:
                    print("duplicate element found")
                    do_append = 0
if do_append:
    rr.append(pp)
print(rr)
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>duplicate element found
[[1, 2], [3, 4], [5, 6], [7, 8]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I approached  this way:</p>
<pre><code>def test_element_existed(list1, list2):
    a = set([j for i in range(len(list1)) for j in list1[i]])
    b = set([j for i in range(len(list2)) for j in list2[i]])
    #check if any element in set(a) and set(b) are common and print it
    print(bool(set(a) &amp; set(b)), set(a) &amp; set(b))
    return list(a.union(b) - a.intersection(b))
test_element_existed(rr, pp)
</code></pre>
<p>result:</p>
<pre><code>True {7}
[1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think I know what you are asking, but I'm not sure. Because the question is phrased awkwardly, for me anyway.</p>
<p>I think you want to use sets. Sets are a data-structure in python that control lists of unique elements. So it sounds like you want things in rr only to be in rr, if they are not already in pp?</p>
<p>So, I'd use a set for pp. Create a set of everything in pp:</p>
<pre><code>from itertools import chain
rr = []
pp = [[7,9], [10, 11]]
# create a unique set of elements from the lists in pp
unique_items_in_pp = set(chain(*pp))

def in_pp(items):
    """Takes an iterable, returns bool, True if an element of iterable is in pp"""
    return set(items).isdisjoint(unique_items_in_pp)

# reject anything into rr if in the set
print(list(filter(rr_add, [[1,2], [3,4], [5,6], [7,8]])))
</code></pre>
<p>Running this code:</p>
<pre><code>&gt;&gt;&gt;[[1, 2], [3, 4], [5, 6]]
</code></pre>
<p>Because I find the question a bit awkward, I've just thrown together a possible solution. It's not complete, but hopefully it shows the main benefit of using a <a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#set" rel="nofollow noreferrer"><strong>set</strong></a> </p>
</div>
<div class="post-text" itemprop="text">
<p>This is my solution, it works:<br/>
1- the group Function that choose the elements into groups:</p>
<pre><code>import random
from students.models import students

pars = students.objects.all()

def groupp (x, y):
    res = random.sample(x, y)
    while len(set([u.first_language for u in res])) &lt; y:
        res = random.sample(x, y)
    return res
</code></pre>
<p>2- the logic for accepting or Refusing that Group, then send the result to the view:</p>
<pre><code>def lession_group (request):
    results=[]
    parr = list(students.objects.all())
    pick = []
    picked = []
    final = []
    for i in range(4):
        pick = groupp (parr, 2)
        while pick in final or pick[::-1] in final or any(p in picked for p in pick):
            pick = groupp (parr, 2)
        final.append(pick)
        picked.extend(pick)
</code></pre>
</div>
<span class="comment-copy"><code>while h == j:</code> if it becomes <code>True</code>, it remains <code>True</code>; neither <code>h</code> not <code>j</code> is updated within. Maybe <code>if</code> (Disclaimer: I don't understand your question).</span>
<span class="comment-copy">I'm guessing you're not referring to <code>[7,9] in rr</code>, because in the example - that's not the case? Judging by the code, I'm guessing you want to see if any number in the inner lists, exists in any of the inner lists in <code>rr</code> for instance, <code>7</code> is in the last list of <code>rr</code>, and that should return <code>True</code>?</span>
<span class="comment-copy">@Torxed exactly what i want.</span>
<span class="comment-copy">@Austin i ve tried the if, still the same problem</span>
<span class="comment-copy">I have no idea what your end result should look like. Because in the question <code>pp</code> is appended to <code>rr</code>. And <code>seq</code> is never defined. But <code>pp</code> is replaced while you're iterating over it, so it's hard for us to guess. But I left a working example where you get a list of results at the end, not sure if that's what you were looking for.</span>
<span class="comment-copy">It will only give you <code>True</code> or <code>False</code> if there are occurrences on both sides, but it's a neat function :)</span>
<span class="comment-copy">Thanks. Can remove the <code>bool()</code> wrapping and return a set of the common elements..</span>
<span class="comment-copy">True, altho then it will only print out the number that exists in both cases. Again, it's very unclear what OP wants to achieve here. So depending on the refined request later, this might be an invalid solution if OP or anyone else needs a cleaned list of non-triggered items from either one of the lists. Again, great use of <code>set</code>, and it's elegant as hell. Just hope people don't down vote this beautiful piece of code later if OP changes the question hehe.</span>
<span class="comment-copy"><code>NameError: name </code>incoming` is not defined.` - Not sure what <code>incoming</code> is supposed to be in this example?</span>
<span class="comment-copy">Would be nice of you if you made the code run:able at least. Good idea to use sets tho!</span>
<span class="comment-copy">Fair enough, yeah, I've made it runnable.</span>
