<div class="post-text" itemprop="text">
<p>I've started a project that requires and uses websockets to send information from server X to client Y, as intended.</p>
<p>However, I kept running into the issue where every 20 or so seconds the connection would be dropped since that's how TCP/IP is meant to be, so I need to send <em>heartbeats</em> per se.</p>
<p>Before I go on, if there's some other way of doing this (apart from sending a heartbeat) please let me know.</p>
<hr/>
<p>So the methodology I was going about to make the websocket before sending heartbeats was as such:</p>
<pre class="lang-py prettyprint-override"><code>async def listener(websocket, path, service):
  command = service['log_command']
  p = subprocess.Popen(command, stdout=subprocess.PIPE, bufsize=1, shell=True)
  prev_sd = "-1"
  await heartbeat_manager(websocket)
  asyncio.sleep(5)
  while True:
    await websocket.send(p.stdout.readline())
</code></pre>
<p>The <code>while True</code> and after is all that we care about, my intention is to have the websocket send a heartbeat of some text every 5 seconds but don't know where at all to get started.</p>
<p>Sidenote: There's another function that I call that actually runs this websocket, but it's irrelevant to the question so I did not include it, but rest assured; it does exist (and all of this code is functional, but only for 20ish seconds before dying).</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using Python's async/await mechanism, perhaps you could try using <a href="https://docs.python.org/3/library/asyncio-subprocess.html" rel="nofollow noreferrer">asyncio subprocesses</a> to let you await a subprocess's output streams. The following example code spawns the subprocess and checks for new lines available on standard output with a 5 second timeout, using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer"><code>asyncio.wait_for()</code></a>; if no data is available to send, we deliver a heartbeat instead.</p>
<pre class="lang-py prettyprint-override"><code>import asyncio

async def listener(websocket, path, service):
    command = service['log_command']
    p = await asyncio.create_subprocess_shell(command, stdout=asyncio.subprocess.PIPE)
    ...
    while True:
        try:
            data = await asyncio.wait_for(p.stdout.readline(), timeout=5)
            websocket.send(data)
        except asyncio.TimeOutError:
            await websocket.send("heartbeat")
</code></pre>
</div>
<span class="comment-copy">Thanks for the response, this results in <code>RuntimeError: Cannot add child handler, the child watcher does not have a loop attached</code></span>
<span class="comment-copy">If you're not running this from the main thread, there are <a href="https://docs.python.org/3/library/asyncio-subprocess.html#subprocess-and-threads" rel="nofollow noreferrer">limitations</a>. Otherwise, you could try adding a watcher to your loop <a href="http://www.decodednode.com/2018/11/asyncio-neweventloop-and-child-watchers.html" rel="nofollow noreferrer">manually</a></span>
<span class="comment-copy">That would be the reason, I'm running this subprocess inside a thread; although the link to attach the child watcher didn't exactly click for me mentally, mind explaining? Thanks!</span>
