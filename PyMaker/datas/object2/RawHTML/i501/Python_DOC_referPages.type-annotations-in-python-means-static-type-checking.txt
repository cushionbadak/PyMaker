<div class="post-text" itemprop="text">
<p>I am looking at <code>typing</code> module from python because I hope to enforce some static type checking in a project written in python. </p>
<p>When I define a function like <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">the one from the doc</a></p>
<pre><code>def greeting(name: str) -&gt; str:
    return 'Hello ' + name
</code></pre>
<p>and try to do something like <code>greeting(3)</code>, I indeed got the following error</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in greeting
TypeError: must be str, not int
</code></pre>
<p>But when I again define a function called <code>test</code></p>
<pre><code>def test(a: int) -&gt; None:
    print(a)
</code></pre>
<p>and do <code>test("a")</code>, I have <code>a</code> printed without any errors raised. I also tried </p>
<pre><code>def test(a: str) -&gt; None:
    print(a)
</code></pre>
<p>and do <code>test(3)</code>, but no TypeError is raised.</p>
<p>I defined both functions in exactly the same environment, i.e. an interaction python session using iTerm. Why would this happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>The clue here is in the line number: the error is occurring inside the function, when you try to add <code>'Hello'</code> and <code>3</code>. The type annotations are checked for syntactic correctness by the interpreter, but are not otherwise actioned.</p>
<p>There are projects like <a href="http://mypy-lang.org/" rel="nofollow noreferrer"><code>mypy</code></a> that use the annotations for status type checking and various other purposes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Type annotations in python <strong>DO NOT</strong> enforce static type checking.</p>
<p>Python's still a dynamic language, where the interpreter checks whether it has a method to do the operation, add a str ("hello") and add an integer (3), when it reaches this line during the execution loop. <a href="http://%20https://www.python.org/dev/peps/pep-0484/#non-goals" rel="nofollow noreferrer">Pep-484</a> states the core-developers don't want to change this with annotations.</p>
<p>If you look at the documentation, it is called <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">'type hints'</a>. Hints are not enforcement.</p>
<p>Type hints are really for developers and their tools (like IDEs) to better document the expected type of a parameter. But adding this form of documentation does not place any restriction the argument. It is <strong>merely documentation</strong>. In fact, <em>it's best to think of these annotations as documentation</em>.</p>
<p>The error you are seeing happens without those annotations. E.g.</p>
<pre><code>&gt;&gt;&gt; "Hello" + 3
Traceback (most recent call last):
   File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "int") to str
</code></pre>
<p>It is possible to develop tools to do this if you want. The annotation on the object's  </p>
<pre><code>__annotations__
</code></pre>
<p><strong>Why is it like this?</strong>
In python, we generally don't do explicit type checks. Instead, we just try to call the method, like "add 'hello' and 3" and let there be an error. It's up to the caller of the function to provide the correct types. But this also means it's up to the writer of the function to document the parameter accurately. Type hints help describe the expected type, and make it available on the object, which is useful for other tools to then hook into. Previously, we'd write this stuff as documentation, like:</p>
<pre><code>def greeting(name):
    """Greeting to name
    :param name: str, the name to greet
    Returns string"""
    return "hello" + name
</code></pre>
<p><strong>Use duck typing to help you out</strong>
The type error you've raised would be avoided if you used built-in string formatting or cast the incoming value to a string before calling add. For example, to avoid the error you saw, you could:</p>
<pre><code> def greeting(name: str) -&gt; str:
    """Greeting to name
    :param name: str, the name to greet
    Returns string"""
    return "hello" + str(name)

def greeting(name: str) -&gt; str:
    """Greeting to name
    :param name: str, the name to greet
    Returns string"""
    return "hello {}".format(name)
</code></pre>
</div>
<span class="comment-copy">The TypeError raised by greeting is coming from adding an integer to a string, not due to the typechecking</span>
<span class="comment-copy">But then what does the doc mean by "static type checker" if type annotations do not enforce type checking at all?</span>
