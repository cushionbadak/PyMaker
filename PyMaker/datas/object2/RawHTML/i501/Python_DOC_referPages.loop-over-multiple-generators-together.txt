<div class="post-text" itemprop="text">
<p>I need to get the result of each generator at the same time but the number of generators can be anything from 1 to 10.</p>
<p>My question is probably related to this question: <a href="https://stackoverflow.com/questions/20910213/loop-over-two-generator-together">Loop over two generator together</a></p>
<p>Is it possible to generalize this for an arbitrary number of generators which are in a list? Something like (not working)</p>
<pre><code>generators = [gen1, gen2, gen3, ....]
for *data in *generators:
    #do something, e.g. average data along axis and write out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>IIUC you want <code>zip</code> for this. Here's a simple example taking the sum:</p>
<pre><code>generators = [(1,2), (3,4), (5,6)]
[sum(i) for i in zip(*generators)]

# [9, 12]
</code></pre>
<hr/>
<p>Or <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> as @alexis suggests, if the generators could differ in length and you'd like to iterate until the longest one is consumed:</p>
<pre><code>generators = [(1,2), (3,4), (5,6,0)]
[sum(i) for i in zip_longest(*generators, fillvalue=0)]
# [9, 12, 0]
</code></pre>
</div>
<span class="comment-copy"><code>chain</code> consumes the iterables one <i>after</i> the other, it's the wrong tool.</span>
<span class="comment-copy">Unfortunately not because it says "returns elements from the first iterable until it is exhausted, then proceeds to the next iterable". But it should return the first element of each iterable and then the second and so on</span>
<span class="comment-copy">You might need to look into <code>zip</code> as it is posted in an answer to question you linked in your question.</span>
<span class="comment-copy"><code>for a, b in zip(it1, it2)</code> to consume them at the same time, <code>itertools.chain</code> to iterate the first then the second and so on.</span>
<span class="comment-copy">Or <code>itertools.izip_longest</code>, for maximum robustness.</span>
<span class="comment-copy">It's not more robust, it's just different. Whether <code>zip</code> or <code>izip_longest</code> is appropriate is something you need to decide for each use case. (And most of the time, you are zipping lists that have--or are <i>supposed</i> to have--the same length.)</span>
<span class="comment-copy">Again, it's not more robust. Your use-case determines if (using <code>[[1,2,3], [4,5]]</code> as an example) ignoring the <code>3</code> from the first list or pairing it with some extra value like <code>(3, None)</code> is the <i>correct</i> thing to do.</span>
