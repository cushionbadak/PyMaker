<div class="post-text" itemprop="text">
<p>Common Lisp has <a href="http://clhs.lisp.se/Body/m_defpar.htm" rel="nofollow noreferrer"><code>defvar</code></a> which
creates a global variable but only sets it if it is new: if it already
exists, it is <em>not</em> reset. This is useful when reloading a file from a long running interactive process, because it keeps the data.</p>
<p>I want the same in Python.
I have file <code>foo.py</code> which contains something like this:</p>
<pre><code>cache = {}
def expensive(x):
    try:
        return cache[x]
    except KeyError:
        # do a lot of work
        cache[x] = res
        return res
</code></pre>
<p>When I do <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer"><code>imp.reload(foo)</code></a>, the value of <code>cache</code> is lost which I want
to avoid.</p>
<h1>How do I keep <code>cache</code> across <code>reload</code>?</h1>
<p><strong>PS</strong>. I guess I can follow <a href="https://stackoverflow.com/q/843277/850781">How do I check if a variable exists?</a> :</p>
<pre><code>if 'cache' not in globals():
   cache = {}
</code></pre>
<p>but it does not look "Pythonic" for some reason... 
If it <em>is</em> TRT, please tell me so!</p>
<h2>Answering comments:</h2>
<ul>
<li>I am <em>not</em> interested in cross-invocation persistence; I <em>am</em> already handling that.</li>
<li>I <em>am</em> painfully aware that reloading changes class meta-objects and I <em>am</em> already handling that.</li>
<li>The values in <code>cache</code> are huge, I cannot go to disk every time I need them.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Here are a couple of options. One is to use a temporary file as persistent storage for your cache, and try to load every time you load the module:</p>
<pre><code># foo.py
import tempfile
import pathlib
import pickle

_CACHE_TEMP_FILE_NAME = '__foo_cache__.pickle'
_CACHE = {}

def expensive(x):
    try:
        return _CACHE[x]
    except KeyError:
        # do a lot of work
        _CACHE[x] = res
        _save_cache()
        return res

def _save_cache():
    tmp = pathlib.Path(tempfile.gettempdir(), _CACHE_TEMP_FILE_NAME)
    with tmp.open('wb') as f:
        pickle.dump(_CACHE, f)

def _load_cache():
    global _CACHE
    tmp = pathlib.Path(tempfile.gettempdir(), _CACHE_TEMP_FILE_NAME)
    if not tmp.is_file():
        return
    try:
        with tmp.open('rb') as f:
            _CACHE = pickle.load(f)
    except pickle.UnpicklingError:
        pass

_load_cache()
</code></pre>
<p>The only issue with this is that you need to trust the environment not to write anything malicious in place of the temporary file (the <code>pickle</code> module is not secure against erroneous or maliciously constructed data).</p>
<p>Another option is to use another module for the cache, one that does not get reloaded:</p>
<pre><code># foo_cache.py
Cache = {}
</code></pre>
<p>And then:</p>
<pre><code># foo.py
import foo_cache

def expensive(x):
    try:
        return foo_cache.Cache[x]
    except KeyError:
        # do a lot of work
        foo_cache.Cache[x] = res
        return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the whole point of a reload is to ensure that the executed module's code is run a second time, there is essentially no way to avoid some kind of "reload detection."</p>
<p>The code you use appears to be the best answer from those given in the question you reference.</p>
</div>
<span class="comment-copy">Why not use a different scope? Create a <code>get_cache</code> function in <code>foo,py</code> and store the cache in the same file you call <code>imp.reload()</code></span>
<span class="comment-copy">I suppose the easiest way would be to use dump a json file</span>
<span class="comment-copy">This is the key: <code>If a module instantiates instances of a class, reloading the module that defines the class does not affect the method definitions of the instances — they continue to use the old class definition. The same is true for derived classes.</code></span>
<span class="comment-copy">The code you've provided in your PS looks like it absolutely should work, have you tried it? "When a module is reloaded, its dictionary (containing the module’s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module’s advantage if it maintains a global table or cache of objects". But reloading is probably a bad idea anyway, avoid it if you can.</span>
<span class="comment-copy">You can use <i>persistent storage</i>, a.k.a. the file system, and just <code>pickle</code> the contents of the variable.</span>
<span class="comment-copy">I think the <code>foo_cache</code> solution is perfect. I hate it that one has to create a separate file for that, but, I guess, I will have to live with it.</span>
