<div class="post-text" itemprop="text">
<p>There is an existing class whose <code>__init__()</code> already takes a varying number &amp; types for its arguments.  I wish to subclass to add a new argument.  I do not know how I am intended to write the subclass's new <code>__init__()</code> <em>definition</em>.</p>
<p>I do not have the source for the existing base class (it's probably written in C++).  <code>help(QListWidgetItem)</code> gives me:</p>
<pre><code>class QListWidgetItem(sip.wrapper)
 |  QListWidgetItem(parent: QListWidget = None, type: int = QListWidgetItem.Type)
 |  QListWidgetItem(str, parent: QListWidget = None, type: int = QListWidgetItem.Type)
 |  QListWidgetItem(QIcon, str, parent: QListWidget = None, type: int = QListWidgetItem.Type)
 |  QListWidgetItem(QListWidgetItem)
</code></pre>
<p>My editor (PyCharm) recognises these and offers context-sensitive completion.  It behaves as though they have been declared via <code>@overload</code> directives, and I wish to retain that.</p>
<p>Note that already not only is the number of arguments variable but also so are the types. For example, looking through all the overloads parameter #1 might be a <code>QListWidget</code>, a <code>str</code>, a <code>QIcon</code> or a <code>QListWidgetItem</code>, or not even supplied, and depending on that influences what the second argument can be, etc.</p>
<p>I wish to add an extra one:</p>
<pre><code>MyListWidgetItem(text: str, value: QVariant, parent: QListWidget = None, type: int = QListWidgetItem.Type)
</code></pre>
<p>Note that my new <code>QVariant</code> argument is in second place, and I wish it to be positional not keyword-named.</p>
<p>So I need to recognise this new one when it's called; I need to pull out my new <code>value: QVariant</code> to set my new member variable, I also need to remove it before calling the base class constructor . </p>
<p>I know that for the <em>declaration</em> I will be adding an <em>overload</em> like:</p>
<pre><code>class MyListWidgetItem(QListWidgetItem)
    @overload
    def __init__(self, text: str, value: QVariant, parent: QListWidget=None, type: int=QListWidgetItem):
        pass
</code></pre>
<p>(I assume that will leave the existing <code>QListWidgetItem</code> <code>@overload</code>s still available via my derived <code>MyListWidgetItem</code>s?)</p>
<p>What about for the actual <em>definition</em>?  What does it do and how should it be declared/written?</p>
<p>I need to recognise this new one when it's called; I need to pull out my new <code>value: QVariant</code> to set my variable, I also need to remove it before calling the base class constructor.</p>
<p>I can only guess: is it my job in order to recognise my case to write like:</p>
<pre><code>if len(arguments) &gt;= 2:
    if isinstance(arguments[0], str) and isinstance(arguments[1], QVariant):
        self.value = arguments[1]
        del arguments[1]
</code></pre>
<p>Then: Am I supposed to write the single <code>__init__()</code> definition (<em>not</em> <code>@overload</code> declarations) for my new sub-class along the lines of:</p>
<pre><code>def __init__(self, *__args)
    ...
    super().__init__(*__args)
</code></pre>
<p>or with distinct, explicit, typed arguments along the lines of:</p>
<pre><code>def __init__(self, arg1: typing.Union[QListWidget, str, icon, QListWidgetItem, None], arg2: typing..., arg3: typing..., arg4)
    ...
    super().__init__(arg1, arg2, arg3, arg4)
</code></pre>
<p>The latter looks complicated?  Is the former approach declaring and working directly off <code>*__args</code> the best way to go?</p>
<p>[<strong>EDIT</strong>: If it makes any difference for producing some kind of solution, I am willing to make my new parameter optional via <code>value: QVariant = ...</code>.  Or, if the answer is, say, "You won't be able to do it quite your way because ..., but the better way to do this is to make it a named-keyword-only argument because then you can ...", or whatever, I would consider in that light.]</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two somewhat separate issues here.</p>
<p>The first is specific to PyCharm and it's use of the <a href="https://docs.python.org/3/library/typing.html#module-typing" rel="nofollow noreferrer">typing module</a>. It generates pyi files with stubs defining the APIs of various third-party libraries (such as PyQt) so that it can provide auto-completion and such like. In addition, it supports <em>user-defined</em> type-hints and pyi files, which are documented here: <a href="https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html" rel="nofollow noreferrer">Type Hinting in PyCharm</a>. However, since I am not a PyCharm user, I cannot give any practical advice on exactly how you should define your own overload stubs so that they augment the existing PyQt ones. I assume it must be possible, though.</p>
<p>The second issue concerns exactly how to implement function overloads for existing PyQt APIs. The short answer to this is that you can't: Python simply does not support overloads in the same way that C++ does. This is because Python is dynamically typed, so that type of overloading makes no sense there. However, it is possible to work around this in various ways to provide equivalent behaviour.</p>
<p>For your specific case, the simplest solution demands a small compromise. Your question states: "Note that my new QVariant argument is in second place, and I wish it to be positional not keyword-named". If you're willing to forgo this requirement, it makes things <em>a lot</em> easier, because you can then define your sub-class like this:</p>
<pre><code>class MyListWidgetItem(QListWidgetItem):
    def __init__(self, *args, value=None, **kwargs):
        super().__init__(*args, **kwargs)
</code></pre>
<p>or like this:</p>
<pre><code>class MyListWidgetItem(QListWidgetItem):
    def __init__(self, *args, **kwargs):
        value = kwargs.pop('value', None)
        super().__init__(*args, **kwargs)
</code></pre>
<p>These sub-classes will support all the existing PyQt overloads without ever needing to know exactly how they are defined, since you are simply passing on the arguments to the base implementation. It is entirely up to the user to supply the correct arguments, but since the base class is provided by PyQt, it will automatically raise a <code>TypeError</code> if the wrong ones are given. This all helps to keep the implementation very simple, but it does put a premium on documenting your APIs properly, given that the function signature itself provides little or no hint about what the correct arguments should be. However, if you can also find a way to utilise PyCharm's type-hinting support as suggested above, that should get you pretty close to a very simple, workable solution.</p>
<p>But what if you weren't willing to compromise? The immediate problem this raises can be seen if you consider this signature:</p>
<pre><code>QListWidgetItem(parent: QListWidget = None, type: int = QListWidgetItem.Type)
</code></pre>
<p>This permits creating an item with <em>no arguments</em>. But that immediately clobbers any new overload which defines <em>required</em> arguments, since Python will raise a <code>TypeError</code> if they are missing when the constructor is called at runtime. The only way to work around this is to use an <code>*args, **kwargs</code> signature and then explicitly check the number and type of all the arguments in the body of the <code>__init__</code>. Effectively, this is what <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer">functools.singledispatch</a> and third-party packages like <a href="https://pypi.org/project/multipledispatch/" rel="nofollow noreferrer">multipledispatch</a> do, only via decorators. This doesn't really by-pass the above problem, though - it just moves it elsewhere and saves you having to maintain a whole load of complicated boiler-plate code.</p>
<p>I'm not going to give any dispatch-style examples here: firstly because I have no idea how they will play out in PyCharm (or even PyQt, for that matter), and secondly because they have already been covered in more generic SO questions like this one: <a href="https://stackoverflow.com/questions/6434482/python-function-overloading">Python function overloading</a>. My advice would be to start with the much simpler implementation given above, and then consider experimenting with the other approaches if you find you <em>really</em> need to add overloads with non-keyword arguments.</p>
<p>One final approach to consider is what might be called The Standard Kitchen-Sink Overload. In this approach, you simply forget about the signatures of the existing APIs and define your sub-class something like this:</p>
<pre><code>class MyListWidgetItem(QListWidgetItem):
    def __init__(self, text='', value=None, parent=None, icon=None,
                       item=None, type=QListWidgetItem.Type):
        if item is not None:
            super().__init__(item)
        elif icon is not None:
            super().__init__(icon, text, parent, type)
        else:
            super().__init__(text, parent, type)
</code></pre>
<p>Or if you don't care about <code>type</code> and the copy-constructor:</p>
<pre><code>class MyListWidgetItem(QListWidgetItem):
    def __init__(self, text='', value=None, parent=None, icon=None):
        if icon is not None:
            super().__init__(icon, text, parent)
        else:
            super().__init__(text, parent)
</code></pre>
<p>The vast majority of Python/PyQt code probably uses some variation of this kind of approach. Thus, <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">practicality beats purity</a>, I guess...</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no one-size-fits-all answer, and pyQt (which is really a thin layer above Qt and exposes quite a few C++ idioms) is not necessarily representative of the most common use cases. </p>
<p>As a general rule, it's considered better practice to explicitely copy (and extend) the parent class's initializer prototype, so you (generic "you" -&gt; anyone having to maintain the code) don't necessarily have to read the parent class doc etc to know what's expected.</p>
<p>Now in some cases where </p>
<ul>
<li>the parent class takes a lot of arguments </li>
<li><strong>and</strong> your subclass doesn't mess with those arguments </li>
<li><strong>and</strong> your subclass only wants to ADD arguments </li>
<li><strong>and</strong> it's ok for you / your team to add those arguments as keyword-only arguments or to force them to come before any of the parent's ones</li>
<li><strong>and</strong> it's ok for you / your team to give up on autodoc / type hints etc</li>
</ul>
<p>then using <code>*args</code> and <code>**kwargs</code> is indeed a solution:</p>
<pre><code>def __init__(self, my_positional_arg, *args, **kwargs)
    # use .pop() to avoid passing it to the parent
    my_own_kw_arg = kw.pop("my_own_kw_arg", "nothing")
    super().__init__(*args, **kwargs)
</code></pre>
<p>Note that you <strong>really</strong> want to support <strong>both</strong> <code>*args</code> and <code>**kwargs</code> in this case, as even required positional args can be passed as named arguments, and that's most often how they're actually passed when the class (or function FWIW) takes a lot of arguments (it's easier to remember names than positions...). </p>
</div>
<span class="comment-copy">Thank you so much for this detailed explanation, it's what I was looking for and clarifies a lot.  Since my only exposure to Python (I'm a C-family-member) is with PyQt, and PyCharm editor, I don't know where it's "un-pythonic" and just try to work with it as I find it.  I had already come to the conclusion that what I (thought I) wanted is too difficult/messy to do and had changed over to <code>def __init__(self, *args, value=None, **kwargs):</code>, which works and suffices.  But your answer confirms what I thought is going on, and is very helpful.</span>
<span class="comment-copy">This won't work, because for some of the pre-existing overloads, <code>my_positional_arg</code> will eat a parameter that should be included in <code>*args</code>. Also, there are some pre-existing overloads that do not require <i>any</i> arguments, whereas your definition always enforces at least one.</span>
<span class="comment-copy">@ekhumoro as I said "there's not one-size-fits-all answer, and pyQt (which is really a thin layer above Qt and exposes quite a few C++ idioms) is not necessarily representative of the most common use case". This <code>@overload</code> thingie is typicall C++ stuff and quite unpythonic indeed.</span>
<span class="comment-copy">Well, I think this is rather a case of "no-size-fits-anything". The OP is asking for a function definition that enforces <i>two required arguments</i> as well as allowing for some overloads with <i>no required arguments</i>. In python, this is just plain impossible, since you can't avoid the type-error from the missing arguments. The OP needs to have a re-think and accept that some compromises are inevitable when trying to fake c++ idioms in pure python.</span>
<span class="comment-copy">Python doesn't natively support function overloading at all FWIW - but with some proper multidispatch implementation (which  assume is what this <code>overload</code> decorator is for) then I don't see why it couldn't have both a version with no argument and one with two... But anyway, my answer was intended as a generic answer, not as a Qt specific one. If PyQT makes it impossible to use common Python idioms then I can't do much about it actually &lt;g&gt;</span>
<span class="comment-copy">@JonBrave well sorry for the somewhat "generic" answer but the fact is that pyQT "overload" system is rather specific and not representative of how those issues are handled in plain Python - which is why I added the pyqt tag to your question so hopefully someone more knowledgeable might post a more specific answer.</span>
