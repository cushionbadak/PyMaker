<div class="post-text" itemprop="text">
<p>This might be a really strange question but nevertheless,</p>
<p>Consider a variable called <strong>a</strong>.
Let us now assign it a value as follows:</p>
<pre><code>a = 1
</code></pre>
<p>Let us now change the value of <strong>a</strong> now.</p>
<pre><code>a = 3
</code></pre>
<p>Is there any way in Python to know the previous value of a variable without storing it in another variable.Does python internally maintain a sort of a ledger of all the values of a variable during its lifetime that can be accessed ?</p>
</div>
<div class="post-text" itemprop="text">
<h1>Answer: actually, we CAN</h1>
<p>But not in general case. </p>
<p>You need some magick for this.</p>
<p>And magick is called  "custom namespaces".</p>
<p>Whole idea is from Armin Ronacher presentation <a href="http://mitsuhiko.pocoo.org/badideas.pdf" rel="noreferrer">5 years of Bad Ideas</a>.</p>
<h1>Magick: custom namespace with history of values</h1>
<p>Let's create custom namespace that saves history of values.</p>
<p>For demonstration purposes let's change rule for <code>__del__</code> - instead of deleting values we will insert None.</p>
<pre><code>from collections import MutableMapping
class HistoryNamespace(MutableMapping):
    def __init__(self):
        self.ns = {}        
    def __getitem__(self, key):
        return self.ns[key][-1]  # Rule 1. We return last value in history 
    def __delitem__(self, key):
        self.ns[key].append(None) # Rule 4. Instead of delete we will insert None in history
    def __setitem__(self, key, value): # Rule 3. Instead of update we insert value in history
        if key in self.ns:
            self.ns[key].append(value)            
        else:
            self.ns[key] = list([value,]) # Rule 2. Instead of insert we create history list
    def __len__(self):
         return len(self.ns)
    def __iter__(self):
         return iter(self.ns)    

history_locals = HistoryNamespace()        
exec('''
foo=2
foo=3
del foo  
foo=4
print(foo)
''', {}, history_locals)
print("History of foo:", history_locals.ns['foo'])
</code></pre>
<p>Rejoice!</p>
<p>Custom namespaces is very powerful technique but almost never used.</p>
<p>The fact I find somewhat puzzling.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer <strong>No</strong>, long answer <strong>Yes, if you do it yourself</strong>.</p>
<hr/>
<p><strong>NO</strong></p>
<p>The precise handling (dict, array, ...) of <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">local names</a> is implementation defined, but <em>for all intents and purposes</em> the history of a name is not tracked. None of the major implementations provide this functionality.</p>
<p>As far as the Python language is concerned, an object not assigned to a name is gone. In practice, garbage collection is free to claim any ambient object not currently bound to a name. Whether this happens <a href="https://www.python.org" rel="nofollow noreferrer">immediately</a> or <a href="https://pypy.org" rel="nofollow noreferrer">at an arbitrary time</a> does not change that such objects are off limits for Python code. Otherwise, Python would have to keep a significant share of dead objects alive.</p>
<p><em>Once a name is re-asigned, its previous referent is gone from it.</em></p>
<hr/>
<p><strong>Yes, but please don't do it unless your really have to</strong></p>
<p>There are various ways to hook into the execution of Python code. For example, you can intercept calls/lines/returns by using <a href="https://docs.python.org/3/library/sys.html#sys.settrace" rel="nofollow noreferrer"><code>sys.settrace</code></a>; this is how debuggers work, and can inspect anything. If you have control over how the actual code is executed, see <a href="https://stackoverflow.com/a/54744937/5349916">Alex Yu's answer</a> for a way to hook just into the namespace.</p>
<pre><code>import sys

class LocalsTracer:
    """Tracer for local assignment that prints the history of names"""
    def __init__(self, frame, event, arg):
        assert event == "call"
        # identifier for the call we are tracing - name, file, line
        self.subject = "%s (%s:%s)" % (frame.f_code.co_name, frame.f_code.co_filename, frame.f_code.co_firstlineno)
        self.names = {}

    # tracer gets *called* by the interpreter
    def __call__(self, frame, event, arg):
        if event == "line":
            self.trace_names(frame, event, arg)
        elif event in ("return", "exception"):
            self.trace_names(frame, event, arg)
            self.trace_exit(frame, event, arg)
        else:
            raise RuntimeError("Invalid event: %r" % event)

    def trace_names(self, frame, event, arg):
        """Capture modifications of names and store their history"""
        for name, value in frame.f_locals.items():
            try:
                if self.names[name][-1] != value:
                    self.names[name].append(value)
            except KeyError:
                self.names[name] = [value]
        return self

    def trace_exit(self, frame, event, arg):
        """Report the current trace on exit"""
        print("exit", self.subject, "via", event)
        print(self.names)

# trace targets can be defined regularly, anywhere
def bar(b):  # tracer captures function parameters
    b = 4

def foo():
    a = 1
    b = 2
    bar(27)  # tracer can recurse
    a = 3

sys.settrace(LocalsTracer)  # start tracing locals assignment
foo()
sys.settrace(None)          # stop tracing
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>No</strong>. There is no way to know the previous value of a variable without assigning to the object another variable. Only the presence of references keeps an object alive in memory. The garbage collector disposes of the object, when the reference count of the object reaches zero.</p>
<p>However, according to the example from <a href="http://shop.oreilly.com/product/0636920032519.do" rel="nofollow noreferrer"><strong>Fluent Python</strong> by Luciano Ramalho</a> it's possible in a console session using a weak reference to an object (weak reference doesn't increase the reference count of the object!):</p>
<pre><code>&gt;&gt;&gt; import weakref
&gt;&gt;&gt; a = {0, 1}
&gt;&gt;&gt; wref = weakref.ref(a)
&gt;&gt;&gt; wref()
{0, 1}
&gt;&gt;&gt; a = {2, 3}
&gt;&gt;&gt; wref()
{0, 1}
</code></pre>
<h3>VS</h3>
<pre><code>import weakref

a = {0, 1}
wref = weakref.ref(a)
print(wref())

a = {2, 3}
print(wref())
</code></pre>
<p>Output:</p>
<pre><code>{0, 1}
None
</code></pre>
<p>The trick is that Python console automatically assigns the variable <code>_</code> to the result of expressions, which are not <code>None</code></p>
</div>
<span class="comment-copy">You could store the previous value in another variable...?</span>
<span class="comment-copy"><i>Does python internally maintain a sort of a ledger of all the values of a variable during its lifetime that be accessed?</i> No, it does not.</span>
<span class="comment-copy">Why do you want this? Give some context, I can't think of any practical reason</span>
<span class="comment-copy">Two points. 1. Python does not do this but it's fairly easy to make your own class, override <code>__setattr__</code> or <code>__setitem__</code> to keep a log of previous values. and use that. 2. I get the feeling that your question is an instance of the <a href="http://xyproblem.info/" rel="nofollow noreferrer">xy problem</a>. Perhaps you can tell us what you're trying to do instead?</span>
<span class="comment-copy">@NoufalIbrahim Imagine say: a) Rounding namespace - namespace where all arithmetical operations are rounded to some <code>ndigits</code> on <b>every</b> step (example from F#) , b) Serializing namespace - imitation of MUMPS so-called "global" variables: variables that serialized to storage on each <code>__setvalue__</code>. Variables that can live between program restarts. Majority of python programmers are just not aware of possibilities to implement such things</span>
<span class="comment-copy">Actually my answer is not so simplified: one can run in custom namespaces .. please correct me but I suppose that almost every python program. I start to think "what is can't be run in customized namespaces?"</span>
<span class="comment-copy">@AlexYu Don't get me wrong, I think your approach very appropriate for most cases. Still, it requires control over how the source code is handled - one must feed it to <code>exec</code>. A tracer can be used on existing objects, even when the source is not available. Most importantly, tracers supports arbitrary levels of nesting both in how code is structured and executed.</span>
<span class="comment-copy">I'm not defending "my approach". I just think: a) every <code>import</code> is just an <code>exec</code> in disguise, b) <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer">imports</a> allows namespace customization too. So: we don't have any limits for using customized namespaces for programs of any complexity. Am I wrong here? Please tell me</span>
<span class="comment-copy">@AlexYu The limit is that one must <i>change</i> the <code>import</code> statement to an <code>exec</code> statement, <i>before</i> it is executed. So inspection needs full control over how the code is executed. A tracer on the other hand can be installed <i>after</i> code execution, and doesn't even need the code to be accessible (e.g. in a REPL, generated code, generated objects). Note that a tracer can also inspect returns, exceptions and even opcodes.</span>
<span class="comment-copy">Ah, I understood your point. Of cause <code>sys.settrace</code>, <code>frame</code> manipulation and such are better suited for some cases. Anyway I don't think somebody seriously will try to implement something like TransactionalMemory in python. Oh.. wait! I just remembered that something similar was attempted in <code>pypy</code>!</span>
<span class="comment-copy">I'm not sure if this is correct and relevant, the reference count of small integers (like in the example) is not zero after <code>a</code> is re-assigned, the integers are still alive in memory but not bound to <code>a</code></span>
<span class="comment-copy">@Chris_Rands The value and even the existence of reference counts, as well as the lifetime of unreachable objects, is purely implementation defined. For all intents and purposes an unreachable object is observably gone, however.</span>
