<div class="post-text" itemprop="text">
<p>I have been using <code>.pop()</code> and <code>.append()</code> extensively for Leetcode-style programming problems, especially in cases where you have to accumulate palindromes, subsets, permutations, etc.</p>
<p>Would I get a substantial performance gain from migrating to using a fixed size list instead? My concern is that internally the python list reallocates to a smaller internal array when I execute a bunch of pops, and then has to "allocate up" again when I append.</p>
<p>I know that the amortized time complexity of append and pop is O(1), but I want to get better performance if I can.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes.</p>
<p>Python (at least the CPython implementation) uses magic under the hood to make lists as efficient as possible. According to <a href="https://www.laurentluce.com/posts/python-list-implementation/" rel="noreferrer">this blog post</a> (2011), calls to append and pop will dynamically allocate and deallocate memory in chunks (overallocating where necessary) for efficiency. The list will only deallocate memory if it shrinks below the chunk size. So, for most cases if you are doing a lot of appends and pops, no memory allocation/deallocation will be performed.</p>
<p>Basically the idea with these high level languages is that you should be able to use the data structure most suited to your use case and the interpreter will ensure that you don't have to worry about the background workings. (eg. avoid micro-optimisation and instead focus on the efficiency of the algorithms in general) If you're that worried about performance, I'd suggest using a language where you have more control over the memory, like C/C++ or Rust.</p>
<p>Python guarantees O(1) complexity for append and pops as you noted, so it sounds like it will be perfectly suited for your case. If you wanted to use it like a queue and using things like <code>list.pop(1)</code> or <code>list.insert(0, obj)</code> which are slower, then you could look into a dedicated queue data structure, for example.</p>
</div>
<span class="comment-copy">A wise man once <a href="http://wiki.c2.com/?PrematureOptimization" rel="nofollow noreferrer">said</a>: "Premature optimization is the root of all evil." Also, note that Python doesn't have C-style fixed size arrays.</span>
<span class="comment-copy">Allocation time is dwarfed by other overhead. You're going to lose more time to interpreter overhead than you could save on allocation if you switch to a fixed-size list and manual end-index management.</span>
<span class="comment-copy">@user2357112 competitive programming platforms often allow more time for intepreteted languages so this overhead isn't a disadvantage. Because of this, the efficiency of chosen datastructures and algorithms is still important.</span>
<span class="comment-copy">If you want a queue you can use the <a href="https://docs.python.org/3/library/collections.html#deque-objects" rel="nofollow noreferrer">deque object</a>.</span>
