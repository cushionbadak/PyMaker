<div class="post-text" itemprop="text">
<p>Hi I have a question about splitting strings into tokens.</p>
<p>Here is an example string:</p>
<blockquote>
<p><code>string</code> = "As I was waiting, a man came out of a side room, and at a glance I was sure he must be Long John. His left leg was cut off close by the hip, and under the left shoulder he carried a crutch, which he managed with wonderful dexterity, hopping about upon it like a bird. He was very tall and strong, with a face as big as a ham—plain and pale, but intelligent and smiling. Indeed, he seemed in the most cheerful spirits, whistling as he moved about among the tables, with a merry word or a slap on the shoulder for the more favoured of his guests."</p>
</blockquote>
<p>and I'm trying to split <code>string</code> correctly into its tokens. </p>
<p>Here is my function <code>count_words</code></p>
<pre><code>def count_words(text):
    """Count how many times each unique word occurs in text."""
    counts = dict()  # dictionary of { &lt;word&gt;: &lt;count&gt; } pairs to return
    #counts["I"] = 1
    print(text)
    # TODO: Convert to lowercase
    lowerText = text.lower()
    # TODO: Split text into tokens (words), leaving out punctuation
    # (Hint: Use regex to split on non-alphanumeric characters)
    split = re.split("[\s.,!?:;'\"-]+",lowerText)
    print(split)
    # TODO: Aggregate word counts using a dictionary
</code></pre>
<p>and the result of <code>split</code> here </p>
<blockquote>
<p>['as', 'i', 'was', 'waiting', 'a', 'man', 'came', 'out', 'of', 'a',
  'side', 'room', 'and', 'at', 'a', 'glance', 'i', 'was', 'sure', 'he',
  'must', 'be', 'long', 'john', 'his', 'left', 'leg', 'was', 'cut',
  'off', 'close', 'by', 'the', 'hip', 'and', 'under', 'the', 'left',
  'shoulder', 'he', 'carried', 'a', 'crutch', 'which', 'he', 'managed',
  'with', 'wonderful', 'dexterity', 'hopping', 'about', 'upon', 'it',
  'like', 'a', 'bird', 'he', 'was', 'very', 'tall', 'and', 'strong',
  'with', 'a', 'face', 'as', 'big', 'as', 'a', 'ham—plain', 'and',
  'pale', 'but', 'intelligent', 'and', 'smiling', 'indeed', 'he',
  'seemed', 'in', 'the', 'most', 'cheerful', 'spirits', 'whistling',
  'as', 'he', 'moved', 'about', 'among', 'the', 'tables', 'with', 'a',
  'merry', 'word', 'or', 'a', 'slap', 'on', 'the', 'shoulder', 'for',
  'the', 'more', 'favoured', 'of', 'his', 'guests', '']</p>
</blockquote>
<p>as you see there is the empty string <code>''</code> in the last index of the <code>split</code> list.</p>
<p>Please help me understand this empty string in the list and to correctly split this example <code>string</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/tutorial/datastructures.html?highlight=list%20comprehensions#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> to iterate over the list items produced by <code>re.split</code> and only keep them if they are not empty strings:</p>
<pre class="lang-py prettyprint-override"><code>def count_words(text):
    """Count how many times each unique word occurs in text."""
    counts = dict()  # dictionary of { &lt;word&gt;: &lt;count&gt; } pairs to return
    #counts["I"] = 1
    print(text)
    # TODO: Convert to lowercase
    lowerText = text.lower()
    # TODO: Split text into tokens (words), leaving out punctuation 
    # (Hint: Use regex to split on non-alphanumeric characters) 

    split = re.split("[\s.,!?:;'\"-]+",lowerText)
    split = [x for x in split if x != '']  # &lt;- list comprehension
    print(split) 
</code></pre>
<p>You should also consider returning the data from the function, and printing it from the caller rather than printing it from within the function.  That will provide you with flexibility in future.</p>
</div>
<div class="post-text" itemprop="text">
<p>That happened because the end of string is <code>.</code> and it is in the split <code>pattern</code> so , when match <code>.</code> the next match will start with an empty and that why you see <code>''</code>.</p>
<p>I suggest this solution using <code>re.findall</code> instead to work an opposite way like this :</p>
<pre><code>def count_words(text):
    """Count how many times each unique word occurs in text."""
    counts = dict()  # dictionary of { &lt;word&gt;: &lt;count&gt; } pairs to return
    #counts["I"] = 1
    print(text)
    # TODO: Convert to lowercase
    lowerText = text.lower()
    # TODO: Split text into tokens (words), leaving out punctuation
    # (Hint: Use regex to split on non-alphanumeric characters)
    split = re.findall(r"[a-z\-]+", lowerText)
    print(split)
    # TODO: Aggregate word counts using a dictionary
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer">wiki</a> explains this behavior:</p>
<blockquote>
<p>If there are capturing groups in the separator and it matches at the
  start of the string, the result will start with an empty string. The
  same holds for the end of the string</p>
</blockquote>
<p>Even though yours is not actually a capturing group, the effect is the same. Note that it could be at the end as well as at the start (for instance if your string started with a whitespace).</p>
<p>The 2 solution already proposed (more or less) by others are these:</p>
<h2>Solution 1: <code>findall</code></h2>
<p>As other users pointed out you can use <code>findall</code> and try to inverse the logic of the pattern. With yours, you can easily negate your character class: <code>[^\s\.,!?:;'\"-]+</code>.</p>
<p>But it depends on you regex pattern because it is not always that easy.</p>
<h2>Solution 2: check on the starting and ending token</h2>
<p>Instead of checking if each token is <code>!= ''</code>, you can just look at the first or at the last one of the tokens, since you are <strong>eagerly</strong> taking all the characters on the set you need to split on.</p>
<pre><code>split = re.split("[\s\.,!?:;'\"-]+",lowerText)

if split[0] == '':
    split = split[1:]

if split[-1] == '':
    split = split[:-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have an empty string due to a point is also matching to split at the <code>string</code> ending and anything is downstream. You can, however, filter out  empty strings with <code>filter</code> function and thus complete your function:</p>
<pre><code>import re
import collections


def count_words(text):
    """Count how many times each unique word occurs in text."""

    lowerText = text.lower()

    split = re.split("[ .,!?:;'\"\-]+",lowerText)
    ## filer out empty strings and count
    ## words:

   return collections.Counter( filter(None, split) )


count_words(text=string)
# Counter({'a': 9, 'he': 6, 'the': 6, 'and': 5, 'as': 4, 'was': 4, 'with': 3, 'his': 2, 'about': 2, 'i': 2, 'of': 2, 'shoulder': 2, 'left': 2, 'dexterity': 1, 'seemed': 1, 'managed': 1, 'among': 1, 'indeed': 1, 'favoured': 1, 'moved': 1, 'it': 1, 'slap': 1, 'cheerful': 1, 'at': 1, 'in': 1, 'close': 1, 'glance': 1, 'face': 1, 'pale': 1, 'smiling': 1, 'out': 1, 'tables': 1, 'cut': 1, 'ham': 1, 'for': 1, 'long': 1, 'intelligent': 1, 'waiting': 1, 'wonderful': 1, 'which': 1, 'under': 1, 'must': 1, 'bird': 1, 'guests': 1, 'more': 1, 'hip': 1, 'be': 1, 'sure': 1, 'leg': 1, 'very': 1, 'big': 1, 'spirits': 1, 'upon': 1, 'but': 1, 'like': 1, 'most': 1, 'carried': 1, 'whistling': 1, 'merry': 1, 'tall': 1, 'word': 1, 'strong': 1, 'by': 1, 'on': 1, 'john': 1, 'off': 1, 'room': 1, 'hopping': 1, 'or': 1, 'crutch': 1, 'man': 1, 'plain': 1, 'side': 1, 'came': 1})
</code></pre>
</div>
<span class="comment-copy">The short answer to solve your problem: use <code>del split[-1]</code> to remove that last element</span>
<span class="comment-copy">Perhaps this page can be helpful <a href="https://stackoverflow.com/questions/16099694/how-to-remove-empty-string-in-a-list/16099706" title="how to remove empty string in a list">stackoverflow.com/questions/16099694/…</a></span>
<span class="comment-copy">What if you have a word like <code>I'm</code>? Should it get split? Note that rather than splitting, you may match all those strings, <code>re.findall(r"[^\s.,!?:;'\"-]+", s)</code>. See <a href="https://regex101.com/r/FX8pXc/1" rel="nofollow noreferrer">this demo</a>. The empty string is due to the fact the match is at the end of the string.</span>
<span class="comment-copy">Hello, what is r and \- means in r"[a-z\-]+"?</span>
<span class="comment-copy">and what is findall do?</span>
<span class="comment-copy">@kimYumi r is prefix [a-z\-] is pattern to match from a up to z and - as well</span>
<span class="comment-copy">@kimYumi re.findall return all non-overlapping matches of pattern in string, as a list of strings.</span>
<span class="comment-copy">@kimYumi <a href="https://docs.python.org/2/library/re.html?highlight=re%20findall#re.findall" rel="nofollow noreferrer">docs.python.org/2/library/…</a></span>
