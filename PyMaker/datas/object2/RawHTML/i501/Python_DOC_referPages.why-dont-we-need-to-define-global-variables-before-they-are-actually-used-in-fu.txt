<div class="post-text" itemprop="text">
<p>I was looking at the following code:</p>
<pre><code>def f():
    print(x)

if __name__ == '__main__':
    x = [1,2,3]
    f()
</code></pre>
<p>which to my amazement works. I would have expected that NOT to work because I would have expected needing <code>x</code> to be defined BEFORE the function definition of <code>f</code> (otherwise, how does <code>f</code> know what <code>x</code> refers to?). So I expected the following to be the only version that should have worked:</p>
<pre><code>x = [1,2,3]
def f():
    print(x)

if __name__ == '__main__':
    #x = [1,2,3]
    f()
</code></pre>
<p>though I am obviously wrong. Why? What part of how Python is supposed to work did I get wrong?</p>
<hr/>
<p>Note as coding practice I'd never use globals. They are dangerous and unclear. I'd personally always pass variables to functions (or something that is more clear and safe like that). This was just out of curiosity.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why shouldn't it work? When you're creating the function it's just a code snippet that it isn't executed (kind of lazy evaluation) until it's called. That's the difference between Python and other compiled languages such as C++, which would raise <code>undefined variable x</code> error.</p>
<p>You'll just need the variable <code>x</code> to exist when you call the function <code>f</code>. It will first look at some variable x in the local scope and then in the global scope, so that's why it works anyway, even if x it's been defined after the function!</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>do</em> need to define the variable before it's used:</p>
<pre><code>def f():
    print(x)

if __name__ == '__main__':
    x = [1,2,3] # definition
    f()         # use
</code></pre>
<p>If you had tried it the other way around:</p>
<pre><code>def f():
    print(x)

if __name__ == '__main__':
    f()         # use
    x = [1,2,3] # definition
</code></pre>
<p>it wouldn't have worked.</p>
<p>When you define <code>f</code>, you're not using <code>x</code>. You're just writing code that will eventually use <code>x</code> once called. That code will go look for the <code>x</code> variable when it actually tries to use it, not at function definition time.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first version ie :</p>
<pre><code>def f():
    print(x)

if __name__ == '__main__':
    x = [1,2,3]
    f()
</code></pre>
<p>The variable <code>x</code> is in scope thanks to the enclosing scope of <code>if</code> block , since python doesn't have a block scope <code>x</code> is in local scope to the function <code>f()</code></p>
<p>Where as in the second version:</p>
<pre><code>x = [1,2,3]
def f():
    print(x)

if __name__ == '__main__':
    f()
</code></pre>
<p><code>x</code> is in global scope. Hence inaccessible unless you explicitly include <code>global x</code> in inside the definition of <code>f()</code>, <strong>which is NOT a good practice</strong>.</p>
<p>Read the following excerpt from the official <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">documentation</a> :</p>
<blockquote>
<p>A scope is a textual region of a Python program where a namespace is
  directly accessible. “Directly accessible” here means that an
  unqualified reference to a name attempts to find the name in the
  namespace.</p>
<p>Although scopes are determined statically, they are used dynamically.
  At any time during execution, there are at least three nested scopes
  whose namespaces are directly accessible:</p>
<ul>
<li><p>the innermost scope, which is searched first, contains the local names</p></li>
<li><p>the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also
  non-global names</p></li>
<li><p>the next-to-last scope contains the current module’s global names</p></li>
<li><p>the outermost scope (searched last) is the namespace containing built-in names</p></li>
</ul>
</blockquote>
</div>
<span class="comment-copy">The variable needs to be defined before the function is <i>used</i></span>
<span class="comment-copy">@UnholySheep really? Why? (obviously ur right)</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features" rel="nofollow noreferrer">docs.python.org/3/reference/…</a> : <i>"Name resolution of free variables occurs at runtime, not at compile time."</i></span>
<span class="comment-copy">@UnholySheep though its bad practice do the above right?</span>
<span class="comment-copy">"bad practice" is opinion-based. Personally I don't use any non-local variables in functions (except class members, but even those I prefer to use sparely)</span>
<span class="comment-copy">though is using this functionality of Python this way bad practices? I would have thought it is.</span>
<span class="comment-copy">Well, the bad practice here would be to use global variables, but as everything in life, those exist for some propose, and can be useful in some cases. Everything depends on the context!</span>
<span class="comment-copy">when are globals ever a good idea, I'd be curious! I've been indoctrinated to cringe at their sight.</span>
<span class="comment-copy">There are some related posts explaining it in detail with several references, take a look to this other <a href="https://stackoverflow.com/questions/19158339/why-are-global-variables-evil">question</a></span>
