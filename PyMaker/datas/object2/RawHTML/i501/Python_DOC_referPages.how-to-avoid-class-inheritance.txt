<div class="post-text" itemprop="text">
<p>I've recently been dealing a lot with class inheritance on a project I'm working on, and I've started to become disenchanted with it as a programming concept. I do understand its appeal: it provides a clean way to extend an existing base class with new methods, thereby avoiding having to rewrite the same code multiple times and adding a nice logical structure to how classes are related to one another.</p>
<p>However, now that I've been using it more extensively, its drawbacks have become much more apparent. Not only does it add a layer of opacity to where a method or attribute comes from, forcing me to go down a rabbit hole of inherited classes every time I want to figure out where a given method is being defined, but it also breaks encapsulation by allowing you to unwittingly redefine public and private functions and variables in an inherited class.</p>
<p>Here's a very simple example of how easy it is to break things with inheritance.</p>
<pre><code>class Parent:
    def __init__(self):
        self._private_var = 10

    def add_ten(self, n):
        return n + self._private_var


class Child(Parent):
    def __init__(self):
        self._private_var = 100

    def add_hundred(self, n):
        return n + self._private_var
</code></pre>
<p>Now, let's say I want to use <code>Child</code>'s inherited <code>.add_ten</code> method:</p>
<pre><code>c = Child()

c.add_ten(4)
&gt;&gt; 104
</code></pre>
<p>Since I unknowingly redefined <code>Parent</code>'s <code>._private_var</code>, the <code>.add_ten</code> method now adds 100 instead of 10.</p>
<p>Granted, inheritance might be dealt with slightly differently in other languages (I know Python doesn't have any truly "private" methods or variables, so perhaps this is not as much of an issue in Java or C++). Still, the downsides of inheritance seem to me to outweigh its advantages and make we want to avoid using it altogether if I can.</p>
<p>The issue is that the alternative seems to add a lot of redundancy.</p>
<p>For example, I could have defined <code>ChildTwo</code> as:</p>
<pre><code>class ChildTwo:
    def __init__(self):
        self._parent = Parent()
        self._private_var = 100

    def add_ten(self, n):
        return self._parent.add_ten(n)

    def add_hundred(self, n):
        return n + self._private_var
</code></pre>
<p>This would allow both <code>.add_ten</code> and <code>.add_hundred</code> to behave as expected, but it would also require me to manually add every method I would like to inherit from the <code>Parent</code> class, which seems wasteful in terms of keeping my code lean. This is especially true when there are multiple methods I'd like to inherit from <code>Parent</code>.</p>
<p>I'm also not sure (?) if instantiating the <code>Parent</code> class for every <code>ChildTwo</code> class might have some impact on performance.</p>
<p>What's the best way to avoid using inheritance while still avoiding code repetition as much as possible and having a minimal impact on performance?</p>
<p><strong>Edit:</strong> Someone pointed out that this is a bad example, since <code>.add_ten</code> should probably be defined as <code>n + 10</code> instead of <code>n + self._private_var</code>. That's a fair point, but it requires that I know how <code>Parent</code> is implemented, which may not always be the case. If <code>Parent</code> is in some external module then there's nothing I can do about it. Furthermore, if its implementation of <code>.add_ten</code> changes in the future, it has an impact on the <code>Child</code> class as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are obviously no hard rules on when and when not to use inheritance. However, there are a few key things I do to help avoid issues.</p>
<p>I treat child classes as just extensions of the parent's logic. I therefore try to avoid overwriting objects, instead only extending them.</p>
<p>For example, I commonly have a parent class which receives the configs for a project. Then, any child classes can use these configs and do whatever necessary logic with them. All the configs are the same, they're not being changed, so inheritance will not cause any issues.</p>
<pre><code>class Parent:
    def __init__(self, name, configs):
        self.name = name
        self.theory = configs['theory']
        self.log_file = configs['log_file']
        ...

class Child(Parent):
    def __init__(self, name, configs):
        super().__init__(name, configs)
</code></pre>
<p>I would not however have a method in the parent class that performed some action with the configs and then alter that method in the child classes. Despite that being perfectly acceptable python code, I find it easy to make mistakes and it adds unnecessary complexity. Why bother writing a method if you're going to constantly override it?</p>
<p>With multiple inheritance, if it's not something you've encountered before, it can be surprisingly easy to run into issues with "Method Resolution Order". The Diamond of Death or whatever other dramatic names it has. This occurs when multiple inheritance leads to ambiguity in how a child class should inherit from above it in the inheritance tree. For this reason I completely avoid ever making classes "siblings".</p>
<p>Inheritance can often scale badly. By which I mean, adding lots of logic to a pre-existing inheritance structure can cause issues. Maybe your child classes all used the parent class method in the same way but now you've a new child class which is slightly different. Ok so you can overwrite that method. But what if you begin adding more and more child classes which also need to overwrite that method? Now it makes sense to rewrite the base class method which means you need to rewrite all of the overwritten methods.</p>
<p>Sometimes inheritance will be instrumental in reducing repetition, other times it will be a headache for maintenance, testing and extension. As always in programming, if you find yourself writing the same thing over and over, you're doing something wrong. Knowing exactly what a class structure will be used for in the future, for me has been the best way of making sure any inheritance won't cause issues.</p>
<p>I would just say that your example seems a bit of a straw-man. You set up a demonstrably bad structure then dismiss inheritance as the reason for failure. If you're going to add ten, add ten, don't add some changeable variable.</p>
<p>Finally, while I have banged on about personal preference, be aware in the working environment, people's preferences will be drastically different to yours. You should understand how to use, extend and debug all different class structures.</p>
</div>
<span class="comment-copy">Inheritance isn't breaking your encapsulation - you are the one doing it! If you use a proper naming convention you should have no trouble distinguishing which variables you can overwrite.</span>
<span class="comment-copy">Python's inheritance is indeed a bit hard, because you can unintentionally overwrite base class' field. And so it requires more knowledge about whole inheritance chain. But that's not the reason to avoid it. You just need a proper discipline in code writing. But yes, I would avoid inheritance if possible. Not only in Python.</span>
<span class="comment-copy">Your example is probably one of the worst examples I can imagine. You do not name a method <code>add_ten</code>, when in reality you add some private variable that could hold any value.</span>
<span class="comment-copy">Do you perceive inheritance as impacting performance in a positive or negative manner? What type of performance are you referring to, memory?, execution time?, lines of code?, personal productivity?, group productivity?, code reviewer's productivity?</span>
<span class="comment-copy">The way to "avoid" inheritance here would be to rename <code>_private_var</code> and make it a class-private name. i.e. <code>__private_var</code>. If you do this, running your code will cause an <code>AttributeError: 'Child' object has no attribute '_Parent__private_var'</code> (note the <code>_Parent</code> prefix automatically added). See <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="nofollow noreferrer">Reserved classes of identifiers</a> in the documentation. Note I put "avoid" in quotes because that's not what this is really doing.</span>
