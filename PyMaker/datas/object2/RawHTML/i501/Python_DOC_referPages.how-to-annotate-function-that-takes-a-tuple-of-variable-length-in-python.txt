<div class="post-text" itemprop="text">
<p>I have a function that takes a tuple of different lengths as an argument:</p>
<pre><code>from typing import Tuple


def process_tuple(t: Tuple[str]):
    # Do nasty tuple stuff

process_tuple(("a",))
process_tuple(("a", "b"))
process_tuple(("a", "b", "c"))

</code></pre>
<p>When I annotate function like mentioned above, I get these error messages</p>
<pre><code>fool.py:9: error: Argument 1 to "process_tuple" has incompatible type "Tuple[str, str]"; expected "Tuple[str]"
fool.py:10: error: Argument 1 to "process_tuple" has incompatible type "Tuple[str, str, str]"; expected "Tuple[str]"
</code></pre>
<p><code>process_tuple</code> really works with tuples and I use them as immutable lists of variable length. I haven't found any consensus on this topic on the internet, so I wonder how should I annotate this kind of input. </p>
</div>
<div class="post-text" itemprop="text">
<p>Variable length homogeneous tuple we can annotate using <code>...</code> literal (aka <code>Ellipsis</code>) like</p>
<pre><code>def process_tuple(t: Tuple[str, ...]):
    ...
</code></pre>
<p>after that errors should go away.</p>
<p>From <a href="https://docs.python.org/3/library/typing.html#typing.Tuple" rel="noreferrer">docs</a></p>
<blockquote>
<p>To specify a variable-length tuple of homogeneous type, use literal
  ellipsis, e.g. <code>Tuple[int, ...]</code>. A plain <code>Tuple</code> is equivalent to
  <code>Tuple[Any, ...]</code>, and in turn to <code>tuple</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the Ellipsis answer as posted by Azat you could make it more explicit by using <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer"><code>@typing.overload</code></a> or <a href="https://docs.python.org/3/library/typing.html#typing.Union" rel="nofollow noreferrer"><code>typing.Union</code></a></p>
<pre><code>from typing import Tuple


@overload
def process_tuple(t: Tuple[str]):
    # Do nasty tuple stuff

@overload
def process_tuple(t: Tuple[str, str]):
    ...
</code></pre>
<p>Or with the Union:</p>
<pre><code>from typing import Tuple, Union


def process_tuple(t: Union[Tuple[str], Tuple[str, str], Tuple[str, str, str]]):
    # Do nasty tuple stuff
</code></pre>
</div>
<span class="comment-copy">Do you get these errors when you run the code? I ran the code without any errors.</span>
<span class="comment-copy">I get these errors when I run <code>mypy</code>.</span>
<span class="comment-copy">This actually <i>is</i> a little bit counter-intuitive and counter-logical. If we assume that <code>List[str]</code> is okay for variable length lists, then why <code>Tuple[str]</code> is not okay for variable length tuple? And <code>(type(("a", "a")) == type(("a", "a", "a"))</code> yields <code>True</code>.</span>
<span class="comment-copy">@Montreal: that's because <code>tuple</code>s and <code>list</code>s serve for different purposes: <code>tuple</code>s are heterogeneous containers (like positional arguments to an arbitrary function or a single table record from RDBMS, or in math world -- elements of cartesian product of different sets (or a union of cartesian products), so each coordinate may have a different type, but their number is usually fixed), while <code>list</code>s are homogeneous (like collection of same table records or a finite sequence of elements of some set)</span>
<span class="comment-copy">@Montreal: so <code>Tuple[str]</code> is a single-<code>str</code>-object <code>tuple</code>, while <code>List[str]</code> is a collection of arbitrary number of <code>str</code> objects</span>
<span class="comment-copy">Okay, that makes sense.</span>
<span class="comment-copy">I knew about it, but my tuples can be very lengthy, so it is not an option. Anyway, thank you.</span>
<span class="comment-copy">btw <code>overload</code>s should go before implementation</span>
<span class="comment-copy">Yes, you're right :)</span>
