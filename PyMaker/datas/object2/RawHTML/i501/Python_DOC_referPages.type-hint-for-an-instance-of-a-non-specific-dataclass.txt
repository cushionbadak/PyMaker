<div class="post-text" itemprop="text">
<p>I have a function that accepts an instance of any <code>dataclass</code>.
what would be an appropriate type hint for it ?</p>
<p>haven't found something official in the python documentation </p>
<hr/>
<p>this is what I have been doing, but i don't think it's correct</p>
<pre><code>from typing import Any, NewType

DataClass = NewType('DataClass', Any)
def foo(obj: DataClass):
    ...
</code></pre>
<p>another idea is to use a <a href="https://www.python.org/dev/peps/pep-0544/#defining-a-protocol" rel="nofollow noreferrer"><code>Protocol</code></a> with these class attributes <code>__dataclass_fields__</code>, <code>__dataclass_params__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Despite its name, <code>dataclasses.dataclass</code> doesn't expose a class interface. It just allows you to declare a custom class in a convenient way that makes it obvious that it is going to be used as a data container. So, in theory, there is little opportunity to write something that only works on dataclasses, because dataclasses really are just ordinary classes.</p>
<p>In practice, there a couple of reasons why you would want to declare dataclass-only functions anyway, and I see two ways to go about it.</p>
<hr/>
<p><strong>The <em>right</em> way, using a static type checker and writing a Protocol</strong></p>
<pre><code>from dataclasses import dataclass
from typing import Dict

from typing_extensions import Protocol

class IsDataclass(Protocol):
    # as already noted in comments, checking for this attribute is currently
    # the most reliable way to ascertain that something is a dataclass
    __dataclass_fields__: Dict

def dataclass_only(x: IsDataclass):
    ...  # do something that only makes sense with a dataclass

@dataclass
class A:
    pass

dataclass_only(A())  # a static type check should show that this line is fine
</code></pre>
<p>This approach is also what you alluded to in your question, but it has three downsides:</p>
<ul>
<li>You need a third party library such as <a href="http://www.mypy-lang.org/" rel="nofollow noreferrer"><code>mypy</code></a> to do the static type checking for you</li>
<li>You need to install <a href="https://pypi.org/project/typing-extensions/" rel="nofollow noreferrer"><code>typing_extensions</code></a> as well, since <code>Protocol</code> is not part of the core <code>typing</code> module as of yet</li>
<li>Last but not least, using protocols for dataclasses in this way <a href="https://github.com/python/mypy/issues/6568" rel="nofollow noreferrer">doesn't work right now</a></li>
</ul>
<hr/>
<p><strong>Something slightly more <a href="https://docs.quantifiedcode.com/python-anti-patterns/readability/asking_for_permission_instead_of_forgiveness_when_working_with_files.html" rel="nofollow noreferrer">EAFP</a>-inspired that actually works</strong></p>
<pre><code>from dataclasses import is_dataclass

def dataclass_only(x):
    """Do something that only makes sense with a dataclass.

    Raises:
        ValueError if something that is not a dataclass is passed.

    ... more documentation ...
    """
    if not is_dataclass(x):
        raise ValueError(f"'{x.__class__.__name__}' is not a dataclass!")
    ...
</code></pre>
<p>In this approach, the behavior is still very clear to a maintainer or user of this code thanks to the documentation. But the downside is that you don't get a static analysis of your code (including type hints by your IDE), not now and not ever.</p>
</div>
<span class="comment-copy">Uh, what? There's no observable difference between a class with an <code>@dataclass</code> decorator and a class without. Dataclasses don't implement any special methods and don't have any special attributes. Distinguishing between a "dataclass" and a "regular" class makes no sense whatsoever.</span>
<span class="comment-copy">The function unpacks a data class to a dictionary, and they have special attributes, <code>__dataclass_fields__</code>, <code>__dataclass_params__</code>. as stated in the question. the same thing can be said about namedtuples and the do have a type hint even though they are simply inheriting from <code>tuple</code></span>
<span class="comment-copy">Those attributes are undocumented and thus I would advise against relying on their existence. I was wrong about there being no observable difference though; functions like <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple" rel="nofollow noreferrer"><code>dataclasses.astuple</code></a> only work with dataclasses.</span>
<span class="comment-copy">so a <code>Protocol</code> with a <code>astuple</code> method ? sounds good, but a bit precarious. not sure why they decided to create <code>dataclass</code>es with a decorator and not via inheritance and meta classes like  <code>namedtuple</code>s.</span>
<span class="comment-copy"><code>astuple</code> is not a method, so that's not gonna work. I don't think this can be done with <code>typing</code>, since dataclasses technically aren't a type. They don't expose a base class or a specific public interface. In other words, receiving a non-dataclass instead of a dataclass is closer to a ValueError than a TypeError.</span>
