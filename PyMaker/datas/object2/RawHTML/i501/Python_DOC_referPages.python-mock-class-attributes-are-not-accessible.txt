<div class="post-text" itemprop="text">
<p>When mocking a class object I can't access it's attributes.
I've read a lot of documentation but I'm new to mocking and don't see the problem with this code. I expect x and y to return the same value 1e-15</p>
<pre><code>class test_user_data:
    scale = 1e-15

class test_signal(unittest.TestCase):
    @patch('xx.user_data', autospec=test_user_data, spec_set=True)
    def test_data(self, mock_user_data):
        x = xx.user_data()
        y = test_user_data()
        print(x.scale)
        print(y.scale)
</code></pre>
<p>but I get</p>
<pre><code>&lt;NonCallableMagicMock name='user_data().timescale' spec_set='float' id='47213638195072'&gt;
1e-15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>autospec</code> and spec'ing in general is used to define an API. When using a <code>Mock</code>, you can pretty much call or access any attribute on it and it'll just let you. It will return another mock object though.</p>
<p>See something like this:</p>
<pre><code>&gt;&gt;&gt; my_mock = Mock()
&gt;&gt;&gt; my_mock.stuff
&lt;Mock name='mock.stuff' id='139870989908344'&gt;
&gt;&gt;&gt; my_mock.junk()
&lt;Mock name='mock.junk()' id='139870987197912'&gt;
</code></pre>
<p>If I define a spec, it says you can't access things that don't actually exist on the real class. Like so:</p>
<pre><code>&gt;&gt;&gt; my_mock = Mock(spec=xx.user_data)
&gt;&gt;&gt; my_mock.stuff
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib64/python3.4/unittest/mock.py", line 574, in __getattr__
    raise AttributeError("Mock object has no attribute %r" % name)
AttributeError: Mock object has no attribute 'stuff'
&gt;&gt;&gt; my_mock.scale
&lt;Mock name='mock.scale' id='139871128095264'&gt;
</code></pre>
<p>So the above shows you can't access an attribute on the Mock that isn't defined in the actual <code>user_data</code> class because I've used spec.</p>
<p>That explains how autospec works, but what you actually want is the <code>return_value</code> arg. Go ahead and add it to your patch decorator and you should be all set. It should look like this:</p>
<pre><code>@patch('xx.user_data', autospec=test_user_data, spec_set=True, return_value=test_user_data)
</code></pre>
</div>
<span class="comment-copy">Thank you for the explanation, your solution solves the problem. If test_user_data had a <b>init</b> method, is there way to force mock to run it?</span>
<span class="comment-copy">I think it would take a little bit of hacking around to get exactly what you want, but I do believe it's possible yes. What's the end goal of what you're trying to accomplish with that? Do you actually want to test <code>__init__</code>? Or you want the effect of <code>__init__</code> to happen on the mock object? I'd encourage you to take a look at <code>.side_effect</code> here: <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#quick-guide</a> It will allow you to assign function pointers (a function pointer to the original <code>__init__</code> in this case) and might accomplish what you're looking for.</span>
<span class="comment-copy">@Damo given the complexity, and if the above link doesn't completely solve it, you may want to consider opening a new question for this as well.</span>
<span class="comment-copy">Thanks @wholevinski. Your response fixes the issue for basic user_data. I also have more complex user_data with additional fields and dependencies between them, these fields are initialized in <code>__init__</code>. Using <code>side_effect</code> works. Which gives: <code>@patch('xx.user_data', autospec=test_user_data, return_value=test_user_data, side_effect=test_user_data.__init__(test_user_data))</code></span>
