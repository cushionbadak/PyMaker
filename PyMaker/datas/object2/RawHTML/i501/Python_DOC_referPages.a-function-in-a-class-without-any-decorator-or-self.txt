<div class="post-text" itemprop="text">
<p>I have following class with a function: </p>
<pre><code>class A: 
    def myfn():
        print("In myfn method.")
</code></pre>
<p>Here, the function does not have <code>self</code> as argument. It also does not have <code>@classmethod</code> or <code>@staticmethod</code> as decorator. However, it works if called with class: </p>
<pre><code>A.myfn()
</code></pre>
<p>Output: </p>
<pre><code>In myfn method.
</code></pre>
<p>But give an error if called from any instance: </p>
<pre><code>a = A()
a.myfn()
</code></pre>
<p>Error output: </p>
<pre><code>Traceback (most recent call last):
  File "testing.py", line 16, in &lt;module&gt;
    a.myfn()
TypeError: myfn() takes 0 positional arguments but 1 was given
</code></pre>
<p>probably because <code>self</code> was also sent as an argument.</p>
<p>What kind of function will this be called? Will it be a static function? Is it advisable to use function like this in classes? What is the drawback?</p>
<p>Edit: This function works only when called with class and not with object/instance. My main question is what is such a function called?</p>
<p>Edit2: It seems from the answers that this type of function, despite being the simplest form, is not accepted as legal. However, as no serious drawback is mentioned in any of many answers, I find this can be a useful construct, especially to group my own static functions in a class that I can call as needed. I would not need to create any instance of this class. In the least, it saves me from typing <code>@staticmethod</code> every time and makes code look less complex. It also gets derived neatly for someone to extend my class. Although all such functions can be kept at top/global level, keeping them in class is more modular. However, I feel there should be a specific name for such a simple construct which works in this specific way and it should be recognized as legal. It may also help beginners understand why <code>self</code> argument is needed for usual functions in a Python class. This will only add to the simplicity of this great language.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not a true method. Correctly declarated instance methods should have a <code>self</code> argument (the name is only a convention and can be changed if you want hard to read code), and classmethods and staticmethods should be introduced by their respective decorator.</p>
<p>But at a lower level, <code>def</code> in a class declaration just creates a function and assigns it to a class member. That is exactly what happens here: <code>A.my_fn</code> is a function and can successfully be called as <code>A.my_fn()</code>.</p>
<p>But as it was not declared with <code>@staticmethod</code>, it is not a true static method and it cannot be applied on a <code>A</code> instance. Python sees a member of that name that happens to be a function which is neither a static nor a class method, so it prepends the current instance to the list of arguments and tries to execute it.</p>
<p>To answer your exact question, this is not a method but just a function that happens to be assigned to a class member.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>function</code> type implements the descriptor protocol, which means when you access <code>myfn</code> via the class or an instance of the class, you don't get the actual function back; you get instead the result of that function's <code>__get__</code> method. That is,</p>
<pre><code>A.myfn == A.myfn.__get__(None, A)
</code></pre>
<p>Here, <code>myfn</code> is an instance method, though one that hasn't been defined properly to be used as such. When accessed via the <em>class</em>, though, the return value of <code>__get__</code> is simply the function object itself, and the <em>function</em> can be called the same as a static method.</p>
<p>Access via an instance results in a different call to <code>__get__</code>. If <code>a</code> is an instance of <code>A</code>, then</p>
<pre><code>a.myfn() == A.myfn.__get__(a, A)
</code></pre>
<p>Here , <code>__get__</code> tries to return, essentially, a partial application of <code>myfn</code> to <code>a</code>, but because <code>myfn</code> doesn't take <em>any</em> arguments, that fails.</p>
<p>You might ask, what <em>is</em> a static method? <code>staticmethod</code> is a type that wraps a function and defines its own <code>__get__</code> method. That method returns the underlying function whether or not the attribute is accessed via the class or an instance. Otherwise, there is very little difference between a static method and an ordinary function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Such a function isn't the same as what <code>@staticmethod</code> provides, but is indeed a static method of sorts.</p>
<p>With <code>@staticmethod</code> you can also call the static method on an instance of the class. If <code>A</code> is a class and <code>A.a</code> is a <code>static method</code>, you'll be able to do both <code>A.a()</code> and <code>A().a()</code>. Without this decorator, only the first example will work, because for the second one, as you correctly noticed, "<code>self</code> [will] also [be] sent as an argument":</p>
<pre><code>class A:
    @staticmethod
    def a():
        return 1
</code></pre>
<p>Running this:</p>
<pre><code>&gt;&gt;&gt; A.a()  # `A` is the class itself
1
&gt;&gt;&gt; A().a()  # `A()` is an instance of the class `A`
1
</code></pre>
<p>On the other hand:</p>
<pre><code>class B:
    def b():
        return 2
</code></pre>
<p>Now, the second version doesn't work:</p>
<pre><code>&gt;&gt;&gt; B.b()
2
&gt;&gt;&gt; B().b()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: b() takes 0 positional arguments but 1 was given
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>further to @chepnet's answer, if you define a class whose objects implement the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a> like:</p>
<pre><code>class Descr:
    def __get__(self, obj, type=None):
        print('get', obj, type)
    def __set__(self, obj, value):
        print('set', obj, value)
    def __delete__(self, obj):
        print('delete', obj)
</code></pre>
<p>you can embed an instance of this in a class and invoke various operations on it:</p>
<pre><code>class Foo:
    foo = Descr()

Foo.foo
obj = Foo()
obj.foo
</code></pre>
<p>which outputs:</p>
<pre><code>get None &lt;class '__main__.Foo'&gt;
get &lt;__main__.Foo object at 0x106d4f9b0&gt; &lt;class '__main__.Foo'&gt;
</code></pre>
<p>as functions also implement the descriptor protocol, we can replay this by doing:</p>
<pre><code>def bar():
    pass

print(bar)
print(bar.__get__(None, Foo))
print(bar.__get__(obj, Foo))
</code></pre>
<p>which outputs:</p>
<pre><code>&lt;function bar at 0x1062da730&gt;
&lt;function bar at 0x1062da730&gt;
&lt;bound method bar of &lt;__main__.Foo object at 0x106d4f9b0&gt;&gt;
</code></pre>
<p>hopefully that complements chepnet's answer which I found a little terse/opaque</p>
</div>
<span class="comment-copy">"probably because self was also sent as an argument" - right. "Will it be a static function?" - <a href="https://stackoverflow.com/questions/735975/static-methods-in-python">yep!</a></span>
<span class="comment-copy">Can you post a link to the docs where it is mentioned that such a function will be considered to be @staticmethod ?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/735975/static-methods-in-python">This</a> post in detail explains the static method.</span>
<span class="comment-copy">Your linked page mentions such a function as implicit <code>classmethod</code> not <code>staticmethod</code> : see <code>rollcall</code> function on that page.</span>
