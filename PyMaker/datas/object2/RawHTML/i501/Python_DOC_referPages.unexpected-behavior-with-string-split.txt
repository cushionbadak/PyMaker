<div class="post-text" itemprop="text">
<p>Say I have a string, <code>string = 'a'</code></p>
<p>I do <code>string.split()</code> and I get <code>['a']</code></p>
<p>I don't want this, I only want a list when I have whitespace in my string, ala <code>string = 'a b c d'</code></p>
<p>So far, I've tried all the following with no luck:</p>
<pre><code>&gt;&gt;&gt; a = 'a'
&gt;&gt;&gt; a.split()
['a']
&gt;&gt;&gt; a = 'a b'
&gt;&gt;&gt; a.split(' ')
['a', 'b']
&gt;&gt;&gt; a = 'a'
&gt;&gt;&gt; a.split(' ')
['a']
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'\S+', a)
['a']
&gt;&gt;&gt; re.findall(r'\S', a)
['a']
&gt;&gt;&gt; re.findall(r'\S+', a)
['a', 'b']
&gt;&gt;&gt; re.split(r'\s+', a)
['a', 'b']
&gt;&gt;&gt; a = 'a'
&gt;&gt;&gt; re.split(r'\s+', a)
['a']
&gt;&gt;&gt; a.split(" ")
['a']
&gt;&gt;&gt; a = "a"
&gt;&gt;&gt; a.split(" ")
['a']
&gt;&gt;&gt; a.strip().split(" ")
['a']
&gt;&gt;&gt; a = "a".strip()
&gt;&gt;&gt; a.split(" ")
['a']
</code></pre>
<p>Am I crazy? I see no whitespace in the string "a".</p>
<pre><code>&gt;&gt;&gt; r"[^\S\n\t]+"
'[^\\S\\n\\t]+'
&gt;&gt;&gt; print(re.findall(r'[^\S\n\t]+',a))
[]
</code></pre>
<p>What up?</p>
<p><strong><em>EDIT</em></strong></p>
<p>FWIW, this is how I got what I needed:</p>
<pre><code># test for linked array
if typename == 'org.apache.ctakes.typesystem.type.textsem.ProcedureMention':
    for f in AnnotationType.all_features:
        if 'Array' in f.rangeTypeName:
            if attributes.get(f.name) and typesystem.get_type(f.elementType):
                print([ int(i) for i in attributes[f.name].split() ])
</code></pre>
<p>and that is the end...</p>
</div>
<div class="post-text" itemprop="text">
<p>Split will always return a list, try this.</p>
<pre><code>def split_it(s):
    if len(s.split()) &gt; 1:
        return s.split()
    else:
        return s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The behavior of <code>split</code> makes sense, it always returns a list. Why not just check if the list length is 1?</p>
<pre><code>def weird_split(a):
    words = a.split()
    if len(words) == 1:
        return words[0]
    return words
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the conditional expression to check for the presence of space, and use <code>split</code> only if a space is detected:</p>
<pre><code>str1 = 'abc'
split_str1 = str1 if (' ' not in str1) else str1.split(' ')
print (split_str1)
str1 = 'ab c'
split_str1 = str1 if (' ' not in str1) else str1.split(' ')
print (split_str1)
</code></pre>
<p>This would give the output:</p>
<pre><code>abc
['ab', 'c']
</code></pre>
</div>
<span class="comment-copy">split just returns a list.  that's what up.</span>
<span class="comment-copy">The method <code>.split()</code> applied to a string will always return a list of all the sub-strings in that spring, split by spaces (unless another splitting character is provided). <code>'a'</code> has one sub-string, namely <code>'a'</code> and that's what is returned in the list <code>['a']</code>.</span>
<span class="comment-copy">"I only want a list when I have whitespace in my string" - bad idea. It's much easier to work with a result that's consistently a list, instead of sometimes a string and sometimes a list. A <code>str.split</code> that worked the way you ask for would be a major source of bugs.</span>
<span class="comment-copy"><code>.split()</code> always returns a list even if does not split the string, and this is probably the more consistent behaviour. See <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str.split</a></span>
<span class="comment-copy">You're falling into a common newbie trap, where you think "wouldn't it be easier if the result of this operation was just a single [thing] instead of a [container] of [things] when there's only one [thing], so I don't have to get the [thing] out of the [container]", but in fact, not having a consistent return type means you have to write <i>more</i> code to conditionally work with either a single thing or a container of things. In fact, you usually end up putting the single thing in a container anyway, as the easiest way to deal with both cases.</span>
<span class="comment-copy">Thanks! It's been a LONG day. I think it's time to quit! Oy!</span>
<span class="comment-copy">Np! 10 points for throwing as much as you did at it, looks gruelling.</span>
<span class="comment-copy">I've had worse. Needed to determine if a feature/attribute in an XMI annotation/tag is a representation of an array. It's just Monday dead brain syndrome.</span>
<span class="comment-copy">@horcle_buzz: This seems like a bad way to check that. After all, your attribute could be a representation of an array that happens to have only one element.</span>
<span class="comment-copy">Actually, I have it. I'm using a data structure (UIMA CAS) that has a defined type system definition file. I can just search the type system file for attributes/features that are arrays!  Thanks @user2357112 for getting me to think a bit deeper.</span>
