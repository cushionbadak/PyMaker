<div class="post-text" itemprop="text">
<pre><code>class A{
  A();
  void a();
  virtual void v();
}
</code></pre>
<p>make this to liba.so</p>
<pre><code>class B : A {
  B();
  void b();
  void v();
}
extern "C" {
  A* newB() {
    return new B();
  }
  void calla(A*b) {
    b-&gt;a();
  }
  void callv(A*b) {
     b-&gt;v();
  }
}
</code></pre>
<p>make this to libb.so</p>
<p>in python:</p>
<pre><code>from ctypes import cdll 
lib = cdll.LoadLibrary('./libb.so')

class B(object):
  def __init__(self):
    self.obj = lib.newb()
  def a(self):
    lib.calla(self.obj)
  def v(self):
    lib.callv(self.obj)

b = B()
b.a()  # call base class function, that's ok
b.v()  # call derive class virtual function , segment fault!
</code></pre>
<p>Does this mean python cant use dll including inheritance logic?</p>
<p>seems python cant call c++ class as its function entrance changed bc inherit logic, can anyone talk about this?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Notes</strong>:</p>
<ul>
<li>Neither of the code (<em>C</em> or <em>Python</em>) compiled <em>OOTB</em>. That is because it was either incomplete or incorrect. Check <a href="https://stackoverflow.com/help/mcve">[SO]: How to create a Minimal, Complete, and Verifiable example (mcve)</a> for how to format your questions</li>
<li><a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer">[Python 3]: ctypes - A foreign function library for Python</a> might be useful</li>
<li>The <em>virtual</em> method had nothing to do with the error, it was just a coincidence, the error is because of <strong><em>argtypes</em> and <em>restype</em> not being specified</strong>. Check <a href="https://stackoverflow.com/questions/53182796/python-ctypes-issue-on-different-oses/53185316#53185316">[SO]: python ctypes issue on different OSes (@CristiFati's answer)</a> (<a href="https://stackoverflow.com/questions/52268294/python-ctypes-cdll-loadlibrary-instantiate-an-object-execute-its-method-priva/52272969#52272969">[SO]: Python ctypes cdll.LoadLibrary, instantiate an object, execute its method, private variable address truncated (@CristiFati's answer)</a>, or many others) for details</li>
</ul>
<p>I've prepared a full (and dummy) example, to illustrate the behavior.</p>
<p><em>a.h</em>:</p>
<pre class="lang-c prettyprint-override"><code>#pragma once
#define COUT() std::cout &lt;&lt; __FILE__ &lt;&lt; ":" &lt;&lt; __LINE__ &lt;&lt; "(" &lt;&lt; __FUNCTION__ &lt;&lt; ")\n"

#if defined(_WIN32)
#  define DLL_EXPORT __declspec(dllexport)
#else
#  define DLL_EXPORT
#endif


class DLL_EXPORT A {
public:
    A();
    virtual ~A();
    void a();
    virtual void v();
};
</code></pre>
<p><em>a.cpp</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "a.h"
#include &lt;iostream&gt;


A::A() {
    COUT();
}

A::~A() {
    COUT();
}

void A::a() {
    COUT();
}

void A::v() {
    COUT();
}
</code></pre>
<p><em>b.h</em>:</p>
<pre class="lang-c prettyprint-override"><code>#pragma once
#include "a.h"


class B : public A {
public:
    B();
    void b();
    void v();
};


extern "C" {
    DLL_EXPORT A *newB() {
        return new B();
    }

    DLL_EXPORT void calla(A *b) {
        b-&gt;a();
    }

    DLL_EXPORT void callv(A *b) {
        b-&gt;v();
    }

    DLL_EXPORT void delB(A *b)
    {
        delete b;
    }
}
</code></pre>
<p><em>b.cpp</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include "b.h"
#include &lt;iostream&gt;


B::B() : 
    A() {
    COUT();
}

void B::b() {
    COUT();
}

void B::v() {
    COUT();
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import ctypes


LIB_NAME = "./libb.so"


class B(object):

    def __init__(self, lib_name=LIB_NAME):
        self.lib = ctypes.cdll.LoadLibrary(lib_name)
        self.lib.newB.restype = ctypes.c_void_p
        self.obj = self.lib.newB()

    def a(self):
        self.lib.calla.argtypes = [ctypes.c_void_p]
        self.lib.calla(self.obj)

    def v(self):
        self.lib.callv.argtypes = [ctypes.c_void_p]
        self.lib.callv(self.obj)

    def __del__(self):
        self.lib.delB.argtypes = [ctypes.c_void_p]
        self.lib.delB(self.obj)
        self.obj = None
        self.lib = None


def main():
    b = B()
    b.a()
    b.v()


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-c prettyprint-override"><code>[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054646019]&gt; ls
a.cpp  a.h  b.cpp  b.h  code.py
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054646019]&gt; g++ -shared -fPIC -o liba.so a.cpp
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054646019]&gt; g++ -shared -fPIC -o libb.so b.cpp ./liba.so
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054646019]&gt; ls
a.cpp  a.h  b.cpp  b.h  code.py  liba.so  libb.so
[cfati@cfati-5510-0:/cygdrive/e/Work/Dev/StackOverflow/q054646019]&gt; python3 code.py
Python 3.6.4 (default, Jan  7 2018, 15:53:53)
[GCC 6.4.0] on cygwin

a.cpp:6(A)
b.cpp:7(B)
a.cpp:14(a)
b.cpp:15(v)
a.cpp:10(~A)
</code></pre>
</blockquote>
</div>
<span class="comment-copy"><code>s.v()</code>? Where does <code>s</code> come from? <code>o.O</code></span>
<span class="comment-copy">This doesn't answer your question (which is also quite vague), but if you need to wrap a C++ library you can take a look at pybind11: <a href="https://pybind11.readthedocs.io/en/stable/" rel="nofollow noreferrer">pybind11.readthedocs.io/en/stable</a> instead of making a C-version of your lib and using ctypes.</span>
<span class="comment-copy">typo, thats b @JoeyMallone</span>
<span class="comment-copy">thanks, i will try pybind11 @HannesOvr√©n</span>
<span class="comment-copy">Be aware that C++ ABI varies across different compilers and sometimes even within same compiler family but different versions. So you usually cannot even use a C++ library built with GCC from within MSVC. If you try pybind or similar, you likely will have to compile both (pybind and your dll) with the same compiler to get it running.</span>
