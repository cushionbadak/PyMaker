<div class="post-text" itemprop="text">
<p>I have created following dictionary <code>test</code>, consisting of <code>Series</code> objects:</p>
<pre><code>test = {
    'A': pd.Series([True, False, True]),
    'B' : pd.Series([True,False,False])
}
</code></pre>
<p>I would like to perfrom <code>test['A'] &amp; test['B']</code>. My problem is that I want to perfrom bit-wise addition for any possible number of keys in the dictionary. (I.e. it can be <code>'A'</code> or <code>'A' and 'B'</code> or <code>'A' and 'B' and 'C'</code> etc.). In any case, the value for each key has the same length, and all the <code>Series</code> are boolean.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many advantages to working with a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="nofollow noreferrer"><code>DataFrame</code></a> instead of a dictionary of <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html" rel="nofollow noreferrer"><code>Series</code></a> objects. Converting from the latter to the former is trivial:</p>
<pre><code>&gt;&gt;&gt; df = pd.DataFrame(test)
&gt;&gt;&gt; df
       A      B
0   True   True
1  False  False
2   True  False
</code></pre>
<p>While the <code>DataFrame</code> constructor is pretty smart about parsing the input data, you could explicitly tell it you are initializing from a dictionary by using the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.from_dict.html#pandas.DataFrame.from_dict" rel="nofollow noreferrer"><code>from_dict</code></a> <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a>:</p>
<pre><code>&gt;&gt;&gt; df = pd.DataFrame.from_dict(test)
</code></pre>
<p>Now you can apply <code>&amp;</code> using the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all" rel="nofollow noreferrer"><code>all</code></a> method along any axis you want:</p>
<pre><code>&gt;&gt;&gt; df.all(axis=1) # going across
0     True
1    False
2    False
dtype: bool
</code></pre>
<p>The same goes for <code>|</code> using <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any" rel="nofollow noreferrer"><code>any</code></a>:</p>
<pre><code>&gt;&gt;&gt; df.any(axis=1)
0     True
1    False
2     True
dtype: bool
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a simple one-line solution to your problem (if you want cumulative <code>and</code> operation over columns e.g. <code>A and B</code>, <code>A and B and C</code>, <code>A and B and C and D</code> and so on):</p>
<pre><code>import pandas as pd

test = {
    "A": pd.Series([True, True, True]),
    "B": pd.Series([True, False, False]),
    "C": pd.Series([False, True, False]),
    "D": pd.Series([True, False, False]),
}

df = pd.DataFrame.from_dict(test)

# Here is da man    
print(df.cummin(axis="columns"))
</code></pre>
<p>Using <code>cummin</code>, if any value is <code>False</code>, all coming after it will be <code>False</code> as well as it's the smallest value.</p>
<p>Original dataframe:</p>
<pre><code>      A      B      C      D
0  True   True  False   True
1  True  False   True  False
2  True  False  False  False
</code></pre>
<p>Cumulative <code>and</code>:</p>
<pre><code>      A      B      C      D
0  True   True  False  False
1  True  False  False  False
2  True  False  False  False
</code></pre>
<p>First column is <code>A</code>, second is <code>A and B</code>, third <code>A and B and C</code>, last is <code>A and B and C and D</code>.</p>
</div>
<span class="comment-copy">Why not use a DataFrame?</span>
<span class="comment-copy">Question: do you want to perform the bitwise of the KEYS or actually of the VALUES? When I read bitwise of the KEYS, I literally interpret as: 'A' | 'B'</span>
<span class="comment-copy">Indeed by converting to dataframe, it is straight forward. Many thanks! I understand that Series do not provide this kind of manipulation in an easy way.</span>
<span class="comment-copy">@NSK. They do, but not for an arbitrary number of them.</span>
