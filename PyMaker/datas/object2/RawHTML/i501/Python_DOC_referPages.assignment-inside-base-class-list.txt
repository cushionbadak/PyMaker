<div class="post-text" itemprop="text">
<p>When reading the <code>typing</code> module source I noticed following:</p>
<pre class="lang-py prettyprint-override"><code>class _SpecialForm(_Final, _Immutable, _root=True):
    ...
</code></pre>
<p>Here, an assignment is inside the base class list.</p>
<p>Later, it's checked in:</p>
<pre class="lang-py prettyprint-override"><code>class _Final:
    def __init_subclass__(self, *args, **kwds):
        if '_root' not in kwds:
            raise TypeError("Cannot subclass special typing classes")
</code></pre>
<p>Where exactly does <code>_root</code> end up? Docs refer to it as "class keyword arguments" (<a href="https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>init_subclass</strong></a>), but I couldn't find any further info on this.</p>
</div>
<div class="post-text" itemprop="text">
<p>A class keyword argument is any kwyword argument that is passed in the class declaration. Only one such argument have a special treatment - <code>metaclass=</code> - this one dictates the callable that will be used to provide the metaclass.</p>
<p>Any other keyword argument there is passed as is to the metaclass <code>__new__</code> and <code>__init__</code> methods, and to any superclass <code>__init_subclass__</code> method. These are not treated in a special way, and, above all, are not "base classes" - the methods mentioned before will receive these keyword arguments normally as any Python method: they may be declared in the method signature, or they may accept the <code>**kwargs</code> dictionary (which is the case).</p>
<p>It is worth mentioning that passing such arguments with a proper <code>__init_subclass__</code> method in the superclasses that will "swallow" it, the class declaration will fail with a <code>TypeError</code> due to the unrecognized argument to <code>object</code>'s <code>__init_subclass__</code>. In contrast, the default metaclass implementation of <code>__new__</code> and <code>__init__</code> on the <code>type</code> class will simply ignore any extra keywords passed.</p>
<p>Thus:</p>
<pre><code>In [1]: class A(test=None): 
   ...:     pass 
   ...:            
</code></pre>
<p>fails with: </p>
<pre><code>TypeError: __init_subclass__() takes no keyword arguments
</code></pre>
<p>While:</p>
<pre><code>In [2]: class A: 
   ...:     def __init_subclass__(cls, **kwd): 
   ...:         super().__init_subclass__(cls)
   ...:                                                                                 

In [3]: class B(A, test=None): 
   ...:     pass 
   ...:           
</code></pre>
<p>works with no problems. (<code>A.__init_subclass__</code> kwd will be passed <code>{"test": None}</code>)</p>
</div>
<span class="comment-copy">What do you mean where does it end up? Like other methods, if you don't override it it'll end up calling the root implementation, <code>object.__init_subclass__</code> (which doesn't accept any keyword arguments). It's not an assignment, it's a keyword argument, as the docs describe it.</span>
<span class="comment-copy">You already found it. It ends up as an argument to <code>__init_subclass__</code>. (In this specific case, at least. Generally speaking, it could also go to the metaclass's <code>__new__</code>.)</span>
<span class="comment-copy">So its literally only effect is getting passed to <code>__init_subclass__</code>?</span>
