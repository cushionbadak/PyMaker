<div class="post-text" itemprop="text">
<p>New to Python here.</p>
<p>I am looking for a simple way of creating a list (Output), which returns the count of the elements of another objective list (MyList) while preserving the indexing(?).</p>
<p>This is what I would like to get:</p>
<pre><code>MyList = ["a", "b", "c", "c", "a", "c"]
Output = [ 2 ,  1 ,  3 ,  3 ,  2 ,  3 ]
</code></pre>
<p>I found solutions to a similar problem. Count the number of occurrences for each element in a list.</p>
<pre><code>In  : Counter(MyList)
Out : Counter({'a': 2, 'b': 1, 'c': 3})
</code></pre>
<p>This, however, returns a Counter object which doesn't preserve the indexing.</p>
<p>I assume that given the keys in the Counter I could construct my desired output, however I am not sure how to proceed.</p>
<p>Extra info, I have pandas imported in my script and MyList is actually a column in a pandas dataframe.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of listcomp as in another solution you can use the function <code>itemgetter()</code>:</p>
<pre><code>from collections import Counter
from operator import itemgetter

MyList = ["a", "b", "c", "c", "a", "c"]

c = Counter(MyList)
itemgetter(*MyList)(c)
# (2, 1, 3, 3, 2, 3)
</code></pre>
<p>UPDATE: As @ALollz mentioned in the comments this solution seems to be the fastet one. If OP needs a list instead of a tuple the result must be converted wih <code>list()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer"><code>list.count</code></a> method, which will count the amount of times each string takes place in <code>MyList</code>. You can generate a new list with the counts by using a <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>MyList = ["a", "b", "c", "c", "a", "c"]

[MyList.count(i) for i in MyList]
# [2, 1, 3, 3, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>np.unique</code> to create a dictionary of value counts and map the values. This will be fast, though not as fast as the Counter methods:</p>
<pre><code>import numpy as np

list(map(dict(zip(*np.unique(MyList, return_counts=True))).get, MyList))
#[2, 1, 3, 3, 2, 3]
</code></pre>
<hr/>
<p>Some timings for a moderate sized list:</p>
<pre><code>MyList = np.random.randint(1, 2000, 5000).tolist()

%timeit [MyList.count(i) for i in MyList]
#413 ms ± 165 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit list(map(dict(zip(*np.unique(MyList, return_counts=True))).get, MyList))
#1.89 ms ± 1.73 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%timeit pd.DataFrame(MyList).groupby(MyList).transform(len)[0].tolist()
#2.18 s ± 12.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

c=Counter(MyList)
%timeit lout=[c[i] for i in MyList]
#679 µs ± 2.33 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

c = Counter(MyList)
%timeit list(itemgetter(*MyList)(c))
#503 µs ± 162 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>Larger list:</p>
<pre><code>MyList = np.random.randint(1, 2000, 50000).tolist()

%timeit [MyList.count(i) for i in MyList]
#41.2 s ± 5.27 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit list(map(dict(zip(*np.unique(MyList, return_counts=True))).get, MyList))
#18 ms ± 56.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit pd.DataFrame(MyList).groupby(MyList).transform(len)[0].tolist()
#2.44 s ± 12.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

c=Counter(MyList)
%timeit lout=[c[i] for i in MyList]
#6.89 ms ± 22.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

c = Counter(MyList)
%timeit list(itemgetter(*MyList)(c))
#5.27 ms ± 10.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You just need to implement below piece of code</p>
<pre><code>    c=Counter(MyList)
    lout=[c[i] for i in MyList]
</code></pre>
<p>now list <em>lout</em> is your desired output</p>
</div>
<div class="post-text" itemprop="text">
<p>A pandas solution looks like this:</p>
<pre><code>df = pd.DataFrame(data=["a", "b", "c", "c", "a", "c"], columns=['MyList'])
df['Count'] = df.groupby('MyList')['MyList'].transform(len)
</code></pre>
<p><strong>Edit</strong>: One shouldn't use pandas if this is the only thing you want to do. I only answered this question because of the pandas tag.</p>
<p>The performance depends on the number of groups:</p>
<pre><code>MyList = np.random.randint(1, 10, 10000).tolist()
df = pd.DataFrame(MyList)

%timeit [MyList.count(i) for i in MyList]
# 1.32 s ± 15.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
%timeit df.groupby(0)[0].transform(len)
# 3.89 ms ± 112 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

MyList = np.random.randint(1, 9000, 10000).tolist()
df = pd.DataFrame(MyList)

%timeit [MyList.count(i) for i in MyList]
# 1.36 s ± 11.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
%timeit df.groupby(0)[0].transform(len)
# 1.33 s ± 19.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one from the hettinger's classic snippets :)</p>
<pre><code>from collections import Counter, OrderedDict

class OrderedCounter(Counter, OrderedDict):
     'Counter that remembers the order elements are first seen'
     def __repr__(self):
         return '%s(%r)' % (self.__class__.__name__,
                            OrderedDict(self))
     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)

x = ["a", "b", "c", "c", "a", "c"]
oc = OrderedCounter(x)
&gt;&gt;&gt; oc
OrderedCounter(OrderedDict([('a', 2), ('b', 1), ('c', 3)]))
&gt;&gt;&gt; oc['a']
2
</code></pre>
</div>
<span class="comment-copy">perhaps <code>list(itemgetter(*MyList)(c))</code> to match the output, but I'm surprised this doesn't have more votes. Seems to be the fastest solution</span>
<span class="comment-copy">@ALollz Nice! You are right about the list. I thought it’s easy and OP probably knows how to do it. Maybe he needs just an array.</span>
<span class="comment-copy">Definitely the fastest, I have a follow-up question thou. Does importing extra modules have any negative effect on the code performance? I had previously implemented @ALollz 's solution as it looked the fastest and didn't require any module and (most probably) I would import itemgetter and Counter just for this operation</span>
<span class="comment-copy">works on the example but it doesn't on my list. It returns the following: KeyError: 'Level 1111111111ABC11111 not found'. (which is the first element I am counting)</span>
<span class="comment-copy">Can you share your actual list? @Gio</span>
<span class="comment-copy">Nope, unfortunately I can't. The best I can do is give you a masked example, not sure it can be of any help. I can confirm that the elements are strings thou: <code>In   : type(df.iloc[1]["MyList"])</code> <code>Out: str</code></span>
<span class="comment-copy">Hmm this should be working fine, make sure you are MyList is actually a list. And also that you are using it both to iterate in the list comprehension and to count the values.</span>
<span class="comment-copy">Well a pandas series is not a list @Gio. This is a list method. You can turn your series to a list with <code>Series.tolist()</code></span>
<span class="comment-copy">Interesting to see how much more optimised <code>Counter</code> is for this task</span>
<span class="comment-copy">Yes, I was really surprised. One of these days I'll install <code>perfplot</code> to make it easier to see.</span>
<span class="comment-copy">Hope I would be able to see the plot. would be very interesting. :)</span>
<span class="comment-copy">You might want to initialise the Counter outside the list comprehension, and then simply access its values, rather than creating <code>len(MyList)</code> Counters</span>
<span class="comment-copy">@yatu yes you are right. Since it was a small list, I have just given it as in one line.I have edited the answer now. :)</span>
<span class="comment-copy">Works perfectly but it gets slow quite fast (just tried on a sample dataset with 15k observations)</span>
