<div class="post-text" itemprop="text">
<p>When one uses <a href="https://github.com/pybind/pybind11" rel="nofollow noreferrer">pybind</a> to create python-c++ bindings, upon compilation pybind creates a <code>*.so</code> file. AFAIK the compilation step in pybind just uses the c++ compiler, so this should be no different from just regular shared libs that one would create for a normal c++ code. How does the python interpreter introspect into these <code>*.so</code> files to notice that there are python-compatible modules in them?</p>
</div>
<div class="post-text" itemprop="text">
<p>Ultimately, you'll want to look at the CPython docs for how C extensions work. From the docs: <a href="https://docs.python.org/3/extending/building.html" rel="nofollow noreferrer">https://docs.python.org/3/extending/building.html</a></p>
<blockquote>
<p>A C extension for CPython is a shared library (e.g. a .so file on Linux, .pyd on Windows), which exports an initialization function.</p>
</blockquote>
<p>As it says here, the primary difference is that it defines its initialization / entry point function.</p>
<p>All <code>pybind</code> does is wrap this entry point via <code>PYBIND11_MODULE</code>:
<a href="https://pybind11.readthedocs.io/en/stable/basics.html#creating-bindings-for-a-simple-function" rel="nofollow noreferrer">https://pybind11.readthedocs.io/en/stable/basics.html#creating-bindings-for-a-simple-function</a>
<a href="https://github.com/pybind/pybind11/blob/25abf7e/include/pybind11/detail/common.h#L283" rel="nofollow noreferrer">https://github.com/pybind/pybind11/blob/25abf7e/include/pybind11/detail/common.h#L283</a></p>
</div>
