<div class="post-text" itemprop="text">
<p>I know that Python is a dynamically typed language, and that I am likely trying to recreate Java behavior here. However, I have a team of people working on this code base, and my goal with the code is to ensure that they are doing things in a consistent manner. Let me give an example:</p>
<pre><code>class Company:
    def __init__(self, j):
        self.locations = []
</code></pre>
<p>When they instantiate a Company object, an empty list that holds locations is created. Now, with Python anything can be added to the list. However, I would like for this list to only contain Location objects:</p>
<pre><code>class Location:
    def __init__(self, j):
        self.address = None
        self.city = None
        self.state = None
        self.zip = None
</code></pre>
<p>I'm doing this with classes so that the code is self documenting. In other words, "location has only these attributes". My goal is that they do this:</p>
<pre><code>c = Company()
l = Location()
l.city = "New York"
c.locations.append(l)
</code></pre>
<p>Unfortunately, nothing is stopping them from simply doing <code>c.locations.append("foo")</code>, and nothing indicates to them that <code>c.locations</code> should be a list of Location objects.</p>
<p>What is the Pythonic way to enforce consistency when working with a team of developers?</p>
</div>
<div class="post-text" itemprop="text">
<p>An OOP solution is to make sure the users of your class' API do not have to interact directly with your instance attributes.</p>
<h1>Methods</h1>
<p>One approach is to implement methods which encapsulate the logic of adding a location.</p>
<h3>Example</h3>
<pre><code>class Company:
    def __init__(self, j):
        self.locations = []

    def add_location(self, location):
        if isinstance(location, Location):
            self.locations.append(location)
        else:
            raise TypeError("argument 'location' should be a Location object")
</code></pre>
<h1>Properties</h1>
<p>Another OOP concept you can use is a <a href="https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work">property</a>. Properties are a simple way to define getter and setters for your instance attributes.</p>
<h3>Example</h3>
<p>Suppose we want to enforce a certain format for a <code>Location.zip</code> attribute</p>
<pre><code>class Location:
    def __init__(self):
        self._zip = None

    @property
    def zip(self):
        return self._zip

    @zip.setter
    def zip(self, value):
        if some_condition_on_value:
            self._zip = value
        else:
            raise ValueError('Incorrect format')

    @zip.deleter
    def zip(self):
        self._zip = None
</code></pre>
<p>Notice that the attribute <code>Location()._zip</code> is still accessible and writable. While the underscore denotes what should be a private attribute, <a href="https://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private">nothing is really private in Python</a>.</p>
<h1>Final word</h1>
<p>Due to Python's high introspection capabilities, nothing will ever be totally safe. You will have to sit down with your team and discuss the tools and practice you want to adopt.</p>
<blockquote>
<p>Nothing is really private in python. No class or class instance can
  keep you away from all what's inside (this makes introspection
  possible and powerful). Python trusts you. It says "hey, if you want
  to go poking around in dark places, I'm gonna trust that you've got a
  good reason and you're not making trouble."</p>
<p>After all, we're all consenting adults here.</p>
<p>--- <a href="https://mail.python.org/pipermail/tutor/2003-October/025932.html" rel="nofollow noreferrer">Karl Fast</a></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You could also define a new class <code>ListOfLocations</code> that make the safety checks. Something like this</p>
<pre><code>class ListOfLocations(list):
   def append(self,l):
      if not isinstance(l, Location): raise TypeError("Location required here")
      else: super().append(l)
</code></pre>
</div>
<span class="comment-copy">You can use type hints and run a static analyser over the code, e.g. <code>mypy</code>. But this will not prevent runtime type errors. You could also look into <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclasses</code></a></span>
<span class="comment-copy">Did you look at e.g. this discussion : <a href="https://stackoverflow.com/questions/12569018/why-is-adding-attributes-to-an-already-instantiated-object-allowed" title="why is adding attributes to an already instantiated object allowed">stackoverflow.com/questions/12569018/…</a> ?</span>
<span class="comment-copy"><code>c.locations.append</code> is bad. Provide a method on your object that checks the type before appending. Users of this class should only use that method and shouldn't be touching <code>self.locations</code> directly. Conventionally, attributes that aren't part of the public API are marked with a single-underscore, so you could use <code>._locations</code> to let [people know: "don't touch this"</span>
<span class="comment-copy">@Demi-Lune The advantage that I get is that doing a <code>l.</code> in VS Code, PyCharm, etc, shows the end user what attributes I expect them to set. I did not realize that they could add any attribute they wanted, which is unfortunate.</span>
<span class="comment-copy">Also note that the type enforcement prevents duck typing (<a href="https://stackoverflow.com/questions/4205130/what-is-duck-typing">stackoverflow.com/questions/4205130/what-is-duck-typing</a>), which is a nice feature of python (imho). So the pythonic answer could be "make a nice developer's doc".</span>
<span class="comment-copy">Ah, I thought it was not Pythonic to have setters/getters. I guess it is different if the attribute is a list rather than a string?</span>
<span class="comment-copy">@FranzKafka It is perfectly pythonic. Python actually has a whole getter and setter protocol which you should definitely know about: <a href="https://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work" title="how does the property decorator work">stackoverflow.com/questions/17330160/…</a> I believe it will greatly help you with the issues you are facing.</span>
<span class="comment-copy">@FranzKafka this is not a setter. A setter would be something like <code>def set_locations(self, loc): self.loctions = loc</code> You shouldn't do that. You should use a regular attribute and of you want to control access at some point, you can re-factor using a <code>property</code></span>
<span class="comment-copy">@FranzKafka no, not at all. If you just want to <i>set or get</i> an instance attribute, then you just do it. Directly mutating the object referenced by an instance attribute is another matter.</span>
<span class="comment-copy"><code>@property</code> means the setter/getter implementation details are not exposed to the user, e.g. <code>obj.var = "foo"</code> works in both cases (setter function or basic attribute). But <code>obj.var.append()</code> is not the same thing.</span>
<span class="comment-copy">This is a good step, but does not prevent from using <code>ListOfLocations.extend</code>, <code>ListOfLocations.insert</code>, <code>ListOfLocations.__setitem__</code>, etc.</span>
<span class="comment-copy">Yes, it'd require redefining any syntax that we want to protect. It's probably a matter of taste with your answer. The only advantage of this one, is that it doesn't require any modification of the initial test-case.</span>
