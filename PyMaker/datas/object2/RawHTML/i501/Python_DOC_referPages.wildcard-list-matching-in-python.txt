<div class="post-text" itemprop="text">
<p>I have a list of strings</p>
<pre><code>l = [
   '/api/users/*',
   '/api/account/*
]
</code></pre>
<p>And paths are like</p>
<pre><code>/api/users/add/
/api/users/edit/1
/api/users/
/api/account/view/1
/api/account/
</code></pre>
<p>How can I perform filter for the paths if they exist in the list <code>l</code>.</p>
<p>condition like</p>
<pre><code>'/api/users/add/' in l
</code></pre>
<p>should return <code>True</code> and for all given paths above.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your wildcards are always the last thing in the query string, I recommend chopping it off and using <a href="https://stackoverflow.com/q/8802860/699305"><code>.startswith()</code></a>. Otherwise, use the <a href="https://docs.python.org/3/library/fnmatch.html" rel="nofollow noreferrer"><code>fnmatch</code></a> module which interprets "glob"-style wildcards:</p>
<pre><code>from fnmatch import fnmatch

def listglob(path, patterns):
    return any(fnmatch(path, pat) for pat in patterns)

for path in paths:
    print(path, listglob(path, l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [
   '/api/users/*',
   '/api/account/'
]

paths = [
'/api/users/add/'
'/api/users/edit/1',
'/api/users/',
'/api/account/view/1',
'/api/account/'
]

for path in paths:
    if path in l:
        print("Path: {}, found in the list".format(path))
</code></pre>
<p>OUTPUT:</p>
<pre><code>Path: /api/account/, found in the list
</code></pre>
<p><strong>EDIT:</strong></p>
<p>If you want a method that would return the boolean value:</p>
<pre><code>l = [
   '/api/users/*',
   '/api/account/'
]

paths = [
'/api/users/add/',
'/api/users/edit/1',
'/api/users/',
'/api/account/view/1',
'/api/account/'
]

def checkPath(path):
        if path in l:
            return True
        else:
            return False

for i in range(0,len(paths)):
    print(checkPath(paths[i]))
</code></pre>
<p>OUTPUT:</p>
<pre><code>False
False
False
False
True
</code></pre>
<p><strong>EDIT 2:</strong></p>
<p>If you want the <code>*</code> ones to match with the path, you can remove the <code>*</code> from the original list and then iterate like:</p>
<pre><code>def checkPath(path):
        if path in l_new:
            return True
        else:
            return False

# strip the asterick
l_new = [s.strip('*') for s in l]

for i in range(0,len(paths)):
    print(checkPath(paths[i]))
</code></pre>
<p>OUTPUT:</p>
<pre><code>False
False
True
False
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, you want to see if the wildcard pattern would hold true. For this you can use the <code>fnmatch</code> module from <code>glob</code>. Supposing you have this:</p>
<pre><code>l = [
   '/api/users/*',
   '/api/account/*'
]

paths = [
   '/api/users/add/'
   '/api/users/edit/1',
   '/api/users/',
   '/api/account/view/1',
   '/api/account/',
   '/non/existent/path'
]
</code></pre>
<p>You could get this:</p>
<pre><code>&gt;&gt;&gt; import fnmatch
&gt;&gt;&gt; [any(fnmatch.fnmatch(path, pat) for pat in l) for path in paths]
[True, True, True, True, False]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>fnmatch</code> solutions posted already are certainly recommended for this problem, however, the answer below demonstrates a non-import solution:</p>
<pre><code>def matchs_path(_pattern, _input):
  _a, _b = filter(None, _pattern.split('/')), filter(None, _input.split('/'))
  while True:
    _val, _val2 = next(_a, None), next(_b, None)
    if _val is None and _val2 is None:
      return True
    if _val != '*' and _val != _val2:
      return False
    if _val == "*":
      _to_see = next(_a, None)
      if _to_see is None:
        return True
      while True:
        c = next(_b, None)
        if c is None:
          return True
        if c == _to_see:
          break
</code></pre>
<hr/>
<pre><code>patterns = ['/api/users/*', '/api/account/*', '/new/*/test/here']
data = ['/api/users/add/', '/api/users/edit/1', '/api/users/', '/api/account/view/1', '/api/account/', '/going/to/fail/here', '/new/additional/abc/test/here']
new_results = {i:{c:matchs_path(i, c) for c in data} for i in patterns}
</code></pre>
<p>Output:</p>
<pre><code>{
 "/api/users/*": {
    "/api/users/add/": true,
    "/api/users/edit/1": true,
    "/api/users/": true,
    "/api/account/view/1": false,
    "/api/account/": false,
    "/going/to/fail/here": false,
    "/new/additional/abc/test/here": false
 },
  "/api/account/*": {
    "/api/users/add/": false,
    "/api/users/edit/1": false,
    "/api/users/": false,
    "/api/account/view/1": true,
    "/api/account/": true,
    "/going/to/fail/here": false,
    "/new/additional/abc/test/here": false
 },
 "/new/*/test/here": {
    "/api/users/add/": false,
    "/api/users/edit/1": false,
    "/api/users/": false,
    "/api/account/view/1": false,
    "/api/account/": false,
    "/going/to/fail/here": false,
    "/new/additional/abc/test/here": true
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Or a list comprehension:</p>
<pre><code>print('\n'.join(['Path: {}, found in the list'.format(path) for path in paths if path in l]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a regular expression to replace a <code>*</code> at the end of the path pattern with <code>.*</code> and than use those as regular expressions themselves to match the paths in the list.</p>
<pre><code>paths = ['/api/users/add/',
         '/api/users/edit/1',
         '/api/users/',
         '/api/account/view/1',
         '/api/account/',
         '/not/a/valid/path']
l = ['/api/users/*', '/api/account/*']
patterns = [re.compile(re.sub("\*$", ".*", s)) for s in l]

&gt;&gt;&gt; [path for path in paths if any(p.match(path) for p in patterns)]
['/api/users/add/',
 '/api/users/edit/1',
 '/api/users/',
 '/api/account/view/1',
 '/api/account/']
</code></pre>
</div>
<span class="comment-copy">Please <a href="https://stackoverflow.com/posts/54646743/edit">edit</a> your question and include the code you've written to solve this problem.</span>
<span class="comment-copy">If the wildcards are always at the end of a path, you don't need wildcard matching and you can just use prefix match. If you do need wildcard matching, use the appropriate library (<code>fnmatch</code>)</span>
<span class="comment-copy">What if there are paths in <code>l</code> that don't have a <code>*</code>, i.e. require a perfect match?</span>
<span class="comment-copy">@tobias_k The first Edit would work in that case, if you remove <code>*</code> from the <code>l</code> it would return <code>False False True False True</code></span>
<span class="comment-copy">But if you just remove the <code>*</code> how can you differentiate between paths that allow for a suffix and those that don't?</span>
<span class="comment-copy">Ah, in that case, I think the best shot would be <code>fnmatch</code> as described already!</span>
<span class="comment-copy"><code>fnmatch</code> is its own module, <code>glob</code> just uses it.</span>
<span class="comment-copy">@alexis thanks! I'll fix that.</span>
<span class="comment-copy">The question is titled "wildcard list matching". Where is your wildcard support?</span>
<span class="comment-copy">Or you could use <code>fnmatch.translate</code> to convert all wildcard symbols for you. But why bother, when Python also has support for the glob syntax?</span>
<span class="comment-copy">@alexis Yes, that's why I upvoted your answer. ;-)</span>
<span class="comment-copy">Heh, thanks :-o</span>
