<div class="post-text" itemprop="text">
<p>I'm writing an iterative solution for summation, and it seems to give the correct answer. But I'm told by my tutor that it's giving the wrong result for <code>non-commutative combine operations</code>. I went to google but I'm still unsure what exactly it means...  </p>
<p>Here is the recursive code I wrote:</p>
<pre><code>def sum(term, a, next, b):
    # First recursive version
    if a &gt; b:
        return 0
    else:
        return term(a) + sum(term, next(a), next, b)

def accumulate(combiner, base, term, a, next, b):
    # Improved version
    if a &gt; b:
        return base
    else:
        return combiner(term(a), accumulate(combiner, base, term, next(a), next, b))

print(sum(lambda x: x, 1, lambda x: x, 5))
print(accumulate(lambda x,y: x+y, 0, lambda x: x, 1, lambda x: x, 5))
# Both solution equate to - 1 + 2 + 3 + 4 + 5 
</code></pre>
<p>This is the iterative version I wrote that gives the wrong results for <code>non-commutative combine operations</code> - 
Edit: accumulate_iter gives the wrong results when <code>lambda x,y: x- y</code> is used for combiner</p>
<pre><code>def accumulate_iter(combiner, null_value, term, a, next, b):
    while a &lt;= b:
        null_value = combiner(term(a), null_value)
        a = next(a)
    return null_value
</code></pre>
<p>Hoping if someone could provide a solution for this iterative version of <code>accumulate</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You <code>accumulate_iter</code> works fine when the combiner is commutative, but it gives different result when the combiner is non-commutative. That's because the recursive <code>accumulate</code> combine elements from the back to the front, but the iterative version combine them from the front to the back.</p>
<p>So what we need to do is to make <code>accumulate_iter</code> combine from behind, and following is a rewritten <code>accumulate_iter</code>:</p>
<pre><code>def accumulate_iter(a, b, base, combiner, next, term):
    # we want to combine from behind, 
    # but it's hard to do that since we are iterate from ahead
    # here we first go through the process, 
    # and store the elements encounted into a list
    l = []
    while a &lt;= b:
        l.append(term(a))
        a = next(a)
    l.append(base)
    print(l)

    # now we can combine from behind!
    while len(l)&gt;1:
        l[-2] = combiner(l[-2], l[-1])
        l.pop()
    return l[0]
</code></pre>
</div>
<span class="comment-copy">Non-commutative just means that it's not guaranteed that <code>a + b == b + a</code>. You have to make sure that you are passing the operands to <code>+</code> in the order they appear in the sequence.</span>
<span class="comment-copy">Please clarify: a) <code>accumulate</code> is <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">itertools.accumulate</a>, b) if so: why are you trying to create own version of <code>sum</code> through already implemented <code>accumulate</code> - what is the purpose of such exercize?</span>
<span class="comment-copy">For example, list concatenation is not commutative. <code>[2] + [3] == [2,3] != [3,2] == [3] + [2]</code>.</span>
<span class="comment-copy">opps, sorry I put in the wrong function, just changed it</span>
<span class="comment-copy">oh @AlexYu the website is for a different question</span>
<span class="comment-copy">oh thank you! I realised that after thinking for awhile, but wasn't sure how I can edit the code to do so from back to front</span>
