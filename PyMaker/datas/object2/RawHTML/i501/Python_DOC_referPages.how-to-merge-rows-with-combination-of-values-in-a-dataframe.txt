<div class="post-text" itemprop="text">
<p>I have a DataFrame (df1) as given below</p>
<pre><code>    Hair  Feathers  Legs  Type  Count
 R1  1       NaN     0     1      1
 R2  1        0      Nan   1      32
 R3  1        0      2     1      4
 R4  1       Nan     4     1      27
</code></pre>
<p>I want to merge rows based by different combinations of the values in each column and also want to add the count values for each merged row. The resultant dataframe(df2) will look like this:</p>
<pre><code>    Hair  Feathers  Legs  Type  Count
 R1   1      0        0     1     33
 R2   1      0        2     1     36
 R3   1      0        4     1     59
</code></pre>
<p>The merging is performed in such a way that any <code>Nan</code> value will be merged with 0 or 1. In df2, R1 is calculated by merging the <code>Nan</code> value of Feathers (df1,R1)  with the 0 value of Feathers (df1,R2). Similarly, the value of 0 in Legs (df1,R1) is merged with <code>Nan</code> value of Legs (df1,R2). Then the count of R1 (1) and R2(32) are added. In the same manner R2 and R3 are merged because Feathers value in R2 (df1) is similar to R3 (df1) and Legs value of <code>Nan</code> is merged with 2 in R3 (df1) and the count of R2 (32) and R3 (4) are added. </p>
<p>I hope the explanation makes sense. Any help will be highly appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>A possible way to do it is by replicating each of the rows containing <code>NaN</code> and fill them with values for the column.</p>
<p>First, we need to get the possible not-null unique values per column:</p>
<pre><code>unique_values = df.iloc[:, :-1].apply(
       lambda x: x.dropna().unique().tolist(), axis=0).to_dict()   
&gt; unique_values
{'Hair': [1.0], 'Feathers': [0.0], 'Legs': [0.0, 2.0, 4.0], 'Type': [1.0]}
</code></pre>
<p>Then iterate through each row of the dataframe and replace each <code>NaN</code> by the possible values for each column. We can do this using <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html" rel="nofollow noreferrer"><code>pandas.DataFrame.iterrows</code></a>:</p>
<pre><code>mask = df.iloc[:, :-1].isnull().any(axis=1)

# Keep the rows that do not contain `Nan`
# and then added modified rows

list_of_df = [r for i, r in df[~mask].iterrows()]

for row_index, row in df[mask].iterrows(): 

    for c in row[row.isnull()].index: 

        # For each column of the row, replace 
        # Nan by possible values for the column

        for v in unique_values[c]: 

            list_of_df.append(row.copy().fillna({c:v})) 

df_res = pd.concat(list_of_df, axis=1, ignore_index=True).T
</code></pre>
<p>The result is a dataframe where all the <code>NaN</code> have been filled with possible values for the column:</p>
<pre><code>&gt; df_res

   Hair  Feathers  Legs  Type  Count
0   1.0       0.0   2.0   1.0    4.0
1   1.0       0.0   0.0   1.0    1.0
2   1.0       0.0   0.0   1.0   32.0
3   1.0       0.0   2.0   1.0   32.0
4   1.0       0.0   4.0   1.0   32.0
5   1.0       0.0   4.0   1.0   27.0
</code></pre>
<p>To get the final result of <code>Count</code> grouping by possible combinations of <code>['Hair', 'Feathers', 'Legs', 'Type']</code> we just need to do:</p>
<pre><code>&gt; df_res.groupby(['Hair', 'Feathers', 'Legs', 'Type']).sum().reset_index()  

   Hair  Feathers  Legs  Type  Count
0   1.0       0.0   0.0   1.0   33.0
1   1.0       0.0   2.0   1.0   36.0
2   1.0       0.0   4.0   1.0   59.0
</code></pre>
<p>Hope it serves</p>
<p><strong>UPDATE</strong></p>
<p>If one or more of the elements in the row are missing, the procedure looking for all the possible combinations for the missing values at the same time. Let us add a new row with two elements missing:</p>
<pre><code>&gt; df

   Hair  Feathers  Legs  Type  Count
0   1.0       NaN   0.0   1.0    1.0
1   1.0       0.0   NaN   1.0   32.0
2   1.0       0.0   2.0   1.0    4.0
3   1.0       NaN   4.0   1.0   27.0
4   1.0       NaN   NaN   1.0   32.0
</code></pre>
<p>We will proceed in similar way, but the replacements combinations will be obtained using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product</a>:</p>
<pre><code> import itertools 

 unique_values = df.iloc[:, :-1].apply(
       lambda x: x.dropna().unique().tolist(), axis=0).to_dict()

 mask = df.iloc[:, :-1].isnull().any(axis=1) 

 list_of_df = [r for i, r in df[~mask].iterrows()] 

 for row_index, row in df[mask].iterrows():  

     cols = row[row.isnull()].index.tolist() 

     for p in itertools.product(*[unique_values[c] for c in cols]): 

         list_of_df.append(row.copy().fillna({c:v for c, v in zip(cols, p)}))

 df_res = pd.concat(list_of_df, axis=1, ignore_index=True).T       


&gt; df_res.sort_values(['Hair', 'Feathers', 'Legs', 'Type']).reset_index(drop=True)

Hair  Feathers  Legs  Type  Count
1   1.0       0.0   0.0   1.0    1.0
2   1.0       0.0   0.0   1.0   32.0
6   1.0       0.0   0.0   1.0   32.0
0   1.0       0.0   2.0   1.0    4.0
3   1.0       0.0   2.0   1.0   32.0
7   1.0       0.0   2.0   1.0   32.0
4   1.0       0.0   4.0   1.0   32.0
5   1.0       0.0   4.0   1.0   27.0
8   1.0       0.0   4.0   1.0   32.0

&gt; df_res.groupby(['Hair', 'Feathers', 'Legs', 'Type']).sum().reset_index()

   Hair  Feathers  Legs  Type  Count
0   1.0       0.0   0.0   1.0   65.0
1   1.0       0.0   2.0   1.0   68.0
2   1.0       0.0   4.0   1.0   91.0
</code></pre>
</div>
<span class="comment-copy">(for @eshfaq ahamed)Hello, Actully I don't know ans of your question, I wish you get back your correct ans soon, currently I work in project "data analysis" for matrices I use numpy array, but the structure is not good, your data structure is very good, How create this type of data structure, can you help me, I need also the labeling. (Note (for admin): I post this as ans because I am not eligible to comment, but I need the eligibility this is very help full as A developer. Thank you</span>
<span class="comment-copy">so why is 27+4 not added?</span>
<span class="comment-copy">@anky_91 because the value for Legs in R3 is 2 and for Legs in R4 is 4. If both the values were similar then 27 will be added to 4.</span>
<span class="comment-copy">thank you so much for the comprehensive solution. It does works nicely for the example I gave but if another column is included to the dataframe (df1) it doesn't remove all the <code>NaN</code> values. I thought about it and it looks like the code looks to each row and considers only one empty cell. If the number of empty cells are more than 1 then <code>Nan</code> values appear. For example if R2 in df1 is like this <code>1  NaN  NaN  1  32</code> then the output for this row will be <code>1  0  NaN 1  32</code>, <code>1  NaN  0  1  32</code>, <code>1  NaN  2  1  4</code> and <code>1  NaN 4  1  27</code>. Is there a solution for this??</span>
<span class="comment-copy">That has to be done in a different way since we have to take into account all possible combinations to substitute. Take a look now.</span>
<span class="comment-copy">Thank you so much for all the help. It worked very well. Can't Thank you enough</span>
