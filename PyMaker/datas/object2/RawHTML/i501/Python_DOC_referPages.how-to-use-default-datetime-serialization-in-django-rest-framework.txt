<div class="post-text" itemprop="text">
<p>I've got a Django REST Framework serializer containing the following:</p>
<pre><code>from rest_framework import serializers


class ThingSerializer(serializers.ModelSerializer):
    last_changed = serializers.SerializerMethodField(read_only=True)

    def get_last_changed(self, instance: Thing) -&gt; str:
        log_entry = LogEntry.objects.get_for_object(instance).latest()

        representation: str = serializers.DateTimeField('%Y-%m-%dT%H:%M:%SZ').to_representation(log_entry.timestamp)
        return representation
</code></pre>
<p>This is problematic because if the datetime formatting ever changes it will be different to all the other <code>datetime</code>s. I want to <strong>reuse the code path which DRF uses to serialize other <code>datetime</code> fields.</strong></p>
<p>What I've tried so far:</p>
<ul>
<li>The only <a href="https://stackoverflow.com/a/5781657/96588">answer</a> which looked relevant doesn't actually produce the same result as DRF (it includes milliseconds, which DRF does not), presumably because it's using the Django rather than DRF serializer.</li>
<li><code>rest_framework.serializers.DateTimeField().to_representation(log_entry.timestamp)</code>, <code>rest_framework.fields.DateTimeField().to_representation(log_entry.timestamp)</code> and <code>rest_framework.fields.DateTimeField(format=api_settings.DATETIME_FORMAT).to_representation(log_entry.timestamp)</code> don't work either; they produce strings with microsecond accuracy. I've verified with a debugger that DRF calls the latter when serializing other fields, so I can't understand why it produces a different result in my case.</li>
<li><p><code>LogEntry.timestamp</code> is declared as a <code>django.db.DateTimeField</code>, but if I try something like <code>LogEntry.timestamp.to_representation(log_entry.timestamp)</code> it fails badly:</p>
<blockquote>
<p>AttributeError: 'DeferredAttribute' object has no attribute 'to_representation'</p>
</blockquote></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Taking a look through the source of DRF, the interesting stuff is happening in <code>rest_framework/fields.py</code>.</p>
<p>In particular, all of the formatting stuff is happening directly in the <code>DateTimeField.to_representation</code> method.</p>
<p>You have a couple of ways of replicating DRF's behaviour.</p>
<hr/>
<p>First, you could just not pass a format at all. DRF should use its default if you don't explicitly supply a format.</p>
<pre><code>representation: str = serializers.DateTimeField().to_representation(log_entry.timestamp)
</code></pre>
<hr/>
<p>Alternatively, keep doing what you're doing, but explicitly pass the format string from DRF's <code>api_settings.DATETIME_FORMAT</code>. This might feel less magical, but honestly it's probably more brittle to API changes in the future.</p>
<p>This might look like:</p>
<pre><code>from rest_framework.settings import api_settings
...
representation: str = serializers.DateTimeField(api_settings.DATETIME_FORMAT).to_representation(log_entry.timestamp)
</code></pre>
<hr/>
<p>However, given that you attempted the first and it failed, we need to look a bit deeper!</p>
<p>The default DateFormat for DRF is <code>ISO_8601</code>, which has the <a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/fields.py#L1236" rel="nofollow noreferrer">following code</a> in it:</p>
<pre><code>value = value.isoformat()
if value.endswith('+00:00'):
    value = value[:-6] + 'Z'
    return value
</code></pre>
<p>That is, it effectively just leans on the python <code>isoformat</code> function.</p>
<p><code>isoformat</code> will format differently <strong>if the value has microseconds or not</strong>.</p>
<p>From the <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat" rel="nofollow noreferrer">Python docs</a>, <code>isoformat</code> will:</p>
<blockquote>
<p>Return a string representing the date and time in ISO 8601 format, YYYY-MM-DDTHH:MM:SS.ffffff or, if microsecond is 0, YYYY-MM-DDTHH:MM:SS</p>
</blockquote>
<p>In this case, the solution is to explicitly set the microseconds to <strong>zero</strong> in the timestamp. There are a couple of ways to do this, but we can switch to a Unix timestamp, clip to seconds, and back again</p>
<pre><code>ts = int(log_entry.timestamp)
representation: str = serializers.DateTimeField().to_representation(ts)
</code></pre>
<p>or keep using the DateTime object directly, which will have better timezone handling:</p>
<pre><code>representation: str = serializers.DateTimeField().to_representation(
        logentry.replace(microsecond=0)
    )
</code></pre>
</div>
<span class="comment-copy">I tried the first one already, and it produced a different format from all my other datetime fieldsâ€¦</span>
<span class="comment-copy">I added an update :)</span>
<span class="comment-copy">You're right, the milliseconds change the formatting! Frig!</span>
