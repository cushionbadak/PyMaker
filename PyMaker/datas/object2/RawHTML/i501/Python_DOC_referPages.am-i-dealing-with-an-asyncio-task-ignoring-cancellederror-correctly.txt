<div class="post-text" itemprop="text">
<p>I'm not asking how to cancel such task. It is not possible and it it is explained here: <a href="https://stackoverflow.com/a/33578893/5378816">https://stackoverflow.com/a/33578893/5378816</a></p>
<p>My concern is this change in <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer">wait_for</a>:</p>
<blockquote>
<p>Changed in version 3.7: When aw is cancelled due to a timeout,
  wait_for waits for aw to be cancelled. Previously, it raised
  asyncio.TimeoutError immediately.</p>
</blockquote>
<p>Don't get me wrong, I like it, it is an improvement.</p>
<p>However, this program will now hang in <code>wait_for</code> (Python 3.7):</p>
<pre><code>import asyncio

async def uncancellable():
    while True:
        try:
            await asyncio.sleep(99)
        except asyncio.CancelledError:
            print("sorry!")

TIMEOUT = 1.0

async def test():
    task = asyncio.get_event_loop().create_task(uncancellable())
    try:
        await asyncio.wait_for(task, TIMEOUT)
    except asyncio.TimeoutError:
        print("timeout")

asyncio.get_event_loop().run_until_complete(test())
</code></pre>
<p>An uncancellable task is a programming error. But if I need to be <a href="https://en.wikipedia.org/wiki/Defensive_programming" rel="nofollow noreferrer">defensive</a>, how do I prevent the <code>wait_for</code> from hanging indefinitely?</p>
<p>I tried this. First timeout: before cancelling, second timeout: before giving up.</p>
<pre><code>await asyncio.wait_for(asyncio.wait_for(task, TIMEOUT1), TIMEOUT1+TIMEOUT2)
</code></pre>
<p>There is one tiny issue I don't much care about. When it raises <code>asyncio.TimeoutError</code> I cannot tell if it happened at first or at the second timeout. Basically I think it works, but is it really correct?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But if I need to be defensive, how do I prevent the wait_for from
  hanging indefinitely?</p>
</blockquote>
<p>I don't think to consider each task as potentially uncancellable is a good idea.</p>
<p>Usually you just assume this situation won't happen and it's ok because, yes, uncancellable task is a programming error and it's not a kind of error that you expect to see often. Same way you usually don't expect some inner code will suppress <code>KeyboardInterrupt</code> or <a href="https://stackoverflow.com/a/14797463/1113207">any other</a> <code>BaseException</code>.</p>
<p>There's nothing wrong in expecting third-party code to follow some contracts (like in example above or, let's say not randomly to call <code>sys.exit()</code>). Otherwise you'll have to write <strong>much</strong> more code and probably still not cover all possible cases.</p>
</div>
