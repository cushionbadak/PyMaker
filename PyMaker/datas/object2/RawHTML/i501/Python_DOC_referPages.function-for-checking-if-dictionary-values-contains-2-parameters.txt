<div class="post-text" itemprop="text">
<p>I want to write a function that is checking if 2 values are satisfied, then perform finding the highest value for the third parameter. For example:</p>
<p><code>myFunction(condition1, condition2, parameter)</code></p>
<p>My data is in a dictionary (can put it <code>Data Frame</code>, don't know what is the best approach. Guess it is dictionary of dictionaries right now). <code>condition1</code> and <code>condition2</code> has more than 1 values, e.g., </p>
<p>condition1 looks like: <code>{0: ['pizza', 'pasta', 'salad'], 1: ['kebab', 'pasta', 'stew'],...}</code>
condition2 looks like: <code>{0: ['italian'], 1: ['american','mexican', 'italian'],...}</code>
parameter (rating) looks like: <code>{0:67, 1:56, 2:32,...}</code>, and
name looks like: <code>{0:'macys',1:'maze',2:'mcdonalds'...}</code></p>
<p>Basically, I want to find the best restaurant who serves <code>'pizza'</code> and it is <code>'italian'</code>, and has the highest <code>'rating'</code> (return the name of the restaurant). </p>
<p>Only thing I can get is to show me all the keys that contain​ <code>'pizza'</code> with this code:</p>
<pre><code>[key for key, value in datadict["condition1"].items() if 'pizza' in value]
</code></pre>
<p>but when adding <code>and</code> for the second condition:</p>
<pre><code>def myfunction(condition1, condition2, highest):
    [key for key, value in datadict["condition1"].items() if condition1 in value] and [key for key, value in datadict["condition2"].items() if condition2 in value]
</code></pre>
<p>I get some weird results. Also, I tried with this and it's getting results but based for only one condition: </p>
<pre><code>def func(condition1):
    for i in datadict["condition1"]: #reaching the keys of dict
        for x in datadict["condition1"][i]: #reaching every element in tuples
            if x==condition1: #if match found..
                print ("{} holding {}.".format(i,x)) #printing it..
funct('pizza')
</code></pre>
<p>Output:</p>
<pre><code>8 holding pizza.
30 holding pizza.
33 holding pizza.
</code></pre>
<p>But with: </p>
<pre><code>def func(condition1, condition2):
        for i in datadict["condition1"], j in datadict["condition2"]: #reaching the keys of dict
            for x in datadict["condition1"][i] and y in datadict["condition2"][j]: #reaching every element in tuples
                if x==condition1 and y==condition2: #if match found..
                    print ("{} holding {}.".format(i,x)) #printing it..
    funct('pizza', 'italian')
</code></pre>
<p>I get: </p>
<blockquote>
<p>NameError: name 'j' is not defined</p>
</blockquote>
<p>how to properly check for other condition and return name instead of the key?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to invert your data sets. You have ids pointing to attributes, but are searching for attributes to point you to ids.</p>
<p>Build <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">sets</a> from your conditions, so you can intersect these:</p>
<pre><code>cuisine_to_id = {}
for id, cuisines in condition1.items():
    for c in cuisines:
        cuisine_to_id.setdefault(c, set()).add(id)

style_to_id = {}
for id, styles in condition2.items():
    for s in styles:
         style_to_id.setdefault(s, set()).add(id)
</code></pre>
<p>So now you have dictionaries that have keys like <code>'pizza'</code> point to a set of ids (<code>{0, 2, ...}</code>). You want to do this <strong>once</strong>, after initially loading this data, there is no need to repeatedly build these sets.</p>
<p>If you were building the <code>condition1</code> and <code>condition2</code> dictionaries from another dataset of restaurants, just build the above name-to-set-of-ids mappings instead. The <code>condition*</code> dictionaries are not all that useful for anything else. </p>
<p>Picking out matching restaurants is then a set operation, <code>&amp;</code> gives us an intersection for restaurants that match both conditions:</p>
<pre><code>matches = cuisine_to_id['pizza'] &amp; style_to_id['italian']
</code></pre>
<p>then find the restaurant id from the matched ids with the highest rating, and map that one id to a name:</p>
<pre><code>return names[max(matches, key=parameter.get)]
</code></pre>
<p>This, incidentally, is the kinds of operations that <em>relational databases</em> are absolutely great at. You want to put this information into a SQL database; Python includes the embedded <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow noreferrer"><code>sqlite3</code> database library</a>, no need to set up a separate server here.</p>
<p>You could then run queries like</p>
<pre><code>SELECT r.name
FROM restaurants r
INNER JOIN restaurant_cuisines rc ON rc.restaurant_id = r.id
INNER JOIN cuisines c ON rc.cuisine_id = c.id
INNER JOIN restaurant_styles rs ON rs.restaurant_id = r.id
INNER JOIN styles s ON rs.style_id = s.id
WHERE c.name = 'pizza' AND s.name = 'italian'
ORDER BY r.rating DESC
LIMIT 1
</code></pre>
<p>That may look a little daunting, but it'll be <em>really really fast and efficient</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could find keys of food1 and food2 that match your conditions using list comprehension and then return name of restaurant that has highest value in <code>rating</code>.</p>
<pre><code>food1 = {0: ['pizza', 'pasta', 'salad'], 1: ['kebab', 'pasta', 'stew'], 2:['sushi', 'pizza']}
food2 = {0: ['italian'], 1: ['american','mexican', 'italian'], 2: ['polish', 'italian']}
rating = {0:67, 1:56, 2:32}
names = {0:'macys',1:'maze',2:'mcdonalds'}

def myFunction(condition1, condition2):
    filtered = [k for k, v in food1.items() if condition1 in v and condition2 in food2[k]]

    if not filtered:
        return

    return names[max(filtered, key=rating.get)]

print(myFunction('pizza', 'italian'))
</code></pre>
</div>
<span class="comment-copy">Are the keys always consecutive numbers? You appear to have <i>lists</i> instead, with the indices moved to dictionary keys.</span>
<span class="comment-copy">how can i check this? I pulled data from REST API with "requests", for condition1 is: 'condition1': list(y['cuisine']['name'] for y in get_restaurant_json["cuisine"])</span>
<span class="comment-copy">it throws: AttributeError: 'dict' object has no attribute 'set_default' while executing for id, conds in condition1.items()</span>
<span class="comment-copy">@Mr.Mister. Sorry, my mistake, that was a typo. Remove the underscores.</span>
<span class="comment-copy">tnx, what will happen in case they have same rating, it will take just first or all?</span>
<span class="comment-copy">@Mr.Mister. It’ll take just one.</span>
<span class="comment-copy">@Mr.Mister. If you need a list of matching restaurants with the highest rating (which could be a list of one), then first get the maximum rating with <code>max_rating = max(parameter[id] for id in matches)</code> then all restaurant names with that rating: <code>return [names[id] for id in matches if parameter[id] == max_rating]</code>.</span>
