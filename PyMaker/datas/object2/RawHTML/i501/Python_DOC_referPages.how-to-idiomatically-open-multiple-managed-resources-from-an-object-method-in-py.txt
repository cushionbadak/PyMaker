<div class="post-text" itemprop="text">
<p>What is the most Pythonic way of constructing an object to open multiple (context managed) resources and do work with those resources?</p>
<p>I have a class which opens several managed resources, which are then operated on in class methods.</p>
<p>For example, if I had to open a connection to a local cache database and to a web server at the same time (e.g. check for data in the cache first, then pull from the server if not there).</p>
<p>I've been able to come up with some code to manage the resources using a yield statement, but it doesn't seem very intuitive. In Python, is there a canonical way of approaching this problem?</p>
<h1>Minimal example:</h1>
<pre><code>from contextlib import contextmanager

@contextmanager
def resource_A():
    print('opening resource A...')
    a = 'resource_A'
    yield a
    print('closing resource A...')

@contextmanager
def resource_B():
    print('opening resource B...')
    b = 'resource_B'
    yield b
    print('closing resource B...')

class ResourceManager(object):
    def opened(self):
        self.resources = self._resources()
        self.a, self.b = next(self.resources)
    def closed(self):
        try:
            next(self.resources)
        except StopIteration:
            del self.resources
            del self.a
            del self.b
    def _resources(self):
        with resource_A() as a, resource_B() as b:
            yield a, b
    def processing(self):
        print('doing something with resource_A and resource_B...')
    def __enter__(self):
        self.opened()
        return self
    def __exit__(self, ex_type, ex_val, traceback):
        self.closed()
</code></pre>
<h2>Opening and closing</h2>
<pre><code>&gt;&gt;&gt; r = ResourceManager()
&gt;&gt;&gt; r.opened()
opening resource A...
opening resource B...
&gt;&gt;&gt; r.a
'resource_A'
&gt;&gt;&gt; r.b
'resource_B'
&gt;&gt;&gt; r.closed()
closing resource B...
closing resource A...
</code></pre>
<h2>Using with a context manager</h2>
<pre><code>&gt;&gt;&gt; with ResourceManager() as r:
...     r.processing()
...
opening resource A...
opening resource B...
doing something with resource_A and resource_B...
closing resource B...
closing resource A...
</code></pre>
<p>The code above seems to work fine, but it doesn't seem very intuitive. Specifically, the yield-next idiom seems a bit hard to digest.</p>
<p>Is there a better way to open/close multiple managed resources which will be subsequently used in class methods in Python?</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>I think, <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>ExitStack</code></a> will make your code easier</li>
<li>IMO, using <code>__enter__</code> and <code>__exit__</code> explicitly is more readable than <code>next(...)</code> thingy</li>
<li>Not actually about CMs, but big part of <em>idiomatic</em> python code includes naming. <code>opened</code> and <code>closed</code> reads as properties that should return boolean not be called, i.e. <code>r.opened -&gt; True</code>. This is what most people would expect from your interface. <em>Actions</em>, on other hand, should be spelled as verbs, like <code>open</code> and <code>close</code>.</li>
</ol>
<p>Simple example with ideas above:</p>
<pre><code>class ResourceManager(object):
    def open(self):
        self.stack = ExitStack()
        self.a = self.stack.enter_context(resource_A())
        self.b = self.stack.enter_context(resource_B())
    def close(self):
        self.stack.close()

    def processing(self):
        print('doing something with resource_A and resource_B...')
    def __enter__(self):
        self.open()
        return self
    def __exit__(self, ex_type, ex_val, traceback):
        self.close()
</code></pre>
</div>
<span class="comment-copy">I think that this answer is correct.</span>
<span class="comment-copy">Regarding idiomatic opening and closing: I noticed PEP 343 uses "opening" or "opened" rather than "open". I assume that this is to avoid squashing the built-in "open" method... which could badly break things. But, that being said, I'm not sure that applies here. I looked at the standard library, and the 'webbrowser' module uses open, so I think you might be right to suggest that 'open' is more idiomatic than 'opened'. I can't  find that a source which states that, though.</span>
<span class="comment-copy">I'm pretty sure that PEP uses that form to avoid name clash. This does not applies to class methods. Again, this is subjective, but in my opinion, good python code should "reads" as plain english.</span>
<span class="comment-copy">The real gem of advice here is the suggestion to use ExitStack, which I think could be documented better. That seems like the "correct" way to manage multiple resources within a class-type context manager. Honestly, I think that your example should be added to the documentation.</span>
<span class="comment-copy">I'll consider contributing ;)</span>
