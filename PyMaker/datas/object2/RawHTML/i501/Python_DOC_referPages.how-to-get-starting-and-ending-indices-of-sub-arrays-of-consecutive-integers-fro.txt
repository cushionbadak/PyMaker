<div class="post-text" itemprop="text">
<p>I'm new to programming, I have a numpy array as (the first column is the indices)</p>
<pre><code>rows = np.array([5,6,7,8,14,15,16,31])

0 5
1 6
2 7
3 8
4 14
5 15
6 16
7 31 
</code></pre>
<p>I need to get starting and ending indices of sub-arrays of consecutive integers, such as 0 and 3, 4 and 6 etc. 
I tried to do it like this</p>
<pre><code>start = np.array([])
end = np.array([])
c = 0
while c &lt; len(rows):
   for i in range(c, len(rows)):
      if rows[i]-rows[i+1] &gt; 1:
        np.append(start, c)
        np.append(end, i)
        c = i+1
</code></pre>
<p>It doesn't work, any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one-line solution using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>list( itertools.filterfalse(lambda i: (i&gt;0) and (rows[i]-rows[i-1] == 1), range(len(rows))) )

[0, 4, 7]
</code></pre>
<p>How does this work?</p>
<ul>
<li>we apply <code>itertools.filterfalse()</code> over the sequence of indices <code>range(len(rows))</code>, i.e. <code>0..(len(rows)-1)</code></li>
<li><code>filterfalse()</code> will give the values where our chosen <em>predicate function</em> is false i.e. we want to see the indices where values are <em>not</em> consecutive. Hence we give it the function <code>lambda i: (rows[i]-rows[i-1] == 1)</code>.

<ul>
<li>We just need to tweak that so that it also evaluates to False at (i==0), hence we add the gating term: <code>(i&gt;0) and ...</code></li>
</ul></li>
<li>finally we wrap all this in <code>list(...)</code> to convert the iterator back into a list</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>To get first element of an array use: <code>a[0]</code>, to get last element <code>a[-1]</code>, where a is an array.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way. Note that I used Python lists to accumulate the desired indices and converted them to numpy arrays only at the end. I did this since numpy arrays are not designed to add new members--they work best with fixed sizes. There are more pythonic ways to do this, but I tried to keep with the knowledge that you showed in your question. One strange result of this code is that if <code>rows</code> is an empty array, <code>start</code> becomes <code>array([0])</code> and <code>end</code> becomes <code>array([-1])</code>. My code works as expected for non-empty arrays.</p>
<pre><code>import numpy as np

rows = np.array([5, 6, 7, 8, 14, 15, 16, 31])

startlist = [0]
endlist = []
for ndx in range(1, len(rows)):
    if rows[ndx] != rows[ndx - 1] + 1:
        startlist.append(ndx)
        endlist.append(ndx - 1)
endlist.append(len(rows) - 1)
start = np.array(startlist)
end = np.array(endlist)
</code></pre>
<p>The result of that is</p>
<pre><code>start
Out[10]: array([0, 4, 7])

end
Out[11]: array([3, 6, 7])
</code></pre>
</div>
<span class="comment-copy">Thank you for commenting I edited the post.</span>
<span class="comment-copy">You can do this nicely with <code>itertools</code> and the third-party package <code>more_itertools</code>. See <a href="https://stackoverflow.com/questions/2361945/detecting-consecutive-integers-in-a-list">Detecting consecutive integers in a list</a>, <a href="https://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list">Identify groups of continuous numbers in a list</a>. It's a trivial tweak to return the indices instead of the values. You also probably want to filter the output to only return sequences of length &gt;= 2</span>
<span class="comment-copy">Also there is the useful <code>np.diff(rows)</code> which in your case gives you <code>array([1,1,1,6,1,1,15])</code>, so you can do <code>np.diff(rows) == 1</code>, then feed that into an iterator or while-loop.</span>
<span class="comment-copy">but I don't need to get only the first and last element</span>
<span class="comment-copy">The <code>itertools</code> solution is more compact, I added it</span>
<span class="comment-copy">@smci: Your solution is indeed much more compact than mine, but it uses multiple ideas that the OP may not know. Your solution also does not create the <code>end</code> array that the OP wants. (Yes, I know that it can be created from the <code>start</code> array--your solution would be improved if you show how.)</span>
