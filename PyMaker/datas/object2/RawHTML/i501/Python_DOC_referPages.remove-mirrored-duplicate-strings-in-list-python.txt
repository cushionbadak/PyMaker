<div class="post-text" itemprop="text">
<p>What is an efficient python algorithm to remove all mirrored text duplicates in a list where the items are in the format as below?</p>
<pre><code>ExList = [' dutch italian english', ' italian english dutch', ' dutch italian german', ' dutch german italian' ]
</code></pre>
<p>Required result: <code>[' dutch english italian ', 'dutch german italian' ]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This solution uses the <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">set</a> datastructure and focuses on producing compact code, mostly with list/set/generator comprehenstions. If this is a homework task for a beginner course and you just copy the result, it will be very obvious that you did not write the code yourself. Try to follow the thought process and reproduce the results yourself.</p>
<hr/>
<p>1) split each element at <code>" "</code> (space)</p>
<pre><code>for item in ExList:
    splitted = item.split(" ")
</code></pre>
<p>2) remove now empty elements due to superfluous spaces in the input. This can be done in 1 line with the step above (empty strings are "falsy") using a <em>list comprehenstion</em>:</p>
<pre><code>for item in ExList:
    splitted = [lang for lang in item.split(" ") if lang]
</code></pre>
<p>3) Put the result in a set, which by definition disregards order and ignores duplicates. For this step we primarily need the property of unordered identity, meaning <code>set([1, 2]) == set([2, 1])</code>. This can be combined with the line above using a <em>generator comprehension</em>:</p>
<pre><code>for item in ExList:
    itemSet = set(lang for lang in item.split(" ") if lang)
</code></pre>
<p>Now, within that loop, put all those sets of languages into another set. This time, because all the item sets with the same items in any order are considered equal, the outer set will automatically disregard any duplicates. To be able to put the item set into another set, it needs to be immutable (because mutability might cause a change in identity), which is called a <code>frozenset</code> in python. The code looks like this:</p>
<pre><code>ExList = [' dutch italian english', ' italian english dutch', ' dutch italian german', ' dutch german italian' ]

result = set()
for item in ExList:
    result.add(frozenset(lang for lang in item.split(" ") if lang))
</code></pre>
<p>Or, as a <em>set comprehension</em> on one line:</p>
<pre><code>result = {frozenset(lang for lang in item.split(" ") if lang) for item in ExList}
</code></pre>
<p>The result is as follows:</p>
<pre><code>&gt;&gt;&gt; print(result)
{frozenset({'italian', 'dutch', 'german'}), frozenset({'italian', 'dutch', 'english'})}
</code></pre>
<p>you can turn that back into lists if the set print output looks confusing to you</p>
<pre><code>&gt;&gt;&gt; print([list(itemSet) for itemSet in result])
[['italian', 'dutch', 'german'], ['italian', 'dutch', 'english']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may work for you:</p>
<pre><code>def unique_list(s):
    x = set([tuple(sorted(s.split())) for s in ExList])
    return [" ".join(s) for s in x]

print(unique_list(ExList)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might not be the most efficient solution, but hope it will be of some help.</p>
<p>Using the property that keys of dictionary are unique.</p>
<pre><code>m_dict = {}

for a in ExList:
    b = a.split()
    b.sort()
    m_dict[' '.join(b)] = None

print m_dict.keys()
</code></pre>
</div>
<span class="comment-copy">This sounds like homework in which case you should provide what you've tried</span>
<span class="comment-copy">What have you tried? You can split in spaces, sort them and convert them to tuples for use in a set comprehension, and then convert back to a list of strings. That won't preserve original order, if that's a requirement. I can provide an example when I get back to my machine.</span>
<span class="comment-copy">@Ian Quah I assure you that is not the case, I have tried sorting each item in alphabetical order and removing duplicate strings to no avail. I am looking for a more efficient algorithm as my lists are much larger in my project.</span>
<span class="comment-copy">@Maus an example with python syntax will be much appreciated, bless you.</span>
<span class="comment-copy"><code>'dutch english italian'</code> isn't in the original list.</span>
<span class="comment-copy">Thank you x100 Felk for this well explained answer, it means a lot to me and will hopefully will help users who have a similar question in the future. I understand that the way my question is formulated gives the impression that it is homework hence the down votes, for the record I'm currently in HS and am doing this for a personal project.</span>
<span class="comment-copy">Why not use a <code>set</code>?</span>
<span class="comment-copy"><code>list({' '.join(a.split().sort()) for a in ExList})</code></span>
<span class="comment-copy">@PeterWood it required more iterations to get back the original list item. Lists cannot be hashed so the set won't work here directly, isn't it?</span>
<span class="comment-copy">Where would you be trying to <code>hash</code> a <code>list</code>? the <code>list</code> is joined into a <code>str</code>, which is immutable and can be hashed.</span>
