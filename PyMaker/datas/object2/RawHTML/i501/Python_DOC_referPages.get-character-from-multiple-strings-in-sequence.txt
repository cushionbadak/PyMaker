<div class="post-text" itemprop="text">
<p>How do I take the first character from each string in a list, join them together, then the second character from each string, join them together, and so on - and eventually create one combined string? </p>
<p>eg. if I have strings like these:</p>
<pre><code>homanif
eiesdnt
ltiwege
lsworar
</code></pre>
<p>I want the end result to be <code>helloitsmeiwaswonderingafter</code></p>
<p>I put together a very hackneyed version of this which does the job but produces an extra line of gibberish. Considering this is prone to index going out of range, I don't think this is a good approach:</p>
<pre><code>final_c = ['homanif', 'eiesdnt', 'ltiwege', 'lsworar']

final_message = ""
current_char = 0

for i in range(len(final_c[1])):
    for c in final_c:
        final_message += c[current_char]
    current_char += 1

final_message += final_c[0][:-1]    

print(final_message)    
</code></pre>
<p>gives me <code>helloitsmeiwaswonderingafterhomani</code> when it should simply stop at <code>helloitsmeiwaswonderingafter</code>.</p>
<p>How do I improve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a nested comprehension:</p>
<pre><code>x = ["homanif", 
     "eiesdnt", 
     "ltiwege", 
     "lsworar"] 

y = "".join(x[i][j]
            for j in range(len(x[0]))
            for i in range(len(x)))
</code></pre>
<p>or use nested joins and <code>zip</code></p>
<pre><code>y = "".join("".join(y) for y in zip(*x))     
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Problems related to iterating in some convoluted order can often be solved elegantly with <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a>.</p>
<h2>Using zip</h2>
<p>You can use <code>zip</code> and <code>itertools.chain</code> together.</p>
<pre><code>from itertools import chain

final_c = ['homanif', 'eiesdnt', 'ltiwege', 'lsworar']
final_message = ''.join(chain.from_iterable(zip(*final_c))) # 'helloitsmeiwaswonderingafter'
</code></pre>
<p>In the event you needed the strings in <code>final_c</code> to be of different lengths, you could tweak your code a bit by using <code>itertools.zip_longest</code>.</p>
<pre><code>final_message = ''.join(filter(None, chain.from_iterable(zip_longest(*final_c))))
</code></pre>
<h2>Using cycle</h2>
<p>The fun part with <code>itertools</code> is that it offers plenty of clever short solutions for iterating over objects. Here is another using <code>itertools.cycle</code>.</p>
<pre><code>from itertools import cycle

final_c = ['homanif', 'eiesdnt', 'ltiwege', 'lsworara']
final_message = ''.join(next(w) for w in cycle(iter(w) for w in final_c))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a code that works for me :</p>
<pre><code>final_c = ["homanif", "eiesdnt", "ltiwege", "lsworar"]
final_message = ""
current_char = 0

for i in range(len(final_c[1])):
    for c in final_c:
        final_message += c[current_char]
    current_char += 1

# final_message += final_c[0][:-1]    

print(final_message) 
</code></pre>
<p>I hope it helps</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't understand what you are expecting with the line 
<code>final_message += final_c[0][:-1]</code> </p>
<p>The code works just fine without that. Either remove that line or go with something like list comprehensions :</p>
<pre><code>final_message = "".join(final_c[i][j] for j in range(len(final_c[0])) for i in range(len(final_c)))
</code></pre>
<p>This gives the expected output:</p>
<pre><code>helloitsmeiwaswonderingafter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>looks like you can have a matrix of form nxm where n is the number of words and m is the number of character in a word (the following code will work if all your words have the same length)</p>
<pre><code>import numpy as np

n = len(final_c)  # number of words in your list
m = len(final_c[0])  # number of character in a word

array = np_array(''.join([list(w) for w in ''.join(final_c)])
# reshape the array 
matrix = array.reshape(n,1,m )
''.join(matrix.transpose().flatten())
</code></pre>
</div>
<span class="comment-copy"><code>''.join(''.join(t) for t in (zip(*final_c)))</code></span>
<span class="comment-copy">@Chris_Rands your solution worked great! I wish I could mark it as the answer.</span>
<span class="comment-copy">@Chris_Rands already gave me the second one-liner code in the comments section instead, which worked really well. Nonetheless, I'll mark this as the correct answer since it has that. Thanks!</span>
