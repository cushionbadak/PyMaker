<div class="post-text" itemprop="text">
<p>I am in the process of trying to port a <code>flask</code> app to <code>quart</code> to utilise <code>asyncio</code>. I don't think my current approach is working, as my entire function chain is written without async in mind - consider the following:</p>
<pre><code>def long_running_task(task):
    result = some_synchronous_function(task)
    return result

@app.route('/&lt;task&gt;', methods=['GET'])
async def do_task(task):
    ok = await long_running_task(task)
    if ok:
        return (ok.result)
    else:
        return ('Something went wrong')
</code></pre>
<p>If <code>long_running_task</code> and its whole chain of function calls are not declared as <code>async</code>, am I actually getting any benefit from my route being declared as <code>async</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>To run a blocking synchronous function from asyncio, without blocking the main event loop, you can use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asynchronous_in_executor" rel="nofollow noreferrer"><code>loop.run_in_executor()</code></a> to run the blocking function in a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer"><code>ThreadPoolExecutor</code></a> or <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer"><code>ProcessPoolExecutor</code></a>` (i.e. in its own thread or process).</p>
<p>From within the async function you want to call it from:</p>
<pre><code>loop = asyncio.get_event_loop()

result = await loop.run_in_executor(None, long_running_task, task)
</code></pre>
<p>The first argument <code>None</code> is to tell it to use the default executor for the loop. Obviously <code>do_task()</code> will still have to wait for <code>result</code> to complete, but while it is waiting, other async tasks will be able to run in event-loop.</p>
</div>
<span class="comment-copy">Nope, that shouldn't even work. You can only <code>await</code> awaitables â€” async functions etc. To use the power of async, you need to transform your I/O (DB access, etc.) to asynchronous access.</span>
