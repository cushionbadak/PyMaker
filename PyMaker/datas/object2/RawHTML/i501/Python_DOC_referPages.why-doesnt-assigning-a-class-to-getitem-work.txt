<div class="post-text" itemprop="text">
<p>Here is a <code>list</code> subclass which delegates its item getting to <a href="https://docs.python.org/3/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress</code></a>.</p>
<pre><code>from itertools import compress

class WeirdList(list):
    def __getitem__(self, item):
        return compress(self, item)

l = WeirdList([1, 2, 3, 4])
print(*l[0, 1, 0, 1]) # 2 4
</code></pre>
<p>The above works fine, although I was under the impression that I could directly assign <code>compress</code> to <code>__getitem__</code>.</p>
<pre><code>class WeirdList(list):
    __getitem__ = compress

l = WeirdList([1, 2, 3, 4])
print(*l[0, 1, 0, 1])
</code></pre>
<p>This raises the following:</p>
<pre><code>Traceback (most recent call last):
  File "...", line 7, in &lt;module&gt; print(*l[0, 1, 0, 1])
TypeError: Required argument 'selectors' (pos 2) not found
</code></pre>
<p>I believed this breaks because <code>compress</code> is a class and not a function, but the message shows the <code>TypeError</code> was raised from calling <code>compress</code>.</p>
<p>At which point did the <code>__getitem__</code> protcol call <code>compress</code> with a single argument?</p>
</div>
<div class="post-text" itemprop="text">
<p>A function can be used as a method because it has a <code>__get__</code> attribute. The <em>class</em> <code>compress</code> doesn't have a <code>__get__</code> attribute:</p>
<pre><code>&gt;&gt;&gt; compress.__get__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
AttributeError: type object 'itertools.compress' has no attribute '__get__'  
</code></pre>
<p>and so cannot be a method.</p>
<p>When invoking an attribute with a <code>__get__</code> method, the <code>__get__</code> method is called and its return value is returned, rather than the value of the attribute itself. That is, <code>l[0] == l.__getitem__(0) == l.__getitem__.__get__(l, type(l))(0)</code>, where the return value of <code>__get__</code> is an object that already has <code>l</code> passed to the function.</p>
<p>(If you've ever wondered what the <code>classmethod</code> and <code>staticmethod</code> decorators do, they return objects with different <code>__get__</code> methods.)</p>
</div>
<span class="comment-copy">The implicit adding of <code>self</code> as the first parameter only happens when retrieving a <i>function</i> from a class.</span>
<span class="comment-copy">What Python version are you using, this is not the usual python 3 <code>TypeError: toto() missing 1 required positional argument: 'thing'</code> nor the python 2 <code>TypeError: toto() takes exactly 2 arguments (1 given)</code></span>
<span class="comment-copy">@Beno√ÆtPilatte This is 3.6.2 on Windows</span>
<span class="comment-copy">@jasonharper Oh perfectly makes sense. This answers my question. Feel free to put write down an answer.</span>
<span class="comment-copy">@jasonharper Not necessarily a function, but something with an appropriate <code>__get__</code> method (which <code>function</code> has).</span>
<span class="comment-copy">Class defining <code>__get__</code> method is called <i>descriptor</i>. Thorough description how it works is in the <a href="https://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow noreferrer">Python documentation</a>.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html</a> also discusses how the descriptor protocol works.</span>
