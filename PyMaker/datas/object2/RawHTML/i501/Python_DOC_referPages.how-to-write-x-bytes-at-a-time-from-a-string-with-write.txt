<div class="post-text" itemprop="text">
<p>I'm writing a program for an internet module that reads a locally stored file, and writes it to a .txt file on my computer.</p>
<pre><code>def write2file():
    print "Listing local files ready for copying:"
    listFiles()
    print 'Enter name of file to copy:'
    name = raw_input()
    pastedFile = readAll('AT+URDFILE="' + name + '"')    #Reads a local file using AT commands (not important to discuss)
    print 'Enter path to file directory'
    path = raw_input()
    myFile = open(join(path, name),"w")
    myFile.write(pastedFile)
    myFile.close()
</code></pre>
<p>I write the whole thing in one go. Problem is that when the product is implemented, it's only going to be possible to write 128 bytes at a time.</p>
</div>
<div class="post-text" itemprop="text">
<p>To write from a stream, the <code>io</code> module can help nicely here. I'm assuming you do <em>not</em> want to write bytes to a file, so we will use the <code>StringIO</code> object, which will treat a string object like a file handler</p>
<pre class="lang-py prettyprint-override"><code>from io import StringIO

def write2file(bytes_to_write):
    print "Listing local files ready for copying:"
    listFiles()
    print 'Enter name of file to copy:'
    name = raw_input()
    pastedFile = readAll('AT+URDFILE="' + name + '"')

    # I'm assuming pastedFile is a `string` object
    str_obj = StringIO(pastedFile)

    # Now we can read in specific bytes-sizes from str_obj
    fh = open(os.path.join(path, name), 'w')

    # read in the first bit, bytes_to_write is an int for number of bytes you want to read
    bit = str_obj.read(bytes_to_write)

    while bit:
        fh.write(bit)
        bit = str_obj.read(bytes_to_write)

    fh.close()
</code></pre>
<p>The way this works is <code>StringIO</code> will <code>read</code> x number of bytes until it hits the end of the string, then it will return a null string, which will terminate the <code>while</code> loop.</p>
<p>The cleaner way to do file opening and closing is using the <code>with</code> keyword:</p>
<pre class="lang-py prettyprint-override"><code>
   with open(filename, w) as fh:
       # read in the first bit, bytes_to_write is an int for number of bytes you want to read
       bit = str_obj.read(bytes_to_write)

       while bit:
           fh.write(bit)
           bit = str_obj.read(bytes_to_write)
</code></pre>
<p>That way you don't need the explicit <code>open</code> and <code>close</code> commands</p>
<p>NOTE:
This is assuming the <code>readAll</code> function does indeed read the entire file that you've given it. The <em>only reads 128 bytes at a time</em> might call that into question</p>
</div>
<span class="comment-copy">Please update your question with your code that attempts to <code>write 128 bytes at a time.</code></span>
<span class="comment-copy">Sorry, i didn't understand this <code>Problem is that when the product is implemented, it's only going to be possible to write 128 bytes at a time</code> ?</span>
<span class="comment-copy">I think the part marked <code>no need to discuss</code> <i>might</i> need discussion. If you are indeed looking to write from a stream, the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer"><code>io</code></a> module might be helpful. You can use <code>StringIO</code> or <code>BytesIO</code> to stream a specific amount of content</span>
<span class="comment-copy">I've posted to give some clarity on the <code>io</code> comment, it's still unclear what <code>readAll</code> does</span>
<span class="comment-copy">What was meant was that after implementation the communication will happen through a protocol which only allows messages up to 128 bytes at a time. I want to test a communication scenario, which is why I needed the program to write 128 bytes at a time instead of the whole string. Sorry for confusion</span>
