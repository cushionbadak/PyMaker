<div class="post-text" itemprop="text">
<p>I have list/array of integers, call a subarray a <em>peak</em> if it goes up and then goes down. For example:</p>
<pre><code>[5,5,4,5,4]
</code></pre>
<p>contains </p>
<pre><code>[4,5,4]
</code></pre>
<p>which is a peak.</p>
<p>Also consider</p>
<pre><code>[6,5,4,4,4,4,4,5,6,7,7,7,7,7,6]
</code></pre>
<p>which contains</p>
<pre><code>[6,7,7,7,7,7,6]
</code></pre>
<p>which is a peak.</p>
<h1>The problem</h1>
<p>Given an input list, I would like to find all the peaks contained in it of minimal length and report them. In the example above, <code>[5,6,7,7,7,7,7,6]</code> is also a peak but we remove the first element and it remains a peak so we don't report it.</p>
<p>So for input list:</p>
<pre><code>L = [5,5,5,5,4,5,4,5,6,7,8,8,8,8,8,9,9,8]
</code></pre>
<p>we would return</p>
<pre><code>[4,5,4] and [8,9,9,8] only.
</code></pre>
<p>I am having problems devising a nice algorithm for this. Any help would be hugely appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Using <code>itertools</code></h1>
<p>Here is a short solution using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to detect peaks. The groups identifying peaks are then unpacked to yield the actual sequence.</p>
<pre><code>from itertools import groupby, islice

l = [1, 2, 1, 2, 2, 0, 0]

fst, mid, nxt = groupby(l), islice(groupby(l), 1, None), islice(groupby(l), 2, None)
peaks = [[f[0], *m[1], n[0]] for f, m, n in zip(fst, mid, nxt) if f[0] &lt; m[0] &gt; n[0]]

print(peaks)
</code></pre>
<h3>Output</h3>
<pre><code>[[1, 2, 1], [1, 2, 2, 0]]
</code></pre>
<h1>Using a loop (faster)</h1>
<p>The above solution is elegant but since three instances of <code>groupby</code> are created, the list is traversed three times.</p>
<p>Here is a solution using a single traversal.</p>
<pre><code>def peaks(lst):
    first = 0
    last = 1
    while last &lt; len(lst) - 1:
        if lst[first] &lt; lst[last] == lst[last+1]:
            last += 1
        elif lst[first] &lt; lst[last] &gt; lst[last+1]:
            yield lst[first:last+2]
            first = last + 1
            last += 2
        else:
            first = last
            last += 1

l = [1, 2, 1, 2, 2, 0, 0]
print(list(peaks(l)))
</code></pre>
<h3>Output</h3>
<pre><code>[[1, 2, 1], [1, 2, 2, 0]]
</code></pre>
<h1>Notes on benchmark</h1>
<p>Upon benchmarking with <code>timeit</code>, I noticed an increase in performance of about 20% for the solution using a loop. For short lists the overhead of <code>groupby</code> could bring that number up to 40%. The benchmark was done on Python 3.6.</p>
</div>
<span class="comment-copy">So [4, 5, 5, 4] is considered a peak as well?</span>
<span class="comment-copy">@OlivierMelan√ßon yes</span>
<span class="comment-copy">What about something like [4, 5, 5, 2]? Or are the elements guaranteed to only change by 1.</span>
<span class="comment-copy">@IFunball That is a peak too.  But do you have a simpler method when they only change by 1?</span>
<span class="comment-copy">@IFunball Does my suggested solution suits your needs?</span>
<span class="comment-copy">The function seems to be missing a return statement?</span>
<span class="comment-copy">@Anush It's a generator, it <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do">yields</a> the peaks. This is a good practice for when lists can be fairly long. And anyway, a generator can always be made into a list with a cast.</span>
<span class="comment-copy">Thank you. Your answers are great.</span>
