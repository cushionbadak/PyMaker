<div class="post-text" itemprop="text">
<p>I'm unable to flatten and transform an XML to CSV file using XSLT, when dealing with large XML files.</p>
<p>Currently, I'm parsing a nested XML file with <code>lxml</code> using a XSL file to flatten the output and then I write the output to a CSV file.</p>
<p>My XML looks something like this:</p>
<pre><code>&lt;root&gt;
    &lt;level1&gt;
        &lt;level2&gt;
            &lt;topid&gt;1&lt;/topid&gt;
            &lt;level3&gt;
                &lt;subtopid&gt;1&lt;/topid&gt;
                &lt;level4&gt;
                    &lt;subid&gt;1&lt;/id&gt;
                    &lt;descr&gt;test&lt;/descr&gt;
                &lt;/level4&gt;
                &lt;level4&gt;
                    &lt;subid&gt;2&lt;/id&gt;
                    &lt;descr&gt;test2&lt;/descr&gt;
                &lt;/level4&gt;
                ...
            &lt;/level3&gt;
            ...
        &lt;/level2&gt;
    &lt;/level1&gt;
&lt;/root&gt;
</code></pre>
<p>I want to end up with the following CSV file:</p>
<pre><code>topid,subtopid,subid,descr
1,1,1,test
1,1,2,test2
....
</code></pre>
<p>My XSLT:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="text" encoding="utf-8" use-character-maps="map"/&gt;
&lt;xsl:character-map name="map"&gt;
    &lt;xsl:output-character character="," string=" "/&gt;
&lt;/xsl:character-map&gt;

&lt;xsl:strip-space elements="*"/&gt;
&lt;xsl:variable name="delimiter" select="','"/&gt;
&lt;xsl:variable name="newline" select="'&amp;#xd;'" /&gt;

&lt;xsl:template match="/root"&gt;
    &lt;xsl:text&gt;topid,subtopid,subid,descr&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline" /&gt;

    &lt;xsl:for-each select="level1/level2/level3/level4"&gt;
        &lt;xsl:value-of select="ancestor::root/level1/level2/topid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="ancestor::root/level1/level2/level3/subtopid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="subid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="descr" /&gt;
        &lt;xsl:value-of select="$newline" /&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</code></pre>
<p></p>
<p>My Python code:</p>
<pre><code>import lxml.etree as ET

xsltfile = ET.XSLT(ET.parse('transactions.xsl'))
xmlfile  = ET.parse('myxmlfile.xml')
output   = xsltfile(xmlfile).write_output('output.csv')
</code></pre>
<p>This works great for small files, but now I want to do the same with an XML file of +- 2.5gb. Using etree.parse will load it into memory, which won't work with larger files obviously.</p>
<p>I want to iterate somewhere, so I'm not loading the XML file into memory and  write to CSV line for line, while still making use of the XSLT for transforming. I'm using the XSLT file because it's the only way I know (now)  how to flatten a nested XML file.</p>
</div>
<div class="post-text" itemprop="text">
<p>One possibility is to use XSLT 3.0 streaming. There are two challenges here:</p>
<p>(a) making your code streamable. We can't judge how difficult that is without seeing the stylesheet code.</p>
<p>(b) installing and running a streaming XSLT 3.0 processor. This depends how locked in to the Python environment you are. If it has to be done in Python, you could try installing Saxon/C. The alternative is to call out to a different environment in which case you have more options, for example you could run Saxon-EE on Java.</p>
<p><strong>LATER</strong></p>
<p>Looking at the code you have posted, it's rather strange</p>
<pre><code>&lt;xsl:for-each select="level1/level2/level3/level4"&gt;
    &lt;xsl:value-of select="ancestor::root/level1/level2/topid" /&gt;
</code></pre>
<p>I suspect you want to output the <code>topid</code> of the "current" <code>level2</code> element, but that's not what this is doing (in XSLT 1.0 it will print the value of the first <code>level2/topic</code>, in XSLT 2.0+ is will print the values of all the <code>level2/topic</code> elements. I suspect you really want something like this:</p>
<pre><code>    &lt;xsl:for-each select="level1/level2/level3/level4"&gt;
        &lt;xsl:value-of select="ancestor::level2/topid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="ancestor::level3/subtopid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="subid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="descr" /&gt;
        &lt;xsl:value-of select="$newline" /&gt;
    &lt;/xsl:for-each&gt;
</code></pre>
<p>That's almost streamable, but not quite. Streaming doesn't allow you to go back to the topid and subtopid elements. The easiest way to make it streamable might be to save the most recent values of these elements in accumulators:</p>
<pre><code>&lt;xsl:accumulator name="topid" as="xs:string" initial-value="''"&gt;
  &lt;xsl:accumulator-rule match="topid/text()" select="string(.)"/&gt;
&lt;/xsl:accumulator&gt;

&lt;xsl:accumulator name="subtopid" as="xs:string" initial-value="''"&gt;
  &lt;xsl:accumulator-rule match="subtopid/text()" select="string(.)"/&gt;
&lt;/xsl:accumulator&gt;
</code></pre>
<p>and then access the values as:</p>
<pre><code>    &lt;xsl:for-each select="level1/level2/level3/level4"&gt;
        &lt;xsl:value-of select="accumulator-before('topid')" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="accumulator-before('subtopid')" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="subid" /&gt;
        &lt;xsl:value-of select="$delimiter" /&gt;
        &lt;xsl:value-of select="descr" /&gt;
        &lt;xsl:value-of select="$newline" /&gt;
    &lt;/xsl:for-each&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd rather use XSLT 3.0 (or even 2.0!) in Python, but haven't had the time to figure out how to use Saxon/C.</p>
<p>Another option would be to use <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.iterparse" rel="nofollow noreferrer"><code>iterparse()</code></a>.</p>
<p>Example...</p>
<p><strong>XML Input</strong> (fixed to be well-formed and to add a second <code>level3</code> for testing)</p>
<pre class="lang-xml prettyprint-override"><code>&lt;root&gt;
    &lt;level1&gt;
        &lt;level2&gt;
            &lt;topid&gt;1&lt;/topid&gt;
            &lt;level3&gt;
                &lt;subtopid&gt;1&lt;/subtopid&gt;
                &lt;level4&gt;
                    &lt;subid&gt;1&lt;/subid&gt;
                    &lt;descr&gt;test&lt;/descr&gt;
                &lt;/level4&gt;
                &lt;level4&gt;
                    &lt;subid&gt;2&lt;/subid&gt;
                    &lt;descr&gt;test2&lt;/descr&gt;
                &lt;/level4&gt;
            &lt;/level3&gt;
            &lt;level3&gt;
                &lt;subtopid&gt;2&lt;/subtopid&gt;
                &lt;level4&gt;
                    &lt;subid&gt;1&lt;/subid&gt;
                    &lt;descr&gt;test&lt;/descr&gt;
                &lt;/level4&gt;
                &lt;level4&gt;
                    &lt;subid&gt;2&lt;/subid&gt;
                    &lt;descr&gt;test2&lt;/descr&gt;
                &lt;/level4&gt;
            &lt;/level3&gt;
        &lt;/level2&gt;
    &lt;/level1&gt;
&lt;/root&gt;
</code></pre>
<p><strong>Python</strong></p>
<pre class="lang-py prettyprint-override"><code>from lxml import etree
import csv

context = etree.iterparse("test.xml", events=("start", "end"))

fields = ("topid", "subtopid", "subid", "descr")

with open("test.csv", "w", newline="", encoding="utf8") as xml_data_to_csv:

    csv_writer = csv.DictWriter(xml_data_to_csv, fieldnames=fields,
                                delimiter=",", quoting=csv.QUOTE_MINIMAL)

    csv_writer.writeheader()

    topid = None
    subtopid = None
    values = {}

    for event, elem in context:
        tag = elem.tag
        text = elem.text

        if tag == "topid" and text:
            topid = text

        if tag == "subtopid" and text:
            subtopid = text

        if tag == "subid" and text:
            values["subid"] = text

        if tag == "descr" and text:
            values["descr"] = text

        if event == "start" and tag == "level4":
            # Build a dict containing all of the "fields" with default values of "Unknown".
            values = {key: "Unknown" for key in fields}

        if event == "end" and tag == "level4":
            values["topid"] = topid
            values["subtopid"] = subtopid
            csv_writer.writerow(values)

        elem.clear()
</code></pre>
<p><strong>CSV Output</strong></p>
<pre><code>topid,subtopid,subid,descr
1,1,1,test
1,1,2,test2
1,2,1,test
1,2,2,test2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Saxon/C and python can work:</p>
<p>One user has successfully used Boost.Python to interface with the C++ library. </p>
<p>Another user has done the interfacing in a different way: <a href="https://github.com/ajelenak/pysaxon" rel="nofollow noreferrer">https://github.com/ajelenak/pysaxon</a></p>
</div>
<span class="comment-copy">Just a heads-up; lxml doesn't support XSLT 2.0 so your character-map isn't doing anything.</span>
<span class="comment-copy">Thanks. I just updated my post with all the code. I will have a look into the XSLT 3.0. streaming!</span>
