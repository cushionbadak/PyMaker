<div class="post-text" itemprop="text">
<p>I am just getting started in Python Programming. I had a problem on checking if a given list contains alternating sequence of primes and perfect squares. The list can start with either a prime or a perfect square. I came up with a solution but it's not efficient as it generates unwanted lists. Is this possible with more efficient Python code?</p>
<p>First I'm creating functions to generate a list of primes as well as perfect squares up to the max value of testing list. Functions <code>squaretest()</code> and <code>primecheck()</code>:</p>
<hr/>
<pre><code>def squaretest(num):
    sqlist=[]
    i=1
    while i**2 &lt;= num:
        sqlist.append(i**2) 
        i+=1
    return sqlist

def primecheck(num):
    primelist=[]
    for i in range(2,num + 1):
            for p in range(2,i):
                if (i % p) == 0:
                    break
            else:
                primelist.append(i)
    return primelist
</code></pre>
<hr/>
<p>Then I am dividing the given list into lists of even index and odd index elements and checking all elements of them against the <code>primelist</code> and the <code>squarelist</code>:</p>
<pre><code>def primesquare(l):
    if len(l)==1:
        primelist = primecheck(l[0])
        sqlist = squaretest(l[0])
        return (l[0] in primelist) or (l[0] in sqlist)
    else:
        ol=[]
        el=[]
        for i in range(0,len(l),2):
            ol.append(l[i])
        for p in range (1, len(l),2):
            el.append(l[p])
        primelist = primecheck(max(l))
        sqlist = squaretest (max(l))
        return((all(x in primelist for x in el)) == True and (all(y in sqlist for y in ol)) == True) or ((all(x in primelist for x in ol)) == True and (all(y in sqlist for y in el)) == True)
</code></pre>
<hr/>
<p>It works.
Any suggestions will be really helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">sets</a> to check if all members of a list are in another list.</p>
<pre><code>def primesquare(l):
    if len(l) == 0:
        return True

    primelist = set(primecheck(max(l)))
    sqlist = set(squaretest(max(l)))

    ol = set(l[::2])
    el = set(l[1::2])

    odds_are_primes = ol.issubset(primelist)
    odds_are_squares = ol.issubset(sqlist)
    evens_are_primes = el.issubset(primelist)
    evens_are_squares = el.issubset(sqlist)

    return (odds_are_primes and evens_are_squares) or (odds_are_squares and evens_are_primes)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I came up with a solution but it's not efficient as it generates
  unwanted lists.</p>
</blockquote>
<p>Assuming the unwanted lists are the two lists representing the even and odd elements, then we can fix that.  (Eliminating the primes and squares list is a whole 'nother problem.)  Below is my rework of your code -- we don't create addtional lists but rather with a couple of reusable <em>ranges</em> which are objects that produce integer sequences as needed, but not stored in memory.</p>
<p>Your <code>any()</code> design is efficient in that the arguments are generator expressions, not lists, which are computed as needed.  As soon as a flaw is found in the array, the whole thing stops and returns False--it doesn't need to process the rest:</p>
<pre><code>def squares(number):
    return {x * x for x in range(int(number ** 0.5) + 1)}

def primes(number):
    prime_set = set()

    for i in range(2, number + 1):
        for p in range(2, int(i ** 0.5) + 1):
            if (i % p) == 0:
                break
        else:  # no break
            prime_set.add(i)

    return prime_set

def primesquare(array):
    if not array:
        return True  # define as the problem demands

    length, maximum = len(array), max(array)

    odd, even = range(0, length, 2), range(1, length, 2)

    prime_set, square_set = primes(maximum), squares(maximum)

    return all(array[i] in prime_set for i in even) and all(array[i] in square_set for i in odd) or all(array[i] in prime_set for i in odd) and all(array[i] in square_set for i in even)
</code></pre>
<p>I admire @AndreySemakin's set-based solution (+1), and use sets above, but his solution generates the same lists you want to eliminate (just in the form of sets).</p>
</div>
<div class="post-text" itemprop="text">
<p>I came up with this solution:  </p>
<pre><code>def primesquare(lst):

    # checking if the first element is either perfect square or a prime
    if not lst or (not checksquare(lst[0]) and not checkprime(lst[0])):
        return False

    length = len(lst)

    if length == 1:
        return True

    if checksquare(lst[0]):
        # if first element is square then make s(quare)=2 and p(rime)=1
        s, p = 2, 1
    else:
        # if first element is prime then make s=1 and p=2
        s, p = 1, 2

    # running perfect square loop from s to len-1 with gap of 2 and checking condition
    for i in range(s, length, 2):
        if not checksquare(lst[i]):
            return False

    # running prime loop from p to len-1 with gap of 2
    for i in range(p, length, 2):
        if not checkprime(lst[i]):
            return False

    return True

def checksquare(n):  # function to check perfect square

    if n &lt; 0:
        return False

    if 0 &lt;= n &lt;= 1:
        return True

    for i in range(int(n ** 0.5) + 1):
        if i * i == n:
            return True

    return False

def checkprime(n):  # function to check prime

    if n &lt; 2:
        return False

    if n % 2 == 0:
        return n == 2

    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return False

    return True
</code></pre>
</div>
<span class="comment-copy">As it lacks any extra lists at all, this solution has real merit.  Unfortunately, that might be obscured by its non-idiomatic use of Python.  With your permission, I'd like to edit your answer to rework the code for clarity, and just a touch of added efficiency.  We can always roll it back if you're not happy with my changes.</span>
<span class="comment-copy">@cdlane  sure, you can edit my answer</span>
<span class="comment-copy">I rewrote your squares and primes functions for efficiency so that they don't become the focus of your answer which is really the <code>primesquare()</code> function.  In it, I adjusted the values of <code>s</code> &amp; <code>p</code> to reflect that the first element of the list has already been tested and so doesn't need to be tested again in the full list test.  And tidied up your boolean tests.</span>
