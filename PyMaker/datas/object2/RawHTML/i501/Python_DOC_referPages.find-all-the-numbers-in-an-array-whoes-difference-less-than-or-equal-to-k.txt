<div class="post-text" itemprop="text">
<p>I want to find two numbers <code>A[i]</code> and <code>A[j]</code> whose difference is less than or equal to <code>K</code>, I need to store index of such numbers in array L (Left) R (Right) and return L &amp; R </p>
<pre class="lang-py prettyprint-override"><code>def fun(A, k): 
    n = len(A)
    l = 0
    r = n-1
    # traverse the array for the two elements 
    while l&lt;r: 
        if (A[l] - A[r] &lt;= n):
            return A[l],A[r]
        elif (A[l] - A[r] &lt; n): 
            l += 1
        else: 
            r -= 1
    return 0

# Driver code to test above function 
A = [3.5,5,6,12,13] 
k = 1.7
print(fun(A, k))
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code>L[0,0,1,3,3],R[1,2,2,4,4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>itertools.combinations</code> to get all possible combinations, then test their differences and append if needed.</p>
<pre><code>from itertools import combinations

def fun(A, k):
    l, r = [], []
    for (x_idx, x_val), (y_idx, y_val) in combinations(enumerate(A), 2):
        if abs(x_val - y_val) &lt;= k:
            l.append(x_idx)
            r.append(y_idx)
    return l, r
</code></pre>
<p>Test:</p>
<pre><code>A = [3.5,5,6,12,13] 
k = 1.7
print(fun(A, k))
# ([0, 1, 3], [1, 2, 4])
</code></pre>
<p>Though it's not your expected output, I feel like your expected output may have a few errors according to your logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>O(n log n)</code> solution that exploits the ordering in your example <code>A</code> (if it's not ordered, you can always pay <code>O(n log n)</code> a second time to sort it, though preserving the original indices would likely make it not worth the complexity):</p>
<pre><code>from bisect import bisect

def fun(A, k):
    # Add A.sort() if A not guaranteed to be sorted
    for l, x in enumerate(A):
        for r in range(l+1, bisect(A, x+k, l+1)):
            yield l, r
</code></pre>
<p>This uses <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect" rel="nofollow noreferrer">the <code>bisect.bisect</code> function</a> to find the end point for each start point in <code>O(log n)</code> time, making the overall cost <code>O(n log n)</code>. It doesn't even need to directly test most values against <code>k</code>, since <code>bisect</code> finds the end of the indices which meet the different criteria, and all values in between definitely meet it. </p>
<p>Rather than building the <code>list</code> manually, I've made this a generator function that can be converted to the <code>L</code> and <code>R</code> values with <code>zip</code> and unpacking:</p>
<pre><code>&gt;&gt;&gt; A = [3.5,5,6,12,13] 
&gt;&gt;&gt; k = 1.7
&gt;&gt;&gt; L, R = zip(*fun(A, k))
&gt;&gt;&gt; print(L, R)
(0, 1, 3), (1, 2, 4)
</code></pre>
<p>You could do it with <code>list</code>s explicitly:</p>
<pre><code>def fun(A, k):
    L, R = [], []
    for l, x in enumerate(A):
        newr = range(l+1, bisect(A, x+k, l+1))
        L += [l] * len(newr)
        R.extend(newr)
    return L, R
</code></pre>
<p>but I kind of like the generator-&gt;zip-&gt;unpack approach for letting Python do most of the work. Either way, the theoretical cost of <code>O(n log n)</code> is better than <code>O(n * (n - 1) / 2)</code> (roughly <code>O(n ** 2)</code>).</p>
</div>
<span class="comment-copy">Why is <code>0, 2</code> in your output?  Isn't the difference there greater than 1.7?</span>
<span class="comment-copy">On top of that, you seem to be looking for <code>A[l] - A[r] &lt;= n</code> where <code>n</code> is the size of the <code>list</code>; you're comparing computed values from <code>A</code> with the length of <code>A</code>??? Did you perhaps mean to use <code>k</code> <i>somewhere</i> in this code?</span>
<span class="comment-copy">@PatrickHaugh the example I'm solving is having same output</span>
<span class="comment-copy">cant we do this via while loop?</span>
<span class="comment-copy">@June Why? When iterating a sequence, a <code>for</code> loop is essentially always better.</span>
<span class="comment-copy">ohh got it, is this O(n)?</span>
<span class="comment-copy">Had a similar idea (but avoiding manual <code>list</code> construction in favor of making it a generator and using <code>zip</code> to unpack the results). Not worth a separate answer, but <a href="https://tio.run/##VY7BCsIwEETv@Yo5JhILbamC2EPvnryKSNUEl6ZJSdND/fmaiCjOadjZt7PDHB7Olov2rgcF5YNzZgT1g/MBN9dfybaBnB2Xu9LQk@WNRCd2DFHaeXBzIQkjJLhPzguQ/SO5slOvfBsUb@Ja8YGTSKO9jtxgnbh9je6XJc2kzB3vhnicsQY1TmVWyUpuZF7IvDyzLs7ybMsOEsdonzTw1fdPwQZPNvAUimV5AQ" rel="nofollow noreferrer" title="Python 3 â€“ Try It Online">posted here for comparison</a>.</span>
<span class="comment-copy">@June Because a call to <code>combinations</code> is required, which generates <code>nCr(length, 2)</code> sequences, it's <code>O(n * (n - 1) / 2)</code>, not <code>O(N)</code>. I do not believe further optimization is possible.</span>
