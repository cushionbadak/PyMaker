<div class="post-text" itemprop="text">
<p>Suppose a following situation:</p>
<pre><code>[c1, c2, c3] &gt;&gt; child_task
</code></pre>
<p>where all <code>c1</code>, <code>c2</code>, <code>c3</code> and <code>child_task</code> are operators and have <code>task_id</code> equal to <code>id1</code>, <code>id2</code>, <code>id3</code> and <code>child_id</code> respectively.</p>
<p>Task <code>child_task</code> is also a <code>PythonOperator</code> with <code>provide_context=True</code> and <code>python_callable=dummy_func</code></p>
<pre><code>def dummy_func(**context):
    #...
</code></pre>
<p>Is it possible to retrieve all parents' ids inside the <code>dummy_func</code>(perhaps by browsing the dag somehow using the context)?</p>
<p>Expected result in this case would be a list <code>['id1', 'id2', 'id3']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>upstream_task_ids</code> and <code>downstream_task_ids</code> <a href="https://github.com/apache/airflow/blob/v1-10-stable/airflow/models.py#L2950" rel="nofollow noreferrer"><em>properties</em> of <code>BaseOperator</code></a> are meant just for this purpose.</p>
<pre><code>from typing import List
..
parent_task_ids: List[str] = my_task.upstream_task_ids
child_task_ids: List[str] = my_task_downstream_task_ids
</code></pre>
<hr/>
<p>Do note however that with this <code>property</code>, you only get immediate (<em>upstream / downstream</em>) neighbour(s) of a task. In order to get all <strong>ancestor or descendent</strong> <code>task</code>s, you can quickly cook-up the good old <em>graph theory</em> approach such as this <code>BFS</code>-<em>like</em> implementation</p>
<pre><code>from typing import List, Set
from queue import Queue
from airflow.models import BaseOperator

def get_ancestor_tasks(my_task: BaseOperator) -&gt; List[BaseOperator]:
    ancestor_task_ids: Set[str] = set()
    tasks_queue: Queue = Queue()
    # determine parent tasks to begin BFS
    for task in my_task.upstream_list:
        tasks_queue.put(item=task)
    # perform BFS
    while not tasks_queue.empty():
        task: BaseOperator = tasks_queue.get()
        ancestor_task_ids.add(element=task.task_id)
        for _task in task.upstream_list:
            tasks_queue.put(item=_task)
    # Convert task_ids to actual tasks
    ancestor_tasks: List[BaseOperator] = [task for task in my_task.dag.tasks if task.task_id in ancestor_task_ids]
    return ancestor_tasks
</code></pre>
<p><em>Above snippet is NOT tested, but I'm sure you can take inspiration from it</em></p>
<hr/>
<p>References</p>
<ul>
<li><a href="https://stackoverflow.com/a/54455294/3679900">Get all Airflow Leaf Nodes/Tasks</a></li>
<li><a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Python Queue</a></li>
<li><a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">Python 3 type-annotations</a></li>
</ul>
</div>
<span class="comment-copy">Immediate neighbours are sufficient in my case. Thanks!</span>
