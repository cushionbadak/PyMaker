<div class="post-text" itemprop="text">
<p>I am trying to process batches of a vector </p>
<p>let say, I have this vector</p>
<pre><code>v = [10, 20, 30, 40, 70, 80, 90]
</code></pre>
<p>I want to print every three elements, if it reaches the end, it goes back to the beginning and takes the first to element and so on. For example, the output would be something like</p>
<p>10, 20, 30</p>
<p>40, 70, 80</p>
<p>90, 10, 20    &lt;== starts over</p>
<p>30, 40, 70 </p>
<p>80, 90, 10    &lt;== starts over</p>
<p>and so on...</p>
<p>I know I can do this creating a function and calculating the start and end index using module, but I was thinking if there is a way just playing with the sintaxis, something like</p>
<pre><code>v[8:10 % 9]  #would print v[8], v[0] and v[1]
</code></pre>
<p>I know you can do this for a single index v[index % len(v)], but is it possible to do it for a range <code>v[range % len(v)]</code> ? </p>
</div>
<div class="post-text" itemprop="text">
<p>Though computing indexes is possible, I would use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> with the <code>zip(*[] * x)</code> grouper:</p>
<pre><code>from itertools import cycle

v = [10, 20, 30, 40, 70, 80, 90]

n = 10

for index, *group in zip(range(n), *[cycle(v)] * 3):
    print(group)
</code></pre>
<p>Change <code>n</code> to however many times you want to loop. Output:</p>
<pre><code>[10, 20, 30]
[40, 70, 80]
[90, 10, 20]
[30, 40, 70]
[80, 90, 10]
[20, 30, 40]
[70, 80, 90]
[10, 20, 30]
[40, 70, 80]
[90, 10, 20]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow noreferrer">itertools</a> have a number of tools that can help you with that:</p>
<pre><code>from itertools import cycle, islice


def chunks(iterable, size):
    it = iter(iterable)
    item = list(islice(it, size))
    while item:
        yield item
        item = list(islice(it, size))


v = [10, 20, 30, 40, 70, 80, 90]


for subset in chunks(cycle(v), 3):
  print(subset)
</code></pre>
<p>which produces (yields):</p>
<pre><code>[10, 20, 30]
[40, 70, 80]
[90, 10, 20]
...
</code></pre>
<hr/>
<p>The <code>chunks</code> function has been taken from <a href="https://stackoverflow.com/a/312467/6162307">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your problem correctly, you want circular indexing. I think there are two ways of achieving this. Through explicit functions, as you mentioned, and other answers have elaborated. But you want to achieve the same through usual list syntax (including slicing). It is only possible if you make a subclass out of base list class. Below is an example of doing this:</p>
<pre><code>class circularlist(list):
    def map_key(self, key):
        length = len(self)
        return key%length

    def __getitem__(self, key):
        if isinstance(key, int):
            return super().__getitem__(self.map_key(key))
        elif isinstance(key, slice):
            step = key.step if key.step else 1
            idx = [i for i in \
                   range(key.start, key.stop, step)]
            return [self.__getitem__(i) for i in idx]
        else:
            print(type(key))
            return super().__getitem__(key)

v = [10, 20, 30, 40, 70, 80, 90]
vv = circularlist(v)

print(vv[42])
print(vv[20:30])
</code></pre>
<p>Note: I do not recommend this, and suggest the other methods above.</p>
</div>
