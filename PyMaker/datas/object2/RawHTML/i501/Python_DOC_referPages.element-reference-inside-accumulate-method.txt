<div class="post-text" itemprop="text">
<p>could someone help me understand what the s[1] and s[0] are referring to in the code below? This code will generate a Fibonacci serie. And I am still trying to understand how accumulate() works. Does it return the first value (0,1) as it is, then uses the result from the first application of the lambda function as s[1] and another tuple (0,1) from the list generated by repeat() as s[0]? or s[0] and s[1] are assigned as 0 and 1 respectively? </p>
<p>Thanks!</p>
<pre><code>import itertools as it
def second_order(p, q, r, initial_values):
    """Return sequence defined by s(n) = p * s(n-1) + q * s(n-2) + r."""
    intermediate = it.accumulate(
        it.repeat(initial_values),
        lambda s, i: (s[1], p*s[1] + q*s[0] + r)
    )
    return intermediate
fibs = second_order(p=1, q=1, r=0, initial_values=(0, 1))
list(next(fibs) for n in range(8))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>indexable[n]</code> is the way to get the value in index <code>n</code> of <code>indexable</code>. Since tuples are indexable collections (they define <code>__getitem__</code>), you're getting the zero-index and one-index of that tuple (the first and second values, respectively).</p>
<p>This might be better-understood in the no-longer-valid syntax:</p>
<pre><code>lambda (s1, s2), i: (s2, p*s2 + q*s1 + r)
</code></pre>
<hr/>
<p>As you correctly intuited, <code>accumulate([x1, x2, x3], fn)</code> returns the infinite series <code>[x1, fn(x1, x2), fn(x2, fn(x1, x2)), ...]</code> <code>fn</code> in this case is a function that has the signature:</p>
<pre><code>def fn(last_last_value, last_value)
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html?highlight=itertools%20accumulate#itertools.accumulate" rel="nofollow noreferrer">The docs</a> probably show this most clearly, using <code>operator.add</code> (aka <code>+</code>)</p>
<pre><code>def accumulate(iterable, func=operator.add):
    'Return running totals'
    # accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15
    # accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120
    it = iter(iterable)
    try:
        total = next(it)
    except StopIteration:
        return
    yield total
    for element in it:
        total = func(total, element)
        yield total
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>p=1</code> and <code>q=1</code> and <code>r=0</code>, we can ignore them altogether and it ultimately boils down to just this:</p>
<pre><code>it.accumulate( 
    [(0,1),(0,1),(0,1),(0,1),(0,1), ...], 
    lambda prev, current: (prev[1], prev[1] + prev[0])
)
</code></pre>
<p>You can visualize it like this:</p>
<pre><code>0th:                             -&gt; result0= (0,1)
1th: prev=(0,1)    current=(0,1) -&gt; result1= (1, 0+1)= (1,1)
2nd: prev=result1  current=(0,1) -&gt; result2= (0+1, 0+1+1)= (1,2)
3rd: prev=result2  current=(0,1) -&gt; result3= (0+1+1, 0+1+1+0+1)= (2,3)
4th: prev=result3  current=(0,1) -&gt; result4= (0+1+1+0+1, 0+1+1+0+1+0+1+1)= (3,5)
...
</code></pre>
<p>as you can see <code>current</code> never gets used. <br/>
In your code <code>i</code> is <code>current</code>, <code>s</code> is <code>prev</code>, and so <code>s[0] == prev[0]</code> which is the first element in the tuple, and <code>s[1]</code> is the 2nd element</p>
</div>
