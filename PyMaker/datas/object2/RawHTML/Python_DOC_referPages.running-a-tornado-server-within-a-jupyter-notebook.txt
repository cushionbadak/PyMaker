<div class="post-text" itemprop="text">
<p>Taking the standard Tornado demonstration and pushing the IOLoop into a background thread allows querying of the server within a single script. This is useful when the Tornado server is an interactive object (see Dask or similar).</p>
<pre class="lang-py prettyprint-override"><code>import asyncio
import requests
import tornado.ioloop
import tornado.web

from concurrent.futures import ThreadPoolExecutor

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

pool = ThreadPoolExecutor(max_workers=2)
loop = tornado.ioloop.IOLoop()

app = make_app()
app.listen(8888)
fut = pool.submit(loop.start)

print(requests.get("https://localhost:8888"))
</code></pre>
<p>The above works just fine in a standard python script (though it is missing safe shutdown). Jupyter notebook are optimal environment for these interactive Tornado server environments. However, when it comes to Jupyter this idea breaks down as there is already a active running loop:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; asyncio.get_event_loop()
&lt;_UnixSelectorEventLoop running=True closed=False debug=False&gt;
</code></pre>
<p>This is seen when running the above script in a Jupyter notebook, both the server and the request client are trying to open a connection in the same thread and the code hangs. Building a new Asyncio loop and/or Tornado IOLoop does not seem to help and I suspect I am missing something in Jupyter itself.</p>
<p>The question: Is it possible to have a live Tornado server running in the background within a Jupyter notebook so that standard python <code>requests</code> or similar can connect to it from the primary thread? I would prefer to avoid Asyncio in the code presented to users if possible due to its relatively complexity for novice users.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Part 1: Let get nested tornado(s)</h1>
<p>To find the information you need you would have had to follow the following crumbtrails, start by looking at what is described in the release notes of <a href="http://%20https://ipython.readthedocs.io/en/stable/whatsnew/version7.html#autowait-asynchronous-repl" rel="nofollow noreferrer">IPython 7</a>
It particular it will point you to more informations on the async and await sections in the <a href="https://ipython.readthedocs.io/en/stable/interactive/autoawait.html#using-autoawait-in-a-notebook-ipykernel" rel="nofollow noreferrer">documentation</a>, and to <a href="https://github.com/jupyter/notebook/issues/3397#issuecomment-419386811" rel="nofollow noreferrer">this discussion</a>,
which suggest the use of <a href="https://github.com/erdewit/nest_asyncio" rel="nofollow noreferrer">nest_asyncio</a>.</p>
<p>The Crux is the following:</p>
<ul>
<li>A) either you trick python into running two nested event loops. (what nest_asyncio does)</li>
<li>B) You schedule coroutines on already existing eventloop. (I'm not sure how to do that with tornado)</li>
</ul>
<p>I'm pretty sure you know all that, but I'm sure other reader will appreciate. </p>
<p>There are unfortunately no ways to make it totally transparent to users â€“ well unless you control the deployment like on a jupyterhub, and can add these lines to the IPython startups scripts that are automatically loaded. But I think the following is simple enough.</p>
<pre class="lang-py prettyprint-override"><code>import nest_asyncio
nest_asyncio.apply()


# rest of your tornado setup and start code.
</code></pre>
<h1>Part 2: Gotcha Synchronous code block eventloop.</h1>
<p>Previous section takes only care of being able to run the tornado app. But note that <strong>any synchronous code will block the eventloop</strong>; thus when running <code>print(requests.get("http://localhost:8000"))</code> the server will appear to not work as you are blocking the eventloop, which will restart only when the code finish execution which is waiting for the eventloop to restart...(understanding this is an exercise left to the reader). You need to either issue <code>print(requests.get("http://localhost:8000"))</code> <strong>from another kernel</strong>, or, use aiohttp. </p>
<p>Here is how to use aiohttp in a similar way as requests.</p>
<pre class="lang-py prettyprint-override"><code>import aiohttp
session =  aiohttp.ClientSession()
await session.get('http://localhost:8889')
</code></pre>
<p>In this case as aiohttp is non-blocking things will appear to work properly.  You here can see some extra IPython magic where we autodetect async code and run it on the current eventloop. </p>
<p>A cool exercise could be to run a <code>request.get</code> in a loop in another kernel, and run <code>sleep(5)</code> in the kernel where tornado is running, and see that we stop processing requests...</p>
<h1>Part 3: Disclaimer and other routes:</h1>
<p>This is <em>quite tricky</em> and I would advise to not use in production, and warn your users this is not the recommended way of doing things.</p>
<p>That does not completely solve your case, you will need to run things not in the main thread which I'm not sure is possible.</p>
<p>You can also try to play with other loop runners like <a href="https://trio.readthedocs.io/en/latest/" rel="nofollow noreferrer">trio</a> and <a href="https://github.com/dabeaz/curio" rel="nofollow noreferrer">curio</a>; they might allow you to do stuff you can't with asyncio by default like nesting, but <a href="https://en.wikipedia.org/wiki/Here_be_dragons" rel="nofollow noreferrer">here be dragoons</a>. I highly recommend trio and the <a href="https://vorpus.org/blog/archives.html" rel="nofollow noreferrer">multiple blog posts around its creation</a>, especially if you are teaching async.</p>
<p>Enjoy, hope that helped, and please report bugs, as well as things that did work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make the tornado server run in background using the <a href="https://ipython.org/ipython-doc/dev/interactive/magics.html#cellmagic-script" rel="nofollow noreferrer"><code>%%script --bg</code></a> magic command. The option <code>--bg</code> tells jupyter to run the code of the current cell in background.</p>
<p>Just create a tornado server in one cell alongwith the magic command and run that cell.</p>
<p>Example:</p>
<pre><code>%%script python --bg

import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

loop = tornado.ioloop.IOLoop.current()

app = make_app()
app.listen(8000) # 8888 was being used by jupyter in my case

loop.start()
</code></pre>
<p>And then you can use <code>requests</code> in a separate cell to connect to the server:</p>
<pre><code>import requests

print(requests.get("http://localhost:8000"))

# prints &lt;Response [200]&gt;
</code></pre>
<hr/>
<p>One thing to note here is that if you stop/interrupt the kernel on any cell, the background script will also stop. So you'll have to run this cell again to start the server.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on my <a href="https://github.com/mrocklin/streamz/pull/227" rel="nofollow noreferrer">recent PR to streamz</a>, here is something that works, similar to your idea:</p>
<pre><code>class InNotebookServer(object):
    def __init__(self, port):
        self.port = port
        self.loop = get_ioloop()
        self.start()

    def _start_server(self):
        from tornado.web import Application, RequestHandler
        from tornado.httpserver import HTTPServer
        from tornado import gen

        class Handler(RequestHandler):
            source = self

            @gen.coroutine
            def get(self):
                self.write('Hello World')

        application = Application([
            ('/', Handler),
        ])
        self.server = HTTPServer(application)
        self.server.listen(self.port)

    def start(self):
        """Start HTTP server and listen"""
        self.loop.add_callback(self._start_server)


_io_loops = []

def get_ioloop():
    from tornado.ioloop import IOLoop
    import threading
    if not _io_loops:
        loop = IOLoop()
        thread = threading.Thread(target=loop.start)
        thread.daemon = True
        thread.start()
        _io_loops.append(loop)
    return _io_loops[0]
</code></pre>
<p>To call in the notebook</p>
<pre><code>In [2]: server = InNotebookServer(9005)
In [3]: import requests
        requests.get('http://localhost:9005')
Out[3]: &lt;Response [200]&gt;
</code></pre>
</div>
<span class="comment-copy">This does work well. I do think this falls under "command line subprocess" however as this is effectively what happens in the background. I would like to avoid this solution as the <code>app/loop</code> is not interactive in this particular scenario.</span>
<span class="comment-copy">@Daniel Can you please define "not interactive"?</span>
<span class="comment-copy">The <code>app</code> is not accessible from within other parts of Jupyter. For example if I have a method <code>app.await_results()</code> which will block until operations are completed this is not possible under the current model.</span>
