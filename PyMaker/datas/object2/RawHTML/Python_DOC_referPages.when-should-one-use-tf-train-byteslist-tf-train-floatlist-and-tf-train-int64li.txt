<div class="post-text" itemprop="text">
<p>TensorFlow provides 3 different formats for data to be stored in a <code>tf.train.Feature</code>. These are:</p>
<pre><code>tf.train.BytesList
tf.train.FloatList
tf.train.Int64List
</code></pre>
<p>I often struggle to choose between <code>tf.train.Int64List</code> / <code>tf.train.FloatList</code> and <code>tf.train.BytesList</code>.</p>
<p>I see some examples online where they convert ints/floats into bytes and then store them in a <code>tf.train.BytesList</code>. Is this preferable to using one of the other formats? If so, why does TensorFlow even provide <code>tf.train.Int64List</code> and <code>tf.train.FloatList</code> as optional formats when you could just convert them to bytes and use <code>tf.train.BytesList</code>?</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because bytes list will require more memory. It's designed to store string data, or for example numpy arrays converted to single bytestring. Consider example:</p>
<pre><code>def int64_feature(value):
    if type(value) != list:
        value = [value]
    return tf.train.Feature(int64_list=tf.train.Int64List(value=value))

def float_feature(value):
    if type(value) != list:
        value = [value]
    return tf.train.Feature(float_list=tf.train.FloatList(value=value))

def bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))

writer = tf.python_io.TFRecordWriter('file.tfrecords')
bytes = np.array(1.1).tostring() 
int = 1
float = 1.1
example = tf.train.Example(features=tf.train.Features(feature={'1': float_feature(float)}))
writer.write(example.SerializeToString())
writer.close()

for str_rec in tf.python_io.tf_record_iterator('file.tfrecords'):
    example = tf.train.Example()
    example.ParseFromString(str_rec)
    str = (example.features.feature['1'].float_list.value[0])
    print(getsizeof(str))
</code></pre>
<p>For dtype float in will output 24 bytes, the lowest value. However, you can't pass int to a <code>tf.train.FloatList</code>. Int dtype will occupy 28 bytes in this case, while bytes will be 41 undecoded(before applying <code>np.fromstring</code>) and even more after.</p>
</div>
<span class="comment-copy">Great, thanks @Sharky. That the bytes list will take more memory and is designed to store string data answers the question and makes a lot of sense. The code was particularly useful.</span>
<span class="comment-copy">If I may, why does a bytes list take more memory? I always considered bytes to be computer readable and compact...</span>
<span class="comment-copy">You're right about bytes, but it only holds when dealing with numbers. string or bytes stores additional information, such as length, length in bytes, encoding type, hash and maybe some other. Take a look <a href="https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html" rel="nofollow noreferrer">jakevdp.github.io/PythonDataScienceHandbook/â€¦</a></span>
<span class="comment-copy">Ah I see, so in my case, if I would like to store a 2 dimensional list of float values, I should perhaps use float_list since converting to bytes would mean that I store type info and reference count in the bytes? That link was very useful indeed, thank you.</span>
