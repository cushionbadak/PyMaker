<div class="post-text" itemprop="text">
<p>I am looking through some unit testing code and I found this:</p>
<pre><code>self.assertIn(b'Hello', res.body)
</code></pre>
<p>I know that this means <a href="http://docs.python.org/3/reference/lexical_analysis.html#literals" rel="nofollow noreferrer"><code>bytes</code></a> in Python 3 which <a href="http://docs.python.org/3/library/functions.html#bytes" rel="nofollow noreferrer">returns a byte array</a>, as I found <a href="https://stackoverflow.com/a/2592818/2502012">here</a>.  I believe that the code was written for Python 3.3 and am trying to figure out how it works in other versions (in my case 2.7)  The <a href="https://stackoverflow.com/questions/2592764/what-does-a-b-prefix-before-a-python-string-means">related question</a> that I found had a poorly-written accepted answer with contradictory comments that confused me.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>In what versions of python does <code>b'myString'</code> "work"?</li>
<li>How does it behave in python 2.x?</li>
<li>How does it behave in python 3.x?</li>
<li>Does that have something to do with the <a href="http://docs.python.org/2/whatsnew/2.6.html#pep-3112-byte-literals" rel="nofollow noreferrer">byte literal change</a>?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This is all described in the document you linked.</p>
<ul>
<li>In what versions of python does <code>b'myString'</code> "work"?: <strong>2.6+.</strong></li>
<li>How does it behave in python 2.x? <strong>It creates a <code>bytes</code> literal—which is the exact same thing as a <code>str</code> literal in 2.x.</strong></li>
<li>How does it behave in python 3.x? <strong>It creates a <code>bytes</code> literal—which is <em>not</em> the same thing as a <code>str</code> literal in 3.x.</strong></li>
<li>Does that have something to do with the byte literal change? <strong>Yes. That's the whole point; it lets you write "future compatible" code—or code that works in both 2.6+ and 3.0+ without <code>2to3</code>.</strong></li>
</ul>
<p>Quoting from the first paragraph in the section you linked:</p>
<blockquote>
<p>For future compatibility, Python 2.6 adds <code>bytes</code> as a synonym for the <code>str</code> type, and it also supports the b'' notation.</p>
</blockquote>
<p>Note that, as it says a few lines down, Python 2.x <code>bytes</code>/<code>str</code> is not exactly the same type as Python 3.x <code>bytes</code>: "most notably, the constructor is completely different". But bytes literals are the same, except in the edge case where you're putting Unicode characters into a bytes literal (which has no defined meaning in 2.x, but does something arbitrary that may sometimes happen to be what you'd hoped, while in 3.x it's a guaranteed <code>SyntaxError</code>).</p>
</div>
<span class="comment-copy">What's contradictory about the comments to that answer? It's just the answerer and another user helping each other out looking for reference links to back up the very simple answer. (Section 2.4.1 of the reference docs had a bug in 2.6, but it was fixed; see <a href="http://docs.python.org/2.7/reference/lexical_analysis.html#string-literals" rel="nofollow noreferrer">here</a>.)</span>
<span class="comment-copy">And what part of the answer is unclear? It specifically says it's a bytes literal in 3.x, it's not legal at all in 2.5 and older, and it's equivalent to a plain string in 2.6+ for future compatibility. The only thing remotely confusable is whether 2.6+ includes 3.x (it doesn't; that was already covered in the first part).</span>
<span class="comment-copy">Finally, <code>bytes</code> does <i>not</i> return a <code>bytearray</code> in 3.x. Those are two separate but related types, similar to <code>frozenset</code> vs. <code>set</code> or <code>tuple</code> vs. <code>list</code>.</span>
<span class="comment-copy">The answer uses the word "it" a total of two times. One of them is inside a parenthetical aside that you can completely ignore. The other, I can't imagine what "it" could possibly refer to besides either "bytes literal" or "this prefix", and it makes perfect sense either way.</span>
<span class="comment-copy">More importantly, if you think an answer is confusing, comment on the answer; don't create a new question asking for comments on the answer to another question.</span>
<span class="comment-copy">Is there no <code>bytes</code> literal equivalent in Python 2.x? I'm working on making a script that was written for Python 3, Python 2.7 compatible. I ran <code>3to2</code> on it but still doesn't work so I'm going in and doing it myself. When I read in a certain kind of file header I get statements like: <code>b'DIGLABELdigin\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'</code> in Python 3 but the come up as weird symbols in Python 2.7. they look like little 2x2 matrices but they're characters. When I past them into a txt editor they come up as new lines and stuff like that</span>
<span class="comment-copy">In Python 2.7, bytes and str are the same type. You can use the 'b' prefix, but it has no effect. (Similarly, in Python 3.4, you can use the 'u' prefix, but it has no effect.) So you most likely already have the right thing; the issue is just that you're trying to print it to the console, and Python 2.x and 3.x do that differently, so you see, say, the cp1252 character for 0x01 in 2.x, but the escaped string <code>\x01</code> in 3.x. If you want to ensure that you see escaped strings in both, explicitly <code>print(s.decode('unicode-escape'))</code>.</span>
