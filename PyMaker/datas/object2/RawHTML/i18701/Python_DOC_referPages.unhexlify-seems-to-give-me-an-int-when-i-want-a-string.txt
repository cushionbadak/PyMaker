<div class="post-text" itemprop="text">
<p>I need to do an XOR of two hex strings so that each byte is XORed separately, but it doesn't work because the <code>ord()</code> function that I use seems to be getting an <code>int</code> as input instead of the intended string. Take a look at his code first to see what I mean:</p>
<pre><code>from binascii import hexlify, unhexlify

def xor_hexstr(s1, s2):
    if len(s1) &gt; len(s2):
        q = zip(unhexlify(s1[:len(s2)]), unhexlify(s2))
        return hexlify("".join(chr(ord(c1) ^ ord(c2)) for c1, c2 in q))

    else:
        q = zip(unhexlify(s2[:len(s1)]), unhexlify(s1))
        return hexlify("".join(chr(ord(c1) ^ ord(c2)) for c1, c2 in q))


t1 = "0ec17c9dabb8955c5dfb9cef627ddb4d"
t2 = "4ca00ff4c898d61e1edbf1800618fb28"

xor_hexstr(t1, t2)
</code></pre>
<p>And the error that I am getting:</p>
<pre><code>TypeError: ord() expected string of length 1, but int found
</code></pre>
<p>I then checked the values of q, and they indeed where integers for some reason. I don't see why, because according to my logic they are supposed to be strings because I gave it a hex encoded string, unhexlified it and then stuck each character into a slot in q.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <code>hexlify</code> and <code>unhexlify</code> on Python 3, where they return a <code>bytes</code> object. You then zip these objects, which iterates over the <code>bytes</code> objects to create the pairs. Iteration over a <code>bytes</code> object produces integers. See the <a href="http://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code> type documentation</a>:</p>
<blockquote>
<p>While <code>bytes</code> literals and representations are based on ASCII text, <code>bytes</code> objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code>0 &lt;= x &lt; 256</code>.</p>
</blockquote>
<p>You do not need to use <code>ord()</code> when looping over a <code>bytes</code> object; you <em>already</em> have integers representing the individual bytes.</p>
<p>Simply use a <code>bytes</code> object again after XOR-ing the values:</p>
<pre><code>def xor_hexstr(s1, s2):
    if len(s1) &gt; len(s2):
        q = zip(unhexlify(s1[:len(s2)]), unhexlify(s2))
    else:
        q = zip(unhexlify(s2[:len(s1)]), unhexlify(s1))

    return hexlify(bytes(c1 ^ c2 for c1, c2 in q))
</code></pre>
<p>Note that <code>hexlify</code> returns a <code>bytes</code> object too. If you <em>have</em> to have a string (unicode) object then decode from ASCII:</p>
<pre><code>xor_hexstr(t1, t2).decode('ASCII')
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; xor_hexstr(t1, t2)
b'426173696320434243206d6f64652065'
&gt;&gt;&gt; xor_hexstr(t1, t2).decode('ASCII')
'426173696320434243206d6f64652065'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from binascii import hexlify, unhexlify

def xor_hexstr(s1, s2):
    q = zip(unhexlify(s1), unhexlify(s2))
    return "".join(chr(c1 ^ c2) for c1, c2 in q)


s1 = "0ec17c9dabb8955c5dfb9cef627ddb4d"
s2 = "4ca00ff4c898d61e1edbf1800618fb28"

print(xor_hexstr(s1, s2))
</code></pre>
<p>output <code>Basic CBC mode e</code></p>
</div>
<span class="comment-copy">Why do you pass <code>s1</code>, <code>s2</code> instead of <code>t1</code>, <code>t2</code>?</span>
<span class="comment-copy">Sorry falsetru, that was a typo :D. I don't have that in my original code though.</span>
<span class="comment-copy">Thank you! Your solution worked, and your explanation was good :D.</span>
