<div class="post-text" itemprop="text">
<p>I checked on this link that set is mutable <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#frozenset</a> while frozenset is immutable and hence hashable. So how is the set implemented in python and what is the element look up time? Actually I had a list of tuples [(1,2),(3,4),(2,1)] where each entry in the tuple is a id and I wanted to create a set/frozenset out of the this list. In this case the set should contain (1,2,3,4) as elements. Can I use frozenset to insert elements into it one by one from the list of tuples or I can only use a set?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can instantiate a frozenset from a generator expression or other iterable. It's not immutable until it's finished being instantiated.</p>
<pre><code>&gt;&gt;&gt; L = [(1,2),(3,4),(2,1)]
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; frozenset(chain.from_iterable(L))
frozenset([1, 2, 3, 4])
</code></pre>
<p>Python3.3 also has an optimisation that turns set literals such as {1, 2, 3, 4} into precomputed frozensets when used as the right-hand side of an <code>in</code> operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sets and frozensets are implemented the same way, as hashtables. (Why else would they require their elements to implement <code>__hash__</code>?) In fact, if you look at <a href="https://hg.python.org/cpython/file/3.6/Objects/setobject.c" rel="nofollow noreferrer"><code>Objects/setobject.c</code></a>, they share almost all their code. This means that as long as hash collisions don't get out of hand, lookup and deletion are O(1) and insertion is amortized O(1).</p>
<p>The usual way to create a frozenset is to initialize it with some other iterable. As gnibbler suggested, the best fit here would probably be <code>itertools.chain.from_iterable</code>:</p>
<pre><code>&gt;&gt;&gt; L = [(1,2),(3,4),(2,1)]
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; frozenset(chain.from_iterable(L))
frozenset([1, 2, 3, 4])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As for your first question, I haven't actually checked the source, but it seems safe to assume from the fact that sets need to contain objects of hashable types, that it is implemented using a hash table, and that its lookup time is, therefore, O(1).</p>
<p>As for your second question, you cannot insert the elements into a <code>frozenset</code> one by one (obviously, since it's immutable), but there's no reason to use a set instead; just construct it from a list (or other iterable) of the constituent values, e.g. like this:</p>
<pre><code>data = [(1, 2), (3, 4), (2, 1)]
result = frozenset(reduce(list.__add__, [list(x) for x in data], []))
</code></pre>
</div>
<span class="comment-copy">This is purely speculation, but I would think that they're both implemented in the same way, but frozenset has a write lock (hence the immutability). The lookup times on a <code>frozenset</code> should be faster in the average case, given that with mutability (in <code>set</code>s), the interpreter may need to probe longer to find/insert an element. Hopefully though, someone who really knows this will post an answer - I'm interested</span>
<span class="comment-copy">What should you prefer set or frozenset and what is the difference in lookup times?</span>
<span class="comment-copy">@vkaul11, I wouldn't expect there to be a difference in lookup time</span>
<span class="comment-copy">@vkaul11, the frozenset optimization should mean that the set is created at compile time, not every time the code is executed (at run time). Depending on the situation this micro-optimization could have a noticeable effect on performance.</span>
<span class="comment-copy">docs.python.org/2.4/lib/types-set.html So the link here is outdated? There are currently two builtin set types, set and frozenset. The set type is mutable -- the contents can be changed using methods like add() and remove(). Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset type is immutable and hashable -- its contents cannot be altered after is created; however, it can be used as a dictionary key or as an element of another set</span>
<span class="comment-copy">While that link is about an old version, the information in it is still mostly correct. It doesn't contradict what I've said, though. Most of the frozenset and set code is the exact same code. They even have the same iterator type.</span>
<span class="comment-copy">According to the link, set does not have a hash value so how is it implemented with hash table?</span>
<span class="comment-copy">A hash table doesn't have to be hashable; its keys have to be hashable.</span>
<span class="comment-copy"><code>list.__add__</code> will give you quadratic performance. You should use <code>list.__iadd__</code> there instead</span>
<span class="comment-copy">Sure, but it was just an example. I tried to keep it simple for the sake of demonstration, though I'm not sure how well I succeeded in the end. :)</span>
<span class="comment-copy"><a href="http://docs.python.org/2.4/lib/types-set.html" rel="nofollow noreferrer">docs.python.org/2.4/lib/types-set.html</a> So the link here is outdated? There are currently two builtin set types, set and frozenset. The set type is mutable -- the contents can be changed using methods like add() and remove(). Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset type is immutable and hashable -- its contents cannot be altered after is created; however, it can be used as a dictionary key or as an element of another set.</span>
<span class="comment-copy">What makes you think it is outdated? It seems accurate to me.</span>
<span class="comment-copy">You said above  "I haven't actually checked the source, but it seems safe to assume from the fact that sets need to contain objects of hashable types, that it is implemented using a hash table, and that its lookup time is, therefore, O(1)." and the link said "it has no hash value and cannot be used as either a dictionary key or as an element of another set."</span>
