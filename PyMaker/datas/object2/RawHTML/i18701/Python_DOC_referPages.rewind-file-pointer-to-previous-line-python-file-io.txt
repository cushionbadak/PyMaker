<div class="post-text" itemprop="text">
<p>I'm reading throug a large gene file of the format</p>
<pre><code>&gt;GeneID
ACTCTCTCTATATATATATAT\n
GCTCTGCTTCTAGAGAGAGTG\n
TCTATTTGTTTATATATCTTT\n
&gt;GeneID
GCTCTGCTTCTAGAAATTCCC\n
ACTCTGTATATATTTTCAAAA\n
GCTCTGCTTCTAGAGAGAGTG\n
</code></pre>
<p>Each gene start with a &gt; then a unique ID. After comes line of the nucleotides of that gene.
Unfortunately, this file was generated so that there are line breaks between each of the lines of sequence.</p>
<p>I need to read in each sequence as one contiguous string. So, I have been using the next method (as shown below).</p>
<pre><code>for line in filer:
    if line.startswith("&gt;"):

        # Find Sequences
        seq_seg = next(filer)
        seq = ""

        # Concatenate lines until find next gene
        while not (seq_seg.startswith("&gt;")):
            seq += seq_seg.strip()  # Get rid of '\n'
            seq_seg = next(filer)
</code></pre>
<p>I find that my script is only picking up half of the genes in the file because when next is called on the condition that makes the while loop fail, the file pointer is pointing to the next gene ID, then when the next iteration of the for loop executes, it moves to the next file.</p>
<p>Is there a way to rewind the file pointer to the previous line, so my for loop catches that as a new gene?</p>
<p>I have seen similar questions, but none of them address the specific way that I am reading through the file with the </p>
<pre><code>  for line in file:
        #do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a generator instead of skipping through lines (something tells me this can be simplified greatly):</p>
<pre><code>def parse_file(file):
    id = ''
    gene = ''

    for line in file:
        if line.startswith('&gt;'):
            if gene:
                yield id, gene

            id = line[1:]
            gene = ''
        else:
            gene += line.strip()
    else:
        yield id, gene # Final gene
</code></pre>
<p>Now, you can safely iterate over the whole thing with just a few lines of code:</p>
<pre><code>with open('file.txt', 'r') as handle:
    for gene_id, nucleotides in parse_file(handle):
        print gene_id, nucleotides
</code></pre>
<p>There's also <a href="https://pypi.python.org/pypi/pyfasta/" rel="nofollow">pyfasta</a>.</p>
<p>Or a more general function with <code>itertools</code>:</p>
<pre><code>def grouper(line):
    return line.startswith('&gt;') and line[1:]

def itersplit(it, pred):
    groups = (list(group) for key, group in itertools.groupby(it, pred))
    yield from zip(groups, groups)

def parse(file):
    for key, group in itersplit(file, grouper):
        yield key[0], ''.join(group)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a way to rewind the file pointer to the previous line, so my for loop catches that as a new gene?</p>
</blockquote>
<p>In Python 3, no. You cannot mix file iteration with explicit operations on the file pointer.</p>
<p>In Python 2, maybe. But this only works by accident, which is why it was banned in 3.0, and it's not guaranteed to work properly in every case. So, you shouldn't do it.</p>
<p>A better way to do it is to ask how to rewind an <em>iterator</em>. And the answer is <a href="http://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a>. You can peek ahead by using <code>tee</code>. You can rebind the iterator to <code>chain([pushed_back_value], iterator)</code>. And so on.</p>
<p>But, as others have pointed out, there's an even better way to do this. You don't really need to peek ahead <em>or</em> seek back here, you just need to group things. You can do that with <code>itertools</code> too, but in this case it's trivial enough that you might as well just do it explicitly, as Blender shows.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another method that uses <code>re</code> and <code>mmap</code>:</p>
<pre><code>import mmap, re

with open(your_file) as fin:
    mm = mmap.mmap(fin.fileno(), 0, access=mmap.ACCESS_READ)
    for match in re.finditer('&gt;([^\n]+)([^&gt;]*)', mm, flags=re.DOTALL):
        print match.group(1), match.group(2).replace('\n', '')

#GeneID1 ACTCTCTCTATATATATATATGCTCTGCTTCTAGAGAGAGTGTCTATTTGTTTATATATCTTT
#GeneID2 GCTCTGCTTCTAGAAATTCCCACTCTGTATATATTTTCAAAAGCTCTGCTTCTAGAGAGAGTG
</code></pre>
<p>Doing it this way enables the entire file to be treated as a string, but will make use of the OS providing the part of the file on demand to be complete the regex. As it uses <code>finditer</code> we're also not building a result set up in memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are much easier ways to read a fasta file, for example:</p>
<pre><code>entries = []
for line in filer:
    if line.startswith('&gt;'):
        entries.append((line.rstrip()[1:], []))
    else:
        entries[-1][1].append(line.rstrip())
</code></pre>
<p>This will give you an list of tuples.  The first element is the sequence ID and the second element is a list of the sequences.</p>
<p>It's easy to join the sequences after this:</p>
<pre><code>entries = [(x, "".join(y)) for x,y in entries]
</code></pre>
</div>
<span class="comment-copy">You really, really don't want to call <code>next</code> on an iterator while already looping over the same iterator, unless you want to screw with the iteration in exactly the way you're doing.</span>
<span class="comment-copy">Won't this miss the last entry?  Since the file does not end with a line beginning with <code>&gt;</code>?</span>
<span class="comment-copy">@GWW: Yes, thanks.</span>
<span class="comment-copy">@Blender: It can definitely be simplified by first grouping the iterator over lines into an iterator over batches where a line starting with <code>'&gt;'</code> marks a new one, and then just processing each batch. But I think the resulting code would be harder to understand for a novice, so the way you already wrote it is a perfect way to illustrate the idea.</span>
<span class="comment-copy">@Blender: I'd write a more general <code>itersplit</code> function that takes a predicate and an iterator and iterators over groups split each time the predicate is true. Also, I think you could do it even more simply with <code>takewhile</code> than with <code>groupby</code>. But again, I think your original version is clearer anyway.</span>
<span class="comment-copy">@Blender: Actually, never mind; using <code>takewhile</code> easily requires a two-arg <code>iter</code> around its <code>next</code>, which is just silly. But all you're doing to the <code>groupby</code> is (a) throwing away the keys, (b) listifying the values, and (c) grouping the values into pairs (because the keys always alternate), soâ€¦ that's almost a 1-liner. See my edit to your answer.</span>
