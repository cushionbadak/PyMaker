<div class="post-text" itemprop="text">
<p>I am using pyserial and need to send some values less than 255. If I send the int itself the the ascii value of the int gets sent. So now I am converting the int into a unicode value and sending it through the serial port. </p>
<pre><code>unichr(numlessthan255);

However it throws this error:
'ascii' codec can't encode character u'\x9a' in position 24: ordinal not in range(128)
</code></pre>
<p>Whats the best way to convert an int to unicode?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <code>chr(somenumber)</code> to get a 1 byte value of an int as long as it is less than 256.  pySerial will then send it fine.</p>
<p>If you are looking at sending things over pySerial it is a <em>very</em> good idea to look at the struct module in the standard library it handles endian issues an packing issues as well as encoding for just about every data type that you are likely to need that is 1 byte or over.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2 - Turn it into a string first, then into unicode.</p>
<pre><code>str(integer).decode("utf-8")
</code></pre>
<p>Best way I think. Works with any integer, plus still works if you put a string in as the input.</p>
<p>Updated edit due to a comment: For Python 2 and 3 - This works on both but a bit messy:</p>
<pre><code>str(integer).encode("utf-8").decode("utf-8") 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/2/library/functions.html#chr" rel="noreferrer"><code>chr()</code> function</a> instead; you are sending a value of less than 256 but more than 128, but are creating a Unicode character.</p>
<p>The unicode character has to then be encoded first to get a <em>byte</em> character, and that encoding fails because you are using a value outside the ASCII range (0-127):</p>
<pre><code>&gt;&gt;&gt; str(unichr(169))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode character u'\xa9' in position 0: ordinal not in range(128)
</code></pre>
<p>This is normal Python 2 behaviour; when trying to convert a unicode string to a byte string, an implicit encoding has to take place and the default encoding is ASCII.</p>
<p>If you were to use <code>chr()</code> instead, you create a byte string of one character and that implicit encoding does <em>not</em> have to take place:</p>
<pre><code>&gt;&gt;&gt; str(chr(169))
'\xa9'
</code></pre>
<p>Another method you may want to look into is the <a href="http://docs.python.org/2/library/struct.html" rel="noreferrer"><code>struct</code> module</a>, especially if you need to send integer values <em>greater</em> than 255:</p>
<pre><code>&gt;&gt;&gt; struct.pack('!H', 1000)
'\x03\xe8'
</code></pre>
<p>The above example packs an integer into a unsigned short in network byte order, for example.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that the best solution is to be explicit and say that you want to represent a number as a byte (and <a href="https://stackoverflow.com/questions/4545661/unicodedecodeerror-when-redirecting-to-file/4546129#4546129">not as a character</a>):</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('B', 128)
&gt;&gt;&gt; '\x80'
</code></pre>
<p>This makes your code work in both Python 2 and Python 3 (in Python 3, the result is, as it should, a <a href="http://docs.python.org/3/library/functions.html#bytes" rel="nofollow noreferrer">bytes</a> object). An alternative, in Python 3, would be to use the new <code>bytes([128])</code> to create a single byte of value 128.</p>
<p>I am not a big fan of the <code>chr()</code> solutions: <a href="http://docs.python.org/3/library/functions.html#chr" rel="nofollow noreferrer">in Python 3</a>, they produce a (character, not byte) <em>string</em> that needs to be <a href="https://stackoverflow.com/questions/4545661/unicodedecodeerror-when-redirecting-to-file/4546129#4546129">encoded</a> before sending it anywhere (file, socket, terminal,…)—<code>chr()</code> in Python 3 is equivalent to the problematic Python 2 <code>unichr()</code> of the question. The <code>struct</code> solution has the advantage of correctly producing a byte whatever the version of Python. If you want to send data over the serial port with <code>chr()</code>, you need to have control over the encoding that must take place subsequently. The code might work when the default encoding used by Python 3 is UTF-8 (which I think is the case), but this is due to the fact that Unicode characters of code point smaller than 256 can be coded as a single byte in UTF-8. This adds an unnecessary layer of subtlety and complexity that I do not recommend (it makes the code harder to understand and, if necessary, debug).</p>
<p>So, I strongly suggest that you use the approach above (which was also hinted at by Steve Barnes and Martijn Pieters): it makes it clear that you want to produce a <em>byte</em> (and not characters). It will not give you any surprise even if you run your code with Python 3, and it makes your intent clearer and more obvious.</p>
</div>
<span class="comment-copy">Python2 or Python3? (guessing Python2, but makes quite the difference) Are you quite sure <code>unichr</code> is the call crashing? How are you doing the actual sending of the unichr returned data?</span>
<span class="comment-copy"><code>unichr()</code> does not exist in Python 3, so this is Python 2. <code>unichr()</code> is named <code>chr()</code> in Python 3 (conversion to a Unicode character).</span>
<span class="comment-copy">that works thanks a lot</span>
<span class="comment-copy">@user2578666: If a response is useful to you and you mark it as accepted, it is only fair to up-vote it too. Welcome to StackOverflow!</span>
<span class="comment-copy">No rep yet.Got to earn it:-)</span>
<span class="comment-copy">@user2578666: I see—I did not remember this rule. May you reputation grow fast. :)</span>
<span class="comment-copy"><code>chr(32)</code> is also <code>0x20</code> which is the space character - what do you expect to see?</span>
<span class="comment-copy"><code>str(integer).encode("utf-8").decode("utf-8")</code>, while ugly, will work on Python 2 and 3, whereas the above will only work on Python 2.</span>
<span class="comment-copy">I guess you meant "bytes", not "a byte character"? "byte character" is not a common expression, and is almost an <a href="http://stackoverflow.com/questions/4545661/unicodedecodeerror-when-redirecting-to-file/4546129#4546129">oxymoron</a>. Furthermore, the default encoding does not have to be ASCII: it is officially <code>sys.getdefaultencoding()</code>.</span>
<span class="comment-copy">@EOL: This is Python 2, this is a string object, which is really a sequence of bytes. But looping over it gives you strings of length 1; byte characters.</span>
<span class="comment-copy">@EOL: The default encoding <b>is</b> ASCII on Python 2, when it comes to implicit encodings (concatenating strings and unicode, comparing for equality, etc.).</span>
<span class="comment-copy">@EOL: Do not confuse that with the <code>print</code> statement / function encoding to the codec of <code>sys.stdout</code>.</span>
<span class="comment-copy">Do you have a reference that states this? I have always been looking for it.</span>
<span class="comment-copy">Bravo @EOL - one of the, (possibly many), misleading things about C that C++ inherited is the lack of any distinction between a string that has a length of 1, a single character - both text n the local encoding - and a byte.</span>
