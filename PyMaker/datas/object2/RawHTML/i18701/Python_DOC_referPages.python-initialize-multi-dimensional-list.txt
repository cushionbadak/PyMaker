<div class="post-text" itemprop="text">
<p>I want to initialize a multidimensional list. Basically, I want a 10x10 grid - a list of 10 lists each containing 10 items.</p>
<p>Each list value should be initialized to the integer 0.</p>
<p>The obvious way to do this in a one-liner: <code>myList = [[0]*10]*10</code> won't work because it produces a list of 10 references to one list, so changing an item in any row changes it in all rows.</p>
<p>The documentation I've seen talks about using <code>[:]</code> to copy a list, but that still won't work when using the multiplier: <code>myList = [0]*10; myList = myList[:]*10</code> has the same effect as <code>myList = [[0]*10]*10</code>.</p>
<p>Short of creating a loop of <code>myList.append()</code>s, is there a quick efficient way to initialize a list in this way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it quite efficiently with a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>:</p>
<pre><code>a = [[0] * number_cols for i in range(number_rows)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a job for...the nested <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>!</p>
<pre><code>[[0 for i in range(10)] for j in range(10)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just thought I'd add an answer because the question asked for the general n-dimensional case and I don't think that was answered yet. You can do this recursively for any number of dimensions with the following example:</p>
<pre><code>n_dims = [3, 4, 5]

empty_list = 0
for n in n_dims:
    empty_list = [empty_list] * n

&gt;&gt;&gt;empty_list
&gt;&gt;&gt;[[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
   [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
   [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
   [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
   [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might actually need an <a href="http://docs.python.org/2/library/array.html" rel="nofollow">array</a> instead of some lists. Almost every time I see this "presized nested list" pattern, something is not quite right.</p>
</div>
<div class="post-text" itemprop="text">
<p>An additional solution is to use NumPy library:</p>
<pre><code>import numpy as np

zero_array = np.zeros((10, 10), dtype='int')
</code></pre>
<p>This can be easily converted to a regular python list with the <code>.tolist()</code> method if necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two common and short way to do this:</p>
<p><strong>First:</strong></p>
<pre><code>[[0] * n] * m
</code></pre>
<p><strong>Second:</strong></p>
<pre><code>[[0 for column in range(n)] for row in range(m)]
</code></pre>
</div>
<span class="comment-copy">I think the <code>[:]</code> idea can work too, e.g. <code>[x[:] for x in [[0]*10]*10]</code>.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly">this question</a> to understand why <code>[[0]*10]*10</code> doesn't work as expected.</span>
<span class="comment-copy">Nice, avoids the nested for loop that the obvious answer has, but only works if the value to which you want the array initialized is okay to be referenced multiple times, so not if you want the array populated with unique instances of a class.</span>
<span class="comment-copy">That is correct. Glad that you bring that up.</span>
<span class="comment-copy">Perfect. Works great. Thanks!</span>
<span class="comment-copy">Note the data may now be accessed using array-like syntax: <code>a[col_num][row_num]</code></span>
<span class="comment-copy">I believe you mean <code>a[row_num][col_num]</code> correct?</span>
<span class="comment-copy">I believe this is more clear and <i>generally</i> preferable to the alternatives (like using <code>[0]*10</code>).</span>
<span class="comment-copy">This is the correct solution if the list elements are mutable objects.</span>
<span class="comment-copy">This has the same problem as described in the question - it creates many references to the same list.</span>
