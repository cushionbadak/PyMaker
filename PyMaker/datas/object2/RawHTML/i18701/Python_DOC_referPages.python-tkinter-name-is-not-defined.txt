<div class="post-text" itemprop="text">
<p>Code:</p>
<pre><code>def createLetters(frame, startX, startY, width, height, spacing):

    alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", "R", 
                "S", "T", "U", "V", "W", "X", "Y", "Z"]

    def letterAction(letter):
        letter.destroy()

    for i in range(0, 26):

        if (i &gt;= 9 and i &lt;= 17):
            y = startY +  height + 2 * spacing
            x = startX + ((width + spacing) * (i - 9))

        elif (i &gt;= 17):
            y = startY + 2 * height + 3 * spacing
            x = (width + spacing) / 2 + startX + ((width + spacing) * (i - 18))

        elif (i &lt;= 8):
            y = startY + spacing
            x = startX + ((width + spacing) * i)

        exec(alphabet[i] + " = Button(" + frame + ", text = '" + alphabet[i] + "', command = letterAction(" + alphabet[i] + "))")
        exec(alphabet[i] + ".place(x = " + str(x) + ", y = " + str(y) + ", width = " + str(width) + ", height = " + str(height) + ")")
</code></pre>
<p>Error:</p>
<pre><code>Exception in Tkinter callback
Traceback (most recent call last):
  File "C:\Python33\lib\tkinter\__init__.py", line 1442, in __call__
    return self.func(*args)
  File "E:\Hangman\hangmanTk.py", line 106, in playScreen
    createLetters("playFrame", 175, 250, 50, 50, 0)
  File "E:\Hangman\hangmanTk.py", line 95, in createLetters
    exec(alphabet[i] + " = Button(" + frame + ", text = '" + alphabet[i] + "', command = letterAction(" + alphabet[i] + "))")
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name 'A' is not defined
</code></pre>
<p>I'm attempting to create multiple tkinter buttons with a loop. I can create the buttons fine but i can't seem to create callbacks for them. When ever i try, it tells me that the variables that i use for the buttons are not defined. I tried adding "exec("global " + alphabet[i])" above where i defined the buttons but that didn't change anything.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://stupidpythonideas.blogspot.com/2013/05/why-evalexec-is-bad.html" rel="nofollow">Using <code>exec</code> is almost always the wrong way to do it, no matter what "it" is.</a></p>
<p><a href="http://stupidpythonideas.blogspot.com/2013/05/why-you-dont-want-to-dynamically-create.html" rel="nofollow">And creating variables dynamically is almost always the wrong thing to do.</a></p>
<p>And your problems getting this to work are a perfect illustration of why.</p>
<hr/>
<p>Just create a <code>dict</code> mapping names to buttons:</p>
<pre><code>buttons = {}

# ...

letter = alphabet[i]
buttons[letter] = Button(frame, text = letter, command = letterAction(letter))
buttons[letter].place(x = x, y = y, width = width, height = height)
</code></pre>
<p>If you really want to dump the <code>dict</code> into <code>locals()</code> (or, similarly, <code>self.__dict__</code> or <code>globals()</code> or …), that's trivial. But you don't. The only place you need to use the variable is in your <code>letterAction</code> function. So:</p>
<pre><code>def createLetters(frame, startX, startY, width, height, spacing):

    alphabet = string.ascii_uppercase
    buttons = {}

    def letterAction(letter):
        buttons[letter].destroy()

    for i, letter in enumerate(alphabet):

        if (i &gt;= 9 and i &lt;= 17):
            y = startY +  height + 2 * spacing
            x = startX + ((width + spacing) * (i - 9))

        elif (i &gt;= 17):
            y = startY + 2 * height + 3 * spacing
            x = (width + spacing) / 2 + startX + ((width + spacing) * (i - 18))

        elif (i &lt;= 8):
            y = startY + spacing
            x = startX + ((width + spacing) * i)

        buttons[letter] = Button(frame, text = letter, command = letterAction(letter))
        buttons[letter].place(x = x, y = y, width = width, height = height)
</code></pre>
<hr/>
<p>But notice that this does the wrong thing. <code>command = letterAction(letter)</code>—whether you run it directly, or via <code>exec</code>—is going to call <code>letterAction(letter)</code> now, destroying the button before you even create it, and returning <code>None</code>, which you'll then set as the <code>command</code>. </p>
<p>You need <code>lambda: letterAction(letter)</code> or <code>partial(letterAction, letter)</code> to fix this.</p>
<p>Plus, you can't write code to pass the button variable itself to <code>letter</code>, either now or later, because the variable doesn't exist yet. You have to pass the <em>letter</em>, as a string, as I did above.</p>
<hr/>
<p>But really, if you think about it, you don't need these button variables at all—whether in a <code>dict</code> or otherwise. You just need a way to bind each button as its own callback's target, right? There are a number of ways to do this, but the obvious one is a class, either inheriting or delegating to <code>Button</code> (or, in this case, neither, since you don't need to use it as a button, or even remember it, after creation).</p>
<p>While we're at it, let's remove some extraneous parens and such that just make things harder to read and fix the problem that <code>17</code> seems to belong in two different groups…</p>
<pre><code>class SelfDestructiveButton(object):
    def __init__(self, frame, letter, x, y, width, height):
        self.button = Button(frame, text=letter, command=self.command)
        self.button.place(x=x, y=y, width=width, height=height)
    def command(self):
        self.button.destroy()

def createLetters(frame, startX, startY, width, height, spacing):
    for i, letter in enumerate(string.ascii_uppercase):
        if 9 &lt;= i &lt;= 17:
            y = startY +  height + 2 * spacing
            x = startX + ((width + spacing) * (i - 9))
        elif i &gt; 17:
            y = startY + 2 * height + 3 * spacing
            x = (width + spacing) / 2 + startX + ((width + spacing) * (i - 18))
        else:
            y = startY + spacing
            x = startX + ((width + spacing) * i)
        SelfDestructiveButton(frame, letter, x, y, width, height)
</code></pre>
<p>It might be even clearer with <code>if 'J' &lt;= letter &lt;= 'R'</code>, because it's the letters rather than the numbers that you're going to see while debugging it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The string in your first call to <code>exec</code> evaluates to:</p>
<pre><code>"A = Button(&lt;frame&gt;, text = 'A', command = letterAction(A))"
</code></pre>
<p>You are therefore referencing <code>A</code> (the name) before having defined it. I'm guessing you forgot the single quotes around the second <code>alphabet[i]</code>:</p>
<pre><code>exec(alphabet[i] + " = Button(" + frame + ", text = '" + alphabet[i] + "', command = letterAction('" + alphabet[i] + "'))")
</code></pre>
<p>Note this would call <code>letterAction('A')</code>, i.e. <code>'A'.destroy()</code>, which will throw an <code>AttributeError</code> since strings have no <code>destroy()</code> method. What is <code>letterAction</code> supposed to achieve?</p>
</div>
<span class="comment-copy"><code>import string; alphabet = list(string.ascii_uppercase)</code> would be a lot less painful</span>
<span class="comment-copy">For that matter, there's no reason to have a list instead of a string in the first place, since all he needs to do is index it. (And looping over <code>enumerate</code> would make it even simpler.)</span>
<span class="comment-copy">What does the <code>enumerate</code> function do with strings? I can't find any examples of it being used with a string.</span>
<span class="comment-copy">@guney98: The same thing it does with any other iterable. It's easier to show than to explain, so just fire up your interpreter and type this: <code>print(list(enumerate('abc')))</code></span>
<span class="comment-copy"><code>place</code> is a very odd choice. Is there a specific reason you're using it instead of <code>grid</code>?</span>
<span class="comment-copy">Maybe the buttons are intended to destroy themselves? In this case, <code>A</code> (the button itself) is no yet created, and <code>letterAction</code> should return the <code>destroy</code> method, not invoke it.</span>
<span class="comment-copy">@tobias_k Or perhaps use <a href="http://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial()</code></a> on the <code>letterAction</code> function. Either way <code>A</code> needs to be defined first though.</span>
<span class="comment-copy">There's no way to make this work without using the button name _as a string_—either <code>lambda: letterAction('A')</code> or <code>partial(letterAction, 'A')</code>. Which means that <code>letterAction</code> has to look it up in <code>locals()</code>. (Of course it's really not a local, but a closure variable… but <code>locals()[letter]</code> will work.)</span>
