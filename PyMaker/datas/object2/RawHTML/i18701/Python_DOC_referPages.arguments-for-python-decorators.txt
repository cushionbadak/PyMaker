<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15564512/how-to-create-a-decorator-function-with-arguments-on-python-class">How to create a decorator function with arguments on python class?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>So with the following...</p>
<pre><code>    def makeBold(fn):
        def wrapped():
            return '&lt;b&gt;'+fn()+'&lt;/b&gt;'
        return wrapped

    @makeBold
    def produceElement():
        return 'hello'
</code></pre>
<p>The result is</p>
<pre><code>    &lt;b&gt;hello&lt;/b&gt;
</code></pre>
<p>I would like to do something like this...</p>
<pre><code>    @makeBold(attrib=val, attrib=val)
    def produceElement():
        return 'hello'
</code></pre>
<p>and have the result be something like...</p>
<pre><code>    &lt;b attrib=val, attrib=val&gt;hello&lt;b/&gt;
</code></pre>
<p>Any advice would be great!</p>
</div>
<div class="post-text" itemprop="text">
<p>Wrap your function with another function:</p>
<pre><code>import functools
def makeBold(**kwargs):
    attribstrings = str(kwargs) # figure out what to do with the dict yourself 
    def actualdecorator(fn):
        @functools.wraps(fn)
        def wrapped():
            return '&lt;b'+attribstrings+'&gt;'+fn()+'&lt;/b&gt;'
        return wrapped
    return actualdecorator
</code></pre>
<p>I leave working out how to build the string as an exercise for the reader.</p>
<p>Note that the structure of a decorator expression is <code>@ &lt;callable object of one parameter, w&gt; &lt;declaration of callable object, f&gt;</code>. It's effect is <code>f = w(f)</code>. Accordingly, <code>w</code> (the decorator) has to return a callable of the same type as <code>f</code>.</p>
<p>In <code>@makebold(foo)def bar(x):pass</code>, the expression <code>makebold(foo)</code> is the decorator - that is, the final effect of the decorator is <code>bar = makebold(foo)(bar)</code>, and so <code>bar</code> ends up holding <code>wrapped</code>.</p>
<p>The purpose of <code>functools.wraps</code> is to fix up properties of the decorated function to copy over metadata (such as name and docstring) from the argument function to the wrapped function, so that the whole wrapping process is transparent.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm perhaps dubious that this is a good use case for decorators, but here:</p>
<pre><code>import string

SelfClosing = object()

def escapeAttr(attr):
    # WARNING: example only, security not guaranteed for any of these functions
    return attr.replace('"', '\\"')

def tag(name, content='', **attributes):
    # prepare attributes
    for attr,value in attributes.items():
        assert all(c.isalnum() for c in attr)  # probably want to check xml spec
    attrString = ' '.join('{}="{}"'.format(k,escapeAttr(v)) for k,v in attributes.items())

    if not content==SelfClosing:
        return '&lt;{name} {attrs}&gt;{content}&lt;/{name}&gt;'.format(
            name = name,
            attrs = attrString,
            content = content
        )
    else:  # self-closing tag
        return '&lt;{name} {attrs}/&gt;'
</code></pre>
<p>Example:</p>
<pre><code>def makeBoldWrapper(**attributes):
    def wrapWithBold(origFunc):
        def composed(*args, **kw):
            result = origFunc(*args, **kw)
            postprocessed = tag('b', content=result, **attributes)
            return postprocessed
        return composed
    return wrapWithBold
</code></pre>
<p>Demo:</p>
<pre><code>@makeBoldWrapper(attr1='1', attr2='2')
def helloWorld(text):
    return text

&gt;&gt;&gt; print( helloWorld('Hello, world!') )
&lt;b attr2="2" attr1="1"&gt;Hello, world!&lt;/b&gt;
</code></pre>
<p>The common misconception with decorators is that the parameters <code>(attr1=...)</code> are parameters to the decorator <code>@myDecorator</code>; that is not the case. Rather the result of the function call <code>myDecoratorFactory(attr1=...)</code> is calculated as <code>someresult</code> and becomes an anonymous decorator <code>@someresult</code>. Therefore 'decorators with arguments' are actually decorator factories that need to return a decorator as a value.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to do something like this, you would need a function that returns a decorator function. So in this case (assuming you want to accept arbitrary attributes), you would write</p>
<pre><code>def format_attribs(kwargs):
    """Properly formats HTML attributes from a dictionary"""
    return ' '.join('{}="{}"'.format(key, val) for key,val in kwargs.iteritems())

def makeBold(**kwargs):
    attribs = format_attribs(kwargs)
    def _makeBold(fn):
        def wrapped():
            return '&lt;b ' + attribs + '&gt;' + fn() + '&lt;/b&gt;'
        return wrapped
    return _makeBold
</code></pre>
<p>In order to make this <code>makeBold</code> function a little more general, you want to pass arguments through to <code>fn</code> and keep other information such as function name using <a href="http://docs.python.org/2/library/functools.html#functools.wraps" rel="nofollow"><code>functools.wraps</code></a>:</p>
<pre><code>import functools
def makeBold(**kwargs):
    attribs = format_attribs(kwargs)
    def _makeBold(fn):
        @wraps(fn)
        def wrapped(*args, **kwargs):
            return '&lt;b ' + attribs + '&gt;' + fn(*args, **kwargs) + '&lt;/b&gt;'
        return wrapped
    return _makeBold
</code></pre>
</div>
<span class="comment-copy">Probably wouldn't hurt to shove a <code>functools.wraps</code> there...</span>
<span class="comment-copy">@JonClements Good point.</span>
<span class="comment-copy">Can you explain the layers of decorators including the functools decorator?</span>
<span class="comment-copy">@Stephan The <code>functools</code> decorator has <a href="http://docs.python.org/3.4/library/functools.html#functools.wraps" rel="nofollow noreferrer">documentation</a> that explains it adequately. That said, explaining <i>why</i> the structure of the solution has to look this way might be a good idea.</span>
<span class="comment-copy">A function that returns a function that takes a function and returns a function. I call this functional programming!</span>
<span class="comment-copy">You should probably use <code>functools.wraps</code> in your code samples. It's not necessary but clearly a "best practice".</span>
<span class="comment-copy">@millimoose: I personally have a love-hate relationship with <code>partial</code> since I've had issues with it in the past. I feel it's kind of klunkey and destroys method signatures, though currying is good. Even though <code>@wraps</code> exists to allegedly preserve the name of the function and docstring, if I wanted that, imho it'd be better to use a 'real' decorator framework that gets everything right. Unnecessary decorators also can create a significant amount of overhead, which I once tried to ignore but failed. Once made a framework that rewrites the function and recompiles it into what it 'should be'.</span>
<span class="comment-copy">@millimoose: [continued] But perhaps you're right that I should be using it, for no other reason that perhaps forward-compatibility, perhaps replacing it with another <code>from myfuture import wraps</code> that might be swapped out to do something else. Still not sure if I should use it in examples though because that might increase the required brainpower to figure out what things are doing, since it essentially does nothing (it's been a while since I used it, perhaps I'm ignoring *args or **kw convenience?). Thank you for the suggestion though.</span>
<span class="comment-copy">As of Python 3.3, <code>functools.wraps</code> supports preserving function signatures as visible with <a href="http://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer"><code>inspect.signature()</code></a>. (Unfortunately not <code>getargspec()</code>, for some reason the two mechanisms weren't unified.) So the "'real' decorator framework' you desire is, in fact, <code>wraps()</code>. (I admit I didn't know this from the top of my head, it just occured me that maybe someone on the Python dev team thought of this - turns out they did.)</span>
<span class="comment-copy">@millimoose: Ooh nice, thanks. I might then use it for when performance is not an issue.</span>
