<div class="post-text" itemprop="text">
<p>I have a dictionary, which contains a title and the data. Is there a way to split this data into two lists while keeping the order it was extracted from the dictionary? I have to process the key list and the value list separately, and then I use those lists to build a string.</p>
<p>It's important because I print them out separately, and the output has to match. It doesn't matter if lists are out of order than when they were entered. So long as their positions match in the lists, it's fine.</p>
<p>Here is a very simple example to represent the case:</p>
<pre><code>mydict = {'Hello':1, 'World':2, 'Again':3}
keys = mydict.keys()
values = mydict.values()

print 'The list of keys are: %s' % stringify(keys)
print 'The corresponding values are: %s' % stringify(values)

# Output:
&gt; The list of keys are: Hello, Again, World
&gt; The corresponding values are: 1, 3, 2
</code></pre>
<p>I know I can build an ordered dictionary and then getting the key/value ordering will be guaranteed, but I would also like to handle this case as well (non-ordered dictionary).</p>
</div>
<div class="post-text" itemprop="text">
<p>Even though the order you see the pairs in is arbitrary, the output from <code>keys()</code> and <code>values()</code> <em>will</em> always align, assuming you don't modify the dictionary.  From the <a href="http://docs.python.org/2/library/stdtypes.html#dict.items">docs</a>:</p>
<blockquote>
<p>If items(), keys(), values(), iteritems(), iterkeys(), and
  itervalues() are called with no intervening modifications to the
  dictionary, the lists will directly correspond. This allows the
  creation of (value, key) pairs using zip(): pairs = zip(d.values(),
  d.keys()). The same relationship holds for the iterkeys() and
  itervalues() methods: pairs = zip(d.itervalues(), d.iterkeys())
  provides the same value for pairs. Another way to create the same list
  is pairs = [(v, k) for (k, v) in d.iteritems()].</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>titles = myDict.keys()
allData = [myDict[t] for t in titles]
</code></pre>
<p>This way, <code>titles</code> might be in some unpredictable order, but each element in <code>allData</code> will be the data pertaining to the corresponding element in <code>titles</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Just use <code>items</code>, which gives you, effectively, a zipped-together copy of <code>keys</code> and <code>values</code>:</p>
<pre><code>items = mydict.items()

print 'The list of keys are: %s' % stringify([key for key, value in items])
print 'The list of values are: %s' % stringify([value for key, value in items])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just don't mutate the <code>dict</code> and you'll be fine. Otherwise, there's just a twist on what you've done already of:</p>
<pre><code>keys, values = zip(*mydict.items())
</code></pre>
<p>Which somehow feels "safer" than two operations...</p>
</div>
<span class="comment-copy">I thought that was only guaranteed in Python 3. (In <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">Dictionary view objects</a>.) Nice to know it's true in 2.x as well!</span>
