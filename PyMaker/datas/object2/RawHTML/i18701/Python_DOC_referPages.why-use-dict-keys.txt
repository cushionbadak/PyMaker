<div class="post-text" itemprop="text">
<p>I recently wrote some code that looked something like this:</p>
<pre><code># dct is a dictionary
if "key" in dct.keys():
</code></pre>
<p>However, I later found that I could achieve the same results with:</p>
<pre><code>if "key" in dct:
</code></pre>
<p>This discovery got me thinking and I began to run some tests to see if there could be a scenario when I <em>must</em> use the <code>keys</code> method of a dictionary.  My conclusion however is no, there is not.</p>
<p>If I want the keys in a list, I can do:</p>
<pre><code>keys_list = list(dct)
</code></pre>
<p>If I want to iterate over the keys, I can do:</p>
<pre><code>for key in dct:
    ...
</code></pre>
<p>Lastly, if I want to test if a key is in <code>dct</code>, I can use <code>in</code> as I did above.</p>
<p>Summed up, my question is: am I missing something?  Could there ever be a scenario where I <em>must</em> use the <code>keys</code> method?...or is it simply a leftover method from an earlier installation of Python that should be ignored?</p>
</div>
<div class="post-text" itemprop="text">
<p>On Python 3, use <code>dct.keys()</code> to get a <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer"><em>dictionary view object</em></a>, which lets you do set operations on just the keys:</p>
<pre><code>&gt;&gt;&gt; for sharedkey in dct1.keys() &amp; dct2.keys():  # intersection of two dictionaries
...     print(dct1[sharedkey], dct2[sharedkey])
</code></pre>
<p>In Python 2, you'd use <code>dct.viewkeys()</code> for that.</p>
<p>In Python 2, <code>dct.keys()</code> returns a list, a copy of the keys in the dictionary. This can be passed around an a separate object that can be manipulated in its own right, including removing elements without affecting the dictionary itself; however, you can create the same list with <code>list(dct)</code>, which works in both Python 2 and 3. </p>
<p>You indeed don't want any of these for iteration or membership testing; always use <code>for key in dct</code> and <code>key in dct</code> for those, respectively.</p>
</div>
<div class="post-text" itemprop="text">
<p>Source: <a href="http://www.python.org/dev/peps/pep-0234/">PEP 234</a>, <a href="http://www.python.org/dev/peps/pep-3106/">PEP 3106</a></p>
<p>Python 2's relatively useless <code>dict.keys</code> method exists for historical reasons. Originally, dicts weren't iterable. In fact, there was no such thing as an iterator; iterating over sequences worked by calling <code>__getitem__</code>, the element access method, with increasing integer indices until an <code>IndexError</code> was raised. To iterate over the keys of a dict, you had to call the <code>keys</code> method to get an explicit list of keys and iterate over that.</p>
<p>When iterators went in, dicts became iterable, because it was more convenient, faster, and all around better to say</p>
<pre><code>for key in d:
</code></pre>
<p>than</p>
<pre><code>for key in d.keys()
</code></pre>
<p>This had the side-effect of making <code>d.keys()</code> utterly superfluous; <code>list(d)</code> and <code>iter(d)</code> now did everything <code>d.keys()</code> did in a cleaner, more general way. They couldn't get rid of <code>keys</code>, though, since so much code already called it.</p>
<p>(At this time, dicts also got a <code>__contains__</code> method, so you could say <code>key in d</code> instead of <code>d.has_key(key)</code>. This was shorter and nicely symmetrical with <code>for key in d</code>; the symmetry is also why iterating over a dict gives the keys instead of (key, value) pairs.)</p>
<p>In Python 3, taking inspiration from the Java Collections Framework, the <code>keys</code>, <code>values</code>, and <code>items</code> methods of dicts were changed. Instead of returning lists, they would return views of the original dict. The key and item views would support set-like operations, and all views would be wrappers around the underlying dict, reflecting any changes to the dict. This made <code>keys</code> useful again.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're not using Python 3, <code>list(dct)</code> is equivalent to <code>dct.keys()</code>. Which one you use is a matter of personal preference. I personally think <code>dct.keys()</code> is slightly clearer, but to each their own.</p>
<p>In any case, there isn't a scenario where you "need" to use <code>dct.keys()</code> per se.</p>
<p>In Python 3, <code>dct.keys()</code> returns a "dictionary view object", so if you need to get a hold of an unmaterialized view to the keys (which could be useful for huge dictionaries) outside of a <code>for</code> loop context, you'd need to use <code>dct.keys()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>key in dict 
is much faster than checking
key in dict.keys()</p>
</div>
<span class="comment-copy">If feel <code>dct.keys()</code> is more efficient, as you retrieve the keys as a list <i>once</i> . Now, <code>if key in dct</code> works, however, each time the lookup would involve some extra processing. This is an optimization</span>
<span class="comment-copy">Explicit is better than implicit.</span>
<span class="comment-copy">@karthikr: in both cases, <code>for</code> creates an iterator object (the return value of the <code>iter()</code> function, which yields values in the sequence. Both cases return dictionary keys, with the difference that using <code>dict.keys()</code> requires an attribute lookup and function call <i>first</i>. Thus, it is less efficient.</span>
<span class="comment-copy">@karthikr: add to that that in Python 2 <code>.keys()</code> creates a new list containing all the keys of the dictionary first.</span>
<span class="comment-copy">Also, <code>k in d</code> (where d is a dictionary) has the potential to be much faster than <code>k in l</code> (where l is a list) as the latter does a linear search of the list, while the former does a hash lookup in the dictionary.  The hash lookup is O(1) while the list search is O(len(l)).</span>
<span class="comment-copy">I agree with tom.  dct.keys() is more traditional and idiomatic python (e.g. it is <code>pythonic</code>).  Obtuse syntax tricks like <code>list(dct)</code> are more of a gimmick than an idiomatic usage - many times a noob python user would need to dig a little deeper to determine whether <code>list(dct)</code> returns a list of keys or a list of items.  dct.keys() is unambiguous and clear on initial inspection for anyone reading your code, even to a python noob.  <code>for key in dct</code> is fine as it is idiomatic python usage.</span>
<span class="comment-copy">Technically <code>dct.keys()</code> is a "dictionary view object" in Python 3, not an iterator: <code>type(dct.keys())</code> is <code>&lt;class 'dict_keys'&gt;</code> while <code>type(iter(dct))</code> is <code>&lt;class 'dict_iterator'&gt;</code>.  (See Martijn's and user2357112's answers.)  Hence <code>next(iter(dct))</code> is OK but <code>next(dct.keys())</code> is not.</span>
<span class="comment-copy">Ah, you're right of course, @torek. I'll update my answer. Thanks.</span>
