<div class="post-text" itemprop="text">
<p>I've two data sets in array:</p>
<pre><code>arr1 = [
  ['2011-10-10', 1, 1],
  ['2007-08-09', 5, 3],
  ...
]

arr2 = [
  ['2011-10-10', 3, 4],
  ['2007-09-05', 1, 1],
  ...
]
</code></pre>
<p>I want to combine them into one array like this:</p>
<pre><code>arr3 = [
  ['2011-10-10', 1, 1, 3, 4],
  ...
]
</code></pre>
<p>I mean, just combine those lines with the same <code>date</code> column.</p>
<p>=== EDIT===</p>
<p>Thanks everyone, Just for clarification, I don't need those lines which not appear in both array, just drop them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Organize your data differently (you can <em>easily</em> convert what you already have to two <code>dict</code>s):</p>
<pre><code>d1 = { '2011-10-10': [1, 1],
       '2007-08-09': [5, 3]
     }
d2 = { '2011-10-10': [3, 4],
       '2007-09-05': [1, 1]
     }
</code></pre>
<p>Then:</p>
<pre><code>d3 = { k : d1[k] + d2[k] for k in d1 if k in d2 }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can convert the arrays to a dict, and back again.</p>
<pre><code>d1 = dict((x[0],x[1:]) for x in arr1)
d2 = dict((x[0],x[1:]) for x in arr2)
keys = set(d1).union(d2)
n = []
result = dict((k, d1.get(k, n) + d2.get(k, n)) for k in keys)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It may be worth mentioning set data types. as their methods align to the type of problem.  The set operators allow you to join sets easily and flexibly with full, inner, outer, left, right joins.  As with dictionaries, sets do not retain order, but if you cast a set back into a list, you may then apply an order on the result join.  Alternatively, you could use an o<a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">rdered dictionary</a>.</p>
<pre><code>set1 = set(x[0] for x in arr1)
set2 = set(x[0] for x in arr2)
resultset = (set1 &amp; set2)
</code></pre>
<p>This only gets you the union of dates in the original lists, in order to reconstruct arr3 you would need to append the [1:] data in arr1 and arr2 where the dates are in the result set.  This reconstruction would not be as neat as using the dictionary solutions above, but using sets is worthy of consideration for similar problems.</p>
</div>
<div class="post-text" itemprop="text">
<p>A single dictionary approach:</p>
<pre><code>tmp = {}
# add as many as you like into the outermost array.
for outer in [arr1,arr2]:
    for inner in outer:
        start, rest = inner[0], inner[1:]
        # the list if key exists, else create a new list. Append to the result
        tmp[start] = tmp.get(start,[]) + rest

output = []

for k,v in tmp.iteritems():
   output.append([k] + v)
</code></pre>
<p>That would be the equivalent of a full outer join (returns data from both sides even if one side is null). If you wanted an inner join, you might change it to this:</p>
<pre><code>tmp = {}
keys_with_dupes = []

for outer in [arr1,arr2]:
    for inner in outer:
        start, rest = inner[0], inner[1:]
        original = tmp.get(start,[])
        tmp[start] = original + rest
        if original:
            keys_with_dupes.append(start)

output = []

for k in keys_with_dupes:
   v = tmp[k]
   output.append([k] + v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generator function approach, skipping corresponding elements whose dates don't match:</p>
<pre><code>import itertools
def gen(a1, a2):
    for x,y in itertools.izip(a1, a2):
        if x[0] == y[0]:
            ret = list(x)
            ret.extend(y[1:])
            yield ret
        else:
            continue

&gt;&gt;print list(gen(arr1, arr2))
[['2011-10-10', 1, 1, 3, 4]]
</code></pre>
<p>But yeah, if possible, organize your data differently.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless both are very large lists, I'd use a dictionary:</p>
<pre><code>arr1 = [
  ['2011-10-10', 1, 1],
  ['2007-08-09', 5, 3]
]

arr2 = [
  ['2011-10-10', 3, 4],
  ['2007-09-05', 1, 1]
]

table_1 = dict((tup[0], tup[1:]) for tup in arr1)
table_2 = dict((tup[0], tup[1:]) for tup in arr2)
merged = {}
for key, value in table_1.items():
    other = table_2.get(key)
    if other:
        merged[key] = value + other
</code></pre>
<p>Otherwise, it would be more efficient to sort each, and then do a merge that way. But I imagine for most purposes this would be fast enough.</p>
</div>
<span class="comment-copy">Thought about using a dict?</span>
<span class="comment-copy">btw, those are lists, not arrays.</span>
<span class="comment-copy"><a href="http://code.activestate.com/recipes/577937-inner-join/" rel="nofollow noreferrer">code.activestate.com/recipes/577937-inner-join</a></span>
<span class="comment-copy">Must <code>['2007-09-05', 1, 1]</code> still be in the output (in <code>arr3</code>)?</span>
<span class="comment-copy"><code>pandas</code> is an excellent choice for operations along these lines, if you don't mind a relatively "heavy" dependency: <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas.pydata.org</a></span>
<span class="comment-copy">This will miss those entries with dates that do not occur in both sets.</span>
<span class="comment-copy">@Jan-Philip Gehrcke: "<i>I mean, just combine those lines with the same date column.</i>"</span>
<span class="comment-copy">Jason, yes, he says that he wants those being combined, but he does not say that he wants to miss the other data points. He (or she) needs to clarify.</span>
<span class="comment-copy">Well, either way, it's an <i>easy</i> modification for a full-outer join: <code>{ k : (d1[k] if k in d1 else []) + (d2[k] if k in d2 else []) for k in set(d1).union(d2) }</code>.</span>
<span class="comment-copy">@cwallenpoole: Thanks for correction!</span>
<span class="comment-copy">Did you try it? For me, this is not the expected output: <code>&gt;&gt;&gt; result [['2011-10-10', 3, 4], ['2007-08-09', 5, 3], ['2007-09-05', 1, 1]] </code></span>
<span class="comment-copy">@Jan-PhilipGehrcke Gehrcke It should work now.</span>
<span class="comment-copy"><code>zip</code> (or <code>izip</code>) only makes sense if the two lists directly correspond. If they don't, you might not find any of the matches.</span>
<span class="comment-copy">@Blckknght: Yes, you're right.</span>
