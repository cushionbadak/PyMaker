<div class="post-text" itemprop="text">
<p>In a python unit test (actually Django), what is the correct <code>assert</code> statement that will tell me if my test result contains a string of my choosing?</p>
<pre><code>self.assertContainsTheString(result, {"car" : ["toyota","honda"]})
</code></pre>
<p>I want to make sure that my <code>result</code> contains at least the json object (or string) that I specified as the second argument above</p>
<pre><code>{"car" : ["toyota","honda"]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>self.assertContains(result, "abcd")
</code></pre>
<p>You can modify it to work with json.</p>
<p>Use <code>self.assertContains</code> only for <code>HttpResponse</code> objects. For other objects, use <code>self.assertIn</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To assert if a string is or is not a substring of another, you should use <code>assertIn</code> and <code>assertNotIn</code>:</p>
<pre class="lang-py prettyprint-override"><code># Passes
self.assertIn('bcd', 'abcde')

# AssertionError: 'bcd' unexpectedly found in 'abcde'
self.assertNotIn('bcd', 'abcde')
</code></pre>
<p>These are new since <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertIn">Python 2.7</a> and <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertIn">Python 3.1</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can write assertion about expected part of string in another string with a simple assertTrue + in python keyword :</p>
<pre><code>self.assertTrue("expected_part_of_string" in my_longer_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Build a JSON object using <code>json.dumps()</code>.</p>
<p>Then compare them using <code>assertEqual(result, your_json_dict)</code></p>
<pre><code>import json

expected_dict = {"car":["toyota", "honda"]}
expected_dict_json = json.dumps(expected_dict)

self.assertEqual(result, expected_dict_json)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/36021102/1286705">As mentioned by Ed I</a>, <code>assertIn</code> is probably the simplest answer to finding one string in another. However, the question states:</p>
<blockquote>
<p>I want to make sure that my <code>result</code> contains at least the json object (or string) that I specified as the second argument above,i.e., <code>{"car" : ["toyota","honda"]}</code></p>
</blockquote>
<p>Therefore I would use multiple assertions so that helpful messages are received on failure - tests will have to be understood and maintained in the future, potentially by someone that didn't write them originally. Therefore assuming we're inside a <code>django.test.TestCase</code>:</p>
<pre><code># Check that `car` is a key in `result`
self.assertIn('car', result)
# Compare the `car` to what's expected (assuming that order matters)
self.assertEqual(result['car'], ['toyota', 'honda'])
</code></pre>
<p>Which gives helpful messages as follows:</p>
<pre><code># If 'car' isn't in the result:
AssertionError: 'car' not found in {'context': ..., 'etc':... }
# If 'car' entry doesn't match:
AssertionError: Lists differ: ['toyota', 'honda'] != ['honda', 'volvo']

First differing element 0:
toyota
honda

- ['toyota', 'honda']
+ ['honda', 'volvo']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found myself in a similar problem and I used the attribute <a href="https://docs.djangoproject.com/en/1.8/ref/template-response/#attributes" rel="nofollow">rendered_content</a>, so I wrote</p>
<p><code>assertTrue('string' in response.rendered_content)</code> and similarly</p>
<p><code>assertFalse('string' in response.rendered_content)</code> if I want to test that a string is not rendered</p>
<p>But it also worked the early suggested method,</p>
<p><code>AssertContains(response, 'html string as rendered')</code></p>
<p>So I'd say that the first one is more straightforward.
I hope it will help.</p>
</div>
<span class="comment-copy">would [<a href="https://docs.djangoproject.com/en/1.11/topics/testing/tools/#django.test.Response.json]" rel="nofollow noreferrer">docs.djangoproject.com/en/1.11/topics/testing/tools/â€¦</a> help?</span>
<span class="comment-copy">yes but due to the json structure, it could have some whitespace added which are not problematic in json but problematic if you want to compare with a python string.</span>
<span class="comment-copy">assertContains is not intended to by used for other object than HttpReponse, prefer using assertTrue with "in" python keyword instead (see my answser below).</span>
<span class="comment-copy">This is wrong. Assertconains is for http responses.</span>
<span class="comment-copy">This answer should clarify that it is tailored for HttpResponse only</span>
<span class="comment-copy">Also <code>assertIn</code> provides helpful messages on failure as you've illustrated.</span>
<span class="comment-copy">The issue with this strategy is that is can give poor failure messages of the form "AssertionError: False is not true"</span>
<span class="comment-copy">Why using <code>assertTrue()</code> instead of <a href="http://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual" rel="nofollow noreferrer"><code>assertEqual()</code></a>? At least with <code>assertEqual()</code>, the module will print both the result and the expected values.</span>
<span class="comment-copy">You are right, assertEqual() is better. I can't find the link but I was pretty sure to have read somewhere to use assertTrue instead of assertEqual. Obviously, I was wrong :) I'll fix the example above.</span>
<span class="comment-copy">Note that this will be unreliable when you have more than one key in any dictionary because the <code>dumps()</code> uses arbitrary ordering and we don't know the ordering of keys in <code>result</code>.  You'd be much better off using <code>self.assertEqual(json.loads(result), expected_dict)</code>.</span>
