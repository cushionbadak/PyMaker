<div class="post-text" itemprop="text">
<p>I want to pipe the output of <code>ps -ef</code> to python line by line. </p>
<p>The script I am using is this (first.py) -  </p>
<pre><code>#! /usr/bin/python

import sys

for line in sys.argv:
   print line
</code></pre>
<p>Unfortunately, the "line" is split into words separated by whitespace. So, for example, if I do </p>
<pre><code>echo "days go by and still" | xargs first.py
</code></pre>
<p>the output I get is </p>
<pre><code>./first.py
days
go
by
and
still
</code></pre>
<p>How to write the script such that the output is </p>
<pre><code>./first.py
days go by and still
</code></pre>
<p>?</p>
</div>
<div class="post-text" itemprop="text">
<p>I do not quite understand why you want to use commandline arguments instead of simply reading from <strong>standard input</strong>. Python has a simple idiom for iterating over lines at stdin:</p>
<pre><code>import sys

for line in sys.stdin:
    sys.stdout.write(line)
</code></pre>
<p>My usage example:</p>
<pre><code>$ echo -e "first line\nsecond line" | python python_iterate_stdin.py 
first line
second line
</code></pre>
<p>Your usage example:</p>
<pre><code>$ echo "days go by and still" | python python_iterate_stdin.py
days go by and still
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want is <a href="https://docs.python.org/3/library/os.html#os.popen" rel="nofollow noreferrer"><code>popen</code></a>, which makes it possible to directly read the output of a command like you would read a file:</p>
<pre><code>import os
with os.popen('ps -ef') as pse:
    for line in pse:
        print line
        # presumably parse line now
</code></pre>
<p>Note that, if you want more complex parsing, you'll have to dig into the documentation of <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer"><code>subprocess.Popen</code></a>.</p>
</div>
<span class="comment-copy">Thanks for this answer. I could have marked this as the correct answer, but the other answer was also correct and was posted first.</span>
<span class="comment-copy">Just to clarify: your goal is to read the standard output of one program line by line with your Python program. You are using the command line, you propose use a pipe to transfer the standard output from the first program to your second program (which makes sense). And then, instead of simply reading from standard input in your Python program, you prefer to include a third program to your stack which performs a magic conversion from stdin to commandline arguments and possibly calls your Python program multiple times and fragments the input (do you know how <code>xargs</code> works?)?</span>
<span class="comment-copy">No, I don't know how xargs works.</span>
<span class="comment-copy">The operating system imposes a limit on the number of commandline arguments that a program can process. <code>xargs</code> makes sure that the program defined by the first argument to <code>xargs</code> is never called with more args than defined by this limit. It simply calls the program multiple times if required so that all arguments becomed processed. Hence, for large input multiple <b>independent</b> runs of your Python program might happen. Generally, commandline arguments are not the place to provide tons of input data.</span>
<span class="comment-copy">Ok. That would be catastrophic.</span>
