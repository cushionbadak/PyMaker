<div class="post-text" itemprop="text">
<p>I try to define a generator function <code>mycount()</code> that can be reset with the generator function <code>send(0)</code> as in the example below. Everything works fine, except when I use <code>send(0)</code> on a new generator object that hasn't started yet. In this case it gives a <code>TypeError</code>. Is there any function that checks if the generator has started or do I have to catch the <code>TypeError</code> and create a new generator object with <code>mycount(0)</code> in such case?</p>
<pre><code>def mycount(value):
    while True:
        v = yield value
        if v == None:
            value = value + 1
        else:
            value = v

g = mycount(3)
print(next(g))    # prints 3
print(next(g))    # prints 4
print(g.send(0))  # prints 0
print(next(g))    # prints 1
print(next(g))    # prints 2

g2 = mycount(3)
g2.send(0)
# TypeError: can't send non-None value to a just-started generator
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To avoid sending a non-<code>None</code> value to a just-started generator, you need to call <code>next</code> or <code>send(None)</code> first.  I agree with the others that David Beazley's <a href="http://dabeaz.com/coroutines/coroutine.py" rel="nofollow">coroutine decorator</a> (in python 3.x you need to call to <code>__next__()</code> function instead of <code>next()</code>) is a great option.  Though that particular decorator is simple, I've also successfully used the <a href="https://pypi.python.org/pypi/CoPipes" rel="nofollow">copipes</a> library, which is a nice implementation of many of the utilities from Beazley's presentations, including coroutine.</p>
<p>Regarding whether one can check if a generator is started - in Python 3, you can use <a href="http://docs.python.org/3.2/library/inspect.html#inspect.getgeneratorstate" rel="nofollow">inspect.getgeneratorstate</a>.  This isn't available in Python 2, but the <a href="http://hg.python.org/cpython/file/ddff866d820d/Lib/inspect.py#l1273" rel="nofollow">CPython implementation</a> is pure python and doesn't rely on anything new to Python 3, so you can check yourself in the same way:</p>
<pre><code>if generator.gi_running:
    return GEN_RUNNING
if generator.gi_frame is None:
    return GEN_CLOSED
if generator.gi_frame.f_lasti == -1:
    return GEN_CREATED
return GEN_SUSPENDED
</code></pre>
<p>Specifically, <code>g2</code> is started if <code>inspect.getgeneratorstate(g2) != inspect.GEN_CREATED</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As your error implies the <code>send</code> function must be called with <code>None</code> on a just-started generator
<a href="http://docs.python.org/3/reference/expressions.html?highlight=generator#generator.send" rel="nofollow">(docs-link)</a>. </p>
<p>You <em>could</em> catch the <code>TypeError</code> and roll from there:</p>
<pre><code>    #...
    try:
        g2.send(0)
    except TypeError:
        #Now you know it hasn't started, etc.
        g2.send(None)
</code></pre>
<p>Either way it can't be used to 'reset' the generator, it just has to be remade. </p>
<p>Great overview of generator concepts and syntax <a href="http://www.dabeaz.com/generators/Generators.pdf" rel="nofollow">here</a>, covering chaining of generators and other advanced topics.</p>
</div>
<div class="post-text" itemprop="text">
<p>In particular, you might find a way to use the <code>consumer</code> decorator described on p. I-131 of David Beazley's "Generator Tricks," to which J. Gwyn provided a link:</p>
<pre><code>def consumer(func):
    def start(*args,**kwargs):
        c = func(*args,**kwargs)
        c.next()
        return c
    return start
</code></pre>
<p>I use something similar in my code.</p>
<p>Note that <code>if v is None</code> is preferred over <code>if v == None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a complete implementation Python2 compatible routine, getgeneratorstate(gtor), with test code.</p>
<pre><code>import unittest
import enum

class GtorState(enum.Enum):
    GEN_RUNNING ='GEN_RUNNING'
    GEN_CLOSED ='GEN_CLOSED'
    GEN_CREATED ='GEN_CREATED'
    GEN_SUSPENDED ='GEN_SUSPENDED'

    @staticmethod
    def getgeneratorstate(gtor):
        if gtor.gi_running:
            return GtorState.GEN_RUNNING

        if gtor.gi_frame is None:
            return GtorState.GEN_CLOSED

        if gtor.gi_frame.f_lasti == -1:
            return GtorState.GEN_CREATED

        return GtorState.GEN_SUSPENDED
    #end-def

def coro000():
    """ a coroutine that does little 

    """ 
    print('-&gt; coroutine started')
    x =yield
    print('-&gt; coroutine received ', x)


class Test_Coro(unittest.TestCase):
    def test_coro000(self):

        my_coro000 =coro000()
        self.assertEqual( GtorState.getgeneratorstate(my_coro000), GtorState.GEN_CREATED)

        next(my_coro000)  # prints '-&gt; coroutine started'
        self.assertEqual( GtorState.getgeneratorstate(my_coro000), GtorState.GEN_SUSPENDED)

        try:
            my_coro000.send(42)  # prints '-&gt; coroutine received 42 
            self.assertEqual( GtorState.getgeneratorstate(my_coro000), GtorState.GEN_SUSPENDED)

            self.fail('should have raised StopIteration ')

        except StopIteration:
            self.assertTrue(True, 'On exit a coroutine will throw StopIteration')
            self.assertEqual( GtorState.getgeneratorstate(my_coro000), GtorState.GEN_CLOSED)
</code></pre>
</div>
<span class="comment-copy">This is really a nice solution, but it only works for generator functions that use this decorator. I prefer something that works on every generator. So, I use Rich Franks solution.</span>
<span class="comment-copy">True, this solution is limited.  More significant IMO is that it changes the behavior of the generator.</span>
