<div class="post-text" itemprop="text">
<p>I am using glade as my gui and creating a process to run my gui in. This app will open a socket when 'on' is clicked. When i press 'send', it will send whatever is in an textfield to the socket. The socket receives this data and sends it back. The problem is after i send data to the socket the thread doesn't terminate. Also after i close my gui it calls a sys.exit() but also leaves a process and doesn't terminate. I believe the error is in how i am implementing my processes or all my processing in general. Can anyone shine some light on this? It also relates to my last post as well. Thanks</p>
<p>main.py</p>
<p>// Main thread that create a new process for my gui and displays it</p>
<pre><code>import socket, thread, gtk, Handler, sys, os, multiprocessing 
sys.setrecursionlimit(10000)  


if __name__ == '__main__':

    builder = gtk.Builder()
    #32bit template.glade 64bit template-2.22
    # @todo add switching between architectures
    #
    builder.add_from_file("template/template-2.22.glade")
    builder.connect_signals(Handler.Handler(builder))
    window = builder.get_object("window1")
    window.show_all()
    try:
        p =  multiprocessing.Process(target=gtk.main())
        p.start()

    except:
            print "Error Starting new Thread"
</code></pre>
<p>handler.py</p>
<p>// Handler for gtk glade signals, creates new threads and handles button and stuff</p>
<pre><code>import thread, threading, os, server, client,multiprocessing, time
import sys, gtk


class Handler(object):
    '''
    classdocs
    '''
    myobject = ''

    def __init__(self,object1):
        #Getting glade builder
        self.myobject = object1
        '''
        Constructor
        '''

    def clickme(self,value):

        myserver = server.Server()
        try:
            p =  multiprocessing.Process(target=myserver.run)
            p.start()

        except:
            pass

    def sendmessage(self,value):
        text = self.myobject.get_object('entry1').get_text()
        print text
        msg = client.MyClass()
        p =  multiprocessing.Process(target=msg.run,args=([text]))
        p.start()
</code></pre>
<p>server.py</p>
<p>// Opens a socket and listens for incoming data and sends it back</p>
<pre><code>import socket,multiprocessing, gtk, sys

class Server:
    '''
    classdocs
    '''
    def __init__(self):
        '''
        Constructor
        '''

    def run(self):

        try:
            while 1:
                HOST = 'localhost'                 # Symbolic name meaning the local host
                PORT = 50006              # Arbitrary non-privileged port
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((HOST, PORT))
                s.listen(5)
                conn, addr = s.accept()
                print 'Connected by', addr
                while True:
                    data = conn.recv(1024)
                    if not data:
                        conn.close()
                        sys.exit()
                        break
                    elif data != '':
                        conn.sendall(data)
                        break

            print "Closing"    
            #conn.close()
        finally:
            print "End"
            pass
</code></pre>
<p>client.py</p>
<p>// Sends whatever is inside text area to socket</p>
<pre><code>import time

class MyClass:
    '''
    classdocs
    '''

    def __init__(self):
        '''
        Constructor
        '''
    def run(self,text):
        try:
            import socket
            HOST = 'localhost'    # The localhost
            PORT = 50006             # The same port as used by the server
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((HOST, PORT))
            s.send(text)
            data = s.recv(1024)

            while 1:
                if data != '':
                    print 'Received', repr(data)
                    break
        finally:
            pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is just wrong:</p>
<pre><code>p =  multiprocessing.Process(target=gtk.main())
p.start()
</code></pre>
<p>First, you can't start the gtk main loop in a subprocess, even if you did it rigth. Fortunately the process never really tries to start <code>main</code> as you <strong>call</strong> <code>gtk.main()</code>, which will block until the main loop exits and then return <code>None</code>. So what you're actually doing is:</p>
<pre><code>gtk.main()
p =  multiprocessing.Process(target=None)
p.start()
</code></pre>
<p>Througout the rest of your code you keep creating new processes and then forgetting about them. If you would keep a reference to them, you could at least try to send the <code>TERM</code> signal to them to shut them down (using <code>Process.terminate</code>, or set the <a href="http://docs.python.org/3/library/multiprocessing#multiprocessing.Process.daemon" rel="nofollow"><code>daemon</code></a> flag). If you want to shut down the subprocess cleanly, you either need to <a href="http://docs.python.org/3/library/signal" rel="nofollow">handle that signal</a> in the subprocess, or use other IPC mechanisms to get it to shut down cleanly (like <code>mutliprocessing.Event</code>, ...).</p>
<p>Then there is this:</p>
<pre><code>            while True:
                data = conn.recv(1024)
                if not data:
                    conn.close()
                    sys.exit()
                    break
                elif data != '':
                    conn.sendall(data)
                    break
</code></pre>
<p>This while loop will never loop (unless <code>recv</code> magically returns something else then a string). The first execution path ends with <code>sys.exit()</code> (taking the whole server down - the break is unreachable), the second ends with <code>break</code>, so the loop is useless.</p>
<p>A few lines below you have the exact opposite:</p>
<pre><code>        data = s.recv(1024)
        while 1:
            if data != '':
                print 'Received', repr(data)
                break
</code></pre>
<p>Unless <code>data</code> was <code>''</code> in the first line, this will be an endless loop, as <code>data</code>'s value won't change anymore.</p>
<p>Generally you don't really need multiprocessing for most of this. Starting a server in a different process may be ok if if has to do a lot of work, but spawing a subprocess just to send some data is overkill. Sending and receiving using sockets are IO bound, using threading here would be more reasonable.</p>
<p>You have two classes (<code>Server</code> and <code>Handler</code>) which have only two methods, one of which is <code>__init__</code>, and the other one is only used as target for a subprocess:</p>
<pre><code>    myserver = server.Server()
    try:
        p =  multiprocessing.Process(target=myserver.run)
</code></pre>
<p>and:</p>
<pre><code>    msg = client.MyClass()
    p =  multiprocessing.Process(target=msg.run,args=([text]))
</code></pre>
<p>That's a sign that these shouldn't be classes but functions.</p>
</div>
