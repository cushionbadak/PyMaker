<div class="post-text" itemprop="text">
<p>Quick question to mainly satisfy my curiosity on the topic. </p>
<p>I am writing some large python programs with an SQlite database backend and will be dealing with a large number of records in the future, so I need to optimize as much as I can. </p>
<p>For a few functions, I am searching through keys in a dictionary. I have been using the "in" keyword for prototyping and was planning on going back and optimizing those searches later as I know the "in" keyword is generally O(n) (as this just translates to python iterating over an entire list and comparing each element). But, as a python dict is basically just a hash map, is the python interpreter smart enough to interpret:</p>
<pre><code>if(key in dict.keys()):
    ...code...
</code></pre>
<p>to:</p>
<pre><code>if(dict[key] != None):
    ...code...
</code></pre>
<p>It is basically the same operation but the top would be O(n) and the bottom would be O(1).  </p>
<p>It's easy for me to use the bottom version in my code, but then I was just curious and thought I would ask. </p>
</div>
<div class="post-text" itemprop="text">
<p>First, <code>key in d.keys()</code> is guaranteed to give you the same value as <code>key in d</code> for any dict <code>d</code>.</p>
<p>And the <code>in</code> operation on a <code>dict</code>, or the <code>dict_keys</code> object you get back from calling <code>keys()</code> on it (in 3.x), is <em>not</em> O(N), it's O(1).</p>
<p>There's no real "optimization" going on; it's just that using the hash is the obvious way to implement <code>__contains__</code> on a hash table, just as it's the obvious way to implement <code>__getitem__</code>.</p>
<hr/>
<p>You may ask where this is guaranteed.</p>
<p>Well, it's not. <a href="http://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="noreferrer">Mapping Types</a> defines <code>dict</code> as, basically, a hash table implementation of <a href="http://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="noreferrer"><code>collections.abc.Mapping</code></a>. There's nothing stopping someone from creating a hash table implementation of a Mapping, but still providing O(N) searches. But it would be extra work to make such a bad implementation, so why would they?</p>
<p>If you really need to prove it to yourself, you can test every implementation you care about (with a profiler, or by using some type with a custom <code>__hash__</code> and <code>__eq__</code> that logs calls, or…), or read the source.</p>
<hr/>
<p>In 2.x, you do not want to call <code>keys</code>, because that generates a <code>list</code> of the keys, instead of a <code>KeysView</code>. You could use <code>iterkeys</code>, but that may generate an iterator or something else that's not O(1). So, just use the dict itself as a sequence.</p>
<p>Even in 3.x, you don't want to call <code>keys</code>, because there's no need to. Iterating a <code>dict</code>, checking its <code>__contains__</code>, and in general treating it like a sequence is <em>always</em> equivalent to doing the same thing to its keys, so why bother? (And of course building the trivial <code>KeyView</code>, and accessing through it, are going to add a few nanoseconds to your running time and a few keystrokes to your program.)</p>
<p>(It's not quite clear that using sequence operations is equivalent for <code>d.keys()</code>/<code>d.iterkeys()</code> and <code>d</code> in 2.x. Other than performance issues, they <em>are</em> equivalent in every CPython, Jython, IronPython, and PyPy implementation, but it doesn't seem to be stated anywhere the way it is in 3.x. And it doesn't matter; just use <code>key in d</code>.)</p>
<hr/>
<p>While we're at it, note that this:</p>
<pre><code>if(dict[key] != None):
</code></pre>
<p>… is not going to work. If the <code>key</code> is not in the <code>dict</code>, this will raise <code>KeyError</code>, not return <code>None</code>.</p>
<p>Also, you should never check <code>None</code> with <code>==</code> or <code>!=</code>; always use <code>is</code>.</p>
<p>You can do this with a <code>try</code>—or, more simply, do <code>if dict.get(key, None) is not None</code>. But again, there's no reason to do so. Also, that won't handle cases where <code>None</code> is a perfectly valid item. If that's the case, you need to do something like <code>sentinel = object(); if dict.get(key, sentinel) is not sentinel:</code>.</p>
<hr/>
<p>So, the right thing to write is:</p>
<pre><code>if key in d:
</code></pre>
<hr/>
<p>More generally, this is not true:</p>
<blockquote>
<p>I know the "in" keyword is generally O(n) (as this just translates to python iterating over an entire list and comparing each element</p>
</blockquote>
<p>The <code>in</code> operator, like most other operators, is just a call to a <code>__contains__</code> method (or the equivalent for a C/Java/.NET/RPython builtin). <code>list</code> implements it by iterating the list and comparing each element; <code>dict</code> implements it by hashing the value and looking up the hash; <code>blist.blist</code> implements it by walking a B+Tree; etc. So, it could be O(n), O(1), O(log n), or something completely different.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2 <code>dict.keys()</code> creates the whole list of keys first that's why it is an <code>O(N)</code> operation, while <code>key in dict</code> is an <code>O(1)</code> operation.</p>
<p><code>if(dict[key] != None)</code> will raise <code>KeyError</code> if key is not found in the dict, so it is not equivalent to the first code.</p>
<p>Python 2 results:</p>
<pre><code>&gt;&gt;&gt; dic = dict.fromkeys(range(10**5))
&gt;&gt;&gt; %timeit 10000 in dic
1000000 loops, best of 3: 170 ns per loop
&gt;&gt;&gt; %timeit 10000 in dic.keys()
100 loops, best of 3: 4.98 ms per loop
&gt;&gt;&gt; %timeit 10000 in dic.iterkeys()
1000 loops, best of 3: 402 us per loop
&gt;&gt;&gt; %timeit 10000 in dic.viewkeys()
1000000 loops, best of 3: 457 ns per loop
</code></pre>
<p>In Python 3 <code>dict.keys()</code> returns a view object which is quite faster than Python 2's <code>keys()</code> but still slower simple normal <code>key in dict</code>:</p>
<p>Python 3 results:</p>
<pre><code>&gt;&gt;&gt; dic = dict.fromkeys(range(10**5))
&gt;&gt;&gt; %timeit 10000 in dic
1000000 loops, best of 3: 295 ns per loop
&gt;&gt;&gt; %timeit 10000 in dic.keys()
1000000 loops, best of 3: 475 ns per loop
</code></pre>
<p>Use just:</p>
<pre><code>if key in dict:
   #code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The proper way to do this would be</p>
<pre><code>if key in dict:
    do stuff
</code></pre>
<p>the <strong>in</strong> operator is O(1) for dictionaries and sets in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>The in operator for dict has average case time-complexity of O(1). For detailed information about time complexity of other dict() methods, visit this <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">link</a>.</p>
</div>
<span class="comment-copy">I say do what is easiest, and profile later.</span>
<span class="comment-copy">Actually, the code on bottom wouldn't work. You have to do something akin to <code>try: dict[key]; except KeyError: pass; else: #...code...</code>.</span>
<span class="comment-copy">@TravisGD This is a good point, I forgot about that</span>
<span class="comment-copy">As a side note: Don't wrap <code>if</code> conditions in unnecessary parentheses. People who read and write a lot of Python expect parentheses to mean something—a tuple, a genexp, or overriding operator precedence—and they'll have to stop and read each line twice to make sure your parens don't actually mean anything.</span>
<span class="comment-copy">Another side note: Don't name a dictionary <code>dict</code>—that hides the type and constructor of the same name, which you may well want to use later on.</span>
<span class="comment-copy">That's what I was thinking, is this documented anywhere? I wasn't sure though just because I though dict.keys() may just be returning a list. Making the "in" O(n)</span>
<span class="comment-copy">@tknickman: In general, Python doesn't document performance characteristics of its functions. (Partly this is because it's always possible for you to do something ridiculous like define a <code>hash</code> function that depends on the number of elements.) So, <a href="http://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">this</a> is all you get. But the fact that it documents that dicts are hash tables implies pretty strongly that <code>key in d</code>, <code>d[key]</code>, and <code>d.get(key)</code> are all going to be O(1).</span>
<span class="comment-copy">Awesome, thanks!</span>
<span class="comment-copy"><i>Average</i> case is O(1), worst case O(n).</span>
<span class="comment-copy">@AshwiniChaudhary: They are guaranteed to be semantically equivalent. In Python 3.x, they're also equivalent as far as performance. In Python 2.x, <code>keys</code> will obviously be slower. I've edited the answer to give more details. But the real point is, there is never any reason to use <code>key in d.keys()</code>, so you don't have to remember the details.</span>
<span class="comment-copy">This is 2.x-specific. (Also, note that in CPython 2.7.3 or PyPy 2.0b1, <code>iterkeys</code> may be much faster than <code>keys</code>—Python 2.x allows <code>iterkeys</code> to be something smarter that just <code>iter(d.keys())</code>, and they actually do take some advantage. But it's still nowhere near as fast as just using <code>d</code> directly. On my computer, it's 94ns vs. 338us vs. 2.03ms.)</span>
<span class="comment-copy">Should modify that final sentence to limit that to dictionaries (and sets) because <code>x in a_list</code> is O(n).</span>
<span class="comment-copy">Entirely correct, thanks.  My mistake.</span>
<span class="comment-copy">While this link may answer the question, it is better to include the essential parts of the answer here and provide the link for reference. Link-only answers can become invalid if the linked page changes.</span>
