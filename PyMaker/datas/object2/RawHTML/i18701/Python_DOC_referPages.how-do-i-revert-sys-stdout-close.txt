<div class="post-text" itemprop="text">
<p>In the interactive console:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.stdout
&lt;open file '&lt;stdout&gt;', mode 'w' at 0xb7810078&gt;
&gt;&gt;&gt; sys.stdout.close()
&gt;&gt;&gt; sys.stdout # confirming that it's closed
(...) ValueError: I/O operation on closed file
</code></pre>
<p>Attempting to revert:</p>
<pre><code>&gt;&gt;&gt; sys.stdout.open()
(...) AttributeError: 'file' object has no attribute 'open'
&gt;&gt;&gt; sys.stdout.write('foo')
(...) ValueError: I/O operation on closed file
</code></pre>
<p>I agree that it's a frivolous question, but I'm curious how sys.stdout.close() can be reverted in Python (without restarting the interactive console, of course) and why sys.stdout.open() does not make sense.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, so I hope you are on a unix system...</p>
<p>Basically sys.stdout is just a variable containing any writable object.</p>
<p>So we can do magic like </p>
<pre><code>sys.stdout = open("file", "w")
</code></pre>
<p>and now we can write to that file as if it was stdout.</p>
<p>Knowing unix is just one big box of files. Unix is kind enough to give us <code>/dev/stdout</code></p>
<p>So to re-open stdout its simple</p>
<pre><code>sys.stdout = open("/dev/stdout", "w")
</code></pre>
<p>Job done, you now have a new stdout opened up.</p>
<p>Edit</p>
<pre><code>&gt;&gt;&gt; os.fstat(1)
posix.stat_result(st_mode=8592, st_ino=7, st_dev=11L, st_nlink=1, st_uid=1000, st_gid=5, st_size=0, st_atime=1374230552, st_mtime=1374230552, st_ctime=1374230434)
&gt;&gt;&gt; sys.stdout.close()
&gt;&gt;&gt; sys.stdout = open("/dev/stdout", "w")
&gt;&gt;&gt; sys.stdout.fileno()
3
&gt;&gt;&gt; os.fstat(3)
posix.stat_result(st_mode=8592, st_ino=7, st_dev=11L, st_nlink=1, st_uid=1000, st_gid=5, st_size=0, st_atime=1374230576, st_mtime=1374230576, st_ctime=1374230434)
&gt;&gt;&gt; os.fstat(1)
posix.stat_result(st_mode=8592, st_ino=7, st_dev=11L, st_nlink=1, st_uid=1000, st_gid=5, st_size=0, st_atime=1374230576, st_mtime=1374230576, st_ctime=1374230434)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In your case, you can get the <code>sys.stdout</code> back by <code>sys.stdout = os.fdopen(1, 'w', 0)</code>.</p>
<p>But, in truth, you do not close the <code>sys.stdout</code> really. If you want to close it completely, you have to use <code>os.close(sys.stdout.fileno())</code>. You can read <a href="http://docs.python.org/3/faq/library.html#why-doesn-t-closing-sys-stdout-stdin-stderr-really-close-it">Why doesnâ€™t closing sys.stdout (stdin, stderr) really close it?</a> for why. In this case, I don't know how to reopen it. The above method or even <code>open('/dev/stdout', 'w')</code> have failed on my Linux.</p>
</div>
<div class="post-text" itemprop="text">
<p>sys.stdout.open() doesn't make any sense because open takes a filename and mode as parameters and a closed stream object doesn't have an open method.</p>
<p>The main answer is <strong><em>Don't Close It In The First Place!</em></strong></p>
</div>
<div class="post-text" itemprop="text">
<p>The reason why sys.stdout.open() does not make sense whereas sys.stdout.close() does (despite the apparent symmetry), is that .open() and .close() apply to the stream/file, to which sys.stdout is just a pointer (and sys.stdout doesn't point to any stream/file once the latter is closed).</p>
</div>
<span class="comment-copy">The great thing is that your solution is not Unix-specific.</span>
