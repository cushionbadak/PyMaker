<div class="post-text" itemprop="text">
<p>I need to check if all the letters that form a given word are contained inside a given string. I´ve tried something but isn´t working:</p>
<pre><code>def check(texto, control):
    for letra in control:
        if texto.find(letra) == control.find(letra):
            return control + " is not here"
        else:
            return control + " is here!"
</code></pre>
<blockquote>
<p>print check('jshdgfyrgj', 'Correo')</p>
</blockquote>
<p>Should return "Correo is not here"</p>
<blockquote>
<p>print check('cfgotyrrtepo', 'Correo')</p>
</blockquote>
<p>Should return "Correo is here!"</p>
<p>It currently returns correo is here in all cases. Whats wrong with my code?
Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>A couple issues - one, you expect the function to ignore case differences, but don't tell it to do so. - 'c' is not 'C'.</p>
<p>For checking to see whether a letter is in a string it's often better to use <code>letter in text_string</code> rather than the <code>str.find()</code> method. Be sure you understand what find returns - check out the <a href="http://docs.python.org/3/library/stdtypes.html#str.find" rel="nofollow">docs</a>.</p>
<p>In the example below I use <code>letter in set(text_string)</code> - this only checks the letters of <code>text_string</code> once if there are duplicates. For small strings this won't make much of a difference in performance.</p>
<p>You can use the <code>all</code> function to do a bunch of boolean checks.</p>
<pre><code>def check(text, control):
    # Set both strings to lower case, since we're ignoring case
    text = text.lower()
    control = control.lower()
    # Check that each character in control is in text
    return all((c in text for c in set(control)))

&gt;&gt;&gt; check('jshdgfyrgj', 'Correo')
2: False
&gt;&gt;&gt; check('cfgotyrrtepo', 'Correo')
3: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not something like: </p>
<pre><code>def check(texto, control):
    texto = [letter for letter in texto]
    while texto:
        for letra in control:
            if letra in texto:
                texto.remove(letra)
            else:
                return False
    return True
</code></pre>
<p>this ensures repeated letters are repeated in texto also.</p>
<p>e.g.</p>
<pre><code>&gt;&gt;&gt; check('abc','bac')
True
&gt;&gt;&gt; check('abc','bacc')
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If order doesn't matter:</p>
<pre><code>...
return all([letter in texto for letter in control])
</code></pre>
<p>If order is important: </p>
<pre><code>...
texto_modified = "".join([letter for letter in texto if letter in control])
return texto_modified == control
</code></pre>
</div>
<span class="comment-copy">You say it's better to use <code>letter in text_string</code> and then use the equivalent <code>letter in set(text_string)</code>. Need to explain why...</span>
<span class="comment-copy">Good point, added a note.</span>
<span class="comment-copy">you can just <code>return all((c in text for c in set(control)))</code></span>
<span class="comment-copy">Actually, another reason one might want to use <code>letter in set(text_string)</code> instead of <code>letter in text_string</code> is because the time complexity of searching a hash table is O(1) vs O(n) for a linear search. However to do this also entails the overhead of constructing the <code>set</code> object, so in this case it could actually slow things down...</span>
<span class="comment-copy">inner list is not required in <code>all()</code>.</span>
