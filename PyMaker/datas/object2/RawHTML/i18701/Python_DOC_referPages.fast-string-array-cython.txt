<div class="post-text" itemprop="text">
<p>Having following hypothetical code:</p>
<pre><code>cdef extern from "string.h":
    int strcmp(char* str1, char* str2)

def foo(list_str1, list_str2):
    cdef unsigned int i, j
    c_arr1 = ??
    c_arr2 = ??
    for i in xrange(len(list_str1)):
        for j in xrange(len(list_str2)):
            if not strcmp(c_arr1[i], c_arr2[j]):
                do some funny stuff
</code></pre>
<p>is there some way how to convert the lists to c arrays?</p>
<p>I have read and tried <a href="https://stackoverflow.com/questions/9665177/cython-converting-list-of-strings-to-char">Cython - converting list of strings to char **</a> but that only throws errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try following code. <code>to_cstring_array</code> function in the following code is what you want.</p>
<pre><code>from libc.stdlib cimport malloc, free
from libc.string cimport strcmp
from cpython.string cimport PyString_AsString

cdef char ** to_cstring_array(list_str):
    cdef char **ret = &lt;char **&gt;malloc(len(list_str) * sizeof(char *))
    for i in xrange(len(list_str)):
        ret[i] = PyString_AsString(list_str[i])
    return ret

def foo(list_str1, list_str2):
    cdef unsigned int i, j
    cdef char **c_arr1 = to_cstring_array(list_str1)
    cdef char **c_arr2 = to_cstring_array(list_str2)

    for i in xrange(len(list_str1)):
        for j in xrange(len(list_str2)):
            if i != j and strcmp(c_arr1[i], c_arr2[j]) == 0:
                print i, j, list_str1[i]
    free(c_arr1)
    free(c_arr2)

foo(['hello', 'python', 'world'], ['python', 'rules'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're on Python 3, here's an update to @falsetru's answer (untested on Python 2).</p>
<pre><code>cdef extern from "Python.h":
    char* PyUnicode_AsUTF8(object unicode)

from libc.stdlib cimport malloc, free
from libc.string cimport strcmp

cdef char ** to_cstring_array(list_str):
    cdef char **ret = &lt;char **&gt;malloc(len(list_str) * sizeof(char *))
    for i in xrange(len(list_str)):
        ret[i] = PyUnicode_AsUTF8(list_str[i])
    return ret

def foo(list_str1, list_str2):
    cdef unsigned int i, j
    cdef char **c_arr1 = to_cstring_array(list_str1)
    cdef char **c_arr2 = to_cstring_array(list_str2)

    for i in range(len(list_str1)):
        for j in range(len(list_str2)):
            if i != j and strcmp(c_arr1[i], c_arr2[j]) == 0:
                print(i, j, list_str1[i])
    free(c_arr1)
    free(c_arr2)

foo(['hello', 'python', 'world'], ['python', 'rules'])
</code></pre>
<hr/>
<p><strong>Warning:</strong> The pointer returned by <code>PyUnicode_AsUTF8</code> is cached in the parent unicode-object. Which has two consequences:</p>
<ol>
<li>this pointer is only valid as long as the parent unicode-object is alive. Accessing it afterwards leads to undefined behavior (e.g. possible segmentation fault).</li>
<li>The caller of the <code>PyUnicode_AsUTF8</code> <strong>isn't</strong> responsible for the freeing the memory.</li>
</ol>
</div>
<span class="comment-copy">Well that is an awesome answer!! many thanks for that, but the thing is now, that the line ret[i] = PyString_AsString(list_str[i]) raises Obtaining char* from temporary Python value during compilation</span>
<span class="comment-copy">Ok, my bad! I have forgotten the from cpython.string cimport PyString_AsString. Now it works just fine! Thank you!!</span>
<span class="comment-copy"><code>PyString_AsString</code> is python2 only, so this solution will not work for python3</span>
<span class="comment-copy">@ead, Beside <code>PyString_AsString</code>, there are <code>xrange</code> calls in OP's code. So I thought it's okay to assume it's python 2 code. Any suggestion to make this solution work both in python 2/3 is welcome.</span>
<span class="comment-copy">It's worth making clear that the memory for the stored <code>char*</code> is owned by the Python strings so is only valid while the Python strings are still alive. It's fine in this question, but I came here from a linked question that had copied the code and run into problems</span>
<span class="comment-copy">Maybe it is worth mentioning, that since Python 3.7 it is <code>const char * PyUnicode_AsUTF8(...)</code> <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUTF8" rel="nofollow noreferrer">docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUTF8</a></span>
<span class="comment-copy">Thank you, please edit the answer if you feel it needs correction!</span>
