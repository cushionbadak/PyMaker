<div class="post-text" itemprop="text">
<p>I have basically a similar question, though I do not feel it has been answered properly:</p>
<p><a href="https://stackoverflow.com/questions/14804735/tkinter-how-can-i-dynamically-create-a-widget-that-can-then-be-destroyed-or-rem">Tkinter: How can I dynamically create a widget that can then be destroyed or removed?</a></p>
<p>The <a href="https://stackoverflow.com/a/14804796/1575066">accepted answer</a> is:</p>
<blockquote>
<p>You'll want to store the dynamically-created widgets in a list. Have
  something like</p>
<pre><code>     dynamic_buttons = []

     def onDoubleClick(event):
     ...
     button = Button(...)
     dynamic_buttons.append(button)
     button.pack() 

You can then access the buttons for removal with, say,

     dynamic_buttons[0].destroy()
</code></pre>
</blockquote>
<p>You can see that the reference they speak of is not variable, here the number 0 is used. But when dynamically creating widgets, how do you connect these references to the buttons?</p>
<p>Say that you create a Toplevel widget (displays a file's content), and want to have a button to close the widget. The dynamic creation will allow multiple files to be open. 
The problem is that even with this list, how will the button "know" to which widget it belongs, as there is no hard reference (great that you have a list of the items, but toplevel 5 + button 5 have no clue they are 5th in their lists). There will always be just one "active" version of the button and the toplevel, and this one can be deleted.</p>
<pre><code>aanstuur_files = []
aanstuur_frames = []
aanstuur_buttons = []

def editAanstuur():
    openfiles = filedialog.askopenfilenames()
    if not openfiles:
        return 
    for file in openfiles:
        newtop = Toplevel(nGui, height=100, width=100)
        labelTitle = Label(newtop, text=file).pack()
        newButton = Button(newtop, text="save &amp; close", command= ...).pack()
        aanstuur_files.append(file)
        aanstuur_buttons.append(newButton)
        aanstuur_frames.append(newtop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How does the button know which window it belongs to? You tell it:</p>
<pre><code>newButton = Button(newtop, command=lambda top=newtop: top.destroy())
</code></pre>
<p>By the way, you're assigning <code>None</code> to <code>newButton</code> in your code. This is because you are doing <code>newbutton = Button(...).pack()</code>, which means <code>newbutton</code> gets the value of <code>pack()</code> which is always None.</p>
<p>If you are going to save a reference to a widget, you must create the widget in a separate step from when you place it in a window.</p>
<p>An even better solution is to take advantage of classes and objects. Create your own subclass of Toplevel, and the instance will keep track of all of the subwidgets for you. For example:</p>
<pre><code>class MyToplevel(Toplevel):
    def __init__(self, parent, filename, *args, **kwargs):
        Toplevel.__init__(self, parent, *args, **kwargs)
        self.filename = filename
        self.savebutton = Button(..., command=self.save)
        ...
    def save(self):
        print "saving...", self.filename
        ...
        self.destroy()
...
openfiles = filedialog.askopenfilenames()
if not openfiles:
    return 
for file in openfiles:
    newtop = MyToplevel(nGui, file, height=100, width=100)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>APass in a index to your command function using the <a href="http://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code> function</a>:</p>
<pre><code>def editAanstuur():
    openfiles = filedialog.askopenfilenames()
    if not openfiles:
        return 
    for i, file in enumerate(openfiles):
        newtop = Toplevel(nGui, height=100, width=100)
        labelTitle = Label(newtop, text=file).pack()
        newButton = Button(newtop, text="Save", command=lambda index=i: print(index)).pack()
        aanstuur_files.append(file)
        aanstuur_buttons.append(newButton)
        aanstuur_frames.append(newtop)
</code></pre>
<p>Make sure that you pass the index as a keyword parameter to bind the value when defining the lambda (a closure would use the last value of <code>i</code>).</p>
<p><code>enumerate()</code> takes a second argument, the index to start at, which defaults at 0.</p>
</div>
<span class="comment-copy">Ah yes, I am aware of that <code>.pack()</code> issue. The thing is that I want to save the file which is a child of this top widget before closing, how to access that Text field's content and write it to a file ?</span>
<span class="comment-copy">Got it, giving it extra arguments. Thank you very much.</span>
<span class="comment-copy">@Dualinity: an even better solution than to keep piling on arguments is to create your own class. I've updated my answer to give an indication of how you can do that.</span>
<span class="comment-copy">When the function <code>editAanstuur()</code> will be used again, how will it be able to continue where it left off? (after multiple files have been opened, even more will be opened) Or is the index sent this way a hard reference?</span>
<span class="comment-copy">@Dualinity: You can pass a start index to <code>enumerate()</code>. It'll start at 0 by default.</span>
<span class="comment-copy">Am I missing something with how to use <code>command</code>? Would <code>lambda: saveButton(i)</code> call the function saveButton with the correct, hardlinked,<code>i</code>? Here it shows something in between <code>lambda</code> and <code>:</code></span>
<span class="comment-copy">You are missing something; that is a closure, and <code>i</code> will not be looked up until the button is clicked. That will <i>not</i> be the right index.</span>
<span class="comment-copy">The closure making sure it will be a hard reference?</span>
