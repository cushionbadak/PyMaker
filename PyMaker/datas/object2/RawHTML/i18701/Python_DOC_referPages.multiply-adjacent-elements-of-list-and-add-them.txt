<div class="post-text" itemprop="text">
<p>I want to successively multiply adjacent element of the list and add the multiplication:</p>
<ul>
<li><code>([1,2,3,4])</code> should perform <code>(1*2+2*3+3*4)</code>, and </li>
<li><code>[1,2,3]</code> I want to get <code>8</code> because <code>(1*2)+(2*3)</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension:</p>
<pre><code>&gt;&gt;&gt; mylist = [1,2,3,4]
&gt;&gt;&gt; sum(mylist[i] * mylist[i + 1] for i in range(len(mylist) - 1))
20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>pairwise</code> itertools recipe</a>:</p>
<pre><code>&gt;&gt;&gt; sum(a * b for (a, b) in pairwise([1, 2, 3, 4]))
20
&gt;&gt;&gt; sum(a * b for (a, b) in pairwise([1, 2, 3]))
8
</code></pre>
<blockquote>
<p>What I need to change if want <code>function([1,2,3,4])</code> perform <code>(1*2*3*4)</code>?</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; reduce(mul, [1, 2, 3, 4])
24
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre class="lang-python prettyprint-override"><code>x=[1,2,3,4]
print sum(a*b for a,b in zip(x, x[1:]))
#prints 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Function using <a href="http://docs.python.org/2/library/functions.html#sum" rel="nofollow"><code>sum</code></a>, <a href="http://docs.python.org/2/library/functions.html#map" rel="nofollow"><code>map</code></a>, <a href="http://docs.python.org/2/reference/expressions.html#lambda" rel="nofollow"><code>lambda</code></a> and <a href="http://docs.python.org/2/library/functions.html#zip" rel="nofollow"><code>zip</code></a></p>
<pre><code>def my_math(lst):
    return sum(map(lambda x: x[0]*x[1], zip(lst,  lst[1:])))

&gt;&gt;&gt; my_math([1,2,3])
8
&gt;&gt;&gt; my_math([1,2,3,4])
20
&gt;&gt;&gt; my_math([1,2,3,4,5])
40
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [88]: mylist = [1,2,3,4]

In [89]: sum(itertools.imap(lambda t: operator.mul(*t), itertools.izip(mylist, itertools.islice(mylist, 1, len(mylist)))))
Out[89]: 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A generator expression without any list slices/copies</p>
<pre><code>&gt;&gt;&gt; mylist = [1,2,3,4]
&gt;&gt;&gt; sum(mylist[i-1] * j for i, j in enumerate(mylist) if i)
20
</code></pre>
</div>
<span class="comment-copy">Something is not clear in what you are asking, either your examples are wrong - or you are not <i>multiplying</i>. 1 times 2 times 3 is 6, not 8.</span>
<span class="comment-copy">Essentially the same as <a href="http://stackoverflow.com/q/14916957/1907098">stackoverflow.com/q/14916957/1907098</a>, except you <code>sum</code> the resulting list.</span>
<span class="comment-copy">Sounds like you need to <code>fold</code> or <code>zip</code> ...</span>
<span class="comment-copy">What I need to chenge if want function([1,2,3,4]) perform (1*2*3*4)?</span>
<span class="comment-copy">@user2469891 See my edit.</span>
<span class="comment-copy">+1. You can shed the <code>[:-1]</code>, <code>print sum(a*b for a,b in zip(x, x[1:]))</code> produces the same result</span>
<span class="comment-copy">Updated. Thanks.</span>
<span class="comment-copy">That's what I thought "multiply elements" meant too, but look at the examples OP gives in the question body.</span>
<span class="comment-copy">@InbarRose Why does the map(*zip) version not work?</span>
<span class="comment-copy">@ersran9 You mean the <code>map(mul, ...)</code> one? <code>mul</code> takes two arguments, and—sadly—does not support passing a single iterable.</span>
<span class="comment-copy">@poke Well, what I wanted to know was why <code>map(mul, *zip(..))</code> wouldn't provide two arguments to <code>mul</code> instead of a <code>tuple</code>.</span>
<span class="comment-copy">@ersran9 <code>*zip()</code> only makes the return value of the whole zip expand into multiple arguments, so you are essentially calling <code>map(mul, zip_0, zip_1, zip_2, ...)</code> where each <code>zip_i</code> is still a tuple.</span>
