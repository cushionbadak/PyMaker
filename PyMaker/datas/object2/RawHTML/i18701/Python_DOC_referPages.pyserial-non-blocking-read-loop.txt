<div class="post-text" itemprop="text">
<p>I am reading serial data like this:</p>
<pre><code>connected = False
port = 'COM4'
baud = 9600

ser = serial.Serial(port, baud, timeout=0)

while not connected:
    #serin = ser.read()
    connected = True

    while True:
        print("test")
        reading = ser.readline().decode()
</code></pre>
<p>The problem is that it prevents anything else from executing including bottle py web framework. Adding <code>sleep()</code> won't help.</p>
<p>Changing "while True"" to "while ser.readline():" doesn't print "test", which is strange since it worked in Python 2.7. Any ideas what could be wrong?</p>
<p>Ideally I should be able to read serial data only when it's available. Data is being sent every 1,000 ms.</p>
</div>
<div class="post-text" itemprop="text">
<p>Put it in a separate thread, for example:</p>
<pre><code>import threading
import serial

connected = False
port = 'COM4'
baud = 9600

serial_port = serial.Serial(port, baud, timeout=0)

def handle_data(data):
    print(data)

def read_from_port(ser):
    while not connected:
        #serin = ser.read()
        connected = True

        while True:
           print("test")
           reading = ser.readline().decode()
           handle_data(reading)

thread = threading.Thread(target=read_from_port, args=(serial_port,))
thread.start()
</code></pre>
<p><a href="http://docs.python.org/3/library/threading" rel="noreferrer">http://docs.python.org/3/library/threading</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Using a separate thread is totally unnecessary. Just do this for your infinite while loop instead (Tested in Python 3.2.3):</p>
<pre><code>import serial
import time # Optional (if using time.sleep() below)

while (True):
    # NB: for PySerial v3.0 or later, use property `in_waiting` instead of function `inWaiting()` below!
    if (ser.inWaiting()&gt;0): #if incoming bytes are waiting to be read from the serial input buffer
        data_str = ser.read(ser.inWaiting()).decode('ascii') #read the bytes and convert from binary array to ASCII
        print(data_str, end='') #print the incoming string without putting a new-line ('\n') automatically after every print()
    #Put the rest of your code you want here
    time.sleep(0.01) # Optional: sleep 10 ms (0.01 sec) once per loop to let other threads on your PC run during this time. 
</code></pre>
<p>This way you only read and print if something is there. You said, "Ideally I should be able to read serial data only when it's available." This is exactly what the code above does. If nothing is available to read, it skips on to the rest of your code in the while loop. Totally non-blocking.</p>
<p>(This answer originally posted &amp; debugged here: <a href="https://stackoverflow.com/questions/38757906/python-3-non-blocking-read-with-pyserial-cannot-get-pyserials-in-waiting-pro/">Python 3 non-blocking read with pySerial (Cannot get pySerial's "in_waiting" property to work)</a>)</p>
<p>pySerial documentation: <a href="http://pyserial.readthedocs.io/en/latest/pyserial_api.html" rel="noreferrer">http://pyserial.readthedocs.io/en/latest/pyserial_api.html</a></p>
<p>UPDATE:  </p>
<ul>
<li>27 Dec. 2018: added comment about <code>in_waiting</code> vs <code>inWaiting()</code>. Thanks to @FurkanTürkal for pointing that out in the comments below. See documentation here: <a href="https://pyserial.readthedocs.io/en/latest/pyserial_api.html#serial.Serial.in_waiting" rel="noreferrer">https://pyserial.readthedocs.io/en/latest/pyserial_api.html#serial.Serial.in_waiting</a>.</li>
<li>27 Oct. 2018: Add sleep to let other threads run.  

<ul>
<li>Documentation: <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="noreferrer">https://docs.python.org/3/library/time.html#time.sleep</a></li>
<li>Thanks to @RufusV2 for bringing this point up in the comments.</li>
</ul></li>
</ul>
<h2>Note on multi-threading:</h2>
<p>Even though reading serial data, as shown above, does <em>not</em> require using multiple threads, reading keyboard input in a non-blocking manner <em>does</em>. Therefore, to accomplish non-blocking keyboard input reading, I've written this answer: <a href="https://stackoverflow.com/questions/5404068/how-to-read-keyboard-input/53344690#53344690">How to read keyboard-input?</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a timer driven event to test and read the serial port.
Untested example:</p>
<pre><code>import threading
class serialreading():
    def __init__(self):
        self.active = True
        self.test() 
    def test(self):
        n_in =comport.in_waiting()
        if n_in&gt; 0:
            self.data = self.data + comport.read(size=n_in)
    if len(self.data) &gt; 0: 
        print(self.data)
        self.data=""
    if self.active:
        threading.Timer(1, test).start()  # start new timer of 1 second
    def stop(self):
        self.active = False
</code></pre>
</div>
<span class="comment-copy">Wouldn't you create a thread and add this read code to it?</span>
<span class="comment-copy">serial communication is blocking ... you should use a thread</span>
<span class="comment-copy">Could you post an answer with an example?</span>
<span class="comment-copy">Serial is blocking ... unless you set it to non-blocking. (unless they changed something since py 2.4)</span>
<span class="comment-copy">I just posted my answer below. Also, I recommend you add the keyword "nonblocking" to this question.</span>
<span class="comment-copy">How to close this thread when it is not needed more?</span>
<span class="comment-copy">Too see a generic multithreading example with queue usage, see here: <a href="https://stackoverflow.com/questions/5404068/how-to-read-keyboard-input/53344690#53344690" title="how to read keyboard input">stackoverflow.com/questions/5404068/how-to-read-keyboard-input/…</a>.</span>
<span class="comment-copy">Thanks! This solution got me out of a tough spot today. I really feel this should be the accepted answer in this case.</span>
<span class="comment-copy">Instead of while(True) I would suggest using while(ser.isOpen())</span>
<span class="comment-copy">for PySerial Version &gt;3 you need to use ser.is_open</span>
<span class="comment-copy">If you are not blocking, I'd recommend an else clause to the if..inWaiting block, with a time.sleep(0.01) to avoid "pegging" the CPU of your computer if you want anything else to run at the same time.</span>
<span class="comment-copy">Changed in version 3.0: changed to property from <code>inWaiting()</code> to <code>in_waiting()</code> Please <a href="https://pyserial.readthedocs.io/en/latest/pyserial_api.html#serial.Serial.in_waiting" rel="nofollow noreferrer">see here</a>.</span>
