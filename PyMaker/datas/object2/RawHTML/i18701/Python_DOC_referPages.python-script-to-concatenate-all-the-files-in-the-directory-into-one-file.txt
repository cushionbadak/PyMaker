<div class="post-text" itemprop="text">
<p>I have written the following script to concatenate all the files in the directory into one single file. </p>
<p>Can this be optimized, in terms of </p>
<ol>
<li><p>idiomatic python</p></li>
<li><p>time </p></li>
</ol>
<p>Here is the snippet:</p>
<pre><code>import time, glob

outfilename = 'all_' + str((int(time.time()))) + ".txt"

filenames = glob.glob('*.txt')

with open(outfilename, 'wb') as outfile:
    for fname in filenames:
        with open(fname, 'r') as readfile:
            infile = readfile.read()
            for line in infile:
                outfile.write(line)
            outfile.write("\n\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/2/library/shutil.html#shutil.copyfileobj" rel="noreferrer"><code>shutil.copyfileobj</code></a> to copy data:</p>
<pre><code>import shutil

with open(outfilename, 'wb') as outfile:
    for filename in glob.glob('*.txt'):
        if filename == outfilename:
            # don't want to copy the output into the output
            continue
        with open(filename, 'rb') as readfile:
            shutil.copyfileobj(readfile, outfile)
</code></pre>
<p><code>shutil</code> reads from the <code>readfile</code> object in chunks, writing them to the <code>outfile</code> fileobject directly. Do not use <code>readline()</code> or a iteration buffer, since you do not need the overhead of finding line endings.</p>
<p>Use the same mode for both reading and writing; this is especially important when using Python 3; I've used binary mode for both here. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using Python 2.7, I did some "benchmark" testing of</p>
<pre><code>outfile.write(infile.read())
</code></pre>
<p>vs</p>
<pre><code>shutil.copyfileobj(readfile, outfile)
</code></pre>
<p>I iterated over 20 .txt files ranging in size from 63 MB to 313 MB with a joint file size of ~ 2.6 GB. In both methods, normal read mode performed better than binary read mode and shutil.copyfileobj was generally faster than outfile.write.</p>
<p>When comparing the worst combination (outfile.write, binary mode) with the best combination (shutil.copyfileobj, normal read mode), the difference was quite significant:</p>
<pre><code>outfile.write, binary mode: 43 seconds, on average.

shutil.copyfileobj, normal mode: 27 seconds, on average.
</code></pre>
<p>The outfile had a final size of 2620 MB in normal read mode vs 2578 MB in binary read mode.</p>
</div>
<div class="post-text" itemprop="text">
<p>No need to use that many variables.</p>
<pre><code>with open(outfilename, 'w') as outfile:
    for fname in filenames:
        with open(fname, 'r') as readfile:
            outfile.write(readfile.read() + "\n\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/fileinput.html" rel="nofollow">fileinput</a> module provides a natural way to iterate over multiple files</p>
<pre><code>for line in fileinput.input(glob.glob("*.txt")):
    outfile.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over the lines of a file object directly, without reading the whole thing into memory:</p>
<pre><code>with open(fname, 'r') as readfile:
    for line in readfile:
        outfile.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I was curious to check more on performance and I used answers of Martijn Pieters and Stephen Miller.</p>
<p>I tried binary and text modes with <code>shutil</code> and without <code>shutil</code>. I tried to merge 270 files.</p>
<p>Text mode - </p>
<pre><code>def using_shutil_text(outfilename):
    with open(outfilename, 'w') as outfile:
        for filename in glob.glob('*.txt'):
            if filename == outfilename:
                # don't want to copy the output into the output
                continue
            with open(filename, 'r') as readfile:
                shutil.copyfileobj(readfile, outfile)

def without_shutil_text(outfilename):
    with open(outfilename, 'w') as outfile:
        for filename in glob.glob('*.txt'):
            if filename == outfilename:
                # don't want to copy the output into the output
                continue
            with open(filename, 'r') as readfile:
                outfile.write(readfile.read())
</code></pre>
<p>Binary mode - </p>
<pre><code>def using_shutil_text(outfilename):
    with open(outfilename, 'wb') as outfile:
        for filename in glob.glob('*.txt'):
            if filename == outfilename:
                # don't want to copy the output into the output
                continue
            with open(filename, 'rb') as readfile:
                shutil.copyfileobj(readfile, outfile)

def without_shutil_text(outfilename):
    with open(outfilename, 'wb') as outfile:
        for filename in glob.glob('*.txt'):
            if filename == outfilename:
                # don't want to copy the output into the output
                continue
            with open(filename, 'rb') as readfile:
                outfile.write(readfile.read())
</code></pre>
<p>Running times for binary mode - </p>
<pre><code>Shutil - 20.161773920059204
Normal - 17.327500820159912
</code></pre>
<p>Running times for text mode - </p>
<pre><code>Shutil - 20.47757601737976
Normal - 13.718038082122803
</code></pre>
<p>Looks like in both modes, shutil performs same while text mode is faster than binary. </p>
<p>OS: Mac OS 10.14 Mojave. Macbook Air 2017. </p>
</div>
<span class="comment-copy">optimized for time? use "cat *.txt &gt; all.txt" :)</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/17749058/combine-multiple-text-files-into-one-text-file-using-python">combine multiple text files into one text file using python</a></span>
<span class="comment-copy">Why is important to use the same mode for writing and reading?</span>
<span class="comment-copy">@JuanDavid: because shutil will use <code>.read()</code> calls on one, <code>.write()</code> calls on the other file object, passing the read data from one to the other. If one is open in binary mode, the other in text, you are passing through incompatible data (binary data to a text file, or text data to a binary file).</span>
<span class="comment-copy">Interesting. What platform was that?</span>
<span class="comment-copy">I roughly work on two platforms: Linux Fedora 16, different nodes or Windows 7 Enterprise SP1 with an Intel Core(TM)2 Quad CPU Q9550, 2.83 GHz. I think it was the latter.</span>
<span class="comment-copy">thanks for the info!</span>
<span class="comment-copy">This would be even better if it didn't confine itself to reading a line at a time.</span>
<span class="comment-copy">@Marcin, that is correct. I used to think this was a cool solution - until I saw Martijn Pieter's <code>shutil.copyfileobj</code> humdinger.</span>
