<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>import logging
class A(object):
    def __init__(self):
        self._l = self._get_logger()

    def _get_logger(self):
        loglevel = logging.INFO
        l = logging.getLogger(__name__)
        l.setLevel(logging.INFO)
        h = logging.StreamHandler()
        f = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
        h.setFormatter(f)
        l.addHandler(h)
        l.setLevel(loglevel)
        return l  

    def p(self, msg):
        self._l.info(msg)

for msg in ["hey", "there"]:
    a = A()
    a.p(msg)
</code></pre>
<p>The output that I get is:</p>
<pre><code>2013-07-19 17:42:02,657 INFO hey
2013-07-19 17:42:02,657 INFO there
2013-07-19 17:42:02,657 INFO there
</code></pre>
<p>Why is "there" being printed twice? Similarly, if I add another object of class A inside the loop and print a message, it gets printed thrice.</p>
<p>The documentation says that logging.getLogger() will always return the same instance of the logger if the name of the logger matches. In this case, the name does match. Should it not return the same logger instance? If it is infact doing so, why is the message getting printed multiple times?</p>
</div>
<div class="post-text" itemprop="text">
<p>logger is created once, but multiple handlers are created.</p>
<p>Create <code>A</code> once.</p>
<pre><code>a = A()
for msg in ["hey", "there"]:
    a.p(msg)
</code></pre>
<p>Or change <code>_get_logger</code> as follow:</p>
<pre><code>def _get_logger(self):
    loglevel = logging.INFO
    l = logging.getLogger(__name__)
    if not getattr(l, 'handler_set', None):
        l.setLevel(loglevel)
        h = logging.StreamHandler()
        f = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
        h.setFormatter(f)
        l.addHandler(h)
        l.setLevel(loglevel)
        l.handler_set = True
    return l  
</code></pre>
<p><strong>UPDATE</strong></p>
<p>Since Python 3.2, you can use <a href="https://docs.python.org/3/library/logging.html#logging.Logger.hasHandlers" rel="nofollow noreferrer"><code>logging.Logger.hasHandlers</code></a> to see if this logger has any handlers configured. (thanks @toom)</p>
<pre><code>def _get_logger(self):
    loglevel = logging.INFO
    l = logging.getLogger(__name__)
    if not l.hasHandlers():
        ...
    return l
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In my case , the root loggers handler were also being called , All I did was to set <code>propagate</code> attribute of logger instance to <code>False</code>.</p>
<pre><code>import logging
logger = logging.getLogger("MyLogger")

# stop propagting to root logger
logger.propagate = False

# other log configuration stuff
# ....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since python 3.2 and newer:</p>
<p>Consider using <code>hasHandlers()</code> to check if a logger has handlers or not.</p>
<p><a href="https://docs.python.org/3/library/logging.html#logging.Logger.hasHandlers" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html#logging.Logger.hasHandlers</a></p>
</div>
<span class="comment-copy">My use case is different. I want to be able to spawn multiple objects of a class that implements its own logger. Is this the right way of doing things? Also, why are the log lines getting printed multiple times?</span>
<span class="comment-copy">@NikhilSingh, See updated explanation and code.</span>
<span class="comment-copy">@NikhilSingh: <code>getLogger</code> does return the same logger every time, but then each time you instantiate <code>A</code>, you're calling <code>addHandler</code> on that same logger. It will print a message for every handler you've added.</span>
<span class="comment-copy">You are constructing the logger handler once for each A instance. You are creating an A instance for "hey" and "there", so two handlers. Change the line to <code>["hey", "there", "buddy"]</code> and you'll get 3 copies of "buddy". Only create the A._l logger once per class, not once per instance.</span>
<span class="comment-copy">Since python 3.2: You should consider <code>l = logging.getLogger(__name__)</code> and then <code>l.hasHandlers()</code> method. Does exactly the job! <a href="https://docs.python.org/3/library/logging.html#logging.Logger.hasHandlers" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
