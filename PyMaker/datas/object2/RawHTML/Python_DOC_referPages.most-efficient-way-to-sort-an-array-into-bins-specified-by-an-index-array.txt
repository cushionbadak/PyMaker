<div class="post-text" itemprop="text">
<p>The task by example:</p>
<pre><code>data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
idx  = np.array([2, 0, 1, 1, 2, 0, 1, 1, 2])
</code></pre>
<p>Expected result:</p>
<pre><code>binned = np.array([2, 6, 3, 4, 7, 8, 1, 5, 9])
</code></pre>
<p>Constraints:</p>
<ul>
<li><p>Should be fast.</p></li>
<li><p>Should be <code>O(n+k)</code> where n is the length of data and k is the number of bins.</p></li>
<li><p>Should be stable, i.e. order within bins is preserved.</p></li>
</ul>
<p>Obvious solution</p>
<pre><code>data[np.argsort(idx, kind='stable')]
</code></pre>
<p>is <code>O(n log n)</code>.</p>
<p><code>O(n+k)</code> solution</p>
<pre><code>def sort_to_bins(idx, data, mx=-1):
    if mx==-1:
        mx = idx.max() + 1
    cnts = np.zeros(mx + 1, int)
    for i in range(idx.size):
        cnts[idx[i] + 1] += 1
    for i in range(1, cnts.size):
        cnts[i] += cnts[i-1]
    res = np.empty_like(data)
    for i in range(data.size):
        res[cnts[idx[i]]] = data[i]
        cnts[idx[i]] += 1
    return res
</code></pre>
<p>is loopy and slow.</p>
<p>Is there a better method in pure <code>numpy</code> &lt; <code>scipy</code> &lt; <code>pandas</code> &lt; <code>numba</code>/<code>pythran</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are a few solutions:</p>
<ol>
<li><p>Use <code>np.argsort</code> anyway, after all it is fast compiled code.</p></li>
<li><p>Use <code>np.bincount</code> to get the bin sizes and <code>np.argpartition</code> which is <code>O(n)</code> for fixed number of bins. Downside: currently, no stable algorithm is available, thus we have to sort each bin.</p></li>
<li><p>Use <code>scipy.ndimage.measurements.labeled_comprehension</code>. This does roughly what is required, but no idea how it is implemented.</p></li>
<li><p>Use <code>pandas</code>. I'm a complete <code>pandas</code> noob, so what I cobbled together here using <code>groupby</code> may be suboptimal.</p></li>
<li><p>Use <code>scipy.sparse</code> switching between compressed sparse row and compressed sparse column formats happens to implement the exact operation we are looking for.</p></li>
<li><p>Use <code>pythran</code> (I'm sure <code>numba</code> works as well) on the loopy code in the question. All that is required is to insert at the top after numpy import</p></li>
</ol>
<p>.</p>
<pre><code>#pythran export sort_to_bins(int[:], float[:], int)
</code></pre>
<p>and then compile</p>
<pre><code># pythran stb_pthr.py
</code></pre>
<p>Benchmarks 100 bins, variable number of items:</p>
<p><a href="https://i.stack.imgur.com/SL2bT.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/SL2bT.png"/></a></p>
<p>Take home:</p>
<p>If you are ok with <code>numba</code>/<code>pythran</code> that is the way to go, if not <code>scipy.sparse</code> scales rather well.</p>
<p>Code:</p>
<pre><code>import numpy as np
from scipy import sparse
from scipy.ndimage.measurements import labeled_comprehension
from stb_pthr import sort_to_bins as sort_to_bins_pythran
import pandas as pd

def sort_to_bins_pandas(idx, data, mx=-1):
    df = pd.DataFrame.from_dict(data=data)
    out = np.empty_like(data)
    j = 0
    for grp in df.groupby(idx).groups.values():
        out[j:j+len(grp)] = data[np.sort(grp)]
        j += len(grp)
    return out

def sort_to_bins_ndimage(idx, data, mx=-1):
    if mx==-1:
        mx = idx.max() + 1
    out = np.empty_like(data)
    j = 0
    def collect(bin):
        nonlocal j
        out[j:j+len(bin)] = np.sort(bin)
        j += len(bin)
        return 0
    labeled_comprehension(data, idx, np.arange(mx), collect, data.dtype, None)
    return out

def sort_to_bins_partition(idx, data, mx=-1):
    if mx==-1:
        mx = idx.max() + 1
    return data[np.argpartition(idx, np.bincount(idx, None, mx)[:-1].cumsum())]

def sort_to_bins_partition_stable(idx, data, mx=-1):
    if mx==-1:
        mx = idx.max() + 1
    split = np.bincount(idx, None, mx)[:-1].cumsum()
    srt = np.argpartition(idx, split)
    for bin in np.split(srt, split):
        bin.sort()
    return data[srt]

def sort_to_bins_sparse(idx, data, mx=-1):
    if mx==-1:
        mx = idx.max() + 1    
    return sparse.csr_matrix((data, idx, np.arange(len(idx)+1)), (len(idx), mx)).tocsc().data

def sort_to_bins_argsort(idx, data, mx=-1):
    return data[idx.argsort(kind='stable')]

from timeit import timeit
exmpls = [np.random.randint(0, K, (N,)) for K, N in np.c_[np.full(16, 100), 1&lt;&lt;np.arange(5, 21)]]

timings = {}
for idx in exmpls:
    data = np.arange(len(idx), dtype=float)
    ref = None
    for x, f in (*globals().items(),):
        if x.startswith('sort_to_bins_'):
            timings.setdefault(x.replace('sort_to_bins_', '').replace('_', ' '), []).append(timeit('f(idx, data, -1)', globals={'f':f, 'idx':idx, 'data':data}, number=10)*100)
            if x=='sort_to_bins_partition':
                continue
            if ref is None:
                ref = f(idx, data, -1)
            else:
                assert np.all(f(idx, data, -1)==ref)

import pylab
for k, v in timings.items():
    pylab.loglog(1&lt;&lt;np.arange(5, 21), v, label=k)
pylab.xlabel('#items')
pylab.ylabel('time [ms]')
pylab.legend()
pylab.show()
</code></pre>
</div>
<span class="comment-copy">As mentioned in the post I'm not good with pandas. Better solutions especially with pandas, but also otherwise most welcome.</span>
