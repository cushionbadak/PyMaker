<div class="post-text" itemprop="text">
<p>The <code>pandas</code> <code>drop_duplicates</code> function is great for "uniquifying" a dataframe. However, one of the keyword arguments to pass is <code>take_last=True</code> or <code>take_last=False</code>, while I would like to drop all rows which are duplicates across a subset of columns. Is this possible?</p>
<pre><code>    A   B   C
0   foo 0   A
1   foo 1   A
2   foo 1   B
3   bar 1   A
</code></pre>
<p>As an example, I would like to drop rows which match on columns <code>A</code> and <code>C</code> so this should drop rows 0 and 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is much easier in pandas now with <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.DataFrame.drop_duplicates.html">drop_duplicates</a> and the keep parameter.</p>
<pre><code>import pandas as pd
df = pd.DataFrame({"A":["foo", "foo", "foo", "bar"], "B":[0,1,1,1], "C":["A","A","B","A"]})
df.drop_duplicates(subset=['A', 'C'], keep=False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just want to add to Ben's answer on <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.DataFrame.drop_duplicates.html" rel="noreferrer">drop_duplicates</a>:</p>
<p><code>keep</code> : {‘first’, ‘last’, False}, default ‘first’</p>
<ul>
<li><p>first : Drop duplicates except for the first occurrence.</p></li>
<li><p>last : Drop duplicates except for the last occurrence.</p></li>
<li><p><strong>False : Drop all duplicates.</strong></p></li>
</ul>
<p>So set <code>keep</code> to False we give you desired answer.</p>
<blockquote>
<p>DataFrame.drop_duplicates(*args, **kwargs) Return DataFrame with
  duplicate rows removed, optionally only considering certain columns</p>
<p>Parameters:    subset : column label or sequence of labels, optional
  Only consider certain columns for identifying duplicates, by default
  use all of the columns keep : {‘first’, ‘last’, False}, default
  ‘first’ first : Drop duplicates except for the first occurrence. last
  : Drop duplicates except for the last occurrence. False : Drop all
  duplicates. take_last : deprecated inplace : boolean, default False
  Whether to drop duplicates in place or to return a copy cols : kwargs
  only argument of subset [deprecated] Returns:  deduplicated :
  DataFrame</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>use <code>groupby</code> and <code>filter</code></p>
<pre><code>import pandas as pd
df = pd.DataFrame({"A":["foo", "foo", "foo", "bar"], "B":[0,1,1,1], "C":["A","A","B","A"]})
df.groupby(["A", "C"]).filter(lambda df:df.shape[0] == 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want result to be stored in another dataset:</p>
<pre><code>df.drop_duplicates(keep=False)
</code></pre>
<p>or</p>
<pre><code>df.drop_duplicates(keep=False, inplace=False)
</code></pre>
<p>If same dataset needs to updated:</p>
<pre><code>df.drop_duplicates(keep=False, inplace=True)
</code></pre>
<p>Above examples will remove all duplicates and keep one, similar to <code>DISTINCT *</code> in SQL</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, drop rows 0 and 1 only requires (any observations containing matched A and C is kept.):</p>
<pre><code>In [335]:

df['AC']=df.A+df.C
In [336]:

print df.drop_duplicates('C', take_last=True) #this dataset is a special case, in general, one may need to first drop_duplicates by 'c' and then by 'a'.
     A  B  C    AC
2  foo  1  B  fooB
3  bar  1  A  barA

[2 rows x 4 columns]
</code></pre>
<p>But I suspect what you really want is this (one observation containing matched A and C is kept.):</p>
<pre><code>In [337]:

print df.drop_duplicates('AC')
     A  B  C    AC
0  foo  0  A  fooA
2  foo  1  B  fooB
3  bar  1  A  barA

[3 rows x 4 columns]
</code></pre>
<h1>Edit:</h1>
<p>Now it is much clearer, therefore:</p>
<pre><code>In [352]:
DG=df.groupby(['A', 'C'])   
print pd.concat([DG.get_group(item) for item, value in DG.groups.items() if len(value)==1])
     A  B  C
2  foo  1  B
3  bar  1  A

[2 rows x 3 columns]
</code></pre>
</div>
<span class="comment-copy">Also providing an example dataset will be helpful for this question here.</span>
<span class="comment-copy">What if my columns are not explicitly labelled? How do I select the columns just based on their index?</span>
<span class="comment-copy">Maybe <code>df.reindex(df.iloc[:,[0,2]].drop_duplicates(keep=False).index)</code>?</span>
<span class="comment-copy">you could try <code>df.drop_duplicates(subset=[df.columns[0:2]], keep = False)</code></span>
<span class="comment-copy">If that was what I wanted, I'd just use <code>df.drop_duplicates(['A','C'])</code> as the default keeps one observation take the first or last as I mentioned in the question - although I've just realised I had the keyword wrong as I was writing from memory. What I want is to drop all rows which are identical on the columns of interest (A and C in the example data).</span>
