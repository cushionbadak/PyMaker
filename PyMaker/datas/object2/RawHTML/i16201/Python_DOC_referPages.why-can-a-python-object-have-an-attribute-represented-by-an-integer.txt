<div class="post-text" itemprop="text">
<p>I think I might have a fundamental misunderstanding of what a python attribute actually <em>is</em>. Consider the following:</p>
<pre><code> &gt;&gt;&gt; class Test:
 ...     pass
 ... 
 &gt;&gt;&gt; t = Test()
 &gt;&gt;&gt; setattr(t, '0', 0)
 &gt;&gt;&gt; t.0
   File "&lt;stdin&gt;", line 1
     t.0
       ^
 SyntaxError: invalid syntax
 &gt;&gt;&gt; getattr(t, '0')
 0
 &gt;&gt;&gt; setattr(t, 'one', 1)
 &gt;&gt;&gt; t.one
 1
 &gt;&gt;&gt; getattr(t, 'one')
 1
</code></pre>
<p>Why does Python allow me to set an attribute if I can't legally access it with dot notation? I understand that <code>t.0</code> makes no sense, but at the same time I wonder why it's no different than <code>t.one</code> because I created them the same way.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is just a quirk of the syntax and semantics of python. Any string can be used as an attribute name, however only identifiers can be used with dot notation. Thus the only way of accessing non-identifier attributes is with getattr/setattr or some other indirect function. Strangely enough this practice doesn't extend so far as to allow any type to be an attribute, only strings get that privilege.</p>
</div>
<div class="post-text" itemprop="text">
<p>Attributes are a kind of members any Python object can have. Usually you would expect the built-in syntax to dictate what kind of attribute names are accepted. For that, the definition is <a href="https://docs.python.org/3/reference/expressions.html#attribute-references" rel="nofollow">pretty clear</a>:</p>
<pre><code>attributeref ::=  primary "." identifier
</code></pre>
<p>So what follows after the dot is required to be a valid <a href="https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier" rel="nofollow">identifier</a> which limits the allowed attribute names easily. Ignoring other Unicode areas for now, it essentially means that the attribute may not start with a number. So <code>0</code> is not a valid identifier and as such <code>t.0</code> is not a valid <em>attribute reference</em> as per the specification.</p>
<p>However, <code>getattr</code> and alike work a bit differently. They just require the attribute name to be a string. And that string is passed on directly to the internal <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_GetAttr" rel="nofollow"><code>PyObject_GetAttr</code></a> functions. And those donâ€™t require a valid identifier.</p>
<p>So using <code>getattr</code> etc., you can essentially trick Python and attach attribute to objects, which names would not be allowed according to the specification of the language.</p>
</div>
<span class="comment-copy"><i>"Strangely enough this practice doesn't extend so far as to allow any type to be an attribute, only strings get that privilege"</i>. This is true, but you <i>can</i> assign any hashable object as a key in <code>__dict__</code>. The standard library actually uses this in <a href="http://stackoverflow.com/a/25436195/2073595">at least one place</a>.</span>
<span class="comment-copy">@dano Depends on the object though. Slot attributes are not stored in <code>__dict__</code>. And I could also overwrite <code>__getattribute__</code> to change it all around.</span>
