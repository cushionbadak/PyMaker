<div class="post-text" itemprop="text">
<p>I'm trying to connect to my gmail account with imaplib:</p>
<pre><code>import imaplib
mail = imaplib.IMAP4_SSH('imap.gmail.com')
mail.login('myemail@gmail.com', 'mypassword')
mail.select("inbox")
# returns ('OK', [b'12009'])
</code></pre>
<p>This all seems to work nicely, however:</p>
<pre><code>mail.search(None, "ALL")
# returns error: command: SEARCH =&gt; got more than 10000 bytes
mail.logout()
# returns ('NO',
# ["&lt;class 'imaplib.IMAP4.error'&gt;: command: LOGOUT =&gt; got more than 10000 bytes"])
</code></pre>
<p>The account I'm trying to access has about 9,000 emails in the the inbox. I tried the above with another account which has less than 1,000 and the code works fine.</p>
<p>Is the issue with the first email account related to the number of mails in it? Is there some default setting that implements some size limit? </p>
<p>How can I get around the error and read my emails?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is the issue with the first email account related to the number of mails in it?</p>
</blockquote>
<p>Not <em>directly</em>, but yeah, pretty much. The issue is with the fact that you're trying to download the whole list of 9000 messages at once.</p>
<p>Sending ridiculously long lines has been a useful DoS attack and, for programs implemented in C rather than Python, buffer overflow attack against many network clients and servers. It can also be very slow, and choke the network. But notice that the RFC was last updated in 1999, and <code>imaplib</code> was written in 1997, so the limits of "ridiculous" may have changed since then.</p>
<p>The <em>right</em> way to solve this, according to <a href="https://www.ietf.org/rfc/rfc2683.txt" rel="noreferrer">RFC 2683</a>, is to not try to do that. (See especially section 3.2.1.5.)</p>
<hr/>
<blockquote>
<p>Is there some default setting that implements some size limit?</p>
</blockquote>
<p>Yes. It's not listed in the docs, but since the RFC recommends a limit of 8000 bytes, and it's allowing 10000, I guess that's reasonable.</p>
<hr/>
<blockquote>
<p>How can I get around the error and read my emails?</p>
</blockquote>
<p>Again, what you <em>should</em> do is break this up into smaller reads.</p>
<p>But as long gmail has no problem with a search this big, and you're happy to require a computer and network connection a little better than late-90s-standard, you can probably get away with getting around the problem instead.</p>
<p>Fortunately, like many of the modules in the stdlib, <code>imaplib</code> is written as much to be useful sample code as to be used as a module. You can always tell this is the case because <a href="https://docs.python.org/3/library/imaplib.html" rel="noreferrer">the documentation</a> links to <a href="http://hg.python.org/cpython/file/default/Lib/imaplib.py" rel="noreferrer">the source</a> right at the top.</p>
<p>So, if you take a look, you'll see, not far from the top:</p>
<pre><code># reading arbitrary length lines. RFC 3501 and 2060 (IMAP 4rev1)
# don't specify a line length. RFC 2683 however suggests limiting client
# command lines to 1000 octets and server command lines to 8000 octets.
# We have selected 10000 for some extra margin and since that is supposedly
# also what UW and Panda IMAP does.
_MAXLINE = 10000
</code></pre>
<p>So, if you want to override this, you could fork the module (save <code>imaplib.py</code> as <code>myimaplib.py</code> and use that instead), or you could just monkeypatch it at runtime:</p>
<pre><code>import imaplib
imaplib._MAXLINE = 40000
</code></pre>
<p>Of course you'll have to pick a number that you think better reflects the edge of ridiculousness in 2014.</p>
</div>
<span class="comment-copy">This is an excellent answer... thanks for all the pointers and detailed explanation. I often find myself pushing 'the edge of ridiculousness' by pure accident. In this case though I my split up my request...</span>
<span class="comment-copy">This answer is in fact incorrect, since the <a href="http://tools.ietf.org/html/rfc2683#section-3.2.1.5" rel="nofollow noreferrer">advice</a> in RFC 2683 concerns the length of command lines sent by the client and accepted by the server, not the length of responses returned from the server.  There's a python bug page <a href="http://bugs.python.org/issue23647" rel="nofollow noreferrer">here</a> with some useful discussion.  It looks like the default value of MAXLINE has been increased 10 fold in response.</span>
