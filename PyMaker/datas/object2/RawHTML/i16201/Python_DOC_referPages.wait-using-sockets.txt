<div class="post-text" itemprop="text">
<p>Is there a method to wait for a result from an SSL socket before continuing?</p>
<p>for example this is my current code :</p>
<pre><code>circ_to_rend.createStream(1, "xx.x.x.x", 80)
connected = recvCell(ssl_sock)
</code></pre>
<p>but is there a way to pause the program until something is sent back from that stream or do I just simply carry on using the code above which <em>should</em> do this as connected willn't be assigned a value until somthing is received? </p>
<p>create stream is a section of code i have written which creates a stream to send data through the tor network,and recvCell is below, this gets a reply and decodes it so it can be read :</p>
<pre><code>def recvCell(sock, waitFor = 0):
        while True:
                hdr = sock.recv(3)
                circid, cmd = struct.unpack("&gt;HB", hdr[0:3])
                ln = 509
                if cmd == 7 or cmd &gt;= 128:
                        ln = struct.unpack("&gt;H", sock.recv(2))[0]
                pl = sock.recv(ln)

                print "got pkt circ ",circid, " cmd", cmd
                if cmd == waitFor or waitFor == 0:
                        print "Return pkt circ ",circid, " cmd", cmd
                        return { 'circId': circid, 'cmd': cmd, 'len': ln, 'pl': pl}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code you provided is not complete so we can't figure out the entire design, but the <a href="https://docs.python.org/2/library/ssl.html" rel="nofollow"><code>ssl</code></a> module uses <a href="https://docs.python.org/2/library/socket.html" rel="nofollow"><code>socket</code></a>, whose <a href="https://docs.python.org/2/library/socket.html#socket.socket.recv" rel="nofollow"><code>recv()</code></a> method can:</p>
<ol>
<li><p>(<em>socket in blocking mode</em>): Blocks the execution until some data is ready.</p></li>
<li><p>(<em>socket in non-blocking mode</em>): Throws an error if no data is available</p></li>
</ol>
<p>The sockets are created in <em>blocking mode</em> as default (the blocking setting can be changed using <a href="https://docs.python.org/2/library/socket.html#socket.socket.setblocking" rel="nofollow">setblocking</a>). So a call to <code>recv()</code> should block until some data is ready on the SSL socket.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer your literal question:</p>
<blockquote>
<p>is there a way to pause the program until something is sent back from that stream</p>
</blockquote>
<p>Yes, the <a href="https://docs.python.org/3/library/select.html" rel="nofollow"><code>select</code></a> module (or, in 3.4+, the higher-level <a href="https://docs.python.org/3/library/selectors.html" rel="nofollow"><code>selectors</code></a> module) provides ways to pause until something has been sent back, after which you know you can receive it without blocking.</p>
<p>But there's a much simpler way to do this, and as far as I can tell you're already doing it:</p>
<blockquote>
<p>do I just simply carry on using the code above which should do this as connected willn't be assigned a value until somthing is received?</p>
</blockquote>
<p>If <code>connected</code> isn't assigned a value until something is received, then you're <em>already</em> pausing the program until something is sent back from the stream. Unless you switch a socket to non-blocking mode, <code>recv</code> automatically does that. So… I don't know what your problem is, but if you're looking for validation that your code is correct, then yes, it is—at least in this aspect.</p>
<hr/>
<p>There is at least one other problem, however. There is absolutely no guarantee that <code>recv(509)</code> will block until 509 bytes come in. It will block until <em>any packet</em> comes in. Which could be less than 509 bytes. Which means your code will read the first, say, 300 bytes of a message and treat it as a whole message, and then the next time you try to <code>recv</code> you'll get the remaining 209 bytes of that message (or maybe those 209 bytes plus the first 140 of the next message, or whatever) and confuse your code badly. You should always loop and accumulate until you get the full data. The easiest way to do that is to write a function like this:</p>
<pre><code>def recvall(sock, bufsize):
    buf = ''
    while len(buf) &lt; bufsize:
        newbuf = sock.recv(bufsize - len(buf))
        if not newbuf:
            return buf # or maybe raise an exception
        buf += newbuf
</code></pre>
</div>
<span class="comment-copy">What is this <code>createStream</code> and <code>recvCell</code>? They're not part of the Python <code>socket</code> or <code>ssl</code> library. If you're asking about a third-party library, you'll need to tell us which one.</span>
<span class="comment-copy">Added above :) sorry i left that bit out</span>
<span class="comment-copy">I still don't understand the problem. It sounds like you've got a blocking socket, so <code>recvCell</code> doesn't return until it's received everything it wanted, so the program is already paused. Is that not what's happening? If not, what <i>is</i> happening? Are you getting an exception? Is the program carrying on with nothing in <code>connected</code>? Are you busy-looping around <code>recv</code> calls and burning 100% CPU? Something different?</span>
<span class="comment-copy">This is almost completely wrong. Blocking mode means that it blocks execution until data is ready; non-blocking means it doesn't. Also, sockets are created in blocking mode by default, unless spun off from a non-blocking socket, in which case it's platform-dependent whether they start off blocking.</span>
<span class="comment-copy">Oops, I swapped them, thanks! :)</span>
