<div class="post-text" itemprop="text">
<p>I'm trying to understand how to use the new AsyncIO functionality in Python 3.4 and I'm struggling with how to use the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.add_reader">event_loop.add_reader()</a>. From the <a href="http://comments.gmane.org/gmane.comp.python.tulip/2162">limited discussions</a> that I've found it looks like its for reading the standard out of a separate process as opposed to the contents of an open file. Is that true? If so it appears that there's no AsyncIO specific way to integrate standard file IO, is this also true?</p>
<p>I've been playing with the following code. The output of the following gives the exception <code>PermissionError: [Errno 1] Operation not permitted</code> from line 399 of /python3.4/selectors.py <code>self._epoll.register(key.fd, epoll_events)</code> that is triggered by the <code>add_reader()</code> line below</p>
<pre><code>import asyncio
import urllib.parse
import sys
import pdb
import os

def fileCallback(*args):
    pdb.set_trace()

path = sys.argv[1]
loop = asyncio.get_event_loop()
#fd = os.open(path, os.O_RDONLY)
fd = open(path, 'r')
#data = fd.read()
#print(data)
#fd.close()
pdb.set_trace()
task = loop.add_reader(fd, fileCallback, fd)
loop.run_until_complete(task)
loop.close()
</code></pre>
<p><strong>EDIT</strong></p>
<p>For those looking for an example of how to use AsyncIO to read more than one file at a time like I was curious about, here's an example of how it can be accomplished. The secret is in the line <code>yield from asyncio.sleep(0)</code>. This essentially pauses the current function, putting it back in the event loop queue, to be called after all other ready functions are executed. Functions are determined to be ready based on how they were scheduled.</p>
<pre><code>import asyncio

@asyncio.coroutine
def read_section(file, length):
    yield from asyncio.sleep(0)
    return file.read(length)

@asyncio.coroutine
def read_file(path):
    fd = open(path, 'r')
    retVal = []
    cnt = 0
    while True:
        cnt = cnt + 1
        data = yield from read_section(fd, 102400)
        print(path + ': ' + str(cnt) + ' - ' + str(len(data)))
        if len(data) == 0:
            break;
    fd.close()

paths = ["loadme.txt", "loadme also.txt"]
loop = asyncio.get_event_loop()
tasks = []
for path in paths:
    tasks.append(asyncio.async(read_file(path)))
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>These functions expect a file descriptor, that is, the underlying integers the operating system uses, not Python's file objects. File objects that are based on file descriptors return that descriptor on the <code>fileno()</code> method, so for example:</p>
<pre><code>&gt;&gt;&gt; sys.stderr.fileno()
2
</code></pre>
<p>In Unix, file descriptors can be attached to files or a lot of other things, including other processes.</p>
<p><strong>Edit for the OP's edit:</strong></p>
<p>As Max in the comments says, you can not use <code>epoll</code> on local files (and asyncio uses <code>epoll</code>). Yes, that's kind of weird. You can use it on pipes, though, for example:</p>
<pre><code>import asyncio
import urllib.parse
import sys
import pdb
import os

def fileCallback(*args):
    print("Received: " + sys.stdin.readline())

loop = asyncio.get_event_loop()
task = loop.add_reader(sys.stdin.fileno(), fileCallback)
loop.run_forever()
</code></pre>
<p>This will echo stuff you write on stdin.</p>
</div>
<div class="post-text" itemprop="text">
<p>you cannot use add_reader on local files, because:</p>
<ul>
<li>It cannot be done using select/poll/epoll</li>
<li>It depends on the operating system</li>
<li>It cannot be fully asynchronous because of os limitations (linux does not support async fs metadata read/write)</li>
</ul>
<p>But, technically, yes you should be able to do async filesystem read/write, (almost) all systems have DMA mechanism for doing i/o "in the background". And no, local i/o is not <em>really</em> fast such that no one would want it, the CPU are in the order of millions times faster that disk i/o.</p>
<p>Look for aiofile or aiofiles if you want to try async i/o</p>
</div>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/8645721/why-does-select-select-work-with-disk-files-but-not-epoll">this question</a> for why this is  failing; <code>epoll</code> doesn't support regular files.</span>
<span class="comment-copy">@dano: If I did this on FreeBSD, would it use kqueue and work with regular files?</span>
<span class="comment-copy">I'm not sure exactly, but I do know that AsyncIO's aim is to expose the file system's standard IO call backs. So if that's the standard way that FreeBSD performs IO call backs then probably</span>
<span class="comment-copy">@JanusTroelsen On FreeBSD the <code>SelectorEventLoop</code> get used, which uses the <a href="https://docs.python.org/3/library/selectors.html#module-selectors" rel="nofollow noreferrer"><code>selectors</code></a> module to choose the most efficient event loop for the platform. If that's kqueue, then that should be what <code>selectors</code> chooses. I don't know if that will make <code>add_reader</code> work with regular files, though. If you give it a try, let me know how it goes!</span>
<span class="comment-copy">Ok, so then in my example the <code>os.open()</code> which returns a numeric file descriptor should work? Because it gives me the same result</span>
<span class="comment-copy">Local files cannot usually be selected/polled etc. on because they do not block.</span>
<span class="comment-copy">Updated my answer to reflect your updated question :-)</span>
<span class="comment-copy">Is that just because of the efficiency of loading files locally? If you had a large file or files that needed to be loaded would you experience blocking?</span>
<span class="comment-copy">And yes, if reading a large file into the process memory all at once would take too long, you can do reads in smaller chunks (<code>os.read</code> has a buffersize argument) and yield in between those chunks.</span>
