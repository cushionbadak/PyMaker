<div class="post-text" itemprop="text">
<p>I've created a function to project a bipartite edgelist into a single mode edgelist, and everything works as it should.  However, my existing plan has been to add all these edges to a list, then load that list into a pandas dataframe, and filter the list based on edge weight to create new dataframes, then write those dataframes to csv.  </p>
<p>This has worked well, until my data became too large to hold in RAM.  </p>
<p>I'm thinking that instead of adding the single mode edgelist to a list, I should just just write the contents of <code>folded</code> to CSV, and skip even adding that data to a list at all.  I would also like to filter what I write to CSV to only write lines with weight greater than or equal to 2.</p>
<p><em>Data:</em></p>
<pre><code>E1,Brenda Rogers
E1,Evelyn Jefferson
E1,Laura Mandeville
E10,Nora Fayette
E10,Helen Lloyd
E10,Katherina Rogers
E10,Myra Liddel
E10,Sylvia Avondale
E11,Flora Price
E11,Nora Fayette
E11,Helen Lloyd
E11,Olivia Carleton
E12,Nora Fayette
E12,Verne Sanderson
E12,Helen Lloyd
E12,Katherina Rogers
E12,Myra Liddel
E12,Sylvia Avondale
E13,Nora Fayette
E13,Katherina Rogers
E13,Sylvia Avondale
E14,Nora Fayette
E14,Katherina Rogers
E14,Sylvia Avondale
E2,Evelyn Jefferson
E2,Laura Mandeville
E2,Theresa Anderson
E3,Brenda Rogers
E3,Charlotte McDowd
E3,Frances Anderson
E3,Evelyn Jefferson
E3,Laura Mandeville
E3,Theresa Anderson
E4,Brenda Rogers
E4,Charlotte McDowd
E4,Evelyn Jefferson
E4,Theresa Anderson
E5,Brenda Rogers
E5,Charlotte McDowd
E5,Frances Anderson
E5,Evelyn Jefferson
E5,Ruth DeSand
E5,Eleanor Nye
E5,Laura Mandeville
E5,Theresa Anderson
E6,Brenda Rogers
E6,Nora Fayette
E6,Frances Anderson
E6,Evelyn Jefferson
E6,Eleanor Nye
E6,Laura Mandeville
E6,Pearl Oglethorpe
E6,Theresa Anderson
E7,Brenda Rogers
E7,Charlotte McDowd
E7,Nora Fayette
E7,Verne Sanderson
E7,Ruth DeSand
E7,Helen Lloyd
E7,Eleanor Nye
E7,Laura Mandeville
E7,Sylvia Avondale
E7,Theresa Anderson
E8,Brenda Rogers
E8,Verne Sanderson
E8,Frances Anderson
E8,Dorothy Murchison
E8,Evelyn Jefferson
E8,Ruth DeSand
E8,Helen Lloyd
E8,Eleanor Nye
E8,Katherina Rogers
E8,Laura Mandeville
E8,Myra Liddel
E8,Pearl Oglethorpe
E8,Sylvia Avondale
E8,Theresa Anderson
E9,Flora Price
E9,Nora Fayette
E9,Verne Sanderson
E9,Dorothy Murchison
E9,Evelyn Jefferson
E9,Ruth DeSand
E9,Olivia Carleton
E9,Katherina Rogers
E9,Myra Liddel
E9,Pearl Oglethorpe
E9,Sylvia Avondale
E9,Theresa Anderson
</code></pre>
<p><strong><em>How can I alter my code to write directly to CSV and skip adding the edges to the folded list, but only edges that have a weight greater than or equal to 3?</em></strong></p>
<p><em>Below is the code as-is, which adds all the edges to a list, then writes to list to CSV:</em></p>
<pre><code>import csv
import networkx as nx
from networkx.algorithms import bipartite

def fold_network(input_file):

    # load text file into a dict with head as keys
    header = ['Event','Name']        
    rawData = [{key: value for (key, value) in zip(header, line.strip().split(','))} for line in open(input_file)]

    # create edgelist for Name -x- Event relationships
    edgelist = []
    for i in rawData:
        edgelist.append(
        (i['Event'],
        i['Name'])    
        )

    # create a unique list of Name and Event for nodes
    Event = sorted(set([i['Event'] for i in rawData]))
    Name = sorted(set([i['Name'] for i in rawData]))

    # add nodes and edges to a graph
    B = nx.Graph()
    B.add_nodes_from(Event, bipartite=0)
    B.add_nodes_from(Name, bipartite=1)
    B.add_edges_from(edgelist)

    # create bipartite projection graph
    name_nodes, event_nodes = bipartite.sets(B)
    event_nodes = set(n for n,d in B.nodes(data=True) if d['bipartite']==0)
    name_nodes = set(B) - event_nodes

    # project graph and write projected graph's edgelist to a list
    seen = set()
    folded = []
    for u in name_nodes:
    #    seen=set([u]) # print both u-v, and v-u
        seen.add(u) # don't print v-u
        unbrs = set(B[u])
        nbrs2 = set((n for nbr in unbrs for n in B[nbr])) - seen
        for v in nbrs2:
            vnbrs = set(B[v])
            common = unbrs &amp; vnbrs
            weight = len(common)
            row = u, v, weight
            folded.append(row)

    # write folded list containing only edges with weight greater than or equal to 3 to CSV
    for i in folded:
        if i[2] &gt;= 3:
            with open('outfile.csv', 'wb') as f:
                csv.writer(f).writerows(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, the answer to the main question (there is a good reason why you should restrict your question to, well, one question) is quite simple - all you have to is to remodel this tiny bit of code:</p>
<pre><code>    for v in nbrs2:
        vnbrs = set(B[v])
        common = unbrs &amp; vnbrs
        weight = len(common)
        row = u, v, weight
        folded.append(row)
</code></pre>
<p>Into something like:</p>
<pre><code>    for v in nbrs2:
        vnbrs = set(B[v])
        common = unbrs &amp; vnbrs
        weight = len(common)
        row = u, v, weight
        f = open('outfile.csv', 'a')
        f.write(row)
        f.close()
</code></pre>
<p>Of course you will have to format the row accordingly, and you may not need to open and close file handle for each row, but with this approach you won't have to build up a large chunk of data in memory that you do not need.</p>
</div>
<span class="comment-copy">So, why won't you just replace folded.append(row) with a call that writes the row to file? If csv.writer doesn't support it then all you need is to open the file and append to it.</span>
<span class="comment-copy">@Puciek - I think that's a great idea, but I haven't been able to figure how to make that work properly unfortunately.</span>
<span class="comment-copy">What do you mean by that? What have you tried and why didn't it work?</span>
<span class="comment-copy">Thanks, but I get the error <code>TypeError: expected a character buffer object</code>.  I see that is because <code>write</code> requires a string or buffer.</span>
<span class="comment-copy">As I said you will most likely have to format the row (among other things). If you have specific questions on how to do it (including what you've tried and what is your problem), feel free to ask in the comments. But if you are looking for a complete solution that you can just copy/paste into your code without any effort on your part, well, probably someone else will come along soon enough and do it for the upvote.</span>
<span class="comment-copy">I'm very new to python, but I tried <code>row = ','.join([u, v, str(weight)])</code>, but that apparently writes everything to the first row.</span>
<span class="comment-copy">This isn't an issue with being new to python, more of an issue of not wanting to do the work (same way you've ignored my initial comment about how this didn't work in the first place). To tackle this issue you need to break it down into prices and see what is not working as intended, so the logical step would be to print the ROW as it it (simply add print(row) into your code), then if that is okay - add additional print after you try to format it and see whether that is working fine. There are also tools that make it oh so much easier, like PDB - <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">docs.python.org/3/library/pdb.html</a></span>
