<div class="post-text" itemprop="text">
<p>How can I convert a (big endian) variable-sized binary byte array to an (unsigned) integer/long? As an example, <code>'\x11\x34'</code>, which represents 4404</p>
<p>Right now, I'm using </p>
<pre><code>def bytes_to_int(bytes):
  return int(bytes.encode('hex'), 16)
</code></pre>
<p>Which is small and somewhat readable, but probably not very efficient. Is there a better (more obvious) way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't traditionally have much use for "numbers in big-endian C layout" that are too big for C. (If you're dealing with 2-byte, 4-byte, or 8-byte numbers, then <code>struct.unpack</code> is the answer.)</p>
<p>But enough people got sick of there not being one obvious way to do this that Python 3.2 added a method <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes"><code>int.from_bytes</code></a> that does exactly what you want:</p>
<pre><code>int.from_bytes(b, byteorder='big', signed=False)
</code></pre>
<p>Unfortunately, if you're using an older version of Python, you don't have this. So, what options do you have? (Besides the obvious one: update to 3.2, or, better, 3.4…)</p>
<hr/>
<p>First, there's your code. I think <code>binascii.hexlify</code> is a better way to spell it than <code>.encode('hex')</code>, because "encode" has always seemed a little weird for a method on byte strings (as opposed to Unicode strings), and it's in fact been banished in Python 3. But otherwise, it seems pretty readable and obvious to me. And it should be pretty fast—yes, it has to create an intermediate string, but it's doing all the looping and arithmetic in C (at least in CPython), which is generally an order of magnitude or two faster than in Python. Unless your <code>bytearray</code> is so big that allocating the string will itself be costly, I wouldn't worry about performance here.</p>
<p>Alternatively, you could do it in a loop. But that's going to be more verbose and, at least in CPython, a lot slower.</p>
<p>You could try to eliminate the explicit loop for an implicit one, but the obvious function to do that is <code>reduce</code>, which is considered un-Pythonic by part of the community—and of course it's going to require calling a function for each byte.</p>
<p>You could unroll the loop or <code>reduce</code> by breaking it into chunks of 8 bytes and looping over <code>struct.unpack_from</code>, or by just doing a big <code>struct.unpack('Q'*len(b)//8 + 'B' * len(b)%8)</code> and looping over that, but that makes it a lot less readable and probably not that much faster.</p>
<p>You could use NumPy… but if you're going bigger than either 64 or maybe 128 bits, it's going to end up converting everything to Python objects anyway.</p>
<p>So, I think your answer is the best option.</p>
<hr/>
<p>Here are some timings comparing it to the most obvious manual conversion:</p>
<pre><code>import binascii
import functools
import numpy as np

def hexint(b):
    return int(binascii.hexlify(b), 16)

def loop1(b):
    def f(x, y): return (x&lt;&lt;8)|y
    return functools.reduce(f, b, 0)

def loop2(b):
    x = 0
    for c in b:
        x &lt;&lt;= 8
        x |= c
    return x

def numpily(b):
    n = np.array(list(b))
    p = 1 &lt;&lt; np.arange(len(b)-1, -1, -1, dtype=object)
    return np.sum(n * p)
</code></pre>
<hr/>
<pre><code>In [226]: b = bytearray(range(256))

In [227]: %timeit hexint(b)
1000000 loops, best of 3: 1.8 µs per loop

In [228]: %timeit loop1(b)
10000 loops, best of 3: 57.7 µs per loop

In [229]: %timeit loop2(b)
10000 loops, best of 3: 46.4 µs per loop

In [283]: %timeit numpily(b)
10000 loops, best of 3: 88.5 µs per loop
</code></pre>
<p>For comparison in Python 3.4:</p>
<pre><code>In [17]: %timeit hexint(b)
1000000 loops, best of 3: 1.69 µs per loop

In [17]: %timeit int.from_bytes(b, byteorder='big', signed=False)
1000000 loops, best of 3: 1.42 µs per loop
</code></pre>
<p>So, your method is still pretty fast…</p>
</div>
<div class="post-text" itemprop="text">
<p>Function <a href="https://docs.python.org/2/library/struct.html" rel="nofollow">struct.unpack(...)</a> does what you need.</p>
</div>
<span class="comment-copy">What makes you think it's not very efficient? More to the point, what makes you think this will be a bottleneck in any code you'll ever write?</span>
<span class="comment-copy">Meanwhile, is this a fixed-length bytearray, or is it always 2 bytes?</span>
<span class="comment-copy">Also, what is <code>'\x1134'</code>? You mean <code>'\x11\x34'</code>? Or <code>'\\x1134'</code>? Because what you've written is a 3-character byte string with bytes 0x11, 0x33, 0x34, which I don't think is what you have or want.</span>
<span class="comment-copy">Have you tried using struct ? <a href="https://docs.python.org/2/library/struct.html" rel="nofollow noreferrer">docs.python.org/2/library/struct.html</a></span>
<span class="comment-copy">I've added those details to the question. It's a variable-size bytearray, and my example was wrong. The code is probably not a bottleneck in any way (otherwise this should probably be done in C), but I wanted to know if there was a "canonical best way to do it" - especially since there should <i>preferably be only one obvious way to do it</i></span>
<span class="comment-copy">python3 support is definitely a bonus. In this case it's efficient enough for my needs, I just wanted to make sure there wasn't a more obvious way</span>
<span class="comment-copy">Only if it's a fixed-length (2-byte-long, in his example) bytearray.</span>
<span class="comment-copy">indeed, sorry, I forgot to mention that. I've edited the question in the meanwhile</span>
