<div class="post-text" itemprop="text">
<p>I need to determine if a string represents a valid python identifier. Since python 3 identifiers support <a href="https://docs.python.org/dev/reference/lexical_analysis.html#identifiers" rel="nofollow">obscure unicode functionality</a>, and python syntax might change across releases, I decided to avoid manual parsing. Unfortunately my attempts at utilizing python's internal interfaces don't seem to work:</p>
<p>I. function <a href="https://docs.python.org/dev/library/functions.html#compile" rel="nofollow">compile</a></p>
<pre><code>&gt;&gt;&gt; string = "a = 5; b "
&gt;&gt;&gt; test = "{} = 5"
&gt;&gt;&gt; compile(test.format(string), "&lt;string&gt;", "exec")
&lt;code object &lt;module&gt; at 0xb71b4d90, file "&lt;string&gt;", line 1&gt;
</code></pre>
<p>Clearly <code>test</code> can't force compile to use ast.Name as the root of the AST.</p>
<p>Next I attempt using the modules <code>ast</code> and <code>parser</code>. These modules are intended to derive a string, rather than determining if a string matches a particular derivation, but I figure they might be helpful anyway.</p>
<p>II. module <a href="https://docs.python.org/dev/library/ast.html" rel="nofollow">ast</a></p>
<pre><code>&gt;&gt;&gt; a=ast.Module(body=[ast.Expr(value=ast.Name(id='1a', ctx=ast.Load()))])
&gt;&gt;&gt; af = ast.fix_missing_locations(a)
&gt;&gt;&gt; c = compile(af, "&lt;string&gt;", "exec")
&gt;&gt;&gt; exec(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name '1a' is not defined
</code></pre>
<p>OK, clearly Name isn't parsing '1a' for correctness. Perhaps this step happens earlier, in the parse phase.</p>
<p>III. module <a href="https://docs.python.org/dev/library/parser.html" rel="nofollow">parser</a></p>
<pre><code>&gt;&gt;&gt; p = parser.suite("a")
&gt;&gt;&gt; t = parser.st2tuple(p)
&gt;&gt;&gt; t
(257, (268, (269, (270, (271, (272, (302, (306, (307, (308, (309, (312, (313, (314, (315, (316, (317, (318, (319, (320, (1, 'a')))))))))))))))))), (4, ''))), (4, ''), (0, ''))
&gt;&gt;&gt; 
&gt;&gt;&gt; t = (257, (268, (269, (270, (271, (272, (302, (306, (307, (308, (309, (312, (313, (314, (315, (316, (317, (318, (319, (320, (1, '1a')))))))))))))))))), (4, ''))), (4, ''), (0, ''))
&gt;&gt;&gt; p = parser.sequence2st(t)
&gt;&gt;&gt; c = parser.compilest(p)
&gt;&gt;&gt; exec(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;syntax-tree&gt;", line 0, in &lt;module&gt;
NameError: name '1a' is not defined
</code></pre>
<p>OK, still not being checked... why? Quick check of python's <a href="https://docs.python.org/dev/reference/grammar.html" rel="nofollow">full grammar specification</a> shows that NAME is not defined. If these checks are performed by the bytecode compiler, shouldn't <code>1a</code> have been caught?</p>
<p>I'm starting to suspect python exposes no functionality towards this goal. I'm also curious why some attempts failed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to parse, just <a href="https://docs.python.org/3/library/tokenize.html" rel="nofollow">tokenize</a>, and -- if you care -- test if the returned <code>NAME</code> is a keyword</p>
<p>Example, partly adapted from the linked documentation:</p>
<pre><code>&gt;&gt;&gt; import tokenize
&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from keyword import iskeyword
&gt;&gt;&gt; s = "def twoπ(a,b):"
&gt;&gt;&gt; g = tokenize.tokenize(BytesIO(s.encode("utf-8")).readline)
&gt;&gt;&gt; for toktype, tokval, st, end, _ in g:
...   if toktype == tokenize.NAME and iskeyword(tokval):
...     print ("KEYWORD ", tokval)
...   else:
...     print(toktype, tokval)
... 
56 utf-8
KEYWORD  def
1 twoπ
52 (
1 a
52 ,
1 b
52 )
52 :
0 
</code></pre>
<p>You'll always get an ENCODING (56) token at the beginning of the input, and an ENDMARKER (0) at the end.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure where you were going with your <code>compile</code> example, but if you <code>compile</code> <em>just</em> the potential identifer for <code>eval</code>, it exposes what is going on.</p>
<pre><code>&gt;&gt;&gt; dis(compile("1", "&lt;string&gt;", "eval"))

  1           0 LOAD_CONST               0 (1)
              3 RETURN_VALUE

&gt;&gt;&gt; dis(compile("a", "&lt;string&gt;", "eval"))

  1           0 LOAD_NAME                0 (a)
              3 RETURN_VALUE

&gt;&gt;&gt; dis(compile("1a", "&lt;string&gt;", "eval"))

  File "&lt;string&gt;", line 1
    1a
     ^
SyntaxError: unexpected EOF while parsing

&gt;&gt;&gt; dis(compile("你好", "&lt;string&gt;", "eval"))

  1           0 LOAD_NAME                0 (你好)
              3 RETURN_VALUE
</code></pre>
<p>It would require more testing before using for real (for edge cases), but getting a <code>LOAD_NAME</code> opcode back is indicative. Failure states can include both an exception and getting a different opcode so you have to check for both.</p>
</div>
<span class="comment-copy">This is a nice approach but it appears you need to add a check for reserved words separately using <code>keyword.iskeyword</code> as <code>def</code>, <code>for</code>, etc tokenize as <code>NAME</code>. Not sure if there are other edge cases.</span>
<span class="comment-copy">Good point. If you care about keywords, you have to test that. I'll edit the answer.</span>
<span class="comment-copy">I agree, this is a good approach which also explains why neither <code>ast</code> nor <code>parser</code> worked - identifiers are tokenized and validated before parsing. I find this surprising: python's lexer must encode some state/grammar in order to discriminate valid input, something normally relegated to parsers. Anyway while the <code>tokenize</code> module doesn't expose python internals (unlike <code>ast</code> and <code>parser</code> it reimplements the tokenizer in pure python), it is certainly a more stable approach than using the <code>dis</code> module, which carries a big fat warning: "[No guarantees]..[bytecode varies across VMs and releases]"</span>
<span class="comment-copy">The compile example attempts to validate <code>string</code> as an identifier by enforcing a subtree of python's grammar through assignment. The example also demonstrates how futile this approach is: suffers from something akin to code injection. You example does the same by ensuring the bytecode matches a certain pattern. While a good idea, unfortunately the <code>dis</code> interface is too unstable for my taste.</span>
<span class="comment-copy"><code>dis</code> is just to show you - you would use <code>co_code</code> and <code>opcodes</code> to find whether <code>LOAD_NAME</code> is present.</span>
<span class="comment-copy">Although, a string like <code>(a)</code> could still be a problem, so never mind.</span>
