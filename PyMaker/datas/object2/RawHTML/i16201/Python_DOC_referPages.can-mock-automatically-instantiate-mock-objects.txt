<div class="post-text" itemprop="text">
<p>I'm writing tests for the class <code>OnlineService</code> which instantiates a class of type <code>api.API</code>, which in turn instantiates a class of type <code>api.Resource</code>. The method I'm testing in this example is <code>initialize</code> which tests connectivity with the remote service, by issuing a <code>GET</code> request to a <code>Ping</code> resource in the remote API.</p>
<p>I'm currently patching these objects to be mocks using the following code, but it still looks a bit verbose to me.</p>
<pre><code>@patch('api.Resource')
@patch('api.API')
def test_initialize(self, api_mock, resource_mock):
    api_instance = api_mock.return_value
    api_instance.Ping = resource_mock.return_value # is this step really necessary?
    api_instance.Ping.get.side_effect = [None, HTTPError()]

    service = OnlineService()

    service.initialize()
    assert service.connected is True

    service.initialize()
    assert service.connected is False
</code></pre>
<p>Do I really have to assign a <code>Resource</code> mock instance to the property of another mock instance manually? Perhaps there is some feature in the <code>mock</code> package that can do this for me?</p>
<p><strong>UPDATE</strong></p>
<p>I've split up the test in two and also attached the relevant code from the <code>OnlineService</code> that is under test. Here is the <code>OnlineService</code> class:</p>
<pre><code>class OnlineService(object):
    def __init__(self):
        self.webservice_url = u''
        self.verify_ssl = True
        self.connected = False

    def initialize(self, webservice_url, verify_ssl, connectivity_check_timeout):
        self.webservice_url = webservice_url
        self.verify_ssl = verify_ssl
        self.connected = self.can_connect_to_api(connectivity_check_timeout)

    def can_connect_to_api(self, connectivity_check_timeout):
        api_instance = api.API(url=self.webservice_url, verify_ssl=self.verify_ssl, timeout=connectivity_check_timeout)
        try:
            # api_instance.Ping of type api.Resource was instantiated in api.API()
            api_instance.Ping.get()
            return True
        except:
            return False
</code></pre>
<p>And here is the test code:</p>
<pre><code>def test_initialize(self):
    service = OnlineService()
    service.can_connect_to_api = MagicMock(return_value=True)

    service.initialize(u'some_url', False, 3.42)

    service.can_connect_to_api.assert_called_once_with(3.42)
    assert service.webservice_url is u'some_url'
    assert service.verify_ssl is False
    assert service.connected is True

@patch('api.Resource')
@patch('api.API')
def test_can_connect_to_api(self, api_mock, resource_mock):
    api_instance = api_mock.return_value
    api_instance.Ping = resource_mock.return_value # is this step really necessary?
    api_instance.Ping.get.side_effect = [None, HTTPError()]

    service = OnlineService()

    connected = service.can_connect_to_api(5.0)
    assert connected is True

    connected = service.can_connect_to_api(5.0)
    assert connected is False
</code></pre>
<p>Currently the test passes if I run it. Commenting out the line we're discussing gives me the following failure in <code>test_can_connect_to_api</code>:</p>
<pre><code>======================================================================
FAIL: Services.tests.test_OnlineService.TestOnlineService.test_can_connect_to_api
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Development\Projects\app\venv\lib\site-packages\nose\case.py", line 197, in runTest
    self.test(*self.arg)
  File "C:\Development\Projects\app\venv\lib\site-packages\mock.py", line 1201, in patched
    return func(*args, **keywargs)
  File "C:\Development\Projects\app\src\Services\tests\test_OnlineService.py", line 47, in test_can_connect_to_api
    assert connected is False
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.013s

FAILED (failures=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The line:</p>
<pre><code>api_instance.Ping = resource_mock.return_value # is this step really necessary?
</code></pre>
<p>assigns a new empty <code>MagicMock</code> instance to <code>api_instance.Ping</code>. However, accessing <code>Ping</code> without that assignment <em>already</em> does this because <code>api_instance</code> is itself a <code>MagicMock</code> object; the line is entirely redundant:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; api_instance = MagicMock()
&gt;&gt;&gt; api_instance.Ping
&lt;MagicMock name='mock.Ping' id='4515362016'&gt;
</code></pre>
<p>As such, the following would suffice:</p>
<pre><code>@patch('api.API')
def test_initialize(self, api_mock):
    api_instance = api_mock.return_value
    api_instance.Ping.get.side_effect = [None, HTTPError()]
</code></pre>
<p>Of course, if the code-under-test is <em>not</em> using <code>api.API().Ping.get</code> to obtain the resource, then the above code would not achieve its goal; but then you won't need to alter <code>api_instance.Ping</code> <em>either</em>.</p>
<p>The thing to remember here is that you <em>replaced <code>api.API</code></em>; what that class original does is no longer of concern to you. All you need to do is manage the expectation of the code <em>using</em> <code>api.API</code>; if it uses <code>api.API()</code> and uses attributes or methods on that object, mock those out. If <code>api.Resource</code> is not directly used by the code-under-test, leave it out of your tests too.</p>
<p>Your added code shows that you are <em>mocking the wrong object</em> however. You mocked <code>api.Resource</code> correctly, but theh <code>API()</code> object in the CUT is <strong>not a mock</strong>. See the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow"><em>Where to patch</em> section</a> of the <code>unittest.mock</code> documentation. Your CUT uses a global name <code>API</code>; it does <strong>not</strong> reference <code>api.API</code>. Mock <em>that global</em>:</p>
<pre><code>@patch('module_under_test.API')
def test_initialize(self, api_mock):
    api_instance = api_mock.return_value
    api_instance.Ping.get.side_effect = [None, HTTPError()]
</code></pre>
<p>or you could just have mocked out <em>just</em> the <code>Ping</code> resource; evidently that is what your unmocked <code>API()</code> class uses, after all:</p>
<pre><code>@patch('api.Resource')
def test_can_connect_to_api(self, resource_mock):
    # API().Ping is an instance of api.Resource; mocking that also works
    resource_mock.return_value.get.side_effect = [None, HTTPError()]
</code></pre>
</div>
<span class="comment-copy">Please don't put 'SOLVED' sections in your question; that's what the accept mark is for. :-)</span>
<span class="comment-copy">But the exact code you used <b>doesn't matter</b> to future visitors. It is the <i>concepts</i> that matter here; my answer told you how to solve your specific problem, because I explained how the mechanics work.</span>
<span class="comment-copy">If future visitors cannot work out that <code>@patch('module_under_test.API')</code> is the solution here because I didn't use the exact module name your code used, then they won't be able to figure that out with your now-working code either.</span>
<span class="comment-copy">The CUT instantiates <code>api.API</code> (which implicitly instantiates a bunch of <code>api.Resource</code> objects, of which <code>Ping</code> is one) and then calls <code>get</code> on the <code>Resource</code> instance <code>Ping</code>. So I can't leave it out of the test.  More importantly, since <code>Ping</code> is instantiated by <code>api.API</code>'s constructor, the line doesn't seem redundant to me, since <code>MagicMock</code> won't instantiate <code>Ping</code> for me. Is there some trick I can use for this? Or should I leave the method as is?</span>
<span class="comment-copy">@Korijn: but it <i>is</i>; <code>api.API()</code> is now a mock. Whatever the original did, that <i>doesn't happen anymore nor does it matter</i>. What does the code in the CUT <i>look like</i> when it uses <code>Ping.get</code>?</span>
<span class="comment-copy">@Korijn: You are mocking the <b>wrong <code>API</code> object</b>. You need to mock <code>module_under_test.API</code>, not <code>api.API</code>.</span>
<span class="comment-copy">@Korijn: because you did not mock the correct <code>API</code> object, your <i>original API class</i> is now using the mocked <code>api.Resource</code> object. The line is still redundant; so is the use of <code>api_mock</code> in that case.</span>
<span class="comment-copy">@Korijn: For unittests I'd mock <code>API()</code> as that is the boundary between the CUT and the outside world. This is not an integration test between the CUT and the API object, after all.</span>
