<div class="post-text" itemprop="text">
<p>What is the most efficient way to find consecutively repeating strings in a Python list?  </p>
<p>For example, suppose I have the list
<code>["a", "a", "b", "c", "b","b","b"]</code>.  I want an output of something like: <code>["group of 2 a's found at index 0, group of 3 b's found at index 4']</code>.</p>
<p>Is there a built in function to accomplish this task?  I did find <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html" rel="nofollow"><code>numpy.bincount</code></a>, but that seems to only work on numeric values.</p>
<p>Thanks in advance for the help.</p>
</div>
<div class="post-text" itemprop="text">
<p>It’s funny that you should call it a group, because the function probably best-suited to this is <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; items = ["a", "a", "b", "c", "b", "b", "b"]
&gt;&gt;&gt; [(k, sum(1 for _ in vs)) for k, vs in itertools.groupby(items)]
[('a', 2), ('b', 1), ('c', 1), ('b', 3)]
</code></pre>
<p>(<code>sum(1 for _ in vs)</code> is a count, by the way, since <code>len</code> doesn’t work on just any iterable, and <code>len(list(…))</code> is wasteful.)</p>
<p>Getting the index is a little more complicated; I’d just do it using a loop.</p>
<pre><code>import itertools

def group_with_index(l):
    i = 0

    for k, vs in itertools.groupby(l):
        c = sum(1 for _ in vs)
        yield (k, c, i)
        i += c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This requires state information between elements of the loop so its not easy to do with a list comprehension. Instead you can keep track of last value in a loop:</p>
<pre><code>groups = []
for i, val in enumerate(["a", "a", "b", "c", "b","b","b"]):
    if i == 0:
         cnt = 1
         loc = i
         last_val = val
    elif val == last_val:
         cnt += 1
    else:
         groups.append((cnt, last_val, loc))
         cnt = 1
         loc = i
         last_val = val

for group in groups:
     print("group of {0} {1}'s found at index {2}".format(*group)
</code></pre>
<p>Output:</p>
<pre><code>group of 2 a's found at index 0
group of 1 b's found at index 2
group of 1 c's found at index 3
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2161752/how-to-count-the-frequency-of-the-elements-in-a-list">How to count the frequency of the elements in a list?</a></span>
<span class="comment-copy">Only consecutive repeated elements? Not just anywhere?</span>
<span class="comment-copy">Yes, only consecutive repetitions.  <b>alfasin</b>, I did see that thread, but the solutions seemed to count all repetitions, not just consecutive ones.</span>
<span class="comment-copy">I don't think this gives you only consecutive repetitions, does it?</span>
<span class="comment-copy">@PatrickCollins: It does! That’s why you generally pass something sorted to <code>groupby</code>. (See the example output, too.)</span>
<span class="comment-copy">I stand corrected, +1</span>
<span class="comment-copy">Is there a quick way to get the indices of the consecutive blocks, as in my post?  I suppose that shouldn't be too hard to write myself, but I'd prefer to use the (more efficient) built-in method, if it exists!</span>
<span class="comment-copy">@Pythontology: Hm… I’ve been trying a few things, and there doesn’t seem to be an efficient way that’s simpler than a loop.</span>
<span class="comment-copy">Thanks for your help!</span>
