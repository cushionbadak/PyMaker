<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects" rel="nofollow">Python docs</a> mentions the following about names being aliases to objects:</p>
<blockquote>
<p>Objects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the implementation; and if a function modifies an object passed as an argument, the caller will see the change â€” this eliminates the need for two different argument passing mechanisms as in Pascal.</p>
</blockquote>
<p>In some other high-level languages it is often the case that primitive types are special-cased, and are copied instead of referenced, for performance reasons. For example, in Java:</p>
<pre class="lang-java prettyprint-override"><code>int a = 20000;
int b = a;
</code></pre>
<p>The code above will copy the value <code>20000</code>, instead of the pointer to the value <code>20000</code>. In this case, <code>a</code> and <code>b</code> will likely occupy different locations in memory. Due to special-casing on <code>==</code> to test for equality instead of identity for primitive types only, I don't believe this behaviour can be introspected in normal code, however.</p>
<p>On the other hand, limited testing with types such as <code>int</code> and <code>str</code> in Python 3 shows that indeed, the pointers are copied rather than the values, as specified in the documentation:</p>
<pre class="lang-py prettyprint-override"><code>a = 20000
b = a
a is b # True
</code></pre>
<p>This is a very nice property that makes the language very consistent, as there is no special-casing for primitive types. All assignments reassign a name to another object. However, for performance reasons, might it be possible for a Python interpreter to special-case types like <code>int</code>?</p>
<p>Hence, my question is: Is this property for primitive types guaranteed? In other words, is it always true that after <code>b = a</code>, the comparison <code>a is b</code> will be <code>True</code>, no matter the Python interpreter used?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is specified in <a href="https://docs.python.org/2/reference/simple_stmts.html#assignment-statements" rel="nofollow">the documentation</a>:</p>
<blockquote>
<p>If the target is an identifier (name):</p>
<p>If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.</p>
<p>Otherwise: the name is bound to the object in the current global namespace.</p>
</blockquote>
<p>(In Python 3 there is an additional case related to <code>nonlocal</code>, but the rule is the same; the only difference is what namespace the binding takes place in.)</p>
<p>Note, crucially, that this only applies when assigning to a <strong>bare name</strong>.  If the assignment is something like <code>a.foo = b</code> or <code>a[blah] = b</code>, all bets are off and just about anything can happen.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>b = a</code> make the names <code>b</code> and <code>a</code> reference the exact same object. So yes, in Python, <code>a is b</code> will then always be True.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; int
&lt;class 'int'&gt;
</code></pre>
<p>Python doesn't use primitive types in the same way as Java. As you see here, <code>int</code> is a class. Instances of this class are <em>objects</em> with all that means. It just so happens that this is a builtin class rather than one defined in a <code>.py</code> file somewhere.</p>
<p>Think about the Java behavior of <code>Integer</code> vs <code>int</code>.</p>
<p>When you do <code>a = 1; b = a</code> you are setting <code>b</code> to a reference to the same object that <code>a</code> refers to, so it doesn't copy the value.</p>
<p>As far as special casing, CPython does make "small" integers (from -5 to 255) into singletons so they do not have to be recreated, but this is an implementation detail.</p>
</div>
<div class="post-text" itemprop="text">
<p>All variables and expressions in Python are references (semantically equivalent to pointers to objects). If you are familiar with a C++, it is like the following:</p>
<pre><code>object *a = new object(20000);
object *b = a;
a == b // true
</code></pre>
<p>Assigning one variable to another will copy the value, a pointer. After the assignment the two pointers will always point to the same object.</p>
</div>
<span class="comment-copy">"Guaranteed across interpreters" can be a tricky thing in Python, given that many subtler aspects of the language are underspecified. (I am not sure if this is one of them, probably not.)</span>
<span class="comment-copy">Name-object binding is not a subtle aspect of Python implementation, rather a fundamental principle of the language.</span>
<span class="comment-copy">"The code above will copy the value 20000, instead of the pointer to the value 20000." But there is semantically no difference between the two. "In this case, a and b will likely occupy different locations in memory." And so will if <code>a</code> and <code>b</code> are the reference type <code>Integer</code> -- the variables <code>a</code> and <code>b</code>, which are references (pointers) occupy different places in the memory; they just point to the same object. The same thing happens in Python; the variables <code>a</code> and <code>b</code> occupy different places in memory; they just point to the same object.</span>
<span class="comment-copy">Thank you! This was exactly what I was looking for.</span>
