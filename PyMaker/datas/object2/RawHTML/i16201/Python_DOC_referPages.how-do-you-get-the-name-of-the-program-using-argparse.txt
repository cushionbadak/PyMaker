<div class="post-text" itemprop="text">
<p>I am using <code>argparse</code> to parse command line arguments. While going through the documentation for <a href="https://docs.python.org/3/library/argparse.html#module-argparse" rel="noreferrer"><code>argparse</code></a> I could only see a provision to use a different program name. </p>
<p>I want to be able to use the default program name without having to import <code>sys</code>. There is nothing in <code>argparse</code>, as far as I can see, that will return the program name.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
args = parser.parse_args()

print(dir(args))
</code></pre>
<p>And here's the output:</p>
<p><code>['__class__', '__contains__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_get_args', '_get_kwargs']</code></p>
<p>Is there any other way of retrieving the program name without having to import the <code>sys</code> module?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ArgumentParser</code>instances have a<code>prog</code>attribute which I think is what you want.</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
print('parser.prog: {}'.format(parser.prog))
</code></pre>
<p>I discovered this by reading the module's source code in <a href="https://hg.python.org/cpython/file/default/Lib/argparse.py" rel="nofollow noreferrer"><code>Lib/argparse.py</code></a>â€”specifically looking at the <code>class ArgumentParser</code> <a href="https://hg.python.org/cpython/file/default/Lib/argparse.py#l1581" rel="nofollow noreferrer">definition</a>. Since the attribute's name doesn't start with an underscore character, I assume it's public.</p>
<p><strong><em>Update</em></strong></p>
<p>I see that, nowadays at least, that the <code>prog</code> attribute of <code>ArgumentParser</code> instance <em>is</em> (or has been since this question was asked) documented in both <a href="https://docs.python.org/2/library/argparse.html#argumentparser-objects" rel="nofollow noreferrer">Python 2's documentation</a> and <a href="https://docs.python.org/3/library/argparse.html#argumentparser-objects" rel="nofollow noreferrer">Python 3's documentation</a>. </p>
<p>So, yes, it's definitely public, and in both versions, if it is not supplied as a keyword argument when creating the <code>ArgumentParser</code>, it defaults to <code>prog = _os.path.basename(_sys.argv[0])</code> (where <code>_os</code> and <code>_sys</code> are private <code>argparse</code> module attributes that correspond to their non-underscore-prefixed counterparts. Note that because of the use of <code>os.basename()</code>, this will only be the script's filename, not the complete path to it that <em>may</em> (it's OS dependent) have been in <code>sys.argv[0]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course the correct way would be:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.argv[0]
    scripts/script.py
</code></pre>
<p>But let's assume for a moment you have a good reason that prevents you to <code>import sys</code> but allows you to <code>import argparse</code>.</p>
<p><a href="https://stackoverflow.com/users/355230/martineau">martineau</a> has done a wonderful job discovering <code>prog</code>, let's try it:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; print parser.prog
    script.py
</code></pre>
<p>As noted by <a href="https://stackoverflow.com/users/901925/hpaulj">hpaulj</a>, this only has the filename and not the full path like <code>sys.argv[0]</code> because the module <a href="http://hg.python.org/cpython/file/71cb8f605f77/Lib/argparse.py" rel="noreferrer"><code>argparse.py</code></a> is using <code>prog = os.path.basename(sys.argv[0])</code>.</p>
<p>But <code>argparse</code> must use <code>sys</code>, so it needs to be accessible in <code>argparse</code> namespace. Let's check it:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; print argparse.__dict__
    { ..., '_sys': &lt;module 'sys' (built-in)&gt;, ... }
</code></pre>
<p>Here it is! Let's try to use <code>_sys</code>:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; print argparse._sys.argv[0]
    scripts/script.py
</code></pre>
<p>You are using <code>sys</code>! Of course, but I haven't imported it, only <code>argparse</code>, that was the question!</p>
<p>Of course this has a number of contraindications:</p>
<ul>
<li>You should not use variables prefixed by <code>_</code> or <code>__</code> of other namespaces, they are used <a href="https://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">internally</a>.</li>
<li>You should not rely on imports of other modules, they may change.</li>
<li>You should not rely on undocumented api, they may change.</li>
</ul>
<h3>tl;dr</h3>
<p>This was fun, but just stick to <code>import sys</code> until <code>argparse</code> releases an api to access <code>sys.argv[0]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>%(prog)</code> from inside <code>argparse</code> help texts</strong></p>
<p>This is a common use case when you want to give an example of how to use the command within the help itself.</p>
<p>main.py</p>
<pre><code>#!/usr/bin/env python3
import argparse
parser = argparse.ArgumentParser(
        description="Do something cool. My name is: %(prog)s",
    epilog="""
This is how you do it:

    %(prog)s yourarg
""",
    formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument('somearg', help='also works here: %(prog)s')
args = parser.parse_args()
</code></pre>
<p>Then:</p>
<pre><code>./main.py -h
</code></pre>
<p>gives:</p>
<pre><code>./main.py -h
usage: main.py [-h] somearg

Do something cool. My name is: main.py

positional arguments:
  somearg     also works here: main.py

optional arguments:
  -h, --help  show this help message and exit

This is how you do it:

    main.py yourarg
</code></pre>
<p>One advantage over <code>sys.argv[0]</code> is that the message stays unchanged no matter where you call it from:</p>
<pre><code>cd ..
./mydir/main.py
</code></pre>
<p>Documented at: <a href="https://docs.python.org/3/library/argparse.html#prog" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#prog</a></p>
<blockquote>
<p>Note that the program name, whether determined from <code>sys.argv[0]</code> or from the <code>prog=</code> argument, is available to help messages using the <code>%(prog)s</code> format specifier.</p>
</blockquote>
<p>Tested on Python 3.5.2.</p>
</div>
<span class="comment-copy">Why don't you want to import sys in this case? If you wanted, you could just import argv. <code>from sys import argv</code>.</span>
<span class="comment-copy">Was I wrong to assume that argparse is meant to be a module that is a wrapper over sys.argv[]? Since argparse parses all the command line arguments, should it not have had the program name as well for cleaner code? Imho, it looks rather odd when sys.argv[0] suddenly butts into the code when it's argparse everywhere else.</span>
<span class="comment-copy"><code>argparse</code> imports <code>sys</code> as <code>_sys</code>.  So in theory you could use: <code>argparse._sys.argv[0]</code>.  Note also that <code>argparse</code> gets the command line strings (that it parses) from <code>_sys.argv[1:]</code>.</span>
<span class="comment-copy">See also: <a href="https://stackoverflow.com/a/17406225/1959808">stackoverflow.com/a/17406225/1959808</a></span>
<span class="comment-copy">What it uses, if <code>prog</code> isn't given as an parameter is <code>prog = os.path.basename(sys.argv[0])</code>.</span>
<span class="comment-copy">Thanks for all the details! I accepted @martineau's answer, though, because it directly answers my question.</span>
