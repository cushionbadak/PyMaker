<div class="post-text" itemprop="text">
<p>I'm trying to deliver work when a page is appended to the pages list, but my code output returns a NotImplementedError. Here is the code with what I'm trying to do:</p>
<p><strong>Code:</strong></p>
<pre><code>from multiprocessing import Pool, current_process
import time
import random
import copy_reg
import types
import threading


class PageControler(object):
    def __init__(self):
        self.nProcess = 3
        self.pages = [1,2,3,4,5,6,7,8,9,10]
        self.manageWork()


    def manageWork(self):

        self.pool = Pool(processes=self.nProcess)

        time.sleep(2)
        work_queue = threading.Thread(target=self.modifyQueue)
        work_queue.start()

        #pool.close()
        #pool.join()

    def deliverWork(self):    
        if self.pages != []:
            pag = self.pages.pop()
            self.pool.apply_async(self.myFun)


    def modifyQueue(self):
        t = time.time()
        while (time.time()-t) &lt; 10:
            time.sleep(1)
            self.pages.append(99)
            print self.pages
            self.deliverWork()

    def myFun(self):
        time.sleep(2)


if __name__ == '__main__':
    def _pickle_method(m):
        if m.im_self is None:
            return getattr, (m.im_class, m.im_func.func_name)
        else:
            return getattr, (m.im_self, m.im_func.func_name)

    copy_reg.pickle(types.MethodType, _pickle_method)

    PageControler()
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>NotImplementedError: pool objects cannot be passed between processes or pickled
</code></pre>
<p>It's any way to pass the pool object between the processes ?</p>
<p><strong>Edit:</strong></p>
<p>I'm using Python 2.6 </p>
</div>
<div class="post-text" itemprop="text">
<p>In order to pickle the instance method you're trying to pass to the <code>Pool</code>, Python needs to pickle the entire <code>PageControler</code> object, including its instance variables. One of those instance variables is the <code>Pool</code> object itself, and <code>Pool</code> objects can't be pickled, hence the error. You can work around this by implementing <a href="https://docs.python.org/2.7/library/pickle.html#object.__getstate__" rel="noreferrer"><code>__getstate__</code></a> on the object, and using that to remove the <code>pool</code> object from the instance prior to pickling:</p>
<pre><code>class PageControler(object):
    def __init__(self):
        self.nProcess = 3
        self.pages = [1,2,3,4,5,6,7,8,9,10]
        self.manageWork()


    def manageWork(self):

        self.pool = Pool(processes=self.nProcess)

        time.sleep(2)
        work_queue = threading.Thread(target=self.modifyQueue)
        work_queue.start()

        #pool.close()
        #pool.join()

    def deliverWork(self):    
        if self.pages != []:
            pag = self.pages.pop()
            self.pool.apply_async(self.myFun)


    def modifyQueue(self):
        t = time.time()
        while (time.time()-t) &lt; 10:
            time.sleep(1)
            self.pages.append(99)
            print self.pages
            self.deliverWork()

    def myFun(self):
        time.sleep(2)

    def __getstate__(self):
        self_dict = self.__dict__.copy()
        del self_dict['pool']
        return self_dict

    def __setstate__(self, state):
        self.__dict__.update(state)
</code></pre>
<p><code>__getstate__</code> is always called prior to pickling an object, and allow you to specify exactly which pieces of the object's state should actually be pickled. Then upon unpickling, <a href="https://docs.python.org/2.7/library/pickle.html#object.__setstate__" rel="noreferrer"><code>__setstate__(state)</code></a> will be called if its implemented (it is in our case), or if it's not, the <code>dict</code> returned by <code>__getstate__</code> will be used as the <code>__dict__</code> for the unpickled instance. In the above example, we're explicitly setting <code>__dict__</code> to the <code>dict</code> we returned in <code>__getstate__</code>, but we could have just not implemented <code>__setstate__</code> and gotten the same effect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dano's answer is a good approach if you must pass the entire object to the process. In your case, the function you are passing to pool has no requirement for a reference to the class instance. So an alternative may be to make the function a static method using the <code>@staticmethod</code> decorator. If the function does require reference to one or two class member variables these could be passed in as arguments for read only variables, and updated in a callback if a write is required also (of course, you will need to do this if you want to update the local class instance in any case).</p>
<p>For example:</p>
<pre><code>Class A(object):

    def __init__(self):
        self._pool = multiprocessing.Pool(1)
        self.member_variable = 1

    @staticmethod
    def MyFunc(variable):
        variable += 1
        return variable

    def Callback(self, return_val):
        self.member_variable = return_val

    def CallFuncAsync(self):
        pool.apply_async(self.MyFunc, (self.member_variable,), callback=self.Callback)
</code></pre>
</div>
<span class="comment-copy">python 2.7, I suppose?</span>
<span class="comment-copy">Python 2.6, but I've been reading and python 2.7 have the same problem.</span>
<span class="comment-copy">Thanks for your help, again!</span>
<span class="comment-copy">This is a very nice answer and helped solve my issue. It led me to this in Python3, which may be useful to others: <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer">docs.python.org/3/library/pickle.html#object.__getstate__</a></span>
<span class="comment-copy">This is awesome! You rock @dano! Thanks</span>
<span class="comment-copy">Wow, what a good answer.  I now understand what's been happening for the last two hours.  Thanks @dano</span>
<span class="comment-copy">man... what a great answer</span>
