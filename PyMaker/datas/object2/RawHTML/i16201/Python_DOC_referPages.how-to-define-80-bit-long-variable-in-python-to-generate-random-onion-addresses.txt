<div class="post-text" itemprop="text">
<p>I'm trying to implement some random generator of <a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network)" rel="nofollow noreferrer">Tor</a> <a href="https://en.wikipedia.org/wiki/.onion" rel="nofollow noreferrer">.onion</a> addresses which involves generation of 80-bit numbers to create 16-character hashes.</p>
<p>How do I define such variable in Python?</p>
<p><a href="https://en.wikipedia.org/wiki/.onion#Format" rel="nofollow noreferrer">.onion format</a>:</p>
<blockquote>
<p>"16-character hashes can be made up of any letter of the alphabet, and
  decimal digits beginning with 2 and ending with 7, thus representing
  an 80-bit number in base32."</p>
</blockquote>
<p>Links:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/9849764/manipulating-80-bits-datatype-in-c">Manipulating 80 bits datatype in C</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You want this one-liner if you are on Python3</p>
<pre><code>import base64
import codecs
import random

data = base64.b32encode(
    codecs.decode(codecs.encode(
        '{0:020x}'.format(random.getrandbits(80))
    ), 'hex_codec')
)
</code></pre>
<p>Explanation: You grab your 80 random bits using <a href="https://docs.python.org/library/random.html#random.getrandbits" rel="nofollow"><code>random.getrandbits</code></a>, encode it into binary form (which you kind of have to go through the process by going through the hex encoding, then use the <a href="https://docs.python.org/library/base64.html#base64.b32encode" rel="nofollow"><code>base64.b32encode</code></a> function, which provides the <a href="http://tools.ietf.org/html/rfc3548.html" rel="nofollow">RFC 3548</a> compliant method of encoding this into your target encoding of base32.</p>
<p>Works for Python 2 also.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a sequence of 10 bytes encoding an 80 bit random  number like this:</p>
<pre><code>import struct
import random

number = random.randint(0, 2**80)
data = struct.pack("qH", number &gt;&gt; 16, number &amp; 16)
</code></pre>
<p><strong>update</strong></p>
<p>Sorry, teh above part does not take care about the encoding of the key in Base32 - 
without resorting to Python's string codecs (see metatoaster's answer for that) a compact and readable form is:</p>
<pre><code>import string
import random

digits = string.lowercase + "234567"

res = ""
n = random.randrange(2**80)
for _ in range(16):
    res += digits[n &amp; 0b11111]
    n &gt;&gt;= 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you actually need the alphanumeric representation of the 80-bit hash, just select the base-32 digits directly.</p>
<pre><code>digits = "abcdefghijklmnopqrstuvwxyz234567"
address = "".join(random.choice(digits) for _ in range(16))
</code></pre>
<p>I found a 15% speed-up by avoiding repeated name lookups for <code>random.choice</code> and by using a list comprehension rather than passing a generator to <code>"".join</code>.</p>
<pre><code>from random import choice
digits = "abcdefghijklmnopqrstuvwxyz234567"
address = "".join([choice(digits) for _ in range(16)])
</code></pre>
</div>
<span class="comment-copy">Shouldn't a long (python 2) or an int (python 3) just work straight out?</span>
<span class="comment-copy">How do I know they're 80-bit long and they won't overflow?</span>
<span class="comment-copy"><code>random.getrandbits(80)</code></span>
<span class="comment-copy">@kenorb - Because they're defined that way in python.</span>
<span class="comment-copy">Python 3.3: <code>LookupError: unknown encoding: hex</code>. It should be <a href="https://docs.python.org/3/library/codecs.html#binary-transforms" rel="nofollow noreferrer"><code>hex_codec</code></a>.</span>
<span class="comment-copy">Oh, I tested this in python3.4 which was installed on my system.  Confirmed not to work on python3.2 either. Thanks for that @Matthias.</span>
<span class="comment-copy">Works for me on Python 2.7.5 &amp; 3.4.1 (OSX). Code: <code>import random,base64,codecs; base64.b32encode(codecs.decode(codecs.encode('{0:020x}'.format(random.getrandbits(80))),'hex_codec')).lower();</code>.</span>
<span class="comment-copy">Or just use <code>struct.pack("10B", number)</code>. This avoids worrying about what endianess is used for the multi-byte values.</span>
<span class="comment-copy">This raises <code>struct.error: argument out of range</code> if the number is "not clean", such as <code>658690783642833129621763</code>.</span>
<span class="comment-copy">This looks clean but takes about 110% the time of my solution according to <code>timeit</code>, but I don't think it matters in a one-off call.</span>
<span class="comment-copy">How much of the 10% can we shave off if you save a reference to <code>random.choice</code> first? :)  ( <code>rc=random.choice; "".join(rc(digits) for _ in range(16)</code>)</span>
<span class="comment-copy">There is also a little bit of speed up if you use a list comprehension rather than a generator as the argument to <code>"".join</code>. (Paradoxical, but it's because <code>"".join</code> has to build a list anyway in order to compute how much space to allocate for the result.)</span>
