<div class="post-text" itemprop="text">
<p>Say we have a list:</p>
<pre><code>X = [1,2,3,4,5,6,7,8]
</code></pre>
<p>and we have created a function called add():</p>
<pre><code>def add():
  sum = 0
  result = 0
  for e in X:
    sum = sum + e
    return sum
add()
</code></pre>
<p>which runs through a list of numbers X, adding the next element in the list to the previous sum. So for each element X[i], we have:</p>
<pre><code>1
3
6
10
15
21
28
36
45
</code></pre>
<p>Now, what if I want to put these results in a list again, by making use of a list comprehension. Is it possible to call a function such as add() within a list comprehension,
given that it is possible to apply built in functions inside list comprehensions?</p>
<p>I have tried the following:</p>
<pre><code>L = [add() for e in X]
print L
</code></pre>
<p>which gives</p>
<pre><code>[None, None, None, None, None, None, None, None, None]
</code></pre>
<p>instead of</p>
<pre><code>[1,3,6,10,15,21,28,36,45]
</code></pre>
<p>Why am I getting NoneType values in this list?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do this with <code>yield</code> to keep with your original format:</p>
<pre><code>    X = [1,2,3,4,5,6,7,8]

    def add():
      sum = 0
      for e in X:
        sum = sum + e
        yield sum

    L = [value for value in add()]
    print L
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is possible to call functions inside list comprehensions. Your example is fine - it's the <code>add()</code> function that is to be blamed.
What you need is make the <code>add()</code> function receive an argument - the list to sum.</p>
<pre><code>def add(elements):
    sum = 0
    for el in elements:
        sum += el
    return sum
</code></pre>
<p>This way, the list comprehension would look like this:</p>
<pre><code>L = [add(X[:i+1]) for i in xrange(len(X))]
[1, 3, 6, 10, 15, 21, 28, 36]
</code></pre>
<p>This is equivalent to:</p>
<pre><code>L = [add(X[:1]), add(X[:2]), ..., add(X[:8])]
</code></pre>
<p>Which turns out to be a list of prefix sums - the thing you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your approach won't work, because your <code>add()</code> is stateless.  You need something that maintains state between different invocations of <code>add()</code>, otherwise <code>add()</code> will always produce the same output.</p>
<p>One solution to accomplish what you want is <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate()</code></a>.  See <a href="https://stackoverflow.com/questions/14423794/equivalent-of-haskell-scanl-in-python">Equivalent of Haskell scanl in python</a> for a discussion.</p>
<p>Other answers here have suggested using a list comprehension that involves a <code>range()</code>.  While that would work, it would also be inefficient, as an O(n^2) algorithm that recomputes the cumulative sums from scratch for each entry.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python
"""
produce a list that adds each item to the previous item
this list [1,2,3,4] will produce this list [1,3,6,10]
"""

def accumulate(my_list, previous = 0):
    for i in my_list:
        previous += i
        yield previous

x = [1,2,3,4,5,6,7,8,9]
new_list = []
new_list = [i for i in accumulate(x)]
print x   
print new_list
</code></pre>
<p>produces this:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 3, 6, 10, 15, 21, 28, 36, 45]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it is possible to call any function in list comprehension.</p>
<p>Also note that in Python 2.x you cannot have <code>print</code> in list comprehension because <a href="https://stackoverflow.com/questions/2141098/list-comprehension-why-is-this-a-syntax-error"><code>print</code> is not a function</a> (in Python 2).</p>
<p>To your example - it could look like this, using an <code>add()</code> function that works with shared state (the <code>s</code> variable):</p>
<pre><code>s = 0   # better not use name 'sum' as it is already a builtin function
def add(i):
    global s
    s += i
    return s
X = [1, 2, 3, 4, 5, 6, 7, 8]
print [add(i) for i in X]
# prints [1, 3, 6, 10, 15, 21, 28, 36]
# but beware the global shared state! for example when called again:
print [add(i) for i in X]
# prints [37, 39, 42, 46, 51, 57, 64, 72]
</code></pre>
<p>See other answers how to do it without that shared state so you don't get different results when you forget to set <code>s = 0</code>.</p>
</div>
<span class="comment-copy">I'm not sure how a single <code>add()</code> call has produced multiple values.</span>
<span class="comment-copy">Something is wrong here - the <code>add()</code> function returns only one value and it should be the same each time (because <code>X</code> is not being modified). Are you sure you have <code>return</code> and not <code>print</code> in <code>add()</code>?</span>
<span class="comment-copy">Your <code>for</code> loop returns on the first iteration.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2805624/equivalent-to-f-s-seq-scan-method-in-python">Equivalent to F#â€™s Seq.scan() method in Python?</a></span>
<span class="comment-copy">I get <code>[1, 1, 1, 1, 1, 1, 1, 1]</code> instead; are you certain you are using the right <code>add()</code> function?</span>
<span class="comment-copy"><code>L = [value for value in add()]</code> would seem clearer in this context.</span>
<span class="comment-copy">I also suggest changing <code>add()</code> to take <code>X</code> as a parameter.</span>
<span class="comment-copy">@kroolik You're right: edited</span>
<span class="comment-copy">Are you saying that the list X would be fixed for this reason? Can you clarify what you mean here?</span>
<span class="comment-copy">I'm saying that every time you call <code>add()</code>, it will produce the same output, because it takes no parameters, performs no mutation, and is generally unstateful. klasske's suggestion to change <code>return</code> to <code>yield</code> works, because generators do keep state.</span>
