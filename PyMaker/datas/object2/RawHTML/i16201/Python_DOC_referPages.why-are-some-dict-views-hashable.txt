<div class="post-text" itemprop="text">
<p>In python 3, the <code>keys()</code>, <code>values()</code>, and <code>items()</code> methods provide <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow"><em>dynamic views</em></a> of their respective elements.  These were backported to python 2.7 and are available there as <code>viewkeys</code>, <code>viewvalues</code>, and <code>viewitems</code>.  I'm referring to them interchangeably here.</p>
<p>Is there any reasonable explanation for this:</p>
<pre><code>#!/usr/bin/python3.4
In [1]: hash({}.keys())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-1-3727b260127e&gt; in &lt;module&gt;()
----&gt; 1 hash({}.keys())

TypeError: unhashable type: 'dict_keys'

In [2]: hash({}.items())
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-2-decac720f012&gt; in &lt;module&gt;()
----&gt; 1 hash({}.items())

TypeError: unhashable type: 'dict_items'

In [3]: hash({}.values())
Out[3]: -9223363248553358775
</code></pre>
<p>I found this rather surprising.</p>
<hr/>
<p>The python docs <a href="https://docs.python.org/3.4/glossary.html#term-hashable" rel="nofollow">glossary on "hashable"</a> says:</p>
<blockquote>
<p>An object is hashable if it has a hash value which never changes
  during its lifetime (it needs a <code>__hash__()</code> method), and can be
  compared to other objects (it needs an <code>__eq__()</code> method). Hashable
  objects which compare equal must have the same hash value.</p>
</blockquote>
<p>Okay, the first part actually checks out; it doesn't appear that the hash of a <code>dict_values</code> object will change over its lifetime - even though its underlying values certainly can.</p>
<pre><code>In [11]: d = {}

In [12]: vals = d.values()

In [13]: vals.__hash__()
Out[13]: -9223363248553358718

In [14]: d['a'] = 'b'

In [15]: vals
Out[15]: dict_values(['b'])

In [16]: vals.__hash__()
Out[16]: -9223363248553358718
</code></pre>
<p>But the part about <code>__eq__()</code>... well, it doesn't have one of those, actually.</p>
<pre><code>In [17]: {'a':'a'}.values().__eq__('something else')
Out[17]: NotImplemented
</code></pre>
<p>So... yeah.  Can someone make any sense of this?  Is there a reason for this asymmetry that of the three <code>viewfoo</code> methods, only <code>dict_values</code> objects are hashable?</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe this occurs because <code>viewitems</code> and <code>viewkeys</code> provide custom rich comparison functions, but <code>viewvalues</code> does not. <a href="http://hg.python.org/cpython/file/acb30ed7eceb/Objects/dictobject.c#l3591" rel="nofollow">Here</a> are the definitions of each view type:</p>
<pre class="lang-c prettyprint-override"><code>PyTypeObject PyDictKeys_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "dict_keys",                                /* tp_name */
    sizeof(dictviewobject),                     /* tp_basicsize */
    0,                                          /* tp_itemsize */
    /* methods */
    (destructor)dictview_dealloc,               /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    (reprfunc)dictview_repr,                    /* tp_repr */
    &amp;dictviews_as_number,                       /* tp_as_number */
    &amp;dictkeys_as_sequence,                      /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    0,                                          /* tp_hash */
    0,                                          /* tp_call */
    0,                                          /* tp_str */
    PyObject_GenericGetAttr,                    /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
    0,                                          /* tp_doc */
    (traverseproc)dictview_traverse,            /* tp_traverse */
    0,                                          /* tp_clear */
    dictview_richcompare,                       /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    (getiterfunc)dictkeys_iter,                 /* tp_iter */
    0,                                          /* tp_iternext */
    dictkeys_methods,                           /* tp_methods */
    0,
};

PyTypeObject PyDictItems_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "dict_items",                               /* tp_name */
    sizeof(dictviewobject),                     /* tp_basicsize */
    0,                                          /* tp_itemsize */
    /* methods */
    (destructor)dictview_dealloc,               /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    (reprfunc)dictview_repr,                    /* tp_repr */
    &amp;dictviews_as_number,                       /* tp_as_number */
    &amp;dictitems_as_sequence,                     /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    0,                                          /* tp_hash */
    0,                                          /* tp_call */
    0,                                          /* tp_str */
    PyObject_GenericGetAttr,                    /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
    0,                                          /* tp_doc */
    (traverseproc)dictview_traverse,            /* tp_traverse */
    0,                                          /* tp_clear */
    dictview_richcompare,                       /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    (getiterfunc)dictitems_iter,                /* tp_iter */
    0,                                          /* tp_iternext */
    dictitems_methods,                          /* tp_methods */
    0,
};

PyTypeObject PyDictValues_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "dict_values",                              /* tp_name */
    sizeof(dictviewobject),                     /* tp_basicsize */
    0,                                          /* tp_itemsize */
    /* methods */
    (destructor)dictview_dealloc,               /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    (reprfunc)dictview_repr,                    /* tp_repr */
    0,                                          /* tp_as_number */
    &amp;dictvalues_as_sequence,                    /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    0,                                          /* tp_hash */
    0,                                          /* tp_call */
    0,                                          /* tp_str */
    PyObject_GenericGetAttr,                    /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
    0,                                          /* tp_doc */
    (traverseproc)dictview_traverse,            /* tp_traverse */
    0,                                          /* tp_clear */
    0,                                          /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    (getiterfunc)dictvalues_iter,               /* tp_iter */
    0,                                          /* tp_iternext */
    dictvalues_methods,                         /* tp_methods */
    0,
};
</code></pre>
<p>Notice that <code>tp_richcompare</code> is defined as <code>dictview_richcompare</code> for <code>items</code> and <code>keys</code>, but not <code>values</code>. Now, the <a href="https://docs.python.org/3.5/reference/datamodel.html#object.__hash__" rel="nofollow">documentation for <code>__hash__</code></a> says this:</p>
<blockquote>
<p>A class that overrides <code>__eq__()</code> and does not define <code>__hash__()</code> will have its <code>__hash__()</code> implicitly set to None.</p>
<p>...</p>
<p>If a class that overrides <code>__eq__()</code> needs to retain the implementation
  of <code>__hash__()</code> from a parent class, the interpreter must be told this
  explicitly by setting <code>__hash__ = &lt;ParentClass&gt;.__hash__</code>.</p>
<p>If a class that does not override <code>__eq__()</code> wishes to suppress hash
  support, it should include <code>__hash__ = None</code> in the class definition.`</p>
</blockquote>
<p>So, because <code>items</code>/<code>keys</code> are overriding <code>__eq__()</code> (by providing a <code>tp_richcompare</code> function), they would need to explicitly define <code>__hash__</code> as being equal to the parent's to retain an implementation for it. Because <code>values</code> doesn't override <code>__eq__()</code>, it inherits the <code>__hash__</code> from <code>object</code>, because <code>tp_hash</code> and <code>tp_richcompare</code> <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash" rel="nofollow">get inherited from the parent if they're both NULL</a>:</p>
<blockquote>
<p>This field is inherited by subtypes together with tp_richcompare: a
  subtype inherits both of tp_richcompare and tp_hash, when the
  subtypeâ€™s tp_richcompare and tp_hash are both NULL.</p>
</blockquote>
<p>The fact that the impelmentation for <code>dict_values</code> isn't preventing this automatic inheritence would probably be considered a bug.</p>
</div>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/q/24830632">Difference between a set and a view</a> and <a href="http://stackoverflow.com/q/24678047">Inconsistent behaviour between dict.items and dict.values</a></span>
<span class="comment-copy">Looks like the <code>dict_values</code> having a hash value is an oversight here though.</span>
<span class="comment-copy">Thanks dano.  Appreciate and agree with your findings.  Seems like <code>tp_hash</code> (for all three, really) should be explicitly be set to <code>PyObject_HashNotImplemented</code> in order to fix.  I'll open an issue on the bug tracker.</span>
<span class="comment-copy">Looks like @roippi filed <a href="http://bugs.python.org/issue22192" rel="nofollow noreferrer">issue22192</a> for this, for anyone interested.</span>
