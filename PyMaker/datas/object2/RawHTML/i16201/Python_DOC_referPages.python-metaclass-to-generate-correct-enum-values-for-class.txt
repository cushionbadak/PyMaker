<div class="post-text" itemprop="text">
<p>My <a href="https://stackoverflow.com/questions/25518988/python-equivalent-of-c-sharp-enum-hasflag">previous question</a> asked about Enum in python</p>
<p>Lets say I am creating State classes:</p>
<pre><code>class State(object):
    """
    Abstract class representing a state.
    """
    enum = 1

    def __init__(self, instance):
        self.instance = instance

    def is_flag(self, flag):
        return flag &amp; self.enum == self.enum
</code></pre>
<p>And then I create different actual States</p>
<pre><code>class New(State):
    enum = 2
    def pay(self):
        ...

class Paid(State):
    enum = 4
    def complete(self):
        ...

class Completed(State):
    enum = 8


ACCOUNTABLE = Paid.enum | Completed.enum
</code></pre>
<p>while this works, I would like to automate the generation of the enum values, and it seems like it can be done by using Meta classes, the question is how?</p>
</div>
<div class="post-text" itemprop="text">
<p>While I don't think defining a separate class for each enum value is a very robust approach for the reasons stated in my comments, here's one way it could be done which will support the creation of multiple independent base state classes.</p>
<pre><code>class MetaState(type):
    _baseclasses = {}  # registry of instances &amp; number of subclasses of each
    def __new__(cls, name, bases, attrs):
        cls = super(MetaState, cls).__new__(cls, name, bases, attrs)
        if bases == (object,):  # definition of a base class?
            MetaState._baseclasses[cls] = 0  # create initial registry entry
        else:  # must be derived from a previously defined base state class
            for base in bases:  # find base state class
                if base in MetaState._baseclasses:
                    setattr(cls, 'enum', 2 ** MetaState._baseclasses[base])
                    MetaState._baseclasses[base] += 1
                    break
            else:
                raise TypeError('Class not derived from base state class')
        return cls

class BaseState(object):
    """ Abstract base class for each derived state subclass. """
    __metaclass__ = MetaState

    def is_flag(self, flag):
        return flag &amp; self.enum == self.enum

class A(BaseState): pass
class B(BaseState): pass
class C(BaseState): pass

print A.enum  # -&gt; 1
print B.enum  # -&gt; 2
print C.enum  # -&gt; 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 has an <a href="https://docs.python.org/3/library/enum.html#module-enum" rel="nofollow"><code>Enum</code> data type</a>, which <a href="https://pypi.python.org/pypi/enum34" rel="nofollow">has been backported</a>.</p>
<pre><code>from enum import IntEnum

States = IntEnum('States', [(n, 2**i) for i, n in enumerate('New Paid Complete'.split(), 1)])

list(States) # [&lt;States.New: 2&gt;, &lt;States.Paid: 4&gt;, &lt;States.Complete: 8&gt;]
</code></pre>
<p>or</p>
<pre><code>class States(IntEnum):
    New = 2
    Paid = 4
    Complete = 8
    def is_flag(self, flag):
        return self &amp; flag == flag
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have also come up a solution (needs fixing) for my answer:</p>
<pre><code>class StateMeta(type):

    def __new__(cls, name, bases, attrs):
        cls = super(StateMeta, cls).__new__(cls, name, bases, attrs)
        if bases[-1] == object:
            return cls

        setattr(cls, 'enum', 2 ** (len(bases[-1].__subclasses__())-1))
        return cls


class State(object):
    """
    Abstract class representing a state.
    """
    __metaclass__ = StateMeta

    enum = 0

    def __init__(self, instance):
        self.instance = instance

    def is_flag(self, flag):
        return flag &amp; self.enum == self.enum
</code></pre>
<p>Running it:</p>
<pre><code>&gt;&gt;&gt; class A(State):
...     pass
... 
&gt;&gt;&gt; A.enum
1
&gt;&gt;&gt; class B(State):
...     pass
... 
&gt;&gt;&gt; B.enum
2
</code></pre>
</div>
<span class="comment-copy">Abstract base classes aren't the same thing a metaclasses. Regardless, creating separate classes with an attribute holding a single integer value seems like an awfully heavy-weight approach to creating Enum values. Another issue with this approach is that the integer values generated could vary depending on the order and number of of subclasses defined -- which means they wouldn't be constant values, something which is often desirable for enumerations.</span>
<span class="comment-copy">I have also considered the inconsistent values can be generated by the metaclass. I want to implement StateMachine pattern not just the Enum.</span>
<span class="comment-copy">It's unclear how the StateMachine pattern would make it possible to avoid the issue of inconsistent values. Also your use of <code>ABCMeta</code> is unnecessary, both here and in the answer you posted to your own question. In Python abstract base classes aren't the same thing as they are in, say, C++. If you insist on using classes to represent different Enum values -- a questionable approach -- a metaclass is probably all you'd need.</span>
<span class="comment-copy">OK thanks, I have removed the ABCMeta, I thought of using that <code>ABCMeta</code> could stop accidentally instating <code>State</code> class. I have also noticed the possible inconsistent enum values being generated, so in my actual implementation I have commented out the metaclass and specify the enum explicitly.</span>
<span class="comment-copy">Why are you skipping an enum value of 1 (2**0)?</span>
<span class="comment-copy">I am not skipping in purpose, but I cannot use the power of the iterator value because it's generating the enum value in a single class scope.</span>
<span class="comment-copy"><code>StateMeta.__new__()</code> is called when class <code>State</code> is defined, as well as when classes <code>A</code> and <code>B</code> are (because the latter two inherit <code>State</code>'s metaclass), so I don't understand what you mean by a "single class scope".</span>
<span class="comment-copy">I guess you are right, when creating A class, the count of subclass of State should be 1 (before B gets created), so I can possibly use use 2**(len(_cls.__subclasses__())-1) to create enum value.</span>
