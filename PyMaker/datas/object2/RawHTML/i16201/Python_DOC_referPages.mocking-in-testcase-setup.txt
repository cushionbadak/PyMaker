<div class="post-text" itemprop="text">
<p>I want to mock all test methods of a <code>TestCase</code>.</p>
<p>My first try to use <code>TestCase.setUp()</code> did not work, since <code>setUp()</code> finishes before the test methods gets executed.</p>
<p>I can't mock the real test method with this inside <code>setUp()</code>:</p>
<pre><code>with mock.patch(...):
    do_something()
</code></pre>
<p>I guess I am missing something.</p>
<p>How to use <code>mock.patch()</code> for all methods of a test case?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>with mock.patch()</code> is a <em>context manager</em>, the patch is unapplied when the context ends, and the context ends at the end of the block of code.</p>
<p>That means that the patches are unapplied again when <code>setUp()</code> ends.</p>
<p>Your options are to either use <code>@mock.patch()</code> as a <em>class decorator</em> or to use the <a href="https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop" rel="nofollow"><code>start</code> and <code>stop</code> methods</a> on the patchers.</p>
<p>Using <code>@mock.patch()</code> as a class decorator has the same effect as applying it as a decorator to each and every test method:</p>
<pre><code>@mock.patch('module.ClassName')
class TestFoo(unittest.TestCase):
    def setUp(self):
        # ...

    def test_one(self, class_mock):
        # ...

    def test_two(self, class_mock):
        # ...
</code></pre>
<p>Here both <code>test_one</code> and <code>test_two</code> are passed in a mock object because the <code>@mock.patch()</code> class decorator has found all test methods and decorated them.</p>
<p>Using the start and stop methods lets you apply and unapply patches in the <code>setUp</code> and <code>tearDown</code> methods:</p>
<pre><code>class TestFoo(unittest.TestCase):
    def setUp(self):
        self.patch1 = mock.patch(...)
        self.patch1.start()

    def tearDown(self):
        self.patch1.stop()
</code></pre>
<p>Here <code>patch1</code> is started on set-up, and stopped again when the test is torn down. This acts just like the context manager, but instead hooks into the test boundaries.</p>
<p>Instead of using a <code>tearDown</code>, you can also register the <code>patch.stop()</code> as a cleanup function with <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup" rel="nofollow"><code>TestCase.addCleanup()</code></a>:</p>
<pre><code>class TestFoo(unittest.TestCase):
    def setUp(self):
        patch1 = mock.patch(...)
        patch1.start()
        self.addCleanup(patch1.stop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>mock.patch.start</code>, <code>mock.patch.stop</code>. (See <a href="https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop" rel="nofollow">patch methods: start and stop</a>).</p>
<p>For example:</p>
<pre><code>class MyTest(TestCase):

    def setUp(self):
        self.patcher = mock.patch('...')
        self.MockClass = self.patcher.start()

    def tearDown(self):
        self.patcher.stop()

    def test_something(self):
        ....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most general solution, which works for all context managers is:</p>
<pre class="lang-python prettyprint-override"><code>import unittest

class TCase(unittest.TestCase):
    def setUp(self):
        self.cm = mock.path(...)
        self.cm.__enter__()

    def test1(self):
        ...

    def tearDown(self):
        self.cm.__exit__(None, None, None)
</code></pre>
</div>
<span class="comment-copy">There is no need to call <code>__enter__</code> and <code>__exit__</code> when there are explicit <code>start</code> and <code>stop</code> methods for just this purpose.</span>
