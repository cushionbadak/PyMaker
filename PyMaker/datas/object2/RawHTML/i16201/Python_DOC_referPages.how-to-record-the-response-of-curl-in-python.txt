<div class="post-text" itemprop="text">
<pre><code>import os
 os.system("curl --head http://somewebsite.com")
</code></pre>
<p>That prints out:</p>
<pre><code>HTTP/1.1 200 OK
Server: MochiWeb/1.0
Date: Fri, 22 Aug 2014 22:24:54 GMT
Content-Type: application/json
Cache-Control: no-cache
Access-Control-Allow-Origin: *
</code></pre>
<p>So this link returns streaming data in JSON format, How do I record the response in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't be doing this. I'll explain why later; first I'll show how to make it work. You have three problems, and you have to fix them all.</p>
<hr/>
<p>As the <a href="http://curl.haxx.se/docs/manpage.html" rel="nofollow"><code>curl</code></a> manpage says:</p>
<blockquote>
<p><code>-I, --head</code></p>
<p>(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.</p>
</blockquote>
<p>So you're explicitly telling curl to ask the server not to send you the response body. To fix this, don't send <code>--head</code>.</p>
<pre><code>os.system("curl http://somewebsite.com")
</code></pre>
<hr/>
<p>As the <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow"><code>os.system</code></a> docs say:</p>
<blockquote>
<p>On Unix, the return value is the exit status of the process encoded in the format specified for <code>wait()</code>…</p>
<p>On Windows, the return value is that returned by the system shell after running <em>command</em>.</p>
</blockquote>
<p>In other words, all you get back is an exit code—a small integer. The output just gets printed out; there's no way for you to record it. To actually record the text, look at the next paragraph:</p>
<blockquote>
<p>The <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" rel="nofollow"><code>subprocess</code></a> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the <a href="https://docs.python.org/3/library/subprocess.html#subprocess-replacements" rel="nofollow"><em>Replacing Older Functions with the <code>subprocess</code> Module</em></a> section in the <code>subprocess</code> documentation for some helpful recipes.</p>
</blockquote>
<p>Follow that link, and it shows you exactly how to do get the output in the first example: use the <code>check_output</code> function. Note that you will have to convert that command line into a list of arguments. (You <em>could</em> use <code>shell=True</code> instead, but there's no good reason to; all the shell will do for you here is get in the way.)</p>
<pre><code>output = subprocess.check_output(["curl", "http://somewebsite.com"])
</code></pre>
<hr/>
<p>Finally, by default, <code>curl</code> outputs the body to stdout—which is great, that's what you're capturing—but it also outputs stuff to stderr, which may include a progress meter, the headers, etc., depending on various circumstances. Unless you want to capture this information, or just dump it out for your users to see, you want to tell curl not to do this. See the manpage linked above for details:</p>
<pre><code>output = subprocess.check_output(["curl", "-q", "http://somewebsite.com"])
</code></pre>
<hr/>
<p>So, that works. Why do you not want to do things this way?</p>
<p>Because there's a much better way to do what you want: the <a href="https://docs.python.org/3/library/urllib.request.html#module-urllib.request" rel="nofollow"><code>urllib.request</code></a> module (or, if you're on Python 2.x, <code>urllib2</code>):</p>
<pre><code>output = urllib.request.urlopen('http://www.somewebsite.com').read()
</code></pre>
<p>How is this better?</p>
<ul>
<li>Portable: works on any system that can run Python, not just systems with <code>curl</code> installed.</li>
<li>Simpler: no need to work out the right arguments to an external program, then figure out how to pass them from Python.</li>
<li>Better error handling: you can check the HTTP status code, instead of trying to parse whatever <code>curl</code> gives you.</li>
<li>More flexible: if you want to, e.g., get both the headers and data separately, you can get them separately, without having to figure out how to get curl to dump the headers to a separate pipe and <code>Popen</code> it from Python and read from the two pipes without deadlocking.</li>
<li>Easier to debug.</li>
</ul>
</div>
<span class="comment-copy">Why do you try to use curl via <code>os.system()</code>? Wouldn't be much better to use some module such as <code>urllib2</code> from python standard library?</span>
