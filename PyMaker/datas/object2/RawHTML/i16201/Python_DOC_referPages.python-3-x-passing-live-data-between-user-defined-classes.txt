<div class="post-text" itemprop="text">
<p>New to Python
Assume the following</p>
<pre><code>class A:
   def __init__(self):
       self.X = "A"
       #init whatever I need to make this work

   def Areturn(self)
       return self.x

class B:
   def __init__(self):
       self.Y = "B"
       #initi whatever I need to make this work

   def Bset(self. sender)
       self.Y = sender
</code></pre>
<p>So now do the following:</p>
<pre><code>A.x = "QQQ"
B.Bset(A.Areturn)

A.X = "ZZZ"
</code></pre>
<p>Now what I want to do is NOT have to call <code>B.Bset(A.Areturn</code>) in order to get <code>self.Y</code> updated. In another words, I don't want to have to "refresh" <code>B</code> explicitly every time <code>A</code> changes. Ideally, something like an implicit (defined in <code>B.__init__</code>) flag that says, for this instance, if the value of <code>A</code> changes, trigger <code>B</code> to evaluate. Almost like a "depends on" relationship between <code>A</code> and <code>B</code> for a given instance of each.</p>
<p>Suggestions on how to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're willing to require that <code>A</code> receives an instance of <code>B</code> in its constructor, you can simply use the <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow"><code>property</code></a> decorator for this:</p>
<pre><code>class A:
   def __init__(self, b):
       self._x = "A"
       self.b = b

   @property
   def x(self):
       return self._x

   @x.setter
   def x(self, val):
       self._x = val
       self.b.Y = val

class B:
   def __init__(self):
       self.Y = "B"
</code></pre>
<p>If you want something more generic (so that <code>A</code> doesn't need to know about <code>B</code> at creation time), you can provide a way for any object to register to be updated when <code>A.x</code> changes:</p>
<pre><code>class A:
   def __init__(self):
       self._x = "A"
       self._x_listeners = []

   @property
   def x(self):
       return self._x

   @x.setter
   def x(self, val):
       self._x = val
       # Update the correct attribute for all listening objects
       for listener in self._x_listeners:
          setattr(listener[0], listener[1], val)

   def register_x_listener(self, obj, prop):
       # obj is the object to update, prop is the property on that object.
       self._x_listeners.append((obj, prop))

class B:
   def __init__(self):
       self.Y = "B"

a = A()
b = B()
a.register_x_listener(b, 'Y') # Now b.Y will be updated when a.x changes.
print(a.x)
print(b.Y)
a.x = 5 
print(a.x)
print(b.Y)
</code></pre>
<p>Output:</p>
<pre><code>A
B
5
5
</code></pre>
</div>
