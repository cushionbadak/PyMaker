<div class="post-text" itemprop="text">
<p>I would like to ask that if we are defining a child class using a base class, why would we need to initialize the arguments in the parent class in <code>__init__</code> method. I am similiar to JAVA OOP and as I remember in Java we just add the new arguments in the child class.</p>
<p>If I am wrong about Java too, can somebody please explain the reason to do it? Isn't inheritance something supposed to be make our lives easier with programming.</p>
<pre><code>class Car(object):
    condition = "new"
    def __init__(self, model, color, mpg):
        self.model = model
        self.color = color
        self.mpg   = mpg

    def display_car(self):
        print "This is a %s %s with %s MPG." % (self.color, self.model, self.mpg)

    def drive_car(self):
        self.condition = "used"

class ElectricCar(Car):
    def __init__(self, model, color, mpg, battery_type):
        self.model = model
        self.color = color
        self.mpg = mpg
        self.battery_type = battery_type



my_car = ElectricCar("Auris", "golden", 89, "molten salt")
</code></pre>
<p>I mean why isn't <code>self.battery_type = battery_type</code> inside ElectricCar class is enough for this kind of inheritance?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can invoke the overridden <code>__init__</code> method by using the <a href="https://docs.python.org/3/library/functions.html#super" rel="noreferrer"><code>super()</code> proxy object</a>:</p>
<pre><code>class ElectricCar(Car):
    def __init__(self, model, color, mpg, battery_type):
        super(ElectricCar, self).__init__(model, color, mpg)
        self.battery_type = battery_type
</code></pre>
<p>If you are using Python 3, you can omit the class and self references:</p>
<pre><code>class ElectricCar(Car):
    def __init__(self, model, color, mpg, battery_type):
        super().__init__(model, color, mpg)
        self.battery_type = battery_type
</code></pre>
<p>Either way, the <code>super()</code> call gives you a proxy object on which you can look up attributes and methods on the whole chain of parent classes; it'll find the next <code>__init__</code> method in the chain, then bind it such that you can call it as a regular method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write :</p>
<pre><code>class ElectricCar(Car):
    def __init__(self, model, color, mpg, battery_type):
         super(ElectricCar, self).__init__(model, color, mpg)
         self.battery_type = battery_type
</code></pre>
</div>
<span class="comment-copy">In Java, you call the <code>super</code> constructor (<code>super(arg1, arg2, ...)</code>)</span>
<span class="comment-copy">So if I would like to call the display_car method of the parent class with an additional feature of its country, <code>def display_car(self, country):  super(ElectricCar, self).display_car(country) self.country = country</code> this would be enough then ? for python 2.7</span>
<span class="comment-copy">@Alkadian: the original version doesn't take a <code>country</code> argument though.</span>
<span class="comment-copy">along with my new variable, older print which is in the parent class will be there too right?</span>
<span class="comment-copy">@Alkadian: you are just calling a method here; it's just like any other method call, it'll run and do what you defined it to do. As defined it will not also print the country.</span>
<span class="comment-copy">thx for your help, good day</span>
<span class="comment-copy">Thx for the solution</span>
