<div class="post-text" itemprop="text">
<p>So the <code>threading</code> module has a <code>Timer</code> class inhereted from <code>Thread</code> class to repeatedly execute some tasks.</p>
<p>I was wondering why doesn't the multiprocessing module have something like an analogous <code>TimedProcess</code> class for e.g., which is inhereted from <code>Process</code> to repeatedly execute some tasks?</p>
<p>It is possible to write such a timed process and I have written one but still curious. Or am I missing something?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty straightforward to implement yourself:</p>
<pre><code>from multiprocessing import Process, Event


class Timer(Process):
    def __init__(self, interval, function, args=[], kwargs={}):
        super(Timer, self).__init__()
        self.interval = interval
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.finished = Event()

    def cancel(self):
        """Stop the timer if it hasn't finished yet"""
        self.finished.set()

    def run(self):
        self.finished.wait(self.interval)
        if not self.finished.is_set():
            self.function(*self.args, **self.kwargs)
        self.finished.set()
</code></pre>
<p>I'm not sure why there isn't one included in the stdlib. Perhaps because its less likely to be useful?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a pretty open-ended question, and the literal answer wouldn't be very useful.</p>
<p>But let's try to come up with some educated guesses.</p>
<p><code>pyprocessing</code>* didn't have it. Why not? Probably because it's not particularly useful.</p>
<p>Almost any non-trivial app that needs timers needs multiple timers, recurring timers, relatively fast timers, etc. Firing off a new thread for each timed event is a terrible idea.</p>
<p>So, why is it even in <code>threading</code>? </p>
<p>Well, for <em>trivial</em> apps, it can actually be useful. It's not that unreasonable to add <code>threading</code> to a single-process app just so you can kick off a <code>Timer</code> to signal the main thread and interrupt it if it gets lost, for example. But that's not relevant to <code>multiprocessing</code>.</p>
<p>Also, <code>threading</code> is one of those modules that's designed to be useful as example code, not just as a library—and that was especially true when it was first added. That's why <a href="https://docs.python.org/3/library/threading.html#timer-objects" rel="nofollow">the docs</a> link to <a href="http://hg.python.org/cpython/file/3.4/Lib/threading.py" rel="nofollow">the source</a>. And <code>Timer</code> is a great piece of sample code—it's obvious to what it does and how it works, and it's hard to think of anything much simpler that could demonstrate how to use a synchronization object. But you don't need the code in two places to serve as an example, and there's nothing additional and multiprocessing-specific to demonstrate.</p>
<p>And finally Itamar Shtull-Trauring wanted it, did the work, and offered it, and nobody had any good argument against including it; presumably the same thing never happened with <code>pyprocessing</code>.**</p>
<p>During the 2.6/3.0 planning, <a href="http://legacy.python.org/dev/peps/pep-0371/" rel="nofollow">PEP 371</a> adapted <code>pyprocessing</code> into the stdlib <code>multiprocessing</code> module. This was a pretty big job, and done in a bit of a rush, especially since they took on the task of PEP8-ifying the names in <code>threading</code> so they wouldn't have to rename all of <code>pyprocessing</code> to match the non-standard names in <code>threading</code> just for someone to rename them all again when <code>threading</code> got fixed a year or two later. So, even though being a drop-in replacement for <code>threading</code> whenever possible was one of the secondary goals, I'm guessing nobody did a complete survey to make sure that was accomplished.</p>
<p>Since then, presumably, either nobody has noticed it was missing and suggested it, or nobody has made a compelling enough argument, or nobody did the actual work. If you believe it should be added, and can defend your belief, create a bug or write to python-ideas, and include your implementation, and sign a PSF contributor's agreement, and it may get you immortalized. :)</p>
<p><sub>* Unfortunately, I can't find any good historical links to <code>pyprocessing</code>. The source repo is dead, the contributors moved on to maintaining the stdlib <code>multiprocessing</code> module and the PyPI <a href="https://pypi.python.org/pypi/multiprocessing/" rel="nofollow"><code>multiprocessing</code></a> backport, even that project has largely been supplanted by <a href="https://pypi.python.org/pypi/billiard/" rel="nofollow"><code>billiard</code></a>, and in the intervening years a new and unrelated project has taken over the original name…</sub></p>
<p><sub>** Note that in <a href="http://bugs.python.org/issue428326" rel="nofollow">issue #428326</a>, where <code>Timer</code> was first suggested, more than half of the rationale is that it's good example code.</sub></p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/2/library/sched.html" rel="nofollow noreferrer">docs.python.org/2/library/sched.html</a></span>
<span class="comment-copy">See also <a href="http://stackoverflow.com/q/12435211">stackoverflow.com/q/12435211</a></span>
<span class="comment-copy">As far as I can tell scheduler does not inheret from Process. If Timer can inheret from Thread, why can't another Timer say TimerProc inheret from Process?</span>
<span class="comment-copy">@Manas: You wouldn't call it <code>TimerProc</code>, it'd just be <code>multiprocessing.Timer</code>. In fact, I believe you could copy and paste the code out of <code>threading.py</code>, change <code>Thread</code> to <code>Process</code> the two places it appears, and be done.</span>
<span class="comment-copy">Yeah, I kind of ended up doing the same thing. But same hold true for Thread and Timer. So the decision to not include in stdlib is funny unless there is some pressing reason. As far as I can see, repeatedly executing a process offers more advantages than repeatedly executing threads. All the advantages of processes over threads like no shared memory, GIL, true multiprocessing hold. I can see uses for those features.</span>
<span class="comment-copy">The question already says "It is possible to write such a timed process and I have written one", so I don't think showing how to write one answers the question.</span>
<span class="comment-copy">@abarnert Agreed - I've spent the last 15 minutes or so searching the mailing lists / commit logs for some evidence of <i>why</i> it wasn't included, so I could edit it into my answer. But as it appears you've found, there really isn't any mention of it. Seems to just be a case of "no one really cared enough to do it".</span>
<span class="comment-copy">@Manas It's quite possible that if you submitted a patch to add a <code>multiprocessing.Timer</code>, it would be accepted. The lack of results when you google "multiprocessing.timer", "multprocessing timer", etc. seems to suggest very few people have been missing it, though.</span>
<span class="comment-copy">People probably don't miss it because it is a trivial thing to implement, although I belive most just end up using <code>threading.Timer</code> which I belive is a bad way to repeatedly do tasks.</span>
