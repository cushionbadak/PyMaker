<div class="post-text" itemprop="text">
<p>I want to use Python's built-in <a href="https://docs.python.org/2/library/functions.html#min" rel="nofollow">min()</a> and <a href="https://docs.python.org/2/library/functions.html#max" rel="nofollow">max()</a> functions on a collection of my <code>Point</code> objects. However, I want the <code>distance</code> attribute to be the compared value. How can I specify this in the class definition?</p>
<pre><code>class Point():
    def __init__(self, x, y, distance):
        self.x = x
        self.y = y
        self.distance = distance

a = Point(3, 5, 2)
b = Point(5, 4, 1)
c = Point(8, 4, 5)

hopefully_b = min(a, b, c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a key function:</p>
<pre><code>from operator import attrgetter

max(a, b, c, key=attrgetter('distance'))
</code></pre>
<p>The <a href="https://docs.python.org/2/library/operator.html#operator.attrgetter" rel="nofollow"><code>operator.attrgetter()</code> function</a> produces a callable that returns the named attribute for each object passed to it. You could achieve the same with a <code>lambda</code> callable:</p>
<pre><code>max(a, b, c, key=lambda p: p.distance)
</code></pre>
<p>Alternatively, you can add special methods to the class to define how they should be compared; the <a href="https://docs.python.org/2/reference/datamodel.html#object.__eq__" rel="nofollow"><code>__eq__</code></a> method defines how two instances are equal, and methods like <a href="https://docs.python.org/2/reference/datamodel.html#object.__lt__" rel="nofollow"><code>__lt__</code></a> and friends are used when comparing two instances to see how they order. <code>max()</code> will then make use of these methods to find a 'largest' item, without a <code>key</code> function.</p>
<p>With the <a href="https://docs.python.org/2/library/functools.html#functools.total_ordering" rel="nofollow"><code>@functools.total_ordering()</code> decorator</a> you only have to implement two of those; <code>__eq__</code> and one of the comparison methods:</p>
<pre><code>from functools import total_ordering

@total_ordering
class Point():
    def __init__(self, x, y, distance):
        self.x = x
        self.y = y
        self.distance = distance

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return NotImplemented  # only the same type or subclasses
        return (self.x, self.y, self.distance) == (other.x, other.y, other.distance)

    def __lt__(self, other):
        if not isinstance(other, type(self)):
            return NotImplemented  # only the same type or subclasses
        if (self.x, self.y) == (other.x, other.y):
            return False  # same coordinates makes them equalish?
        return self.distance &lt; other.distance
</code></pre>
<p>For <code>Point</code> objects this should probably be thought out more; what happens if distance is not equal but x and y are, for example?</p>
</div>
<div class="post-text" itemprop="text">
<p>When using <code>min</code> and <code>max</code> without a special key function, the functions will use the order of the objects to determine its result. So you will have to implement an order for your <code>Point</code> class, making e.g. <code>a &gt; b</code> work.</p>
<p>To do that, you will need to implement a number of <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">special methods</a>. That way you enable comparison between those objects. Since you likely want a proper order where <code>a &lt; b</code> implies <code>b &gt; a</code> etc., you can use <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow"><code>functools.total_ordering</code></a> to implement a <a href="http://en.wikipedia.org/wiki/Total_order" rel="nofollow">total order</a> by just defining the equality and a single lower-than comparison:</p>
<pre><code>import functools

@functools.total_ordering
class Point:
    def __init__ (self, x, y, distance):
        self.x = x
        self.y = y
        self.distance = distance

    def __lt__ (self, other):
        return (self.distance, self.x, self.y) &lt; (other.distance, other.x, other.y)

    def __eq__ (self, other):
        return (self.distance, self.x, self.y) == (other.distance, other.x, other.y)

    def __repr__ (self):
        return 'Point({}, {}, {})'.format(self.x, self.y, self.distance)
</code></pre>
<pre><code>&gt;&gt;&gt; a, b, c = Point(3, 5, 2), Point(5, 4, 1), Point(8, 4, 5)
&gt;&gt;&gt; min(a, b, c)
Point(5, 4, 1)
&gt;&gt;&gt; max(a, b, c)
Point(8, 4, 5)
</code></pre>
</div>
<span class="comment-copy">Thank you very much. Can you provide some insight as to which attribute gets used when no key is specified (default behavior)?</span>
<span class="comment-copy">@sgarza62: for classes without ordering methods, instances of the same type are ordered by <code>id()</code> value instead.</span>
<span class="comment-copy">This is a very comprehensive answer</span>
