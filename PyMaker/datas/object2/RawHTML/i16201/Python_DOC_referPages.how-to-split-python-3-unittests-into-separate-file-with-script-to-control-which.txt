<div class="post-text" itemprop="text">
<p>I want to split my Python 3.4 unit tests in separate modules and still be able to control which tests to run or skip from the command line, as if all tests were located in the same file. I'm having trouble doing so.</p>
<p>According to <a href="https://docs.python.org/3/library/unittest.html#command-line-interface" rel="nofollow">the docs</a>, command line arguments can be used to select which tests to run. For example:</p>
<p>TestSeqFunc.py:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import random
import unittest

class TestSequenceFunctions(unittest.TestCase):

    def setUp(self):
        self.seq = list(range(10))

    def test_shuffle(self):
        # make sure the shuffled sequence does not lose any elements
        random.shuffle(self.seq)
        self.seq.sort()
        self.assertEqual(self.seq, list(range(10)))

        # should raise an exception for an immutable sequence
        self.assertRaises(TypeError, random.shuffle, (1,2,3))

    def test_choice(self):
        element = random.choice(self.seq)
        self.assertTrue(element in self.seq)

    def test_sample(self):
        with self.assertRaises(ValueError):
            random.sample(self.seq, 20)
        for element in random.sample(self.seq, 5):
            self.assertTrue(element in self.seq)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>can be controlled with either:</p>
<pre><code>./TestSeqFunc.py
</code></pre>
<p>to run all tests in the file,</p>
<pre><code>./TestSeqFunc.py TestSequenceFunctions
</code></pre>
<p>to run all tests defined in the TestSequenceFunctions class, and finally:</p>
<pre><code>./TestSeqFunc.py TestSequenceFunctions.test_sample
</code></pre>
<p>to run the specific <code>test_sample()</code> method.</p>
<p>The problem I have is that I cannot find an organization of files that will allow me to:</p>
<ol>
<li>Have multiple modules containing multiple classes and methods in <em>separate files</em></li>
<li>Use a kind of wrapper script that will give the same kind of control over which tests (module/file, class, method) to run.</li>
</ol>
<p>The problem I have is I cannot find a way to emulate the <code>python3 -m unittest</code> behaviour using a <code>run_tests.py</code> script. For example, I want to be able to do:</p>
<ol>
<li>Run all the tests in the current directory
So <code>./run_tests.py -v</code> should do do the same as <code>python3 -m unittest -v</code></li>
<li>Run one module (file):
<code>./run_tests.py -v TestSeqFunc</code> being equivalent to <code>python3 -m unittest -v TestSeqFunc</code></li>
<li>Run one class:
<code>./run_tests.py -v TestSeqFunc.TestSequenceFunctions</code> being equivalent to <code>python3 -m unittest -v TestSeqFunc.TestSequenceFunctions</code></li>
<li>Run specific methods from a class:
<code>./run_tests.py -v TestSeqFunc.TestSequenceFunctions.test_sample</code> being equivalent to <code>python3 -m unittest -v TestSeqFunc.TestSequenceFunctions.test_sample</code></li>
</ol>
<p>Note that I want to:</p>
<ol>
<li>be able to pass arguments to unittests, for example the verbose flag used previously;</li>
<li>allow running specific modules, classes and even methods.</li>
</ol>
<p>As of now, I use a <code>suite()</code> function in my <code>run_all.py</code> script which loads manually the modules and add their class to a suite using <code>addTest(unittest.makeSuite(obj))</code>. Then, my main() is simple:</p>
<pre><code>if __name__ == '__main__':
    unittest.main(defaultTest='suite')
</code></pre>
<p>But using this I cannot run specific tests. In the end, I might just execute <code>python3 -m unittest &lt;sys.argv&gt;</code> from inside the <code>run_all.py</code> script, but that would be inelegant...</p>
<p>Any suggestions?!</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass command-line arguments to <code>unittest.main</code> using the <a href="https://docs.python.org/3.4/library/unittest.html#unittest.main" rel="nofollow"><code>argv</code> parameter</a>:</p>
<blockquote>
<p>The argv argument can be a list of options passed to the program, with
  the first element being the program name. <strong>If not specified or None,
  the values of sys.argv are used</strong>. (my emphasis)</p>
</blockquote>
<p>So you should be able to use</p>
<pre><code>if __name__ == '__main__':
    unittest.main(defaultTest='suite')
</code></pre>
<p>without any change and be able to call your script with command-line arguments as desired.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my final run_all.py:</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest
import glob

test_pattern = 'validate_*.py'

if __name__ == '__main__':

    # Find all files matching pattern
    module_files = sorted(glob.glob(test_pattern))
    module_names = [os.path.splitext(os.path.basename(module_file))[0] for module_file in module_files]

    # Iterate over the found files
    print('Importing:')
    for module in module_names:
        print('    ', module)
        exec('import %s' % module)

    print('Done!')
    print()

    unittest.main(defaultTest=module_names)
</code></pre>
<p>Notes:</p>
<ol>
<li><p>I use exec() to simulate 'import modulename'. The issue is that using importlib (<a href="https://stackoverflow.com/a/301146">explained here for example</a>) will import the module but will not create a namespace for the module content. When I type <code>import os</code>, an "os" namespace is created and I can then access <code>os.path</code>. By using importlib, I couldn't figure out a way to do create that namespace. Having such a namespace is required for <code>unittest</code>; you get these kind of errors:</p>
<pre><code>Traceback (most recent call last):
File "./run_all.py", line 89, in &lt;module&gt;
    unittest.main(argv=sys.argv)
File "~/usr/lib/python3.4/unittest/main.py", line 92, in __init__
    self.parseArgs(argv)
File "~/usr/lib/python3.4/unittest/main.py", line 139, in parseArgs
    self.createTests()
File "~/usr/lib/python3.4/unittest/main.py", line 146, in createTests
    self.module)
File "~/usr/lib/python3.4/unittest/loader.py", line 146, in loadTestsFromNames
    suites = [self.loadTestsFromName(name, module) for name in names]
File "~/usr/lib/python3.4/unittest/loader.py", line 146, in &lt;listcomp&gt;
    suites = [self.loadTestsFromName(name, module) for name in names]
File "~/usr/lib/python3.4/unittest/loader.py", line 114, in loadTestsFromName
    parent, obj = obj, getattr(obj, part)
AttributeError: 'module' object has no attribute 'validate_module1'
</code></pre>
<p>Hence the use of <code>exec()</code>.</p></li>
<li><p>I have to add <code>defaultTest=module_names</code> or else <code>main()</code> defaults to all test classes <em>inside the current file</em>. Since there is no test class in <code>run_all.py</code>, nothing gets executed. So <code>defaultTest</code> must point to a list of all the modules name.</p></li>
</ol>
</div>
<span class="comment-copy">That's exactly what I was about to paste; sys.argv is used if not specified. So actually, just calling main() does work. It doesn't work though if I use a test suite, but not having one just simplifies the code. Thanks ;)</span>
