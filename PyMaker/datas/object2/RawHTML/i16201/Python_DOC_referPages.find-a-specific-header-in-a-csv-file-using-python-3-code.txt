<div class="post-text" itemprop="text">
<p>right now I have Python 3 code that takes a column of data within a CSV file, delimits the phrases in each cell into individual words based on spaces, then exports the data back into a new CSV file.  </p>
<p>What I am wondering about is if there is a way to tell python to only apply the formatting code to a specific column with a particular header?</p>
<p>Here is what my source data looks like</p>
<pre><code>Keyword              Source       Number 
Lions Tigers Bears     US          3
Dogs Zebra            Canada       5
Sharks Guppies         US          2
</code></pre>
<p>and here is my code which delimits the phrases in each cell into individual words based on a space </p>
<pre><code>with open(b'C:\Users\jk\Desktop\helloworld.csv', 'r') as datafile:
    data = []
    for row in datafile:
        data.extend(item.strip() for item in row.split())
with open('test.csv', 'w') as a_file:
    for result in data:
        result = ''.join(result)
        a_file.write(result + '\n')
        print(result)
</code></pre>
<p>so that the source data becomes</p>
<pre><code> Keywords         Source         Number
 Lions            US              3
 Tigers
 Bears
 Dogs             Canada          5
</code></pre>
<p>etc                </p>
<p>In this case, I only need all of this code to apply to the one column with the heading <code>Keyword</code>.  Ideally, what I am trying to do is also extend the data found in the "Source" and "Number" to these newly created rows (Lions US 3 -- Tigers US 3 -- Bears US 3  etc) but I haven't really figured out that part yet!</p>
<p>I've been poking around the forum for awhile trying to find an answer and I know you can tell python to read the first line of the CSV file where the headers are placed (<code>headers = file.readline()</code>) but beyond that I am lost.  Would this be an easier task using the CSV reader?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow"><code>csv</code> module</a> to split your data into columns. Use the <code>csv.DictReader()</code> object to make it easier to select a column by the header:</p>
<pre><code>import csv

source = r'C:\Users\jk\Desktop\helloworld.csv'
dest = 'test.csv'

with open(source, newline='') as inf, open(dest, 'w', newline='') as outf:
    reader = csv.DictReader(inf)
    writer = csv.DictWriter(outf, fieldnames=reader.fieldnames)
    for row in reader:
        words = row['Keyword'].split()
        row['Keyword'] = words[0]
        writer.writerow(row)
        writer.writerows({'Keyword': w} for w in words[1:])
</code></pre>
<p>The <code>DictReader()</code> will read the first row from your file and use it as the keys for the dictionaries produced for each row; so a row looks like:</p>
<pre><code>{'Keyword': 'Lions Tigers Bears', 'Source': 'US', 'Number': '3'}
</code></pre>
<p>Now you can address each column individually, and update the dictionary with just the first word of the <code>Keyword</code> column before producing additional rows for the remaining words. </p>
<p>I'm assuming here that your files are <em>comma</em> separated. If a different delimiter is needed, then set the <code>delimiter</code> argument to that character:</p>
<pre><code>reader = csv.DictReader(inf, delimiter='\t')
</code></pre>
<p>for a tab-separated format. See the module documentation for the various options, including pre-defined format combinations called <em>dialects</em>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; import csv
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; sample = StringIO('''\
... Keyword,Source,Number
... Lions Tigers Bears,US,3
... Dogs Zebra,Canada,5
... Sharks Guppies,US,2
... ''')
&gt;&gt;&gt; output = StringIO()
&gt;&gt;&gt; reader = csv.DictReader(sample)
&gt;&gt;&gt; writer = csv.DictWriter(output, fieldnames=reader.fieldnames)
&gt;&gt;&gt; for row in reader:
...     words = row['Keyword'].split()
...     row['Keyword'] = words[0]
...     writer.writerow(row)
...     writer.writerows({'Keyword': w} for w in words[1:])
... 
12
15
13
&gt;&gt;&gt; print(output.getvalue())
Lions,US,3
Tigers,,
Bears,,
Dogs,Canada,5
Zebras,,
Sharks,US,2
Guppies,,
</code></pre>
</div>
<span class="comment-copy">Are your columns tab separated?</span>
<span class="comment-copy">Hi, Martijn -- the file is in CSV format so I do not believe so</span>
<span class="comment-copy">The <code>C</code> stands for <i>Character</i>; both comma and tabs are common. I'll assume you have comma-separated data then; your sample data doesn't give much of a hint.</span>
<span class="comment-copy">@MartijnPieters comma-separated with no comma in sight? :)</span>
<span class="comment-copy">@JonClements: so many people load the CSV into Excel and then show the results from that rather than the actual file contents.</span>
<span class="comment-copy"><code>row['Keyword'] = row['Keyword'].replace(' ','')</code> looks better to me than the split/join. I have a feeling the OP could be after an output row of 3 columns though for the <code>Lions Tigers Bears</code> (but not sure)</span>
<span class="comment-copy">@JonClements: I was trying to 'reuse' a concept from the OP code; simply showing how to apply the same transformation to just one column. Since the original code uses <code>''.join()</code> I think it is fair to assume that that is the goal but for just one column.</span>
<span class="comment-copy">should <code>LionsTigersBears</code> not be <code>Lions Tigers Bears</code>?</span>
<span class="comment-copy">@PadraicCunningham: no, the point was to remove spaces from that column. The column is split on whitespace, then re-joined without.</span>
<span class="comment-copy">Hi Martijn,  thank you for the response and the commentary!  Very useful especially with this dictreader!  The only issue is that my original code doesn't just remove the white spaces within the keyword row (i.e. lionstigersbears).  What it does is delimits each of those "phrases" so that it becomes a stacked column where each cell only has one word!  I have updated my original post to make this clearer</span>
