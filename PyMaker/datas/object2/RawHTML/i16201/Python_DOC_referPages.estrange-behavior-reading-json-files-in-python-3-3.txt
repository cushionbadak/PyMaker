<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6921699/can-i-get-json-to-load-into-an-ordereddict">Can I get JSON to load into an OrderedDict?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I am using the 'json' packages to read JSON files and convert to CSV. I wrote a script some months ago using Python 2.7, which extracts a dictionary containing the name of the objects in JSON file <strong>(It worked perfectly back then).</strong>
 When I run the script in Python 3.3 the order in which the objects are retrieved are different every time the script is executed. </p>
<p><em>Any idea why this happens? and How to fix it?</em></p>
<p>My script:</p>
<pre><code>import json
import csv

   input_file = open('my_path\\json_file', 'r')
   myjson = json.load(input_f)
   input_f.close()
   new_json = myjson['markers'] #main object containing sub-objects

   keys = {} #empty dictionary to store list of sub-objects

   for i in new_json:
       for k in i.keys():
           keys[k] = 1
</code></pre>
<p>Some output examples:</p>
<p>EXECUTION 1:</p>
<pre><code>KEYS{'': 1, 'latitude': 1, 'Particles': 1, 'Wind Speed': 1, 'image': 1, 'Humidity': 1, 'C/ Daoiz y Velarde': 1, 'Noise': 1, 'Battery level': 1, 'id': 1, 'Soil Moisture': 1, ....}
</code></pre>
<p>EXECUTION 2:</p>
<pre><code>KEYS{'': 1, 'Relative humidity': 1, 'N02': 1, 'Particles': 1, 'Rainfall': 1, 'image': 1, 'Odometer': 1, 'Co Index': 1, 'Wind Direction': 1, 'Atmospheric Pressure': 1, ....}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the way dictionaries now work in Python 3. It is the result of a security patch that was disabled by default in 2.x. See <a href="https://stackoverflow.com/a/14959001/65529">this answer</a> for more explanation.</p>
<p>You can get the behavior you desire by using the <code>object_pairs_hook</code> keyword argument. Pass it the <code>collections.OrderedDict</code> class. You'll likely also want to store the results in an OrderedDict, too. This is documented <a href="https://docs.python.org/3.3/library/json.html#json.load" rel="nofollow noreferrer">here</a> and <a href="https://docs.python.org/2/library/collections.html#ordereddict-objects" rel="nofollow noreferrer">here</a>. For example:</p>
<pre><code>import json
import csv
import collections

input_file = open('my_path\\json_file', 'r')
myjson = json.load(input_f, object_pairs_hook=collections.OrderedDict)
input_f.close()
new_json = myjson['markers'] #main object containing sub-objects

keys = collections.OrderedDict()

for i in new_json:
    for k in i.keys():
        keys[k] = 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This occurs because python dictionaries are <strong>not</strong> guaranteed to be sorted. Use an ordereddict to fix it:</p>
<pre><code>import json
import csv
from collections import OrderedDict

input_file = open('my_path\\json_file, 'r')
myjson = OrderedDict(json.load(input_f))
input_f.close()
keys = {} #empty dictionary to store list of sub-objects

for i in new_json:
    for k in i.keys():
       keys[k] = 1
</code></pre>
</div>
<span class="comment-copy">Python's <code>dict</code> objects are unordered. The top answer in the question I linked to above will solve this by loading the json directly into a <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a>.</span>
<span class="comment-copy">OT: Can I ask you why you are exporting data from JSON to CSV? In other words what is the end goal you want to achieve by this transformation?</span>
<span class="comment-copy">My end goal is to prepare data harvested from a website into PostgreSQL. Ordering and cleaning (remove some known inconsistencies) is required.</span>
<span class="comment-copy">I don't think this will preserve the ordering that's in the file stored on disk, because it's still initially being loaded into a normal <code>dict</code>.</span>
<span class="comment-copy">OP wants it formatted on output if he wants it on the disk, they need only write it out that way, using json.dumps or whatever.</span>
