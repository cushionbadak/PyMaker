<div class="post-text" itemprop="text">
<p>I'm using Python 3.4.1 and the unittest module to validate another piece of software.</p>
<p>The other piece of software needs to be run and its output must be parsed by the python script for validation. The output file is an XML file containing an unknown number of  elements.</p>
<p>For now, I've been using <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow"><code>subTest()</code></a> to generate one subtest per XML element. This is not exactly what I want. </p>
<p>I would like to create one test_* method for every  element in the XML file. The problem is that I don't know in advance how many elements there will be, so I need a way to automatically add new test_* methods to the unittest. I though of having a setUpClass() method that would call the external software to generate the XML and build an update list of test* methods to be run.</p>
<p>But I think the methods are added to the unittest's list of methods to run <em>before</em> anything is executed, so that once I get to the point where I add new methods (using <code>setattr()</code> from inside <code>setUpClass()</code> for example), the list is already built and the new methods are never run...</p>
<p>Is it possible to dynamically change the list of methods to run in unittest?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a variation of what I came up with:</p>
<pre><code>import unittest

class MyClass:
    def setup(self):
        # run external software
    def parse_xml(self):
        # parse the xml file
    def generator(self, test_class, a, b):
        def test(self):
            self.assertEqual(a, b)
        return test

    def add_test_methods(self, test_class):
        for i in range(len(self.all_status)):
            test = self.generator(test_class, self.all_status[i], STATUS_SUCCESS)
            setattr(test_class, "test_uid_%d" % i, test)


class TestIO(unittest.TestCase):
    pass

mb = MyClass()
mb.setup()
mb.parse_xml()
mb.add_test_methods(TestIO)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>The trick is to do generate and parse the XML file outside of any class and add the resulting methods to the class using <code>setatt()</code>. The problem with this approach is that it run codes outside of the testing suite which I was hoping not to do. So a failure there will break the whole suite (since <code>unittest</code> won't catch the error...)</p>
<p>Maybe I could move the XML generation to its own testing class?</p>
<p>Any better suggestion?</p>
</div>
<div class="post-text" itemprop="text">
<p>I came up with this . Tried my hands on the code submitted by @big_gie. In this way, the setUp and tearDown will also run as per unit test rule..</p>
<p><code>import unittest</code></p>
<p><code>def generator(test_class, a, b):
    def test(self):
        self.assertEqual(a, b)
    return test</code></p>
<p><code>def add_test_methods(test_class):
    test_list = [[2,3, 'one'], [5,5, 'two'], [0,0, 'three']]
    for case in test_list:
        test = generator(test_class, case[0], case[1])
        setattr(test_class, "test_%s" % case[2], test)</code></p>
<p><code>class TestIO(unittest.TestCase):</code>
<code>def setUp(self):
        print 'Setup'
        pass</code></p>
<p><code>def tearDown(self):
        print 'TearDown'
        pass</code></p>
<p><code>add_test_methods(TestIO)</code></p>
<p><code>if __name__ == '__main__':</code>
<code>unittest.main(verbosity=1)</code></p>
<p><strong>Result:</strong></p>
<pre><code>&gt;&gt;&gt; 
Setup
FTearDown
Setup
TearDown
.Setup
TearDown
.
======================================================================
FAIL: test_one (__main__.TestIO)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "D:/inchowar/Desktop/PyTrash/test_auto_3.py", line 5, in test
    self.assertEqual(a, b)
AssertionError: 2 != 3

----------------------------------------------------------------------
Ran 3 tests in 0.019s

FAILED (failures=1)
</code></pre>
</div>
<span class="comment-copy">You may be able to do this with <code>py.test</code>. Though, what exactly makes <code>subTest</code> a problem? It seems that it does what you want?</span>
<span class="comment-copy"><code>subTest</code> is close, but not exactly; every &lt;test&gt;&lt;/test&gt; element is actually a unit test result from the software. I would like to match tests on both side, not have a bunch of tests from the software match to a single test in python...</span>
