<div class="post-text" itemprop="text">
<p>I have a large existing program library that currently has a .NET binding, and I'm thinking about writing a Python binding. The existing API makes extensive use of signature-based overloading. So, I have a large collection of static functions like:</p>
<pre><code>Circle(p1, p2, p3) -- Creates a circle through three points
Circle(p, r)       -- Creates a circle with given center point and radius
Circle(c1, c2, c3) -- Creates a circle tangent to three curves
</code></pre>
<p>There are a few cases where the same inputs must be used in different ways, so signature-based overloading doesn't work, and I have to use different function names, instead. For example</p>
<pre><code>BezierCurve(p1,p2,p3,p4) -- Bezier curve using given points as control points
BezierCurveThroughPoints(p1,p2,p3,p4) -- Bezier curve passing through given points
</code></pre>
<p>I suppose this second technique (using different function names) could be used everywhere in the Python API. So, I would have</p>
<pre><code>CircleThroughThreePoints(p1, p2, p3)
CircleCenterRadius(p, r)
CircleTangentThreeCurves(c1, c2, c3)
</code></pre>
<p>But the names look unpleasantly verbose (I don't like abbreviations), and inventing all of them will be quite a challenge, because the library has thousands of functions.</p>
<p><strong>Low Priorities:</strong><br/>
Effort (on my part) -- I don't care if I have to write a lot of code.<br/>
Performance</p>
<p><strong>High Priorities:</strong><br/>
Ease of use/understanding for callers (many will be programming newbies).<br/>
Easy for me to write good documentation.<br/>
Simplicity -- avoid the need for advanced concepts in caller's code.  </p>
<p>I'm sure I'm not the first person who ever wished for signature-based overloading in Python. What work-arounds do people typically use?</p>
</div>
<div class="post-text" itemprop="text">
<p>One option is to exclusively keyword arguments in the constructor, and include logic to figure out what should be used:</p>
<pre><code>class Circle(object):
    def __init__(self, points=(), radius=None, curves=()):
        if radius and len(points) == 1:
            center_point = points[0]
            # Create from radius/center point
        elif curves and len(curves) == 3:
            # create from curves
        elif points and len(points) == 3:
            # create from points
        else:
            raise ValueError("Must provide a tuple of three points, a point and a radius, or a tuple of three curves)
</code></pre>
<p>You can also use classmethods to make things easier for the users of the API:</p>
<pre><code>class Circle(object):
    def __init__(self, points=(), radius=None, curves=()):
         # same as above

    @classmethod
    def from_points(p1, p2, p3):
        return cls(points=(p1, p2, p3))

    @classmethod
    def from_point_and_radius(cls, point, radius):
        return cls(points=(point,), radius=radius)

    @classmethod
    def from_curves(cls, c1, c2, c3):
        return cls(curves=(c1, c2, c3))
</code></pre>
<p>Usage:</p>
<pre><code>c = Circle.from_points(p1, p2, p3)
c = Circle.from_point_and_radius(p1, r)
c = Circle.from_curves(c1, c2, c3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of options.</p>
<p>You can have one constructor that accepts and arbitrary number of arguments (with <code>*args</code> and/or <code>**varargs</code> syntaxes) and does different things depending on the number and type the arguments have.</p>
<p>Or, you can write secondary constructors as class methods. These are known as "factory" methods. If you have multiple constructors that take the same number of objects of the same classes (as in your <code>BezierCurve</code> example), this is probably your only option.</p>
<p>If you don't mind overriding <code>__new__</code> rather than <code>__init__</code>, you can even have both, with the <code>__new__</code> method handling one form of arguments by itself and referring other kinds to the factory methods for regularizing. Here's an example of what that might look like, including doc strings for the multiple signatures to <code>__new__</code>:</p>
<pre><code>class Circle(object):
    """Circle(center, radius) -&gt; Circle object
       Circle(point1, point2, point3) -&gt; Circle object
       Circle(curve1, curve2, curve3) -&gt; Circle object

       Return a Circle with the provided center and radius. If three points are given,
       the center and radius will be computed so that the circle will pass through each
       of the points. If three curves are given, the circle's center and radius will
       be chosen so that the circle will be tangent to each of them."""

    def __new__(cls, *args):
        if len(args) == 2:
            self = super(Circle, cls).__new__(cls)
            self.center, self.radius = args
            return self
        elif len(args) == 3:
            if all(isinstance(arg, Point) for arg in args):
                return Circle.through_points(*args)
            elif all(isinstance(arg, Curve) for arg in args):
                return Circle.tangent_to_curves(*args)
        raise TypeError("Invalid arguments to Circle()")

    @classmethod
    def through_points(cls, point1, point2, point3):
        """from_points(point1, point2, point3) -&gt; Circle object

        Return a Circle that touches three points."""

        # compute center and radius from the points...
        # then call back to the main constructor:
        return cls(center, radius)

    @classmethod
    def tangent_to_curves(cls, curve1, curve2, curve3):
        """from_curves(curve1, curve2, curve3) -&gt; Circle object

        Return a Circle that is tangent to three curves."""

        # here too, compute center and radius from curves ...
        # then call back to the main constructor:
        return cls(center, radius)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary, like so</p>
<pre><code>Circle({'points':[p1,p2,p3]})
Circle({'radius':r})
Circle({'curves':[c1,c2,c3])
</code></pre>
<p>And the initializer would say</p>
<pre><code>def __init__(args):
  if len(args)&gt;1:
    raise SomeError("only pass one of points, radius, curves")
  if 'points' in args: {blah}
  elsif 'radius' in args: {blahblah}
  elsif 'curves' in args: {evenmoreblah}
  else: raise SomeError("same as above")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to just write code parse the args yourself. Then you wouldn't have to change the API at all. You could even write a decorator so it'd be reusable:</p>
<pre><code>import functools

def overload(func):
  '''Creates a signature from the arguments passed to the decorated function and passes it as the first argument'''
  @functools.wraps(func)
  def inner(*args):
    signature = tuple(map(type, args))
    return func(signature, *args)
  return inner

def matches(collection, sig):
  '''Returns True if each item in collection is an instance of its respective item in signature'''
  if len(sig)!=len(collection): 
    return False
  return all(issubclass(i, j) for i,j in zip(collection, sig))

@overload
def Circle1(sig, *args):  
  if matches(sig, (Point,)*3):
    #do stuff with args
    print "3 points"
  elif matches(sig, (Point, float)):
    #as before
    print "point, float"
  elif matches(sig, (Curve,)*3):
    #and again
    print "3 curves"
  else:
    raise TypeError("Invalid argument signature")

# or even better
@overload
def Circle2(sig, *args):
  valid_sigs = {(Point,)*3: CircleThroughThreePoints,
                (Point, float): CircleCenterRadius,
                (Curve,)*3: CircleTangentThreeCurves
               }
  try:  
    return (f for s,f in valid_sigs.items() if matches(sig, s)).next()(*args)
  except StopIteration:
    raise TypeError("Invalid argument signature")
</code></pre>
<h2>How it appears to API users:</h2>
<p>This is the best part. To an API user, they just see this:</p>
<pre><code>&gt;&gt;&gt; help(Circle)

Circle(*args)
  Whatever's in Circle's docstring. You should put info here about valid signatures.
</code></pre>
<p>They can just call <code>Circle</code> like you showed in your question.</p>
<h2>How it works:</h2>
<p>The whole idea is to hide the signature-matching from the API. This is accomplished by using a <a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/" rel="nofollow">decorator</a> to create a signature, basically a tuple containing the types of each of the arguments, and passing that as the first argument to the functions.</p>
<h3>overload:</h3>
<p>When you decorate a function with <code>@overload</code>, <code>overload</code> is called with that function as an argument. Whatever is returned (in this case <code>inner</code>) replaces the decorated function. <code>functools.wraps</code> ensures that the new function has the same name, docstring, etc.</p>
<p>Overload is a fairly simple decorator. All it does is make a tuple of the types of each argument and pass that tuple as the first argument to the decorated function.</p>
<h3>Circle take 1:</h3>
<p>This is the simplest approach. At the beginning of the function, just test the signature against all valid ones. </p>
<h3>Circle take 2:</h3>
<p>This is a little more fancy. The benefit is that you can define all of your valid signatures together in one place. The return statement uses a generator to filter the matching valid signature from the dictionary, and <code>.next()</code> just gets the first one. Since that entire statement returns a function, you can just stick a <code>()</code> afterwards to call it. If none of the valid signatures match, <code>.next()</code> raises a <code>StopIteration</code>.</p>
<p>All in all, this function just returns the result of the function with the matching signature.</p>
<h3>final notes:</h3>
<p>One thing you see a lot in this bit of code is the <code>*args</code> construct. When used in a function definition, it just stores all the arguments in a list named "args". Elsewhere, it expands a list named <code>args</code> so that each item becomes an argument to a function (e.g. <code>a = func(*args)</code>).</p>
<p>I don't think it's terribly uncommon to do odd things like this to present clean APIs in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a number of modules in PyPI that can help you with signature based overloading and dispatch: <a href="https://pypi.python.org/pypi/multipledispatch/0.4.5" rel="nofollow">multipledispatch</a>, <a href="https://pypi.python.org/pypi/multimethods" rel="nofollow">multimethods</a>, <a href="https://pypi.python.org/pypi/Dispatching" rel="nofollow">Dispatching</a> - none of which I have real experience with, but <code>multipledispatch</code> looks like what you want and it's well documented. Using your circle example:</p>
<pre><code>from multipledispatch import dispatch

class Point(tuple):
    pass

class Curve(object):         
    pass

@dispatch(Point, Point, Point)
def Circle(point1, point2, point3):
    print "Circle(point1, point2, point3): point1 = %r, point2 = %r, point3 = %r" % (point1, point2, point3)

@dispatch(Point, int)
def Circle(centre, radius):
    print "Circle(centre, radius): centre = %r, radius = %r" % (centre, radius)

@dispatch(Curve, Curve, Curve)
def Circle(curve1, curve2, curve3):
    print "Circle(curve1, curve2, curve3): curve1 = %r, curve2 = %r, curve3 = %r" % (curve1, curve2, curve3)


&gt;&gt;&gt; Circle(Point((10,10)), Point((20,20)), Point((30,30)))
Circle(point1, point2, point3): point1 = (10, 10), point2 = (20, 20), point3 = (30, 30)
&gt;&gt;&gt; p1 = Point((25,10))
&gt;&gt;&gt; p1
(10, 10)
&gt;&gt;&gt; Circle(p1, 100)
Circle(centre, radius): centre = (25, 10), radius = 100

&gt;&gt;&gt; Circle(*(Curve(),)*3)
Circle(curve1, curve2, curve3): curve1 = &lt;__main__.Curve object at 0xa954d0&gt;, curve2 = &lt;__main__.Curve object at 0xa954d0&gt;, curve3 = &lt;__main__.Curve object at 0xa954d0&gt;

&gt;&gt;&gt; Circle()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/mhawke/virtualenvs/urllib3/lib/python2.7/site-packages/multipledispatch/dispatcher.py", line 143, in __call__
    func = self.resolve(types)
  File "/home/mhawke/virtualenvs/urllib3/lib/python2.7/site-packages/multipledispatch/dispatcher.py", line 184, in resolve
    (self.name, str_signature(types)))
NotImplementedError: Could not find signature for Circle: &lt;&gt;
</code></pre>
<p>It's also possible to decorate instance methods, so you can provide multiple implementations of <code>__init__()</code>, which is quite nice. If you were implementing any actual behaviour within the class, e.g. <code>Circle.draw()</code>, you would need some logic to work out what values are available with to draw the circle (centre and radius, 3 points, etc). But as this is just to provide a set of bindings, you probably only need to call the correct native code function and pass on the parameters  :</p>
<pre><code>from numbers import Number
from multipledispatch import dispatch

class Point(tuple):
    pass

class Curve(object):
    pass

class Circle(object):
    "A circle class"

    # dispatch(Point, (int, float, Decimal....))
    @dispatch(Point, Number)
    def __init__(self, centre, radius):
        """Circle(Point, Number): create a circle from a Point and radius."""

        print "Circle.__init__(): centre %r, radius %r" % (centre, radius)

    @dispatch(Point, Point, Point)
    def __init__(self, point1, point2, point3):
        """Circle(Point, Point, Point): create a circle from 3 points."""

        print "Circle.__init__(): point1 %r, point2 %r, point3 = %r" % (point1, point2, point3)

    @dispatch(Curve, Curve, Curve)
    def __init__(self, curve1, curve2, curve3):
        """Circle(Curve, Curve, Curve): create a circle from 3 curves."""

        print "Circle.__init__(): curve1 %r, curve2 %r, curve3 = %r" % (curve1, curve2, curve3)

    __doc__ = '' if __doc__ is None else '{}\n\n'.format(__doc__)
    __doc__ += '\n'.join(f.__doc__ for f in __init__.funcs.values())


&gt;&gt;&gt; print Circle.__doc__
A circle class

Circle(Point, Number): create a circle from a Point and radius.
Circle(Point, Point, Point): create a circle from 3 points.
Circle(Curve, Curve, Curve): create a circle from 3 curves.

&gt;&gt;&gt; for num in 10, 10.22, complex(10.22), True, Decimal(100):
...     Circle(Point((10,20)), num)
... 
Circle.__init__(): centre (10, 20), radius 10
&lt;__main__.Circle object at 0x1d42fd0&gt;
Circle.__init__(): centre (10, 20), radius 10.22
&lt;__main__.Circle object at 0x1e3d890&gt;
Circle.__init__(): centre (10, 20), radius (10.22+0j)
&lt;__main__.Circle object at 0x1d42fd0&gt;
Circle.__init__(): centre (10, 20), radius True
&lt;__main__.Circle object at 0x1e3d890&gt;
Circle.__init__(): centre (10, 20), radius Decimal('100')
&lt;__main__.Circle object at 0x1d42fd0&gt;

&gt;&gt;&gt; Circle(Curve(), Curve(), Curve())
Circle.__init__(): curve1 &lt;__main__.Curve object at 0x1e3db50&gt;, curve2 &lt;__main__.Curve object at 0x1d42fd0&gt;, curve3 = &lt;__main__.Curve object at 0x1d4b1d0&gt;
&lt;__main__.Circle object at 0x1d4b4d0&gt;

&gt;&gt;&gt; p1=Point((10,20))
&gt;&gt;&gt; Circle(*(p1,)*3)
Circle.__init__(): point1 (10, 20), point2 (10, 20), point3 = (10, 20)
&lt;__main__.Circle object at 0x1e3d890&gt;

&gt;&gt;&gt; Circle()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/mhawke/virtualenvs/urllib3/lib/python2.7/site-packages/multipledispatch/dispatcher.py", line 235, in __call__
    func = self.resolve(types)
  File "/home/mhawke/virtualenvs/urllib3/lib/python2.7/site-packages/multipledispatch/dispatcher.py", line 184, in resolve
    (self.name, str_signature(types)))
NotImplementedError: Could not find signature for __init__: &lt;&gt;
</code></pre>
</div>
<span class="comment-copy">You can simulate signature-based overloading in Python different ways, but for cases like the <code>BezierCurve</code> vs <code>BezierCurveThroughPoints</code> example you're going to need to use different functions names or add an argument to a single function which is used to differentiate them and provide a means to determine the intended usage of the otherwise identical arguments.</span>
<span class="comment-copy">Understood. Even in VB and C#, I need different function names in this case. The question was whether or not my Python API should use this approach in all cases.</span>
<span class="comment-copy"><code>from_points</code> and friends are known as factory methods, which is a very useful pattern.</span>
<span class="comment-copy">Your suggestion of <code>classmethod</code> alternative constructors is a good one, but for the overloaded <code>__init__</code> method I'd suggest using <code>*args</code> and inspecting the types, rather than requiring keywords to distinguish between the options.</span>
<span class="comment-copy">@bubba It's immediately clear that the object being returned when you call <code>Circle.from_points</code> is a <code>Circle</code>, but it is somewhat ambiguous what <code>CircleThroughThreePoints</code> is going to return without first looking at the documentation. It's also an idiom fairly commonly used in Python. The built-in <a href="https://docs.python.org/2/library/datetime.html#datetime-objects" rel="nofollow noreferrer"><code>datetime</code></a> module uses it, for example.</span>
<span class="comment-copy">@bubba Only providing a constructor/function with <code>*args</code> makes it hard for the user to figure out what input is valid, <i>and</i> makes it harder for you to figure out if the user provided valid input. The only way for the user to know what input is legal is to read the docs, which is not good API design. And then you have to do a bunch of introspection at runtime to figure out what the user provided and if its valid, which is bug prone on both your end and the users. The more verbose approach is less elegant, but self documenting and less susceptible to bugs.</span>
<span class="comment-copy">@bubba Yes, it would be nice to have true function overloading. There is <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch</code></a> in Python 3.x, but it's pretty limited (top-level functions only, overloads strictly based on the first argument).</span>
<span class="comment-copy">This is a good pattern (used extensively by the BDFL himself in Google App Engine's NDB API), but you have several errors. You've used <code>def</code> instead of <code>class</code> to define the class and none of your class methods take <code>cls</code> as a first argument. Finally, it's good style to preface "private" methods (and I use the term loosely) with an underscore.</span>
<span class="comment-copy">Thanks for pointing out my silly typos. I've fixed the <code>def</code> and missing <code>cls</code> parameters. I left the names without underscores, as the factory methods can be part of the public API (even though they're somewhat redundant, given the main constructor).</span>
<span class="comment-copy">@Blckknght I think you're missing a <code>return self</code> in <code>__new__</code>.</span>
<span class="comment-copy">Thanks. Is this a common approach, or would people (especially newbies) likely find it bizarre/exotic/confusing?</span>
<span class="comment-copy">Rather than this, you probably should use <code>**kwargs</code> instead, of you want to force the use of keyword arguments.</span>
<span class="comment-copy">Thanks. That looks promising if it's not too unPythonic. Sorry, but I'm not yet smart enough to understand what you wrote. What would the function calls/usage and the function documentation look like?</span>
<span class="comment-copy">Interesting approach. However the type-matching that's done is unPythonic (non-polymorphic) as it doesn't support arguments of types derived from those explicitly named. You might be able fix that by using <code>isinstance()</code> in the signature matching instead of <code>type()</code>.</span>
<span class="comment-copy">&gt; doesn't support arguments of types derived from those explicitly named. That would be a big problem. I have many different curve types derived from Curve, and I'd need to be able to receive these as input, for use in the TangentThreeCurves variant.</span>
<span class="comment-copy">@bubba: I've altered it a bit. Now it'll support derived types.</span>
<span class="comment-copy">Fixed it, and actually tested it this time. It'll all work.</span>
<span class="comment-copy">Looks useful. Do you know if it supports polymorphic arguments? For example, if <code>BezierCurve</code> was derived from <code>Curve</code>, would <code>Circle(bezier1, bezier2, bezier3)</code> still dispatch to <code>__init__(self, curve1, curve2, curve3)</code>?</span>
<span class="comment-copy">Thanks. In this approach, where does the documentation go? If the user wants to know how to call each of the 3 (or more) functions for creating circles, where does he (or she) look?</span>
<span class="comment-copy">@martineau -- I'm a Python neophyte, so maybe this is a stupid question. If a Python function is designed to receive objects of certain types as input, then doesn't it <i>automatically</i> work if objects of derived types are input??</span>
<span class="comment-copy">@bubba: Python functions aren't really "designed" to receive object of any particular type. The only way that can come up is if somewhere in the function, code tries to do something illegal to one of the arguments. As long as they all expose the same methods, it doesn't matter. For example, if a function just adds 1 to every item in a collection, you could pass a list, tuple, dictionary, file object, anything iterator really. If it walks like a duck and quacks like a duck...</span>
<span class="comment-copy">@bubba: re documentation, I think that you'd need to document at the class level, rather than the individual versions of <code>__init__()</code>. Then <code>help(Circle)</code> would display the class docstring (as well as method docstrings). <code>Circle.__init__.__doc__</code> is set by <code>multipledispatch</code>.</span>
