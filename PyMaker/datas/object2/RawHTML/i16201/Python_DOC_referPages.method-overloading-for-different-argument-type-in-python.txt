<div class="post-text" itemprop="text">
<p>I'm writing a preprocessor in python, part of which works with an AST.</p>
<p>There is a <code>render()</code> method that takes care of converting various statements to source code.</p>
<p>Now, I have it like this (shortened):</p>
<pre><code>def render(self, s):
    """ Render a statement by type. """

    # code block (used in structures)
    if isinstance(s, S_Block):
        # delegate to private method that does the work
        return self._render_block(s)

    # empty statement
    if isinstance(s, S_Empty):
        return self._render_empty(s)

    # a function declaration
    if isinstance(s, S_Function):
        return self._render_function(s)

    # ...
</code></pre>
<p>As you can see, it's tedious, prone to errors and a the code is quite long (I have many more kinds of statements).</p>
<p>The ideal solution would be (in Java syntax):</p>
<pre><code>String render(S_Block s)
{
    // render block
}

String render(S_Empty s)
{
    // render empty statement
}

String render(S_Function s)
{
    // render function statement
}

// ...
</code></pre>
<p>Of course, python can't do this, because it has dynamic typing. When I searched for how to mimick method overloading, all answers just said "You don't want to do that in python". I guess that is true in some cases, but here <code>kwargs</code> is really not useful at all.</p>
<p>How would I do this in python, without the hideous kilometre-long sequence if type checking ifs, as shown above? Also, preferably a "pythonic" way to do so?</p>
<p><strong>Note:</strong> There can be multiple "Renderer" implementations, which render the statements in different manners. I can't therefore move the rendering code to the statements and just call <code>s.render()</code>. It must be done in the renderer class.</p>
<p>(I've found some <a href="http://curtis.schlak.com/2013/06/20/follow-up-to-python-visitor-pattern.html">interesting "visitor" code</a>, but I'm not sure if it's really the thing I want).</p>
</div>
<div class="post-text" itemprop="text">
<p>Would something like this work?</p>
<pre><code>self.map = {
            S_Block : self._render_block,
            S_Empty : self._render_empty,
            S_Function: self._render_function
}
def render(self, s):
    return self.map[type(s)](s)
</code></pre>
<p>Keeping a reference to a class object as a key in a dictionary and having it's value be the function object you want to call will make your code shorter and less error prone. The only place an error could occur here would be in the definition of the dictionary. Or one of your internal functions of course.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.4 (or are willing to install the <a href="https://pypi.python.org/pypi/singledispatch" rel="noreferrer">backport</a> for Python 2.6+), you can use <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="noreferrer"><code>functools.singledispatch</code></a> for this*:</p>
<pre><code>from functools import singledispatch

class S_Block(object): pass
class S_Empty(object): pass
class S_Function(object): pass


class Test(object):
    def __init__(self):
        self.render = singledispatch(self.render)
        self.render.register(S_Block, self._render_block)
        self.render.register(S_Empty, self._render_empty)
        self.render.register(S_Function, self._render_function)

    def render(self, s):
        raise TypeError("This type isn't supported: {}".format(type(s)))

    def _render_block(self, s):
        print("render block")

    def _render_empty(self, s):
        print("render empty")

    def _render_function(self, s):
        print("render function")


if __name__ == "__main__":
    t = Test()
    b = S_Block()
    f = S_Function()
    e = S_Empty()
    t.render(b)
    t.render(f)
    t.render(e)
</code></pre>
<p>Output:</p>
<pre><code>render block
render function
render empty
</code></pre>
<p><sub>*Code based on <a href="https://gist.github.com/ambv/5682351" rel="noreferrer">this gist.</a></sub></p>
</div>
<div class="post-text" itemprop="text">
<p>The overloading syntax you are looking for can be achieved using <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605" rel="noreferrer">Guido van Rossum's multimethod decorator</a>. </p>
<p>Here is a variant of the multimethod decorator which can decorate class methods (the original decorates plain functions). I've named the variant <code>multidispatch</code> to disambiguate it from the original:</p>
<pre><code>import functools

def multidispatch(*types):
    def register(function):
        name = function.__name__
        mm = multidispatch.registry.get(name)
        if mm is None:
            @functools.wraps(function)
            def wrapper(self, *args):
                types = tuple(arg.__class__ for arg in args) 
                function = wrapper.typemap.get(types)
                if function is None:
                    raise TypeError("no match")
                return function(self, *args)
            wrapper.typemap = {}
            mm = multidispatch.registry[name] = wrapper
        if types in mm.typemap:
            raise TypeError("duplicate registration")
        mm.typemap[types] = function
        return mm
    return register
multidispatch.registry = {}
</code></pre>
<p>and it can be used like this:</p>
<pre><code>class Foo(object):
    @multidispatch(str)
    def render(self, s):
        print('string: {}'.format(s))
    @multidispatch(float)
    def render(self, s):
        print('float: {}'.format(s))
    @multidispatch(float, int)
    def render(self, s, t):
        print('float, int: {}, {}'.format(s, t))

foo = Foo()
foo.render('text')
# string: text
foo.render(1.234)
# float: 1.234
foo.render(1.234, 2)
# float, int: 1.234, 2
</code></pre>
<p>The demo code above shows how to overload the <code>Foo.render</code> method based on the types of its arguments.</p>
<p>This code searches for exact matching types as opposed to checking for <code>isinstance</code> relationships. It could be modified to handle that (at the expense of making the lookups O(n) instead of O(1)) but since it sounds like you don't need this anyway, I'll leave the code in this simpler form.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add some performance measurements to the @unutbu 's answer:</p>
<pre><code>@multimethod(str)
def foo(bar: str) -&gt; int:
    return 'string: {}'.format(bar)

@multimethod(float)
def foo(bar: float) -&gt; int:
    return 'float: {}'.format(bar)

def foo_simple(bar):
    return 'string: {}'.format(bar)
</code></pre>
<hr/>
<pre><code>import time

string_type = "test"
iterations = 10000000

start_time1 = time.time()
for i in range(iterations):
    foo(string_type)
end_time1 = time.time() - start_time1


start_time2 = time.time()
for i in range(iterations):
    foo_simple(string_type)
end_time2 = time.time() - start_time2

print("multimethod: " + str(end_time1))
print("standard: " + str(end_time2))
</code></pre>
<hr/>
<p>Returns:</p>
<pre><code>&gt; multimethod: 16.846999883651733
&gt; standard:     4.509999990463257
</code></pre>
</div>
<span class="comment-copy">Check out the answers for <a href="http://stackoverflow.com/questions/25336481/overloading-or-alternatives-in-python-api-design/25336653?noredirect=1#comment39516486_25336653">this question</a>. This one is technically a duplicate but it's received some different answers so I'm hesitant to flag it.</span>
<span class="comment-copy">oh man beat me by like few seconds!</span>
<span class="comment-copy"><code>isinstance</code> returns true for subclasses as well as the class itself.  You can't match the semantics with a mapping.</span>
<span class="comment-copy">@Joowani Great minds thing a like. The only thing you should consider is that in my implementation the dictionary is static and will be used across all instances of the class. Where your dictionary must be instantiated every time the function is used.</span>
<span class="comment-copy">@roippi I never used isinstance? edit: Oh I see what you mean now. I hadn't considered that but it doesn't seem to be what the op is needing.</span>
<span class="comment-copy">Interesting approach, and @roippi that's really not an issue here, I'm always matching for the "deepest child" of the hierarchy, eg. S_If, and not S_BranchingStatement (if I had one). I'll wait a while if something better turns up, but this certainly looks like a good technique (not perfect, but at least less verbose).</span>
