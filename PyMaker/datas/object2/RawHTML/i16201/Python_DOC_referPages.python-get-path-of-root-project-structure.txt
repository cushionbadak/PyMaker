<div class="post-text" itemprop="text">
<p>I've got a python project with a configuration file in the project root. 
The configuration file needs to be accessed in a few different files throughout the project. </p>
<p>So it looks something like: <code>&lt;ROOT&gt;/configuration.conf</code>
<code>&lt;ROOT&gt;/A/a.py</code>, <code>&lt;ROOT&gt;/A/B/b.py</code> (when b,a.py access the configuration file). </p>
<p>What's the best / easiest way to get the path to the project root and the configuration file without depending on which file inside the project I'm in? i.e without using <code>../../</code>? It's okay to assume that we know the project root's name.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this how Django does it: <strong>define a variable to the Project Root from a file that is in the top-level of the project.</strong> For example, if this is what your project structure looks like:</p>
<pre><code>project/
    configuration.conf
    definitions.py
    main.py
    utils.py
</code></pre>
<p>In <code>definitions.py</code> you can define (this requires <code>import os</code>):</p>
<pre><code>ROOT_DIR = os.path.dirname(os.path.abspath(__file__)) # This is your Project Root
</code></pre>
<p>Thus, with the <strong>Project Root</strong> known, you can <strong>create a variable that points to the location of the configuration</strong> (this can be defined anywhere, but a logical place would be to put it in a location where constants are defined - e.g. <code>definitions.py</code>):</p>
<pre><code>CONFIG_PATH = os.path.join(ROOT_DIR, 'configuration.conf')  # requires `import os`
</code></pre>
<p>Then, you can easily access the constant (in any of the other files) with the import statement (e.g. in <code>utils.py</code>): <code>from definitions import CONFIG_PATH</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To get the path of the "root" module, you can use:</p>
<pre><code>import os
import sys
os.path.dirname(sys.modules['__main__'].__file__)
</code></pre>
<p>But more interestingly if you have an config "object" in your top-most module you could -read- from it like so:</p>
<pre><code>app = sys.modules['__main__']
stuff = app.config.somefunc()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Other answers advice to use file in top-level of the project. This is not necessary if you use <code>pathlib.Path</code> and <code>parent</code>. Consider the following directory structure where all files except <code>README.md</code> and <code>utils.py</code> have been omitted.</p>
<pre><code>project
│   README.md
|
└───src
│   │   utils.py
|   |   ...
|   ...
</code></pre>
<p>In <code>utils.py</code> we define the following function.</p>
<pre><code>from pathlib import Path

def get_project_root() -&gt; Path:
    """Returns project root folder."""
    return Path(__file__).parent.parent
</code></pre>
<p>In any module in the project we can now get the project root as follows.</p>
<pre><code>from src.utils import get_project_root

root = get_project_root()
</code></pre>
<p><strong>Benefits</strong>: Any module which calls <code>get_project_root</code> can be moved without changing program behavior. Only when the module <code>utils.py</code> is moved we have to update <code>get_project_root</code> and the imports (use IDE refactoring to automate this).</p>
</div>
<div class="post-text" itemprop="text">
<p>A standard way to achieve this would be to use the <code>pkg_resources</code> module which is part of the <code>setuptools</code> package.  <code>setuptools</code> is used to create an install-able python package.</p>
<p>You can use <code>pkg_resources</code> to return the contents of your desired file as a string and you can use <code>pkg_resources</code> to get the actual path of the desired file on your system.</p>
<p>Let's say that you have a package called <code>stackoverflow</code>.</p>
<pre><code>stackoverflow/
|-- app
|   `-- __init__.py
`-- resources
    |-- bands
    |   |-- Dream\ Theater
    |   |-- __init__.py
    |   |-- King's\ X
    |   |-- Megadeth
    |   `-- Rush
    `-- __init__.py

3 directories, 7 files
</code></pre>
<p>Now let's say that you want to access the file Rush from a module <code>app.run</code>. Use <code>pkg_resources.resouces_filename</code> to get the path to Rush and <code>pkg_resources.resource_string</code> to get the contents of Rush; thusly:</p>
<pre><code>import pkg_resources

if __name__ == "__main__":
    print pkg_resources.resource_filename('resources.bands', 'Rush')
    print pkg_resources.resource_string('resources.bands', 'Rush')
</code></pre>
<p>The output:</p>
<pre><code>/home/sri/workspace/stackoverflow/resources/bands/Rush
Base: Geddy Lee
Vocals: Geddy Lee
Guitar: Alex Lifeson
Drums: Neil Peart
</code></pre>
<p>This works for all packages in your python path. So if you want to know where <code>lxml.etree</code> exists on your system:</p>
<pre><code>import pkg_resources

if __name__ == "__main__":
    print pkg_resources.resource_filename('lxml', 'etree')
</code></pre>
<p>output:</p>
<pre><code>/usr/lib64/python2.7/site-packages/lxml/etree
</code></pre>
<p>The point is that you can use this standard method to access files that are installed on your system (e.g pip install xxx or yum -y install python-xxx) and files that are within the module that you're currently working on.</p>
</div>
<div class="post-text" itemprop="text">
<p>All the previous solutions seem to be overly complicated for what I think you need, and often didn't work for me. The following one-line command does what you want:</p>
<pre><code>import os
ROOT_DIR = os.path.abspath(os.curdir)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This worked for me using a standard PyCharm project with my virtual environment (venv) under the project root directory.</p>
<p>Code below isnt the prettiest, but consistently gets the project root. It returns the full directory path to venv from the <code>VIRTUAL_ENV</code> environment variable e.g. <code>/Users/NAME/documents/PROJECT/venv</code></p>
<p>It then splits the path at the last <code>/</code>, giving an array with two elements. The first element will be the project path e.g. <code>/Users/NAME/documents/PROJECT</code> </p>
<pre><code>import os

print(os.path.split(os.environ['VIRTUAL_ENV'])[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've recently been trying to do something similar and I have found these answers inadequate for my use cases (a distributed library that needs to detect project root). Mainly I've been battling different environments and platforms, and still haven't found something perfectly universal.</p>
<h1>Code local to project</h1>
<p>I've seen this example mentioned and used in a few places, Django, etc.</p>
<pre><code>import os
print(os.path.dirname(os.path.abspath(__file__)))
</code></pre>
<p>Simple as this is, it only works when the file that the snippet is in is actually part of the project. <strong>We do not retrieve the project directory, but instead the snippet's directory</strong> </p>
<p>Similarly, the <em>sys.modules</em> approach breaks down when <strong>called</strong> from outside the entrypoint of the application, specifically I've observed a child thread cannot determine this without relation back to the '<strong>main</strong>' module. I've explicitly put the import inside a function to demonstrate an import from a child thread, moving it to top level of app.py would fix it.</p>
<pre><code>app/
|-- config
|   `-- __init__.py
|   `-- settings.py
`-- app.py
</code></pre>
<p>app.py</p>
<pre><code>#!/usr/bin/env python
import threading


def background_setup():
    # Explicitly importing this from the context of the child thread
    from config import settings
    print(settings.ROOT_DIR)


# Spawn a thread to background preparation tasks
t = threading.Thread(target=background_setup)
t.start()

# Do other things during initialization

t.join()

# Ready to take traffic
</code></pre>
<p>settings.py</p>
<pre><code>import os
import sys


ROOT_DIR = None


def setup():
    global ROOT_DIR
    ROOT_DIR = os.path.dirname(sys.modules['__main__'].__file__)
    # Do something slow
</code></pre>
<p>Running this program produces an attribute error:</p>
<pre><code>&gt;&gt;&gt; import main
&gt;&gt;&gt; Exception in thread Thread-1:
Traceback (most recent call last):
  File "C:\Python2714\lib\threading.py", line 801, in __bootstrap_inner
    self.run()
  File "C:\Python2714\lib\threading.py", line 754, in run
    self.__target(*self.__args, **self.__kwargs)
  File "main.py", line 6, in background_setup
    from config import settings
  File "config\settings.py", line 34, in &lt;module&gt;
    ROOT_DIR = get_root()
  File "config\settings.py", line 31, in get_root
    return os.path.dirname(sys.modules['__main__'].__file__)
AttributeError: 'module' object has no attribute '__file__'
</code></pre>
<p>...hence a threading-based solution</p>
<h1>Location independent</h1>
<p>Using the same application structure as before but modifying settings.py</p>
<pre><code>import os
import sys
import inspect
import platform
import threading


ROOT_DIR = None


def setup():
    main_id = None
    for t in threading.enumerate():
        if t.name == 'MainThread':
            main_id = t.ident
            break

    if not main_id:
        raise RuntimeError("Main thread exited before execution")

    current_main_frame = sys._current_frames()[main_id]
    base_frame = inspect.getouterframes(current_main_frame)[-1]

    if platform.system() == 'Windows':
        filename = base_frame.filename
    else:
        filename = base_frame[0].f_code.co_filename

    global ROOT_DIR
    ROOT_DIR = os.path.dirname(os.path.abspath(filename))
</code></pre>
<p>Breaking this down:
First we want to accurately find the thread ID of the main thread. In Python3.4+ the threading library has <code>threading.main_thread()</code> however, everybody doesn't use 3.4+ so we search through all threads looking for the main thread save it's ID. If the main thread has already exited, it won't be listed in the <code>threading.enumerate()</code>. We raise a <code>RuntimeError()</code> in this case until I find a better solution.</p>
<pre><code>main_id = None
for t in threading.enumerate():
    if t.name == 'MainThread':
        main_id = t.ident
        break

if not main_id:
    raise RuntimeError("Main thread exited before execution")
</code></pre>
<p>Next we find the very first stack frame of the main thread. <strong>Using the cPython specific function</strong> <code>sys._current_frames()</code> we get a dictionary of every thread's current stack frame. Then utilizing <code>inspect.getouterframes()</code> we can retrieve the entire stack for the main thread and the very first frame.
    current_main_frame = sys._current_frames()[main_id]
    base_frame = inspect.getouterframes(current_main_frame)[-1]
Finally, the differences between Windows and Linux implementations of <code>inspect.getouterframes()</code> need to be handled. Using the cleaned up filename, <code>os.path.abspath()</code> and <code>os.path.dirname()</code> clean things up.</p>
<pre><code>if platform.system() == 'Windows':
    filename = base_frame.filename
else:
    filename = base_frame[0].f_code.co_filename

global ROOT_DIR
ROOT_DIR = os.path.dirname(os.path.abspath(filename))
</code></pre>
<p>So far I've tested this on Python2.7 and 3.6 on Windows as well as Python3.4 on WSL</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I struggled with this problem too until I came to this solution.
This is the cleanest solution in my opinion.</p>
<p>In your <strong>setup.py</strong> add "packages"</p>
<pre><code>setup(
name='package_name'
version='0.0.1'
.
.
.
packages=['package_name']
.
.
.
)
</code></pre>
<p>In your <strong>python_script.py</strong></p>
<pre><code>import pkg_resources
import os

resource_package = pkg_resources.get_distribution(
    'package_name').location
config_path = os.path.join(resource_package,'configuration.conf')
</code></pre>
</div>
<span class="comment-copy">does <code>&lt;ROOT&gt;/__init__.py</code> exist?</span>
<span class="comment-copy">Either your configuration file is a python module, and you can easily access it just with an import statement, either it's not a python module and you should put it in a well known location. For example $HOME/.my_project/my_project.conf.</span>
<span class="comment-copy">@JohnSmithOptional - It's a JSON file. I need to be able to access it using the path. Yes. All of the folders include it.</span>
<span class="comment-copy">_ It's okay to assume that we know the project root's name._ Does that mean you know the path to the project? Isn't it just os.path.join(known_root_name, "configuration.conf") then?</span>
<span class="comment-copy">If it's a user configuration I'd generally use something like <code>os.path.expanduser('~/.myproject/myproject.conf')</code>. It works on Unix and Windows.</span>
<span class="comment-copy">To include the definitions.py file like that, will it be required to add a <code>__init__.py</code> file to the root project directory as well ? Should that be correct ? I've just started with python and not sure on the best practices. Thanks.</span>
<span class="comment-copy">@akskap: No, an <code>__init__.py</code> will not be required, as that file is only required when defining packages: <i>The <code>__init__.py</code> files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, <code>__init__.py</code> can just be an empty file, but it can also execute initialization code for the package or set the <code>__all__</code> variable, described later.</i>  See: <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#packages</a></span>
<span class="comment-copy">I am curious, style wise, whether it is acceptable or frowned upon to add these definitions to the <code>__init.py__</code> of the root package. It would save creating another file, as well as allow the nicer syntax of <code>from root_pack import ROOT_DIR, CONFIG_PATH</code>.</span>
<span class="comment-copy">@Johndt6: the convention is to keep <code>__init__.py</code> empty, but that isn't strictly true (it's a convention after all). See this for more: <a href="http://stackoverflow.com/questions/2361124/using-init-py">stackoverflow.com/questions/2361124/using-init-py</a></span>
<span class="comment-copy">Here <code>os</code> is not by default available. Need to import <code>os</code>. So adding the line <code>import os</code> would make the answer more complete.</span>
<span class="comment-copy">Here <code>os</code> is not by default available. Need to import <code>os</code>. So adding the line <code>import os</code> would make the answer more complete.</span>
<span class="comment-copy">This gives the directory that contains the script that was executed. For example, when running <code>python3 -m topmodule.submodule.script</code> it will give <code>/path/to/topmodule/submodule</code> instead of <code>/path/to/topmodule</code>.</span>
<span class="comment-copy">I like your band choice !</span>
<span class="comment-copy">Ah yes.  The good ol' boys.  10 bucks is 10 bucks, eh?</span>
<span class="comment-copy">Put that in config.py, at the root of the directory, .. bamn! Yout got yourself a singleton.</span>
<span class="comment-copy">This won't work with setups like anaconda or pipenv, since the virtual environment isn't contained within the project in those cases.</span>
