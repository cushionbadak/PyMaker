<div class="post-text" itemprop="text">
<p>I want to translate some Haskell code into Python.
The Haskell classes/instances look like:</p>
<pre class="lang-hs prettyprint-override"><code>{-# LANGUAGE MultiParamTypeClasses #-}

module MyModule where

class Example a b where
    doSomething :: a -&gt; b -&gt; Bool 
    doSomethingElse :: a -&gt; b -&gt; Int

instance Example Int Int where
    doSomething a b = (a + b * 2) &gt; 5
    doSomethingElse a b = a - b * 4
</code></pre>
<p>Is there a way in Python to approximate the Haskell class/instance construct?
What is the least offensive way to translate this into Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't really have an analogue in Python, but you can fake it:</p>
<pre><code>def int_int_doSomething(a, b):
    return (a + b * 2) &gt; 5


def int_int_doSomethingElse(a, b):
    return a - b * 4


Example = {}
Example[(int, int)] = (int_int_doSomething, int_int_doSomethingElse)


def doSomething(a, b):
    types = type(a), type(b)
    return Example[types][0](a, b)


def doSomethingElse(a, b):
    types = type(a), type(b)
    return Example[types][1](a, b)
</code></pre>
<p>All you have to do is add new values to <code>Example</code> for each type combination you want to have.  You could even throw in some extra error handling in <code>doSomething</code> and <code>doSomethingElse</code>, or some other methods to make it easier.  Another way would be to make an object that keeps track of all of these and lets you add new types to the map in a more managed way, but it's just more bookkeeping on top of what I've already shown.</p>
<p>Keep in mind that this is essentially how Haskell does it, too, except the checks are performed at compile time.  Typeclasses are really nothing more than a dictionary lookup on the type to pick the appropriate functions to insert into the computation.  Haskell just does this automatically for you at compile time instead of you having to manage it yourself like you do in Python.</p>
<hr/>
<p>To add that bookkeeping, you could do something like the following, keeping it in its own module and then it'll only (by default) export the symbols in <code>__all__</code>.  This keeps things looking more like the Haskell version:</p>
<pre><code>class _Example(object):
    def __init__(self, doSomething, doSomethingElse):
        self.doSomething     = doSomething
        self.doSomethingElse = doSomethingElse

ExampleStore = {}

def register(type1, type2, instance):
    ExampleStore[(type1, type2)] = instance

def doSomething(a, b):
    types = type(a), type(b)
    return ExampleStore[types].doSomething(a, b)

def doSomethingElse(a, b):
    types = type(a), type(b)
    return ExampleStore[types].doSomethingElse(a, b)

def Example(type1, type2, doSomething, doSomethingElse):
    register(type1, type2, _Example(doSomething, doSomethingElse))

__all__ = [
    'doSomethingElse',
    'doSomethingElse',
    'Example'
]
</code></pre>
<p>Then you can make instances like</p>
<pre><code>Example(int, int,
    doSomething=lambda a, b: (a + b * 2) &gt; 5,
    doSomethingElse=lambda a, b: a - b * 4
)
</code></pre>
<p>Which looks <em>almost</em> like Haskell.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't have parametric types in Python, as it's dynamically typed. Also the distinction between <code>classes</code> and <code>instances</code> is clear in Python, but as <code>classes</code> are themselves "live objects", the distinction of usage might be a little bit blurred sometimes...</p>
<p>For your case, a classical implementation might go as:</p>
<pre><code>#you don't really need this base class, it's just for documenting purposes
class Example:
    def doSomething(self, a, b):
        raise "Not Implemented"
    def doSomethingElse(self, a, b):
        raise "Not Implemented"

class ConcreteClass(Example):
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    def doSomething(self, a, b):
        return (a + b * self.x) &gt; self.y
    def doSomethingElse(self, a, b):
        return a - b * self.z

 instance = ConcreteClass((2, 5, 4)
</code></pre>
<p>but I personally dislike that convoluted style, so you might just go with something more lightweight, like:</p>
<pre><code> from collections import namedtuple
 Example = namedtuple('Example', 'doSomething doSomethingElse')
 instance = Example((lambda a, b: (a + b * 2) &gt; 5),
                    (lambda a, b: a - b *4Â ))
</code></pre>
<p>And of course, rely on <em>duck typing</em> and usually "let it crash". The lack of type safety should be made up with extensive unit testing.</p>
</div>
<span class="comment-copy">I think it's going to be difficult to duplicate that in Python.  More or less the main point of that Haskell construct is to enforce the types and number of arguments that the function accepts and returns.  Python's dynamic typing makes that kind of type enforcement almost impossible.  (Python 3 function annotations get you part of the way, but are enforced at runtime, not compile time.)  You can certainly make a class and make a subclass that reimplements its methods, but you can't know whether the new implementation has the right signature until it's actually time to call it.</span>
<span class="comment-copy">TIP from <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">docs.python.org</a> (Python 3): <i>"To add overloaded implementations to the function, use the register() attribute of the generic function. It is a decorator, taking a type parameter and decorating a function implementing the operation for that type"</i></span>
