<div class="post-text" itemprop="text">
<p>I defined the function <code>f</code> as</p>
<pre><code>def f(flag):
    n = 10
    if flag:
        for i in range(n):
            yield i
    else:
        return range(n)
</code></pre>
<p>But <code>f</code> returns a generator no matter what <code>flag</code> is:</p>
<pre><code>&gt;&gt;&gt; f(True)
&lt;generator object f at 0x0000000003C5EEA0&gt;

&gt;&gt;&gt; f(False)
&lt;generator object f at 0x0000000007AC4828&gt;
</code></pre>
<p>And if I iterate over the returned object:</p>
<pre><code># prints normally
for i in f(True):
    print(i)

# doesn't print
for i in f(False):
    print(i)
</code></pre>
<p>It looks like <code>f(False)</code> returns a generator which has been iterated over. What's the reason? Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>A function containing a <code>yield</code> statement <strong>always</strong> returns a generator object.</p>
<p>Only when you iterate over that generator object will the code in the function be executed. Until that time, no code in the function is executed and Python <em>cannot know</em> that you'll just return.</p>
<p>Note that using <code>return</code> in a generator function has <em>different semantics</em> than in a regular function; <code>return</code> in this case simply is seen as 'exit the generator here'; the return value is discarded as a generator can only produce values via <code>yield</code> expressions.</p>
<p>It looks like you want to use <code>yield from</code> instead:</p>
<pre><code>def f(flag):
    n = 10
    if flag:
        for i in range(n):
            yield i
    else:
        yield from range(n)
</code></pre>
<p><code>yield from</code> requires Python 3.3 or up.</p>
<p>See the <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions"><code>yield</code> expression</a> documentation:</p>
<blockquote>
<p>Using a <code>yield</code> expression in a function’s body causes that function to be a generator.</p>
<p>When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. The execution starts when one of the generator’s methods is called. At that time, the execution proceeds to the first <code>yield</code> expression, where it is suspended again, returning the value of expression_list to the generator’s caller.</p>
</blockquote>
<p>Iteration over a generator calls the <a href="https://docs.python.org/3/reference/expressions.html#generator.__next__"><code>generator.__next__()</code> method</a>, triggering execution.</p>
<p>If you wanted to return a generator <em>some of the time</em>, then don't use <code>yield</code> in this function. You'd produce the generator by other means; using a separate function for example, or by using a generator expression perhaps:</p>
<pre><code>def f(flag):
    n = 10
    if flag:
        return (i for i in range(n))
    else:
        return range(n)
</code></pre>
<p>Now no <code>yield</code> is used in <code>f</code> and it will no longer produce a generator object directly. Instead, the generator expression <code>(i for i in range(n))</code> produces it, but only conditionally.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can work around this by using a nested function that actually uses <code>yield</code>:</p>
<pre><code>def f(flag):
    def gen():
        for i in range(n):
            yield i
    n = 10
    if flag:
        return gen()
    else:
        return range(n)

&gt;&gt;&gt; f(True)
&lt;generator object gen at 0x7f62017e3730&gt;
&gt;&gt;&gt; f(False)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>As Martijn points out, any function containing a <code>yield</code> will always return a generator object, so if in some cases you want the body of <code>f</code> to actually be executed when <code>f()</code> is called, rather than only be executed when iterated over, you have to use this approach.</p>
<p>The standard library instance method <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map" rel="nofollow"><code>map</code></a> from <code>concurrent.Futures.ProcessPoolExecutor</code>/<code>concurrent.Futures.ThreadPoolExecutor</code> uses this to ensure futures are submitted as soon as <code>map</code> is called, rather than only when you try to actually retrieve results from it, for example:</p>
<pre><code>def map(self, fn, *iterables, timeout=None):
    if timeout is not None:
        end_time = timeout + time.time()

    fs = [self.submit(fn, *args) for args in zip(*iterables)]

    # Yield must be hidden in closure so that the futures are submitted
    # before the first iterator value is required.
    def result_iterator():
        try:
            for future in fs:
                if timeout is None:
                    yield future.result()
                else:
                    yield future.result(end_time - time.time())
        finally:
            for future in fs:
                future.cancel()
    return result_iterator()
</code></pre>
</div>
<span class="comment-copy">If a function has a <code>yield</code> in it, even unreachably, it's always a generator.</span>
