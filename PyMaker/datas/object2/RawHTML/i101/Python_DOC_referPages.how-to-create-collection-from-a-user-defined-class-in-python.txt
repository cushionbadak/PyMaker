<div class="post-text" itemprop="text">
<p>Let i have the following class in python:</p>
<pre><code>class Word:
def __init__(self, _lemma, _frequency):
    self.lemma = str(_lemma)
    self.frequency = int(_frequency) 
</code></pre>
<p>now i want to create a collection of class <code>Word</code> which hold following logic when an <code>Word</code> object <code>word1</code> is being added to collection:</p>
<ul>
<li>if the collection contains a <code>Word</code> object <code>word</code> where <code>word.lemma = word1.lemma</code> then <code>word.frequency = word.frequency + word1.frequency</code></li>
<li>else add <code>word1</code> to collection</li>
</ul>
<p>How can i do it?</p>
<hr/>
<p>Previously i used a list to do so where i checked if the list contains a <code>Word</code> object which has same <code>lemma</code> as <code>word1.lemma</code>. But the approach has O(n^2) complexity to add n <code>word</code> in the collection.</p>
<pre><code>from Word import Word

class Corpus:

    def __init__(self, _name, _total_count):
        self.name = str(_name)
        self.total_count = int(_total_count)
        self.words = []

    def add(self, _word):

        find_word = [index for index, word in enumerate(self.words) if word.lemma == _word.lemma]  # O(n)
        if len(find_word) == 0:
            self.words.append(Word(_word.lemma, _word.frequency))
        else:
            self.words[find_word[0]].frequency = self.words[find_word[0]].frequency + _word.frequency
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your wording may confuse community members, who're familiar with Python. I think you're using "dictionary" term as the part of your domain model and not as data structure in Python.</p>
<p>If you really need both <code>Word</code> and <code>Corpus</code> classes - you should go forward with code like this:</p>
<pre class="lang-py prettyprint-override"><code>from collections import defaultdict


class Word:

    def __init__(self, lemma: str, frequency: int):
        self.lemma = lemma
        self.frequency = frequency

    def __eq__(self, other):
        return self.lemma == other.lemma

   def __hash__(self):
       return hash(self.lemma)


class Corpus:

    def __init__(self):
        self.words = defaultdict(0)

    def add(self, word: Word):
        self.words[word] += word.frequency
</code></pre>
<p>Key points are:</p>
<ol>
<li>Usage of <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hints</a></li>
<li>How <code>dict</code> lookup (e.g. <code>'b' in {'a': 23, 'b': 24}</code>) is working - <a href="https://stackoverflow.com/questions/44531020/when-does-eq-gets-called-using-hash">When does __eq__ gets called using hash()?</a></li>
<li><a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> usage</li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> usage</li>
</ol>
<p>And I highly recommend to think if you really want to store <code>Word</code> instances in <code>Corpus</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it easily by using a dictionary instead of a list, using the word.lemma as key:</p>
<pre><code>def add(self, _word):
    if _word.lemma not in self.words:
        self.words[_word.lemma] = _word
    else:
        self.words[_word.lemma].frequency += _word.frequency
</code></pre>
<p>a inconvenient is that it duplicates the lemma information...</p>
<hr/>
<p>If using a <code>Word</code> class is not mandatory, your could use a <a href="https://docs.python.org/3.7/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> (with a 0 default value) that just associate frequency (value) to lemma (key):</p>
<pre><code>class Corpus:
    def __init__(...):
        ...
        self.words = defaultdict(lambda: 0)

    def add(self, lemma, frequency):
        self.words[lemma] += frequency
</code></pre>
</div>
<span class="comment-copy">Why your "self.words" is a list while you want a dictionary ?</span>
<span class="comment-copy">Your approach has O(n) complexity</span>
<span class="comment-copy">@Sanyash yout are right. The <code>Corpus.add()</code> complexity is O(n). I fixed the comment in the code. but i wanted to say that the complexity is O(n^2) to add n <code>word</code>.</span>
<span class="comment-copy">Yes. I can omit storing <code>Word</code> instances in <code>Corpus</code>. I can use the approach showed by Tryph something like using a <code>defaultdict</code> (with a 0 default value) that just associate frequency (value) to lemma (key). But can you please explain me why you are telling me to reconsider storing <code>Word</code> instances in <code>Corpus</code>?</span>
<span class="comment-copy">Way of storing <code>Word</code> instances will let you encapsulate more complex logic behind frequency accumulation (e.g. assume both lowercase and uppercase words equal) and keep cohesion high. But if you're ok with just storing words summing up frequency of them (case sensitive) - why not to just store string representations of words.</span>
<span class="comment-copy">tl;dr - store <code>Word</code> instances if you plan to make your algorithm more complex; store just string representation of lemmas if it 100% remain the same</span>
