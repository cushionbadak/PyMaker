<div class="post-text" itemprop="text">
<p>I have this list:</p>
<pre><code>list = [{1,2,3,4}, {3,4,5}, {2,6}] 
</code></pre>
<p>I want to have this as the output:</p>
<pre><code>{1,6}
</code></pre>
<p>So I only want the unique numbers to have an output.
This is what I tried, but it does not work:</p>
<pre><code>list = [{1,2,3,4}, {3,4,5}, {2,6}] 
s1 = []
for number in list:
   if number not in s1:
      s1.append(number)
def unique(s1):
   return set.difference(*s1)
print (unique(s1))
</code></pre>
<p>My output is:</p>
<pre><code>{1, 2, 3, 4}
</code></pre>
<p>I have no clue how to fix this? I am a python beginner so can anyone explain what the answer is and why that should be the solution? Many thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a <code>Counter</code> object.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; my_list = [{1,2,3,4}, {3,4,5}, {2,6}]
&gt;&gt;&gt; set(k for k,v in Counter(chain.from_iterable(my_list)).items() if v == 1)
set([1, 5, 6])
</code></pre>
<p><code>chain.from_iterable</code> "flattens" <code>my_list</code>. The <code>Counter</code> compiles how many times each element from the flattened list is seen, and the generator expression sends only the keys mapped to a value of 1 to <code>set</code>.</p>
<hr/>
<p>Some of the intermediate values involved:</p>
<pre><code>&gt;&gt;&gt; list(chain.from_iterable(my_list))
[1, 2, 3, 4, 3, 4, 5, 2, 6]
&gt;&gt;&gt; Counter(chain.from_iterable(my_list))
Counter({2: 2, 3: 2, 4: 2, 1: 1, 5: 1, 6: 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had an earlier answer posted that wasn't right. I don't like to give up, and I wanted to find an answer to this question that only used sets.  I'm not saying that this is a better answer than the others, but it does achieve at least my own goal of not bringing any extra packages into the solution:</p>
<pre><code>def unique(data):
    result = set()
    dups = set()
    for s1 in data:
        # accumulate everything we see more than once
        dups = dups | (result &amp; s1)
        # accumulate everything
        result = (result | s1)
    # the result is everything we only saw once, or in other words,
    # everything we saw minus everything we saw more than once
    return result - dups

print(unique([{1,2,3,4}, {3,4,5}, {2,6}]))
print(unique([{1}, {1}, {1}]))
</code></pre>
<p>Output:</p>
<pre><code>set([1, 5, 6])
set([])
</code></pre>
<p>There's probably a better solution even to using just sets. I always want to try to use the simplest set of tools possible because I think it is the most understandable to do so, and will often turn out to be as efficient as anything else as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not a fancy python solution but what you probably want is to build a dict where the key is a number in the list and the value is the number of times it occurs.</p>
<p>This solution is by no way optimal since we are performing to many iterations:</p>
<pre class="lang-py prettyprint-override"><code>list = [{1,2,3,4}, {3,4,5}, {2,6}] 
count_hash = {}

for dict in list:
    for number in dict:
        if number in count_hash:
            count_hash[number] += 1
        else:
            count_hash[number] = 1

for number in count_hash:
    if count_hash[number] == 1:
        print(number)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree with <a href="https://stackoverflow.com/users/1126841/chepner">chepner</a> on using a Counter.  Using <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">functools</a>.reduce to flatten the list came from <a href="https://stackoverflow.com/questions/952914/#45323085">here</a>.</p>
<pre><code>import functools
import operator
from collections import Counter

my_list = [{1,2,3,4}, {3,4,5}, {2,6}]
flat_list = functools.reduce(operator.iconcat, my_list, [])

results = [k for (k, v) in Counter(flat_list).items() if v == 1]

print(results)

# OUTPUT
# [1, 5, 6]
</code></pre>
</div>
<span class="comment-copy">Shouldn't 5 also be in the output?</span>
<span class="comment-copy"><code>for number in list</code> does not iterate through numbers. After that loop, <code>s1</code> is the same as <code>list</code>. Also, don't call your variables <code>list</code> - that is a built-in name.</span>
<span class="comment-copy"><code>set.difference</code> will not never give as result items which are not in the first set.</span>
<span class="comment-copy">This doesn't work for cases such as <code>[{1}, {1}, {1}]</code>, since your method will wrongly give a result of <code>{1}</code> (instead of an empty set).</span>
<span class="comment-copy">Wow, you're right!  Ok, so I'm an idiot.  A persistent idiot though.  Solution updated.</span>
<span class="comment-copy">I think your latest solution is over-complicated. All you need to do is iterate over all the elements and accumulate one set of shared values (<code>A</code>) and one set of duplicated values (<code>B</code>). This can be done by simply testing whether the current value is in <code>A</code>: if it is, add it to <code>B</code>; if not, add it to <code>A</code>. The final result will then be simply <code>A ^ B</code> (i.e. <code>A.symmetric_difference(B)</code>). I think that comes close to what the OP was originally trying to achieve.</span>
<span class="comment-copy">Actually, the result can just be <code>A - B</code> (i.e. <code>A.difference(B)</code>), since we don't need anything from <code>B</code>.</span>
<span class="comment-copy">@ekhumoro, I don't know about "complicated", but maybe "inefficient".  I wanted to avoid any <b>if</b> blocks.  I wanted all the logic to be with sets.  Maybe you can figure out a better algorithm under those constraints. - I don't see how adding a <b>if</b> can be seen as a simplification</span>
