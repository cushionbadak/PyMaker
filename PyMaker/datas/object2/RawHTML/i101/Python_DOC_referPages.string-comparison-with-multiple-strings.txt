<div class="post-text" itemprop="text">
<p>How can I check if any of the strings in an array exists in another string?</p>
<p>Like:</p>
<pre><code>a = ['a', 'b', 'c']
str = "a123"
if a in str:
  print "some of the strings found in str"
else:
  print "no strings found in str"
</code></pre>
<p>That code doesn't work, it's just to show what I want to achieve.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/library/functions.html#any" rel="noreferrer"><strong><code>any</code></strong></a>:</p>
<pre><code>if any(x in str for x in a):
</code></pre>
<p>Similarly to check if <em>all</em> the strings from the list are found, use <a href="http://docs.python.org/library/functions.html#all" rel="noreferrer"><strong><code>all</code></strong></a> instead of <code>any</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>any()</code> is by far the best approach if all you want is <code>True</code> or <code>False</code>, but if you want to know specifically which string/strings match, you can use a couple things.</p>
<p>If you want the first match (with <code>False</code> as a default):</p>
<pre><code>match = next((x for x in a if x in str), False)
</code></pre>
<p>If you want to get all matches (including duplicates):</p>
<pre><code>matches = [x for x in a if x in str]
</code></pre>
<p>If you want to get all non-duplicate matches (disregarding order):</p>
<pre><code>matches = {x for x in a if x in str}
</code></pre>
<p>If you want to get all non-duplicate matches in the right order:</p>
<pre><code>matches = []
for x in a:
    if x in str and x not in matches:
        matches.append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be careful if the strings in <code>a</code> or <code>str</code> gets longer. The straightforward solutions take O(S*(A^2)), where <code>S</code> is the length of <code>str</code> and A is the sum of the lenghts of all strings in <code>a</code>. For a faster solution, look at <a href="http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm" rel="noreferrer">Aho-Corasick</a> algorithm for string matching, which runs in linear time O(S+A).</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to add some diversity with <strong><code>regex</code></strong>:</p>
<pre><code>import re

if any(re.findall(r'a|b|c', str, re.IGNORECASE)):
    print 'possible matches thanks to regex'
else:
    print 'no matches'
</code></pre>
<p>or if your list is too long - <code>any(re.findall(r'|'.join(a), str, re.IGNORECASE))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You need to iterate on the elements of a.</p>
<pre><code>a = ['a', 'b', 'c']
str = "a123"
found_a_string = False
for item in a:    
    if item in str:
        found_a_string = True

if found_a_string:
    print "found a match"
else:
    print "no match found"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = ['a', 'b', 'c']
str =  "a123"

a_match = [True for match in a if match in str]

if True in a_match:
  print "some of the strings found in str"
else:
  print "no strings found in str"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>jbernadas already mentioned the <a href="http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm" rel="nofollow noreferrer">Aho-Corasick-Algorithm</a> in order to reduce complexity.</p>
<p>Here is one way to use it in Python:</p>
<ol>
<li><p>Download aho_corasick.py from <a href="https://gist.github.com/atdt/875e0dba6a15e3fa6018" rel="nofollow noreferrer">here</a></p></li>
<li><p>Put it in the same directory as your main Python file and name it <code>aho_corasick.py</code></p></li>
<li><p>Try the alrorithm with the following code:</p>
<pre><code>from aho_corasick import aho_corasick #(string, keywords)

print(aho_corasick(string, ["keyword1", "keyword2"]))
</code></pre></li>
</ol>
<p>Note that the search is <em>case-sensitive</em></p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on the  context 
suppose if you want to check single literal like(any single word a,e,w,..etc) <strong>in</strong> is enough</p>
<pre><code>original_word ="hackerearcth"
for 'h' in original_word:
      print("YES")
</code></pre>
<p>if you want to check any of the character among the original_word:
make use of </p>
<pre><code>if any(your_required in yourinput for your_required in original_word ):
</code></pre>
<p>if you want all the input you want in that  original_word,make use of all
simple</p>
<pre><code>original_word = ['h', 'a', 'c', 'k', 'e', 'r', 'e', 'a', 'r', 't', 'h']
yourinput = str(input()).lower()
if all(requested_word in yourinput for requested_word in original_word):
    print("yes")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>flog = open('test.txt', 'r')
flogLines = flog.readlines()
strlist = ['SUCCESS', 'Done','SUCCESSFUL']
res = False
for line in flogLines:
     for fstr in strlist:
         if line.find(fstr) != -1:
            print('found') 
            res = True


if res:
    print('res true')
else: 
    print('res false')
</code></pre>
<p><a href="https://i.stack.imgur.com/JGKMt.png" rel="nofollow noreferrer"><img alt="output example image" src="https://i.stack.imgur.com/JGKMt.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would use this kind of function for speed:</p>
<pre><code>def check_string(string, substring_list):
    for substring in substring_list:
        if substring in string:
            return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = "firstName and favoriteFood"
mandatory_fields = ['firstName', 'lastName', 'age']


# for each
for field in mandatory_fields:
    if field not in data:
        print("Error, missing req field {0}".format(field));

# still fine, multiple if statements
if ('firstName' not in data or 
    'lastName' not in data or
    'age' not in data):
    print("Error, missing a req field");

# not very readable, list comprehension
missing_fields = [x for x in mandatory_fields if x not in data]
if (len(missing_fields)&gt;0):
    print("Error, missing fields {0}".format(", ".join(missing_fields)));
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just some more info on how to get all list elements availlable in String</p>
<pre><code>a = ['a', 'b', 'c']
str = "a123" 
list(filter(lambda x:  x in str, a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A surprisingly fast approach is to use <code>set</code>:</p>
<pre><code>a = ['a', 'b', 'c']
str = "a123"
if set(a) &amp; set(str):
    print("some of the strings found in str")
else:
    print("no strings found in str")
</code></pre>
<p>This works if <code>a</code> does not contain any multiple-character values (in which case use <code>any</code> as listed <a href="https://stackoverflow.com/a/3389611/122033">above</a>). If so, it's simpler to specify <code>a</code> as a string: <code>a = 'abc'</code>.</p>
</div>
<span class="comment-copy">I'm surprised there aren't (yet) any answers comparing to a compiled regex in terms of perf, especially compared to size of the string and number of "needles" to search for.</span>
<span class="comment-copy">@Pat I am not surprised. The question is not about performance. Today most programmers care more for getting it done and readability. The performance question is valid, but a different question.</span>
<span class="comment-copy">Using str as a variable is confusing and may result in unexpected behavior as it is a reserved word; see <a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" rel="nofollow noreferrer">link</a>.</span>
<span class="comment-copy">any() takes an iterable. I am not sure which version of Python you are using but in 2.6 you will need to put [] around your argument to any().  any([x in str for x in a])  so that the comprehension returns an iterable. But maybe later versions of Python already do this.</span>
<span class="comment-copy">@Mark Byers: Sorry for the late comment, but is there a way to print the string that was found? How would you do this. Thank you.</span>
<span class="comment-copy">Not sure I understand, if a is the list, and str is the thing to match against, what is the x? Python newbie ftw. :)</span>
<span class="comment-copy">@red: you can read <code>for x in a</code> like "for each element in list".  Since <code>a</code> is a list of strings, and <code>x</code> is an element of that list, <code>x</code> is a string (one of 'a', 'b', 'c' in original example)</span>
<span class="comment-copy">@emispowder It works fine for me as-is in Python 2.6.9.</span>
<span class="comment-copy">please add example for the last match too</span>
<span class="comment-copy">@OlegKokorin: It creates a list of matching strings in the same order it finds them, but it keeps only the first one if two are the same.</span>
<span class="comment-copy">can Aho-Corasick also find substrings instead of prefixes ?</span>
<span class="comment-copy">Some python Aho-Corasick libraries are <a href="https://pypi.python.org/pypi/pyahocorasick/" rel="nofollow noreferrer">here</a> and <a href="https://github.com/JanFan/py-aho-corasick" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">This works for the given use case of the question. If the you search for <code>(</code> or <code>*</code> this fails, since quoting for the regex syntax needs to be done.</span>
<span class="comment-copy">You can escape it if necessary with <code>'|'.join(map(re.escape, strings_to_match))</code>. You sould probably <code>re.compile('|'.join(...))</code> as well.</span>
<span class="comment-copy">Yes i knew how to do that but compared to Marks answer, that's horrible code.</span>
<span class="comment-copy">Only if you understand Mark's code.  The problem you were having is that you weren't examining the elements of your array.  There are a lot of terse, pythonic ways to accomplish what you want that would hide the essence of what was wrong with your code.</span>
<span class="comment-copy">It may be 'horrible code' but it's <a href="http://docs.python.org/2/library/functions.html#any" rel="nofollow noreferrer">exactly what any() does</a>. Also, this gives you the actual string that matched, whereas any() just tells you there is a match.</span>
<span class="comment-copy">Interesting, but probably only faster for huge strings and keyword lists.</span>
