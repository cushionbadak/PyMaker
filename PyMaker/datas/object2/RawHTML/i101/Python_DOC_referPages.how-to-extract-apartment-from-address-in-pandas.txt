<div class="post-text" itemprop="text">
<p>I have a rather messy data set that has a lot of inconsistencies and errors due to manually input data.</p>
<p>I'm working on the address column of this dataset in pandas. </p>
<p>What I would like to do is break the address column into 3 separate entities:</p>
<p>1) a column for the address</p>
<p>2) a column for the street number</p>
<p>3) a column for the apartment or unit number</p>
<p>The data looks like the following:</p>
<pre><code>address
----------------------
123 smith street #5234
5000 john ct
34 wood st apt# 23
523 fire road apt #87
charles way apt. 434
0987 misty lane unit B 
</code></pre>
<p>I have already removed the street numbers into their own column. For this I used "np.where" using an easy logical condition that if the string started with digits extract them into the new street column.</p>
<p>I am now stuck on how to do this with apartment numbers.</p>
<p>I am assuming that because of the inconsistencies, I have to do something like:</p>
<pre><code>df['apt/unit'] = np.where(str contains "apt", extract string starting at "apt" until end, else np.NaN)
df['apt/unit'] = np.where(str contains "unit", extract string starting at "unit" until end, else np.NaN)
</code></pre>
<p>Will I have to use regex to do this? If so, what is the way to go about that?</p>
<p>Are there any alternatives to this line of thinking?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you have multiple conditions for your <code>apt/unit</code> column, you can use <code>np.select</code> here like the following:</p>
<pre><code># Define our conditions
conditions = [
    df.address.str.contains('apt'),
    df.address.str.contains('unit'),
    df.address.str.contains('#')
]

# Define our choices based on our conditions
choices = [
    df.address.apply(lambda x: x[x.find('apt'):]),
    df.address.apply(lambda x: x[x.find('unit'):]),
    df.address.apply(lambda x: x[x.find('#'):])
]

# Apply this logic by creating the new column and cleaning up address column
df['apt/unit'] = np.select(conditions, choices, default = '')

# Clean up our address column
choices2 = [
    df.address.apply(lambda x: x[:x.find('apt')]),
    df.address.apply(lambda x: x[:x.find('unit')]),
    df.address.apply(lambda x: x[:x.find('#')])
]
df['address'] = np.select(conditions, choices2, default = df.address)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>print(df)

             address  apt/unit
0  123 smith street      #5234
1       5000 john ct          
2        34 wood st    apt# 23
3     523 fire road    apt #87
4       charles way   apt. 434
5   0987 misty lane     unit B
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.extract.html" rel="nofollow noreferrer"><code>Series.str.extract</code></a>, something like:</p>
<pre><code>pat = r'^(?P&lt;number&gt;\d+)?(?P&lt;street&gt;.+(?=\bapt|\bunit)|.+(?=#)|.+)(?P&lt;apt_unit&gt;(?:\bapt|\bunit|#).+)?'
df.address.str.extract(pat)
</code></pre>
<p>[out]</p>
<pre><code>  number          street  apt_unit
0    123   smith street      #5234
1   5000         john ct       NaN
2     34        wood st    apt# 23
3    523      fire road    apt #87
4    NaN    charles way   apt. 434
5   0987     misty lane     unit B
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use a regex, here's a way to do it that matches number, street, and apartment in separate <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">named groups</a> and then uses df.apply to populate new columns of the dataframe. Street name types are listed out brute force. Anything left over is the apartment number.</p>
<pre><code>regex = '(?P&lt;num&gt;\d+)? ?(?P&lt;street&gt;\w+ (street|way|st|road|ct|lane)) ?(?P&lt;apt&gt;.+)?'

def get_num(address):
    match = re.match(regex, address)
    return match.group('num')


def get_street(address):
    match = re.match(regex, address)
    return match.group('street')


def get_apt(address):
    match = re.match(address)
    return match.group('apt')


df['num'] = df['address'].apply(get_num)
df['street'] = df['address'].apply(get_street)
df['apt'] = df['address'].apply(get_apt)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you already have removed all street numbers the only numbers left should be apartment numbers. Therefore you can use a simple regex to extract all numbers that are left in this column:</p>
<pre><code>df['apt_number'] = df.address.str.extract(r'([\d]+)')
</code></pre>
<p>edit:
With the above answer alone the numbers will remain in the addresses column, to remove we simply replace them with an empty string:</p>
<pre><code>df['address'] = df.address.str.replace(r'([\d]+)', '')
</code></pre>
</div>
<span class="comment-copy">I think this is the most succinct answer that covers the conditions necessary. Two slight things that need to be changed and I will accept your answer. 1) we can also put "df.address.contains('#') and the complementary code in the df.address.apply part as well to handle entry "0".   2) the original text is remaining in the address column. Should not be there anymore and solely moved to the new column.</span>
<span class="comment-copy">I edit the question for  finding <code>'#'</code>, but what do you mean with entry <code>"0"</code>? @DudeWah</span>
<span class="comment-copy">entry <code>0</code> meaning the first row in the example; i.e., the one you just changed to handle <code>#</code></span>
<span class="comment-copy">So this is correct now? @DudeWah Not sure if I understand you correctly</span>
<span class="comment-copy">I understand now, this should be correct output. See edit @DudeWah</span>
<span class="comment-copy">I like this as a nice one liner. Note though that the first entry <code>smith street #5234</code> was not handled correctly and the apartment number <code>5234</code> is still in the address.</span>
<span class="comment-copy">Ah, I see, I've update the pattern, although it is probably getting a bit complicated and unwieldy...</span>
<span class="comment-copy">I think it still looks fine because this is a particular problem so it's going to look slightly messy no matter what. By the way, is there a way to make sure that only the exact string is being extracted? For example, I just noticed there are some entries that contain things like <code>captain lane</code> and i don't want <code>c</code> in address and <code>aptain lane</code> in <code>apt_unit</code>. but I do want <code>apt.</code> in <code>apt_unit</code></span>
<span class="comment-copy">yes, potentially adding a regex boundary character <code>\b</code> infront of 'apt', 'unit' etc. I've updated my answer, if you want to test it again</span>
<span class="comment-copy">Getting the following error when trying this method: <code>AttributeError: 'str' object has no attribute 'match'</code></span>
<span class="comment-copy">@DudeWah: a typo in get_apt() in the initial posting, my apologies. The call needs to be <code>re.match(address)</code> not <code>regex.match(address)</code></span>
<span class="comment-copy">This is a nice solution for cases where the data is well defined. The assumption that "the only numbers left should be apartment numbers" does not hold up. Take for instance this following address string: 2103 highway 45 North</span>
