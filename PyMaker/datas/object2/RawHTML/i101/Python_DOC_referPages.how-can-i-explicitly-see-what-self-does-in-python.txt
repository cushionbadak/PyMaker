<div class="post-text" itemprop="text">
<p>I've read somewhere that the use of ‘<strong>self</strong>’ in Python converts <code>myobject.method (arg1, arg2)</code> 
into <code>MyClass.method(myobject, arg1, arg2)</code>. </p>
<p>Does anyone know how I can prove this? 
Is it only possible if I look at the bytecode by using <code>dis.dis</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>self</em> doesn't do anything. <em>self</em> is merely the conventional name given to the first argument of a method in Python class definitions. This argument will be passed an instance of the class.</p>
<p>Essentially, to understand what is actually going on, you have to understand Python descriptors. The best places are the official <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">docs</a> 
To boil it down, descriptor objects are objects that implement <code>__get__</code>, <code>__set__</code> or <code>__delete__</code>. These methods intercept object attribute access, <code>obj.x</code>, object attribute assignment: <code>obj.x = 42</code>, and object attribute deletion, <code>del obj.x</code>.</p>
<p>Also, check out the <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-howto-guide" rel="nofollow noreferrer">HOWTO</a>, where they show how Python <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">functions and methods are simply descriptors</a>, and show an example Python implementation (of course, in CPython, this is implemented in C):</p>
<pre><code>class Function(object):
    . . .
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        if obj is None:
            return self
        return types.MethodType(self, obj)
</code></pre>
<p>We can "cheat" and create our own object that merely wraps a function object, and see that this works.</p>
<pre><code>import types
class Function:
    def __init__(self, func):
        self._func = func
    def __call__(self, *args, **kwargs):
        return self._func(*args, **kwargs)
    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c https://docs.python.org/3/howto/descriptor.html#functions-and-methods"
        if obj is None:
            return self
        else:
            return types.MethodType(self, obj)

class Foo:
   def __init__(self):
       self.foo = 42
   bar = Function(lambda self:
       self.foo ** 2
</code></pre>
<p>And or, in a REPL:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt;
&gt;&gt;&gt; class Function:
...     def __init__(self, func):
...         self._func = func
...     def __call__(self, *args, **kwargs):
...         return self._func(*args, **kwargs)
...     def __get__(self, obj, objtype=None):
...         "Simulate func_descr_get() in Objects/funcobject.c https://docs.python.org/3/howto/descriptor.html#functions-and-methods"
...         if obj is None:
...             return self
...         else:
...             return types.MethodType(self, obj)
...
&gt;&gt;&gt; class Foo:
...    def __init__(self):
...        self.foo = 42
...    bar = Function(lambda self:
...        self.foo ** 2
...    )
...
&gt;&gt;&gt; Foo().bar()
1764
</code></pre>
<p>This shows you that the magic behind "self" is merely that function objects <em>are descriptors</em>, they implement a <code>__get__</code> method which either returns the function itself if called without an instance, or returns a method-object that binds the first argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>Trying it out for yourself in IDLE could help you out with this:</p>
<pre><code>class MyObject(object):
  def method(self, arg1, arg2):
     print(self)

  @staticmethod
  def static_method(arg1, arg2):
     print(arg1)

my_object = MyObject()
my_object.method(1, 2)
&gt;&gt;&gt; &lt;MyObject at 0x1234&gt;
my_object.static_method(1, 2)
&gt;&gt;&gt; 1
</code></pre>
<p>Python doesn't convert anything, it just silently passes the class instance as the first argument to a class method. Above you can see if you made the method static (via <code>@staticmethod</code> decorator), you avoid that extra parameter.</p>
</div>
<span class="comment-copy">The conversion isn't made by python but by <code>method</code> object itself which should be a user-defined function object, or otherwise implement appropriate descriptor protocol which returns an object of "instance method" type. This object upon calling indeed performs the substitution you described.</span>
