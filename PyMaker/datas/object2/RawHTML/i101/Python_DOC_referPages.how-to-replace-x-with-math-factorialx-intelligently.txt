<div class="post-text" itemprop="text">
<p>I am currently implementing a graphical calculator in Python, in a manner where you can type a natural expression and evaluate it. This is not a problem with most functions or operators, but as the factorial function is denoted by a <code>!</code> after the operand, this is more difficult.</p>
<p>What I have is a string which contains a function, for example: <code>'(2x + 1)!'</code> which needs to be replaced with: <code>'math.factorial((2x + 1))'</code></p>
<p>However, the string may also include other terms such as: <code>'2*x + (2x + 1)! - math.sin(x)'</code>
and the factorial term may not necessarily contain brackets: <code>'2!'</code></p>
<p>I've been trying to find a solution to this problem, but to no avail, I don't think the <code>string.replace()</code> method can do this directly. Is what I seek too ambitious, or is there some method by which I could achieve a result as desired?</p>
</div>
<div class="post-text" itemprop="text">
<p>There's two levels of answer to your question: (1) solve your current problem; (2) solve your general problem.</p>
<p>(1) is pretty easy - the most common, versatile tool in general for doing string pattern matching and replacement is <a href="https://en.wikipedia.org/wiki/Regular_expression" rel="nofollow noreferrer">Regular Expressions</a> (RE). You simply define the pattern you're looking for, the pattern you want out, and pass the RE engine your string. Python has a <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">RE module</a> built-in called <code>re</code>. Most languages have something similar. Some languages (eg. Perl) even have it as a core part of the language syntax.</p>
<p>A pattern is a series of either specific characters, or non-specific ("wildcard") characters. So in your case you want the non-specific characters before a specific '!' character. You seem to suggest that "before" in your case means either all the non-whitespace characters, or if the proceeding character is a ')', then all the characters between that and the proceeding '('. So let's build that pattern, starting with the version without the parentheses:</p>
<pre><code>[\w] - the set of characters which are letters or numbers (we need a set of
       characters that doesn't include whitespace or ')' so I'm taking some
       liberty to keep the example simple - you could always build your own
       more complex set with the '[]' pattern)
+    - at least one of them
!    - the '!' character
</code></pre>
<p>And then the version with the parentheses:</p>
<pre><code>\(  - the literal '(' character, as opposed to the special function that ( has
.   - any character
+   - at least one of them
?   - but dont be "greedy", ie. only take the smallest set of characters that
      match the pattern (will work out to be the closest pair of parentheses)
\)  - the closing ')' character
!   - the '!' character
</code></pre>
<p>Then we just need to put it all together. We use <code>|</code> to match the first pattern OR the second pattern. And we use <code>(</code> and <code>)</code> to denote the part of the pattern we want to "capture" - it's the bit before the '!' and inside the parentheses that we want to use later. So your pattern becomes:</p>
<pre><code>([\w]+)!|\((.+?)\)!
</code></pre>
<p>Don't worry, RE expressions always come out looking like someone has just mashed the keyboard. There are some great tools out there like <a href="https://regexr.com" rel="nofollow noreferrer">RegExr</a> which help break down complex RE expressions.</p>
<p>Finally, you just need to take your captures and stick them in "math.factorial". <code>\x</code> means the <code>x</code>th match. If the first pattern matches, <code>\2</code> will be blank and vice-versa, so we can just use both of them at once.</p>
<pre><code>math.factorial(\1\2)
</code></pre>
<p>That's it! Here how you run your RE in Python (note the <code>r</code> before the strings prevents Python from trying to process the <code>\</code> as an escape sequence):</p>
<pre><code>import re
re.sub(r'([\w]+)!|\((.+?)\)!', r'math.factorial(\1\2)', '2*x + (2x + 1)! - math.sin(x) + 2!')
</code></pre>
<p><code>re.sub</code> takes three parameters (plus some optional ones not used here): the RE pattern, the replacement string, and the input string. This produces:</p>
<pre><code>'2*x + math.factorial(2x + 1) - math.sin(x) + math.factorial(2)'
</code></pre>
<p>which is I believe what you're after.</p>
<p>Now, (2) is harder. If your intention really is to implement a calculator that takes strings as input, you're quickly going to drown in regular expressions. There will be so many exceptions and variations between what can be entered and what Python can interpret, that you'll end up with something quite fragile, that will fail on its first contact with a user. If you're not intending on having users you're pretty safe - you can just stick to using the patterns that work. If not, then you'll find the pattern matching method a bit limiting.</p>
<p>In general, the problem you're tackling is known as <em>lexical analysis</em> (or more fully, as the three step process of <em>lexical analysis</em>, <em>syntactic analysis</em> and <em>semantic analysis</em>). The standard way to tackle this is with a technique called <em>recursive descent parsing</em>.</p>
<p>Intriguingly, the Python interpreter performs exactly this process in interpreting the <code>re</code> statement above - compilers and interpreters all undertake the same process to turn a string into tokens that can be processed by a computer.</p>
<p>You'll find lots of tutorials on the web. It's a bit more complex than using RE, but allows significantly more generalisation. You might want to start with the very brief intro <a href="http://otfried.org/courses/cs206/notes/calculator.pdf" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>You could remove the brackets and calculate everything in a linear form, such that when parsing the brackets it would evaluate the operand, and then apply the factorial function - in the order written.</li>
<li>Or, you could get the index of the factorial <code>!</code> in the string, then if the character at the index before is a close bracket  <code>)</code> you know there is a bracketed operand that needs to be calculated prior to applying math.factorial().</li>
</ol>
</div>
<span class="comment-copy">What you need to do is basically infix expression parsing (although the <code>!</code> operator s actually a suffix operator. However you may be able to modify one for infix notation so it handles that one operator as an exception. Here's a recipe for <a href="http://code.activestate.com/recipes/579123-infix-expression-evaluation/" rel="nofollow noreferrer">Infix expression evaluation</a> I found you could try. There's also the <a href="https://github.com/pyparsing/pyparsing/" rel="nofollow noreferrer">pyparsing</a> module, but I don't know much about it.</span>
<span class="comment-copy">you can use the <code>re</code> module, my regex is not very strong but this pattern <i>will</i> match the case you posted with parens and <code>math.sin</code> --&gt; <code>r'[(](.+?)[)]!'</code></span>
<span class="comment-copy">I think you might be able use @aws_apprentice's regex suggestion to handle the <code>!</code> <i>postfix</i> (not "suffix") operators (and something else for all the other operators). BTW, the classic, text-book, way to parse infix expressions is via something called <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow noreferrer">recursive-descent parsing</a>.</span>
<span class="comment-copy">Why not making a button for ! Which parse a very particular string which can then be easily replace.</span>
<span class="comment-copy">Thank you, I'd never even heard of regular expressions before asking this question. With your help and my own research I now at least understand the basics of RE, and have been able to implement what I needed.</span>
<span class="comment-copy">Because it's (sort of) an answer, I'm not downvoting. However, just because you can't post a comment doesn't mean you should post it as an answer.</span>
<span class="comment-copy">@jhpratt For me it's a valid rhetorical answer</span>
