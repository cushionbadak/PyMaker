<div class="post-text" itemprop="text">
<p>What is best practice for extending <code>Enum</code> type in Python 3.4 and is there even a possibility for do this?</p>
<p>For example:</p>
<pre><code>from enum import Enum

class EventStatus(Enum):
   success = 0
   failure = 1

class BookingStatus(EventStatus):
   duplicate = 2
   unknown = 3

Traceback (most recent call last):
...
TypeError: Cannot extend enumerations
</code></pre>
<p>Currently there is no possible way to create a base enum class with members and use it in other enum classes (like in the example above). Is there any other way to implement inheritance for Python enums?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Subclassing an enumeration is allowed only if the enumeration does not define any members.</p>
<p>Allowing subclassing of enums that define members would lead to a violation of some important invariants of types and instances.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations">https://docs.python.org/3/library/enum.html#restricted-subclassing-of-enumerations</a></p>
<p>So <strong>no</strong>, it's not directly possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>Calling the Enum class directly and making use of chain allows the extension (joining) of an existing enum. </p>
<blockquote>
<p>I came upon the problem of extending enums while working on a CANopen
  implementation. Parameter indices in the range from 0x1000 to 0x2000
  are generic to all CANopen nodes while e.g. the range from 0x6000
  onwards depends open whether the node is a drive, io-module, etc.</p>
</blockquote>
<p><em>nodes.py:</em></p>
<pre><code>from enum import IntEnum

class IndexGeneric(IntEnum):
    """ This enum holds the index value of genric object entrys
    """
    DeviceType    = 0x1000
    ErrorRegister = 0x1001

Idx = IndexGeneric
</code></pre>
<p><em>drives.py:</em></p>
<pre><code>from itertools import chain
from enum import IntEnum
from nodes import IndexGeneric

class IndexDrives(IntEnum):
    """ This enum holds the index value of drive object entrys
    """
    ControlWord   = 0x6040
    StatusWord    = 0x6041
    OperationMode = 0x6060

Idx= IntEnum('Idx', [(i.name, i.value) for i in chain(IndexGeneric,IndexDrives)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While uncommon, it is sometimes useful to create an enum from many modules.  The <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer"><code>aenum</code></a><sup>1</sup> library supports this with an <code>extend_enum</code> function:</p>
<pre><code>from aenum import Enum, extend_enum

class Index(Enum):
    DeviceType    = 0x1000
    ErrorRegister = 0x1001

for name, value in (
        ('ControlWord', 0x6040),
        ('StatusWord', 0x6041),
        ('OperationMode', 0x6060),
        ):
    extend_enum(Index, name, value)

assert len(Index) == 5
assert list(Index) == [Index.DeviceType, Index.ErrorRegister, Index.ControlWord, Index.StatusWord, Index.OperationMode]
assert Index.DeviceType.value == 0x1000
assert Index.StatusWord.value == 0x6041
</code></pre>
<hr/>
<p><sup>1</sup> Disclosure:  I am the author of the <a href="https://docs.python.org/3/library/enum.html" rel="noreferrer">Python stdlib <code>Enum</code></a>, the <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer"><code>enum34</code> backport</a>, and the <a href="https://pypi.python.org/pypi/aenum" rel="noreferrer">Advanced Enumeration (<code>aenum</code>)</a>  library.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've opted to use a metaclass approach to this problem.</p>
<pre><code>from enum import EnumMeta

class MetaClsEnumJoin(EnumMeta):
    """
    Metaclass that creates a new `enum.Enum` from multiple existing Enums.

    @code
        from enum import Enum

        ENUMA = Enum('ENUMA', {'a': 1, 'b': 2})
        ENUMB = Enum('ENUMB', {'c': 3, 'd': 4})
        class ENUMJOINED(Enum, metaclass=MetaClsEnumJoin, enums=(ENUMA, ENUMB)):
            pass

        print(ENUMJOINED.a)
        print(ENUMJOINED.b)
        print(ENUMJOINED.c)
        print(ENUMJOINED.d)
    @endcode
    """

    @classmethod
    def __prepare__(metacls, name, bases, enums=None, **kargs):
        """
        Generates the class's namespace.
        @param enums Iterable of `enum.Enum` classes to include in the new class.  Conflicts will
            be resolved by overriding existing values defined by Enums earlier in the iterable with
            values defined by Enums later in the iterable.
        """
        #kargs = {"myArg1": 1, "myArg2": 2}
        if enums is None:
            raise ValueError('Class keyword argument `enums` must be defined to use this metaclass.')
        ret = super().__prepare__(name, bases, **kargs)
        for enm in enums:
            for item in enm:
                ret[item.name] = item.value  #Throws `TypeError` if conflict.
        return ret

    def __new__(metacls, name, bases, namespace, **kargs):
        return super().__new__(metacls, name, bases, namespace)
        #DO NOT send "**kargs" to "type.__new__".  It won't catch them and
        #you'll get a "TypeError: type() takes 1 or 3 arguments" exception.

    def __init__(cls, name, bases, namespace, **kargs):
        super().__init__(name, bases, namespace)
        #DO NOT send "**kargs" to "type.__init__" in Python 3.5 and older.  You'll get a
        #"TypeError: type.__init__() takes no keyword arguments" exception.
</code></pre>
<p>This metaclass can be used like so:</p>
<pre><code>&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt;
&gt;&gt;&gt; ENUMA = Enum('ENUMA', {'a': 1, 'b': 2})
&gt;&gt;&gt; ENUMB = Enum('ENUMB', {'c': 3, 'd': 4})
&gt;&gt;&gt; class ENUMJOINED(Enum, metaclass=MetaClsEnumJoin, enums=(ENUMA, ENUMB)):
...     e = 5
...     f = 6
...
&gt;&gt;&gt; print(repr(ENUMJOINED.a))
&lt;ENUMJOINED.a: 1&gt;
&gt;&gt;&gt; print(repr(ENUMJOINED.b))
&lt;ENUMJOINED.b: 2&gt;
&gt;&gt;&gt; print(repr(ENUMJOINED.c))
&lt;ENUMJOINED.c: 3&gt;
&gt;&gt;&gt; print(repr(ENUMJOINED.d))
&lt;ENUMJOINED.d: 4&gt;
&gt;&gt;&gt; print(repr(ENUMJOINED.e))
&lt;ENUMJOINED.e: 5&gt;
&gt;&gt;&gt; print(repr(ENUMJOINED.f))
&lt;ENUMJOINED.f: 6&gt;
</code></pre>
<p>Note what happens in the event of a namespace conflict:</p>
<pre><code>&gt;&gt;&gt; ENUMC = Enum('ENUMA', {'a': 1, 'b': 2})
&gt;&gt;&gt; ENUMD = Enum('ENUMB', {'a': 3})
&gt;&gt;&gt; class ENUMJOINEDCONFLICT(Enum, metaclass=MetaClsEnumJoin, enums=(ENUMC, ENUMD)):
...     pass
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 19, in __prepare__
  File "C:\Users\jcrwfrd\AppData\Local\Programs\Python\Python37\lib\enum.py", line 100, in __setitem__
    raise TypeError('Attempted to reuse key: %r' % key)
TypeError: Attempted to reuse key: 'a'
&gt;&gt;&gt;
</code></pre>
<p>This is due to the base <code>enum.EnumMeta.__prepare__</code> returning a special <code>enum._EnumDict</code> instead of the typical <code>dict</code> object that behaves different upon key assignment.  You may wish to suppress this error message by surrounding it with a <code>try</code>-<code>except TypeError</code>, or there may be a way to modify the namespace before calling <code>super().__prepare__(...)</code>.</p>
<p>This approach creates a new <code>Enum</code> using the same name-value pairs as the source <code>Enum</code>s, but the resulting <code>Enum</code> members are unique.  The names and values will be the same, but they will still fail certain comparisons:</p>
<pre><code>&gt;&gt;&gt; ENUMA.b.name == ENUMJOINED.b.name
True
&gt;&gt;&gt; ENUMA.b.value == ENUMJOINED.b.value
True
&gt;&gt;&gt; ENUMA.b == ENUMJOINED.b
False
&gt;&gt;&gt; ENUMA.b is ENUMJOINED.b
False
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">The idea behind an enum is that you have a complete list of all values of that type. If you extend it and add more values, you break the most fundamental property of enums.</span>
<span class="comment-copy">@user2357112: thx, this is an answer for my problem.</span>
<span class="comment-copy">Is there any other built-in method for do this?</span>
<span class="comment-copy">@falek.marcin: You'd need to provide more usage info. You could just make <code>BookingStatus</code> directly inherit from <code>Enum</code> and repeat the names values from the first; it's mildly redundant, and they won't interoperate (they're different types), but if you're only using one set of values, it's fine.</span>
<span class="comment-copy">@falek.marcin: Probably not. I think that the best thing you can do is to use another, simpler implementation of Enum. There are <a href="http://stackoverflow.com/q/36932/3821804">plenty of them</a>.</span>
<span class="comment-copy">@ShadowRanger: yes, it's a simple solution but i want to avoid duplication so i was just curios is there a possibility to extend enums.</span>
<span class="comment-copy">For the record, the reason it makes no sense is that <code>Enum</code> types use identity based comparisons and the values of the enumeration are immutable. And the <code>type</code> of a value is important when determining relative ordering, membership testing, etc. When you define <code>success</code>, its <code>type</code> is immutably set as <code>EventStatus</code>; if you were allowed to inherit from <code>EventStatus</code>, suddenly <code>success</code> would need to be <code>BookingStatus</code> too (doing so would violate immutability and/or cause issues with the <code>type</code> based testing).</span>
<span class="comment-copy">I would like to use code derived from your final snippet in the MIT-licensed <a href="https://pypi.python.org/pypi/typhon" rel="nofollow noreferrer">typhon library</a>.  Are you willing to relicense this under a MIT-compatible license?  I will keep full attribution.</span>
<span class="comment-copy">@gerrit yes, sure feel free to use it! sorry for the late reply</span>
