<div class="post-text" itemprop="text">
<p>I have a large datasource from which I pull data, chunk by chunk.<br/>
Instead of returning a chunk of <code>chunksize</code> items, I want to yield a single item, via a generator, and once I have yield all the data from a chunk I want to load the next chunk.<br/>
The goal is to return one item at a time, without loading the full datasource, but also without pulling the items one by one from the datasource.</p>
<p>Here is some pseudo code:</p>
<pre class="lang-py prettyprint-override"><code>def get_data_chunk(datasource, chunksize=10):
    # grab chunksize elements of datasource
    return data_chunk # a list of dict, usually

def generator(datasource):
    data_chunk = get_data_chunk(datasource)
    for item in data_chunk:
        yield item
    # if no more item in data_chunk, reload from get_data_chunk
    # until datasource does not return anything
</code></pre>
<p>I tried to use a queue that I refill once empty, without success.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have two options:</p>
<ol>
<li><p>Either use a <code>while True:</code> loop and exit when the next chunk is empty:</p>
<pre><code>def generator(datasource):
    while True:
        data_chunk = get_data_chunk(datasource)
        if not data_chunk:
            return
        for item in data_chunk:
            yield item
</code></pre></li>
<li><p>Use the two-argument form of the <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter()</code> function</a> in a <code>for</code> loop:</p>
<pre><code>def generator(datasource):
    for data_chunk in iter(lambda: get_data_chunk(datasource), None):
        for item in data_chunk:
            yield item
</code></pre>
<p>or, using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a>:</p>
<pre><code>from itertools import chain

def generator(datasource):
    chunk_iter = iter(lambda: get_data_chunk(datasource), None)
    yield from chain.from_iterable(chunk_iter)
</code></pre></li>
</ol>
<p>The latter requires that you know what the 'end value' looks like. In the above, I assumed that that end value is <code>None</code>, but if it is an empty list, you need to replace <code>None</code> with <code>[]</code>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, islice
&gt;&gt;&gt; from random import randrange
&gt;&gt;&gt; demosource = (randrange(11, 81) for _ in range(17))
&gt;&gt;&gt; def get_data_chunk(datasource, chunksize=10):
...     return list(islice(datasource, chunksize))
...
&gt;&gt;&gt; def generator(datasource):
...     chunk_iter = iter(lambda: get_data_chunk(datasource), [])  # last chuck is an empty list
...     yield from chain.from_iterable(chunk_iter)
...
&gt;&gt;&gt; list(generator(demosource))
[38, 47, 74, 13, 23, 24, 47, 61, 30, 38, 70, 41, 43, 47, 37, 34, 67]
</code></pre>
</div>
