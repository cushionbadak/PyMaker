<div class="post-text" itemprop="text">
<p>The below works in Python 2 but not 3. Is there a way to access local variables in Python 3? Or an alternative solution to these cases?</p>
<pre><code>[('{name_var}_{i:02d}of{maxpg:02d}.{date_var}').format(i, **locals()) 
  for i in range(start, end)]
</code></pre>
<p>Error in Python 3: </p>
<blockquote>
<p>KeyError: 'local_var'</p>
</blockquote>
<p>Below is a simpler toy example of above (works in Python 2 but not 3)</p>
<pre><code>local_var = 'hello'
['{local_var}'.format(**locals()) for i in range(1)]
</code></pre>
<p>Error in Python 3: </p>
<blockquote>
<p>KeyError: 'local_var'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As explained by @user2357112 in a comment, list comprehensions have their own local scope (and thus <code>locals()</code> dict) in Python 3.</p>
<p>Compare:</p>
<pre><code>&gt;&gt;&gt; var=1
&gt;&gt;&gt; [locals() for _ in range(1)]
[{'_': 0, '.0': &lt;range_iterator object at 0x7f5b65cb7270&gt;}]
</code></pre>
<p>With</p>
<pre><code>&gt;&gt;&gt; [l for l in (locals(), )]
[{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'var': 1}]
</code></pre>
<p>In the first case, the function <code>locals</code> is called inside the list comprehension code while in the second the result of the function call is passed as an argument to the list comprehension.</p>
<p>The <code>dis</code> module confirms that:</p>
<pre><code>&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; def f(): return [locals() for _ in range(1)]
... 
&gt;&gt;&gt; dis(f)
  1           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x7fc8173bd9c0, file "&lt;stdin&gt;", line 1&gt;)
              2 LOAD_CONST               2 ('f.&lt;locals&gt;.&lt;listcomp&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_GLOBAL              0 (range)
              8 LOAD_CONST               3 (1)
             10 CALL_FUNCTION            1
             12 GET_ITER
             14 CALL_FUNCTION            1
             16 RETURN_VALUE
</code></pre>
<p>The <code>locals</code> function was not called. You see the call in the code of the list comprehension:</p>
<pre><code>&gt;&gt;&gt; dis(f.__code__.co_consts[1])
  1           0 BUILD_LIST               0
              2 LOAD_FAST                0 (.0)
        &gt;&gt;    4 FOR_ITER                10 (to 16)
              6 STORE_FAST               1 (_)
              8 LOAD_GLOBAL              0 (locals)
             10 CALL_FUNCTION            0
             12 LIST_APPEND              2
             14 JUMP_ABSOLUTE            4
        &gt;&gt;   16 RETURN_VALUE
</code></pre>
<p>While             </p>
<pre><code>&gt;&gt;&gt; def g(): return [l for l in (locals(),)]
... 
&gt;&gt;&gt; dis(g)
  1           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x7f5b65cb8930, file "&lt;stdin&gt;", line 1&gt;)
              2 LOAD_CONST               2 ('g.&lt;locals&gt;.&lt;listcomp&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_GLOBAL              0 (locals)
              8 CALL_FUNCTION            0
             10 BUILD_TUPLE              1
             12 GET_ITER
             14 CALL_FUNCTION            1
             16 RETURN_VALUE
</code></pre>
<p>The <code>locals</code> function is called before the list comprehension execution, the iter is built and passed to the list comprehension.</p>
<p>Concerning your specific problem, you can force the evaluation of <code>locals</code> outside of the list comprehension (note the <code>i=i</code>: this is not a positional argument):</p>
<pre><code>&gt;&gt;&gt; d = locals()
&gt;&gt;&gt; ['{name_var}_{i:02d}of{maxpg:02d}.{date_var}'.format(i=i, **d) for i in range(start, end)]
['VAR_00of01.2019-01-01', 'VAR_01of01.2019-01-01', 'VAR_02of01.2019-01-01', 'VAR_03of01.2019-01-01', 'VAR_04of01.2019-01-01', 'VAR_05of01.2019-01-01', 'VAR_06of01.2019-01-01', 'VAR_07of01.2019-01-01', 'VAR_08of01.2019-01-01', 'VAR_09of01.2019-01-01']
</code></pre>
<p>If your version of Python is 3.6 or newer, you can use (f strings)[<a href="https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals]" rel="nofollow noreferrer">https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals]</a></p>
<pre><code>&gt;&gt;&gt; [f'{name_var}_{i:02d}of{maxpg:02d}.{date_var}' for i in range(start, end)]
['VAR_00of01.2019-01-01', 'VAR_01of01.2019-01-01', 'VAR_02of01.2019-01-01', 'VAR_03of01.2019-01-01', 'VAR_04of01.2019-01-01', 'VAR_05of01.2019-01-01', 'VAR_06of01.2019-01-01', 'VAR_07of01.2019-01-01', 'VAR_08of01.2019-01-01', 'VAR_09of01.2019-01-01']
</code></pre>
<p>However, I think it's not a good idea to make a lookup in <code>locals()</code> for every iteration. You can build your <code>format_string</code> once and use it in the list comprehension: </p>
<pre><code>&gt;&gt;&gt; format_string = '{name_var}_{{i:02d}}of{maxpg:02d}.{date_var}'.format(**locals()) 
&gt;&gt;&gt; format_string
'VAR_{i:02d}of01.2019-01-01'
</code></pre>
<p>Or (&gt;= 3.6):</p>
<pre><code>&gt;&gt;&gt; format_string = f'{name_var}_{{i:02d}}of{maxpg:02d}.{date_var}'
</code></pre>
<p>Then you have:</p>
<pre><code>&gt;&gt;&gt; [format_string.format(i=i) for i in range(start, end)]
['VAR_00of01.2019-01-01', 'VAR_01of01.2019-01-01', 'VAR_02of01.2019-01-01', 'VAR_03of01.2019-01-01', 'VAR_04of01.2019-01-01', 'VAR_05of01.2019-01-01', 'VAR_06of01.2019-01-01', 'VAR_07of01.2019-01-01', 'VAR_08of01.2019-01-01', 'VAR_09of01.2019-01-01']
</code></pre>
</div>
<span class="comment-copy">Please make a clearer example for us, currently your code works in any version...</span>
<span class="comment-copy">are you using some broken shell by happenstance? the <code>***</code> is not what the standard python repl shows.</span>
<span class="comment-copy">Sorry for the confusion. I fixed the toy example to one that's representative and re-tested to confirm it works in Python 2 but not 3. The old one was only broken in pdb (for pdb-specific reasons).</span>
<span class="comment-copy">On Python 3, the list comprehension has its own local scope. Variables from the outer scope won't show up in <code>locals()</code> unless the list comprehension uses them as closure variables.</span>
<span class="comment-copy">@bamboo77: If the list comprehension contains a direct name lookup for variable <code>blah</code>, something like <code>[blah for thing in stuff]</code>, then the compiler will compile the code to go through the extra work needed to support accessing <code>blah</code> from within the comprehension. If it just calls <code>locals</code>, something like <code>[locals()['blah'] for thing in stuff]</code>, the compiler doesn't activate the mechanisms needed to support the lookup.</span>
<span class="comment-copy">Great answer!!!</span>
<span class="comment-copy">Thanks for the workaround - this works!</span>
