<div class="post-text" itemprop="text">
<p>I've found that you can run a php file from Python by using this:</p>
<pre><code>import subprocess

proc = subprocess.Popen('php.exe input.php', shell=True, stdout=subprocess.PIPE)
response = proc.stdout.read().decode("utf-8")
print(response)
</code></pre>
<p>But is there a way to run php code from a string, not from a file? For example:</p>
<pre><code>&lt;?php
  $a = ['a', 'b', 'c'][0];
  echo($a);
?&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>[EDIT]   </p>
<p>Use <code>php -r "code"</code> with <em>subprocess.Popen</em>:</p>
<pre><code>def php(code):
    p = subprocess.Popen(["php", "-r", code],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out = p.communicate() #returns a tuple (stdoutdata, stderrdata)
    if out[1] != b'': raise Exception(out[1].decode('UTF-8'))
    return out[0].decode('UTF-8')

code = """ \
  $a = ['a', 'b', 'c'][2]; \
  echo($a);"""
print(php(code))
</code></pre>
<p>[Original Answer]  </p>
<p>I found a <a href="https://github.com/brool/util/blob/master/php.py" rel="nofollow noreferrer">simple class</a> that allows you to do that.<br/>
The code is self-explanatory. The class contains 3 methods:</p>
<blockquote>
<ul>
<li>get_raw(self, code): Given a code block, invoke the code and return the raw result as a string  </li>
<li>get(self, code): Given a code block that emits json, invoke the code and interpret the result as a Python value.  </li>
<li>get_one(self, code): Given a code block that emits multiple json values (one per line), yield the next value.</li>
</ul>
</blockquote>
<p>The example you wrote would look like this:</p>
<pre><code>php = PHP()
code = """ \
  $a = ['a', 'b', 'c'][0]; \
  echo($a);"""
print (php.get_raw(code))
</code></pre>
<p>You can also add a prefix and postfix to the code with <code>PHP(prefix="",postfix"")</code></p>
<p>PS.: I modified the original class because popen2 is deprecated. I also made the code compatible with Python 3. You can <a href="https://gist.github.com/victortv7/e5b30bf5aff71c9511d98f77c9bfb1be" rel="nofollow noreferrer">get it here</a> :</p>
<pre><code>import json
import subprocess

class PHP:
    """This class provides a stupid simple interface to PHP code."""

    def __init__(self, prefix="", postfix=""):
        """prefix = optional prefix for all code (usually require statements)
        postfix = optional postfix for all code
        Semicolons are not added automatically, so you'll need to make sure to put them in!"""
        self.prefix = prefix
        self.postfix = postfix

    def __submit(self, code):
        code = self.prefix + code + self.postfix
        p = subprocess.Popen(["php","-r",code], shell=True,
                  stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        (child_stdin, child_stdout) = (p.stdin, p.stdout)
        return child_stdout

    def get_raw(self, code):
        """Given a code block, invoke the code and return the raw result as a string."""
        out = self.__submit(code)
        return out.read()

    def get(self, code):
        """Given a code block that emits json, invoke the code and interpret the result as a Python value."""
        out = self.__submit(code)
        return json.loads(out.read())

    def get_one(self, code):
        """Given a code block that emits multiple json values (one per line), yield the next value."""
        out = self.__submit(code)
        for line in out:
            line = line.strip()
            if line:
                yield json.loads(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on Victor Val's answer, here is my own compact version.</p>
<pre><code>import subprocess

def run(code):
    p = subprocess.Popen(['php','-r',code], stdout=subprocess.PIPE)
    return p.stdout.read().decode('utf-8')

code = """ \
  $a = ['a', 'b', 'c'][0]; \
  echo($a);"""
print(run(code))
</code></pre>
</div>
<span class="comment-copy">Yes. PHP can run code from stdin.</span>
<span class="comment-copy">Can you demonstrate?</span>
<span class="comment-copy">Check out the <code>-r --run</code> command line flag on <a href="http://php.net/manual/en/features.commandline.options.php" rel="nofollow noreferrer">php.net/manual/en/features.commandline.options.php</a></span>
<span class="comment-copy">Thanks very much for your answer. I found two problems, however, but neither are serious. With <code>close_fds=True</code> included I get the error <code>ValueError: close_fds is not supported on Windows platforms if you redirect stdin/stdout/stderr</code>, but with that removed it runs fine. Then I still get the output in bytes with <code>b</code> at the beginning. So I just added <code>.decode("utf-8")</code> to the print statement, like in my first example. If you make those changes to the answer it will be more helpful.</span>
<span class="comment-copy">Also, the functions <code>get</code> and <code>get_one</code> are unneeded for this example, and so could be removed for brevity.</span>
<span class="comment-copy">From what <a href="https://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">I've read</a>:   "Note that on Windows, you cannot set close_fds to true and also redirect the standard handles by setting stdin, stdout or stderr."   I realized that it was working for me because I am using <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">python 3.7</a>: "Changed in version 3.7: Itâ€™s now possible to set close_fds to True when redirecting the standard handles"</span>
<span class="comment-copy">Is there any advantage of using close_fds?</span>
<span class="comment-copy">I think it's better to leave out close_fds and let the <i>subprocess</i> decide what is best according to your OS and python version. Also, reading the docs I could note that it recommends using shell=False to avoid code injection and using the method communicate() instead of read() when you use stdout=PIPE. stdin is also not necessary if you don't need to send a streaming input. I've edited my post to include a much simpler version. I've added exception handling though, which was made easier with <i>communicate()</i></span>
