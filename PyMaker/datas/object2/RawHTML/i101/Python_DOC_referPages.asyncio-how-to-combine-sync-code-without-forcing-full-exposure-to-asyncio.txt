<div class="post-text" itemprop="text">
<p>It seems that python's asyncio is an all-or-nothing kind of deal. Specifically it seems to force full call stack to be async-aware.</p>
<p>Here is an example:</p>
<p>Let's assume that there is an algorithm implemented by function <em>a()</em>.<br/>
That algorithm calls function <em>b()</em>.</p>
<pre><code>def a(b):
  for i in ...:
    # do smth...
    res = b()
    # do smth more ...
</code></pre>
<p>Now let's assume that function <em>b()</em> might be implemented differently in different environments and one might want to call <em>a()</em> inside an async event loop (with <em>loop.call_soon()</em>) with <em>b()</em> calling some asyncio-aware code:</p>
<pre><code>def b():
   await .... # this forces b() to be declared async.
</code></pre>
<p>Using existing event loop seems to be explicitly prohibited...
So, are there methods to implement this functionality without forcing the full stack (<em>a()</em> and <em>b()</em>) to be explicitly defined as async coroutines?</p>
</div>
<div class="post-text" itemprop="text">
<p>Although taken at face value asyncio <em>is</em> an all-or-nothing deal, there are still two escape hatches that can help when dealing with legacy or heterogenous environment:</p>
<ul>
<li><p>Within asyncio, you can await <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools" rel="nofollow noreferrer"><code>loop.run_in_executor(callable, args...)</code></a> to evaluate sync code in another thread, and suspending the current coroutine until the result is ready.</p></li>
<li><p>Outside asyncio, you can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe()</code></a> to submit a coroutine to an event loop running in another thread. The function returns a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>concurrent.futures</code> future</a> which has a blocking <code>result()</code> method. (This requires starting an event loop in a separate thread beforehand.)</p></li>
</ul>
<p>With those two tools at your disposal, it is not that hard to mix asyncio and classic synchronous code.</p>
</div>
<span class="comment-copy"><code>It seems that python's asyncio is an all-or-nothing kind of deal. Specifically it seems to force full call stack to be async-aware.</code> -- Yep.  All <code>async</code> stacks are like that.</span>
<span class="comment-copy">Gevent offers a little more flexibility.  What I like about it, is you don't have to necessarily write async code to make it async.  Especially WSGI stuff.  A simple spawn is all that's required to make it async.</span>
<span class="comment-copy"><a href="https://colmap.github.io/index.html" rel="nofollow noreferrer"><code>run_in_executor</code></a>?</span>
