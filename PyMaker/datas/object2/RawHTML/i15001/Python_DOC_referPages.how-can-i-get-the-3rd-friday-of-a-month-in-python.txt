<div class="post-text" itemprop="text">
<p>I'm trying to get stock data from Yahoo! Finance using Python 2.7.9, but I only need data for the 3rd Friday of the month. I have a function to get the data, but need a way to get the dates. I want something like this:</p>
<pre><code>def get_third_fris(how_many):
    # code and stuff
    return list_of_fris
</code></pre>
<p>So that calling <code>get_third_fris(6)</code> will return a 6-item-long list of 3rd Fridays following the current date. <strong>The dates need to be Unix timestamps.</strong></p>
<p>(I have pretty much no experience with <code>time</code> or <code>datetime</code>, so please explain what your code is doing.)</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/calendar.html" rel="nofollow noreferrer"><code>calendar</code></a> module to list weeks, then grab the Friday of that week.</p>
<pre><code>import calendar

c = calendar.Calendar(firstweekday=calendar.SUNDAY)

year = 2015; month = 2

monthcal = c.monthdatescalendar(year,month)
third_friday = [day for week in monthcal for day in week if \
                day.weekday() == calendar.FRIDAY and \
                day.month == month][2]
</code></pre>
<p>You <strong><em>can</em></strong> format to Unix timestamp, but it's non-trivial. I'll refer you to <a href="https://stackoverflow.com/a/8778548/3058609">this excellent answer</a> which has info based on whether or not your date is timezone-aware.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use standard python functions to find the third friday of this month:</p>
<pre><code>from datetime import timedelta, date
import calendar

def next_third_friday(d):
    """ Given a third friday find next third friday"""
    d += timedelta(weeks=4)
    return d if d.day &gt;= 15 else d + timedelta(weeks=1)

def third_fridays(d, n):
    """Given a date, calculates n next third fridays"""

    # Find closest friday to 15th of month
    s = date(d.year, d.month, 15)
    result = [s + timedelta(days=(calendar.FRIDAY - s.weekday()) % 7)]

    # This month's third friday passed. Find next.
    if result[0] &lt; d:
        result[0] = next_third_friday(result[0])

    for i in range(n - 1):
        result.append(next_third_friday(result[-1]))

    return result
</code></pre>
<p>We can apply the above function to get the timestamps of the next fridays:</p>
<pre><code>import time

def timestamp(d):
    return int(time.mktime(d.timetuple()))

fridays = third_fridays(date.today(), 2)

print(fridays)
print(map(timestamp, fridays))
</code></pre>
<p>Output:</p>
<pre><code>[datetime.date(2015, 3, 20), datetime.date(2015, 4, 17)]   
[1426802400, 1429218000]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about a more straightforward answer:</p>
<pre><code>import calendar 
c = calendar.Calendar(firstweekday=calendar.SATURDAY)
monthcal = c.monthdatescalendar(my_year, my_month)
monthly_expire_date = monthcal[2][-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We do not need to import anything other than datetime. We can assume 7 days in a week and weekday 0 == Monday.</p>
<pre><code>import datetime

def third_friday(year, month):
    """Return datetime.date for monthly option expiration given year and
    month
    """
    # The 15th is the lowest third day in the month
    third = datetime.date(year, month, 15)
    # What day of the week is the 15th?
    w = third.weekday()
    # Friday is weekday 4
    if w != 4:
        # Replace just the day (of month)
        third = third.replace(day=(15 + (4 - w) % 7))
    return third
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>its easy to use dateutil to get the next friday</p>
<pre><code>import dateutil.parser as dparse
from datetime import timedelta
next_friday = dparse.parse("Friday")
one_week = timedelta(days=7)
friday_after_next = next_friday + one_week
last_friday = friday_after_next + one_week
</code></pre>
<p>this leverages the fact that there is always a week between fridays ... although Im not sure this answers your question it should at the very least provide you with a good starting point</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://labix.org/python-dateutil#head-ba5ffd4df8111d1b83fc194b97ebecf837add454" rel="nofollow noreferrer"><code>dateutil.relativedelta</code></a>:</p>
<pre><code>from dateutil.relativedelta import relativedelta, FR # $ pip install python-dateutil

def third_friday_dateutil(now):
    """the 3rd Friday of the month, not the 3rd Friday after today."""
    now = now.replace(day=1) # 1st day of the month
    now += relativedelta(weeks=2, weekday=FR)
    return now
</code></pre>
<p>Or using <a href="https://dateutil.readthedocs.org/en/latest/rrule.html" rel="nofollow noreferrer"><code>dateutil.rrule</code></a>:</p>
<pre><code>from datetime import date, timedelta
from dateutil.rrule import rrule, MONTHLY, FR

def third_friday_rrule(now):
    return rrule(MONTHLY, count=1, byweekday=FR, bysetpos=3, dtstart=now.replace(day=1))[0]

def get_third_fris_rrule(how_many):
    return list(rrule(MONTHLY, count=how_many, byweekday=FR, bysetpos=3, dtstart=date.today()+timedelta(1)))
</code></pre>
<p>Here's a brute force solution (15x times faster):</p>
<pre><code>#!/usr/bin/env python
import calendar
from datetime import date, timedelta
from itertools import islice

DAY = timedelta(1)
WEEK = 7*DAY

def fridays(now):
    while True:
        if now.weekday() == calendar.FRIDAY:
            while True:
                yield now
                now += WEEK
        now += DAY

def next_month(now):
    """Return the first date that is in the next month."""
    return (now.replace(day=15) + 20*DAY).replace(day=1)

def third_friday_brute_force(now):
    """the 3rd Friday of the month, not the 3rd Friday after today."""
    return next(islice(fridays(now.replace(day=1)), 2, 3))

def get_third_fris(how_many):
    result = []
    now = date.today()
    while len(result) &lt; how_many:
        fr = third_friday_brute_force(now)
        if fr &gt; now: # use only the 3rd Friday after today
            result.append(fr)
        now = next_month(now)
    return result

print(get_third_fris(6))
</code></pre>
<h3>Output</h3>
<pre><code>[datetime.date(2015, 3, 20),
 datetime.date(2015, 4, 17),
 datetime.date(2015, 5, 15),
 datetime.date(2015, 6, 19),
 datetime.date(2015, 7, 17),
 datetime.date(2015, 8, 21)]
</code></pre>
<p>See <a href="https://stackoverflow.com/a/8778548/4279">Converting datetime.date to UTC timestamp in Python</a></p>
<p>Here's <a href="https://gist.github.com/zed/11441b4776f7bbecc830" rel="nofollow noreferrer">comparison with other solutions and tests (for all possible 400 years patterns)</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I generalized @pourhaus answer to find the nth day of any month:</p>
<pre><code>def nth_day_of_month(month, year, day_of_week, n):
    first_possible_day = {1: 1, 2: 8, 3: 15, 4: 22, 5: 29}[n]
    d = datetime.date(year, month, first_possible_day)
    w = d.weekday()
    if w != day_of_week:
        d = d.replace(day=(first_possible_day + (day_of_week - w) % 7))
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from dateutil.relativedelta import *
from datetime import *

def find_mth_friday(your_date,m):
    mth_friday = your_date + relativedelta(day=1, weekday=FR(m)) #sets day=1 in your_date and adds m fridays to it.
    mth_friday_timestamp = int(mth_friday.strftime("%s")) #converting datetime to unix timestamp
    return mth_friday_timestamp

def get_third_fris(n):
    output_timestamps = []
    today = datetime.now() #gets current system date
    for i in range(1,n+1): #value of i varies from 1 to 6 if n=6
        next_month = today + relativedelta(months=+i) #adds i months to current system date
        third_friday = find_mth_friday(next_month,3) #finds third friday of the month using 'find_mth_friday()', the function we defined
        output_timestamps.append(third_friday)
    return output_timestamps

print(get_third_fris(6)) #let's try invoking our function with n=6 dates
</code></pre>
<p>This is what you wanted right?</p>
</div>
<span class="comment-copy">very clever :P ) you win :P</span>
<span class="comment-copy">@JoranBeasley I actually thought you answered the question as-asked and gave up my search for the <code>calendar</code> documentation until I re-read your answer and redoubled my efforts :D</span>
<span class="comment-copy">The Friday of the third week is not necessarily the third Friday!</span>
<span class="comment-copy">@spelchekr: this answer is incorrect for <code>year, month = 2015, 8</code> -- it returns <code>2015-08-14</code> but it should be <code>2015-08-21</code>.</span>
<span class="comment-copy">it works now. Though <a href="https://gist.github.com/zed/11441b4776f7bbecc830" rel="nofollow noreferrer">@JuniorCompressor's solution is 9x times faster</a></span>
<span class="comment-copy">It looks like an efficient solution but it is not clear how and whether it works (it is easy to prove that it works: enumerate all possible starting dates for 400 years and compare the result with a brute force approach and/or solutions from other answers). An explanation on why <code>days = 14 + (4 - start_of_month.weekday()) % 7</code> and/or <code>next_friday += timedelta(days=28)</code> <b>always</b> works wouldn't hurt either. Use <code>calendar.FRIDAY</code> instead of <code>4</code> and/or use <code>timedelta(weeks=4)</code> instead of <code>timedelta(days=28)</code> for clarity. In Python <code>-1 % 7 == 6</code> that might be surprising.</span>
<span class="comment-copy">Thanks a lot for the comments</span>
<span class="comment-copy"><code>+timedelta(weeks=4)</code>-based formula fails e.g., for <code>d=2015-05-31</code> it returns <code>2015-06-12</code> but it should be <code>2015-06-19</code>. The formula <code>s = date(d.year, d.month, 15);  s + timedelta(days=(calendar.FRIDAY - s.weekday()) % 7)</code> always works and returns the 3rd friday of the month.</span>
<span class="comment-copy">Yeap I thought every third friday has distance 4 weeks. I corrected the implementation.</span>
<span class="comment-copy">The equivalent is to change <code>if result[0] &lt; d</code> to <code>&lt;=</code></span>
<span class="comment-copy">Good solution! I am uncertain about its efficiency, since you need to generate the entire calendar.</span>
<span class="comment-copy">Incredible solution, thank you. Just to clarify the comment <code>The 15th is the lowest third day in the month</code>: the earliest a 3rd Friday can happen in a month, is if the 1st day of the month is a Friday, so that 7 days later you have another Friday, and 7 days later you have the 3rd Friday (at the 15th day of the month).</span>
<span class="comment-copy">I need the 3rd Friday of the month, not the 3rd Friday after today. Although I could use this to just add 2 weeks from the 1st Friday of the month. How could I get that?</span>
<span class="comment-copy">@spelchekr: I've added <a href="http://stackoverflow.com/a/28696431/4279"><code>dateutil.relativedelta</code>-based solution</a>.</span>
<span class="comment-copy">Forgive my ignorance. I am learning. How is your fridays(now) function not an infinite loop? WHat keeps it from going on forever, finding the fridays from now until eternity (or i guess some machine max)?</span>
<span class="comment-copy">@lukehawk <code>next(islice</code> takes the 3rd Friday from the infinite <code>fridays()</code> generator (like <code>seq[2:3]</code>). See <a href="http://stackoverflow.com/q/231767/4279">What does the "yield" keyword do?</a></span>
