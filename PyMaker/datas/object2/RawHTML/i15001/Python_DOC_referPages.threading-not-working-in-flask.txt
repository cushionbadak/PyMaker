<div class="post-text" itemprop="text">
<p>I'm trying to use threading in my flask app, like:</p>
<pre><code>@app.route('/index')
def index():
    t = threading.Thread(do_sth_else())
    t.start()
    print('ready to response')
    return render_template('index.html')

def do_sth_else():
    time.sleep(5)
    print('sth else done')
</code></pre>
<p>When calling <code>127.0.0.1:5000/index</code> in the browser, the result in the server console is not what I expected:</p>
<pre><code>sth else done
ready to response
</code></pre>
<p>I want the <code>do_sth_else()</code> function to run in some other thread, while the <code>index()</code> function go on returning the response right away, which means I should see the above result in defferent order.</p>
<p>So I want to know:</p>
<ol>
<li>Why the <code>index()</code> function kept waiting until <code>do_sth_else()</code> is finished</li>
<li>How do I get the app working as I wanted</li>
</ol>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>t = threading.Thread(do_sth_else())</code> calls <code>do_sth_else()</code> and pass it's result to <code>Thread</code>.
You should use it like <code>t = threading.Thread(do_sth_else)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>For actual parallelization in Python, you should use the <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow">multiprocessing</a> module to fork multiple processes that execute in parallel.
Python threads provide interleaving, but are in fact executed serially, not in parallel.</p>
<p>This applies to CPython due to the existence of global interpreter lock, otherwise true concurrency is bound to number of cpu's you have</p>
</div>
<div class="post-text" itemprop="text">
<p>This example working as you want (tested on Python 3.4.3)</p>
<pre><code>from time import sleep
from concurrent.futures import ThreadPoolExecutor

# DOCS https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
executor = ThreadPoolExecutor(2)


@app.route('/index')
def index():
    executor.submit(do_sth_else)
    print('ready to response')
    return render_template('index.html')


def do_sth_else():
    print("Task started!")
    sleep(10)
    print("Task is done!")
</code></pre>
</div>
<span class="comment-copy">I have change ` t = threading.Thread(do_sth_else())` to ` t = threading.Thread(do_sth_else)`, the result seems right, But i don't know the reason!!!!</span>
<span class="comment-copy">@BlackMamba : @methane 's answer explained the reason, using <code>t = threading.Thread(target=do_sth_else)</code> seem to work for me. And if in need of passing parameter to the target function, use the <code>arg=(parameters)</code> keyword argument.</span>
<span class="comment-copy">Thanks a lot! After looking into the <code>threading.Thread()</code> doc, I think I understood how the function work. :)</span>
<span class="comment-copy">You should specify that this only applies to <code>CPython</code> due to the existence of <code>global interpreter lock</code>, otherwise true concurrency is bound to number of cpu's you have. <a href="http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock" rel="nofollow noreferrer">jython.org/jythonbook/en/1.0/â€¦</a></span>
<span class="comment-copy">@ozgur That's right</span>
