<div class="post-text" itemprop="text">
<p>I have 2 instances of classes that I would like to resolve to the same key in a dictionary:</p>
<pre><code>class CustomClass(): 
    def __hash__(self):
        return 2

a = CustomClass()        
b = CustomClass()        

dicty = {a : 1}
</code></pre>
<p>Here, a and b are not equal as being keys:</p>
<pre><code>&gt;&gt;&gt; a in dicty
True
&gt;&gt;&gt; b in dicty
False
</code></pre>
<p>What exactly is happening with hash; it seemed like a second instance of the CustomClass should match the hashing? What is going on that these hashes do not match? </p>
<p>I just now discovered the actual class is what is being hashed. So how to add a custom dictionary key for a class (i.e. when I try to use a class as a key for a dictionary, how should it be stored so that a and b match)?</p>
<p>Note that in this case I do not care about keeping a link to the original object in the dictionary, I can work with some unusable key object; just it matters they resolve to the same.</p>
<p>EDIT:</p>
<p>Perhaps some advice on the actual case I'd like to solve is required.</p>
<p>I have classes containing boolean <code>np.arrays</code> of shape <code>(8,6)</code>. I want to hash these such that whenever this object is put into a dictionary, the comparison takes place on these values. I made a bitarray out of them according to <a href="https://stackoverflow.com/questions/6694835/efficient-serialization-of-numpy-boolean-arrays">this</a> answer. I noticed it has a <code>__cmp__</code> there (thanks <code>thefourtheye</code> for showing I have to look there). However, my class can be updated, so I'd only like to hash the np.array when I'm actually trying to put it into a dictionary, and not on initiation (and thus storing the hashable bitarray whenever I <strong>init</strong>, since the np.array might be updated, such that the hash is not a real representation anymore). I know that whenever I would update the np.array, I could also update the hashed value, but I'd prefer to only hash once!  </p>
</div>
<div class="post-text" itemprop="text">
<p>You broke the contract between <code>__hash__</code>, <code>__cmp__</code> and <code>__eq__</code>. Quoting the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow"><code>__hash__</code> documentation</a>,</p>
<blockquote>
<p><strong>If a class does not define a <code>__cmp__()</code> or <code>__eq__()</code> method it should not define a <code>__hash__()</code> operation either</strong>; if it defines <code>__cmp__()</code> or <code>__eq__()</code> but not <code>__hash__()</code>, its instances will not be usable in hashed collections. If a class defines mutable objects and implements a <code>__cmp__()</code> or <code>__eq__()</code> method, it should not implement <code>__hash__()</code>, since hashable collection implementations require that a object’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).</p>
<p><strong>User-defined classes have <code>__cmp__()</code> and <code>__hash__()</code> methods by default; with them, all objects compare unequal (except with themselves)</strong> and <code>x.__hash__()</code> returns an appropriate value such that <code>x == y</code> implies both that <code>x is y</code> and <code>hash(x) == hash(y)</code>.</p>
</blockquote>
<p>In your case, the hash value is the same for two objects and <a href="http://en.wikipedia.org/wiki/Hash_table#Collision_resolution" rel="nofollow">hash Collision</a> is common in any hash implementation. So, Python compares the object being looked up with the help <code>__eq__</code> method and finds out that the actual object being searched is not the same as the object already stored in. That is why <code>b in dicty</code> returns <code>False</code>.</p>
<p>So, to fix your problem, define custom <code>__eq__</code> function also, like this</p>
<pre><code>class CustomClass():

    def __init__(self):
        self.data = &lt;something&gt;

    def __hash__(self):
        # Find hash value based on the `data`
        return hash(self.data)

    def __eq__(self, other):
        return self.data == other.data
</code></pre>
<p><strong>Note:</strong> <code>__hash__</code> value should always be the same for a given object. So, please make sure that the <code>data</code> is never changed after assigned initially. Otherwise you ll never be able to get the object from the dictionary, since <code>hash</code> value of <code>data</code> will be different, if it changes in the later point of time.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that the hash function can cause collisions -- different objects can produce the same hash value. As a result the final check to see if an object is present in a dict is still done using an equality comparison (ie. <code>x == y</code>). The hash value is first used to find the relevant objects quickly.</p>
<p>If you want the behaviour you describe then you must also override <code>__eq__</code> as well.</p>
<p>eg.</p>
<pre><code>class CustomClass: 
    def __hash__(self):
        return 2
    def __eq__(self, other):
        return type(self) is type(other) and type(self) is CustomClass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__hash__</code> just determines which bucket the value will be placed into. Within the bucket python always calls to <code>__eq__</code> to make sure it doesn't return an element that just happened to have the same hash, but which is in fact different, so you need to implement your own <code>__eq__</code> as well.</p>
<pre class="lang-py prettyprint-override"><code>class CustomClass():
    def __hash__(self):
        return 2

    def __eq__(self, other):
        return hash(other) == hash(self)


a = CustomClass()     
b = CustomClass()     

dicty = {a : 1}

print a in dicty
print b in dicty
print "a" in dicty
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should implement <code>__eq__</code> method to make your object <code>hashable</code>.
The definition of <code>hashable</code> from doc:</p>
<blockquote>
<p>An object is hashable if it has a hash value which never changes during 
  its lifetime (it needs a __hash__() method), and can be
  compared to other objects (it needs an __eq__() method). Hashable
  objects which compare equal must have the same hash value.</p>
<p>Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.</p>
</blockquote>
</div>
<span class="comment-copy"><code>so I'd only like to hash the np.array when I'm actually trying to put it into a dictionary</code> - Okay, lets say you stored in the dict. But if it can change latter, how will you get it from the dict?</span>
<span class="comment-copy">I would not want to get it from the dict.</span>
<span class="comment-copy">Then why bother storing it in the dict in the first place? Sounds like an <a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY Problem</a> to me.</span>
<span class="comment-copy">First, I populate a set with the initial hashed class objects. Afterwards, I dynamically generate a lot of redundant class objects, which I would like to count using a new dictionary, where whenever there is a hash hit, the count would be incremented. In the case of the counts, I do not care about whether the classes are completely equal, I just care about the hash value at that stage.</span>
<span class="comment-copy">perhaps I should not try to <code>myset.add(myclassobject)</code> and test <code>myclassobject in mydict</code> but I should just do <code>myset.add(hash(myclassobject)</code> and <code>hash(myclassobject) in mydict</code> to only have to do the computations twice (compared to more if I would also hash in <code>__eq__</code> or <code>__cmp__</code>)!</span>
<span class="comment-copy">Might I assume that np.array(dtype=bool) of shape (8,6) in its 262144 possible states would never resolve to the same hash, and thus __ eq __ could always return False not to have an extra calculation needed?</span>
<span class="comment-copy">My <code>__eq__</code> should basically be <code>hash(data) == hash(other.data)</code>, except that I would find it a waste to redo that test if it is not required?</span>
<span class="comment-copy">With respect to your Note: whenever my object's data is changed, it became a different object in my application (and does not have to match)</span>
<span class="comment-copy">@PascalvKooten Hmmm, its not very clear what you are trying to do. I get a feeling that you are focusing only on getting the Object in the dictionary but not worried about retrieving it back.</span>
<span class="comment-copy">that is true...</span>
<span class="comment-copy">Does that mean that if my hash value is going to be different, I can just put <code>return True</code>? My actual <code>__hash__</code> requires a calculation and I do not want to have to do it also at the <code>__eq__</code> stage. Actually, this might set me up that suddenly all instances of classes would match?</span>
<span class="comment-copy">I added an example code. Just putting <code>return True</code> is not enough, because then it will be equal to instances of other types as well, which I assume you don't want to happen.</span>
<span class="comment-copy">Ah, I think I understand now what you want. See my updated code. Just make your <code>__eq__</code> function compare hashes, this way elements with hash collisions will be actually considered equal in the dictionary</span>
<span class="comment-copy">@PascalvKooten Hashable objects must be immutable, thus you only need ever have to calculate the hash value once. You can then cache the hash value in an attribute like <code>_hash</code> for future use.</span>
<span class="comment-copy">@Ishamael However, this requires extra <code>hash</code> computations which I'm trying to avoid. What about always returning False? My main bet is that the hash values should never match if there are 262144 possible states</span>
