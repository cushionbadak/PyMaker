<div class="post-text" itemprop="text">
<p>I have gone through <a href="https://stackoverflow.com/questions/642763/python-intersection-of-two-lists">Find intersection of two lists?</a>, <a href="https://stackoverflow.com/questions/12765558/intersection-of-two-lists-of-strings">Intersection of Two Lists Of Strings</a>, <a href="https://stackoverflow.com/questions/27006622/getting-intersection-of-two-lists-in-python">Getting intersection of two lists in python</a>. However, I could not solve this problem of finding intersection between two string lists using Python.</p>
<p>I have two variables.  </p>
<pre><code>A = [['11@N3'], ['23@N0'], ['62@N0'], ['99@N0'], ['47@N7']]

B  = [['23@N0'], ['12@N1']]
</code></pre>
<p>How to find that '23@N0' is a part of both A and B?</p>
<p>I tried using intersect(a,b) as mentioned in <a href="http://www.saltycrane.com/blog/2008/01/how-to-find-intersection-and-union-of/" rel="nofollow noreferrer">http://www.saltycrane.com/blog/2008/01/how-to-find-intersection-and-union-of/</a>
But, when I try to convert A into set, it throws an error:</p>
<pre><code>File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unhashable type: 'list'
</code></pre>
<p>To convert this into a set, I used the method in <a href="https://stackoverflow.com/questions/13464152/typeerror-unhashable-type-list-when-using-built-in-set-function">TypeError: unhashable type: 'list' when using built-in set function</a> where the list can be converted using </p>
<pre><code>result = sorted(set(map(tuple, A)), reverse=True)
</code></pre>
<p>into a tuple and then the tuple can be converted into a set. However, this returns a null set as the intersection.</p>
<p>Can you help me find the intersection?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>flatten</code> function of <code>compiler.ast</code> module to flatten your sub-list and then apply set intersection like this</p>
<pre><code>from compiler.ast import flatten

A=[['11@N3'], ['23@N0'], ['62@N0'], ['99@N0'], ['47@N7']]
B=[['23@N0'], ['12@N1']]

a = flatten(A)
b = flatten(B)
common_elements = list(set(a).intersection(set(b)))
common_elements
['23@N0']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your datastructure is a bit strange, as it is a list of one-element lists of strings; you'd want to reduce it to a list of strings, then you can apply the previous solutions:</p>
<p>Thus a list like: </p>
<pre><code>B = [['23@N0'], ['12@N1']]
</code></pre>
<p>can be converted to iterator that iterates over <code>'23@N0', '12@N1'</code></p>
<p>with <code>itertools.chain(*)</code>, thus we have simple oneliner:</p>
<pre><code>&gt;&gt;&gt; set(chain(*A)).intersection(chain(*B))
{'23@N0'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that your lists contain sublists so they cannot be converted to sets. Try this:</p>
<pre><code>A=[['11@N3'], ['23@N0'], ['62@N0'], ['99@N0'], ['47@N7']]
B=[['23@N0'], ['12@N1']]

C = [item for sublist in A for item in sublist]
D = [item for sublist in B for item in sublist]

print set(C).intersection(set(D))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you have to fit it on a fortune cookie:</p>
<pre><code>set(i[0] for i in A).intersection(set(i[0] for i in B))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have two lists of lists with one item each. In order to convert that to a set you have to make it a list of strings:</p>
<pre><code>set_a = set([i[0] for i in A])
set_b = set([i[0] for i in B])
</code></pre>
<p>Now you can get the intersection:</p>
<pre><code>set_a.intersection(set_b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>A=[['11@N3'], ['23@N0'], ['62@N0'], ['99@N0'], ['47@N7']]
A=[a[0] for a in A]
B=[['23@N0'], ['12@N1']]
B=[b[0] for b in B]
print set.intersection(set(A),set(B))
</code></pre>
<p>Output:<code>set(['23@N0'])</code></p>
<p>If each of your list has sublists of only <code>1</code> element you can try this.</p>
</div>
<div class="post-text" itemprop="text">
<p>My preference is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> from the standard library:</p>
<pre><code>from itertools import chain

A = [['11@N3'], ['23@N0'], ['62@N0'], ['99@N0'], ['47@N7']]

B = [['23@N0'], ['12@N1']]

set(chain(*A)) &amp; set(chain(*B))

# {'23@N0'}
</code></pre>
</div>
<span class="comment-copy">The fastest way to intersect a big bunch of data is to use Python sets. Python sets are hash maps, therefore they require hashing. Your problem comes from wrapping strings into lists. Lists are mutable objects, that's why they can't be hashed, while strings, being immutable, can be.</span>
<span class="comment-copy">Is there a reason you have a single string in each list?</span>
<span class="comment-copy">This is the dataset I have, I did not generate it, borrowed it from someone.</span>
<span class="comment-copy">@SharathChandra: what does "borrowed" mean? Have you read it from a file? What format?</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/406121/4279">Flattening a shallow list in Python</a></span>
<span class="comment-copy">compiler.ast is python 2 only; suggest using itertools.chain</span>
<span class="comment-copy">Agree with you but if the input list is something like this A= ['11@N3', ['23@N0']] then applying itertools.chain will not truly flatten the list. Resulting list after list(itertools.chain(*A)) would be ['1', '1', '@', 'N', '3', '23@N0'].</span>
<span class="comment-copy">True too; what we really would need is a <code>flatten</code> itertool that would understand strings, bytes.</span>
<span class="comment-copy">@AnttiHaapala: perhaps, you are looking for <a href="http://stackoverflow.com/q/2158395/4279">Flatten (an irregular) list of lists in Python</a>.</span>
<span class="comment-copy">Neither was needed to answer this question, except many of the answers there wouldn't work in 3 either. I mean, it should be in core written in C.</span>
<span class="comment-copy">This does seem to be working if A and B are reversed in the last statement. That is, if we try set(B).intersection(A), it results an empty set.</span>
<span class="comment-copy">you don't need <code>[]</code> inside <code>()</code>: <code>set(x[0] for x in A) &amp; set(x[0] for x in B)</code></span>
