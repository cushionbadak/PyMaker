<div class="post-text" itemprop="text">
<p>I'm trying to write a function that finds the zero-based index of the longest run in a string. If there is more than one run with the same length, the code should return the index of the first one.</p>
<pre><code>a=["a","b","b","c","c","c","d","d","d","d","c","c","c","b","b","a"]

def longestrun(myList):
    result = None
    prev = None
    size = 0
    max_size = 0


    for i in myList:
        if i == prev:
            print (i)
            size += 1
            if size &gt; max_size:
                print ('*******  '+ str(max_size))
                max_size = size 
        else:
            size = 0
        prev = i
    print (max_size+1)    
    return max_size+1


longestrun(a)
</code></pre>
<p>I did some research and found this code which I think could be used to find the longest run in my list, but I don't know how to use this to find the index of the first letter in the longest run. Can anyone help me or give me some advice on how to do this? Overall, the output when the program is run should produce the number 6 as the first 'd' is at index 6, and is the longest run.</p>
<p>Please note I am a beginner so it would be appreciated if answers were kept as simple as possible, and explained.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should be fine:</p>
<pre><code>def longestrun(myList):
    prev = None
    size = 0
    max_size = 0
    curr_pos = 0
    max_pos = 0

    for (index, i) in enumerate(myList):
        if i == prev:
            size += 1
            if size &gt; max_size:
                max_size = size 
                max_pos = curr_pos
        else:
            size = 0
            curr_pos = index
        prev = i
    return max_pos
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code></a> with <a href="https://docs.python.org/2/library/functions.html#max" rel="nofollow"><code>max()</code></a> and <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a> for this:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

def longestrun_index(seq):
    groups = ((next(g), sum(1 for _ in g)+1) for k, g in groupby(enumerate(seq),
                                                             key=itemgetter(1)))
    (index, item), length = max(groups, key=itemgetter(1))
    return index

a = ["a","b","b","c","c","c","d","d","d","d","c","c","c","b","b","a"]    
print (longestrun_index(a))
# 6
</code></pre>
<p><strong>How this works?</strong></p>
<ul>
<li>We first make groups of similar items using <code>itertools.groupby</code> and <code>enumerate(a)</code>. But as <code>enumerate(a)</code> will return both index as well the item((index, item) tuples) from the list <code>a</code> we need to tell <code>groupby</code> to use the item to group stuff, for that I have used <code>operator.itemgetter(1)</code> in <code>groupby()</code>.</li>
<li><p>Now <code>groupby()</code> return two items, the item key item we have used for grouping and the groups in form of iterator. Now we can use this iterator(group) to get the first item as well the index by calling <code>next</code> on the iterator, and then to get the total count of all items present in this group use <code>sum()</code> with a generator expression: <code>sum(1 for _ in g)+1</code>. +1 was done to compensate the item we already fetched from this group using <code>next()</code> earlier on.</p></li>
<li><p>Using the index, key and the count we now have generator that will yield <code>((index, key), length)</code> on iteration.</p></li>
<li><p>Now we can simply use the built-in function  <code>max()</code> with itemgetter again to specify which item to use for comparison(<code>length</code> here) and find the required index.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If you want the starting index of the longest string:</p>
<pre><code>from operator import itemgetter
def longest(l):
    od = defaultdict(int)
    prev = None
    out = []
    for ind, ele in enumerate(l):
        if ele != prev and prev in od:
            out.append((ind, prev, od[prev]))
            od[prev] = 0
        od[ele] += 1
        prev = ele
    best = max(out, key=itemgetter(2)) # max by sequence length
    return best[0] - best[2] # deduct last index from length to get start
print(longest(a))
</code></pre>
<p>I stored all the keys and lengths in case you want to actually also know all the info. </p>
<p>Without imports:</p>
<pre><code>def longest1(l):
    prev = None
    seq = 0 
    best = 0
    indx = None 
    for ind, ele in enumerate(l):
        if ele != prev: # if we have a new char we have a new sequence
             # if current seq len is greater than our current best 
            if seq &gt; best: 
                # update best to current len and set index to start of the sequence
                best = seq
                indx  = ind - seq
            seq = 0 # reset seq count
        seq += 1
        prev = ele
    return indx 
print(longest(a))
</code></pre>
<p>Some timings show the simple loops are actually the most efficient:</p>
<pre><code>In [23]: timeit longestrun_index(a)
100000 loops, best of 3: 9.07 µs per loop

In [24]: timeit longestrun(a)
100000 loops, best of 3: 2.54 µs per loop

In [25]: timeit longest(a)
100000 loops, best of 3: 6.79 µs per loop

In [26]: timeit longest1(a)
100000 loops, best of 3: 3.06 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get a list of runs using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>, then you just have to find the max run and sum the length of all the previous runs:</p>
<pre><code>from itertools import groupby

a = ["a","b","b","c","c","c","d","d","d","d","c","c","c","b","b","a"]

# Get list of runs, each in the form (character, length)
runs = [(x, len(list(y))) for x,y in groupby(a)]

# Identify longest run
maxrun = max(runs, key=lambda x: x[1])

# Sum length of all runs before the max
index = 0
for run in runs:
    if run == maxrun: break
    index += run[1]

print(index)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use defaultdict to create a dictionary with a count of each item then find the key with the highest value, then find the first occurrence of that item.</p>
<pre><code>from collections import defaultdict
import operator

letters=["a","b","b","c","c","c","d","d","d","d","c","c","c","b","b","a"]

d = defaultdict(int)
for letter in letters:
    d[letter] += 1

highest_run = max(d.iteritems(), key=operator.itemgetter(1))[0]

z_index =''.join(letters).find(highest_run)
print z_index
</code></pre>
<p>The benefit of using modules is for simplicity and efficiency of development; plus the "standing on the shoulders of giants" effect from reusing well-maintained and well-tested code. That's not to say you shouldn't be careful when using modules to check that they are well maintained and come with unit tests. </p>
</div>
<span class="comment-copy">Thanks, this is really helpful and I like that it doesn't require modules to work. However, would you be able to explain what 'enumerate' is and how the for loop works?</span>
<span class="comment-copy">Enumerate will generate all the  (index, list element) pairs, and will go through them, so you also get the indexes. curr_pos will contain the start position of the actual run, and if we encounter the end of the run, we check if the current run's length is higher than the previous run's length. If so, we save the curr_pos to max_pos, which will become the result in the end.</span>
<span class="comment-copy">Thank you for the clear explanation, It really helped me understand the working behind this code :)</span>
