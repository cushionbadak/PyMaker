<div class="post-text" itemprop="text">
<p>My general workflow is using 2 screens; 1 for the script, 1 for the interactive buffer. I then evaluate parts of the script code in the interactive buffer. This is really nice when working with a small project (I just reevaluate the code I changed at that moment, everything else equal). It allows for (I'm convinced) the fastest iterations in writing a script.</p>
<p>However, I'm now working on a project where I try to be neat and organize my project with a single class per file (or close to it). </p>
<p>Now here lies the issue: While it is easy to evaluate parts of code, in Python it is difficult to import modules once they have already been imported. </p>
<p>Mind that I most of the time have useful objects in the interactive buffer / global scope (perhaps some objects took 10 minutes to be built). This means that I can't just close &amp; reopen everything.</p>
<p>Are others struggling with this as well? How to conveniently work with multiple files and a Python REPL?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the brilliant <a href="https://github.com/jorgenschaefer/elpy" rel="nofollow noreferrer"><code>elpy</code></a> package allows this from the latest release (available on MELPA).</p>
<p>You can assign a dedicated REPL to each script as you like. It helps to rename the REPL sessions using <kbd>M-x</kbd> <kbd>rename-buffer</kbd>.</p>
<p>Here is a snippet from <a href="http://elpy.readthedocs.io/en/latest/ide.html#command-elpy-shell-toggle-dedicated-shell" rel="nofollow noreferrer">the relevant documentation</a>:</p>
<blockquote>
<h1><kbd>M-x</kbd> <kbd>elpy-shell-toggle-dedicated-shell</kbd></h1>
<p>By default, python buffers are all attached to a same python shell (that lies in the <em>Python</em> buffer), meaning that all buffers and code
  fragments will be send to this shell.
  elpy-shell-toggle-dedicated-shell attaches a dedicated python shell
  (not shared with the other python buffers) to the current python
  buffer. To make this the default behavior (like the deprecated option
  elpy-dedicated-shells did), use the following snippet:</p>
<pre><code>(add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
</code></pre>
<h1><kbd>M-x</kbd> <kbd>elpy-shell-set-local-shell</kbd></h1>
<p>Attach the current python buffer to a specific python shell (whose name is asked with completion). You can use this function to have one
  python shell per project, with:</p>
<pre><code>(add-hook 'elpy-mode-hook (lambda () (elpy-shell-set-local-shell elpy-project-root)))
</code></pre>
</blockquote>
<p>Here is <a href="https://github.com/jorgenschaefer/elpy/pull/1232" rel="nofollow noreferrer">the relevant GitHub issue</a>, which was merged into the master branch on 16th Feb 2018.</p>
</div>
<span class="comment-copy">Are you using <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">importlib.reload(module)</a> to reimport modules from REPL?</span>
<span class="comment-copy">I had that in mind yes. Two issues with it. 1) It is a very inconvenient method to run, hard to bind to something like control-enter that would work in any case and 2) Imagine using a particular module script where you might have written some new/test code on the bottom. When you save the file (which is required for the reload), you might have some unexpected effect as well</span>
<span class="comment-copy">when I open more than one file in python, I usually open a dedicated shell for each of them. In principle if no python shell is running, with C-c C-c in a python file should launch a python shell, asking you if you want to open a dedicated process for the file.</span>
