<div class="post-text" itemprop="text">
<p>I'm looking for a function in Perl 5 that works similarly to Python's <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> built-in. It would return a list of references to arrays, where each array is <code>[$index, $element]</code>:</p>
<pre><code>@a = ("a", "b", "c");
@b = enumerate @a;
# @b = ([0, "a"], [1, "b"], [2, "c"])
</code></pre>
<p><a href="https://metacpan.org/pod/List::Util" rel="nofollow noreferrer">List::Util</a> and <a href="https://metacpan.org/pod/List::MoreUtils" rel="nofollow noreferrer">List::MoreUtils</a> don't seem to have this function. Is there another module that does?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>map</code>, like this</p>
<pre><code>my @data = qw / a b c /;
my @enumeration = map [ $_, $data[$_] ], 0 .. $#data;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perl doesn't have a built-in function to do that but it's easy to roll your own.</p>
<p>Using <code>map</code>:</p>
<pre><code>my @a = qw(a b c);
my $i = 0;
my @b = map [$i++, $_], @a; # ([0, 'a'], [1, 'b'], [2, 'c'])
</code></pre>
<p>As of v5.20, Perl's new slice syntax does something similar:</p>
<pre><code>my @a = qw(a b c);
my @b = %a[0..$#a]; # (0, 'a', 1, 'b', 2, 'c')
</code></pre>
<p>That slice syntax returns a list of index/value pairs but it's a flat list. The pairs aren't grouped into nested arrays. If that's important to your application you can use the pairmap function from List::Util to do it:</p>
<pre><code>use List::Util qw(pairmap);
my @a = qw(a b c);
my @b = pairmap {[$a, $b]} %a[0..$#a]; # ([0, 'a'], [1, 'b'], [2, 'c'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate</code> returns an iterator, not a list, so you should really be asking for an iterator.</p>
<hr/>
<p>In Perl 5.12.0 and up, you can use <a href="http://perldoc.perl.org/functions/each.html" rel="noreferrer"><code>each</code></a> to iterate over arrays:</p>
<pre><code>use strict;
use warnings 'all';
use 5.012;

my @a = qw(foo bar baz);

while (my ($i, $v) = each @a) {
    say "$i -&gt; $v";
}

__END__
0 -&gt; foo
1 -&gt; bar
2 -&gt; baz
</code></pre>
<p>However, you should be very careful when using <code>each</code>; <a href="http://blogs.perl.org/users/rurban/2014/04/do-not-use-each.html" rel="noreferrer">some people even discourage its use altogether</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://search.cpan.org/~spurin/List-Enumerate-0.005/lib/List/Enumerate.pm" rel="nofollow">List::Enumerate</a> module.</p>
<pre><code>use List::Enumerate qw(enumerate);
@a = ("a", "b", "c");
@b = map { [ $_-&gt;index, $_-&gt;item ] } enumerate(@a);
</code></pre>
</div>
<span class="comment-copy">I didn't know <code>map</code> could accept a block without curly braces like that.</span>
<span class="comment-copy">@Flimm: It will take either a <i>block</i> or an <i>expression</i>. Take a look at <a href="http://perldoc.perl.org/functions/map.html" rel="nofollow noreferrer">the documentation</a>.The block is strictly necessary only when you need to write multiple statements (such as the common <code>map { chomp; $_ } &lt;$fh&gt;</code>) or to disambiguate the call. In practice it can be a help to making your code readable. Here, I omitted the braces because the expression already has square brackets to delimit it.</span>
<span class="comment-copy">I always delight in the philosophy of <i>TMTOWTDI</i>, but surely the use of <code>List::Util::pairmap</code> on top of an index/value array slice is just a curiosity? At present I believe that index/value and key/value slices should have been designed to return an array of pairs, as it is much simpler to flatten a list than to pair it up.</span>
<span class="comment-copy">@Borodin: I don't understand your question. I've updated the answer to more clearly illustrate the purpose of using <code>pairmap</code>.</span>
<span class="comment-copy">I'm sorry if I wasn't clear. I'm just saying that a solution that uses a very new feature of Perl together with a core library function, and still ends up being longer than your simple <code>map</code> statement, must be theoretical musing and not a practical suggestion.</span>
<span class="comment-copy"><code>each</code> not being reentrant is a pretty big flaw with it, but it's good to know this option.</span>
<span class="comment-copy">Yes, this is a great feature.  I use it with <code>foreach</code>. We often need both index and value.  But it doesn't seem to be known.</span>
<span class="comment-copy">@zdim I just found out about it last week!</span>
<span class="comment-copy">There doesn't seem to be much of a reason to use <a href="https://metacpan.org/module/List::Enumerate" rel="nofollow noreferrer"><code>List::Enumerate</code></a> here</span>
<span class="comment-copy">I agree with Borodin. It's just a lot of overhead.</span>
<span class="comment-copy"><a href="https://metacpan.org/module/List::Enumerate" rel="nofollow noreferrer"><code>List::Enumerate</code></a> has become less useful since version 12 of Perl 5, which allows the use of <code>each</code> on arrays. The example in the module's documentation can be written with just <code>print "$i $name\n" while ($i, $name) = each @list;</code></span>
