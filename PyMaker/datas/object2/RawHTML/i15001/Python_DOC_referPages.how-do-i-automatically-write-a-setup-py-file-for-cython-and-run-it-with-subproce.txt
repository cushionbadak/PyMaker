<div class="post-text" itemprop="text">
<p>The idea is that I don't have to write a setup.py file myself everytime I want to compile a cython module or package, but rather have a function create it. The function should also run the created setup.py by itself.</p>
<p>So the question also is "how do you write code that writes code?".</p>
</div>
<div class="post-text" itemprop="text">
<p>I found a working solution.
create a compile_cython.py file with the following code:</p>
<pre><code>import os
from subprocess import Popen
temp_dir = os.environ['TEMP']


def package(directory, packages, logfile=False, byproducts=None, annotate=False, language='C'):
    """Compile cython .pyx files to a .pyd file inplace
    :param directory: the directory where the main package lies.
    :param packages: List of packages to compile. A package is described in a
        :type tuple that consists of package name, relative path from main package, list of include files,
        list of include directories and the language (default is C).
    :param logfile: Path or :type bool. If true, a log will be created in :param directory:.
    :param byproducts: The directory in which the by-products will be stored.
        If None, by-products will be saved in "%TEMP%\cython_byproducts".
    :param annotate: The Cython annotate option.
    :param language: Default language

    Example:
    package('C:\\projects', [('graphics', 'game\\graphics', ['OpenGL32'], [r'C:\Program Files\Microsoft SDKs\Windows\v7.1\Lib\x64']])
    """
    if not byproducts: byproducts = os.path.join(temp_dir, "cython_byproducts")
    if logfile is True: logfile = os.path.join(directory, "log.txt")
    elif not logfile: logfile = os.path.join(byproducts, "log.txt")
    if isinstance(packages, str):
        dir, package = os.path.split(packages)
        packages = [(package, package)]


    setup_file = os.path.join(byproducts, "setup.py")
    #Write a setup file
    with open(setup_file, 'w') as file:
        file.write("""
from distutils.core import setup, Extension
from Cython.Build import cythonize
import numpy as np
import sys
print(sys.argv) #print for logging

packages = {packages}

extensions = []
for package in packages:
    default = ['name', 'path', [], [], '{default_language}']
    default[:len(package)]=package
    extensions.append(Extension("%s.*" %default[0], ["%s\\\\*.pyx" %default[1]], libraries=default[2],
    library_dirs=default[3], language=default[4].lower()))

setup(include_dirs = np.get_include(),ext_modules = cythonize(extensions, annotate={annotate})) # accepts a glob pattern
""".format(packages=packages, annotate=annotate, default_language=language)
                        )
    p = Popen(r'python "{setup}" build_ext --inplace --build-temp "{byproducts}"'.format(setup=setup_file,
                                                                                         byproducts=byproducts,)                                                                                         ,
                                                                                        cwd=directory)
    with open(logfile, 'w') as log:
        stdout, stderr = p.communicate()
        log.write(stdout or 'NO OUTPUT\n')
        log.write(stderr or 'NO ERRORS\n')

def module(directory, modules, logfile=False, byproducts=None, annotate=False, language='C'):
    """Compile cython .pyx files to a .pyd file inplace
    :param directory: the directory where the module lies
    :param modules: The Path relative from :param directory or a List of modules to compile. A module is described in a
        :type tuple that consists of module name, relative path from :param directory, list of include files,
        list of include directories and the language (default is C).
    :param logfile: Path or :type bool. If true, a log will be created in :param directory:.
    :param byproducts: The directory in which the by-products will be stored.
        If None, by-products will be saved in "%TEMP%\cython_byproducts".
    :param annotate: The Cython annotate option.
    :param language: Default language

    Example:
    module('C:\\projects', [('effects', 'game\\graphics\\effects.pyx'])
    """
    if not byproducts: byproducts = os.path.join(temp_dir, "cython_byproducts")
    if logfile is True: logfile = os.path.join(directory, "log.txt")
    elif not logfile: logfile = os.path.join(byproducts, "log.txt")
    if isinstance(modules, str):
        dir, name_ext = os.path.split(modules)
        name, ext = os.path.splitext(name_ext)
        modules = [(name, name_ext)]

    setup_file = os.path.join(byproducts, "setup.py")
    #Write a setup file
    with open(setup_file, 'w') as file:
        file.write("""
from distutils.core import setup, Extension
from Cython.Build import cythonize
import numpy as np
import sys
print(sys.argv) #print for logging

modules = {modules}

extensions = []
for module in modules:
    default = ['name', 'path', [], [], '{default_language}']
    default[:len(module)]=module
    extensions.append(Extension("%s" %default[0], ["%s" %default[1]], libraries=default[2],
    library_dirs=default[3], language=default[4].lower()))

setup(include_dirs = np.get_include(),ext_modules = cythonize(extensions, annotate={annotate})) # accepts a glob pattern
""".format(modules=modules, annotate=annotate, default_language=language)
                        )
    p = Popen(r'python "{setup}" build_ext --inplace --build-temp "{byproducts}"'.format(setup=setup_file,
                                                                                         byproducts=byproducts,)                                                                                         ,
                                                                                         cwd=directory)
    with open(logfile, 'w') as log:
        stdout, stderr = p.communicate()
        log.write(stdout or 'NO OUTPUT\n')
        log.write(stderr or 'NO ERRORS\n')
</code></pre>
<p>It still needs some modifications to also compile pure C or C++ files, but it's working for Cython files.</p>
<p>In this setup, Numpy is automatically included. But I guess that's no problem as it doesn't actully include anything unless you use numpy functions, or does it?</p>
</div>
<span class="comment-copy">The usual way to let "code write code" is to define a template string, then <a href="https://docs.python.org/3/library/functions.html#format" rel="nofollow noreferrer">format</a> it and write it to a file.</span>
