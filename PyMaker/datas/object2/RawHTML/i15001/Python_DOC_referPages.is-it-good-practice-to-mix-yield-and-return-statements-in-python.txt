<div class="post-text" itemprop="text">
<p>I'd quite like to have the following behaviour:</p>
<pre><code>def foo(bar=None):
    if bar:
        return other_function(other_thing[bar])
    else:
        for i in other_thing:
            yield other_function(i)
</code></pre>
<p>The idea being that the function can then be used as a generator to build all instances, or it can be used to return a specific instance. Is this a good way to do this in Python? If not, is there a better way.</p>
</div>
<div class="post-text" itemprop="text">
<p>Only in Python 3 it is syntactically possible to have <code>return value</code> and <code>yield</code> in the same function, in Python 2 it will result in:</p>
<pre><code>SyntaxError: 'return' with argument inside generator
</code></pre>
<p>In Python 3 <code>return value</code> inside a generator is actually a syntactic sugar for <code>raise StopIteration(value)</code>, which is also supported by the <code>yield from</code> clause:</p>
<pre><code>def f():
    yield from iter('123')
    return 'ok'

def g():
    message = yield from f()
    print('Message:', message)

In [1]: list(g)
Message: ok
Out[1]: ['1', '2', '3']
</code></pre>
<p>So, this construct does not do what you expect it to. Besides, it does not seem a very good ("pythonic") idea to vary the return type (or, rather, interface) of a function based on the argument value. That may be a matter of taste, though, here is what Guido van Rossum says in his interview in the book <a href="http://shop.oreilly.com/product/9780596515171.do" rel="noreferrer">Masterminds of Programming</a>:</p>
<blockquote>
<p>I have a few personal pet peeves: first of all, and this is specific to dynamic languages, don’t make the return type of a method depend on the value of one of the arguments; otherwise it may be hard to understand what’s returned if you don’t know the relationship—maybe the type-determining argument is passed in from a variable whose content you can’t easily guess while reading the code.</p>
</blockquote>
</div>
<span class="comment-copy">I think this works only in Python 3</span>
<span class="comment-copy">... and even in Python 3 it does not mean what you seem to expect.</span>
<span class="comment-copy">You can make it return either a value or an iterable (e.g. the result of a call to another generator function), but that seems like it would be a terrible idea due to the inconsistency.</span>
<span class="comment-copy">Could you elucidate your last sentence please? It's a great answer, but why not?</span>
<span class="comment-copy">@DavidBoshton I've updated the answer. Basically, that brings less surprises and makes the code easier to comprehend in the future. There are no rules without exceptions, of course, if you know what you're doing.</span>
<span class="comment-copy">This is also <a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer">explictely documented</a>: <i>Using a yield expression in a function’s body causes that function to be a generator</i>. It doesn't matter beyond this point. You use <code>yield</code>, it is a generator function, end of. Reachability doesn't come into play here.</span>
