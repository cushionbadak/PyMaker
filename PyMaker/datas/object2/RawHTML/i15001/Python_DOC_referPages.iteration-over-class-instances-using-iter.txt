<div class="post-text" itemprop="text">
<p>I want to store all the instances of a class in a list and want to iterate over it.</p>
<p>I have tried the following two approaches :</p>
<h1>1 Using MetaClasses</h1>
<pre><code>class ClassIter(type):
    def __iter__(cls):
        return iter(cls._ClassRegistry)
    def __len__(cls):
        return len(cls._ClassRegistry)         

class MyClass(object):
    __metaclass__ = ClassIter
    _ClassRegistry = []
    def __init__(self,objname):
        self._ClassRegistry.append(self)
        self.name = objname

for x in ["first", "second", "third"]:
    MyClass(x)

for y in MyClass:
    print y.name
</code></pre>
<h1>2 : Using <strong>iter</strong> in Class itself</h1>
<pre><code>class MyClass1(object):
    _ClassRegistry = []
    def __init__(self,objname):
        self._ClassRegistry.append(self)
        self.name = objname
    def __iter__(self):
        return iter(self._ClassRegistry)

for x in ["first", "second", "third"]:
    MyClass1(x)

for y in MyClass1:
    print y.name
</code></pre>
<p>Out of both the solutions, former approach works perfectly while the later solution gives an error <code>TypeError: 'type' object is not iterable</code>. </p>
<p>Can some one please explain me (in detail) why the second approach is not working and why there is a need to use metaclass to make another class iterable?</p>
</div>
<div class="post-text" itemprop="text">
<p>Special methods like <code>__iter__</code> are not looked up directly on the object, only on the <em>type</em> of the object. Python calls <code>type(object).__iter__(object)</code>, not <code>object.__iter__()</code>, effectively bypassing the normal object-first-then-type lookups (so from instance to class and from class to metaclass).</p>
<p>This is done to make hashing of types possible; if <code>hash(object)</code> used the <code>__hash__</code> method found directly on the object, you could never define a custom class with a <code>__hash__</code> method for the instances.</p>
<p>The meta class is the type of the class; just like the class is the type of an instance, so <code>iter(class)</code> looks for <code>type(class).__iter__()</code> rather than at <code>class.__iter__</code> directly.</p>
<p>If it <em>did</em> work that way, you could never define a <code>__iter__</code> method for your class <em>instances</em>, because <code>class.__iter__</code> would be a method and require the instance to be bound to, while there is no such instance if you are iterating over the class.</p>
<p>See the <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow"><em>Special method lookup</em> section</a> of the Python datamodel documentation:</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Special method names are always invoked like this:</p>
<pre><code>iter(foo) &lt;--&gt; type(foo).__iter__(foo)
</code></pre>
<p>Your first solution is compatible with this call (<code>type(MyClass)</code> is the metaclass).  Your second is not (<code>type(MyClass1) is type</code>, which has no <code>__iter__()</code> method).</p>
</div>
<span class="comment-copy">Directly related, same principles apply here: <a href="http://stackoverflow.com/q/10376604">Overriding special methods on an instance</a></span>
<span class="comment-copy">I don't understand why people keep on downvoting the Questions without mentioning any reason. I believe, I have asked a valid question here ...</span>
<span class="comment-copy">I agree that the downvotes on your post appear harsh. You did show your attempt, and your expected outcome. The subject is a little esoteric.</span>
<span class="comment-copy">Well, I personally downvoted because I can't even begin to understand why you think the second version would work. You're defining an instance method (you didn't even attempt to use a class method), of course that only works on the <i>instance</i> and not on the class itself. This should be basic python knowledge for anybody working with classes; that you don't seem to know this means you did way too little research.</span>
<span class="comment-copy">@l4mpi: there is always more research that could be done, and more experience gained. But that doesn't mean this question doesn't show effort to understand the issue. I don't think the bar needs to be <i>that</i> high.</span>
<span class="comment-copy">I suspect you must have meant something like "Python calls <code>type(object).__iter__()</code>, not <code>object.__iter__()</code>, effectively bypassing the normal instance-first-then-class lookups" — because what you have doesn't quite make sense regarding how methods are looked up on an object.</span>
<span class="comment-copy">@martineau: Perhaps, but I suspect it is the second half of the sentence that is the confusing part here.</span>
<span class="comment-copy">Don't think so. Seems like "only on the <i>type</i> of the object" should translate to <code>type(object)</code> not <code>type(MyClass)</code>.</span>
<span class="comment-copy">@martineau: ah, you are right; in the context of the rest of the paragraph that makes more sense.</span>
