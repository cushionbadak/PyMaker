<div class="post-text" itemprop="text">
<p>I am coding a small utility, on my Mac OsX Yosemite, that globs my file system using glob2 and testing my code with py.test.</p>
<p>My system locale is en_gb, because this is what I usually speak, however, I also have quite a few files and folders with French and Japanese names.</p>
<p>Now whenever I get a "French" string through glob2, like "/tmp/test/réc", the encoding of the e acute is \xcc\x81c. </p>
<p>However I declared the encoding of my python file as utf-8 which gives me e acute as \xc3\xa9c. So obviously then my tests go funny because they do not match the e acutes.</p>
<p>How do I find the encoding my system has used to encode my e acutes? Is there any alternative but using a <a href="https://pypi.python.org/pypi/chardet" rel="nofollow">chardet</a>-like library?</p>
<p>Thanks</p>
<p><strong>Addendum</strong>
the test that fails is: scope_test.py</p>
<pre><code># -*- coding: utf-8 -*-

import pytest as p
import os
import itertools
import shutil
from os import environ
environ['HOME']= '/tmp/test'

import scope as s  #This is the library I am testing

@p.fixture(scope='module')
def scopes(request):
    """creates temporary directories, temporary test files and 
    returns a list of created scopes"""
    dirs = dict(home=['~'], 
                  simple=['~/simple1',
                         '~/simple2',
                         '~/simple3'], 
                  recursive=['~/réc',
                        '~/réc/sub11',
                        '~/réc/sub12',
                        '~/réc/sub11/sub111',
                        '~/réc/sub11/sub112',
                        '~/réc/sub12/sub 121',
                        '~/réc/sub12/sub 122'])
    # Create the test directories
    os.mkdir(os.path.expanduser('~'))
    for pthlist in dirs.values():
        for dirpth in pthlist:
            if dirpth != '~':
                os.mkdir(os.path.expanduser(dirpth))
    # Make a few files in each directory too
    for pthlist in dirs.values():
        for dirpth in pthlist:
            hidden = ('','.')
            base = ('test','zest','hello')
            num = ('1','2','3','4','5')
            ext = ('.txt','.jpg','.pdf','.todo','.otl')
            fnames=itertools.product(hidden,base,num,ext)
            touch = lambda fullpth: open(fullpth,'w').close()
            for f in fnames:
                touch(os.path.join(os.path.expanduser(dirpth),''.join(f)))
    def delete_directories():
        shutil.rmtree('/tmp/test')
    request.addfinalizer(delete_directories)
    return [ s.Scope('home', 
                     'no scope filtera applied'),
            s.Scope('simple',
                    'simple scope',
                    ['~/simple1',
                     '~/simple2',
                     '~/simple3']),
           s.Scope('recursive', 
                   'recursive scope',
                  ['~/r*c/**', '~/réc/sub11/sub111'],
                  ['~/r*c/**/*1'])]


class Test_Scope:
    def test_recursive_paths(self, scopes):
        assert sorted(scopes[2].get_dir()) == \
                sorted([os.path.expanduser(item) for item in 
                      ['~/réc/sub12',
                            '~/réc/sub11/sub111',
                            '~/réc/sub11/sub112',
                            '~/réc/sub12/sub 122']])
</code></pre>
<p>The definition of the Scope instance is: scope.py</p>
<pre><code>class Scope(object):
    """a scope object produces a list of directories.
    These directories are used to narrow the scope of searching, creating, chdir
    or any other administrative task

    incl_paths and excl_paths take strings representing absolute paths or globs
    of absolute paths. If the user enters a relative path, then an error occurs.
    User can:
        - use conventions from glob2 library for globbing. To unequivocally
        identify a glob, the glob string must have magic characters "*[]?"
        eg: "~/D?[wo]*" 
        will find Downloads, Dropbox but not Documents in user home directory
        - use "~" shortcut
        - use bash variables if they were defined as environment variables in
        the .bashrc or .bash_profile files

    """

    def __init__(self, name,comment='', 
                 incl_paths=[],
                 excl_paths=[]):
        self.name = name
        self.comment = comment
        self.incl_paths = incl_paths
        self.excl_paths = excl_paths
        self.dirty = False


    #...Missing details that do not harm the comprehension of this question...#


    def get_dir(self):
        g = DirGlobber()
        inpaths = [os.path.expanduser(os.path.expandvars(item)) for item in \
                   self.incl_paths if not has_magic(item)]
        inglob = [os.path.expanduser(os.path.expandvars(item)) for item in \
                  self.incl_paths if has_magic(item)]
        outpaths = [os.path.expanduser(os.path.expandvars(item)) for item in \
                    self.excl_paths if not has_magic(item)]
        outglob = [os.path.expanduser(os.path.expandvars(item)) for item in \
                   self.excl_paths if has_magic(item)]
        res = []
        for item in inglob:
            res.extend(g.glob(item))
        if res:
            inset = set(res)
        else:
            inset = set()
        res = []
        for item in outglob:
            res.extend(g.glob(item))
        if res:
            outset = set(res)
        else:
            outset = set()
        #precedence of outglob over inglob
        inset = inset - outset
        #add specific paths and remove specific paths
        inset = inset | set(inpaths)
        inset = inset - set(outpaths)
        return list(inset)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>They are both UTF-8, just two ways of representing the character.</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.name(b'\xcc\x81'.decode('utf8'))
'COMBINING ACUTE ACCENT'
&gt;&gt;&gt; unicodedata.name(b'\xc3\xa9'.decode('utf8'))
'LATIN SMALL LETTER E WITH ACUTE'

&gt;&gt;&gt; print(b'\xc3\xa9'.decode('utf8'))
é
&gt;&gt;&gt; print(b'\xcc\x81'.decode('utf8'))
 ́
&gt;&gt;&gt; print(b'e\xcc\x81'.decode('utf8'))
é
</code></pre>
<p>So when OSX writes the file/directory, it's writing "e" + "combining acute accent", while you're expecting it to be a literal "é".</p>
<p>To fix this you need to compare the normalized unicode strings instead of the byte strings (or even the decoded unicode strings). The <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize" rel="nofollow"><code>unicodedata.normalize</code></a> function in python's standard library can do this:</p>
<pre><code>&gt;&gt;&gt; s1 = unicodedata.normalize('NFC', b're\xcc\x81c'.decode('utf8'))
&gt;&gt;&gt; s2 = unicodedata.normalize('NFC', b'r\xc3\xa9c'.decode('utf8'))
&gt;&gt;&gt; print(s1, s2)
réc réc
&gt;&gt;&gt; s1 == s2
True
</code></pre>
</div>
<span class="comment-copy">Can you show some code? Also are you using python 2 or 3?</span>
<span class="comment-copy">@PaulRooney, lost-theory answered the question while I posted the code. It is python 2.7.</span>
<span class="comment-copy">Thanks lost-theory, this worked for me.</span>
