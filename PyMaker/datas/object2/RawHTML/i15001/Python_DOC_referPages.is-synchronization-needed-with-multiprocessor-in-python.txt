<div class="post-text" itemprop="text">
<p>when using a code like this </p>
<pre><code>def execute_run(list_out): 
   ... do something 

pool = ThreadPoolExecutor(6)
for i in list1:
    for j in list2:
            pool.submit(myfunc, list_out)
pool.join()
</code></pre>
<p>assuming the threads modify list_out, do they do that in a synchronous manner?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your goal is calculate something in multiprocessing way, it's better do not share state.
I propose you to use simple <code>map</code> from <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow">multiprocessing</a> if it's possible:</p>
<pre><code>from multiprocessing import Pool

input_list = []
for i in list1:
    for j in list2:
        input_list.append((i, j))

p = Pool()
result_list = p.map(do_something, input_list)
</code></pre>
<p><code>map</code> works like for-loop:</p>
<pre><code>def naive_map(input_list, do_something):
   result = []
   for i in input_list:
     result.append(do_something(i))
   return result
</code></pre>
<p>So, if you want to use function that is accepting several arguments, you can use lambda function for unpacking tuple.</p>
<pre><code>  &gt;&gt; def your_function(v1, v2):
  &gt;&gt;        return v1+v2
  &gt;&gt; f = lambda (x,y): your_function(x, y)
  &gt;&gt; map(f, [(1,2),(3,4),(5,6)])
       [3, 7, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>multiprocessing</code> thread pools are just threads and don't have any magic to generally synchronize shared objects. You need to protect shared objects with a lock.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is that each process receives a copy of the list, and so won't see changes made by the other processes.</p>
<p>To achieve what you want you will have to use a <a href="https://docs.python.org/3/library/multiprocessing.html#managers" rel="nofollow"><code>Manager</code></a> to create a list proxy. Note that the manager proxy classes do not know when a member is mutated. For example, if an element of a list proxy is mutated somehow, the list proxy has no way of knowing this. You must reassign the member to flush the changes. An example from the documentation:</p>
<pre><code># create a list proxy and append a mutable object (a dictionary)
lproxy = manager.list()
lproxy.append({})
# now mutate the dictionary
d = lproxy[0]
d['a'] = 1
d['b'] = 2
# at this point, the changes to d are not yet synced, but by
# reassigning the dictionary, the proxy is notified of the change
lproxy[0] = d
</code></pre>
</div>
<span class="comment-copy">Is that the <code>ThreadPoolExecutor</code> from the <code>concurrent.futures</code> library?  If so, I don't think it has a <code>join</code> method.  Did you mean <code>shutdown</code>?</span>
<span class="comment-copy">What's going on in <code>execute_run</code>? Does result depend on previous execution?</span>
<span class="comment-copy">I basically need a place where each thread can put the results, possibly a list, in a way that there are no race conditions.</span>
<span class="comment-copy">this way they would modify input_list in a synchronized manner right?</span>
<span class="comment-copy">@Bobo, this way they would <b>not</b> modify input_list at all. They would read it only. So, if you can prepare your data to processing in such way, you should do it.</span>
<span class="comment-copy">I need them to be able to write the results somewhere when they are done. How would I go about it?</span>
<span class="comment-copy">@Bobo, I had added some extra explanation. You should return some value in <code>do_something</code> function. And for each element in <code>input_list</code> you will receive return value in <code>result_list</code>.</span>
<span class="comment-copy">@Bobo, and yes. <code>result_list</code> will be consistent without race conditions.</span>
<span class="comment-copy">Or better yet, refactor your code so that you do not share any objects (except in a read-only fashion) and instead collate output objects in the main thread, after the other threads have run.</span>
<span class="comment-copy">The OP is using a <code>ThreadPoolExecutor</code>, not a <code>ProcessPoolExecutor</code>.  So each thread is modifying the same list.</span>
<span class="comment-copy">do you have a pointer to an example? I need to do something like the code I posted above, where each thread modifies the same list provided as argument. thank you</span>
<span class="comment-copy">I think you could rephrase this to be a little more clear. I think that the way it's currently phrased, it gives the impression that changes such as appending to or popping from a managed list will not be propagated. It would be good to specify that the lack of propagation only applies to mutable items.</span>
<span class="comment-copy">I missed that you were using a <code>ThreadPoolExecutor</code>. You will not gain any performance benefit as python cannot run separate threads on separate cores at the same time. This is because the interpreter itself is not thread-safe. However, threads share the same memory and do not need a manager -- you will still need a mutex/lock to protect access to shared variables. The documentation contains plenty of examples of how to use a manager,</span>
