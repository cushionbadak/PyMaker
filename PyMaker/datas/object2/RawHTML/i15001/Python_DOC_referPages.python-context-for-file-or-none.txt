<div class="post-text" itemprop="text">
<p>Python is going to call a subprocess, the user either requested that subprocesses stdout is to go to a file (or back-holed to os.devnull), or the subprocesses output is to be passed though "in real time".</p>
<p>My current best guess as how to do this would seemingly work:</p>
<ul>
<li>Let <code>file_path</code> be valid input for <code>open()</code></li>
<li>Let <code>logging</code> be a Boolean indicator, true indicating use <code>file_path</code> for logging or false to passthough to stdout.</li>
</ul>
<hr/>
<pre><code>with open(file_path, 'wb') if logging else None as shell_stdout:
    subprocess.call(['ls'], stdout=shell_stdout)
</code></pre>
<p>In tinkering/testing this appears to be the right value, which I have assumed work well with subprocess.call. However, and unsurprisingly I get the following exception:</p>
<pre><code>AttributeError: __exit__
</code></pre>
<p>So <code>None</code> is not a context, it has no <code>__exit__</code>; </p>
<hr/>
<h3>Goals</h3>
<ul>
<li>Not open a file at all if the user does not want logging.</li>
<li>Use contexts (as provided by the stdlib), (Preference; I can't imagine doing the file open/close operations manually being any cleaner.)</li>
<li>Not need a try/catch (Preference to avoid further nesting)</li>
<li>Only have a single call to <code>subprocesses.call</code> (Non duplicated line)</li>
</ul>
<p>So, how could this behavior be achieved? Or what would you suggest doing instead/alternatively?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a "no-op" <a href="https://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer">context manager</a>:</p>
<pre><code>import subprocess
import contextlib
@contextlib.contextmanager
def noop():
    yield None

logging = False
file_path = '/tmp/out'

with open(file_path, 'wb') if logging else noop() as shell_stdout:
    subprocess.call(['ls'], stdout=shell_stdout)
</code></pre>
<p>When logging is <code>True</code>, the conditional expression returns a file object. When <code>logging</code> is False, it returns a <code>noop()</code> context manager (so it can be used in the <code>with-statement</code>), which sets <code>shell_out</code> to <code>None</code> but doesn't do anything special upon exit. </p>
<hr/>
<p><a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">Per the docs</a>, when <code>stdout=None</code>, </p>
<blockquote>
<p>... no redirection will occur; the childâ€™s file handles will be inherited from the parent.</p>
</blockquote>
<p>Usually the parent's stdout would equal <code>sys.stdout</code>. However, it is possible to redirect <code>sys.stdout</code> somewhere else, either explicitly (e.g. <code>sys.stdout = open('/tmp/stdout', 'wb')</code>) or indirectly, such as by using module that redirects <code>sys.stdout</code>. The <code>fileinput</code> module from the standard library redirects <code>sys.stdout</code>, for example. In such cases <code>noop()</code> might be useful for directing stdout to the parent's stdout, which may be different than <code>sys.stdout</code>. </p>
<p>If this corner case does not affect you, then <a href="https://stackoverflow.com/a/28680680/190597">Padraic Cunningham's solution</a> is simpler:</p>
<pre><code>with open(file_path, 'wb') if logging else sys.stdout as shell_stdout:
    subprocess.call(['ls'], stdout=shell_stdout)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Either set <code>shell_stdout</code> to <code>stdout</code> or a <code>file object</code> based on logging being True or False, there is no need to overcomplicate it, you only have one condition or the other <code>if logging</code> will either be True or False, there is nothing wrong with opening a file not using <code>with</code>, there are times when using <code>with</code> does not fit.</p>
<pre><code>import sys

if logging:
      shell_stdout = open(file_path, 'wb') # to file or devnull if logging
else:
    shell_stdout = sys.stdout
subprocess.call(['ls'], stdout=shell_stdout) # real time if not logging
shell_stdout.close()
</code></pre>
<p>To do what you wanted in your question you can do the following, you don't need anything bar <code>sys.stdout</code>:</p>
<pre><code>with open(file_path, 'wb') if logging else sys.stdout as shell_stdout:
    subprocess.call(['ls'], stdout=shell_stdout)
</code></pre>
<p>The file will only be created if logging is True.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.3, tou can define a no-op context manager using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>contextlib.ExitStack</code></a>:</p>
<pre><code>from contextlib import ExitStack

with open(...) if ... else ExitStack():
    ...
</code></pre>
</div>
<span class="comment-copy">I'd suggest dropping the 4th goal and just using two different <code>subprocess.call</code>, given the additional constraint you left as a comment on an answer.</span>
<span class="comment-copy">Note that this will redirect the stdout to the subprocesss PIPE, which you might or might not want.</span>
<span class="comment-copy">@NickBailey I think I can equally substitute <code>None</code> for <code>sys.stdout</code>, which I think tells Sub processes to do more or less the same thing anyway</span>
<span class="comment-copy">@ThorSummonerm yes that is the point, you can direct it wherever you want. But avoid None as you cannot close None</span>
