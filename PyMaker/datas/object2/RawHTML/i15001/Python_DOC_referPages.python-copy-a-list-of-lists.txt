<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2612802/how-to-clone-or-copy-a-list">How to clone or copy a list?</a>
<span class="question-originals-answer-count">
                    20 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/2541865/copying-nested-lists-in-python">Copying nested lists in Python</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I'm using python 3.4.1.<br/>
For a single list <code>a=[1,2]</code>, if I make a copy of it, <code>b = a.copy()</code> when I change items in <code>b</code>, it won't change items in <code>a</code>.<br/>
However, when I define a list of lists (actually a matrix) <code>a = [[1,2],[3,4]]</code>, when I assign <code>b = a.copy()</code>. What I do to list <code>b</code> actually affects <code>a</code>.<br/>
I checked their addresses, they are different.<br/>
Can anyone tell me why?</p>
<p>ps: What I did is <code>b[0][0] = x</code>, and the item in a was also changed.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the docs for the <a href="https://docs.python.org/3/library/copy.html" rel="noreferrer"><code>copy</code></a> module:</p>
<blockquote>
<p>The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):</p>
<ul>
<li>A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.</li>
<li>A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.</li>
</ul>
</blockquote>
<p>When you call regular <code>copy.copy()</code> you are performing a <em>shallow</em> copy. This means that in a case of a list-of-lists, you will get a new copy of the outer list, but it will contain the original inner lists as its elements. Instead you should use <code>copy.deepcopy()</code>, which will create a new copy of both the outer and inner lists.</p>
<p>The reason that you didn't notice this with your first example of using <code>copy([1,2])</code> is that the primitives like <code>int</code> are immutable, and thus it is impossible to change their value without creating a new instance. If the contents of the list had instead been mutable objects (like lists, or any user-defined object with mutable members), any mutation of those objects would have been seen in both copies of the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps a list comprehension as such:</p>
<pre><code>new_list = [x[:] for x in old_list]
</code></pre>
<p>...though if your matrices are deeper than one layer, list comprehension is probably less elegant than just using <code>deepcopy</code>.</p>
<p>edit - a shallow copy, as stated, will still contain references to the objects inside the list. So for example...</p>
<pre><code>&gt;&gt;&gt; this = [1, 2]
&gt;&gt;&gt; that = [33, 44]
&gt;&gt;&gt; stuff = [this, that]
&gt;&gt;&gt; other = stuff[:]
&gt;&gt;&gt; other
[[1, 2], [33, 44]]
&gt;&gt;&gt; other[0][0] = False
&gt;&gt;&gt; stuff
[[False, 2], [33, 44]]    #the same problem as before
&gt;&gt;&gt; this
[False, 2]                #original list also changed
&gt;&gt;&gt; other = [x[:] for x in stuff]
&gt;&gt;&gt; other
[[False, 2], [33, 44]]
&gt;&gt;&gt; other[0][0] = True
&gt;&gt;&gt; other
[[True, 2], [33, 44]]
&gt;&gt;&gt; stuff
[[False, 2], [33, 44]]    #copied matrix is different
&gt;&gt;&gt; this
[False, 2]                #original was unchanged by this assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's very simply, just do that:</p>
<pre><code>b = a
</code></pre>
<p>Exemple:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b.append(4)
&gt;&gt;&gt; b
[1, 2, 3, 4]
&gt;&gt;&gt; a
[1, 2, 3, 4]
</code></pre>
</div>
<span class="comment-copy">Thank you! And one more question about copy. Can I get a copy of a class? Like the tree class, can I get a copy of some tree object t1 using a simple way?</span>
<span class="comment-copy">Yes, you can use the <code>copy</code> module on any object that defines the <code>__copy__</code> and <code>__deepcopy__</code> methods. See the linked documentation in the original answer for specifics. There is not, sadly, a 'pre-defined' copy operation in Python like there is in languages like C++ (which is usually a good thing, because C++'s auto-generated copy-constructor is often wrong for any non-trivial class).</span>
<span class="comment-copy">@jack You can check what is going on when you use the copy method  on <a href="http://www.pythontutor.com/visualize.html#code=a+%3D+%5B%5B1,+2%5D,+%5B3,+4%5D%5D%0Ab+%3D+a.copy()%0Ab%5B0%5D%5B0%5D+%3D+9&amp;mode=display&amp;origin=opt-frontend.js&amp;cumulative=false&amp;heapPrimitives=false&amp;textReferences=false&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;curInstr=0" rel="nofollow noreferrer">pythontutor.com</a>. You can see all of the pointers visualized there.</span>
<span class="comment-copy">It's also a lot less clear to a casual reader what it's doing than using methods from <code>copy</code>, though it is slightly more performant.</span>
<span class="comment-copy">Sure, there's that. But list comprehensions are most pythonic, so I guess it depends on what is considered 'clear', and to whom. In any event, if the matrix is too nested then my suggestion wouldn't be very helpful, but for a single dimension I don't think it is too bad</span>
<span class="comment-copy">This just makes <code>a</code> and <code>b</code> point to the same object. It is not a correct solution</span>
