<div class="post-text" itemprop="text">
<p>I have this code I wrote, to go through all of the primes and print them out.</p>
<pre><code>class Primes:

  def __contains__(self, num):
    for divd in range(2, num):
      if num % divd == 0:
        return False
    return True

  def __iter__(self):
    yield 2
    count = 3
    while True:
      if count in self:
        yield count
      count += 2

primes = Primes()
for x in primes:
  print(x)
</code></pre>
<p>It works fine, but it bugs me that I have to create a Primes object in order to iterate over it. It would make more sense if the second to last line was <code>for x in Primes:</code> and the other line was <code>if count in Primes</code>, but adding either the @classmethod or @staticmethod decorator gives me a <code>argument of type 'classobj' is not iterable</code> error. What's the actual way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">looks up special methods on the <em>type</em> of the object</a>. To iterate over a class, you'd have to put the <code>__iter__</code> method on the <em>metaclass</em>.</p>
<p>Just create the instance in the <code>for</code> loop:</p>
<pre><code>for x in Primes():
</code></pre>
<p>as creating a metaclass just to produce prime numbers is just too much indirection. It would look like this:</p>
<pre><code>class PrimesMeta(type):
    def __contains__(self, num):
        # more efficient prime number test
        if num % 2 == 0:  # even
            return False
        for divd in range(3, int(num ** 0.5) + 1, 2):
            if num % divd == 0:
                return False
        return True

    def __iter__(self):
        yield 2
        count = 3
        while True:
            if count in self:
                yield count
            count += 2

class Primes(metaclass=PrimesMeta):
    pass
</code></pre>
<p>For Python 2, you'd create <code>Primes</code> with:</p>
<pre><code>class Primes(object):
    __metaclass__ = PrimesMeta
</code></pre>
<p>instead.</p>
<p>You can improve on the generator further by using a sieve; see <a href="http://code.activestate.com/recipes/117119/" rel="nofollow">http://code.activestate.com/recipes/117119/</a> for an excellent infinite generator implementation.</p>
</div>
<span class="comment-copy">You can just do <code>for x in Primes():</code>. Or is that still a problem?</span>
<span class="comment-copy">Not exactly an answer to your question, but if you're getting <code>argument of type 'classobj' is not iterable</code> then you're not using Python 3.  'classobj' only exists in Python 2 and is the type of old-style classes.</span>
<span class="comment-copy">Why not just have some sort of custom <code>Math</code> class with a <code>@staticmethod</code> <code>def primes():</code> ?</span>
<span class="comment-copy">Thanks for pointing that out Iguana, I deleted that comment.</span>
<span class="comment-copy">@JoshuaSnider: then why use a class <i>at all</i>?</span>
