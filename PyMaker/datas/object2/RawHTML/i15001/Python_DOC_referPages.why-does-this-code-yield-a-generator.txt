<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/231767/what-does-the-yield-keyword-do">What does the “yield” keyword do?</a>
<span class="question-originals-answer-count">
                    43 answers
                </span>
</li>
</ul>
</div>
<p>I wrote the following into the Python interpreter today:</p>
<pre><code>&gt;&gt;&gt; def test():
...     for c in ['a', 'b', 'c', 'd']: yield c
...
&gt;&gt;&gt; a = test()
&gt;&gt;&gt; a
&lt;generator object test at 0x2556a00&gt;
&gt;&gt;&gt; a.next()
'a'
&gt;&gt;&gt; a.next()
'b'
</code></pre>
<p>This was surprising to me. Shouldn't <code>test</code> return (or yield) one of the elements in my list, not a generator which yields them?</p>
<p>A second function which uses "return" behaves as expected:</p>
<pre><code>&gt;&gt;&gt; def test2():
...     for i in ['a', 'b', 'c', 'd']: return i
...
&gt;&gt;&gt; b = test2()
&gt;&gt;&gt; b
'a'
&gt;&gt;&gt; b
'a'
</code></pre>
<p>Why is this so? Where in the documentation describes this behaviour?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because your yield is nested in your for loop, all your values will be added to the generator expression. Generators are basically equivalent to iterators except, iterators retain the values unless deleted whereas generators generate the values once on the fly. The next method of the generator is implicitly called by the way when used in a for loop rather than a generator. </p>
<p>In addition, you must remember that the return keyword returns one and only on value as does yield. The function returns one generator object with yield that is ready to generate all the supplied values. A standard return statement though returns a value and exits the function so that the other values aren't returned.</p>
</div>
<span class="comment-copy"><i>Shouldn't test return (or yield) one of the elements in my list, not a generator which yields them?</i>. No, because then you can never get another <i>independent</i> generator yielding items separately.</span>
<span class="comment-copy">Documentation: <a href="https://docs.python.org/2/reference/expressions.html#yield-expressions" rel="nofollow noreferrer">docs.python.org/2/reference/expressions.html#yield-expressions</a></span>
<span class="comment-copy">You might want to look at this famous question also asking about yield: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" title="what does the yield keyword do in python">stackoverflow.com/questions/231767/…</a></span>
<span class="comment-copy">Because you used <code>yield</code> in your function, it returns a generator by definition.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement" rel="nofollow noreferrer">yield in docs</a> and <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">-100 This is complete nonsense.  An iterator is just an object with a <code>__next__()</code> method.  Iterators do <b>not</b> "retain the values unless deleted", whatever that means.  And a <code>yield</code> statement does not "return a generator object", it turns the function into a generator function.</span>
<span class="comment-copy">I don't know what you mean by the function turning into something else.</span>
<span class="comment-copy">Any function definition containing a <code>yield</code> statement is considered by the interpreter to be a generator function.  It is not the <code>yield</code> statement itself that returns a generator object.</span>
<span class="comment-copy">Yes, exactly, the function returns the generator, the yield is a directive to do so. That's what I meant by yield.</span>
