<div class="post-text" itemprop="text">
<p>I noticed that in python, string object keeps only one copy. Like below code:</p>
<pre><code>&gt;&gt;&gt; s1='abcde'
&gt;&gt;&gt; s2='abcde'
&gt;&gt;&gt; s1 is s2
True
</code></pre>
<p>s1 and s2 point to the same object.</p>
<p>When I edit s1, s2 still keeps the object ('abcde'), but the s1 points to a new copy. This behavior likes copy on write.</p>
<pre><code>&gt;&gt;&gt; s1=s1+'f'
&gt;&gt;&gt; s1 is s2
False
&gt;&gt;&gt; s1
'abcdef'
&gt;&gt;&gt; s2
'abcde'
</code></pre>
<p>So does python really use the copy on write mechanisim on string object?</p>
</div>
<div class="post-text" itemprop="text">
<p>No copying is taking place in any relevant sense.  Your new string is an entirely new string object.  It is no different than if you had done <code>s1 = 'abcdef'</code>.  Some kinds of objects in Python allow you to modify them "in-place", but not strings.  (In Python parlance, strings are immutable.)</p>
<p>Note that the fact that your two original strings are the same object is due to an implementation-specific optimization and will not always be true:</p>
<pre><code>&gt;&gt;&gt; s1 = 'this is a longer string than yours'
&gt;&gt;&gt; s2 = 'this is a longer string than yours'
&gt;&gt;&gt; s1 is s2
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>yes; both <code>s1</code> and <code>s2</code> will point to same object; because they are interned(based on some <code>rules</code>);</p>
<pre><code>In [73]: s1='abcde'

In [74]: s2='abcde'

In [75]: id(s1), id(s2), s1 is s2
Out[75]: (63060096, 63060096, True)
</code></pre>
<p>like one rule is; you are only allowed ascii letters, digits or underscores;</p>
<pre><code>In [77]: s1='abcde!'

In [78]: s2='abcde!'

In [79]: id(s1), id(s2), s1 is s2
Out[79]: (84722496, 84722368, False)
</code></pre>
<p>also; interesting thing is by default all 0 and length 1 strings are interned;</p>
<pre><code>In [80]: s1 = "_"

In [81]: s2 = "_"

In [82]: id(s1), id(s2), s1 is s2
Out[82]: (8144656, 8144656, True)

In [83]: s1 = "!"

In [84]: s2 = "!"

In [85]: id(s1), id(s2), s1 is s2
Out[85]: (8849888, 8849888, True)
</code></pre>
<p>if i will produce my string at runtime; it won't be interned;</p>
<pre><code>In [86]: s1 = "abcde"

In [87]: s2 = "".join(['a', 'b', 'c', 'd', 'e'])

In [88]: id(s1), id(s2), s1 is s2
Out[88]: (84722944, 84723648, False)
</code></pre>
<p><code>"...during peephole optimization is called constant folding and consists in simplifying constant expressions in advance"</code>(from <a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">this</a> link) 
and these expression based on above rules will be interned</p>
<pre><code>In [91]: 'abc' +'de' is 'abcde'
Out[91]: True

In [92]: def foo():
    ...:     print "abc" + 'de'
    ...:     

In [93]: def foo1():
    ...:     print "abcde"
    ...:     

In [94]: dis.dis(foo)
  2           0 LOAD_CONST               3 ('abcde')
              3 PRINT_ITEM          
              4 PRINT_NEWLINE       
              5 LOAD_CONST               0 (None)
              8 RETURN_VALUE        

In [95]: dis.dis(foo1)
  2           0 LOAD_CONST               1 ('abcde')
              3 PRINT_ITEM          
              4 PRINT_NEWLINE       
              5 LOAD_CONST               0 (None)
              8 RETURN_VALUE        
</code></pre>
<p>and that with the length less than equal to 20;</p>
<pre><code>In [96]: "a" * 20 is 'aaaaaaaaaaaaaaaaaaaa'
Out[96]: True

In [97]: 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
Out[97]: False
</code></pre>
<p>and its all because python strings are immutable; you can't edit them;</p>
<pre><code>In [98]: s1 = "abcde"

In [99]: s1[2] = "C"
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-99-1d7c49892017&gt; in &lt;module&gt;()
----&gt; 1 s1[2] = "C"

TypeError: 'str' object does not support item assignment
</code></pre>
<p>Python provides <a href="https://docs.python.org/2/library/functions.html#intern" rel="nofollow noreferrer"><code>intern</code></a> Built-in Function; in python 3.x it is in <code>sys</code> <a href="https://docs.python.org/3/library/sys.html?highlight=sys.intern#sys.intern" rel="nofollow noreferrer">module</a>;  </p>
<pre><code>In [100]: s1 = 'this is a longer string than yours'

In [101]: s2 = 'this is a longer string than yours'

In [102]: id(s1), id(s2), s1 is s2
Out[102]: (84717088, 84717032, False)

In [103]: s1 = intern('this is a longer string than yours')

In [104]: s2 = intern('this is a longer string than yours')

In [105]: id(s1), id(s2), s1 is s2
Out[105]: (84717424, 84717424, True)
</code></pre>
<p>You can read more at below given links:</p>
<p><a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">http://guilload.com/python-string-interning/</a></p>
<p><a href="https://stackoverflow.com/questions/17679861/does-python-intern-strings">Does Python intern strings?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It is creating a new string object in and of itself!</p>
<pre><code>s1=s1+'f'
</code></pre>
<p>is no different to:</p>
<pre><code>s1 = 'abcdef'
</code></pre>
<p>Note that this can slow down your program significantly if you're appending multiple times to a string (because you are really creating multiple strings). This is a known anti-pattern since <em>every</em> concatenation creates a new string. This results in O(N^2) running time</p>
</div>
<div class="post-text" itemprop="text">
<p>String are immutable. Thus you cant "edit" a string. You get a new copy, i.e. new string object,  in a place where you think you "edit" it.</p>
</div>
<span class="comment-copy">I know your meaning, there's no copying, there is only creating new space. So it should be called as 'CreateNew on write', is it?</span>
<span class="comment-copy">@roast_soul: Not really.  The "write" has nothing to do with it.  Even if you just wrote <code>s1+'f'</code> or <code>'abcdef'</code> but didn't assign it to anything, the new object would still be created.  Whether a new object is created as part of an operation depends on what that operation is, not what (if anything) you're doing with the result.</span>
<span class="comment-copy">so, there is no 'write' operation on string, any operation on string cause the 'creating new space' action. right??</span>
<span class="comment-copy">@roast_soul: Right.</span>
