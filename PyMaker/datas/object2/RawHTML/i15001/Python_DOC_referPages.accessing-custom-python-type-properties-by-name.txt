<div class="post-text" itemprop="text">
<p>in the code below i'm defining a type then using the properties as keys of a dictionary:</p>
<pre><code>ProdType= namedtuple('ProdType', 'Cmdty Eqty Fixed')

prod_map = {ProdType.Cmdty: 'Commodities',
            ProdType.Eqty: 'Equities',
            ProdType.Fixed: 'Fixed Income'}
</code></pre>
<p>I know i can access the value in dictionary prod_map code like this: </p>
<pre><code>descr = prod_map[ProdType.Cmdty], 
</code></pre>
<p>but my question is, is it possible to access this map by a string value? such as:</p>
<pre><code>  descr = prod_map['Cmdty']
</code></pre>
<p>I ask because some clients (for example a .net client) will be accessing this through a webservice and will only be able to pass a string value.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you are trying to use a namedtuple as an enumerated type.  This is not how namedtuples work.  Generate the namedtuple again with <code>verbose=True</code> to see what it creates:</p>
<pre><code>&gt;&gt;&gt; ProdType= namedtuple('ProdType', 'Cmdty Eqty Fixed', verbose=True)
class ProdType(tuple):
    ...
    def __new__(_cls, Cmdty, Eqty, Fixed):
        'Create new instance of ProdType(Cmdty, Eqty, Fixed)'
        return _tuple.__new__(_cls, (Cmdty, Eqty, Fixed))
    ...
    Cmdty = _property(_itemgetter(0), doc='Alias for field number 0')
    Eqty = _property(_itemgetter(1), doc='Alias for field number 1')
    Fixed = _property(_itemgetter(2), doc='Alias for field number 2')
</code></pre>
<p>The above shows that we just made a tuple class with property aliases for the 3 attributes we expect in each instance.  So really, you don't need a dictionary at all, you could just use instances of <code>ProdType</code> like this:</p>
<pre><code>&gt;&gt;&gt; pt = ProdType('Commodities', 'Equity', 'Fixed Income')
&gt;&gt;&gt; pt.Cmdty
'Commodities'
&gt;&gt;&gt; pt.Eqty
'Equity'
</code></pre>
<p>You should simply access the attributes of the namedtuple using the namedtuple properties (as above) but if you <em>really</em> need to access the namedtuple via strings you can use <code>__getattribute__</code> like this:</p>
<pre><code>&gt;&gt;&gt; pt.__getattribute__('Fixed')
'Fixed Income'
</code></pre>
</div>
<span class="comment-copy">What is <code>DB</code>?  Your example doesn't use <code>ProdType</code> at all.</span>
<span class="comment-copy">you should try it and see what happens</span>
<span class="comment-copy">sorry, i tried to  make the example simple and had some typos. i corrected the example.  @krock - i did, that's why i'm asking.</span>
<span class="comment-copy">Yes re: enumerated types.  What it the equivalent way of doing this in python?   For now, looks like i am able to do something like this as a work around:  key = getattr(ProdType, key) if isinstance(key, basestring) else key</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer">Python 3.4</a> has added enumerated types, but as far as my understanding of what you want to do I think creating an instance of the namedtuple (as in the second code block above) should suit your needs.</span>
