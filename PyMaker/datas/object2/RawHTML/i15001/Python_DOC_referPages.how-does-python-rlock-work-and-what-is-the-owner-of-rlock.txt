<div class="post-text" itemprop="text">
<p>I am currently practicing python multi-thread module, and I write some code as below, but it is not working as I just expect.</p>
<pre><code>import threading
import thread
import random
import time
lock = threading.RLock()
def func(lock):
    print("In Thread " + threading.currentThread().getName())
    lock.acquire()
    time.sleep(random.random()*10)
    lock.release()
    print("Out Thread " + threading.currentThread().getName())

def start():
    lock.acquire()
    for i in range(5):
        thread.start_new(func, (lock,))
    lock.release()

# for i in range(5):
#     thread.start_new(func, (lock,))
start()

print("test")
time.sleep(1)
lock.acquire()
print("main ends")
lock.release()
</code></pre>
<p>In my opinion, whether there is time.sleep(1) in the main thread does not count much for the new threads's running, because the lock is global and belongs to the main thread, the lock.acquire() operation would always work fine, so the main thread should not wait for those new threads to proceed. According to the property of thread.start_new(), when the main thread ends, all new threads would also stop. However, when I comment out the time.sleep() line, the program goes as what I have expected, but when I add this line in, the main thread always waits for new threads to finish.</p>
<p>This confuses me a lot and hope someone would explain to me the functionality of Rlock() as well as which thread does it belong to when I create it in the main thread while passing it to the sub-new thread and calling lock.acquire()?</p>
</div>
<div class="post-text" itemprop="text">
<p>A lock belongs to the thread that last did <code>.acquire()</code> it successfully, until it has been <code>.release()</code>d.</p>
<p>A <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>RLock</code></a>, short for re-entrant lock is a lock that can be acquired  many times by the same thread that acquired it initially; the lock stays locked and held by the thread until each acquisition has been released.</p>
<p>The re-entrancy means here that the execution enters a section of code guarded by the lock, while the lock is held already.  Your code does not demonstrate a case where a re-entrant lock is needed but suppose you have functions:</p>
<pre><code>def guarded_op():
    with lock:
        print("Now doing 1 op")
        another_op()

def another_op():
    with lock:
        print("Now did the another op")
</code></pre>
<p>A non-re-entrant lock would not work there, as the "lock was already locked" in guarded op; the locking would fail in <code>another_op</code>; but <code>RLock</code> works just fine.</p>
<p>By the way, you should always use the <code>with</code> statement with locks whenever possible to ensure their orderly release.</p>
</div>
