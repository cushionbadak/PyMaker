<div class="post-text" itemprop="text">
<p>I have an array of shape [120000, 3] in which only the first 1500 elements are useful and the others are 0.</p>
<p>Here an example</p>
<pre><code>[15.0, 14.0, 13.0]
[11.0, 7.0, 8.0]
[4.0, 1.0, 3.0]
[0.0, 0.0, 0.0]
[0.0, 0.0, 0.0]
[0.0, 0.0, 0.0]
[0.0, 0.0, 0.0]
</code></pre>
<p>I have to find a way to remove all the elements that are [0.0, 0.0, 0.0]. I tried to write this but it doesn't work</p>
<pre><code>for point in points:
        if point[0] == 0.0 and point[1] == 0.0 and point[2] == 0.0:
            np.delete(points, point)
</code></pre>
<hr/>
<p><strong>edit</strong></p>
<p>All the solutions in the comment work, but I gave the green tick to the one I have used. Thanks to all.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few related approaches, split into two camps. You can either use a vectorised approach via calculation of a single Boolean array and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.all.html" rel="nofollow noreferrer"><code>np.ndarray.all</code></a>. Or you can calculate the index of the first row which contains only <code>0</code> elements, either via a <code>for</code> loop or <code>next</code> with a generator expression.</p>
<p>For performance, I recommend you use <a href="https://numba.pydata.org/" rel="nofollow noreferrer"><code>numba</code></a> with a manual <code>for</code> loop. Here's one example, but see benchmarking below for a more efficient variant:</p>
<pre><code>from numba import jit

@jit(nopython=True)
def trim_enum_nb(A):
    for idx in range(A.shape[0]):
        if (A[idx]==0).all():
            break
    return A[:idx]
</code></pre>
<h3>Performance benchmarking</h3>
<pre><code># python 3.6.5, numpy 1.14.3

%timeit trim_enum_loop(A)     # 9.09 ms
%timeit trim_enum_nb(A)       # 193 µs
%timeit trim_enum_nb2(A)      # 2.2 µs
%timeit trim_enum_gen(A)      # 8.89 ms
%timeit trim_vect(A)          # 3.09 ms
%timeit trim_searchsorted(A)  # 7.67 µs
</code></pre>
<hr/>
<h3>Test code</h3>
<p><strong>Setup</strong></p>
<pre><code>import numpy as np
from numba import jit

np.random.seed(0)

n = 120000
k = 1500

A = np.random.randint(1, 10, (n, 3))
A[k:, :] = 0
</code></pre>
<p><strong>Functions</strong></p>
<pre><code>def trim_enum_loop(A):
    for idx, row in enumerate(A):
        if (row==0).all():
            break
    return A[:idx]

@jit(nopython=True)
def trim_enum_nb(A):
    for idx in range(A.shape[0]):
        if (A[idx]==0).all():
            break
    return A[:idx]

@jit(nopython=True)
def trim_enum_nb2(A):
    for idx in range(A.shape[0]):
        res = False
        for col in range(A.shape[1]):
            res |= A[idx, col]
            if res:
                break
            return A[:idx]

def trim_enum_gen(A):
    idx = next(idx for idx, row in enumerate(A) if (row==0).all())
    return A[:idx]

def trim_vect(A):
    idx = np.where((A == 0).all(1))[0][0]
    return A[:idx]

def trim_searchsorted(A):
    B = np.frombuffer(A, 'S12')
    idx = A.shape[0] - np.searchsorted(B[::-1], B[-1:], 'right')[0]
    return A[:idx]
</code></pre>
<p><strong>Checks</strong></p>
<pre><code># check all results are the same
assert (trim_vect(A) == trim_enum_loop(A)).all()
assert (trim_vect(A) == trim_enum_nb(A)).all()
assert (trim_vect(A) == trim_enum_nb2(A)).all()
assert (trim_vect(A) == trim_enum_gen(A)).all()
assert (trim_vect(A) == trim_searchsorted(A)).all()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use for loops--those are slow.  Calling <code>np.delete</code> repeatedly in a for loop is a recipe for poor performance.</p>
<p>Instead, create a mask:</p>
<pre><code>zero_rows = (points == 0).all(1)
</code></pre>
<p>That is an array of length 120000 which is True where all the elements in that row are 0.</p>
<p>Then find the first such row:</p>
<pre><code>first_invalid = np.where(zero_rows)[0][0]
</code></pre>
<p>Finally, slice the array:</p>
<pre><code>points[:first_invalid]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>x = [[15.0, 14.0, 13.0],
[11.0, 7.0, 8.0],
[4.0, 1.0, 3.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0]]
</code></pre>
<p>The simple iterative solution:</p>
<pre><code>y = [i for i in x if i != [0.0, 0.0, 0.0]]
</code></pre>
<p>A better solution (Python 3.x):</p>
<pre><code>y = list(filter(lambda a: a != [0.0, 0.0, 0.0], x))
</code></pre>
<p>output:</p>
<pre><code>[[15.0, 14.0, 13.0], [11.0, 7.0, 8.0], [4.0, 1.0, 3.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For logarithmic complexity, you can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.searchsorted.html" rel="nofollow noreferrer">numpy.searchsorted</a> after casting data by rows:</p>
<pre><code>B=np.frombuffer(A,'S12')
index=B.size-np.searchsorted(B[::-1],B[-1:],'right')[0]
</code></pre>
<p><code>index</code> will be the number of not null items if the first ones are all not null.</p>
<p>test :  </p>
<pre><code>&gt;&gt;&gt;&gt; %timeit B.size-searchsorted(B[::-1],B[-1:],'right')[0]
2.2 µs 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>know it is over just thought i would give my answer :)</p>
<pre><code>x = [[15.0, 14.0, 13.0],
[11.0, 7.0, 8.0],
[4.0, 1.0, 3.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0]]
</code></pre>
<p>then a simeple list comprehension can be made</p>
<pre><code>[i for i in x if all(i)]
</code></pre>
<p>and outputs:</p>
<pre><code>[[15.0, 14.0, 13.0],[11.0, 7.0, 8.0],[4.0, 1.0, 3.0]]
</code></pre>
<p>takes </p>
<pre><code>0.0000010866 # seconds or 1.0866 microseconds
</code></pre>
<p>take the time with a gram of salt it is really inconsisten give my 2 sec to get a better estimation</p>
<p>when:</p>
<pre><code>x = [[15.0, 14.0, 13.0],
[11.0, 7.0, 8.0],
[4.0, 1.0, 3.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0],
[0.0, 0.0, 0.0]]*(120000//7)
</code></pre>
<p>i get the time to</p>
<pre><code>0.01199 # seconds
</code></pre>
<p>this time is hugely based on wather they are 0 or not, 0 are way faster since it is ignored.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple iterative solution with usage of <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html" rel="nofollow noreferrer">vstack</a></p>
<pre><code>import numpy as np
b = np.empty((0,3), float)
for elem in a:
    toRemove = np.array([0.0, 0.0, 0.0])
    if(not np.array_equal(elem,toRemove)):
        b=np.vstack((b, elem))
</code></pre>
</div>
<span class="comment-copy">Could you explain to me the if in the trim_enum_gen? What is the .all()?</span>
<span class="comment-copy">See <a href="https://docs.scipy.org/doc/numpy-1.10.4/reference/generated/numpy.ndarray.all.html" rel="nofollow noreferrer"><code>np.ndarray.all</code></a>, <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> and <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expressions</a>. If you have a <b>specific</b> question on how they are used here, I can try and explain further.</span>
<span class="comment-copy">numba for numba : replacing <code>if (A[idx]==0).all():</code> by         ` for j in range(3):\             if v[j]!=0:\                 break\         if v[j]==0:\             break  is four times faster ;)</span>
<span class="comment-copy">@B.M., Good point, updated. It takes a while to get used to <i>trying</i> to write nested loops. The solution I now have seems to be ~100x faster than previous numba!</span>
<span class="comment-copy">Would be interesting how this compares to John Zwinck's answer regarding performance.</span>
<span class="comment-copy">Why is you (Python 3.x) solution better (and why doesn't it work just as well in Python 2)?</span>
<span class="comment-copy">I think you need <code>A.shape[0]-np.searchsorted(B[::-1],B[-1:],'right')[0]</code>.</span>
<span class="comment-copy">Nice solution anyway +1, I also added this solution to my post timings, hope that's ok with you.</span>
