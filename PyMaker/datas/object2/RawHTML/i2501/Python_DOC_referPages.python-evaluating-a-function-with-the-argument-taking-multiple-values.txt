<div class="post-text" itemprop="text">
<p>Asssume I have a function in python which returns the power of 2 of its input</p>
<pre><code>def f(x):
    return x**2
</code></pre>
<p>Assume also I have a vector of integers 1,2,3,4,5</p>
<pre><code>I = asarray(list(range(1,6)))
</code></pre>
<p>Now I want to evaluate the function <code>f</code> with all inputs from <code>I</code> and the results should be in a vector of dimensions 5 (A 1x5 array in Python). My desired result is then: <code>[1,4,9,16,25]</code>.</p>
<p>Can I get this result <strong>WITHOUT</strong> the use of a <code>for</code> or any other loop?</p>
<p>I have used <code>array</code> package </p>
</div>
<div class="post-text" itemprop="text">
<p>directly from the <a href="http://book.pythontips.com/en/latest/map_filter.html" rel="nofollow noreferrer">pythontips</a> website...</p>
<p>use the <code>map</code> function!</p>
<pre><code>squared = list(map(lambda x: x**2, I))
</code></pre>
<p>if you want to use your function inside the <code>map</code>-function, just do <code>squared = list(map(f, I))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are generally two classical ways to apply a function to all elements of an iterable and store the results in a list. The more flexible one is a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>result = [f(x) for x in range(1, 6)]  # the upper bound is exclusive!
</code></pre>
<p>The other option is <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a> which allows a more concise notation, in particular if you have a named function available and do not need to use a lambda or the like:</p>
<pre><code>result = map(f, range(1, 6))        # Python2: returns list
result = list(map(f, range(1, 6)))  # Python3: return iterator, so cast
</code></pre>
</div>
<span class="comment-copy">your <code>list(range(1,5))</code> will only give you the numbers 1 to 4, since the range function is non inclusive for the upper boundary!</span>
<span class="comment-copy">Why not use a loop?</span>
<span class="comment-copy">You may use <code>map()</code> or a list comprehension, but these are merely loops in disguise. Or you may use the NumPy module, which has methods like <code>square()</code> that are automatically applied to every element in an array, but this too is merely a loop in disguise.</span>
<span class="comment-copy"><code>result = [f(x) for x in range(1, 6)]</code></span>
<span class="comment-copy">Thanks. This solved the simplified problem I stated above. What if my function is depended on two or more variables and one of the was fixed? For instance f(x,y)=x^y and I want to keep y fixed at 2</span>
<span class="comment-copy">then you would define <code>f(x,2) = x^2</code> and just call the same as above!</span>
<span class="comment-copy">Why not use a list comprehension? I know OP said they didn't want loops, but it's simpler to use if you're binding one of the parameters.</span>
