<div class="post-text" itemprop="text">
<p>I ask your help, because I'm trying to run a cython example a bit more complex than the one with one class that is possible to find in many tutorials (e.g. <a href="https://medium.com/@shamir.stav_83310/making-your-c-library-callable-from-python-by-wrapping-it-with-cython-b09db35012a3" rel="nofollow noreferrer">this guide</a> ). I haven't found any "more advanced" tutorial, so I hope this question will be useful also for people that are trying to learn it a bit more in depth.</p>
<p>I will write here the steps I took, hoping that someone will tell me where is my mistake.</p>
<p>I have a <em>Rectangle</em> c++ class (I put here just the .h file to make it shorter):</p>
<pre><code>#ifndef RECTANGLE_H
#define RECTANGLE_H
namespace shapes { 
    class Rectangle {
        public:
            int x0, y0, x1, y1;
            Rectangle();
            Rectangle(int x0, int y0, int x1, int y1);
            ~Rectangle();
            int getArea();
    };
}
#endif
</code></pre>
<p>and a <em>Group2</em> class. A very simple example class, whose constructor take as input 2 Rectangles:</p>
<pre><code>#ifndef GROUP4_H
#define GROUP4_H
#include "Rectangle.h"
namespace shapes{
    class Group2 {
    public:
        Rectangle rect0, rect1, rect2, rect3 ;
        Group2();
        Group2(Rectangle rect0, Rectangle rect1);
        ~Group2();
        void getAreas(int *area0, int *area1);
    };
}
#endif
</code></pre>
<p>Then I create a <em>grp2.pyx</em> file with the definition of both <em>Rectangle</em> and <em>Group2</em> class:</p>
<pre><code>#RECTANGLE
cdef extern from "Rectangle.h" namespace "shapes":
    cdef cppclass Rectangle:
        Rectangle() except +
        Rectangle(int, int, int, int) except +
        int x0, y0, x1, y1
        int getArea()

cdef class PyRectangle:
    cdef Rectangle c_rect
    def __cinit__(self, int x0, int y0, int x1, int y1):
        self.c_rect = Rectangle(x0, y0, x1, y1)
    def get_area(self):
        return self.c_rect.getArea()

# GROUP2
cdef extern from "Group2.h" namespace "shapes":
    cdef cppclass Group2:
        Group2() except +
        Group2(Rectangle rect0, Rectangle rect1) except +
        void getAreas(int *area0, int *area1)
cdef class PyGroup2:
    cdef Group2 c_group2
    def __cinit__(self, Rectangle rect0, Rectangle rect1):
        self.c_group2 = Group2(rect0, rect1)
    def get_areas(self):
        cdef int area0, area1
        self.c_group2.getAreas(&amp;area0, &amp;area1)
        return area0, area1
</code></pre>
<p>Then I compile those two class in a static c++ library with command line:</p>
<pre><code>gcc -c -fPIC Group2.cpp Rectangle.cpp
</code></pre>
<p>and</p>
<pre><code>ar rcs libexample.a Group2.o Rectangle.o
</code></pre>
<p>To finish i create the cython <em>setup.py</em> file that i call from command line:</p>
<pre><code>from distutils.core import setup, Extension
from Cython.Build import cythonize

setup(ext_modules = cythonize(Extension(
           name="grp2",                                # the extension name
           sources=["grp2.pyx"], # the Cython source and
           libraries=["example"],
           library_dirs=["lib"],
           include_dirs=["lib"],
                                                  # additional C++ source files
           language="c++",                        # generate and compile C++ code
      )))
</code></pre>
<p>At this point I have the error in the <em>_cinint_</em> of <em>PyGroup2</em>:</p>
<blockquote>
<p>Cannot convert Python object argument to type 'Rectangle'</p>
</blockquote>
<p>I suppose there is some mistake in my pyx file, but I cannot tell what, since I'm defining there the <em>Rectangle</em> for python.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>PyRectangle</code> in the signatures of <code>def</code>-functions and <code>PyRectangle.c_rect</code> when passing rectangles to C++-functions.</p>
<p>That means your code should be:</p>
<pre><code>cdef class PyGroup2:
    ...
    def __cinit__(self, PyRectangle rect0, PyRectangle rect1):
        self.c_group2 = Group2(rect0.c_rect, rect1.c_rect)
</code></pre>
<p>Read on for a more detailed explanation why.</p>
<hr/>
<p>All arguments passed to <code>def</code>-functions are Python-objects (i.e. of type <code>object</code> in Cython-parlance), after all those functions will be called from pure Python, which only knows Python-objects.</p>
<p>However, you can add some syntactic sugar and use "late-binding" in the signature of a <code>def</code>-function, for example, instead of</p>
<pre><code>def do_something(n):
  ...
</code></pre>
<p>use</p>
<pre><code>def do_something(int n):
  ...
</code></pre>
<p>Under the hood, Cython will transform this code to something like:</p>
<pre><code>def do_something(n_):
   cdef int n = n_ # conversion to C-int
   ...
</code></pre>
<p>This automatic conversion is possible for builtin-types like <code>int</code> or <code>double</code>, because there is functionality in Python-C-API for these conversions (i.e. <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_AsLong" rel="nofollow noreferrer"><code>PyLong_AsLong</code></a>, <a href="https://docs.python.org/3/c-api/float.html#c.PyFloat_AsDouble" rel="nofollow noreferrer"><code>PyFloat_AsDouble</code></a>). Cython also handles the error checking, so you should not undertake these conversion manually.</p>
<p>However, for user-defined types/classes like your <code>Rectangle</code>-class such automatic conversion is not possible - Cython can only automatically convert to <code>cdef</code>-classes/extensions, i.e. <code>PyRectangle</code>, thus <code>PyRectangle</code> should be used in the signature:</p>
<pre><code>cdef class PyGroup2:
    ...
    def __cinit__(self, PyRectangle rect0, PyRectangle rect1):
        ...
</code></pre>
<p>After Cython took care of conversion from <code>object</code> to <code>PyRectangle</code>, the last step from <code>PyRectangle</code> to <code>Rectangle</code> must be taken manually by utilizing the <code>c_rect</code> - pointer:</p>
<pre><code>...
def __cinit__(self, PyRectangle rect0, PyRectangle rect1):
    self.c_group2 = Group2(rect0.c_rect, rect1.c_rect)
</code></pre>
<hr/>
<p>The rules are similar for <code>cpdef</code>-function, because they can be called from pure Python. The <a href="https://cython.readthedocs.io/en/latest/src/userguide/early_binding_for_speed.html" rel="nofollow noreferrer">"early binding"</a> works only for types which Cython can automatically coverted from/to Python objects.</p>
<p>Unsurprisingly, the only function which can habe C++-classes in their signatures are the <code>cdef</code>-functions.</p>
</div>
<span class="comment-copy">It should be <code>def __cinit__(self, PyRectangle rect0, PyRectangle rect1):</code> because you can only pass Python objects to def-functions and then <code>self.c_group2 = Group2(rect0.c_rect, rect1.c_rect)</code> (or similar) because you cannot pass Python-objects to c++-code</span>
<span class="comment-copy">@ead Could you post this is a proper answer? Mostly because this gets asked reasonably frequently, and this is a fairly clear and straightforward version of the question so it would be good to use for duplicates in future</span>
<span class="comment-copy">Very clear answer. This crucial point was not so easy to understand from the other sources I looked. Thank you</span>
