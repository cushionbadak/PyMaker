<div class="post-text" itemprop="text">
<p>I have a list of tuples:</p>
<pre><code>[(0, 1), (0, 1), (0, 0), (0, 0), (1, 0), (1, 0), (1, 1), (1, 0), (1, 0), (2, 0), (2, 1), (2, 0), (3, 0), (3, 1), (3, 1), (3, 0), (3, 0), (4, 0), (4, 1), (4, 0), (4, 1), (4, 1), (5, 0), (5, 0), (5, 1), (5, 1)]
</code></pre>
<p>and I want to sum the right-side of tuples where the left-side is equal, and to put it in another tuples-list, so for the above list i'll get:</p>
<pre><code>[(0,2),(1,1),(2,1),(3,2),(4,3),(5,2)]
</code></pre>
<p>I tried this:</p>
<pre><code>k=0
for i,TCtup in enumerate(wordsMatchingList):
    if wordsMatchingList[i][0]==k:
        TC_matches+=wordsMatchingList[i][1]
        print("k: {} /// TC_matches: {}".format(k,TC_matches)) #for checking
    else:
        groupedWordsMatchingList.append(tuple((k,TC_matches)))
        TC_matches=0
        k+=1
</code></pre>
<p>but from k=1 it just loop one time less for every k because of the else condition.</p>
<p>thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>yet another way,</p>
<pre><code>t.sort(key=lambda x: x[0]) #sort before groupby (required)
g=itertools.groupby(t, lambda x: x[0])
new_l = []
for k,v in g:
    new_l.append((k, sum([x[1] for x in v])))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your tuples are guaranteed to come in order like this—all the <code>(0, x)</code>, then all the <code>(1, x)</code>, etc.—you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; xs = [(0, 1), (0, 1), (0, 0), (0, 0), (1, 0), (1, 0), (1, 1), (1, 0), (1, 0), (2, 0), (2, 1), (2, 0), (3, 0), (3, 1), (3, 1), (3, 0), (3, 0), (4, 0), (4, 1), (4, 0), (4, 1), (4, 1), (5, 0), (5, 0), (5, 1), (5, 1)]
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; groups = groupby(xs, key=itemgetter(0))
&gt;&gt;&gt; ys = [(key, sum(map(itemgetter(1), group))) for key, group in groups]
</code></pre>
<p>If they <em>aren't</em>, but you can sort them (you have a list, not just an arbitrary iterable, and it isn't so huge that log-linear time will be too expensive):</p>
<pre><code>&gt;&gt;&gt; groups = groupby(sorted(xs, key=itemgetter(0)), key=itemgetter(0))
</code></pre>
<p>If you can't sort them, you can manually build up the totals as you go:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; totals = Counter()
&gt;&gt;&gt; for k, v in xs:
...     totals[k] += v
&gt;&gt;&gt; ys = list(totals.items())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another approach is using a <code>defaultdict</code> (from <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">collections</a>) and to iterate the list of tuples.</p>
<pre><code>from collections import defaultdict

lst = [(0, 1), (0, 1), (0, 0), (0, 0), (1, 0), (1, 0), (1, 1), (1, 0), (1, 0), (2, 0), (2, 1), (2, 0), (3, 0), (3, 1), (3, 1), (3, 0), (3, 0), (4, 0), (4, 1), (4, 0), (4, 1), (4, 1), (5, 0), (5, 0), (5, 1), (5, 1)]

d = defaultdict(int)

for (u,v) in lst:
    d[u]+=v

# list(d.items()) [(0, 2), (1, 1), (2, 1), (3, 2), (4, 3), (5, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend using a library with a <code>groupby</code> function. <code>pandas</code>, for instance, can be useful</p>
<pre><code>&gt;&gt;&gt; s = pd.DataFrame(list_)
&gt;&gt;&gt; s.groupby(0, as_index=False).sum().agg(tuple,1).tolist()

[(0, 2), (1, 1), (2, 1), (3, 2), (4, 3), (5, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [5]: [(j, sum([i[1] for i in a if i[0] == j])) for j in set([i[0] for i in a])]
Out[5]: [(0, 2), (1, 1), (2, 1), (3, 2), (4, 3), (5, 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [(0, 1), (0, 1), (0, 0), (0, 0), (1, 0), (1, 0), (1, 1), (1, 0), (1, 0), (2, 0), (2, 1), (2, 0), (3, 0), (3, 1), (3, 1), (3, 0), (3, 0), (4, 0), (4, 1), (4, 0), (4, 1), (4, 1), (5, 0), (5, 0), (5, 1), (5, 1)]
[(i,sum([q[1] for q in lst if q[0] == i])) for i in range(lst[-1][0]+1)]
</code></pre>
<p>gives:</p>
<pre><code>[(0,2),(1,1),(2,1),(3,2),(4,3),(5,2)]
</code></pre>
</div>
<span class="comment-copy">Did you look at itertools.groupby?</span>
<span class="comment-copy">Are your tuples guaranteed to be in sorted order like this?</span>
<span class="comment-copy">Paul Rooney- I'll look for it now.</span>
<span class="comment-copy">abarnert- yes it guaranteed to be in sorted order</span>
<span class="comment-copy"><code>e = {}; for k, v in xs: e[k] = e.get(k,0)+v</code> should work. I also tend to think this will have least complexity as compared to the one with groupby, map, sum and for loop all at once</span>
<span class="comment-copy">@Onyambu That's the same as my last version but with a one-letter variable name for <code>totals</code>, and repeating yourself to avoid the use of <code>Counter</code>, and missing the last step. Also, if by "least complexity" you mean computational complexity, then yes, as I explained, sorting takes log-linear time; if you've already done it, then the rest of the work is linear, but otherwise, it obviously isn't.</span>
<span class="comment-copy">I am not talking of mine. I am saying your second answer is better than your first answer. Leave alone the code i wrote</span>
<span class="comment-copy">You are iteraring the whole list for each distinct left elements of a tuple.</span>
<span class="comment-copy">Yeah, I agree, time complexity is O(m*n), but it's easier to read and will do the work for a small sized list as the one posted by op.</span>
