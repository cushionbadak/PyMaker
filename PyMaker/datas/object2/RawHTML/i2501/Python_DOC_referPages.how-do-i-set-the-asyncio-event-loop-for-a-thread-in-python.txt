<div class="post-text" itemprop="text">
<p>I'm trying to create two threads that each have their own asyncio event loop.</p>
<p>I've tried the following code but it doesn't seem to work:</p>
<pre><code>import asyncio
from threading import Thread

def hello(thread_name):
    print('hello from thread {}!'.format(thread_name))

event_loop_a = asyncio.new_event_loop()
event_loop_b = asyncio.new_event_loop()

def callback_a():
    asyncio.set_event_loop(event_loop_a)
    asyncio.get_event_loop().call_soon_threadsafe(lambda: hello('a'))

def callback_b():
    asyncio.set_event_loop(event_loop_b)
    asyncio.get_event_loop().call_soon_threadsafe(lambda: hello('b'))

thread_a = Thread(target=callback_a, daemon=True)
thread_b = Thread(target=callback_b, daemon=True)
thread_a.start()
thread_b.start()
</code></pre>
<p>My use case is calling Tornado web framework's websocket_connect async function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your threads are queuing callbacks in their respective event loops, but they exit before actually <em>running</em> the event loop, so the callbacks never get executed. Also, you don't need <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe" rel="nofollow noreferrer"><code>call_soon_threadsafe</code></a>, since you are invoking the callback from the same thread the event loop is (or, rather, will be) running on.</p>
<p>This code prints the expected output:</p>
<pre><code>import asyncio
from threading import Thread

def hello(thread_name):
    print('hello from thread {}!'.format(thread_name))

event_loop_a = asyncio.new_event_loop()
event_loop_b = asyncio.new_event_loop()

def callback_a():
    asyncio.set_event_loop(event_loop_a)
    asyncio.get_event_loop().call_soon(lambda: hello('a'))
    event_loop_a.run_forever()

def callback_b():
    asyncio.set_event_loop(event_loop_b)
    asyncio.get_event_loop().call_soon(lambda: hello('b'))
    event_loop_b.run_forever()

thread_a = Thread(target=callback_a, daemon=True)
thread_b = Thread(target=callback_b, daemon=True)
thread_a.start()
thread_b.start()
</code></pre>
<p>A more typical use case for <code>call_soon_threadsafe</code>, and more in line with what you might have had in mind, is to submit a callback (or a coroutine using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe</code></a>) to an event loop running in another thread. Here is an example:</p>
<pre><code>import asyncio, threading

def hello(thread_name):
    print('hello from thread {}!'.format(thread_name))

event_loop_a = asyncio.new_event_loop()
event_loop_b = asyncio.new_event_loop()

def run_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

threading.Thread(target=lambda: run_loop(event_loop_a)).start()
threading.Thread(target=lambda: run_loop(event_loop_b)).start()

event_loop_a.call_soon_threadsafe(lambda: hello('a'))
event_loop_b.call_soon_threadsafe(lambda: hello('b'))

event_loop_a.call_soon_threadsafe(event_loop_a.stop)
event_loop_b.call_soon_threadsafe(event_loop_b.stop)
</code></pre>
<p>In that case it is rarely needed to have more than one event loop thread - you'd typically create only one, and allow that thread to service all your asyncio needs. After all, being able to host a large number of tasks in a single event loop is one of the strong points of asyncio.</p>
</div>
<span class="comment-copy">What does "it doesn't seem to work" mean? Are you getting an exception? Are the event loops not running?</span>
<span class="comment-copy">the event loops aren't running, no exceptions but the event loop doesn't seem to be set in the thread</span>
<span class="comment-copy">This answer helped me get Tornado websocket_connect work correctly in its own thread with its own eventloop, thanks for this answer! The important piece I was missing was <code>loop.run_forever()</code>, and the call_soon_threadsafe helped me schedule the functions I wanted. Thanks!</span>
<span class="comment-copy">@RudolfOlah If you like <code>call_soon_threadsafe</code>, also check out <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>asyncio.run_coroutine_threadsafe</code></a>, which allows you to schedule a <i>coroutine</i> in the event loop thread, and returns a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>concurrent.futures.Future</code></a> which allows waiting for the coroutine to finish without causing a deadlock.</span>
<span class="comment-copy">thanks for the tip; in my other case, with Tornado <code>websocket_connect</code>, the future finishes upon connection: <a href="http://www.tornadoweb.org/en/stable/websocket.html#tornado.websocket.websocket_connect" rel="nofollow noreferrer">tornadoweb.org/en/stable/â€¦</a>  I guess it would make sense for the loop to run that function until completion (websocket client has connected to the server successfully), and then run the loop forever.</span>
