<div class="post-text" itemprop="text">
<p>I'm trying to use Python's <a href="https://docs.python.org/3.7/library/re.html#re.findall" rel="nofollow noreferrer">findall</a> to try and find all the hypenated <em>and</em> non-hypenated identifiers in a string (this is to plug into existing code, so using any constructs beyond <code>findall</code> won't work). If you imagine code like this:</p>
<pre><code>regex = ...
body = "foo-bar foo-bar-stuff stuff foo-word-stuff"

ids = re.compile(regex).findall(body)
</code></pre>
<p>I would like the <code>ids</code> value to be <code>['foo', 'bar', 'word', 'foo-bar', 'foo-bar-stuff', and 'stuff']</code> (although not <code>bar-stuff</code>, because it's hypenated, but does not appear as a standalone space-separated identifier). Order of the array/set is not important.</p>
<p>A simple regex which matches the non-hypenated identifiers is <code>\w+</code> and one which matches the hypenated ones is <code>[\w-]+</code>. However, I cannot figure out one which does both simultaneously (I don't have total control over the code, so cannot concatenate the lists together - I would like to do this in one Regex if possible). </p>
<p>I have tried <code>\w|[\w-]+</code> but since the expression is greedy, this misses out <code>bar</code> for example, only matching <code>-bar</code> since <code>foo</code> has already been matched and it won't retry the pattern from the same starting position. I would like to find matches for (for example) both <code>foo</code> and <code>foo-bar</code> which begin (are anchored) at the same string position (which I think <code>findall</code> simply doesn't consider).</p>
<p>I've been trying some tricks such as lookaheads/lookbehinds such as mentioned, but I can't find any way to make them applicable to my scenario.</p>
<p>Any help would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may use</p>
<pre><code>import re
s = "foo-bar foo-bar-stuff stuff" #=&gt; {'foo-bar', 'foo', 'bar', 'foo-bar-stuff', 'stuff'}
# s = "A-B-C D" # =&gt; {'C', 'D', 'A', 'A-B-C', 'B'}
l = re.findall(r'(?&lt;!\S)\w+(?:-\w+)*(?!\S)', s)
res = []
for e in l:
    res.append(e)
    res.extend(e.split('-'))
print(set(res))
</code></pre>
<p><strong>Pattern details</strong></p>
<ul>
<li><code>(?&lt;!\S)</code> - no non-whitespace right before</li>
<li><code>\w+</code> - 1+ word chars</li>
<li><code>(?:-\w+)*</code> - zero or more repetitions of

<ul>
<li><code>-</code> - a hyphen</li>
<li><code>\w+</code> - 1+ word chars</li>
</ul></li>
<li><code>(?!\S)</code> - no non-whitespace right after.</li>
</ul>
<p>See the <a href="https://regex101.com/r/YMWPp2/1" rel="nofollow noreferrer">pattern demo online</a>.</p>
<p>Note that to get all items, I split the matches with <code>-</code> and add these items to the resulting list. Then, with <code>set</code>, I remove any eventual dupes.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't have to use regex</p>
<p>Just use split(below is example)</p>
<pre><code>result = []
for x in body.split():
    if x not in result:
            result.append(x)
    for y in x.split('-'):
            if y not in result:
                    result.append(y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not possible with <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">findall</a> alone, since it finds all <strong>non-overlapping</strong> matches, as the documentation says.</p>
<p>All you can do is find all longest matches with <code>\w[-\w]*</code> or something like that, and then generate all valid spans out of them (most probably starting from their <code>split</code> on <code>'-'</code>).</p>
<p>Please note that <code>\w[-\w]*</code> will also match <code>123</code>, <code>1-a</code>, and <code>a--</code>, so something like<br/><code>(?=\D)\w[-\w]*</code> or <code>(?=\D)\w+(?:-\w+)*</code> could be preferable (but you would still have to filter out the <code>1</code> from <code>a-1</code>).</p>
</div>
<span class="comment-copy">You're asking for overlapping regex, which python's <code>re</code> module does not currently support.  If you need to use the module, and your strings aren't that long, you could simply match twice</span>
<span class="comment-copy">It's unclear why <code>foo</code>, <code>bar</code>, and <code>foo-bar</code> should all be matched from the first string, while you don't want a similar overlapping match for the second string. Is the number of hyphens a factor in the decision?</span>
<span class="comment-copy">Try <a href="https://ideone.com/dXJUDE" rel="nofollow noreferrer">ideone.com/dXJUDE</a></span>
<span class="comment-copy">Are you sure you want <code>bar</code> to be matched, but not <code>bar-stuff</code>? That does not appear to be consistent.</span>
<span class="comment-copy">@tripleee Sorry I should have clarified earlier. It is consistent, but I appreciate it's confusing. <code>bar-stuff</code> is a hypenated <i>substring</i> of one of the identifiers, so it doesn't count by my criteria. Only non-hypenated substrings should count.</span>
<span class="comment-copy">Thanks. I'm going to mark this accepted for now especially given the effort you've put in - thanks! Unfortunately this isn't suitable for my purposes - I should have made this clearer in the question but I'm trying to plug my regex into some existing code that uses <code>findall</code> (and only findall) - yours augments it with a loop. I might be able to hack it in though. Thanks.</span>
<span class="comment-copy">@AndrewFerrier No idea if it is possible. See <a href="http://rextester.com/WNJTX11169" rel="nofollow noreferrer">another demo</a> (it is Python 2, I guess some things can be done better with Python 3.)</span>
<span class="comment-copy">Reasonable approach, thanks. Doesn't answer my question with a regex, which is unfortunate as I'm trying to retrofit my answer into somewhere that uses one. But this is helpful, nevertheless. Thanks.</span>
<span class="comment-copy">I had a nasty feeling that was the case, but thanks for confirming.</span>
