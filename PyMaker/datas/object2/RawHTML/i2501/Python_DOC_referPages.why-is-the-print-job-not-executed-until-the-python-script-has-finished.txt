<div class="post-text" itemprop="text">
<p>In my understanding, <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">subprocess.Popen()</a> should create a new process and does not block the main one.</p>
<p>However, the following scripts do not print until they have finished. </p>
<p>It appears that the print job is added after the button is pressed, but for some reason not directly executed. (At least Ubuntu shows an added print job.)</p>
<p><strong>Why does this behavior occur?</strong></p>
<pre><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess

lpr =  subprocess.Popen("/usr/bin/lpr",              # on raspbian: /usr/bin/lp
                        stdin=subprocess.PIPE,
                        stdout=subprocess.DEVNULL,   # proposed by user elias
                        close_fds=True)              # proposed by user elias

output = "Username: testuser\n".encode() \
         + "Password: p4ssw0rd\n".encode()

lpr.stdin.write(output)

while True:
    pass
</code></pre>
<p>The above script does not print anything, even after it has been quit using ctrl-c. (The print job seems to stay in the queue.)</p>
<pre><code>#! /usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import time

lpr =  subprocess.Popen("/usr/bin/lpr",              # on raspbian: /usr/bin/lp
                        stdin=subprocess.PIPE,
                        stdout=subprocess.DEVNULL,   # proposed by user elias 
                        close_fds=True)              # proposed by user elias

output = "Username: testuser\n".encode() \
         + "Password: p4ssw0rd\n".encode()

lpr.stdin.write(output)

time.sleep(20)
</code></pre>
<p>This prints after 20 seconds (when the script ends).</p>
<hr/>
<p>About the execution environment:  </p>
<ul>
<li><em>os</em>: ubuntu 18.04 (does also occur on raspbian)</li>
<li><em>python</em>: 3.6.5  </li>
<li><em>printer</em>: a network printer via CUPS (does also occur when connected via USB)</li>
</ul>
<hr/>
<p><strong>SOLUTION:</strong></p>
<p>As can be seen in the comments of the answer from user <em>elias</em>, the behavior was caused by buffering.</p>
<p>The problem was solved by closing stdin.</p>
<pre><code>lpr.stdin.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe if you don't specify <code>stdout</code> in the <code>Popen</code> call it will share the same as the parent process, whose output your program is probably owning.</p>
<p>Try adding <code>stdout=subprocess.DEVNULL</code> (or <code>stdout=subprocess.PIPE</code>, in case you want to capture that output).</p>
<p>From <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>stdin, stdout and stderr specify the executed program’s standard input, standard output and standard error file handles, respectively. Valid values are PIPE, DEVNULL, an existing file descriptor (a positive integer), an existing file object, and None. PIPE indicates that a new pipe to the child should be created. DEVNULL indicates that the special file os.devnull will be used. With the default settings of None, no redirection will occur; the child’s file handles will be inherited from the parent.</p>
</blockquote>
</div>
<span class="comment-copy">Thanks for your quick reply. I added the parameter, but I am not sure if it solved the problem. It appears that a print job is added right after the button is pressed, but not directly executed. Maybe it is a peculiarity of Ubuntu?</span>
<span class="comment-copy">Hm, it could be... If you still want to make sure it will run in background, you can also try <code>close_fds=True</code> (saw this on: <a href="https://stackoverflow.com/a/34459371/149872">stackoverflow.com/a/34459371/149872</a>)</span>
<span class="comment-copy">@AFoeee does the same thing happen if you run the command in a shell-script instead of a python script? something like: <code>echo -e "Username: testuser\nPassword: p4ssw0rd" | /usr/bin/lpr &amp;</code></span>
<span class="comment-copy">If you get the same behavior, then the problem is definitely unrelated to python/urwid.</span>
<span class="comment-copy">Hmm, interesting! Maybe it's because of buffering? You could try flushing the stdin after writing to it, like <code>lpr.stdin.flush()</code> or maybe even closing it  <code>lpr.stdin.flush()</code> ?</span>
