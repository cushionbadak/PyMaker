<div class="post-text" itemprop="text">
<p>I want to use standard output if a <code>function()</code> have args <code>use_standard_output = True</code>.</p>
<p>Like this:</p>
<pre><code>def function(use_standard_output = True):

    ~ SOME PROCESS ~

    if(use_standard_output):
        print("print something to monitor the process")
</code></pre>
<p>Is there smarter way to implement this?
Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Look into the <a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow noreferrer"><code>logging</code></a> module. It comes equipped with different levels.</p>
<p>For example, you could replace your call to <code>print</code> with <code>logging.info("Print something to monitor the process")</code></p>
<p>If you configure it with <code>logging.basicConfig(level=logging.INFO)</code>, you will see the output. If you raise the logging level (e.g. <code>logging.basicConfig(level=logging.WARNING)</code>, it will be ignored.</p>
<p>For a complete example:</p>
<pre><code>import logging
def function():
    logging.info("print something to monitor the process")

logging.basicConfig(level=logging.INFO)
function()
logging.basicConfig(leve=logging.WARNING)
function()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Whether it's "smart" or not, you can redefine the print function. This was the rationale for making it a function in Python 3. Since you'll be "shadowing" the built-in function (i.e. re-using its name locally, effectively redefining it) you do, of course, have to retain a reference to the built_in function so you can use it inside your redefinition.</p>
<p>Then a global (here, <code>OUTPUT_REQUIRED</code>) can determine whether or not it produces any output:</p>
<pre><code>system_print = print

def print(*args, **kwargs):
    if OUTPUT_REQUIRED:
        system_print(*args, **kwargs)
</code></pre>
<p>The <code>*args, *kwargs</code> notation may not be familiar to you. Using it as the code does, in both the definition and the call, it is a simple way to call <code>system_print</code> with the same positional and keyword arguments that your <code>print</code> function was called with.</p>
<p>You could continue to use the additional argument by explicitly naming it in the definition, and not passing it through to <code>print</code>:</p>
<pre><code>system_print = print

def print(OUTPUT_REQUIRED, *args, **kwargs):
    if OUTPUT_REQUIRED:
        system_print(*args, **kwargs)
</code></pre>
<p>This represents a change to the API which would make switching back to the standard function more difficult. I'd recommend simply using a different name in this case.</p>
<p>The logging module, while extremely comprehensive, takes a little more effort to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want either write the message to the terminal or to a log file you can work with streams. You simply work with a stream object pointing to a file or STDOUT.</p>
<pre><code>import sys

if use_standard_output:
    stream = sys.stdout
else:
    stream = open('logfile', 'w')

print("print something to monitor the process", file=stream)
</code></pre>
</div>
<span class="comment-copy">What happens if <code>use_standard_output = False</code>? Does it do nothing or does it write to a log file?</span>
