<div class="post-text" itemprop="text">
<p>In its essence, I do this:</p>
<pre><code>a = True
b = False
ls = [a, b]

a = False

print(ls)
&gt; [True, False]
</code></pre>
<p>And what happens is that whatever happens to <code>a</code> is decoupled from the list after the first inclusion. Is there any way to update <code>a</code> and also have the list updating itself, in a clean way?</p>
<p>Of course I could simply do <code>ls[0] = False</code> and be done. But in a large project, with many moving parts, I'd like to avoid non-descriptive bracket indexing.</p>
<p>I assume I could do some messy construct of an instantiated class, and then iterate over the attributes, but that sounds like messy business. Or is it?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid indexing and have easy to read attributes then you could just use a class that has class attributes:</p>
<pre><code>class Data:
    a = True
</code></pre>
<p>and keep multiple references to it:</p>
<pre><code>data = Data
data2 = Data  # or similarly data2 = data

data.a = False
print(data2.a)
# False
</code></pre>
<p>Note that if you instantiate the class you'll need to keep a reference to the instance rather than the class as the original class won't be updated anymore:</p>
<pre><code>data = Data()
data2 = data

data.a = 123
print(data2.a)
# 123

# original class remains unchanged
print(Data().a)
# True
</code></pre>
<p>From Python 3.7 you can use a <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclass</a>, which makes instantiate with custom data simpler:</p>
<pre><code>from dataclasses import dataclass

@dataclass
class Data:
    a = True

data = Data(a=False)
data2 = data
print(data2.a)
# False
</code></pre>
<p>Finally, if you do care about variable states then there's a good chance you'll be working in a class anyway, in which case you could use a property:</p>
<pre><code>class SomeClass:
    def __init__(self):
        self.a = False
        self.b = True

    @property
    def ls(self):
        return self.a, self.b

some_class = SomeClass()
some_class.a = True
print(some_class.ls)
# True, True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you this quite simple solution defining <code>ls</code> as a function instead of a simple list. In this way, <code>ls()</code> will always returns the updated values of <code>a</code>and <code>b</code>. The code is very close to your original code:  </p>
<pre><code>a = True
b = False

ls = lambda:[a,b]

a = False
print(ls())  # [False, False]

b = True
print(ls())  # [False, True]
</code></pre>
</div>
<span class="comment-copy"><code>ls</code> is a <code>tuple</code> and tuples are <i>immutable</i>. Changing it to a list does not solve the problem but you can't expect a tuple to update.</span>
<span class="comment-copy">There are concepts like copy and deepcopy in Python.</span>
<span class="comment-copy"><code>a</code> is a name for an object. If you assign to <code>a</code> you don't change the object you change what <code>a</code> references.</span>
<span class="comment-copy">In short: no. Assignment to a symbol (variable name) only ever affects that symbol. Unless you mutate mutable objects, such effects never propagate.</span>
<span class="comment-copy">@barny tuples are immutable and more appropriate for heterogeneous data. Lists are more appropriate for homogeneous data.</span>
<span class="comment-copy">It's probably worth noting that this only works in Py &gt;= 3.7</span>
<span class="comment-copy">This is probably the densest approach, coupled with an <code>__iter__: yield</code> method to make it list-like.</span>
