<div class="post-text" itemprop="text">
<p>I have a list containing different data types, say numbers and strings:</p>
<pre><code>foo = [5,2,'a',8,4,'b','y',9, 'd','e','g']
</code></pre>
<p>Let's say I want to find all consecutive strings in the the list, and group them together:</p>
<pre><code>bar = [ ['a'],['b','y'],['d','e','g'] ]
</code></pre>
<p>How can I do this</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a wonderful opportunity to use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>:</p>
<pre><code>from itertools import groupby


foo = [5,2,'a',8,4,'b','y',9, 'd','e','g']
bar = [list(g) for k, g in groupby(foo, key=lambda x: isinstance(x, str)) if k]
</code></pre>
<p>which produces the desired:</p>
<pre><code>[['a'], ['b', 'y'], ['d', 'e', 'g']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Iterate through each element in the list, if it is of type <code>str</code>, append it to <code>one_d_array</code>, otherwise, append <code>one_d_array</code> to <code>two_d_array</code>, provided <code>one_d_array</code> is not empty. Reset <code>one_d_array</code> whenever the element is not of type <code>str</code></p>
<pre><code>lst = [5,2,'a',8,4,'b','y',9, 'd','e','g', 3]
ind = 0
two_d_arr = []
one_d_arr = []
while(ind &lt; len(lst)):
    cur_element = lst[ind]
    if(isinstance(cur_element, str) == True):
        one_d_arr.append(cur_element)
    else:
        if(len(one_d_arr) != 0):
            two_d_arr.append(one_d_arr)
        one_d_arr = []
    ind = ind+1
if(len(one_d_arr) != 0):
            two_d_arr.append(one_d_arr)
print(two_d_arr)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without using any import, you can do it through a good old "for loop" iterating over the elements of the lists. Here is a code working also for any type you want, not only string:  </p>
<pre><code>def group_list(a_list, a_type):
    res = []
    sublist = []
    for elem in a_list:
        if isinstance(elem, a_type):
            # Here the element is of  type a_type: append it to a sublist
            sublist.append(elem)
        else:
            # Here the element is not of type a_type: append the sublist (if not empty) to the result list
            if sublist:
                res.append(sublist)
                sublist = []
    # If the last element of the list is of type a_type, the last sublist has not been appended: append it now
    if sublist:
        res.append(sublist)

    return res


foo = [5,2,'a',8,4,'b','y',9, 'd','e','g']
print(group_list(foo,str)) 
# [['a'], ['b', 'y'], ['d', 'e', 'g']]
</code></pre>
</div>
<span class="comment-copy">This has been answered (with various criteria before) - what you're effectively after is something like: <code>bar = [list(g) for k, g in itertools.groupby(foo, lambda L: isinstance(L, str)) if k]</code> - there's a fairly comprehensive post on SO for this somewhere... bear with...</span>
<span class="comment-copy">Could you point me to one of the previous answers?</span>
<span class="comment-copy">Yup - trying to find a good one :)</span>
<span class="comment-copy">Umm... what's with the weird order of <code>k, g</code> and using <code>if g==True</code> there?</span>
<span class="comment-copy">@JonClements Without the <code>if k==True</code> it returns <code>[[5, 2], ['a'], [8, 4], ['b', 'y'], [9], ['d', 'e', 'g']]</code>. The grouping is done based on what boolean the <code>key</code> returns.</span>
<span class="comment-copy">but <code>if k</code> is fine :)</span>
<span class="comment-copy">@JonClements I see what you mean now.. Sorry.</span>
<span class="comment-copy">How could I add a second condition to the key part. Lets say I wanted only strings that were above a certain length.</span>
