<div class="post-text" itemprop="text">
<p>I am using Python 3.6 and the <code>dataclasses</code> backport package from <a href="https://github.com/ericvsmith/dataclasses" rel="nofollow noreferrer">ericvsmith</a>.</p>
<p>It seems that calling <code>dataclasses.asdict(my_dataclass)</code> is ~10x slower than calling <code>my_dataclass.__dict__</code>:</p>
<pre><code>In [172]: @dataclass
     ...: class MyDataClass:
     ...:     a: int
     ...:     b: int
     ...:     c: str
     ...: 

In [173]: %%time
     ...: _ = [MyDataClass(1, 2, "A" * 1000).__dict__ for _ in range(1_000_000)]
     ...: 
CPU times: user 631 ms, sys: 249 ms, total: 880 ms
Wall time: 880 ms

In [175]: %%time
     ...: _ = [dataclasses.asdict(MyDataClass(1, 2, "A" * 1000)) for _ in range(1_000_000)]
     ...: 
CPU times: user 11.3 s, sys: 328 ms, total: 11.6 s
Wall time: 11.7 s
</code></pre>
<p>Is this expected behavior? In what cases should I have to use <code>dataclasses.asdict(obj)</code> instead of <code>obj.__dict__</code>? </p>
<hr/>
<p><strong>Edit</strong>: Using <code>__dict__.copy()</code> does not make a big difference:</p>
<pre><code>In [176]: %%time
     ...: _ = [MyDataClass(1, 2, "A" * 1000).__dict__.copy() for _ in range(1_000_000)]
     ...: 
CPU times: user 922 ms, sys: 48 ms, total: 970 ms
Wall time: 970 ms
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In most cases where you would have used <code>__dict__</code> without <code>dataclasses</code>, you should probably keep using <code>__dict__</code>, maybe with a <code>copy</code> call. <code>asdict</code> does a <em>lot</em> of extra work that you may not actually want. Here's what it does.</p>
<hr/>
<p>First, from the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Each dataclass is converted to a dict of its fields, as name: value pairs. <strong>dataclasses, dicts, lists, and tuples are recursed into.</strong> For example:</p>
<pre><code>@dataclass
class Point:
     x: int
     y: int

@dataclass
class C:
     mylist: List[Point]

p = Point(10, 20)
assert asdict(p) == {'x': 10, 'y': 20}

c = C([Point(0, 0), Point(10, 4)])
assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}
</code></pre>
</blockquote>
<p>So if you want recursive dataclass dictification, use <code>asdict</code>. If you don't want it, then all the overhead that goes into providing it is wasted. Particularly, if you use <code>asdict</code>, then changing the implementation of contained objects to use <code>dataclass</code> will change the result of <code>asdict</code> on outer objects.</p>
<hr/>
<p>Aside from that, <code>asdict</code> builds a <em>new</em> dict, while <code>__dict__</code> simply accesses the object's attribute dict directly. The return value of <code>asdict</code> will not be affected by reassignment of the original object's fields. Also, <code>asdict</code> uses <code>fields</code>, so if you add attributes to a dataclass instance that don't correspond to declared fields, <code>asdict</code> won't include them.</p>
<p>Finally, the docs don't mention it at all, but <code>asdict</code> will <a href="https://github.com/python/cpython/blob/v3.7.0/Lib/dataclasses.py#L1028" rel="nofollow noreferrer">call <code>deepcopy</code></a> on everything that isn't a dataclass object, dict, list, or tuple:</p>
<pre><code>else:
    return copy.deepcopy(obj)
</code></pre>
<p>(Dataclass objects, dicts, lists, and tuples go through the recursive logic, which also builds a copy, just with recursive dictification applied.)</p>
<p><code>deepcopy</code> is really expensive on its own, and the lack of any <code>memo</code> handling means that <code>asdict</code> is likely to create multiple copies of shared objects in nontrivial object graphs. Watch out for that:</p>
<pre><code>&gt;&gt;&gt; from dataclasses import dataclass, asdict
&gt;&gt;&gt; @dataclass
... class Foo:
...     x: object
...     y: object
... 
&gt;&gt;&gt; a = object()
&gt;&gt;&gt; b = Foo(a, a)
&gt;&gt;&gt; c = asdict(b)
&gt;&gt;&gt; b.x is b.y
True
&gt;&gt;&gt; c['x'] is c['y']
False
&gt;&gt;&gt; c['x'] is b.x
False
</code></pre>
</div>
<span class="comment-copy">Well, for starters, <code>asdict</code> will create and return <i>new dict object</i>, and recursive and convert any other data-class instances into dicts, whereas <code>__dict__</code> simply returns a reference to the namespace of the object, something you probably don't want to mutate, for example...</span>
<span class="comment-copy">OK, this makes sense. I guess I just looking for a "pythonic" way to convert a dataclass into a dictionary, without relying on dunder attributes like <code>__dict__</code>. I guess <code>vars(my_data_class)</code> accomplishes that.</span>
<span class="comment-copy">@ostrokach don't do that. It does't <i>convert to a dict</i> it <i>returns the objects' namespace dict</i>.</span>
<span class="comment-copy">My use-case is <code>df = pd.DataFrame([vars(dc) for dc in dcs])</code>, so a copy is made eventually.  But in general, yes, you are right.</span>
