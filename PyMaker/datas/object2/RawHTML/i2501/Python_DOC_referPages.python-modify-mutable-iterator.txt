<div class="post-text" itemprop="text">
<p>The code is like following:</p>
<pre><code>f=open('test.txt')
file=iter(f)
</code></pre>
<p>When I do</p>
<pre><code>next(file)
</code></pre>
<p>It will print line by line of file.
But when I modified the test.txt file and saved it, the next(file) still printed the original file content.</p>
<p>Does iterator store the complete file in the memory?
If not why the content of the file didn't get updated?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, as an iterator the <code>file</code> object stores only a look-ahead buffer, not the complete file, in memory. This makes it efficient for large files.</p>
<p>Since there is this look-ahead buffer, changes made to the file won't be reflected to the <code>next</code> method. However, you can use the <code>seek</code> method to clear this buffer so the next call to the <code>next</code> method will return the updated content:</p>
<pre><code>f.seek(f.tell()) # seek the current position only to clear the look-ahead buffer
print(next(f)) # prints the updated next line from the current position
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's suppose <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">open()</a> reads 2 letters at a time. (Actual value is <a href="https://docs.python.org/3/library/io.html#io.DEFAULT_BUFFER_SIZE" rel="nofollow noreferrer">io.DEFAULT_BUFFER_SIZE</a>)</p>
<pre><code>f=open('test.txt')
</code></pre>
<p>You've created a file object, <code>_io.TextIOWrapper</code> which, oversimplified, is like <code>[{read from 0 to io.DEFAULT_BUFFER_SIZE of test.txt}, ...}</code></p>
<pre><code>file=iter(f)
</code></pre>
<p>You've created a iterator of <code>_io.TextIOWrapper</code> with data like this: <code>[{read from 0 to 1}, ... {read from n-1 to n}]</code></p>
<pre><code>next(file)
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">next()</a> has went through the first item of <code>file</code>, read it, and printed it.</p>
<h1>Let's learn from an example.</h1>
<h2>Reading normally</h2>
<p><em>test.txt</em></p>
<pre><code>what a beautiful day
</code></pre>
<p>We will open the file, iter(), and list() to open and iter through all of it and make a list.</p>
<pre><code>In [1]: f = open('test.txt')

In [2]: list(iter(f))
Out[2]: ['what a beautiful day']
</code></pre>
<p>Just as expected.</p>
<h2>File changes after <code>open()</code></h2>
<pre><code>In [1]: f = open('test.txt')
</code></pre>
<p>We've opened the file.</p>
<p>We will now append <code>hello open()</code> to test.txt.</p>
<p><em>test.txt</em></p>
<pre><code>what a beautiful day

hello open()
</code></pre>
<p>and then iter() and list() it.</p>
<pre><code>In [2]: list(iter(f))
Out[2]: ['what a beautiful day\n', '\n', 'hello open()']
</code></pre>
<p>The changed contents are seen. We can see that <code>open()</code> does not actually read the file.</p>
<h2>File changes after <code>iter()</code></h2>
<pre><code>In [1]: f = open('test.txt')

In [2]: i = iter(f)
</code></pre>
<p>We've opened the file and <code>iter()</code>d.</p>
<p>We will now append <code>hello iter()</code></p>
<p><em>test.txt</em></p>
<pre><code>what a beautiful day

hello open()

hello iter()
</code></pre>
<p>and then  list() it.</p>
<pre><code>In [3]: list(i)
Out[3]: ['what a beautiful day\n', '\n', 'hello open()\n', '\n', 'hello iter()']
</code></pre>
<p>The changed contents are seen. We can also see that <code>iter()</code> does not actually read the file.</p>
</div>
<span class="comment-copy">No, a file iterator doesnâ€™t store the file content in memory. It stores the position in the file. The file is usually loaded by chunks so it stores a buffer (by default 8192 bytes but it can vary).</span>
<span class="comment-copy">btw, <code>f</code> object itself is an iterator with <code>f.next</code> method (and <code>f.__next__</code> in Python 3.+) ..you do not need to pass it <code>iter(...)</code> function explicitly</span>
<span class="comment-copy">So If my file size is bigger than 8192 bytes buffer size then theoretically if I modified the last line of file, the result will be the new content not the original content?</span>
<span class="comment-copy">Yes, that is what I aware as well. But if that is the case, why modify the physical file content is not affecting the next line ?</span>
<span class="comment-copy">I've updated my answer with an explanation and a solution.</span>
<span class="comment-copy">So If my file size is bigger than 8192 bytes buffer size then theoretically if I modified the last line of file, the result will be the new content not the original content?</span>
<span class="comment-copy">Yes that would be the case.</span>
