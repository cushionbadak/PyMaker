<div class="post-text" itemprop="text">
<p>I'm trying to make changes to an existing python module, and then test it locally. What's the best way to do this?</p>
<p>I cloned the github module and made changes, but I'm not sure how to import the local package instead of the already installed one.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to do such testing would be to create a virtual environment, and then installing the package in <a href="https://pip.pypa.io/en/stable/reference/pip_install/#cmdoption-e" rel="nofollow noreferrer">development mode</a>.</p>
<p>Assuming you are on Linux it would look something like this.</p>
<pre><code>$ virtualenv dev_env
$ source dev_env/bin/activate
$ cd ~/project_folder
$ pip install -e .
</code></pre>
<p>This workflow would not overwrite the already installed package on your system. Other maybe even simpler alternatives would to just use a IDE like <a href="https://www.jetbrains.com/pycharm/" rel="nofollow noreferrer">PyCharm</a> that handles most of this for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way consists in using <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="nofollow noreferrer">sys.path()</a>.<br/>
For example:</p>
<pre><code>import sys
sys.path.insert(0, path/to/module)
</code></pre>
<p>In this way, you give priority to a specific path when looking for a module.<br/>
This means that the module you want to import will be searched first in <code>path/to/module</code> and after in the other directories already in <code>sys.path</code>.</p>
<p>The advantage of this approach is that this new order will hold only inside your script without changing the import order of the other ones. </p>
<p><em>Note</em>: For development purposes you should use a virtualenv as suggested by <a href="https://stackoverflow.com/a/52248649/1359058">@eandersson</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should probably be doing most of your development work in a <a href="https://packaging.python.org/tutorials/installing-packages/#creating-virtual-environments" rel="nofollow noreferrer">virtual environment</a>.  Your workflow for this could look like:</p>
<pre class="lang-sh prettyprint-override"><code># activate the virtual environment in ~/vpy
. $HOME/vpy/bin/activate

# install my app and its dependencies
cd $HOME/src/myapp
pip install -e .

# use my forked library instead
cd $HOME/src/forkedlib
pip install -e .
pytest # or whatever tests the forked lib has

# try it out with my application too
cd $HOME/src/myapp
pytest # or whatever tests your app has
myapp
</code></pre>
<p><code>pip install -e</code> does some magic so that, whenever you <code>import</code> the module in the library, it gets routed directly to the checked-out source tree, so if you make edits in <code>forkedlib</code> and then re-run <code>myapp</code>, you'll see those changes directly.</p>
<p>When you're done, you can <code>pip uninstall forkedlib</code> and then re-run <code>pip install -e .</code> to reinstall your application's (declared) dependencies.  (Or delete and recreate the virtual environment, if that's easier.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The approach of the <a href="https://stackoverflow.com/a/52248555/1536976">answer by abc</a> adding the module path to the system path is fine for local, instant testing, but it's not the full solution, for example when C code needs to be compiled or command line hooks must be set. For a full test you might want to install the package instead.</p>
<p>A typical Python has a <code>setup.py</code> and can be packaged into a distribution file (wheel, ...) which can then be installed locally from a local file.</p>
<p>The workflow would be:</p>
<ul>
<li>create a package distributable (may include a command like <code>python setup.py bdist_wheel</code>)</li>
<li>create a new virtual environment for testing (or de-install any previously installed, non-modified version of the package)</li>
<li>installe the package from the locally created distributable (may be as simple as <code>pip install --no-index --find-links=..</code>)</li>
<li>run the tests</li>
</ul>
<p>This results in exactly the same situation every future user of the package will find itself in and is a complete test (including the installing process), but it's also a lot of effort, that's why I usually only us the system path method during development, but the full installation way only directly before a release.</p>
</div>
<span class="comment-copy">Are you asking how to import your copy while experimenting with/testing your copy, or how to embed it as "vendor code" into your own app so that it uses the embedded copy instead of whatever's installed, or how to install it into your virtualenv/user/system site-packages over the public released version, or…?</span>
<span class="comment-copy">If you run the <code>python</code> command from where to local module source is, that will be loaded first before the global version. You can also create a virtual environment.</span>
<span class="comment-copy">Use a <a href="https://docs.python-guide.org/dev/virtualenvs/" rel="nofollow noreferrer">virtual environment</a></span>
<span class="comment-copy">or you can open a new branch, modify it, then checkout this branch when you want to use it.</span>
<span class="comment-copy">See also <a href="https://stackoverflow.com/questions/15031694/installing-python-packages-from-local-file-system-folder-to-virtualenv-with-pip" title="installing python packages from local file system folder to virtualenv with pip">stackoverflow.com/questions/15031694/…</a></span>
<span class="comment-copy">how do i do this on pycharm?</span>
<span class="comment-copy">You can just import both projects into the same workspace. I technically don't even think you need a virtualenv, but might be good to just create one to be isolated.</span>
<span class="comment-copy">is the path just the path on the file system? "~/project/module" I keep getting error ModuleNotFound</span>
<span class="comment-copy">It depends on its structure. Typically you would have a folder with an <code>__init__.py</code> file in it. with other scripts/folders.</span>
