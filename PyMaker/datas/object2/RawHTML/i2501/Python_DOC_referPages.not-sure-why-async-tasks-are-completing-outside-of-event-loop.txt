<div class="post-text" itemprop="text">
<p>I cannot figure out this behavior. I'm using Python 3.6.4.</p>
<p>In here, I have 4 async functions. In <code>test1</code>, I call <code>asyncio.ensure_future(TestAsync())</code> and turn the coroutine into a task. On the others (<code>test2</code>, <code>test3</code>, <code>test4</code>) I didn't call <code>ensure_future()</code>, I just created the coroutine and passed them into a list and then passed the list into the event loop.</p>
<p>I left <code>test1</code> out of the list I passed into the event loop. So I was under the impression test1 would not run, but in my output, it clearly did. Can someone explain to me why <code>test1</code> still outputed when it wasn't inside the event loop?</p>
<pre><code>import asyncio
import random

async def TestAsync():
    print("Test 1 started")
    wait = random.randint(1, 10)
    await asyncio.sleep(wait)
    print("Test 1 done awaited: " + str(wait))

async def TestAsync2():
    print("Test 2 started")
    wait = random.randint(1, 10)
    await asyncio.sleep(wait)
    print("Test 2 done awaited: " + str(wait))

async def TestAsync3():
    print("Test 3 started")
    wait = random.randint(1, 10)
    await asyncio.sleep(wait)
    print("Test 3 done awaited: " + str(wait))

async def TestAsync4():
    print("Test 4 started")
    wait = random.randint(1, 10)
    await asyncio.sleep(wait)
    print("Test 4 done awaited: " + str(wait))

test1 = asyncio.ensure_future(TestAsync())
test2 = TestAsync2()
test3 = TestAsync3()
test4 = TestAsync4()
tasklist = [test2, test3, test4]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasklist))
</code></pre>
<p>Output</p>
<pre><code>Test 1 started.    &lt;--This is the one wasn't in the event loop
Test 3 started
Test 4 started
Test 2 started
Test 4 done awaited: 1
Test 3 done awaited: 2
Test 1 done awaited: 7
Test 2 done awaited: 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others pointed out, <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer"><code>ensure_future</code></a> will add the task to the default event loop, to run at the next opportunity. <code>ensure_future</code> converts an arbitrary awaitable into an <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future" rel="nofollow noreferrer"><code>asyncio.Future</code></a>, which in case of a coroutine object is accomplished by wrapping it into a <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task" rel="nofollow noreferrer"><code>Task</code></a> (a subclass of <code>Future</code>) with a <a href="https://github.com/python/cpython/blob/3286ce4adee85c5ce8ab3ee3089f3cd44a017fd7/Lib/asyncio/tasks.py#L606" rel="nofollow noreferrer">call</a> to <code>create_task</code>. The task will run the next time the event loop spins regardless of whether the code that calls <code>ensure_future</code> stores a reference to the returned future.</p>
<p>The other important thing to notice is that <code>run_until_complete(x)</code> means "submit <code>x</code> to the event loop and run the loop until <code>x</code> completes", it does nothing to prevent tasks added <strong>before</strong> the call to <code>run_until_complete</code> from running.</p>
<p>In Python 3.7, there is a new function <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run</code></a> that creates a <em>new</em> event loop and submits the given coroutine to it. Replacing <code>asyncio.run_until_complete</code> with <code>asyncio.run</code> would produce the behavior you expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer">the docs for <code>ensure_future</code></a>:</p>
<blockquote>
<p>Schedule the execution of a coroutine object</p>
</blockquote>
<p>When you call <code>ensure_future</code>, the coroutine is schedule and will be eligible to run whenever the event loop is running.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3.6/library/asyncio-task.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Calling a coroutine does not start its code running – the coroutine object returned by the call doesn’t do anything until you schedule its execution. There are two basic ways to start it running: call <code>await coroutine</code> or <code>yield from coroutine</code> from another coroutine (assuming the other coroutine is already running!), or schedule its execution using the <a href="https://docs.python.org/3.6/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer"><code>ensure_future()</code></a> function or the <a href="https://docs.python.org/3.6/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task" rel="nofollow noreferrer"><code>AbstractEventLoop.create_task()</code></a> method.</p>
</blockquote>
<p>As <a href="https://stackoverflow.com/a/52251454/2988730">@dirn's answer</a> implies, <code>ensure_future</code> by itself does not start the task unless there is an event loop already running. However, the subsequent loop kickoff with <a href="https://docs.python.org/3.6/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete" rel="nofollow noreferrer"><code>run_until_complete</code></a> does start the task.</p>
</div>
<span class="comment-copy">So does python implicitly add <code>test1 = asyncio.ensure_future(TestAsync())</code> to the event loop? I guess I'm failing to understand why the task is running. I thought it would only start running when added to the event loop and I would just have an orphaned task.</span>
<span class="comment-copy">@jesse Yes, the task is implicitly added. <code>ensure_future</code> is about converting an arbitrary awaitable into something that implements the <code>Future</code> interface. Given a coroutine object, this is accomplished by <a href="https://github.com/python/cpython/blob/3286ce4adee85c5ce8ab3ee3089f3cd44a017fd7/Lib/asyncio/tasks.py#L606" rel="nofollow noreferrer">calling <code>create_task</code></a> on the default event loop, which adds the task to the loop. In other words, there is no such thing as an orphaned task. An orphaned coroutine, sure, but once it's wrapped into a task, it's always associated with an event loop.</span>
<span class="comment-copy">Thanks for linking me the github to <code>create task</code>. That proved way more useful than I expected. I was really thinking about the event loop wrong the whole time.   I guess where my misunderstanding was I thought <code>get_event_loop</code> was instantiating an event loop object, but the loop was already instantiated. When I was calling <code>get_event_loop</code> it returned already existing loop at that point and adding more tasks to it.</span>
<span class="comment-copy">@jesse Exactly. <code>get_event_loop</code> <b>is</b> instantiating the event loop object the first time it's called, it's just that the first call wasn't where you thought it was, it was hidden in <code>ensure_future</code>.</span>
<span class="comment-copy">It's not <code>get_event_loop</code> that starts the task, it's <code>run_until_complete</code> that spins up the event loop for <i>all</i> tasks, not just the one explicitly given as argument.</span>
<span class="comment-copy">@user4815162342 Thanks. Fixed.</span>
