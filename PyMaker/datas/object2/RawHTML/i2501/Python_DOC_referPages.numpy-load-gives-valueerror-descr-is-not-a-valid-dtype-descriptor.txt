<div class="post-text" itemprop="text">
<p>I have written a <code>npy</code> file in my C++ program using <code>cnpy</code>:</p>
<pre><code>vector &lt; double &gt; vrmsd(max,99.9);
.
.
.
cnpy::npy_save(frmsd,&amp;vrmsd,{nfeat},"w");
</code></pre>
<p>following the example <a href="https://github.com/rogersce/cnpy/blob/master/example1.cpp" rel="nofollow noreferrer">here</a>.</p>
<p>But when I try to load the file using <code>numpy</code> I get an error</p>
<pre><code>y = np.load(frmsd)
</code></pre>
<blockquote>
<p><code>ValueError: descr is not a valid dtype descriptor: '&lt;?24'</code></p>
</blockquote>
<p>Below I paste the result of <code>hexdump -C</code> for a <code>npy</code> file containing a <code>vector&lt;double&gt;</code> of length 2 (should contain 46.950, 43.94):</p>
<pre><code>00000000  93 4e 55 4d 50 59 01 00  46 00 7b 27 64 65 73 63  |.NUMPY..F.{'desc|
00000010  72 27 3a 20 27 3c 3f 32  34 27 2c 20 27 66 6f 72  |r': '&lt;?24', 'for|
00000020  74 72 61 6e 5f 6f 72 64  65 72 27 3a 20 46 61 6c  |tran_order': Fal|
00000030  73 65 2c 20 27 73 68 61  70 65 27 3a 20 28 32 2c  |se, 'shape': (2,|
00000040  29 2c 20 7d 20 20 20 20  20 20 20 20 20 20 20 0a  |), }           .|
00000050  10 4d 1b 02 00 00 00 00  20 4d 1b 02 00 00 00 00  |.M...... M......|
00000060  20 4d 1b 02 00 00 00 00  00 ff 00 00 00 ff 00 00  | M..............|
00000070  c8 33 19 02 00 00 00 00  94 99 90 5b 00 00 00 00  |.3.........[....|
00000080
</code></pre>
<p>This issue has been posted to <code>cnpy</code> github site as well. Just wondering if there is something I can do on the <code>numpy</code> side? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to fix this from the numpy side… Well, you probably don't want to modify numpy to understand non-standard descr strings, and I suspect that even if you treat that descr string as what it seems to be claiming you'd get garbage anyway.  </p>
<p>But you <em>can</em> do a hacky workaround.</p>
<p>If you open the binary file, it should start with something like this:</p>
<pre><code>\x93NUMPY\x01\x00v\x00{'descr': '&lt;?24', 'fortran_order': False, 'shape': (30, 20), }
</code></pre>
<p>… followed by some whitespace ending in a newline before the raw bytes.</p>
<p>You can edit this carefully in a hex editor or text editor, or with Python code that opens the file in binary mode, reads it, does some normal string operations on the bytes, and writes it back out.</p>
<p>In particular, the bit that looks like a Python dict repr really is exactly that, and the values mean exactly what you think they mean. Loading the file ends up trying to create an <code>np.dtype('&lt;?24')</code>, and that's where the error comes from.</p>
<p>If you just edit the <code>descr</code> and <code>shape</code> values, and make sure to keep the dict repr the same length (by padding with whitespace), that will give you something you can <code>load</code>.</p>
<p>So, what does <code>&lt;?24</code> mean? Well, it's not a valid format as specified by  <a href="https://www.python.org/dev/peps/pep-3118/" rel="nofollow noreferrer">PEP 3118</a> and <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow noreferrer"><code>struct</code></a>, but it does fit the pattern of numpy's extensions to that format. For example, in numpy, you can specify <code>f8</code>, meaning "same as <code>f</code> but 8 bytes". So, presumably, this means a 24-byte little-endian version of <code>?</code>, which means <code>_Bool</code> if compiled with C99, <code>char</code> if not, and is meant to be interpreted as <code>bool</code> in Python.</p>
<p>So, if numpy allowed this descr to specify a dtype, what it would mean is that every cell is 24 bytes, interpreted as a little-endian integer interpreted as a bool. Of course numpy doesn't know how to handle integers of any length but 1, 2, 4, or 8 bytes, and it expects bools to be 1 byte, so it isn't allowed. But you could read the same thing as 24 separate bools.</p>
<p>How do you do that? Just change the <code>descr</code> string to <code>'?'</code>, and the <code>shape</code> to <code>(30, 20, 24)</code>, and now you've got a 30x20x24 boolean array, and if you slice <code>[..., 0]</code>, you get a 30x20 boolean array. Or, possibly, <code>'24?'</code> would do that without needing to change the <code>shape</code>.</p>
<p>The problem is, your C++ values are doubles, not bools.</p>
<p>Hopefully, it's just written the doubles in little-endian format with 16 extra 0 bytes after each one. If so, just change the <code>descr</code> to <code>'&lt;f8'</code>, change the <code>shape</code> to <code>(30, 20, 3)</code>, and see what you get. If the first <code>(30, 20)</code> is your desired array, and the other two are all zeros, you're done; just slice it. (And maybe <code>ascontiguous</code> it if you want to cut the memory use.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a bug as per the format of <code>npy_save()</code> arguments on the example you provided.</p>
<p>Instead of,</p>
<pre><code>cnpy::npy_save(frmsd,&amp;vrmsd,{nfeat},"w");
</code></pre>
<p>You want,</p>
<pre><code>cnpy::npy_save(frmsd,&amp;vrmsd[0],{nfeat},"w");
</code></pre>
</div>
<span class="comment-copy">By "something I can do", are you looking for a hacky workaround?</span>
<span class="comment-copy">Well, I'm not above a hacky workaround! Of course it would be best if I could get the file headers to comply with npy standard, but even a hack might give me some insight into whats happening.</span>
<span class="comment-copy">Can you save a much smaller array (say, 4x2), and show us the actual contents of the saved file? It'll be a lot easier to show you how to work on that than to hack up an example.</span>
<span class="comment-copy">Ah yes. will do</span>
<span class="comment-copy">Could you please advise me how to show the contents of the binary file (linux or mac OS)?</span>
<span class="comment-copy">Thanks for your quick reply. The header does indeed contain <code>'descr': '&lt;?24', </code>, but I'm confused about the <code>_Bool</code> part of your answer as the original vector is of type double.</span>
<span class="comment-copy">@DMS <code>?</code> means <code>_Bool</code>. <i>Hopefully</i> the C++ code hasn't actually converted all your doubles to bools and thrown away everything about them other than their nonzeroness. The only way to be sure is to look at the raw bytes part (is it all <code>\x00</code> and <code>\x01</code>, or a wide range of values?), or to just try parsing it as three times as many <code>'&lt;f8'</code> values as you wanted and see if it looks right.</span>
<span class="comment-copy">hexdump -C gives: <code>00000000  93 4e 55 4d 50 59 01 00  46 00 7b 27 64 65 73 63  |.NUMPY..F.{'desc| 00000010  72 27 3a 20 27 3c 3f 32  34 27 2c 20 27 66 6f 72  |r': '&lt;?24', 'for| 00000020  74 72 61 6e 5f 6f 72 64  65 72 27 3a 20 46 61 6c  |tran_order': Fal| 00000030  73 65 2c 20 27 73 68 61  70 65 27 3a 20 28 32 2c  |se, 'shape': (2,| 00000040  29 2c 20 7d 20 20 20 20  20 20 20 20 20 20 20 0a  |), }           .| 00000050  10 3d 8b 01 00 00 00 00  20 3d 8b 01 00 00 00 00  |.=...... =......| 00000060  20 3d 8b 01 00 00 00 00  00 ff 00 00 00 ff 00 00  | =..............|</code></span>
<span class="comment-copy">Hmm thats ugly, but it looks like a range of values.</span>
<span class="comment-copy">Can you <a href="https://stackoverflow.com/posts/52195081/edit">edit</a> that into the question?</span>
