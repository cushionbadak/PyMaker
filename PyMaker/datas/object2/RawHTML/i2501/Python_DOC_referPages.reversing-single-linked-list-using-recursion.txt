<div class="post-text" itemprop="text">
<p>I have made a function that reverses the singly linked list using Recursive method.
However I am having some difficulty executing my below code:</p>
<pre><code>class node:
    def __init__(self,data=None):
        self.next=None
        self.data=data

class linked_list:
    def __init__(self):
        self.head=node()

def append(self,data):
    new_node=node(data)
    cur_node=self.head
    while (cur_node.next!=None):
        cur_node=cur_node.next
    cur_node.next=new_node
    return cur_node.data

def display(self):
    elements=[]
    cur_node=self.head
    while(cur_node.next!=None):
        cur_node=cur_node.next
        elements.append(cur_node.data)
    print(elements)

def reverseRecursive(self,prev_code,cur_node):
    if cur_node.next!=None:
        reverseRecursive(cur_node,cur_node.next)
        cur_node.next=prev_node
    else:
        self.head=cur_node
    return
lst1=linked_list()
lst1.display()
lst1.append(1)
lst1.append(3)
lst1.append(5)
lst1.append(7)
lst1.display()
lst1.reverseRecursive(None,_____)
lst1.display()
</code></pre>
<p>What should I pass the second argument in reverseRecursive function/method so that I can execute it?</p>
<p>As a second argument, I want to simply pass the <strong>head</strong> node of a linked list. But I don't know how to get the head node from the <strong>init method</strong> of  the class <strong>linked_list</strong> </p>
<p>I have tried several things but I'm not able to resolve it. Maybe I am not very good at OOP concepts. Can anyone please help me in resolving this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The linked list is a recursive structure, and so using it with functional style will yield the best results. In your program, you have implemented a linked list using procedural style and <a href="https://en.wikipedia.org/wiki/Immutable_object" rel="nofollow noreferrer">mutable</a> nodes – you change the values of <code>data</code> and <code>next</code> over time. While this might feel like an intuitive approach, I'd like to focus on an <em>immutable</em> discipline that frees us from crippling state complexity.</p>
<p>First, we fix the <code>node</code> constructor function. We set both properties when constructing new nodes because they will not change later in the program –</p>
<pre><code>class node:
  def __init__ (self, data, next):
    self.data = data
    self.next = next
</code></pre>
<p>Then a <code>linked_list</code> is just a single node constructed by a particular convention:</p>
<ul>
<li><code>node.data</code> hold's the node's data</li>
<li><code>node.next</code> is either:

<ul>
<li>another <code>linked_list</code></li>
<li><em>or</em>, <code>None</code>, representing the end of the list</li>
</ul></li>
</ul>
<p>We begin with the constructor for <code>linked_list</code> –</p>
<pre><code>class linked_list:
  def __init__ (self, node = None):
    self.node = node

  # ...
</code></pre>
<p>And implement <code>is_empty</code>, <code>head</code>, and <code>tail</code> <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a> to abstract away <code>node</code> –</p>
<pre><code>class linked_list:
  def __init__ (self, node = None):
    self.node = node

  @property
  def is_empty (self):
    return self.node is None

  @property
  def head (self):
    if self.is_empty:
      raise Exception ("cannot get head of an empty list")
    else:
      return self.node.data

  @property
  def tail (self):
    if self.is_empty:
      raise Exception ("cannot get tail of an empty list")
    else:
      return self.node.next
</code></pre>
<p>Now the use of a <code>node</code> is completely abstracted, and we can write higher level list behaviors by using our new properties –</p>
<pre><code>class linked_list:
  ... 

  def length (self):
    if self.is_empty:
      return 0
    else:
      return 1 + self.tail.length()
</code></pre>
<p>Above, we see it's very easy to talk about our list through use of its properties. Before we go further, let's see how we can construct lists and visualize them using <code>print</code>. For object-to-string conversion, we use <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__</code></a> –</p>
<pre><code>class linked_list:
  ... 

  def add (self, x):
    return linked_list (node (x, self))

  def __str__ (self):
    if self.is_empty:
      return "None"
    else:
      return str (self.head) + " -&gt; " + str (self.tail)

ls = linked_list().add('A').add('B').add('C')
print (ls)
# C -&gt; B -&gt; A -&gt; None

print (ls.length())
# 3
</code></pre>
<p>Remember, because we've built an immutable linked list, <code>add</code> does <em>not</em> change the list it was called upon –</p>
<pre><code>ls = linked_list().add('A').add('B').add('C')
print (ls)
# C -&gt; B -&gt; A -&gt; None

print (ls.add('D'))
# D -&gt; C -&gt; B -&gt; A -&gt; None

print (ls)
# C -&gt; B -&gt; A -&gt; None
</code></pre>
<p>Finally, we can implement <code>reverse</code> –</p>
<pre><code>class linked_list:

  # ...

  def reverse (self):
    def loop (ls, acc):
      if ls.is_empty:
        return acc
      else:
        return loop (ls.tail, acc.add(ls.head))
    return loop (self, linked_list())

ls = linked_list().add('A').add('B').add('C')
print (ls)
# C -&gt; B -&gt; A -&gt; None

print (ls.reverse())
# A -&gt; B -&gt; C -&gt; None
</code></pre>
<p>Reversing the list does not mutate it</p>
<pre><code>print (ls)
# C -&gt; B -&gt; A -&gt; None

print (ls.reverse())
# A -&gt; B -&gt; C -&gt; None

print (ls)
# C -&gt; B -&gt; A -&gt; None
</code></pre>
</div>
<span class="comment-copy">I think it is <code>prev_node</code> and not <code>prev_code</code> and also <code>self.reverseRecursive(....)</code> inside the definition of <code>reverseRecursive</code></span>
<span class="comment-copy">You have <b>indentation errors</b>! You don't have to pass a <code>class member</code> to a <code>class method</code>. Simply use <code>cur_node = self.head</code> on top of <code>def reverseRecursive</code>.</span>
