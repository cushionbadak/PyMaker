<div class="post-text" itemprop="text">
<p>Suppose I have a Python function as defined below:</p>
<pre><code>def foo(arg1,arg2):
    #do something with args
    a = arg1 + arg2
    return a
</code></pre>
<p>I can get the name of the function using <code>foo.func_name</code>. How can I programmatically get its source code, as I typed above?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the function is from a source file available on the filesystem, then <a href="https://docs.python.org/3/library/inspect.html#inspect.getsource" rel="noreferrer"><code>inspect.getsource(foo)</code></a> might be of help:</p>
<p>If <code>foo</code> is defined as:</p>
<pre><code>def foo(arg1,arg2):         
    #do something with args 
    a = arg1 + arg2         
    return a  
</code></pre>
<p>Then:      </p>
<pre><code>import inspect
lines = inspect.getsource(foo)
print(lines)
</code></pre>
<p>Returns:    </p>
<pre><code>def foo(arg1,arg2):         
    #do something with args 
    a = arg1 + arg2         
    return a                
</code></pre>
<p>But I believe that if the function is compiled from a string, stream or imported from a compiled file, then you cannot retrieve its source code.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/library/inspect.html?highlight=inspect#retrieving-source-code" rel="noreferrer">inspect module</a> has methods for retrieving source code from python objects. Seemingly it only works if the source is located in a file though. If you had that I guess you wouldn't need to get the source from the object.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dis</code> is your friend if the source code is not available:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo(arg1,arg2):
...     #do something with args
...     a = arg1 + arg2
...     return a
...
&gt;&gt;&gt; dis.dis(foo)
  3           0 LOAD_FAST                0 (arg1)
              3 LOAD_FAST                1 (arg2)
              6 BINARY_ADD
              7 STORE_FAST               2 (a)

  4          10 LOAD_FAST                2 (a)
             13 RETURN_VALUE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using IPython, then you need to type "foo??"</p>
<pre><code>In [19]: foo??
Signature: foo(arg1, arg2)
Source:
def foo(arg1,arg2):
    #do something with args
    a = arg1 + arg2
    return a

File:      ~/Desktop/&lt;ipython-input-18-3174e3126506&gt;
Type:      function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While I'd generally agree that <code>inspect</code> is a good answer, I'd disagree that you can't get the source code of objects defined in the interpreter.  If you use <code>dill.source.getsource</code> from <a href="https://github.com/uqfoundation/dill" rel="noreferrer"><code>dill</code></a>, you can get the source of functions and lambdas, even if they are defined interactively.
It also can get the code for from bound or unbound class methods and functions defined in curries... however, you might not be able to compile that code without the enclosing object's code.</p>
<pre><code>&gt;&gt;&gt; from dill.source import getsource
&gt;&gt;&gt; 
&gt;&gt;&gt; def add(x,y):
...   return x+y
... 
&gt;&gt;&gt; squared = lambda x:x**2
&gt;&gt;&gt; 
&gt;&gt;&gt; print getsource(add)
def add(x,y):
  return x+y

&gt;&gt;&gt; print getsource(squared)
squared = lambda x:x**2

&gt;&gt;&gt; 
&gt;&gt;&gt; class Foo(object):
...   def bar(self, x):
...     return x*x+x
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; 
&gt;&gt;&gt; print getsource(f.bar)
def bar(self, x):
    return x*x+x

&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To expand on runeh's answer:</p>
<pre><code>&gt;&gt;&gt; def foo(a):
...    x = 2
...    return x + a

&gt;&gt;&gt; import inspect

&gt;&gt;&gt; inspect.getsource(foo)
u'def foo(a):\n    x = 2\n    return x + a\n'

print inspect.getsource(foo)
def foo(a):
   x = 2
   return x + a
</code></pre>
<p>EDIT: As pointed out by @0sh this example works using <code>ipython</code> but not plain <code>python</code>. It should be fine in both, however, when importing code from source files.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>inspect</code> module to get full source code for that. You have to use <code>getsource()</code> method for that from the <code>inspect</code> module. For example:</p>
<pre><code>import inspect

def get_my_code():
    x = "abcd"
    return x

print(inspect.getsource(get_my_code))
</code></pre>
<p>You can check it out more options on the below link.
<a href="https://docs.python.org/2/library/inspect.html#retrieving-source-code" rel="noreferrer">retrieve your python code</a></p>
</div>
<div class="post-text" itemprop="text">
<p>to summarize :</p>
<pre><code>import inspect
print( "".join(inspect.getsourcelines(foo)[0]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're strictly defining the function yourself and it's a relatively short definition, a solution without dependencies would be to define the function in a string and assign the eval() of the expression to your function. </p>
<p>E.g. </p>
<pre><code>funcstring = 'lambda x: x&gt; 5'
func = eval(funcstring)
</code></pre>
<p>then optionally to attach the original code to the function: </p>
<pre><code>func.source = funcstring
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please mind that the accepted answers work only if the lambda is given on a separate line. If you pass it in as an argument to a function and would like to retrieve the code of the lambda as object, the problem gets a bit tricky since <code>inspect</code> will give you the whole line.</p>
<p>For example, consider a file <code>test.py</code>:</p>
<pre><code>import inspect

def main():
    x, f = 3, lambda a: a + 1
    print(inspect.getsource(f))

if __name__ == "__main__":
    main()
</code></pre>
<p>Executing it gives you (mind the indention!):</p>
<pre><code>    x, f = 3, lambda a: a + 1
</code></pre>
<p>To retrieve the source code of the lambda, your best bet, in my opinion, is to re-parse the whole source file (by using <code>f.__code__.co_filename</code>) and match the lambda AST node by the line number and its context.</p>
<p>We had to do precisely that in our design-by-contract library <a href="https://github.com/Parquery/icontract" rel="nofollow noreferrer">icontract</a> since we had to parse the lambda functions we pass in as arguments to decorators. It is too much code to paste here, so have a look at <a href="https://github.com/Parquery/icontract/blob/6fb85fe00e91a0b27369a543642d071feb7740d6/icontract/represent.py#L157" rel="nofollow noreferrer">the implementation of this function</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I <em>believe</em> that variable names aren't stored in pyc/pyd/pyo files, so you can not retrieve the exact code lines if you don't have source files.</p>
</div>
<span class="comment-copy">I don't get your question. Could you please clarify the sentence "how can i get" and solve the confusion about "func_name" and "somemethod"? Thanks!</span>
<span class="comment-copy">Duplicate: <a href="http://stackoverflow.com/questions/334851/print-the-code-which-defined-a-lambda-function" title="print the code which defined a lambda function">stackoverflow.com/questions/334851/…</a>, <a href="http://stackoverflow.com/questions/399991/python-how-do-you-get-python-to-write-down-the-code-of-a-function-it-has-in-memo" title="python how do you get python to write down the code of a function it has in memo">stackoverflow.com/questions/399991/…</a></span>
<span class="comment-copy">Note, in Python 3 you can get the function name using <code>foo.__name__</code></span>
<span class="comment-copy">You can get a <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">lot of other things</a> as well.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/inspect.html#inspect.getsourcelines" rel="nofollow noreferrer">Returns</a> a tuple; tuple[0] is list of strings representing the lines of source code, and tuple[1] is the line number in the context of execution where it was run. In IPython; this is the line number within the <i>cell</i> not the overall <i>notebook</i></span>
<span class="comment-copy">This answer doesn't explicitly mention it, but inspect.getsource(foo) returns the source in a single string instead of a tuple where tuple[0] is a list of the lines.   getsource will be more useful if you need to peek in the repl</span>
<span class="comment-copy">it doesn't work with e.g. the function <code>len</code>. Where can I find the source code for the <code>len</code> function?</span>
<span class="comment-copy">Does not seem to work in idle.</span>
<span class="comment-copy">or <code>inspect.getsourcelines(foo)</code></span>
<span class="comment-copy">Yes, it seems to work only for objects defined in a file. Not for those defined in interpreter.</span>
<span class="comment-copy">to my surprise, it works in Ipython/Jupyter notebooks also</span>
<span class="comment-copy">I tried using inspect in a <code>python 3.5.3</code> interpreter. <code>import inspect</code> + <code>inspect.getsource(foo)</code> worked fine.</span>
<span class="comment-copy">@AndréChristofferAndersen Yeah but it shouldn't work for functions defined in the interpreter</span>
<span class="comment-copy">Throws a TypeError for builtins.</span>
<span class="comment-copy">@Noumenon because they have usually no source code in Python, they are written in C</span>
<span class="comment-copy">good luck displaying that info as a QToolTip() ;)</span>
<span class="comment-copy">Very helpful in IPython and Jupyter notebook if/when you accidentally delete more than one cell that contains functions you've just spent the day creating and testing....</span>
<span class="comment-copy">doesn't seem to work with functions defined inside an <code>exec</code></span>
<span class="comment-copy">@Ant6n: well, that's just being sneaky.  <code>dill.source.getsource</code> inspects the interpreter's history for functions, classes, lambdas, etc -- it doesn't inspect the content of strings passed to exec.</span>
<span class="comment-copy">This seems very interesting. Is it possible to use <code>dill</code> to answer this question: <a href="http://stackoverflow.com/questions/13827543/is-there-anyway-to-get-the-names-of-passed-arguments-to-a-function-in-python" title="is there anyway to get the names of passed arguments to a function in python">stackoverflow.com/questions/13827543/…</a></span>
<span class="comment-copy">@ArtOfWarfare: partially, yes.  <code>dill.source</code> has functions like <code>getname</code> and <code>importable</code> and <code>getsource</code> that focus on getting the source code (or an importable that yields the object) for any given object.  For simple things like an <code>int</code> there is <i>no</i> source, so it doesn't work as expected (i.e. for 'a = 10' it returns '10').</span>
<span class="comment-copy">This does work for globals however:  <code>&gt;&gt;&gt; a = 10; print( [key for key, val in globals().items() if val is a][0] ) </code></span>
<span class="comment-copy">This won't work, since the interpreter would compile foo to bytecode and throw away the source code, raising an OSError if you try running <code>getsource(foo)</code>.</span>
<span class="comment-copy">@0sh good point as far as the vanilla python interpreter is concerned. However the above code example works when using IPython.</span>
<span class="comment-copy">The use of eval() strikes me as being really, REALLY bad, unless you're writing some kind of interactive Python interpreter. Eval opens up drastic security problems. If you adopt a policy of only eval'ing string literals, you still lose out on a variety of helpful behavior, ranging from syntax highlighting to proper reflection of classes which contain eval'ed members.</span>
<span class="comment-copy">Upvoting. @mehaase: security is obviously not an issue here. Your other comments though are quite relevant, though I'd say lack of syntax highlighting is a combination of the fault of the IDE and the fact that python is not a homoiconic language.</span>
<span class="comment-copy">@ninjagecko Security is always an issue when you're giving advice to the general public. Most readers are coming here because they are googling questions. I don't think many people are going to copy this answer verbatim; instead, they are going to take the concept they learned and apply it to their own problem.</span>
