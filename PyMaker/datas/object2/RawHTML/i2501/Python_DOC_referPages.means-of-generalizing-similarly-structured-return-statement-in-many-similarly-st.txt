<div class="post-text" itemprop="text">
<p>I have a little mathematics-practicing application in which, to add new problems, I just define a new function which returns some dictionaries like this: </p>
<pre><code>def p4():
    vertices = random.randrange(1, 8)
    num_trees = random.randrange(2, 4)
    format_dict = {
        'vertices': vertices,
        'num_trees': num_trees
    }

    answer_dict = {
        'answer': vertices*num_trees, 
        'wrong_1': 0,
        'wrong_2': 1,
        'wrong_3': 'There do not exist any'
    }

    return {'question': format_dict, 'answers': answer_dict}
</code></pre>
<p>Just for some context, this is a Django app. where the text of each problem is stored in a model, and, when the user looks at the problem on the webpage, the text of the model is formatted according to <code>format_dict</code> and the multiple-choice answers are generated according to <code>answer_dict</code>.</p>
<p>Now, <em>every</em> problem, defined above, has the line <code>return {'question': format_dict, 'answer': answer_dict}</code>. Is there a way I can call a function like this, with these two dictionaries, and have the same functionality while omitting the return? I feel as if—if every function needs to have that line—then there's something I can do to generalize it (... A decorator, maybe? I've never used one, but now may be a good excuse).</p>
<hr/>
<p>The model method which processes the dictionaries looks like this: </p>
<pre><code>def gen_QAPair(self):
        # The name/location of the problem's function is stored in 'module'
        module = importlib.import_module(self.QAModule) 
        # This calls the function (p4, for example) and gets the dictionaries
        qaPair = getattr(module, self.QAFunction)()
        # This takes the unformatted text and formats it according to 
        # the returned format dictionary
        formatted_text = self.unformatted_text.format(**qaPair['question'])

        return {'question': formatted_text, 'answers': qaPair['answers']}
</code></pre>
<p>The only thing I could think of was combining <code>answer_dict</code> and <code>format_dict</code> into a dictionary of dictionaries, and returning that—but it wouldn't really save much code, it'd just move defining the keys outside of the return statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>I see two options.</p>
<p>First, you want to generalize that all problem functions return something of the form <code>{'question': format_dict, 'answer': answer_dict}</code>. You can represent this as a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>, or if you have Python 3.7, a <a href="https://realpython.com/python-data-classes/" rel="nofollow noreferrer">data class</a>.</p>
<p>Named tuple example:</p>
<pre><code>from collections import namedtuple
ProblemData = namedtuple('ProblemData', ['question', 'answer'])

def q_n():
    # ...
    return ProblemData(format_dict, answer_dict)
</code></pre>
<p>This solves the problem of the generalizing the structure somewhat, but you still have the return.</p>
<p>A much more general and more difficult approach would be to store each question in a configuration file. Of course, you would have to write some small language and parser to have the dynamic sort of data that you want, but I imagine if you scale up to thousands of questions it would be worth the effort.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to make it a little less verbose:</p>
<pre><code>def p4():
    vertices = random.randrange(1, 8)
    num_trees = random.randrange(2, 4)
    return dict(
        question = {
            'vertices': vertices,
            'num_trees': num_trees
        },
        answer = {
            'answer': vertices*num_trees, 
            'wrong_1': 0,
            'wrong_2': 1,
            'wrong_3': 'There do not exist any'
        }
    )
</code></pre>
<p>(I note you have a discrepancy between "answer" and "answers" in your examples.)</p>
<p>Another option is to return a tuple, and unpack the tuple in your gen_QAPair() function:</p>
<pre><code>return ({
        'vertices': vertices,
        'num_trees': num_trees
    },
    {
        'answer': vertices*num_trees, 
        'wrong_1': 0,
        'wrong_2': 1,
        'wrong_3': 'There do not exist any'
    })
</code></pre>
<p>...then...</p>
<pre><code>question, answer = getattr(module, self.QAFunction)()
</code></pre>
</div>
<span class="comment-copy">Tho, I Cannot Say This Is Best Approach But Adding Your Two Dicts To A List Will Simplify Some Work And Make It Easily Readble</span>
<span class="comment-copy">What's With All The Caps?</span>
<span class="comment-copy">I like (and have just implemented) this idea. I'll accept this as the answer if I can't think of a good way to get rid of the return statements. Is there a way to access function attributes outside of the function w/o the function explicitly returning something? This way, I could write a decorator that returns the tuple of function attributes, and just put <code>@decorator</code> above each function definition</span>
<span class="comment-copy">@AmagicalFishy I don't believe so</span>
<span class="comment-copy">Ah, well. If you don't mind, what would be the benefits of the configuration file method? I thought of that originally, but this seemed a lot easier (according to your answer, it <i>is</i> a lot easier!)</span>
<span class="comment-copy">Code/data separation, mostly. If you ever need to do something like get a list of all your questions, Python does give you tools to do that, but it can be rather awkward. Flat files are simpler to organize, etc. But if you never get to the point where having them as functions frustrates you, then probably no use worrying about it. :)</span>
<span class="comment-copy">Ah, aweosme. Thanks. :D Also, with Django (and it's <i>god damned</i> nifty database stuff), it's pretty easy to do things like get a list of all questions. I've even got them tagged so I can say something like <code>problems = Problem.objects.filter(tag='calculus')</code></span>
<span class="comment-copy">That discrepancy is purposeful! The <code>answer</code> is the <i>actual</i>, correct answers, and the dictionary, <code>answers</code>, is a dictionary of multiple answers (correct and incorrect) to be shown in the multiple-choice screen.</span>
<span class="comment-copy">I mean you <code>return {'question': format_dict, 'answer': answer_dict}</code> but look up <code>qaPair['answers']</code> in gen_QAPair. (It doesn't affect what I suggested, except that with tuples you don't have to worry about the names matching at all.)</span>
<span class="comment-copy">Right, but note that <code>gen_QAPair</code> calls the function <code>p4()</code> (which returns a dictionary w/ keys <code>question</code> and <code>answers</code>)</span>
<span class="comment-copy">Except in the code you posted p4() actually returns a dictionary with keys <code>question</code> and <code>answer</code> (singular).</span>
