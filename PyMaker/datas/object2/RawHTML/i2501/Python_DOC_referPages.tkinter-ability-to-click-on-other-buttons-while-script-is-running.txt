<div class="post-text" itemprop="text">
<p>I have a simple Tkinter gui with about 20 buttons on it. When I click on a button, the script runs for about 5 minutes. During which time, I have to wait until the script stops running to click on the other buttons. Is there a way to setup the window so I can click on other button while the first clicked script is running?</p>
<pre><code>from Tkinter import *
import Tkinter as tk
import time

def function1():
    time.sleep(60)
    print 'function1'


def function2():
    time.sleep(60)
    print 'function2'

root = Tk()

w = 450 # width for the Tk root
h = 500# height for the Tk root

frame = Frame(root, width=w,height =h)
button1=Button(frame, text = 'function 1',fg='black',command=function1).grid(row=1,column=1) 
button2=Button(frame, text = 'function 2',fg='black',command=function2).grid(row=1,column=2) 

frame.pack()
root.mainloop()
</code></pre>
<p>I want to be able to click on <code>function2</code> after while <code>function1</code> is still running</p>
</div>
<div class="post-text" itemprop="text">
<p>If you trigger a callback that takes 1 minute to run, you're not returning to the main loop for 1 minute, so the GUI can't respond to anything.</p>
<p>There are two common solutions to this.</p>
<hr/>
<p>The first is to use a background thread:</p>
<pre><code>def function1():
    time.sleep(60)
    print 'function1'

def function1_background():
    t = threading.Thread(target=function1)
    t.start()

button1 = Button(frame, text='function 1', fg='black', command=function1_background)
</code></pre>
<p>This is simple, but it only works when your code is purely doing background work, not touching any of the tkinter widgets.</p>
<hr/>
<p>The only problem here is that you'd have to <code>def</code> 20 extra functions. You don't want to repeat yourself that much—that's 80 lines of repetitive boilerplate code that gets in the way of seeing the code that matters, and 20 chances to make a stupid bug in copy-pasting that's a pain to track down, and 20 places you have to change if you later decide you want, say, processes instead of threads so the work can parallelize better, or a pool of 4 threads with the background tasks queued up.</p>
<p>You can solve that in a few different ways. See <a href="https://stackoverflow.com/questions/6920302/">this question</a> for more in-depth explanation, but in short, you get Python to do some of the repetitive work for you.</p>
<hr/>
<p>You can <code>def</code> a single helper function:</p>
<pre><code>def background(func):
    t = threading.Thread(target=func)
    t.start()
</code></pre>
<p>… and then <code>lambda</code> 20 separate function:</p>
<pre><code>button1 = Button(frame, text='function 1', fg='black', command=lambda: background(function1))
</code></pre>
<hr/>
<p>Alternatively, you can partially apply the function using <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>partial</code></a>:</p>
<pre><code>button1 = Button(frame, text='function 1', fg='black', command=functools.partial(background, function1))
</code></pre>
<hr/>
<p>Or, if you never want to call the functions except in the background, you can write a decorator and apply it to each function at <code>def</code> time:</p>
<pre><code>def background(func):
    @functools.wraps(func)
    def wrapper():
        t = threading.Thread(target=func)
        t.start()
    return wrapper

@background
def function1():
    time.sleep(60)
    print 'function1'
</code></pre>
<hr/>
<p>If you can't use threads (e.g., because the background work involves fiddling with your tkinter widgets), the alternative is to restructure your code so that, instead of being one monolithic task that takes 1 minute, it's a bunch of separate tasks that each takes a fraction of a second and schedules the next part:</p>
<pre><code>def function1(count=60):
    if count &gt; 0:
        time.sleep(0.1)
        frame.after(0, function1, count-0.1)
    else:
        print 'function1'

button1 = Button(frame, text='function 1', fg='black', command=function1)
</code></pre>
<p>This always works, if you can find a way to do it. Your real work may not be as easy to divide into 0.1-second chunks as a <code>sleep(60)</code> is.</p>
</div>
<span class="comment-copy">Could you maybe state your code in your question? It isn't clear <i>how</i> you want your code to run.</span>
<span class="comment-copy">As a side note, when you do <code>button1 = Button(…).grid(…)</code>, you're just assigning <code>None</code> to <code>button1</code>, not the <code>Button</code> object. The <code>grid</code> method doesn't return anything. You need two statements, <code>button1 = Button(…)</code>, and then a separate <code>button1.grid(…)</code>.</span>
<span class="comment-copy">Yeah you are right. I can't split the other functions into increments. But the first suggestion sounds promising. However since I have about 20 buttons I would have to create 20 of these <code>_background</code> functions. Is there a way to create a general function to run all 20 through? Can you show me how to generalize for just these two functions?</span>
<span class="comment-copy">It doesn't seem to work when I pass it through like this <code>def function1_background(function_name):</code> then <code>t = threading.Thread(target=function_name)</code></span>
<span class="comment-copy">@jason That will work to define a general backgrounding function, but then you have to set the <code>command</code> right. I’ll edit to show you how to do that.</span>
<span class="comment-copy">This is incredibly thorough. Thanks</span>
<span class="comment-copy">@abarnert. I see my mistake. I was passing it as <code>background(lambda: ...)</code> so it was initiating before I pressed the button.</span>
