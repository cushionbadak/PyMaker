<div class="post-text" itemprop="text">
<p>Since this question is about inheritance and <code>super</code>, let's begin by writing a class. Here's a simple everyday class that represents a person:</p>
<pre><code>class Person:
    def __init__(self, name):
        super().__init__()

        self.name = name
</code></pre>
<p>Like every good class should, it calls its parent constructor before initializing itself. And this class does its job perfectly well; it can be used with no problems:</p>
<pre><code>&gt;&gt;&gt; Person('Tom')
&lt;__main__.Person object at 0x7f34eb54bf60&gt;
</code></pre>
<p>But when I try to make a class that inherits from both <code>Person</code> and another class, things suddenly go wrong:</p>
<pre><code>class Horse:
    def __init__(self, fur_color):
        super().__init__()

        self.fur_color = fur_color

class Centaur(Person, Horse):
    def __init__(self, name, fur_color):
        # ??? now what?
        super().__init__(name)  # throws TypeError: __init__() missing 1 required positional argument: 'fur_color'
        Person.__init__(self, name)  # throws the same error
</code></pre>
<p>Because of diamond inheritance (with the <code>object</code> class at the top), it's not possible to initialize <code>Centaur</code> instances correctly. The <code>super().__init__()</code> in <code>Person</code> ends up calling <code>Horse.__init__</code>, which throws an exception because the <code>fur_color</code> argument is missing.</p>
<p>But this problem wouldn't exist if <code>Person</code> and <code>Horse</code> didn't call <code>super().__init__()</code>.</p>
<p>This raises the question: <strong>Should classes that inherit directly from <code>object</code> call <code>super().__init__()</code>? If yes, how would you correctly initialize <code>Centaur</code>?</strong></p>
<hr/>
<p>Disclaimer: I know <a href="https://stackoverflow.com/questions/222877/what-does-super-do-in-python">what <code>super</code> does</a>, how the <a href="https://docs.python.org/3/glossary.html#term-method-resolution-order" rel="nofollow noreferrer">MRO</a> works, and <a href="https://stackoverflow.com/q/3277367/1222951">how <code>super</code> interacts with multiple inheritance</a>. I understand what's causing this error. I just don't know what the correct way to avoid the error is.</p>
<hr/>
<p>Why am I asking specifically about <code>object</code> even though diamond inheritance can occur with other classes as well? That's because <code>object</code> has a special place in python's type hierarchy - it sits at the top of your MRO whether you like it or not. Usually diamond inheritance happens only when you <strong>deliberately</strong> inherit from a certain base class for the goal of achieving a certain goal related to that class. In that case, diamond inheritance is to be expected. But if the class at the top of the diamond is <code>object</code>, chances are that your two parent classes are completely unrelated and have two completely different interfaces, so there's a higher chance of things going wrong.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Should classes that inherit directly from <code>object</code> call <code>super().__init__()</code>?</p>
</blockquote>
<p>You seem to search a simple "yes or no" answer for this question, but unfortunately the answer is "it depends". Furthermore, when deciding if you should call <code>super().__init__()</code>, it is somewhat irrelevant whether or not a class inherits directly from <code>object</code>. What is invariant is that, if <code>object.__init__</code> is called, it should be called without arguments - since <code>object.__init__</code> does not accept arguments. </p>
<p>Practically, in cooperative inheritance situations, this means you must ensure that all arguments are <em>consumed</em> before <code>object.__init__</code> gets invoked. It does <em>not</em> mean you should try to avoid <code>object.__init__</code> being invoked. <a href="https://github.com/requests/requests/blob/943a5c8e89db1758ae24adbbedacb3b05c32df4a/requests/exceptions.py#L19-L21" rel="noreferrer">Here</a> is an example of consuming args before invoking <code>super</code>, the <code>response</code> and <code>request</code> context has been popped out of the mutable mapping <code>kwargs</code>.</p>
<p>I mentioned earlier that whether or not a class inherits directly from <code>object</code> is a red herring<sup>1</sup>. But I didn't mention yet what should motivate this design decision: You should call super init [read: super <code>anymethod</code>] if you want the MRO to continue to be searched for other initializers [read: other <code>anymethod</code>s]. You should not invoke super if you want to indicate the MRO search should be stopped here.</p>
<p>Why does <code>object.__init__</code> exist at all, if it doesn't do anything? Because it <em>does</em> do something: <em>ensures it was called without arguments</em>. The presence of arguments likely indicates a bug<sup>2</sup>. <code>object</code> also serves the purpose of stopping the chain of super calls - <em>somebody</em> has to not call super, otherwise we recurse infinitely. You can stop it explicitly yourself, earlier, by not invoking super. If you don't, <code>object</code> will serve as the final link and stop the chain for you.</p>
<p>Class MRO is determined at compile time, which is generally when a class is defined / when the module is imported. However, note that the use of <code>super</code> involves many chances for <em>runtime</em> branching. You have to consider:</p>
<ul>
<li>Which arguments a method of the <code>super</code> is called with (i.e. which arguments you want to forward along the MRO)</li>
<li>Whether or not super is called at all (sometimes you want to intentionally break the chain)</li>
<li>Which arguments, if any, the <code>super</code> <em>itself</em> is created with (there is an advanced use case described below)</li>
<li>Whether to call a proxied method <em>before</em> or <em>after</em> the code in your own method (put super first if need to access some state the proxied methods set up, put super last if you're setting up some state that the proxied methods rely on being there already - in some cases you even want to put super in the middle somewhere!)</li>
<li>The question asks mostly about <code>__init__</code>, but don't forget that super can be used with any other method, too</li>
</ul>
<p>In rare circumstances, you might conditionally invoke a <code>super</code> call. You might check whether your <code>super()</code> instance has this or that attribute, and base some logic around the result. Or, you might invoke <code>super(OtherClass, self)</code> to explicitly "step over" a link and manually traverse the MRO for this section. Yes, if the default behaviour is not what you wanted, you can hijack the MRO! What all these diabolical ideas have in common is an understanding of the <a href="https://en.wikipedia.org/wiki/C3_linearization" rel="noreferrer">C3 linearization</a> algorithm, how Python makes an MRO, and how super itself uses the MRO. Python's implementation was more or less lifted from <a href="https://en.wikipedia.org/wiki/Dylan_(programming_language)" rel="noreferrer">another programming language</a>, where super was named <a href="https://opendylan.org/documentation/intro-dylan/objects.html" rel="noreferrer"><code>next-method</code></a>. Honestly <code>super</code> is a super-bad name in Python because it causes a common misconception amongst beginners that you're always invoking "up" to one of the parent classes, I wish they had chosen a better name.</p>
<p>When defining an inheritance hierarchy, the interpreter can not know whether you wanted to <em>reuse</em> some other classes existing functionality or to <em>replace</em> it with an alternate implementation, or something else. Either decision could be a valid and practical design. If there was a hard and fast rule about when and how <code>super</code> should be invoked, it would not be left to the programmer to choose - the language would take the decision out of your hands and just do the right thing automatically. I hope that sufficiently explains that invoking super in <code>__init__</code> is not a simple yes/no question.</p>
<blockquote>
<p>If yes, how would you correctly initialize <code>SuperFoo</code>?</p>
</blockquote>
<p><sub>(Source for <code>Foo</code>, <code>SuperFoo</code> etc in <a href="https://stackoverflow.com/revisions/63340da2-7e93-4c21-9cd0-f39a051e4b1a/view-source">this revision</a> of the question)</sub></p>
<p>For the purposes of answering this part, I will assume the <code>__init__</code> methods shown in the MCVE actually need to do some initialization (perhaps you could add placeholder comments in the question's MCVE code to that effect). Don't define an <code>__init__</code> at all if the only you do is call super with same arguments, there's no point. Don't define an <code>__init__</code> that's just <code>pass</code>, unless you intentionally mean to halt the MRO traversal there (in which case a comment is certainly warranted!).</p>
<p>Firstly, before we discuss the <code>SuperFoo</code>, let me say that <code>NoSuperFoo</code> looks like an incomplete or bad design. How do you pass the <code>foo</code> argument to <code>Foo</code>'s init? The <code>foo</code> init value of <code>3</code> was hardcoded. It might be OK to hardcode (or otherwise automatically determine) foo's init value, but then <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noreferrer">you should probably be doing composition not inheritance</a>.</p>
<p>As for <code>SuperFoo</code>, it inherits <code>SuperCls</code> and <code>Foo</code>. <code>SuperCls</code> looks intended for inheritance, <code>Foo</code> does not. That means you may have some work to do, as pointed out in <a href="https://fuhm.net/super-harmful/" rel="noreferrer">super harmful</a>. One way forward, <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noreferrer">as discussed in Raymond's blog</a>, is writing adapters.</p>
<pre><code>class FooAdapter:
    def __init__(self, **kwargs):
        foo_arg = kwargs.pop('foo')  
        # can also use kwargs['foo'] if you want to leave the responsibility to remove 'foo' to someone else
        # can also use kwargs.pop('foo', 'foo-default') if you want to make this an optional argument
        # can also use kwargs.get('foo', 'foo-default') if you want both of the above
        self._the_foo_instance = Foo(foo_arg)
        super().__init__(**kwargs)

    # add any methods, wrappers, or attribute access you need

    @property
    def foo():
        # or however you choose to expose Foo functionality via the adapter
        return self._the_foo_instance.foo
</code></pre>
<p>Note that <code>FooAdapter</code> <em>has a</em> <code>Foo</code>, not <code>FooAdapter</code> <em>is a</em> <code>Foo</code>. This is not the only possible design choice. However, if you are inheriting like <code>class FooParent(Foo)</code>, then you're implying a <code>FooParent</code> <em>is a</em> <code>Foo</code>, and can be used in any place where a <code>Foo</code> would otherwise be - it's often easier to avoid violations of <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">LSP</a> by using composition.  <code>SuperCls</code> should also cooperate by allowing <code>**kwargs</code>:</p>
<pre><code>class SuperCls:
    def __init__(self, **kwargs):
        # some other init code here
        super().__init__(**kwargs)
</code></pre>
<p>Maybe <code>SuperCls</code> is also out of your control and you have to adapt it too, so be it. The point is, this is a way to re-use code, by adjusting the interfaces so that the signatures are matching. Assuming everyone is cooperating well and consuming what they need, eventually <code>super().__init__(**kwargs)</code> will proxy to <code>object.__init__(**{})</code>.</p>
<blockquote>
<p>Since 99% of classes I've seen don't use <code>**kwargs</code> in their constructor, does that mean 99% of python classes are implemented incorrectly?</p>
</blockquote>
<p>No, because <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" rel="noreferrer">YAGNI</a>. Do 99% of classes need to immediately support 100% general dependency-injection with all the bells and whistles, before they are useful? Are they broken if they don't? As an example, consider the <a href="https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes" rel="noreferrer"><code>OrderedCounter</code></a> recipe given in the collections docs. <a href="https://github.com/python/cpython/blob/998b80636690ffbdb0a278810d9c031fad38631d/Lib/collections/__init__.py#L548" rel="noreferrer"><code>Counter.__init__</code></a> accepts <code>*args</code> and <code>**kwargs</code>, but <a href="https://github.com/python/cpython/blob/998b80636690ffbdb0a278810d9c031fad38631d/Lib/collections/__init__.py#L565" rel="noreferrer">doesn't proxy them in the super init call</a>. If you wanted to use one of those arguments, well tough luck, you've got to override <code>__init__</code> and intercept them. <a href="https://github.com/python/cpython/blob/d13e59c1b512069d90efe7ee9b613d3913e79c56/Lib/collections/__init__.py#L96" rel="noreferrer"><code>OrderedDict</code></a> isn't defined cooperatively at all, really, some <a href="https://github.com/python/cpython/blob/d13e59c1b512069d90efe7ee9b613d3913e79c56/Lib/collections/__init__.py#L116" rel="noreferrer">parent calls are hardcoded</a> to <code>dict</code> - and the <code>__init__</code> of anything next in line isn't invoked, so any MRO traversal would be stopped in its tracks there. If you accidentally defined it as <code>OrderedCounter(OrderedDict, Counter)</code> instead of <code>OrderedCounter(Counter, OrderedDict)</code> the metaclass bases would still be able to create a consistent MRO, but the class just wouldn't work at all as an ordered counter.</p>
<p>In spite of all these shortcomings, the <code>OrderedCounter</code> recipe works as advertised, because the MRO is traversed as designed for the intended use-case. So, you don't even need to do cooperative inheritance 100% correctly in order to implement a dependency-injection. The moral of the story is that <em>perfection is the enemy of progress</em> (or, <a href="https://github.com/python/cpython/blob/acd282fd5b3ca4de302b33c9361dbc433593c4ca/Lib/this.py#L11" rel="noreferrer"><em>practicality beats purity</em></a>). If you want to cram <code>MyWhateverClass</code> into any crazy inheritance tree you can dream up, go ahead, but it is up to you to write the necessary scaffolding to allow that. As usual, Python will not prevent you to implement it in whatever hacky way is good enough to work.</p>
<p><sup>1</sup><sub>You're always inheriting from object, whether you wrote it in the class declaration or not. Many open source codebases will inherit from object explicitly anyway in order to be cross-compatible with 2.7 runtimes.</sub></p>
<p><sup>2</sup><sub>This point is explained in greater detail, along with the subtle relationship between <code>__new__</code> and <code>__init__</code>, in CPython sources <a href="https://github.com/python/cpython/blob/24bd50bdcc97d65130c07d6cd26085fd06c3e972/Objects/typeobject.c#L3598-L3638" rel="noreferrer">here</a>.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>Person</code> and <code>Horse</code> were never designed to be used as base classes of the same class, then <code>Centaur</code> probably shouldn't exist. Correctly designing for multiple inheritance is very hard, much more than just calling <code>super</code>. Even single inheritance is pretty tricky.</p>
<p>If <code>Person</code> and <code>Horse</code> <em>are</em> supposed to support creation of classes like <code>Centaur</code>, then <code>Person</code> and <code>Horse</code> (and likely the classes around them) need some redesigning. Here's a start:</p>
<pre><code>class Person:
    def __init__(self, *, name, **kwargs):
        super().__init__(**kwargs)
        self.name = name

class Horse:
    def __init__(self, *, fur_color, **kwargs):
        super().__init__(**kwargs)
        self.fur_color = fur_color

class Centaur(Person, Horse):
    pass

stevehorse = Centaur(name="Steve", fur_color="brown")
</code></pre>
<hr/>
<p>You'll notice some changes. Let's go down the list.</p>
<p>First, the <code>__init__</code> signatures now have a <code>*</code> in the middle. The <code>*</code> marks the beginning of keyword-only arguments: <code>name</code> and <code>fur_color</code> are now keyword-only. It's nearly impossible to get positional arguments to work safely when different classes in a multiple inheritance graph take different arguments, so for safety, we require arguments by keyword. (Things would be different if multiple classes needed to use the same constructor arguments.)</p>
<p>Second, the <code>__init__</code> signatures all take <code>**kwargs</code> now. This lets <code>Person.__init__</code> accept keyword arguments it doesn't understand, like <code>fur_color</code>, and pass them on to down the line until they reach whatever class does understand them. By the time the parameters reach <code>object.__init__</code>, <code>object.__init__</code> should receive empty <code>kwargs</code>.</p>
<p>Third, <code>Centaur</code> doesn't have its own <code>__init__</code> any more. With <code>Person</code> and <code>Horse</code> redesigned, it doesn't need an <code>__init__</code>. The inherited <code>__init__</code> from <code>Person</code> will do the right thing with <code>Centaur</code>'s MRO, passing <code>fur_color</code> to <code>Horse.__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>When using <code>super</code> to call a superclass method, you would normally need the current class and the current instance as parameters:</p>
<pre><code>super(Centaur, self).__init__(...)
</code></pre>
<p>Now, the problem comes with the way Python handles <a href="https://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance#comment15038776_3277407">walking the superclasses</a>. If the <code>__init__</code> methods don't have matching signatures, then the calls will probably cause problems. From the linked example:</p>
<pre><code>class First(object):
    def __init__(self):
        print "first prologue"
        super(First, self).__init__()
        print "first epilogue"

class Second(First):
    def __init__(self):
            print "second prologue"
            super(Second, self).__init__()
            print "second epilogue"

class Third(First):
    def __init__(self):
        print "third prologue"
        super(Third, self).__init__()
        print "third epilogue"

class Fourth(Second, Third):
    def __init__(self):
        super(Fourth, self).__init__()
        print "that's it"

Fourth()
</code></pre>
<p>The output is:</p>
<pre><code>$ python2 super.py                                                                                                                                                                      
second prologue
third prologue
first prologue
first epilogue
third epilogue
second epilogue
that's it
</code></pre>
<p>This shows the order the constructors are called. Also note that the subclass constructors all have compatible signatures because they were written with each other in mind.</p>
</div>
<span class="comment-copy">I don't completely understand your question. But if you're designing a class that is to be used in a multiple inheritance scenario - and maybe in any case - you should always accept <code>*args, **kwargs</code> and pass them on in any super call.</span>
<span class="comment-copy">@DanielRoseman The question is basically this: I've identified a problem (presumably) caused by the use of <code>super</code>, so I want to know if calling <code>super</code> is bad. An answer should say something like <i>"Using <code>super</code> is bad for the exact reason you brought up in your question"</i> or <i>"There's nothing wrong with using <code>super</code>, provided your class is designed for multiple cooperative inheritance"</i>, etc. Or to put it differently, the question can be thought of as "Under what circumstances should a class that inherits directly from <code>object</code> use <code>super</code>?"</span>
<span class="comment-copy">One could ask why <code>object.__init__()</code> doesn't accept <code>*args</code> and <code>**kwargs</code>, which would solve the issue.</span>
<span class="comment-copy">@brunodesthuilliers Would it? I don't think <code>object.__init__</code> is called with arguments anywhere in this code, is it?</span>
<span class="comment-copy">Need to study <a href="https://www.digitalocean.com/community/tutorials/understanding-class-inheritance-in-python-3" rel="nofollow noreferrer">digitalocean.com/community/tutorials/…</a></span>
<span class="comment-copy">Bleh, that OrderedCounter recipe. It's a fluke of implementation details that it works at all, and a fluke of implementation details that it doesn't work with the base classes swapped, and there is no way to tell from the <code>OrderedDict</code> or <code>Counter</code> docs which order should or shouldn't work.</span>
<span class="comment-copy">So to sum it up: It doesn't matter what you do; if your subclasses have a problem with your class's interface they should write an adapter. Did I understand that correctly?</span>
<span class="comment-copy">That's a judgement call - if the subclass is one of your own, you might find yourself wanting to refactor a class interface to allow for easier inheritance rather than muck around writing adapters. And if you can do it well, adapters might not be necessary at all. But you can't anticipate every possible use-case by third party code.</span>
<span class="comment-copy">@user2357112 You might enjoy this <a href="https://www.monkeyuser.com/2018/implementation/" rel="nofollow noreferrer">artist's depiction of the <code>OrderedCounter</code> recipe</a>.</span>
<span class="comment-copy">Good answer, and undoubtedly correct. But if possible, it would be great if you could expand on the "they were never supposed to be used as base classes" case. What would I do if <code>Person</code> and <code>Horse</code> aren't designed to support <code>Centaur</code>? Should I write my own <code>Person</code> and <code>Horse</code> classes with multiple cooperative inheritance in mind? Should I write adapters for the existing <code>Person</code> and <code>Horse</code> classes? Or maybe some other option I didn't think of?</span>
<span class="comment-copy">In the real world, the way forward would depend on whether there are other people using <code>Person</code> and <code>Horse</code> and you need to maintain backwards compat.</span>
<span class="comment-copy"><code>super(Centaur, self)</code> is equivalent to just <code>super()</code>, so there's really no reason to pass the arguments explicitly. And yes, I understand how the MRO works and how it causes that problem. The question is: What should I do about it? What's the correct way to circumvent those problems? Your answer doesn't address this at all.</span>
<span class="comment-copy">I think the code in the linked answer illustrates it a lot better.</span>
