<div class="post-text" itemprop="text">
<p>So, I was watching this presentation and it introduced me to this awesome way of finding the maximum value in a dictionary. This probably isn't breaking any ground for most folks on here, but here it is:</p>
<pre><code>c = {"One":1, "Two":2, "Uns":1}
max(c,key=c.get)
'Two'
</code></pre>
<p>I don't understand quite how it works. The 'get' method returns the value for a key, if the key exists in the dictionary. So does the 'max' iterate through each key, find the associated value and then return the key associated with the maximum value? How does it work when the dictionary has multiple maximum values?</p>
<pre><code>c = {"One":1, "Two":2, "Uns":1, "Dos": 2}
max(c,key=c.get)
'Dos'
</code></pre>
<p>So, to experiment and confuse myself further, I tried this:</p>
<pre><code>c = {"One":1, "Two":2, "Uns":1}
max(c.values(),key=c.get)
1
</code></pre>
<p>So, why did it return '1' instead of '2'? Please un-confuse this soul!</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't confuse the idea of the key of the dictionary, with the "key-function"</p>
<p>When two values are the same, <code>max</code> or <code>min</code> will return the first matching key. Since iteration of dict is unordered until Python3.6, it's not a good idea to rely on which particular key would be returned</p>
<p>In your last example, you are asking the dict to use the values as keys to the dict. This will usually return <code>None</code> unless the value also happens to be a key (This will never happen if all the keys are str and all the values are int, for example). In Python2, since <code>None</code> isn't greater than <code>None</code>, the first key that is encountered will be the one that is eventually returned. In Python3, doing this comparison throws an exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you call:</p>
<pre><code>max(c, key=c.get)
</code></pre>
<p>the <code>max</code> function internally iterates over the first parameter; for a dictionary this will iterate over the <em>keys</em> of the dictionary, in... some order, this is where things get hairy.</p>
<ul>
<li>before Python 3.6, this order was arbitrary and not guaranteed to be any specific order</li>
<li>in the CPython implementation of Python 3.6, the order was changed - as an implementation detail - to be the order in which the keys were inserted into the dictionary. (In your case, the order in which they're written in the literal, so <code>"One"</code>, <code>"Two"</code>, <code>"Uns"</code>, <code>"Dos"</code></li>
<li>as of Python 3.7, this behaviour is guaranteed by the language specification.</li>
</ul>
<p>(See also the <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">Python documentation on the <code>dict</code> type</a>.)</p>
<p>Now we know that the <code>max()</code> function will see two possible keys that map to the maximum value, <code>"Two"</code> and <code>"Dos"</code>, in this order. The <a href="https://docs.python.org/3/library/functions.html?highlight=max#max" rel="nofollow noreferrer">documentation for the <code>max()</code> function</a> states:</p>
<blockquote>
<p>If multiple items are maximal, the function returns the first one encountered.</p>
</blockquote>
<p>So in Python 3.7 as well as CPython 3.6, what is returned depends on the order in which the keys are inserted into the dictionary:</p>
<pre><code>&gt;&gt;&gt; c = {"Uns":1, "Dos":2, "One":1, "Two": 2}
&gt;&gt;&gt; list(iter(c))
['Uns', 'Dos', 'One', 'Two']
&gt;&gt;&gt; max(c, key=c.get)
'Dos'
&gt;&gt;&gt; c = {"One":1, "Two":2, "Uns":1, "Dos": 2}
&gt;&gt;&gt; list(iter(c))
['One', 'Two', 'Uns', 'Dos']
&gt;&gt;&gt; max(c, key=c.get)
'Two'
</code></pre>
<p>In Python 3.5, which maximum will be the first encountered is arbitrary, but it will be the first key with a maximum value seen in <code>list(iter(c))</code></p>
<p>In Python 2.7, the behaviour of the <code>max()</code> function I cited above isn't specified in the documentation, so who knows really.</p>
<hr/>
<p>As for your second example, it really plain doesn't make sense, so I'll just rush past it: <code>c.get()</code> will return <code>None</code> when you pass it a key that doesn't exist in the dictionary. In Python 2.x, it was allowed to compare <code>None</code> with <code>None</code> using the <code>&lt;</code> operator that <code>max()</code> uses to determine the maximum; I'm guessing since it compares two same objects, they were considered equal and thus the result of that comparison was <code>False</code>, and every item in your case would be considered the "maximum". Since the order of the keys is unspecified in Python 2.x, and neither is which one is returned by <code>max()</code>, the result you get is essentially arbitrary. Not that it matters, since there is no sense the whole thing could be making.</p>
<p>You could prevent this by avoiding the use of <code>dict.get()</code>, and writing more assertive code that fails early because it's clear accessing a key that doesn't exist in the dictionary is a mistake:</p>
<pre><code>max(c, key=lambda k: c[k])
</code></pre>
</div>
<span class="comment-copy">You're not using python3. The last line should throw a TypeError.</span>
<span class="comment-copy">Apologies... I use Python 2.7 at work and 3.6 at home. This was on 2.7.</span>
<span class="comment-copy">Works pretty well as it should on python3 !</span>
<span class="comment-copy">@JohnLaRooy, I thought I had copied the relevant segments over... Edited to now list what was ACTUALLY in IDLE</span>
<span class="comment-copy"><code>c.get</code> is just convenient to use since it already exists and does what you need. Since the key definitely exists for each call, you could write <code>max(c, key=lambda k: c[k])</code> instead, if that's easier to understand</span>
