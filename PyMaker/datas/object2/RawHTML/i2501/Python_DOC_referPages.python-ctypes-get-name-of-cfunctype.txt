<div class="post-text" itemprop="text">
<p>I am looking into some code I have not written with pdb.</p>
<pre><code>(Pdb) self.function
&lt;CFunctionType object at 0x000000DC768E0E18&gt;
(Pdb) type(self.function)
&lt;class 'ctypes.CFUNCTYPE.&lt;locals&gt;.CFunctionType'&gt;
(Pdb) dir(self.function)
['__bool__', '__call__', '__class__', '__ctypes_from_outparam__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_argtypes_', '_b_base_', '_b_needsfree_', '_flags_', '_objects', '_restype_', 'argtypes', 'errcheck', 'restype']
(Pdb) self.function._flags_
1
(Pdb) self.function._objects
{'0': &lt;CDLL 'C:\path', handle 7ffe26465400 at 0xdc74ad2908&gt;}
</code></pre>
<p>Is it possible for me to find out where self.function was defined, or what the name of the function is? self.function._objects points towards a DLL, but it's not clear to me how or if I can find the function's name so I can look it up in the source code.</p>
<p>Further, is it possible to step into the function when it is called? It is called in the code in the following way:</p>
<pre><code>self.function(*self.args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is it possible for me to find out where self.function was defined, </p>
</blockquote>
<p>No, because it was defined in some source code written in C (or another language) that you don't even have (or maybe you do, but Python has no idea where it is); all you have is the DLL/so/dylib that resulted from compiling it.</p>
<hr/>
<blockquote>
<p>… or what the name of the function is? </p>
</blockquote>
<p>Yes. You can usually get the name of a ctypes C function the same way as many other objects in Python: via the <code>__name__</code> special attribute:</p>
<pre><code>&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; libm = ctypes.CDLL('libm.dylib')
&gt;&gt;&gt; fabs = libm.fabs
&gt;&gt;&gt; fabs
&lt;_FuncPtr object at 0x1067ac750&gt;
&gt;&gt;&gt; fabs.__name__
'fabs'
</code></pre>
<blockquote>
<p>self.function._objects points towards a DLL, but it's not clear to me how or if I can find the function's name so I can look it up in the source code.</p>
</blockquote>
<p>You can't get the function name from there. But you can get the library name from there via the <a href="https://docs.python.org/3/library/ctypes.html#ctypes.PyDLL._name" rel="nofollow noreferrer"><code>_name</code></a> attribute:</p>
<pre><code>&gt;&gt;&gt; fabs._objects['0']._name
'libm.dylib'
</code></pre>
<p>(Despite the underscore, this is a public attribute, as the docs explain.)</p>
<p>This will usually be the name passed to the <code>CDLL</code> constructor or <code>cdll.LoadLibrary</code> call. On Windows, for libraries loaded with the <code>cdll.spam</code> magic, I think you actually get the resolved pathname, like <code>'D:\path\to\spam.dll'</code>, not just <code>'spam'</code> or <code>'spam.dll'</code>, but I'm not positive.</p>
<hr/>
<blockquote>
<p>Further, is it possible to step into the function when it is called?</p>
</blockquote>
<p>No, because the function is compiled machine code; it doesn't have any Python bytecode for you to step into.</p>
<p>You could, of course, attach a debugger like Visual Studio, lldb, or gdb and step into the machine code <em>that</em> way.</p>
</div>
<span class="comment-copy">You can't step into a C function in the Python debugger, because it doesn't have any Python bytecode to step into. (You could of course attach a debugger like gdb, lldb, or Visual Studio and step through the machine code, if you want to do that.)</span>
<span class="comment-copy">Is it possible to get the function name?</span>
