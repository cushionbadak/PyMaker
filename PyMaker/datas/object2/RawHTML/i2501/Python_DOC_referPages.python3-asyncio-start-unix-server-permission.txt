<div class="post-text" itemprop="text">
<p>The software that I run due to special circumstances will be running as a daemon with root privilege. The software will also have API so that normal user can access it without "sudo" everytime ( API is read-only and can only be accessed from localhost ). </p>
<p>Then wasting a TCP port with random number TCP port that might be forgotten in the future, I prefer to use a UNIX socket, since it will be run on Linux. </p>
<p>I'm using asyncio module to start_unix_server method, but I have trouble with Unix socket file permission since the software starts as root privilege the socket file has "<strong>srwxr-xr-x root root</strong>" permission and I cannot connect to this file unless I use "sudo".</p>
<p>I check that start_unix_server doesn't have any option to change permission, but has sock parameters that accept socket object. So here is what I do and succeeded, but not sure whether this is intended to be done like this</p>
<pre class="lang-python prettyprint-override"><code>import socket
import asyncio

async def handler(reader, writer):
    message = data.decode()
    addr = writer.get_extra_info('peername')
    print("Received %r from %r" % (message, addr))

    print("Send: %r" % message)
    writer.write(data)
    await writer.drain()

    print("Close the client socket")
    writer.close()

socket_file = "/tmp/example-server.socket"
if os.path.exists(socket_file):
    os.remove(socket_file)

srv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
srv.bind(socket_file)

#Here we set the file permission after bind
os.chmod(socket_file, 0o666)

loop = asyncio.get_event_loop()

#Here we pass the socket object to asyncio
asyncio.ensure_future(asyncio.start_unix_server(handler, sock=s))

try:
    loop.run_forever()
except:
    pass
finally:
    loop.close()
    os.remove(socket_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To avoid creating your own socket, you can use the <code>path</code> parameter to <code>start_unix_server</code> (documented under its lower-level relative <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_unix_server" rel="nofollow noreferrer"><code>create_unix_server</code></a>):</p>
<pre><code>loop = asyncio.get_event_loop()

socket_file = "/tmp/example-server.socket"
if os.path.exists(socket_file):
    os.remove(socket_file)
loop.run_until_complete(
    asyncio.start_unix_server(handler, path=socket_file))
os.chmod(socket_file, 0o666)
loop.run_forever()
# ...
</code></pre>
<p>Another option is to use <a href="https://docs.python.org/3/library/os.html#os.umask" rel="nofollow noreferrer"><code>umask</code></a>, but with the caveat that <code>umask</code> affects all threads in the process, so if you have background threads that can create files, they could be affected by the <code>umask</code> change.</p>
</div>
<span class="comment-copy">Your <code>umask</code> controls which permissions are turned off when you create a filesystem object. Run with <code>umask 000</code> to have the socket created with world-write permissions.</span>
<span class="comment-copy">does umask is set globally ? where should I put this umask ?</span>
<span class="comment-copy">Yep I prefer chmod better, I didn't succeed before because I wrap start_unix_server in ensure_future only which is haven't started yet.</span>
