<div class="post-text" itemprop="text">
<p>Is there any way to hook the CPython interpreter so that every function creation (<code>def</code>, <code>lambda</code>) results in a call to a procedure that I've defined? <code>sys.settrace</code> and <code>sys.setprofile</code> unfortunately don't seem to cover both <code>def</code> and <code>lambda</code>.</p>
<h3>Update:</h3>
<p>It seems Python 3.7 has <code>f_trace_opcodes</code>... is there any option for earlier versions?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no equivalent to <code>opcode</code> tracing in versions before 3.7. If there were, the feature wouldn't have been added to 3.7 in the first place.</p>
<p>If you can upgrade to 3.7, then what you want is easy:</p>
<pre><code>def tracefunc(frame, event, arg):
    if event == 'call':
        frame.f_trace_opcodes = True
    elif event == 'opcode':
        if frame.f_code.co_code[frame.f_lasti] == dis.opmap['MAKE_FUNCTION']:
            makefunctiontracefunc(frame)
    return tracefunc
sys.settrace(tracefunc)
</code></pre>
<p>But if you can't… there are a number of more complicated things you <em>could</em> do, depending on what your reasons are for wanting this, but none of them are remotely easy:</p>
<ul>
<li>Use <code>line</code> tracing, and inspect the code until the next line. This is trivial for <code>def</code>, but for <code>lambda</code> (and comprehensions<sup>1</sup>) it's going to be a big pain, because a <code>lambda</code> (or even five of them) can appear in the middle of a statement. You could <code>ast.parse</code> the source, or examine the bytecode, to figure out that there are functions being defined within, but there's still no way to call your hook right at the time of definition.</li>
<li>Instead of using tracing, write an import hook that modifies the code as it's being imported. The easy way to do this is probably at the AST level: after you parse the source, use a <a href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer" rel="nofollow noreferrer"><code>NodeTransformer</code></a> to inject calls to some function<sup>2</sup> before or after each <code>def</code> and <code>lambda</code> node, then compile the transformed tree. But you could also do it at the bytecode level with <a href="https://github.com/vstinner/bytecode" rel="nofollow noreferrer"><code>bytecode</code></a> or <a href="https://github.com/serprex/byteplay" rel="nofollow noreferrer"><code>byteplay</code></a>, before or after each <code>MAKE_FUNCTION</code>.<sup>3</sup></li>
<li>Script <code>pdb</code> instead of writing your own debugger. I'm not sure if this will even help, because <code>pdb</code> has no way to step through part of an expression in the first place.</li>
<li>Debug CPython itself, and add a breakpoint in the <code>MAKE_FUNCTION</code> handler in the <code>ceval</code> loop that calls your code. Of course your code is in the debugger's interpreter—which can be Python for <code>gdb</code> and <code>lldb</code>, but it's still not the <em>same</em> Python interpreter you're debugging. And, while it's possible to recursively evaluate code into the debugged interpreter (or trigger its <code>pdb</code>), it's not easy, and you segfault all over the place while working it out.</li>
</ul>
<hr/>
<p><sub>1. Comprehensions (except list comprehensions, in 2.x) are implemented by defining and then calling a function. So, any of the methods that rely on the <code>MAKE_FUNCTION</code> opcode or similar are going to also fire on comprehensions, while those that rely on source or AST parsing will not (unless you do so explicitly, of course).</sub></p>
<p><sub>2. Obviously you also need to inject an <code>import</code> at the top of every module to make that function available, or inject the function into the builtins module.</sub></p>
<p><sub>3. And <code>MAKE_CLOSURE</code>, for earlier versions of Python.</sub></p>
</div>
<span class="comment-copy"><code>settrace</code> doesn't have specific events for most kinds of statements. But it does have both <code>line</code> and <code>opcode</code> events. So, you can just check whether the line starts a <code>def</code>, or whether the opcode is a <code>MAKE_FUNCTION</code>. (For 2.7 or 3.5, you'd need to check whether it's in <code>MAKE_FUNCTION</code> or <code>MAKE_CLOSURE</code>, and, IIRC, even older versions of Python had even more function-creation opcodes, but you can just look at your version's <code>dis</code> module docs to see.)</span>
<span class="comment-copy">@abarnert: Ohh, I was looking only at Python 2, which doesn't have opcode events. Interesting, I'll check it out for Python 3. Thanks!</span>
<span class="comment-copy">First, you can do this in terms of lines: you just need to look at the statement starting at <code>frame.f_lineno</code> and see if it's a <code>def</code> (hackily by just looking at something like <code>inspect.getsource(frame).lstrip().startswith('def ')</code>, or more robustly by, e.g., <code>ast.parse</code>-ing the source to see if it's a <code>def</code> node. Or, even though you're only being called once per line, you can still look at the opcodes within that line to see if there's a <code>MAKE_FUNCTION</code>.</span>
<span class="comment-copy">@abarnert: I think <code>line</code> is kind of risky for lots of reasons, one of them being that I don't want to miss lambdas (I didn't think to include that in the question but I should have said I want to hook function creation). <code>opcode</code> seems to be what I want though :)</span>
<span class="comment-copy">OK, but notice comprehensions (except listcomps, in 2.x) are function definitions.</span>
