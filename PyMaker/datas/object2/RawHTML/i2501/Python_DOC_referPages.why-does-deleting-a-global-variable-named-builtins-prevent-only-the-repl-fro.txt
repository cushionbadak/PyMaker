<div class="post-text" itemprop="text">
<p>I have a python script with the following contents:</p>
<pre><code># foo.py

__builtins__ = 3
del __builtins__

print(int)  # &lt;- this still works
</code></pre>
<p>Curiously, executing this script with the <code>-i</code> flag prevents <em>only</em> the REPL from accessing builtins:</p>
<pre><code>aran-fey@starlight ~&gt; python3 -i foo.py 
&lt;class 'int'&gt;
&gt;&gt;&gt; print(int)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'print' is not defined
</code></pre>
<p>How come the script can access builtins, but the REPL can't?</p>
</div>
<div class="post-text" itemprop="text">
<p>CPython doesn't look up <code>__builtins__</code> every time it needs to do a built-in variable lookup. Each frame object has an <a href="https://github.com/python/cpython/blob/v3.7.0/Include/frameobject.h#L21" rel="nofollow noreferrer"><code>f_builtins</code></a> member holding its built-in variable dict, and built-in variable lookup goes through there.</p>
<p><code>f_builtins</code> is set on frame object creation. If a new frame has <em>no parent frame</em> (<code>f_back</code>), or a <em>different global variable dict</em> from its parent frame, then frame object initialization looks up <code>__builtins__</code> to set <code>f_builtins</code>. (If the new frame shares a global dict with its parent frame, then it inherits its parent's <code>f_builtins</code>.) This is the only way <code>__builtins__</code> is involved in built-in variable lookup. You can see the code that handles this in <a href="https://github.com/python/cpython/blob/v3.7.0/Objects/frameobject.c#L667" rel="nofollow noreferrer"><code>_PyFrame_New_NoTrack</code></a>.</p>
<p>When you delete <code>__builtins__</code> inside a script, that doesn't affect <code>f_builtins</code>. The rest of the code executing in the script's stack frame still sees builtins. Once the script completes and <code>-i</code> drops you into interactive mode, every interactive command gets a new stack frame (with no parent), and the <code>__builtins__</code> lookup is repeated. This is when the deleted <code>__builtins__</code> finally matter.</p>
</div>
<div class="post-text" itemprop="text">
<p>The execution context is different. Within the REPL we are working line-by-line (<strong>R</strong>ead, <strong>E</strong>val, <strong>P</strong>rint, <strong>L</strong>oop), which allows an opportunity for global execution scope to change in between each step. But the runtime executing a module is to load the modules code, and then exec it within a scope.</p>
<p>In CPython, the builtins namespace associated with the execution of a code block is found by looking up the name <code>__builtins__</code> in the global namespace; this should be bound to a dictionary or a module (in the latter case the module's dictionary is used). When in the <code>__main__</code> module, <code>__builtins__</code> is the built-in module <code>builtins</code>, otherwise <code>__builtins__</code> is bound to the dictionary of the <code>builtins</code> module itself. In both contexts of your question, we are in the <code>__main__</code> module.</p>
<p>What's important is that CPython only looks up the builtins <strong>once</strong>, right before it begins executing your code. In the REPL, this happens every time a new statement is executed. But when executing a python script, the entire content of the script is one single unit. That is why deleting the builtins in the middle of the script has no effect.</p>
<p>To more closely replicate that context inside a REPL, you would not enter the code of the module line by line, but instead use a compound statement:</p>
<pre><code>&gt;&gt;&gt; if 1:
...     del __builtins__
...     print(123)
... 
123
&gt;&gt;&gt; print(123)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'print' is not defined
</code></pre>
<p>Naturally, you're probably now wondering how to remove builtins from within a script. The answer should be obvious: you can't do it by rebinding a name, but you can do it by mutation:</p>
<pre><code># foo2.py
__builtins__.__dict__.clear()
print(int)  # &lt;- NameError: name 'print' is not defined
</code></pre>
<p>As a final note, the fact that <code>__builtins__</code> name is bound at all is <a href="https://docs.python.org/3/reference/executionmodel.html#builtins-and-restricted-execution" rel="nofollow noreferrer">implementation detail</a> of CPython and that is explicitly documented:</p>
<blockquote>
<p>Users should not touch <code>__builtins__</code>; it is strictly an implementation detail.  </p>
</blockquote>
<p>Don't rely on <code>__builtins__</code> for anything serious, if you need access to that scope the correct way is to <code>import builtins</code> and go from there.</p>
</div>
