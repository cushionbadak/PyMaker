<div class="post-text" itemprop="text">
<p>I am trying to write a Card class and I want to make sure that I can use comparison operators on it, as well as use max,min,sort of list of my <code>Card</code> objects.</p>
<p>I read that to accomplish this I just need to implement <code>__cmp__</code> but when I did that my unit tests would not pass, so I ended up implementing all of the comparison magic methods <code>__gt__</code>,<code>__lt__</code>,<code>__eq__</code>, etc.</p>
<p>I want to get rid of bloat in my code and remove all of comparison methods expect for <code>__cmp__</code> if possible.</p>
<p>I am using Python 3.5 Anaconda distribution.</p>
<p>This is my current implementation:</p>
<pre><code>__ranks__ = [2,3,4,5,6,7,8,9,10,"J","Q","K","A"]
__suites__ = ["Clubs","Diamods","Hearts","Spades"]

class Card():
  def __init__(self,suite,rank):
    if suite in __suites__ and rank in __ranks__:
      self.suite = suite
      self.rank = rank
    else:
      raise ValueError("Cards need to be instansiated with names from __ranks__ and __suites")


def __gt__(self,other):
  return self._compare_cards_(other,-1)

def __lt__(self,other):
  return self._compare_cards_(other,1)

def __ge__(self,other):
  return self._compare_cards_(other,-1) or self.__eq__(other)

def __le__(self,other):
  return self._compare_cards_(other,1) or self.__eq__(other)

def __eq__(self,other):
  return self._compare_cards_(other,0)

def __ne__(self,other):
  return not self.__eq__(other)

def _compare_cards_(self,other,expect):
  rank_comp = self._compare_ranks_(other.rank,self.rank)
  if rank_comp == 0:
    return self._compare_suites_(other.suite,self.suite) == expect
  return rank_comp == expect

def _compare_ranks_(self,rank1,rank2):
  return self._compare_attributes_("rank",rank1,rank2)

def _compare_suites_(self,suite1,suite2):
  return self._compare_attributes_("suite",suite1,suite2)

def _compare_attributes_(self,name,attr1,attr2):
  attr_list = eval("__{}s__".format(name))

  if attr_list.index(attr1) &lt; attr_list.index(attr2):
    return -1
  if attr_list.index(attr1) == attr_list.index(attr2):
    return 0
  if attr_list.index(attr1) &gt; attr_list.index(attr2):
    return 1
</code></pre>
<p>Originally instead of all the magic methods that I have now I had <code>__cmp__</code>:</p>
<pre><code>def __cmp__(self,other):
  rank_comp = self._compare_ranks_(other.rank,self.rank)
  if rank_comp == 0:
    return self._compare_suites_(other.suite,self.suite)
  return rank_comp
</code></pre>
<p>My unit tests(using pytest):</p>
<pre><code>import pytest
from game.deck import Card

def test_card_rank_can_be_compared():
  ten_of_spades = Card("Spades",10)
  jack_of_spades = Card("Spades","J")

  assert ten_of_spades &lt; jack_of_spades
  assert jack_of_spades &gt; ten_of_spades
  assert ten_of_spades &lt;= jack_of_spades
  assert jack_of_spades &gt;= ten_of_spades

def test_card_suite_can_be_comapred():
  ten_of_spades = Card("Spades",10)
  ten_of_clubs = Card("Clubs",10)

  assert ten_of_spades &gt; ten_of_clubs
  assert ten_of_clubs &lt; ten_of_spades
  assert ten_of_spades &gt;= ten_of_clubs
  assert ten_of_clubs &lt;= ten_of_spades
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__cmp__</code> no longer exists, so that's not an option. That said, you can implement only <code>__eq__</code> and <code>__lt__</code>, then <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer">use the <code>functools.total_ordering</code> decorator</a> to fill in the rest:</p>
<pre><code>import functools

@functools.total_ordering
class Card:
  ... init here ...
  def __lt__(self,other):
     return self._compare_cards_(other,1)
  def __eq__(self,other):
     return self._compare_cards_(other,0)
  ... no need for le/ge/gt, and you never need ne on Python 3 anyway ...
  ... rest of code ...
</code></pre>
<p>If you can move to 3.7, you might want to look at <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">the <code>dataclasses</code> module</a> which can handle code generation for equality and comparisons very easily, which (if combined with the <code>enum</code> module to properly order your ranks and suits for free), would remove most of your custom code entirely, leaving only a half dozen lines or so.</p>
</div>
<span class="comment-copy">Is what you've posted your actual indentation? If so, you haven't added special methods to the <code>Card</code> class, you've just created a bunch of functions that never get called.</span>
<span class="comment-copy"><code>__cmp__</code> is gone in Python 3. The powers that be decided that you should have to go with the bloated way of doing things. I was not personally consulted on that decision, and I would have voted against it if I had been.</span>
<span class="comment-copy">Also, why are you working so hard to fight against Python, instead of just using it as intended? Your code would be a whole lot simpler.</span>
<span class="comment-copy">Side-note: A card has a "suit", not a "suite"; pluralized, it's still "suits", not "suites". Only time an <code>e</code> appears is referring to "suited" cards, but that's purely the <code>-ed</code> suffix, not part of the word itself.</span>
<span class="comment-copy">@mypetlion: Aside from the NumPy motivation, it was impossible to implement equality comparisons without ordering comparisons in the old API. Also, requiring every equality test to compute ordering was hurting performance. Rich comparisons may be more code, but the benefits are real.</span>
<span class="comment-copy">Even for 3.6, you can either use the dataclasses backport, or the third-party library that inspired it, attrs.</span>
