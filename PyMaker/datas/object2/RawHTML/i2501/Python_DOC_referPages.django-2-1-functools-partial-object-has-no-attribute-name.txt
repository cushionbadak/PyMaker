<div class="post-text" itemprop="text">
<p>I recently upgraded Django from 2.0.7 to 2.1.1, a new error occurs in which I get this error <code>'functools.partial' object has no attribute '__name__'</code>. </p>
<p>I'd like to understand if my fix is right and what caused this new error to happen, I couldn't find anything on the django release notes related to this issue, maybe I missed it. </p>
<p><strong>decorators.py</strong></p>
<pre><code>def auth0_login_required(function):
    def wrap(request, *args, **kwargs):

        if request.isAuthenticated or request.user.is_staff:
            pass
        else:
            raise Http404()

        return function(request, *args, **kwargs)
    wrap.__doc__ = function.__doc__
    wrap.__name__ = function.__name__ # ERROR HERE
    return wrap
</code></pre>
<p>How it is used, <strong>views.py</strong>: </p>
<pre><code>@method_decorator(auth0_login_required, name='dispatch')
class Dashboard(View):
    ...
</code></pre>
<p>For the fix I just removed <code>wrap.__name__ = function.__name__</code>, but I'm not sure if it'll break something else.</p>
<p>Can someone explain?</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than manually copy things across, use the <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>@functools.wraps()</code> decorator</a> to handle this for you:</p>
<pre><code>from functools import wraps

def auth0_login_required(function):
    @wraps(function)
    def wrap(request, *args, **kwargs):

        if request.isAuthenticated or request.user.is_staff:
            pass
        else:
            raise Http404()

        return function(request, *args, **kwargs)

    return wrap
</code></pre>
<p>The <code>@wraps()</code> decorator (via the <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper" rel="nofollow noreferrer"><code>functools.update_wrapper()</code> function it calls</a> knows how to handle <code>functools.partial</code> objects correctly (or rather, it can handle the fact that <code>functools.partial</code> objects have no <code>__name__</code> attribute).</p>
<p>It's fine that the wrapped <code>functools.partial()</code> object found on the <code>View</code> class doesn't have a <code>__name__</code> attribute, what's not fine is that you then don't copy that attribute at all even when you are decorating functions that do have the attribute. If you don't want to use <code>@wraps()</code> you'd have to manually copy the attribute across and handle the exception yourself:</p>
<pre><code>try:
    wrap.__name__ = function.__name__
except AttributeError:
    pass
try:
    wrap.__doc__ = function.__doc__
except AttributeError:
    pass
</code></pre>
<p>but take into account that this doesn't copy the <code>__qualname__</code>, <code>__module__</code> and <code>__annotations__</code> attributes, doesn't handle any custom attributes set on <code>function</code> (which other decorators might rely on). <code>@functools.wraps()</code> does take care of all of those, plus it sets the <code>__wrapped__</code> attribute on the decorator wrapper function that <a href="https://docs.python.org/3/library/inspect.html#inspect.unwrap" rel="nofollow noreferrer">would let you unwrap the decorator again</a>.</p>
</div>
