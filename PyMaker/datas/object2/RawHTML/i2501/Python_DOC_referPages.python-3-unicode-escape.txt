<div class="post-text" itemprop="text">
<p>I have a script that I built following the blueprint in the book <em>Learning Python for Forensics</em>. The script will go through a directory specified by the user and collect the metadata for each file in the directory. The results are saved to a sqlite database  and also written to a CSV or HTML file.</p>
<p>The script was originally written in Python 2.7.15. I am trying to update the code for Python 3.7. However, there is one line in the ingest directory function that is giving me issues.</p>
<p>The <code>ingestDirectory</code> function looks like this:</p>
<pre><code>def ingestDirectory(cur, source, custodian_id):    
    count = 0
    for root, folders, files in os.walk(source):
        for file_name in files:
            meta_data = dict()
            try:
                meta_data['file_name'] = file_name
                meta_data['file_path'] = os.path.join(root, file_name)
                meta_data['extension'] = os.path.splitext(file_name)[-1]

                file_stats = os.stat(meta_data['file_path'])
                meta_data['mode'] = oct(file_stats.st_mode)
                meta_data['inode'] = int(file_stats.st_ino)
                meta_data['file_size'] = int(file_stats.st_size)
                meta_data['atime'] = formatTimestamp(file_stats.st_atime)
                meta_data['mtime'] = formatTimestamp(file_stats.st_mtime)
                meta_data['ctime'] = formatTimestamp(file_stats.st_ctime)
            except Exception as e:
                logging.error('Could not gather data for file: ' + meta_data['file_path'] + e.__str__())
            meta_data['custodian'] = custodian_id
            columns = '","'.join(meta_data.keys())
            values = '","'.join(str(x).encode('string_escape') for x in meta_data.values())
            sql = 'INSERT INTO Files ("' + columns + '") VALUES ("' + values + '")'
            cur.execute(sql)
            count += 1
</code></pre>
<p>The line that is giving me errors is this:</p>
<pre><code>values = '","'.join(str(x).encode('string_escape') for x in meta_data.values())
</code></pre>
<p>This line is meant to handle any string escape characters found in <code>metadata.values</code> before writing the data to the database.</p>
<p>When I tried to run this code in Python 3 I got an error about an unrecognized codec. I did some research hear on Stack Overflow and found that <code>string_escape</code> has been replaced with <code>unicode-escape</code> in Python 3.</p>
<p>I am fairly new to Python 3 and Unicode. My question is this:</p>
<p>How do I update the line above so that it uses <code>unicode-escape</code> instead of <code>string_escape</code> and produces the same result as the Python 2.7 code?</p>
<p>Any help would be appreciated! I have been working on this for several days now and every solution I try just results in more error codes or corrupted output files.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are generating SQL in that piece of code, and escaping was there to try and produce valid SQL. It's a very poor-man's attempt at avoiding SQL injection. It's not very effective, and isn't needed as the database driver already knows how to take care of this, in a much safer fashion!</p>
<p>For SQL databases, the correct way to put the <em>values</em> into SQL parameters. SQL parameters consist of two components: placeholders, and values passed in separately to the <code>.execute()</code> method for the database to cleanly handle. The <code>sqlite3</code> library is no exception, see the <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.execute" rel="nofollow noreferrer"><code>cursor.execute()</code> method for details</a>. For your case, you can use <em>named</em> placeholders:</p>
<pre><code>columns = [f'''"{name.replace('"', '""')}"''' for name in meta_data]
placeholders = [f':{name}' for name in meta_data]
sql = f'INSERT INTO Files ({", ".join(columns)}) VALUES ({", ".join(placeholders)})'    
cur.execute(sql, meta_data)
</code></pre>
<p>Note that <code>meta_data</code> is passed as a second argument; the database takes each <code>:name</code> placeholder and takes the value for that placeholder from the <code>meta_data</code> dictionary. </p>
<p>I also properly formatted the column names, by putting double quotes around them and doubling any <code>"</code> characters in the name; see the <a href="https://www.sqlite.org/lang_keywords.html" rel="nofollow noreferrer">SQLite keyword documentation</a>:</p>
<pre><code>'keyword'       A keyword in single quotes is a string literal.
"keyword"       A keyword in double-quotes is an identifier.
</code></pre>
<p>Your code has hardcoded those column names and none of them are reserved SQL keywords, so they don't really need this protection, but it is still good practice.</p>
<p>For your code, where <code>meta_data</code> has a fixed number of keys, the above builds this <code>sql</code> string:</p>
<pre><code>&gt;&gt;&gt; columns = [f'''"{name.replace('"', '""')}"''' for name in meta_data]
&gt;&gt;&gt; placeholders = [f':{name}' for name in meta_data]
&gt;&gt;&gt; sql = f'INSERT INTO Files ({", ".join(columns)}) VALUES ({", ".join(placeholders)})'
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(sql)
('INSERT INTO Files ("file_name", "file_path", "extension", "mode", "inode", '
 '"file_size", "atime", "mtime", "ctime") VALUES (:file_name, :file_path, '
 ':extension, :mode, :inode, :file_size, :atime, :mtime, :ctime)')
</code></pre>
<p>I'd also change the way you log the error, instead of</p>
<pre><code>logging.error('Could not gather data for file: ' + meta_data['file_path'] + e.__str__())
</code></pre>
<p>I'd use</p>
<pre><code>logging.exception('Could not gather data for file: %s', meta_data['file_path'])
</code></pre>
<p>and leave the error gathering to the logging framework. Even if you do include the exception object, use <code>str(e)</code> or a <code>%s</code> placeholder.</p>
</div>
<span class="comment-copy">Oh, that's beautiful. Plopping data from a hostile source right into an SQL string. This practically screams "SQL injection".</span>
<span class="comment-copy">@melpomene: if this is a console script then that's fine; the user could just write directly to the sqlite database file <i>anyway</i>.</span>
<span class="comment-copy">I'm wondering why you need to decode escapes <i>in the first place</i>. Using <code>string_escape</code> / <code>unicode_escape</code> is a work-around for problems elsewhere, not a tool you'd use when you have full control over your data.</span>
<span class="comment-copy">@MartijnPieters The book is called <i>Learning Python for Forensics</i>, so I'm assuming this script is meant to analyze files from dubious sources.</span>
<span class="comment-copy">@melpomene: that doesn't mean that the practice shown here was recommended by that book, or perhaps only used as a stepping stone. The script analyses a local directory and sets the values from OS-supplied data. I don't see much opportunity for injections (only the filename could be used for that purpose).</span>
<span class="comment-copy">Thanks for the detailed answer! I copied your code into my script and ran into two errors both in the columns = line. The first was EOL while scanning string literal. I noticed that on the left side of the comma in parenthesis you used ' " ' and on the right you used ' " " '. I removed one set of double quotes  and that fixed the EOL error. When I ran the code again I got Syntax Error: f-string error: mismatched '[', '(', or '{'. The console puts a carrot under the [ just after columns = . I'm not sure what the source of the error is. All the brackets seem to match.</span>
<span class="comment-copy">@JSchaefer2516: sorry about that, I fixed the string definition.</span>
<span class="comment-copy">That's OK! Thanks for fixing it. I updated the line, and when I ran the code again I got another error. This one in the sql line. It is: SyntaxError: f-string: expecting '}'. I tried fixing it by enclosing the f-string in three single quotes like you did in the columns line. However, that lead to another error. This one was a sql operational error. All it said was error near " " file" ". I have no idea what the means, nor where it was finding a file written that way. Can you help?</span>
<span class="comment-copy">UPDATE: Ok. So, I fixed the f-string syntax error by enclosing the entire INSERT statement in single quotes. I found several examples that did this, so the best I can figures is that it is required for python 3. However, I'm still getting the sqlite3.OperationalError: near ""file_name"": syntax error message. The only thing I can think of is that the key names for the dict are being double quoted for some reason and that is causing a syntax error in sql. However, I have no idea what is causing sql to read the dict keys this way. They are not double quoted in the code. Any help would be great!</span>
<span class="comment-copy">@JSchaefer2516: I'll have a look at what's up here too, sorry, I have several different things that require attention.</span>
