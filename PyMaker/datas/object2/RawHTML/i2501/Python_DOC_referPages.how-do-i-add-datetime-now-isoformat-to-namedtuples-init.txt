<div class="post-text" itemprop="text">
<p>Of course I have tried:</p>
<pre><code>class PdfContentRecord(NamedTuple):
    filename: str
    page: int
    cache: dict
    data: dict = dict()
    accessed: str = None

    def __new__(cls, *args, **kwargs):
        self = super().__new__(*args, **kwargs)
        self.accessed = datetime.now().isoformat()
        return self
</code></pre>
<p>But I get exactly the same error as <a href="https://stackoverflow.com/questions/3624753/how-to-provide-additional-initialization-for-a-subclass-of-namedtuple">How to provide additional initialization for a subclass of namedtuple?</a></p>
<p>I can't tell if <code>attrs</code> can help me (too difficult to comprehend). <code>dataclasses.dataclass</code> probably can help, but it only supports Python 3.7.</p>
<p>Or I could write my Class, probably also with <code>__slots__</code>...</p>
<p>Edit:</p>
<blockquote>
<p>Did you read the answer in the question you linked?</p>
</blockquote>
<p>works with <code>from collection import namedtuple</code>, but not <code>from typing import NamedTuple</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.7+ users should just take advantage of either the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field" rel="nofollow noreferrer"><code>default_factory</code></a> or the <a href="https://docs.python.org/3/library/dataclasses.html#post-init-processing" rel="nofollow noreferrer"><code>__post_init__</code></a> hook in <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a>. For users on older Python versions, read on..</p>
<p>I think you should be able to do it with an extra layer of types:</p>
<pre><code>from datetime import datetime
from typing import NamedTuple


class _PdfContentRecord(NamedTuple):
    filename: str
    page: int
    cache: dict
    data: dict = None
    accessed: str = None


class PdfContentRecord(_PdfContentRecord):

    def __new__(cls, filename, page, cache, data=None, accessed=None):
        if data is None:
            data = {}
        if accessed is None:
            accessed = datetime.now().isoformat()
        return super().__new__(cls, filename, page, cache, data, accessed)
</code></pre>
<p>Arguably, though, you lose some of the benefits of using a <code>NamedTuple</code> in the first place, and may as well just write the subtype yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quite a beautiful answer, that requires <code>pip install attrs</code> (which inspires <code>dataclass</code>)</p>
<pre><code>import attr

@attr.s
class PdfFileRecord:
    name: str = attr.ib()
    type: str = attr.ib()
    cache: dict = attr.ib()
    data: dict = attr.ib(factory=dict)
    accessed: str = attr.ib(factory =lambda: datetime.now().isoformat())
</code></pre>
<p>For the <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclass</code></a> version, no need to <code>pip</code>, but <a href="https://pypi.org/project/dataclasses/" rel="nofollow noreferrer">at least Python 3.6 is needed</a>.</p>
<pre><code>import dataclasses

@dataclasses.dataclass
class PdfFileRecord:
    name: str
    type: str
    cache: dict
    data: dict = dataclasses.field(default_factory =dict)
    accessed: str = dataclases.field(default_factory =lambda: datetime.now().isoformat())
</code></pre>
</div>
<span class="comment-copy">You also share the same default data dict between instances, probably a bug.</span>
<span class="comment-copy">@wim It works, thank. But it is hard to backport beyond Python 3.6.</span>
<span class="comment-copy">Did you read the answer in the question you linked?</span>
<span class="comment-copy">@wim Thanks to you, I have found <a href="http://www.attrs.org/en/stable/examples.html#other-goodies" rel="nofollow noreferrer"><code>__attrs_post_init__ </code></a></span>
<span class="comment-copy">@user2357112 <code>__new__</code> is just as equally broken.</span>
<span class="comment-copy">You don't need the heavyweight <code>__post_init__</code> solution just to have a dynamically computed default. <code>dataclasses.field</code> supports both <code>default</code> and <code>default_factory</code>, the former for values, the latter for callables. So <code>field(default_factory=lambda: datetime.now().isoformat())</code> would do the trick without needing <code>__post_init__</code>.</span>
<span class="comment-copy">@ShadowRanger  Excellent!  Please edit it directly into the answer, if you feel so inclined.</span>
<span class="comment-copy">Can you explain overriding <code>__new__</code> here.  It seems you are able to set the class attributes at class creation, correct?</span>
<span class="comment-copy">Not set them, exactly, but intercept the arguments.  Overriding <code>__new__</code> instead of <code>__init__</code> is typical when subclassing immutable types such as tuples, datetimes, etc</span>
<span class="comment-copy">You know, you can <code>&gt; pip install dataclasses</code> to Python 3.6.  <a href="https://pypi.org/project/dataclasses/" rel="nofollow noreferrer">pypi.org/project/dataclasses</a>.  What version of Python are you using?</span>
<span class="comment-copy">I am using Python 3.7, but I plan to share my code.</span>
<span class="comment-copy">Note: Now that you've fixed your code per @wim, you might have noticed you don't need <code>__attrs_post_init__</code> at all. You could just define <code>accessed</code> as <code>accessed: str = attr.ib(init=False, factory=lambda: datetime.now().isoformat())</code> and now you don't need <code>__attrs_post_init__</code> at all (and you've avoided separating the information about the default value from the information about the attribute itself).</span>
