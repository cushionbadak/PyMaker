<div class="post-text" itemprop="text">
<p>All I need to do is to create 1 list with all these values without sublists.</p>
<pre><code>example = ['a', ['c', 1, 3], ['f', 7, [4, '4']], [{'lalala': 111}]]
newArray = []

def func(array):
    for i in array:
        for z in i:
            newArray.append(z)

print(func(example))
</code></pre>
<p>The result here would be: ['a', 'c', 1, 3, 'f', 7, [4, '4'], {'lalala': 111}].
When I add 3rd for it would say that 'int' object is not iterable. Do I need somehow check whether the item is int or string and then skip them? Or am I missing something?</p>
<p>P.S. I believe this is done with the recursive functions, but I have no clue about them :(</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one example of recursive function that flattens your list : </p>
<pre><code>def flatten(l):
    if type(l) is list:
        if not l:
            return []
        if len(l) == 1 :
            return flatten(l[0])
        else:
            return flatten(l[0]) + flatten(l[1:])
    else:
        return [l]
</code></pre>
<p>Result is ['a', 'c', 1, 3, 'f', 7, 4, '4', {'lalala': 111}]</p>
</div>
<div class="post-text" itemprop="text">
<p>Using recursive function. Enjoy!</p>
<p><strong>Code:</strong></p>
<pre><code>example = ['a', ['c', 1, 3], ['f', 7, [4, '4']], [{'lalala': 111}]]
newArray = [] 

def super_extend(v):
        if type(v) is list:
            [super_extend(x) for x in v if x is not None]
        if type(v) is dict:
            {k:super_extend(v) for k,v in v.items() if v is not None}
        if type(v) is str or isinstance(v, int) or isinstance(v, float) :
            newArray.append(v)

super_extend(example)
print(newArray)
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>['a', 'c', 1, 3, 'f', 7, 4, '4', 111]
[Finished in 0.078s]
</code></pre>
<p>In case you don't want the dictionaries to stay as dictionaries and only want the values. You can use this. But if you want to keep the keys all you need to do is use:</p>
<pre><code>if type(v) is dict:
        {super_extend(v):super_extend(k) for k,v in v.items() if v is not None}
</code></pre>
<p>Then the output would be:</p>
<pre><code>['a', 'c', 1, 3, 'f', 7, 4, '4', 'lalala', 111]
[Finished in 0.077s]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a recursive generator function:</p>
<pre><code>def flatten(l):
    if isinstance(l, list):
        for x in l:
            yield from flatten(x)
    else:
        yield l

&gt;&gt;&gt; list(flatten(example))
['a', 'c', 1, 3, 'f', 7, 4, '4', {'lalala': 111}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>List methods</h3>
<p>The <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>list</code></a> object offers two different methods to add new items to a given <code>list</code>:</p>
<ol>
<li><p><strong>list.append(x):</strong> Add an item to the end of the list. Equivalent to a[len(a):] = [x].</p></li>
<li><p><strong>list.extend(iterable):</strong> Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.</p></li>
</ol>
<h3>Example</h3>
<pre><code>old_list = ['a', ['c', 1, 3], ['f', 7, [4, '4']], [{'lalala': 111}]]
new_list = []

for element in old_list:
    new_list.extend(element)

print(new_list)
</code></pre>
<p><strong>Result</strong></p>
<pre><code>['a', 'c', 1, 3, 'f', 7, [4, '4'], {'lalala': 111}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you are looking for something like this:</p>
<pre><code>example = ['a', ['c', 1, 3], ['f', 7, [4, '4']], [{'lalala': 111}]]

def func(array):
    newArray = []
    for i in array:
        if((type(i)==int) or (type(i)==str)):
            newArray.append(i)
        elif(type(i)==dict ):
            keys = i.keys()
            values = i.values()
            newArray.append(keys[0])
            newArray.append(values[0])
        else:
            for z in i:            
                newArray.append(z)
    return newArray

print(func(example))
print(func(func(example)))
print(func(func(func(example))))
</code></pre>
<p>result:</p>
<pre><code>['a', 'c', 1, 3, 'f', 7, [4, '4'], {'lalala': 111}]
['a', 'c', 1, 3, 'f', 7, 4, '4', 'lalala', 111]
['a', 'c', 1, 3, 'f', 7, 4, '4', 'lalala', 111]
</code></pre>
</div>
<span class="comment-copy">look at <code>extend</code></span>
<span class="comment-copy">I don't think that the desired output is ['a', 'c', 1, 3, 'f', 7, [4, '4'], {'lalala': 111}] because author's function already does it</span>
<span class="comment-copy">@roganjosh, this is his current result when I ran his code. It's not the output he desires. He did not post his desired output, he clearly stated he wanted to expand more but adding a third loop was running with the error of iterating on integers which is not possible. He also added the possible use of recursive function which I did use.</span>
<span class="comment-copy">@Taras this should be the accepted answer. Much more elegant than my solution if you use python 3.3+ (should be mentioned in the answer though)</span>
