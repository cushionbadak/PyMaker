<div class="post-text" itemprop="text">
<p>I know how to cast to a string, but how does casting to a string actually work? Like if I were to write my own function in python to replace the current str() function how would I do that?</p>
</div>
<div class="post-text" itemprop="text">
<h2><code>str</code> as a type</h2>
<p>You cannot replace the <code>str</code> type. It is a base type which cannot be mimicked with a Python class without using <code>str</code> itself.</p>
<p>In the same way, you could not write an <code>int</code> class without using <code>int</code> as it is your builtin way to represent cardinal values.</p>
<p>This happens because Python is a high-level language. You can think of it as an API for using a lot of well-crafted C functions, in the case of CPython. This means you do not have access to key components such as pointers, bit manipulation and memory allocation that would allow you to reimplement some types such as <code>int</code>, <code>str</code> or <code>tuple</code> without somehow using them in the process.</p>
<h2><code>str</code> cast</h2>
<p>At a more basic level, if what you want is to know how the piping for casting to a string works, it is relatively straightforward.</p>
<p>The function <code>str</code> will call the <code>__str__</code> method of the object to cast. If it does not exist, it falls back on <code>repr</code>.</p>
<pre><code>def str(obj=''):
    if hasattr(obj, '__str__'):
        return obj.__str__()
    else:
        return repr(obj)
</code></pre>
<p>It is the responsibility of the object to format a <code>str</code> to be returned by its <code>__str__</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the dunder method <code>__str__</code> to override that of <code>object</code>, and return an intelligible message.</p>
<pre><code>class Example:
    def __init__(self, example='an example'):
        self.example = example
    def __str__(self):
        return f'here is the str representation of {self.example}'
</code></pre>
<p>example:</p>
<pre><code>e = Example()
print(e)   # equivalent to calling print(str(e))
</code></pre>
<p>outputs:</p>
<pre><code>here is the str representation of an example
</code></pre>
<p>Without the <code>__str__</code> method, it would revert to using the <code>object</code> one, and the output would be something like this:</p>
<pre><code>&lt;__main__.Example object at 0x10f8da4a8&gt;
</code></pre>
<hr/>
<p>Here is a link to <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">the Python Data Model</a> <code>__str__</code> part<br/>
and a link to the <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">python documentation</a> about <code>str</code> objects<br/>
where you will find additional background information.</p>
</div>
<span class="comment-copy">What do you want your replacement <code>str</code> function do? This can be done, but you have to be more specific about your use case.</span>
<span class="comment-copy">If you want to know how the <code>str</code> class actually works then first read the doc., <a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#str</a> then look at the source code of the implementation you are using.</span>
<span class="comment-copy">You both (Olivier &amp; @JeanFrancoisFabre) make me doubt if I understood the question correctly?!? Or maybe we interpreted it at various distinct levels?</span>
<span class="comment-copy">I don't think that first statement is correct. For example, if I wanted to convert the integer 42 to a string I simply need to do some math and a lookup of the ascii table to learn what ascii character represents the digit 4 and which represents the digit 2. The reverse is also possible. I can convert the string "42" to an integer by looking at each character and assigning a value to the character "4" and the character "2", and doing math based on the location of the character in the string.</span>
<span class="comment-copy">@ReblochonMasque We do have two different interpretations. Mine is that you cannot reimplement str as your would implement, say, defaultdict because it is purely in C. Although, your point that you can have a wrapper around a string to have your own class is a valuable point as well</span>
<span class="comment-copy">@BryanOakley: but <code>"42"</code> will always be an <code>str</code> object, not your own class (unless you change the implementation source).</span>
<span class="comment-copy">@BryanOakley Yes, but you are using a str in the process. By example you could implement a Counter without using a Counter, because it is fairly high level. Although a low-level (C-level) type such as str cannot be implemented without somehow using str, implicitly or explicitly.</span>
