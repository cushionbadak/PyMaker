<div class="post-text" itemprop="text">
<p>I am looking to see if there is a good way to create a wrapping object.  </p>
<pre><code>class Thing_A(object):pass

class Thing_B(object):pass

class Wrapper(object):
    def __init__(self, thing):
        self.thing = thing
</code></pre>
<p>I am looking for a solution I can write in Wrapper class (or potentially a metaclass of Wrapper) so the following code is accurate. I don't have ability to change Thing_A or Thing_B classes in my real world scenario.</p>
<pre><code>a_thing = Thing_A()
b_thing = Thing_B()
wrapper_a = Wrapper(a_thing)
wrapper_b = Wrapper(b_thing)

isinstance(wrapper_a, Thing_A) #needs to returns True
isinstance(wrapper_b, Thing_B) #needs to returns True
isinstance(wrapper_a, Thing_B) #needs to returns False
isinstance(wrapper_a, Wrapper) #needs to returns True
isinstance(wrapper_b, Wrapper) #needs to returns True
</code></pre>
<p>I tried looking at <code>__new__</code>, metaclasses and type class creation but I am not getting the result I want. If there is a better way to go at this without directly subclassing Thing_A or Thing_B please let me know. I also found that <code>__instancecheck__</code> but because I can't change Thing_A class or Thing_B class, I can't use it.</p>
<p>Thanks,
Jason</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what you mean by this:</p>
<blockquote>
<p>I also found that <code>__instancecheck__</code> is possible to use for the last two <code>isinstance</code> checks but not the first two.</p>
</blockquote>
<p>For the last two, you don't need to do anything. The default <code>type.__instancecheck__</code> is already going to return <code>True</code>, because your objects really are <code>Wrapper</code> instances.</p>
<p>For the first two, it certainly is possible. Obviously it depends on how you implement the <a href="https://docs.python.org/3/reference/datamodel.html#class.__instancecheck__" rel="nofollow noreferrer"><code>__instancecheck__</code></a>, but any option you pick will work here, as long as you make it look at something on the instance.</p>
<hr/>
<p>Rather than hardcode something that looks at <code>self.thing</code>, let's write something more general: a protocol where any object can declare, dynamically, that it wants to be an instance of <code>Thing_A</code> or <code>Thing_B</code> by just adding it to some iterable called <code>self._fakebases</code>. So, <code>isinstance(thing, Thing_B)</code> will be true if <code>Thing_B</code> is in <code>type(thing).__bases__</code> (the usual rule) <em>or</em> in <code>thing._fakebases</code> (the rule you want to add):</p>
<pre><code>class Fakey(type):
    def __instancecheck__(self, inst):
        if super().__instancecheck__(inst):
            return True
        try:
            if self in inst._fake_bases:
                return True
        except AttributeError:
            pass
        return False

class Thing_A(metaclass=Fakey): pass

class Thing_B(metaclass=Fakey): pass
</code></pre>
<p>Now, <code>wrapper</code> can support that protocol by setting <code>_fake_bases</code>:</p>
<pre><code>class Wrapper(object):
    def __init__(self, thing):
        self.thing = thing
        self._fake_bases = {type(thing)}
</code></pre>
<p>â€¦ or, maybe even better, use a <code>property</code>:</p>
<pre><code>class Wrapper(object):
    def __init__(self, thing):
        self.thing = thing
    @property
    def _fake_bases(self):
        return {type(self.thing)}
</code></pre>
<p>Notice that <code>Wrapper</code> doesn't have to use the <code>Fakey</code> metaclass, because the default <code>__instancecheck__</code> rules work fine with <code>Wrapper</code> as the class; it's <code>Thing_A</code> and <code>Thing_B</code> where you want different behavior.</p>
<p>And here's that different behavior:</p>
<pre><code>&gt;&gt;&gt; a_thing = Thing_A()
&gt;&gt;&gt; b_thing = Thing_B()
&gt;&gt;&gt; wrapper_a = Wrapper(a_thing)
&gt;&gt;&gt; wrapper_b = Wrapper(b_thing)
&gt;&gt;&gt; isinstance(wrapper_a, Thing_A) #needs to returns True
True
&gt;&gt;&gt; isinstance(wrapper_b, Thing_B) #needs to returns True
True
&gt;&gt;&gt; isinstance(wrapper_a, Thing_B) #needs to returns False
False
&gt;&gt;&gt; isinstance(wrapper_a, Wrapper) #needs to returns True
True
&gt;&gt;&gt; isinstance(wrapper_b, Wrapper) #needs to returns True
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do your best to look for other solutions. This kind of thing is prone to a lot of weird bugs, and it's going to be even more of an arcane mess to debug than it will be to write.</p>
<p>That said, if you really want to give yourself this maintenance nightmare, then the way to do it is to lie about <code>__class__</code>:</p>
<pre><code>class Wrapper(object):
    def __init__(self, thing):
        self.thing = thing
    @property
    def __class__(self):
        return self.thing.__class__
</code></pre>
<p><a href="https://ideone.com/bmfSr2" rel="nofollow noreferrer">Ideone demo.</a></p>
<p>This only handles <code>isinstance</code>; if you want to forward attribute lookup to <code>self.thing</code>, you'll need to implement a forwarding <code>__getattr__</code> or <code>__getattribute__</code>, and if you want magic methods to work, you're going to have to separately define forwarding implementations of every magic method you want to forward to <code>self.thing</code>.</p>
</div>
<span class="comment-copy">If you want to see it done, I've written code that actually does this before (as a component in a system used in production at a former employer). See <a href="https://web.dyfis.net/bzr/isg_state_machine_framework/" rel="nofollow noreferrer">web.dyfis.net/bzr/isg_state_machine_framework</a> -- the directory looks empty over a standard web browser but can be checked out with <a href="http://bazaar.canonical.com/en/" rel="nofollow noreferrer">Bazaar</a> for the source tree. Metaclasses were indeed a component of that solution.</span>
<span class="comment-copy">Have you tried 'forwarding' the call of the first 2 examples to the original class in <code>self.thing</code>?  So you'd do something like <code>return isinstance(instance, self.thing)</code> to pass it to the wrapped class</span>
<span class="comment-copy">ok the only problem that I have with this solution is that in the actual problem. I can't change the classes Thing_A and Thing_B and I already have the instances (I am not calling the constructors.).</span>
<span class="comment-copy">You are correct as written the last two isinstance checks work. I goofed, they didn't work with my attempt locally with changing <b>new</b> behavior.</span>
<span class="comment-copy">@JasonJones Well, you <i>have</i> to be able to change <code>Thing_A</code> and <code>Thing_B</code>. If you can't edit their code, or monkeypatch them, or replace them with wrapper classes around the real classes, then you can't hook their instance checks. (Well, I suppose you could wrap up the <code>isinstance</code> function instead, but that feels even uglier.)</span>
<span class="comment-copy">@JasonJones As for already having the wrapper objects and not calling the constructors, that part is trivial. If you don't understand how to set or modify the instance attribute <code>_fake_bases</code> on an existing object, you really shouldn't be coming anywhere near this kind of code.</span>
<span class="comment-copy">I have not problem adding/modifying ._fake_bases on an object. The problem is I can't change Thing_A or Thing_B classes.  I can/could overwrite the class __metaclass__but since one already exists, I don't know ramifications of changing it to Fakey type. I don't know how safe that solution would be.</span>
<span class="comment-copy">I was really hoping to avoid this and find a different type of design pattern instead.</span>
