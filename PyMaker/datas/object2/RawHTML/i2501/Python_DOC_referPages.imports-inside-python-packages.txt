<div class="post-text" itemprop="text">
<p>I was facing import error (ImportError: cannot import name 'ClassB') in following code:</p>
<p>dir structure:</p>
<pre><code>main.py
test_pkg/
    __init__.py
    a.py
    b.py
</code></pre>
<p><code>main.py</code>:</p>
<pre><code>from test_pkg import ClassA, ClassB
</code></pre>
<p><code>__init__.py</code>:</p>
<pre><code>from .a import ClassA
from .b import ClassB
</code></pre>
<p><code>a.py</code>:</p>
<pre><code>from test_pkg import ClassB
class ClassA:
    pass
</code></pre>
<p><code>b.py</code>:</p>
<pre><code>class ClassB:
    pass
</code></pre>
<p>in past i fixed it by quick 'experiment' by adding full name in import in a.py:</p>
<pre><code>from test_pkg.b import ClassB
class ClassA:
    pass
</code></pre>
<p>I have read about import machinery and according to :</p>
<p><em>This name will be used in various phases of the import search, and it may be the dotted path to a submodule, e.g. foo.bar.baz. In this case, Python first tries to import foo, then foo.bar, and finally foo.bar.baz.</em> <a href="https://docs.python.org/3/reference/import.html#searching" rel="nofollow noreferrer">link2doc</a></p>
<p>I was expecting it will fail again, because it will try to import test_pkg during test_pkg import, but it is working. My question is why?</p>
<p>Also 2 additional questions:</p>
<ol>
<li>is it proper approach to have cross modules dependencies?</li>
<li>is it ok to have modules imported in package <strong>init</strong>.py?</li>
</ol>
<hr/>
<p>My analysis:</p>
<p>Based on readings i recognized that high probably issue is that, because off</p>
<pre><code>__init__.py:
from .a import ClassA
from .b import ClassB
</code></pre>
<p>ClassA and ClassB import is executed as part of test_pkg import, but then hits import statement in a.py:</p>
<pre><code>a.py:
from test_pkg import ClassB
class ClassA:
    pass
</code></pre>
<p>and it fail because circular dependency occured.</p>
<p>But is working when is imported using:</p>
<pre><code>from test_pkg.b import ClassB
</code></pre>
<p>and according to my understanding it shouldnt, because: </p>
<blockquote>
<p>This name will be used in various phases of the import search, and it
  may be the dotted path to a submodule, e.g. foo.bar.baz. In this case,
  Python first tries to import foo, then foo.bar, and finally
  foo.bar.baz. If any of the intermediate imports fail, a
  ModuleNotFoundError is raised.</p>
</blockquote>
<p>so i was expecting same behavior for both imports.</p>
<p>Looks like import with full path is not launching problematic test_pkg import process</p>
<pre><code>from test_pkg.b import ClassB
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your file is named <code>b.py</code>, but you're trying to <code>import B</code>, not <code>import b</code>.</p>
<p>Depending on your platform (see <a href="https://www.python.org/dev/peps/pep-0235/" rel="nofollow noreferrer">PEP 235</a> for details), this may work, or it may not. If it doesn't work, the symptoms will be exactly what you're seeing: <code>ImportError: cannot import name 'B'</code>.</p>
<p>The fix is to <code>from test_okg import b</code>. Or, if you want the module to be named <code>B</code>, rename the file to <code>B.py</code>.</p>
<p>This actually has nothing to do with packages (except that the error message you get says <code>cannot import name 'B'</code> instead of <code>No module named 'B'</code>, because in a failed <code>from â€¦ import</code> statement, Python can't tell whether you were failing to import a module from a package, or some global name from a module).</p>
<hr/>
<p>So, why does this work?</p>
<pre><code>from test_pkg.b import B
</code></pre>
<blockquote>
<p>I was expecting it will fail again, because it will try to import test_pkg during test_pkg import, but it is working. My question is why?</p>
</blockquote>
<p>Because importing <code>test_pkg</code> isn't the problem in the first place; importing <code>test_pkg.B</code> is. And you solved that problem by importing <code>test_pkg.b</code> instead.</p>
<p><code>test_pkg.b</code> is successfully found in <code>test_pkg/b.py</code>.</p>
<p>And then, <code>test_pkg.b.B</code> is found within that module, and imported into your module, because of course there's a <code>class B:</code> statement in <code>b.py</code>.</p>
<hr/>
<p>For your followup questions:</p>
<blockquote>
<p>is it proper approach to have cross modules dependencies?</p>
</blockquote>
<p>There's nothing wrong with cross-module dependencies as long as they aren't circular, and yours aren't.</p>
<p>It's perfectly fine for <code>test_pkg.a</code> to import <code>test_pkg.b</code> with an absolute import, like <code>from test_pkg import b</code>. </p>
<p>However, it's usually better to use a relative import, like <code>from . import b</code> (unless you need dual-version code that works the same on Python 2.x and 3.x). <a href="https://www.python.org/dev/peps/pep-0328/" rel="nofollow noreferrer">PEP 328</a> explains the reasons why relative imports are usually better for intra-package dependencies (and why it's only "usually" rather than "always").</p>
<blockquote>
<p>is it ok to have modules imported in package <code>__init__.py</code>?</p>
</blockquote>
<p>Yes. In fact, this is a pretty common idiom, used for multiple purposes.</p>
<p>For example, see <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/__init__.py" rel="nofollow noreferrer"><code>asyncio.__init__.py</code></a>, which imports all of the public exports from each of its submodules and re-exports them. There are a handful of rarely-used names in the submodules, which don't start with <code>_</code> but aren't included in <code>__all__</code>, and if you want to use those you need to import the submodule explicitly. But everything you're likely to need in a typical program is included in <code>__all__</code> and re-exported by the package, so you can just write, e.g., <code>asyncio.Lock</code> instead of <code>asyncio.locks.Lock</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code I would prefer to write is probably:</p>
<p><code>main.py</code>:</p>
<pre><code>from test_pkg import A, B
</code></pre>
<p><code>b.py</code>:</p>
<pre><code>class B:
    pass
</code></pre>
<p><code>a.py</code>:</p>
<pre><code>from .b import B

class A:
    pass
</code></pre>
<p><code>__init__.py</code>:</p>
<pre><code>from .a import A
from .b import B
</code></pre>
<p><code>main.py</code>:</p>
<pre><code>from test_pkg import A, B
</code></pre>
<ol>
<li><p>The proper approach is to have cross module dependencies but not circular. You should figure out the hierarchy of your project and arrange your dependency graph in a DAG (directed acyclic graph).</p></li>
<li><p>what you put in package <code>__init__.py</code> will be what you can access thru the package. Also you can refer to this <a href="https://stackoverflow.com/questions/44834/can-someone-explain-all-in-python">question</a> for the use of <code>__all__</code> in <code>__init__.py</code>.</p></li>
</ol>
</div>
<span class="comment-copy">changed class names to make code more clear</span>
<span class="comment-copy">hi, thanks for answer, i am not getting what exactly you mean by the first part of your answer. behavior of code is not pointing to your expolanation, bacause the import is working ok in main.py, but is broken after reimport is included. i will add my view on problem to question</span>
<span class="comment-copy">i have updated question little bit to point exactly to what am i asking. Thanks for answering 'additional' questions.</span>
