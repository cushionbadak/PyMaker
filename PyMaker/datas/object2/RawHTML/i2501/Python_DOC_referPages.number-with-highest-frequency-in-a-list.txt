<div class="post-text" itemprop="text">
<p>I am trying to write a program that will show me the number that appears most frequently in a list. I am trying to do this without importing any libraries. So far I have something that will give me the number of times the most frequent # appears but I want the number itself, not how many times it appears. How can I change what I have so far in a simple way to do this?</p>
<pre><code>def freq(L):
    st = []
    L.sort()
    for i in L:
        st.append(L.count(i))
    print max(st)
</code></pre>
<p>EDIT: for example, freq([4, 6, 4, 3, 9, 1, 4]) is returning 3 since 4 appears 3 times. But I would like it to return 4 as in the most frequent value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try dictionaries</p>
<pre><code>def freq(L):
     st = {}
     for i in set(L):
        st.update({L.count(i):i})
     print (st.get(max(st)))
</code></pre>
<p>or shorter:</p>
<pre><code>def freq(L):
    st={L.count(i):i for i in set(L)}
    print (st.get(max(st)))
</code></pre>
<p>another solution without dictionaries:</p>
<pre><code>def freq(L):
    a=0
    b=None
    for e in set(L):
        if L.count(e)&gt;a:
            a=L.count(e)
            b=e
    print(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>list.count</code> has O(<em>n</em>) complexity, given <em>n</em> values in your list. If there are <em>m</em> unique values, this means your algorithm will have minimum O(<em>m</em> x <em>n</em>) complexity. This isn't desirable.</p>
<p>One O(<em>n</em>) solution is to create a counting dictionary and increment values as you iterate:</p>
<pre><code>lst = [1, 2, 3, 3, 3, 2, 1, 3, 3]

def freq(L):
    d = {}
    for num in L:
        d[num] = d.get(num, 0) + 1
    maxcount = max(d.values())
    return next(k for k, v in d.items() if v == maxcount)

freq(lst)  # 3
</code></pre>
<p>Of course, with <code>collections.Counter</code> the syntax is trivial:</p>
<pre><code>from collections import Counter

def freq(L):
    return Counter(L).most_common()[0][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way to do it with list comprehensions:</p>
<p><code>mostFrequentNumber = L[max([(L.count(d), i) for i, d in enumerate(L)])[1]]</code></p>
<p>To break it down:</p>
<p>We iterate an enumerated version of the list:
<code>i, d in enumerate(L)</code>, which will produce tuples with the value and index. Then we create a list of tuples with the <code>count</code> of <code>d</code> and the index, <code>i</code>: <code>(L.count(d), i)</code>. We use the Max function to get the one with the highest count. Then we index the list <code>L</code> using the highest value at index <code>[1]</code> in the tuple.</p>
<p>This input: <code>L = [1, 1, 1,  2, 3, 4]</code> will then produce 1 as a result, although may not be the most efficient.</p>
</div>
<span class="comment-copy">Potentially float numbers or strictly integers?</span>
<span class="comment-copy">Use <code>collections.Counter</code> to replace most of the code you've written -- that gives you a dict with the frequency of each item in the list.  Reverse the dict.  Apply <code>max</code> to the keys.  Now just use that as the index into the reversed dict.  This will return <i>one</i> most-frequent item.</span>
<span class="comment-copy">When you say, "without importing any libraries", does that include modules in the standard library like <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>? If it does, why are you avoiding those libraries? Is this a learning exercise?</span>
<span class="comment-copy">Hi, could you give an example of the input data and what you want the output to be?</span>
<span class="comment-copy">@Prune, Note that <code>Counter</code> does have a <code>most_common</code> method, which means there's no need to manually calculate the max of your values.</span>
