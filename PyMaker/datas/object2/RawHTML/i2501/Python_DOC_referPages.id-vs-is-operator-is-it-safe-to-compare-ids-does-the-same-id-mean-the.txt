<div class="post-text" itemprop="text">
<p>How much can I rely on the object's <code>id()</code> and its uniqueness in practice? E.g.:</p>
<ul>
<li>Does <code>id(a) == id(b)</code> mean <code>a is b</code> or vice versa? What about the opposite?</li>
<li>How safe is it to save an <code>id</code> somewhere to be used later (e.g. into some registry instead of the object itself)?</li>
</ul>
<p><sub>(Written as a proposed canonical in response to <a href="https://meta.stackoverflow.com/questions/373074/canonicals-for-python-are-objects-with-the-same-id-the-same-object-is-oper">Canonicals for Python: are objects with the same id() the same object, `is` operator, unbound method objects</a>)</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/library/functions.html?highlight=id#id" rel="nofollow noreferrer"><code>id()</code> documentation</a>, an <code>id</code> is only guaranteed to be unique</p>
<ol>
<li>for the lifetime of the specific object, and</li>
<li>within a specific interpreter instance</li>
</ol>
<p>As such, <strong>comparing <code>id</code>s is not safe unless you also somehow ensure that both objects whose <code>id</code>s are taken are still alive at the time of comparison</strong> (and are associated with the same Python interpreter instance, but you need to really try to make that become false).</p>
<p>Which is exactly what <code>is</code> does -- which makes comparing <code>id</code>s redundant. If you cannot use the <code>is</code> syntax for whatever reason, there's always <a href="https://docs.python.org/3/library/operator.html?highlight=operator#operator.is_" rel="nofollow noreferrer"><code>operator.is_</code></a>.</p>
<hr/>
<p>Now, <strong>whether an object is still alive at the time of comparison is not always obvious</strong> (and sometimes is grossly <i>non</i>-obvious):</p>
<ul>
<li><p><strong>Accessing some attributes</strong> (e.g. <a href="https://stackoverflow.com/questions/13348031/ids-of-bound-and-unbound-method-objects-sometimes-the-same-for-different-o">bound methods of an object</a>) <strong>creates a new object each time.</strong> So, the result's <code>id</code> may or may not be the same on each attribute access.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; class C(object): pass
&gt;&gt;&gt; c=C()
&gt;&gt;&gt; c.a=1

&gt;&gt;&gt; c.a is c.a
True        # same object each time

&gt;&gt;&gt; c.__init__ is c.__init__
False       # a different object each time

# The above two are not the only possible cases.
# An attribute may be implemented to sometimes return the same object
# and sometimes a different one:
@property
def page(self):
    if check_for_new_version():
        self._page=get_new_version()
    return self._page
</code></pre></li>
<li><p>If an object <strong>is created as a result of calculating an expression and not saved anywhere, it's immediately discarded,</strong><sup>1</sup> and any object created after that can take up its <code>id</code>.</p>
<ul>
<li><p>This is even true within the same code line. E.g. the result of <code>id(create_foo()) == id(create_bar())</code> is undefined.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; id([])     #the list object is discarded when id() returns
39733320L
&gt;&gt;&gt; id([])     #a new, unrelated object is created (and discarded, too)
39733320L      #its id can happen to be the same
&gt;&gt;&gt; id([[]])
39733640L      #or not
&gt;&gt;&gt; id([])
39733640L      #you never really know
</code></pre></li>
</ul></li>
</ul>
<hr/>
<p>Due to the above safety requirements when comparing <code>id</code>s, saving an <code>id</code> instead of the object is not very useful because you have to save a reference to the object itself anyway -- to ensure that it stays alive. Neither is there any performance gain: <a href="https://github.com/python/cpython/blob/master/Modules/_operator.c#L691" rel="nofollow noreferrer"><code>is</code> implementation is as simple as comparing pointers</a>.</p>
<hr/>
<p>Finally, as an internal optimization (and implementation detail, so this may differ between implementations and releases), CPython reuses some often-used simple objects of immutable types. As of this writing, that includes <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">small integers</a> and <a href="https://stackoverflow.com/questions/17679861/does-python-intern-strings">some strings</a>. So even if you got them from different places, their <code>id</code>s might coincide.</p>
<p>This does not (technically) violate the above <code>id()</code> documentation's uniqueness promises: the reused object stays alive throughout all the reuses.</p>
<p>This is also not a big deal because whether two variables point to the same object or not is only practical to know if the object is mutable: <a href="https://stackoverflow.com/questions/29785084/changing-one-list-unexpectedly-changes-another-too">if two variables point to the same mutable object, mutating one will (unexpectedly) change the other, too</a>. Immutable types don't have that problem, so for them, it doesn't matter if two variables point to two identical objects or to the same one.</p>
<hr/>
<p><sup>1</sup><sub>Sometimes, this is called "unnamed expression".</sub></p>
</div>
<span class="comment-copy"><code>(something is something) == (id(something) is id(something))</code> returns <code>True</code></span>
<span class="comment-copy">@U9-Forward not necessarily if evaluating <code>something</code> returns a new object each time. That's the whole reason for the confusion.</span>
<span class="comment-copy">Yeah that's right</span>
<span class="comment-copy">This badly needs actual examples: 1) some unnamed expressions e.g. <code>(t+t), (t+2)</code> 2) some bound and unbound method objects: <code>a.method1</code>, <code>a.method2</code>, <code>b.method1</code>... 3) string expressions, such as <code>s = "food"</code> <code>s1 = s[0:3]</code> <code>s2 = s[0:3]</code> . Otherwise it will go totally over the heads of new users. They won't even understand the terms and how they relate to code.</span>
<span class="comment-copy">@smci I tried to add examples, but they only make things more confusing and distract from the ubiquitous nature of the phenomena. The examples you gave either mix in other phenomena (special ids for ints), or are not counterintuitive (slices), or are already there (reference link to explanation for bound methods).</span>
