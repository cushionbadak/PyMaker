<div class="post-text" itemprop="text">
<p>I have a list</p>
<pre><code>[[0.5, 2], [0.5, 5], [2, 3], [2, 6], [2, 0.6], [7, 1]]
</code></pre>
<p>I require the output from summing the second element in each sublist for a unique first element. In this case it is:</p>
<pre><code>[[0.5, 7], [2, 9.6], [7, 1]]
</code></pre>
<p>Where <code>[0.5, 7]</code> is summing the second element of <code>[0.5, 2]</code> and <code>[0.5, 5]</code>.</p>
<p>What would be the most efficient way to do this for say lists of length 1,000.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accumulate with a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; data = defaultdict(int)
&gt;&gt;&gt; L = [[0.5, 2], [0.5, 5], [2, 3], [2, 6], [2, 0.6], [7, 1]]
&gt;&gt;&gt; for k, v in L:
...     data[k] += v
...     
&gt;&gt;&gt; [[k,v] for (k,v) in data.items()]
[[0.5, 7], [2, 9.6], [7, 1]]
</code></pre>
<p>Note that the value for 2 was automatically "promoted" to a float by addition, even though this is a defaultdict of int.  This is to match the desired output posted in the question, but I think you should consider to use homogeneous output types rather than a mix of int and float.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using Pandas, you can retain the original 'order' of the data:</p>
<pre><code>pairs = [[0.5, 2], [0.5, 5], [2, 3], [2, 6], [2, 0.6], [7, 1]]
df = pd.DataFrame(pairs)
&gt;&gt;&gt; [tup[0] for tup in zip(df.groupby(0, sort=False, as_index=False).sum().values.tolist())]
[[0.5, 7.0], [2.0, 9.6], [7.0, 1.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Will this work?</p>
<pre><code>L = [[0.5, 2], [0.5, 5], [2, 3], [2, 6], [2, 0.6], [7, 1]]
nums = []
d = {}
for lst in L:
    if lst[0] not in d:
        d[lst[0]] = []
        nums.append(lst[0])
    d[lst[0]].append(lst[1])

for key in nums:
    print [key, sum(d[key])]
</code></pre>
<p>Output:</p>
<pre><code>[0.5, 7]
[2, 9.6]
[7, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get away with sorting and <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from operator import itemgetter
from itertools import groupby

data = [[0.5, 2], [0.5, 5], [2, 3], [2, 6], [2, 0.6], [7, 1]]

key = itemgetter(0)
data.sort(key=key)  # Use data = sorted(data, key=key) to avoid clobbering
result = [[k, sum(group)] for k, group in groupby(data, key)]
</code></pre>
<p>This will not preserve the original order of the keys.</p>
</div>
<span class="comment-copy">Can you use pandas or numpy?  A groupby is the way to go here, its essentially what your asking.  Writing you're own groupby function, if you've never done it before, is a huge pain.</span>
<span class="comment-copy">Is your input list sorted by the first element?</span>
<span class="comment-copy">lists of length 1000 is tiny. pandas/numpy groupy would be quite overkill for that.</span>
<span class="comment-copy">@jpp Not sorted but I want to retain the same order in the output.</span>
<span class="comment-copy">@AndrewK, Then I suggest <code>collections.defaultdict</code>, O(<i>n</i>) complexity and avoids Pandas / NumPy overhead for the small arrays you are working with.</span>
<span class="comment-copy">Thanks. I don't use defaultdict though. How would I get this to a list with the same order as the original?</span>
<span class="comment-copy"><code>list(data.items())</code> should do it on Python 3.6+.</span>
<span class="comment-copy">My input values will all be float. Will this always retain my original ordering of the list?</span>
<span class="comment-copy">To retain original ordering pre-py3.6, use OrderedDict with setdefault.</span>
<span class="comment-copy">How would I get the output to <code>[[0.5, 7], [2, 9.6], [7, 1]]</code> instead of <code>[(0.5, 7), (2, 9.6), (7, 1)]</code>?</span>
