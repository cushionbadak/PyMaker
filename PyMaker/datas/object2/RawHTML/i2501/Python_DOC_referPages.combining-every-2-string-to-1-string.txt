<div class="post-text" itemprop="text">
<p>I have a list a</p>
<pre><code>list = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']
</code></pre>
<p>I want to get a list of strings like <code>["247400015203223811, DPF", "247400015203223813, ZPF"]</code>
combining every 2 strings to 1 string</p>
<p>I tried like
</p>
<pre><code>list2 = []
list = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']

        for i in range(0, len(list), 2):
            list2.append(list[i] + list[i])
</code></pre>
<p>is this even possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You almost had it, you can use this list comprehension:</p>
<pre><code>mylist = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']

mylist2 = [mylist[i]+', '+mylist[i+1]for i in range(0,len(mylist),2)]

&gt;&gt;&gt; mylist2
['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
<p>Make sure you don't use the keyword <code>list</code> as a variable name, because it masks the python built-in type (I changed it to <code>mylist</code> instead)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think slicing and <code>zip</code> can work nicely here:</p>
<pre><code># assuming list of stringals is named `strings`
even_indexed = strings[::2]
odd_indexed = strings[1::2]

# create pairs to join
pairs = zip(even_indexed, odd_indexed)

# join all pairs
result = list(map(', '.join, pairs))
</code></pre>
<p>Can't test but this gets the idea across.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course is possible, and you almost got the answer:<br/>
you simply have to add 1 to the index of the second word:  </p>
<pre><code>list2 = []

list1 = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']

for i in range(0, len(list1), 2):
    list2.append(list1[i] + list1[i+1])

print(list2) # OUTPUT: ['247400015203223811DPF', '247400015203223813ZPF']
</code></pre>
<p>but you maybe want also to have a dot between the 2 words:</p>
<pre><code>list2.append(list1[i] + '.' + list1[i+1]) # OUTPUT: ['247400015203223811.DPF', '247400015203223813.ZPF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One common pattern to pair items in a list is to get an iterator over the list, then <code>zip</code> that iterator with itself.  From there, joining the pairs with <code>", "</code> is as easy as calling <code>str.join</code></p>
<pre><code># Don't reuse the name list, it already has a meaning
list_ = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']

it = iter(list_)

print([", ".join(pair) for pair in zip(it, it)])
# ['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can slice the list, <code>zip</code> the slices and <code>map</code> them to <code>join</code>:</p>
<pre><code>l = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']
print(list(map(', '.join, zip(l[::2], l[1::2]))))
</code></pre>
<p>This outputs:</p>
<pre><code>['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension </p>
<pre><code>list = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']
res = [ ', '.join(x) for x in zip(list[0::2], list[1::2]) ]
</code></pre>
<p>output:</p>
<pre><code>['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's give you the one-line style solution, easily readable:  </p>
<pre><code>list_ = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']
print([", ".join(i) for i in zip(list_[0::2], list_[1::2])])
# ['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
<p>Note that:  </p>
<ul>
<li><code>list_[0::2]</code> is the list of elements of list_ with <strong>even</strong> index</li>
<li><code>list_[1::2]</code> is the list of elements of list_ with <strong>odd</strong> index</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><code>zip</code> the Iterator over the list together with itself in order to get pairs of two.</p>
<p>Demo of the principle:</p>
<pre><code>&gt;&gt;&gt; lst = ['247400015203223811', 'DPF', '247400015203223813', 'ZPF']
&gt;&gt;&gt; it = iter(lst)
&gt;&gt;&gt; list(zip(it, it))
[('247400015203223811', 'DPF'), ('247400015203223813', 'ZPF')]
</code></pre>
<p>Applying the principle in a list comprehension:</p>
<pre><code>&gt;&gt;&gt; [', '.join(s) for s in zip(*[iter(lst)]*2)]
['247400015203223811, DPF', '247400015203223813, ZPF']
</code></pre>
<p>No extra memory for slices or intermediary lists needed. No fiddling around with indexes.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

def grouper(iterable, n, fillvalue=None):
    """ Collect data into fixed-length chunks or blocks.

        grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    """
    args = [iter(iterable)] * n
    return itertools.zip_longest(*args, fillvalue=fillvalue)

x = ["a", "b", "c", "d", "e"]
x_grouped = [", ".join(pair) for pair in grouper(x, 2, "")]

print(x_grouped)  # -&gt; ['a, b', 'c, d', 'e, ']
</code></pre>
<p>You can use the grouper function from an <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools recipe</a>. If you have an odd number of strings in your list, you can specify a fillvalue.</p>
</div>
<span class="comment-copy"><code>str.join</code> should be <code>", ".join</code>, otherwise you'll get a <code>TypeError</code></span>
<span class="comment-copy">Man, that's so clever! Would love to make more than one upvote!</span>
