<div class="post-text" itemprop="text">
<p>I am trying to use a factory function to generate some type annotations – specifically for <code>tuple</code> types. I have one version of the factory that works fine (as in, it compiles, runs, and checks out satisfactorily in MyPy):</p>
<pre class="lang-py prettyprint-override"><code>import typing as tx
HomogenousTypeVar = tx.TypeVar('HomogenousTypeVar')
TupleTypeReturnType = tx.Type[tx.Tuple[HomogenousTypeVar, ...]]

def TupleType(length: int,
              tuptyp: tx.Type[HomogenousTypeVar] = str) -&gt; TupleTypeReturnType:
    """ Create a type annotation for a tuple of a given type and length """
    assert length &gt; 0
    return tx.Tuple[tuple(tuptyp for idx in range(length))]
</code></pre>
<p>… for which the usage is like e.g.: </p>
<pre class="lang-py prettyprint-override"><code>class Thing(object):

    __slots__: TupleType(2) = ('yo', 'dogg')
    other_fields: TupleType(4) = ('i', 'heard',
                                  'you', 'like')

    # etc, or what have you
</code></pre>
<p>… however, I was unsuccessful when I tried to add support for the <code>typing.ClassVar</code> annotation, which looked like this:</p>
<pre class="lang-py prettyprint-override"><code>import typing as tx
HomogenousTypeVar = tx.TypeVar('HomogenousTypeVar')
TupleTypeReturnType = tx.Union[tx.Type[tx.Tuple[HomogenousTypeVar, ...]],
                               tx.Type[tx.ClassVar[tx.Tuple[HomogenousTypeVar, ...]]]]

def TupleType(length: int,
              tuptyp: tx.Type[HomogenousTypeVar] = str,
              clsvar: bool = False) -&gt; TupleTypeReturnType:
    """ Create a type annotation for a tuple of a given type and length,
        specifying additionally whether or not it is a ClassVar """
    assert length &gt; 0
    out = tx.Tuple[tuple(tuptyp for idx in range(length))]
    return clsvar and tx.ClassVar[out] or out
</code></pre>
<p>… after this change, the code won’t even initially compile – it fails to do so with a <code>TypeError</code> from deep within the <code>typing</code> module:</p>
<blockquote>
<p>TypeError: typing.ClassVar[typing.Tuple[~HomogenousTypeVar, ...]] is
  not valid as type argument</p>
</blockquote>
<p>… which, as errors go, strikes me as a little phoned-in; I mean, is not <em>everything</em> in <code>typing</code> supposed to be a valid type argument in some fashion, give-or-take?</p>
<p>In <a href="https://github.com/python/typing/blob/d6631e8ea56063897e341207477e0cc3231f20b2/src/typing.py#L1376-L1430" rel="nofollow noreferrer">the <code>typing</code> source code related to <code>ClassVar</code></a>, there are a handful of restrictions to its use mentioned in the docstring – but this is not one of them. Is there something obvious I am missing? Is my attempt to use this annotation in this fashion a quixotic one? What else might I try?</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure your original code snippet actually type-checks with mypy? When I try running it using either Mypy 0.620 or the latest version from github, I get the following errors:</p>
<pre><code>test.py:13: error: invalid type comment or annotation
test.py:13: note: Suggestion: use TupleType[...] instead of TupleType(...)
test.py:14: error: invalid type comment or annotation
test.py:14: note: Suggestion: use TupleType[...] instead of TupleType(...)
</code></pre>
<p>I'm also not able to reproduce the error you get with your ClassVar code -- when I try running it, I get the following errors:</p>
<pre><code>test.py:4: error: Invalid type: ClassVar nested inside other type
test.py:6: error: Incompatible default for argument "tuptyp" (default has type "Type[str]", argument has type "Type[HomogenousTypeVar]")
test.py:12: error: Invalid type alias
test.py:13: warning: Returning Any from function declared to return "Union[Type[Tuple[HomogenousTypeVar?, ...]], Type[Tuple[HomogenousTypeVar?, ...]]]"
test.py:15: error: Name 'Thing' is not defined
test.py:16: error: Revealed type is 'Any'
</code></pre>
<p>Are you sure you're actually running mypy, as opposed to just running the code? E.g. if you only run <code>python3 test.py</code>, you're basically skipping all type checks (apart from some bare minimum sanity checks built into the typing module). </p>
<p>If you want to type-check your code, you need to pip-install mypy and run <code>python3 -m mypy test.py</code>.</p>
<hr/>
<p>In any case, all of these error messages are expected behavior -- mypy (and any other PEP 484 compliant type checker) can only analyze your code <em>statically</em> and will not attempt to run or analyze any factory functions/any type-hint generation functions you may try and write.</p>
<p>So, this means that unfortunately you won't be able to use your generated type hint with ClassVars if you want PEP 484 compliant tools to be able to analyze your code -- they can't understand/interpret your original set of type hints, and adding ClassVars certainly won't help.</p>
<p>If you want to generate type hints, the only real option I can think of is to invent some sort of mini-language or macro system on top of Python that when run, will generate Python code. You would then run and typecheck that generated code instead of your macrofied Python language.</p>
<p>But I really don't recommend doing this -- it's a very fragile hack.</p>
<hr/>
<p>More broadly, whenever you start running into these sorts of type-related limitations, I think it's a sign that your code is too complicated. I would either look into simplifying your code or (if that's not possible) switch to a language like Haskell or Idris which would let you use a more expressive (albeit more complex) type system.</p>
<p>For example, in this case, you're trying to generalize the Tuple type -- that leads me to infer that your codebase contains many different kinds of tuples of different arities and types.</p>
<p>That strikes me as being a bit suspicious -- I would instead look into converting some of those tuples into either regular classes or (if you still need tuple-like functionality) a <a href="https://mypy.readthedocs.io/en/latest/kinds_of_types.html#named-tuples" rel="nofollow noreferrer">namedtuple</a>. <a href="https://mypy.readthedocs.io/en/latest/additional_features.html#dataclasses" rel="nofollow noreferrer">Dataclasses</a> (which are new <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">as of Python 3.7</a>) could also be convenient here.</p>
<p>Those solutions would also help make your code a little more readable -- you can now give concrete names and meanings to each distinct kind of tuple.</p>
<p>Alternatively, if you have only a few distinct types of tuples but use those tuples all over the place, you could try using <a href="https://mypy.readthedocs.io/en/latest/kinds_of_types.html#type-aliases" rel="nofollow noreferrer">type aliases</a> so you don't have to repeatedly re-type the same (long) type over and over. E.g. instead of doing:</p>
<pre><code>def foo(x: Tuple[int, int, int, int]) -&gt; None: ...
</code></pre>
<p>...you could do:</p>
<pre><code>IpAddress = Tuple[int, int, int, int]

def foo(x: IpAddress) -&gt; None: ...
</code></pre>
</div>
