<div class="post-text" itemprop="text">
<p>As the thread <a href="https://stackoverflow.com/questions/4706499/how-do-you-append-to-a-file">How do you append to a file?</a>, most answer is about open a file and append to it, for instance:</p>
<pre><code>def FileSave(content):
    with open(filename, "a") as myfile:
        myfile.write(content)

FileSave("test1 \n")
FileSave("test2 \n")
</code></pre>
<p>Why don't we just extract <code>myfile</code> out and only write to it when <code>FileSave</code> is invoked.</p>
<pre><code>global myfile
myfile = open(filename)
def FileSave(content):
    myfile.write(content)

FileSave("test1 \n")
FileSave("test2 \n")
</code></pre>
<p>Is the latter code better cause it's open the file only once and write it multiple times?
Or, there is no difference cause what's inside python will guarantee the file is opened only once albeit the <code>open</code> method is invoked multiple times.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a number of problems with your modified code that aren't really relevant to your question: you open the file in read-only mode, you never close the file, you have a <code>global</code> statement that does nothing…</p>
<p>Let's ignore all of those and just talk about the advantages and disadvantages of opening and closing a file over and over:</p>
<ul>
<li>Wastes a bit of time. If you're really unlucky, the file could even just barely keep falling out of the disk cache and waste even more time.</li>
<li>Ensures that you're always appending to the end of the file, even if some other program is also appending to the same file. (This is pretty important for, e.g., syslog-type logs.)<sup>1</sup></li>
<li>Ensures that you've flushed your writes to disk at some point, which reduces the chance of lost data if your program crashes or gets killed.</li>
<li>Ensures that you've flushed your writes to disk <em>as soon as you write them</em>. If you try to open and read the file elsewhere in the same program, or in a different program, or if the end user just opens it in Notepad, you won't be missing the last 1.73KB worth of lines because they're still in a buffer somewhere and won't be written until later.<sup>2</sup></li>
</ul>
<p>So, it's a tradeoff. Often, you want one of those guarantees, and the performance cost isn't a big deal. Sometimes, it is a big deal and the guarantees don't matter. Sometimes, you really need both, so you have to write something complicated where you manually buffer up bits and write-and-flush them all at once.</p>
<hr/>
<p><sub>1. As the Python docs for <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open</code></a> make clear, this will happen anyway on <em>some</em> Unix systems. But not on other Unix systems, and not on Windows..</sub></p>
<p><sub>2. Also, if you have multiple writers, they're all appending a line at a time, rather than appending whenever they happen to flush, which is again pretty important for logfiles.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>In general <code>global</code> should be <a href="https://stackoverflow.com/questions/16011056/how-to-avoid-global-variables">avoided if possible</a>.</p>
<p>The reason that people use the <code>with</code> command when dealing with files is that it explicitly controls the scope. Once the <code>with</code> operator is done the file is closed and the file variable is discarded. </p>
<p>You can avoid using the <code>with</code> operator but then you must remember to call <code>myfile.close()</code>. Particularly if you're dealing with a lot of files. </p>
<p>One way that avoids using the <code>with</code> block that also avoids using global is</p>
<pre><code> def filesave(f_obj, string):
     f_obj.write(string)

 f = open(filename, 'a')
 filesave(f, "test1\n")
 filesave(f, "test2\n")
 f.close()
</code></pre>
<p>However at this point you'd be better off getting rid of the function and just simply doing:</p>
<pre><code>f = open(filename, 'a')
f.write("test1\n")
f.write("test2\n")
f.close()
</code></pre>
<p>At which point you could easily put it within a <code>with</code> block:</p>
<pre><code>with open(filename, 'a') as f:
    f.write("test1\n")
    f.write("test2\n")
</code></pre>
<p>So yes. There's no <strong>hard</strong> reason to not do what you're doing. It's just not very Pythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>The latter code may be more efficient, but the former code is safer because it makes sure that the content that each call to <code>FileSave</code> writes to the file gets flushed to the filesystem so that other processes can read the updated content, and by closing the file handle with each call using <code>open</code> as a context manager, you allow other processes a chance to write to the file as well (specifically in Windows).</p>
</div>
<div class="post-text" itemprop="text">
<p>It really depends on the circumstances, but here are some thoughts:</p>
<p>A <code>with</code> block absolutely guarantees that the file will be closed once the block is exited. Python does not make and weird optimizations for appending files.</p>
<p>In general, globals make your code less modular, and therefore harder to read and maintain. You would think that the original <code>FileSave</code> function is attempting to avoid globals, but it's using the global name <code>filename</code>, so you may as well use a global file altogether at that point, as it will save you some I/O overhead.</p>
<p>A better option would be to avoid globals at all, or to at least use them properly. You really don't need a separate function to wrap <code>file.write</code>, but if it represents something more complex, here is a design suggestion:</p>
<pre><code>def save(file, content):
    print(content, file=file)

def my_thing(filename):
    with open(filename, 'a') as f:
        # do some stuff
        save(f, 'test1')
        # do more stuff
        save(f, 'test2')

if __name__ == '__main__':
    my_thing('myfile.txt')
</code></pre>
<p>Notice that when you call the module as a script, a file name defined in the global scope will be passed in to the main routine. However, since the main routine does not reference global variables, you can A) read it easier because it's self contained, and B) test it without having to wonder how to feed it inputs without breaking everything else.</p>
<p>Also, by using <code>print</code> instead of <code>file.write</code>, you avoid having to spend newlines manually.</p>
</div>
<span class="comment-copy">There are a number of problems with your modified code that aren't really relevant to your question: you open the file in read-only mode, you never close the file, you have a <code>global</code> statement that does nothing…</span>
<span class="comment-copy">It's not really clear which version you assign which (dis)advantage.</span>
<span class="comment-copy">@viraptor These are all advantages and disadvantages of opening and closing the file repeatedly.</span>
<span class="comment-copy">I'm not sure the second point is really true. Multiple processes can have the same file opened in the append mode and all of them will append to the end, whatever order they end up writing in.</span>
<span class="comment-copy">@viraptor And I really don't know how to make that clearer than literally saying "the advantages and disadvantages of opening and closing a file over and over:". What would make that  more obvious to you?</span>
<span class="comment-copy">@viraptor No. <code>'a'</code> files always write to the end on some Unix systems, but not others, and POSIX explicitly says that's implementation-dependent and should not be relied on. And it's not true on Windows.</span>
<span class="comment-copy">Allowing other programs to open the file while you're writing to it intermittently is a great way to crash your program on Windows.</span>
