<div class="post-text" itemprop="text">
<p>I encountered this issue but found the solution after a bit of research. I have posted my answer below to show my findings. If anyone has alternative suggestions please post them.</p>
<p>I needed to convert a <code>datetime.datime</code> object to a Unix timestamp. I tried using the datetime.timestamp. I found the result was 1 hour behind what I expected. I was able to replicate this issue with the following.</p>
<pre><code>from datetime import datetime, timestamp
dt = datetime.utcfromtimestamp(1438956602.0)
</code></pre>
<p>dt now equals <code>datetime.datetime(2015, 8, 7, 14, 10, 2)</code></p>
<p>Then:</p>
<pre><code>dt_stamp = datetime.timestamp(dt)
</code></pre>
<p>Which gives <code>dt_stamp = 1438953002.0</code> (which is different from our original timestamp). If we convert it back to datetime</p>
<pre><code>datetime.utcfromtimestamp(dt_stamp)
</code></pre>
<p>We get:</p>
<pre><code>datetime.datetime(2015, 8, 7, 13, 10, 2)
</code></pre>
<p>Which is an hour earlier than our original time.</p>
<p>For context I am using Python 3 and based in Britain where we're currently using British summer time (1 hour ahead of UTC).</p>
<p>My solution can be found below. If you think I have missed anything from my explanation or there's a better solution, please post your own answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you need a so called aware datetime object. Aware means it nows the time difference you have:</p>
<pre><code>datetime.fromtimestamp(timestamp, timezone(timedelta(hours=1)))
</code></pre>
<p>Try it with that line of code, where <code>timestamp</code> is your Unix timestamp.</p>
</div>
<div class="post-text" itemprop="text">
<p>The cause for this difference is actually shown in the 
<a href="https://docs.python.org/3/library/datetime.html" rel="nofollow noreferrer">datetime.timestamp documentation</a>.</p>
<blockquote>
<p>Naive datetime instances are assumed to represent local time and this method relies on the platform C mktime() function to perform the conversion. Since datetime supports wider range of values than mktime() on many platforms, this method may raise OverflowError for times far in the past or far in the future.</p>
</blockquote>
<p>Because I am in UTC+1 (during British summer time) this is the timezone <code>datetime.timestamp</code> uses to calculate the timestamp. This is where the mistake comes in. The documentation recommends a few ways to deal with this. I went with the following.</p>
<pre><code>from datetime import datetime, timestamp
dt = datetime.utcfromtimestamp(1438956602.0)
dt_stamp = datetime.timestamp(dt.replace(tzinfo=timezone.utc))
</code></pre>
<p>By adding <code>.replace(tzinfo=timezone.utc)</code> to the end of <code>dt</code> it specifies that this is done in the UTC timezone. <code>datetime.timestamp</code> then knows to use the UTC time rather than whatever timezone my machine is running.</p>
<p>People in America or other parts of the world will encounter this issue if not using the UTC timezone. If this is the case you can set <code>tzinfo</code> to whatever your timezone is. Also note that <code>datetime.utcfromtimestamp</code> is also clearly designed for people using the UTC timezone.</p>
</div>
<span class="comment-copy">As stated in the python doc, naive datetime bases its computation on local time. Since you're currently using BST, that will be the basis for any processing. Hence, the difference of 1 hour. For reference: <a href="https://docs.python.org/3.6/library/datetime.html?highlight=datetime%20timestamp#datetime.datetime.timestamp" rel="nofollow noreferrer">docs.python.org/3.6/library/â€¦</a></span>
