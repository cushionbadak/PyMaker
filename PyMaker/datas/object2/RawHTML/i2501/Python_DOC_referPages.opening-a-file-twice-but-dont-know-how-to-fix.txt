<div class="post-text" itemprop="text">
<pre><code>files = []

os.listdir("C:\\Users\\Name\\Attachments")
for filename in os.listdir(os.getcwd()):
    with open(filename) as f:
        files.append(f)

for file in files:
    with open(file, 'rb') as fp:
        img = MIMEImage(fp.read())
msg.attach(img)
</code></pre>
<p>When I run this, it gives me the error    </p>
<pre><code>TypeError: expected str, bytes or os.PathLike object, not _io.TextIOWrapper
</code></pre>
<p>I know this is due to me opening the file twice, but I'm not sure how to fix this. Any help is appreciated. Thanks</p>
<p>Stacktrace</p>
<pre><code>Traceback (most recent call last):
File "c:\users\yic-hin\mu_code\email test2.py", line 21, in &lt;module&gt;
with open(file, 'rb') as fp:
TypeError: expected str, bytes or os.PathLike object, not _io.TextIOWrapper
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have a couple of problems here.</p>
<h1>File object goes out of scope</h1>
<p>Your first time calling <code>open</code> on the filename in a <code>with</code> block uses a <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer"><strong>context manager</strong></a>. Context managers manage the lifecycle of resources and ensure appropriate tidying operations are performed when leaving the block. In the case of a file, the context manager arranges for the <code>close()</code> method on the file to be called automatically.</p>
<p>The following code:</p>
<pre class="lang-py prettyprint-override"><code>with open(filename) as f:
    files.append(f)
</code></pre>
<p>is approximately equivalent, for the purposes of this answer, to:</p>
<pre class="lang-py prettyprint-override"><code>f = open(filename)
files.append(f)
f.close()
</code></pre>
<p>Accordingly, appending the file object <code>f</code> to a list and attempting to use it <em>outside</em> the <code>with</code> block <strong>will not work</strong>. The file will be closed and any subsequent operations on the stream will not be possible (<a href="https://docs.python.org/3/library/io.html#io.IOBase.close" rel="nofollow noreferrer">docs</a>).</p>
<h1><code>open</code>'s first argument should be a string,<sup>1</sup> <em>not</em> a file object</h1>
<p><sup>1</sup><sub>or, more correctly, a path-like object â€“ see below</sub></p>
<p>Your code crashes before encountering the issue identified above because you attempt to pass a file object to the <code>open</code> method. This is incorrect; <code>open</code>'s first argument, <code>file</code>, is defined in the docs as follows:</p>
<blockquote>
<p><code>file</code> is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed, unless closefd is set to <code>False</code>.)</p>
</blockquote>
<p>A <strong>path-like object</strong> is <a href="https://docs.python.org/3/glossary.html#term-path-like-object" rel="nofollow noreferrer">defined</a> thus:</p>
<blockquote>
<p>An object representing a file system path. A path-like object is either a <code>str</code> or <code>bytes</code> object representing a path, or an object implementing the <code>os.PathLike</code> protocol.</p>
</blockquote>
<p>The simplest value to pass to <code>open</code> is a string denoting the path to a file on your machine. The file object you pass to <code>open</code> is of type <code>_io.TextIOWrapper</code>, which is not a path-like object, and cannot be used in the call to <code>open</code>:</p>
<pre class="lang-py prettyprint-override"><code>TypeError: expected str, bytes or os.PathLike object, not _io.TextIOWrapper
</code></pre>
<hr/>
<h1>Correct approach</h1>
<p>There are several ways to fix this; the simplest is simply to open the file once and avoid the double loop, which I see to be of no benefit to you in the example you supplied. For example, the following code should not exhibit this issue:</p>
<pre class="lang-py prettyprint-override"><code>files = []

os.listdir("C:\\Users\\Name\\Attachments")
for filename in os.listdir(os.getcwd()):
    with open(filename, 'rb') as f:
        img = MIMEImage(f.read())

# I also assume you want to attach /every/ processed image, not
# just the last one. If so, you must ensure this is indented to
# the same level as the `with` block inside the `for` loop.
msg.attach(img)
</code></pre>
</div>
<span class="comment-copy">Can you share the full stacktrace please?</span>
<span class="comment-copy">Why <i>do</i> you make this double for loop? Why don't you just do <code>img = MIMEImage(f.read())</code> already in the first loop...?</span>
<span class="comment-copy">I tried your code but I now get           TypeError: Could not guess image MIME subtype</span>
<span class="comment-copy">That suggests the data read in for the image is not an image, or not an image for which <code>MIMEImage</code> knows how to ascribe a MIME type. Check the documentation of MIMEImage to verify the expected input, and verify the data you pass in represent supported images for that library.</span>
