<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/csv.html#csv.Dialect.delimiter" rel="nofollow noreferrer">documentation</a> states that the default value of <code>Dialect.delimiter</code> is <code>','</code>. However, when I try to print, it returns <code>None</code>. </p>
<pre><code>&gt;&gt;&gt; print(csv.Dialect.delimiter)
None
</code></pre>
<blockquote>
<p>Dialect.delimiter A one-character string used to separate fields. It
    defaults to ','.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This is default value when you creating your own dialect.</p>
<pre><code>import csv

csv.register_dialect('my_dialect')
dialect = csv.get_dialect('my_dialect')
print(dialect.delimiter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's the default value when you create a new <code>Dialect</code>. You can get a dialect instance (an inmutable one if you're using Python 3.x) with <code>csv.get_dialect()</code> and register your own using <code>csv.register_dialect</code>. You can also just subclass <code>Dialect</code> and get on with it.</p>
<p>The documentation may seem unclear if you just read that line, but a few lines above you can see that:</p>
<blockquote>
<p>To make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a <strong>subclass</strong> of the Dialect class having a set of specific methods and a single validate() method.</p>
</blockquote>
<p>Doing a simple <code>help(csv.Dialect)</code> in the REPL confirms that subclassing is a must when working with this class.</p>
<pre><code>class Dialect(builtins.object)
 |  Describe a CSV dialect.
 |
 |  This must be subclassed (see csv.excel).  Valid attributes are:
 |  delimiter, quotechar, escapechar, doublequote, skipinitialspace,
 |  lineterminator, quoting.
 |
 |  Methods defined here:
 |
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  delimiter = None
 |
 |  doublequote = None
 |
 |  escapechar = None
 |
 |  lineterminator = None
 |
 |  quotechar = None
 |
 |  quoting = None
 |
 |  skipinitialspace = None
</code></pre>
</div>
<span class="comment-copy">@Aran-Fey is there any possible explanation for this?</span>
<span class="comment-copy">@Syzmon but I can also create a dialect by inheriting from <code>Dialect</code> class. In this case, however, I have to set every formatting arguments. Clearly, this is a conflict,</span>
<span class="comment-copy">This only holds true when using <code>register_dialect()</code> function.</span>
<span class="comment-copy">yes, but you have to register dialect before you will use it</span>
<span class="comment-copy">No, you can assign the class object directly to the <code>dialect</code> argument.</span>
<span class="comment-copy">Could you show example?</span>
