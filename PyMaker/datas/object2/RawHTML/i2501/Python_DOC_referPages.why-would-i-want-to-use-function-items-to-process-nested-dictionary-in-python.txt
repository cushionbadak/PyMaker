<div class="post-text" itemprop="text">
<p>Are there any applicable differences between <a href="http://docs.python.org/library/stdtypes.html#dict.items" rel="noreferrer"><code>dict.items()</code></a> and <a href="http://docs.python.org/library/stdtypes.html#dict.iteritems" rel="noreferrer"><code>dict.iteritems()</code></a>?</p>
<p>From the Python docs:</p>
<blockquote>
<p><code>dict.items()</code>: Return a <strong>copy</strong> of the dictionary’s list of (key, value) pairs.</p>
<p><code>dict.iteritems()</code>: Return an <strong>iterator</strong> over the dictionary’s (key, value) pairs.</p>
</blockquote>
<p>If I run the code below, each seems to return a reference to the same object. Are there any subtle differences that I am missing?</p>
<pre><code>#!/usr/bin/python

d={1:'one',2:'two',3:'three'}
print 'd.items():'
for k,v in d.items():
   if d[k] is v: print '\tthey are the same object' 
   else: print '\tthey are different'

print 'd.iteritems():'   
for k,v in d.iteritems():
   if d[k] is v: print '\tthey are the same object' 
   else: print '\tthey are different'   
</code></pre>
<p>Output:</p>
<pre><code>d.items():
    they are the same object
    they are the same object
    they are the same object
d.iteritems():
    they are the same object
    they are the same object
    they are the same object
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's part of an evolution. </p>
<p>Originally, Python <code>items()</code> built a real list of tuples and returned that. That could potentially take a lot of extra memory. </p>
<p>Then, generators were introduced to the language in general, and that method was reimplemented as an iterator-generator method named <code>iteritems()</code>. The original remains for backwards compatibility. </p>
<p>One of Python 3’s changes is that  <code>items()</code> now return iterators, and a list is never fully built. The <code>iteritems()</code> method is also gone, since <code>items()</code> in Python 3 works like <code>viewitems()</code> in Python 2.7. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.items()</code> returns a list of 2-tuples (<code>[(key, value), (key, value), ...]</code>), whereas <code>dict.iteritems()</code> is a generator that yields 2-tuples. The former takes more space and time initially, but accessing each element is fast, whereas the second takes less space and time initially, but a bit more time in generating each element.</p>
</div>
<div class="post-text" itemprop="text">
<h2>In Py2.x</h2>
<p>The commands <code>dict.items()</code>, <code>dict.keys()</code> and <code>dict.values()</code> return a <strong>copy</strong> of the dictionary's <strong>list</strong> of <code>(k, v)</code> pair, keys and values.
This could take a lot of memory if the copied list is very large.</p>
<p>The commands <code>dict.iteritems()</code>, <code>dict.iterkeys()</code> and <code>dict.itervalues()</code> return an <strong>iterator</strong> over the dictionary’s <code>(k, v)</code> pair, keys and values.</p>
<p>The commands <code>dict.viewitems()</code>, <code>dict.viewkeys()</code> and <code>dict.viewvalues()</code> return the <a href="http://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="noreferrer"><strong>view objects</strong></a>, which can reflect the dictionary's changes.
(I.e. if you <code>del</code> an item or add a <code>(k,v)</code> pair in the dictionary, the view object can <em>automatically</em> change at the same time.)</p>
<pre><code>$ python2.7

&gt;&gt;&gt; d = {'one':1, 'two':2}
&gt;&gt;&gt; type(d.items())
&lt;type 'list'&gt;
&gt;&gt;&gt; type(d.keys())
&lt;type 'list'&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; type(d.iteritems())
&lt;type 'dictionary-itemiterator'&gt;
&gt;&gt;&gt; type(d.iterkeys())
&lt;type 'dictionary-keyiterator'&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; type(d.viewitems())
&lt;type 'dict_items'&gt;
&gt;&gt;&gt; type(d.viewkeys())
&lt;type 'dict_keys'&gt;
</code></pre>
<hr/>
<h1>While in Py3.x</h1>
<p>In Py3.x, things are more clean, since there are only <code>dict.items()</code>, <code>dict.keys()</code> and <code>dict.values()</code> available, which return the <strong>view objects</strong> just as <code>dict.viewitems()</code> in Py2.x did. </p>
<h3>But</h3>
<p>Just as @lvc noted, <strong>view object</strong> isn't the same as <strong>iterator</strong>, so if you want to return an <strong>iterator</strong> in Py3.x, you could use <a href="http://docs.python.org/3.3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer"><code>iter(dictview)</code></a> :</p>
<pre><code>$ python3.3

&gt;&gt;&gt; d = {'one':'1', 'two':'2'}
&gt;&gt;&gt; type(d.items())
&lt;class 'dict_items'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; type(d.keys())
&lt;class 'dict_keys'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; ii = iter(d.items())
&gt;&gt;&gt; type(ii)
&lt;class 'dict_itemiterator'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; ik = iter(d.keys())
&gt;&gt;&gt; type(ik)
&lt;class 'dict_keyiterator'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You asked: 'Are there any applicable differences between dict.items() and dict.iteritems()'</p>
<p>This may help (for Python 2.x):</p>
<pre><code>&gt;&gt;&gt; d={1:'one',2:'two',3:'three'}
&gt;&gt;&gt; type(d.items())
&lt;type 'list'&gt;
&gt;&gt;&gt; type(d.iteritems())
&lt;type 'dictionary-itemiterator'&gt;
</code></pre>
<p>You can see that <code>d.items()</code> returns a list of tuples of the key, value pairs and <code>d.iteritems()</code> returns a dictionary-itemiterator.</p>
<p>As a list, d.items() is slice-able:</p>
<pre><code>&gt;&gt;&gt; l1=d.items()[0]
&gt;&gt;&gt; l1
(1, 'one')   # an unordered value!
</code></pre>
<p>But would not have an <code>__iter__</code> method:</p>
<pre><code>&gt;&gt;&gt; next(d.items())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: list object is not an iterator
</code></pre>
<p>As an iterator, d.iteritems() is <strong>not</strong> slice-able:</p>
<pre><code>&gt;&gt;&gt; i1=d.iteritems()[0]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'dictionary-itemiterator' object is not subscriptable
</code></pre>
<p>But does have <code>__iter__</code>:</p>
<pre><code>&gt;&gt;&gt; next(d.iteritems())
(1, 'one')               # an unordered value!
</code></pre>
<p>So the items themselves are same -- the container delivering the items are different. One is a list, the other an iterator (depending on the Python version...) </p>
<p>So the applicable differences between dict.items() and dict.iteritems() are the same as the applicable differences between a list and an iterator. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.items()</code> return list of tuples, and <code>dict.iteritems()</code> return iterator object of tuple in dictionary as <code>(key,value)</code>. The tuples are the same, but container is different. </p>
<p><code>dict.items()</code> basically copies all dictionary into list. Try using following code to compare the execution times of the <code>dict.items()</code> and <code>dict.iteritems()</code>. You will see the difference.</p>
<pre><code>import timeit

d = {i:i*2 for i in xrange(10000000)}  
start = timeit.default_timer() #more memory intensive
for key,value in d.items():
    tmp = key + value #do something like print
t1 = timeit.default_timer() - start

start = timeit.default_timer()
for key,value in d.iteritems(): #less memory intensive
    tmp = key + value
t2 = timeit.default_timer() - start
</code></pre>
<p>Output in my machine:</p>
<pre><code>Time with d.items(): 9.04773592949
Time with d.iteritems(): 2.17707300186
</code></pre>
<p>This clearly shows that <code>dictionary.iteritems()</code> is much more efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have </p>
<p><code>dict = {key1:value1, key2:value2, key3:value3,...}</code></p>
<p>In <strong>Python 2</strong>, <code>dict.items()</code> copies each tuples and returns the list of tuples in dictionary i.e. <code>[(key1,value1), (key2,value2), ...]</code>. 
Implications are that the whole dictionary is copied to new list containing tuples</p>
<pre><code>dict = {i: i * 2 for i in xrange(10000000)}  
# Slow and memory hungry.
for key, value in dict.items():
    print(key,":",value)
</code></pre>
<p><code>dict.iteritems()</code> returns the dictionary item iterator. The value of the item returned is also the same i.e. <code>(key1,value1), (key2,value2), ...</code>, but this is not a list. This is only dictionary item iterator object. That means less memory usage (50% less).</p>
<ul>
<li>Lists as mutable snapshots: <code>d.items() -&gt; list(d.items())</code> </li>
<li>Iterator objects: <code>d.iteritems() -&gt; iter(d.items())</code></li>
</ul>
<p>The tuples are the same. You compared tuples in each so you get same.</p>
<pre><code>dict = {i: i * 2 for i in xrange(10000000)}  
# More memory efficient.
for key, value in dict.iteritems():
    print(key,":",value)
</code></pre>
<p>In <strong>Python 3</strong>, <code>dict.items()</code> returns iterator object. dict.iteritems() is removed so there is no more issue.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.iteritems()</code>: gives you an iterator. You may use the iterator in other patterns outside of the loop.</p>
<pre><code>student = {"name": "Daniel", "student_id": 2222}

for key,value in student.items():
    print(key,value)

('student_id', 2222)
('name', 'Daniel')

for key,value in student.iteritems():
    print(key,value)

('student_id', 2222)
('name', 'Daniel')

studentIterator = student.iteritems()

print(studentIterator.next())
('student_id', 2222)

print(studentIterator.next())
('name', 'Daniel')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a way to iterate the item pairs of a dictionary that works with both Python 2 and 3, try something like this:</p>
<pre><code>DICT_ITER_ITEMS = (lambda d: d.iteritems()) if hasattr(dict, 'iteritems') else (lambda d: iter(d.items()))
</code></pre>
<p>Use it like this:</p>
<pre><code>for key, value in DICT_ITER_ITEMS(myDict):
    # Do something with 'key' and/or 'value'.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dict.iteritems</code> is gone in Python3.x So use <code>iter(dict.iitems())</code> to get the same output and memory alocation</p>
</div>
<div class="post-text" itemprop="text">
<p>dict.iteritems() in python 2 is equivalent to dict.items() in python 3.</p>
</div>
<span class="comment-copy">It's basically a difference in how they are computed. <code>items()</code> creates the items all at once and returns a list. <code>iteritems()</code> returns a generator--a generator is an object that "creates" one item at a time every time <code>next()</code> is called on it.</span>
<span class="comment-copy">In your particular case, <code>d[k] is v</code> would always return True because python keeps an array of integer objects for all integers between -5 and 256: <a href="https://docs.python.org/2/c-api/int.html" rel="nofollow noreferrer">docs.python.org/2/c-api/int.html</a> When you create an int in that range you actually just get back a reference to the existing object:  <code>&gt;&gt; a = 2; b = 2 &gt;&gt; a is b True</code> But, <code>&gt;&gt; a = 1234567890; b = 1234567890  &gt;&gt; a is b  False</code></span>
<span class="comment-copy">@the_wolf I think would be better to add the python version of the doc you are referring to in the question.</span>
<span class="comment-copy">Did <code>iteritems()</code> change to <code>iter()</code> in Python 3? The documentation link above doesn't seem to be matching up with this answer.</span>
<span class="comment-copy">Not exactly, @GabrielStaples. iteritems() is removed from dictionaries Python 3, and has no replacement. However, for the same effect, you do use iter(). e.g. iter(dict.items()). See pep 469: <a href="https://www.python.org/dev/peps/pep-0469/" rel="nofollow noreferrer">python.org/dev/peps/pep-0469</a></span>
<span class="comment-copy">Note that you have missed a step in the evolution: the Py3 behavior isn't the same as <code>iteritems()</code>. It actually makes a full sequence-protocol object that also reflects changes to the dict (and is backed by the dict itself, rather than a redundant list)- it's been backported to 2.7 as <code>viewitems()</code>.</span>
<span class="comment-copy">I'd like to learn about this in greater detail, but my google-fu is failing me. Could someone point me to documentation, articles or source that would help me better understand this? @lvc?</span>
<span class="comment-copy">@Stew the change is described in <a href="https://www.python.org/dev/peps/pep-3106/" rel="nofollow noreferrer">PEP 3106</a> and there is a bit more in <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer">what's new in python 3.0</a></span>
<span class="comment-copy">Sorry for elaborating on this ancient question but do I understand correctly that <b><code>iteritems()</code> is always preferable over <code>items()</code></b> in Python 2.x?</span>
<span class="comment-copy">@RubenGeert Most of the time, it doesn't matter. For really large dicts it might be preferable.</span>
<span class="comment-copy">Why would you expect them to be different?</span>
<span class="comment-copy">The "copy" in the docs doesn't mean that the elements are copied (if you want that, use <code>copy.deepcopy</code>). It means that it's a copy of the dictionary items: if you do <code>items = dct.items()</code> and then modify <code>dct</code> by adding/deleting keys or <code>dct[k] = other_v</code>, <code>items</code> will stay the same.</span>
<span class="comment-copy">Nothing in Python is ever a deep copy unless explicitly documented as such.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams - Regarding "more space and time" : At what size of dictionary do they start to matter. Say I've a "large" dictionary <code>{1:'one', 2:'two', ... }</code> over which I want to iterate on a webserver and render the results. At what scale should I start to worry about choosing <code>.items()</code> vs <code>.iteritems()</code> for Python 2.7 ?</span>
<span class="comment-copy">@buffer: Not really sure. My estimate would be 15-20 items, but I haven't tested that.</span>
<span class="comment-copy">This is incorrect. The difference has already been explained in previous answers.</span>
