<div class="post-text" itemprop="text">
<p>Suppose I have some tasks running asynchronously. They may be totally independent, but I still want to set points where the taks will pause so they can run concurrently.</p>
<p>What is the correct way to run the tasks concurrently? I am currently using <code>await asyncio.sleep(0)</code>, but I feel this is adding a lot of overhead. </p>
<pre><code>import asyncio

async def do(id, amount):
    for i in range(amount):
        # Do some time-expensive work
        print(f'{id}: has done {i}')

        await asyncio.sleep(0)

    return f'{id}: done'

async def main():
    res = await asyncio.gather(do('Task1', 5), do('Task2', 3))
    print(*res, sep='\n')

loop = asyncio.get_event_loop()

loop.run_until_complete(main())
</code></pre>
<h2>Output</h2>
<pre><code>Task1: has done 0
Task2: has done 0
Task1: has done 1
Task2: has done 1
Task1: has done 2
Task1: done
Task2: done
</code></pre>
<p>If we were using simple generators, an empty <code>yield</code> would pause the flow of a task without any overhead, but empty <code>await</code> are not valid.</p>
<p>What is the correct way to set such breakpoints without overhead?</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in the comments, normally asyncio coroutines suspend automatically on calls that would block or sleep in equivalent synchronous coffee. In your case the coroutine is CPU-bound, so awaiting blocking calls is not enough, it needs to occasionally relinquish control to the event loop to allow the rest of the system to run.</p>
<p>Explicit yields are not uncommon in cooperative multitasking, and using <code>await asyncio.sleep(0)</code> for that purpose will <a href="https://github.com/python/asyncio/issues/284" rel="nofollow noreferrer">work as intended</a>, it does carry a risk: sleep too often, and you're slowing down the computation by unnecessary switches; sleep too seldom, and you're hogging the event loop by spending too much time in a single coroutine.</p>
<p>The solution provided by asyncio is to offload CPU-bound code to a thread pool using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a>. Awaiting it will automatically suspend the coroutine until the CPU-intensive task is done, without any intermediate polling. For example:</p>
<pre><code>import asyncio

def do(id, amount):
    for i in range(amount):
        # Do some time-expensive work
        print(f'{id}: has done {i}')

    return f'{id}: done'

async def main():
    loop = asyncio.get_event_loop()
    res = await asyncio.gather(
        loop.run_in_executor(None, do, 'Task1', 5),
        loop.run_in_executor(None, do, 'Task2', 3))
    print(*res, sep='\n')

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
</code></pre>
</div>
<span class="comment-copy">Also, breakpoint might not be the correct term here. Feel free to comment or update with correct terminology.</span>
<span class="comment-copy">"but I still want to set some breakpoints so they can run concurrently" - yeah, breakpoint definitely isn't the right word, but I can't tell what it is you're going for or whether it makes sense at all, let alone has a name.</span>
<span class="comment-copy">Are you trying to write a line that says "feel free to switch coroutines here"? You shouldn't need to do that manually; if you have a slow network call to make, asyncio should switch for you when it needs to wait for network comms, and if you have some slow, heavy computation to do, that probably doesn't belong on the event loop at all.</span>
<span class="comment-copy">I see you've edited your post. Any particular reason you want to pause your coroutines? Is there something about your situation that would make the work get done faster that way?</span>
<span class="comment-copy">@user2357112 Yes, that sounds like  "feel free to switch task here".  Suppose I have two tasks that need to take some measurements as frequently as possible. I don't want them to run one after the other, but I also do not want them to wait for any precise amount of time. If this is not the correct approach, feel free to point out that it's a paradigm error on my part.</span>
