<div class="post-text" itemprop="text">
<p>I have a data frame of one column having positive and negative values. I want to find index position of negative values. I have two methods here and I am trying to find which of the methods is best and fastest. My code is: </p>
<pre><code>import pandas as pd
import time

df = pd.DataFrame({'Current': [1, 3, -4, 9, -3, 1, -2]})

# Method-1
start1 = time.time()
neg_index1 = df[(df["Current"]&lt;0)].index.tolist()
print(neg_index1)
end1 = time.time()
print("Method-1 time is = ",end1 - start1)

# Method-2
start2 = time.time()
neg_index2 = df.iloc[df["Current"].lt(0).values].index.tolist()
print(neg_index2)
end2 = time.time()
print("Method-2 time is = ",end2 - start2)
</code></pre>
<p>Output at first execution and Method-2 is faster here: </p>
<pre><code>[2, 4, 6]
Method-1 time is =  0.002000093460083008 
[2, 4, 6]
Method-2 time is =  0.0009999275207519531
</code></pre>
<p>Output at second execution and interestingly both clock same time: </p>
<pre><code>[2, 4, 6]
Method-1 time is =  0.0009999275207519531
[2, 4, 6]
Method-2 time is =  0.0009999275207519531
</code></pre>
<p>Output at fourth execution and surprisingly Method-1 is faster here: </p>
<pre><code>[2, 4, 6]
Method-1 time is =  0.0009999275207519531
[2, 4, 6]
Method-2 time is =  0.0019998550415039062
</code></pre>
<p>Some explanation and help to know which method is faster? </p>
</div>
<div class="post-text" itemprop="text">
<p>I would prefer to use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="nofollow noreferrer"><code>np.where</code></a>:</p>
<pre><code>np.where(df['Current']&lt;0)[0].tolist()
</code></pre>
<p>Also don't use <code>time.time</code> use <code>timeit</code>:</p>
<pre><code>import pandas as pd, numpy as np
import timeit

df = pd.DataFrame({'Current': [1, 3, -4, 9, -3, 1, -2]})

# Method-1
neg_index1 = df[(df["Current"]&lt;0)].index.tolist()
print(neg_index1)
print("Method-1 time is = ",timeit.timeit(lambda: df[(df["Current"]&lt;0)].index.tolist(),number=10))

# Method-2
neg_index2 = df.iloc[df["Current"].lt(0).values].index.tolist()
print(neg_index2)
print("Method-2 time is = ",timeit.timeit(lambda: df.iloc[df["Current"].lt(0).values].index.tolist(),number=10))

# Method-3
neg_index2 = np.where(df['Current']&lt;0)[0].tolist()
print(neg_index2)
print("Method-3 time is = ",timeit.timeit(lambda: np.where(df['Current']&lt;0)[0].tolist(),number=10))
</code></pre>
<p>Output:</p>
<pre><code>[2, 4, 6]
Method-1 time is =  0.0211404744016608
[2, 4, 6]
Method-2 time is =  0.02377961247025239
[2, 4, 6]
Method-3 time is =  0.007515077367731743
</code></pre>
<p>So <code>np.where</code> wins big time!</p>
</div>
<div class="post-text" itemprop="text">
<p>There could be other processes consuming resources while you are measuring the time taken for each execution. There could also be garbage collector kicking in at random points skewing up the results. So never use <code>time.time()</code> for comparing performance.</p>
<p>Use the <code>timeit.timeit</code> for measuring performance. It repeats the code run several times and measures average time taken for each run, thus providing much more acurate results. It also disables garbage collection during the run. </p>
</div>
<span class="comment-copy">It depends some time on the other proceses that the processor get scheduled by the operating system. so if there are other processes invoked by operating system and your processors are busy then these type of situation appears.</span>
<span class="comment-copy">you may want to run  this in an virtual env and see if it changes execution time as the resources will be much more focused as compared to non virtual env.</span>
<span class="comment-copy">Don't use <code>time.time</code> to benchmark things; use the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> module. There are a number of good reasons for that, but it's hard to beat the fact that you're trying to measure something that takes 1-2ms with a clock with a 1ms resolution, which means you've got error bars of +/-100%â€¦</span>
<span class="comment-copy">@Msquare <code>np.where</code> is the fastest (by far)</span>
<span class="comment-copy">@Msquare <a href="https://softwareengineering.stackexchange.com/questions/279965/what-is-the-explication-for-the-difference-execution-time-for-the-same-instructi" title="what is the explication for the difference execution time for the same instructi">softwareengineering.stackexchange.com/questions/279965/â€¦</a></span>
<span class="comment-copy">Excellent. You are simply superb for introducing me a new method-3. I executed it many times. Your are on spot and it is fastest. Thanks a lot.</span>
<span class="comment-copy">@Msquare Your welcome, Happy that i helped, ðŸ˜Š</span>
<span class="comment-copy">Could you give me some explanation about <code>[0]</code> in <code>np.where(df['Current']&lt;0)[0]</code>. I mean, what it is referring to ?</span>
<span class="comment-copy">@Msquare <code>numpy.where</code> returns (in this case) <code>(array([2, 4, 6], dtype=int64),)</code> (a tuple) so get first (zeroth) element, then do <code>tolist</code></span>
<span class="comment-copy">@Msquare You need because <code>np.where</code> returns a tuple with only one element (the array) so get the first (zeroth) element</span>
