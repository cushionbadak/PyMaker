<div class="post-text" itemprop="text">
<p>I am stuck in finding how I can take the "k" in consideration to solve the following problem. Basically, it should start at index k and look for the lowest value in the range from k until the end of the list.</p>
<pre><code>def find_min_index(A, k):
    """
    Finds the index of the smallest element in the list A from index k onwards

    Parameters:
        A (list)
        k: index from which start search

    Example use:
    &gt;&gt;&gt; find_min_index([1, 2, 5, -1], 0)
    3
    &gt;&gt;&gt; find_min_index([1, 1, 1, 5, 9], 2)
    2
    """

    minpos = A.index(min(A))
    return minpos
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One-liner solution is this:</p>
<pre><code>return A[k:].index(min(A[k:]) + k
</code></pre>
<p>You select the minimal element from A[k:], find its index in A[k:] and add k to it to compensate the search area.</p>
<p>A slightly neater solution is this:</p>
<pre><code>slice = A[k:]
return slice.index(min(slice)) + k
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>enumerate</code> to keep track of the original index before you slice the list with <code>k</code> as the starting index:</p>
<pre><code>from operator import itemgetter
def find_min_index(A, k):
    return min(list(enumerate(A))[k:], key=itemgetter(1))[0]
</code></pre>
<p>so that:</p>
<pre><code>print(find_min_index([1, 2, 5, -1], 0))
print(find_min_index([1, 1, 1, 5, 9], 2))
</code></pre>
<p>would output:</p>
<pre><code>3
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate</a> to find the index of min:</p>
<pre><code>def find_min_index(A, k):
    """
    Finds the index of the smallest element in the list A from index k onwards

    Parameters:
        A (list)
        k: index from which start search

    Example use:
    &gt;&gt;&gt; find_min_index([1, 2, 5, -1], 0)
    3
    &gt;&gt;&gt; find_min_index([1, 1, 1, 5, 9], 2)
    2
    """

    o, _ = min(enumerate(A[k:]), key=lambda i: i[1])
    minpos = k + o
    return minpos


print(find_min_index([1, 2, 3, 4], 1))
print(find_min_index([4, 3, 2, 1], 1))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>1
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add <code>k</code> to the index calculated from a sliced input list:</p>
<pre><code>def find_min_index(A, k):
    sliced = A[k:]
    return k + sliced.index(min(sliced))

find_min_index([1, 2, 5, -1], 2)    # 3
find_min_index([1, 1, 1, 5, 9], 2)  # 2
</code></pre>
</div>
<span class="comment-copy">What have you done so far? You need to have list[k:] and find the smallest element within a loop or something like that.</span>
<span class="comment-copy"><code>k + numpy.argmin(A[k:])</code></span>
<span class="comment-copy">@Ekrem just the last two lines including minpos, than I tried somehow include the k steps but didnt suceed..</span>
<span class="comment-copy">@dobera after my comment, some decent answers were already sent. As I see, you struggled with making a sublist starting with 'k'th index.</span>
<span class="comment-copy">You probably shouldn't slice twice. Slice once, store in a variable and reuse.</span>
