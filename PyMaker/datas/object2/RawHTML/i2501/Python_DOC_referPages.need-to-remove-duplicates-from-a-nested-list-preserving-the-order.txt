<div class="post-text" itemprop="text">
<p>I have a list like below</p>
<pre><code>L = [[1,2],[1,3],[1,4],[2,1],[2,5],[3,1],[3,2]]
</code></pre>
<p>The output should be</p>
<pre><code>[[1,2],[1,3],[1,4],[2,5],[3,2]]
</code></pre>
<p>Please note that the order for the pairs and the elements has to be preserved. In other words, I cannot sort the list because the elements order needs to be preserved for the pairs as well. For example, I need the last element [3,2] to be preserved. If i sort them and remove duplicates this will be changed to [2,3] which I do not want.
Also when I say I need to remove duplicates [1,2] or [2,1] is considered to be a duplicate and I want to preserve [1,2] from this.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works similar to <a href="https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-whilst-preserving-order">removing duplicates from a regular list whilst preserving order</a>, but we need to do something about the sublists not being hashable and the order of the sublists being irrelevant.</p>
<p>We can use frozen sets to solve both these issues at once.</p>
<pre><code>&gt;&gt;&gt; lst = [[1,2],[1,3],[1,4],[2,1],[2,5],[3,1],[3,2]] 
&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; result = []
&gt;&gt;&gt; 
&gt;&gt;&gt; for x in lst:
...     s = frozenset(x)
...     if s not in seen:
...         result.append(x)
...         seen.add(s)
... 
&gt;&gt;&gt; result
[[1, 2], [1, 3], [1, 4], [2, 5], [3, 2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>unique_everseen</code> function in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> recipes in the docs</a> does exactly what you need:</p>
<pre><code>&gt;&gt;&gt; lst = [[1,2],[1,3],[1,4],[2,1],[2,5],[3,1],[3,2]]
&gt;&gt;&gt; list(unique_everseen(lst, key=frozenset))
[[1, 2], [1, 3], [1, 4], [2, 5], [3, 2]]
</code></pre>
<p>The basic idea is that it keeps a set of all values seen so far, and skips any value that's already in the set.</p>
<p>The <code>key</code> function works the same way as in <code>sort</code>, <code>max</code>, etc., as explained in the <a href="https://docs.python.org/3/howto/sorting.html#key-functions" rel="nofollow noreferrer">Sorting HOWTO</a>. You want to make two lists that have the same values in a different order match, so we need to compare the set of each list's values, instead of the lists themselves. (The reason we need <code>frozenset</code> instead of <code>set</code> is that <code>set</code> is mutable, and therefore can't be stored in a set.)</p>
<hr/>
<p>If you had more than 2 elements in your sublists, the question would be ambiguous. If you have, say, <code>[1, 1, 2]</code> and <code>[1, 2, 2]</code>, do you want them to be considered duplicates, or not?</p>
<ul>
<li>If yes: Then you're treating them a set, so use <code>key=frozenset</code>.</li>
<li>If no: Then you're treating them as a multiset. The nicest Python implementation of multisets is <code>collections.Counter</code>, but there's no <code>FrozenCounter</code> (and building one just for this purpose is probably overkill). You can simulate one in a few ways:

<ul>
<li><code>key=lambda sublist: frozenset(Counter(sublist).items())</code></li>
<li><code>key=lambda sublist: sorted(Counter(sublist).items())</code></li>
<li><code>key=lambda sublist: tuple(sorted(sublist))</code></li>
</ul></li>
</ul>
<p>Since your initial thought was to sort the sublists—which was only unacceptable because you need to end up with the original value, not the sorted value—I think the last of these options is most likely to be the one you'd want, but that's still really just a guess.</p>
<hr/>
<p>You can just copy and paste the function from the docs into your code:</p>
<pre><code>from itertools import *

def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element
</code></pre>
<p>… or install the third-party library <code>more_itertools</code> and use its <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>unique_everseen</code></a> it from there. Or the different third-party library <code>toolz</code> has an equivalent function named <a href="https://toolz.readthedocs.io/en/latest/api.html#itertoolz" rel="nofollow noreferrer"><code>unique</code></a>.</p>
</div>
<span class="comment-copy">Side note, don't shadow class names, use <code>lst</code> or <code>L</code> instead of <code>list</code>. I've updated the question for you.</span>
<span class="comment-copy">Nice explanation :). Didn't know it was in <code>more_itertools</code> too. IMO, the number of times this is used it should become part of <code>itertools</code> core library.</span>
<span class="comment-copy">@jpp There have been a few discussions on the lists about adding all of the recipes in the docs to the actual library. As I understand it, the original reason not to do it was that <code>itertools</code> had a pure-Python implementation and a pure-C one, but converting it to a Python-with-C-acclerator would be a pain. In 3.x that's not a valid excuse anymore, but someone (probably Raymond Hettinger) argued that not having them in the docs would mean people don't learn how they work and how to write minor variations on the same idea.</span>
