<div class="post-text" itemprop="text">
<p>I'm new to Python, and I was wondering why I can't change the attribute for a class instance using a function, if I pass the instance as a function parameter
For example, if I had:</p>
<pre><code>class sol:
    def __init__(self):
        self.val = 0

def fun1(obj, attrib):
    obj[attrib] = 1

newSol = sol()

fun1(newSol, "val")
</code></pre>
<p>Why can't fun1 change the object attribute? Is there a way to change it, or is the "val" attribute immutable?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python class instances and <code>dict</code> are completely different beasts; you're likely coming from a JavaScript background where <code>obj.foo</code> is equivalent to <code>obj["foo"]</code>, but that's not how Python works.</p>
<p>If you want to set an attribute via a <code>str</code> name, <a href="https://docs.python.org/3/library/functions.html#setattr" rel="nofollow noreferrer">use <code>setattr</code></a>:</p>
<pre><code>def fun1(obj, attrib):
    setattr(obj, attrib, 1)
</code></pre>
</div>
<span class="comment-copy">Attribute access (<code>obj.attr</code>) and indexing (<code>obj[index]</code>) are entirely separate concepts in Python.  You'd need to use <code>setattr(obj, attrib, 1)</code> to set an attribute indirectly.</span>
<span class="comment-copy">Sorry, in my mind I was thinking of dicts as objects, and I was assuming the same syntax for setting dict attributes was the same as setting object attribute. Would the sytax dict[attrib] = 1 work for dicts only then?</span>
<span class="comment-copy">You can make your own class that supports indexing by implementing the <code>__setitem__()</code>/<code>__getitem__()</code> methods.</span>
<span class="comment-copy">@albert <code>dict</code>s <i>are</i> objects. Everything in Python is an object. Dict objects cannot have attributes, and using <code>mydict[k] = v</code> does not create an attribute on the dict objects.</span>
<span class="comment-copy">@juanpa.arrivillaga what I meant to say was I was thinking of all objects in Python as dicts. And I'm a little confused about what you said about dicts. Using mydict[k] = v does create a k attribute for mydict, does it not?</span>
<span class="comment-copy">Ah ok I was just wondering that. Thanks for the clarification.</span>
<span class="comment-copy">It seems a little disingenuous to suggest that there's <i>no</i> relation between object attributes and dictionaries, considering that most objects store their attributes in a <code>__dict__</code> dict.</span>
<span class="comment-copy">@PatrickHaugh: Except when <code>__slots__</code> are involved, or it's a C built-in using descriptors to implement access, or when it's a subclass of <code>tuple</code> or <code>list</code> (e.g. anything made via <code>collections.namedtuple</code>) using <code>@property</code> to alias indices to names, etc. Yes, <code>__dict__</code> is implemented as a <code>dict</code>-like thing, often an actual <code>dict</code> (when it exists, which isn't always). But that's mostly an "in the weeds" implementation detail, and not relevant to how you <i>use</i> class instances in 99.999% of cases. Class instances don't quack like <code>dict</code>, so the relationship isn't relevant most of the time.</span>
