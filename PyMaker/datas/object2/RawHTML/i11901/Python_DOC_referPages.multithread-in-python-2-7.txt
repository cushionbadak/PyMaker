<div class="post-text" itemprop="text">
<p>I am doing my final project study with raspberry card and I want to use two cameras at the same time and run the same python program with two cameras to take a picture and make the treatment to know the product
 how I can do this using multithreading</p>
<pre><code>from os import listdir
from os.path import isfile, join
import numpy
import cv2
import os
import sys

def match_images(img1, img2):

   detector = cv2.SURF(200, 1, 1)
   matcher = cv2.BFMatcher(cv2.NORM_L2)
   kp1, desc1 = detector.detectAndCompute(img1, None)
   kp2, desc2 = detector.detectAndCompute(img2, None)
   print 'img1  %d features, img2  %d features' % (len(kp1), len(kp2))
   raw_matches = matcher.knnMatch(desc1, trainDescriptors = desc2, k = 2) 
   kp_pairs = filter_matches(kp1, kp2, raw_matches)
   return kp_pairs

def filter_matches(kp1, kp2, matches, ratio = 0.75):

   mkp1, mkp2 = [], []
   for m in matches:
       if len(m) == 2 and m[0].distance &lt; m[1].distance * ratio:
           m = m[0]
           mkp1.append( kp1[m.queryIdx] )
           mkp2.append( kp2[m.trainIdx] )
   kp_pairs = zip(mkp1, mkp2)
   return kp_pairs

def explore_match(win, img1, img2, kp_pairs, status = None, H = None):

   h1, w1 = img1.shape[:2]
   h2, w2 = img2.shape[:2]
   vis = numpy.zeros((max(h1, h2), w1+w2), numpy.uint8)
   vis[:h1, :w1] = img1
   vis[:h2, w1:w1+w2] = img2
   vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
   if H is not None:
       corners = numpy.float32([[0, 0], [w1, 0], [w1, h1], [0, h1]])
       corners = numpy.int32( cv2.perspectiveTransform(corners.reshape(1, -1, 2), H).reshape(-1, 2) + (w1, 0) )
       cv2.polylines(vis, [corners], True, (255, 255, 255))
   if status is None:
       status = numpy.ones(len(kp_pairs), numpy.bool_)
   p1 = numpy.int32([kpp[0].pt for kpp in kp_pairs])
   p2 = numpy.int32([kpp[1].pt for kpp in kp_pairs]) + (w1, 0)
   green = (0, 255, 0)
   red = (0, 0, 255)
   white = (255, 255, 255)
   kp_color = (51, 103, 236)
   for (x1, y1), (x2, y2), inlier in zip(p1, p2, status):
       if inlier:
           col = green
           cv2.circle(vis, (x1, y1), 2, col, -1)
           cv2.circle(vis, (x2, y2), 2, col, -1)
       else:
           col = red
           r = 2
           thickness = 3
           cv2.line(vis, (x1-r, y1-r), (x1+r, y1+r), col, thickness)
           cv2.line(vis, (x1-r, y1+r), (x1+r, y1-r), col, thickness)
           cv2.line(vis, (x2-r, y2-r), (x2+r, y2+r), col, thickness)
           cv2.line(vis, (x2-r, y2+r), (x2+r, y2-r), col, thickness)
   vis0 = vis.copy()
   for (x1, y1), (x2, y2), inlier in zip(p1, p2, status):
       if inlier:
           cv2.line(vis, (x1, y1), (x2, y2), green)
   cv2.imshow(win, vis)

def draw_matches(window_name, kp_pairs, img1, img2):

mkp1, mkp2 = zip(*kp_pairs)    
p1 = numpy.float32([kp.pt for kp in mkp1])
p2 = numpy.float32([kp.pt for kp in mkp2])   
if len(kp_pairs) &gt;= 100:
       H, status = cv2.findHomography(p1, p2, cv2.RANSAC, 5.0)
       print '%d / %d  inliers/matched' % (numpy.sum(status), len(status))
       import RPI.GPIO as GPIO
       import time
       GPIO.setup(LEDPin, GPIO.OUT)
       GPIO.output(LEDPin, True)
       print("LED ON")
       time.sleep(5)
       GPIO.output(LEDPin, False)  
if len(p1):
       explore_match(window_name, img1, img2, kp_pairs, status, H)

if __name__ == '__main__':

 import cv2
 import os 
 camera_port = 1
 ramp_frames = 2
 camera = cv2.VideoCapture(camera_port)
 def get_image():
  retval, im = camera.read()
  return im
  for i in xrange(ramp_frames):
   temp = get_image()
   print("Taking image...")
   camera_capture = get_image()
   file = "C:/Users/oussema/Desktop/projet/scripts/test_image.png"
  cv2.imwrite(file, camera_capture)
  del(camera)
  img2 = cv2.imread('test_image.png', 0)
  img1 = cv2.imread('1.jpg', 0)
  if img1 is None:
       print 'Failed to load img1:'
       sys.exit(1)       
  if img2 is None:
       print 'Failed to load img2:'
       sys.exit(1)
  kp_pairs = match_images(img1, img2)
  if len(kp_pairs) &gt;= 100:
   draw_matches('find_obj', kp_pairs, img1, img2)
   cv2.waitKey()
   cv2.destroyAllWindows() 
  elif len(kp_pairs) &lt;= 100:
     print '%d matches found, not enough for homography estimation' % len(kp_pairs)
     img1 = cv2.imread('2.jpg', 0)
     kp_pairs = match_images(img1, img2)
     if len(kp_pairs) &gt;= 100:
      draw_matches('find_obj', kp_pairs, img1, img2)
      cv2.waitKey()
      cv2.destroyAllWindows() 
     elif len(kp_pairs) &lt;= 100:
       print '%d matches found, not enough for homography estimation' % len(kp_pairs)
       img1 = cv2.imread('3.jpg', 0)
       kp_pairs = match_images(img1, img2)
       if len(kp_pairs) &gt;= 100:
         draw_matches('find_obj', kp_pairs, img1, img2)
         cv2.waitKey()
         cv2.destroyAllWindows() 
       elif len(kp_pairs) &lt;= 100:
            print '%d matches found, not enough for homography estimation' % len(kp_pairs)
            img1 = cv2.imread('4.jpg', 0)
            kp_pairs = match_images(img1, img2)
            if len(kp_pairs) &gt;= 100:
               draw_matches('find_obj', kp_pairs, img1, img2)
               cv2.waitKey()
               cv2.destroyAllWindows() 
            elif len(kp_pairs) &lt;= 100:
               print '%d matches found, not enough for homography estimation' % len(kp_pairs)
               img1 = cv2.imread('5.jpg', 0)
               kp_pairs = match_images(img1, img2)
               if len(kp_pairs) &gt;= 100:
                 draw_matches('find_obj', kp_pairs, img1, img2)
                 cv2.waitKey()
                 cv2.destroyAllWindows() 
               elif len(kp_pairs) &lt;= 100:
                 print '%d matches found, not enough for homography estimation' % len(kp_pairs)
                 img1 = cv2.imread('6.jpg', 0)
                 kp_pairs = match_images(img1, img2)
                 if len(kp_pairs) &gt;= 100:
                   draw_matches('find_obj', kp_pairs, img1, img2)
                   cv2.waitKey()
                   cv2.destroyAllWindows()
                 elif len(kp_pairs) &lt;= 100:
                   print '%d matches found, not enough for homography estimation' % len(kp_pairs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you can run 2 threads at the same time due to <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow">GIL</a>. So, may be you can try <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow">multiprocessing</a> module.</p>
<p>Jut try:</p>
<pre><code>from multiprocessing import Process

def Camera(name):
    print('hello', name)

if __name__ == '__main__':
    p1 = Process(target=Camera, args=('bob',))
    p2 = Process(target=Camera, args=('jack',))
    p1.start()
    p2.start()
    p1.join()
    p2.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an example, I've left space for you to put your camera code.</p>
<pre><code>import thread
import time

# Define a function for the thread
def camera(threadName, delay):
   # Your Code to take a picture, or whatever

# Create two threads as follows
try:
   thread.start_new_thread( camera, ("camera-1", 2, ) )
   thread.start_new_thread( camera, ("camera-2", 4, ) )
except:
   print "Error: unable to start thread"

while 1:
   pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from os import listdir
from os.path import isfile, join
import numpy
import cv2
import os
import sys

def match_images(img1, img2):

detector = cv2.SURF(200, 1, 1)
matcher = cv2.BFMatcher(cv2.NORM_L2)
kp1, desc1 = detector.detectAndCompute(img1, None)
kp2, desc2 = detector.detectAndCompute(img2, None)
print 'img1  %d features, img2  %d features' % (len(kp1), len(kp2))
raw_matches = matcher.knnMatch(desc1, trainDescriptors = desc2, k = 2) 
kp_pairs = filter_matches(kp1, kp2, raw_matches)
return kp_pairs

def filter_matches(kp1, kp2, matches, ratio = 0.75):

mkp1, mkp2 = [], []
for m in matches:
    if len(m) == 2 and m[0].distance &lt; m[1].distance * ratio:
        m = m[0]
        mkp1.append( kp1[m.queryIdx] )
        mkp2.append( kp2[m.trainIdx] )
kp_pairs = zip(mkp1, mkp2)
return kp_pairs

def explore_match(win, img1, img2, kp_pairs, status = None, H = None):

h1, w1 = img1.shape[:2]
h2, w2 = img2.shape[:2]
vis = numpy.zeros((max(h1, h2), w1+w2), numpy.uint8)
vis[:h1, :w1] = img1
vis[:h2, w1:w1+w2] = img2
vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
if H is not None:
    corners = numpy.float32([[0, 0], [w1, 0], [w1, h1], [0, h1]])
    corners = numpy.int32( cv2.perspectiveTransform(corners.reshape(1, -1, 2), H).reshape(-1, 2) + (w1, 0) )
    cv2.polylines(vis, [corners], True, (255, 255, 255))
if status is None:
    status = numpy.ones(len(kp_pairs), numpy.bool_)
p1 = numpy.int32([kpp[0].pt for kpp in kp_pairs])
p2 = numpy.int32([kpp[1].pt for kpp in kp_pairs]) + (w1, 0)
green = (0, 255, 0)
red = (0, 0, 255)
white = (255, 255, 255)
kp_color = (51, 103, 236)
for (x1, y1), (x2, y2), inlier in zip(p1, p2, status):
    if inlier:
        col = green
        cv2.circle(vis, (x1, y1), 2, col, -1)
        cv2.circle(vis, (x2, y2), 2, col, -1)
    else:
        col = red
        r = 2
        thickness = 3
        cv2.line(vis, (x1-r, y1-r), (x1+r, y1+r), col, thickness)
        cv2.line(vis, (x1-r, y1+r), (x1+r, y1-r), col, thickness)
        cv2.line(vis, (x2-r, y2-r), (x2+r, y2+r), col, thickness)
        cv2.line(vis, (x2-r, y2+r), (x2+r, y2-r), col, thickness)
vis0 = vis.copy()
for (x1, y1), (x2, y2), inlier in zip(p1, p2, status):
    if inlier:
        cv2.line(vis, (x1, y1), (x2, y2), green)
cv2.imshow(win, vis)

def draw_matches(window_name, kp_pairs, img1, img2):

   mkp1, mkp2 = zip(*kp_pairs)    
   p1 = numpy.float32([kp.pt for kp in mkp1])
   p2 = numpy.float32([kp.pt for kp in mkp2])   
   if len(kp_pairs) &gt;= 100:
    H, status = cv2.findHomography(p1, p2, cv2.RANSAC, 5.0)
    print '%d / %d  inliers/matched' % (numpy.sum(status), len(status))
    import RPI.GPIO as GPIO
    import time
    GPIO.setup(LEDPin, GPIO.OUT)
    GPIO.output(LEDPin, True)
    print("LED ON")
    time.sleep(5)
    GPIO.output(LEDPin, False)  
   if len(p1):
    explore_match(window_name, img1, img2, kp_pairs, status, H)

if __name__ == '__main__':

  import cv2
  import os 
  camera_port = 1
  ramp_frames = 2
  camera = cv2.VideoCapture(camera_port)
  def get_image():
   retval, im = camera.read()
   return im
   for i in xrange(ramp_frames):
    temp = get_image()
    print("Taking image...")
    camera_capture = get_image()
   file = "C:/Users/oussema/Desktop/projet/scripts/test_image.png"
   cv2.imwrite(file, camera_capture)
   del(camera)
   img2 = cv2.imread('test_image.png', 0)
   img1 = cv2.imread('1.jpg', 0)
   if img1 is None:
    print 'Failed to load img1:'
    sys.exit(1)       
   if img2 is None:
    print 'Failed to load img2:'
    sys.exit(1)
   kp_pairs = match_images(img1, img2)
   if len(kp_pairs) &gt;= 100:
     draw_matches('find_obj', kp_pairs, img1, img2)
     cv2.waitKey()
     cv2.destroyAllWindows() 
   elif len(kp_pairs) &lt;= 100:
    print '%d matches found, not enough for homography estimation' %       len(kp_pairs)
    img1 = cv2.imread('2.jpg', 0)
    kp_pairs = match_images(img1, img2)
   if len(kp_pairs) &gt;= 100:
    draw_matches('find_obj', kp_pairs, img1, img2)
    cv2.waitKey()
    cv2.destroyAllWindows() 
   elif len(kp_pairs) &lt;= 100:
    print '%d matches found, not enough for homography estimation' % len(kp_pairs)
    img1 = cv2.imread('3.jpg', 0)
    kp_pairs = match_images(img1, img2)
    if len(kp_pairs) &gt;= 100:
     draw_matches('find_obj', kp_pairs, img1, img2)
     cv2.waitKey()
     cv2.destroyAllWindows() 
    elif len(kp_pairs) &lt;= 100:
        print '%d matches found, not enough for homography estimation' % len(kp_pairs)
        img1 = cv2.imread('4.jpg', 0)
        kp_pairs = match_images(img1, img2)
        if len(kp_pairs) &gt;= 100:
           draw_matches('find_obj', kp_pairs, img1, img2)
           cv2.waitKey()
           cv2.destroyAllWindows() 
        elif len(kp_pairs) &lt;= 100:
           print '%d matches found, not enough for homography estimation' % len(kp_pairs)
           img1 = cv2.imread('5.jpg', 0)
           kp_pairs = match_images(img1, img2)
           if len(kp_pairs) &gt;= 100:
             draw_matches('find_obj', kp_pairs, img1, img2)
             cv2.waitKey()
             cv2.destroyAllWindows() 
           elif len(kp_pairs) &lt;= 100:
             print '%d matches found, not enough for homography estimation' % len(kp_pairs)
             img1 = cv2.imread('6.jpg', 0)``
             kp_pairs = match_images(img1, img2)
             if len(kp_pairs) &gt;= 100:
               draw_matches('find_obj', kp_pairs, img1, img2)
               cv2.waitKey()
               cv2.destroyAllWindows()
             elif len(kp_pairs) &lt;= 100:
               print '%d matches found, not enough for homography estimation' % len(kp_pairs)     
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use 2 camera because I have a problem when the product is on the mat</p>
</div>
<span class="comment-copy">Have you tried the multi thread library?</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/2846653/how-to-use-threading-in-python">How to use threading in Python?</a></span>
<span class="comment-copy">no I can not understand how to use multithreading to execute my code to the 2 cameras at the same time</span>
<span class="comment-copy">if you want i can send you my code python</span>
<span class="comment-copy">Hi, please show you code.Read the docs!</span>
<span class="comment-copy">please if you see my code how I can do the multiprocessing or multithread i can do this code avec with 2 camera at the same time ??</span>
<span class="comment-copy">@OussemaHelal, wait please, if you have more detail to show, just edit your question and show your code in the question above. Show the code with right indentations. Thanks!</span>
<span class="comment-copy">sir you can send me your mail or if you want i can send you the code by  mail there is my mail : chamakh871@gmail.com                                              because i can not understand what you want for me exact thanks</span>
<span class="comment-copy">you can not see my code or what is the problem Sir @AlexenderYau                    need your help please i send you my mail if you can help me                                 chamakh871@gmail.com</span>
<span class="comment-copy">you see my code ???</span>
<span class="comment-copy">if you see my code you can help me please</span>
