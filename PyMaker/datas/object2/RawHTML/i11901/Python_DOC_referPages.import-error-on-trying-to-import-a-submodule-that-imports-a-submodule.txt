<div class="post-text" itemprop="text">
<p>I feel like I'm missing something simple and basic. Here's a toy setup</p>
<pre><code>PythonProject/
main.py
x/
    a.py
    y/
        b.py
</code></pre>
<p>b.py has a function foo with no dependencies</p>
<pre><code>def foo():
    print("Hello World")
</code></pre>
<p>a.py needs foo from b.py to work and imports it directly</p>
<pre><code>import y.b
def bar():
    #Do some stuff
    y.b.foo()
</code></pre>
<p>main.py needs bar from a.py</p>
<pre><code>import x.a
x.a.bar()
</code></pre>
<p>Now, running a.py works just fine, it successfully imports b and finds foo.
Trying to run main.py however breaks with an import error: specifically "import b" fails during "import a"</p>
<p>I get the impression that what needs to happen is that <code>b</code> needs to be exposed by an <code>__init__.py</code> in <code>a/</code> but I'm unsure what the pythonic way of doing this would be.</p>
<p>What is the preferred solution to importing a module (a) which imports another module (b) preferably without bringing PythonProject awareness to a?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder-in-python">Importing files from different folder in Python</a>:</p>
<h2>main.py</h2>
<pre><code>import sys
sys.path.insert(0, 'C:/path/x')
import a
a.bar()
</code></pre>
<h2>a.py</h2>
<pre><code>import sys
sys.path.insert(0, 'C:/path/x/y')
import b
def bar():
    #Do some stuff
    b.foo()
</code></pre>
<h2>b.py</h2>
<pre><code>def foo():
    print("Hello World")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This was never properly answered even though Paul H alluded to the answer.</p>
<p>It's very simple and mentioned but not directly stated <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">here</a>.</p>
<p>If you have a directory like this:</p>
<pre><code>sound/                      Top-level package
  __init__.py               Initialize the sound package
  formats/                  Subpackage for file format conversions
          __init__.py
          wavread.py
          wavwrite.py
          aiffread.py
          aiffwrite.py
          auread.py
          auwrite.py
          ...
  effects/                  Subpackage for sound effects
          __init__.py
          echo.py
          surround.py
          reverse.py
          ...
  filters/                  Subpackage for filters
          __init__.py
          equalizer.py
          vocoder.py
          karaoke.py
          ...
</code></pre>
<p>The <code>__init__.py</code> file in (for example "effects") needs to include </p>
<pre><code>import effects.echo
import effects.surround
import effects.reverse
</code></pre>
<p>To call a submodule from within a submodule, as you asked, for example, echo calls surround, then you will need to import surround into echo using
<code>import effects.surround as surround</code></p>
</div>
<span class="comment-copy">I copied your code, verbatim, and the problem is not reproducible. What is the exact error you are receiving? Can we see more code?</span>
<span class="comment-copy">Thank you for replying!  I edited the code in the example to make the directory names different from the file names. When I run the exact code I have posted now, I get:  <code>Traceback (most recent call last):   File "main.py", line 1, in &lt;module&gt;     import x.a   File "/Users/rsmirol/PythonProject/x/a.py", line 1, in &lt;module&gt;     import y.b ImportError: No module named 'y'</code></span>
<span class="comment-copy">This happens on <code>python3 main.py</code></span>
<span class="comment-copy">Okay, I will try it now.</span>
<span class="comment-copy">I found a solution! I will post it as an answer.</span>
<span class="comment-copy">So to generalize, we could us os to find the absolute path to a module and add it to the python path?  Do you think this is something that makes sense to do in <code>__init__.py</code> for the modules?</span>
<span class="comment-copy">@Zaez Don't mess with the path. use <code>__init__.py</code> files. <a href="http://stackoverflow.com/a/21995949/1552748">stackoverflow.com/a/21995949/1552748</a></span>
<span class="comment-copy">@PaulH I don't see a solution that works without messing with the path directly or in <code>__init__.py</code> files. What am I missing? The problem essentially is that the project root doesn't care about y, but cares about x which cares about y, so when x calls `import y.b' there is an import error that it can't find y.</span>
<span class="comment-copy">each directory needs an init file. each init file should import the functions it wants to expose to the user. there's no need to modify the path.</span>
<span class="comment-copy">that's not how packages should be built: <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#packages</a></span>
<span class="comment-copy">although - if someone wants to add to this so that a main() function within echo doesn't need to be called with echo.main(arg1, etc) but rather echo(arg1, etc) that'd be great</span>
