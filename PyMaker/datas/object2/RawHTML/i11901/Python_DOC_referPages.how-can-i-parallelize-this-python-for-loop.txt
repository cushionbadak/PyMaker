<div class="post-text" itemprop="text">
<p>I'm dealing with an image processing problem that needs to be parallelized. I've seen several examples showing the use of parallel processing in Python, but the inputs of all those examples are 1-D arrays. 
Therefore, I'm looking for a way to parallelize a function performing a two processes on an image. The following code is what I need to be prallelized:</p>
<pre><code>for i in arange(0, shape(img)[0] - window_size[0], 10):
    for j in arange(0, shape(img)[1] - window_size[1], 10):
        Process1 = Do_something(img[i: i + winSize[0], j: j + winSize[1]])
        Process2 = Do_something(Process1)
</code></pre>
<p>How this nested loop can be parallelized?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not entirely sure what do the variables mean or what does the <code>Do_something()</code> function does but this is a general way to make it parallel:</p>
<pre><code>import concurrent.futures
import functools

def process_stuff(i, j, img, winSize):
    Process1 = Do_something(img[i: i + winSize[0], j: j + winSize[1]])
    Process2 = Do_something(Process1)

with concurrent.futures.ProcessPoolExecutor() as executor:
    for i in arange(0, shape(img)[0] - window_size[0], 10):
        for j in arange(0, shape(img)[1] - window_size[1], 10):
            executor.submit(process_stuff, i, j, img, winSize)
</code></pre>
<p>This solution is fitted to Python 3.2 and above. Older versions may use the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow">multiprocessing</a> module.</p>
<p>If you wish for a more efficient way allowing to get the return values too, this is another way:</p>
<pre><code>import concurrent.futures
import functools
import itertools
import operator

def process_stuff(i, j, img, winSize):
    Process1 = Do_something(img[i: i + winSize[0], j: j + winSize[1]])
    Process2 = Do_something(Process1)

with concurrent.futures.ProcessPoolExecutor() as executor:
    i_iterator = arange(0, shape(img)[0] - window_size[0], 10)
    j_iterator = arange(0, shape(img)[1] - window_size[1], 10)
    product = itertools.product(i_iterator, j_iterator)
    iter1, iter2 = itertools.tee(product)
    i_iterator = map(operator.itemgetter(0), iter1)
    j_iterator = map(operator.itemgetter(1), iter2)

    do_process = functools.partial(process_stuff, img=img, winSize=winSize)
    executor.map(do_process, i_iterator, j_iterator)
</code></pre>
<p>It's a bit more complicated but what I did here is get the <code>product()</code> of all combinations of <code>i</code> and <code>j</code>, split <code>i</code> and <code>j</code> into two iterators, and <code>map()</code> with the iterators as variables.</p>
<p><strong>UPDATE:</strong></p>
<p>My best bet is that the thing holding you up is the transfer of the image to different processes.
This will only transfer the appropriate part of the image:</p>
<pre><code>import concurrent.futures
import itertools

def process_stuff(img_part):
    Process1 = Do_something(img_part)
    Process2 = Do_something(Process1)

with concurrent.futures.ProcessPoolExecutor() as executor:
    i_iterator = arange(0, shape(img)[0] - window_size[0], 10)
    j_iterator = arange(0, shape(img)[1] - window_size[1], 10)
    product = itertools.product(i_iterator, j_iterator)
    parts_generator = (img[i: i + winSize[0], j: j + winSize[1]]
                       for i, j in product)

    executor.map(process_stuff, parts_generator)
</code></pre>
</div>
<span class="comment-copy">Have a look at this: <a href="https://www.quora.com/What-is-the-Python-equivalent-of-MATLABs-parfor" rel="nofollow noreferrer">quora.com/What-is-the-Python-equivalent-of-MATLABs-parfor</a></span>
<span class="comment-copy">You should probably add a note that this only works in Python 3.2 and above.</span>
<span class="comment-copy">@Bharel, thank you so much for the time you took to help me. I used both forms of your solution. Although all the cores are used after running the program, the time of yielding the results is significantly longer than the single-core processing. Where am I doing a mistake? Thank you</span>
<span class="comment-copy">Thanks @Federico :-) I submitted a 3rd solution. It's a bit problematic for me to know what part of the code takes the time. If <code>Do_something()</code> is the function that takes a long time, and it's able to run parallel, submitting the appropriate image parts to the function will incur only a small transfer overhead and will result in a faster execution.</span>
<span class="comment-copy">@Bharel, I'm so grateful for proposing the third solution. It's actually an object detection problem. The <code>Process1</code> computes the HOG of the respective part of an image, and the <code>Process2</code> predicts the result, using SVM classification.  The <code>Process1</code> takes no time, but <code>Process2</code>, which is the prediction part, deteriorates the speed! It worth to add that for SVM, I'm using <code>Sklearn.svm</code> module and for HOG, <code>OpenCV</code>, which is very fast.</span>
<span class="comment-copy">@Federico how is the third solution doing then?</span>
