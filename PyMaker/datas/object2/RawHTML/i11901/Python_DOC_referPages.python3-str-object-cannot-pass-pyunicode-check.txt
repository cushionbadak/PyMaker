<div class="post-text" itemprop="text">
<p>I was writing a C extension function, which was supposed to accept a <code>str</code> object as argument. The code is shown below:</p>
<pre><code>static PyObject *py_print_chars(PyObject *self, PyObject *o) {
PyObject *bytes;
char *s;
if (!PyUnicode_Check(o)) {
    PyErr_SetString(PyExc_TypeError, "Expected string");
    return NULL;
}
bytes = PyUnicode_AsUTF8String(o);
s = PyBytes_AsString(bytes);
print_chars(s);
Py_DECREF(bytes);
Py_RETURN_NONE;
}
</code></pre>
<p>But as I test the module in python3 console, I find <code>str</code> objects can't pass the <code>PyUnicode_Check</code>:</p>
<pre><code>&gt;&gt;&gt; from sample2 import *    
&gt;&gt;&gt; print_chars('Hello world')    
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Expected string
</code></pre>
<p>As far as I know, Python 3’s <code>str()</code> type is called PyUnicode in C and the C code above was written in refer to "python cookbook3" Char15.13. I just can't work out the problem. Can anybody tell me what's wrong with my code.</p>
<p>Here is what "python cookbook3" said:</p>
<p>If for some reason, you are working directly with a PyObject * and can’t use PyArg_ParseTuple(), the following code samples show how you can check and extract a suitable <code>char *</code> reference, from both a bytes and string object:</p>
<pre><code>/* Some Python Object (obtained somehow) */
PyObject *obj;

/* Conversion from bytes */
{
    char *s;
    s = PyBytes_AsString(o);
    if (!s) {
       return NULL;   /* TypeError already raised */
    }
    print_chars(s);
}
/* Conversion to UTF-8 bytes from a string */
{
    PyObject *bytes;
    char *s;
    if (!PyUnicode_Check(obj)) {
        PyErr_SetString(PyExc_TypeError, "Expected string");
        return NULL;
    }
    bytes = PyUnicode_AsUTF8String(obj);
    s = PyBytes_AsString(bytes);
    print_chars(s);
    Py_DECREF(bytes);
}
</code></pre>
<hr/>
<p>And the whole code:</p>
<pre><code>#include "Python.h"
#include "sample.h"

static PyObject *py_print_chars(PyObject *self, PyObject *o) {
    PyObject *bytes;
    char *s;
    if (!PyUnicode_Check(o)) {
        PyErr_SetString(PyExc_TypeError, "Expected string");
        return NULL;
    }
    bytes = PyUnicode_AsUTF8String(o);
    s = PyBytes_AsString(bytes);
    print_chars(s);
    Py_DECREF(bytes);
    Py_RETURN_NONE;
}

/* Module method table */
static PyMethodDef SampleMethods[] = {
    {"print_chars", py_print_chars, METH_VARARGS, "print character"},
    { NULL, NULL, 0, NULL}
};

/* Module structure */
static struct PyModuleDef samplemodule = {
PyModuleDef_HEAD_INIT,
    "sample",
    "A sample module",
    -1,
    SampleMethods
};

/* Module initialization function */
PyMODINIT_FUNC
PyInit_sample2(void) {
    return PyModule_Create(&amp;samplemodule);
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the goal is to accept exactly one argument, the function <a href="https://docs.python.org/3/c-api/structures.html#METH_O" rel="nofollow">should be declared as <code>METH_O</code></a>, not <code>METH_VARARGS</code>; the former passes along the single argument without wrapping, the latter wraps in a <code>tuple</code> which would need to be unpacked or parsed to get the <code>PyUnicode*</code> inside.</p>
</div>
<span class="comment-copy">Don't you need <code>PyArg_ParseTuple</code> with an argument of <code>u</code> first?  But it does depend on the  argument types in the method table (like METH_VARARGS), which you have not shown.</span>
<span class="comment-copy">Yes, factuallty, a PyArg_parseTupel can slove this problem perfectly. But it's said in "python cookbook3" there is another workout without using PyArg_ParseTuple.</span>
<span class="comment-copy">I wasn't thinking any part else of the code may go wrong for it worked well for other funciton. I am adding the whole code on question description.</span>
<span class="comment-copy">Thanks, you right hit the point.</span>
