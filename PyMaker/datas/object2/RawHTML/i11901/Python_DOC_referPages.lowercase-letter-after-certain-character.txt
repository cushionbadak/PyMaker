<div class="post-text" itemprop="text">
<p>I like some ways of how <code>string.capwords()</code> behaves, and some ways of how <code>.title()</code> behaves, but not one single one.</p>
<p>I need abbreviations capitalized, which <code>.title()</code> does, but not <code>string.capwords()</code>, and <code>string.capwords()</code> does not capitalize letters after single quotes, so I need a combination of the two. I want to use <code>.title(),</code> and then I need to lowercase the single letter after an apostrophe only if there are no spaces between.</p>
<p>For example, here's a user's input:</p>
<pre><code>string="it's e.t.!"
</code></pre>
<p>And I want to convert it to:</p>
<pre><code>&gt;&gt;&gt; "It's E.T.!"
</code></pre>
<p><code>.title()</code> would capitalize the 's', and <code>string.capwords()</code> would not capitalize the "e.t.".</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expression substitution (See <a href="https://docs.python.org/3/library/re.html#re.sub"><code>re.sub</code></a>):</p>
<pre><code>&gt;&gt;&gt; s = "it's e.t.!"
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub(r"\b(?&lt;!')[a-z]", lambda m: m.group().upper(), s)
"It's E.T.!"
</code></pre>
<p><code>[a-z]</code> will match lowercase alphabet letter. But not after <code>'</code> (<code>(?&lt;!')</code> - negative look-behind assertion). And the letter should appear after the word boundary; so <code>t</code> will not be matched.</p>
<p>The second argument to <code>re.sub</code>, <code>lambda</code> will return substitution string. (upper version of the letter) and it will be used for replacement.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = ".".join( [word.capitalize() for word in "it's e.t.!".split(".")] )
b = " ".join( [word.capitalize() for word in a.split(" ")] )
print(b)
</code></pre>
<p>Edited to use the capitalize function instead. Now it's starting to look like something usable :). But this solution doesn't work with other whitespace characters. For that I would go with falsetru's solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>if you don't want to use regex , you can always use this simple for loop</p>
<pre><code>s = "it's e.t.!"
capital_s = ''
pos_quote = s.index("'")
for pos, alpha in enumerate(s):
    if pos not in [pos_quote-1, pos_quote+1]:
        alpha = alpha.upper()
    capital_s += alpha
print capital_s
</code></pre>
<p>hope this helps :)</p>
</div>
<span class="comment-copy">Try utilize regular expression in this scenario may be more straightforward</span>
<span class="comment-copy">argh you got there first, nice one!</span>
<span class="comment-copy">Thanks! Works as expected!</span>
<span class="comment-copy">@TrivisionZero, I don't get it. Could you give me example string?</span>
<span class="comment-copy">Nevermind, it's a bug somewhere in my code!</span>
<span class="comment-copy">Try with <code>it's e.t.!</code>, not with the string already capitalized.</span>
<span class="comment-copy">whoops. Let me fix that</span>
<span class="comment-copy">What if <code>,</code> is appear between words?</span>
<span class="comment-copy">It still works with commas or periods between words, however, it doesn't catch other whitespace characters like newlines and tabs.</span>
<span class="comment-copy"><code>a = ".".join( [word[0].upper()+word[1:] for word in "it's e,t,!".split(".")] ); b = " ".join( [word[0].upper()+word[1:] for word in a.split(" ")] ); b</code></span>
