<div class="post-text" itemprop="text">
<p>I'm looking to find out how to use Python to get rid of needless newlines in text like what you get from Project Gutenberg, where their plain-text files are formatted with newlines every 70 characters or so. In Tcl, I could do a simple <code>string map</code>, like this:</p>
<pre><code>set newtext [string map "{\r} {} {\n\n} {\n\n} {\n\t} {\n\t} {\n} { }" $oldtext]
</code></pre>
<p>This would keep paragraphs separated by two newlines (or a newline and a tab) separate, but run together the lines that ended with a single newline (substituting a space), and drop superfluous CR's. Since Python doesn't have <code>string map</code>, I haven't yet been able to find out the most efficient way to dump all the needless newlines, although I'm pretty sure it's <em>not</em> just to search for each newline in order and replace it with a space. I could just evaluate the Tcl expression in Python, if all else fails, but I'd like to find out the best Pythonic way to do the same thing. Can some Python connoisseur here help me out?</p>
</div>
<div class="post-text" itemprop="text">
<p>The nearest equivalent to the tcl <code>string map</code> would be <a href="http://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow">str.translate</a>, but unfortunately it can only map single characters. So it would be necessary to use a regexp to get a similarly compact example. This can be done with <a href="http://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow">look-behind/look-ahead assertions</a>, but the <code>\r</code>'s have to be replaced first:</p>
<pre><code>import re

oldtext = """\
This would keep paragraphs separated.
This would keep paragraphs separated.

This would keep paragraphs separated.
\tThis would keep paragraphs separated.

\rWhen, in the course
of human events,
it becomes necessary
\rfor one people
"""

newtext = re.sub(r'(?&lt;!\n)\n(?![\n\t])', ' ', oldtext.replace('\r', ''))
</code></pre>
<p>output:</p>
<pre><code>This would keep paragraphs separated. This would keep paragraphs separated.

This would keep paragraphs separated.
    This would keep paragraphs separated.

When, in the course of human events, it becomes necessary for one people
</code></pre>
<p>I doubt whether this is as efficient as the tcl code, though.</p>
<p><strong>UPDATE</strong>:</p>
<p>I did a little test using this <a href="http://www.gutenberg.org/cache/epub/2600/pg2600.txt" rel="nofollow">Project Gutenberg EBook of War and Peace</a> (Plain Text UTF-8, 3.1 MB). Here's my tcl script:</p>
<pre><code>set fp [open "gutenberg.txt" r]
set oldtext [read $fp]
close $fp

set newtext [string map "{\r} {} {\n\n} {\n\n} {\n\t} {\n\t} {\n} { }" $oldtext]

puts $newtext
</code></pre>
<p>and my python equivalent:</p>
<pre><code>import re

with open('gutenberg.txt') as stream:
    oldtext = stream.read()

    newtext = re.sub(r'(?&lt;!\n)\n(?![\n\t])', ' ', oldtext.replace('\r', ''))

    print(newtext)
</code></pre>
<p>Crude performance test:</p>
<pre><code>$ /usr/bin/time -f '%E' tclsh gutenberg.tcl &gt; output1.txt
0:00.18
$ /usr/bin/time -f '%E' python gutenberg.py &gt; output2.txt
0:00.30
</code></pre>
<p>So, as expected, the tcl version is more efficient. However, the output from the python version seems somewhat cleaner (no extra spaces inserted at the beginning of lines). </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a regular expression with a look-ahead search:</p>
<pre><code>import re

text = """
...
"""

newtext = re.sub(r"\n(?=[^\n\t])", " ", text)
</code></pre>
<p>That will replace any new line that is not followed by a newline or a tab with a space.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use the following script when I want to do this:</p>
<pre><code>import sys
import os

filename, extension = os.path.splitext(sys.argv[1])

with open(filename+extension, encoding='utf-8-sig') as (file
  ), open(filename+"_unwrapped"+extension, 'w', encoding='utf-8-sig') as (output
  ):
    *lines, last = list(file)
    for line in lines:
        if line == "\n":
            line = "\n\n"
        elif line[0] == "\t":
            line = "\n" + line[:-1] + " "
        else:
            line = line[:-1] + " "
        output.write(line)
    output.write(last)
</code></pre>
<ul>
<li>A "blank" line, with only a linefeed, turns into two linefeeds (to replace the one removed from the previous line). This handles files that separate paragraphs with two linefeeds.</li>
<li>A line beginning with a tab gets a leading linefeed (to replace the one removed from the previous line) and gets its trailing linefeed replaced with a space. This handles files that separate paragraphs with a tab character.</li>
<li>A line that is neither blank nor beginning with a tab gets its trailing linefeed replace with a space.</li>
<li>The last line in the file may not have a trailing linefeed and therefore gets copied directly.</li>
</ul>
</div>
<span class="comment-copy">Your code has an extra parenthesis at the end which gave me a syntax error, but it worked fine after I removed the extra parenthesis, and it looks pretty efficient to me. Also, you remembered (which I didn't) that I needed to get rid of <code>\r</code> as well as <code>\n</code>. I'll probably leave it to somebody else to run time tests on this versus the Tcl code with a gigantic text file from Project Gutenberg. :o)</span>
<span class="comment-copy">I just remembered . . . I did remember <code>\r</code> too, but so did you.</span>
<span class="comment-copy">@McClamrock. Fixed my example code: thanks. I may have a go a doing some timings, but I'll have to learn a bit of tcl first ;-)</span>
<span class="comment-copy">Tcl is even easier than Python in some ways. It has too many curly braces and square brackets, but then Python has too many quotes and parentheses.</span>
<span class="comment-copy">@McClamrock. I did some basic testing: see my updated answer.</span>
<span class="comment-copy">That got rid of some newlines, but not all:     &gt;&gt;&gt; whenin = "when, in the course\nof human events,\nit becomes necessary\nfor one people"     &gt;&gt;&gt; import re     &gt;&gt;&gt; newtext = re.sub(r"\b\n\b", " ", whenin)     &gt;&gt;&gt; newtext     'when, in the course of human events,\nit becomes necessary for one people'  Why not the one after the comma?</span>
<span class="comment-copy">@McClamrock: I have changed my answer.</span>
<span class="comment-copy">That's more like it--it works right now. :o)</span>
<span class="comment-copy">Oops, except for one little flaw: it doesn't get rid of <code>\r</code> as well as <code>\n</code>.</span>
<span class="comment-copy">Impressive script, but it doesn't do the job in one line of code! :o)</span>
