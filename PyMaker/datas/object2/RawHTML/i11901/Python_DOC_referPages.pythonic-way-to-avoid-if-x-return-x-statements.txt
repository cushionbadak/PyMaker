<div class="post-text" itemprop="text">
<p>I have a method that calls 4 other methods in sequence to check for specific conditions, and returns immediately (not checking the following ones) whenever one returns something Truthy.</p>
<pre><code>def check_all_conditions():
    x = check_size()
    if x:
        return x

    x = check_color()
    if x:
        return x

    x = check_tone()
    if x:
        return x

    x = check_flavor()
    if x:
        return x
    return None
</code></pre>
<p>This seems like a lot of baggage code. Instead of each 2-line if statement, I'd rather do something like:</p>
<pre><code>x and return x
</code></pre>
<p>But that is invalid Python. Am I missing a simple, elegant solution here? Incidentally, in this situation, those four check methods may be expensive, so I do not want to call them multiple times.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a loop:</p>
<pre><code>conditions = (check_size, check_color, check_tone, check_flavor)
for condition in conditions:
    result = condition()
    if result:
        return result
</code></pre>
<p>This has the added advantage that you can now make the number of conditions variable.</p>
<p>You could use <a href="https://docs.python.org/3/library/functions.html#map" rel="noreferrer"><code>map()</code></a> + <a href="https://docs.python.org/3/library/functions.html#filter" rel="noreferrer"><code>filter()</code></a> (the Python 3 versions, use the <a href="https://docs.python.org/2/library/future_builtins.html" rel="noreferrer"><code>future_builtins</code> versions</a> in Python 2) to get the first such matching value:</p>
<pre><code>try:
    # Python 2
    from future_builtins import map, filter
except ImportError:
    # Python 3
    pass

conditions = (check_size, check_color, check_tone, check_flavor)
return next(filter(None, map(lambda f: f(), conditions)), None)
</code></pre>
<p>but if this is more readable is debatable.</p>
<p>Another option is to use a generator expression:</p>
<pre><code>conditions = (check_size, check_color, check_tone, check_flavor)
checks = (condition() for condition in conditions)
return next((check for check in checks if check), None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively to Martijn's fine answer, you could chain <code>or</code>. This will return the first truthy value, or <code>None</code> if there's no truthy value:</p>
<pre><code>def check_all_conditions():
    return check_size() or check_color() or check_tone() or check_flavor() or None
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; x = [] or 0 or {} or -1 or None
&gt;&gt;&gt; x
-1
&gt;&gt;&gt; x = [] or 0 or {} or '' or None
&gt;&gt;&gt; x is None
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Don't change it</strong></p>
<p>There are other ways of doing this as the various other answers show. None are as clear as your original code.</p>
</div>
<div class="post-text" itemprop="text">
<p>In effectively the same answer as timgeb, but you could use parenthesis for nicer formatting:</p>
<pre><code>def check_all_the_things():
    return (
        one()
        or two()
        or five()
        or three()
        or None
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="http://blog.codinghorror.com/curlys-law-do-one-thing/">Curly's law</a>, you can make this code more readable by splitting two concerns:</p>
<ul>
<li>What things do I check?</li>
<li>Has one thing returned true?</li>
</ul>
<p>into two functions:</p>
<pre class="lang-py prettyprint-override"><code>def all_conditions():
    yield check_size()
    yield check_color()
    yield check_tone()
    yield check_flavor()

def check_all_conditions():
    for condition in all_conditions():
        if condition:
            return condition
    return None
</code></pre>
<p>This avoids:</p>
<ul>
<li>complicated logical structures</li>
<li>really long lines</li>
<li>repetition</li>
</ul>
<p>...while preserving a linear, easy to read flow.</p>
<p>You can probably also come up with even better function names, according to your particular circumstance, which make it even more readable.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a variant of Martijns first example. It also uses the "collection of callables"-style in order to allow short-circuiting.</p>
<p>Instead of a loop you can use the builtin <code>any</code>. </p>
<pre><code>conditions = (check_size, check_color, check_tone, check_flavor)
return any(condition() for condition in conditions) 
</code></pre>
<p>Note that <code>any</code> returns a boolean, so if you need the exact return value of the check, this solution will not work. <code>any</code> will not distinguish between <code>14</code>, <code>'red'</code>, <code>'sharp'</code>, <code>'spicy'</code> as return values, they will all be returned as <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you considered just writing <code>if x: return x</code> all on one line?</p>
<pre><code>def check_all_conditions():
    x = check_size()
    if x: return x

    x = check_color()
    if x: return x

    x = check_tone()
    if x: return x

    x = check_flavor()
    if x: return x

    return None
</code></pre>
<p>This isn't any less <em>repetitive</em> than what you had, but IMNSHO it reads quite a bit smoother.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm quite surprised nobody mentioned the built-in <a href="https://docs.python.org/2/library/functions.html#any"><code>any</code></a> which is made for this purpose:</p>
<pre><code>def check_all_conditions():
    return any([
        check_size(),
        check_color(),
        check_tone(),
        check_flavor()
    ])
</code></pre>
<p>Note that although this implementation is probably the clearest, it evaluates all the checks even if the first one is <code>True</code>.</p>
<hr/>
<p>If you really need to stop at the first failed check, consider using <a href="https://docs.python.org/2/library/functions.html#reduce"><code>reduce</code></a> which is made to convert a list to a simple value:</p>
<pre><code>def check_all_conditions():
    checks = [check_size, check_color, check_tone, check_flavor]
    return reduce(lambda a, f: a or f(), checks, False)
</code></pre>
<blockquote>
<p><code>reduce(function, iterable[, initializer])</code> : Apply function of two
  arguments cumulatively to the items of iterable, from left to right,
  so as to reduce the iterable to a single value. The left argument, x,
  is the accumulated value and the right argument, y, is the update
  value from the iterable. If the optional initializer is present, it is
  placed before the items of the iterable in the calculation</p>
</blockquote>
<p>In your case:</p>
<ul>
<li><code>lambda a, f: a or f()</code> is the function that checks that either the accumulator <code>a</code> or the current check <code>f()</code> is <code>True</code>. Note that if <code>a</code> is <code>True</code>, <code>f()</code> won't be evaluated.</li>
<li><code>checks</code> contains check functions (the <code>f</code> item from the lambda)</li>
<li><code>False</code> is the initial value, otherwise no check would happen and the result would always be <code>True</code></li>
</ul>
<p><code>any</code> and <code>reduce</code> are basic tools for functional programming. I strongly encourage you to train these out as well as <a href="https://docs.python.org/2/library/functions.html#map"><code>map</code></a> which is awesome too!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the same code structure, you could use ternary statements!</p>
<pre><code>def check_all_conditions():
    x = check_size()
    x = x if x else check_color()
    x = x if x else check_tone()
    x = x if x else check_flavor()

    return x if x else None
</code></pre>
<p>I think this looks nice and clear if you look at it.</p>
<p>Demo:</p>
<p><img alt="Screenshot of it running" src="https://i.stack.imgur.com/gYcy8.png"/></p>
</div>
<div class="post-text" itemprop="text">
<p>For me, the best answer is that from @phil-frost, followed by @wayne-werner's.</p>
<p>What I find interesting is that no one has said anything about the fact that a function will be returning many different data types, which will make then mandatory to do checks on the type of x itself to do any further work.</p>
<p>So I would mix @PhilFrost's response with the idea of keeping a single type:</p>
<pre><code>def all_conditions(x):
    yield check_size(x)
    yield check_color(x)
    yield check_tone(x)
    yield check_flavor(x)

def assessed_x(x,func=all_conditions):
    for condition in func(x):
        if condition:
            return x
    return None
</code></pre>
<p>Notice that <code>x</code> is passed as an argument, but also <code>all_conditions</code> is used as a passed generator of checking functions where all of them get an <code>x</code> to be checked, and return <code>True</code> or <code>False</code>. By using <code>func</code> with <code>all_conditions</code> as default value, you can use <code>assessed_x(x)</code>, or you can pass a further personalised generator via <code>func</code>.</p>
<p>That way, you get <code>x</code> as soon as one check passes, but it will always be the same type.</p>
</div>
<div class="post-text" itemprop="text">
<p>A slight variation on Martijns first example above, that avoids the if inside the loop:</p>
<pre><code>Status = None
for c in [check_size, check_color, check_tone, check_flavor]:
  Status = Status or c();
return Status
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ideally, I would re-write the <code>check_</code>  functions to return <code>True</code> or <code>False</code> rather than a value. Your checks then become</p>
<pre><code>if check_size(x):
    return x
#etc
</code></pre>
<p>Assuming your <code>x</code> is not immutable, your function can still modify it (although they can't reassign it) - but a function called <code>check</code> shouldn't really be modifying it anyway. </p>
</div>
<div class="post-text" itemprop="text">
<p>This way is a little bit outside of the box, but I think the end result is simple, readable, and looks nice. </p>
<p>The basic idea is to <code>raise</code> an exception when one of the functions evaluates as truthy, and return the result. Here's how it might look: </p>
<pre><code>def check_conditions():
    try:
        assertFalsey(
            check_size,
            check_color,
            check_tone,
            check_flavor)
    except TruthyException as e:
        return e.trigger
    else:
        return None
</code></pre>
<p>You'll need a <code>assertFalsey</code> function that raises an exception when one of the called function arguments evaluates as truthy: </p>
<pre><code>def assertFalsey(*funcs):
    for f in funcs:
        o = f()
        if o:
            raise TruthyException(o)
</code></pre>
<p>The above could be modified so as to also provide arguments for the functions to be evaluated. </p>
<p>And of course you'll need the <code>TruthyException</code> itself. This exception provides the <code>object</code> that triggered the exception: </p>
<pre><code>class TruthyException(Exception):
    def __init__(self, obj, *args):
        super().__init__(*args)
        self.trigger = obj
</code></pre>
<p>You can turn the original function into something more general, of course: </p>
<pre><code>def get_truthy_condition(*conditions):
    try:
        assertFalsey(*conditions)
    except TruthyException as e:
        return e.trigger
    else:
        return None

result = get_truthy_condition(check_size, check_color, check_tone, check_flavor)
</code></pre>
<p>This might be a bit slower because you are using both an <code>if</code> statement and handling an exception. However, the exception is only handled a maximum of one time, so the hit to performance should be minor unless you expect to run the check and get a <code>True</code> value many many thousands of times. </p>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way is either using reduce (as someone already mentioned) or itertools (as shown below), but <strong>it seems to me that simply using short circuiting of the <code>or</code> operator produces clearer code</strong></p>
<pre><code>from itertools import imap, dropwhile

def check_all_conditions():
    conditions = (check_size,\
        check_color,\
        check_tone,\
        check_flavor)
    results_gen = dropwhile(lambda x:not x, imap(lambda check:check(), conditions))
    try:
        return results_gen.next()
    except StopIteration:
        return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like @timgeb's. In the meantime I would like to add that expressing <code>None</code> in the <code>return</code> statement is not needed as the collection of <code>or</code> separated statements are evaluated and the first none-zero, none-empty, none-None is returned and if there isn't any then <code>None</code> is returned whether there is a <code>None</code> or not!</p>
<p>So my <code>check_all_conditions()</code> function looks like this:</p>
<pre><code>def check_all_conditions():
    return check_size() or check_color() or check_tone() or check_flavor()
</code></pre>
<p>Using <code>timeit</code> with <code>number=10**7</code> I looked at the running time of a number of the suggestions. For the sake of comparison I just used the <code>random.random()</code> function to return a string or <code>None</code> based on random numbers. Here is the whole code:</p>
<pre><code>import random
import timeit

def check_size():
    if random.random() &lt; 0.25: return "BIG"

def check_color():
    if random.random() &lt; 0.25: return "RED"

def check_tone():
    if random.random() &lt; 0.25: return "SOFT"

def check_flavor():
    if random.random() &lt; 0.25: return "SWEET"

def check_all_conditions_Bernard():
    x = check_size()
    if x:
        return x

    x = check_color()
    if x:
        return x

    x = check_tone()
    if x:
        return x

    x = check_flavor()
    if x:
        return x
    return None

def check_all_Martijn_Pieters():
    conditions = (check_size, check_color, check_tone, check_flavor)
    for condition in conditions:
        result = condition()
        if result:
            return result

def check_all_conditions_timgeb():
    return check_size() or check_color() or check_tone() or check_flavor() or None

def check_all_conditions_Reza():
    return check_size() or check_color() or check_tone() or check_flavor()

def check_all_conditions_Phinet():
    x = check_size()
    x = x if x else check_color()
    x = x if x else check_tone()
    x = x if x else check_flavor()

    return x if x else None

def all_conditions():
    yield check_size()
    yield check_color()
    yield check_tone()
    yield check_flavor()

def check_all_conditions_Phil_Frost():
    for condition in all_conditions():
        if condition:
            return condition

def main():
    num = 10000000
    random.seed(20)
    print("Bernard:", timeit.timeit('check_all_conditions_Bernard()', 'from __main__ import check_all_conditions_Bernard', number=num))
    random.seed(20)
    print("Martijn Pieters:", timeit.timeit('check_all_Martijn_Pieters()', 'from __main__ import check_all_Martijn_Pieters', number=num))
    random.seed(20)
    print("timgeb:", timeit.timeit('check_all_conditions_timgeb()', 'from __main__ import check_all_conditions_timgeb', number=num))
    random.seed(20)
    print("Reza:", timeit.timeit('check_all_conditions_Reza()', 'from __main__ import check_all_conditions_Reza', number=num))
    random.seed(20)
    print("Phinet:", timeit.timeit('check_all_conditions_Phinet()', 'from __main__ import check_all_conditions_Phinet', number=num))
    random.seed(20)
    print("Phil Frost:", timeit.timeit('check_all_conditions_Phil_Frost()', 'from __main__ import check_all_conditions_Phil_Frost', number=num))

if __name__ == '__main__':
    main()
</code></pre>
<p>And here are the results:</p>
<pre><code>Bernard: 7.398444877040768
Martijn Pieters: 8.506569201346597
timgeb: 7.244275416364456
Reza: 6.982133448743038
Phinet: 7.925932800076634
Phil Frost: 11.924794811353031
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm going to jump in here and have never written a single line of Python, but I assume <code>if x = check_something(): return x</code> is valid?</p>
<p>if so:</p>
<pre><code>def check_all_conditions():

    if (x := check_size()): return x
    if (x := check_color()): return x
    if (x := check_tone()): return x
    if (x := check_flavor()): return x

    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have seen some interesting implementations of switch/case statements with dicts in the past that led me to this answer. Using the example you've provided you would get the following. (It's madness <code>using_complete_sentences_for_function_names</code>, so <code>check_all_conditions</code> is renamed to <code>status</code>. See (1))</p>
<pre><code>def status(k = 'a', s = {'a':'b','b':'c','c':'d','d':None}) :
  select = lambda next, test : test if test else next
  d = {'a': lambda : select(s['a'], check_size()  ),
       'b': lambda : select(s['b'], check_color() ),
       'c': lambda : select(s['c'], check_tone()  ),
       'd': lambda : select(s['d'], check_flavor())}
  while k in d : k = d[k]()
  return k
</code></pre>
<p>The select function eliminates the need to call each <code>check_FUNCTION</code> twice i.e. you avoid <code>check_FUNCTION() if check_FUNCTION() else next</code> by adding another function layer. This is useful for long running functions. The lambdas in the dict delay execution of it's values until the while loop.</p>
<p>As a bonus you may modify the execution order and even skip some of the tests by altering <code>k</code> and <code>s</code> e.g. <code>k='c',s={'c':'b','b':None}</code> reduces the number of tests and reverses the original processing order.</p>
<p>The <code>timeit</code> fellows might haggle over the cost of adding an extra layer or two to the stack and the cost for the dict look up but you seem more concerned with the prettiness of the code.</p>
<p>Alternatively a simpler implementation might be the following :</p>
<pre><code>def status(k=check_size) :
  select = lambda next, test : test if test else next
  d = {check_size  : lambda : select(check_color,  check_size()  ),
       check_color : lambda : select(check_tone,   check_color() ),
       check_tone  : lambda : select(check_flavor, check_tone()  ),
       check_flavor: lambda : select(None,         check_flavor())}
  while k in d : k = d[k]()
  return k
</code></pre>
<ol>
<li>I mean this not in terms of pep8 but in terms of using one concise descriptive word in place of a sentence. Granted the OP may be following some coding convention, working one some existing code base or not care for terse terms in their codebase.</li>
</ol>
</div>
<span class="comment-copy">What are these x's? Are they just True/False, or are they data structures containing some information, with None or similar being used as a special case to indicate the absence of any data? If it's the latter, you should almost certainly be using exceptions instead.</span>
<span class="comment-copy">@gerrit The code as presented above is hypothetical/pseudo code which is off-topic on Code Review. If the author of the post wish to get their <i>real, actual working code</i> reviewed, then yes they are welcome to post on Code Review.</span>
<span class="comment-copy">Why do you think <code>x and return x</code> is better than <code>if x: return x</code>? The latter is far more readable and thus maintainable. You shouldn't worry too much about the number of characters or lines; readability counts. They're the exact same number of non-whitespace characters anyway, and if you really must, <code>if x: return x</code> will work fine on just one line.</span>
<span class="comment-copy">Please clarify whether you care about the actual values or you really just need to return a boolean. This makes a difference what options are available and also which ones more clearly communicate the intent. The naming suggests you only need a boolean. It also makes a difference whether avoiding multiple calls to these functions is important. It could also matter if the functions take any or different sets of parameters. Without these clarifications, I think this question falls into one of Unclear, Too Broad, or Opinion Based.</span>
<span class="comment-copy">@jpmc26 OP explicitly speaks of truthy return values, and then his code returns <code>x</code> (as opposed to <code>bool(x)</code>) so as it stands I think it is safe to assume that OP's functions can return anything, and he wants the first anything that's truthy.</span>
<span class="comment-copy">if the conditions are really only conditions, i.e. booleans then in your first proposal you could also use the builtin <code>any</code> instead of the loop. <code>return any(condition() for condition in conditions)</code></span>
<span class="comment-copy">@Leonhard: <code>any</code> has almost the same implementation inside. But it looks much better, please post it as an answer )</span>
<span class="comment-copy">Readability trumps almost all other considerations.  You say, map/filter is 'debatable', I put my vote in for undebatably ugly. Thanks, certainly, but if anyone on my team put a map/filter in for this code I'd transfer them to another team or assign them to bedpan duty.</span>
<span class="comment-copy">Is this unreadable block of code really "pythonian"? And especially the idea of zipping <code>conditions</code> and <code>arguments</code>? This is IMHO much worse than the original code, which takes about 10 seconds to parse by my brainparser.</span>
<span class="comment-copy">"Prefer Python", they said. "Perl is unreadable", they said. And then this happened: <code>return next((check for check in checks if check), None)</code>.</span>
<span class="comment-copy">@MartijnPieters you can use <code>\</code> to put each check on its own line.</span>
<span class="comment-copy">@MartijnPieters I never implied my answer is better than yours, I like your answer, too :)</span>
<span class="comment-copy">@Caridorc: I strongly dislike using <code>\</code> to extend the logical line. Use parentheses where possible instead; so <code>return (....)</code> with newlines inserted as needed. Still, that'll be one long logical line.</span>
<span class="comment-copy">I think this is the better solution.  The argument <i>"it will get tedious [..] if there are more than a few options"</i> is moot, because a single function should not be making an exorbitant number of checks anyways.  If that is required, the checks should be split into multiple functions.</span>
<span class="comment-copy">I will write same as you <a href="http://codepad.org/hSlHRGNc" rel="nofollow noreferrer">with indentation</a></span>
<span class="comment-copy">I'd argue against that, but your suggestion is a legitimate one to be voiced. Personally, I find my eyes strained trying to read the OP while, for example, timgeb's solution clicks instantly.</span>
<span class="comment-copy">It's really a matter of opinion. Me personally, I would remove the newlines after <code>:</code>, because I consider <code>if x: return x</code> to be pretty fine, and it makes the function look more compact. But that may be just me.</span>
<span class="comment-copy">It's not just you. Using <code>or</code> as timgeb did is a proper and well-understood idiom. Many languages have this; perhaps when it is called <code>orelse</code> it is even more clear, but even plain old <code>or</code> (or <code>||</code> in other languages) is <i>meant</i> to be understood as the alternative to try if the first one "doesn't work."</span>
<span class="comment-copy">@RayToal: Importing idioms from other languages is a great way to obfuscate code.</span>
<span class="comment-copy">Sometimes yes, for sure! Also it can be a way to open one's mind and lead one to discover new and better patterns and paradigms that no one may have tried before. Style evolves by people borrowing and sharing and trying new things. Works both ways. Anyway, I've never heard the use of <code>or</code> labeled un-Pythonic or in any way obfuscated, but that's a matter of opinion anyway---as it should be.</span>
<span class="comment-copy">everybody please help raising this answer up to 1st place. do your part !</span>
<span class="comment-copy">That's the most elegant.</span>
<span class="comment-copy">I like this one, although True/False should be changed to condition/None to match the question.</span>
<span class="comment-copy">This is my favourite! It copes with different checks and arguments too. Quite possibly overdesigned for this particular example but a really useful tool for future problems!</span>
<span class="comment-copy">Note that <code>return None</code> is not necessary, because functions return <code>None</code> by default. However, there's nothing wrong with returning <code>None</code> explicitly, and I like that you chose to do so.</span>
<span class="comment-copy">I think this approach would be better implemented with a local function definition.</span>
<span class="comment-copy">@timgeb "Explicit is better than implicit," <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a>.</span>
<span class="comment-copy">You could do <code>next(itertools.ifilter(None, (c() for c in conditions)))</code> to get the actual value without casting it to a boolean.</span>
<span class="comment-copy">Does <code>any</code> actually short-circuit?</span>
<span class="comment-copy">@zwol Yes try it with some sample functions or see <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">docs.python.org/3/library/functions.html</a></span>
<span class="comment-copy">This is less readable than chaining the 4 functions with 'or' and only pays off if the number of conditions is large or dynamic.</span>
<span class="comment-copy">@rjh It's perfectly readable; it's just a list literal and a comprehension. I'd prefer it because my eyes glazeth over after about the third <code>x = bar(); if x: return x;</code></span>
<span class="comment-copy"><code>any</code> only works if the checks actually return a boolean value, literally <code>True</code> or <code>False</code>, but the question doesn't specify that. You'd need to use <code>reduce</code> to return the actual value returned by the check. Also, it's easy enough to avoid evaluating all the checks with <code>any</code> by using a generator, e.g. <code>any(c() for c in (check_size, check_color, check_tone, check_flavor))</code>. As in <a href="https://stackoverflow.com/a/36126903/56541">Leonhard's answer</a></span>
<span class="comment-copy">I like your explanation and usage of <code>reduce</code>. Like @DavidZ I believe your solution with <code>any</code> should use a generator and it needs to be pointed out that it is limited to returning <code>True</code> or <code>False</code>.</span>
<span class="comment-copy">@DavidZ actually <code>any</code> works with truthy values: <code>any([1, "abc", False]) == True</code> and <code>any(["", 0]) == False</code></span>
<span class="comment-copy">@blint sorry, I wasn't clear. The goal of the question is to <i>return the result of the check</i> (and not merely to indicate whether the check succeeded or failed). I was pointing out that <code>any</code> only works for <i>that</i> purpose if actual boolean values are returned from the check functions.</span>
<span class="comment-copy">@DavidZ ok now I got your point ;)</span>
<span class="comment-copy">Whats with the little ASCII fish above your terminal?</span>
<span class="comment-copy">@LegoStormtroopr I use the fish shell, so I decorate it with an ascii fish tank to make me happy. :)</span>
<span class="comment-copy">Thanks for the fine fish (and the colors by the way, what editor is that?)</span>
<span class="comment-copy">You can get fish at <a href="https://fishshell.com" rel="nofollow noreferrer">fishshell.com</a>, and the config file for the ascii here <a href="http://pastebin.com/yYVYvVeK" rel="nofollow noreferrer">pastebin.com/yYVYvVeK</a>, also the editor is sublime text.</span>
<span class="comment-copy"><code>x if x else &lt;something&gt;</code> can just be reduced to <code>x or &lt;something&gt;</code></span>
<span class="comment-copy">Does it? You still do a comparison. In your version you will also check all conditions regardless and not return at the first instance of a truthy value, Dependng on how costly those functions are, that may not be desirable.</span>
<span class="comment-copy">@Reti43: <code>Status or c()</code> will skip/short-circui evaluate calls to <code>c()</code> if <code>Status</code> is truthy, so the code in this answer does not appear to call any more functions than the OP's code. <a href="http://stackoverflow.com/questions/2580136/does-python-support-short-circuiting" title="does python support short circuiting">stackoverflow.com/questions/2580136/…</a></span>
<span class="comment-copy">@NeilSlater True. The only downside I see is that the best case is now in O(n) because the listiterator has to yield n times, when it was O(1) before if the first function returns something truthy in O(1).</span>
<span class="comment-copy">Yes good points. I just have to hope that the c() takes a bit more time to evaluate than looping an almost-empty loop. Checking flavour could take a whole evening at least if it's a good one.</span>
<span class="comment-copy">// , Cute! Is it considered "Pythonic" to use exception handling for this sort of thing?</span>
<span class="comment-copy">@NathanBasanese Sure- exceptions are used for control flow all the time. <code>StopIteration</code> is a pretty good example: an exception is raised every single time you exhaust an iterable. The thing you want to avoid is successively raising exceptions over and over again, which would get expensive. But doing it one time is not.</span>
<span class="comment-copy">// , Ah, I take it you're referring to something like <a href="http://programmers.stackexchange.com/questions/112463/why-do-iterators-in-python-raise-an-exception" title="why do iterators in python raise an exception">programmers.stackexchange.com/questions/112463/…</a>. I have voted for that question and for this answer. Python 3 docs for this are here: <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#iterator-types</a>, I think.</span>
<span class="comment-copy">You want to define a general-purpose function and an exception, just to do a few checks in some other function somewhere? I think that's a bit much.</span>
<span class="comment-copy">@BacklightShining I agree. I'd never actually do this myself. The OP asked for ways to avoid the repeated code, but I think what he started with is perfectly fine.</span>
<span class="comment-copy">It's not valid Python, no. Python doesn't let you use the assignment operator like that. However, a new special assignment expression was added very recently, so you can now write <code>if ( x := check_size() ) :</code> for the same effect.</span>
<span class="comment-copy">Thanks, I have updated the answer :)</span>
<span class="comment-copy">Sometimes people go really crazy with their naming when one word will do. Using the OP's code as an example it is unlikely that he would have functions called <code>check_no/some/even/prime/every_third/fancy_conditions</code> but just this one function so why not call it <code>status</code> or if one insists <code>check_status</code>. Using <code>_all_</code> is superfluous, he's not ensuring the universes integrity. Naming should surely use a consistent set of keywords leveraging name spacing whenever possible. Lengthy sentences best serve as docstrings. One seldomly needs more then 8-10 characters to describe something succinctly.</span>
<span class="comment-copy">I'm a fan of long function names, because I want higher-level functions to be self-documenting.  But <code>check_all_conditions</code> is a bad name, because it's <i>not</i> checking all conditions if one is true.  I'd use something like <code>matches_any_condition</code>.</span>
<span class="comment-copy">That is an interesting tact to take. I try to minimize the number of letters I'll make typo's on later :) It seems I've dolloped a heap of opinion into my solution, when I was really trying to provide a helpful hint. Should this be edited out ?</span>
<span class="comment-copy">This seems way too hacky, especially considering the other solutions on this question. What OP is trying to do isn't complicated at all; the solution should be simple enough to understand half-asleep. And I have no idea what's going on here.</span>
<span class="comment-copy">I was aiming for flexibility. Modified answer to include a less 'hacky' variant</span>
