<div class="post-text" itemprop="text">
<p>My sample dict is:   </p>
<pre><code>sample_dict = {
    'company': {
        'employee': {
            'name': [
                {'explore': ["noname"],
                 'valid': ["john","tom"],
                 'boundary': ["aaaaaaaaaa"],
                 'negative': ["$"]}],
            'age': [
                {'explore': [200],
                 'valid': [20,30],
                 'boundary': [1,99],
                 'negative': [-1,100]}],
            'others':{
                'grade':[
                    {'explore': ["star"],
                     'valid': ["A","B"],
                     'boundary': ["C"],
                     'negative': ["AB"]}]}
    }
}}
</code></pre>
<p>Its a "follow-on" question to-&gt; <a href="https://stackoverflow.com/questions/36198540/split-python-dictionary-to-result-in-all-combinations-of-values">Split python dictionary to result in all combinations of values</a><br/>
I would like to get a segregated list of combinations like below<br/>
<br/>Valid combinations:[generate only out of valid list of data]<br/> 
COMPLETE OUTPUT for VALID CATEGORY : <br/></p>
<pre><code>{'company': {'employee': {'age': 20}, 'name': 'john', 'others': {'grade': 'A'}}}
{'company': {'employee': {'age': 20}, 'name': 'john', 'others': {'grade': 'B'}}}
{'company': {'employee': {'age': 20}, 'name': 'tom', 'others': {'grade': 'A'}}} 
{'company': {'employee': {'age': 20}, 'name': 'tom', 'others': {'grade': 'B'}}} 
{'company': {'employee': {'age': 30}, 'name': 'john', 'others': {'grade': 'A'}}}
{'company': {'employee': {'age': 30}, 'name': 'john', 'others': {'grade': 'B'}}}
{'company': {'employee': {'age': 30}, 'name': 'tom', 'others': {'grade': 'A'}}} 
{'company': {'employee': {'age': 30}, 'name': 'tom', 'others': {'grade': 'B'}}}
</code></pre>
<p>Negative combinations : [Here its bit tricky because, negative combinations should be combined with "valid" pool as well with atleast only value being negative]<br/> 
Complete output expected for NEGATIVE category : <br/>
=&gt;[Basically, excluding combinations where all values are valid - ensuring atleast one value in the combination is from negative group]<br/></p>
<pre><code>{'company': {'employee': {'age': 20}, 'name': 'john', 'others': {'grade': 'AB'}}}
{'company': {'employee': {'age': -1}, 'name': 'tom', 'others': {'grade': 'A'}}}
{'company': {'employee': {'age': 100}, 'name': 'john', 'others': {'grade': 'A'}}}
{'company': {'employee': {'age': 30}, 'name': '$', 'others': {'grade': 'A'}}}
{'company': {'employee': {'age': 30}, 'name': '$', 'others': {'grade': 'AB'}}}
{'company': {'employee': {'age': -1}, 'name': '$', 'others': {'grade': 'AB'}}}
{'company': {'employee': {'age': 100}, 'name': '$', 'others': {'grade': 'AB'}}}
</code></pre>
<p>In the above output, in the first line, grade is tested for negative value AB by keeping remaining all valid. So its not necessary to generate the same with age as 30 as the intent is to test only negative set. We can supply the remaining parameters with any valid data.</p>
<p><br/> 
Boundary Combinations is similar to valid -&gt; Combinations for all values within the boundary pool only<br/> 
Explore : Similar to negative - Mix with valid pool and always atleast one explore value in all combinations.<br/>
<br/>
Sample dict  - revised version<br/></p>
<pre><code>sample_dict2 = {
    'company': {
        'employee_list': [
            {'employee': {'age': [{'boundary': [1,99],
                                   'explore': [200],
                                   'negative': [-1,100],
                                   'valid': [20, 30]}],
                          'name': [{'boundary': ['aaaaaaaaaa'],
                                    'explore': ['noname'],
                                    'negative': ['$'],
                                    'valid': ['john','tom']}],
                          'others': {
                              'grade': [
                                  {'boundary': ['C'],
                                   'explore': ['star'],
                                   'negative': ['AB'],
                                   'valid': ['A','B']},
                                  {'boundary': ['C'],
                                   'explore': ['star'],
                                   'negative': ['AB'],
                                   'valid': ['A','B']}]}}},
            {'employee': {'age': [{'boundary': [1, 99],
                                   'explore': [200],
                                   'negative': [],
                                   'valid': [20, 30]}],
                          'name': [{'boundary': [],
                                    'explore': [],
                                    'negative': ['$'],
                                    'valid': ['john', 'tom']}],
                          'others': {
                              'grade': [
                                  {'boundary': ['C'],
                                   'explore': ['star'],
                                   'negative': [],
                                   'valid': ['A', 'B']},
                                  {'boundary': [],
                                   'explore': ['star'],
                                   'negative': ['AB'],
                                   'valid': ['A', 'B']}]}}}
        ]
    }
}
</code></pre>
<p>The sample_dict2 contains list of dicts. Here "employee" the whole hierarchy is a list element and also leaf node "grade" is a list<br/>
Also, except "valid" and "boundary" other data set can be empty - [] and we need to handle them as well.<br/>
VALID COMBINATIONS will be like<br/></p>
<pre><code>{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','A']}},{'employee': {'age': 1}, 'name': 'john', 'others': {'grade': ['A','A']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','A']}},{'employee': {'age': 1}, 'name': 'john', 'others': {'grade': ['A','B']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','A']}},{'employee': {'age': 1}, 'name': 'tom', 'others': {'grade': ['A','A']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','A']}},{'employee': {'age': 1}, 'name': 'tom', 'others': {'grade': ['A','B']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','B']}},{'employee': {'age': 1}, 'name': 'john', 'others': {'grade': ['A','A']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','B']}},{'employee': {'age': 1}, 'name': 'john', 'others': {'grade': ['A','B']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','B']}},{'employee': {'age': 1}, 'name': 'tom', 'others': {'grade': ['A','A']}}]}}
{'company': {'employee_list':[{'employee': {'age': 20}, 'name': 'john', 'others': {'grade': ['A','B']}},{'employee': {'age': 1}, 'name': 'tom', 'others': {'grade': ['A','B']}}]}}
</code></pre>
<p>plus combinations of age=30 and name =tom in employee index 0</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

def generate_combinations(thing, positive="valid", negative=None):

    """ Generate all possible combinations, walking and mimicking structure of "thing" """

    if isinstance(thing, dict):  # if dictionary, distinguish between two types of dictionary
        if positive in thing:
            return thing[positive] if negative is None else [thing[positive][0]] + thing[negative]
        else:
            results = []
            for key, value in thing.items():  # generate all possible key: value combinations
                subresults = []
                for result in generate_combinations(value, positive, negative):
                    subresults.append((key, result))
                results.append(subresults)
            return [dict(result) for result in itertools.product(*results)]

    elif isinstance(thing, list) or isinstance(thing, tuple):  # added tuple just to be safe
        results = []
        for element in thing:  # generate recursive result sets for each element of list
            for result in generate_combinations(element, positive, negative):
                results.append(result)
        return results

    else:  # not a type we know how to handle
        raise TypeError("Unexpected type")


def generate_invalid_combinations(thing):

    """ Generate all possible combinations and weed out the valid ones """

    valid = generate_combinations(thing)

    return [result for result in generate_combinations(thing, negative='negative') if result not in valid]


def generate_boundary_combinations(thing):

    """ Generate all possible boundary combinations """

    return generate_combinations(thing, positive="boundary")


def generate_explore_combinations(thing):

    """ Generate all possible explore combinations and weed out the valid ones """

    valid = generate_combinations(thing)

    return [result for result in generate_combinations(thing, negative='explore') if result not in valid]
</code></pre>
<p>Calling <code>generate_combinations(sample_dict)</code> returns:</p>
<pre><code>[
{'company': {'employee': {'age': 20, 'name': 'john', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 20, 'name': 'john', 'others': {'grade': 'B'}}}},
{'company': {'employee': {'age': 20, 'name': 'tom', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 20, 'name': 'tom', 'others': {'grade': 'B'}}}},
{'company': {'employee': {'age': 30, 'name': 'john', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 30, 'name': 'john', 'others': {'grade': 'B'}}}},
{'company': {'employee': {'age': 30, 'name': 'tom', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 30, 'name': 'tom', 'others': {'grade': 'B'}}}}
]
</code></pre>
<p>Calling <code>generate_invalid_combinations(sample_dict)</code> returns:</p>
<pre><code>[
{'company': {'employee': {'age': 20, 'name': 'john', 'others': {'grade': 'AB'}}}},
{'company': {'employee': {'age': 20, 'name': '$', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 20, 'name': '$', 'others': {'grade': 'AB'}}}},
{'company': {'employee': {'age': -1, 'name': 'john', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': -1, 'name': 'john', 'others': {'grade': 'AB'}}}},
{'company': {'employee': {'age': -1, 'name': '$', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': -1, 'name': '$', 'others': {'grade': 'AB'}}}},
{'company': {'employee': {'age': 100, 'name': 'john', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 100, 'name': 'john', 'others': {'grade': 'AB'}}}},
{'company': {'employee': {'age': 100, 'name': '$', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 100, 'name': '$', 'others': {'grade': 'AB'}}}}
]
</code></pre>
<p>Calling generate_boundary_combinations(sample_dict) returns:</p>
<pre><code>[
{'company': {'employee': {'age': 1, 'name': 'aaaaaaaaaa', 'others': {'grade': 'C'}}}},
{'company': {'employee': {'age': 99, 'name': 'aaaaaaaaaa', 'others': {'grade': 'C'}}}}
]
</code></pre>
<p>Calling generate_explore_combinations(sample_dict) returns:</p>
<pre><code>[
{'company': {'employee': {'age': 20, 'name': 'john', 'others': {'grade': 'star'}}}},
{'company': {'employee': {'age': 20, 'name': 'noname', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 20, 'name': 'noname', 'others': {'grade': 'star'}}}},
{'company': {'employee': {'age': 200, 'name': 'john', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 200, 'name': 'john', 'others': {'grade': 'star'}}}},
{'company': {'employee': {'age': 200, 'name': 'noname', 'others': {'grade': 'A'}}}},
{'company': {'employee': {'age': 200, 'name': 'noname', 'others': {'grade': 'star'}}}}
]
</code></pre>
<p><strong>REVISED SOLUTION</strong> (To match revised problem)</p>
<pre><code>import itertools
import random

def generate_combinations(thing, positive="valid", negative=None):

    """ Generate all possible combinations, walking and mimicking structure of "thing" """

    if isinstance(thing, dict):  # if dictionary, distinguish between two types of dictionary
        if positive in thing:
            if negative is None:
                return thing[positive]  # here it's OK if it's empty
            elif thing[positive]:  # here it's not OK if it's empty
                return [random.choice(thing[positive])] + thing[negative]
            else:
                return []
        else:
            results = []
            for key, value in thing.items():  # generate all possible key: value combinations
                results.append([(key, result) for result in generate_combinations(value, positive, negative)])
            return [dict(result) for result in itertools.product(*results)]

    elif isinstance(thing, (list, tuple)):  # added tuple just to be safe (thanks Padraic!)
        # generate recursive result sets for each element of list
        results = [generate_combinations(element, positive, negative) for element in thing]
        return [list(result) for result in itertools.product(*results)]

    else:  # not a type we know how to handle
        raise TypeError("Unexpected type")


def generate_boundary_combinations(thing):

    """ Generate all possible boundary combinations """

    valid = generate_combinations(thing)

    return [result for result in generate_combinations(thing, negative='boundary') if result not in valid]
</code></pre>
<p><code>generate_invalid_combinations()</code> and <code>generate_explore_combinations()</code> are the same as before.  Subtle differences:</p>
<p>Instead of grabbing the first item out of the valid array in a negative evaluation, it now grabs a random item from the valid array.</p>
<p>Values for items like <code>'age': [30]</code> come back as lists as that's how they were specified:</p>
<pre><code>'age': [{'boundary': [1, 99],
    'explore': [200],
    'negative': [-1, 100],
    'valid': [20, 30]}],
</code></pre>
<p>If you instead want <code>'age': 30</code> like the earlier output examples, then modify the definition accordingly:</p>
<pre><code>'age': {'boundary': [1, 99],
    'explore': [200],
    'negative': [-1, 100],
    'valid': [20, 30]},
</code></pre>
<p>The boundary property is now treated like one of the 'negative' values.</p>
<p>Just for reference, I don't plan to generate all the outputs this time: calling <code>generate_combinations(sample_dict2)</code> returns results like:</p>
<pre><code>[
{'company': {'employee_list': [{'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}, {'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}, {'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [30]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}, {'employee': {'name': ['john'], 'others': {'grade': ['A', 'B']}, 'age': [20]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}, {'employee': {'name': ['john'], 'others': {'grade': ['A', 'B']}, 'age': [30]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['john'], 'others': {'grade': ['A', 'A']}, 'age': [20]}}, {'employee': {'name': ['john'], 'others': {'grade': ['B', 'A']}, 'age': [20]}}]}},
...
{'company': {'employee_list': [{'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}, {'employee': {'name': ['tom'], 'others': {'grade': ['A', 'B']}, 'age': [30]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}, {'employee': {'name': ['tom'], 'others': {'grade': ['B', 'A']}, 'age': [20]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}, {'employee': {'name': ['tom'], 'others': {'grade': ['B', 'A']}, 'age': [30]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}, {'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [20]}}]}},
{'company': {'employee_list': [{'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}, {'employee': {'name': ['tom'], 'others': {'grade': ['B', 'B']}, 'age': [30]}}]}}
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an open-ended hornet's nest of a question.</p>
<ol>
<li><p>Look at the whitepapers for <a href="http://www.agitar.com/" rel="nofollow noreferrer">Agitar</a> other tools by Agitar to see if this what you are thinking about.</p></li>
<li><p>Look at Knuth's work on <a href="https://rads.stackoverflow.com/amzn/click/com/0201038048" rel="nofollow noreferrer">combinationals</a>.  It's a tough read.</p></li>
<li><p>Consider just writing a recursive descent generator that uses 'yield '.</p></li>
</ol>
</div>
<span class="comment-copy">I don't understand your requirements. What does it mean that a negative combination should combine valid pools with atleast only value being negative?  Do you mean that combinations that contain a value found in the negative class should contain <i>exactly two</i> values from the negative class? Or that they must be in even number? Or something else? I suggest you describe more clearly your exact requirements. Moreover it might be a good idea to provide a <i>complete</i> example of output, so that it can be used as a test-case.</span>
<span class="comment-copy">Its basically for negative testing. Meaning, the combintations to be segregated for negative category can take values from the valid list of data as well but not all inputs can be valid, ie atleast one of the value in the particular generated combination should be negative.Also modifying the question to contain the complete output.</span>
<span class="comment-copy">@Bakuriu updated the question with complete output and more clarification. Please let me know if I am still missing something. Thanks</span>
<span class="comment-copy">Here is the code to get every possible combination of a list of inputs. <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a> I would use this as a starting point, and modify it to suit your needs with the negative scenario and your other scenarios.</span>
<span class="comment-copy">I've added a revision onto the end of my solution to handle the revisions to the problem.</span>
<span class="comment-copy">Thanks a lot for answering, will check and get back to you.</span>
<span class="comment-copy">isinstance cna take a tuple of args <code>isinstance(thing, (list, tuple))</code></span>
<span class="comment-copy">@cdlane , This code works awesome!! Can you please make it handle list of dicts and empty arrays. Updated question with revised input dict =&gt;sample_dict2. Thanks for your wonderful effort!</span>
<span class="comment-copy">Thanks @PadraicCunningham, will revise accordingly.  Always learning on SO...</span>
<span class="comment-copy">@Suren, I'm assuming that empty valid and negative arrays should produce no results -- is that correct?</span>
