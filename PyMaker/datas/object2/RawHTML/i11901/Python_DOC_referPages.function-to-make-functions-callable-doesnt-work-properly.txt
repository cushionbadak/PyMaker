<div class="post-text" itemprop="text">
<p>I'm having the problem of a button executing its' command when it's created. To stop this I have got a function, which can stop this behavior</p>
<p>This is the function which makes functions callable without being executed while creating my button. Usually it works fine but with some functions it seems to deny randomly any input! Here is the code:</p>
<pre><code>class Callable(object):
    def __init__(self, func, *args, **kwds):
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self, *args, **kwds):
         return self.func(self.args)

    def __str__(self):
        return self.func.__name
</code></pre>
<p>It seems to be totally randomly which questions are accepted and which aren't. I'm really desperate, because it takes a lot of time to write a kind of synonym of this class, I adapt them with the number of <code>args</code> and <code>kwds</code>, then it works ok. But now I'm coming to a point where I don't know how many args I'm going to pass, so this won't work any more. </p>
<p>Question:</p>
<ul>
<li>Why does this class doesn't accept every function?</li>
<li>How can I change this behaviour?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your class is used to provide additional context to tkinter callbacks so the callback can actually do something useful. You almost have it right except that you need to unpack the original args and kwds when calling the function. Also, don't include any args in <code>__call__</code> because you don't accept any.</p>
<pre><code>class Callable(object):
    def __init__(self, func, *args, **kwds):
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self):
         return self.func(*self.args, **self.kwargs)

    def __str__(self):
        return self.func.__name


def some_callback(a, b, c=None):
    print(a,b,c)

Button(text="Do not press", 
    command=Callable(some_callback, 1, 2, 3))
</code></pre>
<p>This can also be done without a class, using lambdas instead</p>
<pre><code>def some_callback(a, b, c=None):
    print(a,b,c)

Button(text="Do not press", 
    command=lambda: some_callback(1, 2, 3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe that's what you're looking for:</p>
<pre><code>class Callable(object):
    def __init__(self, func, *args, **kwds):
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self, *args, **kwds):
         return self.func(*self.args, *args, **self.kwds, **kwds)

    def __str__(self):
        return self.func.__name
</code></pre>
<p>You need to unpack it with the <code>*</code> operator, and <code>**</code> for keyword arguments. That way you pass your variables and the function's call variables.</p>
<p><strong>UPDATE:</strong></p>
<p>For python versions older than 3.5, this will work:</p>
<pre><code>class Callable(object):
    def __init__(self, func, *args, **kwds):
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self, *args, **kwds):
        args = self.args + args
        kwargs = kwds.copy()
        kwargs.update(self.kwds)
        return self.func(*args, **kwargs)

    def __str__(self):
        return self.func.__name
</code></pre>
<p>Using this solution, you will first give the variables acquired by the <code>__init__</code> then the variables passed to the <code>__call__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please consider using the following class. It allows you to specify positional arguments and keyword arguments at the time of either instance creation or instance invocation (creating a new instance or calling it). Since it is ambiguous what would be meant if either types of arguments were specified at both times, the class refuses to guess what order or priorities were intended and raises a <code>RuntimeError</code> to prevent undefined behavior. Also, the <code>__str__</code> method should still work if your function or other callable object does not have a <code>__name__</code> attribute.</p>
<pre><code>class Callable:

    def __init__(self, function, *args, **kwargs):
        self.__function, self.__args, self.__kwargs = function, args, kwargs

    def __call__(self, *args, **kwargs):
        if (args or kwargs) and (self.__args or self.__kwargs):
            raise RuntimeError('multiple args and kwargs are not supported')
        if args or kwargs:
            return self.__function(*args, **kwargs)
        return self.__function(*self.__args, **self.__kwargs)

    def __str__(self):
        return getattr(self.__function, '__name__', 'function')
</code></pre>
<p>You might also want to take a look at <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> for a well-defined object with very similar behavior. You may be able to avoid defining your own <code>Callable</code> class and use the <code>functools</code> module instead. That way, there is less code that you have to manage in you project.</p>
</div>
<span class="comment-copy">Provide an example of a function that works, and a function that doesn't.</span>
<span class="comment-copy">@Kevin: This will be hard, I'm using a module called swampy, it's a modulation for tkinter. It changes all the syntax and as I said it is random which functions work and which don't. I'm quite sure I would have seen a pattern</span>
<span class="comment-copy">Can you explain exactly what this is supposed to do?  e.g. you seem to be passing <code>*args</code> to both <code>__init__</code> and <code>__call__</code>.  If I did:  <code>Callable(func, 1, 2, 3)(4, 5)</code> -- What is the equivalent <code>func</code> call that you're expecting?  e.g. is this the same as <code>func(1, 2, 3)</code>, <code>func((1, 2, 3))</code>, <code>func(1, 2, 3, 4 ,5)</code>, <code>func(4, 5)</code>, ...</span>
<span class="comment-copy">Incidentally, if you're just trying to construct callables that have arguments "preloaded", consider using <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow noreferrer">functools.partial</a> or lambda expressions.</span>
<span class="comment-copy">In fact I had the problem of my buttons to execute the commands stored in the function, which were executed directly, when I created the button. With this function,that problem was solved. Can this 'directly executed commands' be solved in an other way?!?!?!?</span>
<span class="comment-copy">This lambda thing worked fine, thank you so much!!</span>
<span class="comment-copy">Note, this syntax with mutiple splat operators isn't available until <a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">python3.5</a> IIRC.  For earlier versions, you'll need to <code>*(self.args + args)</code> and do the analogous thing for the keyword argument unpacking... <code>kwds.update(self.kwds); func(*(self.args + args), **kwds)</code></span>
<span class="comment-copy">Sorry I'm python 3.4. Can you pack it into your answer please? I'm not sure what to do now!</span>
<span class="comment-copy">This answer places an odd requirement on positional arguments. Consider <code>fctn(a,b,c,d)</code> - if any args are given to the class initializer they will precede any args passed to <code>__call__</code>. If OP is trying to implement a partial class, then maybe that's Okay but it should be very explicitly stated.</span>
<span class="comment-copy">@tdelaney Thanks, stated it in bottom line.</span>
<span class="comment-copy">this thing worked too, I tried it out. Nevertheless, I prefer <code>lambda</code>, it's shorter</span>
