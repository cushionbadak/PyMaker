<div class="post-text" itemprop="text">
<p>I've created the following function to pull data out of a file. It works ok, but gets very slow for larger files. </p>
<pre><code>def get_data(file, indexes, data_start, sieve_first = is_float):
    file_list = list(file)
    for i in indexes:
        d_line = i+data_start
        for line in file_list[d_line:]:
            if sieve_first(line.strip().split(',')[0]):
                yield file_list[d_line].strip()
                d_line += 1
            else:
                break

def is_float(f):
    try:
        float(str(f))
    except:
        return False
    else:
        return True

with open('my_data') as f:
    data = get_data(f, index_list, 3)
</code></pre>
<p>The file might look like this (line numbers added for clarity):</p>
<pre><code>line 1234567: # &lt;-- INDEX
line 1234568: # +1
line 1234569: # +2
line 1234570:      8, 17.0, 23, 6487.6
line 1234571:      8, 17.0, 23, 6487.6
line 1234572:      8, 17.0, 23, 6487.6
line 1234572:
line 1234572:
line 1234572:
</code></pre>
<p>With the above example, lines 1234570 through 1234572 will be yielded.</p>
<p>Since my files are large, there are a couple things I don't like about my function. </p>
<ol>
<li>First is that it reads the entire file into memory; I do this so I can use line indexing in order to parse the data out. </li>
<li>Second is that the same lines in the file are iterated over many times- this gets very expensive for a large file. </li>
</ol>
<p>I have fiddled around trying to use iterators to get through the file a single time, but haven't been able to crack it. Any suggestions? </p>
</div>
<div class="post-text" itemprop="text">
<p>If you only want a small portion of the file, I would use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow">itertools.islice</a>. This function will not store any data but the data you want in memory.</p>
<p>Here's an example:</p>
<pre><code>from itertools import islice

def yield_specific_lines_from_file(filename, start, stop):
    with open(filename, 'rb') as ifile:
        for line in islice(ifile, start, stop):
            yield line

lines = list(yield_specific_lines_from_file('test.txt', 10, 20))
</code></pre>
<p>If you use Python 3.3 or newer, you can also simplify this by using the <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator" rel="nofollow"><code>yield from</code></a> statement:</p>
<pre><code>from itertools import islice

def yield_specific_lines_from_file(filename, start, stop):
    with open(filename, 'rb') as ifile:
        yield from islice(ifile, start, stop)

lines = list(yield_specific_lines_from_file('test.txt', 10, 20))
</code></pre>
<p>This will not cache the lines you've already read from the file though. If you want to to this, I suggest that you store all read lines in a dictionary with the line number as key, and only pull the data from the file if needed. </p>
</div>
<div class="post-text" itemprop="text">
<p>Out of left field a bit.  But if you have control over your files you could move the data to an sqlite3 db.  </p>
<p>Also take a look at mmap and linecache.  I imagine these last two are just wrappers around random access files.  i.e. you could roll your own by scanning the files once, then building an index-&gt;offset lookup table and using seek.  </p>
<p>Some of these approaches assume you have some control of the files you're reading? </p>
<p>Also depends on whether you read a lot and write infrequently (if so building an index is not such a bad idea).</p>
</div>
<span class="comment-copy">Just do <code>for line in file</code> instead of <code>list(file)</code></span>
<span class="comment-copy">@cricket_007 thanks, but if <code>file</code> doesn't support indexing, the rest of the function would not work.</span>
<span class="comment-copy">If the file didn't support indexing, then how are you doing <code>file[d_line:]</code>?</span>
<span class="comment-copy">@cricket_007 the line <code>file = list(file)</code> turns it into a <code>list</code>.</span>
<span class="comment-copy">@RickTeachey I know what what <code>list()</code> returns :)</span>
<span class="comment-copy">looks like <code>islice</code> is what i needed. still have to iterate through multiple times, but it's a lot less expensive this way. thanks.</span>
<span class="comment-copy">reading a lot and writing almost never, but perhaps now and then. great ideas - thanks!</span>
