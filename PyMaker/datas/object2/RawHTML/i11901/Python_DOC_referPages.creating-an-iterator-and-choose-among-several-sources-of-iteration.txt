<div class="post-text" itemprop="text">
<p>I want to create an Iterator that would have several "sources" of objects to iterate. I would like to be able to give its <code>__next__()</code> method an optional keyword argument that would offer the possibility to choose the source (no keyword argument would mean, just choose a source randomly).</p>
<p>Using <code>__next__()</code> causes problems (see below), so as a workaround I've written this unsatisfying code:</p>
<pre><code>#!/usr/bin/env python3

import random

class infinite_iterator(object):

    def __init__(self, sources):
        self.collector = []
        for s in sources:
            random.shuffle(s)
            self.collector.append([])
        self.sources = sources

    def __iter__(self):
        return self

    # Workaround: calling it next instead of __next__
    # (not the python3 way...)
    def next(self, **kwargs):
        sce_nb = random.choice([ n for n in range(len(self.sources)) ])
        if 'choice' in kwargs:
            sce_nb = kwargs['choice']
        self.collector[sce_nb].append(self.sources[sce_nb][0])
        output = self.sources[sce_nb].pop(0)
        # Repopulate any empty 'source'
        if not self.sources[sce_nb]:
            (self.sources[sce_nb], self.collector[sce_nb]) = \
                         (self.collector[sce_nb], self.sources[sce_nb])
            random.shuffle(self.sources[sce_nb])
        return output


S = infinite_iterator([["Adam", "Paul", "Oliver", "Aaron", "Joshua", "Jack"],
                       ["Mary", "Sophia", "Emily", "Isobel", "Grace", "Alice", "Lucy"]])

print("Any name: " + S.next())
print("Any girl's name: " + S.next(choice=1))
print("Any boy's name: " + S.next(choice=0))
</code></pre>
<p>Problem is, if I want to write <code>def __next__(self, **kwargs):</code> to make infinite_iterator a real Iterator, then of course I want to write:</p>
<pre><code>print("Any name: " + next(S))
print("Any girl's name: " + next(S, choice=1))
print("Any boy's name: " + next(S, choice=0))
</code></pre>
<p>but get an error (2d line):</p>
<pre><code>TypeError: next() takes no keyword arguments
</code></pre>
<p>I thought this call <code>next(S, choice=1)</code> would use the <code>__next__()</code> function defined in the object. Because of this error, I think that on one hand it actually does not. This could be expectable because it's not exactly a redefinition, as infinite_iterator does not inherit from an "Iterator object" (as far as I understand, there's no such object). But on another hand, if I call only <code>next(S)</code> it works, and in this case, <em>my</em> <code>__next__()</code> method is really called (it chooses randomly a list to iterate over).</p>
<p>Finally, is there a solution to realize such an Iterator?</p>
</div>
<div class="post-text" itemprop="text">
<p>Write a <a href="https://docs.python.org/3/reference/expressions.html#generator-iterator-methods" rel="nofollow">generator</a> (technically a coroutine) and use <code>send</code> to pass in your choices:</p>
<pre><code>import random
def selector(sources):
    option = None
    while True:
        if option is None:
            option = yield random.choice(random.choice(sources))
        else:
            option = yield random.choice(sources[option])

s = selector([["Adam", "Paul", "Oliver", "Aaron", "Joshua", "Jack"],
              ["Mary", "Sophia", "Emily", "Isobel", "Grace", "Alice", "Lucy"]])

print("Any name: " + next(s))
print("Any girl's name: " + s.send(1))
print("Any boy's name: " + s.send(0))
</code></pre>
<p>The way this works is every time you call <code>send</code>, that value gets passed in to the <code>option</code> variable which is used to make the selection for the next iteration of the while loop. </p>
<p>You'll have to start it up by calling <code>next</code> at least once so it hits the first <code>yield</code> statement, but after that it'll work both ways (use <code>next</code> or <code>send(None)</code> for a full random choice, or <code>send(option)</code> for a specific source.</p>
</div>
<span class="comment-copy">OK, so it's impossible to use <code>__next__</code> calling it this way: <code>next(s, choice=1)</code>?</span>
<span class="comment-copy">That's not how the iterator protocol (or the <code>next</code> builtin) is defined, and you can't change that definition, so no. But <code>send</code> works, I'm not sure why you're stuck on using <code>next</code> in particular.</span>
