<div class="post-text" itemprop="text">
<p>I have a sorted array with some repeated values.  How can this array be turned into an array of arrays with the subarrays grouped by value (see below)? In actuality, my_first_array has ~8 million entries, so the solution would preferably be as time efficient as possible.</p>
<pre><code>my_first_array = [1,1,1,3,5,5,9,9,9,9,9,10,23,23]

wanted_array = [ [1,1,1], [3], [5,5], [9,9,9,9,9], [10], [23,23] ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code> makes this trivial</a>:</p>
<pre><code>import itertools

wanted_array = [list(grp) for _, grp in itertools.groupby(my_first_array)]
</code></pre>
<p>With no <code>key</code> function, it just <code>yield</code>s groups consisting of runs of identical values, so you <code>list</code>-ify each one in a list comprehension; easy-peasy. You can think of it as basically a within-Python API for doing the work of the GNU toolkit program, <code>uniq</code>, and related operations.</p>
<p>In CPython (the reference interpreter), <code>groupby</code> is implemented in C, and it operates lazily and linearly; the data must already appear in runs matching the <code>key</code> function, so sorting might make it too expensive, but for already sorted data like you have, there is nothing that will be more efficient.</p>
<p>Note: If the inputs might be value identical, but different objects, it may make sense for memory reasons to change <code>list(grp) for _, grp</code> to <code>[k] * len(list(grp)) for k, grp</code>. The former would retain the original (possibly value but not identity duplicate) objects in the final result, the latter would replicate the first object from each group instead, reducing the final cost per group to the cost of <code>N</code> references to a single object, instead of <code>N</code> references to between <code>1</code> and <code>N</code> objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am assuming that the input is a NumPy array and you are looking for a list of arrays as output. Now, you can split the input array at indices where those shifts (groups of repeats have boundaries) with <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.split.html" rel="nofollow"><code>np.split</code></a>. To find such indices, there are two ways - Using <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.unique.html" rel="nofollow"><code>np.unique</code></a> with its optional argument <code>return_index</code> set as <code>True</code>, and another with a combination of <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.where.html" rel="nofollow"><code>np.where</code></a> and <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.diff.html" rel="nofollow"><code>np.diff</code></a>. Thus, we would have two approaches as listed next.</p>
<p>With <code>np.unique</code> -</p>
<pre><code>import numpy as np

_,idx = np.unique(my_first_array, return_index=True)
out = np.split(my_first_array, idx)[1:]
</code></pre>
<p>With <code>np.where</code> and <code>np.diff</code> -</p>
<pre><code>idx = np.where(np.diff(my_first_array)!=0)[0] + 1
out = np.split(my_first_array, idx)
</code></pre>
<p>Sample run -</p>
<pre><code>In [28]: my_first_array
Out[28]: array([ 1,  1,  1,  3,  5,  5,  9,  9,  9,  9,  9, 10, 23, 23])

In [29]: _,idx = np.unique(my_first_array, return_index=True)
    ...: out = np.split(my_first_array, idx)[1:]
    ...: 

In [30]: out
Out[30]: 
[array([1, 1, 1]),
 array([3]),
 array([5, 5]),
 array([9, 9, 9, 9, 9]),
 array([10]),
 array([23, 23])]

In [31]: idx = np.where(np.diff(my_first_array)!=0)[0] + 1
    ...: out = np.split(my_first_array, idx)
    ...: 

In [32]: out
Out[32]: 
[array([1, 1, 1]),
 array([3]),
 array([5, 5]),
 array([9, 9, 9, 9, 9]),
 array([10]),
 array([23, 23])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution, although it might not be very efficient:</p>
<pre><code>my_first_array = [1,1,1,3,5,5,9,9,9,9,9,10,23,23]
wanted_array = [ [1,1,1], [3], [5,5], [9,9,9,9,9], [10], [23,23] ]

new_array = [ [my_first_array[0]] ]
count = 0
for i in range(1,len(my_first_array)):
    a = my_first_array[i]
    if a == my_first_array[i - 1]:
        new_array[count].append(a)
    else:
        count += 1
        new_array.append([])
        new_array[count].append(a)

new_array == wanted_array  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is O(n):</p>
<pre><code>a = [1,1,1,3,5,5,9,9,9,9,9,10,23,23,24]

res = []
s = 0
e = 0
length = len(a)
while s &lt; length:
    b = []
    while e &lt; length and a[s] == a[e]:
        b.append(a[s])
        e += 1
    res.append(b)
    s = e
print res
</code></pre>
</div>
<span class="comment-copy">If the array has ~8M entries, wouldn't it be smarter to make the output like <code>[(first object, 4), (second object, 32), (third object, 3), ...]</code>, the second entry in the tuples being the count? Could same some memory.</span>
