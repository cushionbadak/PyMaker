<div class="post-text" itemprop="text">
<p>I have an application where people are asked to enter their user name and password. I want them to be able to just press enter to send the name and password. To do this, I've made this:</p>
<pre><code>import curses, curses.textpad
def setup_input():
    inp = curses.newwin(8,55, 0,0)
    inp.addstr(1,1, "Please enter your username:")
    sub = inp.subwin(2,1)
    sub.border()
    sub2 = sub.subwin(3,2)
    global tb
    tb = curses.textpad.Textbox(sub2)
    inp.refresh()
    tb.edit(enter_is_terminate)

def enter_is_terminate(x):
    if x == 10:
        tb.do_command(7)
    tb.do_command(x)

setup_input()
</code></pre>
<p>Unfortunately this doesn't work as expected. The standard character for termination (Triggered by CTRL+G) is 7 and the enter character is 10, but with the above code, all other keys are still handled correctly but when I press enter, it just gives me a newline, instead of terminating the edit mode of the Textbox. What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.4/library/curses.html#module-curses.textpad" rel="nofollow">Found this on the documentation:</a></p>
<blockquote>
<p>If validator is supplied, it must be a function. It will be called for each keystroke entered with the keystroke as a parameter; command dispatch is done on the result.</p>
</blockquote>
<p>So instead of running <code>tb.do_command</code> yourself, just return the key you want to 'input'.</p>
<pre><code>def enter_is_terminate(x):
    if x == 10:
        return 7
</code></pre>
<p>Also, now you don't need to define <code>tb</code> as a global variable, which is usually a good thing. :)</p>
<hr/>
<p>If you'd be happy with just a one line input, you wouldn't have to handle the enter key yourself.</p>
<p>On the <a href="https://docs.python.org/3.4/library/curses.html#module-curses.textpad" rel="nofollow">documentation</a> it sais this:</p>
<blockquote>
<p>Control-J -- Terminate if the window is 1 line, otherwise insert newline.</p>
</blockquote>
<p>So if you <a href="https://docs.python.org/3/library/curses.html#curses.window.subwin" rel="nofollow">define the textbox's sub window with line count of 1</a> you don't need to handle the enter key yourself.</p>
<pre><code>def setup_input():
    inp = curses.newwin(8,55, 0,0)
    inp.addstr(1,1, "Please enter your username:")
    sub = inp.subwin(3, 41, 2, 1)
    sub.border()
    sub2 = sub.subwin(1, 40, 3, 2)
    tb = curses.textpad.Textbox(sub2)
    inp.refresh()
    tb.edit()
</code></pre>
<p>I also gave the <code>sub</code> a specific line and col count so the border is nicely around the textbox.</p>
</div>
<div class="post-text" itemprop="text">
<p>It helps to read the source code.  Here is a working validator:</p>
<pre><code>def enter_is_terminate(x):
    if x == 10:
        x = 7
    return x
</code></pre>
<p>The validator has to return a character, which the <code>edit</code> function checks with <code>do_command</code>:</p>
<pre><code>def edit(self, validate=None):
    "Edit in the widget window and collect the results."
    while 1:            
        ch = self.win.getch()
        if validate:  
            ch = validate(ch)
        if not ch:      
            continue
        if not self.do_command(ch):
            break             
        self.win.refresh() 
    return self.gather()
</code></pre>
<p>and <code>do_command</code> only returns 0 for the two cases (a) ASCII BEL and (b) newline on a one-line window:</p>
<pre><code>    elif ch == curses.ascii.BEL:                           # ^g
        return 0
    elif ch == curses.ascii.NL:                            # ^j
        if self.maxy == 0:
            return 0
        elif y &lt; self.maxy:
            self.win.move(y+1, 0)
</code></pre>
</div>
