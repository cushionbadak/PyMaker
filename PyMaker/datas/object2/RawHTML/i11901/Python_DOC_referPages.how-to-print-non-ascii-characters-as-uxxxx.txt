<div class="post-text" itemprop="text">
<pre><code># what I currently have

print('你好')

# 你好
</code></pre>
<hr/>
<pre><code># this is what I want

print('你好')

# \uXXXX \uXXXX
</code></pre>
<p>How do I do this? I want to print all non-ascii characters in strings as unicode escape literals</p>
</div>
<div class="post-text" itemprop="text">
<p>You can convert strings to a debug representation with non-ASCII, non-printable characters converted to escape sequences using the <a href="https://docs.python.org/3/library/functions.html#ascii" rel="noreferrer"><code>ascii()</code> function</a>:</p>
<blockquote>
<p>As <code>repr()</code>, return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by <code>repr()</code> using <code>\x</code>, <code>\u</code> or <code>\U</code> escapes.</p>
</blockquote>
<p>For Unicode codepoints in the range U+0100-U+FFFF this uses <code>\uhhhh</code> escapes; for the Latin-1 range (U+007F-U+00FF) <code>\xhh</code> escapes are used instead. Note that the output qualifies as valid Python syntax to re-create the string, so quotes are included:</p>
<pre><code>&gt;&gt;&gt; print('你好')
你好
&gt;&gt;&gt; print(ascii('你好'))
'\u4f60\u597d'
&gt;&gt;&gt; print(ascii('ASCII is not changed, Latin-1 (åéîøü) is, as are all higher codepoints, such as 你好'))
'ASCII is not changed, Latin-1 (\xe5\xe9\xee\xf8\xfc) is, as are all higher codepoints, such as \u4f60\u597d'
</code></pre>
<p>If you <em>must</em> have <code>\uhhhh</code> for everything, you'll have to do your own conversion:</p>
<pre><code>import re

def escape_unicode(t, _p=re.compile(r'[\u0080-\U0010ffff]')):
    def escape(match):
        char = ord(match.group())
        return '\\u{:04x}'.format(char) if char &lt; 0x10000 else '\\U{:08x}'.format(char)
    return _p.sub(escape, t)
</code></pre>
<p>The above function does <em>not</em> add quotes like the <code>ascii()</code> function does:</p>
<pre><code>&gt;&gt;&gt; print(escape_unicode('你好'))
\u4f60\u597d
&gt;&gt;&gt; print(escape_unicode('ASCII is not changed, Latin-1 (åéîøü) is, as are all higher codepoints, such as 你好'))
ASCII is not changed, Latin-1 (\u00e5\u00e9\u00ee\u00f8\u00fc) is, as are all higher codepoints, such as \u4f60\u597d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do note that what without replacing <code>\</code> with <code>\\</code>, what you want is not reversible; eg. you can't know whether the actual string was <code>'好'</code> (one character) or <code>'\\u597d'</code> (6 characters in ascii range), since both would produce <code>\u597d</code> as output. Martijn's suggestion does the backslash-replacement, and is reversible.</p>
<p>You could just make the conversion yourself:</p>
<pre><code>def unicodeescape(s):
    return ''.join(c if ord(c) &lt; 128 else '\\u%04x' % ord(c) for c in s)

print(unicodeescape('你好'))
</code></pre>
<p>(Martijn's note about characters outside the BMP still applies)</p>
<p>If you want to do this to everything your program outputs, and trying to remember to pass everything through a conversion function doesn't seem like your idea of a good time, you could also try something like this:</p>
<pre><code>import codecs, sys

def unicodeescapereplace(error):
    if isinstance(error, UnicodeEncodeError):
        s = error.object[error.start:error.end]
        repl = ''.join('\\u%04x' % ord(c) for c in s)
        return (repl, error.end)
    raise error

codecs.register_error('unicodeescapereplace', unicodeescapereplace)
sys.stdout = codecs.getwriter('ascii')(sys.stdout.buffer, 'unicodeescapereplace')

print('你好')
</code></pre>
<p>This creates a custom encoding error handler, which handles UnicodeEncodeErrors by replacing the offending character with a unicode escape. You can use it like <code>'你好'.encode('ascii', 'unicodeescapereplace')</code>, or like the example above, replace the stdout with one that uses it automatically for all encoding.</p>
</div>
<div class="post-text" itemprop="text">
<p>The normal representation is obtained by using the <code>ascii</code> builtin as explain by Martijn Pieters.</p>
<p>If you really want to constently print \u escapes, you can do it <em>by hand</em>:</p>
<pre><code>t = 'ASCII is not changed, Latin-1 (åéîøü) is, as are all higher codepoints, such as 你好'
disp = u = "'" + ''.join([c if (ord(c) &lt; 128) else r'\u%04x' % (ord(c),) for c in t ]) + "'"
print(disp)
print(eval(disp))
</code></pre>
<p>gives as expected:</p>
<pre class="lang-none prettyprint-override"><code>'ASCII is not changed, Latin-1 (\u00e5\u00e9\u00ee\u00f8\u00fc) is, as are all higher codepoints, such as \u4f60\u597d'
ASCII is not changed, Latin-1 (åéîøü) is, as are all higher codepoints, such as 你好
</code></pre>
<p>NB: I do know that eval is evil but in that particular use case I know that the inner string contains no <code>'</code> and that it is enclosed in <code>'</code> so it can not be more than a mere conversion of encoded characters - but I will never do that on a external string without at least testing <code>t.contains("'")</code>...</p>
<p>NB2: this method cannot process correctly characters whose code is greater than 0xffff - it would need another <em>if else</em>...</p>
</div>
<span class="comment-copy">@jDo What in god's name are you even saying?</span>
<span class="comment-copy">Strings in Python 3 should use utf-8 by default. The proper fix is to find out why your string is in ASCII rather than utf-8 and fixing that.</span>
<span class="comment-copy">@Alan yeah, i don't know. I'll delete that useless comment :D But couldn't you still use the exception handling in that way and simply replace the dumb print statement with something else? (provided that you don't want to fix the encoding error as Carpetsmoker suggests )</span>
<span class="comment-copy">@Carpetsmoker Strings in Python 3 are not UTF-8 by default, they are Unicode by default and print encodes them to <code>sys.stdout.encoding</code>, which may or may not be UTF-8.</span>
<span class="comment-copy">is it possible to force everything to <code>\uXXXX</code> for standardization reasons?</span>
<span class="comment-copy">@Alan: not with the <code>ascii()</code> function. You'd have to do this manually then. Note also that for anything outside the BMP (codepoints over U+FFFF) you'd have to use the <code>\Uhhhhhhhh</code> notation in Python. What problem are you trying to solve?</span>
