<div class="post-text" itemprop="text">
<p>I am trying to generate all possible ways to interleave any two arbitrary strings in Python.</p>
<p>For example: If the two strings are <code>'ab'</code> and <code>'cd'</code>, the output I wish to get is:</p>
<pre><code>['abcd', 'acbd', 'acdb', 'cabd', 'cadb', 'cdab']
</code></pre>
<p>See <code>a</code> is always before <code>b</code> (and <code>c</code> before <code>d</code>). I am struggling to find a solution to this. I have tried itertools as shown below:</p>
<pre><code>import itertools

def shuffle(s,t):
    string = s+t
    for i in itertools.permutations(string):
        print(''.join(i))

shuffle('ab','cd')
</code></pre>
<p>But as expected, this returns all possible permutations disregarding order of <code>a</code> and <code>b</code> (and <code>c</code> and <code>d</code>).</p>
</div>
<div class="post-text" itemprop="text">
<h2>The Idea</h2>
<p>Let the two strings you want to interleave be <code>s</code> and <code>t</code>. We will use recursion to generate all the possible ways to interleave these two strings. </p>
<p>If at any point of time we have interleaved the first <code>i</code> characters of <code>s</code> and the first <code>j</code> characters of <code>t</code> to create some string <code>res</code>, then we have two ways to interleave them for the next step-</p>
<ol>
<li>Append the <code>i+1</code> th character of <code>s</code> to <code>res</code></li>
<li>Append the <code>j+1</code> th character of <code>t</code> to <code>res</code></li>
</ol>
<p>We continue this recursion till all characters of both the strings have been used and then we store this result in a list of strings <code>lis</code> as in the code below.</p>
<h2>The Code</h2>
<pre><code>def interleave(s, t, res, i, j, lis):
    if i == len(s) and j == len(t):
        lis.append(res)
        return
    if i &lt; len(s):
        interleave(s, t, res + s[i], i + 1, j, lis)
    if j &lt; len(t):
        interleave(s, t, res + t[j], i, j + 1, lis)

l = []
s = "ab"
t = "cd"
interleave(s, t, "", 0, 0, l)
print l
</code></pre>
<p><strong>Output</strong> </p>
<pre><code>['abcd', 'acbd', 'acdb', 'cabd', 'cadb', 'cdab']
</code></pre>
<p>This implementation is as efficient as we can get (at least asymptotically) since we never generate the same string twice.</p>
</div>
<div class="post-text" itemprop="text">
<p>Several other solutions have already been posted, but most of them generate the full list of interleaved strings (or something equivalent to it) in memory, making their memory usage grow exponentially as a function of the input length.  Surely there must be a better way.</p>
<p>Enumerating all ways to interleave two sequences, of length <em>a</em> and <em>b</em> respectively, is basically the same as enumerating all <em>a</em>+<em>b</em> bit integers with exably <em>b</em> bits set.  Each such integer corresponds to a distinct way to interleave the sequences, obtained by replacing every 0 bit with an element of the first sequence, and every 1 bit with an element of the second sequence.</p>
<p>Conveniently, there's a clever and efficient way to <a href="http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/" rel="noreferrer">calculate the next integer with the same number of bits set</a>, which we can use to generate all such integers.  So let's do that first:</p>
<pre class="lang-python prettyprint-override"><code>def bit_patterns(m, n):
    """Generate all m-bit numbers with exactly n bits set, in ascending order.
    See http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/
    """
    patt = (1 &lt;&lt; int(n)) - 1
    if patt == 0: yield 0; return  # loop below assumes patt has at least one bit set!
    while (patt &gt;&gt; m) == 0:
        yield patt
        lowb = patt &amp; -patt  # extract the lowest bit of the pattern
        incr = patt + lowb   # increment the lowest bit
        diff = patt ^ incr   # extract the bits flipped by the increment
        patt = incr + ((diff // lowb) &gt;&gt; 2)  # restore bit count after increment
</code></pre>
<p>Now we can use this generator to generate all ways to interleave any two sequences:</p>
<pre class="lang-python prettyprint-override"><code>def interleave(a, b):
    """Generate all possible ways to interleave two sequences."""
    m = len(a) + len(b)
    n = len(a)
    for pattern in bit_patterns(m, n):
        seq = []
        i = j = 0
        for k in range(m):
            bit = pattern &amp; 1
            pattern &gt;&gt;= 1
            seq.append(a[i] if bit else b[j])
            i += bit
            j += 1-bit
        yield seq
</code></pre>
<p>Note that, in order to try to be as generic as possible, this code takes arbitrary sequence types and returns lists.  Strings are sequences in Python, so you can pass them in just fine; to convert the generated lists back into strings, you can concatenate their elements e.g. with <code>"".join()</code>, like this:</p>
<pre class="lang-python prettyprint-override"><code>foo = "ABCD"
bar = "1234"
for seq in interleave(foo, bar):
    print("".join(seq))
</code></pre>
<p>There we go: a fully non-recursive efficient generator-based solution that uses very little memory even for long inputs, and only generates each output once (thus requiring no inefficient duplicate elimination step).  And it even works in both Python 2 and 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Highly inefficient but working:</p>
<pre><code>def shuffle(s,t):
    if s=="":
        return [t]
    elif t=="":
        return [s]
    else:
        leftShuffle=[s[0]+val for val in shuffle(s[1:],t)]
        rightShuffle=[t[0]+val for val in shuffle(s,t[1:])]
        leftShuffle.extend(rightShuffle)
        return leftShuffle

print(shuffle("ab","cd"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You only need to compare the index of <code>a</code> to <code>b</code> and <code>c</code> to <code>d</code> then filter out those elements where index of <code>a</code> is greater than index of <code>b</code> and index of <code>c</code> is greater than index of <code>d</code>.</p>
<pre><code>def interleave(s, t):
    mystring = s + t
    return [el for el in [''.join(item) for item in permutations(mystring) if  item.index('a') &lt; item.index('b') and item.index('c') &lt; item.index('d')]]
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import permutations
&gt;&gt;&gt; s = 'ab'
&gt;&gt;&gt; t = 'cd'
&gt;&gt;&gt; [el for  el in [''.join(item) for item in permutations(s+t) if item.index('a') &lt; item.index('b') and item.index('c') &lt; item.index('d')]]
['abcd', 'acbd', 'acdb', 'cabd', 'cadb', 'cdab']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for sports</p>
<h2>a solution without explicit conditionals or predicates</h2>
<p>(i.e., without any <code>if</code> keywords):</p>
<pre><code>from itertools import chain, repeat, permutations
from copy import deepcopy


def shuffle(*strings):
    # Treat the strings as pools from which to draw elements in order.
    # Convert the strings to lists, so that drawn items can be removed:
    pools = (list(string) for string in strings)

    # From each pool, we have to draw as many times as it has items:
    pools_to_draw_from = chain.from_iterable(
        repeat(pool, len(pool)) for pool in pools
    )

    # Because itertools.permutations treats elements as unique based on their
    # position, not on their value and because pools_to_draw_from has repeated
    # repeated items, we would get repeated permutations, if we would not
    # filter them out with `unique`.
    possible_drawing_orders = unique(permutations(pools_to_draw_from))

    # For each drawing order, we want to draw (and thus remove) items from our
    # pools. Subsequent draws within the same drawing order should get the
    # respective next item in the pool, i.e., see the modified pool. But we don't
    # want the pools to be exhausted after processing the first drawing ordering.
    #
    # Deepcopy preserves internal repetition and thus does exactly what we need.
    possible_drawing_orders = (deepcopy(pdo) for pdo in possible_drawing_orders)

    # Draw from the pools for each possible order,
    # build strings and return them in a list:
    return [''.join(_draw(p)) for p in possible_drawing_orders]


def _draw(drawing_order):
    return (pool_to_draw_from.pop(0) for pool_to_draw_from in drawing_order)
</code></pre>
<p>We need a helper function for this:</p>
<pre><code>from operator import itemgetter
from itertools import groupby

def unique(iterable, key=None):
    # Other than unique_everseen from
    # https://docs.python.org/3/library/itertools.html#itertools-recipes, this
    # works for iterables of non-hashable elements, too.
    return unique_justseen(sorted(iterable, key=key), key)


def unique_justseen(iterable, key=None):
    """
    List unique elements, preserving order. Remember only the element just seen.
    """
    # from https://docs.python.org/3/library/itertools.html#itertools-recipes
    return map(next, map(itemgetter(1), groupby(iterable, key)))
</code></pre>
<p>If the number of non-unique permutations is large, this is probably rather inefficient, due to the call to <code>sorted</code>. For alternatives to obtain unique permutations of non-unique values, see <a href="https://stackoverflow.com/questions/6284396/permutations-with-unique-values">permutations with unique values</a>.</p>
<h3>TL;DR?</h3>
<p>No problem. We can boil this approach down to this abomination:</p>
<pre><code>from itertools import chain, repeat, permutations
from copy import deepcopy

def shuffle(*strings):
    return list({''.join(l.pop(0) for l in deepcopy(p)) for p in permutations(chain.from_iterable(repeat(list(s), len(s)) for s in strings))})
</code></pre>
<p>(Using a set comprehension on the result instead of ensuring uniqueness earlier.)</p>
</div>
<span class="comment-copy">Related: <a href="http://codegolf.stackexchange.com/questions/76428/all-possible-ways-to-interleave-two-strings" title="all possible ways to interleave two strings">codegolf.stackexchange.com/questions/76428/…</a></span>
<span class="comment-copy">Great explanation and solution, thanks!</span>
<span class="comment-copy">Depending on context, you may want to eliminate the recursive structure or implement a pythonic tail recursion. See <a href="http://stackoverflow.com/q/13591970/4966481">stackoverflow.com/q/13591970/4966481</a></span>
<span class="comment-copy">"This implementation is as efficient as we can get (at least asymptotically)".  Unfortunately, that's not true if there are duplicates.  You should store the partial strings in a trie or hashtable to prevent repeated work.</span>
<span class="comment-copy">Very clever. You might be interested in <a href="http://stackoverflow.com/a/36378763/1477667">one I wrote today</a> that (if I'm using the Python terminology properly) interleaves two <i>generators</i> with reasonable time bounds. It's only guaranteed to produce all possible ways if the generators ultimately halt, but that seems likely to be a reasonable price to pay for efficiency.</span>
<span class="comment-copy">Holy cats, I've never seen <i>three nested <code>for</code> loops in a listcomp</i> before. ಠ_ಠ you're <i>insane</i></span>
