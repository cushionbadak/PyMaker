<div class="post-text" itemprop="text">
<p>I need to create two tables in <code>peewee</code>. The tables are exactly the same, but one is temporary.</p>
<p>This is the definition of the table model:</p>
<pre><code>class my_table(Model):
    user_id = BigIntegerField(primary_key = True)
    created_date = DateTimeField(default=datetime.datetime.now)
    class Meta:
        database = db
</code></pre>
<p>Now I need to also create a temporary table <code>my_table_temp</code> which is an exact copy of <code>my_table</code>. </p>
<p>Yet I noticed that if I do <code>my_table_temp = my_table</code> when I do <code>my_table_temp.create_table()</code> I actually create in my database a table named <code>my_table</code>.</p>
<p>Is there a better way than redundantly </p>
<pre><code>class my_table(Model):
    user_id = BigIntegerField(primary_key = True)
    created_date = DateTimeField(default=datetime.datetime.now)
    class Meta:
        database = db

class my_table_temp(Model):
    user_id = BigIntegerField(primary_key = True)
    created_date = DateTimeField(default=datetime.datetime.now)
    class Meta:
        database = db
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not simply extend <code>my_table</code> and do nothing else,</p>
<pre><code>class my_table(Model):
    user_id = BigIntegerField(primary_key=True)
    created_date = DateTimeField(default=datetime.datetime.now)

    class Meta:
        database = db

class my_table_temp(my_table):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about this solution?</p>
<pre><code>def create_table():
    class TableClass(Model):
        user_id = BigIntegerField(primary_key = True)
        created_date = DateTimeField(default=datetime.datetime.now)
        class Meta:
            database = db

    return TableClass

myTable = create_table()
myTempTable = create_table()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending Wojciech's comment, why not use e.g. </p>
<p><code>my_table_temp = type("my_table_temp", (my_table,), {} )
</code></p>
<p>Or if using CamelCase as recommended,</p>
<p><code>MyTableTemp = type("MyTableTemp", (MyTable,), {} )
</code></p>
<p>For details on using <code>type</code> to dynamically create classes, see here: 
<a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow">https://docs.python.org/3/library/functions.html#type</a></p>
<p>or using <code>types</code>:
<a href="https://docs.python.org/3/library/types.html" rel="nofollow">https://docs.python.org/3/library/types.html</a></p>
</div>
<span class="comment-copy">Is there anything that prevents you from making the temp table a subclass of original one? Like <code>class my_table_temp(my_table)</code>? Also, please name your classes <code>CamelCase</code> in Python...</span>
<span class="comment-copy">You mean nothing else but switching to CamelCase, right?</span>
<span class="comment-copy">Ya, may be... :)</span>
<span class="comment-copy">Author of peewee -- this is what I would suggest. Just subclass your table and override anything that needs to be different (if anything).</span>
<span class="comment-copy">NO! Just subclass. Muctadir has the right answer.</span>
<span class="comment-copy">NO! Just subclass. What in the world would you use <code>type()</code> for? What benefit does it gain you over simple subclassing?</span>
<span class="comment-copy">@coleifer: this <i>is</i> just subclassing... it saves admittedly only 1 line of code, but apart from that it does the same thing as the class statement.</span>
<span class="comment-copy">Bro I know that, it's insanely unpythonic and bad advice</span>
<span class="comment-copy">@coleifer: Can I ask why you consider this to be unpythonic vs explicit subclassing without adding any functionality?</span>
