<div class="post-text" itemprop="text">
<p>I have a tuple <code>x = (2,)</code> to which I would like to append a variable <code>y</code>. I do not know ahead of time exactly what kind of variable <code>y</code> will be.</p>
<p><code>y</code> could be:</p>
<ul>
<li>a tuple, in which case I'm quite happy to use <code>x+y</code>, or</li>
<li>a single object (typically string or int), in which case I should use <code>x+(y,)</code>.</li>
</ul>
<p>Adopting one strategy will give me a TypeError half of the time, and adopting the other will give me <code>(2, (3, 4))</code> when I want <code>(2, 3, 4)</code>.</p>
<p>What's the best way to handle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow"><code>isinstance</code></a> in a <code>if</code> condition. </p>
<pre><code>&gt;&gt;&gt; x = (2,)
&gt;&gt;&gt; y1 = (1,2)
&gt;&gt;&gt; y2 = 2
&gt;&gt;&gt; def concat_tups(x,y):
...     return x + (y if isinstance(y,tuple) else (y,))
... 
&gt;&gt;&gt; concat_tups(x,y2)
(2, 2)
&gt;&gt;&gt; concat_tups(x,y1)
(2, 1, 2)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the second strategy, just check whether you're adding an iterable with multiple items or a single item.</p>
<p>You can see if an object is an iterable (<code>tuple</code>, <code>list</code>, etc.) by checking for the presence of an <code>__iter__</code> attribute. For example:</p>
<pre><code># Checks whether the object is iterable, like a tuple or list, but not a string.
if hasattr(y, "__iter__"):
    x += tuple(y)
# Otherwise, it must be a "single object" as you describe it.
else:
    x += (y,)
</code></pre>
<p>Try this. This snippet will behave exactly like you describe in your question.</p>
<p>Note that in Python 3, strings have an <code>__iter__</code> method. In Python 2.7:</p>
<pre><code>&gt;&gt;&gt; hasattr("abc", "__iter__")
False
</code></pre>
<p>In Python 3+:</p>
<pre><code>&gt;&gt;&gt; hasattr("abc","__iter__")
True
</code></pre>
<p>If you are on Python 3, which you didn't mention in your question, replace <code>hasattr(y, "__iter__")</code> with <code>hasattr(y, "__iter__") and not isinstance(y, str)</code>. This will still account for either tuples or lists. </p>
</div>
<span class="comment-copy">For one thing, tuples are immutable, so you're creating a new object. For another, you could catch the error and try the other method.</span>
<span class="comment-copy">What about lists?</span>
<span class="comment-copy">It bothers me that you sometimes get tuples, sometimes scalars to append. The only valid scenario in python where you can get values of different types is when emulating function overloading. In that scenario it's totally fine to check for <code>type(y) == tuple</code> or <code>isinstance(y, tuple)</code> or <code>isinstance(y, collections.Iterable)</code></span>
<span class="comment-copy">Thanks Jon, I was a bit loose with my language, it is indeed a new object. To Tamas's point, I am working with objects within a framework that can be indexed over multiple sets. When I iterate on an object defined over a single set, I get the single item indices, but if I'm iterating over an object defined on multiple sets, in which case I get tuples.</span>
<span class="comment-copy">This doesn't work if y is a list. See my answer, which is more robust for any iterable type that might be appended to a tuple.</span>
<span class="comment-copy">@Luke, It has been mentioned that <code>y</code> can be a tuple or a int or a string only.</span>
<span class="comment-copy">The OP did only mention tuples as iterables, I just assumed he meant iterables with multiple items. He did not specify that the only 'singe object' types could be string or int: "a single object (<i>typically</i> string or int)"</span>
<span class="comment-copy">Note that <code>str</code> also has <code>__iter__</code> as attribute. So with <code>x</code> as <code>(2)</code> and <code>y</code> as <code>'hi'</code>, the output will be <code>(2,'h','i')</code></span>
<span class="comment-copy">@LukeTaylor as Tamas mentions in comments on the question - the portable and Pythonic way isn't to check for presence of dunder methods, but using <code>isinstance(y, collections.Iterable)</code>...</span>
<span class="comment-copy">Edited to note the Python 2 vs 3 difference.</span>
<span class="comment-copy">@LukeTaylor I prefer to use the tools that are guaranteed to work, that don't require understanding of implementation details, work across versions and don't require having to explain why it may work in one case but not another :p</span>
<span class="comment-copy">Regarding your update - don't forget that file like objects, sets and dicts are also iterable, as are arrays, bytearrays, bytes etc... - it's much easier to special case string than it is to whitelist all other type objects whose iterable state is desirable</span>
