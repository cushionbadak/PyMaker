<div class="post-text" itemprop="text">
<p>I have a PyUnicode object I'm trying to convert back to a C string (char *).</p>
<p>The way I am trying to do it does not seem to be working. Here is my code:</p>
<pre><code>PyObject * objectCompName = PyTuple_GET_ITEM(compTuple, (Py_ssize_t) 0);
PyObject * ooCompName = PyUnicode_AsASCIIString(objectCompName);
char * compName = PyBytes_AsString(ooCompName);
Py_DECREF(ooCompName);
</code></pre>
<p>Is there another/better way I should be doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If UTF-8 encoded <code>char *</code> is OK, you should definitely use <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsUTF8AndSize" rel="nofollow"><code>PyUnicode_AsUTF8AndSize</code></a> (which requires Python 3.3):</p>
<pre><code>PyObject * objectCompName = PySequence_GetItem(compTuple, 0);
if (! objectCompName) {
    return NULL;
}

size_t size;
char *ptr = PyUnicode_AsUTF8AndSize(objectCompName, &amp;size);
if (!ptr) {
    return NULL;
}

// notice that the string pointed to by ptr is not guaranteed to stay forever,
// and you need to copy it, perhaps by `strdup`.
</code></pre>
<p>Also, do understand that is <strong>mandatory</strong> to check the return value of each and every <code>Py*</code> function call that you ever execute in your code. </p>
<p>Here the <code>PyTuple_GetItem</code> will return <code>NULL</code> if <code>compTuple</code> is not a <code>tuple</code>, or <code>0</code> causes <code>IndexError</code>. <code>PyUnicode_AsUTF8AndSize</code> will return <code>NULL</code> if <code>objectCompName</code> is not a <code>str</code> object. Ignore the return value and CPython crashes with <code>SIGSEGV</code> when the conditions are right.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to first convert your python PyUnicode to a non-unicode python string (read more here: <a href="https://docs.python.org/2/c-api/unicode.html#ascii-codecs" rel="nofollow">https://docs.python.org/2/c-api/unicode.html#ascii-codecs</a>) , then you can easily convert the result into <code>char*</code> . </p>
<p>Below is a pseudo code to help you proceed: </p>
<pre><code>// Assumption: you have a variable named "pyobj" which is
// a pointer to an instance of PyUnicodeObject.

PyObject* temp = PyUnicode_AsASCIIString(pyobj);
if (NULL == temp) {
    // Means the string can't be converted to ASCII, the codec failed
    printf("Oh noes\n");
    return;
}

// Get the actual bytes as a C string
char* c_str = PyByteArray_AsString(temp);

// Use the string in some manner
printf("The python unicode string is: %s\n", c_str);

// Make sure the temp stuff gets cleaned up at the end
Py_XDECREF(temp);
</code></pre>
</div>
<span class="comment-copy">Define "does not seem to be working".  Do you get crashes?  Results different from what you wanted?  In either case, exactly what?</span>
<span class="comment-copy">With which version of Python are you working?</span>
<span class="comment-copy">@JohnBollinger it segfaults when it gets here. Python 3.</span>
<span class="comment-copy">Any reason for the downvote on both my question and the answer?</span>
<span class="comment-copy">You do not check the return values of your API calls, nor test whether an exception has been raised.  That would be a good place to start.</span>
<span class="comment-copy">The PyUnicode string is originally made in another C function using <code>PyUnicode_DecodeASCII</code>.</span>
<span class="comment-copy">In that case <code>PyUnicode_AsUTF8AndSize</code> is very fine.</span>
<span class="comment-copy">Okay great. You state that it is "mandatory" to check the return values. I do plan to check them, I just haven't been as I wanted to just test and make sure it works first. Is it actually a requirement to check the return value, or you are just saying that is a very good practice?</span>
<span class="comment-copy"><b>Yes, it is absolutely mandatory, not only a good practice.</b></span>
<span class="comment-copy">Correct, so it is definitely a good thing that you told me that I need these checks as now I see what was causing underlying issues. Thanks.</span>
<span class="comment-copy">The line with the <code>PyByteArray_AsString(temp);</code> is segfaulting.</span>
