<div class="post-text" itemprop="text">
<p>For example, if passed the following:</p>
<pre><code>a = []
</code></pre>
<p>How do I check to see if <code>a</code> is empty?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>if not a:
  print("List is empty")
</code></pre>
<p>Using the implicit booleanness of the empty list is quite pythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way to do it is from the <a href="https://www.python.org/dev/peps/pep-0008" rel="noreferrer">PEP 8 style guide</a> (where <strong>Yes</strong> means “recommended” and <strong>No</strong> means “not recommended”):</p>
<blockquote>
<p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.
  </p>
<pre><code><b>Yes:</b> if not seq:
     if seq:

<b>No:</b>  if len(seq):
     if not len(seq):
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I prefer it explicitly:</p>
<pre><code>if len(li) == 0:
    print('the list is empty')
</code></pre>
<p>This way it's 100% clear that <code>li</code> is a sequence (list) and we want to test its size. My problem with <code>if not li: ...</code> is that it gives the false impression that <code>li</code> is a boolean variable.</p>
</div>
<div class="post-text" itemprop="text">
<p><sub>Other people seem to be generalizing the question beyond just lists, so I thought I'd add a caveat for a different type of sequence that a lot of people might use, especially since this is the first google hit for "python test empty array".</sub></p>
<h1>Other methods don't work for numpy arrays</h1>
<p>You need to be careful with numpy arrays, because other methods that work fine for <code>list</code>s or other standard containers fail for numpy arrays.  I explain why below, but in short, the <a href="http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array" rel="noreferrer">preferred method</a> is to use <code>size</code>.</p>
<h3>The "pythonic" way doesn't work: Part 1</h3>
<p>The "pythonic" way fails with numpy arrays because numpy tries to cast the array to an array of <code>bool</code>s, and <code>if x</code> tries to evaluate all of those <code>bool</code>s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a <code>ValueError</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,1])
&gt;&gt;&gt; if x: print("x")
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</code></pre>
<h3>The "pythonic" way doesn't work: Part 2</h3>
<p>But at least the case above tells you that it failed.  If you happen to have a numpy array with exactly one element, the <code>if</code> statement will "work", in the sense that you don't get an error.  However, if that one element happens to be <code>0</code> (or <code>0.0</code>, or <code>false</code>, ...), the <code>if</code> statement will incorrectly result in <code>false</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,])
&gt;&gt;&gt; if x: print("x")
... else: print("No x")
No x
</code></pre>
<p>But clearly <code>x</code> exists and is not empty!  This result is not what you wanted.</p>
<h3>Using <code>len</code> can give unexpected results</h3>
<p>For example,</p>
<pre><code>len( numpy.zeros((1,0)) )
</code></pre>
<p>returns 1, even though the array has zero elements.</p>
<h3>The numpythonic way</h3>
<p>As explained in the <a href="http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array" rel="noreferrer">scipy FAQ</a>, the correct method in all cases where you know you have a numpy array is to use <code>if x.size</code>:</p>
<pre><code>&gt;&gt;&gt; x = numpy.array([0,1])
&gt;&gt;&gt; if x.size: print("x")
x

&gt;&gt;&gt; x = numpy.array([0,])
&gt;&gt;&gt; if x.size: print("x")
... else: print("No x")
x

&gt;&gt;&gt; x = numpy.zeros((1,0))
&gt;&gt;&gt; if x.size: print("x")
... else: print("No x")
No x
</code></pre>
<p>If you're not sure whether it might be a <code>list</code>, a numpy array, or something else, you could combine this approach with <a href="https://stackoverflow.com/a/10835703/1194883">the answer @dubiousjim gives</a> to make sure the right test is used for each type.  Not very "pythonic", but it turns out that numpy intentionally broke pythonicity in at least this sense.</p>
<p>If you need to do more than just check if the input is empty, and you're using other numpy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input <em>to be</em> a numpy array.  There are a few nice functions for doing this quickly — most importantly <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html" rel="noreferrer"><code>numpy.asarray</code></a>.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen <code>dtype</code>.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a numpy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current <a href="http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html" rel="noreferrer">scope</a>:</p>
<pre><code>x = numpy.asarray(x, dtype=numpy.double)
</code></pre>
<p>This will make the <code>x.size</code> check work in all cases I see on this page.</p>
</div>
<div class="post-text" itemprop="text">
<p>An empty list is itself considered false in true value testing (see <a href="https://docs.python.org/2/library/stdtypes.html#truth-value-testing" rel="noreferrer">python documentation</a>):</p>
<pre><code>a = []
if a:
     print "not empty"
</code></pre>
<p>@Daren Thomas</p>
<blockquote>
<p>EDIT: Another point against testing
  the empty list as False: What about
  polymorphism? You shouldn't depend on
  a list being a list. It should just
  quack like a duck - how are you going
  to get your duckCollection to quack
  ''False'' when it has no elements?</p>
</blockquote>
<p>Your duckCollection should implement <code>__nonzero__</code> or <code>__len__</code> so the if a: will work without problems.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Best way to check if a list is empty</h2>
<p>For example, if passed the following:</p>
<pre><code>a = []
</code></pre>
<p>How do I check to see if a is empty?</p>
</blockquote>
<h2>Short Answer:</h2>
<p>Place the list in a boolean context (for example, with an <code>if</code> or <code>while</code> statement). It will test <code>False</code> if it is empty, and <code>True</code> otherwise. For example:</p>
<pre><code>if not a:                           # do this!
    print('a is an empty list')
</code></pre>
<h2>Appeal to Authority</h2>
<p><a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="noreferrer">PEP 8</a>, the official Python style guide for Python code in Python's standard library, asserts:</p>
<blockquote>
<p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</p>
<pre><code>Yes: if not seq:
     if seq:

No: if len(seq):
    if not len(seq):
</code></pre>
</blockquote>
<p>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</p>
<h2>Explanation</h2>
<p>I frequently see code like this from experienced programmers new to Python:</p>
<pre><code>if len(a) == 0:                     # Don't do this!
    print('a is an empty list')
</code></pre>
<p>And users of lazy languages may be tempted to do this:</p>
<pre><code>if a == []:                         # Don't do this!
    print('a is an empty list')
</code></pre>
<p>These are correct in their respective other languages. And this is even semantically correct in Python. </p>
<p>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</p>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">docs</a> (and note specifically the inclusion of the empty list, <code>[]</code>):</p>
<blockquote>
<p>By default, an object is considered true unless its class defines
  either a <code>__bool__()</code> method that returns <code>False</code> or a <code>__len__()</code> method
  that returns zero, when called with the object. Here are most of the built-in objects considered false:</p>
<ul>
<li>constants defined to be false: <code>None</code> and <code>False</code>.</li>
<li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>empty sequences and collections: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
</blockquote>
<p>And the datamodel documentation:</p>
<blockquote>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noreferrer"><code>object.__bool__(self)</code></a></p>
<p>Called to implement truth value testing and the built-in operation <code>bool()</code>; should return <code>False</code> or <code>True</code>. When this method is not defined,
  <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code>
  nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>
<p>and </p>
<blockquote>
<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noreferrer"><code>object.__len__(self)</code></a></p>
<p>Called to implement the built-in function <code>len()</code>. Should return the length of the object, an integer &gt;= 0. Also, an object that doesn’t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p>
</blockquote>
<p>So instead of this:</p>
<pre><code>if len(a) == 0:                     # Don't do this!
    print('a is an empty list')
</code></pre>
<p>or this:</p>
<pre><code>if a == []:                     # Don't do this!
    print('a is an empty list')
</code></pre>
<p>Do this:</p>
<pre><code>if not a:
    print('a is an empty list')
</code></pre>
<h2>Doing what's Pythonic usually pays off in performance:</h2>
<p>Does it pay off? (Note that less time to perform an equivalent operation is better:)</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; min(timeit.repeat(lambda: len([]) == 0, repeat=100))
0.13775854044661884
&gt;&gt;&gt; min(timeit.repeat(lambda: [] == [], repeat=100))
0.0984637276455409
&gt;&gt;&gt; min(timeit.repeat(lambda: not [], repeat=100))
0.07878462291455435
</code></pre>
<p>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(lambda: [], repeat=100))
0.07074015751817342
</code></pre>
<p>We see that <em>either</em> checking for length with the builtin function <code>len</code> compared to <code>0</code> <em>or</em> checking against an empty list is <strong>much</strong> less performant than using the builtin syntax of the language as documented.</p>
<p>Why?</p>
<p>For the <code>len(a) == 0</code> check:</p>
<p>First Python has to check the globals to see if <code>len</code> is shadowed. </p>
<p>Then it must call the function, load <code>0</code>, and do the equality comparison in Python (instead of with C):</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(lambda: len([]) == 0)
  1           0 LOAD_GLOBAL              0 (len)
              2 BUILD_LIST               0
              4 CALL_FUNCTION            1
              6 LOAD_CONST               1 (0)
              8 COMPARE_OP               2 (==)
             10 RETURN_VALUE
</code></pre>
<p>And for the <code>[] == []</code> it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: [] == [])
  1           0 BUILD_LIST               0
              2 BUILD_LIST               0
              4 COMPARE_OP               2 (==)
              6 RETURN_VALUE
</code></pre>
<p>The "Pythonic" way is a much simpler and faster check since the length of the list is cached in the object instance header:</p>
<pre><code>&gt;&gt;&gt; dis.dis(lambda: not [])
  1           0 BUILD_LIST               0
              2 UNARY_NOT
              4 RETURN_VALUE
</code></pre>
<h2>Evidence from the C source and documentation</h2>
<blockquote>
<p><a href="https://docs.python.org/2/c-api/structures.html#c.PyVarObject" rel="noreferrer"><code>PyVarObject</code></a></p>
<p>This is an extension of <code>PyObject</code> that adds the <code>ob_size</code> field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the <code>PyObject_VAR_HEAD</code> macro.</p>
</blockquote>
<p>From the c source in <a href="https://github.com/python/cpython/blob/master/Include/listobject.h" rel="noreferrer">Include/listobject.h</a>:</p>
<pre><code>typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 &lt;= ob_size &lt;= allocated
     *     len(list) == ob_size
</code></pre>
<p>I have enjoyed researching this and I spend a lot of time curating my answers. If you think I'm leaving something out, please let me know in a comment.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/53522/908494">Patrick's (accepted) answer</a> is right: <code>if not a:</code> is the right way to do it. <a href="https://stackoverflow.com/a/53752/908494">Harley Holcombe's answer</a> is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom—even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</p>
<p>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</p>
<p>It's true that <code>if not a:</code> doesn't distinguish empty lists from <code>None</code>, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know <em>what</em> you want to be explicit about, so you can test for exactly that. For example, <code>if not a and a is not None:</code> means "anything falsey except None", while <code>if len(a) != 0:</code> means "only empty sequences—and anything besides a sequence is an error here", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</p>
<p>But when you don't have anything to be explicit about, anything other than <code>if not a:</code> is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you <em>habitually</em> mislead the reader like this, then when you <em>do</em> need to make a distinction, it's going to pass unnoticed because you've been "crying wolf" all over your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have seen the below as preferred:</p>
<pre><code>if not a:
    print("The list is empty or null")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Why check at all?</h1>
<p>No one seems to have addressed questioning your <em>need</em> to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</p>
<p>I would argue that the <em>most pythonic</em> way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</p>
<pre><code>a = []

for item in a:
    &lt;do something with item&gt;

&lt;rest of code&gt;
</code></pre>
<p>This has the benefit of handling any contents of <strong>a</strong>, while not requiring a specific check for emptiness.  If <strong>a</strong> is empty, the dependent block will not execute and the interpreter will fall through to the next line.</p>
<p>If you do actually need to check the array for emptiness, the other answers are sufficient.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://books.google.com/books?id=vpTAq4dnmuAC&amp;pg=RA1-PA479&amp;lpg=RA1-PA479&amp;dq=Python+len+big+O&amp;source=web&amp;ots=AOM6A1K9Fy&amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;hl=en&amp;sa=X&amp;oi=book_result&amp;resnum=4&amp;ct=result" rel="noreferrer"><code>len()</code> is an O(1) operation</a> for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</p>
<p>JavaScript <a href="http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting" rel="noreferrer">has a similar notion of truthy/falsy</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I had written:</p>
<pre><code>if isinstance(a, (list, some, other, types, i, accept)) and not a:
    do_stuff
</code></pre>
<p>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as "pythonic"---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where <code>a</code> is, for example, <code>False</code>, you need a test more restrictive than just <code>if not a:</code>. You could use something like this:</p>
<pre><code>if isinstance(a, numpy.ndarray) and not a.size:
    do_stuff
elif isinstance(a, collections.Sized) and not a:
    do_stuff
</code></pre>
<p>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</p>
<pre><code>elif isinstance(a, (list, tuple)) and not a:
</code></pre>
<p>if you only want to accept instances of particular types (and their subtypes), or with:</p>
<pre><code>elif isinstance(a, (list, tuple)) and not len(a):
</code></pre>
<p>You can get away without the explicit type check, but only if the surrounding context already assures you that <code>a</code> is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a <code>TypeError</code> if you call <code>len</code> on a value for which it's undefined) that you're prepared to handle. In general, the "pythonic" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to <em>think</em> about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on <code>len</code> or the boolean typecast may not do precisely what you're expecting.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is very uniform about the treatment of emptiness. Given the following:</p>
<pre><code>a = []

.
.
.

if a:
   print("List is not empty.")
else:
   print("List is empty.")
</code></pre>
<p>You simply check list a with an "if" statement to see if it is empty.  From what I have read and been taught, this is the "Pythonic" way to see if a list or tuple is empty.</p>
</div>
<div class="post-text" itemprop="text">
<p>Some methods that I use:</p>
<pre><code>if not a:
    print "list is empty"


if len(a) == 0:
    print "list is empty"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing">documentation</a> on truth value testing:</p>
<p>All values other than what is listed here are considered <code>True</code></p>
<ul>
<li><code>None</code></li>
<li><code>False</code></li>
<li>zero of any numeric type, for example, <code>0</code>, <code>0.0</code>, <code>0j</code>.</li>
<li>any empty sequence, for example, <code>''</code>, <code>()</code>, <code>[]</code>.</li>
<li>any empty mapping, for example, <code>{}</code>.</li>
<li>instances of user-defined classes, if the class defines a <code>__bool__()</code> or <code>__len__()</code> method, when that method returns the integer zero or bool value <code>False</code>.</li>
</ul>
<p>As can be seen, empty list <code>[]</code> is <em>falsy</em>, so doing what would be done to a boolean value sounds most efficient:</p>
<pre><code>if not a:
    print('"a" is empty!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are a few ways you can check if a list is empty:</p>
<pre><code>a = [] #the list
</code></pre>
<p><strong>1)</strong> The pretty simple pythonic way:</p>
<pre><code>if not a:
    print("a is empty")
</code></pre>
<p>In Python, <strong>empty containers</strong> such as lists,tuples,sets,dicts,variables etc are seen as <code>False</code>. One could simply treat the list as a predicate (<em>returning a Boolean value</em>). And  a <code>True</code> value would indicate that it's non-empty.</p>
<p><strong>2)</strong> A much explicit way: using the <code>len()</code> to find the length and check if it equals to <code>0</code>:</p>
<pre><code>if len(a) == 0:
    print("a is empty")
</code></pre>
<p><strong>3)</strong> Or comparing it to an anonymous empty list:</p>
<pre><code>if a == []:
    print("a is empty")
</code></pre>
<p><strong>4)</strong> Another yet <em>silly</em> way to do is using <code>exception</code> and <code>iter()</code>:</p>
<pre><code>try:
    next(iter(a))
    # list has elements
except StopIteration:
    print("Error: a is empty")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer the following:</p>
<pre><code>if a == []:
   print "The list is empty."
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def list_test (L):
    if   L is None  : print 'list is None'
    elif not L      : print 'list is empty'
    else: print 'list has %d elements' % len(L)

list_test(None)
list_test([])
list_test([1,2,3])
</code></pre>
<p>It is sometimes good to test for <code>None</code> and for emptiness separately as those are two different states. The code above produces the following output:</p>
<pre><code>list is None 
list is empty 
list has 3 elements
</code></pre>
<p>Although it's worth nothing that <code>None</code> is falsy. So if you don't want to separate test for <code>None</code>-ness, you don't have to do that. </p>
<pre><code>def list_test2 (L):
    if not L      : print 'list is empty'
    else: print 'list has %d elements' % len(L)

list_test2(None)
list_test2([])
list_test2([1,2,3])
</code></pre>
<p>produces expected</p>
<pre><code>list is empty
list is empty
list has 3 elements
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Method 1 (Preferred):</p>
<pre><code>if not a : 
   print ("Empty") 
</code></pre>
<p>Method 2 :</p>
<pre><code>if len(a) == 0 :
   print( "Empty" )
</code></pre>
<p>Method 3: </p>
<pre><code>if a == [] :
  print ("Empty")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another simple way could be</p>
<pre><code>a = []
if len(a) == 0:
  print("Empty")
else:
  print(" Not empty")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</p>
<pre><code>not a
</code></pre>
<p>will also pass for <code>None</code> and other types of empty structures. If you truly want to check for an empty list, you can do this:</p>
<pre><code>if isinstance(a, list) and len(a)==0:
    print("Received an empty list")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From python3 onwards you can use</p>
<pre><code>a == []
</code></pre>
<p>to check if the list is empty</p>
<p>EDIT : This works with python2.7 too.. </p>
<p>I am not sure why there are so many complicated answers.
It's pretty clear and straightforward</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check if the length of the array is zero (or not.) If the <strong>length of the array is zero</strong>, then it is <strong>empty</strong>. try the following:</p>
<pre><code>a = []
if len(a)==0 : print "List is empty"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>we could use a simple if else:</p>
<pre><code>list=[]
if len(list)==0:
    print ("list is empty")
else:
    print ("list is not empty")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Being inspired by @dubiousjim's solution, I propose to use an additional general check of whether is it something iterable</p>
<pre><code>import collections
def is_empty(a):
    return not a and isinstance(a, collections.Iterable)
</code></pre>
<p>Note: a string is considered to be iterable. - add <code>and not isinstance(a,(str,unicode))</code> if you want the empty string to be excluded</p>
<p>Test:</p>
<pre><code>&gt;&gt;&gt; is_empty('sss')
False
&gt;&gt;&gt; is_empty(555)
False
&gt;&gt;&gt; is_empty(0)
False
&gt;&gt;&gt; is_empty('')
True
&gt;&gt;&gt; is_empty([3])
False
&gt;&gt;&gt; is_empty([])
True
&gt;&gt;&gt; is_empty({})
True
&gt;&gt;&gt; is_empty(())
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can even try using bool() like this</p>
<pre><code>    a = [1,2,3];
    print bool(a); # it will return True
    a = [];
    print bool(a); # it will return False
</code></pre>
<p>I love this way for checking list is empty or not. </p>
<p>Very handy and useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple way is checking the length is equal zero.</p>
<pre><code>if len(a) == 0:
    print("a is empty")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>print('not empty' if a else 'empty')
</code></pre>
<p>a little more practical:</p>
<pre><code>a.pop() if a else None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check if: <code>len(list) == 0</code> returns: <code>True</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Simply use is_empty() or make function like:- </p>
<pre><code>def is_empty(any_structure):
    if any_structure:
        print('Structure is not empty.')
        return True
    else:
        print('Structure is empty.')
        return False  
</code></pre>
<p>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just <code>is_empty(any_structure)</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to check if list is empty;</p>
<pre><code>l = []
if l:
    # do your stuff.
</code></pre>
<p>If you want to check weather all the values in list is empty.</p>
<pre><code>l = ["", False, 0, '', [], {}, ()]
if all(bool(x) for x in l):
    # do your stuff.
</code></pre>
<p>However this will be True for empty list.</p>
<pre><code>def empty_list(lst):
    if len(lst) ==0:
        return false
    else:
        return all(bool(x) for x in l)
</code></pre>
<p>Now you can use:</p>
<pre><code>if empty_list(lst):
    # do your stuff.
</code></pre>
</div>
<span class="comment-copy">Playing devil's advocate. I don't understand why this idiom is considered pythonic. 'Explicit is better then implicit', correct? This check doesn't seem very explicit about what is is checking.</span>
<span class="comment-copy">@JamesMcMahon - it's a trade-off between explicitness and type flexibility.  generally, "being explicit" means not doing "magical" things.  on the other hand, "duck typing" means working with more general interfaces, rather than explicitly checking for types.  so something like <code>if a == []</code> is forcing a particular type (<code>() == []</code> is <code>False</code>).  here, general consensus seems to be that duck typing wins out (in effect, saying that <code>__nonzero__</code> is the interface for testing emptiness <a href="http://docs.python.org/reference/datamodel.html#object.__nonzero__" rel="nofollow noreferrer">docs.python.org/reference/datamodel.html#object.__nonzero__</a>)</span>
<span class="comment-copy">Alternatively, one can use <code>if len(a) == 0: print('List is empty')</code></span>
<span class="comment-copy">@thepunitsingh:  Yes, but most linters will say that <code>if not a:</code> is preferable.</span>
<span class="comment-copy">@user1071847 yes. I guess my method is a bit old school, coming from C Lang.</span>
<span class="comment-copy">The second way seems better if you wish to signal that <code>seq</code> is expected to be some sort of list-like object.</span>
<span class="comment-copy">@BallpointBen which, Pythonism advocates would say, should be implicit in the way the variable is named, as much as possible</span>
<span class="comment-copy">@BallpointBen try using Python's <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">type hinting</a> for signaling what a variable should be. It was introduced in 3.5.</span>
<span class="comment-copy">numpy broke this idiom... seq = numpy.array([1,2,3]) followed by if not seq raises an exception "ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()"</span>
<span class="comment-copy">Checking if the length of a list is equal to zero, rather than just checking if the list is false, is ugly and unpythonic. Anyone familiar with Python will not think <code>li</code> is a bool at all, and wont care. If it's important, you should add a comment, not more code.</span>
<span class="comment-copy">This seems like an unnecessarily precise test, which is often slower and is always less readable IMHO.  Instead of checking the size of something empty, why not just check if it's empty?</span>
<span class="comment-copy">Anyway, the reason this is bad (and that violating idioms in a language with strong idioms like Python is bad in general) is that it signals to the reader that you're specifically checking the length for some reason (e.g., because you want <code>None</code> or <code>0</code> to raise an exception rather than passing). So, when you do it for no reason, that's misleading—and it also means that when your code <i>does</i> need to make the distinction, the distinction is invisible because you've "cried wolf" all over the rest of the source.</span>
<span class="comment-copy">I think this is just needlessly lengthening the code.  Otherwise, why not be even more "explicit" with <code>if bool(len(li) == 0) is True:</code>?</span>
<span class="comment-copy">@Jabba it will be <b>O(1)</b> in many cases (those where you work with the built-in data types), but you just can't rely on that. You might be working with a custom data type that doesn't have this property. You might also decide to add this custom data type later, after you already wrote this code.</span>
<span class="comment-copy">It's worth noting that this isn't a flaw in Python, but rather an intentional break of contract by <code>numpy</code> - <code>numpy</code> is a library with a very specific use case, and it has a different 'natural' definition of what truthiness on an array is to the Python standard for containers. It makes sense to optimise for that case, in the way that <code>pathlib</code> uses <code>/</code> to concatenate paths instead of <code>+</code> - it's non-standard, but makes sense in context.</span>
<span class="comment-copy">Agreed.  My point is just that it's important to remember that numpy has made the choice to break duck typing for both the very common <code>if x</code> and <code>len(x)</code> idioms -- and sometimes that breakage can be very hard to detect and debug.</span>
<span class="comment-copy">I don't know, for me, if a method called len(x) doesn't return the array length because assumptions, it's name is bad designed.</span>
<span class="comment-copy">This question has nothing to do with numpy arrays</span>
<span class="comment-copy">@ppperry Yes, the original question was not about Numpy arrays, but when working with those and possibly duck typed arguments, this question becomes very relevant.</span>
<span class="comment-copy">This is IMO quite a good read and a valuable contribution (responding nine years after the question has been posed may have some smell, but not in this case at least for me). Thanks Aaron.</span>
<span class="comment-copy">@Dilettant Smells are rules of thumb or heuristics that make us look closer. Some new users post late answers that essentially copy other answers, and that's the sort of thing we're concerned about when it comes to late answers. Late answers that add value <i>are</i> quite welcome, however - otherwise we'd close posts after some period of time, like Reddit does.</span>
<span class="comment-copy"><code>None</code> is not a list; it is its own type.</span>
<span class="comment-copy">The thing is, check if the list is empty is quite important, at least for me. Have you considered if there's some script inside <code>&lt;rest of code&gt;</code> that might use the result from the <code>for</code> loop? Or directly use some values in <code>a</code>?  Indeed, if the script is designed to run with strictly controlled input, the check might be a little unnecessary. But in most cases, the input varies, and have a check is usually better.</span>
<span class="comment-copy">This is a good point in most cases</span>
<span class="comment-copy">Respectfully, no.  What I considered was someone who didn’t know enough about Python to know that “if &lt;list&gt;:” was the correct answer, asked how to check for an empty list.  Then I notice a LOT of answers that offered differing opinions, but none seemed to address the original need.  That is what I tried to do with my answer—have them examine the need before continuing.  I believe I suggested as much in my answer, explicitly.</span>
<span class="comment-copy">@AmarthGûl - How might one <i>get</i> the results from the for loop to the script inside &lt;rest of code&gt; to be processed?  In a list, perhaps? Or maybe a dict?  If so, the same logic applies.  I'm not understanding how <i>variable input</i> could have any effect within any kind of reasonably designed code, where processing an empty list would be a bad idea.</span>
<span class="comment-copy">It's pretty rare that you're going to have an exhaustive list of 6 types that you want to accept and not be flexible for any other types. When you need that kind of thing, you probably want an ABC. In this case, it would probably be one of the stdlib ABCs, like <code>collections.abc.Sized</code> or <code>collections.abc.Sequence</code>, but it might be one you write yourself and <code>register(list)</code> on. If you actually do have code where it's important to distinguish empty from other falsey, and also to distinguish lists and tuples from any other sequences, then this is correct—but I don't believe you have such code.</span>
<span class="comment-copy">The reason people don't like this is because it's entirely unnessesary in most cases. Python is a duck-typed language, and this level of defensive coding actively hinders that. The idea behind Python's type system is that things should work as long as the object passed in functions in the way it needs to. By doing explicit type checks you are forcing the caller to use specific types, going against the very grain of the language. While occasionally such things are necessary (excluding strings from being treated as sequences), such cases are rare and almost always best as blacklists.</span>
<span class="comment-copy">If you really want to check that the value is exactly <code>[]</code> and not something falsy of another type, then surely <code>if a == []:</code> is called for, rather than mucking about with isinstance.</span>
<span class="comment-copy">There are some automatic coercions for <code>==</code> though. Off the top of my head, I can't identify any for <code>[]</code>. <code>[] == ()</code> for instance returns <code>False</code>. But for example <code>frozenset()==set()</code> returns <code>True</code>. So it's worth at least giving some thought to whether some undesired type might be coerced to <code>[]</code> (or vice versa) when doing <code>a == []</code>.</span>
<span class="comment-copy">@RemcoGerlich - isinstance() is still preferable as opposed to constructing an empty list to compare against.  Also, as another pointed out, the equality operator may invoke implicit conversion of some types, which may be undesirable.  There is no reason to ever code "a == []" and that code would definitely be flagged as a defect in any code review I've participated in.  Using the appropriate tool as provided by the language should not be considered "mucking about," but rather "good programming technique."</span>
<span class="comment-copy">how do we assert this when using unite testing?</span>
<span class="comment-copy">@DJ_Stuffy_K assert what in unit testing, an empty list? Just use <code>assert(not myList)</code>. If you also want to assert the object is a <code>list</code>, you can use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertIsInstance" rel="nofollow noreferrer"><code>assertIsInstance()</code></a>.</span>
<span class="comment-copy">This is going to be slower, as you instantiate an extra empty list unnecessarily.</span>
<span class="comment-copy">this is less readable than <code>if not a:</code> and breaks more easily. Please don't do it.</span>
<span class="comment-copy">There is a good point made earlier <code>() == []</code> is also equal to false. Although I like how this implementation reads the <code>if not a:</code> covers all cases, if you are definitely expecting a list then your example should be sufficient.</span>
<span class="comment-copy">It is possible this throws an exception, if <code>a</code> is not a list and <code>a</code> has no method <code>__len__</code> implemented. I would recommend: <code>if isinstance(obj, list): if len(obj) == 0:  print '...'</code></span>
<span class="comment-copy">@SvenKrüger nope. Operator <code>and</code> is lazy in Python. Nothing after <code>and</code> is going to be executed if condition before <code>and</code> is False.</span>
<span class="comment-copy">This is true in many programming languages, not just Python</span>
<span class="comment-copy">please give more explanation about how it is working without writing "if"?</span>
<span class="comment-copy">Using <code>%timeit</code> in ipdb, <code>len(a)</code> is almost 50% faster than <code>bool(a)</code>, however <a href="https://stackoverflow.com/a/53752/2996101">pep 8</a> would recommend using <code>bool(a)</code>.</span>
<span class="comment-copy">Overbroad; this is just asking whether a list is empty, not whether something is an empty iterable.</span>
<span class="comment-copy">If I wasn't happy with <code>if a:</code>, it would be because I wanted an exception if <code>a</code> wasn't some sort of container.  (Being an <i>iterable</i> also allows iterators, which can't usefully be tested for emptiness.)</span>
<span class="comment-copy">For those (like me) who didn't know, <code>bool()</code> converts a Python variable into a boolean so you can <a href="http://stackoverflow.com/a/24868176/6157047">store the truthiness or falsiness</a> of a value without having to use an if-statement. I think it's less readable than simply using a conditional like the accepted answer, but I'm sure there are other good use cases for it.</span>
<span class="comment-copy">This is usable in an expression and is more terse.</span>
<span class="comment-copy">I see that pylint complains about this: <code>&gt;&gt;&gt; timeit.timeit(setup='None', stmt="list=[]; bool(list)", number=10000) 0.0009641999999985273 &gt;&gt;&gt; timeit.timeit(setup='None', stmt="list=[]; bool(len(list))", number=10000) 0.002756199999993214</code> it is way slower</span>
<span class="comment-copy">The name <code>is_empty</code> suggests that it returns something.  But if it did, that something would just be <code>bool(any_structure)</code>, which you should use instead (<i>when</i> you need a <code>bool</code> at all).</span>
<span class="comment-copy">Why do we want a variation on <code>bool</code> that (also) prints messages to standard output?</span>
<span class="comment-copy">@DavisHerring We always  have two choice first is to print using function other is using return <code>bool</code> variable. Choice is yours. I write both so you can choose between them.</span>
<span class="comment-copy">all(bool(x) for x in l) is True for an empty list</span>
