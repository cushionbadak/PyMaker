<div class="post-text" itemprop="text">
<p>In python, is there a difference between <code>raise</code> and <code>raise e</code> in an except block?</p>
<p><code>dis</code> is showing me different results, but I don't know what it means.</p>
<p>What's the end behavior of both?</p>
<pre><code>import dis
def a():
    try:
        raise Exception()
    except Exception as e:
        raise


def b():
    try:
        raise Exception()
    except Exception as e:
        raise e

dis.dis(a)
# OUT:   4           0 SETUP_EXCEPT            13 (to 16)
# OUT:   5           3 LOAD_GLOBAL              0 (Exception)
# OUT:               6 CALL_FUNCTION            0
# OUT:               9 RAISE_VARARGS            1
# OUT:              12 POP_BLOCK           
# OUT:              13 JUMP_FORWARD            22 (to 38)
# OUT:   6     &gt;&gt;   16 DUP_TOP             
# OUT:              17 LOAD_GLOBAL              0 (Exception)
# OUT:              20 COMPARE_OP              10 (exception match)
# OUT:              23 POP_JUMP_IF_FALSE       37
# OUT:              26 POP_TOP             
# OUT:              27 STORE_FAST               0 (e)
# OUT:              30 POP_TOP             
# OUT:   7          31 RAISE_VARARGS            0
# OUT:              34 JUMP_FORWARD             1 (to 38)
# OUT:         &gt;&gt;   37 END_FINALLY         
# OUT:         &gt;&gt;   38 LOAD_CONST               0 (None)
# OUT:              41 RETURN_VALUE        
dis.dis(b)
# OUT:   4           0 SETUP_EXCEPT            13 (to 16)
# OUT:   5           3 LOAD_GLOBAL              0 (Exception)
# OUT:               6 CALL_FUNCTION            0
# OUT:               9 RAISE_VARARGS            1
# OUT:              12 POP_BLOCK           
# OUT:              13 JUMP_FORWARD            25 (to 41)
# OUT:   6     &gt;&gt;   16 DUP_TOP             
# OUT:              17 LOAD_GLOBAL              0 (Exception)
# OUT:              20 COMPARE_OP              10 (exception match)
# OUT:              23 POP_JUMP_IF_FALSE       40
# OUT:              26 POP_TOP             
# OUT:              27 STORE_FAST               0 (e)
# OUT:              30 POP_TOP             
# OUT:   7          31 LOAD_FAST                0 (e)
# OUT:              34 RAISE_VARARGS            1
# OUT:              37 JUMP_FORWARD             1 (to 41)
# OUT:         &gt;&gt;   40 END_FINALLY         
# OUT:         &gt;&gt;   41 LOAD_CONST               0 (None)
# OUT:              44 RETURN_VALUE        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no difference in this case. <code>raise</code> without arguments <a href="https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement">will always raise the last exception thrown</a> (which is also accessible with <code>sys.exc_info()</code>).</p>
<p>The reason the bytecode is different is because Python is a dynamic language and the interpreter doesn't really "know" that <code>e</code> refers to the (unmodified) exception that is currently being handled. But this may not always be the case, consider:</p>
<pre><code>try:
    raise Exception()
except Exception as e:
    if foo():
        e = OtherException()
    raise e
</code></pre>
<p>What is <code>e</code> now? There is no way to tell when compiling the bytecode (only when actually <em>running</em> the program).</p>
<p>In simple examples like yours, it might be possible for the Python interpreter to "optimize" the bytecode, but so far no one has done this. And why should they? It's a micro-optimization at best and may still break in subtle ways in obscure conditions. There is a lot of other fruit that is hanging a lot lower than this and is more nutritious to boot ;-)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a difference in the backtraces that the two forms generate.</p>
<p>Using <code>raise</code>, this code:</p>
<pre><code>try:
   int("hello")
except ValueError as e:
   raise
</code></pre>
<p>Gives the following backtrace:</p>
<pre><code>Traceback (most recent call last):
  File "myfile.py", line 2, in &lt;module&gt;
    int("hello")
ValueError: invalid literal for int() with base 10: 'hello'
</code></pre>
<p>Using <code>raise e</code> as follows:</p>
<pre><code>try:
   int("hello")
except ValueError as e:
   raise e
</code></pre>
<p>Gives the following backtrace</p>
<pre><code>Traceback (most recent call last):
  File "myfile.py", line 4, in &lt;module&gt;
    raise e
ValueError: invalid literal for int() with base 10: 'hello'
</code></pre>
<p>The difference is that in the <code>raise</code> case, the correct line referencing the original source of the exception is quoted in the backtrace, but in the <code>raise e</code> case the traceback references the <code>raise e</code> line not the original cause.</p>
<p>Therefore, I recommend always using <code>raise</code> rather than <code>raise e</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to clear the "last exception" (i.e. the result of <code>sys.exc_info()</code>) info with <code>sys.exc_clear()</code>. For instance, this would happen if the catch block called a function <code>foo()</code>, which itself has special error handling.</p>
<p>In that case, <code>raise</code> with and without an argument would mean diffent things. <code>raise e</code> would still have a reference to the exception caught a few lines above, while the <code>raise</code> shorthand would try to raise <code>None</code>, which is an error.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/18001721/raise-with-no-argument">raise with no argument</a></span>
<span class="comment-copy">@Jérôme I don't think this is a duplicate of that. This question is about the difference between no-arg and with-arg versions in this specific code sample. That question is about how no-arg works generally. They're related but not duplicate</span>
<span class="comment-copy">Yes, and the accepted answer is interesting precisely for this reason. If there is a way to unflag a question, I'll do it.</span>
<span class="comment-copy">I'm not trying to optimize, I just was wondering if the behavior was any different in this specific case</span>
<span class="comment-copy">@Daenyth Yeah, I understand that, the optimization note was merely to explain why Python doesn't "optimize" the bytecode in simple examples ;-)</span>
<span class="comment-copy">Your edit makes that more clear, thanks</span>
<span class="comment-copy">The behaviour you're describing is true of Python 2, but not Python 3. In Python 3, <code>raise e</code> does not swallow the original source and actually shows strictly <i>more</i> information in this case.</span>
<span class="comment-copy">This is a very important point. I've spent way too much time to trace the real source of error due to <code>raise e</code>.</span>
