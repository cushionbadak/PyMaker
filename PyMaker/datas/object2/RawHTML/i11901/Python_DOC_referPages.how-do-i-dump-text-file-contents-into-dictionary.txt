<div class="post-text" itemprop="text">
<p>Hi I'm using python 3 on mac and I'm trying to create a generic program to communicate with a range of different multimeters dependent on which text file is loaded. For example, I want a dictionary that will look something like this:</p>
<pre><code>prog_key  = {"DC_Volts":"FUNC:DC V","AC_Volts":"FUNC:AC V"...} #just an example
</code></pre>
<p>This will eventually be used in conjunction with the pyvisa library in order to send commands to a meter.</p>
<p>So, in order to make my program generic, I want this dictionary:</p>
<pre><code>prog_key = {}
</code></pre>
<p>to load a text file which has the following contents:</p>
<pre><code>"DC_Volt”:”FUNC:VOLT DC”,
"DC_Curr”:”FUNC:CURR DC”,
"AC_Volt”:”FUNC:VOLT AC”,
"AC_Curr”:”FUNC:CURR AC”,
"Res_2”:”FUNC:RES”,
"Res_4”:”FUNC:RES 4”,
"Freq”:”FUNC:FREQ”,
"Cap”:”FUNC:CAP”,
"Temp”:”FUNC:TEMP”,
"Diode”:”FUNC:DIO”,
“Meas”:”MEAS:IMM”
</code></pre>
<p>As I will have it ready-formatted in the text file, I literally just want to dump it in the dictionary (all quotation marks, colons and commas will be in place). I'm doing it this way as different meters will have different commands, so I can just load a different text file if I'm using a different meter.</p>
<p>Is the fact that my commands have colons gonna cause any problems?</p>
<p>If theres a better way, I don't mind reformatting my text file. The main thing is that I make all of my text files following the same trend, doesn't really matter what that trent is as long as it works!</p>
<p>Thanks</p>
<p>Edit: those are indeed meant to be straight quotes </p>
</div>
<div class="post-text" itemprop="text">
<p>I think perhaps a better way to format the file (to avoid dealing with comma line delimiters and colon field delimiters) is CSV. For example,</p>
<pre><code>"DC_Volt","FUNC:VOLT DC"
"DC_Curr","FUNC:CURR DC"
"AC_Volt","FUNC:VOLT AC"
</code></pre>
<p>This would allow you to read into your dictionary as follows:</p>
<pre><code>import csv

my_dict = {}

with open('myfile.csv', 'r') as f:
  for line in csv.reader(f):
    my_dict[line[0]] = line[1]
</code></pre>
<hr/>
<p>EDIT: Like @ShadowRanger suggested, this could be better for JSON than CSV. (It would allow you to keep your key-value format).</p>
<p>The file could look like:</p>
<pre><code>{
  "DC_Volt":"FUNC:VOLT DC",
  "DC_Curr":"FUNC:CURR DC",
  "AC_Volt":"FUNC:VOLT AC"
}
</code></pre>
<p>and you code could be:</p>
<pre><code>import json

with open('myfile.json', 'r') as f:
  j = json.load(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, without changing your existing file, since your keys and values are all legal <code>str</code> literals (assuming those smart quotes were a mistake), you could just let Python do the work using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>ast.literal_eval</code></a> or <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow"><code>json.loads</code></a>:</p>
<pre><code>import ast
import json

with open(myfilename) as f:
    dict_literal_str = '{{ {} }}'.format(f.read())
# With ast
prog_key = ast.literal_eval(dict_literal_str)
# or json
prog_key = json.loads(dict_literal_str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This assumes that all the quotes in the file are an actual <code>"</code> and not those other type of quotes. What this does is read the file, match a regex expression against it and fill the dictionary.</p>
<pre><code>import re

dictionary = {}
file = open(FILE_NAME, "r")
for line in file:
   catched = re.findall("\"(.*)\":\"(.*)\"", line)
   # Only one result which is a tuple
   dictionary[catched[0][0]] = catched[0][1]
file.close()
</code></pre>
</div>
<span class="comment-copy">Are those actually smart quotes (<code>“</code> and <code>”</code>) in there, or are they really straight quotes (<code>"</code>)?</span>
<span class="comment-copy">This sounds more like a use case for classes than for dictionary. Basically a class is a beefed-up dictionary. You can even use inheritance to deal with meters which have some similarities.</span>
<span class="comment-copy">I've edited it, they are supposed to be straight quotes</span>
<span class="comment-copy">Actually, it would be even easier if it's exactly one pair per line: <code>my_dict = dict(csv.reader(f))</code> would do it. No need to initialize to empty <code>dict</code>, no explicit looping in Python.</span>
<span class="comment-copy">Ah, nice little one-liner! Will make a note of that one.</span>
<span class="comment-copy">As soon as I posted this I thought about using a csv instead</span>
<span class="comment-copy">@KierranPurden: Yar, and the <code>csv</code> module wouldn't even require you to change the file format; just configure the <code>csv.reader</code> to use <code>delimiter=':'</code>, possibly with <code>quoting=csv.QUOTE_ALL</code> (may not be needed for reading), and it will work on the original file.</span>
<span class="comment-copy">@ShadowRanger thanks for this. If I use the colon as the delimiter then will it get confused with the colons which are inside quotes? Sorry I'm away from my laptop right now so can't try it (mobile app)</span>
<span class="comment-copy">Why the double curly braces?</span>
<span class="comment-copy">@PeterWood: The <code>format</code> method would otherwise interpret them as format item delimiters; you escape braces by doubling them.</span>
<span class="comment-copy">Ah, I remember now, thanks.</span>
<span class="comment-copy">Reimplementing basic parsing with regexes? Please no. (Also, always use <code>with</code> statements for file objects)</span>
<span class="comment-copy">@ShadowRanger I'm one of those people who likes to reinvent the wheel rather than use the current design of the wheel. On top of that, I think this might even add something to the knowledge to people. Your code is small and simple, yet is not clear to me what it actually does. After all, I'm a beginner :P</span>
<span class="comment-copy">I'm all for <i>learning</i> by reinventing wheels, but reaching for regular expressions isn't really improving things here. In particular, when it comes to parsing known formats, always use a proper parser when available; the edge cases for parsing are ugly, and often impossible or terribly ugly to properly handle with regular expressions (which are either not a context-free grammar, or express context-free grammars poorly). If at all possible, always use an existing parser first, and only resort to regular expressions if none exist and the format is simple enough to avoid major edge cases.</span>
