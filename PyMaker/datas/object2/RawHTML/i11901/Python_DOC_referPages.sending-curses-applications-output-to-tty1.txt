<div class="post-text" itemprop="text">
<h2>Goal</h2>
<p>I'd like to make my curses Python application display its output on a Linux machine's first physical console (TTY1) by adding it to <code>/etc/inittab</code>, reloading init with <code>telinit q</code> and so on.</p>
<p>I'd like to avoid a hacky way of using IO redirection when starting it from <code>/etc/inittab</code> with:</p>
<pre><code>1:2345:respawn:/path/to/app.py &gt; /dev/tty1 &lt; /dev/tty1
</code></pre>
<p>What I'm after is doing it natively from within my app, similar to the way <code>getty</code> does it, i.e. you use a command line argument to tell it on which TTY to listen to:</p>
<pre><code>S0:2345:respawn:/sbin/getty -L ttyS1 115200 vt100
</code></pre>
<h2>Example code</h2>
<p>For simplicity, let's say I've written this very complex app that when invoked, prints some content using ncurses routines.</p>
<pre><code>import curses

class CursesApp(object):

  def __init__(self, stdscr):
    self.stdscr = stdscr
    # Code producing some output, accepting user input, etc.
    # ...    

curses.wrapper(CursesApp)
</code></pre>
<p>The code I already have does everything I need, except that it only shows its output on the terminal it's run from. When invoked from inittab without the hacky redirection I mentioned above, it works but there's no output on TTY1. </p>
<p>I know that init doesn't redirect input and output by itself, so that's expected.</p>
<p>How would I need to modify my existing code to send its output to the requested TTY instead of STDOUT?</p>
<p>PS. I'm not asking how to add support for command line arguments, I already have this but removed it from the code sample for brevity.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is rather simple. Just open the terminal device once for input and once for output; then duplicate the input descriptor to the active process' file descriptor 0, and output descriptor over file descriptors 1 and 2. Then close the other handles to the TTY:</p>
<pre><code>import os
import sys

with open('/dev/tty6', 'rb') as inf, open('/dev/tty6', 'wb') as outf:
    os.dup2(inf.fileno(), 0)
    os.dup2(outf.fileno(), 1)
    os.dup2(outf.fileno(), 2)
</code></pre>
<p>I tested this with the <a href="https://docs.python.org/3/library/cmd.html" rel="nofollow"><code>cmd</code> module</a> running on TTY6:</p>
<pre><code>import cmd
cmd.Cmd().cmdloop()
</code></pre>
<p>Works perfectly. With curses it is apparent from their looks that something is missing: <code>TERM</code> environment variable:</p>
<pre><code>os.environ['TERM'] = 'linux'
</code></pre>
<p>Execute all these statements before even importing <code>curses</code> and it should work.</p>
</div>
<span class="comment-copy">Thank you Antti, this is exactly what I wanted!</span>
