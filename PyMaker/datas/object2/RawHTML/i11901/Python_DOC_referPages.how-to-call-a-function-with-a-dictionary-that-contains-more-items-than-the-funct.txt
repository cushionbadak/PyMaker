<div class="post-text" itemprop="text">
<p>I am looking for the best way to combine a function with a dictionary <em>that contains more items than the function's inputs</em></p>
<p>basic **kwarg unpacking fails in this case:</p>
<pre><code>def foo(a,b):
    return a + b

d = {'a':1,
     'b':2,
     'c':3}

foo(**d)
--&gt; TypeError: foo() got an unexpected keyword argument 'c'
</code></pre>
<p>After some research I came up with the following approach:</p>
<pre><code>import inspect

# utilities
def get_input_names(function):
    '''get arguments names from function'''
    return inspect.getargspec(function)[0]

def filter_dict(dict_,keys):
    return {k:dict_[k] for k in keys}

def combine(function,dict_):
    '''combine a function with a dictionary that may contain more items than the function's inputs '''
    filtered_dict = filter_dict(dict_,get_input_names(function))
    return function(**filtered_dict)

# examples
def foo(a,b):
    return a + b

d = {'a':1,
     'b':2,
     'c':3}

print combine(foo,d)
--&gt; 3
</code></pre>
<p>My question is: is this a good way of dealing with this problem, or is there a better practice or is there a mechanism in the language that I'm missing perhaps?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about <em>making a <a href="http://thecodeship.com/patterns/guide-to-python-function-decorators/">decorator</a></em> that would <em>filter allowed keyword arguments only</em>:</p>
<pre><code>import inspect


def get_input_names(function):
    '''get arguments names from function'''
    return inspect.getargspec(function)[0]


def filter_dict(dict_,keys):
    return {k:dict_[k] for k in keys}


def filter_kwargs(func):
   def func_wrapper(**kwargs):
       return func(**filter_dict(kwargs, get_input_names(func)))
   return func_wrapper


@filter_kwargs
def foo(a,b):
    return a + b


d = {'a':1,
     'b':2,
     'c':3}

print(foo(**d))
</code></pre>
<p>What is nice about this decorator is that it is generic and reusable. And you would not need to change the way you call and use your target functions. </p>
</div>
<div class="post-text" itemprop="text">
<p>All of these answers are wrong.</p>
<p>It is not possible to do what you are asking, because the function might be declared like this:</p>
<pre><code>def foo(**kwargs):
    a = kwargs.pop('a')
    b = kwargs.pop('b')
    if kwargs:
        raise TypeError('Unexpected arguments: %r' % kwargs)
</code></pre>
<p>Now, why on earth would anyone write that?</p>
<p>Because they don't know all of the arguments ahead of time.  Here's a more realistic case:</p>
<pre><code>def __init__(self, **kwargs):
    for name in self.known_arguments():
        value = kwargs.pop(name, default)
        self.do_something(name, value)
    super().__init__(**kwargs)  # The superclass does not take any arguments
</code></pre>
<p>And <a href="https://bitbucket.org/NYKevin/nbtparse/src/276f94bc309addbd81b2d87d94b273eac5e6dbf7/nbtparse/semantics/nbtobject.py?at=%40&amp;fileviewer=file-view-default#nbtobject.py-140">here</a> is some real-world code which actually does this.</p>
<p>You might ask why we need the last line.  Why pass arguments to a superclass that doesn't take any?  <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Cooperative multiple inheritance</a>.  If my class gets an argument it does not recognize, it should not swallow that argument, nor should it error out.  It should pass the argument up the chain so that another class I might not know about can handle it.  And if nobody handles it, then <code>object.__init__()</code> will provide an appropriate error message.  Unfortunately, the other answers will not handle that gracefully.  They will see <code>**kwargs</code> and either pass no arguments or pass all of them, which are both incorrect.</p>
<p><strong>The bottom line</strong>: There is no general way to discover whether a function call is legal without actually making that function call.  <code>inspect</code> is a crude approximation, and entirely falls apart in the face of variadic functions.  Variadic does not mean "pass whatever you like"; it means "the rules are too complex to express in a signature."  As a result, while it may be possible in many cases to do what you're trying to do, there will always be situations where there is no correct answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem lies with the way you defined your function, it should be defined like this - </p>
<pre><code>def foo(**kwargs):
</code></pre>
<p>And then inside the function you can iterate over the number of arguments sent to the function like so - </p>
<pre><code>if kwargs is not None:
        for key, value in kwargs.iteritems():
                do something
</code></pre>
<p>You can find more info about using **kwargs in this post - 
<a href="http://pythontips.com/2013/08/04/args-and-kwargs-in-python-explained/" rel="noreferrer">http://pythontips.com/2013/08/04/args-and-kwargs-in-python-explained/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use a <a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">decorator function</a> to filter out those <em>keyword arguments</em> that are not allowed in you function. Of you use the <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>signature</code></a> function new in 3.3 to return your function <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer"><code>Signature</code></a></p>
<pre><code>from inspect import signature
from functools import wraps


def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        sig = signature(func)
        result = func(*[kwargs[param] for param in sig.parameters])
        return result
    return wrapper
</code></pre>
<p>From Python 3.0 you can use <a href="https://docs.python.org/3/library/inspect.html#inspect.getargspec" rel="nofollow noreferrer"><code>getargspec</code></a> which is <em>deprecated since version 3.0</em></p>
<pre><code>import inspect


def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        argspec = inspect.getargspec(func).args
        result = func(*[kwargs[param] for param in argspec])
            return result
    return wrapper
</code></pre>
<p>To apply your <em>decorate</em> an existing function you need to pass your function as argument to your decorator:</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def foo(a, b):
...     return a + b
... 
&gt;&gt;&gt; foo = decorator(foo)
&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; foo(**d)
3
</code></pre>
<p>To apply your decorator to a newly function simply use <code>@</code></p>
<pre><code>&gt;&gt;&gt; @decorator
... def foo(a, b):
...     return a + b
... 
&gt;&gt;&gt; foo(**d)
3
</code></pre>
<hr/>
<p>You can also define your function using  arbitrary keywords arguments <code>**kwargs</code>.</p>
<pre><code>&gt;&gt;&gt; def foo(**kwargs):
...     if 'a' in kwargs and 'b' in kwargs:
...         return kwargs['a'] + kwargs['b']
... 
&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; foo(**d)
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would do something like this:</p>
<pre><code>def combine(function, dictionary):
    return function(**{key:value for key, value in dictionary.items()
                    if key in inspect.getargspec(function)[0]}
    )
</code></pre>
<p>Use:</p>
<pre><code>&gt;&gt;&gt; def this(a, b, c=5):
...     print(a, b, c)
...
&gt;&gt;&gt; combine(this, {'a': 4, 'b': 6, 'c': 6, 'd': 8})
4 6 6
&gt;&gt;&gt; combine(this, {'a': 6, 'b': 5, 'd': 8})
6 5 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is still modifying the original function, but you can create a kwargs bitbucket at the end of the argument list:</p>
<pre><code>def foo(a, b, **kwargs):
    return a + b

foo(**{
    'a': 5,
    'b': 8,
    'c': 'üêò'
}) # 13
</code></pre>
</div>
<span class="comment-copy">Thanks Kevin! I accepted alecxe's answer in the end because it was most directly helpful for my situation, however i found yours a very interesting read too, and I agree it's essential to realize that there are important scenarios to consider where the 'filter kwargs' approach will not work.</span>
<span class="comment-copy">Thanks. I should have mentioned perhaps that I'm building a framework for a program where other people (sometimes relative novices in python) are creating the functions. Hence, I'd prefer them not having to deal with the **kwargs , but rather them using basic function inputs: foo(a,b); I'd like to hide this **kwargs filtering complexity in utility functions.</span>
