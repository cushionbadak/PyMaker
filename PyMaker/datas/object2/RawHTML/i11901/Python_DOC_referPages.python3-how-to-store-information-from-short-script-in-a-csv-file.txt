<div class="post-text" itemprop="text">
<p>I have a script that searches Google for Lil Wayne articles, and then -- for each article -- returns title, summary, url, and keywords. </p>
<p>But I would really like to make a CSV file that had TITLE, SUMMARY, URL, KEYWORDS as columns and then stored the relevant information for each article in each row. </p>
<pre><code>from newspaper import Article 
import google 

#Search Setup
for url in google.search('Lil Wayne', num=10, stop=3, pause=0):
    article = Article(url)      
    article.download() 
    article.parse()
    article.nlp()     


    #Print the parsed output of each article
    print(u'TITLE: ' + str(article.title.encode('ascii', 'ignore')))
    print(u'SUMMARY: ' + str(article.summary.encode('ascii', 'ignore')))
    print(u'URL: ' + str(article.url))
    print(u'KEYWORDS: ' + str(article.keywords)) 
    print("\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use something like this in your code:</p>
<pre><code>from newspaper import Article 
import google 

with open('output_file.csv', 'wb') as csvfile:
    lil_wayne_writer = csv.writer(csvfile)

    #Search Setup
    for url in google.search('Lil Wayne', num=10, stop=3, pause=0):
        article = Article(url)      
        article.download() 
        article.parse()
        article.nlp()
        lil_wayne_writer.writerow(
            [
                str(article.title.encode('ascii', 'ignore')),
                str(article.summary.encode('ascii', 'ignore')),
                str(article.url),
                str(article.keywords),
            ]
        )
</code></pre>
<p>This basically opens a csv writer, then writes each row as you find an article. There is more info about csv writers <a href="https://docs.python.org/2/library/csv.html" rel="nofollow">in the python docs</a></p>
<p>You might need to edit it a little to work properly in your environment.</p>
<p>If you would like to write the headers into your CSV file, simply add a single call to something like this:</p>
<pre><code>lil_wayne_writer.writerow(['TITLE', 'SUMMARY', 'URL', 'KEYWORDS'])
</code></pre>
</div>
<span class="comment-copy">Is this actually Python 3? Python 3 wouldn't need the <code>u</code> prefix on text string literals, and <code>str(article.title.encode('ascii', 'ignore'))</code> would behave funny (<code>str</code> would return the <code>repr</code> of the <code>bytes</code> object <code>encode</code> returns).</span>
<span class="comment-copy">In any event, I strongly suggest you actually check the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module docs</a>; this is mostly boilerplate, and the examples there should get you started.</span>
<span class="comment-copy">Hi,   Yeah I originally wrote this in python 2 and I am pretty sure I messed up the decoding.   I eventually get the following error:  <code>UnicodeDecodeError: 'utf-8' codec can't decode byte 0x81 in position 170: invalid start byte</code>  Do you know what's up with that?</span>
<span class="comment-copy">Without a traceback, I can't tell you specifically. If the goal is to write <code>csv</code> that might contain non-ASCII text though, stop trying to do this in Python 2, and use Python 3 instead. You won't need to call <code>decode</code> at all, the <code>csv</code> module will handle the full Unicode range without a problem (you can store the original text, instead of dropping data on the floor like <code>decode</code> with <code>errorhandler</code> <code>"ignore"</code> does). Worst case scenario, you'd need to explicitly pass <code>encoding='utf-8'</code> or the like to the <code>open</code> function, so it uses an encoding that can represent the whole Unicode range.</span>
<span class="comment-copy">Basically, if you need to handle non-ASCII text, Python 3 is better, and if it's non-ASCII CSV, the Py2 <code>csv</code> module is a royal pain, and writing portable code is going to be a headache; target Py3 and be done with it.</span>
<span class="comment-copy">Assuming this is really Py3, you'd want to <code>decode</code> back to <code>str</code> (or pass a second argument to the <code>str</code> constructor); otherwise, you get the <code>repr</code> of the <code>bytes</code> object. So <code>str(article.title.encode('ascii', 'ignore')),</code> would become either <code>str(article.title.encode('ascii', 'ignore'), 'ascii'),</code> or <code>article.title.encode('ascii', 'ignore').decode('ascii'),</code>. Also, you need to open the output file with <code>open('output_file.csv', 'w', newline='')</code> not <code>'wb'</code> without <code>newline</code>; the Py3 <code>csv</code> module is <code>str</code> based, not bytes based.</span>
<span class="comment-copy">Thanks @ShadowRanger - I'll add those options to my research list to improve my Python3 chops :).</span>
