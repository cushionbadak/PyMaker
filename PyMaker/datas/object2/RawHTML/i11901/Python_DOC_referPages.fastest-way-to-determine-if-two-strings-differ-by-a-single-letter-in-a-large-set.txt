<div class="post-text" itemprop="text">
<p>I am trying to compare two strings and add one of the strings to a list if they are almost equal (differ by a single letter). What would be the fastest way to do this as my set of words is over 90k and doing this often takes too long?</p>
<p>EDIT: one of the words (comparison_word in code below) does not change.</p>
<p>EDIT2: the words must be of equal length</p>
<p>This is my current code:</p>
<pre><code>    for word in set_of_words:
        amount = 0  
        if len(word) == len(comparison_word):
            for i in range(len(word)):
                if comparison_word[i] != word[i]:
                    amount += 1
            if amount == 1:
                list_of_words.append(word)
    return list_of_words
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following searches my dictionary of 61K words in about 25 msec.  </p>
<pre><code>import re

def search(word, text):
    ws = [r'\b{}[^{}]{}\b'.format(w[:i],w[i],w[i+1:]) for i in range(len(word))]

    for mo in re.finditer('|'.join(ws), text):
        yield mo.group()

with open("/12dicts/5desk.txt") as f:
    text = f.read()

for hit in search('zealoos', text):
    print(hit)                         #prints zealous
</code></pre>
<p>Presuming that the list of strings is in a file, one string per line, read it in as one long string and use a regular expression to search the string for matches.</p>
<p><code>search()</code> takes a word like 'what' and turns it into a regular expression like this:</p>
<pre><code>\b[^w]hat\b|\bw[^h]at\b|\bwh[^a]t\b|\bwha[^t]\b
</code></pre>
<p>And then scans all the words and find all the near misses--at C-speed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might find zip is a more efficient than indexing:</p>
<pre><code>def almost_equal(set_of_words,comp):
    ln = len(comp)
    for word in set_of_words:
        count = 0
        if len(word) == ln:
            for a, b in zip(word, comp):
                count += a != b
                if count == 2:
                    break
            else:
                yield word
</code></pre>
<p>Demo:</p>
<pre><code>In [5]: list(almost_equal(["foo","bar","foob","foe"],"foa"))
Out[5]: ['foo', 'foe']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The idea is to reduce the amount of work being done:</p>
<pre><code>n_comparison_word = len(comparison_word)
for word in set_of_words:
    amount = 0
    n_word = len(word)
    if n_word != n_comparison_word:
        continue
    for i in range(n_word):
        if comparison_word[i] != word[i]:
            amount += 1
        if amount == 2:
            break
    if amount == 1:
        list_of_words.append(word)
return list_of_words
</code></pre>
<p>Some notes:</p>
<ul>
<li>The value of <code>len(comparison_word)</code> needs to be computed only once (ever).</li>
<li>The value of <code>len(word)</code> needs to computed once (per iteration of the loop).</li>
<li>You know you can stop looking at a word when <code>amount</code> reaches the value 2 (or more - in any case that word can no longer be part of the result).</li>
</ul>
<p>It may be worth reading <a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" rel="nofollow">this part of the Python documentation</a> regarding the <code>continue</code> and <code>break</code> statements which are both used in the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Haven't done exhaustive testing, but if <code>comparison_word</code> is not too long (fewer than 6 letters), and your <code>set_of_words</code> can change, then it might be worth it to compute all acceptable words, store those in a set, a simply iterate through <code>set_of_words</code> and test for <code>word in acceptable_words</code>. </p>
<p>If not, here's my take on your code:</p>
<pre><code>for word in set_of_words:
  different_letter_exists = False
  length = len(word)
  if length == len(comparison_word):
    for i, letter in enumerate(word):
        if letter != comparison_word[i]:
            if different_letter_exists:
                break
            else:
                different_letter_exists = True
    if i == length:
        list_of_words.append(word)
</code></pre>
<p>Essentially: for every word, once you encounter an different letter, <code>different_letter_exists</code> is set to True. If you encounter it again, you break out of the loop. A new word is only added if <code>i == length</code>, which only happens if <code>enumerate</code> gets all the way to the end, which only happens if only one different letter exists. </p>
<p>Good luck :)</p>
</div>
<span class="comment-copy">What about <code>foo</code> and <code>fo</code>?</span>
<span class="comment-copy">How does your 'set of words' change?</span>
<span class="comment-copy">This, along with <a href="http://stackoverflow.com/a/36208085/3566755">this solution</a> brought my average time down to 28 seconds from 40 seconds</span>
<span class="comment-copy">appending to a list may be very slightly faster</span>
<span class="comment-copy">I think they are trying to compare all the words with each other. So I imagine the first step would be to create a dictionary of words lengths where each hash held a list of unique words.</span>
<span class="comment-copy">This brought my average time down to 30 seconds from 40 seconds</span>
