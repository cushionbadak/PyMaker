<div class="post-text" itemprop="text">
<p>I have a list l of lists <code>[l1, ..., ln]</code> of equal length</p>
<p>I want to compare the <code>l1[k], l2[k], ..., ln[k]</code> for all <code>k</code> in <code>len(l1)</code> and make another list <code>l0</code> by picking the element that appears most frequently.</p>
<p>So, if <code>l1 = [1, 2, 3]</code>, <code>l2 = [1, 4, 4]</code> and <code>l3 = [0, 2, 4]</code>, then <code>l = [1, 2, 4]</code>. If there is a tie, I will look at the lists that make up the tie and choose the one in the list with higher priority. Priority is given a priori, each list is given a priority.
Ex. if you have value 1 in lists <code>l1</code> and <code>l3</code>, and value 2 in lists <code>l2</code> and <code>l4</code>, and 3 in <code>l5</code>, and lists are ordered according to priority, say <code>l5&gt;l2&gt;l3&gt;l1&gt;l4</code>, then I will pick 2, because 2 is in <code>l2</code> that contains an element with highest occurrence and its priority is higher than <code>l1</code> and <code>l3</code>.</p>
<p>How do I do this in python without creating a for loop with lots of if/else conditions?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the Counter module from the collections library.  Using the <code>map</code> function will reduce your list looping.  You will need an if/else statement for the case that there is no most frequent value but only for that:</p>
<pre><code>import collections

list0 = []
list_length = len(your_lists[0])
for k in list_length:
    k_vals = map(lambda x: x[k], your_lists) #collect all values at k pos
    counts = collections.Counter(k_vals).most_common() #tuples (val,ct) sorted by count
    if counts[0][1] &gt; counts[1][1]: #is there a most common value
        list0.append(counts[0][0]) #takes the value with highest count
    else:
        list0.append(k_vals[0]) #takes element from first list
</code></pre>
<p><code>list0</code> is the answer you are looking for.  I just hate using <code>l</code> because it's easy to confuse with the number <code>1</code> </p>
<p><strong>Edit</strong> (based on comments):<br/>
Incorporating your comments, instead of the if/else statement, use a while loop: </p>
<pre><code>i = list_length
while counts[0][1] == counts[1][1]:
    counts = collections.Counter(k_vals[:i]).most_common() #ignore the lowest priority element
    i -= 1 #go back farther if there's still a tie
list0.append(counts[0][0]) #takes the value with highest count once there's no tie
</code></pre>
<p>So the whole thing is now:</p>
<pre><code>import collections

list0 = []
list_length = len(your_lists[0])
for k in list_length:
    k_vals = map(lambda x: x[k], your_lists) #collect all values at k pos
    counts = collections.Counter(k_vals).most_common() #tuples (val,ct) sorted by count
    i = list_length
    while counts[0][1] == counts[1][1]: #in case of a tie
        counts = collections.Counter(k_vals[:i]).most_common() #ignore the lowest priority element
        i -= 1 #go back farther if there's still a tie
    list0.append(counts[0][0]) #takes the value with highest count
</code></pre>
<p>You throw in one more tiny loop but on the bright side there's no if/else statements at all!</p>
</div>
<div class="post-text" itemprop="text">
<p>Just transpose the sublists and get the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter.most_common</code></a> element key from each group:</p>
<pre><code>from collections import Counter


lists = [[1, 2, 3],[1, 4, 4],[0, 2, 4]]

print([Counter(sub).most_common(1)[0][0] for sub in zip(*lists)])
</code></pre>
<p>If they are individual lists just zip those:</p>
<pre><code>l1, l2, l3 = [1, 2, 3], [1, 4, 4], [0, 2, 4]

print([Counter(sub).most_common(1)[0][0] for sub in zip(l1,l2,l3)])
</code></pre>
<p>Not sure how taking the first element from the grouping if there is a tie makes sense as it may not be the one that tied but that is trivial to implement, just get the two most_common and check if their counts are equal:</p>
<pre><code>def most_cm(lists):
    for sub in zip(*lists):      
        # get two most frequent 
        comm = Counter(sub).most_common(2)
        # if their values are equal just return the ele from l1
        yield comm[0][0] if len(comm) == 1 or comm[0][1] != comm[1][1] else sub[0]
</code></pre>
<p>We also need <code>if len(comm) == 1</code> in case all the elements are the same or we will get an IndexError.</p>
<p>If you are talking about taking the element that comes from the earlier list in the event of a tie i.e l2 comes before l5 then that is just the same as taking any of the elements that tie.</p>
<p>For a decent number of sublists:</p>
<pre><code>In [61]: lis = [[randint(1,10000) for _ in range(10)] for _ in range(100000)]

In [62]: list(most_cm(lis))
Out[62]: [5856, 9104, 1245, 4304, 829, 8214, 9496, 9182, 8233, 7482]

In [63]: timeit list(most_cm(lis))
1 loops, best of 3: 249 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Solution is:</p>
<pre><code>a = [1, 2, 3]
b = [1, 4, 4]
c = [0, 2, 4]

print [max(set(element), key=element.count) for element in zip(a, b, c)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That's what you're looking for:</p>
<pre><code>from collections import Counter
from operator import itemgetter

l0 = [max(Counter(li).items(), key=itemgetter(1))[0] for li in zip(*l)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are OK taking any one of a set of elements that are tied as most common, and you can guarantee that you won't hit an empty list within your list of lists, then here is a way using <code>Counter</code> (so, <code>from collections import Counter</code>):</p>
<pre><code>l = [ [1, 0, 2, 3, 4, 7, 8],
      [2, 0, 2, 1, 0, 7, 1],
      [2, 0, 1, 4, 0, 1, 8]]

res = []

for k in range(len(l[0])):
    res.append(Counter(lst[k] for lst in l).most_common()[0][0])
</code></pre>
<p>Doing this in IPython and printing the result:</p>
<pre><code>In [86]: res
Out[86]: [2, 0, 2, 1, 0, 7, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>l1 = [1,2,3]
l2 = [1,4,4]
l3 = [0,2,4]

lists = [l1, l2, l3]

print [max(set(x), key=x.count) for x in zip(*lists)]
</code></pre>
</div>
<span class="comment-copy">What have you tried so far? Please post an <a href="http://stackoverflow.com/help/mcve">MCEV</a> if possible.</span>
<span class="comment-copy">@Gabriel I had implemented a loop with if/else but that quickly looked like a bad idea</span>
<span class="comment-copy">What if there is a tie?  Are all the lists the same length?  Do you only want to compare the same indexes?</span>
<span class="comment-copy">Same length. The lists have a priority associated with them, so, if there is a tie, I will look at the lists that make up the tie and choose the one with higher priority</span>
<span class="comment-copy">@user, how is the priority calculated?</span>
<span class="comment-copy">I think it may crash if all values are the same, as there won't be a counts[1][1]</span>
<span class="comment-copy">map with a lambda is also going to way  slower than zipping</span>
