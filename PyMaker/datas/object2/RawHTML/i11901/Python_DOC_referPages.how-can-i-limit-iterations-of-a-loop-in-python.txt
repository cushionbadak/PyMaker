<div class="post-text" itemprop="text">
<p>Say I have a list of items, and I want to iterate over the first few of it:</p>
<pre><code>items = list(range(10)) # I mean this to represent any kind of iterable.
limit = 5
</code></pre>
<h2>Naive implementation</h2>
<p>The Python na√Øf coming from other languages would probably write this perfectly serviceable and performant (if unidiomatic) code:</p>
<pre><code>index = 0
for item in items: # Python's `for` loop is a for-each.
    print(item)    # or whatever function of that item.
    index += 1
    if index == limit:
        break
</code></pre>
<h2>More idiomatic implementation</h2>
<p>But Python has enumerate, which subsumes about half of that code nicely:</p>
<pre><code>for index, item in enumerate(items):
    print(item)
    if index == limit: # There's gotta be a better way.
        break
</code></pre>
<p>So we've about cut the extra code in half. But there's gotta be a better way.</p>
<h1>Can we approximate the below pseudocode behavior?</h1>
<p>If enumerate took another optional <code>stop</code> argument (for example, it takes a <code>start</code> argument like this: <code>enumerate(items, start=1)</code>) that would, I think, be ideal, but the below doesn't exist (see the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="noreferrer">documentation on enumerate here</a>):</p>
<pre><code># hypothetical code, not implemented:
for _, item in enumerate(items, start=0, stop=limit): # `stop` not implemented
    print(item)
</code></pre>
<p>Note that there would be no need to name the <code>index</code> because there is no need to reference it.</p>
<p>Is there an idiomatic way to write the above? How?</p>
<p>A secondary question: why isn't this built into enumerate?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>How can I limit iterations of a loop in Python?</h1>
<pre><code>for index, item in enumerate(items):
    print(item)
    if index == limit:
        break
</code></pre>
<p>Is there a shorter, idiomatic way to write the above? How?</p>
</blockquote>
<h2>Including the index</h2>
<p><code>zip</code> stops on the shortest iterable of its arguments. (In contrast with the behavior of <code>zip_longest</code>, which uses the longest iterable.)</p>
<p><code>range</code> can provide a limited iterable that we can pass to zip along with our primary iterable.</p>
<p>So we can pass a <code>range</code> object (with its <code>stop</code> argument) to <code>zip</code> and use it like a limited enumerate.</p>
<h2><code>zip(range(limit), items)</code></h2>
<p>Using Python 3, <code>zip</code> and <code>range</code> return iterables, which pipeline the data instead of materializing the data in lists for intermediate steps.</p>
<pre><code>for index, item in zip(range(limit), items):
    print(index, item)
</code></pre>
<p>To get the same behavior in Python 2, just substitute <code>xrange</code> for <code>range</code> and <code>itertools.izip</code> for <code>zip</code>.</p>
<pre><code>from itertools import izip
for index, item in izip(xrange(limit), items):
    print(item)
</code></pre>
<h2>If not requiring the index, <code>itertools.islice</code></h2>
<p>You can use <code>itertools.islice</code>:</p>
<pre><code>for item in itertools.islice(items, 0, stop):
    print(item)
</code></pre>
<p>which doesn't require assigning to the index.</p>
<h2>Composing <code>enumerate(islice(items, stop))</code> to get the index</h2>
<p>As Pablo Ruiz Ruiz points out, we can also compose islice with enumerate.</p>
<pre><code>for index, item in enumerate(islice(items, limit)):
    print(index, item)
</code></pre>
<blockquote>
<h1>Why isn't this built into <code>enumerate</code>?</h1>
</blockquote>
<p>Here's enumerate implemented in pure Python (with possible modifications to get the desired behavior in comments):</p>
<pre><code>def enumerate(collection, start=0):  # could add stop=None
    i = start
    it = iter(collection)
    while 1:                         # could modify to `while i != stop:`
        yield (i, next(it))
        i += 1
</code></pre>
<p>The above would be less performant for those using enumerate already, because it would have to check whether it is time to stop every iteration. We can just check and use the old enumerate if don't get a stop argument:</p>
<pre><code>_enumerate = enumerate

def enumerate(collection, start=0, stop=None):
    if stop is not None:
        return zip(range(start, stop), collection)
    return _enumerate(collection, start)
</code></pre>
<p>This extra check would have a slight negligible performance impact.</p>
<p>As to <em>why</em> enumerate does not have a stop argument, this was originally proposed (see <a href="https://www.python.org/dev/peps/pep-0279/" rel="noreferrer">PEP 279</a>):</p>
<blockquote>
<p>This function was originally proposed with optional start
      and stop arguments.  GvR [Guido van Rossum] pointed out that the function call
      <code>enumerate(seqn, 4, 6)</code> had an alternate, plausible interpretation as
      a slice that would return the fourth and fifth elements of the
      sequence.  To avoid the ambiguity, the optional arguments were
      dropped even though it meant losing flexibility as a loop counter.
      That flexibility was most important for the common case of
      counting from one, as in:</p>
<pre><code>for linenum, line in enumerate(source,1):  print linenum, line
</code></pre>
</blockquote>
<p>So apparently <code>start</code> was kept because it was very valuable, and <code>stop</code> was dropped because it had fewer use-cases and contributed to confusion on the usage of the new function.</p>
<h2>Avoid slicing with subscript notation</h2>
<p>Another answer says:</p>
<blockquote>
<p>Why not simply use</p>
<pre><code>for item in items[:limit]: # or limit+1, depends
</code></pre>
</blockquote>
<p>Here's a few downsides:</p>
<ul>
<li>It only works for iterables that accept slicing, thus it is more limited.</li>
<li>If they do accept slicing, it usually creates a new data structure in memory, instead of iterating over the reference data structure, thus it wastes memory (All builtin objects make copies when sliced, but, for example, numpy arrays make a view when sliced).</li>
<li>Unsliceable iterables would require the other kind of handling. If you switch to a lazy evaluation model, you'll have to change the code with slicing as well.</li>
</ul>
<p>You should only use slicing with subscript notation when you understand the limitations and whether it makes a copy or a view.</p>
<h1>Conclusion</h1>
<p>I would presume that now the Python community knows the usage of enumerate, the confusion costs would be outweighed by the value of the argument.</p>
<p>Until that time, you can use:</p>
<pre><code>for index, element in zip(range(limit), items):
    ...
</code></pre>
<p>or</p>
<pre><code>for index, item in enumerate(islice(items, limit)):
    ...
</code></pre>
<p>or, if you don't need the index at all:</p>
<pre><code>for element in islice(items, 0, limit):
    ...
</code></pre>
<p>And avoid slicing with subscript notation, unless you understand the limitations.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/itertools.html#itertools.islice"><code>itertools.islice</code></a> for this. It accepts <code>start</code>, <code>stop</code> and <code>step</code> arguments, if you're passing only one argument then it is considered as <code>stop</code>. And it will work with any iterable.</p>
<pre><code>itertools.islice(iterable, stop)
itertools.islice(iterable, start, stop[, step])
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; items = list(range(10))
&gt;&gt;&gt; limit = 5
&gt;&gt;&gt; for item in islice(items, limit):
    print item,
...
0 1 2 3 4
</code></pre>
<p>Example from docs:</p>
<pre><code>islice('ABCDEFG', 2) --&gt; A B
islice('ABCDEFG', 2, 4) --&gt; C D
islice('ABCDEFG', 2, None) --&gt; C D E F G
islice('ABCDEFG', 0, None, 2) --&gt; A C E G
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not simply use</p>
<pre><code>for item in items[:limit]: # or limit+1, depends
    print(item)    # or whatever function of that item.
</code></pre>
<p>This will only work for some iterables, but since you specified Lists, it works.</p>
<p>It doesn't work if you use Sets or dicts etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pass islice with the limit inside enumerate</p>
<pre><code>a = [2,3,4,2,1,4]

for a, v in enumerate(islice(a, 3)): 
   print(a, v)
</code></pre>
<p>Output:</p>
<pre><code>0 2
1 3
2 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not loop until the limit or the end of list, whichever occurs earlier, like this:</p>
<pre><code>items = range(10)
limit = 5
for i in range(min(limit, len(items))):
  print items[i]
</code></pre>
<p>Output:</p>
<pre><code>0
1
2
3
4
</code></pre>
</div>
<span class="comment-copy">what about codeforester's answer below? is there downside?</span>
<span class="comment-copy">This's the most elegant way to limit iterations of generators! Also, you can specify <code>islice(generator, None)</code> to get all iterations - this's useful if you'd like to limit iterations depending on some condition</span>
<span class="comment-copy">Yeah, lists, tuples, and range objects take slices, but it leaves out a lot, like iterators, sets, and generators. Another downside is that it makes a new data structure, like a list or tuple, instead of lazily evaluating the data.</span>
