<div class="post-text" itemprop="text">
<pre><code>a=[1,10]
b=[2,20]
h=[]
heapq.heappush(h,a)
heapq.heappush(h,b)
a[0]=5
heapq.heappop(h)
</code></pre>
<p>pops [5,10] instead of [2,20]</p>
<p>If I have used heapq.heapify(h) before popping up, it gives correct answer : i.e [2,20]
Is it always required to heapify the list before popping in case you have changed any of the list values?</p>
</div>
<div class="post-text" itemprop="text">
<p>When using <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow">heapq</a>, <code>list.sort()</code> or any other sorting module like <a href="https://pypi.python.org/pypi/sortedcontainers" rel="nofollow">sortedcontainers</a>, modifying a mutable item such as a list will cause the internal sorting to be disrupted. Usage of tuples in that case is recommended as it will prevent accidental corruption of the sort.</p>
<p>When using <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow">heapq</a> or <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow">bisect</a>, the module thinks the list is already sorted and the algorithm used works only on sorted lists. Modifying the sorted list will break the algorithm and produce unexpected results.</p>
<p>If you change a mutable object, you must re-sort the list if you want it to function correctly. <code>heapq.heapify()</code> is indeed the way to sort it if you're using <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow">heapq</a>.</p>
</div>
