<div class="post-text" itemprop="text">
<p>I have events that have occurred on specific dates e.g:</p>
<pre><code>[{'date_event': datetime.date(2001, 1, 1), 'event_name': 'event_1'},
 {'date_event': datetime.date(2001, 10, 1), 'event_name': 'event_2'}]
</code></pre>
<p>I am looking for a data structure in Python to store this information in such a way that I can easily retrieve events that occur between specific dates. In essence, I want to be able to query a data structure and return events that occurred between two dates. e.g.:</p>
<pre><code> def return_events_between_dates(start_date, end_date):
     ...
     return(list_of_events)
</code></pre>
<p>Is there a builtin structure in Python which easily allows this? I am not looking to re-invent the wheel if there is already something which is optimized for this sort of query. If not, would list-comprehension be the best approach?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>No,</strong> there's no simple built-in structure that would do this in an optimized way.</p>
<p><strong>However,</strong> the standard library module <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code></a> provides functions for working with sorted lists in a more optimized way than list comprehensions would. You can use this to accomplish your task; it just takes a little work and care.</p>
<p>Unfortunately, they don't take a key function as an argument, like <code>list.sort()</code> does. So to use the <code>bisect</code> functions you need to preprocess your event objects into things that are comparable, and will compare primarily based on their dates. Tuples can be nice for this:</p>
<pre><code>preprocessed_events = [(e['date_event'], e['event_name']) for e in events]
preprocessed_events.sort()
</code></pre>
<p>Now you can use <code>bisect_left()</code> and <code>bisect_right()</code> to get the indices of your sorted list where the events you want begin and end (assuming your endpoints are both inclusive):</p>
<pre><code>index_first = bisect.bisect_left(preprocessed_events, (start_date,))
index_last = bisect.bisect_right(preprocessed_events, (end_date,))
</code></pre>
<p>Note that you have to turn <code>start_date</code> and <code>end_date</code> into tuples to be comparable with the tuples in the sorted list.</p>
<p>Knowing the start and end indices, you can get a list of all the events with a slice of the sorted list, and if need be convert them back into whatever form you want to return them in.</p>
<p>Don't forget to check your slice indices, and your choices of <code>bisect_left()</code> and <code>bisect_right()</code>, to make sure you're including/excluding the endpoints you want to include/exclude. Especially in the case where you have multiple events on the same date as your <code>start_date</code> or <code>end_date</code>.</p>
</div>
<span class="comment-copy">From where you want to retrieve data, that must be allow you date comparison, like if you use <code>DJango</code> date field, then it will allow date comparison</span>
<span class="comment-copy">@DanGetz - thanks - yeh, that was what i meant - and thanks for the answer - this is was exactly the sort of thing i was hoping for.</span>
