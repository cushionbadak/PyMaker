<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/mmap.html#module-mmap" rel="nofollow noreferrer">Memory mapped file</a> is an efficient way for using regex or doing manipulation on large binary files.</p>
<p>In case I have a large text file (~1GB), is it possible to work with an encoding-aware mapped file?<br/>
Regex like <code>[\u1234-\u5678]</code> won't work on <code>bytes</code> objects and converting the pattern to unicode will not work either (as <code>"[\u1234-\u5678]".encode("utf-32")</code>  for example will not understand the range correctly).<br/>
Searching might work if I convert the search pattern from <code>str</code> to <code>bytes</code> using <code>.encode()</code> but it's still somewhat limited and there should be a simpler way instead of decoding and encoding all day.</p>
<p>I have tried wrapping it with <code>io.TextIOWrapper</code> inside an <code>io.BufferedRandom</code> but to no avail:</p>
<pre><code>AttributeError: 'mmap.mmap' object has no attribute 'seekable'
</code></pre>
<p>Creating a wrapper (using inheritance) and setting the methods <code>seekable</code>, <code>readable</code> and <code>writable</code> to return <code>True</code> did not work either.</p>
<p>Regarding encoding, a fixed length encoding like <code>utf-32</code>, code-points or the lower BMP of <code>utf-16</code> (if it's even possible referring just to that part) might be assumed.</p>
<p>Solution is welcome for any python version.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't do this without essentially reinventing the wheel from scratch (writing all new versions of the <code>re</code> module, the <code>mmap</code> module, etc.), or writing extraordinarily complex regexes that can't use the niceties of stuff like true Unicode character ranges (you'd have an alternation between three different patterns to make <code>[\u1234-\u5678]</code>, something like <code>(?:\x12[\x34-\xff]|[\x13-\x55].|\x56[\x00-\x78])</code>).</p>
<p>Basically, <code>re</code> patterns only work with <code>str</code>, or work with <code>bytes</code>-like objects (and you can't try to work around it with <code>memoryview</code>s and casts, because <code>re</code> still treats it as bytes, not larger types).</p>
<p>For simple searches, you could try using <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow"><code>mmap.find</code></a> after encoding the string to use for searching, but that's still prone to subtle bugs; for UCS-2 or UTF-32, you'd need to check that the return value from <code>find</code> was aligned on a two or four byte boundary respectively to ensure you didn't mistake the end of one character and the beginning of the next for a completely different character. If the alignment test failed, you'd have to repeat the search with a <code>start</code> offset of the last return value + 1 until you either got a hit or <code>find</code> returned <code>-1</code>. It's just not a reasonable thing to do in the general case.</p>
</div>
<span class="comment-copy">With variable-length encodings like UTF-8, there's no way to tell where character 50000 is without going through the 49999 characters before it, defeating the purpose of memory-mapping. You might find something that works for fixed-length encodings.</span>
<span class="comment-copy">@user2357112 Thought it might pose a problem but for the sake of the question, a fixed length like <code>utf-16</code>, <code>utf-32</code> or code-points might be assumed.</span>
<span class="comment-copy">UTF-16 is still variable-length, and in any case, it's the encoding of the file that's the issue, not the encoding of the pattern.</span>
<span class="comment-copy">@user2357112 updated to specify <code>utf-32</code> or the lower BMP of <code>utf-16</code> if it's even possible referring just to that part. And yes, the encoding of the file is indeed the issue.</span>
<span class="comment-copy">The regex should be <code>(?:\x12[\x34-\xff]|[\x13-\x55].)|(?:\x56[\x00-\x78])</code> btw.</span>
<span class="comment-copy">@Bharel: That pattern you gave would be equivalent to <code>[\u1234-\u55ff][\u5600-\u5678]</code> wouldn't it? Two different classes for different ranges, not one class covering the whole range. Of course, it would still only work if the data was big endian UCS-2; you'd have to flip the contents of each alternation if it were little endian.</span>
<span class="comment-copy">My bad, It will just be the same. I also forgot the endian-ness. What a mess. Anyway, it sounds rather unfortunate if you're correct regarding the fact it doesn't exist but I'll be waiting for another answer. I believe I'm not the first who thought of using mmap on text files (or at least I hope I'm not). If non arise in a reasonable time I'll <i>accept</i> this answer as my fate.</span>
<span class="comment-copy">@Bharel: You're not the first to think of it, because I know I tried to figure out if this was possible a couple years back. :-) I tried a ton of approaches, but <code>mmap</code>s can't do multi-byte, <code>memoryview</code>s, even <code>cast</code> to different sizes, still act like <code>bytes</code> with <code>re</code> <code>bytes</code> patterns, and <code>re</code> <code>str</code> patterns work solely with <code>str</code> (and <code>unicode</code> on Py2), not arbitrary types.</span>
<span class="comment-copy">Well then, I guess we're all doomed :-( Perhaps you should contact your friends at Microsoft to supply us a smart WinAPI for encoded mmaps :P  I'll still wait patiently for a miraculous answer I guess.</span>
