<div class="post-text" itemprop="text">
<p>I've got this code:</p>
<pre><code>class Chars:
    char_to_number = {
        'a': ['1'],
        'b': ['2'],
        'c': ['3', '6'],
        'd': ['4', '5'],
    }

    number_to_char = {
        number: char
        for char in char_to_number
        for number in char_to_number[char]
    }
</code></pre>
<p>Now this code returns an error as such: 
<code>name 'char_to_number' is not defined</code></p>
<p>Now it looks like python could not parse the nested dictionary comprehension. It looks like the inner scope was not updated with the outer scope, which defined the <code>char_to_number</code> variable.</p>
<p>I've solved this code with this implementation:</p>
<pre><code>class Chars:
    char_to_number = {
        'a': ['1'],
        'b': ['2'],
        'c': ['3', '6'],
        'd': ['4', '5'],
    }

    number_to_char = {
        number: char
        for char, optional_numbers in char_to_number.items()
        for number in optional_numbers
    }
</code></pre>
<p>Here I'm not using the char_to_number variable in the inner loop, and python succeeded to parse this code.</p>
<p>Of course, all of that happens in the global scope of the class.
In the global python scope, it doesn't happen:</p>
<pre><code>char_to_number = {
    'a': ['1'],
    'b': ['2'],
    'c': ['3', '6'],
    'd': ['4', '5'],
}

number_to_char = {
    number: char
    for char in char_to_number
    for number in char_to_number[char]
}
</code></pre>
<p>Does anyone have any clue about that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe it's because there's no permanent definition of your objects as you have in a global scope. If you make your variables permanent in the scope of your class the problem should be solved:</p>
<pre><code>class Chars:
    def __init__(self):
        self.char_to_number = {
            'a': ['1'],
            'b': ['2'],
            'c': ['3', '6'],
            'd': ['4', '5'],
        }

        self.number_to_char = {
            number: char
            for char in self.char_to_number
            for number in self.char_to_number[char]
        }

c = Chars()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The essence of the problem is not the nesting. It's the fact that there's a flaw in the scope in comprehensions used within classes. To understand why this looks like a flaw, take the code from the original question by @gal-ben-david and put it in a function (print statement and function call added to generate output and confirm that this code works, at least in Python 3.6.6):</p>
<pre><code>def Chars():
    char_to_number = {
        'a': ['1'],
        'b': ['2'],
        'c': ['3', '6'],
        'd': ['4', '5'],
    }
    number_to_char = {
        number: char
        for char in char_to_number
        for number in char_to_number[char]
    }
    print(number_to_char)
</code></pre>
<p>To understand why nesting is not the problem, take a look at the example in the explanation for this "limitation", <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">in the section on the execution model of the Python language reference</a>:</p>
<pre><code>class A:
    a = 42
    b = list(a + i for i in range(10))
</code></pre>
<p>The variable "a" is not in the scope of the comprehension if these two lines appear in a class, but it would be in a function or module. I call that a bug. To formalize the limitation a bit: when a comprehension is used in a class, only the outermost iterator in the for loop(s) is accessible inside the comprehension, but no other variables from outside the comprehension are accessible.</p>
<p>Comprehensions are presented as being equivalent to for loops, but obviously they aren't. While the nature of this flaw is being debated (bug or not bug), I've submitted a ticket to the developers about the documentation of comprehensions, which really should mention this problem prominently.</p>
<p>I don't have enough points to comment on @armatita's response, but note that it's a workaround and not equivalent to what the original code is trying to do, because it makes char_to_number and number_to_char attributes of each class instance and not of the class itself. I landed on this page because I was trying to assign class attributes.</p>
</div>
<span class="comment-copy">this one is obvious, and it is similar to my 3rd example. Python parses differently when it comes to the global scope of the class.</span>
<span class="comment-copy">I can only guess that Python parses the nested loops into a local domain. Not the first "for char in char_to_number" where you are giving arguments. But in the second, "number inchar_to_number[char]", where it happens locally to the first. So my guess is that you actually have something like &gt;&gt; LoopFunction() { char; LoopFunction2(); } , thus it won't detect the local argument "char_to_number" ("char" should have no problem). The solution is to make global either in Global or Class scope. It's hypothetical, never seen the source code for comprehension loops.</span>
