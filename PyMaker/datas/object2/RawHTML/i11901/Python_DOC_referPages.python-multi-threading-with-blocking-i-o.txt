<div class="post-text" itemprop="text">
<p>My application uses multiple I/O blocking (network) requests that take a while to complete. 
I tried using multi threading but it doesn't appear to bring any speedup, I'm guessing it's something to do with Python's GIL.</p>
<p>The thing is all of the requests can be done concurrently and have no dependencies on each other. How do I solve this performance issue?</p>
<p>My code</p>
<pre><code>import threading
import urllib2
import time
def send_request(url, count_str):
    start_time = time.time()
    urllib2.urlopen(url)
    print "Request " + count_str + " took " + str(time.time() - start_time) + " started at " + str(start_time)

count = 0
for url in open('urllist.txt'):
    t = threading.Thread(target=send_request, args = (url.strip(), str(count)))
    t.start()
    count+=1
</code></pre>
<p>The output is </p>
<pre><code>Request 1 took 5.0150949955 started at 1458789266.78
Request 2 took 10.0112490654 started at 1458789266.79
Request 0 took 15.024559021 started at 1458789266.78
Request 3 took 20.016972065 started at 1458789266.79
</code></pre>
<p>The urls in urllist.txt point to a server I'm running locally that take  5 seconds to respond. 
As you can see they all "start" at the same time, but they are blocking. </p>
</div>
<div class="post-text" itemprop="text">
<p>I cannot reproduce your problem (when testing against a handful of internet servers, each one repeated a few times, all requests are serviced in about the same time, no steadily increasing delays), but your new output points to a completely different issue: I suspect the "local server" you're using may not be multithreaded (or otherwise able to service multiple requests at once).</p>
<p>Your own output indicates the threads are launching in parallel, but requests are being serviced serially; if it was GIL handoff causing problems, I'd expect to see all of them delayed a bit (one thread would get some work done, then another would do some more, etc.), not each one running to completion before the next starts. This smacks of a problem on the server side, where the server is handling requests to completion before it services additional connections.</p>
<p>Taking a stab at psychic debugging, did you by any chance implement the five second request time by adding a sleep in the server code, possibly after <code>accept</code> returns, but before launching a thread to service it? Or just not use threading on the server at all?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python threads are slow! Python has a GIL (Global Interpreter Lock) which uses a mutex to serialize access to internals. You might want to have a look at Jython which doesn't have a GIL and can fully exploit multiprocessor systems.</p>
</div>
<span class="comment-copy">You can show us your code :)</span>
<span class="comment-copy">@Signal updated it =) I'm very new to multithreading in Python so could be quite a lot wrong with it</span>
<span class="comment-copy">How is <code>q.join()</code> supposed to return? Nothing in your code is processing the <code>Queue</code> to call <code>.get()</code> let alone <code>.task_done()</code>. You're also not returning anything from <code>get_and_read_url</code>, so you're just enqueuing <code>None</code>. Finally, I'll note: For threading in general, and <code>Queue</code>s in particular, Python 2 is <i>bad</i>; if you can move to more recent Python (<a href="https://docs.python.org/3/whatsnew/3.2.html#multi-threading" rel="nofollow noreferrer">3.2 or later</a>), the rewritten GIL means that while threading still gains you nothing on CPU bound tasks, it doesn't run substantially slower and eat a core on nothing but GIL overhead.</span>
<span class="comment-copy">Simplified code to not use <code>Queue</code> as it's not needed for this example + I they were the mistakes you pointed out. I added some code to measure the start and end of each request and the output and make the question clearer.</span>
<span class="comment-copy">Wow this was it. The local server I had running didn't have multithreading enabled and was blocking in the response. Should I close the question or at least rename it because it's not a Python problem and was infact an issue testing the performance?</span>
<span class="comment-copy">@tt_Gantz: I wouldn't close it, since really, in its current state, it asks a question that someone might legitimately ask in the future, for the same reasons, and it (now) gives enough information to help them identify their own problem.</span>
<span class="comment-copy">The OP is aware of the GIL having mentioned it in the question; the threads should be I/O bound though, and typically threading to coordinate parallel tasks that block on I/O is fine. "The GIL is bad, so never ever use threads" is a vast oversimplification, and adds nothing. And given how terrible Jython support has been (over five years behind the language spec), it wouldn't be my first recommendation.</span>
