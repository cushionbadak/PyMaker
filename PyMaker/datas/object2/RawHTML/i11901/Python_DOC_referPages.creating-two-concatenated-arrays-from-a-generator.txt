<div class="post-text" itemprop="text">
<p>Consider the following example in Python 2.7. We have an arbitrary function <code>f()</code> that returns two 1-dimensional numpy arrays. Note that in general <code>f()</code> may returns arrays of different size and that the size may depend on the input. </p>
<p>Now we would like to call <code>map</code> on <code>f()</code> and concatenate the results into two separate new arrays. </p>
<pre><code>import numpy as np

def f(x):
    return np.arange(x),np.ones(x,dtype=int)   

inputs = np.arange(1,10)
result = map(f,inputs)
x = np.concatenate([i[0] for i in result]) 
y = np.concatenate([i[1] for i in result]) 
</code></pre>
<p>This gives the intended result. However, since result may take up much memory, it may be preferable to use a generator by calling <code>imap</code> instead of <code>map</code>.    </p>
<pre><code>from itertools import imap
result = imap(f,inputs)
x = np.concatenate([i[0] for i in result]) 
y = np.concatenate([i[1] for i in result]) 
</code></pre>
<p>However, this gives an error because the generator is empty at the point where we calculate <code>y</code>. </p>
<p>Is there a way to use the generator only once and still create these two concatenated arrays? I'm looking for a solution without a for loop, since it is rather inefficient to repeatedly concatenate/append arrays. </p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a way to use the generator only once and still create these two concatenated arrays?</p>
</blockquote>
<p>Yes, a generator can be cloned with <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>tee</code></a>:</p>
<pre><code>import itertools
a, b = itertools.tee(result)

x = np.concatenate([i[0] for i in a]) 
y = np.concatenate([i[1] for i in b]) 
</code></pre>
<hr/>
<p>However, using <code>tee</code> does not help with the memory usage in your case. The above solution would require 5 N memory to run: </p>
<ul>
<li>N for caching the generator inside <code>tee</code>,</li>
<li>2 N for the list comprehensions inside <code>np.concatenate</code> calls,</li>
<li>2 N for the concatenated arrays. </li>
</ul>
<p>Clearly, we could do better by dropping the <code>tee</code>:</p>
<pre><code>x_acc = []
y_acc = []
for x_i, y_i in result:
    x_acc.append(x_i)
    y_acc.append(y_i)

x = np.concatenate(x_acc)
y = np.concatenate(y_acc)
</code></pre>
<p>This shaved off one more N, leaving 4 N. Going further means dropping the intermediate lists and preallocating <code>x</code> and <code>y</code>. Note, that you needn't know the <em>exact</em> sizes of the arrays, only the upper bounds:</p>
<pre><code>x = np.empty(capacity)
y = np.empty(capacity)
right = 0
for x_i, y_i in result:
    left = right
    right += len(x_i)  # == len(y_i)  
    x[left:right] = x_i
    y[left:right] = y_i

x = x[:right].copy()
y = y[:right].copy()
</code></pre>
<p>In fact, you don't even need an upper bound. Just ensure that <code>x</code> and <code>y</code> are big enough to accommodate the new item:</p>
<pre><code>for x_i, y_i in result:
    # ...
    if right &gt;= len(x):
        # It would be slightly trickier for &gt;1D, but the idea
        # remains the same: alter the 0-the dimension to fit 
        # the new item.
        new_capacity = max(right, len(x)) * 1.5
        x = x.resize(new_capacity)
        y = y.resize(new_capacity)
</code></pre>
</div>
<span class="comment-copy">Do you mean that <code>i[0]</code> and <code>i[1]</code> can have different shapes?</span>
<span class="comment-copy">@SergeiLebedev In general, yes. In my example they have the same shape.</span>
<span class="comment-copy">I don't see the benefit of using a generator for <code>result</code>. You still build up two lists of the same size as <code>result</code> for the <code>np.concatenate</code> call. So, if having two lists is acceptable, you can just iterate over <code>result</code> in a for-loop and update the lists simultaneously.</span>
<span class="comment-copy">@SergeiLebedev I want to use this in a situation where the size of result is close to my memory limit.</span>
<span class="comment-copy">Do you know the sizes of <code>x</code> and <code>y</code>?</span>
