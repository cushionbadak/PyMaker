<div class="post-text" itemprop="text">
<p>In the following snippet, I have manually entered the two functions that are arguments for <strong>AnyEc</strong>.</p>
<pre><code>def element_visible(context, element_id):
    element = WebDriverWait(context.browser, 10).until(AnyEc(
        expected_conditions.visibility_of_element_located((By.ID, element_id[0])),
        expected_conditions.visibility_of_element_located((By.ID, element_id[1]))
    ))
    return element
</code></pre>
<p>How would I be able to create those arguments as functions, depending on the list length of <strong>element_id</strong>?</p>
<p>I've tried using for eaches, but have been unable to generate a comma separated list of functions that didn't get parsed as a string argument.</p>
<p><strong>Edit:</strong>
It looks like the iterating functions are now being run with the suggested updates. Unfortunately it appears I am no longer getting the functions to return.</p>
<p>Below is my updated code:</p>
<pre><code>class AnyEc:
    # Use with WebDriverWait to combine expected_conditions in an OR
    def __init__(self, *args):
        self.ecs = args

    def __call__(self, browser):
        for fn in self.ecs:
            try:
                if fn(browser):
                    # Return element ID located and element object
                    return [fn.locator[1], fn(browser)]
            except:
                pass

def element_visible(context, element_id):
    # Iterate through element_id list to provide args for AnyEc
    args = [expected_conditions.visibility_of_element_located((By.ID, id)) for id in element_id]
    element = WebDriverWait(context.browser, 10).until(AnyEc(*args))
    return element
</code></pre>
<p><strong>Edit 2:</strong>
I'm currently resorting to using the following code, despite being inelegant:</p>
<pre><code>def element_visible(context, element_id):
    if isinstance(element_id, str):
        element = WebDriverWait(context.browser, 10).until(AnyEc(
            expected_conditions.visibility_of_element_located((By.ID, element_id))
        ))
    else:
        element = WebDriverWait(context.browser, 10).until(AnyEc(
            expected_conditions.visibility_of_element_located((By.ID, element_id[0])),
            expected_conditions.visibility_of_element_located((By.ID, element_id[1]))
        ))
    return element
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create your functions first:</p>
<pre><code>args = [expected_conditions.visibility_of_element_located((By.ID, id_)) 
        for id_ in element_id]
</code></pre>
<p>Use with <code>*</code>:</p>
<pre><code>element = WebDriverWait(context.browser, 10).until(AnyEc(*args))
</code></pre>
<p>You can use the <code>*</code> syntax to <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">unpack</a> a sequence such as list as separate arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Collect the expected conditions in a list and then <em><a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">unpack the list</a></em>:</p>
<pre><code>conditions = [
    expected_conditions.visibility_of_element_located((By.ID, item))
    for item in element_id
]
element = WebDriverWait(context.browser, 10).until(AnyEc(*conditions))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use Python's *args to pass a list of arguments to a function:    </p>
<pre><code>def element_visible(context, element_id):
    any_ec_args = []
    for i, element in enumerate(element_id):
        arg = expected_conditions.visibility_of_element_located((By.ID,
                                                                 element_id[i]))
        any_ec_args.append(arg)
    element = WebDriverWait(context.browser, 10).until(AnyEc(*any_ec_args))
    return element
</code></pre>
</div>
<span class="comment-copy">Remove the <code>try ... except: pass</code> to see if there is an exception and what kind of exception.</span>
<span class="comment-copy">Unfortunately that still results in no return. The try/pass is to allow the function to pass onto the following function if no element is located.  When run the same script with manually written arguments, it seems to work correctly.</span>
<span class="comment-copy">In Python 2 better use class <code>AnyEc(object):</code> to get a new-style class.</span>
<span class="comment-copy">Where is the <code>if isinstance(element_id, str)</code> in the updated version?</span>
<span class="comment-copy">It's not present. Wouldn't "(*args)" also work if there was only one argument?</span>
<span class="comment-copy">It appears the functions are being taken as arguments but are no longer returning anything. Any ideas as to why?</span>
<span class="comment-copy">Should be the same effect as your approach. Does you approach still work with <code>AnyEc</code>?</span>
<span class="comment-copy">Yes it does. I've added an edit with the currently working code.</span>
<span class="comment-copy">It appears the functions are being taken as arguments but are no longer returning anything. Any ideas as to why?</span>
