<div class="post-text" itemprop="text">
<p>I'm using python 2.7</p>
<p>I have a file that contains hex strings:</p>
<pre><code>    \x01\x02\x93AAA
    \x02\x02\x93AAA
    \x03\x02\x93AAA
....
</code></pre>
<p>They are a mix of unprintable characters, represented as hex, and printablecharacters represented in ascii.</p>
<p>I am reading them into a map based on their line number. Then trying to send it over a socket. I am receiving inconsistent results when I send from my map versus as a straight string.</p>
<p>Example code:</p>
<pre><code>print mymap[0]
mysocket.sendall(mymap[0])
mysocket.sendall("\x01\x02\x93AAA")
</code></pre>
<p>With these two send attempts, in wireshark, I can see the first one when sending from mymap is being sent in ASCII. As in it sends '\', 'x', '0', '1' instead of interpreting that as a hex 0x01. Where as the second line sends it correctly as hex data. </p>
<p>The print mymap[0] prints exactly the same string ("\x01\x02\x93AAA"), so why is one sending it as ASCII, and one sending it as hex? </p>
<p>I want it to send as hex, but when using my map It keeps sending it as ASCII, yet just hardcoding a string in sends as hex. Help?</p>
<p>Edit: I updated the title of this question to reflect what the underlying problem actually was. For those happening upon this later. My original thought was it had to do with reading the data from a map, when in reality the issue was reading it in from a file. </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python code <code>'\x01'</code> is an escape sequence, in a text file it is only text. You have to unescape the string before sending.</p>
<pre><code>import re

def unescape(text):
    return re.sub(r'\\x([0-9a-fA-F]{2})', lambda g: chr(int(g.group(1),16)), text)
</code></pre>
</div>
<span class="comment-copy">Daniel, you are my hero. I've spent so much time hitting my head against a wall on this.. That worked perfectly</span>
<span class="comment-copy">Nitpicking: Won't this fail with a legitimate input like <code>\\x40</code> which is supposed to be one backslash, followed by <code>x40</code>, but instead gets interpreted as <code>\@</code> (changing <code>\x40</code> to <code>@</code>)? I'd think careful use of <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> would be safer. Maybe something like <code>fmt, repl = ('"""{}"""', '"') if text.endswith("'") else ("'''{}'''", "'")</code>, <code>return ast.literal_eval(fmt.format(text.replace(repl, '\\' + repl)))</code> (the <code>replace</code> escapes the quote characters, the format wraps to a string literal, then let Python take over).</span>
