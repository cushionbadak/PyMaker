<div class="post-text" itemprop="text">
<p>I have a numpy array like,</p>
<pre><code>nums = np.array([17, 18, 19, 20, 21, 22, 23])
</code></pre>
<p>How do I filter out the prime numbers from this array in a pythonic manner?
I know to do a simple filtering like,</p>
<pre><code>nums[nums &gt; 20]   #array([21, 22, 23])
</code></pre>
<p>Is there a way to pass a lambda function for filtering?</p>
<p><em>Expected output: array([17, 19, 23])</em></p>
</div>
<div class="post-text" itemprop="text">
<p>The way that I would do it is with gmpy or a 3rd party library who has developed a good primality test algorithm. The Miller-Rabin primality test is generally a very safe (and fast!) bet. If you just want the slow way, you can do:</p>
<pre><code>import numpy as np
import math

def is_prime(n):
    if n % 2 == 0 and n &gt; 2: 
        return False
    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))

a = np.arange(1, 10**3)
foo = np.vectorize(is_prime)
pbools = foo(a)
primes = np.extract(pbools, a)
primes  # =&gt; Output below
array([  1,   2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,
        41,  43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97,
       101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,
       167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
       239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,
       313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,
       397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
       467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
       569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,
       643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,
       733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,
       823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907,
       911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997])
</code></pre>
<p>If you want to filter OUT the primes, just call np.invert on the pbools variables. The same would go for any predicate. You can also pass a lambda into vectorize. For example, say we wanted only prime numbers that are also 1 away from being divisible by 5 (for whatever reason).</p>
<pre><code>import numpy as np
import math

def is_prime(n):
    if n % 2 == 0 and n &gt; 2: 
        return False
    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))

a = np.arange(1, 10**3)
foo = np.vectorize(lambda x: (not (x + 1) % 5 or not (x - 1) % 5) and is_prime(x))
primes = a[foo(a)]  # =&gt; Shorthand.... Output below
array([  1,  11,  19,  29,  31,  41,  59,  61,  71,  79,  89, 101, 109,
   131, 139, 149, 151, 179, 181, 191, 199, 211, 229, 239, 241, 251,
   269, 271, 281, 311, 331, 349, 359, 379, 389, 401, 409, 419, 421,
   431, 439, 449, 461, 479, 491, 499, 509, 521, 541, 569, 571, 599,
   601, 619, 631, 641, 659, 661, 691, 701, 709, 719, 739, 751, 761,
   769, 809, 811, 821, 829, 839, 859, 881, 911, 919, 929, 941, 971, 991])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you care of speed and efficiency I would recommend you to use one of the <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.intersect1d.html" rel="nofollow">fastest prime sieves</a> and <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.intersect1d.html" rel="nofollow">numpy.intersect1d()</a> function:</p>
<pre><code>import numpy as np

def primesfrom2to(n):
    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """ Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n """
    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)
    sieve[0] = False
    for i in range(int(n**0.5)//3+1):
        if sieve[i]:
            k=3*i+1|1
            sieve[      ((k*k)//3)      ::2*k] = False
            sieve[(k*k+4*k-2*k*(i&amp;1))//3::2*k] = False
    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]

# generate 100.000 random integers from 1 to 1.000.000.000
a1 = np.random.randint(1, 10**9, 100000)
# generate all primes that are equal or less than a1.max() 
primes = primesfrom2to(a1.max())

# print result    
print(np.intersect1d(primes, a1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Having a setup like this:</p>
<pre><code>import numpy as np
import math
nums = np.array([17, 18, 19, 20, 21, 22, 23])
</code></pre>
<p>So now we create an array that contains all possible integer candidates:</p>
<pre><code>divisors = np.arange(2,int(math.sqrt(np.max(nums)))+1) # Numbers from 2 to sqrt(max(nums))
print(divisors)
# [2 3 4]
</code></pre>
<p>Now apply the modulo operation on the array but with a different dimension so we check each number with each divisor:</p>
<pre><code>print(nums[:,None] % divisors[None,:]) # Modulo operation on each element (0 means divisible)
</code></pre>
<pre>
[[1 2 1]
 [0 0 2]
 [1 1 3]
 [0 2 0]
 [1 0 1]
 [0 1 2]
 [1 2 3]]
</pre>
<p>Now how do we get the primes ... we check if there is no result in the line that is zero:</p>
<pre><code>print(np.min(nums[:,None] % divisors[None,:], axis=1)) # Minimum of the modulo for that element
# [1 0 1 0 0 0 1]
</code></pre>
<p>and then create a mask to index them:</p>
<pre><code>print(nums[np.min(nums[:,None] % divisors[None,:], axis=1) &gt; 0]) # So index them
# [17 19 23]
</code></pre>
<hr/>
<p>So all you need in the end is:</p>
<pre><code>nums = np.array([17, 18, 19, 20, 21, 22, 23])
divisors = np.arange(2,int(math.sqrt(np.max(nums)))+1)
nums[np.min(nums[:,None] % divisors[None,:], axis=1) &gt; 0]
</code></pre>
<p>all the other stuff is just for illustrating what each step is doing.</p>
<p>This is not trivial since it uses broadcasting of 1D arrays into a 2D array but the method should be clear. Let me know if you have any questions.</p>
<hr/>
<p>If you want to optimize this, there is another possibility: The divisors are currently every number between <code>2</code> and the <code>sqrt(max(array))</code> but you don't need to test for all these numbers. If you had a function that returned all primes in that range that would be enough. For example using <code>primesfrom2to</code> of @MaxU's answer a faster possibility is:</p>
<pre><code>nums = np.array([17, 18, 19, 20, 21, 22, 23])
# All prime numbers in the range from 2 to sqrt(max(nums))
divisors = primesfrom2to(int(math.sqrt(np.max(nums)))+1)
nums[np.min(nums[:,None] % divisors[None,:], axis=1) &gt; 0]
</code></pre>
<p>but it uses the same mechanism as before but is a bit faster. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>It appears that you question is not about primes at all, but about how to apply a function to <code>numpy</code> array. I used simple <code>is_odd</code> example. Maybe <code>np.vectorize</code> is what you are looking for:</p>
<pre><code>In [34]: nums = np.array([17, 18, 19, 20, 21, 22, 23])

In [35]: def is_odd(n):
    if n % 2 == 1:
        return True
    return False
   ....: 

In [36]: is_odd_v = np.vectorize(is_odd)

In [37]: nums[is_odd_v(nums)]
Out[37]: array([17, 19, 21, 23]
</code></pre>
<p>If I recall correctly <code>np.vectorize</code> is used primarily for convenience, and does not have great performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really want to use a Filter, you can use this:</p>
<pre><code>nums[[i for i in range(len(nums)) if sum([nums[i]%val==0 for val in range(2,nums[i]-1)])==0]]
</code></pre>
<p>What does this do?</p>
<p>We search all indexes with prime number by using</p>
<pre><code>[i for i in range(len(nums)) if sum([nums[i]%val==0 for val in range(2,nums[i]-1)])==0]
</code></pre>
<p>This basically goes through every value and checks if it is not divisible by any value smaller than itself (ignoring 1)</p>
<pre><code>[i for i in range(len(nums)) #for every index

if sum(#calculate sum of booleans

[nums[i]%val==0 for val in range(2,nums[i]-1)] # check if it is divisble by any value smaller than itself

)==0 #check if the number of divisors is zero
</code></pre>
</div>
<span class="comment-copy">Welcome to StackOverflow. Questions should at least make an attempt at solving the problem or at least you could tell us what you tried. A good place to start in this case ist to try checking if they are divisible by any integer? A hint: The <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">modulo operator</a> could be of some use.</span>
<span class="comment-copy">@MSeifert the sarcasm is palpable. OP, gmpy has a built-in miller-rabin primality test.</span>
<span class="comment-copy">I'm a beginner in numpy. I'm looking for a better way to do this..</span>
<span class="comment-copy">Find some code (or write it!) to get a list of primes that goes to the highest limit of your nums array.  then use for n in primes</span>
<span class="comment-copy">@kmario23, generally when you want to find <i>a better way</i> you would usually have a way that worked already, if you add that working attempt to your question that would help.</span>
<span class="comment-copy">But this will not <i>always</i> return prime? It'll return 39 but it's not a prime though</span>
<span class="comment-copy">@kmario23 This will not return primes, this will return odd numbers. But if you function wrote <code>is_prime</code> function yourself. It would return you a filtered <code>np.array</code> of primes. Of course my solution is naive and not optimized.</span>
<span class="comment-copy">Why the downvote? I know it is ugly and unoptimized, but it works and satisfies the question asked.</span>
