<div class="post-text" itemprop="text">
<p>I wrote a unittest to test timeout with the requests package</p>
<p>my_module.py:</p>
<pre><code>import requests

class MyException(Exception): pass

def my_method():
    try:
        r = requests.get(...)
    except requests.exceptions.Timeout:
        raise MyException()
</code></pre>
<p>Unittest:</p>
<pre><code>from mock import patch
from unittest import TestCase
from requests.exceptions import Timeout

from my_module import MyException

@patch('my_module.requests')
class MyUnitTest(TestCase):
    def my_test(self, requests):
        def get(*args, **kwargs):
            raise Timeout()

        requests.get = get

        try:
            my_module.my_method(...)
        except MyException:
            return

        self.fail("No Timeout)
</code></pre>
<p>But when it runs, the try block in <code>my_method</code> never catches the <code>requests.exceptions.Timeout</code></p>
</div>
<div class="post-text" itemprop="text">
<p>There are two problems I see here. One that directly fixes your problem, and the second is a slight misuse of the Mocking framework that further simplifies your implementation. </p>
<p>First, to directly address your issue, based on how you are looking to test your assertion, what you are actually looking to do here: </p>
<pre><code>requests.get = get
</code></pre>
<p>You <em>should</em> be using a <code>side_effect</code> here to help raise your exception. Per the <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>side_effect allows you to perform side effects, including raising an
  exception when a mock is called</p>
</blockquote>
<p>With that in mind, all you really need to do is this: </p>
<pre><code>requests.get.side_effect = get
</code></pre>
<p>That should get your exception to raise. However, chances are you <em>might</em> face this error: </p>
<pre><code>TypeError: catching classes that do not inherit from BaseException is not allowed
</code></pre>
<p>This can be <em>best</em> explained by actually reading <a href="https://stackoverflow.com/a/31873937/1832539">this</a> great answer about why that is happening. With that answer, taking that suggestion to actually only mock out what you <em>need</em> will help fully resolve your issue. So, in the end, your code will actually look something like this, with the mocked <code>get</code> instead of mocked <code>requests</code> module:</p>
<pre><code>class MyUnitTest(unittest.TestCase):

    @patch('my_module.requests.get')
    def test_my_test(self, m_get):
        def get(*args, **kwargs):
            raise Timeout()

        m_get.side_effect = get

        try:
            my_method()
        except MyException:
            return
</code></pre>
<p>You can now actually further simplify this by making better use of what is in unittest with <code>assertRaises</code> instead of the try/except. This will ultimately just assert that the exception was raised when the method is called. Furthermore, you do not <em>need</em> to create a new method that will raise a timeout, you can actually simply state that your mocked get will have a <code>side_effect</code> that raises an exception. So you can replace that entire <code>def get</code> with simply this: </p>
<pre><code>m_get.side_effect = Timeout()
</code></pre>
<p>However, you can actually directly put this in to your patch decorator, so, now your final code will look like this: </p>
<pre><code>class MyUnitTest(unittest.TestCase):

    @patch('my_module.requests.get', side_effect=Timeout())
    def test_my_test(self, m_get):    
        with self.assertRaises(MyException):
            my_method()
</code></pre>
<p>I hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>patch('my_module.requests')</code> will replace <code>my_module.requests</code> with a new mock object, but in your test method you replace the <code>requests.get</code> method of the directly imported and therefore on the original requests module, which means that change is not reflected within your module.</p>
<p>It should work if in your test method you replace it on the requests mock within your <code>my_module</code> instead:</p>
<pre><code>my_module.requests.get = get
</code></pre>
</div>
