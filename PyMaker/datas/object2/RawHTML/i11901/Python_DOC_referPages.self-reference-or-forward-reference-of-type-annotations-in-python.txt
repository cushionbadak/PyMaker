<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/33837918/type-hints-solve-circular-dependency">Type hints: solve circular dependency</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm trying to figure out how self-reference of types work with <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer">python3's type annotations</a> - the docs don't specify anything regarding this.</p>
<p>As an example:</p>
<pre><code>from typing import TypeVar, Optional, Generic

T = TypeVar('T')
class Node(Generic[T]):
    left = None
    right = None
    value = None

    def __init__(
        self, value: Optional[T],
        left: Optional[Node[T]]=None,
        right: Optional[Node[T]]=None,
    ) -&gt; None:
        self.value = value
        self.left = left
        self.right = right
</code></pre>
<p>This code generates the error:</p>
<pre><code>Traceback (most recent call last):
  File "node.py", line 4, in &lt;module&gt;
    class Node(Generic[T]):
  File "node.py", line 12, in Node
    right: Optional[Node[T]]=None,
NameError: name 'Node' is not defined
</code></pre>
<p>This is using Python 3.5.1</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://www.python.org/dev/peps/pep-0484/#the-problem-of-forward-declarations" rel="noreferrer">PEP 0484 - Type Hints - The problem of forward declarations</a> addresses the issue:</p>
<blockquote>
<p>The problem with type hints is that annotations (per <a href="https://www.python.org/dev/peps/pep-3107/" rel="noreferrer">PEP 3107</a> , and
  similar to default values) are evaluated at the time a function is
  defined, and thus any names used in an annotation must be already
  defined when the function is being defined. A common scenario is a
  class definition whose methods need to reference the class itself in
  their annotations. (More general, it can also occur with mutually
  recursive classes.) This is natural for container types, for example:</p>
<p>...</p>
<p>As written this will not work, because of the peculiarity in Python
  that class names become defined once the entire body of the class has
  been executed. <strong>Our solution, which isn't particularly elegant, but
  gets the job done, is to allow using string literals in annotations.</strong>
  Most of the time you won't have to use this though -- most uses of
  type hints are expected to reference builtin types or types defined in
  other modules.</p>
</blockquote>
<pre><code>from typing import TypeVar, Optional, Generic

T = TypeVar('T')
class Node(Generic[T]):
    left = None
    right = None
    value = None

    def __init__(
        self,
        value: Optional[T],
        left: Optional['Node[T]']=None,
        right: Optional['Node[T]']=None,
    ) -&gt; None:
        self.value = value
        self.left = left
        self.right = right
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; import typing
&gt;&gt;&gt; typing.get_type_hints(Node.__init__)
{'return': None,
 'value': typing.Union[~T, NoneType],
 'left': typing.Union[__main__.Node[~T], NoneType],
 'right': typing.Union[__main__.Node[~T], NoneType]}
</code></pre>
</div>
<span class="comment-copy">Hmmm, <code>typing</code> is available only from 3.5. Check <a href="https://docs.python.org/3.5/whatsnew/3.5.html" rel="nofollow noreferrer">whatsnew of 3.5 version</a></span>
<span class="comment-copy">@thefourtheye: I edited the question. I just installed 3.5.1 and the problem still exists. The reason I had it working with 3.4 was because I had mypy installed</span>
<span class="comment-copy">Thanks! I can't believe I completely missed that part - it even has a similar example to mine!</span>
