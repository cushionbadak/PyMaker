<div class="post-text" itemprop="text">
<p>I have client and server module, each one can be started by a function. I just need to find a way to run booth in parallel which:</p>
<ol>
<li><p>in case of an exception in the client/server would stop the other so the test runner would not stay stuck</p></li>
<li><p>in case of an exception in client/server would print the exception or propagate it to the runner so I could see it and debug the client/server using the test suite</p></li>
<li><p>would preferably use threads for performance reasons</p></li>
</ol>
<p>The first tentative with simple threads ended with an ugly <code>os._exit(1)</code> when catching a exception in the run method of the thread (which kills the test runner...) Edit: with the threading package</p>
<p>The second tentative (to try to avoid os._exit()) was with <code>concurrent.futures.ThreadPoolExecutor</code>. It allows to get the exception out of the thread but I still can't find a way to abort the other thread.</p>
<pre><code>with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
    server_future = executor.submit(server)
    client_future = executor.submit(client)

    concurrent.futures.wait([server_future, client_future],
                           return_when=concurrent.futures.FIRST_EXCEPTION)

    if client_future.done() &amp;&amp; client_future.exception():
        # we can handle the client exception here
        # but how to stop the server from waiting the client?
        # also, raise is blocking

    if server_future.done() &amp;&amp; server_future.exception():
        # same here
</code></pre>
<ul>
<li>Is there a way to achieve this with threads?</li>
<li>If not with threads, is there a simple way to test a client server app at all? (I think the two first requirements are enough to have a usable solution)</li>
</ul>
<p>Edit: The client or the server would be blocked on an accept() or a receive() call so I can't periodically pool a flag a decide to exit.(one of classic method to stop a thread)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a> package. Be aware though that force killing thread is not a good idea, <a href="https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread-in-python">as discussed here</a>. It seems there is no official way to kill Thread in Python, but you can follow one of the example given on the linked post. </p>
<p>Now you need to wait for one thread to exit before stopping the other one, avoiding your test runner to be stuck. You can use Threads wrapping your server/client launch, and have your main Thread waiting for either client/server Thread to exit before killing the other one.</p>
<p>You can define your client/server Thread like this:</p>
<pre><code># Server thread (replace 
class testServerThread (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        # Do stuff if required

    def run(self):
        try:
            startServer() # Or startClient() for your client thread
        except: Exception 
          # Print your exception here, so you can debug
</code></pre>
<p>Then, start both client and server thread, and wait for one of them to exit. Once one of them is not alive anymore, you can kill the other and continue on testing. </p>
<pre><code># Create and start client/server
serverThread = testServerThread ()
clientThread = testClientThread ()

serverThread.start()
clientThread.start()

# Wait at most 5 seconds for them to exit, and loop if they're still both alive
while(serverThread.is_alive() and clientThread.is_alive()):
    serverThread.join(5)
    clientThread.join(5)

# Either client or server exited. Kill the other one.
# Note: the kill function you'll have to define yourself, as said above
if(serverThread.is_alive()):
    serverThread.kill()

if(clientThread.islive()):
    clientThread.kill()

# Done! Your Test runner can continue its work
</code></pre>
<p>The central piece of code is the <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow noreferrer">join()</a> function:</p>
<blockquote>
<p>Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception –, or until the optional timeout occurs.</p>
</blockquote>
<p>So in our case, it will wait 5 seconds for the client and 5 seconds for the server, and if both of them are still alive afterward it will loop again. Whenever one of them exit, the loop will stop, and the remaining thread will be killed.</p>
</div>
<span class="comment-copy">The first try was with the threading package, I should have mentioned it. I've searched about how to kill a thread but couldn't apply a solution because I had no control on what the threads where doing(can't periodically check a flag). In my case they would block doing an accept() or a receive() on a socket. But after searching specifically how to interrupt those operations I found out that I could simply close() the socket! Thanks a lot for indirectly guiding me to that solution!</span>
