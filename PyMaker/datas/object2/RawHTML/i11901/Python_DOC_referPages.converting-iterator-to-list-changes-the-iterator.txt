<div class="post-text" itemprop="text">
<p>The following code produces some very strange results</p>
<pre><code>import re
string = "test test test"
positions = re.finditer("test", string)
print (list(positions))
print (list(positions))
</code></pre>
<p>Output:</p>
<pre><code>[&lt;Match object...&gt;, &lt;Match object...&gt;, &lt;Match object...&gt;]
[]
</code></pre>
<p>Now, I think I know what's going on here. The first <code>list</code> call "exhausts" the iterator (so it "uses the iterator up", like in a generator, in the process of creating a list from the iterator) so then when the second call to <code>list</code> is made, the iterator is gone and we get an empty list. This seems to be confirmed by the paragraph below, although I am am trying to understand some of the things they are saying here, so I am not entirely happy with this explanation (if it is the right one):</p>
<blockquote>
<p>A container object (such as a list) produces a fresh new iterator
  each time you pass it to the iter() function or use it in a for loop.
  Attempting this with an iterator will just return the same exhausted
  iterator object used in the previous iteration pass, making it appear
  like an empty container.</p>
</blockquote>
<p>The above paragraph is from <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow">the official documentation</a>. </p>
<p>I do not really understand what they are saying in the first sentence in the above paragraph, especially with regards to passing to the <code>iter()</code> function, and I do not know how they connect usage in a for loop to a list producing a fresh new iterator. The second sentence, though, seems closer to what I first thought was going on in the code above. </p>
<p>If anyone can help me clear up the confusion here, I would appreciate it immensely.</p>
<p><strong>NOTE:</strong></p>
<p>I am using Python 3.5.1</p>
</div>
<div class="post-text" itemprop="text">
<p>This line:</p>
<pre><code>positions = re.finditer("test", string)
</code></pre>
<p><a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow">It returns a one-shot iterator</a>.  Then you called <code>list(positions)</code> <em>twice</em> on the same iterator.  </p>
<p>So for the second call, it was already exhausted.  </p>
<p>Lists will give you a fresh iterator every time you iterate them, so there is no exhausting behaviour on a list itself.  Compare the behaviour below to understand the piece of documentation you quoted:</p>
<pre><code>&gt;&gt;&gt; L = ['a', 'b', 'c']
&gt;&gt;&gt; list(L)
['a', 'b', 'c']
&gt;&gt;&gt; list(L)
['a', 'b', 'c']
&gt;&gt;&gt; iter_L = iter(L)  # calls L.__iter__() and returns you a one-shot iterator
&gt;&gt;&gt; list(iter_L)
['a', 'b', 'c']
&gt;&gt;&gt; list(iter_L)
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When list() runs over an iterator, it basically calls next() on it until it raises the exception StopIteration and then appends each thing that the next() returns to a list, then returns that list. Basically, an implementation of list(iter) could be:</p>
<pre><code>my_list(iter):
    output = []
    try:
        while True:
            output.append(iter.next())
    except StopIteration:
        return output
</code></pre>
<p>By the way, a <code>for</code> loop does the exact same thing, but instead of <code>output.append(iter.next())</code> it does the body of the loop.</p>
</div>
<span class="comment-copy">one-shot iterator?</span>
<span class="comment-copy">Yes.  You can only iterate it once.</span>
<span class="comment-copy">Ok, but that was pretty much what I said I thought already (that it exhausts the iterator the first time, then the second time it's gone). But nevermind, I think I have figured out what the paragraph I have quoted in my question is saying.</span>
<span class="comment-copy">Haha, was just about to answer my own question with exactly the latest edit you have made on your answer (with the code starting with <code>L = ['a'...</code>). But I see you beat me to it</span>
<span class="comment-copy">Note that the behaviour you see in the original question has nothing to do with <code>list.__iter__</code>, and everything to do with the contract of <code>re.finditer</code>.</span>
