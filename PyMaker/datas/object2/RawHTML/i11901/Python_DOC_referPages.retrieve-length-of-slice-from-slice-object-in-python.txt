<div class="post-text" itemprop="text">
<p>The title explains itself, how to get 2 out of the object</p>
<pre><code>slice(0,2)
</code></pre>
<p>The documentation is somewhat confusing, or it is the wrong one</p>
<p><a href="https://docs.python.org/2/c-api/slice.html" rel="noreferrer">https://docs.python.org/2/c-api/slice.html</a></p>
<p>In particular I don't understand what is the meaning of the output of</p>
<pre><code>slice(0,2).indices(0)  # (0, 0, 1)
slice(0,2).indices(10 ** 10)  # (0, 2, 1)
</code></pre>
<p>One possible workaround is to slice a list with the slice object</p>
<pre><code>a = [1,2,3,4,5]
len(a[slice(0,2)])  # 2
</code></pre>
<p>But this will fail for an arbitrary large slice.</p>
<p>Thanks, I couldn't find an answer In other posts. </p>
</div>
<div class="post-text" itemprop="text">
<p>There is no complete answer for this. <code>slice</code> doesn't give you a length because the length of the result is always dependent on the size of the sequence being sliced, a short sequence (including an empty sequence) will produce fewer items, and if the <code>slice</code> is unbounded, then the length will grow in tandem with the length of the sequence; a <code>slice</code> might just go "to end of sequence" by having a <code>start</code> or <code>stop</code> of <code>None</code>.</p>
<p>For a quick and easy way to compute the length for a sequence of a known length, you just combine <code>.indices</code> with Py3's <code>range</code> (or <code>xrange</code> in Py2, though <code>xrange</code> has limitations on values that Py3 <code>range</code> does not). <a href="https://docs.python.org/3/reference/datamodel.html#slice.indices" rel="nofollow"><code>slice.indices</code> gives you the concrete <code>start</code>, <code>stop</code> and <code>stride</code> values derived when a <code>slice</code> applies to a sequence of a given length</a>, it's basically the values you'd fill in in a C-style <code>for</code> loop that traverses the same indices as the <code>slice</code>:</p>
<pre><code> for (ssize_t i = start; i &lt; stop; i += stride)
</code></pre>
<p>So to calculate the length of a <code>slice</code> when applied to a sequence with 1000 elements, you'd do:</p>
<pre><code>&gt;&gt;&gt; len(range(*slice(0, 2).indices(1000)))
2
&gt;&gt;&gt; len(range(*slice(10, None, 3).indices(1000)))
330
</code></pre>
<p>If you're on Python 2, and your values might exceed what <code>xrange</code> can handle (it's limited to bounds and total length equal to what a <code>ssize_t</code> can hold), you can just do the calculation by hand:</p>
<pre><code>def slice_len_for(slc, seqlen):
    start, stop, step = slc.indices(seqlen)
    return max(0, (stop - start + (step - (1 if step &gt; 0 else -1))) // step)

&gt;&gt;&gt; slice_len_for(slice(10, None, 3), 1000)
330
</code></pre>
<p><strong>Update:</strong> Unfortunately, <code>slice.indices</code> itself won't accept a <code>len</code> for the sequence beyond what a <code>long</code> can hold, so this doesn't gain you anything over using <code>xrange</code> in Py2. Left in place for those interested, but the workaround doesn't workaround anything unless you also <a href="https://hg.python.org/cpython/file/2.7/Objects/sliceobject.c#l102" rel="nofollow">perform the work <code>slice</code> does to convert negative values and <code>None</code> to concrete values based on the sequence length.</a> Sigh.</p>
</div>
<div class="post-text" itemprop="text">
<p>So it looks like <code>slice.indices(n)</code> returns the arguments to be given to <code>range</code>, to get the item indices which should be reflected in the slice of a sequence of length <code>n</code> (<s>although it's not documented</s> <strong>edit:</strong> as @ShadowRanger pointed out, it is indeed <a href="https://docs.python.org/3/reference/datamodel.html#slice.indices" rel="nofollow">documented</a>). So the following lines evaluate to the same values:</p>
<pre><code># get some list to work on
my_list = list(range(100))

# slice syntax
print(my_list[1:15:3])
# regular item access
print(my_list[slice(1,15,3)])
# reinvent list slicing
print([my_list[i] for i in range(*slice(1,15,3).indices(len(my_list)))])
</code></pre>
<p>As you see, the resulting list's length is the same as the length of <code>range(*slice(1,15,3).indices(len(my_list)))</code>, which depends on the <code>slice</code> object itself, and the length of the sequence to be sliced. That's why <code>len(range(*slice.indices(n)))</code> will give you the right answer in Python 3. (the range object is a generator, which fortunately has the <code>__len__</code> function defined, so it can give you the item count, without the need to enumerate and count them.)</p>
<p>If you work with large numbers in python 2, you can replicate the calculation as @ShadowRanger suggests.</p>
<p>The original implementation of <code>range.__len__</code> is the following:</p>
<pre><code>/* Return number of items in range (lo, hi, step).  step != 0
 * required.  The result always fits in an unsigned long.
 */
static unsigned long
get_len_of_range(long lo, long hi, long step)
{
    /* -------------------------------------------------------------
    If step &gt; 0 and lo &gt;= hi, or step &lt; 0 and lo &lt;= hi, the range is empty.
    Else for step &gt; 0, if n values are in the range, the last one is
    lo + (n-1)*step, which must be &lt;= hi-1.  Rearranging,
    n &lt;= (hi - lo - 1)/step + 1, so taking the floor of the RHS gives
    the proper value.  Since lo &lt; hi in this case, hi-lo-1 &gt;= 0, so
    the RHS is non-negative and so truncation is the same as the
    floor.  Letting M be the largest positive long, the worst case
    for the RHS numerator is hi=M, lo=-M-1, and then
    hi-lo-1 = M-(-M-1)-1 = 2*M.  Therefore unsigned long has enough
    precision to compute the RHS exactly.  The analysis for step &lt; 0
    is similar.
    ---------------------------------------------------------------*/
    assert(step != 0);
    if (step &gt; 0 &amp;&amp; lo &lt; hi)
    return 1UL + (hi - 1UL - lo) / step;
    else if (step &lt; 0 &amp;&amp; lo &gt; hi)
    return 1UL + (lo - 1UL - hi) / (0UL - step);
    else
    return 0UL;
}
</code></pre>
<p>And <code>slice.indices</code>:</p>
<pre><code>int
PySlice_GetIndices(PySliceObject *r, Py_ssize_t length,
                   Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
{
    /* XXX support long ints */
    if (r-&gt;step == Py_None) {
        *step = 1;
    } else {
        if (!PyInt_Check(r-&gt;step) &amp;&amp; !PyLong_Check(r-&gt;step)) return -1;
        *step = PyInt_AsSsize_t(r-&gt;step);
    }
    if (r-&gt;start == Py_None) {
        *start = *step &lt; 0 ? length-1 : 0;
    } else {
        if (!PyInt_Check(r-&gt;start) &amp;&amp; !PyLong_Check(r-&gt;step)) return -1;
        *start = PyInt_AsSsize_t(r-&gt;start);
        if (*start &lt; 0) *start += length;
    }
    if (r-&gt;stop == Py_None) {
        *stop = *step &lt; 0 ? -1 : length;
    } else {
        if (!PyInt_Check(r-&gt;stop) &amp;&amp; !PyLong_Check(r-&gt;step)) return -1;
        *stop = PyInt_AsSsize_t(r-&gt;stop);
        if (*stop &lt; 0) *stop += length;
    }
    if (*stop &gt; length) return -1;
    if (*start &gt;= length) return -1;
    if (*step == 0) return -1;
    return 0;
}
</code></pre>
<p>The sources are from <a href="https://svn.python.org/projects/python/trunk/Objects/" rel="nofollow">svn</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; slice(0,2).__getattribute__('stop')
2
&gt;&gt;&gt; slice(0,2).__getattribute__('start')
0
</code></pre>
</div>
<span class="comment-copy">FYI, <a href="https://docs.python.org/3/reference/datamodel.html#slice.indices" rel="nofollow noreferrer"><code>slice.indices</code> is documented, just not in the place you'd expect.</a>. The docstring in the interactive interpreter is also useful.</span>
<span class="comment-copy">@ShadowRanger Woah, you are right on this one too! I didn't manage to find that. (I updated my answer with that information if you dont mind)</span>
<span class="comment-copy">Please use the <a href="https://stackoverflow.com/posts/41260751/edit">edit</a> link explain how this code works and don't just give the code, as an explanation is more likely to help future readers. See also <a href="https://stackoverflow.com/questions/how-to-answer">How to Answer</a>.</span>
<span class="comment-copy">This is wrong - <code>stop</code> and <code>start</code> don't give you the length - it depends on the <code>step</code> <i>and</i> on the length of the item you're slicing.  And if you want to get <code>stop</code> and <code>start</code> attributes, why use <code>__getattribute__</code>?  Why not just say, <code>slice(2).start</code>?</span>
