<div class="post-text" itemprop="text">
<p>I'd like to point to a function that does nothing:</p>
<pre><code>def identity(*args)
    return args
</code></pre>
<p>my use case is something like this</p>
<pre><code>try:
    gettext.find(...)
    ...
    _ = gettext.gettext
else:
    _ = identity
</code></pre>
<p>Of course, I could use the <code>identity</code> defined above, but a built-in would certainly run faster (and avoid bugs introduced by my own).</p>
<p>Apparently, <code>map</code> and <code>filter</code> use <code>None</code> for the identity, but this is specific to their implementations.</p>
<pre><code>&gt;&gt;&gt; _=None
&gt;&gt;&gt; _("hello")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'NoneType' object is not callable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Doing some more research, there is none, a feature was asked in <a href="http://bugs.python.org/issue1673203" rel="noreferrer">issue 1673203</a> And from <a href="http://mail.python.org/pipermail/python-ideas/2009-March/003647.html" rel="noreferrer">Raymond Hettinger said there won't be</a>:</p>
<blockquote>
<p>Better to let people write their own trivial pass-throughs
  and think about the signature and time costs.</p>
</blockquote>
<p>So a better way to do it is actually (a lambda avoids naming the function):</p>
<pre><code>_ = lambda *args: args
</code></pre>
<ul>
<li>advantage: takes any number of parameters</li>
<li>disadvantage: the result is a boxed version of the parameters</li>
</ul>
<p>OR</p>
<pre><code>_ = lambda x: x
</code></pre>
<ul>
<li>advantage: doesn't change the type of the parameter</li>
<li>disadvantage: takes exactly 1 positional parameter</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>yours will work fine. When the number of parameters is fix you can use an anonymous function like this:</p>
<pre><code>lambda x: x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An identity function, as defined in <a href="https://en.wikipedia.org/wiki/Identity_function" rel="noreferrer">https://en.wikipedia.org/wiki/Identity_function</a>, takes a single argument and returns it unchanged:</p>
<pre><code>def identity(x):
    return x
</code></pre>
<p>What you are asking for when you say you want the signature <code>def identity(*args)</code> is <em>not</em> strictly an identity function, as you want it to take multiple arguments. That's fine, but then you hit a problem as Python functions don't return multiple results, so you have to find a way of cramming all of those arguments into one return value.</p>
<p>The usual way of returning "multiple values" in Python is to return a tuple of the values - technically that's one return value but it can be used in most contexts as if it were multiple values. But doing that here means you get</p>
<pre><code>&gt;&gt;&gt; def mv_identity(*args):
...     return args
...
&gt;&gt;&gt; mv_identity(1,2,3)
(1, 2, 3)
&gt;&gt;&gt; # So far, so good. But what happens now with single arguments?
&gt;&gt;&gt; mv_identity(1)
(1,)
</code></pre>
<p>And fixing <em>that</em> problem quickly gives other issues, as the various answers here have shown.</p>
<p>So, in summary, there's no identity function defined in Python because:</p>
<ol>
<li>The formal definition (a single argument function) isn't that useful, and is trivial to write.</li>
<li>Extending the definition to multiple arguments is not well-defined in general, and you're far better off defining your own version that works the way you need it to for your particular situation.</li>
</ol>
<p>For your precise case,</p>
<pre><code>def dummy_gettext(message):
    return message
</code></pre>
<p>is almost certainly what you want - a function that has the same calling convention and return as <code>gettext.gettext</code>, which returns its argument unchanged, and is clearly named to describe what it does and where it's intended to be used. I'd be pretty shocked if performance were a crucial consideration here.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, there isn't.</p>
<p>Note that your <code>identity</code>:</p>
<ol>
<li>is equivalent to lambda *args: args</li>
<li><p>Will box its args - i.e. </p>
<pre><code>In [6]: id = lambda *args: args

In [7]: id(3)
Out[7]: (3,)
</code></pre></li>
</ol>
<p>So, you may want to use <code>lambda arg: arg</code> if you want a true identity function.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no a built-in identity function in Python. An imitation of the <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:id" rel="nofollow noreferrer">Haskell's <code>id</code> function</a> would be:</p>
<pre><code>identity = lambda x, *args: (x,) + args if args else x
</code></pre>
<p>Example usage:</p>
<pre><code>identity(1)
1
identity(1,2)
(1, 2)
</code></pre>
<p>Since <code>identity</code> does nothing except returning the given arguments, I do not think that it is slower than a native implementation would be. It might even be faster, because it saves a call to a native function.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Stub of a single-argument function</h1>
<p><a href="https://docs.python.org/3/library/gettext.html#gettext.gettext" rel="nofollow noreferrer"><code>gettext.gettext</code></a> (the OP's example use case) accepts a single argument, <code>message</code>. If one needs a stub for it, there's no reason to return <code>[message]</code> instead of <code>message</code> (<code>def identity(*args): return args</code>). Thus both </p>
<pre><code>_ = lambda message: message

def _(message):
    return message
</code></pre>
<p>fit perfectly.</p>
<blockquote>
<p>...but a built-in would certainly run faster (and avoid bugs introduced by my own).</p>
</blockquote>
<p>Bugs in such a trivial case are barely relevant. For an argument of predefined type, say <code>str</code>, we can use <code>str()</code> itself as an identity function (because of <a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">string interning</a> it even retains object identity, see <code>id</code> note below) and compare its performance with the lambda solution:</p>
<pre><code>$ python3 -m timeit -s "f = lambda m: m" "f('foo')"
10000000 loops, best of 3: 0.0852 usec per loop
$ python3 -m timeit "str('foo')"
10000000 loops, best of 3: 0.107 usec per loop
</code></pre>
<p>A micro-optimisation is possible. For example, the following <a href="http://cython.org/" rel="nofollow noreferrer">Cython</a> code:</p>
<p><em>test.pyx</em></p>
<pre><code>cpdef str f(str message):
    return message
</code></pre>
<p>Then:</p>
<pre><code>$ pip install runcython3
$ makecython3 test.pyx
$ python3 -m timeit -s "from test import f" "f('foo')"
10000000 loops, best of 3: 0.0317 usec per loop
</code></pre>
<h1>Build-in object identity function</h1>
<p>Don't confuse an identity function with the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id</code></a> built-in function which returns <em>the 'identity' of an object</em> (meaning a unique identifier for that particular object rather than that object's value, as compared with <code>==</code> operator), its memory address in CPython.</p>
</div>
<div class="post-text" itemprop="text">
<p>The thread is pretty old. But still wanted to post this.</p>
<p>It is possible to build an identity method for both arguments and objects. In the example below, ObjOut is an identity for ObjIn. All other examples above haven't dealt with dict **kwargs.</p>
<pre><code>class test(object):
    def __init__(self,*args,**kwargs):
        self.args = args
        self.kwargs = kwargs
    def identity (self):
        return self

objIn=test('arg-1','arg-2','arg-3','arg-n',key1=1,key2=2,key3=3,keyn='n')
objOut=objIn.identity()
print('args=',objOut.args,'kwargs=',objOut.kwargs)

#If you want just the arguments to be printed...
print(test('arg-1','arg-2','arg-3','arg-n',key1=1,key2=2,key3=3,keyn='n').identity().args)
print(test('arg-1','arg-2','arg-3','arg-n',key1=1,key2=2,key3=3,keyn='n').identity().kwargs)

$ py test.py
args= ('arg-1', 'arg-2', 'arg-3', 'arg-n') kwargs= {'key1': 1, 'keyn': 'n', 'key2': 2, 'key3': 3}
('arg-1', 'arg-2', 'arg-3', 'arg-n')
{'key1': 1, 'keyn': 'n', 'key2': 2, 'key3': 3}
</code></pre>
</div>
<span class="comment-copy">What do you mean by <code>map and filter use None for the identity</code>?</span>
<span class="comment-copy">@MattFenwick: <code>map(None, [1, 2, 3])</code></span>
<span class="comment-copy">Check out the return value. Your args variable will be a sequence of (in this scenario) one value, so either omit the asterisk in the declaration, or unpack it befor returning.</span>
<span class="comment-copy">@GregHewgill: Sadly, that doesn't work in Python 3.x.</span>
<span class="comment-copy">@GregHewgill My bad. I took that from the doc after googling. But the Python2.x doc always comes first...</span>
<span class="comment-copy">Note that this is not an identity function.</span>
<span class="comment-copy">@Marcin Thanks for the remark. I have added advantages/drawbacks of the two in order not to mislead anyone. And now, I really believe there should have been a builtin function that accepts any number of parameters and is a true identity :)</span>
<span class="comment-copy">Nice answer. However, what would a true identity function return when taking multiple parameters?</span>
<span class="comment-copy">@Marcin: Neither, just going by what he asked in his question.</span>
<span class="comment-copy">Yes thanks, I have a trivial <code>lambda x: x</code> identity function that works for one string parameter. @Marcin I wish I could do <code>lambda *args: *args</code> :-)</span>
<span class="comment-copy">You can do this with varargs too: <code>lambda *args: args</code>. It's really a stylistic choice.</span>
<span class="comment-copy">I like the second better, since it takes any number of arguments.</span>
<span class="comment-copy">@delnan @rds - the <code>*args</code> version has a different return type, so they are not equivalent even for the single-argument case.</span>
<span class="comment-copy">@delnan: You said that it's a stylistic choice, which incorrectly implies that there is no difference in the semantics of the two forms.</span>
<span class="comment-copy">@Marcin: It's unfortunate if I implied that. I meant the choice between <code>def</code> and <code>lambda</code> for such simple functions.</span>
<span class="comment-copy">A 40% speedup "doesn't seem too worth it"? In cases where the identity operates as a "default filter" for a function that runs, say, once per channel on a 10,000x10,000 pixel image (perhaps not every-day but certainly not uncommon), that's the difference between 25 and 9 seconds of execution time! Regardless, thank you for the Cython example.</span>
<span class="comment-copy">@9999years I agree. I've removed the worthiness comment. Also thanks for improving the answer. I've made a few minor changes on top of yours.</span>
<span class="comment-copy">If you have a 10,000x10,000 pixel image then I would strongly recommend using vectorized operations using something like numpy.  It will be way faster, use way less memory, and not require writing cython code.</span>
<span class="comment-copy">this looks like a reference, if so, then where is it from?</span>
<span class="comment-copy">@JeffPuckettII I didn't follow your question. Are you asking if the new object is a reference?</span>
<span class="comment-copy">you used a blockquote highlight for "It is possible to build an identity..." which implies a reference from another source. If these are your own words, then I would suggest not highlighting it as a quote. really not a big deal. but if this is a quote from another source, then you should include a reference to it.</span>
<span class="comment-copy">Ok. Done.......</span>
<span class="comment-copy">How do you answer the original question <code>map(identity, [1, 2, 3])</code> returns <code>[1, 2, 3]</code>?</span>
