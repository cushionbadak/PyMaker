<div class="post-text" itemprop="text">
<p>I want to find n zero elements in a sparse matrix. I write the code below: </p>
<pre><code>counter = 0
while counter &lt; n:
    r = randint(0, W.shape[0]-1)
    c = randint(0, W.shape[1]-1)
    if W[r,c] == 0:
        result.append([r,c])
        counter += 1
</code></pre>
<p>Unfortunately, it is very slow. I want something more efficient. Is there any way to access zero elements from scipy sparse matrix quickly?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
import scipy.sparse as sparse
import random
randint = random.randint

def orig(W, n):
    result = list()
    while len(result) &lt; n:
        r = randint(0, W.shape[0]-1)
        c = randint(0, W.shape[1]-1)
        if W[r,c] == 0:
            result.append((r,c))
    return result

def alt(W, n):
    nrows, ncols = W.shape
    density = n / (nrows*ncols - W.count_nonzero())
    W = W.copy()
    W.data[:] = 1
    W2 = sparse.csr_matrix((nrows, ncols))
    while W2.count_nonzero() &lt; n:
        W2 += sparse.random(nrows, ncols, density=density, format='csr')
        # remove nonzero values from W2 where W is 1
        W2 -= W2.multiply(W)
    W2 = W2.tocoo()    
    r = W2.row[:n]
    c = W2.col[:n]
    result = list(zip(r, c))
    return result

def alt_with_dupes(W, n):
    nrows, ncols = W.shape
    density = n / (nrows*ncols - W.count_nonzero())
    W = W.copy()
    W.data[:] = 1
    W2 = sparse.csr_matrix((nrows, ncols))
    while W2.data.sum() &lt; n:
        tmp = sparse.random(nrows, ncols, density=density, format='csr')
        tmp.data[:] = 1
        W2 += tmp
        # remove nonzero values from W2 where W is 1
        W2 -= W2.multiply(W)
    W2 = W2.tocoo()
    num_repeats = W2.data.astype('int')
    r = np.repeat(W2.row, num_repeats)
    c = np.repeat(W2.col, num_repeats)
    idx = np.random.choice(len(r), n)
    result = list(zip(r[idx], c[idx]))
    return result
</code></pre>
<hr/>
<p>Here's a benchmark with:</p>
<pre><code>W = sparse.random(1000, 50000, density=0.02, format='csr')
n = int((np.multiply(*W.shape) - W.nnz)*0.01)

In [194]: %timeit alt(W, n)
809 ms ± 261 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [195]: %timeit orig(W, n)
11.2 s ± 121 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [223]: %timeit alt_with_dupes(W, n)
986 ms ± 290 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<hr/>
<p>Note that <code>alt</code> returns a list with no duplicates. Both <code>orig</code> and <code>alt_with_dupes</code> may return duplicates. </p>
</div>
<div class="post-text" itemprop="text">
<p>First, here's some code to create some sample data:</p>
<pre><code>import numpy as np
rows, cols = 10,20   # Shape of W
nonzeros = 7         # How many nonzeros exist in W
zeros = 70           # How many zeros we want to randomly select

W = np.zeros((rows,cols), dtype=int)
nonzero_rows = np.random.randint(0, rows, size=(nonzeros,))
nonzero_cols = np.random.randint(0, cols, size=(nonzeros,))
W[nonzero_rows, nonzero_cols] = 20
</code></pre>
<p>The above code has created <code>W</code> as a sparse numpy array, having shape <code>(10,20)</code>, and having only <code>7</code> non-zero elements (out of the <code>200</code> elements). All the non-zero elements have a value <code>20</code>.</p>
<p><strong>Here's the solution to pick <code>zeros=70</code> zero elements from this sparse matrix:</strong></p>
<pre><code>argwhere_res = np.argwhere(np.logical_not(W))
zero_count = len(argwhere_res)
ids = np.random.choice(range(zero_count), size=(zeros,))
res = argwhere_res[ids]
</code></pre>
<p><code>res</code> would now be a shape <code>(70,2)</code> array giving the locations of the <code>70</code> elements that we have randomly chosen from <code>W</code>.</p>
<p><strong>Note that this does not involve any loops.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>First make a list of all the 0's:</p>
<pre><code>list_0s = [(j, i) for i in range(len(matrix[j])) for j in range len(matrix) if matrix[j,i] == 0]
</code></pre>
<p>Then get your random choices:</p>
<pre><code>random_0s = random.choices(list_0s, k=n)
</code></pre>
<p>Testing this with:</p>
<pre><code> matrix = np.random.randint(1000, size=(1000,1000))
 n = 100
</code></pre>
<p>Takes 0.34 seconds.</p>
</div>
<span class="comment-copy">Is the matrix very sparse, or quite dense? Is <code>n</code> small or large compared to the number of zero elements in <code>W</code>? Different methods will be fastest depending on which regime we are in.</span>
<span class="comment-copy">@unutbu It is very sparse(density = 0.02). and I want to select about one percent of the zero elements. Also, the dimension of the array is high(1000 * 50000)</span>
<span class="comment-copy">Could you instead simply generate a random matrix with density 0.01, and add that to this?  It would be faster.  Though there will be some overlaps, but the 'randomness' might be just as good, if not better.</span>
<span class="comment-copy">Some in equality tests on a sparse matrix can produce matrix that is mostly True's - if all the 0's satisfy the test.  the result is a very unsparse sparse matrix.</span>
<span class="comment-copy">Keep in mind that in a sparse matrix, the zeros are defined by what isn't there.  It has a record of the nonzeros, which is much smaller.</span>
<span class="comment-copy">It's wonderful. Thank you very much</span>
<span class="comment-copy">The np.argwhere is a good point.</span>
<span class="comment-copy">@Nathan, yep, one of those infrequent occasions when <code>np.argwhere()</code> is more useful than <code>np.where()</code>.</span>
<span class="comment-copy">@fountainhead what is zero_rows? Does this code works for Scipy.sparse.matrix as well?</span>
<span class="comment-copy">@zahra: <code>zero_rows</code> was an error. Made corrections now.</span>
<span class="comment-copy">@zahra: Sorry, I'm not aware whether <code>np.logical_not()</code> works on a <code>scipy.sparse.matrix</code>. I had carelessly read the term sparse matrix as a loose description of a numpy array with very few non-zero values. I had missed the csr_matrix in the title too. Bottom line -- this solution will be relevant only if <code>np.logical_not()</code> works with your csr_matrix, or if there is an inexpensive conversion step.</span>
<span class="comment-copy">It's a good idea. but actually it's not memory and time friendly :)</span>
<span class="comment-copy">I've added a test case showing it's actually pretty fast. As for memory, the only wasted memory is the list of 0s, which is going to be 2% of the original matrix size. I don't think it's too wastefull.</span>
<span class="comment-copy">The density of my matrix is 0.02. So 98% of the matrix is zero. and it's not possible for me to keep all these values on memory.</span>
<span class="comment-copy">In that case I don't see what you mean with your program running very slowly, how large is your matrix? @zahra</span>
<span class="comment-copy">It is a (1000*50000) matrix and in some cases bigger.</span>
