<div class="post-text" itemprop="text">
<p>I have recently moved from MATLAB to python since pyhton is better suited for the current project. Since my thesis is in biomechanics, i find myself in deep water as i am not that experienced in either python or this type of analysis. </p>
<p>My function looks like this:</p>
<pre><code>def PolarFFT(data):                      
    L = len(data)
    R = np.zeros((data.shape))   
    R = sp.fftpack.rfft(data)     
    R = np.abs(R)
    R = R[1:-1]    
    n = R.size
    ts = 1/fs
    f = sp.fftpack.rfftfreq(L,ts)
    f = f[1:-1]

    outputfft = R
    outputfft[:,-1] = f

    return outputfft

accWindfrq = PolarFFT(accWind)
</code></pre>
<p>This is my best shot so far, and it does not work as intended. It seems to just output the raw data in another scaling.
The idea is to have a output which is a Lx4 matrix where col 1=x, 2=y, 3=z and 4=frequency bins. </p>
<p>Is there anyone who can help me with this? Or point me in the right direction? Maybe what i have done above is not even possible? ANY comments and help is very much appreciated.</p>
<p>Best regards</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming that <code>accWind</code> is an Lx3 array.<br/>
<code>R = np.zeros((data.shape))</code> doesn't do anything, as it will be replaced. The next line points <code>R</code> at the new data rather than copying it into <code>R</code>.<br/>
<code>R = sp.fftpack.rfft(data)</code> should be <code>R = sp.fftpack.rfft(data, axis=0)</code>. By default it fourier transforms over the last axis.<br/>
<code>outputfft[:,-1] = f</code> doesn't concatenate the arrays. It overwrites the last column. You can use one of:</p>
<pre><code>outputfft = np.concatenate((R, f), axis=1)
# or
outputfft = np.hstack((R, f))
# or
outputfft = np.empty((f.size, 4), dtype='c')
outputfft[:, :-1] = R
outputfft[:, -1] = f
</code></pre>
<p>I only included the last one because I thought that's what you were going for.</p>
</div>
<span class="comment-copy">Thank you very much for your answer! the accwind is actually Lx4 where no4 col is a time var that is not needed an therefore i overwrite it with the frequencies(is this causing a problem?). Should i slice out the time before the fft and then use one of your suggested methods instead? The 'axis=0' solved one problem, thanks!  on another note, i get amplitudes of up to 80.000 and that does not sound right for accelerometer data. What can i have done wrong?</span>
<span class="comment-copy">I tried to attach a picture of my fft plot, but the technicalities of stackoverflow is still quite new to me, so i failed in this.  There is one really big peak around 5 hz of 80.000. Following peaks maxes out at 18.000 and flattens out just around 50 hz.</span>
<span class="comment-copy">Ah. In that case you can ignore everything I said about concatenation. I thought you were going for a Matlab <code>end+1</code> type of thing. The only other thing I can think of is a <code>dt</code> factor between discrete and continuous Fourier transforms.</span>
<span class="comment-copy">Thanks a lot!  "The only other thing I can think of is a dt factor between discrete and continuous Fourier transforms"  Can you elaborate on this? Should i do both kind of analysis?</span>
<span class="comment-copy">If you look at the Wikipedia pages for the <a href="https://en.wikipedia.org/wiki/Fourier_transform#Definition" rel="nofollow noreferrer">continuous</a> and <a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Definition" rel="nofollow noreferrer">discrete</a> transforms, and approximate the integral with a <a href="https://en.wikipedia.org/wiki/Riemann_sum" rel="nofollow noreferrer">Riemann sum</a>, you'll see that the two differ by a factor of <code>dt</code>, the time-step, which I think is <code>ts</code> in your code. This does depend on whether your intuition is for the continuous or discrete case, but I'd try multiplying your answer by <code>ts</code> and see if it fits your intuition better.</span>
