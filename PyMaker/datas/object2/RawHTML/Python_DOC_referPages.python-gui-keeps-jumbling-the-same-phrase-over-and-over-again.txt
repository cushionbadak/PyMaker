<div class="post-text" itemprop="text">
<p>I am trying to make a GUI using tkinter. In this GUI the user has to guess the jumbled phrase. The problem is, the list presents in the <code>startgame</code> function only returns the last element. Also, instead of getting different jumbled phrases every time on correct guess, I keep getting the same jumbled phrase with just its order in which it is jumbled changed.</p>
<p>Here is the complete code.</p>
<pre><code> #GUI app logic
import random
from tkinter import *
tv_shows = ['Game of Thrones','Friends','How I Met Your Mother','Breaking Bad','Narcos','Flash','Arrow','Big Bang Theory','Walking Dead','Agents Of Shield','Blue Planet 2',
            'Legion','The Grand Tour','Band Of Brothers','Westworld','Sherlock','The Punisher', 'True Detective', 'Daredevil','Luke Cage','Jessica Jones','Iron Fist','Stranger Things',
            'Rick and Morty', 'House of Cards', '13 Reasons Why','House MD', 'Castle','Doctor Who','Dexter','Suits']
score = 0
user_list=[]
time= 0
for i in range(1,11,1):
    user_list.append(random.choice(tv_shows))

print(user_list)


def jumble(word):   
    jum=" "
    while word:
        pos=random.randrange(len(word))
        jum +=word[pos]
        word=word[:pos]+word[(pos + 1):]
    return jum

def sen_jumble(w):
    l=[]
    for i in w:
        new = jumble(i)
        l.append(new)
    l=" ".join(l)
    return l

def start_game(event):
    timetaken()
    jumb_list = []
    global score
    for i in user_list:
        r1 = sen_jumble(i.split())
        jumb_list.append(r1)
        guess.focus_set()
    if time&gt;0:
        for i in range(0,10,1):              
            word.config(text = "Jumbled Word =&gt; " + str(jumb_list[i]))

            if guess.get().lower() == user_list[i].lower():
                score += 1
                score_display.config(text = str(score))
                guess.delete(0,END)


def timetaken():
   global time
   if time&gt;=0:
      time += 1
      timeout.config(text = "Time : "+ str(time))
      timeout.after(1000, timetaken)

main = Tk()
main.title("Guess What")
main.geometry("375x200")

rules = Label(main, text="Guess the correct Tv-show name for the jumbled one shown")
rules.pack()

word = Label(main)
word.pack()

score_display = Label(main)
score_display.pack()

timeout = Label(main)
timeout.pack()

guess = Entry(main)
main.bind('&lt;Return&gt;',start_game)
guess.pack()
guess.focus_set()

main.mainloop()    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that <code>&lt;RETURN&gt;</code> is bound to <code>start_game()</code>, so while you believe you are looping through guesses and answers, the fact is that every time the user hits <code>&lt;RETURN&gt;</code> on their answer, a new instance of <code>start_game()</code> begins!  We instead need to split setting up the new word (aka <code>start_game()</code> from the <code>&lt;RETURN&gt;</code> event (aka <code>score_game()</code>).</p>
<p>I've reworked your code along these lines below--for simplicity, I tossed the timing code altogether as it was broken and not part of your question:</p>
<pre><code>from random import shuffle
from tkinter import *

JUMBLED, PLAINTEXT = 0, 1

tv_shows = [
    'Game of Thrones', 'Friends', 'How I Met Your Mother', 'Breaking Bad', 'Narcos', 'Flash', 'Arrow', 'Big Bang Theory',
    'Walking Dead', 'Agents Of Shield', 'Blue Planet 2', 'Legion', 'The Grand Tour', 'Band Of Brothers', 'Westworld'
    'Sherlock', 'The Punisher', 'True Detective', 'Daredevil', 'Luke Cage', 'Jessica Jones', 'Iron Fist', 'Stranger Things',
    'Rick and Morty', 'House of Cards', '13 Reasons Why', 'House MD', 'Castle', 'Doctor Who', 'Dexter', 'Suits'
]

def word_jumble(word):
    letters = list(word)

    shuffle(letters)

    return "".join(letters)

def sentence_jumble(w):
    words = w.split()

    shuffle(words)

    return " ".join(word_jumble(word) for word in words)

def start_game():
    global jumble

    guess.focus_set()

    jumble = jumble_list.pop()

    word.config(text="Jumbled Words =&gt; " + jumble[JUMBLED])

def score_game(event):
    global score

    if guess.get().lower() == jumble[PLAINTEXT].lower():
        guess.delete(0, END)

        score += 1
        score_display.config(text=str(score))

        if jumble_list:
            score_display.after(500, start_game)
        else:
            main.unbind('&lt;Return&gt;')

shuffle(tv_shows)

jumble_list = [(sentence_jumble(title), title) for title in tv_shows]

score = 0
jumble = None  # a tuple with (jumbled, plaintext)

main = Tk()
main.title("Guess What")
main.geometry("375x200")

Label(main, text="Guess the TV show name from the jumbled one shown").pack()

word = Label(main)
word.pack()

score_display = Label(main)
score_display.pack()
score_display.config(text=str(score))

guess = Entry(main)
guess.pack()
guess.focus_set()

main.bind('&lt;Return&gt;', score_game)

start_game()

main.mainloop()
</code></pre>
<p>You'll need to add back in the end of game scenario.  You can limit the number of rounds by truncating <code>jumble_list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This part:</p>
<pre><code>    for i in range(0,10,1):              
        word.config(text = "Jumbled Word =&gt; " + str(jumb_list[i]))

        if guess.get().lower() == user_list[i].lower():
            score += 1
            score_display.config(text = str(score))
            guess.delete(0,END)
</code></pre>
<p>Your for loop will not wait for you to finish the guess. It always finishes the loop and config your <code>word</code> widget 10 times until it reaches the last one. You can get rid of the <code>for</code> loop and advance the list index base on current score:</p>
<pre><code>def start_game(event):
    timetaken()
    jumb_list = []
    global score
    for i in user_list:
        r1 = sen_jumble(i.split())
        jumb_list.append(r1)
        guess.focus_set()
    word.config(text = "Jumbled Word =&gt; " + str(jumb_list[score]))
    if guess.get().lower() == user_list[score].lower():
        score += 1
        score_display.config(text = str(score))
        try:
            word.config(text="Jumbled Word =&gt; " + str(jumb_list[score]))
        except IndexError:
            word.config(text="You Win!")
            score = 0
        guess.delete(0,END)
</code></pre>
</div>
<span class="comment-copy">Ok, I see now where i made a mistake, Thanks for the help</span>
<span class="comment-copy">The thought of removing the loop never crossed my mind, I should have seen that with every enter press i start the game again so The loop was not required. Thanks a lot</span>
