<div class="post-text" itemprop="text">
<p><strong>Update:</strong> If it helps narrow down the question for anyone, this question is really more about the CPython API and whether or not I'm missing some way to reach information that I need.  I'm not asking for solutions to a broader problem, but rather in working on a broader problem I hit upon a specific question about CPython and whether or not it provided a way that was not obvious to me to obtain some specific information.  I only tagged the question <a class="post-tag" href="/questions/tagged/c" rel="tag" title="show questions tagged 'c'">c</a> because by its nature it requires some C expertise, but it is <em>not</em> a general question about C or specific architectures/platforms.</p>
<p>See also the note below about one possible approach using <code>PyEval_SetTrace</code>, though I was hoping their might be a better way.  As another example, there exists a <code>PyMain_GetArgcArgv</code> which would do the trick here, but <em>only</em> if the Python interpreter were started from the <code>python</code> executable rather than embedded (which might be an acceptable limitation).  Also <code>PyMain_GetArgcArgv</code> is not documented as part of the API.</p>
<hr/>
<p>I would like to be able to find the address of a C stack frame (i.e. the <code>__builtin_frame_address(0)</code> as defined appropriately for that platform) that is most closely associated with a Python stack frame.  In particular I'd like to find the outer-most frame--or close to it--associated with a Python function call, to be defined better below.</p>
<p>The context, to summarize, is that I'm wrapping a C library that uses an obscure custom-purpose garbage collector which needs a pointer to the bottom of the stack--at least as far back as there are local variables pointing to objects that should be tracked by the GC.  Ideally I could mark the bottom of the stack once; in this case since it is being wrapped in a Python module it is sufficient to go down to the outer-most Python stack frame.  The best available alternative would be to manually mark the stack bottom whenever entering calls to the library, but this is not ideal, and also would require patching to the library (which may be needed either way), as it currently only allows setting the stack bottom address once, during an initialization function.</p>
<p>How exactly a Python stack frame is associated with a C stack frame is ill-defined as it is, as there is technically no hard-and-fast connection between the two.  However, for the practical purpose at hand it would be at or close to (depending on compiler optimizations, etc.) the <a href="https://github.com/python/cpython/blob/e63e617ebbe481c498bdf037a62e09f4f9f3963f/Python/ceval.c#L530" rel="nofollow noreferrer"><code>PyEval_EvalFrameEx</code></a> call for the frame being executed (I'm not interested in frames that are not currently on the call stack since it's obviously a meaningless question in that case).</p>
<p>This is all obviously very CPython-specific and that's OK for my purposes.  That being the case, there's no reason technically that the CPython <code>PyFrameObject</code> struct implementation couldn't carry information like this on one of its members, but as far as I can tell there's nothing specifically stored on <code>PyFrameObject</code>s that would allow me to associate it with a C stack frame.  For example, my problem would be "solved" well-enough, for the purposes of this application, if there were something in <code>PyFrameObject</code> like <code>f_cstack</code> that were used like:</p>
<pre><code>PyObject* _Py_HOT_FUNCTION
_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag)
{
    ...
    f-&gt;f_executing = 1;
    f-&gt;f_cstack = &amp;f;
    ...
}
</code></pre>
<p>This would work AFAICT--even though <code>f</code> is typically passed in a register, my gcc will handle code like this by pushing <code>f</code> on the stack and storing its address on the stack.  Unfortunately there is currently nothing like this I can find.</p>
<p>The best idea I've been able to come up with would be to register a <a href="https://docs.python.org/3/c-api/init.html#c.PyEval_SetTrace" rel="nofollow noreferrer"><code>PyEval_SetTrace</code></a> handler, which would be called upon entering Python stack frames and thus give me the opportunity to root around the stack from there.  But really for the application at hand I only need to be able to find the "outer-most" <code>PyEval_EvalFrameEx</code> call, which there will be one of for any running Python code.  So installing a trace callback won't necessarily get me that, and it's additional overhead I don't need for every function call.</p>
<p>I fear there is not currently a good solution to this, though it would be handy if there were.</p>
<p>(P.S. I'm also only concerned about the main stack, and not threads, though any solution that would work on the main thread would likely have a similar solution on auxiliary threads).</p>
</div>
<div class="post-text" itemprop="text">
<p>In general and in principle, you probably cannot always do what you want (it is well known that C implementations might not even need any call stack in some cases). Since sometimes compilers like <a href="https://gcc.gnu.org/" rel="nofollow noreferrer">GCC</a> (or <a href="https://clang.llvm.org/" rel="nofollow noreferrer">Clang</a>) are able of <a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow noreferrer">tail-call</a> compiler <a href="https://en.wikipedia.org/wiki/Optimizing_compiler" rel="nofollow noreferrer">optimizations</a> (which, combined with link-time optimizations, could give surprising results). Some <a href="https://en.wikipedia.org/wiki/Calling_convention" rel="nofollow noreferrer">calling conventions</a> or compilation modes (e.g. <code>gcc -fomit-frame-pointer -m32</code> <a href="https://stackoverflow.com/questions/14666665/trying-to-understand-gcc-option-fomit-frame-pointer">on</a> 32 bits x86) make difficult the traversal of the <a href="https://en.wikipedia.org/wiki/Call_stack" rel="nofollow noreferrer">call stack</a> (at least, without <em>additional</em> data).</p>
<p>In practice, you should investigate using the GNU <a href="https://www.gnu.org/software/libc/manual/html_node/Backtraces.html" rel="nofollow noreferrer">backtrace</a> function and even better Ian Taylor's <a href="https://github.com/ianlancetaylor/libbacktrace" rel="nofollow noreferrer">libbacktrace</a>. This <code>libbacktrace</code> library parses <a href="https://en.wikipedia.org/wiki/DWARF" rel="nofollow noreferrer">DWARF</a> debug information (so it might be Linux specific and perhaps won't work on Windows). On Linux, <a href="http://man7.org/linux/man-pages/man3/dladdr.3.html" rel="nofollow noreferrer">dladdr(3)</a> is able to get a symbol name close to a given address.</p>
<p>So you'll better compile both your main program and the Python runtime (and perhaps additional libraries) with <code>-g</code> flag passed to <code>gcc</code> or <code>g++</code> (to get DWARF debug information), then use <code>libbacktrace</code>. Remember that GCC is able to handle <em>both</em> <code>-g</code> and optimizations flags like <code>-O2</code> at the same time. The performance of the binary or library does not suffer (since optimizations are done by the GCC compiler).</p>
<p>For hunting <a href="https://en.wikipedia.org/wiki/Memory_leak" rel="nofollow noreferrer">memory leaks</a> (which was indirectly mentioned in some comment, but not in the question itself), some tools are available (e.g. <a href="https://valgrind.org/" rel="nofollow noreferrer">valgrind</a>). Asking if they are adequate for a mixed Python + C program is a different question.</p>
<p>Garbage collection bugs are painful to hunt (and I did wrote several GCs myself -notably in my obsolete <a href="http://starynkevitch.net/Basile/gcc-melt/" rel="nofollow noreferrer">GCC MELT</a> and in my <a href="https://github.com/bstarynk/bismon/" rel="nofollow noreferrer">bismon</a>-, so I speak by experience; read also the <a href="https://gchandbook.org/" rel="nofollow noreferrer">GC handbook</a>). Mixing a GC with another one (Python refcounting mechanism is a GC mechanism) is painful and brittle. It could be more reasonable <em>in practice</em> to split your software in several processes using <a href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="nofollow noreferrer">inter-process communication</a> facilities (and these are operating system specific).</p>
<p>Since <a href="https://github.com/python/cpython" rel="nofollow noreferrer">CPython</a> is <a href="https://en.wikipedia.org/wiki/Free_software" rel="nofollow noreferrer">free software</a>, you might <a href="https://en.wikipedia.org/wiki/Fork_(software_development)" rel="nofollow noreferrer">fork</a> it to add <code>libbacktrace</code> support inside (and doing that should be reasonably easy, technically speaking).</p>
</div>
<span class="comment-copy">On which operating system?</span>
<span class="comment-copy">This is hypothethically an OS-independent question, so it can't rely on specific binary formats or anything.  I'm adding a small update.</span>
<span class="comment-copy">In practice, it is not OS-neutral</span>
<span class="comment-copy">Could be some <a href="http://xyproblem.info" rel="nofollow noreferrer">XY problem</a>... what is the <i>actual</i> issue you have? That should be mentioned in the question</span>
<span class="comment-copy">It's not an XY problem.  The actual issue has other (albeit less satisfying) solutions, and I'm just curious if anyone is clever enough to find a solution that I can't see to this approach to the problem.  Thank you for trying to help but the <i>actual</i> issue is as stated.</span>
<span class="comment-copy">I realize this is problematic, "in general", and I don't <i>think</i> tail-call optimizations would come into play much when it comes to calls into the Python interpreter (and even if that were so it actually wouldn't be much of a problem in this case).  The application here is not actually debugging-related but garbage collection-related.  I certainly can (and do) compile Python with debugging info, but I can't guarantee that will be the case everywhere.</span>
<span class="comment-copy">"Mixing a GC with another one (Python refcounting mechanism is a GC mechanism) is painful and brittle." In this case it already works quite well and there is a simple, deterministic interaction between Python wrappers for objects tracked by the other GC, and the Python reference counts.  In fact, wrapping such objects in Python objects makes it easier because we can use refcounts to mark those objects as alive for the other GC.  The problem comes in with local variables.  We might just ensure that all objects handled by the other GC are returned from some pool rather than on the stack.</span>
<span class="comment-copy">I'm ready to discuss that face to face (with your computer and a board). I could even come to Paris Sud in one or two hours (if you ask by email). I'am offering (only today dec 4th 2018) to be your <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging" rel="nofollow noreferrer">rubber duck</a> if you ask.</span>
<span class="comment-copy">Thank you for the kind offer, but I'm not available today anyways; I have to leave for an appointment in an hour or else I might take you up on that.  You seem like an interesting person from whom I'm sure I could learn a thing or two, but frankly this interaction has soured me on any interest in pursuing this particular matter further unless you're an expert on Python internals; I will probably ask the CPython devs what they think instead since really all I'm asking is a particularity of CPython.    Would love to meet and chat some other time though.</span>
