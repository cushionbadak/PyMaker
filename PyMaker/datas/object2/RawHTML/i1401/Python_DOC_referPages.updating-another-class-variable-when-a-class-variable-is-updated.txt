<div class="post-text" itemprop="text">
<p>I'm trying to create a matrix class that stores the original input, and then creates 2 more variables from the original input, called rows and columns, meaning that I can access specific rows or columns by doing something like matrix([[1, 2], [3, 4]]).rows[0] to get [1, 2] or matrix([[1, 2], [3, 4]]).columns[0] to get [1, 3]. So far this works quite well, however if I wanted to reassign a row or column to another value, such as:</p>
<pre><code>A = matrix([[1, 2], [3, 4]])
print(A.columns[0])
</code></pre>
<p>which gives me:</p>
<blockquote>
<p>[1, 2]</p>
</blockquote>
<p>but if I were to perform this block of code further down to update a column like this, </p>
<pre><code>A.columns[0] = [5, 6]
</code></pre>
<p>and then print out A again, it would give me the original input, </p>
<pre><code>print(A)
</code></pre>
<blockquote>
<p>[[1, 2], [3, 4]]</p>
</blockquote>
<p>but printing a.columns[0] gives me the updated column, </p>
<blockquote>
<p>[5, 6]</p>
</blockquote>
<p>and printing a.columns as a whole gives me</p>
<blockquote>
<p>[[5, 6], [2, 4]]</p>
</blockquote>
<p>How would I code it in such a way that doing A.columns[0] updates both the input variable and the column variable?
Here's my original code:</p>
<pre><code>class matrix:
    def __init__(self, values):
        self.values = values
        self.rows = [row for row in self.values]
        self.columns = [[row[i] for row in self.values] for i in    range(list(set([len(row) for row in self.values]))[0])]

    def __setattr__(self, name, value):
        if name not in ["rows", "columns"]:
            self.__dict__[name] = value
        elif hasattr(self, name):
            #This is the part of code I'm trying to use to attempt updating self.values and self.columns at once, but it isn't even printing so I didn't bother writing any code for it
            print name, value
        else:
            self.__dict__[name] = value

    def __setitem__(self, index, value):
        print index, value

    def __str__(self):
        return str(self.values)

a = matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
a.columns[1] = [4, 4, 4]
print(a)
</code></pre>
<p>still gives</p>
<blockquote>
<p>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</p>
</blockquote>
<p>when I want it to give me [[1, 4, 3], [4, 4, 6], [7, 4, 9]], but of course updating the columns variable would have nothing to do with self.values (which is the original input variable), since its like having 2 completely separate variables. How do I link them together so that any changes from self.values updates into self.columns and self.rows and any changes from self.columns and self.rows update self.values?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are asking is not easy. You want to: </p>
<ul>
<li>Define something that looks like a attribute in a class </li>
<li>But you don't want that attribute to hold any value. </li>
<li>Show a transformation of another attribute</li>
<li>Be able to retrieve or set a slice of that transformation</li>
</ul>
<p>On way to do that is create a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property attribute</a> that will give you what you want instead of copying the values when you create an instance. That property attribute could then override the method to simulate an index in your <code>matrix</code>. It could look like:</p>
<pre><code>class Matrix:

    def __init__(self, values):
        self.values = values
        self.rows = self.Row_view(self)
        self.columns = self.Columns_view(self)

    class Columns_view:

        def __init__(self, owner):
            self.owner = owner

        def __str__(self):
            return str(list(list(x) for x in zip(*self.owner.values)))

        def __getitem__(self, key):
            return [row[key] for row in self.owner.values]

        def __setitem__(self, key, new_values):
            for (row, new_row_value) in zip(self.owner.values, new_values):
                row[key] = new_row_value

    class Row_view:

        def __init__(self, owner):
            self.owner = owner

        def __str__(self):
            return str(self.owner.values)

        def __getitem__(self, key):
            return self.owner.values[key]

        def __setitem__(self, key, new_values):
            self.owner.values[key] = new_values

    def __str__(self):
        return str(self.values)

A = Matrix([[1, 2], [3, 4]])
print(A.columns[0])

A.columns[0] = [5, 6]
print(A)

print(A.columns[0])
print(A.columns)

a = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
a.columns[1] = [4, 4, 4]
print(a)

print(a.columns[:2])
</code></pre>
<p>There could be other ways to do that but it's probably the simpler way to do that unless you have additional requirements.</p>
</div>
<span class="comment-copy">I don't understand what purpose this would have. You've overwritten an attribute that describes the original object; how is the object supposed to respond to that? You will clearly have a mismatch. Are you looking for something like <code>.reshape()</code> in numpy?</span>
<span class="comment-copy">Thats the thing, I would like those attributes to affect each other instead of simply just be a copy of the rows and columns when initialised. As for the reshape, I don't use numpy so I have no idea what that is.</span>
<span class="comment-copy">How I would like it to respond is that whenever I update matrix.columns[columnNumber] = a list, I want it to update matrix.values as well, and vice versa</span>
