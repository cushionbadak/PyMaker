<div class="post-text" itemprop="text">
<p>Windows 10, Python 2.7.4</p>
<p>Endless loop , no output with PoolExecutor implemented</p>
<p>Please help , code as following:</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor as PoolExecutor
from subprocess import Popen, PIPE

script_to_exec = "extract_logs.py"

d_list = ["E:\work\d_010_001.txt", "E:\work\d_010_002.txt", "E:\work\d_010_003.txt"]
i_list = ["E:\work\im_010_001.txt", "E:\work\im_010_002.txt", "E:\work\im_010_003.txt"]
output_folder_prefix = r"E:\work\output"


def get_output_folder_name(prefix, any_d):
    return prefix + \
    str("\\") + \
    str(any_d.split(".")[0].split("\\")[-1].split("d_", 1)[1])


def get_exec(d, i, output_folder_prefix ):
    process = Popen(['python', script_to_exec,
                            '-d', d,
                            '-i', i,
                            '-o', get_output_folder_name(output_folder_prefix)],
                            stdout=PIPE)
data = process.communicate()
for line in data:
    print(line)


with PoolExecutor(max_workers=2) as executor:
   for _ in executor.map(get_exec, d_list, i_list, output_folder_prefix):
       pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" rel="nofollow noreferrer">docs</a></p>
<blockquote>
<p>The <strong>main</strong> module must be importable by worker subprocesses. This
  means that ProcessPoolExecutor will not work in the interactive
  interpreter.</p>
</blockquote>
<p>The trouble with the way processes have to be created in windows means that you would need to incorporate <code>if __name__ == '__main__': main()</code> type of syntax as shown in the <a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor-example" rel="nofollow noreferrer">example</a> and run it from the terminal. </p>
<p>If you would like to further read into why that is, look into <a href="https://docs.python.org/3/library/multiprocessing.html#the-process-class" rel="nofollow noreferrer">multiprocessing</a>, which is being used under the wraps for concurrent futures, and further read <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing-programming" rel="nofollow noreferrer">here</a> . </p>
<p>The summary however, would be that windows does not have an os.fork method, and so has to utilize a "cheat" to create a subprocess, which is to create an entirely new python instance and execute the script from the top to reach a similar state. This however, means that each new version needs to be given the knowledge that is it not the main thread that started the process spawning.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are launching Python interactively.<br/>
The interpreter's you are launching via subprocess aren't exiting after executing the script - that's why they are kept open forever.</p>
<p>Just a hint especially for debugging:
Have a look at stderr and check for the result code of the subprocesses:</p>
<pre><code>def get_exec(d, i, output_folder_prefix ):
    process = Popen(['python', script_to_exec,
                            '-d', d,
                            '-i', i,
                            '-o', get_output_folder_name(output_folder_prefix)],
                        stdout=PIPE,
                        stderr=PIPE)
    data, err = sp.communicate()
    if process.returncode != 0:
        print "An error happend ..."
    for line in data:
        ...
</code></pre>
</div>
<span class="comment-copy">I believe there are some exceptions in your worker. You can use <code>Future.result()</code> to get those.</span>
<span class="comment-copy">You might want to consider not using an ancient Python version. If the 3.x versions aren't an option, at least upgrade to the latest 2.7.15.</span>
<span class="comment-copy"><code>ProcessPoolExecutor</code> creates child process. So does<code>Popen</code>. It seems unnecessary. Use plain <code>map</code></span>
