<div class="post-text" itemprop="text">
<p>In Python, it is known that <em>in</em> checks for membership in iterators (lists, dictionaries, etc) and looks for substrings in strings. My question is regarding how <em>in</em> is implemented to achieve all of the following: 1) test for membership, 2) test for substrings and 3) access to the next element in a for-loop.  For example, when <code>for i in myList:</code> or <code>if i in myList:</code> is executed, does <em>in</em> call <code>myList.__next__()</code>? If it does call it, how then does it work with strings, given that <em>str</em> objects are not iterators(as checked in Python 2.7) and so do not have the <em>next()</em> method? If a detailed discussion of <em>in</em>'s implementation is not possible, would appreciate if a gist of it is supplied here. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>A class can define how the <code>in</code> operator works on instances of that class by defining a <code>__contains__</code> method.</p>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">Python data model documentation</a> says:</p>
<blockquote>
<p>For objects that donâ€™t define <code>__contains__()</code>, the membership test first tries iteration via <code>__iter__()</code>, then the old sequence iteration protocol via <code>__getitem__()</code>, see <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">this section in the language reference</a>.</p>
</blockquote>
<p><a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow noreferrer">Section 6.10.2, "Membership test operations", of the Python language reference</a> has this to say:</p>
<blockquote>
<p>The operators <code>in</code> and <code>not in</code> test for membership. <code>x in s</code> evaluates to <code>True</code> if <em>x</em> is a member of <em>s</em>, and <code>False</code> otherwise. <code>x not in s</code> returns the negation of <code>x in s</code>. All built-in sequences and set types support this as well as dictionary, for which <code>in</code> tests whether the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression <code>x in y</code> is equivalent to <code>any(x is e or x == e for e in y)</code>.</p>
<p>For the string and bytes types, <code>x in y</code> is <code>True</code> if and only if <em>x</em> is a substring of <em>y</em>. An equivalent test is <code>y.find(x) != -1</code>. Empty strings are always considered to be a substring of any other string, so <code>"" in "abc"</code> will return <code>True</code>.</p>
<p>For user-defined classes which define the <code>__contains__()</code> method, <code>x in y</code> returns <code>True</code> if <code>y.__contains__(x)</code> returns a true value, and <code>False</code> otherwise.</p>
<p>For user-defined classes which do not define <code>__contains__()</code> but do define <code>__iter__()</code>, <code>x in y</code> is <code>True</code> if some value <code>z</code> with <code>x == z</code> is produced while iterating over <code>y</code>. If an exception is raised during the iteration, it is as if <code>in</code> raised that exception.</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines <code>__getitem__()</code>, <code>x in y</code> is <code>True</code> if and only if there is a non-negative integer index <em>i</em> such that <code>x == y[i]</code>, and all lower integer indices do not raise <code>IndexError</code> exception. (If any other exception is raised, it is as if <code>in</code> raised that exception).</p>
<p>The operator <code>not in</code> is defined to have the inverse true value of <code>in</code>.</p>
</blockquote>
<p>As a comment indicates above, the <em>expression operator</em> <code>in</code> is distinct from the <em>keyword</em> <code>in</code> which forms a part of <a href="https://docs.python.org/3/reference/compound_stmts.html#for" rel="nofollow noreferrer">the <code>for</code> statement</a>. In the Python grammar, the <code>in</code> is "hardcoded" as a part of the syntax of <code>for</code>:</p>
<blockquote>
<pre><code>for_stmt ::=  "for" target_list "in" expression_list ":" suite
              ["else" ":" suite]
</code></pre>
</blockquote>
<p>So in the context of a <code>for</code> statement, <code>in</code> doesn't behave as an operator, it's simply a syntactic marker to separate the <code>target_list</code> from the <code>expression_list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has <code>__contains__</code> special method that is used when you do <code>item in collection</code>.</p>
<p>For example, here's a class that "__contains__" all even numbers:</p>
<pre><code>&gt;&gt;&gt; class EvenNumbers:
...   def __contains__(self, item):
...     return item % 2 == 0
...
&gt;&gt;&gt; en = EvenNumbers()
&gt;&gt;&gt; 2 in en
True
&gt;&gt;&gt; 3 in en
False
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">Note: the <code>in</code> in <code>for i in x</code> is not the same operator as the the <code>in</code> in <code>if i in x</code>.  The first is just syntax/grammar that goes with for, the second is an actual operator.</span>
