<div class="post-text" itemprop="text">
<p>I am looping over an <code>itertools.permutation</code> object and for efficiency, the loop breaks once the item is found. I understand that because I used the <code>for</code> loop I am unable to catch the <code>StopIteration</code> error when the generator is exhausted and the item is not found.</p>
<p>So far I have implemented a <code>found</code> flag, but it seems kinda hacky.</p>
<pre><code>from itertools import permutations

def verify_string(name, compare):
    name = name.lower().split()
    compare = compare.lower().split()
    p = permutations(compare, len(compare))
    found = 0

    for i in p:
        if list(i) == name:
            print(f'Found: {compare} in {name}')
            found = 1
            break

    if not found:
        print('Not Found')

name = 'guido van rossum'
compare = 'van guido rossum'

verify_string(name, compare)
&gt;&gt;Found: ['van', 'guido', 'rossum'] in ['guido', 'van', 'rossum']
</code></pre>
<p>I also thought of checking <code>if not next(p, '')</code> to see if it is exhausted but the item might be found in the generator's last item and will return <code>True</code> anyways.</p>
<p><em>From a Pythonic view, is there a way to manage looping over a generator that <strong>stops and return when an item is found</strong> and <strong>returns a different value only when the generator is exhausted.</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>The Pythonic way is to use a <code>for-else</code> loop.</p>
<pre><code>from itertools import permutations

def verify_string(name, compare):
    name = name.lower().split()
    compare = compare.lower().split()    
    for i in permutations(compare, len(compare)):
        if list(i) == name:
            print(f'Found: {compare} in {name}')
            break
    else:  # Raymond Hettinger calls this "if no break" condition
        # If we did not break out of the "for loop", execute this.
        print('Not Found')

name = 'guido van rossum'
compare = 'van guido rossum'

verify_string(name, compare)
&gt;&gt;&gt; Found: ['van', 'guido', 'rossum'] in ['guido', 'van', 'rossum']
</code></pre>
<h2>Edit</h2>
<p>My initial reply was to how to avoid using the <code>found</code> flag and I wasn't paying attention to what you were actually trying to do. The <code>for-else</code> construct is also a very useful and often neglected language construct that I wanted to highlight.</p>
<p>However, if you <strong>just</strong> want to check if the set of string is a permutation of another, then why not just</p>
<pre><code>match = sorted(name.lower().split()) == sorted(compare.lower().split())
</code></pre>
<p>This avoids the need to go through all possible permutation of the words in the string.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>From a Pythonic view, is there a way to manage looping over a
  generator that stops and return when an item is found and returns a
  different value only when the generator is exhausted.</p>
</blockquote>
<p>As you don't actually return anything - if you fix that part of your function, you'll return <code>None</code> if there are no matches:</p>
<pre><code>from itertools import permutations

def verify_string(name, compare):
    name = name.lower().split()
    compare = compare.lower().split()    
    for i in permutations(compare, len(compare)):
        if list(i) == name:
            return True

name = 'guido van rossum'
compare = 'van guido rossum'

if verify_string(name, compare):
  print(f'Found: {compare} in {name}')
else:
  print('Not found')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two approaches. One is to test a membership of an iterator:</p>
<pre><code>from itertools import permutations
from collections import Counter


def verify_string(name, compare):
    if tuple(compare.lower().split()) in permutations(name.lower().split()):
        print(f"Found: {compare} in {name}")
    else:
        print("No match found")
</code></pre>
<p>We can also avoid the function altogether with a ternary operator:</p>
<pre><code>val if val in itr else other_val
</code></pre>
<p>If the iterator at hand happens to be the <code>permutations</code>, then we can get away without considering every permutation and count words instead.</p>
<pre><code>def verify_string_fast(name, compare):
    if not Counter(compare.lower.split()) - Counter(name.lower.split()):
        print(f"Found: {compare} in {name}")
    else:
        print("No match found")
</code></pre>
<p>More generally, if we have a test condition other than membership, we can do:</p>
<pre><code>def verify_general(val, itr):
    if any(compare(val, x) for x in itr):
        print("Success")
    else:
        print("Failure")
</code></pre>
<hr/>
<p>Note on membership in an iterator. According to the official <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">documentation</a>, </p>
<blockquote>
<p>For user-defined classes which do not define <strong>contains</strong>() but do
  define <strong>iter</strong>(), x in y is True if some value z with x == z is
  produced while iterating over y. If an exception is raised during the
  iteration, it is as if in raised that exception.</p>
</blockquote>
<p>Since <code>permutations</code> has an <code>__iter__</code> method, testing for membership is possible.</p>
<p>For example,</p>
<pre><code>assert (3, 2, 1) in permutations([1, 2, 3])
</code></pre>
</div>
<span class="comment-copy">As a side comment, it is better to cast <code>name</code> as a tuple and test for <code>i == name</code>. This way, you can avoid creating a redundant copy of each permutation.</span>
<span class="comment-copy">Lol that is so true, that was my earlier code without the <code>break</code> and it kept printing because of that. Thanks anyways.</span>
<span class="comment-copy">This is nice but I would prefer checking <code>if tuple(name) in permutations(compare, len(compare))</code> as opposed to the for loop.</span>
<span class="comment-copy">Thanks, I was not paying attention to the string permutation problem too. Rather just trying to understand the best way to loop over a generator finding for values, you answered the <i>question</i> clearly with the <code>for-else</code> construct which I misunderstood earlier.</span>
<span class="comment-copy">@BernardL that is my take too. Also, we can consider replacing <code>sorted</code> with <code>set</code> or <code>Counter</code> for better time complexity, at least on paper.</span>
<span class="comment-copy">@YakymPirozhenko go ahead and post your updated answer with that and I will gladly +1 for a workable solution.</span>
<span class="comment-copy">That's true, I was just juggling with the thoughts of whether to manage it in the function or not.</span>
<span class="comment-copy">The results do not really matter for this question, as long as the generator stops when the criteria are matched. And how would I use <code>itertools.chain</code> for my problem statement?</span>
<span class="comment-copy">I think that I was focusing on the details of the example too much. See if the first snipped added in the last edit does the job.</span>
<span class="comment-copy">Do you mean to convert, <code>list(permutations(name.lower.split()))</code>? Tested and membership testing with generators does not work. For the <code>Counter</code> method, why are you doing an equality test? And where did you define the function <code>compare</code> in <code>verify_general</code>.</span>
<span class="comment-copy">@BernardL there was a typo in my code; <code>permutations(name.lower.split()</code> should be <code>permutations(name.lower().split()</code>. For the details of how testing iterator membership works, see <a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a> I did not define compare, it's meant to be pseudocode for a boolean binary predicate.</span>
<span class="comment-copy">The inequality check for Counter comparison comes into play if <code>compare</code> has fewer words than <code>name</code>, but every word in <code>compare</code> is a word in <code>name</code>.</span>
