<div class="post-text" itemprop="text">
<p>how can I print all sequences of length n containing letters from a list (that can repeat themselves)? <strong>using recursion</strong>.
for example:</p>
<pre><code>seq = ['a', 'b']
n = 2
</code></pre>
<p>output:</p>
<pre><code>aa,ab,ba,bb
</code></pre>
<p>I've been looking up and could only find recursive programs that give all sequences with <strong>no</strong> repetition. furthermore, I couldn't find any solution regarding a given list (most of them are given strings)</p>
<p>one of the problems is that I'm not sure how to address the function recursively while it contains the length n.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can recruse on <code>n</code>, the length of the subsequence. If <code>n == 0</code>, there is only one subsequence - the empty one. Otherwise, you take all pairs of elements of your list and subsequences of length n-1, and get all subsequences of length <code>n</code>.</p>
<pre><code>def subseqs(lst, n):
    if n &lt;= 0:
        return [[]]
    else:
        return [[x] + xs for x in lst for xs in subseqs(lst, n - 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>One of the ways to solve this is to use <code>itertools.product</code></h2>
<pre><code>import itertools

seq = ['a', 'b']
n = 2

for a, b in itertools.product(seq,repeat = n): print (f"{a}{b}") #loop through all the products and print them

#result --&gt; 
# aa
# ab
# ba
# bb
</code></pre>
<p>I hope this helps :)</p>
</div>
<div class="post-text" itemprop="text">
<p>I will use itertools</p>
<pre><code>import itertools

seq = ['a', 'b']
n = 2

print([i+j for i,j in itertools.product(seq,repeat=n)])
</code></pre>
<p>This is a task for product ;)</p>
<p>BTW: if you don’t want modules look at source code: </p>
<pre><code>def product(*args, repeat=1):
    # product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --&gt; 000 001 010 011 100     101 110 111
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)
</code></pre>
<p>Source code at: <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.product</a></p>
<p>Learn and Reverse engineering it to fit your need ;). Example if you don’t want it to return tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another approach, using only recursion. The <code>findSeqRecPerChar</code> finds all possible combinations for a specific character in the list and the <code>findSeqRec</code> find all possible combinations for every character:</p>
<pre><code>seq = ['a', 'b']
n = 2

def findSeqRecPerChar(seq,n,elem,index):
    if index == n:
        return []
    else:
        return [elem+seq[index]] + findSeqRecPerChar(seq,n,elem,index+1)

def findSeqRec(seq,n,index,l):
    if index == n-1:
        return l + []
    else:
        l.extend(findSeqRecPerChar(seq,n,seq[index-1],0))
        return findSeqRec(seq,n,index+1,l)

result = findSeqRec(seq,n,-1,[])

print(result)
</code></pre>
<p>Output:</p>
<pre><code>['aa', 'ab', 'ba', 'bb']
</code></pre>
</div>
<span class="comment-copy">You are looking for PSL <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> module</span>
<span class="comment-copy">cannot use any module ;( @jlandercy</span>
<span class="comment-copy">Is it an homework or an assignment? If so please add the <code>homework</code> tag and state it in your post.</span>
<span class="comment-copy">itertools is part of Python Standard Library. It comes with Python</span>
<span class="comment-copy">thanks. can you explain what xs means? also, would this work for longer sequences? (for example ['a','b','c'] ) @Yakym Pirozhenko</span>
<span class="comment-copy">This would work for longer sequences; <code>xs</code> is a part of a <i>list comprehension</i> - you could look at examples in the documentation. You can accomplish the same task with two for loops, but that may be less elegant from Python standpoint.</span>
<span class="comment-copy">In this case, <code>xs</code> stands for a subsequence of length <code>n-1</code>.</span>
<span class="comment-copy">I think that OP does not want to use <code>itertools</code>. Otherwise, you could also use <code>combinatons_with_replacement</code> of the shelf.</span>
<span class="comment-copy">He can look at source code and rewrite itertools product function ;)</span>
<span class="comment-copy">Probably will be educational, although I think that product is implemented in C for efficiency.</span>
<span class="comment-copy">Pedantic, but here is the actual source: <a href="https://github.com/python/cpython/blob/9718b59ee5f2416cdb8116ea5837b062faf0d9f8/Modules/itertoolsmodule.c#L2090" rel="nofollow noreferrer">github.com/python/cpython/blob/…</a> The snippet above is a Python analog.</span>
<span class="comment-copy">Probably he wants it in Python layer ;)</span>
