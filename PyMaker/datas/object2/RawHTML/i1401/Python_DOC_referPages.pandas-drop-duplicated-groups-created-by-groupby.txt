<div class="post-text" itemprop="text">
<p>I'd like to create groups by a custom ID, and then eliminate groups that are duplicates in some columns.</p>
<p>For example </p>
<pre><code>| id | A   | B  |
|----|-----|----|
| 1  | foo | 40 |
| 1  | bar | 50 |
| 2  | foo | 40 |
| 2  | bar | 50 |
| 2  | cod | 0  |
| 3  | foo | 40 |
| 3  | bar | 50 |
</code></pre>
<p>to</p>
<pre><code>| id | A   | B  |
|----|-----|----|
| 1  | foo | 40 |
| 1  | bar | 50 |
| 2  | foo | 40 |
| 2  | bar | 50 |
| 2  | cod | 0  |
</code></pre>
<p>Here I grouped by id and then i removed 3 because, if we only consider columns A and B, they are identical, while group 2 has some duplicated rows but its not an exact copy.</p>
<p>I've tried looping over groups but its very slow even tho there is only around 12.000 groups. One possible complication is that groups have variable sizes.</p>
<p>Here is the solution ive been working on but its taking way to long with no aparent duplicated hits (which i know exists in this db)</p>
<pre><code>grps = datafinal.groupby('Form_id') 
unique_grps={}

first=True
for lab1, grp1 in grps:
    if first:
        unique_grps[lab1] = grp1
        first=False
        continue
    for lab2, grp2 in unique_grps.copy().items():
        if grp2[['A','B']].equals(grp1[['A','B']]):
            print("hit")
            continue
        unique_grps[lab1] = grp1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>agg</code> <code>tuple</code> and <code>duplicated</code></p>
<pre><code>s=df.groupby('id').agg(tuple).sum(1).duplicated()
df.loc[df.id.isin(s[~s].index)]
Out[779]: 
   id    A   B
0   1  foo  40
1   1  bar  50
2   2  foo  40
3   2  bar  50
4   2  cod   0
</code></pre>
<p>More info : Right now , everything within the group is in one <code>tuple</code> </p>
<pre><code>df.groupby('id').agg(tuple).sum(1)
Out[780]: 
id
1            (foo, bar, 40, 50)
2    (foo, bar, cod, 40, 50, 0)
3            (foo, bar, 40, 50)
dtype: object
</code></pre>
<hr/>
<p>Update </p>
<pre><code>from natsort import natsorted
s=df.groupby('id').agg(tuple).sum(1).map(natsorted).map(tuple).duplicated()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>unique_everseen</code> recipe</a> from the <code>itertools</code> docs (also found in the <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools</code></a> library), together with <code>pd.concat</code> and <code>groupby</code>:</p>
<pre><code>from operator import itemgetter
from more_itertools import unique_everseen

def unique_key(x):
    return tuple(map(tuple, x[['A', 'B']].values.tolist()))

def jpp(df):
    groups = map(itemgetter(1), df.groupby('id'))
    return pd.concat(unique_everseen(groups, key=unique_key))

print(jpp(df))

   id    A   B
0   1  foo  40
1   1  bar  50
2   2  foo  40
3   2  bar  50
4   2  cod   0
</code></pre>
</div>
<span class="comment-copy">Can't you just drop duplicates w.r.t. columns A and B first?</span>
<span class="comment-copy">@timgeb I don't think that will work. Imagine group 2 had 1 of the rows of group 3 and group 1 had the other. <code>drop_duplicates</code> would remove group 3 even though it's not fully duplicated by one group.</span>
<span class="comment-copy">@timgeb that would remove group 2 first two rows, which i need to keep.</span>
<span class="comment-copy">Ah, ok, thanks for clarifying.</span>
<span class="comment-copy">Can you use the built-in <a href="http://pandas.pydata.org/pandas-docs/version/0.17/generated/pandas.DataFrame.drop_duplicates.html" rel="nofollow noreferrer">drop duplicates</a> with the subset as <code>'A', 'B'</code> on your result DF?</span>
<span class="comment-copy">Nice, this gets me 90% there, however I need to specify a subset of the columns i want to check for duplicates, (for simplicity I didn't add more columns in my example but say there are 5 columns and the other 3 I don't care about)</span>
<span class="comment-copy">Oh but i can just subset the dataframe on the first step can't I? This would work then.</span>
<span class="comment-copy">I think perhaps <code>.sort_values</code> first incase the order of rows isn't consistent within groups?</span>
<span class="comment-copy">@user3207377 you can just filter at the first step , then you can achieve what you need</span>
<span class="comment-copy">@ALollz indeed i'm now looking at sorting the values. I'm unsure at which point though.</span>
