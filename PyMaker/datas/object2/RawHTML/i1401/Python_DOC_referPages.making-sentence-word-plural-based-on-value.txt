<div class="post-text" itemprop="text">
<p>I'm wondering if there is a preferred or at least more readable/pretty/pythonic way to make a sentence plural based on data being put into it.</p>
<p><strong>Here's how I'm doing it now</strong></p>
<pre><code>ret = f'Done! {deleted} entr{"y was" if deleted == 1 else "ies were"} removed.'
</code></pre>
<p>I know this works, but it just doesn't sit well when I go and read it. I've thought of either making a function or using a dict-switch (which is something I kinda like) but maybe someone knows a better way.</p>
<p><strong>Solutions I've tried:</strong></p>
<p><em>using a dict</em></p>
<pre><code>plural = {1:'y was'}
ret = f'Done! {deleted} entr{plural.get(deleted, "ies were")} removed.'
</code></pre>
<p><em>using a function</em></p>
<pre><code>def plural(num: int):
    return 'y was' if num == 1 else 'ies were'
</code></pre>
<p><em>using boolean operators</em></p>
<pre><code>ret = f'Done! {deleted} entr{deleted != 1 and "ies were" or "y was"} removed.'
</code></pre>
<p>Those are really the only other ways I can think of right now that makes sense, also the reason I want this is because I have multiple places where I'd need to make words plural. The issue is, I may want to use different wording in places and would like to keep from repeating myself with making word(s) plural for human-readable format.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe in this single instance (if we are talking a few strings to be declinated) then such approaches are sufficient.</p>
<p>But in general case, localization (L10N) and internationalization (I12N) is best handled with suitable libraries.</p>
<p>In case of python we have a standard library <a href="https://docs.python.org/3/library/gettext.html" rel="nofollow noreferrer"><code>gettext</code></a> that can be used for this purpose. It is effectively a python API to <a href="https://www.gnu.org/software/gettext/manual/gettext.html" rel="nofollow noreferrer">GNU gettext</a> which is a neat option for a start.
There are supplementary resources:</p>
<ol>
<li><a href="http://www.supernifty.org/blog/2011/09/16/python-localization-made-easy/comment-page-1/" rel="nofollow noreferrer">Step-by-step guide</a> how to localize your python script.</li>
<li><a href="https://phraseapp.com/blog/posts/translate-python-gnu-gettext/" rel="nofollow noreferrer">A more in-depth introduction to GNU gettext</a> in the context if python.</li>
<li>Or <a href="https://inventwithpython.com/blog/2014/12/20/translate-your-python-3-program-with-the-gettext-module/" rel="nofollow noreferrer">another one</a> if the previous does not suit you.</li>
<li>And finally, much more involved but comprehensive <a href="https://www.mattlayman.com/blog/2015/i18n/" rel="nofollow noreferrer">python internationalization guide</a>.</li>
</ol>
<p>In short, there is much more to L10N and I12N than plurals...</p>
</div>
<div class="post-text" itemprop="text">
<p>While I found <a href="https://stackoverflow.com/a/53590442/225020">@sophros answer</a> very knowledgeable and informative, I decided it was more than I needed. I decided to write my own custom class as I needed something cheap and easy and that I can reuse for different words/sentences. Feel free to use yourself if you like it!</p>
<pre><code>class Plural:
    __slots__ = 'word', 'value', 'singular', 'plural', 'zero', 'ignore_negatives'

    def __init__(self, value: int, word: str = "", **kwargs):
        """
        Parameters
        ----------
        value : int
            The determining value
        word : str, optional
            The word to make plural. (defaults to "")
        singular : str, optional
            Appended to `word` if `value` == 1. (defaults to '')
        plural : str, optional
            Appended to `word` if `value` &gt; 1. (defaults to 's')
        zero : str, optional
            Replaces `value` if `value` == 0. (defaults to 0)
        ignore_negatives : bool, optional
            This will raise ValueError if `value` is negative. (defaults to False)
            Set to True if you don't care about negative values.
        """

        self.value, self.word = value, word
        self.singular = kwargs.pop('singular', '')
        self.plural = kwargs.pop('plural', 's')
        self.zero = kwargs.pop('zero', 0)
        self.ignore_negatives = kwargs.pop('ignore_negatives', False)

    def __str__(self):
        v = self.value
        pluralizer = self.plural if abs(v) &gt; 1 else self.singular

        if v &lt; 0 and not self.ignore_negatives:
            raise ValueError

        return f"{v or self.zero} {self.word}{pluralizer}"
</code></pre>
<p><strong>Test that it works</strong></p>
<pre><code>print(Plural(-2, singular="entry", plural="entries", ignore_negatives = True))
#-2 entries
print(Plural(-1, singular="entry", plural="entries", ignore_negatives = True))
#-1 entry
print(Plural(0, singular="entry", plural="entries"))
#0 entries
print(Plural(1, singular="entry", plural="entries"))
#1 entry
print(Plural(2, singular="entry", plural="entries"))
#2 entries
</code></pre>
<p><strong>With Negative Value</strong></p>
<pre><code>print(Plural(-1, singular="entry", plural="entries"))
#Traceback (most recent call last):                                                                                            
#File "/home/main.py", line 53, in &lt;module&gt;                                                                                  
#    print(Plural(-1, singular="entry", plural="entries"))                                                                     
#  File "/home/main.py", line 43, in __str__                                                                                   
#    raise ValueError                                                                                                          
#ValueError
</code></pre>
<p><strong>Other use cases</strong></p>
<pre><code>print(Plural(1, "entr", singular="y", plural="ies"))
#1 entry
print(Plural(2, "entr", singular="y", plural="ies"))
#2 entries
print(Plural(0, "value", zero="No"))
#No value
print(Plural(1, "value"))
#1 Value
print(Plural(2, "value"))
#2 Values
</code></pre>
<p><strong>If you just want a quick and dirty fix</strong></p>
<p>Either use one of my examples in the question or make a method like in my question but here's a tweaked version as <a href="https://stackoverflow.com/questions/53589770/making-sentence-word-plural-based-on-value#comment94042792_53589770">@Ev. Kounis</a> and <a href="https://stackoverflow.com/questions/53589770/making-sentence-word-plural-based-on-value#comment94042805_53589770">@9769953</a> suggested in the comments <em>(hope ya'll don't mind me putting ur suggestions in the answer)</em></p>
<pre><code>def plural(num: int, word: str = "", single: str = "", mult: str = 's'):
    return f"{num} {(plural, singular)[abs(num) == 1]}"
</code></pre>
</div>
<span class="comment-copy">Your solutions look fine: natural languages generally don't play nice with very structured strings, with lots of exceptions.</span>
<span class="comment-copy">boolean indexing would be yet another option <code>["ies were", "y was"][deleted == 1]</code></span>
<span class="comment-copy">Perhaps allow for the singular and plural form (with a default) in your function variant: <code>def plural(num: int, single='': str, mult='s': str):</code>. That makes it more usable elsewhere. Oh, and change <code>if num == 0</code> to <code>if num == 1</code> in that function.</span>
<span class="comment-copy">How do you handle the case were <code>deleted = 0</code>?</span>
<span class="comment-copy"><code>deleted == 0</code>.. Hmm, yet another reason for this lol</span>
