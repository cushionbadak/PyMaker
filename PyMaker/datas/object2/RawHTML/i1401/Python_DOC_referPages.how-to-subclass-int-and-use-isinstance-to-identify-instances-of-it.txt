<div class="post-text" itemprop="text">
<p>I want to subclass <code>int</code> (or some other analogous builtin numerical type), that I can explicitly type check.  </p>
<p>This q&amp;a is similar, but didn't answer what I'm seeing exactly:
<a href="https://stackoverflow.com/questions/34032765/sub-classing-a-built-in-python-type-such-as-int">Sub-classing a built-in Python type such as int</a></p>
<p>Here's a rough example of what I'm trying to achieve: </p>
<pre><code>class MyId( int ) : pass 

class MyCollection() :

    def __init__( self ):
        self.__id = MyId( 0 )

    def nextId( self ) :        
        self.__id+=1
        print "isinstance",  isinstance(self.__id, MyId)
        return self.__id
</code></pre>
<p>Unfortunately, my invocation of <code>isinstance</code> returns <code>False</code>. How do I make it succeed (ideally with this same basic concept)? It's obvious how to achieve is this by giving MyId class a "has a" rather than "is a" relationship with <code>int</code>... but I thought it be nicer to just make it an <code>int</code> with a specific "name".</p>
<p>Currently, I'm writing this in Py2, but any cross version answers are appreciated if applicable. </p>
</div>
<div class="post-text" itemprop="text">
<p>That's because you need to override the <code>__add__</code> method.</p>
<p>If you don't override this method, it will use the builtin int <code>__add__</code> method which returns a new integer object.</p>
<p>See <a href="https://stackoverflow.com/questions/11836570/how-to-implement-iadd-for-an-immutable-type">this topic</a> which explains this behavior as mentioned by @martineau in comments. </p>
<pre><code>class MyId( int ):
    def __add__(self, i):
        return MyId(super(MyId, self).__add__(i))

class MyCollection() :

    def __init__( self ):
        self.__id = MyId( 0 )

    def nextId( self ) :        
        self.__id += 1
        print "isinstance",  isinstance(self.__id, MyId)
        return self.__id

a = MyCollection()
a.nextId()
</code></pre>
<p>Prints: <code>isinstance True</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of subclassing <code>int</code> just check that your instance variable is an <code>int</code>.</p>
<pre><code>class MyCollection():

    def __init__( self ):
        self.__id = 0

    def nextId( self ) :        
        self.__id += 1
        print "isinstance",  isinstance(self.__id, int)
        return self.__id
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like what you're after is being able to check that values being passed around have been created in a specific way. In <em>Python 3.5.2+</em> there is the <code>typing</code> module that provides <a href="https://docs.python.org/3/library/typing.html#newtype" rel="nofollow noreferrer"><code>NewType</code></a>. This allows you to do static analysis of your code to make sure it's doing the things you expect it to do. The example given in the documentation is:</p>
<blockquote>
<pre><code>from typing import NewType

UserId = NewType('UserId', int)
some_id = UserId(524313)
</code></pre>
<p>The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:</p>
<pre><code>def get_user_name(user_id: UserId) -&gt; str:
    ...

# typechecks
user_a = get_user_name(UserId(42351))

# does not typecheck; an int is not a UserId
user_b = get_user_name(-1)
</code></pre>
</blockquote>
<p>No actual type checking is performed at runtime, and the value returned by <code>NewType</code> is just a pass-through function that returns its argument unchanged. This also means you cannot do things like <code>isinstance(obj, UserId)</code>, since <code>UserId</code> is not an actual class. What is does mean is, as mentioned by the documentation, static type checkers will help uncover logical errors -- which seems like what you're after.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per Dunes' suggestion, I simply dropped the entire <code>int</code> concept entirely. As he pointed out, any vanilla object can implicitly be used as a unique key!</p>
<p>In fact <code>MyId</code> could be defined as simply: <code>class MyId: pass</code>. Often, that would be it - a perfectly usable, implicitly unique key!</p>
<p>For my use case, however, I need to pass these keys back and forth across sub processes (via <code>multiprocessing</code> queues).  I ran into trouble with that ultra light weight approach, as the hash value would change when the objects where pickled and pushed across processes.  A minor secondary concern was that I wanted to make these objects easy to log and manually read / match up through logs.  As such, I went with this:</p>
<pre><code>class _MyIdPrivate: pass
class MyId :
    def __init__( self ):
        self.__priv = _MyIdPrivate() 
        self.__i = hash( self.__priv )            
    def __str__( self ): return str( self.__i )
    def __hash__( self ): return self.__i
    def __eq__( self, other ): 
        try: return self.__i == other.__i
        except: return False     

class MyCollection :

    def __init__( self ):
        self.__objs={}

    def uniqueId( self ): return MyId()

    def push( self, i, obj ):
        self.__objs[ i ] = obj     

    def pop( self, i ):
        return self.__objs.pop( i, None )     

c = MyCollection()
uId = c.uniqueId()
print "uId", uId
print "isinstance", isinstance(uId, MyId)
c.push( uId, "A" )
print c.pop( MyId() )
print c.pop( uId )
</code></pre>
<p>As you can see, I wrapped the short and sweet approach into a more comprehensive/verbose one. When I create the MyId object, I create a _MyIdPrivate member, and take the hash of that at that moment of creation.  When pickling, and pushing across sub projects, that _MyIdPrivate hash will change - but it doesn't matter because I captured the initial value, and everything ends up pivoting off of that.  </p>
<p>The main benefit of this approach over the original <code>int</code> plan is that I get a unique key without "calculating" or assigning it directly.  </p>
<p>As Dunes' suggested I could have also used a uuid. I can see pros and cons to that vs this...</p>
</div>
<span class="comment-copy">If you don't want to implement all the relevant magic methods (<code>__add__, __radd__, etc.</code>) in <code>MyId</code>, you could just go with <code>self.__id = MyId(self.__id + 1)</code>.</span>
<span class="comment-copy">If your goal is to type check, why not just just check that <code>__id</code> is an <code>int</code>? <code>isinstance(self.__id, int)</code></span>
<span class="comment-copy">I agree with @axblount as I don't really understand here the need of overriding the builtin int.</span>
<span class="comment-copy">Thanks, @schwobaseggl . That's definitely in the running for the "best" solution.  It's shorter, but I hate that it requires a client class having to understand what equates to a private implementation detail.  I also don't care for destroying an object and creating a new one, just to change a value.  Essentially, we have an immutable int in that case.</span>
<span class="comment-copy">As I wrote in another comment here, btw: The point is to determine whether some polymorphic functions are returning and/or dealing with a specific kind of object, because the context of what to do with such will hinge on that. I need to differentiate between an int and this "id type".</span>
<span class="comment-copy">Would be a better answer if you explained <i>why</i> <code>__add__()</code> needs to be implemented.</span>
<span class="comment-copy">Hmm.  This is definitely a valid answer,  I upvoted it.  But, I'm not in love with it.  I hate the idea that I have to redefine add the functions that I'm trying to get for free.  That's the point of the sub classing.  @schwobaseggl answer (posted as a comment) might be better... But it's less than perfect too I think...</span>
<span class="comment-copy">Am I going to have to override equality operators too? ... If so I'm not sure that I'm gaining anything by using int as a base...  I already saw couldn't print one of these objects implicitly...</span>
<span class="comment-copy">@martineau that's because it is not totally clear in my head. Is that because int is immutable, so <code>__add__</code> needs to build a new (int) object ?</span>
<span class="comment-copy">@BuvinJ you don't have to override equality operators, just operations that returns an "updated" integer.</span>
<span class="comment-copy">Thanks, but that doesn't serve my needs.  The point is to determine whether some polymorphic functions are returning and/or dealing with a specific kind of object, because the context of what to do with such will hinge on that.  I need to differentiate between an int and this "id type"</span>
<span class="comment-copy">Then I think a 'has a' relationship is your best. It sounds like you don't want <code>__id</code> to be treated like an int. The best way to prevent that is by creating a new class.</span>
<span class="comment-copy">I guess I need to go with a damn "has a" after all.  See my (displeasing...) answer.</span>
<span class="comment-copy">I like this idea, but it doesn't create a separate type. <code>type(UserId(1)) == int</code> is true. <code>UserId</code> itself is a function not a type.</span>
<span class="comment-copy">Combining <code>__hash__</code> and your <code>increment</code> method is a very bad idea. Objects should not have mutable hash values, or at the very least should not be mutated whilst they are keys in a mapping. If do you need mutate the hash value of a key then you will not be able to reference it any more. See <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__hash__</a> for more details.</span>
<span class="comment-copy">Good point, @Dunes!  I can see the logical flaw in what I have here.  Can you suggest a specific rewrite for what I'm trying to achieve?</span>
<span class="comment-copy">I revised and re-posted.  Better?</span>
<span class="comment-copy">I don't quite get why you want what you want. It's a bit of an anti-pattern for python -- the "if it acts/quacks like a duck" thing. I get the impression you're not overly familiar with Python and are trying to force it to behave more like a statically typed language. Your new implementation looks like it will work and is along the lines of what I would have suggested to make this work.</span>
<span class="comment-copy">I am quite familiar with Python.  The entire point to all this is the fact that it is a weakly typed language.  I have a situation where it makes perfect sense for some functions to return and or handle multiple types, one of which is a key to collection.</span>
