<div class="post-text" itemprop="text">
<p>I have a data that looks like this(but much bigger and has more keys). </p>
<pre><code> [{'director_name': 'James Cameron','gross': 760505847, 'genres': ['Action', 'Adventure', 'Fantasy', 'Sci-Fi'],'actor_1_name': 'CCH Pounder','movie_title': 'Avatar','budget': 237000000,'title_year': 2009, 'imdb_score': 7.9},{'director_name': 'Gore Verbinski','num_critic_for_reviews': 302,'gross': 309404152,'genres': ['Action', 'Adventure', 'Fantasy'],'actor_1_name': 'Johnny Depp','movie_title': "Pirates of the Caribbean: At World's End",'budget': 300000000,'title_year': 2007,'imdb_score': 7.1},{'director_name': 'Sam Mendes', 'gross': 200074175,'genres': ['Action', 'Adventure', 'Thriller'],'actor_1_name': 'Christoph Waltz','movie_title': 'Spectre','budget': 245000000,'title_year': 2015,'imdb_score': 6.8}]
</code></pre>
<p>I have written this code, which allows me to index by movie_title, but not by other field_names from schema:</p>
<pre><code>def index_by_title(moviess):
    return {movie['movie_title']: movie for movie in moviess}
</code></pre>
<p>How to index it according to every key from schema(which is a list of keys), not only for title?
When dealing with arbitrary fields to index by, also several movies might have the same key. For example, I should be able to index by year, and of course, many movies are made each year. So the values in the indices should be lists. Unfortunately, you cannot do this with a list comprehension. I think i should use for loop. </p>
</div>
<div class="post-text" itemprop="text">
<p>I case your input data is really a string, you can make use of <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">ast.ast.literal_eval</a>, to convert the input into a Python object:</p>
<pre><code>import ast
import pprint
rawData = """[{'director_name': 'James Cameron','gross': 760505847, 'genres': ['Action', 'Adventure', 'Fantasy', 'Sci-Fi'],'actor_1_name': 'CCH Pounder','movie_title': 'Avatar','budget': 237000000,'title_year': 2009, 'imdb_score': 7.9},{'director_name': 'Gore Verbinski','num_critic_for_reviews': 302,'gross': 309404152,'genres': ['Action', 'Adventure', 'Fantasy'],'actor_1_name': 'Johnny Depp','movie_title': "Pirates of the Caribbean: At World's End",'budget': 300000000,'title_year': 2007,'imdb_score': 7.1},{'director_name': 'Sam Mendes', 'gross': 200074175,'genres': ['Action', 'Adventure', 'Thriller'],'actor_1_name': 'Christoph Waltz','movie_title': 'Spectre','budget': 245000000,'title_year': 2015,'imdb_score': 6.8}]"""

def index_by_title(moviess, key):
    return {movie[key]: movie for movie in moviess if key in movie}


data = ast.literal_eval(rawData)
print index_by_title(data, 'director_name')
</code></pre>
<p>This returns:</p>
<pre><code>{'Gore Verbinski': {'actor_1_name': 'Johnny Depp',
                    'budget': 300000000,
                    'director_name': 'Gore Verbinski',
                    'genres': ['Action', 'Adventure', 'Fantasy'],
                    'gross': 309404152,
                    'imdb_score': 7.1,
                    'movie_title': "Pirates of the Caribbean: At World's End",
                    'num_critic_for_reviews': 302,
                    'title_year': 2007},
 'James Cameron': {'actor_1_name': 'CCH Pounder',
                   'budget': 237000000,
                   'director_name': 'James Cameron',
                   'genres': ['Action', 'Adventure', 'Fantasy', 'Sci-Fi'],
                   'gross': 760505847,
                   'imdb_score': 7.9,
                   'movie_title': 'Avatar',
                   'title_year': 2009},
 'Sam Mendes': {'actor_1_name': 'Christoph Waltz',
                'budget': 245000000,
                'director_name': 'Sam Mendes',
                'genres': ['Action', 'Adventure', 'Thriller'],
                'gross': 200074175,
                'imdb_score': 6.8,
                'movie_title': 'Spectre',
                'title_year': 2015}}
</code></pre>
</div>
<span class="comment-copy">1) Your sample code isn't valid, as those single quotes aren't paired properly (e.g. the '[{' at the beginning is a string, I think you want it to be a dictionary inside a list. 2) Please provide some clarification on what the indexing function(s) should return.</span>
<span class="comment-copy">Is it possible to do something like this? eg. when index is by year, it should return  {2005: list of dictionaries of all movies created in 2005}, {2006: list of dictionaries of all movies created in 2006 }</span>
<span class="comment-copy">Yes it's possible, but I don't have time to work it out right now. Try to write a function "the long way" before squeezing your code into things like list comprehensions and other syntactic sugar that will shrink your code, but might make it so dense that it requires a lot of time and thought to understand.</span>
<span class="comment-copy">Thanks, Maurice. Could you please help me to edit my code so that it indexes not only on title, but on all other keys as well, like gross, budget (and those come from schema).  <code>def index_by_key(moviess, schema)</code></span>
<span class="comment-copy">Just edited ...</span>
