<div class="post-text" itemprop="text">
<p>This <em>seems</em> like something that is likely to have been asked before, but an hour or so of searching has yielded no results. <a href="https://stackoverflow.com/questions/52063759/passing-default-list-argument-to-dataclasses">Passing default list argument to dataclasses</a> looked promising, but it's not quite what I'm looking for.</p>
<p>Here's the problem: when one tries to assign a mutable value to a class attribute, there's an error:</p>
<pre><code>@dataclass
class Foo:
    bar: list = []

# ValueError: mutable default &lt;class 'list'&gt; for field a is not allowed: use default_factory
</code></pre>
<p>I gathered from the error message that I'm supposed to use the following instead:</p>
<pre><code>@dataclass
class Foo:
    bar: list = field(default_factory=list)
</code></pre>
<p>But why are mutable defaults not allowed? Is it to enforce avoidance of the <a href="https://stackoverflow.com/q/1132941/8117067">mutable default argument problem</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like my question was quite clearly answered in <a href="https://docs.python.org/3/library/dataclasses.html#mutable-default-values" rel="nofollow noreferrer">the docs</a> (which derived from <a href="https://www.python.org/dev/peps/pep-0557/#mutable-default-values" rel="nofollow noreferrer">PEP 557</a>, as shmee mentioned):</p>
<blockquote>
<p>Python stores default member variable values in class attributes. Consider this example, not using dataclasses:</p>
<pre><code>class C:
    x = []
    def add(self, element):
        self.x.append(element)

o1 = C()
o2 = C()
o1.add(1)
o2.add(2)
assert o1.x == [1, 2]
assert o1.x is o2.x
</code></pre>
<p>Note that the two instances of class <code>C</code> share the same class variable <code>x</code>, as expected.</p>
<p>Using dataclasses, if this code was valid:</p>
<pre><code>@dataclass
class D:
    x: List = []
    def add(self, element):
        self.x += element
</code></pre>
<p>it would generate code similar to:</p>
<pre><code>class D:
    x = []
    def __init__(self, x=x):
        self.x = x
    def add(self, element):
        self.x += element
</code></pre>
<p>This has the same issue as the original example using class <code>C</code>. That is, two instances of class <code>D</code> that do not specify a value for <code>x</code> when creating a class instance will share the same copy of <code>x</code>. Because dataclasses just use normal Python class creation they also share this behavior. There is no general way for Data Classes to detect this condition. Instead, dataclasses will raise a <code>TypeError</code> if it detects a default parameter of type <code>list</code>, <code>dict</code>, or <code>set</code>. This is a partial solution, but it does protect against many common errors.</p>
</blockquote>
</div>
<span class="comment-copy">"Is it to enforce avoidance of the mutable default argument problem" Yes. Imagine a change to one instance changing all of instances ever created. If this is one's desired behavior they should use a class attribute.</span>
<span class="comment-copy"><a href="https://www.python.org/dev/peps/pep-0557/#mutable-default-values" rel="nofollow noreferrer">Relevant section of PEP 557</a> explaining this design.</span>
