<div class="post-text" itemprop="text">
<p>I try to embed the Python Interpreter into C.
In order to test this I create a shared library and 
try to load this one in Python with ctypes. Unfortunately this doesn't 
work and I would like to understand why.</p>
<p>Here is an example c - code:  </p>
<pre><code>#ifdef __cplusplus
extern "C" {
#endif

#include &lt;Python.h&gt;


int run_py(void);
int run_py2(void);

int
run_py(void)
{
    printf("hello from run_py\n");
    return 42;
}

int
run_py2(void)
{
    printf("entering c-function: run_py()\n");
    Py_Initialize();
    PyRun_SimpleString("print('hello world')");
    return 0;
}

#ifdef __cplusplus
}
#endif
</code></pre>
<p>So I compile this into "mylib.so" with gcc and use python3.7-config --cflags and --ldflags for linking and so on which works.</p>
<p>Here is the Python code I use to load this..</p>
<pre><code>import ctypes as c
import os
import sys


if __name__ == '__main__':
    print("running shared-lib integration test with python:\n{}".format(sys.version))

    path = os.path.dirname(os.path.realpath(__file__))
    dllfile = os.path.join(path, 'mylib.so')
    dll = c.CDLL(str(dllfile))

    print("loaded CDLL")
    dll.run_py.restype  = c.c_int
    dll.run_py2.restype  = c.c_int

    print("now calling dll.run_py()...")
    rv = dll.run_py()
    print("called dll.run_py: rv={}".format(rv))

    print("now calling dll.run_py2()...")
    rv2 = dll.run_py2()
    print("called dll.run_py2: rv={}".format(rv2))
</code></pre>
<p>So this simply loads both functions run_py and run_py2
and executes them. This is the output... </p>
<pre><code>running shared-lib integration test with python:
3.7.1 (default, Oct 22 2018, 10:41:28) 
[GCC 8.2.1 20180831]
loaded CDLL
now calling dll.run_py()...
hello from run_py
called dll.run_py: rv=42
now calling dll.run_py2()...
entering c-function: run_py()
Segmentation fault (core dumped)
</code></pre>
<p>So basically this leads to segfault  when calling run_py2.
The cause for this is the call of <code>PyRun_SimpleString</code> .
However if I compile this as a standalone C programm 
everything seems to work just fine. I really 
would like to understand why this happens... but currently im
out ouf ideas so any feedback is really appreciated here. </p>
<p>BR jrsm</p>
</div>
<div class="post-text" itemprop="text">
<p>I changed your code a bit. Also, I'm testing on <em>Win</em> (as it's more convenient for me at this point), but I'm sure things are the same in <em>Nix</em>.</p>
<p><em>dll.c</em>:</p>
<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;Python.h&gt;

#define PRINT_MSG_0() printf("From C - [%s] (%d) - [%s]\n", __FILE__, __LINE__, __FUNCTION__)

#if defined(_WIN32)
#define DLL_EXPORT_API __declspec(dllexport)
#else
#define DLL_EXPORT_API
#endif

#if defined(__cplusplus)
extern "C" {
#endif

DLL_EXPORT_API int test0(void);
DLL_EXPORT_API int test1(void);

#if defined(__cplusplus)
}
#endif


int test0(void) {
    PRINT_MSG_0();
    return 42;
}


int test1(void) {
    PRINT_MSG_0();
    Py_Initialize();
    PRINT_MSG_0();
    PyRun_SimpleString("print(\"Hello world!!!\")");
    PRINT_MSG_0();
    return 0;
}
</code></pre>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
from ctypes import CDLL,\
    c_int


DLL = "./dll.so"


def main():
    dll_dll = CDLL(DLL)
    test0_func = dll_dll.test0
    test0_func.argtypes = None
    test0_func.restype = c_int
    test1_func = dll_dll.test1
    test1_func.argtypes = None
    test1_func.restype = c_int

    print("Calling {:}...".format(test0_func.__name__))
    res = test0_func()
    print("{:} returned {:d}".format(test0_func.__name__, res))
    print("Calling {:}...".format(test1_func.__name__))
    res = test1_func()
    print("{:} returned {:d}".format(test1_func.__name__, res))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;"c:\Install\x86\Microsoft\Visual Studio Community\2015\vc\vcvarsall.bat" x64

(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;dir /b
code.py
dll.c

(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;cl /nologo /DDLL /MD /Ic:\Install\x64\Python\Python\3.5\include dll.c  /link /NOLOGO /DLL /OUT:dll.so /LIBPATH:c:\Install\x64\Python\Python\3.5\libs
dll.c
   Creating library dll.lib and object dll.exp

(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;dir /b
code.py
dll.c
dll.exp
dll.lib
dll.obj
dll.so

(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Calling test0...
From C - [dll.c] (26) - [test0]
test0 returned 42
Calling test1...
From C - [dll.c] (32) - [test1]
From C - [dll.c] (34) - [test1]
Traceback (most recent call last):
  File "code.py", line 30, in &lt;module&gt;
    main()
  File "code.py", line 24, in main
    res = test1_func()
OSError: exception: access violation reading 0x0000000000000010
</code></pre>
</blockquote>
<p>The problem reproduces. First, I thought it's the <a href="https://docs.python.org/3/c-api/init.html#c.Py_Initialize" rel="nofollow noreferrer">[Python 3]: void <strong>Py_Initialize</strong>()</a> call. But then I remembered <a href="https://docs.python.org/3/library/ctypes.html#ctypes.PyDLL" rel="nofollow noreferrer">[Python 3]: <em>class</em> ctypes.<strong>PyDLL</strong>(<em>name, mode=DEFAULT_MODE, handle=None</em>)</a> (<strong>emphasis</strong> is mine) which states:</p>
<blockquote>
<p>Instances of this class behave like <a href="https://docs.python.org/3/library/ctypes.html#ctypes.CDLL" rel="nofollow noreferrer">CDLL</a> instances, except that the Python GIL is <em>not</em> released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised.<br/></p>
<p>Thus, this is only useful to <strong>call Python C api functions</strong> directly.</p>
</blockquote>
<p>Replacing <em>CDLL</em> by <em>PyDLL</em> in <em>code.py</em>, yields:</p>
<blockquote>
<pre><code>(py35x64_test) e:\Work\Dev\StackOverflow\q053609932&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

Calling test0...
From C - [dll.c] (26) - [test0]
test0 returned 42
Calling test1...
From C - [dll.c] (32) - [test1]
From C - [dll.c] (34) - [test1]
Hello world!!!
From C - [dll.c] (36) - [test1]
test1 returned 0
</code></pre>
</blockquote>
</div>
<span class="comment-copy">It looks like you are mixing two different things, embedding Python and extending Python. If your library extends Python (i.e. is loadable from within Python) you should not try to embed a Python interpreter in it (unless you want two independent unrelated Python interpreters, which I doubt).</span>
<span class="comment-copy">Yes you are right, in the end I will not use  two python interpeters... only the shared library from within C (So Python embedded in C).  However I tried this as a first test (out of curiosity) and now I want to understand why it is broken ;-)</span>
<span class="comment-copy">Thank you for your time and patience to test this. I replaced CDLL and it seems to work so this is nice, thank you !  Do you have an  idea why this segfault occurs ? what do you mean by only useful for python c api function calls ?</span>
<span class="comment-copy">I personally, don't mean anything, it's a paste from the official doc. You know that <i>Python</i> code runs under <i>GIL</i>, meaning that every function (including <i>PyRun_SimpleString</i>) should run so. <i>CDLL</i> "stops" <i>GIL</i>, so I guess it's <i>Undefined Behavior</i>. For more details you'll probably have to browse the <i>Python</i> source code.</span>
<span class="comment-copy">Yeah  I think  it is probably hard to tell what is happening.  However I would think that there are 2 GILs, one for the embedded python and one for the other. I mean when using the multiprocessing module, hence, spawning multiple python processes, there should be also more than 1 GIL..</span>
<span class="comment-copy">No there is one <i>GIL</i> (which can be active/inactive) per process. Our case is in that condition. But the problem is that a function (<i>PyRun_SimpleString</i>) that is supposed to operate under <i>GIL</i>, doesn't because it was released by <i>CDLL</i>. Maybe it references some pointers that were invalidated by the <i>GIL</i> release.</span>
<span class="comment-copy">This would mean that 2 python interpeters share the GIL ?</span>
