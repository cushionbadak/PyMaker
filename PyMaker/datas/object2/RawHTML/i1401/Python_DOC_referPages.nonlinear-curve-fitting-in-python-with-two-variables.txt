<div class="post-text" itemprop="text">
<p>I am trying to define a function that fits input x and y data of the form:</p>
<pre><code>def nlvh(x,y, xi, yi, H,C):

    return ((H-xi*C)/8.314)*((1/xi) - x) + (C/8.314)*np.log((1/x)/xi) + np.log(yi)
</code></pre>
<p>The x and y data are 1-D numpy arrays of the same length. I would like to slice the data so that I can select the first 5 points of x and y, fit those by optimizing C and H in the model, and then move one point ahead and repeat. I have some code that does this for a linear fit over the same data:</p>
<pre><code>for i in np.arange(len(x)):
    xdata = x[i:i + window]
    ydata = y[i:i+window]
    a[i], b[i] = np.polyfit(xdata, ydata,1)
    xdata_avg[i] = np.mean(xdata)
    if i == (lenx - window):
        break
</code></pre>
<p>but doing the same thing over the equation defined above appears to be a bit more tricky. x and y appear as the independent and dependent variables, but there are also parameters xo and yo which are the first values of x and y in each window. </p>
<p>The end result I would like are two new arrays with H[i] and C[i], where i designates each subsequent window. Does anybody have some insight as to how I can get started?</p>
</div>
<div class="post-text" itemprop="text">
<p>Following your comment to my previous answer (where you suggested that you will like <code>xi</code> and <code>yi</code> to be the initial values in each "sliced" <code>x</code> and <code>y</code> arrays), I am adding another answer. This answer introduces a change in the function <code>nlvh</code> and achieves exactly what you desire. As like my previous answer, we will use <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="nofollow noreferrer">curve_fit</a> from <strong>scipy.optimize</strong>.</p>
<p>In the below mentioned code, I am using <a href="https://thepythonguru.com/python-builtin-functions/globals/" rel="nofollow noreferrer">globals()</a> function from python to define <code>xi</code> and <code>yi</code>. For every sliced <code>x</code> and <code>y</code> arrays, <code>xi</code> and <code>yi</code> store the first value of the respective sliced arrays. This is the revamped code:</p>
<pre><code>from __future__ import division #For decimal division.
import numpy as np
from scipy.optimize import curve_fit

def nlvh(x, H, C):
    return ((H-xi*C)/8.314)*((1/xi) - x) + (C/8.314)*np.log((1/x)/xi) + np.log(yi)

xdata = np.arange(1,21) #Choose an array for x.

#Choose an array for y.
ydata = np.array([-0.1404996,  -0.04353953,  0.35002257,  0.12939468, -0.34259184, -0.2906065,
     -0.37508709, -0.41583238, -0.511851,   -0.39465581, -0.32631751, -0.34403938,
     -0.592997,   -0.34312689, -0.4838437,  -0.19311436, -0.20962735, -0.31134191, 
     -0.09487793, -0.55578775])


H_lst, C_lst = [], []
for i in range( len(xdata)-5 ):
    #Select 5 consecutive points of xdata (from index i to i+4).
    xnew = xdata[i: i+5]
    globals()['xi'] = xnew[0]

    #Select 5 consecutive points of ydata (from index i to i+4).
    ynew = ydata[i: i+5]
    globals()['yi'] = ynew[0]  

    #Fit function nlvh to data using scipy.optimize.curve_fit
    popt, pcov = curve_fit(nlvh, xnew, ynew, maxfev=100000)

    #Optimal values for H from minimization of sum of the squared residuals.
    H_lst += [popt[0]] 

    #Optimal values for C from minimization of sum of the squared residuals.
    C_lst += [popt[1]] 

H_arr, C_arr = np.asarray(H_lst), np.asarray(C_lst) #Convert list to numpy arrays.
</code></pre>
<p>Your output for <code>H_arr</code> and <code>C_arr</code> will now be the following:</p>
<pre><code>print H_arr 
&gt;&gt;&gt;[1.0, 1.0, -23.041138662879327, -34.58915200575536, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

print C_arr
&gt;&gt;&gt;[1.0, 1.0, -8.795855063863234, -9.271561975595562, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
</code></pre>
<p>Following are the plots that you get for the data selected above (<code>xdata</code>, <code>ydata</code>).</p>
<p><a href="https://i.stack.imgur.com/2N6ae.png" rel="nofollow noreferrer"><img alt="Plot of parameter H" src="https://i.stack.imgur.com/2N6ae.png"/></a>
<a href="https://i.stack.imgur.com/aUaqO.png" rel="nofollow noreferrer"><img alt="Plot of parameter C" src="https://i.stack.imgur.com/aUaqO.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="nofollow noreferrer">curve_fit</a> from <strong>scipy.optimize</strong>. It will use non-linear least squares to fit the parameters <code>(H, C, xi, yi)</code> of your function <code>nlvh</code> to given input data for <code>x</code> and <code>y</code>.</p>
<p>Try the following code. In the below mentioned code, <code>H_arr</code> and <code>C_arr</code> are numpy arrays which contain fit parameters of <code>H</code> and <code>C</code> respectively when the function <code>nlvh</code> is fitted to windows of 5 consecutive points of <code>xdata</code> and <code>ydata</code> (<code>xdata</code> and <code>ydata</code> are arrays that I have chosen for <code>x</code> and <code>y</code>. You can choose different arrays here.)</p>
<pre><code>from __future__ import division #For decimal division.
import numpy as np
from scipy.optimize import curve_fit

def nlvh(x, H, C, xi, yi):
    return ((H-xi*C)/8.314)*((1/xi) - x) + (C/8.314)*np.log((1/x)/xi) + np.log(yi)

xdata = np.arange(1,21) #Choose an array for x

#Find an array yy for chosen values of parameters (H, C, xi, yi)
yy = nlvh(xdata, H=1.0, C=1.0, xi=1.0, yi=1.0)  

print yy
&gt;&gt;&gt;[ 0. -0.08337108 -0.13214004 -0.16674217 -0.19358166 -0.21551112 -0.23405222 -0.25011325 -0.26428008 -0.27695274 -0.28841656 -0.2988822 -0.30850967 -0.3174233  -0.3257217  -0.33348433 -0.3407762 -0.34765116 -0.35415432 -0.36032382]

#Add noise to the initally chosen array yy.
y_noise = 0.2 * np.random.normal(size=xdata.size)
ydata = yy + y_noise    

print ydata

&gt;&gt;&gt;[-0.1404996  -0.04353953  0.35002257  0.12939468 -0.34259184 -0.2906065 -0.37508709 -0.41583238 -0.511851   -0.39465581 -0.32631751 -0.34403938 -0.592997   -0.34312689 -0.4838437  -0.19311436 -0.20962735 -0.31134191-0.09487793 -0.55578775]

H_lst, C_lst = [], []
for i in range( len(xdata)-5 ):
    #Select 5 consecutive points of xdata (from index i to i+4).
    xnew = xdata[i: i+5]

    #Select 5 consecutive points of ydata (from index i to i+4).
    ynew = ydata[i: i+5]

    #Fit function nlvh to data using scipy.optimize.curve_fit
    popt, pcov = curve_fit(nlvh, xnew, ynew, maxfev=100000)

    #Optimal values for H from minimization of sum of the squared residuals.
    H_lst += [popt[0]] 

    #Optimal values for C from minimization of sum of the squared residuals.
    C_lst += [popt[1]]   

H_arr, C_arr = np.asarray(H_lst), np.asarray(C_lst) #Convert list to numpy arrays.
</code></pre>
<p>Following will be your output of <code>H_arr</code> and <code>C_arr</code> for the chosen values of <code>xdata</code> and <code>ydata</code>.</p>
<pre><code>print H_arr

&gt;&gt;&gt;[ -11.5317468   -18.44101926   20.30837781   31.47360697  -14.45018355 24.17226837   39.96761325   15.28776756 -113.15255865   15.71324201 51.56631241  159.38292301  -28.2429133   -60.97509922  -89.48216973]

print C_arr

&gt;&gt;&gt;[0.70339652 0.34734507 0.2664654  0.2062776  0.30740565 0.19066498 0.1812445  0.30169133 0.11654544 0.21882872 0.11852967 0.09968506 0.2288574  0.128909   0.11658227]
</code></pre>
</div>
<span class="comment-copy">What do you use for fitting? You don't seem to use your function <code>nlvh</code>. In any case you could fit a <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>partial</code></a> function, with the remaining parameters set.</span>
<span class="comment-copy">Does <code>nlvh</code> define a rule that x and y follow or is it a definition of y? I'm asking because it takes as arguments x, y, xo, yo, H and C and is written in terms of xi, yi, x, C and H (but not y). If you try using this in Python you'll get a <code>UnboundLocalError </code> exception for xi and yi. Please correct this and explain what this function represents.</span>
<span class="comment-copy">Should <code>xi</code> and <code>yi</code> in <code>nlvh</code> function be the same as <code>xo</code> and <code>yo</code> respectively? I think you have a typo in nlvh.</span>
<span class="comment-copy">@telba : Did you get a chance to try the aforesaid method? You can let me know if you have any comments or questions.</span>
<span class="comment-copy">@Siddharth_Satpathy: This was great help, thank you! I was able to configure the code to do exactly what I wanted it to do. The globals() operation was something I wasn't aware of that I am now using in different scripts.</span>
<span class="comment-copy">@telba : I am happy this could be of use. Happy coding! =)</span>
<span class="comment-copy">This was great help, thank you!</span>
<span class="comment-copy">This was supposed to be included in the last comment.... As you asked before, xo and yo are typos. They should have read xi, yi in the nlvh function. These should be the initial values in each "sliced" x and y arrays, i.e., xdata[0] and ydata[0]. I have been working through how this can be incorporated into the for loop but I have been getting stuck. I am looking through the hyperlink for curve_fit and cannot see how I can fix xi and yi in nlvh. Is there documentation on how to do this other than the info you provided? Thank you again for your help.</span>
<span class="comment-copy">@telba : With a small change in the definition of the function <code>nlvh</code> one can make sure that <code>xi</code> and <code>yi</code> are the initial values of the sliced x and y arrays. Are you open for that? One question: is xi = xnew[0] or is xi=xdata[0] (similar question for yi. Is yi = ynew[0] or is yi=ydata[0] ? )</span>
