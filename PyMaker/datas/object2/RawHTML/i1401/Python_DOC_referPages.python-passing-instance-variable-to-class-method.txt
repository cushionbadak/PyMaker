<div class="post-text" itemprop="text">
<p>I am using <code>xlsxwriter</code> and I have created a class where I have created a workbook. Then I have added 2 worksheets to it.
Now I have written a method that's writing data to one of the worksheets, but now I would like to use it on both worksheets. This is a simple example to explain the situation:</p>
<pre><code>import xlsxwriter

class ExcelWorkbook():
    def __init__(self, filename):
        self.wb = xlsxwriter.Workbook(filename)
        self.ws1 = self.wb.add_worksheet('Num')
        self.ws1LineCount = 0
        self.ws2 = self.wb.add_worksheet('Result')
        self.ws2LineCount = 0

    def write_data(self, data, title):        
        self.ws1.write_row(self.ws1LineCount, 0, title)
        self.ws1LineCount += 1
        self.ws1.write_row(self.ws1LineCount, 0, data)
        self.ws1LineCount += 1

xlsxWorkbook = ExcelWorkbook('Test2.xlsx')
numArr = (0.000000520593523979187, 13.123456789, 1.789456, 0.002345, 0.00123, 1)
titleBar = ('Date', 'quantity', 'Average [m]', 'Standard Dev [m]', 'Test', 'Success')
xlsxWorkbook.write_data(numArr, titleBar)
</code></pre>
<p>Now I'd like to use the <code>write_data</code> method for both worksheets, so I thought I'd pass the worksheet as a parameter, but unfortunately it's not that simple, as I cannot pass the instance variable <code>self.ws1</code> or <code>self.ws2</code>.</p>
<p>So the question is: how can I do that? </p>
<p>I came up with a very nasty solution, like this:</p>
<pre><code>def write_data(self, data, title, instance = 'ws1'):
    if instance == 'ws1':
        instance = self.ws1
        lineCounter = self.ws1LineCount
    elif instance == 'ws2':
        instance = self.ws2
        lineCounter = self.ws2LineCount

    instance.write_row(self.ws1LineCount, 0, title)
    lineCounter += 1
    instance.write_row(self.ws1LineCount, 0, data)
    lineCounter += 1
</code></pre>
<p>but honestly I don't like it. Is there a proper way to do it, or is it like a completely unreasonable thing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of the if block, better use <code>workbook.get_worksheet_by_name()</code> method</p>
<pre><code>def write_data(self, data, title, ws = 'Num'):
    wsheet = self.wb.get_worksheet_by_name(ws)
    wsheet.write_row(self.ws1LineCount, 0, title)
    lineCounter += 1
    wsheet.write_row(self.ws1LineCount, 0, data)
    lineCounter += 1
</code></pre>
<p>EDIT: or you can use getattr() function, e.g.</p>
<pre><code>def write_data(self, data, title, ws = 'ws1'):
    wsheet = getattr(self, ws, self.ws1))
    wsheet.write_row(self.ws1LineCount, 0, title)
    lineCounter += 1
    wsheet.write_row(self.ws1LineCount, 0, data)
    lineCounter += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd do something like this:</p>
<pre><code>from collections import defaultdict
import xlsxwriter

class ExcelWorkbook():
    def __init__(self, filename):
        self.wb = xlsxwriter.Workbook(filename)

        self.ws1 = self.wb.add_worksheet('Num')
        self.ws2 = self.wb.add_worksheet('Result')
        self._line_counts = defaultdict(int)

    def write_data(self, ws, data, title):
        self._write_row(ws, title)
        self._write_row(ws, data)

    def _write_row(self, ws, content):
        ws.write_row(self._line_counts[ws], 0, content)
        self._line_counts[ws] += 1

xlsxWorkbook = ExcelWorkbook('Test2.xlsx')
numArr = (0.000000520593523979187, 13.123456789, 1.789456, 0.002345, 0.00123, 1)
titleBar = ('Date', 'quantity', 'Average [m]', 'Standard Dev [m]', 'Test', 'Success')
xlsxWorkbook.write_data(xlsxWorkbook.ws1, numArr, titleBar)
xlsxWorkbook.write_data(xlsxWorkbook.ws2, numArr, titleBar)
</code></pre>
<p>By using <code>defaultdict</code>, you don't need to explicitly keep a line count variable for each worksheet. The <code>write_data</code> function accepts a new parameter <code>ws</code> so that you can set the worksheet that should be written to. Writing a row can be factored into a separate method to reduce code duplication.</p>
<p>Does this answer your question?</p>
<p><strong>Edit:</strong></p>
<p>a default value cannot access <code>self</code>, but you can work around this quite easily:</p>
<pre><code>def write_data(self, data, title, ws=None):
        if ws is None:            
            ws = self.ws1
        self._write_row(ws, title)
        self._write_row(ws, data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you should consider to have an extra class <code>ExcelWorksheet</code>, in order to put all logic related to them inside:</p>
<pre><code>class ExcelWorksheet(object):
    def __init__(self, workbook, name):
        self.wb = workbook
        self.ws = self.wb.add_worksheet(name)
        self.wsLineCount = 0

    def write_data(self, data, title):        
        self.ws.write_row(self.wsLineCount, 0, title)
        self.wsLineCount += 1
        self.ws.write_row(self.wsLineCount, 0, data)
        self.wsLineCount += 1
</code></pre>
<p>This way, you can refactor your code to this:</p>
<pre><code>class ExcelWorkbook(object):
    def __init__(self, filename):
        self.wb = xlsxwriter.Workbook(filename)
        self.ws1 = ExcelWorksheet(self.wb, 'Num')
        self.ws2 = ExcelWorksheet(self.wb, 'Result')


xlsxWorkbook = ExcelWorkbook('Test2.xlsx')
numArr = (0.000000520593523979187, 13.123456789, 1.789456, 0.002345, 0.00123, 1)
titleBar = ('Date', 'quantity', 'Average [m]', 'Standard Dev [m]', 'Test', 'Success')
xlsxWorkbook.ws1.write_data(numArr, titleBar)
xlsxWorkbook.ws2.write_data(numArr, titleBar)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With vars(self), you can access any element of the object as a dictionnary.</p>
<p>Then vars(self)["ws1"] is like self.ws1 and vars(self)["ws2"] is like self.ws2</p>
<p>Then you just have to pass a key argument "ws1" or "ws2" in write_data.</p>
<pre><code>def write_data(self, data, title, key='ws1'):
    instance = vars(self)[key]
    lineCounter = vars(self)[key+"LineCount"]

    instance.write_row(lineCounter , 0, title)
    lineCounter += 1
    instance.write_row(lineCounter , 0, data)
    lineCounter += 1
</code></pre>
</div>
<span class="comment-copy">hello, what about storing the excel sheet in a list. then you can iterate it to access each of them?</span>
<span class="comment-copy">What do you mean that you cannot pass the instance variable? You should be able to with <code>xlsxWorkbook.write_data(data, title, xlsxWorkbook.ws1)</code></span>
<span class="comment-copy">@CarlosMermingas what is <code>xlsxWorkbook</code>? I have tried to pass <code>instance = self.ws1</code> as a keyword argument with default value, but it didn't work...</span>
<span class="comment-copy">It's in your code: <code>xlsxWorkbook = ExcelWorkbook('Test2.xlsx')</code>. It's the instance of <code>ExcelWorkbook</code></span>
<span class="comment-copy"><code>self</code> is just a name that you pick. It is not a special word in Python. You cannot use <code>self</code> unless it is defined somewhere. You can use it in methods in a class because it is set as the first argument.</span>
<span class="comment-copy">That's actually a good idea!</span>
<span class="comment-copy">@toti08, of course, if you still want to use property (e.g. 'ws1'), not actull worksheet name, you can use getattr() function <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#getattr</a></span>
<span class="comment-copy">Thanks! The first approach works perfectly, while the second should be used with <code>wsheet = getattr(self, 'ws1')</code>. But both are good approaches, thanks!</span>
<span class="comment-copy">@toni08, the second one should be used as I show you.  <code>wsheet = getattr(self, ws, 'ws1'))</code>. This way you can use default value when you call the <code>write_data()</code> method and also, if you pass a attribute that does not exists (e.g. 'ws3') still fall back to the default value of 'ws1'</span>
<span class="comment-copy">Weird, if I use it the way you suggest I get an error: <code>AttributeError: 'str' object has no attribute 'write_row'</code> because I got back a string (<code>ws1</code>) and not a worksheet instance....maybe because I'm in Python2?</span>
<span class="comment-copy">Thanks for your answer, that's a good idea. What if I want to give the <code>ws</code> parameter a default value? I'm asking this because I wouldn't want to break already existing software...</span>
<span class="comment-copy">please see my edit. There are shorter solutions (e.g. <code>ws = ws or self.ws1</code>), but they might be too "magical" for most coders and have slightly different semantics</span>
<span class="comment-copy">Thanks, that works well!</span>
<span class="comment-copy">Thanks, that's also a good idea, I'll think whether this is feasible in my case...</span>
<span class="comment-copy">Glad to help you. Please, remember to chose an answer if your problem was resolved.</span>
<span class="comment-copy">While this should work, it's easy to break by providing a wrong <code>key</code> and IDE's are most likely not able to point that out using static analysis.</span>
<span class="comment-copy">In fact like any basic function, a wrong arg does not work. But if you prefer your solution with a pseudo-static method asking as argument the reference to its own attribut... I wonder the interest of OOP when I see that.</span>
