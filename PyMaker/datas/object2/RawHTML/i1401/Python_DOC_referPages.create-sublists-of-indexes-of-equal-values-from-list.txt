<div class="post-text" itemprop="text">
<p>I'm trying to split a list of integers into sublists of the the indexes of equal integers. So say I have a list:</p>
<pre><code>original_list = [1,2,1,4,4,4,3,4,4,1,4,3,3]
</code></pre>
<p>The desired output would be:</p>
<pre><code>indexes : [[0,2,9], [1], [6,11,12], [3,4,5,7,8,10]]
# corresponds to sublists: [[1,1,1] [2], [3,3,3], [4,4,4,4,4,4]]
</code></pre>
<p>I can't figure out how to do this though, as most solutions require you to first sort the original list, but in my case, this messes up the indices. Itertools or np.arrays have not helped me for this reason, as they only group sequential equal elements. </p>
<p>Does anyone know of a solution for this problem? I would love to hear!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>enumerate</code>:</p>
<pre><code>original_list = [1,2,1,4,4,4,3,4,4,1,4,3,3]
groups = {a:[i for i, c in enumerate(original_list) if c == a] for a in set(original_list)}
</code></pre>
<p>Output:</p>
<pre><code>{1: [0, 2, 9], 2: [1], 3: [6, 11, 12], 4: [3, 4, 5, 7, 8, 10]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3.6/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> for a one-pass solution. Then use <code>sorted</code> if you need, as in your desired result, to sort your indices by value.</p>
<pre><code>original_list = [1,2,1,4,4,4,3,4,4,1,4,3,3]

from collections import defaultdict
from operator import itemgetter

dd = defaultdict(list)

for idx, value in enumerate(original_list):
    dd[value].append(idx)

keys, values = zip(*sorted(dd.items(), key=itemgetter(0)))

print(keys, values, sep='\n')

(1, 2, 3, 4)
([0, 2, 9], [1], [6, 11, 12], [3, 4, 5, 7, 8, 10])
</code></pre>
<p>For comparison, the values of <code>dd</code> are <em>insertion</em> ordered in Python 3.6+ (officially in 3.7+, as a CPython implementation detail in 3.6):</p>
<pre><code>print(list(dd.values()))

[[0, 2, 9], [1], [3, 4, 5, 7, 8, 10], [6, 11, 12]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I would do it with numpy, using the argsort function I linked in the comments.</p>
<pre><code>original = [1,2,1,4,4,4,3,4,4,1,4,3,3]
indexes = []
s = set()

for n in np.argsort(original):
    if original[n] in s:
        indexes[-1].append(n)
    else:
        indexes.append([n])
        s.add(original[n])

print(indexes)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be achieved with a list comprehension.</p>
<pre><code>&gt;&gt;&gt; x = [1,2,1,4,4,4,3,4,4,1,4,3,3]
&gt;&gt;&gt; [[i for i in range(len(x)) if x[i]==y] for y in sorted(set(x))]
[[0, 2, 9], [1], [6, 11, 12], [3, 4, 5, 7, 8, 10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> and a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>, you can build a mapping of values to their indices with </p>
<pre><code>from collections import defaultdict

dd = defaultdict(list)
for index, value in enumerate(original_list):
    dd[value].append(index)

print(dd)
# defaultdict(&lt;class 'list'&gt;, {1: [0, 2, 9], 2: [1], 4: [3, 4, 5, 7, 8, 10], 3: [6, 11, 12]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a linear time and space solution that appends indexes to number bucket lists in an <code>OrderedDict()</code> and extracts the index lists to produce the result:</p>
<pre><code>from collections import OrderedDict

original_list = [9,2,9,4,4,4,3,4,4,9,4,3,3]
counts = OrderedDict()

for i, e in enumerate(original_list):
    if e not in counts:
        counts[e] = []
    counts[e].append(i)

print(list(counts.values()))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[[0, 2, 9], [1], [6, 11, 12], [3, 4, 5, 7, 8, 10]]
</code></pre>
<p><a href="https://repl.it/repls/DelayedEmptyComma" rel="nofollow noreferrer">Try it!</a></p>
</div>
<span class="comment-copy">FYI, there's a suitable sort function in numpy for this: <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html" rel="nofollow noreferrer">argsort</a></span>
<span class="comment-copy">clever use of the set to keep track of what you have seen. Python's sorted can be swapped for numpy's without sacrificing performance (in the big Oh sense), besides it returns a new list so the first isn't modified. Good work.</span>
<span class="comment-copy">@xerosmith You actually can't swap Pythons sort function because <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html" rel="nofollow noreferrer"><code>argsort</code></a> does something else. It returns the indexes of the elements rather than the elements themselves. Also, it doesn't modify the original list.</span>
<span class="comment-copy">Fair enough, +1 because 1 just learnt <code>np.argsort</code></span>
<span class="comment-copy">Not to nitpick here, but the time complexity of this is pretty bad.</span>
<span class="comment-copy">@ninesalt lol, and you did just that. Nevertheless, in a situation such as this, the comprehension suffices because it is a one off thing. If you had to do something like this over and over, you should use to a different data structure.   Premature optimisation is unnecessary moreover, for small lists (even up to a few thousand elements), the actual execution time of this will be so small that this solution works fine.   It is correct, compact, and works just fine. I quite like the answer from Ajax1234 as well. But hey, array indexing is constant time eh?</span>
<span class="comment-copy">I get what you're saying but you shouldn't be doing it the "bad" way until you need to improve it, even if it <i>is</i> a one off thing. OP didn't mention complexity so it obviously doesn't matter in this case, that was just a side note. Also, take a look at my answer.</span>
<span class="comment-copy">But that's the thing, this is not "the bad way". In fact, starting from a a correct solution and incrementally improving the optimising the solution whilst maintaining correctness is a very very important method of deriving a program from specifications. This method is espoused by the likes of Donald Knuth, Richard Bird and several others. See  <a href="https://en.m.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism" rel="nofollow noreferrer">en.m.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism</a></span>
