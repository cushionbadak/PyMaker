<div class="post-text" itemprop="text">
<p>I have an asyncio app which uses server from <code>aiohttp</code> and async sockets with <code>asyncio.open_connection()</code></p>
<p>My code contains some blocking calls from the PIL library like </p>
<pre><code>Image.save()
Image.resize()
</code></pre>
<ol>
<li>Even though the calls are not blocking for too much time, still, can my web server freeze if I use these blocking calls? More precisely, is it possible that the event loop will miss events because of blocking code? </li>
<li>If yes, what is the replacement for these functions, that integrate with asyncio? there is no asyncio version of PIL.  </li>
<li>In general, what is considered a 'blocking code' in asyncio? besides the obvious operations like socket, read file, etc.<br/>
For example, does <code>os.path.join()</code> is considered ok? what about working on a <code>numpy</code> array?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>can my web server freeze if I use these blocking calls? More
  precisely, is it possible that the event loop will miss events because
  of blocking code?</p>
</blockquote>
<p>Server will precisely freeze for time of executing image functions. You won't miss any events, but all events handling will be delayed for the time image functions are executing.</p>
<p>Freezing event loop is a bad situation - you should avoid it.</p>
<blockquote>
<p>If yes, what is the replacement for these functions, that integrate
  with asyncio? there is no asyncio version of PIL.</p>
</blockquote>
<p>Easiest and universal way to avoid freezing event loop - to execute blocking function in another thread or another process using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer">asyncio.run_in_executor</a>. Code snippet there shows how to do it and contains good explanation when to use process or thread:</p>
<pre><code>def blocking_io():
    # File operations (such as logging) can block the
    # event loop: run them in a thread pool.
    with open('/dev/urandom', 'rb') as f:
        return f.read(100)

def cpu_bound():
    # CPU-bound operations will block the event loop:
    # in general it is preferable to run them in a
    # process pool.
    return sum(i * i for i in range(10 ** 7))
</code></pre>
<p>I only want to add that process pool may not be always good solution for every CPU-bound operations. If your image functions don't take much time (or especially if your server doesn't have multiple processor cores) it may still be more productive to run them in a thread.</p>
<blockquote>
<p>In general, what is considered a 'blocking code' in asyncio? besides
  the obvious operations like socket, read file, etc. For example, does
  os.path.join() is considered ok? what about working on a numpy array?</p>
</blockquote>
<p>Roughly saying any function is blocking: it blocks event loop for some time. But many functions like <code>os.path.join</code> take so little time so they're not a problem and we don't call them "blocking".</p>
<p>It's hard to say exact limit when execution time (and event loop freezing) becomes a problem, especially considering that this time will be different for different hardware. My biased advice - if your code takes (or may take) &gt; 50 ms before returning control to event loop, consider it blocking and use <code>run_in_executor</code>.</p>
<p><strong>Upd:</strong></p>
<blockquote>
<p>Thanks, does it make sense to use one event loop (of the main thread),
  and using another thread that will add tasks using the same loop?</p>
</blockquote>
<p>I'm not sure what you mean here, but I think not. We need another thread to run some job in, not to add tasks in there.</p>
<blockquote>
<p>I need some way for the thread to inform the main thread after the
  image processing is completed`</p>
</blockquote>
<p>Just await result of <code>run_in_executor</code> or start task with it. <code>run_in_executor</code> - is a coroutine that executes something in background thread without blocking event loop. </p>
<p>It will look like this:</p>
<pre><code>thrad_pool = ThreadPoolExecutor()


def process_image(img):
    # all stuff to process image here
    img.save()
    img.resize()


async def async_image_process(img):
    await loop.run_in_executor(
        thread_pool, 
        partial(process_image, img)
    )


async def handler(request):

    asyncio.create_task(
        async_image_process(img)
    )
    # we use task to return responce imideately,
    # read https://stackoverflow.com/a/37345564/1113207

    return web.Response(text="Image processed without blocking other requests")
</code></pre>
</div>
<span class="comment-copy">Thanks, does it make sense to use one event loop (of the main thread), and using another thread that will add tasks using the same loop? As I need some way for the thread to inform the main thread after the image processing is completed.</span>
<span class="comment-copy">@user3599803 I updated answer to address this.</span>
