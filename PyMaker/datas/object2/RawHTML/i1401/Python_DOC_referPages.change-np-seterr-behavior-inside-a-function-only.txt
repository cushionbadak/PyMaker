<div class="post-text" itemprop="text">
<p>I want to change the floating point error handling of numpy inside of a single function. </p>
<p>Typical example:</p>
<pre><code>import numpy as np

def f():
    np.seterr(all='raise')
    # Do some other stuff

print(np.seterr())
# {'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}

f()
print(np.seterr())
# {'divide': 'raise', 'over': 'raise', 'under': 'raise', 'invalid': 'raise'}
</code></pre>
<p>I would like the call to <code>f</code>to not change the output of  <code>np.seterr()</code>, I have no idea how to do this.</p>
<p>Thanks for any help ! </p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.errstate.html" rel="nofollow noreferrer"><code>numpy.errstate</code></a> context manager to change floating-point error handling temporarily:</p>
<pre><code>def f():
    with numpy.errstate(all='raise'):
        ...
</code></pre>
<p>Be aware that while this is a temporary change, it is still global across threads and coroutines. As of the time of this writing, NumPy doesn't offer an option for thread-local or <a href="https://docs.python.org/3/library/contextvars.html" rel="nofollow noreferrer"><code>contextvars</code></a>-based error settings.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can achieve this by resetting how errors are handled at the end of your function, i.e.:</p>
<pre><code>def f():
    err = np.geterr()
    np.seterr(all='raise')
    try:
        # do stuff
    finally:
        np.seterr(**err)
</code></pre>
</div>
<span class="comment-copy">Woah that's neat. I didn't know about that!</span>
<span class="comment-copy">Thanks a lot, that's exactly what I was after :)</span>
