<div class="post-text" itemprop="text">
<p>I have a flask-based app. When I run it locally, I run it from the command line, but when I deploy it, I start it with gunicorn with multiple workers.</p>
<p>I want to use the <code>logging</code> module to log to a file. The docs I've found for this are <a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html</a> and <a href="https://docs.python.org/3/howto/logging-cookbook.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/logging-cookbook.html</a> .</p>
<p>I am confused over the correct way to use logging when my app may be launched with gunicorn. The docs address threading but assume I have control of the master process. Points of confusion:</p>
<p>Will <code>logger = logging.getLogger('myapp')</code> return the same logger object in different gunicorn worker threads?</p>
<p>If I am attaching a logging <code>FileHandler</code> to my logger in order to log to a file, how can I avoid doing this multiple times in the different workers?</p>
<p>My understanding - which may be wrong - is that if I just call <code>logger.setLevel(logging.DEBUG)</code>, this will send messages via the root logger which may have a higher default logging level and may ignore debug messages, and so I <em>also</em> need to call <code>logging.basicConfig(logging.DEBUG)</code> in order for my debug messages to get through. But the docs say not to call <code>logging.basicConfig()</code> from a thread. How can I  correctly set the root logging level when using gunicorn? Or do I not need to?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is my typical Flask/Gunicorn setup. Note gunicorn is ran via supervisor.</p>
<p>wsgi_web.py. Note <code>ProxyFix</code> to get a client's real IP address from Nginx.</p>
<pre><code>from werkzeug.contrib.fixers import ProxyFix
from app import create_app
import logging

gunicorn_logger = logging.getLogger('gunicorn.error')

application = create_app(logger_override=gunicorn_logger)
application.wsgi_app = ProxyFix(application.wsgi_app, num_proxies=1)
</code></pre>
<p>Flask application factory <code>create_app</code> </p>
<pre><code>def create_app(logger_override=None):
    app = Flask(__name__)

    if logger_override:
        app.logger.handlers = logger_override.handlers
        app.logger.setLevel(logger_override.level)

    # more

    return app
</code></pre>
<p>Gunicorn command (4th line) within supervisor conf, note the <code>--log-level</code> parameter has been set to <code>info</code> in this instance. Note <code>X-REAL-IP</code> passed to access <code>--access-logformat</code></p>
<pre><code>[program:web]
directory = /home/paul/www/example
environment = APP_SETTINGS="app.config.ProductionConfig"
command = /home/paul/.virtualenvs/example/bin/gunicorn wsgi_web:application -b localhost:8000 --workers 3 --worker-class gevent --keep-alive 10 --log-level info --access-logfile /home/paul/www/logs/admin.gunicorn.access.log --error-logfile /home/paul/www/logs/admin.gunicorn.error.log --access-logformat '%%({X-REAL-IP}i)s %%(l)s %%(u)s %%(t)s "%%(r)s" %%(s)s %%(b)s "%%(f)s" "%%(a)s"'
user = paul
autostart=true
autorestart=true
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Each worker is an isolated process with its own memory so you can't really share the same logger across different workers.</p>
<p>Your code runs inside these workers because the master process only cares about managing the workers.</p>
<blockquote>
<p>The master process is a simple loop that listens for various process
  signals and reacts accordingly. It manages the list of running workers
  by listening for signals like TTIN, TTOU, and CHLD. TTIN and TTOU tell
  the master to increase or decrease the number of running workers.</p>
</blockquote>
<p>In Gunicorn itself, there are two main run modes</p>
<ul>
<li>Sync</li>
<li>Async</li>
</ul>
<p>So this is different from threading, this is multiprocessing.</p>
<blockquote>
<p>However since Gunicorn 19, a threads option can be used to process requests in
  multiple threads. Using threads assumes use of the gthread worker.</p>
</blockquote>
<p>With this in mind, the logging code will be written once and will be invoked multiple times each time a new worker is created. You can use Singelton pattern to ensure the same logger instance is being used inside the same worker. </p>
<hr/>
<p>For configuring the logger itself, you just need to follow the normal process of setting the root logger levels and the different loggers levels.</p>
<p><a href="https://docs.python.org/3.4/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">basicConfig()</a> won't affect the root handler if it's already setup:</p>
<blockquote>
<p>This function does nothing if the root logger already has handlers configured for it.</p>
</blockquote>
<p>To set the level on root explicitly do </p>
<pre><code>logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(name)
</code></pre>
<p>Then the level can be set on the handler or logger level.</p>
<pre><code>handler = logging.handlers.TimedRotatingFileHandler(log_path, when='midnight', backupCount=30)                                                                                                             
handler.setLevel(min_level)
</code></pre>
<p>You can check this similar answer for logging related details
<a href="https://stackoverflow.com/questions/38537905/set-logging-levels">Set logging levels</a></p>
<p>More Resources : </p>
<p><a href="http://docs.gunicorn.org/en/stable/design.html" rel="nofollow noreferrer">http://docs.gunicorn.org/en/stable/design.html</a></p>
</div>
