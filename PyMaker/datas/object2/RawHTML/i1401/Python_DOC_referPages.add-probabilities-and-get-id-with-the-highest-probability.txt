<div class="post-text" itemprop="text">
<p>I have the following structure:</p>
<pre><code>('2', 0.30334973335266113)
('4', 0.43178531527519226)
('3', 0.3627113997936249)
('9', 0.5691161155700684)
('2', 0.4603477120399475)
('2', 0.7340329885482788)
('10', 0.4691111445426941)
('13', 0.20860238373279572)
('3', 0.4541565775871277)
('2', 0.4479588568210602)
('2', 0.6090611815452576)
('16', 0.5154575705528259)
('11', 0.4370063543319702)
('12', 0.38097500801086426)
('14', 0.23826521635055542)
('3', 0.39956724643707275)
('12', 0.291579008102417)
('11', 0.4514589309692383)
</code></pre>
<p>I want to get an output that adds the probabilities of each of the id there and return the one that has the highest score.</p>
<p>For instance for 3 and 10:</p>
<pre><code>(3, 1.2)
(10, 0.46)
</code></pre>
<p>The return should be: (3, 1.2)</p>
<pre><code>summed = {}
lis = [('2', 0.30334973335266113),
('4', 0.43178531527519226),
('3', 0.3627113997936249),
('9', 0.5691161155700684),
('2', 0.4603477120399475),
('2', 0.7340329885482788),
('10', 0.4691111445426941),
('13', 0.20860238373279572),
('3', 0.4541565775871277),
('2', 0.4479588568210602),
('2', 0.6090611815452576),
('16', 0.5154575705528259),
('11', 0.4370063543319702),
('12', 0.38097500801086426),
('14', 0.23826521635055542),
('3', 0.39956724643707275),
('12', 0.291579008102417),
('11', 0.4514589309692383)]

for i in lis:
    summed[str(i[0])] = i[1]
</code></pre>
<p>This though overrides the keys so only the last seen key and its value gets stored. When inserted a new key I don't want it to be overwritten, I want the value to be added to the existing key. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can collect the values in a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> and then get the <code>most_common(1)</code>:</p>
<pre><code>&gt;&gt;&gt; lst = [('2', 0.30334973335266113),..., ('11', 0.4514589309692383)]
&gt;&gt;&gt; c = collections.Counter()
&gt;&gt;&gt; for x,y in lst: c[x] += y
&gt;&gt;&gt; c.most_common(1)
[('2', 2.554750472307205)]
</code></pre>
<hr/>
<p>About your existing code: You are not actually <em>summing</em>, but just overwriting the previous value, if any, with <code>=</code>. Intead, you should use <code>+=</code> and initialize the value with <code>0</code> if it does not exist yet. (<code>collections.Counter</code> will do this automatically) Then use <code>max</code> to get the max element.</p>
<pre><code>for x, y in lis:
    if x not in summed:
        summed[x] = 0
    summed[x] += y
print(max(summed.items(), key=lambda t: t[1]))
</code></pre>
</div>
<span class="comment-copy">And what's preventing you from doing so?</span>
<span class="comment-copy">What have you attempted so far? What is your data stored in?</span>
<span class="comment-copy">see <a href="https://stackoverflow.com/questions/13145368/find-the-maximum-value-in-a-list-of-tuples-in-python" title="find the maximum value in a list of tuples in python">stackoverflow.com/questions/13145368/â€¦</a></span>
<span class="comment-copy">It's currently computed dynamically each line. Not sure what's the most efficient way to handle this type of data sets, lists, or key value maps</span>
<span class="comment-copy">Show your code and then we can see how to improve it.</span>
