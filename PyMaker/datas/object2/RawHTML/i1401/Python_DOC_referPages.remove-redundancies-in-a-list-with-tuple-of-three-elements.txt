<div class="post-text" itemprop="text">
<p>I have a list of tuples similar to A:</p>
<pre><code> A = [[(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)], 
[(160, 2, 5), (1000, 2, 5), (111, 1, 2)], 
[(134, 3, 5), (126, 1, 3), (128, 3, 4), (139, 1, 3)], 
[(128, 3, 4)], 
[(90, 1, 5), (160, 2, 5), (134, 3, 5), (1000, 2, 5), (1000, 1, 5), (176, 1, 5)]]
</code></pre>
<p>In each row of this list, there might be tuples which their second and third elements are the same. For example in A[0]:</p>
<pre><code>A[0] = [(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)]
</code></pre>
<p>(90, 1, 5), (1000, 1, 5) and (176, 1, 5) have the same second and third elements. Among these, I need to keep the one which has the max value for the first element and remove the other two. So, I should be able to keep (1000, 1, 5) and remove (90, 1, 5) and (176, 1, 5) from A[0].</p>
<p>It would be better to keep the ordering of the list.</p>
<p>Is there any way to do that iteratively for all the rows in A? Any help would be appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand correctly, here's an <code>itertools.groupby</code> solution. I'm assuming order in the final result does not matter.</p>
<pre><code>from itertools import groupby

def keep_max(lst, groupkey, maxkey):
    'groups lst w.r.t. to groupkey, keeps maximum of each group w.r.t. maxkey'
    sor = sorted(lst, key=groupkey)
    groups = (tuple(g) for _, g in groupby(sor, key=groupkey))
    return [max(g, key=maxkey) for g in groups]
</code></pre>
<p>In action:</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; groupkey = itemgetter(1, 2)
&gt;&gt;&gt; maxkey = itemgetter(0)
&gt;&gt;&gt; A = [[(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)], [(160, 2, 5), (1000, 2, 5), (111, 1, 2)], [(134, 3, 5), (126, 1, 3), (128, 3, 4), (139, 1, 3)], [(128, 3, 4)], [(90, 1, 5), (160, 2, 5), (134, 3, 5), (1000, 2, 5), (1000, 1, 5), (176, 1, 5)]]
&gt;&gt;&gt;
&gt;&gt;&gt; [keep_max(sub, groupkey, maxkey) for sub in A]
[[(111, 1, 2), (139, 1, 3), (1000, 1, 5)],
 [(111, 1, 2), (1000, 2, 5)],
 [(139, 1, 3), (128, 3, 4), (134, 3, 5)],
 [(128, 3, 4)],
 [(1000, 1, 5), (1000, 2, 5), (134, 3, 5)]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution keeps the original ordering of the tuples assuming each tuple (as a whole) is unique; in the case there are duplicates tuples this will return the last appearance of each tuple:</p>
<pre><code>from operator import itemgetter

A = [[(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)],
     [(160, 2, 5), (1000, 2, 5), (111, 1, 2)],
     [(134, 3, 5), (126, 1, 3), (128, 3, 4), (139, 1, 3)],
     [(128, 3, 4)],
     [(90, 1, 5), (160, 2, 5), (134, 3, 5), (1000, 2, 5), (1000, 1, 5), (176, 1, 5)]]


def uniques(lst):
    groups = {}

    for t in lst:
        groups.setdefault(t[1:], []).append(t)

    lookup = {t: i for i, t in enumerate(lst)}
    index = lookup.get

    first = itemgetter(0)
    return sorted(map(lambda x: max(x, key=first), groups.values()), key=index)


result = [uniques(a) for a in A]
print(result)    
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[(139, 1, 3), (1000, 1, 5), (111, 1, 2)], [(1000, 2, 5), (111, 1, 2)], [(134, 3, 5), (128, 3, 4), (139, 1, 3)], [(128, 3, 4)], [(134, 3, 5), (1000, 2, 5), (1000, 1, 5)]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can afford to ignore ordering, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group elements by the 2nd and 3rd elements on a list sorted by ascending order of 2nd and 3rd elements and descending order of the first element. Then the first element of each group is your desired choice:</p>
<pre><code>from itertools import groupby

A = [[(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)], 
     [(160, 2, 5), (1000, 2, 5), (111, 1, 2)], 
     [(134, 3, 5), (126, 1, 3), (128, 3, 4), (139, 1, 3)], 
     [(128, 3, 4)], 
     [(90, 1, 5), (160, 2, 5), (134, 3, 5), (1000, 2, 5), (1000, 1, 5), (176, 1, 5)]]

def max_duplicate(lst):
    res = []
    for k, g in groupby(sorted(lst, key=lambda x: (x[1], x[2], -x[0])), key=lambda x: (x[1], x[2])):
        res.append(next(g))
    return res

result = [max_duplicate(l) for l in A]
for r in result:
    print(r)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[(111, 1, 2), (139, 1, 3), (1000, 1, 5)]
[(111, 1, 2), (1000, 2, 5)]
[(139, 1, 3), (128, 3, 4), (134, 3, 5)]
[(128, 3, 4)]
[(1000, 1, 5), (1000, 2, 5), (134, 3, 5)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by using a hashmap as follows:</p>
<pre><code>d = {}
for a in A:
    for aa in a:
        v, k1, k2 = aa
        if (k1, k2) in d:
            d[(k1, k2)] = max(v, d[(k1, k2)])
        else:
            d[(k1, k2)] = v

l = [[v, k1, k2] for (k1, k2), v in d.iteritems()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using dictionaries:</p>
<pre><code>fin = []
for row in A:
    dict = {}
    for tup in row:
        dict[tup[1:2]] = tup[0]
    fin.append(dict)
A = [[value, t1, t1] for (t1, t2), value in dict.iteritems()]
</code></pre>
<p>Using this, your dict will transform A[0] from</p>
<pre><code>A[0] = [(90, 1, 5), (126, 1, 3), (139, 1, 3), (1000, 1, 5), (111, 1, 2), (176, 1, 5)]
</code></pre>
<p>to </p>
<pre><code>{ (1,5): 1000, (1,3): 139, (1,2): 111 } (as a dict)
</code></pre>
<p>and can then be converted back to an array using iteritems</p>
<p>This way, the order will also be preserved.</p>
</div>
<span class="comment-copy">Is preserving the original order in the lists important?</span>
<span class="comment-copy">@slider It would be better to keep the order in the list but if there is no way, then I should ignore preserving the ordering in the list.</span>
<span class="comment-copy">if your original data can be modified, I suggest using a dictionary, with a key of a tuple using the second and third element, and the value being your first element. That way, you can easily update max values, especially if you have a large dataset</span>
<span class="comment-copy">Useful answer here: <a href="https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-whilst-preserving-order">removing duplicates while maintaining order</a>.</span>
<span class="comment-copy">@I'm new to Python, so may I ask to elaborate more? or write the part of the code that you think would work?</span>
<span class="comment-copy">Thanks! That works perfectly!</span>
