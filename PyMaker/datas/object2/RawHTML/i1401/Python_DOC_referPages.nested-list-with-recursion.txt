<div class="post-text" itemprop="text">
<p>How i can sort multidimensional list to two-dimensional list?</p>
<p>Multidimensional input: <code>[8, [6, 7, [-1], [4, [[10]]], 2], 1]</code></p>
<p>Desired two-dimensional output: <code>[[8, 1], [6, 7, 2], [-1, 4], [], [10]]</code></p>
<p>all same depth list items need to be in same list.</p>
</div>
<div class="post-text" itemprop="text">
<p>The idea is basically the same that the one in @TerryA answer, but using <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer">setdefault</a> and checking at the end of the for loop if something of the depth was added:</p>
<pre><code>lst = [8, [6, 7, [-1], [4, [[10]]], 2], 1]


def depths(l):
    def flatten(l, start=0, depth={}):

        for e in l:
            if isinstance(e, list):
                flatten(e, start=start + 1, depth=depth)
            else:
                depth.setdefault(start, []).append(e)
         if start not in depth:
            depth[start] = []

    d = {}
    flatten(l, depth=d)

    return [d[i] for i in range(max(d) + 1)]


result = depths(lst)
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[8, 1], [6, 7, 2], [-1, 4], [], [10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could perhaps use a <a href="https://docs.python.org/3.3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> here to measure the depth of each element, along with recursion:</p>
<pre><code>from collections import defaultdict
L = [8, [6, 7, [-1], [4, [[10]]], 2], 1]
res = defaultdict(list)
def myfunc(L, depth):
    for i in L:
        if isinstance(i, list):
            myfunc(i, depth+1)
        else:
            res[depth].append(i)

myfunc(L, 0)
</code></pre>
<p>The defaultdict will then look like this:</p>
<pre><code>defaultdict(&lt;class 'list'&gt;, {0: [8, 1], 1: [6, 7, 2], 2: [-1, 4], 4: [10]})
</code></pre>
<p>You'll then need to translate the defaultdict back to what you want. Note that the default dict will not contain an empty list because it can't detect it (ie: <code>[[10]]</code> and <code>[10]</code> are both lists), but what it will have is a gap in the range (notice how the depth <code>3</code> is missing in the defaultdict).</p>
<pre><code>final = []
for i in range(max(res)+1):
    if i not in res:
        final.append([])
    else:
        final.append(res[i])

print(final)
</code></pre>
<p>Very messy, I'm sure improvements could be made.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>My option with recursion and without any dependencies:</strong></p>
<pre><code>lst = [8, [6, 7, [-1], [4, [[10]]], 2], 1]

def flat_group(lst, deep = 0, res = None):
  if res == None: res = []
  for item in lst:
    if len(res) &lt;= deep: res.append([])
    if not type(item) == list:
      res[deep].append((item))
    else:
      flat_group(item, deep + 1, res)
  return res


print(flat_group(lst))
#=&gt; [[8, 1], [6, 7, 2], [-1, 4], [], [10]]
</code></pre>
<p><hr/>
To show <strong>How it works</strong>, I split the method in two:</p>
<pre><code>def flat(lst, deep = 0, res = []):
  for item in lst:
    if not type(item) == list:
      res.append((deep, item))
    else:
      flat(item, deep + 1, res)
  return res

def group(lst):
  flatten = flat(lst)
  max_n = max(flatten)[0]
  res = [[] for _ in range(0,max_n+1)]
  for deep, item in flatten:
    res[deep].append(item)
  return res

print(group(lst))
#=&gt; [[8, 1], [6, 7, 2], [-1, 4], [], [10]]
</code></pre>
<p><code>flat(lst)</code> is a recursive method that builds a flat list of tuples where each tuple contains the value and the deep inside the original list.
So the call <code>flat(lst)</code> returns:</p>
<pre><code># [(0, 8), (1, 6), (1, 7), (2, -1), (2, 4), (4, 10), (1, 2), (0, 1)]
</code></pre>
<p>Then <code>group(lst)</code> builds a list of <code>n+1</code> empty sub-list, where <code>n</code> is the maximum depth, it iterates over the result of <code>flat(lst)</code> and append each element by index to the proper sub-list.</p>
<p>The <code>flat_group(lst)</code> does almost the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this by first generating a dictionary of elements at each depth (with depth as key in this dictionary and list of elements of that depth as value). The recursive function <code>get_elements_by_depth</code> below does this. Then all you need to do is flatten the values of that dictionary. (the function <code>flatten_by_depth</code> below does what you need).</p>
<pre><code>from collections import defaultdict

def get_elements_by_depth(ls, cur_depth, cur_dict):
    """
        returns a dictionary with depth as key and a list of all
        elements that have that depth as value
    """
    for x in ls:
        if isinstance(x, list):
            get_elements_by_depth(x, cur_depth + 1, cur_dict)
        else:
            cur_dict[cur_depth].append(x)
    return cur_dict


def flatten_by_depth(ls):
    """
        returns a list of lists, where the list at index i 
        contains all elements of depth i
    """
    elements_by_depth = get_elements_by_depth(ls, 0, defaultdict(list))
    max_depth = max(elements_by_depth.keys())
    # Since we're using a defaultdict, we don't have to worry about
    # missing keys in elements_by_depth
    return [
        elements_by_depth[i]
        for i in xrange(max_depth + 1)
    ]
</code></pre>
<hr/>
<pre><code>&gt; flatten_by_depth([8, [6, 7, [-1], [4, [[10]]], 2], 1])
[[8, 1], [6, 7, 2], [-1, 4], [], [10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The recursive approach taken by the other answers comes with the recursion limit imposed by Python and the overhead of two passes. A more efficient one-pass iterative approach is to implement breadth-first search using a queue of tuples of lists and associated depths:</p>
<pre><code>from collections import deque
def flatten(lst):
    output = []
    q = deque([(lst, 0)])
    while q:
        l, depth = q.popleft()
        for i in l:
            if isinstance(i, list):
                q.append((i, depth + 1))
            else:
                while depth &gt;= len(output):
                    output.append([])
                output[-1].append(i)
    return output
</code></pre>
<p>so that:</p>
<pre><code>flatten([8, [6, 7, [-1], [4, [[10]]], 2], 1])
</code></pre>
<p>returns:</p>
<pre><code>[[8, 1], [6, 7, 2], [-1, 4], [], [10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Somebody recently posted a similar question which, by the time I composed my answer, was closed as a duplicate. So I figured I'd add my answer here.</p>
<pre><code>def extract_entries(nested_list, new_list=[]):
    # Add the list of all of the items in &lt;nested_list&gt; that are NOT lists themselves. 
    new_list.append( [ e for e in nested_list if type(e) != list ] )

    # Look at entries in &lt;nested_list&gt; that ARE lists themselves.
    for entry in nested_list:
        if type(entry) == list:
            extract_entries(entry, new_list)

    return new_list
</code></pre>
<p>Testing:</p>
<pre><code>M = [8, [6, 7, [-1], [4, [[10]]], 2], 1]
print(extract_entries(M))
# Returns: [[8, 1], [6, 7, 2], [-1], [4], [], [10]]
</code></pre>
</div>
<span class="comment-copy">what's the logic behind this?</span>
<span class="comment-copy">Please try to solve the problem by yourself first.</span>
<span class="comment-copy">@Sociopath he is reorganizing the list by layer depth</span>
<span class="comment-copy">compute the "depth" of each element, then rebuild a list of lists</span>
<span class="comment-copy">Can you please tell me whether <code>[[8, 1], [6, 7, 2], [4], [], [10], [-1]]</code> is an acceptable result, and if not, then why?</span>
<span class="comment-copy"><code>i in res</code> is better than <code>if res.get(i) is None</code></span>
<span class="comment-copy">@Jean-Fran√ßoisFabre yup, ty</span>
<span class="comment-copy">This breaks if there are multiple levels of a sublist without an item, such as <code>[8, [6, 7, [-1], [4, [[[10]]]], 2], 1]</code>. Also, using a mutable object as a default parameter value would result in incorrect results if the function is called more than once.</span>
<span class="comment-copy">@blhsing, thanks for the advice!! I suppose I fixed the first part, but I'm not able to find a workaround for the object mutation... (with Ruby there is not this issue). Can you address me?</span>
<span class="comment-copy">@blhsing then I suppose I fixed also the default param..</span>
<span class="comment-copy">Yes you did fix it. +1</span>
