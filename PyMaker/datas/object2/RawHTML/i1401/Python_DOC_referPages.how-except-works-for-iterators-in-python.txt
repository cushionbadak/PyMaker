<div class="post-text" itemprop="text">
<p>Can you explain to me why the except clause has never been executed and print never been called in the example?    </p>
<pre><code>def h(lst):
  try:
    yield from lst
  except StopIteration:
    print('ST')

t = h([1,2])
next(t)
&gt;&gt;&gt; 1
next(t)
&gt;&gt;&gt; 2
next(t)
&gt;&gt;&gt; Traceback (most recent call last):

File "&lt;ipython-input-77-f843efe259be&gt;", line 1, in &lt;module&gt;
next(t)

StopIteration
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>StopIteration</code> is thrown by <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a>, not by the <code>yield from</code>:</p>
<blockquote>
<p><code>next(iterator[, default])</code></p>
<p>Retrieve the next item from the <em>iterator</em> by calling its <code>__next__()</code> method. If <em>default</em> is given, it is returned if the iterator is exhausted, otherwise <code>StopIteration</code> is raised.</p>
</blockquote>
<p>So you could instead wrap the <code>next</code> call.</p>
<pre><code>def h(lst):
    yield from lst

def next_or_print(it):
    try:
        next(it)
    except StopIteration:
        print('ST')
</code></pre>
<p>Then you use it like this:</p>
<pre><code>&gt;&gt;&gt; t = h([1,2])
&gt;&gt;&gt; next_or_print(t)
1
&gt;&gt;&gt; next_or_print(t)
2
&gt;&gt;&gt; next_or_print(t)
ST
</code></pre>
<p>Note that <code>next</code> also has a second argument that allows to provide a <em>default</em> instead of the <code>StopIteration</code>:</p>
<pre><code>&gt;&gt;&gt; t = h([1,2])
&gt;&gt;&gt; next(t, 'ST')
1
&gt;&gt;&gt; next(t, 'ST')
2
&gt;&gt;&gt; next(t, 'ST')
ST
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>next</code> calls are <strong>outside</strong> your <code>h</code> function and so are not covered by your <code>try</code> / <code>except</code> clause. For comparison, try this:</p>
<pre><code>def h(lst):
    yield from lst

t = h([1,2])
</code></pre>
<p>Then run repeatedly:</p>
<pre><code>try:
    print(next(t))
except StopIteration:
    print('ST')
</code></pre>
<p>Result:</p>
<pre><code>1
2
'ST'
'ST'
'ST'
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def h(lst):
  try:
    yield from lst
  except StopIteration:
    print('ST')
t = h([1, 2])
&gt;&gt;&gt; print(t)
&lt;generator object h at 0x7fbf6f08aa40&gt;
</code></pre>
<p>The function "h" returns a generator. The statement "yield" as a "return" does nothing, only returns a generator. The exception will not be in that part of the code.</p>
<p>The exception must be transferred to another part of the code, where it will work.</p>
<pre><code>def h(lst):
    yield from lst
t = h([1, 2])
next(t)
next(t)
try:
    next(t)
except StopIteration:
    print('ST')
ST
</code></pre>
</div>
