<div class="post-text" itemprop="text">
<p>I'm trying to convert this string data that looks a lot like a list containing dictionaries, into an actual data of said data type or any other form that I can retrieve information. To put it into multiple lines for better view, the string looks like this.</p>
<pre><code>[
    {"type": "account", "data": "{\bid\:8,\acc_num\:135}"},
    {"type": "card", "data": "{\card_num\:142}"}
]
</code></pre>
<p>I've tried the common <code>json.loads(a, strict=False)</code> and <code>json.loads(a)</code> but it had errors as below. I hoped the <code>"{\bid\:8,\acc_num\:135}"</code> part to be lumped into a string (as a value to the key <code>data</code>) but maybe it didn't happen... Thought it might be the <code>\</code> in the string causing this problem but <code>a=a.replace('\','')</code>
is not valid as well (<code>SyntaxError: EOL while scanning string literal</code> error). </p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
File "a.py", line 55, in &lt;module&gt;
    a=json.loads(a)
File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py", line 348, in loads
    return _default_decoder.decode(s)
File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py", line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py", line 353, in raw_decode
    obj, end = self.scan_once(s, idx)
json.decoder.JSONDecodeError: Invalid control character at: line 1 column 32 (char 31)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have mentioned, you could use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a> to do this—but you'll need to use it <em>twice</em>, something like what's shown below which uses a dictionary to "unescape" any standard string backslash escaped characters encountered (while leaving others alone).</p>
<p>The central idea is a two-step process:</p>
<ol>
<li>First to turn characters that must have been escaped back into their original unescaped format (which contains the <code>\</code> character). </li>
<li>Then replace the <code>\</code> character in that with a quote character. </li>
</ol>
<p>For example the character <code>'x\08'</code>—a backspace—is first changed into <code>'\b'</code>, then into <code>'"b'</code>.</p>
<pre><code>from ast import literal_eval

translate = {
    '\\': r'"',   # Backslash (\)
    '\'': r"'",   # Single quote (')
    '\"': r'"',   # Double quote (")
    '\a': r'"a',  # ASCII Bell (BEL)
    '\b': r'"b',  # ASCII Backspace (BS)
    '\f': r'"f',  # ASCII Formfeed (FF)
    '\n': r'"n',  # ASCII Linefeed (LF)
    '\r': r'"r',  # ASCII Carriage Return (CR)
    '\t': r'"t',  # ASCII Horizontal Tab (TAB)
    '\v': r'"v',  # ASCII Vertical Tab (VT)
}.get  # Function to translate escaped characters back to their original form.

def parse(data):
    def unescaped(s): return ''.join(translate(ch, ch) for ch in s)

    result = []
    for d in literal_eval(data):  # First call.
        for key, value in d.items():
            try:
                d[key] = literal_eval(unescaped(value))  # Second call.
            except ValueError:
                pass
        result.append(d)

    return result


if __name__ == '__main__':
    from textwrap import dedent
    from pprint import pprint

    data = dedent("""\
        [
            {"type": "account", "data": "{\bid\:8,\acc_num\:135}"},
            {"type": "card", "data": "{\card_num\:142}"}
        ]
    """)

    pprint(parse(data))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[{'data': {'acc_num': 135, 'bid': 8}, 'type': 'account'},
 {'data': {'card_num': 142}, 'type': 'card'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">ast.literal_eval()</a>:</p>
<pre><code>&gt;&gt;&gt; s = """[
...     {"type": "account", "data": "{\bid\:8,\acc_num\:135}"},
...     {"type": "card", "data": "{\card_num\:142}"}
... ]"""
&gt;&gt;&gt; import ast
&gt;&gt;&gt; x = ast.literal_eval(s)
&gt;&gt;&gt; x
[{'type': 'account', 'data': '{\x08id\\:8,\x07cc_num\\:135}'}, {'type': 'card', 'data': '{\\card_num\\:142}'}]
&gt;&gt;&gt; x[0]
{'type': 'account', 'data': '{\x08id\\:8,\x07cc_num\\:135}'}
</code></pre>
</div>
<span class="comment-copy">You have to escape the backslash in the <code>replace()</code> call: <code>a=a.replace('\\','')</code></span>
<span class="comment-copy">@John: That won't solve the problem which is due to the fact that many of the <code>'\'</code> characters aren't actually in the string—there they are the ASCII value of corresponding character (see table of recognized Standard C-like escape sequences in the <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">String and Bytes literals</a> section of the documentation).</span>
<span class="comment-copy">I don't think you understood the question because <code>ast.literal_eval()</code> alone doesn't produce the desired result.</span>
