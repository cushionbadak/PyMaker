<div class="post-text" itemprop="text">
<p>I was looking at the Python documentation for <a href="https://docs.python.org/3/library/functions.html#print" rel="nofollow noreferrer"><code>print</code></a> which states:</p>
<blockquote>
<p>print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)</p>
</blockquote>
<p>As it can be seen, if the <code>file</code> on which to print is not specified, the default <code>sys.stdout</code> is used, which got me thinking.</p>
<p>Calling <code>print</code> definitely <strong>does not import</strong> <code>sys</code> in the background, so how does it work?</p>
<p>is <code>sys.stdout</code> somehow <em>reachable</em> from everywhere?</p>
<hr/>
<p><strong>Example:</strong></p>
<p>I am using PyCharm and I want to create a function that either prints a message <code>text</code> to a file or to standard output. I began writing:</p>
<pre><code>def my_print(text, file=None):
    print(text, file=file if file is not None else ?)
</code></pre>
<p>So what goes after <code>else</code>? <code>sys.stdout</code> does not work and obviously, I am <strong>not interested</strong> in the verbose:</p>
<pre><code>def my_print(text, file=None):
    if file is None:
        print(text)
    else:
        print(text, file=file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The other answer points out that print is implemented in C. However, <em>even if</em> it was implemented in Python, that would not mean that <code>sys</code> was available from everywhere.</p>
<p>Consider this code:</p>
<p>utils.py</p>
<pre><code>import sys

def my_print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False):
    file.write(sep.join(objects))
</code></pre>
<p>main.py</p>
<pre><code>from utils import print

my_print('foo')
</code></pre>
<p>Here <code>sys</code> is only available within utils, but print will still output to <code>sys.stdout</code> without it being accessible from main.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think @DanielRoseman gave a good idea of <em>why</em> the implementation might not necessarily give you access to <code>sys</code> directly, but to address the last part of your question, you can use this approach...:</p>
<pre><code>def my_print(text, file=None):
    print(text, **({'file': file} if file else {}))
</code></pre>
<p>... where basically you are unpacking the argument <code>file=file</code> if <code>file</code> is present, otherwise pass no argument.</p>
<p>In terms of readability I think your original implementation is superior however.</p>
<hr/>
<p>Actually you can just pass <code>None</code>:</p>
<pre><code>def my_print(text, file=None):
    print(text, file=file)
</code></pre>
<p>... and it would just <code>print</code> the <code>text</code> if <code>file</code> is not provided...</p>
</div>
<span class="comment-copy">No, neither of those things. That default is in the <i>definition</i> of print, not in the place where you use it.</span>
<span class="comment-copy">@DanielRoseman Thank you for the quick comment. Could you elaborate a bit on that? Maybe with an answer even?</span>
<span class="comment-copy">so on the <code>utils.py</code> the <code>import sys</code> <b>must</b> be there.</span>
<span class="comment-copy">Further, it is even possible (but unlikely) to implement as <code>def my_print(text): import sys; sys.stdout...</code> where <code>sys</code> will not exist anywhere outside of the local scope.</span>
