<div class="post-text" itemprop="text">
<p>Possible duplicate for <a href="https://stackoverflow.com/questions/31637435/is-python-3-5s-grammar-ll1">this question</a> however for me it's not specific enough.</p>
<p>The python grammar is <a href="https://www.python.org/dev/peps/pep-3099/" rel="nofollow noreferrer">claimed to be LL(1)</a>, but I've noticed some expressions in the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Python grammar</a> that really confuse me, for example, the arguments in the following function call:</p>
<pre><code>foo(a)
foo(a=a)
</code></pre>
<p>corresponds to the following grammar:</p>
<pre><code>argument: ( test [comp_for] |
            test '=' test |
            '**' test |
            '*' test )
</code></pre>
<p><code>test</code> appears twice in the first position of the grammar. It means that by only looking at <code>test</code> Python cannot determine it's <code>test [comp_for]</code> or <code>test '=' test</code>. </p>
<p>More examples:</p>
<pre><code>comp_op: '&lt;'|'&gt;'|'=='|'&gt;='|'&lt;='|'&lt;&gt;'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
</code></pre>
<p>Note <code>'is'</code> and <code>'is' 'not'</code></p>
<pre><code>subscript: test | [test] ':' [test] [sliceop]
</code></pre>
<p><code>test</code> also appears twice.</p>
<p>Is my understanding of LL(1) wrong? Does Python do some workaround for the grammar during lexing or parsing to make it LL(1) processable? Thank you all in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">grammar presented in the Python documentation</a> (and used to generate the Python parser) is written in a form of Extended BNF which includes "operators" such as optionality (<code>[a]</code>) and Kleene closure (<code>(a b c)*</code>). LL(1), however, is a category which appies only to simple context-free grammars, which do not have such operators. So asking whether that particular grammar is LL(1) or not is a category error.</p>
<p>In order to make the question meaningful, the grammar would have to be transformed into a simple context-free grammar. This is, of course, possible but there is no canonical transformation and the Python documentation does not explain the precise transformation used. Some transformations may produce LL(1) grammars and other ones might not. (Indeed, naive translation of the Kleene star can easily lead to ambiguity, which is by definition not LL(k) for any k.)</p>
<p>In practice, the Python parsing apparatus transforms the grammar into an executable parser, not into a context-free grammar. For Python's pragmatic purposes, it is sufficient to be able to build a predictive parser with a lookahead of just one token. Because a predictive parser can use control structures like conditional statements and loops, a complete transformation into a context-free grammar is unnecessary. Thus, it is possible to use EBNF productions -- as with the documented grammar -- which are not fully left-factored, and even EBNF productions whose transformation to LL(1) is non-trivial:</p>
<pre><code>simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
</code></pre>
<p>In the above production, the repetition of <code>(';' small_stmt)*</code> may be followed by a <code>';'</code>, which means that a simple <code>while</code> loop will not correctly represent the production. I don't know how this production is handled by the Python parser generator, but it is possible to transform it into CFG by left-factoring after expanding the repetition:</p>
<pre><code>simple_stmt: small_stmt rest_A
rest_A     : ';' ret_B
           | NEWLINE
rest_B     : small_stmt rest_A
           | NEWLINE
</code></pre>
<p>Similarly, the entire EBNF can be transformed into an LL(1) grammar. That is not done because the exercise is neither useful for parsing or for explaining the syntax. It would be hard to read, and the EBNF can be directly transformed into a parser.</p>
<p>This is slightly independent of the question of whether Python is LL(1), because a language is LL(1) precisely if an LL(1) grammar exists for the language. There will always be an infinitude of possible grammars for a language, including grammars which are not LL(k) for any k and even grammars which are not context-free, but that is irrelevant to the question of whether the <em>language</em> is LL(1): the language is LL(1) if even one LL(1) grammar exists. (I'm aware that this is not the original question, so I won't pursue this any further.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You're correct that constructs like <code>'is' | 'is' 'not'</code> aren't LL(1). They can be left-factored to LL(1) quite easily by changing it to <code>'is' notOpt</code> where <code>notOpt: 'not' | ϵ</code> or, if you allow EBNF syntax, just <code>'is' 'not'?</code> (or <code>'is' ['not']</code> depending on the flavor of EBNF).</p>
<p>So the language is LL(1), but the grammar technically is not. I assume the Python designers decided that this was okay because the left-factored version would be more difficult to read without much benefit and the current version can still be used as the basis for an LL(1) parser without much difficulty.</p>
</div>
<span class="comment-copy">@PatrickHaugh I don't think it's fair to label this a duplicate when neither the linked question nor answer address OP's specific concerns regarding <code>is not</code> and <code>test</code>.</span>
<span class="comment-copy">Doesn't the <code>(1)</code> mean the parser has one token of lookahead?  So if it's "on" the <code>test</code>, it can look at the next token (but no farther).  (My compilers class was many moons ago, so grain of salt)</span>
<span class="comment-copy">@JETM @sepp2k  Fair enough.  I think this question boils down to a misunderstanding about the nature of <code>LL(1)</code> grammars/parsers though.</span>
<span class="comment-copy">@PatrickHaugh It counts the current token as lookahead (if you can look at it without consuming it). So LL(1) means you can look at the current token only and LL(2) would mean that you can look one token further. LL(0) (which isn't really a thing) would mean that you can never look at a token without consuming it, so it wouldn't be possible to select an alternative based on the current token.</span>
<span class="comment-copy">As per <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" rel="nofollow noreferrer">en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form</a> , a EBNF describes a <i>language</i> rather than <i>grammar.</i> There's no 1-1 correspondence between a EBNF and the resulting grammar, there are multiple possible grammars for a given EBNF. So it only matters if some of them can be LL(1).</span>
<span class="comment-copy">A very clear explanation. Thank you!</span>
<span class="comment-copy">Just an additional thought from Wikipedia: <code>A ε-free LL(1) grammar is also a SLR(1) grammar.</code> So Python is not SLR(1)</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/53596580/is-the-pythons-grammar-ll1#comment94056991_53596580" title="is the pythons grammar ll1%23comment94056991_53596580">stackoverflow.com/questions/53596580/…</a></span>
<span class="comment-copy">@Max Yes, of course. Thank you.</span>
