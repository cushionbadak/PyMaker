<div class="post-text" itemprop="text">
<p>I haven't found an answer which I looked for, so I figured it out by myself and would like to share it with you. These ones: <a href="https://stackoverflow.com/questions/16458340/python-equivalent-of-zip-for-dictionaries">Python equivalent of zip for dictionaries</a> do not implement "default value" (aka. longest flavor) neither do not keep the order.</p>
<h3>How to zip <code>OrderedDict</code>s in python in "zip_longest" flavor?</h3>
<p>Having:</p>
<pre class="lang-py prettyprint-override"><code>from collections import OrderedDict

o1 = OrderedDict([("key_a", "a1"), ("key_b", "b1")])
o2 = OrderedDict([("key_a", "a2"), ("key_h", "h2")])
o3 = OrderedDict([("key_c", "c3")])
o4 = OrderedDict([("key_x", "x4")])
</code></pre>
<p>How to get pairs of key and corresponding zipped values from each OrderedDict passed, but with <code>None</code> if the value is missing?</p>
<pre class="lang-py prettyprint-override"><code>expected_result = [
    ('key_a', ('a1', 'a2', None, None)),
    ('key_b', ('b1', None, None, None)),
    ('key_h', (None, 'h2', None, None)),
    ('key_c', (None, None, 'c3', None)),
    ('key_x', (None, None, None, 'x4')),
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension that iterates over an <code>OrderedDict</code> created from all the keys of the given dicts and outputs key-value tuples with values being a tuple with a generator expression that iterates through the dicts and returns the value of the given key in each dict:</p>
<pre><code>def zip_dicts(*dicts):
    return [(k, tuple(d.get(k) for d in dicts)) for k in OrderedDict.fromkeys(k for d in dicts for k in d)]
</code></pre>
<p>so that <code>zip_dicts(o1, o2, o3, o4)</code> returns:</p>
<pre><code>[('key_a', ('a1', 'a2', None, None)),
 ('key_b', ('b1', None, None, None)),
 ('key_h', (None, 'h2', None, None)),
 ('key_c', (None, None, 'c3', None)),
 ('key_x', (None, None, None, 'x4'))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@blhsing provided the cutest <a href="https://stackoverflow.com/a/55173408/2823074">solution</a>. This one is an alternative.
Works in python 2 and 3:</p>
<pre class="lang-py prettyprint-override"><code>def zip_ordered_mappings_default(*mappings):
    collected_keys = set()
    for key in (key for mapping in mappings for key in mapping):
        if key not in collected_keys:
            collected_keys.add(key)
            yield key, tuple(collection.get(key) for collection in mappings)

# usage:
assert list(zip_ordered_mappings_default(o1, o2, o3, o4)) == expected_result
</code></pre>
<p>The order of resulting items is kept and equivalent to union of ordered-sets created from passed dict's keys. I.e. new keys appear at the end.</p>
<p>The solution is quite general and can be used with regular <code>dict</code>s as well:</p>
<pre class="lang-py prettyprint-override"><code>assert dict(zip_ordered_mappings_default(dict(o1), dict(o2), dict(o3), dict(o4))) == {
    'key_a': ('a1', 'a2', None, None),
    'key_b': ('b1', None, None, None),
    'key_h': (None, 'h2', None, None),
    'key_c': (None, None, 'c3', None),
    'key_x': (None, None, None, 'x4')
}
</code></pre>
<p>Of course in case of <code>dicts</code> order of items is not kept, but tuples in resulting values reflect order of the function's arguments.</p>
</div>
<span class="comment-copy">All right! That's definitively the cutest answer, but probably not the fastest. OrderedDict's constructor ignores duplicates - which gives a valid result, but a key is queried as many times as it occurs in all input dicts. For small collections it's the best choice.</span>
<span class="comment-copy">I wonder why do you use indexing to build a tuple, instead of: <code>return OrderedDict((k, tuple(d_.get(k) for d_ in dicts)) for d in dicts for k in d)</code></span>
<span class="comment-copy">Thanks for the feedback. I've updated my answer so that it no longer wastes time generating duplicating tuples by generating an <code>OrderedDict</code> from the keys first. It also now iterates over <code>dicts</code> rather than an index over the length of <code>dicts</code> (which does now seem really obvious, but I originally planned on using index for what made sense to use an index, but later decided not to use that approach and forgot to switch back to iterating over an iterable).</span>
