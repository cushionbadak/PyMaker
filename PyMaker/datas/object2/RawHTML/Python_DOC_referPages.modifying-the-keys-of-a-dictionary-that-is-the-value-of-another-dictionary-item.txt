<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/28225552/is-there-a-recursive-version-of-pythons-dict-get-built-in">Is there a recursive version of Python's dict.get() built-in?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I am new to python and need help in solving an issue:</p>
<p>I have a dictionary like </p>
<pre><code>tmpDict = {'ONE':{'TWO':{'THREE':10}}}
</code></pre>
<p>Do we have any other way to access THREE's value other than doing </p>
<pre><code>tmpDict['ONE']['TWO']['THREE']
</code></pre>
<p>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the get() on each dict. Make sure that you have added the None check for each access. </p>
</div>
<div class="post-text" itemprop="text">
<p>As always in python, there are of course several ways to do it, but <strong>there is one obvious way to do it.</strong></p>
<p><code>tmpdict["ONE"]["TWO"]["THREE"]</code> <em>is</em> the obvious way to do it.</p>
<p>When that does not fit well with your algorithm, that may be a hint that your structure is not the best for the problem.</p>
<p>If you just want to just save you repetative typing, you can of course alias a subset of the dict:</p>
<pre><code>&gt;&gt;&gt; two_dict = tmpdict['ONE']['TWO'] # now you can just write two_dict for tmpdict['ONE']['TWO']
&gt;&gt;&gt; two_dict["spam"] = 23
&gt;&gt;&gt; tmpdict
{'ONE': {'TWO': {'THREE': 10, 'spam': 23}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My implementation:</p>
<pre><code>def get_nested(data, *args):
    if args and data:
        element  = args[0]
        if element:
            value = data.get(element)
            return value if len(args) == 1 else get_nested(value, *args[1:])
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; dct={"foo":{"bar":{"one":1, "two":2}, "misc":[1,2,3]}, "foo2":123}
&gt;&gt;&gt; get_nested(dct, "foo", "bar", "one")
1
&gt;&gt;&gt; get_nested(dct, "foo", "bar", "two")
2
&gt;&gt;&gt; get_nested(dct, "foo", "misc")
[1, 2, 3]
&gt;&gt;&gt; get_nested(dct, "foo", "missing")
&gt;&gt;&gt;
</code></pre>
<p>There are no exceptions raised in case a key is missing, None value is returned in that case.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer was given already by either Sivasubramaniam Arunachalam or ch3ka.</p>
<p>I am just adding a performances view of the answer.</p>
<pre><code>dicttest={}
dicttest['ligne1']={'ligne1.1':'test','ligne1.2':'test8'}
%timeit dicttest['ligne1']['ligne1.1']
%timeit dicttest.get('ligne1').get('ligne1.1')
</code></pre>
<p>gives us : </p>
<blockquote>
<p>112 ns ± 29.7 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</p>
<p>235 ns ± 9.82 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>No, those are nested dictionaries, so that is the only real way (you could use <code>get()</code> but it's the same thing in essence). However, there is an alternative. Instead of having nested dictionaries, you can use a tuple as a key instead:</p>
<pre><code>tempDict = {("ONE", "TWO", "THREE"): 10}
tempDict["ONE", "TWO", "THREE"]
</code></pre>
<p>This does have a disadvantage, there is no (easy and fast) way of getting all of the elements of <code>"TWO"</code> for example, but if that doesn't matter, this could be a good solution.</p>
</div>
<span class="comment-copy">what do you want to do?</span>
<span class="comment-copy">Why do you have a dictionary like that to begin with? How much other data is at each level that you also want an easy way to access?</span>
<span class="comment-copy">Why don't you want to do <code>tmpDict['ONE']['TWO']['THREE']</code>?</span>
<span class="comment-copy">.get is not made for checking afterwards if the returned value is <code>None</code>, you could also just check if the key is in the dictionary: <code>key in dict</code> or for older versions <code>dict.has_key</code></span>
<span class="comment-copy"><code>tmpDict.get('ONE', {}).get('TWO', {}).get('THREE')</code> by using get with empty dict as default... if any of the three keys doesn't exist, it will returns <code>None</code></span>
<span class="comment-copy">True, accessing a dict's element through the <code>[]</code> operator is an obvious way. But I highly recommend to read also <a href="https://stackoverflow.com/a/52260663/3388962">this answer</a> to a related question. There are realistic scenarios where one has to pass a "path" (possibly of variable length) to an element in a (possibly deeply) nested dictionary where it would be cumbersome to call <code>get()</code> or the <code>[]</code> operator on every intermediate dict.</span>
<span class="comment-copy">I'm not quite clear on how this would be beneficial in any practical application.  If your data is structured, flattening it and upping the key complexity doesn't really seem to add value.</span>
<span class="comment-copy">@sr2222 It means you don't have to have a large number of dicts, it means you don't have to worry about creating the sub-dictionaries when adding new values, and it could be more natural depending on the application. I think that's enough to be worthwhile in some situations.</span>
