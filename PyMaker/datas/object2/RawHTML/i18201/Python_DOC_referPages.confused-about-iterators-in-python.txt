<div class="post-text" itemprop="text">
<p>I am studying python with the book <a href="https://rads.stackoverflow.com/amzn/click/com/1590599829" rel="nofollow noreferrer">Beginning Python: From Novice to Professional</a>, and I get confused about the section discussing <code>iterators</code>. There is an example in this section:</p>
<pre><code>&gt;&gt;&gt; Class Fibs:
...    def __init__(self):
...        self.a = 0
...        self.b = 1
...    def __next__(self):
...        self.a, self.b = self.b, self.a + self.b
...        return self.a
...    def __iter__(self):
...        return self
...
&gt;&gt;&gt; fibs = Fibs()
&gt;&gt;&gt; for f in fibs:
...     if f &gt; 1000:
...         print(f)
...         break
...
1597
</code></pre>
<p>To be honest, I only know that <code>fibs</code> is an object with methods <code>__next__</code> and <code>__iter__</code>, but have no idea about what happens in each step of the loop. And I made a test:</p>
<pre><code>&gt;&gt;&gt; isinstance(f, Fibs)
False
&gt;&gt;&gt; f is fibs
False
&gt;&gt;&gt; isinstance(f, int)
True
&gt;&gt;&gt; fibs.a
1597
</code></pre>
<p>This makes me much more confused! Why the boolean value of <code>f is fibs</code> is <code>False</code>? And why <code>fibs.a</code> become 1597 after the execution of the loop?(Is the method <code>__next__</code> automatically called in the loop?) Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code> 1  fibs = Fibs()
 2  for f in fibs:
 3      if f &gt; 1000:
 4          print(f)
 5          break
</code></pre>
<p>Line 1 creates a Fibs() object, calling <code>__init__()</code>. Line 2 calls <code>__iter__()</code>, which returns an iterator object (in this case, just fibs itself). The interpreter will then begin calling the <code>__next__()</code> method repeatedly; it returns <code>self.a</code>, a plain number, which is assigned to the loop variable <code>f</code> (so of course it's not a Fibs() object and certainly not the one named fibs). When that value reaches 1000, the if clause will fire, print the result, and break out of the loop.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>And why fibs.a become 1597 after the execution of the loop?</p>
</blockquote>
<p>Well this is because it is going through the <a href="http://en.wikipedia.org/wiki/Fibonacci_number" rel="nofollow">Fibonacci sequence</a> and this is the first number over 1000 in the sequence.</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,
  <strong>1597</strong>, 2584 ...</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>On enter to the loop interpreter calls <code>__iter__</code> method. On every loop step interpreter calls <code>__next__</code> method of <code>Fibs</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for f in fibs
</code></pre>
<p>implicitly calls <code>fibs.__iter__</code> and binds <code>f</code> to all the objects that it yields, in turn. None of these objects are instances of <code>Fibs</code>, let alone equal to <code>fibs</code>. The whole is (roughly) equivalent to</p>
<pre><code># boilerplate, implicit in the "for" notation
__iterator = iter(fibs)
while True:
    try:
        f = next(__iterator)
    except StopIteration:
        break

    # your code, with f now bound to what the iterator yielded
    if f &gt; 1000:
        print(f)
        break
</code></pre>
<p>(<code>iter</code> and <code>next</code> are the clean ways to call <code>__iter__</code> and <code>__next__</code>, respectively.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, the loop automatically calls <code>__next__</code>.</p>
<p>The <code>for</code> loop does this to the given object:</p>
<pre><code># turn the object into an iterator
iterator = iter(given_object)
while True:
    try:
        # try to get the next value
        next_value = next(iterator)
    except StopIteration
        # for loop is done, run the `else:` block if there is any
        run_for_else_suite()
        break
    else:
        # set the loop target to `next_value`
        assign_next_value(next_value)
        continue = run_loop_body()
        if not continue:
            break
</code></pre>
<p>The <a href="http://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter()</code> function</a> calls <code>given_object.__iter__()</code>, and the <a href="http://docs.python.org/3/library/functions.html#next" rel="nofollow"><code>next()</code> function</a> calls <code>given_object.__next__()</code>; these functions offer some extra functionality and are the proper way of calling into the iterator API.</p>
<p>So, in each loop iteration, <code>f</code> is assigned the value that the <code>Fib.__next__</code> method returned.</p>
<p>You can also see that <code>Fib</code> is its own iterator; <code>__iter__</code> returns <code>self</code>. Other types can return a dedicated iterator object; lists do, for example:</p>
<pre><code>&gt;&gt;&gt; iter([])
&lt;listiterator object at 0x129516610&gt;
</code></pre>
<p>Returning dedicated iterators lets you create multiple 'views' on an object where each iterator maintains its own position, like nested loops:</p>
<pre><code>lst = [1, 2, 3]
for i in lst:
    for j in lst;
        print (i, j)  # prints (0, 0), (0, 1), (0, 2), (0, 3), (1, 0), etc.
</code></pre>
<p>or you can explicitly reuse the iterator:</p>
<pre><code>lst = [1, 2, 3]
lst_iter = iter(lst)
for i in lst_iter:
    for j in lst_iter:
        print (i, j)  # prints (0, 1), (0, 2)
</code></pre>
</div>
<span class="comment-copy">Well obviously it is called, otherwise <code>print(f)</code> wouldn't give you <code>1597</code>. And you couldn't do <code>f &gt; 1000</code> if <code>f</code> wasn't an integer.</span>
<span class="comment-copy"><code>.__iter__()</code> does not create a generator object. It simply returns <code>self</code>; and because <code>self</code> has a <code>__next__</code> method, it is an iterator. Generators are specialized iterators, but iterators are not necessarily generators.</span>
<span class="comment-copy">If <code>.__iter__()</code> was a method that uses a <code>yield</code> expression, <b>then</b> a generator would be returned.</span>
<span class="comment-copy">You're right of course; just being sloppy.</span>
<span class="comment-copy">@LeeDanielCrocker Get a little bit clear now but still have a question: is the method <code>__iter__</code> called only at the beginning of the loop? For example, I have tried to create a list <code>x=[1,2,3]</code> and <code>dir(x)</code> shows no <code>__next__</code> method but there is <code>__iter__</code>. So at the beginning of <code>for i in x</code>, <code>x.__iter__()</code> is called, returning a iterator that is really being "used" by the <code>for</code> loop. Is my comprehension correct?</span>
<span class="comment-copy">@zenotsang: that is correct.</span>
