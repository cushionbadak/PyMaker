<div class="post-text" itemprop="text">
<p>I have a list L of 4-length list</p>
<pre><code>L = [[1,2,12,13],[2,3,13,14],...]
</code></pre>
<p>and two integers a and b which appear many times in the sublists. What I want is to find the index of the sublists in L which contain a AND b.</p>
<p>I wrote a little code</p>
<pre><code>l=[]
for i in range(len(L)):
    if L[i][0]==a or L[i][1]==a or L[i][2]==a or L[i][3]==a:
        l.append([i] + L[i]) # I put the index in the first position.
# Now l is a list of 5-length lists.
# I do the same loop on that list.
r=[]
for i in range(len(l)):
    if l[i][1]==b or l[i][2]==b or l[i][3]==b or l[i][4]==b:
        r.append(i)
</code></pre>
<p>The index I am looking for are in the list r. However I am pretty sure there is another way to do it in Python since I barely know this language. Maybe if my variable L is something else than a list of lists it would be easier/faster, because I will call this procedure a lot in my main program. (len(L) is around 3000)</p>
<p>By the way I know that the number of index is between one and four included, so I could put some break but I don't know if it will be faster.</p>
<p>---------------- EDIT 1 ----------------</p>
<p>Change "a or b (or is inclusive)" to "a AND b" in the second sentence. I wrote a mistake about my goal.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try with</p>
<pre><code>for index, item in enumerate(L):
  if a in item or b in item:
    r.append(index)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this:</p>
<pre><code>r = [i for i,x in enumerate(L) if any(y in x for y in (a,b))]
</code></pre>
<p>enumerate will give you both indices and values in your list comprehension, and the any statement will tell you if either a or b are in x, which is a sublist in L</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any()</code></a> to test the sublists:</p>
<pre><code>if any(a in subl for subl in L):
</code></pre>
<p>This tests each <code>subl</code> but exits the generator expression loop early if a match is found.</p>
<p>This does <em>not</em>, however, return the specific sublist that matched. You could use <a href="http://docs.python.org/3/library/functions.html#next" rel="nofollow"><code>next()</code></a> with a generator expression to find the first match:</p>
<pre><code>matched = next((subl for subl in L if a in subl), None)
if matched is not None:
    matched[1] += 1
</code></pre>
<p>where <code>None</code> is a default returned if the generator expression raises a <code>StopIteration</code> exception, or you can omit the default and use exception handling instead:</p>
<pre><code>try:
    matched = next(subl for subl in L if a in subl)
    matched[1] += 1
except StopIteration:
    pass # no match found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This kind of thing is what list comprehension is made for.</p>
<p>If you really want inclusive or -- then this is the list you want. In your code, currently, you've giving and.</p>
<pre><code>result = [a_tuple for a_tuple in L if a in a_tuple or b in a_tuple]
</code></pre>
</div>
<span class="comment-copy">Can you describe your problem a little more. What are you trying to do and what is wrong with your current approach? Is it really too slow?? (How long is <code>L</code>?) Also, in your current code <code>r</code> is a list of lists that contain both <code>a</code> AND <code>b</code> -- not inclusive or.</span>
<span class="comment-copy">I need the index of each sublists in the main list L, which contains a or b or a and b. My code gives me the right answer but since I barely know the Python language I am sure there is a faster way to do it. The main list L is about 3000 long, and each sublist is 5 long.</span>
<span class="comment-copy">matched = next((subl for subl in L if a in subl), None) gives only one sublist which contains a ; how can I tell Python to continue to search ? And I need the index because it would be silly to write as the final line L.index(matched)</span>
