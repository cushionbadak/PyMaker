<div class="post-text" itemprop="text">
<p>I have a class AbstractDataHandle, whith his <strong>init</strong> method, and a class Classifier. I would like to have two constructors in Classifier, Java like. One inherited from it`s superclass, and one brand new.</p>
<p>It would be something like (but i intend to "keep" the two constructors):</p>
<pre><code>class AbstractDataHandle():
    def __init__(self, elements, attributes, labels):
        self._load(elements, attributes, labels)


class Classifier(AbstractDataHandle):
    def __init__(self, classifier="LinearSVC", proba=False):
        self._fit(classifier, proba)
</code></pre>
<p>Can i have two constructors in one class?
If yes, can i have a constructor inherited from a superclass, and add a new one?</p>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't have two constructors in one class.</p>
<p>Constructors have to be named <code>__init__</code>. And, unlike Java, Python doesn't allow overloading functions or methods by the type of their arguments. So, if you had two constructors, they would both be the same function.</p>
<p>There are a few ways around this.</p>
<hr/>
<p>Use <code>@classmethod</code>s as alternate constructors:</p>
<pre><code>class Breakfast(object):
    @classmethod
    def from_eggs(cls, eggs):
        obj = cls()
        obj.spam, obj.eggs = 5, eggs
        return obj

    @classmethod
    def from_spam_and_eggs(cls, spam, eggs):
        obj = cls()
        obj.spam, obj.eggs = spam, eggs
        return obj
</code></pre>
<p>A simple example from the standard library is <code>datetime.datetime</code>, which can be constructed with <a href="http://docs.python.org/3.3/library/datetime.html#datetime.datetime.now"><code>now</code></a>, <a href="http://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp"><code>fromtimestamp</code></a>, or a few other alternate constructors, besides the <a href="http://docs.python.org/3/library/datetime.html#datetime.datetime">default</a>.</p>
<hr/>
<p>Use default-valued, keyword-only, and/or variable-argument parameters to make a single constructor that can be called different ways:</p>
<pre><code>class Breakfast(object):
    def __init__(self, eggs=0, spam=5):
        self.spam, self.eggs = spam, eggs
</code></pre>
<p><a href="http://docs.python.org/3/library/functions.html#int"><code>int</code></a> is an example of this: You can create it from a string and a base, or from a single argument that knows how to convert itself to an integer.</p>
<hr/>
<p>Create subclasses that each have different constructors:</p>
<pre><code>class Breakfast(object):
    pass

class HealthyBreakfast(object):
    def __init__(self, spam):
        self.spam, self.eggs = spam, 0

class NormalBreakfast(object):
    def __init__(self, spam, eggs):
        self.spam, self.eggs = spam, eggs
</code></pre>
<hr/>
<p>In any of these cases, you can factor out commonalities into a single "base" initializer. For example:</p>
<pre><code>class Breakfast(object):
    def __init__(self, eggs, spam):
        self.spam, self.eggs = spam, eggs

class HealthyBreakfast(object):
    def __init__(self, spam):
        super(HealthyBreakfast, self).__init__(0, spam)
</code></pre>
<hr/>
<p>Of course in no case is it possible to have breakfast without spam.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use class methods, which work as factory methods. That's imho the best approach for multiple constructors. First argument 'cls' is class itself, not it's instance, so cls('Truck') in class method invokes constructor for class Car.</p>
<pre><code>class Car(object):
    def __init__(self, type='car'):
        self.car_type = type

    @classmethod
    def Truck(cls):
        return cls('Truck')

    @classmethod
    def Sport(cls):
        return cls('Sport')

    @classmethod
    def Van(cls):
        return cls('Van')
</code></pre>
<p>Then you call factory method this way:</p>
<pre><code>mycar = Car.Sport()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are the methods in the accepted answer, but I think this one is fairly flexible. It's convoluted, but very flexible.</p>
<p>When the class is instiated, <strong>init</strong> calls a method and pass it a string argument (obtained from instantiation). That function uses conditionals to call the right "constructor" function to initialize your values, let's say you have different sets of possible starting values.</p>
<p>If you need to provide other arguments (e.g. that might have a value only  at runtime), you can use default values in <strong>init</strong>() to allow optional arguments, and initialize those in <strong>init</strong> as you normally would.</p>
<pre><code>class MyClass:
def __init__(self,argsSet1, otherAttribute="Assigning this default value 
             to make this other argument optional",):
    self.selectArgSet(argsSet1)
    self.otherAttribute = otherAttribute
    print otherAttribute
def selectArgSet(self,ArgSet1):
    if ArgSet1 == "constructorArgSet1":
        self.constructorArgSet1()
    elif ArgSet1 == "constructorArgSet2":
        self.constructorArgSet2()
def constructorArgSet1(self):
    print "Use this method as Constructor 1"
    self.variable1 = "Variable1 value in Constructor 1"
    self.variable2 = "Variable2 value in Constructor 1"
    print self.variable1
    print self.variable2
def constructorArgSet2(self):
    print "Use this method as Constructor 2"


      self.variable1 = "Variable1 value in Constructor 2"
        self.variable2 = "Variable2 value in Constructor 2"
        print self.variable1
        print self.variable2

myConstructor_1_Instance = MyClass("constructorArgSet1")
myConstructor_2_Instance = MyClass("constructorArgSet2", "You can still 
                                           initialize values normally")
</code></pre>
<p>The output of which is:</p>
<blockquote>
<p>Use this method as Constructor 1</p>
<p>Variable1 value in Constructor 1</p>
<p>Variable2 value in Constructor 1</p>
<p>Assign default value to make this other argument optional</p>
<p>Use this method as Constructor 2</p>
<p>Variable1 value in Constructor 2</p>
<p>Variable2 value in Constructor 2</p>
<p>You can still initialize values normally</p>
</blockquote>
</div>
<span class="comment-copy">you could have the subclass constructor call the superclass constructor via <code>super</code> <a href="http://stackoverflow.com/questions/576169/understanding-python-super-and-init-methods" title="understanding python super and init methods">stackoverflow.com/questions/576169/…</a></span>
<span class="comment-copy">Thanks for the answer. The thing is, calling super, i would have only one constructor.  In Java is possible to have more than one, if the number (and/or type) of arguments is different. I wonder if the same thing exists in python.</span>
<span class="comment-copy">You can use <code>@classmethod</code> to make as many constructor-like methods as you want.</span>
<span class="comment-copy">Specifically why do you need two constructors? You may want to look at class methods to simulate this behavior <a href="http://stackoverflow.com/a/141777/735204">stackoverflow.com/a/141777/735204</a></span>
<span class="comment-copy">Just for the record, <code>__init__</code> is <i>not</i> the constructor, it's (as the name implies) an initializer. The proper constructor is<code>__new__</code></span>
<span class="comment-copy">@brunodesthuilliers: The documentation calls <code>__init__</code> the constructor repeatedly (e.g., <a href="http://docs.python.org/3.3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer">here</a>). And that's consistent with other languages—e.g., in C++, the method with the same name as the class that takes initialization values is the constructor; the method that allocates storage and is called <code>new</code> is the allocator.</span>
<span class="comment-copy">@brunodesthuilliers: When the docs are speaking carefully, "constructor" only refers to the <i>call</i> to the class object, which may end up calling <code>__new__</code> and/or <code>__init__</code>, not to either of the methods. But when they're speaking carelessly, it's always <code>__init__</code>, not <code>__new__</code>, that's called a constructor.</span>
<span class="comment-copy">the doc also use the terms "variable" and "assignment" instead of "name" and "binding", which BTW confuses the hell out of people coming from the C world. Also <code>__new__</code> doesn't necessarily "allocates" any storage - it can return whatever you want it to return, including an already existing object.</span>
<span class="comment-copy">@brunodesthuilliers: You can argue that the docs are badly worded. But saying "<code>__init__</code> is not the constructor… The proper constructor is <code>__new__</code>…" is wrong. The docs call <code>__init__</code> and not <code>__new__</code> the constructor, and <code>__init__</code> is the one that parallels what constructors in other languages do; you can't just redefine terms to mean something different from what everyone else means and then say "According to my idiosyncratic definitions, you're incorrect."</span>
