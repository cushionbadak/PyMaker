<div class="post-text" itemprop="text">
<p>Say I have a list, <code>['a', 'b', 'c', 'd']</code>. Are there any built-ins or methods in Python to easily create all <strong>contiguous sublists</strong> (i.e. sub-sequences) starting from the first item?:</p>
<pre><code>['a']
['a', 'b']
['a', 'b', 'c']
['a', 'b', 'c', 'd']
</code></pre>
<p>in Python?</p>
<p>Note that I am excluding lists/sequences such as <code>['a' ,'c']</code>,  <code>['a', 'd']</code>, <code>['b']</code>, <code>['c']</code> or <code>['d']</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>To match your example output (prefixes), then you can just use:</p>
<pre><code>prefixes = [your_list[:end] for end in xrange(1, len(your_list) + 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with a simple <a href="http://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; l = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; 
&gt;&gt;&gt; [l[:i+1] for i in range(len(l))]
[['a'], ['a', 'b'], ['a', 'b', 'c'], ['a', 'b', 'c', 'd']]
</code></pre>
<p>See also: <a href="http://docs.python.org/3/library/functions.html#func-range" rel="nofollow"><code>range()</code></a></p>
<p>If you're using Python 2.x, use <a href="http://docs.python.org/2/library/functions.html#xrange" rel="nofollow"><code>xrange()</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>A little more Pythonic than using <code>(x)range</code> (with the benefit of being the same solution for either Python 2 or Python 3):</p>
<pre><code>lst = list('abcde')
prefixes = [ lst[:i+1] for i,_ in enumerate(lst) ]
</code></pre>
<p>If you decided that the empty list should be a valid (zero-length) prefix, a small hack will include it:</p>
<pre><code># Include 0 as an slice index and still get the full list as a prefix
prefixes = [ lst[:i] for i,_ in enumerate(lst + [None]) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just as an alternative:</p>
<pre><code>def prefixes(seq):
    result = []
    for item in seq:
        result.append(item)
        yield result[:]

for x in prefixes(['a', 'b', 'c', 'd']):
    print(x)
</code></pre>
</div>
<span class="comment-copy">you know that's not ALL sublists, right ?</span>
<span class="comment-copy">What about <code>['b', 'c']</code> , <code>['b', 'd']</code> etc?</span>
<span class="comment-copy">Are you looking for consecutive sequences?</span>
<span class="comment-copy">This isn't even all contiguous sublists...you aren't including ['b', 'c'], ['c', 'd'], and ['b', 'c', 'd'].</span>
<span class="comment-copy">@ShashankGupta, I said <b>starting from the first item</b>.</span>
<span class="comment-copy">Should be <code>xrange(1, len(your_list) + 1)</code>.</span>
<span class="comment-copy">@SvenMarnach good catch - thank you :)</span>
<span class="comment-copy">Or <code>range(1, len(your_list) + 1)</code> in Python 3.x</span>
<span class="comment-copy">I'm not sure that it's more Pythonic to use <code>enumerate</code> but throw away half of its return data, and keep only the part which is exactly what <code>range</code> would have given you.</span>
<span class="comment-copy">I'm using 'Flat is better than nested' (<code>enumerate</code> vs <code>(x)range</code> and <code>len</code>) and 'Explicit is better than implicit' ( <code>i</code> is the result of enumerating over the input list) in my interpretation of 'pythonic' here. Just providing my thought process.</span>
