<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/480214/how-do-you-remove-duplicates-from-a-list-whilst-preserving-order">How do you remove duplicates from a list whilst preserving order?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>so I have this list: <code>a = [-11, 13, 13, 10, -11, 10, 9, -3, 6, -9, -6, -6, 13, 8, -11, -5, 6, -8, -12, 5, -9, -1, -5, 2, -2, 13, 14, -9, 7, -4]</code></p>
<p>and by using a set I need to remove the duplicates and also keep them in the same order</p>
<p>I used this code:</p>
<pre><code>def unique(a):
    a = set(a)
    return list(a)
</code></pre>
<p>it does remove the duplicates when I use it but the problem is it returns them in numerical order like this:</p>
<pre><code>&gt;&gt;&gt; unique(a)
[-2, 2, 5, 6, 7, 8, 9, 10, 13, 14, -12, -11, -9, -8, -6, -5, -4, -3, -1]
</code></pre>
<p>how can I return it in the same order as the original list while removing duplicates using sets?</p>
<p>EDIT:</p>
<p>so I've used this code because it worked:</p>
<pre><code>def unique(a):
    seen = set()
    return [seen.add(x) or x for x in a if x not in seen]
</code></pre>
<p>but can someone explain to me what it does? because I need to make another once but it returns the list without negative numbers, and I can't do that unless I understand what that code does</p>
</div>
<div class="post-text" itemprop="text">
<p>This function already exists in the <a href="http://docs.python.org/3/library/itertools.html#recipes" rel="nofollow"><code>itertools</code> recipes</a>, as <code>unique_everseen</code>. You can copy and paste it from there, or read it to see how it works, or install the third-party package <code>more-itertools</code> and use it from there.</p>
<p>Here's a simplified version of the code:</p>
<pre><code>def unique_everseen(iterable):
    seen = set()
    for element in iterable:
        if element not in seen:
            seen.add(element)
            yield element
</code></pre>
<hr/>
<p>The version in the recipes allows for a <code>key</code> function, which you don't need, and it has two optimizations. But first understand the simple version:</p>
<p><code>seen</code> is a set of all values seen so far. For each value, we check whether it's in <code>seen</code>. If so, we skip it. Otherwise, we add it to the set and <code>yield</code> it. So, we <code>yield</code> each element only the first time it's seen.</p>
<hr/>
<p>The first optimization in the recipe version is simple: looking up the <code>seen.add</code> method isn't quite free, so we do it once instead of N times, by doing <code>seen_add = seen.add</code>. This makes a sizable difference when benchmarking trivial cases, like a list of small integers; it may not make much difference in real use cases with values that are more expensive to hash.</p>
<p>The second optimization is to use <code>ifilterfalse</code> instead of an <code>if</code> to skip over the elements that have already been seen. Basically this means that if you have N elements and M unique elements, you only do M iterations in Python and N in the optimized C code inside <code>ifilterfalse</code>, instead of doing N in Python. Since iterating in C is much faster, this is worth it unless almost all of your elements are unique.</p>
<hr/>
<p>To make it work with a <code>key</code> function, all you have to do is keep a set of <code>key(element)</code> values seen so far, instead of <code>element</code> values seen so far. This makes the <code>ifilterfalse</code> optimization a little harder to do and much less effective, so it isn't done.</p>
<hr/>
<p>If you're only dealing with sequences, not arbitrary iterables, and you can count on Python 2.7+, there's another way to do this which is almost as efficient, and even simpler:</p>
<pre><code>def unique(a):
    return OrderedDict.fromkeys(a).keys()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Abuse of list comprehension:</p>
<pre><code>def unique(seq):
    seen = set()
    return [seen.add(x) or x for x in seq if x not in seen]
    # or use parentheses instead of brackets above for a generator
</code></pre>
</div>
<span class="comment-copy"><code>seen.add</code> always returns <code>None</code>, so this will not work.</span>
<span class="comment-copy">fixed, meant <code>or</code></span>
<span class="comment-copy">After the edit, it does work, but it's still pretty horrible. Using <code>or</code> to sequence two operations in an expression is even more of an abuse than using a list comprehension for side effects.</span>
<span class="comment-copy">Yes, it sure is!</span>
<span class="comment-copy">Actually, you can remove the listcomp abuse by just putting the <code>add</code> in the condition: <code>[x for x in seq if x not in seen and not seen.add(x)]</code>. But it's still an abuse of <code>seen.add</code>, and possibly even harder to see that wayâ€¦</span>
