<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/reference/expressions.html#operator-precedence" rel="noreferrer">http://docs.python.org/2/reference/expressions.html#operator-precedence</a></p>
<p>My guess is that it falls into one of the buckets above dict lookups since</p>
<pre><code>func(*mydict[mykey])
</code></pre>
<p>does the dictionary lookup first.
Is there a better chart than my initial link that goes into more detail regarding order of operations in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The unpacking <code>*</code> is not an operator; it's part of the call syntax. It's defined under <a href="http://docs.python.org/2/reference/expressions.html#calls" rel="nofollow">Calls</a>, where you can see that:</p>
<pre><code>["," "*" expression]
</code></pre>
<p>… can be part of an <code>argument_list</code> in two different places. (The semantics are described in the paragraphs starting "If there are more positional…" and "If the syntax…".)</p>
<p>So it takes any <code>expression</code>. You can see that no operator takes a full <code>expression</code> as its direct argument. So, if you want to loosely consider <code>*</code> an operator, it binds more loosely than any operator. But just remember that it isn't actually an operator.</p>
<p>Also keep in mind that this was all changed in Python 3.x. But the basic idea is the same—both argument unpacking and assignment unpacking take an <code>expression</code>, not just a <code>primary</code>, and therefore loosely-speaking bind more loosely than any operator, which all take a <code>primary</code> or something more specific.</p>
<hr/>
<p>Meanwhile, you might want to try running the parser on your code to see what it does:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; tree = ast.parse('func(*mydict[mykey])')
&gt;&gt;&gt; ast.dump(tree)
"Module(body=[Expr(value=Call(func=Name(id='func', ctx=Load()), args=[], keywords=[],
starargs=Subscript(value=Name(id='mydict', ctx=Load()),
slice=Index(value=Name(id='mykey', ctx=Load())), ctx=Load()), kwargs=None))])"
</code></pre>
<p>You can see that the entire <code>Subscript</code> expression ends up as the <code>starargs</code> to the <code>Call</code>.</p>
<p>The <code>ast</code> module uses the <a href="http://docs.python.org/2/library/ast.html#abstract-grammar" rel="nofollow">Abstract Grammar</a> rather than the one described in the reference manual. It has different names for things, and doesn't handle some things that are considered part of the grammar but actually done at a higher level than the parser, and so on—but, on the other hand, it's a lot easier to take in all at once. You can see that an <code>expr</code> used for <code>starargs</code> can be a <code>Subscript</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As BrenBarn mentioned in the comments, the unpacking is defined as part of <a href="http://docs.python.org/3/reference/expressions.html#calls" rel="nofollow">function calls</a> (Python 2 and 3) and <a href="http://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">assignment statements</a> (Python 3).</p>
<p>So no, it will never take part of the operator precedence because it isn’t an operator.</p>
<blockquote>
<p>How do I know that this won't try to unpack "mydict" in this example? Or is this something that the language parser handles.</p>
</blockquote>
<p>In your example, <code>func(*mydict[mykey])</code>, the specification for the function call applies. So let’s try to <em>parse</em> that manually.</p>
<p>The base part is matched by the definition of <code>call</code>, so <code>*mydict[mykey]</code> is the <code>argument_list</code>. And in the argument list, it will be parsed as <code>"*" expression</code>, with <code>mydict[mykey]</code> being the expression. As such, the parser will never apply the unpacking first, because the grammar simply doesn’t specify a case where after <code>"*" expression</code> another part in brackets follows.</p>
</div>
<span class="comment-copy">It's not an operation, it's part of the function call.  <code>*mydict[mykey]</code> doesn't mean anything on its own, it's only <code>func(*mydict[mykey])</code> that causes argument unpacking.</span>
<span class="comment-copy">Note that in Python 3, tuple unpacking is <i>not</i> part of function calls anymore (which is why <code>a, *b = (1, 2, 3)</code> works), and the whole thing is explained a lot better… but that doesn't help for Python 2. (Also, it still isn't clear exactly what the unpacking <code>*</code> is even in 3.x. It's called an operator in some places, and explicitly said not to be an operator in others…)</span>
<span class="comment-copy">@abarnert In Python 3, tuple unpacking <i>is</i> part of function calls. The only thing that changed is that it is now <b>also</b> is part of assignments.</span>
<span class="comment-copy">I fail to see how this <i>“was all changed in Python 3”</i>. The grammar for calls is pretty much the same, especially in regards to the behavior of the unpacking itself.</span>
<span class="comment-copy">@poke: The grammar for call starargs and assignment targets was unified (and def varargs as well). It doesn't make that much practical difference, I suppose; either way, the loose answer is "if you treat it as an operator, it has lower precedence than any operator", and the correct answer involves reading the reference grammar or the abstract grammar or using <code>ast</code> to do the latter for you…</span>
<span class="comment-copy">Your point is moot. In both Python 2 and Python 3 the code produces the <i>identical</i> AST, so those little grammar changes don’t really make a difference here, and definitely didn’t mean it “was all changed in Python 3”—which implies a completely different behavior although that isn’t true at all…</span>
<span class="comment-copy">Ah I see, so unpacking takes place after the expressions are evaluated.</span>
<span class="comment-copy">This answer is for Python 3. Things aren't <i>hugely</i> different in Python 2, but they are different. You can use the version pulldown menu at the top of the docs page to switch to your particular version.</span>
