<div class="post-text" itemprop="text">
<p>I'm curious about good way to define value object in Python. Per Wikipedia: "<a href="http://en.wikipedia.org/wiki/Value_object">value object</a> is a small object that represents a simple entity whose equality isn't based on identity: i.e. two value objects are equal when they have the same value, not necessarily being the same object". In Python that essentially means redefined <code>__eq__</code> and <code>__hash__</code> methods, as well as immutability.</p>
<p>Standard <code>namedtuple</code> seems like almost perfect solution with exception that they don't play well with modern Python IDE like PyCharm. I mean that IDE will not really provide any helpful insights about class defined as <code>namedtuple</code>. While it's possible to attach docstring to such class using trick like this:</p>
<pre><code>class Point2D(namedtuple("Point2D", "x y")):
    """Class for immutable value objects"""
    pass
</code></pre>
<p>there's simply no place where to put description of constructor arguments and specify their types. PyCharm is smart enough to guess arguments for <code>Point2D</code> "constructor", but type-wise it's blind.</p>
<p>This code have some type information pushed in, but it's not very useful:</p>
<pre><code>class Point2D(namedtuple("Point2D", "x y")):
    """Class for immutable value objects"""
    def __new__(cls, x, y):
        """
        :param x: X coordinate
        :type x: float

        :param y: Y coordinate
        :type y: float

        :rtype: Point2D
        """
        return super(Point2D, cls).__new__(cls, x, y)

point = Point2D(1.0, 2.0)
</code></pre>
<p>PyCharm will see types when constructing new objects, but will not grasp that point.x and point.y are floats, so would not not help to detect their misuse. And I also dislike the idea of redefining "magic" methods on routine basis.</p>
<p>So I'm looking for something that will be:</p>
<ul>
<li>just as easy to define as normal Python class or namedtuple</li>
<li>provide value semantics (equality, hashes, immutability)</li>
<li>easy to document in a way that will play nicely with IDE</li>
</ul>
<p>Ideal solution could look like this:</p>
<pre><code>class Point2D(ValueObject):
    """Class for immutable value objects"""
    def __init__(self, x, y):
        """
        :param x: X coordinate
        :type x: float

        :param y: Y coordinate
        :type y: float
        """
        super(Point2D, self).__init__(cls, x, y)
</code></pre>
<p>Or that:</p>
<pre><code>class Point2D(object):
    """Class for immutable value objects"""

    __metaclass__ = ValueObject

    def __init__(self, x, y):
        """
        :param x: X coordinate
        :type x: float

        :param y: Y coordinate
        :type y: float
        """
        pass
</code></pre>
<p>I tried to find something like this but without success. I thought that it will be wise to ask for help before implementing it by myself.</p>
<p>UPDATE:
With help of user4815162342 I managed to come up with something that works. Here's the code:</p>
<pre><code>class ValueObject(object):
    __slots__ = ()

    def __repr__(self):
        attrs = ' '.join('%s=%r' % (slot, getattr(self, slot)) for slot in self.__slots__)
        return '&lt;%s %s&gt;' % (type(self).__name__, attrs)

    def _vals(self):
        return tuple(getattr(self, slot) for slot in self.__slots__)

    def __eq__(self, other):
        if not isinstance(other, ValueObject):
            return NotImplemented
        return self.__slots__ == other.__slots__ and self._vals() == other._vals()

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self._vals())

    def __getstate__(self):
        """
        Required to pickle classes with __slots__
        Must be consistent with __setstate__
        """
        return self._vals()

    def __setstate__(self, state):
        """
        Required to unpickle classes with __slots__
        Must be consistent with __getstate__
        """
        for slot, value in zip(self.__slots__, state):
            setattr(self, slot, value)
</code></pre>
<p>It's very far from an ideal solution. Class declaration looks like this:</p>
<pre><code>class X(ValueObject):
    __slots__ = "a", "b", "c"

    def __init__(self, a, b, c):
        """
        :param a:
        :type a: int
        :param b:
        :type b: str
        :param c:
        :type c: unicode
        """
        self.a = a
        self.b = b
        self.c = c
</code></pre>
<p>It's total FOUR times to list all attributes: in <code>__slots__</code>, in ctor arguments, in docstring and in ctor body. So far I have no idea how to make it less awkward.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your requirements, although carefully expressed, are not quite clear to me, partly because I don't use the PyCharm GUI. But here is an attempt:</p>
<pre><code>class ValueObject(object):
    __slots__ = ()

    def __init__(self, *vals):
        if len(vals) != len(self.__slots__):
            raise TypeError, "%s.__init__ accepts %d arguments, got %d" \
                % (type(self).__name__, len(self.__slots__), len(vals))
        for slot, val in zip(self.__slots__, vals):
            super(ValueObject, self).__setattr__(slot, val)

    def __repr__(self):
        return ('&lt;%s[0x%x] %s&gt;'
                % (type(self).__name__, id(self),
                   ' '.join('%s=%r' % (slot, getattr(self, slot))
                            for slot in self.__slots__)))

    def _vals(self):
        return tuple(getattr(self, slot) for slot in self.__slots__)

    def __eq__(self, other):
        if not isinstance(other, ValueObject):
            return NotImplemented
        return self.__slots__ == other.__slots__ and self._vals() == other._vals()

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self._vals())

    def __setattr__(self, attr, val):
        if attr in self.__slots__:
            raise AttributeError, "%s slot '%s' is read-only" % (type(self).__name__, attr)
        super(ValueObject, self).__setattr__(attr, val)
</code></pre>
<p>Usage is like this:</p>
<pre><code>class X(ValueObject):
  __slots__ = 'a', 'b'
</code></pre>
<p>This gets you a concrete value class with two read-only slots and an autogenerated constructor, <code>__eq__</code>, and <code>__hash__</code>. For example:</p>
<pre><code>&gt;&gt;&gt; x = X(1.0, 2.0, 3.0)
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 5, in __init__
TypeError: X.__init__ accepts 2 arguments, got 3
&gt;&gt;&gt; x = X(1.0, 2.0)
&gt;&gt;&gt; x
&lt;X[0x4440a50] a=1.0 b=2.0&gt;
&gt;&gt;&gt; x.a
1.0
&gt;&gt;&gt; x.b
2.0
&gt;&gt;&gt; x.a = 10
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 32, in __setattr__
AttributeError: X slot 'a' is read-only
&gt;&gt;&gt; x.c = 10
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 33, in __setattr__
AttributeError: 'X' object has no attribute 'c'
&gt;&gt;&gt; dir(x)
['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__weakref__', '_vals', 'a', 'b']
&gt;&gt;&gt; x == X(1.0, 2.0)
True
&gt;&gt;&gt; x == X(1.0, 3.0)
False
&gt;&gt;&gt; hash(x)
3713081631934410656
&gt;&gt;&gt; hash(X(1.0, 2.0))
3713081631934410656
&gt;&gt;&gt; hash(X(1.0, 3.0))
3713081631933328131
</code></pre>
<p>If you want, you can define your own <code>__init__</code> with the docstring that (presumably) provides your IDE with type annotation hints.</p>
</div>
<div class="post-text" itemprop="text">
<h2>New in version 3.5: The <code>typing</code> module and <code>NamedTuple</code></h2>
<p>In version 3.5, the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer"><code>typing</code></a> module has been added, in it, you will find a class that perfectly fits your needs.</p>
<h3>The new <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><code>NamedTuple</code></a></h3>
<p>It works just as you'd expect:</p>
<ul>
<li><p>Simple type definition:</p>
<pre><code>from typing import NamedTuple
class DownloadableFile(NamedTuple):
    file_path: str
    download_url: str
</code></pre></li>
<li><p>Recognized in PyCharm:</p>
<p><a href="https://i.stack.imgur.com/oPaXh.png" rel="nofollow noreferrer"><img alt="PyCharm completion" src="https://i.stack.imgur.com/oPaXh.png"/></a>
<a href="https://i.stack.imgur.com/JXR2d.png" rel="nofollow noreferrer"><img alt="PyCharm type detection" src="https://i.stack.imgur.com/JXR2d.png"/></a></p></li>
</ul>
<hr/>
<p><strong>Note</strong>:<br/>
As of today, the API is still in a <a href="https://docs.python.org/3/glossary.html#term-provisional-api" rel="nofollow noreferrer">provisional stage</a>. It means it isn't guaranteed to be backwards compatible when new version is released. Changes to the interface though are not expected. My personal take on it is: given the simplicity of the design, if change there is, I am sure it will be an easy refactor ;)</p>
</div>
<span class="comment-copy">Note that <code>namedtuple</code> has a primary purpose of providing both the tuple interface (indexing, unpacking), and attribute access. It was invented for backward-compatibility of functions that used to return tuples, such as <code>os.stat</code> or <code>time.gmtime</code>. It is likely not the optimal choice for a simple value type.</span>
<span class="comment-copy">Regarding types: <i>PyCharm is smart enough to guess arguments for Point2D "constructor", but type-wise it's blind</i> Maybe you should be using a statically typed language? In Python it shouldn't be such a big deal that an IDE is blind about types.</span>
<span class="comment-copy">Well, <code>namedtuple</code> almost do the right job for me. It's definitely more then simple value object, but I can live with it.  As for using statically typed language, I wish I could. But I have a Python project on hands and looking for a way to make development more comfortable. And PyCharm already does very good job for inferring type of variables using docstrings.</span>
<span class="comment-copy">I played with this solution for some time. It grasps semantics of value object precisely, but has same troubles with type inference as <code>namedtuple</code>. Adding <code>__init__</code> doesn't really help: without "magical" string like <code>self.a = a</code> PyCharm has no idea that it should link type declaration of an argument to an object attribute. I used your code to build something that will work for me, but it's far from perfect. I'm attaching it as update to original question now.</span>
