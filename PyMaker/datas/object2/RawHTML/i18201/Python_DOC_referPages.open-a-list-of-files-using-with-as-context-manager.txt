<div class="post-text" itemprop="text">
<p><em>Note:</em> I am aware of the </p>
<pre><code>with open('f1') as f1, open('f2') as f2:
    ...
</code></pre>
<p>syntax.  This is a different question.</p>
<hr/>
<p>Given a list of strings <code>file_names</code> is there a way using <code>with</code>/<code>as</code> to open every file name in that using a single line.  Something such as:</p>
<pre><code>with [open(fn) for fn in file_names] as files:
    # use the list of files
</code></pre>
<p>which of course doesn't work as it attempts to use the context manager on a list.  The length of the list may not be known until run-time, such as <code>sys.argv[1:]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you have access to Python 3.3+, there is a special class designed exactly for this purpose: the <a href="http://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>ExitStack</code></a>. It works just like you'd expect:</p>
<pre><code>with contextlib.ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # All opened files will automatically be closed at the end of
    # the with statement, even if attempts to open files later
    # in the list raise an exception
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>class ListContext:
    def __init__(self, l):
        self.l = l

    def __enter__(self):
        for x in self.l:
            x.__enter__()
        return self.l

    def __exit__(self, type, value, traceback):
        for x in self.l:
            x.__exit__(type, value, traceback)

arr = ['a', 'b', 'c']

with ListContext([open(fn, 'w') for fn in arr]) as files:
    print files

print files
</code></pre>
<p>Output is:</p>
<pre><code>[&lt;open file 'a', mode 'w' at 0x7f43d655e390&gt;, &lt;open file 'b', mode 'w' at 0x7f43d655e420&gt;, &lt;open file 'c', mode 'w' at 0x7f43d655e4b0&gt;]
[&lt;closed file 'a', mode 'w' at 0x7f43d655e390&gt;, &lt;closed file 'b', mode 'w' at 0x7f43d655e420&gt;, &lt;closed file 'c', mode 'w' at 0x7f43d655e4b0&gt;]
</code></pre>
<p>Notice, they are open inside the with context and closed outside.</p>
<p>This is using the Python <a href="http://docs.python.org/2/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer">context manager API</a>.</p>
<p>EDIT: It seems like this already exists but is <strong>deprecated</strong>: See <a href="http://docs.python.org/2/library/contextlib.html" rel="nofollow noreferrer">contextlib</a> and <a href="https://stackoverflow.com/questions/3024925/python-create-a-with-block-on-several-context-managers?rq=1">this SO question</a>.  Use it like this:</p>
<pre><code>import contextlib

with contextlib.nested(*[open(fn, 'w') for fn in arr]) as files:
    print files
print files
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you are basically looking for <a href="http://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="nofollow"><code>contextlib.nested()</code></a>, this was deprecated in Python 2.7 in favor of the multiple manager form of the <a href="http://docs.python.org/2/reference/compound_stmts.html#with" rel="nofollow">with</a> statement but as noted in the docs:</p>
<blockquote>
<p>The one advantage of this function over the multiple manager form of the with statement is that argument unpacking allows it to be used with a variable number of context managers</p>
</blockquote>
<p>In case you are on Python 3.x, here is the code from the Python 2.7 source:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def nested(*managers):
    """Combine multiple context managers into a single nested context manager.                                                                                                               
   This function has been deprecated in favour of the multiple manager form
   of the with statement.

   The one advantage of this function over the multiple manager form of the
   with statement is that argument unpacking allows it to be
   used with a variable number of context managers as follows:

      with nested(*managers):
          do_something()

    """
    warn("With-statements now directly support multiple context managers",
         DeprecationWarning, 3)                                                                                                                                                                  exits = []
    vars = []
    exc = (None, None, None)
    try:
        for mgr in managers:
            exit = mgr.__exit__
            enter = mgr.__enter__
            vars.append(enter())
            exits.append(exit)
        yield vars
    except:
        exc = sys.exc_info()
    finally:
        while exits:
            exit = exits.pop()
            try:
                if exit(*exc):
                    exc = (None, None, None)
            except:
                exc = sys.exc_info()
        if exc != (None, None, None):
            # Don't rely on sys.exc_info() still containing
            # the right information. Another exception may
            # have been raised and caught by an exit method
            raise exc[0], exc[1], exc[2]
</code></pre>
</div>
<span class="comment-copy">you could write your own context manager. is that an option? it's pretty easy. <a href="http://docs.python.org/release/2.5.1/ref/context-managers.html" rel="nofollow noreferrer">docs.python.org/release/2.5.1/ref/context-managers.html</a></span>
<span class="comment-copy"><code>contextlib.nested</code> is deprecated</span>
<span class="comment-copy">Thanks, updated. The <code>ListContext</code> I give here has the same caveats.. i.e. problems happen if <code>__enter__()</code> or <code>__exit__()</code> of inner elements trigger exceptions.</span>
