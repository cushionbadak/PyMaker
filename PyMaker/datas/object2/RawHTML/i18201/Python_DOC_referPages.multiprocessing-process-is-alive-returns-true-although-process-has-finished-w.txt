<div class="post-text" itemprop="text">
<p>I use <code>multiprocess.Process</code> to create a child process and then call <code>os.wait4</code> until child exists. When the actual child process finishes, <code>multiprocess.Process.is_alive()</code> still returns <code>True</code>. That's contradicting. Why?</p>
<p>Code:</p>
<pre class="lang-py prettyprint-override"><code>from multiprocessing import Process
import os, sys

proc = Process(target=os.system, args= ("sleep 2", ))
proc.start()

print "is_alive()", proc.is_alive()
ret = os.wait4(proc.pid, 0)
procPid, procStatus, procRes = ret
print "wait4 = ", ret

## Puzzled!
print "----Puzzled below----"
print "is_alive()", proc.is_alive()
if os.WIFEXITED(procStatus):
    print "exit with status", os.WEXITSTATUS(procStatus)
print "is_alive()", proc.is_alive()
sys.exit(1)
</code></pre>
<p>Output:</p>
<pre><code>is_alive() True
wait4 =  (11137, 0, resource.struct_rusage(ru_utime=0.0028959999999999997, ru_stime=0.003189, ru_maxrss=1363968, ru_ixrss=0, ru_idrss=0, ru_isrss=0, ru_minflt=818, ru_majflt=0, ru_nswap=0, ru_inblock=0, ru_oublock=0, ru_msgsnd=0, ru_msgrcv=0, ru_nsignals=0, ru_nvcsw=1, ru_nivcsw=9))
----Puzzled below----
is_alive() True
exit with status 0
is_alive() True
</code></pre>
<p>My question is about the last three output lines. Why <code>is_alive()</code> return <code>True</code> when the actual process is finished. How can that happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <a href="http://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join" rel="noreferrer"><code>Process.join</code></a> instead of <code>os.wait4</code>.</p>
<ul>
<li><code>Process.is_alive</code> calls <code>waitpid</code> internally through <code>multiprocessing.forking.Popen.poll</code>.</li>
<li>If you call <code>os.wait4</code>, <code>waitpid</code> raises <code>os.error</code> which cause the <code>poll()</code> to return <code>None</code>. (<a href="http://hg.python.org/cpython/file/c167ab1c49c9/Lib/multiprocessing/forking.py#l141" rel="noreferrer">http://hg.python.org/cpython/file/c167ab1c49c9/Lib/multiprocessing/forking.py#l141</a>)</li>
<li><code>is_alive()</code> use that return value to determine whether the process is alive. (<a href="http://hg.python.org/cpython/file/c167ab1c49c9/Lib/multiprocessing/process.py#l159" rel="noreferrer">http://hg.python.org/cpython/file/c167ab1c49c9/Lib/multiprocessing/process.py#l159</a>)
<ul>
<li>=&gt; return <code>True</code>.</li>
</ul></li>
</ul>
<p><a href="http://asciinema.org/a/5901" rel="noreferrer">http://asciinema.org/a/5901</a></p>
<hr/>
<p>Replace following line:</p>
<pre><code>ret = os.wait4(proc.pid, 0)
</code></pre>
<p>with:</p>
<pre><code>proc.join()
</code></pre>
</div>
<span class="comment-copy">Just to be concrete, the OP should replace the <code>ret = os.wait4(...</code> line with <code>proc.join()</code>.</span>
<span class="comment-copy">@TimPeters, I added that to the answer. Thank you for comment.</span>
<span class="comment-copy">@falsetru Thanks for your answer. Your asciinema link teaches me very useful Python debug technique. My intention of this question is to get resource of child process from <code>waitpid</code>, but it looks like I should bypass multiprocessing.Process in this case.</span>
<span class="comment-copy">What happens if I use process.termninate() to kill a process? Even after terminating, process.is_alive() returns True. Any fix/workaround?</span>
<span class="comment-copy">@Explorer, <code>terminate</code>, not <code>termninate</code>. According to <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate" rel="nofollow noreferrer">documentation</a>, it send SIGTERM signal on UNIX, call <code>TerminateProcess()</code> on windows.</span>
