<div class="post-text" itemprop="text">
<p>I tried implementing this formula: <a href="http://andrew.hedges.name/experiments/haversine/" rel="noreferrer">http://andrew.hedges.name/experiments/haversine/</a>
The aplet does good for the two points I am testing:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/FGED4.png"/></p>
<p>Yet my code is not working.</p>
<pre><code>from math import sin, cos, sqrt, atan2

R = 6373.0

lat1 = 52.2296756
lon1 = 21.0122287
lat2 = 52.406374
lon2 = 16.9251681

dlon = lon2 - lon1
dlat = lat2 - lat1
a = (sin(dlat/2))**2 + cos(lat1) * cos(lat2) * (sin(dlon/2))**2
c = 2 * atan2(sqrt(a), sqrt(1-a))
distance = R * c

print "Result", distance
print "Should be", 278.546
</code></pre>
<p>The distance it returns is <strong>5447.05546147</strong>. Why?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's because in Python, all the trig functions <a href="http://docs.python.org/3/library/math.html#trigonometric-functions" rel="noreferrer">use radians</a>, not degrees.</p>
<p>You can either convert the numbers manually to radians, or use the <a href="http://docs.python.org/3/library/math.html#math.radians" rel="noreferrer"><code>radians</code></a> function from the math module:</p>
<pre><code>from math import sin, cos, sqrt, atan2, radians

# approximate radius of earth in km
R = 6373.0

lat1 = radians(52.2296756)
lon1 = radians(21.0122287)
lat2 = radians(52.406374)
lon2 = radians(16.9251681)

dlon = lon2 - lon1
dlat = lat2 - lat1

a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
c = 2 * atan2(sqrt(a), sqrt(1 - a))

distance = R * c

print("Result:", distance)
print("Should be:", 278.546, "km")
</code></pre>
<p>The distance is now returning the correct value of <code>278.545589351</code> km.</p>
<p><strong>Edit:</strong> Just as a note, if you've stumbled across this post because you just need a quick and easy way of finding the distance between two points, I recommend you use the approach recommended in <a href="https://stackoverflow.com/a/43211266/646543">Kurt's answer</a> below -- see his post for rationale.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update: 04/2018:</strong> Note that Vincenty distance is deprecated since GeoPy version <a href="https://geopy.readthedocs.io/en/stable/#module-geopy.distance" rel="noreferrer">1.13</a> - you should use geopy.distance.distance() instead!</p>
<hr/>
<p>The answers above are based on the <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">Haversine formula</a>, which assumes the earth is a sphere, which results in errors of up to about 0.5% (according to <code>help(geopy.distance)</code>). <a href="https://en.wikipedia.org/wiki/Vincenty%27s_formulae" rel="noreferrer">Vincenty distance</a> uses more accurate ellipsoidal models such as <a href="https://en.wikipedia.org/wiki/World_Geodetic_System" rel="noreferrer">WGS-84</a>, and is implemented in <a href="https://pypi.python.org/pypi/geopy" rel="noreferrer">geopy</a>. For example,</p>
<pre><code>import geopy.distance

coords_1 = (52.2296756, 21.0122287)
coords_2 = (52.406374, 16.9251681)

print geopy.distance.vincenty(coords_1, coords_2).km
</code></pre>
<p>will print the distance of <code>279.352901604</code> kilometers using the default ellipsoid WGS-84. (You can also choose <code>.miles</code> or one of several other distance units).</p>
</div>
<div class="post-text" itemprop="text">
<p>For people (like me) coming here via search engine and just looking for a solution which works out of the box, I recommend installing <a href="https://github.com/MartinThoma/mpu" rel="noreferrer"><code>mpu</code></a>. Install it via <code>pip install mpu --user</code> and use it like this to get the <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noreferrer">haversine distance</a>:</p>
<pre><code>import mpu

# Point one
lat1 = 52.2296756
lon1 = 21.0122287

# Point two
lat2 = 52.406374
lon2 = 16.9251681

# What you were looking for
dist = mpu.haversine_distance((lat1, lon1), (lat2, lon2))
print(dist)  # gives 278.45817507541943.
</code></pre>
<p>An alternative package is <a href="https://github.com/tkrajina/gpxpy" rel="noreferrer"><code>gpxpy</code></a>.</p>
<p>If you don't want dependencies, you can use:</p>
<pre><code>import math


def distance(origin, destination):
    """
    Calculate the Haversine distance.

    Parameters
    ----------
    origin : tuple of float
        (lat, long)
    destination : tuple of float
        (lat, long)

    Returns
    -------
    distance_in_km : float

    Examples
    --------
    &gt;&gt;&gt; origin = (48.1372, 11.5756)  # Munich
    &gt;&gt;&gt; destination = (52.5186, 13.4083)  # Berlin
    &gt;&gt;&gt; round(distance(origin, destination), 1)
    504.2
    """
    lat1, lon1 = origin
    lat2, lon2 = destination
    radius = 6371  # km

    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
         math.sin(dlon / 2) * math.sin(dlon / 2))
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    d = radius * c

    return d


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
</div>
<span class="comment-copy">this is true in any programming language, and also in differential calculus.  using degrees is the exception, and only used in human speech.</span>
<span class="comment-copy">Word to the wise, this formula requires all degrees be positive. <code>radians(abs(52.123))</code> should do the trick...</span>
<span class="comment-copy">Thanks. Can you please update your answer with coordinates I provided in question instead of Newport and Cleveland. It will give a better understanding to future readers.</span>
<span class="comment-copy">The arbitrary locations of Newport and Cleveland come from the example geopy documentation in the PyPI listing: <a href="https://pypi.python.org/pypi/geopy" rel="nofollow noreferrer">pypi.python.org/pypi/geopy</a></span>
<span class="comment-copy">I had to modify Kurt Peek's answer to this: Capitalization required: <code>print geopy.distance.VincentyDistance(coords_1, coords_2).km 279.352901604</code></span>
<span class="comment-copy">You should probably use <code>geopy.distance.distance(â€¦)</code> in code which is an alias of the currently best (=most accurate) distance formula. (Vincenty at the moment.)</span>
<span class="comment-copy">You should probably use <code>geopy.distance.geodesic</code> since the distance will raise ValueError if <code>c1=(1, 179)</code> and <code>c2=(0,0)</code>.</span>
