<div class="post-text" itemprop="text">
<p>I want to be able to parse something like "10.[3-25].0.X" into the actual list of ip addresses described by this rule, so for the above example rule the list would be [10.3.0.0, 10.3.0.1....10.25.0.255]. What's the best way to do it?
So far the only thing I was able to come out with is the following awful-looking function:</p>
<pre><code>wc = ''.join(wc.split()).upper()
wc = re.sub(r'(?&lt;![\[-])(\d+)(?![\]-])', r'[\1-\1]', wc)
wc = re.sub(r'X', r'[0-255]', wc).split('.')
ips = []
for i in range(int(re.findall(r'(\d+)-(\d+)', wc[0])[0][0]), int(re.findall(r'(\d+)-(\d+)', wc[0])[0][1]) + 1): 

    for j in range(int(re.findall(r'(\d+)-(\d+)', wc[1])[0][0]), int(re.findall(r'(\d+)-(\d+)', wc[1])[0][1]) + 1): 

        for k in range(int(re.findall(r'(\d+)-(\d+)', wc[2])[0][0]), int(re.findall(r'(\d+)-(\d+)', wc[2])[0][1]) + 1):

            for p in range(int(re.findall(r'(\d+)-(\d+)', wc[3])[0][0]), int(re.findall(r'(\d+)-(\d+)', wc[3])[0][1]) + 1):

                ips.append(str(i) + '.' + str(j) + '.' + str(k) + '.' + str(p))

return ips
</code></pre>
<p>Any improvement ideas would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could make this a lot simpler.</p>
<p>First, instead of writing the exact same thing four times, use a loop or a listcomp:</p>
<pre><code>ranges = [range(int(re.findall(r'(\d+)-(\d+)', wc[i])[0][0]), 
                int(re.findall(r'(\d+)-(\d+)', wc[i])[0][1]) + 1)
          for i in range(4)]
</code></pre>
<p>You can also turn the nested loop into a flat loop over the cartesian product:</p>
<pre><code>for i, j, k, p in itertools.product(*ranges):
</code></pre>
<p>And you can turn that long string-concatenation mess into a simple format or join call:</p>
<pre><code>ips.append('{}.{}.{}.{}'.format(i, j, k, p)) # OR
ips.append('.'.join(map(str, (i, j, k, p))))
</code></pre>
<p>And that means you don't need to split out the 4 components in the first place:</p>
<pre><code>for components in itertools.product(*ranges):
    ips.append('{}.{}.{}.{}'.format(*components)) # OR
    ips.append('.'.join(map(str, components)))
</code></pre>
<p>And now that the loop is so trivial, you can turn it into a listcomp:</p>
<pre><code>ips = ['{}.{}.{}.{}'.format(*components)
       for components in itertools.product(*ranges)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://gist.github.com/miku/6906209" rel="nofollow">Here's</a> a possible example using <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>. The idea is to first evaluate the "template" (e.g. 1.5.123.2-5, 23.10-20.X.12, ...) octet by octet (each yielding a list of values) and then take the cartesian product of those lists.</p>
<pre><code>import itertools
import re
import sys

def octet(s):
    """
    Takes a string which represents a single octet template.
    Returns a list of values. Basic sanity checks.
    """
    if s == 'X':
        return xrange(256)
    try:
        low, high = [int(val) for val in s.strip('[]').split('-')]
        if low &gt; high or low &lt; 0 or high &gt; 255:
            raise RuntimeError('That is no valid range.')
        return xrange(low, high + 1)
    except ValueError as err:
        number = int(s)
        if not 0 &lt;= number &lt;= 255:
            raise ValueError('Only 0-255 allowed.')
        return [number]

if __name__ == '__main__':
    try:
        template = sys.argv[1]
        octets = [octet(s) for s in template.split('.')]
        for parts in itertools.product(*octets):
            print('.'.join(map(str, parts)))
    except IndexError as err:
        print('Usage: %s IP-TEMPLATE' % (sys.argv[0]))
        sys.exit(1)
</code></pre>
<p>(Small) Examples:</p>
<pre><code>$ python ipregex.py '1.5.123.[2-5]'
1.5.123.2
1.5.123.3
1.5.123.4
1.5.123.5

$ python ipregex.py '23.[19-20].[200-240].X'
23.19.200.0
23.19.200.1
23.19.200.2
...
23.20.240.253
23.20.240.254
23.20.240.255   
</code></pre>
</div>
<span class="comment-copy">Thanks! there should be one bracket at the end I suppose: ips = ['{}.{}.{}.{}'.format(*components))</span>
<span class="comment-copy">@AlexeyChurak: Good catch! I was also missing a <code>)</code> on one of the other calls above.</span>
<span class="comment-copy">Be careful with brackets in the shell. IIRC, bash will decide it doesn't know how to make a range with a hyphen in the middle and pass it through unchanged, but zsh, tcsh, and other shells will try to interpret it and either explode it for you or give you an error or garbage values.</span>
<span class="comment-copy">@abarnert, True. The current version of my code would easily work without brackets (since <code>strip('[]')</code>, but OP had brackets in the question, so I included them.</span>
<span class="comment-copy">I was just saying that your test transcript might be better as <code>python ipregex.py '23.[19-20].[200-240].X'</code>, just to make sure someone doesn't complain that it doesn't work for him because he's using zsh.</span>
