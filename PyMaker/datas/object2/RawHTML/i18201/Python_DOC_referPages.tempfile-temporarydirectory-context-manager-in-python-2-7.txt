<div class="post-text" itemprop="text">
<p>Is there a way to create a temporary directory in a context manager with Python 2.7?</p>
<pre><code>with tempfile.TemporaryDirectory() as temp_dir:
    # modify files in this dir

# here the temporary diretory does not exist any more.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option is the "backports.tempfile" package on pypi: <a href="https://pypi.python.org/pypi/backports.tempfile" rel="noreferrer">https://pypi.python.org/pypi/backports.tempfile</a></p>
<p>Quoting the project's description: "This package provides backports of new features in Python’s tempfile module under the backports namespace."</p>
<p>Install with:</p>
<pre><code>pip install backports.tempfile
</code></pre>
<p>Then use it in your script:</p>
<pre><code>from backports import tempfile
with tempfile.TemporaryDirectory() as temp_dir:
    # modify files in this dir
# here the temporary directory does not exist any more.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/tempfile.html#tempfile.TemporaryDirectory" rel="noreferrer"><code>tempfile.TemporaryDirectory()</code></a> was added to the tempfile standard library in Python 3.2</p>
<p>It's a simple wrapper for <code>tempfile.mkdtemp</code>. It is coded in pure Python and can be easily ported to Python 2.7. </p>
<p>For example:</p>
<pre><code>from __future__ import print_function

import warnings as _warnings
import os as _os

from tempfile import mkdtemp

class TemporaryDirectory(object):
    """Create and return a temporary directory.  This has the same
    behavior as mkdtemp but can be used as a context manager.  For
    example:

        with TemporaryDirectory() as tmpdir:
            ...

    Upon exiting the context, the directory and everything contained
    in it are removed.
    """

    def __init__(self, suffix="", prefix="tmp", dir=None):
        self._closed = False
        self.name = None # Handle mkdtemp raising an exception
        self.name = mkdtemp(suffix, prefix, dir)

    def __repr__(self):
        return "&lt;{} {!r}&gt;".format(self.__class__.__name__, self.name)

    def __enter__(self):
        return self.name

    def cleanup(self, _warn=False):
        if self.name and not self._closed:
            try:
                self._rmtree(self.name)
            except (TypeError, AttributeError) as ex:
                # Issue #10188: Emit a warning on stderr
                # if the directory could not be cleaned
                # up due to missing globals
                if "None" not in str(ex):
                    raise
                print("ERROR: {!r} while cleaning up {!r}".format(ex, self,),
                      file=_sys.stderr)
                return
            self._closed = True
            if _warn:
                self._warn("Implicitly cleaning up {!r}".format(self),
                           ResourceWarning)

    def __exit__(self, exc, value, tb):
        self.cleanup()

    def __del__(self):
        # Issue a ResourceWarning if implicit cleanup needed
        self.cleanup(_warn=True)

    # XXX (ncoghlan): The following code attempts to make
    # this class tolerant of the module nulling out process
    # that happens during CPython interpreter shutdown
    # Alas, it doesn't actually manage it. See issue #10188
    _listdir = staticmethod(_os.listdir)
    _path_join = staticmethod(_os.path.join)
    _isdir = staticmethod(_os.path.isdir)
    _islink = staticmethod(_os.path.islink)
    _remove = staticmethod(_os.remove)
    _rmdir = staticmethod(_os.rmdir)
    _warn = _warnings.warn

    def _rmtree(self, path):
        # Essentially a stripped down version of shutil.rmtree.  We can't
        # use globals because they may be None'ed out at shutdown.
        for name in self._listdir(path):
            fullname = self._path_join(path, name)
            try:
                isdir = self._isdir(fullname) and not self._islink(fullname)
            except OSError:
                isdir = False
            if isdir:
                self._rmtree(fullname)
            else:
                try:
                    self._remove(fullname)
                except OSError:
                    pass
        try:
            self._rmdir(path)
        except OSError:
            pass

import os
with TemporaryDirectory() as tmp_dir:
    print("Temporary directory path: %s" % tmp_dir)
    print(os.path.isdir(tmp_dir))

# here the temporary diretory does not exist any more.
print(os.path.isdir(tmp_dir))
</code></pre>
</div>
<span class="comment-copy">See <a href="https://stackoverflow.com/q/6884991">stackoverflow.com/q/6884991</a> for how to do this manually.</span>
<span class="comment-copy">I like this more than copy+pasting snippets. Thank you. I hope my question does not get close-votes now, since I prefer libraries. Question concerning libraries should go to <a href="http://softwarerecs.stackexchange.com/">softwarerecs.stackexchange.com</a> ... BTW: I am joking, I don't understand why the sofwarerecs site exists. Why not ask questions about software recommendations on StackOverFlow ...</span>
<span class="comment-copy">Annoyingly, the backport doesn't alias all the existing <code>tempfile</code> things so you might need to have both.</span>
<span class="comment-copy">If the <code>_&lt;thing&gt; = staticmethod(thing)</code> lines don't work, perhaps they should be taken out?</span>
<span class="comment-copy">Is there a <code>import sys as _sys</code> missing for <code>print(... file=_sys.stderr)</code>?</span>
<span class="comment-copy">Source link: <a href="https://github.com/python/cpython/blob/master/Lib/tempfile.py" rel="nofollow noreferrer">tempfile.py</a> The complicated code is due to trying to clean up during finalization as well, if the context manager hasn’t been properly closed on shutdown. This resulted in <a href="https://bugs.python.org/issue22427" rel="nofollow noreferrer">Issue #22427</a> and has been simplified.</span>
