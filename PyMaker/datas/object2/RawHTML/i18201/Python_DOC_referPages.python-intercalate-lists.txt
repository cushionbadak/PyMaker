<div class="post-text" itemprop="text">
<pre><code>def intercala_listas(lista1,lista2):


l1 = ["b", "d", "f", "h"]
l2 = ["a", "c", "e", "g"]
assert intercala_listas(l1,l2) == ['a', 'b', 'c', 'd', 'e','f', 'g', 'h']
assert l1 == ["b", "d", "f", "h"]
assert l2 == ["a", "c", "e", "g"]
</code></pre>
<p>I have to make a function called intercala_lista who will receive 2 list and return a third list who need to put the elements of the first list (l1) in the  odd index and the elements of the second list (l2) at the even index, like the asserts shown. I didn't expect a complete answer I need an idea of how do that.</p>
<p>Edit: I tried something like this:</p>
<pre><code>def intercala_listas(lista1,lista2):
    lista = [8]
    for i in range(len(lista)):
        if lista[i].index%2 == 0:
            lista[i] = lista1[i]
        else:
            lista[i] = lista2[i]
        return lista
</code></pre>
<p>I know i'm not use index properly in this function. The idea is ok?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could zip the lists, and then flatten the result in a comprehension:</p>
<pre><code>def intercala_listas(a, b):
    c = list(zip(a, b))
    return [elt for sublist in c for elt in sublist]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hint: use the <code>zip</code> function:</p>
<pre><code>&gt;&gt;&gt; zip(l2, l1)
[('a', 'b'), ('c', 'd'), ('e', 'f'), ('g', 'h')]
</code></pre>
<p>Regarding your answer: Python lists aren't arrays. They don't have a fixed size, so just append elements to the end:</p>
<pre><code>def intercala_listas(lista1,lista2):
    # Assumes lista1 and lista2 are the same length 
    lista = []

    for i in range(len(lista1)):
        lista.append(lista1[i])
        lista.append(lista2[i])

    return lista
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; print intercala_listas(list("aceg"), list("bdfh"))
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> function is designed to zip lists together. You seem to want to put the second one first, but you can do that by just reversing the arguments.</p>
<p>Meanwhile, this gives you a sequence of 2-tuples that you have to flatten. The right way to do this is to use <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>chain</code></a>. (Using <code>sum</code> is not only misleading, it's also quadratically slow.)</p>
<p>Finally, the end result of this will be some kind of iterable (in fact, an iterator), not a list, so you have to construct a list out of it. So:</p>
<pre><code>def intercala_listas(a, b):
    return list(itertools.chain.from_iterable(zip(b, a)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short and sweet:</p>
<pre><code>list(sum(zip(l2, l1), ()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sum()</code> for this problem in particular can be confusing and slow (see comments), that's why it'd be a better idea to avoid it. Here's how:</p>
<pre><code>[e for ts in zip(l2, l1) for e in ts]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a funky solution using python's slice assignment with offset and step size, to show off some of pythons lesser known features - a nested list comprehension or other solutions using <code>zip</code> would probably be preferable in general. This solution assumes both lists have the same length:</p>
<pre><code>def intersect_lists(l1, l2):
    result = [0] * len(l1) * 2 #create result list of required size
    result[::2] = l2 #assign l2 to the slice of every second item in result
    result[1::2] = l1 #as above but starting at offset 1
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

list(itertools.chain(*zip(l2, l1)))
# ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
</code></pre>
<p>or</p>
<pre><code>list(itertools.chain.from_iterable(zip(l2, l1)))
# ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
</code></pre>
</div>
<span class="comment-copy">Have you tried anything?</span>
<span class="comment-copy">We shouldn't do your homework for you.</span>
<span class="comment-copy">I try something like this: i'll edit the first post</span>
<span class="comment-copy"><code>lista = [8]</code> creates a single-element list with one value, the number <code>8</code>, not an 8-element list.</span>
<span class="comment-copy">Retracted my close vote/down vote. Next time, show what you tried! You'll be far more likely to get helpful answers, such as the one @Blender supplied!</span>
<span class="comment-copy">Nice explanation of what the OP was doing wrong/how close he was/how to fix it.</span>
<span class="comment-copy">â€¦ except that you need <code>len(lista) + len(listb)</code> (or <code>2 * len(lista)</code> or something similar), and then you need <code>lista1[i/2]</code>. Or, alternatively, you need to scrap the <code>if</code> and just do both each time.</span>
<span class="comment-copy">ty for your explanation, make this easy to understand now.</span>
<span class="comment-copy">@abarnert: Guess that mental interpreter isn't running today. Thanks.</span>
<span class="comment-copy">Using sum on tuples is a bad idea. Besides being questionably readable (at least the creator of the sum method thinks it's misleading and unreadable), it's also quadratically slow. With lists, at least you <i>can</i> work around that (e.g., by using <code>functools.reduce</code> and <code>operator.iadd</code>); with tuples, there's really nothing you can do.</span>
<span class="comment-copy">Using <code>sum</code> on lists is a bad idea. Besides being questionably readable (at least the creator of the <code>sum</code> method thinks it's misleading and unreadable), it's also quadratically slow.</span>
<span class="comment-copy">@abarnert that's why I suggest a second, <code>sum</code>-less implementation :)</span>
<span class="comment-copy"><code>((x, y) for x, y in zip(l2, l1))</code> made me chuckle. If you look at it for a second you should realize why :)</span>
<span class="comment-copy">@l4mpi you're right, I just realized it :) . Fixed it!</span>
