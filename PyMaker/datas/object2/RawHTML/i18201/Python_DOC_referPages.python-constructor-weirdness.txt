<div class="post-text" itemprop="text">
<p>I have this simple code:</p>
<pre><code>class bfs:
    vis=[]
    bags=[]
    def __init__ (self,x): 
        for i in p:    #initializes vis with len(p) zeroes 
            self.vis.append(0)
            print self.vis
        self.vis[x]=1   #marks index x as visited
        print self.vis

p=raw_input("Input values: ").split()
for i in range(0,len(p)):
    p[i]=int(p[i])

q=[]
for i in range(0,len(p)):
    q.append(bfs(i))

print
for i in q:
    print i.vis
</code></pre>
<p>If i input, say, any 3 numbers, why do I get this output:</p>
<pre><code>[0]
[0, 0]
[0, 0, 0]
[1, 0, 0]
[1, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 1, 0, 0, 0, 0]
[1, 1, 0, 0, 0, 0, 0]
[1, 1, 0, 0, 0, 0, 0, 0]
[1, 1, 0, 0, 0, 0, 0, 0, 0]
[1, 1, 1, 0, 0, 0, 0, 0, 0]

[1, 1, 1, 0, 0, 0, 0, 0, 0]
[1, 1, 1, 0, 0, 0, 0, 0, 0]
[1, 1, 1, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>Instead of something like this?</p>
<pre><code>[0]
[0, 0]
[0, 0, 0]
[1, 0, 0]
[0]
[0, 0]
[0, 0, 0]
[0, 1, 0]
[0]
[0, 0]
[0, 0, 0]
[0, 0, 1]

[1, 0, 0]
[0, 1, 0]
[0, 0, 1]
</code></pre>
<p>The program seems to just keep on working with one array in all created objs. I don't understand why. Any help would be swell.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're defining defining <code>vis</code> and <code>bags</code> as part of the class (as "attribute references"), instead of in the constructor. Try this instead:</p>
<pre><code>class bfs:
    def __init__(self, x):
        self.vis = []
        self.bags = []
        # etc.
</code></pre>
<p>The <a href="http://docs.python.org/3/tutorial/classes.html#class-objects" rel="nofollow">documentation for class objects</a> may help:</p>
<blockquote>
<p>Attribute references use the standard syntax used for all attribute references in Python: obj.name. Valid attribute names are all the names that were in the classâ€™s namespace when the class object was created. So, if the class definition looked like this:</p>
<pre><code>class MyClass:
    """A simple example class"""
    i = 12345
    def f(self):
        return 'hello world'
</code></pre>
<p>then MyClass.i and MyClass.f are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of MyClass.i by assignment.</p>
</blockquote>
<p>There's also a <a href="http://www.diveintopython.net/object_oriented_framework/class_attributes.html" rel="nofollow">Dive Into Python page</a> about this:</p>
<blockquote>
<p>Class attributes are available both through direct reference to the class and through any instance of the class.</p>
<p>Note: In Java, both static variables (called class attributes in Python) and instance variables (called data attributes in Python) are defined immediately after the class definition (one with the static keyword, one without). <strong>In Python, only class attributes can be defined here; data attributes are defined in the <code>__init__</code> method.</strong></p>
</blockquote>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument">"Least Astonishment" in Python: The Mutable Default Argument</a></span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/68645/static-class-variables-in-python">Static class variables in Python</a></span>
<span class="comment-copy">That did indeed do the trick. I had no idea you had to do things this way in Python. Thanks</span>
