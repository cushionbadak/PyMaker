<div class="post-text" itemprop="text">
<p>Using Numpy/Python, is it possible to return the mean AND variance from a single function call?</p>
<p>I know that I can do them separately, but the mean is required to calculate the sample standard deviation.  So if I use separate functions to get the mean and variance I am adding unnecesary overhead.</p>
<p>I have tried looking at the numpy docs here (<a href="http://docs.scipy.org/doc/numpy/reference/routines.statistics.html">http://docs.scipy.org/doc/numpy/reference/routines.statistics.html</a>), but with no success.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't pass a known mean to <code>np.std</code> or <code>np.var</code>, you'll have to wait for the <a href="http://www.python.org/dev/peps/pep-0450/">new standard library <code>statistics</code> module</a>, but in the meantime you can save a little time by using the formula:</p>
<pre><code>In [329]: a = np.random.rand(1000)

In [330]: %%timeit
   .....: a.mean()
   .....: a.var()
   .....: 
10000 loops, best of 3: 80.6 µs per loop

In [331]: %%timeit
   .....: m = a.mean()
   .....: np.mean((a-m)**2)
   .....: 
10000 loops, best of 3: 60.9 µs per loop

In [332]: m = a.mean()

In [333]: a.var()
Out[333]: 0.078365856465916137

In [334]: np.mean((a-m)**2)
Out[334]: 0.078365856465916137
</code></pre>
<p>If you really are trying to speed things up, try <code>np.dot</code> to do the squaring and summing (since that's what a dot-product is):</p>
<pre><code>In [335]: np.dot(a-m,a-m)/a.size
Out[335]: 0.078365856465916137

In [336]: %%timeit
   .....: m = a.mean()
   .....: c = a-m
   .....: np.dot(c,c)/a.size
   .....: 
10000 loops, best of 3: 38.2 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also avoid the subtraction by making use of the relation between mean, variance and power of a signal:</p>
<pre><code>In [7]: import numpy as np

In [8]: a = np.random.rand(1000)

In [9]: %%timeit
   ...: a.mean()
   ...: a.var()
   ...: 
10000 loops, best of 3: 24.7 us per loop

In [10]: %%timeit
    ...: m = a.mean()
    ...: np.mean((a-m)**2)
    ...: 
100000 loops, best of 3: 18.5 us per loop

In [11]: %%timeit
    ...: m = a.mean()
    ...: power = np.mean(a ** 2)
    ...: power - m ** 2
    ...: 
100000 loops, best of 3: 17.3 us per loop

In [12]: %%timeit
    ...: m = a.mean()
    ...: power = np.dot(a, a) / a.size
    ...: power - m ** 2
    ...: 
100000 loops, best of 3: 9.16 us per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think NumPy provides a function that returns both the mean and the variance.</p>
<p>However, SciPy provides the function <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html" rel="nofollow noreferrer"><code>scipy.stats.norm.fit()</code></a> which returns the mean and standard deviation of a sample.  The function is named after its more specific purpose of fitting a normal distribution to a sample.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; import scipy.stats
&gt;&gt;&gt; scipy.stats.norm.fit([1,2,3])
(2.0, 0.81649658092772603)
</code></pre>
<p>Note that <code>fit()</code> does not apply <a href="https://en.wikipedia.org/wiki/Bessel's_correction" rel="nofollow noreferrer">Bessel's correction</a> to the standard deviation, so if you want that correction, you have to multiply by the appropriate factor.</p>
</div>
<span class="comment-copy">Why don't you just use numpy.std? Or would you like to calculate something other than the standard deviation?</span>
<span class="comment-copy">For future readers:  the <a href="https://docs.python.org/3/library/statistics.html" rel="nofollow noreferrer">statistics module was added in Python 3.4</a> and the variance function can be passed an already calculated mean to save processing time.  I'm not sure how the performance of it compares with numpy, though.</span>
