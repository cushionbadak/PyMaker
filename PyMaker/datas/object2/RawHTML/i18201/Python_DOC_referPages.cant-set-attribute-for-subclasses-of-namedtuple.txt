<div class="post-text" itemprop="text">
<p>It looks like <a href="https://stackoverflow.com/questions/1529002/cant-set-attributes-of-object-class">this</a> or <a href="https://stackoverflow.com/questions/4183432/cant-set-attribute-with-new-style-properties-in-python">this</a> are somewhat related threads, but still haven't figured things out :)</p>
<p>I'm trying to create a subclass of <code>namedtuple</code> and provide different initializers so that I can construct objects in different ways.  For example:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; class C(namedtuple("C", "x, y")) :
...     __slots__ = ()
...     def __init__(self, obj) : # Initialize a C instance by copying values from obj
...         self.x = obj.a
...         self.y = obj.b
...     def __init__(self, x, y) : # Initialize a C instance from the parameters
...         self.x = x
...         self.y = y
</code></pre>
<p>However, that doesn't work:</p>
<pre><code>&gt;&gt;&gt; c = C(1, 2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 7, in __init__
AttributeError: can't set attribute
</code></pre>
<p>After some poking around (for example, see <a href="https://stackoverflow.com/questions/12745671/cannot-init-an-instance-of-a-subclassed-namedtuple">this</a> thread) I tried to use constructors instead of initializers:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; class C(namedtuple("C", "x, y")) :
...     __slots__ = ()
...     def __new__(cls, obj) :
...       self = super(C, cls).__new__(cls, obj.a, obj.b)
...     def __new__(cls, x, y) :
...       self = super(C, cls).__new__(cls, x, y)
</code></pre>
<p>which seemed to construct an object but then I can't read its attributes:</p>
<pre><code>&gt;&gt;&gt; c = C(1,2)
&gt;&gt;&gt; c.x, c.y
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'x'
</code></pre>
<p>Where am I going wrong here?  How can I create a subclass with multiple constructors or initializers?</p>
</div>
<div class="post-text" itemprop="text">
<p>Named tuples are immutable, so you cannot manipulate them in the <code>__init__</code> initializer. Your only option is to override the <code>__new__</code> method:</p>
<pre><code>class C(namedtuple('C', 'x, y')):
    __slots__ = ()
    def __new__(cls, obj):
        return super(C, cls).__new__(cls, obj.x, obj.y)
</code></pre>
<p>Note that because <code>__new__</code> is a factory method for new instances, you do need to <em>return</em> the newly created instance. If you do not use <code>return</code> in the <code>__new__</code> method, the default return value is <code>None</code>, which gives you your error.</p>
<p>Demo with an object with <code>x</code> and <code>y</code> attributes:</p>
<pre><code>&gt;&gt;&gt; class C(namedtuple('C', 'x, y')):
...     __slots__ = ()
...     def __new__(cls, obj):
...         return super(C, cls).__new__(cls, obj.x, obj.y)
... 
&gt;&gt;&gt; O.x, O.y
(10, 20)
&gt;&gt;&gt; C(O)
C(x=10, y=20)
</code></pre>
<p>Python does not support method overloading; generally you either use optional keyword arguments or extra class methods as factory methods.</p>
<p>The <a href="http://docs.python.org/3/library/datetime.html"><code>datetime</code> module</a>, for example, has several such factory methods to let you create objects  that do not fit the standard constructor. <a href="http://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp"><code>datetime.datetime.fromtimestamp()</code></a> creates a <code>datetime.datetime</code> instance from a single numeric value, and so does <a href="http://docs.python.org/3/library/datetime.html#datetime.datetime.fromordinal"><code>datetime.datetime.fromordinal()</code></a>; except that they interpret the number in different ways.</p>
<p>If you wanted to support variable arguments, do:</p>
<pre><code>class C(namedtuple('C', 'x, y')):
    __slots__ = ()

    def __new__(cls, x, y=None):
        if y is None:
            # assume attributes
            x, y = x.x, x.y
        return super(C, cls).__new__(cls, x, y)
</code></pre>
<p>Here, <code>y</code> is an optional argument, defaulting to <code>None</code> if not supplied by the caller:</p>
<pre><code>&gt;&gt;&gt; C(3, 5):
C(x=3, y=5)
&gt;&gt;&gt; C(O)
C(x=10, y=20)
</code></pre>
<p>The alternative, using a class method, would be:</p>
<pre><code>class C(namedtuple('C', 'x, y')):
    @classmethod
    def from_attributes(cls, obj):
        return cls(obj.x, obj.y)
</code></pre>
<p>Now there are two factory methods; one default and one named:</p>
<pre><code>&gt;&gt;&gt; C(3, 5):
C(x=3, y=5)
&gt;&gt;&gt; C.from_attributes(O)
C(x=10, y=20)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two things: one, you're not really getting much out of namedtuple here, as far as i can tell. So maybe you should just switch to a normal class. Also, you can't overload the</p>
<p>Second, other possibilities which might help with your problem:</p>
<p><a href="http://www.oodesign.com/factory-pattern.html" rel="nofollow">Factory design pattern</a> - instead of putting the different parameters in the constructor, have a class that takes different kinds of parameters and calls the constructor with appropriate arguments, outside the object.
<a href="https://pypi.python.org/pypi/recordtype/" rel="nofollow">recordtype</a> - a mutable namedtuple, that allows defaults but would also let you write your subclass the way you originally wanted.
<a href="https://pypi.python.org/pypi/bunch" rel="nofollow">bunch</a> - not exactly a named tuple, but lets you create somewhat arbitrary objects. </p>
</div>
<div class="post-text" itemprop="text">
<p>There is a workaround to changing the attribute of a namedtuple.</p>
<pre><code>import collections

def updateTuple(NamedTuple,nameOfNamedTuple):
    ## Convert namedtuple to an ordered dictionary, which can be updated
    NamedTuple_asdict = NamedTuple._asdict()

    ## Make changes to the required named attributes
    NamedTuple_asdict['path']= 'www.google.com'

    ## reconstruct the namedtuple using the updated ordered dictionary
    updated_NamedTuple = collections.namedtuple(nameOfNamedTuple, NamedTuple_asdict.keys())(**NamedTuple_asdict)

    return updated_NamedTuple

Tuple = collections.namedtuple("Tuple", "path")
NamedTuple = Tuple(path='www.yahoo.com')
NamedTuple = updateTuple(NamedTuple, "Tuple")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you use the the <a href="https://docs.python.org/2/library/collections.html#collections.somenamedtuple._replace" rel="nofollow noreferrer"><code>_replace</code></a> method</p>
<pre><code>from collections import namedtuple
C = namedtuple('C', 'x, y')
c = C(x=10, y=20)
# c.x = 30 won't work
c = c._replace(x=30)
</code></pre>
</div>
<span class="comment-copy">Why do you have double <code>__init__</code> and <code>__new__</code> methods? Only the second one counts, it overwrites the first. Python does not 'overload' method signatures.</span>
<span class="comment-copy">No overloading...  So that means that my original goal of creating instances of C in different ways (depending on overloaded constructors) is not actually doable?</span>
<span class="comment-copy">It is perfectly doable, just using different paradigms.</span>
<span class="comment-copy">See my comment below, under your answer.  You say it's doable using factory methods, but not using multiple "constructors"?</span>
<span class="comment-copy">You can use just one constructor, but the constructor can vary behaviour based on the arguments you pass in.</span>
<span class="comment-copy">Thank you Martijn.  Without overloading I've decided to use a constructor (which receives <code>x</code> and <code>y</code>) and a second factory method (which receives an <code>obj</code>).  Not pretty, perhaps I prefer the C++ style constructor overloading, but I guess that's as much as I can do with Python.</span>
<span class="comment-copy">What about using the _replace method? <a href="https://docs.python.org/2/library/collections.html#collections.somenamedtuple._replace" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
<span class="comment-copy">@YonatanSimson: what about using it? Can you elaborate? Note that <code>instance._replace()</code> returns a new instance, the original is left unchanged. <code>._replace()</code> won't make a factory function more efficient.</span>
<span class="comment-copy">@MartijnPieters True. You can do this: <code>c = c._replace(x=30)</code>. I feel it is better to use existing functionality even if there is some overhead. Writing your own method might have the same overhead costs without having the same level testing and confidence</span>
<span class="comment-copy">@YonatanSimson: how would you use that here? The user is asking for a factory method, to create a new object. <code>_replace()</code> works great on an <i>existing instance</i>, but that's not what is being asked for here.</span>
<span class="comment-copy">Thanks for the links, these are good references!</span>
<span class="comment-copy">This creates a new instance of the named tuple, and all existing references to the named tuple will still access the original and not the new one. Thus, they won't see the change.</span>
<span class="comment-copy">Couldn't the new instance be assigned to the old variable?</span>
<span class="comment-copy">If you keep track of <i>all</i> variables at runtime that point at the original tuple, then yes.</span>
