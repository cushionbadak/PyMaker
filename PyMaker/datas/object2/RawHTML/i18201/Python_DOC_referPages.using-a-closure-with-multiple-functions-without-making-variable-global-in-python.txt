<div class="post-text" itemprop="text">
<p>I'm trying to make an example program in Python 2.7 which saves/shares states between two functions.
You call a function, next time you call a function, it should remember the previous value. Here is my current code:</p>
<pre><code>def stuff():
    global x 
    x = 100
    def f():
        global x
        x = x * 2
        return x
    def g():
        global x
        x = x * 4
        return x
    return (f, g)

a,b = stuff()
print(a());
</code></pre>
<p>This code works, BUT the catch is that <code>x</code> must not be considered as a global variable <strong>outside the scope</strong> of <code>stuff()</code>... (That is the whole point of embedding x within <code>stuff()</code> in the first place). So, would <code>x</code> be global, or is it local to <code>stuff()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to support python 2.X, @georgek's answer is the best, but a lot of people don't realize that you can add attributes to functions.  A common idiom is to use a list of a single element to hold the variable.</p>
<pre><code>def stuff():
    x = [100]
    def g():
        x[0] = x[0]*2
        return x[0]
    def h():
        x[0] = x[0]*4
        return x[0]
    return (g,h)
a, b = stuff()
print(a())
</code></pre>
<p>This works because you never assign to x itself in the internal scopes, so it doesn't rebind the variable and shadow the closure.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x, you can use <a href="http://docs.python.org/3/reference/simple_stmts.html#grammar-token-nonlocal_stmt" rel="nofollow"><code>nonlocal</code></a> statement:</p>
<pre><code>def stuff():
    x = 100
    def f():
        nonlocal x
        x = x * 2
        return x
    def g():
        nonlocal x
        x = x * 4
        return x
    return f, g
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; a, b = stuff()
&gt;&gt;&gt; a()
200
&gt;&gt;&gt; b()
800
&gt;&gt;&gt; a()
1600
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Easiest and least hacky solution, use a class:</p>
<pre><code>class stuff(object):
    x = 100
    def f(self):
        self.x = self.x * 2
        return self.x

    def g(self):
        self.x = self.x * 4
        return self.x
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; s = stuff()
&gt;&gt;&gt; s.f()
200
&gt;&gt;&gt; s.g()
800
</code></pre>
<p>You want to prevent people from accessing <code>x</code> from outside the functions at all. The way you do that in Python is by prefixing it with an underscore:</p>
<pre><code>class stuff(object):
    _x = 100
    def f(self):
        self._x = self._x * 2
        return self._x

    def g(self):
        self._x = self._x * 4
        return self._x
</code></pre>
<p>This tells other Python programmers that it is internal, and not to access it, except on their own risk. You seem to want to prevent even this, but you can't. You can even access the closure in the Python 3 nonlocal example as well:</p>
<pre><code>def stuff():
    x = 100
    def f():
        nonlocal x
        x = x * 2
        return x

    return f

&gt;&gt;&gt; a = stuff()
&gt;&gt;&gt; a()
200
&gt;&gt;&gt; a()
400
&gt;&gt;&gt; a.__closure__[0].cell_contents
400
</code></pre>
<p>So you aren't preventing anyone from fiddling with it, you just make the fiddling it obscure and brittle. and more likely to fail. As such you just end up making things more difficult for everyone involved.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a function without global:</p>
<pre><code>&gt;&gt;&gt; def f():
...     f.x = 100
...     def g():
...             f.x = f.x * 2
...             return f.x
...     def h():
...             f.x = f.x * 4
...             return f.x
...     return (g, h)
...
&gt;&gt;&gt; a, b = f()
&gt;&gt;&gt; a()
200
&gt;&gt;&gt; b()
800
&gt;&gt;&gt; a()
1600
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">In Python 2, you can get around the lack of <code>nonlocal</code> by using a mutable container to hold the <code>x</code> value. It's a bit ugly though.</span>
<span class="comment-copy">I never got back to this, but you are correct. Using some like <code>state = {x: 100}</code> allows the code to be private to <code>stuff()</code>.</span>
<span class="comment-copy">I'd say that being able to "only have one" is the biggest downside to the questioner's current code with <code>global</code>. Other than hiding the class, though, I think this is a great answer.</span>
<span class="comment-copy">@Blckknght: Well, sometimes you want to have only one, when it is some sort of "pseudo-global" thing. I assume that's the case here since he tries to use a function closure.</span>
<span class="comment-copy">Can't you call stuff.x tho and get the value of x? I'm trying to privatize x inside of a function, hence the def instead of use of a class...</span>
<span class="comment-copy">@jadengore Yes, you can access it. This is not a problem. If you don't want to access it outside of the class, then just don't. You can it as internal by prefixing it with underscore: <code>_x = 100</code>, then other programmers will also know it's internal.</span>
<span class="comment-copy">@LennartRegebro The whole point of using the def stuff() from the start is to prevent x from being accessed out of the scope of stuff(). It's not about telling other programmers its internal, I don't want anything outside the function to be able to access x unless it is being return. Want it to be private without using a module.</span>
<span class="comment-copy">So, does this make f.x private and exclusive to things only in the scope of f?</span>
<span class="comment-copy">@jadengore No, f.x is still accessible.</span>
