<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/3/reference/datamodel.html#invoking-descriptors" rel="nofollow">python 3.3 documentation</a> tells me that direct access to a property descriptor should be possible, although I'm skeptical of its syntax <code>x.__get__(a)</code>. But the example that I constructed below fails. Am I missing something?</p>
<pre><code>class MyDescriptor(object):
    """Descriptor"""
    def __get__(self, instance, owner):
        print "hello"
        return 42

class Owner(object):
    x = MyDescriptor()
    def do_direct_access(self):
        self.x.__get__(self)

if __name__ == '__main__':
    my_instance = Owner()
    print my_instance.x
    my_instance.do_direct_access()
</code></pre>
<p>Here's the error I get in Python 2.7 (and also Python 3.2 after porting the snippet of code). The error message makes sense to me, but that doesn't seem to be how the documentation said it would work.</p>
<pre><code>Traceback (most recent call last):
  File "descriptor_test.py", line 15, in &lt;module&gt;
    my_instance.do_direct_access()
  File "descriptor_test.py", line 10, in do_direct_access
    self.x.__get__(self)
AttributeError: 'int' object has no attribute '__get__'

shell returned 1 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By accessing the descriptor on <em><code>self</code></em> you invoked <code>__get__</code> already. The value <code>42</code> is being returned.</p>
<p>For any attribute access, Python will look to the type of the object (so <code>type(self)</code> here) to see if there is a descriptor object there (an object with a <code>.__get__()</code> method, for example), and will then <em>invoke</em> that descriptor.</p>
<p>That's how methods work; a function object is found, which has a <code>.__get__()</code> method, which is invoked and returns a method object bound to self.</p>
<p>If you wanted to access the descriptor directly, you'd have to bypass this mechanism; access <code>x</code> in the <code>__dict__</code> dictionary of <code>Owner</code>:</p>
<pre><code>&gt;&gt;&gt; Owner.__dict__['x']
&lt;__main__.MyDescriptor object at 0x100e48e10&gt;
&gt;&gt;&gt; Owner.__dict__['x'].__get__(None, Owner)
hello
42
</code></pre>
<p>This behaviour is documented right above where you saw the <code>x.__get__(a)</code> direct call:</p>
<blockquote>
<p>The default behavior for attribute access is to get, set, or delete the attribute from an objectâ€™s dictionary. For instance, <code>a.x</code> has a lookup chain starting with <code>a.__dict__['x']</code>, then <code>type(a).__dict__['x']</code>, and continuing through the base classes of <code>type(a)</code> excluding metaclasses.</p>
</blockquote>
<p>The <em>Direct Call</em> scenario in the documentation only applies when you have a direct reference to the descriptor object (not invoked); the <code>Owner.__dict__['x']</code> expression is such a reference.</p>
<p>Your code on the other hand, is an example of the <em>Instance Binding</em> scenario:</p>
<blockquote>
<p>Instance Binding<br/>
  If binding to an object instance, <code>a.x</code> is transformed into the call: <code>type(a).__dict__['x'].__get__(a, type(a))</code>.</p>
</blockquote>
</div>
<span class="comment-copy">Right, I get that. But the documentation has the precise code that I used. Is the documentation wrong then?</span>
<span class="comment-copy">@gkb0986: Nowhere in the documentation does it say that <code>x</code> is an instance.</span>
<span class="comment-copy">I think it does. """Direct Call The simplest and least common call is when user code directly invokes a descriptor method: x.__get__(a).""" I may not have parsed this correctly though.</span>
<span class="comment-copy">@gkb0986 The documentation is not wrong. In that snippet <code>x</code> is a name for the descriptor object. <code>self.x</code> does not evaluate to the descriptor object, it's attribute access and hence handled the way illustrated by this post and by the second snippet in the documentation.</span>
<span class="comment-copy">@gkb0986: expanded on that; you can only make a direct call if you actually have a reference to the descriptor <i>itself</i>; from <code>self</code> python invokes the <i>Instance Binding</i> scenario instead, you do not get access to the descriptor because Python has already invoked it for you.</span>
