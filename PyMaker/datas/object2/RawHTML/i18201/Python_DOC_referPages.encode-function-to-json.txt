<div class="post-text" itemprop="text">
<p>I have an array with an element from the <code>operator</code> module.  I tried storing this with JSON but but got the following error msg. </p>
<pre><code>import operator as op
import json
array = [1,op.ge]
json_encoded = json.dumps(array)
f = open("test.json","w")
f.write(json_encoded)
f.close()
</code></pre>
<p><code>TypeError: &lt;built-in function ge&gt; is not JSON serializable</code></p>
<p>is there a workaround or another way to store this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <a href="http://docs.python.org/3/library/pickle.html#pickle.dumps" rel="noreferrer">pickle</a> module, which can serialize objects, too:</p>
<pre><code>import pickle
...
pickle_encoded = pickle.dumps(array)
...
</code></pre>
<p>Pickle will write a byte-stream, which won't be human-readable in contrast to JSON.</p>
</div>
<span class="comment-copy">You want to store a <i>function</i> as JSON? Why?</span>
<span class="comment-copy">Hi Lutz, I'm randomly generating functions and selecting best performing one, thus need a way to store it ;)</span>
<span class="comment-copy">How do you generate them? Do you write them into Python files?</span>
<span class="comment-copy">@LutzHorn - I randomly select operators, numbers, etc and build them up into dictionaries or array.  Best performers are selected for and mutate. In PERL I would use eval but just learning Python and each variable is put into place as conditions. Not sure if this makes sense but seems to be working.</span>
<span class="comment-copy">Doh! <i>Just</i> beat me to it :)</span>
<span class="comment-copy">Miku, works perfectly - thank you much</span>
<span class="comment-copy">unfortunately, i am not sure this works all the time... if you try it, it is just storing the name of the function in the pickle file. so it would work for an internal, but if it's your own function, loading it back up into a new session will point to a function, but the function may not be imported yet. if he's trying to abuse this for stored procedures, it probably won't work...</span>
<span class="comment-copy">@CorleyBrigman - thanks for the tip; I build the function during runtime with information from stored data, so I think this should work.</span>
<span class="comment-copy">if that's true, then maybe you can store names instead - store a string with the name, and create a dictionary of strings to function objects when you create them. your code would have to change slightly to call f_dict[f_name] instead of f_name() directly, but it's minor...</span>
