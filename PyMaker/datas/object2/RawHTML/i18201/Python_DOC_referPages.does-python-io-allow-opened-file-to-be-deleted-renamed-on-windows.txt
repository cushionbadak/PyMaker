<div class="post-text" itemprop="text">
<p>I would like to read/write to a file but allow for it to be deleted/renamed by other processes. In <code>C#</code> you can open the file with a <a href="http://msdn.microsoft.com/en-us/library/system.io.fileshare.aspx" rel="nofollow"><code>FileShare.Delete</code></a>, does Python have an equivalent?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want a cross-platform equivalent… there really isn't one. On POSIX systems, other processes can always delete/rename files you have open* unless you go out of your way to prevent it. So, you only need to do this for Windows, and you have it pretty much everywhere</p>
<p>Python's standard file objects don't allow you to control Windows sharing flags directly. (This is because they use cross-platform APIs like stdio's <a href="http://msdn.microsoft.com/en-us/library/yeby3zcb%28v=vs.90%29.aspx" rel="nofollow"><code>fopen</code></a> rather than the Windows-specific APIs.)</p>
<p>If you want to do this, you have to call different file functions.</p>
<p>In IronPython, you can of course call the exact same .NET functions you'd call in C#.</p>
<p>In CPython, you can't use .NET, because CPython is a native Win32 app. That means you have to call <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858%28v=vs.85%29.aspx" rel="nofollow"><code>CreateFile</code></a>. You can use the <a href="http://starship.python.net/crew/mhammond/win32/Downloads.html" rel="nofollow">pywin32</a> package to make this easier, but it's still a bit of a pain. </p>
<p>Instead of just <code>f = open(path, 'r+')</code>, you need something like this (untested):</p>
<pre><code>f = win32file.CreateFile(path, 
                         win32con.GENERIC_READ | win32con.GENERIC_WRITE,
                         win32con.FILE_SHARE_DELETE,
                         None, 
                         0, 
                         win32con.OPEN_ALWAYS,
                         None)
</code></pre>
<p>And then, instead of <code>buf = f.read(4096)</code>, you do:</p>
<pre><code>buflen, buf = win32file.ReadFile(f, 4096, None)
</code></pre>
<p>And, instead of just sticking it in a <code>with</code> statement, you have to explicitly close it, with:</p>
<pre><code>win32file.CloseFile(f)
</code></pre>
<p>If you plan on doing a lot of this, wrapping up a <code>win32file</code> handle in a file-like object isn't that hard, and is probably worth doing.</p>
<p>The trickiest bit is deciding how close you want to stick to the arguments for <code>open</code>, and writing the code to convert the values you get into the ones <code>CreateFile</code> wants. (There are also a few edge cases that Win32 native files handles differently than Win32 stdio files, but usually these won't bit you.)</p>
<p>You may also want to look at the <a href="http://docs.python.org/3/library/io.html" rel="nofollow"><code>io</code></a> module for helpers that let you just implement a handful of raw open/read/write/close functions and wrap it up in a complete file-like object automatically.</p>
<hr/>
<p>* Actually, all they can do is <em>unlink</em> the <em>directory entry</em> that you opened. Even if that was the only directory entry linking to that file, the file itself still exists until the last open handle to it is closed.</p>
</div>
<span class="comment-copy"><i>This is because they use cross-platform APIs like stdio's fopen rather than the Windows-specific APIs</i> There's a chance it will be fixed - see <a href="http://bugs.python.org/issue12939" rel="nofollow noreferrer">Add new io.FileIO using the native Windows API</a>. By the way it's interesting how using cross-platform APIs prevents being cross-platform in this case ;)</span>
<span class="comment-copy">@PiotrDobrogost: Well, it allows being exactly as cross-platform as <i>Microsoft</i> cares about; if you want to go beyond that on your own, it gets in the way… BTW, in 3.x, Python uses POSIX/MSVCRT APIs like <code>open</code> rather than stdio APIs. That theoretically should make it easier to change to using Win32 APIs, but it would be a pretty big change; unless you can replace fd's with HANDLEs everywhere, and write new code for everything that MSVCRT emulates on top of fd's, it can't be a drop-in replacement, just a separate file-like type. But I'm a bit surprised no one's PyPI'd that separate type…</span>
