<div class="post-text" itemprop="text">
<p>I am trying to create a high scores list for a little trivia game for class. I'm having an issue though because I can't seem to get the printed output to not just print the dictionary randomly.  This snippet is not actually from the full program because I didn't want to ruin anything so it's just an attempt at reasoning out the function.</p>
<pre><code>scores = {'score1': {'initials': 'ywo',
                     'score': 20},
          'score2': {'initials': 'JRV',
                     'score': 18},
          'score3': {'initials': 'blh',
                     'score': 16},
          'score4': {'initials': 'yth',
                     'score': 15},
          'score5': {'initials': 'rtg',
                     'score': 12}}

total_score = 17


#iterates over the scores to see if new score and initials should be input
for i in (scores):
        if total_score &gt; scores[i]['score']:
        scores[i]['initials'] = 'JKE'
        scores[i]['score'] = total_score
        break

#prints scores in a table like format rather than list
print("HIGH\tSCORES")
for i in scores:
    print(scores[i]['initials'], "\t", scores[i]['score'])
</code></pre>
<p>My output is random every time though.  I just want the dictionary to print in order of highest to lowest eg:</p>
<pre><code>ywo    20 
JRV    18 
JKE    17
</code></pre>
<p>etc etc  </p>
<p>The other issue I am having is that I'm not sure how to approach moving the other scores lower in the dictionary.  So if JKE's score replaces the score at blh, blh isn't just removed from the dictionary but it moves down to score4 index and score4 values would move to score5 etc etc.  I appreciate any advice!  Thank you!  </p>
</div>
<div class="post-text" itemprop="text">
<p>I think you might be trying to make this a bit too complicated (though it sounds like homework so that might be a requirement).</p>
<p>I would approach it like so:</p>
<pre><code>scores = {'YWO': 20,
          'BLH': 16,
          'YTH': 15,
          'JRV': 18,
          'RTG': 12,
         }


def display_scores(scores):
    for score, name in sorted(((scores[k], k) for k in scores, reverse=True):
        print(name, score)
</code></pre>
<p>Then you can easily add players and scores via:</p>
<pre><code>scores[initials] = scores.get(initials, 0) + 1 #or points or whatever
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries don't maintain any particular order, if you use OrderedDict however it will. </p>
<pre><code>from collections import OrderedDict
d = OrderedDict([('first', 1),('second', 2),('third', 3)])
print d.items()
</code></pre>
<p>Output: </p>
<pre><code>[('first', 1), ('second', 2), ('third', 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary is a non sorted type so it is reasonable that every time to expect that the order would be change every time. </p>
<p>I think that you should consider different data type to deal with this problem (this also answers the second part of you question).</p>
<p>I think you should consider either ordered dictionary - <a href="http://docs.python.org/2/library/collections.html" rel="nofollow">http://docs.python.org/2/library/collections.html</a></p>
<p>or something I think is better for this purpose - 
<a href="http://docs.python.org/2/library/heapq.html" rel="nofollow">http://docs.python.org/2/library/heapq.html</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>I would use the list of dictionaries, you could then easily sort the scores, and for example show only best 3.
The format for the list could be:
[{score:player},...]</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to keep your scores ordered somehow. The best way is to keep an ordered list. You can use the <code>bisect</code> module to help you do this. <code>bisect.bisect(list, item)</code> returns the index where you should insert <code>item</code> into the list such that the list is still sorted. If we keep the scores as a list of <code>(score, name)</code> tuples, then the default tuple comparison will work - smaller scores will be first, with larger scores last. We can delete all but the last five elements each time to only keep the top 5 scores.</p>
<pre><code>def add_score(scores, name, score):
    new_item = (score, name)
    scores.insert(bisect.bisect(scores, new_item), new_item)
    del scores[:-5] #keep only the top 5 scores
</code></pre>
<p>To print them we reverse the list:</p>
<pre><code>def print_scores(scores):
    for score, name in reversed(scores):
        print "%s\t%s" % (name, score)
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; scores = []
&gt;&gt;&gt; add_score(scores, "fool", 10)
&gt;&gt;&gt; scores
[(10, 'fool')]
&gt;&gt;&gt; add_score(scores, "jimbo", 100)
&gt;&gt;&gt; scores
[(10, 'fool'), (100, 'jimbo')]
&gt;&gt;&gt; add_score(scores, "bob", 20)
&gt;&gt;&gt; scores
[(10, 'fool'), (20, 'bob'), (100, 'jimbo')]
&gt;&gt;&gt; add_score(scores, "ha", 3)
&gt;&gt;&gt; scores
[(3, 'ha'), (10, 'fool'), (20, 'bob'), (100, 'jimbo')]
&gt;&gt;&gt; add_score(scores, "bob", 200)
&gt;&gt;&gt; add_score(scores, "bob", 140)
&gt;&gt;&gt; add_score(scores, "bob", 50)
&gt;&gt;&gt; scores
[(20, 'bob'), (50, 'bob'), (100, 'jimbo'), (140, 'bob'), (200, 'bob')]
&gt;&gt;&gt; print_scores(scores)
bob 200
bob 140
jimbo   100
bob 50
bob 20
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries are stored in arbitrary order. If you want to sort the output, you have to do that manually. Since you have keys <code>score1</code>, <code>score2</code>, etc. that happen to sort in the right order, you can just do it like this:</p>
<pre><code>for i in sorted(scores):
    print(scores[i]['initials'], "\t", scores[i]['score'])
</code></pre>
<hr/>
<p>However, your code doesn't actually seem to maintain that dictionary properly; when you find a user whose score beats <code>score2</code>, you're just going to replace <code>score2</code> with the new score, rather than pushing it down to <code>score3</code> and so on.</p>
<p>And I'm not sure why you want to store the scores this way in the first place. If you want to maintain an order, why not just use keys <code>0</code> through <code>4</code> in a <code>list</code> instead of <code>score1</code> through <code>score5</code> in a <code>dict</code>? For example:</p>
<pre><code>scores = [{'initials': 'ywo',
           'score': 20},
          {'initials': 'JRV',
           'score': 18},
          {'initials': 'blh',
           'score': 16},
          {'initials': 'yth',
           'score': 15},
          {'initials': 'rtg',
           'score': 12}]

for i, score in enumerate(scores):
    if total_score &gt; score['score']:
        scores[i:i+1] = {'initials': 'JKE', 'score': total_score}
        del scores[5:]
        break
</code></pre>
<p>Now, they're always in sorted order:</p>
<pre><code>for score in scores:
    print(score['initials'], "\t", score['score'])
</code></pre>
<hr/>
<p>You can make this more efficient by using a <a href="http://docs.python.org/3/library/heapq.html" rel="nofollow"><code>heapq</code></a>. However, this gets a bit complicated, because a <code>heapq</code> keeps it values sorted by comparing the values themselves, but you want it to compare on <code>value['score']</code>. Unlike most sort-related functionality in Python, <code>heapq</code> doesn't have a <code>key</code> function to make this easy. So, you have to do some manual "decorate-sort-undecorate" work:</p>
<pre><code>decorated_scores = [(score['score'], score) for score in scores]
heapify(decorated_scores)
</code></pre>
<p>Now, to add a new high score:</p>
<pre><code>new_score = (total_score, {'initials': 'JRV', 'score': total_score})
dropped_off = heappushpop(decorated_scores, new_score)
if dropped_off == new_score:
    # didn't make the high scores
else:
    # did
</code></pre>
<hr/>
<p>Another way to simplify this is to use an auto-sorting list, like the <a href="http://code.activestate.com/recipes/577197-sortedcollection/" rel="nofollow"><code>SortedCollection</code></a> recipe referenced in the <code>bisect</code> docs, or a library like <a href="https://pypi.python.org/pypi/blist/" rel="nofollow"><code>blist.sortedlist</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think there may be better data structures to start with than what you have, I only made one adjustment, make your keys to the dictionary integers, this will solve your printing problem, the function will build a new leader board that will max at 5 entries, and put the new score in where it belongs.  In the event of a tie, the second score of that is submitted will go to the lower of the spots entered. Score has to beat the min score to make the board.</p>
<pre><code>scores = {1: {'initials': 'ywo',
                 'score': 20},
      2: {'initials': 'JRV',
                 'score': 18},
      3: {'initials': 'blh',
                 'score': 16},
      4: {'initials': 'yth',
                 'score': 15},
      5: {'initials': 'rtg',
                 'score': 12}}
def new_leaderboard(new_score,new_initials):
   going_down_a_place = []
   place_found = False
   existing_scores = scores.copy()
   for i in scores:
       if new_score &gt; scores[i]['score'] and place_found == False:
           leaderboard_placement = i
           place_found = True
       if new_score &gt; scores[i]['score']:
           going_down_a_place.append(i)
   if len(going_down_a_place) &gt; 0:
       going_down_a_place.remove(max(going_down_a_place))

   for val in going_down_a_place:
       place = val + 1
       scores[place] = {'initials':existing_scores[val]['initials'],'score':existing_scores[val]['score']}
   if place_found == True:
       scores[leaderboard_placement] = {'initials':new_initials,'score':new_score}

   for i in scores:
       print(scores[i]['initials'], "\t", scores[i]['score'])
new_score = 21
new_initials = 'ddd'
new_leaderboard(new_score,new_initials)
</code></pre>
</div>
<span class="comment-copy">when you find yourself using keys like <code>score1</code>, <code>score2</code> ... maybe it makes more sense to use a <code>list</code> instead of a <code>dict</code>. (you also get the benefit of lists maintaining order.</span>
<span class="comment-copy">That doesn't help, given that he's going to be adding scores and/or replacing them as he goes along, and the order of those updates is not the order he wants.</span>
<span class="comment-copy">For a sorted list of five values, using <code>bisect</code> is overkill. You're not going to get much if any speed gain for the added complexity.</span>
<span class="comment-copy">@abarnert: Well, it's either <code>bisect</code>, or <code>.append</code> and then <code>sort</code>. Speed-wise should be pretty similar. Code-wise it's still about two lines of code. I guess the sort way is more robust, as well, and allows passing <code>key</code>s in, so you might have a point.</span>
<span class="comment-copy">Ok, I think I understand what is going on here, except for a few things.  When it sorts does it sort by the number order or the initials?  Is that what the key=lambda (name, score): part does?</span>
<span class="comment-copy">@JasonVignochi: yea in the older revision, <code>key=lambda (name, score); score</code> returns the score from each element in the list, so it sorts by the score instead. That way you can be more flexible for how to put the items in. In the 2nd revision with <code>bisect</code> I keep them as <code>(score, name)</code> pairs instead.</span>
<span class="comment-copy">So I tried the top part because it's not using anything I haven't learned in class yet but now I am getting an error that string indices must be integers and it points to the line       print(score['initials'], "\t", score['score'])  This is what I made the default list look like      scores=[{'initials': None,              'score': -500}] When I try to print it just from the default everything is ok but when I play through the game really fast then try to print the high scores list I get that error.</span>
<span class="comment-copy">@JasonVignochi: The top part doesn't have any code that references <code>score['initials']</code>, or any variable named <code>score</code> anywhere. It references <code>scores[i]['initials']</code>. I can't debug code that I can't see.</span>
