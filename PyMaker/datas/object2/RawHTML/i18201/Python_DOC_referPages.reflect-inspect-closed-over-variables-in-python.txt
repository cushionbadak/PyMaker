<div class="post-text" itemprop="text">
<p>If I have:</p>
<pre><code>def f(x):
  def g(y):
    return x + y
  return g

f2 = f(2)
</code></pre>
<p>Is there a way to find the 'x' binding that f2 will use? I looked at inspect but could not tell if some of the 'frame' stuff would apply. In other words, could I define a closedVars() below:</p>
<pre><code>def closedVars(anF):
    ... return ...

assert closedVars(f2) == {'x': 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to use the <code>inspect</code> module here.</p>
<pre><code>&gt;&gt;&gt; dict(zip(f2.func_code.co_freevars, (c.cell_contents for c in f2.func_closure)))
{'x': 2}
</code></pre>
<p>works in Python 2.7</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the cell contents by checking out <code>f.func_closure</code> (works in Python 2.7.5):</p>
<pre><code>&gt;&gt;&gt; def f(x):
...   def g(y):
...     return x + y
...   return g
... 
&gt;&gt;&gt; f2 = f(2)
&gt;&gt;&gt; [cell.cell_contents for cell in f2.func_closure]
[2]
</code></pre>
<p>Python 3.3 has an <a href="http://docs.python.org/3/library/inspect.html" rel="nofollow"><code>inspect.getclosurevars</code></a> function:</p>
<blockquote>
<p>Get the mapping of external name references in a Python function or method func to their current values. A named tuple <code>ClosureVars(nonlocals, globals, builtins, unbound)</code> is returned. nonlocals maps referenced names to lexical closure variables, globals to the functionâ€™s module globals and builtins to the builtins visible from the function body. unbound is the set of names referenced in the function that could not be resolved at all given the current module globals and builtins.</p>
</blockquote>
<p>I'm not yet sure if you can get the closed-over variable names pre-Python 3.3.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3 Update - Feb 2019</strong></p>
<p>Purposely, writing this out long-hand:</p>
<pre><code>def f(x):
    def g(y):
        return x + y
    return g

f2 = f(2)

def closedVars(anF):
    keys = f2.__code__.co_freevars
    values = [cell.cell_contents for cell in f2.__closure__]
    # keys and values definitely match in correct order in general case?
    return dict(zip(keys, values))

assert closedVars(f2) == {'x': 2}
</code></pre>
<p>What I am less clear on, and this applies to the answer marked correct above also, is whether the ordering between the tuple of (non-local closure) variable names (<code>__code__.co_freevars</code>) and the ordering of the variable values (<code>f2.__closure__</code>) are guaranteed to match (which the <code>zip</code> operation depends upon). In the simple example used to ask the question, we are only dealing with a single variable <code>x</code> so the above would suffice for that specific case. </p>
<p>Be good if anyone can confirm the general case rather than just assume it to be so? </p>
</div>
<span class="comment-copy">awesome, thanks!</span>
<span class="comment-copy">In Python 3, use <code>__code__.co_freevars</code>, <code>__closure__</code>, and <code>cell_contents</code></span>
<span class="comment-copy">@Leonardo.Z - please see my answer &amp; confirm the question I ask if you are knowledgeable here. OP (Des) also.</span>
<span class="comment-copy">great to know about the 3.3 option too, thanks!</span>
<span class="comment-copy">Hmm, this answer may suggest it is - <a href="https://stackoverflow.com/a/17145475/1882064">stackoverflow.com/a/17145475/1882064</a></span>
<span class="comment-copy">Yes, confirmed.</span>
