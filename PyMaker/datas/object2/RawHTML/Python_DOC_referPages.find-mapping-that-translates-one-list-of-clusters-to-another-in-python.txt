<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/38492314/reordering-cluster-numbers-for-correct-correspondence">reordering cluster numbers for correct correspondence</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I am using scikit-learn to cluster some data, and I want to compare the results of different clustering techniques.  I am immediately faced with the issue that the labels for the clusters are different for different runs, so even if they are clustered exactly the same the similarity of the lists is still very low.</p>
<p>Say I have </p>
<pre><code>list1 = [1, 1, 0, 5, 5, 1, 8, 1]
list2 = [3, 3, 1, 2, 2, 3, 8, 3]
</code></pre>
<p>I would (ideally) like a function that returns the best mapping in the form of a translation dictionary like this:</p>
<pre><code>findMapping(list1, list2)
&gt;&gt;&gt; {0:1, 1:3, 5:2, 8:8}
</code></pre>
<p>And I said "best mapping" because let's say <code>list3 = [3, 3, 1, 2, 2, 3, 8, 4]</code> then <code>findMapping(list1, list3)</code> would still return the same mapping even though the final <code>1</code> turns into a <code>4</code> instead of a <code>3</code>.  </p>
<p>So the best mapping is the one that minimizes the number of differences between the two lists. I think's a good criterion, but there may be a better one.  </p>
<p>I could write a trial-and-error optimization algorithm to do this, but I'm hardly the first person to want to compare the results of clustering algorithms.  I expect something like this already exists and I just don't know what it's called.  But I searched around and didn't find any answers.  </p>
<p>The point is that after applying the best translation I will measure the difference between the lists, so maybe there is a way to measure the difference between lists of numbers indexed differently without finding the translation as an intermediate step, and that's good too.</p>
<p>===================================</p>
<p>Based on Pallie's answer I was able to create the findMapping function, and then I took it one step further to create a translation function that returns the second list converted to the labels of the first list.  </p>
<pre><code>def translateLabels(masterList, listToConvert):    
  contMatrix = contingency_matrix(masterList, listToConvert)
  labelMatcher = munkres.Munkres()
  labelTranlater = labelMatcher.compute(contMatrix.max() - contMatrix)

  uniqueLabels1 = list(set(masterList))
  uniqueLabels2 = list(set(listToConvert))

  tranlatorDict = {}
  for thisPair in labelTranlater:
    tranlatorDict[uniqueLabels2[thisPair[1]]] = uniqueLabels1[thisPair[0]]

  return [tranlatorDict[label] for label in listToConvert]
</code></pre>
<p>Even with this conversion (which I needed for consistent plotting of cluster colors), using the Rand index and/or normalized mutual information does seem like a good way to compare the differences that don't require a shared labeling.  </p>
<p>I also like the idea of first <a href="https://stackoverflow.com/questions/44888415/how-to-set-k-means-clustering-labels-from-highest-to-lowest-with-python">sorting both lists according the values in the data</a>, but that may not work when comparing clusters from very different data.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try calculating the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.adjusted_rand_score.html" rel="nofollow noreferrer">adjusted Rand index</a> between two results. This gives a score between -1 and 1, where 1 is a perfect match.</p>
<p>Or by taking argmax of confusion matrix:</p>
<pre><code>list1 = ['a', 'a', 'b', 'c', 'c', 'a', 'd', 'a']
list2 = [3, 3, 1, 2, 2, 3, 8, 3]
np.argmax(contingency_matrix(list1, list2), axis=1)
array([2, 0, 1, 3])
</code></pre>
<p>2 means row 2 (the value 2, the cluster 3) best matches "a" column 0 (the index of 2). Row 0 then matches column 1, etc.</p>
<p><a href="https://i.stack.imgur.com/NolO2.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/NolO2.png"/></a></p>
<p>For the Hungarian method:</p>
<pre><code>m = Munkres()
contmat = contingency_matrix(list1, list2)
m.compute(contmat.max() - contmat)
[(0, 2), (1, 0), (2, 1), (3, 3)]
</code></pre>
<p>using: <a href="https://github.com/bmc/munkres" rel="nofollow noreferrer">https://github.com/bmc/munkres</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As answered many times before, the standard algorithm to compute such a mapping is the <strong>Hungarian algorithm</strong>.</p>
<p>It originally is meant to match producers and consumers, but it will work for aligning cluster numbers, too.</p>
</div>
<span class="comment-copy">I think the question justifies a certain degree of merit, even if it is purportedly considered by someone as a duplicate. I'm upvoting it.</span>
<span class="comment-copy">Yes, this is the kind of thing that I expected existed.  It does satisfy my need to measure the distance between lists without finding the translation.  If possible I'd still like to have the "translation map" so I can identify which items are different and produce a global color scheme for plots.</span>
<span class="comment-copy">For that information try the contingency matrix: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.cluster.contingency_matrix.html" rel="nofollow noreferrer">scikit-learn.org/stable/modules/generated/â€¦</a></span>
<span class="comment-copy">I believe you that the contingency matrix can provide the information necessary to convert one set of labels to another, but with just that documentation and no examples to be found, it's totally unclear how that can be done.</span>
<span class="comment-copy">Taking the np.argmax of the contingency matrix should result in a list where the indices are the key and the values are the values of the mapping.a good mapping.</span>
<span class="comment-copy">Well, for my sample data, <code>contingency_matrix</code> outputs <code>[[1 0 0 0] [0 0 4 0] [0 2 0 0] [0 0 0 1]]</code> and applying <code>argmax</code> yields <code>[0 2 1 3]</code>, but I don't see how to translate those two lists into the same indices from that output.  I mean, what should <code>5</code> translate to? What about 8? Sorry, I'm just not seeing how to get this to do the job.</span>
<span class="comment-copy">My <i>question</i> is mostly a duplicate of "reordering cluster numbers for correct correspondence"; albeit much more detailed.  However, that question doesn't have a specific answer, just a vague pointer to a method that can be adapted to solve the problem, but no information on how to do that.  This question still needs an actual answer (which may, and probably does, exist somewhere).</span>
