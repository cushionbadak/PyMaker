<div class="post-text" itemprop="text">
<p>I can invoke methods on numbers only when I bind them to a name:</p>
<pre><code>&gt;&gt;&gt; a = 5
&gt;&gt;&gt; a.bit_length()
3
</code></pre>
<p>I can invoke methods on string literals:</p>
<pre><code>&gt;&gt;&gt; 'Hello World'.lower()
'hello world'
</code></pre>
<p>But I cannot invoke methods on numeric literals:</p>
<pre><code>&gt;&gt;&gt; 5.bit_length()
</code></pre>
<p>This raises a <code>SyntaxError</code>. Is there a practical reason for that, or is it historic?</p>
<p><strong>Edit</strong> Just found this <a href="https://stackoverflow.com/questions/10955703/accessing-a-python-int-literals-methods">related question</a> that shows workarounds (that have already been suggested here as well). I guess this also answers the main question - with simple workarounds available, there probably wasn't enough benefit to making the grammar more complex (and harder to parse) to make this work.</p>
</div>
<div class="post-text" itemprop="text">
<p>The floating point numbers are parsed as per the following rules, <a href="https://docs.python.org/3/reference/lexical_analysis.html#floating-point-literals">quoting from the docs</a>,</p>
<pre><code>floatnumber   ::=  pointfloat | exponentfloat
pointfloat    ::=  [intpart] fraction | intpart "."
exponentfloat ::=  (intpart | pointfloat) exponent
intpart       ::=  digit+
fraction      ::=  "." digit+
exponent      ::=  ("e" | "E") ["+" | "-"] digit+
</code></pre>
<p>When Python sees <code>5.</code>, it thinks that the grammar follows <code>[intpart] fraction | intpart "."</code> rule. So, it picks up the next character and finds that it doesn't match the <code>fraction</code> rule. That is why the syntax error is thrown.</p>
<p>You can get around that by</p>
<pre><code>5 .bit_length()
</code></pre>
<p>Or enclosing that in brackets like this</p>
<pre><code>(5).bit_length()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually thefourtheye is slightly mistaken in that the reason for syntax error is not that the <code>fraction</code> rule is not matched.</p>
<p>The reason for the syntax error is that that this rule is used to parse it as a floating point:</p>
<pre><code>pointfloat    ::=  [intpart] fraction | intpart "."
</code></pre>
<p>The number matches the second form, that has integer part followed by a <code>.</code> - <code>5.</code> is a valid literal for floating point, and the token stream produced by <code>5.bit_length</code> produces 2 tokens: <code>5.</code> (that is, float <code>5.0</code>)  and <code>bit_length</code>; a floating point literal followed by a name is syntax error in python. </p>
<p>It is actually possible to call a float method however, with 2 dots:</p>
<pre><code>&gt;&gt;&gt; 5.0.hex()
'0x1.4000000000000p+2'
&gt;&gt;&gt; 5..hex()
'0x1.4000000000000p+2'
</code></pre>
<p>To call the <code>int</code> method, you need to separate the <code>5</code> from <code>.</code> to make them parsed as separate tokens.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/22875862/why-the-bracket-cant-be-omitted-in-int-to-bytes">why the bracket can't be omitted in int.to_bytes?</a></span>
