<div class="post-text" itemprop="text">
<p>Good evening!</p>
<p>I was running some tests on lists and list creation vs iterator creation and I came across some staggering time differences. Observe the following:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('map(lambda x: x**3, [1, 2, 3, 4, 5])')
0.4515998857965542
&gt;&gt;&gt; timeit.timeit('list(map(lambda x: x**3, [1, 2, 3, 4, 5]))')
2.868906182460819
</code></pre>
<p>The iterator version returned by the first test runs more than 6x as fast as converting to a list. I understand basically why this might be occurring, but what I'm more interested in is a solution. Does anyone know of a data structure similar to a list that offers fast creation time? (Basically, I want to know if there is a way to go straight from iterator (i.e. <code>map</code> or <code>filter</code> function, etc.), to a list without any major performance hits)</p>
<p>Things I can sacrifice for speed:</p>
<ol>
<li><p>Appending, inserting, popping and deleting elements.</p></li>
<li><p>Slicing of elements.</p></li>
<li><p>Reversing the list or any inplace operators like sort.</p></li>
<li><p>Contains (<code>in</code>) operator.</p></li>
<li><p>Concatenation and multiplication.</p></li>
</ol>
<p>All suggestions are welcome thanks!</p>
<p>EDIT: Indeed this is for python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>To further extend the answers of the other two guys:</p>
<p>You had a misconception about the iterator. But you refer to as "slow creation time", and then you look for a "faster container", because of your misinterpretation.</p>
<p>Note that the <em>creation</em> of a list object in python is fast:</p>
<pre><code>%timeit list(range(10000))
10000 loops, best of 3: 164 µs per loop
</code></pre>
<p>What you experience as slow is the actual loop that you need to do calculate the values that need to go into the list.</p>
<p>see a very unoptimized example of slowly "creating" a new list of another list:</p>
<pre><code>x = list(range(10000))

def slow_loop(x):
    new = []
    for i in x:
        new.append(i**2)
    return new
%timeit slow_loop(x)
100 loops, best of 3: 4.17 ms per loop
</code></pre>
<p>the time that is spent is actually on the loop, that is "slow" in python.</p>
<p>This is actually what you are doing here technically if you compare:</p>
<pre><code>def your_loop(x):
    return list(map(lambda y: y**2, x))

%timeit your_loop(x)
100 loops, best of 3: 4.5 ms per loop
</code></pre>
<p>There is a way to speed this up though:</p>
<pre><code>def faster_loop(x):
    return [i**2 for i in x]


%timeit faster_loop(x)
100 loops, best of 3: 3.67 ms per loop
</code></pre>
<p>although not by much given this kind of function. The thing is: the slow part here is the math, not the list and not the container. You can prove this by using numpy</p>
<pre><code>arr = np.array(x)

%timeit arr ** 2
100000 loops, best of 3: 7.44 µs per loop
</code></pre>
<p>Woah... crazy speedup.</p>
<p>With the benchmarking - I find myself guilty of this quite often as well - people doubt the system too often but themselves not often enough. So it's not like python is very unoptimized or "slow" it's just that you're doing it wrong. Don't doubt the python list efficiency. Doubt your slow, inefficient code. You will probably get it right quicker...</p>
<p>It seems here the pure python ** operator is very slow, as a simple multiplication
 is much quicker:</p>
<pre><code>def faster_loop2(x):
    return [i * i for i in x]

%timeit faster_loop2(x)
1000 loops, best of 3: 534 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x, <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code></a> doesn't create a list, but just an iterator, unlike Python 2.x.</p>
<pre><code>print(type(map(lambda x: x**3, [1, 2, 3, 4, 5])))
# &lt;class 'map'&gt;
</code></pre>
<p>To really get a list, iterate it with the <code>list</code> function, like this</p>
<pre><code>print(type(list(map(lambda x: x**3, [1, 2, 3, 4, 5]))))
# &lt;class 'list'&gt;
</code></pre>
<p>So, you are really not comparing two similar things.</p>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on thefourtheye's answer; The expressions inside the map function will not be evaluated before you iterate over it. This example should be pretty clear:</p>
<pre><code>from time import sleep

def badass_heavy_function():
    sleep(3600)

# Method call isn't evaluated
foo = map(lambda x: x(), [badass_heavy_function, badass_heavy_function])

# Methods call will be evaluated, please wait 2 hours
bar = list(map(lambda x: x(), [badass_heavy_function, badass_heavy_function]))

for _ in foo:
    # Please wait one hour
    pass
</code></pre>
</div>
<span class="comment-copy">Python 3......?</span>
<span class="comment-copy">Indubitably, this is python 3.</span>
<span class="comment-copy">.. but if this is Python 3, your first example doesn't create a list in the first place.  So you're doing math in the second that you're not in the first.</span>
<span class="comment-copy">If you want performance, you could use numpy for this.</span>
