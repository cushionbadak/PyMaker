<div class="post-text" itemprop="text">
<p>I extract javascript code from PDF, but it is converted octal escape sequences.</p>
<p>I want to convert it to normal JavaScript code.</p>
<pre><code>\040\040\040\040\146\165\156\143\164\151\157\156\040\163\167\050\051\17....
</code></pre>
<p>Please advise me.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works for both Python 2.x and 3.x:</p>
<pre><code>&gt;&gt;&gt; b'\040\040\040\040\146\165\156\143\164\151\157\156\040\163\167'.decode('utf-8')
'    function sw'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/codecs.html#python-specific-encodings" rel="nofollow"><code>unicode_escape</code> encoding</a>:</p>
<p>In Python 2.x:</p>
<pre><code>&gt;&gt;&gt; r'\040\040\040\040\146\165\156\143\164\151\157\156'.decode('unicode-escape')
u'    function'
</code></pre>
<p>In Python 3.x:</p>
<pre><code>&gt;&gt;&gt; br'\040\040\040\040\146\165\156\143\164\151\157\156'.decode('unicode-escape')
'    function'
</code></pre>
</div>
<span class="comment-copy">If you use escaped sequence (non-raw-string), you don't need to use <code>decode</code>.</span>
<span class="comment-copy">Yeah but you end up with a byte array instead of a string.</span>
<span class="comment-copy">You're right. Without the <code>decode</code> call, you will get a <code>bytes</code> objects. (but only in Python 3.x)</span>
