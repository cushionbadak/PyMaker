<div class="post-text" itemprop="text">
<p>I have a df in pandas</p>
<pre><code>import pandas as pd
df = pd.DataFrame(['AA', 'BB', 'CC'], columns = ['value'])
</code></pre>
<p>I want to iterate over rows in df. For each row i want row<code>s value and next row</code>s value
Something like(it does not work):</p>
<pre><code>for i, row in df.iterrows():
     print row['value']
     i1, row1 = next(df.iterrows())
     print row1['value']
</code></pre>
<p>As a result I want </p>
<pre><code>'AA'
'BB'
'BB'
'CC'
'CC'
*Wrong index error here  
</code></pre>
<p>At this point i have mess way to solve this</p>
<pre><code>for i in range(0, df.shape[0])
   print df.irow(i)['value']
   print df.irow(i+1)['value']
</code></pre>
<p>Is there more efficient way to solve this issue? </p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, your "messy way" is ok, there's nothing wrong with using indices into the dataframe, and this will not be too slow. iterrows() itself isn't terribly fast.</p>
<p>A version of your first idea that would work would be:</p>
<pre><code>row_iterator = df.iterrows()
_, last = row_iterator.next()  # take first item from row_iterator
for i, row in row_iterator:
    print(row['value'])
    print(last['value'])
    last = row
</code></pre>
<p>The second method could do something similar, to save one index into the dataframe:</p>
<pre><code>last = df.irow(0)
for i in range(1, df.shape[0]):
    print(last)
    print(df.irow(i))
    last = df.irow(i)
</code></pre>
<p>When speed is critical you can always try both and time the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a <code>pairwise()</code> function example in the <code>itertools</code> document:</p>
<pre><code>from itertools import tee, izip
def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)

import pandas as pd
df = pd.DataFrame(['AA', 'BB', 'CC'], columns = ['value'])

for (i1, row1), (i2, row2) in pairwise(df.iterrows()):
    print i1, i2, row1["value"], row2["value"]
</code></pre>
<p>Here is the output:</p>
<pre><code>0 1 AA BB
1 2 BB CC
</code></pre>
<p>But, I think iter rows in a <code>DataFrame</code> is slow, if you can explain what's the problem you want to solve, maybe I can suggest some better method.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can be solved also by <code>izip</code>ping the dataframe (iterator) with an offset version of itself. </p>
<p>Of course the indexing error cannot be reproduced this way.</p>
<p>Check this out</p>
<pre><code>import pandas as pd
from itertools import izip

df = pd.DataFrame(['AA', 'BB', 'CC'], columns = ['value'])   

for id1, id2 in izip(df.iterrows(),df.ix[1:].iterrows()):
    print id1[1]['value']
    print id2[1]['value']
</code></pre>
<p>which gives</p>
<pre><code>AA
BB
BB
CC
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use shift() function as follows: </p>
<pre><code>df['value_1'] = df.value.shift(-1)
[print(x) for x in df.T.unstack().dropna(how = 'any').values];
</code></pre>
<p>which produces</p>
<pre><code>AA
BB
BB
CC
CC
</code></pre>
<p>This is how the code above works:</p>
<p>Step 1) Use shift function </p>
<pre><code>df['value_1'] = df.value.shift(-1)
print(df)
</code></pre>
<p>produces</p>
<pre><code>value value_1
0    AA      BB
1    BB      CC
2    CC     NaN
</code></pre>
<p>step 2) Transpose:</p>
<pre><code>df = df.T
print(df)
</code></pre>
<p>produces: </p>
<pre><code>          0   1    2
value    AA  BB   CC
value_1  BB  CC  NaN
</code></pre>
<p>Step 3) Unstack:</p>
<pre><code>df = df.unstack()
print(df)
</code></pre>
<p>produces:</p>
<pre><code>0  value       AA
   value_1     BB
1  value       BB
   value_1     CC
2  value       CC
   value_1    NaN
dtype: object
</code></pre>
<p>Step 4) Drop NaN values</p>
<pre><code>df = df.dropna(how = 'any')
print(df)
</code></pre>
<p>produces:</p>
<pre><code>0  value      AA
   value_1    BB
1  value      BB
   value_1    CC
2  value      CC
dtype: object
</code></pre>
<p>Step 5) Return a Numpy representation of the DataFrame, and print value by value:</p>
<pre><code>df = df.values
[print(x) for x in df];
</code></pre>
<p>produces: </p>
<pre><code>AA
BB
BB
CC
CC
</code></pre>
</div>
<span class="comment-copy">I believe the 2nd line of the first option should read: <code>_, last = row_iterator.next()</code></span>
<span class="comment-copy">For Python3 folks use either next(row_iterator) or row_iterator__next__()</span>
<span class="comment-copy">This is very good. I was working on a similar problem to the original question and this solved my issue perfectly. Thanks.</span>
<span class="comment-copy">In Python3 you no longer need to import <code>izip</code> -- the inbuilt <code>zip</code> provides the functionality <a href="https://stackoverflow.com/questions/32659552/izip-not-working-in-python-3-x">SO reference</a></span>
<span class="comment-copy">direct link to Python3 <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe</a></span>
