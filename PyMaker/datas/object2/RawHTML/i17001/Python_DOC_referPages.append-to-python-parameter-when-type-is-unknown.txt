<div class="post-text" itemprop="text">
<p>I have Python v2.7.</p>
<p>I want to create a function which will accept <code>None</code>, a <code>str</code> or a <code>list</code>. I need to append something to the parameter so I've created a helper function as follows:</p>
<pre><code>def _append_or_set(x, to_append):
    if x is None:
        return to_append
    if type(x) is str:
        return [x, to_append]
    if type(x) is list:
        x.append(to_append)
        return x
</code></pre>
<p>(Obviously this is not great programming, and there's no error handling etc. but it's just for illustration.)</p>
<p>But knowing Python, there is already a neat way of doing this. What is it?</p>
<h3>Background on why I'm doing this</h3>
<p>I'm doing this because I want to filter a dataset. The caller passes either None (i.e. return all the rows) or a string (just rows matching this value) or a list (rows matching <em>any</em> of these values)</p>
<p>Regardless of what the caller asks for, I always need to include rows containing <code>foo</code> at the very least. So I do:</p>
<pre><code>def _filter_data(filter_by):
    filter_by = _append_or_set(filter_by, 'foo')
    return do_my_filtering(filter_by)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Its possible that I still may not be understanding what you want, but I think this will work:</p>
<pre><code>&gt;&gt;&gt; def _append_or_set(x, to_append):
...     try:
...         x.append(to_append)
...     except AttributeError:
...         if x:
...             x = [x, to_append]
...         else:
...             x = to_append
...     finally:
...         return x
...
&gt;&gt;&gt; _append_or_set([5,3,4], 6)
[5, 3, 4, 6]
&gt;&gt;&gt; _append_or_set("this is x,", "this is appended")
['this is x,', 'this is appended']
&gt;&gt;&gt; _append_or_set(None, "hello")
'hello'
</code></pre>
<p>By using <code>try...except...finally</code> you can avoid explicit type checking which is generally considered bad practice.  </p>
<p>The first <code>try</code> assumes <code>x</code> is a list.  It isn't (if <code>x.append()</code> breaks), then it must be a string, or <code>None</code>. A simple <code>if</code> will determine which it is. </p>
</div>
<div class="post-text" itemprop="text">
<p>While your function would work fine (except that you should probably use <code>isinstance</code> and <code>elif</code>s), I do see a problem with it, and that is that it does not really have a consistent interface. Assuming that <code>to_append</code> is a string, there are three different situations:</p>
<ol>
<li><code>None</code> is passed, the function returns a string.</li>
<li>A string is passed, the function returns a 2-element list.</li>
<li>A list is passed, the function appends to the list and returns it. The original passed list <em>is also changed</em> (meaning a possible side effect to the parameter).</li>
</ol>
<p>Instead, you should try to keep the interface consistent. For example, always return a list and donâ€™t touch the parameter itself:</p>
<pre><code>def _append_or_set(x, to_append):
    if x is None:
        return [to_append]
    elif isinstance(x, (list, tuple, set)): # also accept tuples and sets
        return list(x) + [to_append]
    else:
        # assume that anything else is fine as the first element
        return [x, to_append]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 adds a <code>singledispatch</code> decorator to the <code>functools</code> module, which lets you use a bit more of a generic programming style:</p>
<pre><code>@singledispatch
def append_or_set(x, to_append):
    raise RuntimeError("Unregistered type")

# This one isn't strictly necessary; you could just have the default behavior
# in the original function be to return the value to append if no other types
# will be supplied.
@append_or_set.register(type(None))
def append_or_set(x, to_append):
    return to_append


@append_or_set.register(str)
def append_or_set(x, to_append):
    return [x, to_append]

@append_or_set.register(list)
def append_or_set(x, to_append):
    x.append(to_append)
    return x
</code></pre>
<p>You can find more information <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow">in the docs</a>, but the most relevant point is one not listed there: the implementation of <code>functools.singledispatch</code> is all Python, so even though you're using Python 2.7 you can backport the necessary code from Python 3.4's version of <code>functools.py</code> and use that. It shouldn't be too much trouble as the functions associated with <code>singledispatch</code> don't appear to use any functionality from Python 3 that is significantly different from that usable in 2.7 even without <code>__future__</code> imports (though I may well be wrong on that as I haven't tested it).</p>
<p>Also, as others have said, it may be a good idea to make the return values more consistent and, unless desired, avoid mutating arguments, e.g. <code>return to_append</code> would become <code>return [to_append]</code> and <code>x.append(to_append);return x</code> would become <code>return x + [to_append]</code>.</p>
</div>
<span class="comment-copy">Its a little unclear why you're approaching the problem this way.  Could you edit to give a little insight into why you've done what you've done?</span>
<span class="comment-copy">I would say your code is fine, I would just do <code>return [to_append]</code> when x is <code>None</code> to make the function always return a list for uniformity.</span>
<span class="comment-copy">This is my favourite answer so far, as I learned some good practice tips in the process!</span>
<span class="comment-copy">@LondonRob, Duck typing is one of the best features of Python! Is there anything I can improve on?</span>
<span class="comment-copy">Thanks @poke. Just amazed there's no sugary way to do this as it must be a relatively normal use case.</span>
<span class="comment-copy">@LondonRob Normally you'll use a protocol to have common functionality for a similar group of types and then wrap it in a try-except block for fallthrough behavior, though the efficiency can vary depending on how often certain types are passed to your function (lots of strings or <code>None</code>s will cause the exception-catching method to run a bit slower than if <code>list</code>s are more common, as the method avoids the pre-check but incurs a bit of penalty when it fails. That sort of "ask for forgiveness rather than permission" is generally considered a more Pythonic style, though).</span>
