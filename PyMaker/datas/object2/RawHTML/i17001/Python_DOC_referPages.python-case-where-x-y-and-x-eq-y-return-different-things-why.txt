<div class="post-text" itemprop="text">
<p>I'm taking my first computing science course, and we just learned about class implementation and inheritance.  In particular, we just covered method overriding and how classes we define inherit from the <code>object</code> superclass by default.  As one of my examples trying out this particular case of inheritance, I used the following code:</p>
<pre><code>class A:
    def __init__(self, i):
        self.i = i
    def __str__(self):
        return "A"
    # Commenting out these two lines to not override __eq__(), just use the 
    # default from our superclass, object
    #def __eq__(self, other):
        #return self.i == other.i

x = A(2)
y = A(2)

&gt;&gt;&gt;print(x == y)
False
&gt;&gt;&gt;print(x.__eq__(y))
NotImplemented
</code></pre>
<p>I expected the result from <code>(x == y)</code>, because as I understand it the default for <code>__eq__()</code> is to check if they're the same objects or not, not worrying about the contents.  Which is <code>False</code>, <code>x</code> and <code>y</code> have the same contents but are different objects.  The second one surprised me though.</p>
<p>So my questions: I thought <code>(x==y)</code> and <code>x.__eq__(y)</code> were synonymous and made exactly the same call.  Why do these produce differing output?  And why does the second conditional return <code>NotImplemented</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow"><code>NotImplemented</code> value</a> you're seeing returned from your inherited <code>__eq__</code> method is a special builtin value used as a sentinel in Python. It can be returned by <code>__magic__</code> methods that implement mathematical or comparison operators to indicate that the class does not support the operator that was attempted (with the provided arguments).</p>
<p>This can be more useful than raising an exception, as it allows Python to fall back to other options to resolve the operator use. For instance, if you do <code>x + y</code>, Python will first try to run <code>x.__add__(y)</code>. If that returns <code>NotImplemented</code>, it will next try the "reverse" version, <code>y.__radd__(x)</code>, which may work if <code>y</code> is a more sophisticated type than <code>x</code> is.</p>
<p>In the case you're asking about, <code>x == y</code>, Python first tries <code>x.__eq__(y)</code>, then <code>y.__eq__(x)</code>, and finally <code>x is y</code> (which will always evaluate to a Boolean value). Since <code>object.__eq__</code> returns <code>NotImplemented</code> in all cases, your class falls back to the identity comparison when you use the real operator, but shows you the <code>NotImplemented</code> sentinel when you call <code>__eq__</code> directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>==</code> operator is equivalent to the <code>eq</code> function, which will internally call the <code>__eq__</code> method of the left operand if it exists to try to determine equality. This is not the <em>only</em> thing it will do, and if <code>__eq__</code> does not exist, as is the case here, it will do other checks, such as checking whether the two are the same object, or <code>__cmp__</code> pre-Python 3.</p>
<p>So in a nutshell, your confusion arises from this assumption, which is incorrect:</p>
<blockquote>
<p>I thought (x==y) and x.__eq__(y) were synonymous and made exactly the same call</p>
</blockquote>
<p>In fact, <code>(x==y)</code> and <code>operators.eq(x, y)</code> are synonymous, and <code>x.__eq__(y)</code> is one of the things <code>eq(x, y)</code> will try to check.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have implemented the <code>__eq__()</code> function for a class, it gets called when you use <code>x == y</code>. Otherwise <code>x == y</code> relies on a default comparison logic. <code>__eq__()</code> does not get implemented automatically when you define a class.</p>
</div>
<span class="comment-copy">Actually (if you're using Python 3, or new-style classes in Python 2) there <i>is</i> a default <code>__eq__</code> that you get for free - the one you inherit from <code>object</code>. With old-style classes, if you don't define <code>__eq__</code>, you won't ever get <code>NotImplemented</code> from it as in the question - you'll get an AttributeError.</span>
