<div class="post-text" itemprop="text">
<p>Due to the wierdness of the particular module I am working with, I am wondering if there is a general way for one class to inherit the properties of another class that is locally created in a method. For example, something the following:</p>
<pre><code>def DefForm():
    class F(object):
        foo = bar

    return F

class MyClass(DefForm):
    pass

m = myClass()
m.foo
&gt;&gt;&gt; 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inherit your class from the <em>return value</em> of the function not the function itself:</p>
<pre><code>class MyClass(DefForm()):
     ...
</code></pre>
<hr/>
<p>Classes in Python are plain objects and when you're inheriting from one, you're also just inheriting from an object.  </p>
<p>For instance, this also works:</p>
<pre><code>class Foo(Bar if x == 3 else Baz):
    ...
</code></pre>
<p>In fact, I can't think of a situation where this wouldn't work. Even this is perfectly valid:</p>
<pre><code>try:
    ...
except (FooExc if x == 3 else BarExc):
    ...
</code></pre>
<p>So not only are classes objects in Python, they are also treated as objects in all situations. </p>
<p>On a more general note, generating classes is called metaprogramming; it's a common practice in many languages (both dynamic as well as compiled and statically typed) and there's generally nothing "weird" about code that does this, as long as sanity and readability are maintained. It's as normal as creating and returning functions from other functions (which is extremely prevalent in Functional Programming), or in fact returning any object. </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>def DefForm():
    class F(object):
        foo = bar

    return F

FClass = DeftForm()

class MyClass(FClass):
    pass

m = myClass()
m.foo
</code></pre>
</div>
<span class="comment-copy">The grammar allows a wide range of expressions in place of one or more specific class names. Python 2 allows either a <code>test</code> expression (essentially, values <code>or</code>'d together or an <code>if...else</code> expression) or a lambda definition (I'm not actually sure how that is interpreted). Python 3 essentially treats the list of base classes as an argument list to a function, so the syntax is identical. For example, <code>x=(A, B); class C(*x): pass</code> is legal as long as the elements of <code>x</code> are valid classes.</span>
<span class="comment-copy">Python 2 allows any expression AFAIK; wasn't aware of the splatting trick in Python 3; thanks for adding that.</span>
<span class="comment-copy">Here are links to the <a href="https://docs.python.org/2/reference/grammar.html" rel="nofollow noreferrer">Python 2</a> and <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Python 3</a> grammars for those interested. See the <code>classdef</code> rule in each.</span>
