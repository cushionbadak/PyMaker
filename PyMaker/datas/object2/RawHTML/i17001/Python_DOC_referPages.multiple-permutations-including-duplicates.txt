<div class="post-text" itemprop="text">
<p>I have a list of 6 elements <code>L = ['a', 'b', 'c', 'd', 'e', 'f']</code> and would like to generate all possible 4 letter combinations - <strong>including duplicate values</strong>.</p>
<p>i.e <code>['a', 'b', 'c', 'd']</code> as well as <code>['a', 'a', 'a', 'a']</code> and <code>['a', 'a', 'b', 'b']</code>, etc.</p>
<p>So far I have been using <code>import itertools: p = list(itertools.permutations(L, 4))</code>. (Python 2.7.6)</p>
<p>However, this is only giving me the 360 unique combinations, rather than the 1296 that I want.</p>
<p>Thanks!!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a cartesian product of 4 copies of the list. You want <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a>:</p>
<pre><code>import itertools
itertools.product(L, repeat=4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can solve this in at least 3 ways.</p>
<ol>
<li>Using nested loop</li>
<li>Using <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehensions</a> </li>
<li>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product()</a></li>
</ol>
<p>Let's see how to use these and deep into the time performance of these:</p>
<pre><code>from time import time

# Solution 1
time_start = time()
L = ['a', 'b', 'c', 'd', 'e', 'f']
ar = []
for a in L:
    for b in L:
        for c in L:
            for d in L:
                ar.append([a,b,c,d])
print(len(ar))
time_end = time()
print('Nested Iterations took %f seconds' %(time_end-time_start))


# Solution 2
time_start = time()
L = ['a', 'b', 'c', 'd', 'e', 'f']
ar = [[a,b,c,d] for a in L for b in L for c in L for d in L]
print(len(ar))
time_end = time()
print('List Comprehension took %f seconds' %(time_end-time_start))


# Solution 3
import itertools
time_start = time()
L = ['a', 'b', 'c', 'd', 'e', 'f']
ar = list(itertools.product(L, repeat = 4))
print(len(ar))
time_end = time()
print('itertools.product took %f seconds' %(time_end-time_start))
</code></pre>
<p>Output:</p>
<pre><code>1296
Nested Iterations took 0.001148 seconds
1296
List Comprehension took 0.000299 seconds
1296
itertools.product took 0.000227 seconds
</code></pre>
<p>So, comparing the ways we see that <code>itertools.product()</code> is simpler and effective than the others.</p>
<p><em>N.B.: The code is run in <a href="https://codepad.remoteinterview.io/" rel="nofollow noreferrer">https://codepad.remoteinterview.io/</a>. Performance may vary.</em></p>
</div>
<span class="comment-copy">Mathematically speaking, your looking for <i>permutations</i>, not <i>combinations</i>. The combinations of items in a set are unordered sets of distinct elements (no duplicates).</span>
