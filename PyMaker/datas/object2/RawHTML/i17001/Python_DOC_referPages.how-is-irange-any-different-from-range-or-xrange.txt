<div class="post-text" itemprop="text">
<p>I was going through Python Generators Wiki when I came across this <a href="https://wiki.python.org/moin/RangeGenerator" rel="noreferrer">RangeGenerator</a> page which talks about <code>irange()</code>  -</p>
<blockquote>
<p>This will let us iterator over large spans of numbers without
  resorting to xrange, which is a lazy list as opposed to a generator.</p>
</blockquote>
<p>I can't seem to understand the test suite and the implementation described on that page. I know that <code>range()</code> creates a list in the memory (from Python 2.7 point of view) and <code>xrange()</code> is a generator. How is <code>irange()</code> any different?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>irange()</code> returns a generator type, which <em>can only be iterated over</em>. Nothing else. Once you iterated over it, the generator is exhausted and can not be iterated over again.</p>
<p>The Python 2 <a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange" rel="noreferrer"><code>xrange()</code> type</a> and Python 3 <a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="noreferrer"><code>range()</code> type</a> are <em>sequence types</em>, they support various operations that other sequences support as well, such as reporting on their length, test for containment, and indexing:</p>
<pre><code>&gt;&gt;&gt; xr = xrange(10, 20, 3)
&gt;&gt;&gt; len(xr)
4
&gt;&gt;&gt; 10 in xr
True
&gt;&gt;&gt; xr[0]
10
&gt;&gt;&gt; xr[1]
13
</code></pre>
<p>You can iterate over these objects more than once:</p>
<pre><code>&gt;&gt;&gt; for i in xr:
...     print i,
... 
10 13 16 19
&gt;&gt;&gt; for i in xr:
...     print i,
... 
10 13 16 19
</code></pre>
<p>You can even use the <a href="https://docs.python.org/2/library/functions.html#reversed" rel="noreferrer"><code>reversed()</code> function</a> to iterate over them <em>in reverse</em>, efficiently:</p>
<pre><code>&gt;&gt;&gt; for i in reversed(xr):
...     print i,
... 
19 16 13 10
</code></pre>
<p>The Python 3 <code>range()</code> type is an improved version of <code>xrange()</code>, in that it supports more sequence operations, is more efficient still, and can handle values beyond <code>sys.maxint</code> (what would be a <code>long</code> integer in Python 2).</p>
<p>It supports slicing, for example, which results in a <em>new</em> <code>range()</code> object for the sliced values:</p>
<pre><code>&gt;&gt;&gt; r = range(10, 20, 3)
&gt;&gt;&gt; r[:2]
range(10, 16, 3)
</code></pre>
<p>You can use negative indices just like you can with other Python sequences, to get elements counting from the end:</p>
<pre><code>&gt;&gt;&gt; r[-2]
16
&gt;&gt;&gt; r[-2:]
range(16, 22, 3)
</code></pre>
<p>and the type supports testing for equality; two <code>range()</code> instances are equal if they'd yield the same values:</p>
<pre><code>&gt;&gt;&gt; range(10, 20, 3) == range(10, 21, 3)
True
</code></pre>
<p>In Python 2, the only advantage the generator <code>irange()</code> might have is that it doesn't suffer from the limitation to non-long integers that <code>xrange()</code> is subjected to:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; xrange(sys.maxint)
xrange(9223372036854775807)
&gt;&gt;&gt; xrange(sys.maxint + 1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: Python int too large to convert to C long
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>irange provides an generator which does not loads entire result into memory. Say you have <code>range(1, 1000000)</code> in case a list of 1000000 numbers would be loaded into memory, whereas in case of <code>xrange(1, 1000000)</code>, just one number would be in memory at a time.</p>
</div>
<span class="comment-copy">Plus <code>xrange</code> has that C long limitation in CPython, <code>irange</code> won't suffer from that problem.</span>
<span class="comment-copy">You have a typo in your answer, you used <code>range()</code> twice. Python 2  also has <code>xrange()</code> which also doesn't produce a full list of integers up front. You don't actually answer the question, as to why the <code>irange()</code> implementation is different from Python 2's <code>xrange()</code> object.</span>
