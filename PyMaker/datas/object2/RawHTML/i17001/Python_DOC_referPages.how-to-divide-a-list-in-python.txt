<div class="post-text" itemprop="text">
<p>I have this list example
<code>list1=[['p1', 'p2', 'p3', 'p4'], ['p5', 'p6', 'p7']]</code> and if any variable is the same as other variable them split it in a group. Lets say p1 and p4 are the same and p5 and p6. So I want a new list that looks like
<code>list2=[['p1', 'p4'], ['p2', 'p3'], ['p5', 'p6'], 'p7']</code>. So how I need to divide them, pls help. I am using the newest version of python.</p>
<p>Ok to be more specific for "the same" in my program, I use p1 and p4 and if they give the same result for a certain character then I merge them in one group. Example</p>
<pre><code>if dictionary.get(p1, character) is dictionary.get(p4, character)
</code></pre>
<p>if you have more questions just ask me.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>unique_everseen</code></a> recipe and <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counters</code></a>:</p>
<pre><code>from collections import Counter

def solve(lst):
    counters = map(Counter, lst)
    return [ [uniq]*c[uniq] for seq, c in zip(lst, counters)
                                                for uniq in unique_everseen(seq)]
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; print(solve([[1, 2, 2, 1], [3, 4, 3]]))
[[1, 1], [2, 2], [3, 3], [4]]
&gt;&gt;&gt; print(solve([['hello', 'hello', 'hello', 'what'], ['i', 'am', 'i']]))
[['hello', 'hello', 'hello'], ['what'], ['i', 'i'], ['am']]
&gt;&gt;&gt; print(solve([[1,2,3,2,1],[9,8,7,8,9],[5,4,6,4,5]]))
[[1, 1], [2, 2], [3], [9, 9], [8, 8], [7], [5, 5], [4, 4], [6]]
</code></pre>
<p>As you can see this also preserves the order of the items.</p>
<hr/>
<p>Code for <code>unique_everseen</code> recipe:</p>
<pre><code>from itertools import filterfalse

def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following will give you that result:</p>
<pre><code>list1=[[1, 2, 2, 1], [3, 4, 3]]

print [[item]*lst.count(item) for lst in list1 for item in list(set(lst))]

[OUTPUT]
[[1, 1], [2, 2], [3, 3], [4]]
</code></pre>
<h3>Example 1</h3>
<pre><code>list1=[['hello', 'hello', 'hello', 'what'], ['i', 'am', 'i']]

print [[item]*lst.count(item) for lst in list1 for item in list(set(lst))]

[OUTPUT]
[['what'], ['hello', 'hello', 'hello'], ['i', 'i'], ['am']]
</code></pre>
<h3>Example 2</h3>
<pre><code>list1=[[1,2,3,2,1],[9,8,7,8,9],[5,4,6,4,5]]

print [[item]*lst.count(item) for lst in list1 for item in list(set(lst))]

[OUTPUT]
[[1, 1], [2, 2], [3], [8, 8], [9, 9], [7], [4, 4], [5, 5], [6]]
</code></pre>
</div>
<span class="comment-copy">Can you please provide example with actual numbers</span>
<span class="comment-copy">I need to use strings, but if you can give me an answer with numbers then ok, I will look it up.</span>
<span class="comment-copy">How do you understand "the same"?  Which Python operator would determine that: <code>==</code> or <code>is</code>?</span>
<span class="comment-copy">I would simply use a <code>for</code> loop.</span>
<span class="comment-copy">I'm curious about how useful lists of identical items are. Wouldn't you be better off with a dictionary with the words as keys and their respective frequencies as values?</span>
