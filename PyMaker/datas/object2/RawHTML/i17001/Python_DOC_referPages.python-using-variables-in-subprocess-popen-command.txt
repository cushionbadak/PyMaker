<div class="post-text" itemprop="text">
<p>I'm new to coding and need some assistance. I am writing a python script that will go through the contents of a directory and as its walks through the directory it will send each file to a Bluetooth device.</p>
<p>It works fine if I specify the filename but I canâ€™t get it to work by using the file name as a variable. Here is the code below</p>
<pre><code>import os
import time
import subprocess

indir = '\\\\10.12.12.218\\myshare'
for  root, dirs, filenames in os.walk(indir):
   for file in filenames:
      print (file)
      subprocess.Popen('ussp-push /dev/rfcomm0 image1.jpg file.jpg', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
print ('end') 
</code></pre>
<p>I am trying to replace 'image1.jpg' in the command with the variable 'file' like below but have not been successful.</p>
<pre><code>subprocess.Popen('ussp-push /dev/rfcomm0', file, 'file.jpg', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
</code></pre>
<p>Will really appreciate any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are several issues:</p>
<ul>
<li><p><code>shell=True</code> is unnecessary. Drop it and use a list argument:</p>
<pre><code>import shlex

args = shlex.split('ussp-push /dev/rfcomm0 image1.jpg file.jpg')
</code></pre></li>
<li><p>you are trying to pass command-line arguments as separate arguments for <code>Popen</code>. Use <code>Popen(['echo', 'a'])</code> instead of <code>Popen('echo', 'a')</code>. The later is wrong completely. See <a href="https://docs.python.org/3.4/library/subprocess.html#popen-constructor" rel="nofollow"><code>Popen()</code> function signature in the docs</a></p></li>
<li><p>do not use <code>stdout=PIPE</code> and/or <code>stderr=PIPE</code> unless you read from <code>p.stdout</code>/<code>p.stderr</code> pipes otherwise your child process may block forever if it fills any of the OS pipe buffers</p></li>
<li><p>save a reference to <code>Popen()</code> to wait for its status later. It is optional but it helps to avoid creating too many zombies</p></li>
</ul>
<p>You could extract the file generating part into a separate function:</p>
<pre><code>import os

def get_files(indir, extensions=('.jpg', '.png')):
    """Yield all files in `indir` with given `extensions` (case-insensitive)."""
    for root, dirs, files in os.walk(indir):
        for filename in files:
            if filename.casefold().endswith(extensions):
               yield os.path.join(root, filename)
</code></pre>
<p>Then to execute commands for each file in parallel:</p>
<pre><code>from subprocess import CalledProcessError, Popen

indir = r'\\10.12.12.218\myshare'
commands = [['ussp-push', '/dev/rfcomm0', path] for path in get_files(indir)]

# start all child processes
children = [Popen(cmd) for cmd in commands]

# wait for them to complete, raise an exception if any of subprocesses fail
for process, cmd in zip(children, commands):
    if process.wait() != 0:
       raise CalledProcessError(process.returncode, cmd)        
</code></pre>
<p>If you don't want to run the commands in parallel then just use <code>subprocess.call</code> instead of <code>subprocess.Popen</code>:</p>
<pre><code>import subprocess

indir = r'\\10.12.12.218\myshare'
statuses = [subprocess.call(['ussp-push', '/dev/rfcomm0', path])
            for path in get_files(indir)]
if any(statuses):
   print('some commands have failed')
</code></pre>
<p>It runs one command at a time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>subprocess.Popen(
    ['ussp-push', '/dev/rfcomm0', file, 'file.jpg'],
     stdout=subprocess.PIPE, 
     stderr=subprocess.PIPE)
</code></pre>
<p>You want to pass to <code>Popen()</code> a list of strings. An alternative would be to build a space-separate command such as:</p>
<pre><code>subprocess.Popen(
    'ussp-push /dev/rfcomm0 "{0}" file.jpg'.format(file) # replace {0} with file
     stdout=subprocess.PIPE, 
     stderr=subprocess.PIPE)
</code></pre>
<h1>Is shell=True Unsafe?</h1>
<p>I would like to make a couple of points regarding the use of <code>shell=True</code>.</p>
<ol>
<li>In this case, as <em>m.wasowski</em> points out in the comment, it is not necessary. </li>
<li><code>shell=True</code> is unsafe if you don't have any control on the command. For example, if you take the command from user's input, then the user can pass you something like <code>sudo rm -fr /</code>. </li>
<li>It is unsafe because once invoke the shell, the <code>PATH</code> might be different. When you issue a command such as <code>ls</code>, it might not come from the usual place (<code>/bin/ls</code>) but some malicious places such as <code>/home/evil/bin</code></li>
</ol>
<p>That being said, <code>shell=True</code> is safe if you have control over the command, in this case, <code>/dev/rfcomm0</code>--you define what the command is, instead of receiving it from elsewhere. Thank you <em>m.wasowski</em> for bringing up this point.</p>
<h1>Update</h1>
<p>Remove <code>shell=True</code>. See comments.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, there are a bunch of files and you want to run a command once with each file as an argument. I think the following should work well.</p>
<pre><code>import os
import time
import subprocess

indir = '\\\\10.12.12.218\\myshare'
for  root, dirs, filenames in os.walk(indir):
    for file in filenames:
        print 'Sending', os.path.join(root, file)
        subprocess.check_call(['ussp-push', '/dev/rfcomm0', os.path.join(root, file), 'file.jpg'])
print ('end')
</code></pre>
<p>Here's the changes I made:</p>
<ol>
<li>I'm using the <code>check_call</code> function instead of <code>Popen</code> as you wanted to run the commands sequentially and not in parallel. The <code>check_call</code> function takes the same arguments as <code>Popen</code>, but waits for the process to finish and raises an exception if the process fails.</li>
<li>I am passing an array (written in square brackets) as the first argument, the command to <code>check_call</code>. This also means there is no need for a <em>shell</em> to interpret a command string and so I removed the <code>shell=True</code>. The first item in this array is the command the rest are commands passed to it.</li>
<li>The last item in the array is the full path to the file. The <code>file</code> variable only holds the file's name. But we need its path as it might lie somewhere deep inside a folder (as you are <code>walk</code>ing recursively). The <code>os.path.join</code> joins two strings with a <code>\</code> or <code>/</code> as appropriate in the platform.</li>
<li>I also removed the <code>stdout</code> and <code>stderr</code> arguments. This means the output and errors from the command are going to turn up in the command line, which is probably what you want. The <code>stdout</code> and <code>stderr</code> arguments make sense when you want to read the output of the command and process it yourself instead of showing it in the terminal.</li>
</ol>
</div>
<span class="comment-copy">Have you seen <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer"><code>Popen()</code> function signature in the docs</a>?</span>
<span class="comment-copy">Thanks for the info - I need to try it out. Alot of the stuff you mention here is above my knowledge but I will try and read up on it an d see where I get. I did manage to do though is change the code by storing the command in a vairable and then passing it, it work howerver only for the fist iteration of the loop, the second time it runs it does send the file to the bluetooth device. Any ideas what could be wrong?</span>
<span class="comment-copy">Here is the code I changed                                              'indir = \\\\10.12.12.218\\testshare for  root, dirs, filenames in os.walk(indir):     for f in filenames:         command = "ussp-push /dev/rfcomm0 " + f + " file.jpg"         print (f)         subprocess.Popen('command', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) print ('end')</span>
<span class="comment-copy">@user3529962: use the code from my answer. If you don't understand what some line in it does; ask.</span>
<span class="comment-copy">I am currently trying the code out in your answer and having a few challenges, how would i do it if I kept everything together without separating the file generating part into a function. I also dont want send the files in parallel, want to send the first file then the next. Are you avialable in chat so we discuss ? Once again thanks for your help really appreciate it.</span>
<span class="comment-copy">@user3529962: I've updated the answer to show how to run one command at a time. You shouldn't unwrap <code>get_files()</code> unless you have a reason.</span>
<span class="comment-copy">there is not need for <code>shell=True</code> when you pass a list of command line arguments, especially since it is unsafe...</span>
<span class="comment-copy">-1 it is incorrect. Do not use a list argument and <code>shell=True</code> together. It is almost always an error: all list items are passed to the shell e.g., <code>/dev/rfcomm0</code> is passed as an argument to <code>/bin/sh</code> instead of <code>ussp-push</code> (assuming POSIX environment).</span>
<span class="comment-copy">It is still incorrect. The <b>string</b> argument such as <code>'ussp-push /dev/rfcomm0 file.jpg'</code> requires <code>shell=True</code> in POSIX. Notice that I said: <i>"Do not use a <b>list</b> argument and <code>shell=True</code> together"</i></span>
