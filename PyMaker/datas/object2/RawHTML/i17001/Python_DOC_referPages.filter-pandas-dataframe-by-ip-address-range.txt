<div class="post-text" itemprop="text">
<p>I need to filter a pandas <code>Dataframe</code> by the range of ip addresses. Is it possible with out regular expressions?</p>
<pre><code>Ex. From 61.245.160.0   To 61.245.175.255
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strings are orderable in python, so you should be able to get away with just that:</p>
<pre><code>In [11]: '61.245.160.0' &lt; '61.245.175.255'
Out[11]: True
</code></pre>
<p>Either boolean mask:</p>
<pre><code>In [12]: df[('61.245.160.0' &lt; df.ip) &amp; (df.ip &lt; '61.245.175.255')]
</code></pre>
<p>or take a slice (if ip were the index):</p>
<pre><code>In [13]: df.loc['61.245.160.0':'61.245.175.255']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have an approach using <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">ipaddress</a>.</p>
<p>For example, I want to know if <code>host0 = 10.2.23.5</code> belongs to any of the following networks <code>NETS  = ['10.2.48.0/25','10.2.23.0/25','10.2.154.0/24']</code>.</p>
<pre><code>&gt;&gt;&gt; host0 = ip.IPv4Address('10.2.23.5')
&gt;&gt;&gt; NETS = ['10.2.48.0/25','10.2.23.0/25','10.2.154.0/24']
&gt;&gt;&gt; nets  = [ip.IPv4Network(x) for x in NETS]
&gt;&gt;&gt; [x for x in nets if (host2 &gt;= x.network_address and host2 &lt;= x.broadcast_address)]
[IPv4Network('10.2.23.0/25')]
</code></pre>
<p>Now, in order to get together this approach with Pandas, one shall do the following: create a function and apply it to each row of the DF.</p>
<pre><code>def fnc(row):
    host = ip.IPv4Address(row)
    vec = [x for x in netsPy if (host &gt;= x.network_address and host &lt;= x.broadcast_address)]

    if len(vec) == 0:
        return '1'
    else:
        return '-1'
</code></pre>
<p>You later on apply it to the DF.</p>
<pre><code>df['newCol'] = df['IP'].apply(fnc)
</code></pre>
<p>This will create a new column <code>newCol</code> where each row will be either <code>1</code> or <code>-1</code> , depending on whether the IP address belongs to either network of your interest.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you have the following DF:</p>
<pre><code>In [48]: df
Out[48]:
               ip
0    61.245.160.1
1  61.245.160.100
2  61.245.160.200
3  61.245.160.254
</code></pre>
<p>let's find all IPs falling between (but not including) <code>61.245.160.99</code> and <code>61.245.160.254</code>:</p>
<pre><code>In [49]: ip_from = '61.245.160.99'

In [50]: ip_to = '61.245.160.254'
</code></pre>
<p>if we will compare IPs as strings - it will be compared lexicographically so it won't work properly as <a href="https://stackoverflow.com/questions/22979109/filter-pandas-dataframe-by-ip-address-range#comment65706530_22979217">@adele has pointed out</a>:</p>
<pre><code>In [51]: df.query("'61.245.160.99' &lt; ip &lt; '61.245.160.254'")
Out[51]:
Empty DataFrame
Columns: [ip]
Index: []

In [52]: df.query('@ip_from &lt; ip &lt; @ip_to')
Out[52]:
Empty DataFrame
Columns: [ip]
Index: []
</code></pre>
<p>We can use <a href="https://pythonhosted.org/netaddr/tutorial_01.html#numerical-representation" rel="nofollow noreferrer">numerical IP representation</a>:</p>
<pre><code>In [53]: df[df.ip.apply(lambda x: int(IPAddress(x)))
   ....:      .to_frame('ip')
   ....:      .eval('{} &lt; ip &lt; {}'.format(int(IPAddress(ip_from)),
   ....:                                  int(IPAddress(ip_to)))
   ....:       )
   ....: ]
Out[53]:
               ip
1  61.245.160.100
2  61.245.160.200
</code></pre>
<p>Explanation:</p>
<pre><code>In [66]: df.ip.apply(lambda x: int(IPAddress(x)))
Out[66]:
0    1039507457
1    1039507556
2    1039507656
3    1039507710
Name: ip, dtype: int64

In [67]: df.ip.apply(lambda x: int(IPAddress(x))).to_frame('ip')
Out[67]:
           ip
0  1039507457
1  1039507556
2  1039507656
3  1039507710

In [68]: (df.ip.apply(lambda x: int(IPAddress(x)))
   ....:    .to_frame('ip')
   ....:    .eval('{} &lt; ip &lt; {}'.format(int(IPAddress(ip_from)),
   ....:                               int(IPAddress(ip_to))))
   ....: )
Out[68]:
0    False
1     True
2     True
3    False
dtype: bool
</code></pre>
<p>PS here is a bit faster (vectorized) function which will return numerical IP representation:</p>
<pre><code>def ip_to_int(ip_ser):
    ips = ip_ser.str.split('.', expand=True).astype(np.int16).values
    mults = np.tile(np.array([24, 16, 8, 0]), len(ip_ser)).reshape(ips.shape)
    return np.sum(np.left_shift(ips, mults), axis=1)
</code></pre>
<p>Demo:</p>
<pre><code>In [78]: df['int_ip'] = ip_to_int(df.ip)

In [79]: df
Out[79]:
               ip      int_ip
0    61.245.160.1  1039507457
1  61.245.160.100  1039507556
2  61.245.160.200  1039507656
3  61.245.160.254  1039507710
</code></pre>
<p>check:</p>
<pre><code>In [80]: (df.ip.apply(lambda x: int(IPAddress(x))) == ip_to_int(df.ip)).all()
Out[80]: True
</code></pre>
</div>
<span class="comment-copy">@Andy Hayden : Ok, fine with regex, I have lot of ranges to be matched, that is why i asked without regex?</span>
<span class="comment-copy">Your solutions are always excellent..:) Thanks very much.</span>
<span class="comment-copy">I love python! The simplest possible solution is often actually available to the programmer!</span>
<span class="comment-copy">Careful with this approach as it does not sort correctly.   i.e. <code>'61.245.160.99' &lt; '61.245.160.102' Out[161]: False</code></span>
<span class="comment-copy">@adele good point, a quick ish way to get the right behaviour is to create a large number representative for an ip address e.g. <code>61 * 1000000000 + 245 * 1000000+ 160 * 1000 + 255</code> and sort based on that.</span>
<span class="comment-copy">I agree with @ade1e. Why not using <code>import ipaddress</code>? It works nice: <code>[x for x in nets if (host2 &gt;= x.network_address and host2 &lt;= x.broadcast_address)]</code> . The only thing is I really do not know how to use this approach with Pandas.</span>
