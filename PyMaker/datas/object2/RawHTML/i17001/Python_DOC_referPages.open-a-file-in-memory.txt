<div class="post-text" itemprop="text">
<p>(I'm working on a Python 3.4 project.)</p>
<p>There's a way to open a (sqlite3) database in memory :</p>
<pre><code>    with sqlite3.connect(":memory:") as database:
</code></pre>
<p>Does such a trick exist for the open() function ? Something like :</p>
<pre><code>   with open(":file_in_memory:") as myfile:
</code></pre>
<p>The idea is to speed up some test functions opening/reading/writing some short files on disk; is there a way to be sure that these operations occur in memory ?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is something similar for file-like input/output to or from a string in <a href="https://docs.python.org/3.4/library/io.html?highlight=stringio#io.StringIO">io.StringIO</a>.</p>
<p>There is no clean way to add url-based processing to normal file open, but being Python dynamic you could monkey-patch standard file open procedure to handle this case.</p>
<p>For example:</p>
<pre><code>from io import StringIO

old_open = open
in_memory_files = {}

def open(name, mode="r", *args, **kwargs):
     if name[:1] == ":" and name[-1:] == ":":
          # in-memory file
          if "w" in mode:
               in_memory_files[name] = ""
          f = StringIO(in_memory_files[name])
          oldclose = f.close
          def newclose():
              in_memory_files[name] = f.getvalue()
              oldclose()
          f.close = newclose
          return f
     else:
          return old_open(name, mode, *args, **kwargs)
</code></pre>
<p>after that you can write</p>
<pre><code>f = open(":test:", "w")
f.write("This is a test\n")
f.close()

f = open(":test:")
print(f.read())
</code></pre>
<p>Note that this example is very minimal and doesn't handle all real file modes (e.g. append mode, or raising the proper exception on opening in read mode an in-memory file that doesn't exist) but it may work for simple cases.</p>
<p>Note also that all in-memory files will remain in memory forever (unless you also patch <code>unlink</code>).</p>
<p>PS: I'm not saying that monkey-patching standard open or <code>StringIO</code> instances is a good idea, just that you can :-D</p>
<p>PS2: This kind of problem is solved better at OS level by creating an in-ram disk. With that you can even call external programs redirecting their output or input from those files and you also get all the full support including concurrent access, directory listings and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about <a href="https://docs.python.org/2/library/stringio.html" rel="noreferrer">StringIO</a>:</p>
<pre><code>import StringIO

output = StringIO.StringIO()
output.write('First line.\n')
print &gt;&gt;output, 'Second line.'

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
</code></pre>
<p>python3: <a href="https://docs.python.org/3/library/io.html" rel="noreferrer">io.StringIO</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.4/library/io.html?highlight=stringio#io.StringIO" rel="nofollow"><code>io.StringIO</code></a> provides a memory file implementation you can use to simulate a real file. Example from documentation:</p>
<pre><code>import io

output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
</code></pre>
<p>In Python 2, this class is available instead as <a href="https://docs.python.org/2/library/stringio.html" rel="nofollow"><code>StringIO.StringIO</code></a>.</p>
</div>
