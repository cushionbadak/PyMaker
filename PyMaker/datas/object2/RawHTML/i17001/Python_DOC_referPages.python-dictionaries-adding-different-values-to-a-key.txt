<div class="post-text" itemprop="text">
<p>I want to make a function that goes through a list and makes a dictionary with keys for each thing in the list and values of the one thing in the list following the key.</p>
<pre><code>def function(s : str) -&gt; {str:{str}}:
    listt=list(s)
    dictt= {}
    for i in listt[:-1]:
        if i not in dictt:
            dictt[i] = set()
        dictt[i].update(listt[listt.index(i)+1])
    return dictt



print(function('bookeeper'))
</code></pre>
<p>should return:</p>
<pre><code>{'b': {'o'}, 'k': {'e'}, 'p': {'e'}, 'o': {'o', 'k'}, 'e': {'e', 'p', 'r'}}
</code></pre>
<p>but actually returns:</p>
<pre><code>{'b': {'o'}, 'k': {'e'}, 'p': {'e'}, 'o': {'o'}, 'e': {'e'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>list.index()</code>; that'll only match the <strong>first</strong> occurrence of a letter; for <code>'o'</code> it'll never find the second <code>'o'</code>; you'll only repeatedly add the same characters to the sets.</p>
<p>Use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a> to add an index to your loop, instead:</p>
<pre><code>def function(s : str) -&gt; {str:{str}}:
    listt=list(s)
    dictt= {}
    for next_index, char in enumerate(listt[:-1], 1):
        if char not in dictt:
            dictt[char] = set()
        dictt[char].update(listt[next_index])
    return dictt
</code></pre>
<p>I started <code>enumerate()</code> at 1 instead of the default 0 so it always represents the <em>next</em> position.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def function(s : str) -&gt; {str:{str}}:
...     listt=list(s)
...     dictt= {}
...     for next_index, char in enumerate(listt[:-1], 1):
...         if char not in dictt:
...             dictt[char] = set()
...         dictt[char].update(listt[next_index])
...     return dictt
... 
&gt;&gt;&gt; print(function('bookeeper'))
{'p': {'e'}, 'o': {'o', 'k'}, 'e': {'p', 'r', 'e'}, 'b': {'o'}, 'k': {'e'}}
</code></pre>
<p>Now that it is working, lets simplify this a little; use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow"><code>dict.setdefault()</code></a> to add the set to the dictionary when the key is missing, for example. Strings are already sequences, no need to cast them to a list either:</p>
<pre><code>def function(s : str) -&gt; {str:{str}}:
    dictt = {}
    for next_index, char in enumerate(s[:-1], 1):
        dictt.setdefault(char, set()).update(s[next_index])
    return dictt
</code></pre>
<p>Instead of <code>enumerate()</code>, we could also use <code>zip()</code> to pair up the letters of the word:</p>
<pre><code>def function(s : str) -&gt; {str:{str}}:
    dictt = {}
    for char, next_char in zip(s, s[1:]):
        dictt.setdefault(char, set()).update(next_char)
    return dictt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that <code>index()</code> always returns the first index in the string, so you'll be adding the same character to the set over and over.</p>
<p>Try something like</p>
<pre><code>def function(s : str) -&gt; {str:{str}}:
    dictt = {}
    for pos, char in enumerate(s[:-1]):
        if char not in dictt:
            dictt[char] = set()
        dictt[char].update(s[pos+1])
    return dictt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the another answer:</p>
<pre><code>def func(string):
    arr = set(string)
    res = {}
    for char in arr:
        index = [i for i in range(len(string)) if string[i] == char]
        temp = []
        for i in index:
            if i == len(string) - 1:
                continue

            temp.append(string[i + 1])

        if temp:
            res[char] = temp

    return res

func('bookeeper')

&gt;&gt;&gt; {'b': ['o'], 'e': ['e', 'p', 'r'], 'k': ['e'], 'o': ['o', 'k'], 'p': ['e']}
</code></pre>
</div>
<span class="comment-copy">I remember seeing this question a few minutes ago: <a href="http://stackoverflow.com/questions/22956714/python-dictionaries-adding-values-to-a-key" title="python dictionaries adding values to a key">stackoverflow.com/questions/22956714/â€¦</a></span>
<span class="comment-copy">grate :) can u please help me ...</span>
<span class="comment-copy">which python version you use?</span>
<span class="comment-copy">@user1153551: Python 3, obviously. The function annotation gives it away.</span>
<span class="comment-copy">@sshashank124: see the <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow noreferrer">Python 3 function definition reference</a>, as well as <a href="http://www.python.org/dev/peps/pep-3107/" rel="nofollow noreferrer">PEP 3107</a></span>
<span class="comment-copy">oooooooooooooooooooooooooooohhhhhhhh</span>
<span class="comment-copy">This produces lists, not sets. It'll produce the wrong result for <code>toppop</code> for example (two times <code>p</code> after <code>o</code>).</span>
<span class="comment-copy">It is also extremely inefficient; your algorithm uses O(N^2) time; for each additional character in the word you double the time taken.</span>
