<div class="post-text" itemprop="text">
<p>Input data:</p>
<pre><code>results= [
        {
      "timestamp_datetime": "2014-03-31 18:10:00 UTC",
      "job_id": 5,
      "processor_utilization_percentage": 72
    },
        {
      "timestamp_datetime": "2014-03-31 18:20:00 UTC",
      "job_id": 2,
      "processor_utilization_percentage": 60
    },
        {
      "timestamp_datetime": "2014-03-30 18:20:00 UTC",
      "job_id": 2,
      "processor_utilization_percentage": 0
    }]
</code></pre>
<p>Output has to be sorted like below, grouping by <code>job_id</code> in ascending order:</p>
<pre><code>newresult = {
    '2':[{ "timestamp_datetime": "2014-03-31 18:20:00 UTC",
            "processor_utilization_percentage": 60},

          {"timestamp_datetime": "2014-03-30 18:20:00 UTC",
          "processor_utilization_percentage": 0},]

    '5':[{
          "timestamp_datetime": "2014-03-31 18:10:00 UTC",
          "processor_utilization_percentage": 72},
        ],
    }
</code></pre>
<p>What is pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are <em>grouping</em>; this is easiest with a <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict()</code> object</a>:</p>
<pre><code>from collections import defaultdict

newresult = defaultdict(list)

for entry in result:
    job_id = entry.pop('job_id')
    newresult[job_id].append(entry)
</code></pre>
<p><code>newresult</code> is a dictionary and these are not ordered; if you need to access job ids in ascending order, sort the keys as you list them:</p>
<pre><code>for job_id in sorted(newresult):
    # loops over the job ids in ascending order.
    for job in newresult[job_id]:
        # entries per job id
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> to group the <code>results</code> by their <code>job_id</code>:</p>
<pre><code>from itertools import groupby
new_results = {k: list(g) for k, g in groupby(results, key=lambda d: d["job_id"])}
</code></pre>
<p>The result is a dictionary, i.e. it has no particular order. If you want to iterate the values in ascending order, you can just do something like this:</p>
<pre><code>for key in sorted(new_results):
    entries = new_results[key]
    # do something with entries
</code></pre>
<hr/>
<p>Update: as Martijn points out, this requires the <code>results</code> list to be sorted by the <code>job_id</code>s (as it is in your example), otherwise entries might be lost.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you really didn't want the the job_id in the newresult:</p>
<pre><code>from collections import defaultdict
newresult = defaultdict(list)
for result in results:
    job_id = result['job_id']
    newresult[job_id].append( 
        {'timestamp_datetime':result['timestamp_datetime'],
         'processor_utilization_percentage':result['processor_utilization_percentage']}
        )
#print newresult
</code></pre>
<p>I don't really see a way to do this with a dictionary comprehension, but I'm sure there's someone out there with more experience in doing that sort of thing who could pull it off.  This is pretty straightforward, though.</p>
</div>
<span class="comment-copy">You are <i>grouping</i> your output; do you need the groups to be sorted still? Your timestapms are all the same, are you sorting on <code>processor_utilization_percentage</code> at all?</span>
<span class="comment-copy">no output should be dictionary of list where key should be job_ids only</span>
<span class="comment-copy">Dictionaries <i>have no order</i>, you can only <b>group</b> your data by <code>job_id</code>. The keys in <code>newresult</code> are not listed in any order.</span>
<span class="comment-copy">The OP made an edit that the output should be grouped by <code>job_id</code> <i>in ascending order</i>, so you'll need add a sort at the end.</span>
<span class="comment-copy">@BioGeek: except that dictionaries are <i>not ordered</i>.</span>
<span class="comment-copy">thanks @MartijnPieters tryed ur solution geting below error lease not i am using python 3.0 Traceback (most recent call last):   File "&lt;pyshell#240&gt;", line 1, in &lt;module&gt;     newresult = defaultdict(list) TypeError: first argument must be callable</span>
<span class="comment-copy">@sagar: you assigned something else to <code>list</code>; use <code>del list</code> first so that <code>list</code> once again refers to the built-in type.</span>
<span class="comment-copy">@sagar: never use <code>list</code> as a variable in your code.</span>
<span class="comment-copy">This only works if the list is sorted on <code>job_id</code> first.</span>
<span class="comment-copy">I mean the <i>input</i>, <code>results</code>, needs to be sorted by <code>job_id</code> for <code>groupby</code> to work. <code>results</code> is a list of dictionaries, if there is a dictionary at index 0 with <code>'job_id': 1</code>, and another at index 5, with other entries with different <code>'job_id'</code> values in between, you end up with just <i>one</i> <code>'jobid': 1</code> entry in your output.</span>
<span class="comment-copy">From the <code>groupby</code> documentation: <i>Generally, the iterable needs to already be sorted on the same key function</i>. Using <code>defaultdict</code> grouping is a O(N) operation, with sorting and <code>groupby</code> it's <code>O(NlogN)</code>. <code>groupby</code> is great if the input is already sorted, of course.</span>
<span class="comment-copy">@MartijnPieters Didn't know that, thanks for pointing out. I'll add this to my answer and leave it here, so others don't make the same error.</span>
<span class="comment-copy">You can do it with a list comprehension and <code>itertools.groupby()</code> but then you need to sort <code>results</code> first; not worth it unless that list is always already sorted on <code>job_id</code>.</span>
