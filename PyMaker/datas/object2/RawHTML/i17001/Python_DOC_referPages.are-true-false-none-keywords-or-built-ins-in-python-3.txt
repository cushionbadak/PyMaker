<div class="post-text" itemprop="text">
<p>So, in Python 2 it was clear. But in Python 3 I'm a little bit confused.</p>
<pre><code>&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
&gt;&gt;&gt; import keyword
&gt;&gt;&gt; dir(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<p><em>True</em>, <em>False</em> and <em>None</em> are present in both the <em>builtins</em> module and the <em>keywords</em> module. Then how should I treat them? As a builtin classes or as a keywords?</p>
</div>
<div class="post-text" itemprop="text">
<p>They are reserved words <em>and</em> built-in values. From the <a href="https://docs.python.org/3/whatsnew/3.0.html#changed-syntax" rel="noreferrer">Python 3 What's New</a>:</p>
<blockquote>
<p><code>True</code>, <code>False</code>, and <code>None</code> are reserved words. (2.6 partially enforced the restrictions on <code>None</code> already.)</p>
</blockquote>
<p>This means you cannot use them as names, assigning a different value to them. This prevents accidentally masking the built-in singleton values:</p>
<pre><code>&gt;&gt;&gt; True = False
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to keyword
</code></pre>
<p>Also see <a href="http://python-history.blogspot.co.uk/2013/11/story-of-none-true-false.html" rel="noreferrer">Guido van Rossum's history lesson on <code>None</code>, <code>True</code> and <code>False</code></a>:</p>
<blockquote>
<p>I still forgot to answer whether None/True/False are literals or keywords. My answer is that they are both. They are keywords because that's how the parser recognizes them. They are literals because that's their role in expressions and because they stand for constant values.</p>
</blockquote>
<p>With <code>True</code>, <code>False</code> and <code>None</code> classified as keywords, the Python compiler can actually optimize their use, since you cannot (directly) rebind these names  Python can look them up as constants instead of globals, which is faster. </p>
<p>Until Python 3.4 there were still some corner cases where the compiler would issue a global lookup for these objects, see <a href="http://bugs.python.org/issue16619" rel="noreferrer">issue 16619</a>. From Python 3.4 onwards the Python parser has been extended to produce a new AST node <code>NameConstant</code> to ensure that they are treated as constants everywhere. </p>
</div>
<span class="comment-copy">But if <code>None</code>, <code>True</code>, and <code>False</code> are now Python keywords, why keep them in the <i>builtins</i> module?</span>
<span class="comment-copy">@ostrokach: the <i>names</i> may be keywords, but they still need to refer to actual objects. When you use the name, you still want that name to resolve to the object. And why break any code that used <code>builtins.False</code> or <code>builtins.True</code> to bypass a local shadowing?</span>
