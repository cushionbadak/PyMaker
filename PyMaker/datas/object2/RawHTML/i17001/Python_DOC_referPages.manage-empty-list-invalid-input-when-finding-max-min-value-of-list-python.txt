<div class="post-text" itemprop="text">
<p>I'm finding max value and min value of a list by using <code>max(list)</code> and <code>min(list)</code> in Python. However, I wonder how to manage empty lists. </p>
<p>For example if the list is an empty list <code>[]</code>, the program raises <code>'ValueError: min() arg is an empty sequence'</code> but I would like to know how to make the program just print <code>'empty list or invalid input'</code> instead of just crashing. How to manage those errors?</p>
</div>
<div class="post-text" itemprop="text">
<p>Catch and handle the exception.</p>
<pre><code>try:
    print(min(l), max(l))
except (ValueError, TypeError):
    print('empty list or invalid input')
</code></pre>
<p><code>ValueError</code> is raised with an empty sequence. <code>TypeError</code> is raised when the sequence contains unorderable types.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4, a <code>default</code> keyword argument has been added to the <code>min</code> and <code>max</code> functions. This allows a value of your choosing to be returned if the functions are used on an empty list (or another iterable object). For example: </p>
<pre><code>&gt;&gt;&gt; min([], default='no elements')
'no elements'

&gt;&gt;&gt; max((), default=999)
999

&gt;&gt;&gt; max([1, 7, 3], default=999) # 999 is not returned unless iterable is empty
7
</code></pre>
<p>If the <code>default</code> keyword is not given, a <code>ValueError</code> is raised instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Specifying a default in earlier versions of Python:</p>
<pre><code>max(lst or [0])
max(lst or ['empty list'])
</code></pre>
</div>
<span class="comment-copy">this is prefered way to do this in python (exceptions are cheap): <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">docs.python.org/3/glossary.html#term-eafp</a></span>
<span class="comment-copy">There's a side-effect: if some other error occurs lower on the stack that happens to be of the same type, it'll be caught too. This inaccuracy is the primary source of critique for exception handling. In this particular case, this is probably of little concern though.</span>
<span class="comment-copy">@ivan_pozdeev Your comment does not make sense to me. The exception handling merely states that a certain operation should succeed and if it fails to succeed for a list of specified error types, then some other handling is chosen instead. Nothing about this proposition says that the <i>reason</i> for the exception must be transparently part of the original code in the <code>try</code> section. If something lower on the stack, like a weird memory error or miscompiled extension module or something, caused a <code>ValuerError</code>, that does not change or break anything about the exception handling.</span>
<span class="comment-copy">It only means that the programmer must consider a wider range of possible failing operations, or weigh the trade-off of explicitly controlling for those kinds of failures with special logic vs. risking the assumption that those kinds of failures are too unlikely to bother caring about until someday when they cause a real problem. Exception handling puts this trade-off decision into the hands of the engineers, where it belongs.</span>
<span class="comment-copy">Very nice. For the curious, this works because empty lists are falsy in Python... so <code>[1,2,3] or 'something else'</code> is [1,2,3], but <code>[] or 'something else'</code> is 'something else'. If the latter is a one-item list, <code>min()</code> will always return its only item.</span>
<span class="comment-copy">Unfortunately this doesn't work for empty iterators.</span>
<span class="comment-copy">no but it's beautiful :)</span>
