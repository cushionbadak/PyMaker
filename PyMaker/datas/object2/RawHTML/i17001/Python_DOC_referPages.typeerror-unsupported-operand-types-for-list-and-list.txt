<div class="post-text" itemprop="text">
<p>In Python, I want to write a list comprehension to iterate over the union of the keys for 2 dictionaries. Here's a toy example:</p>
<pre><code>A = {"bruno":1, "abe":2}.keys()
B = {"abe":5, "carlton":10}.keys()

&gt;&gt;&gt;[ k for k in A | B ]
</code></pre>
<p>I'm getting the error:</p>
<pre><code>Traceback (most recent call last)
&lt;ipython-input-221-ed92ac3be973&gt; in &lt;module&gt;()
      2 B= {"abe":5, "carlton":10}.keys()
      3 
----&gt; 4 [ k for k in A|B]

TypeError: unsupported operand type(s) for |: 'list' and 'list'
</code></pre>
<p>The comprehension works just fine for 1 dictionary. For example:</p>
<pre><code>&gt;&gt;&gt;[ k for k in A]
['bruno', 'abe']
</code></pre>
<p>Not sure where the error is. I'm following an example in a textbook and according to the book, this type of union and intersection operator should work fine. Please let me know your thoughts. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, <code>dict.keys()</code> is a list, not <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="nofollow">dictionary view</a>. Use <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewkeys" rel="nofollow"><code>dict.viewkeys()</code></a> instead:</p>
<pre><code>A = {"bruno":1, "abe":2}.viewkeys()
B = {"abe":5, "carlton":10}.viewkeys()

[k for k in A | B]
</code></pre>
<p>Your example would have worked <em>in Python 3</em>, where the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow"><code>.keys()</code> method</a> has been changed to return a dictionary view by default.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; A = {"bruno":1, "abe":2}.viewkeys()
&gt;&gt;&gt; B = {"abe":5, "carlton":10}.viewkeys()
&gt;&gt;&gt; [k for k in A | B]
['carlton', 'bruno', 'abe']
</code></pre>
<p>It sounds as if your textbook assumes you are using Python 3. Switch textbooks, or use Python 3 to run the examples, don't try to mix the two until you get a lot more experience with the differences between Python 2 and 3.</p>
<p>For the record, a dictionary view supports set operations with the <code>|</code>, <code>^</code>, <code>-</code> and <code>&amp;</code> operators against any iterable on the right-hand side; so the following works too:</p>
<pre><code>A_dict = {"bruno":1, "abe":2}
B_dict = {"abe":5, "carlton":10}

[k for k in A_dict.viewkeys() | B_dict]
</code></pre>
</div>
<span class="comment-copy"><code>[ k for k in set(A) | set(B) ]</code></span>
<span class="comment-copy">I donâ€™t think you need to iterate over key's list. &gt;&gt;&gt; set(A+B) set(['carlton', 'bruno', 'abe'])</span>
<span class="comment-copy">@Arvind: There are far more efficient ways of doing that in Python 2. In Python 3, the posted code would work, which is where the problem lies.</span>
<span class="comment-copy">@TanveerAlam: or <code>set(A).union(B)</code>.</span>
<span class="comment-copy">Nice explanation!!  Though <code>[ k for k in set(A) | set(B) ]</code> this also give correct result. Is there anything wrong using it? just curious. :)</span>
<span class="comment-copy">@Arvind: that'd be <i>far</i> less efficient, because you'd first create two lists from the keys, then create two sets from those again. It's the poor-mans version of what I posted, loads of extra objects being created (with extra loops in C code).</span>
<span class="comment-copy">@Arvind: The dictionary views are light-weight objects that make use of the fact that dictionaries already implement most of the functionality the set operations need.</span>
<span class="comment-copy">@Arvind: If you were to go that route, you'd call <code>set()</code> <i>directly on just one of the dictionaries</i> (not on the <code>.keys()</code> result), then use the <code>.union()</code> method to pass in the other dictionary, directly. That at least saves you creating too many intermediary objects. It'd still be slower.</span>
<span class="comment-copy">Thanks for explanation bro. I think i need to explore more</span>
