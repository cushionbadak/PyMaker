<div class="post-text" itemprop="text">
<p>I just started self teaching Python, and I need a little help with this script:</p>
<pre><code>old_string = "didnt work"   
new_string = "worked"

def function():
    exec("old_string = new_string")     
    print(old_string) 

function()
</code></pre>
<p>I want to get it so <code>old_string = "worked"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're almost there. You're trying to modify a global variable so you have to add the <code>global</code> statement:</p>
<pre><code>old_string = "didn't work"
new_string = "worked"

def function():
    exec("global old_string; old_string = new_string")
    print(old_string)

function()
</code></pre>
<p>If you run the following version, you'll see what happened in your version:</p>
<pre><code>old_string = "didn't work"
new_string = "worked"

def function():
    _locals = locals()
    exec("old_string = new_string", globals(), _locals)
    print(old_string)
    print(_locals)

function()
</code></pre>
<p>output:</p>
<pre><code>didn't work
{'old_string': 'worked'}
</code></pre>
<p>The way you ran it, you ended up trying to modify the function's local variables in <code>exec</code>, which is basically undefined behavior. See the warning in the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code> docs</a>:</p>
<blockquote>
<p><strong>Note:</strong> The default <em>locals</em> act as described for function <code>locals()</code> below: modifications to the default <em>locals</em> dictionary should not be attempted. Pass an explicit <em>locals</em> dictionary if you need to see effects of the code on <em>locals</em> after function <code>exec()</code> returns.</p>
</blockquote>
<p>and the related warning on <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals()</code></a>:</p>
<blockquote>
<p><strong>Note:</strong> The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative way of having <code>exec</code> update your global variables from inside a function is to pass <code>globals()</code> into it. </p>
<pre><code>&gt;&gt;&gt; def function(command):
...    exec(command, globals())
...
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; function('x += 1')
&gt;&gt;&gt; print(x)
2
</code></pre>
<p>Unlike <code>locals()</code>, updating the <code>globals()</code> dictionary is expected always to update the corresponding global variable, and vice versa. </p>
</div>
<span class="comment-copy">What's the point of this? Why do you want to use exec here?</span>
<span class="comment-copy">"I just started self teaching Python.." sounds like they're is just trying to wrap their head around a new language...</span>
<span class="comment-copy">Is there a way to modify it in the scope of the calling function?</span>
<span class="comment-copy">@SarcasticSully there is no calling function here..  If you wonder about something tangentially associated with the question, or answer, you should ask a new question (with the proper context, code samples, etc.) Leaving new questions in comments of 3 year old answers isn't likely to be helpful for anyone...</span>
<span class="comment-copy">Rather than add a <code>global</code> statement, you can simply set the namespaces: <code>exec('old_string = new_string', globals(), globals())</code>.</span>
<span class="comment-copy">@MartijnPieters if you do that (<code>exec('..', globals(), globals())</code>) any variable created in the exec becomes a global -- probably not what you want?</span>
<span class="comment-copy">Yes, and that could be the goal. Most people forget about the ability to specify the namespaces (including new dictionaries), if you donâ€™t want all names as globals using a custom namespace and then extracting what you need afterwards might be the better option anyway.</span>
<span class="comment-copy">Try <code>function("[t for t in range(5)]")</code>, then <code>print(t)</code>... Maybe too many unintended consequences?</span>
<span class="comment-copy">@thebjorn I get <code>NameError: name 't' is not defined</code>, which is what I would expect. Are you using an old version of Python before they fixed the variables-escaping-comprehensions bug?</span>
<span class="comment-copy">Yes 2.7 all the way! (<i>sigh</i>).  Did they fix the for-loop variable escape too?</span>
<span class="comment-copy">No, if I understand you correctly. I think that's intended behaviour.</span>
