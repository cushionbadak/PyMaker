<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; [6,7,8,16,18] &lt;= [6,8,11,13,17]
True
</code></pre>
<p><code>&lt;=</code> Should return <code>True</code> if every element in left set is in right set. But <code>7,16,18</code> are not in the right list. Even if I put the numbers in sets like so</p>
<pre><code>&gt;&gt;&gt; (6,7,8,16,18) &lt;= (6,8,11,13,17)
True
</code></pre>
<p><a href="https://docs.python.org/2/library/sets.html" rel="nofollow">https://docs.python.org/2/library/sets.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <strong>lists and tuples</strong>, not sets. Use <a href="https://docs.python.org/3/reference/expressions.html#set-displays" rel="nofollow"><code>{...}</code> for set literals</a>:</p>
<pre><code>&gt;&gt;&gt; {6, 7, 8, 16, 18} &lt;= {6, 8, 11, 13, 17}
False
</code></pre>
<p>or use <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow"><code>set([...])</code></a> or <a href="https://docs.python.org/3/library/functions.html#func-frozenset" rel="nofollow"><code>frozenset([...])</code></a>. Set literal syntax is only available in Python 2.7 and 3.x.</p>
<p>Lists and tuples don't support set operations. Instead, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> comparisons follow lexicographical ordering conventions; the contents are compaired pairwise and the outcome is based on the first value that differs between the two sequences.</p>
<p>Lexicographically sorted, your left-hand list sorts before the right-hand (<code>6 == 6</code>, then <code>7 &lt; 8</code>) so the outcome <em>for sequences</em> is entirely correct.</p>
</div>
<span class="comment-copy">Thanks Martijin, I understand now. Great explanation!</span>
