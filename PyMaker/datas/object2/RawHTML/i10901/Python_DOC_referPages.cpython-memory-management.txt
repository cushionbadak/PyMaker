<div class="post-text" itemprop="text">
<p>I am writing a CPython module <code>mrloader</code> on top of a C library, I compiled source code and started making some tests.</p>
<p>Python takes 4 Gb of RAM to run 100 iteration loop to get some data from network. This is a big problem, so I used <code>resource</code> to limit the amount of RAM and test if the Python GC's frees the memory. I got a <code>Segmentation fault</code>.</p>
<p>I used <a href="https://docs.python.org/2/c-api/memory.html" rel="nofollow">this</a> documentation and <a href="https://docs.python.org/2/extending/newtypes.html" rel="nofollow">this</a> to write the module, and I think I am doing something wrong when the objects being collected, because if I don't limit the RAM it finishes the 100 loop but it uses 4Gb of memory.</p>
<p>In the mrloader <code>CPython</code> code I have a struct like so:</p>
<pre><code>typedef struct {
    PyObject_HEAD
    AL_KEY ienaKey;
    char* dataPath;
    int nbParams;
    char** pListOfParams;
    CLIST_S* listParam;
    AL_DEFP_S *pListeParamInfo;
    int* pIndexParamIsTopana;
} MRLoader;
</code></pre>
<p>The Python test is like so:</p>
<pre><code>def limit_memory(maxsize):
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (maxsize, hard))

limit_memory(8589934592/10)

for i in xrange(100):
    print '----------------------------', i, '--------------------------' 
    obj = MRLoader.MRLoader(MR)
    obj.initReaderCadence(paramList, cadence, zdtStart, zdtStop)
    print obj.getData()
    obj.closeAll()
</code></pre>
<p>In the CPython code, the <code>destructor</code> is declared like so:</p>
<pre><code>static void MRLoader_dealloc(MRLoader *self){
    self-&gt;ob_type-&gt;tp_free((PyObject *)self);
}
</code></pre>
<p>Am I correctly deallocating the memory ?</p>
<p>I appreciate your time helping me.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found the solution, I was using <code>PyArrayObject</code> that I did not keep a pointer for in the declared struct. The memory was not being released because of this huge numpy array.</p>
<p>So my struct look like this now:</p>
<pre><code>typedef struct {
    PyObject_HEAD
    AL_KEY ienaKey;
    char* dataPath;
    int nbParams;
    char** pListOfParams;
    CLIST_S* listParam;
    AL_DEFP_S *pListeParamInfo;
    int* pIndexParamIsTopana;
    // Added this pointer to the numpy array
    reel64* pValueArray;
} libzihc_MRLoader;
</code></pre>
<p>And in the deallocate function, I called <code>free()</code> before destroying the <code>PyObject</code> self. Now the program does not uses more than 100Mb, the array is big.</p>
<p>Deallocate function:</p>
<pre><code>static void MRLoader_dealloc(MRLoader *self){
    free(self-&gt;pValueArray)
    self-&gt;ob_type-&gt;tp_free((PyObject *)self);
}
</code></pre>
</div>
<span class="comment-copy">Your extension type contains a bunch of pointers.  It is unclear how these are used, but if any of them at any time get assigned the only pointer to a block of memory that must be freed, then the <code>dealloc</code> function must handle freeing that memory when appropriate.  Moreover, in that case, your type's methods must handle those members appropriately -- for example, freeing the pointed-to memory before overwriting the pointer value with a different one.</span>
<span class="comment-copy">Thank you @JohnBollinger, They are deallocated in different methods, and the closeAll(). I am searching what references are not cleaned.</span>
<span class="comment-copy">CPython uses reference counting, which means that data is deallocated as soon as possible, unless there are cycles.  If you never create cyclic data structures, the thing you are doing with <code>setrlimit</code> cannot possibly help.  If you do use cyclic data structures, the <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer"><code>gc</code></a> interfaces are more likely to help.</span>
<span class="comment-copy">It would be wise for the <code>dealloc</code> function to free any memory owned by the object that hasn't already been freed; this will provide a safety net against programming errors.</span>
<span class="comment-copy">@e-nouri, I repeat,  if any of the pointers at any time get assigned the only pointer to a block of memory that must be freed, then <b><i>the dealloc function</i></b> must handle freeing that memory when appropriate.  It is acceptable for other functions also to deallocate as long as they have a means to indicate to the <code>dealloc</code> function that it should not deallocate the same memory again, but you should not rely for correct deallocation exclusively on methods that must be called by your module's user.</span>
