<div class="post-text" itemprop="text">
<p>Is there any way to use a dictionary as the key in a dictionary. Currently I am using two lists for this but it would be nice to use a dictionary. Here is what I currently am doing:</p>
<pre><code>dicts = [{1:'a', 2:'b'}, {1:'b', 2:'a'}]
corresponding_name = ['normal', 'switcheroo']
if {1:'a', 2:'b'} in dicts:
    dict_loc = dicts.index({1:'a', 2:'b'})
    desired_name = corresponding_name[dict_loc]
    print desired_name
</code></pre>
<p>Here is what I want:</p>
<pre><code>dict_dict = {{1:'a', 2:'b'}:'normal', {1:'b', 2:'a'}:'switcheroo'}
try: print dict_dict[{1:'a', 2:'b'}]
except: print "Doesn't exist"
</code></pre>
<p>But this does not work and I'm not sure if there's any way around this.</p>
</div>
<div class="post-text" itemprop="text">
<p>As other answers have noted you can't use dictionaries as keys since keys need to be immutable. What you can do though is to turn a dictionary to a <a href="https://docs.python.org/2/library/stdtypes.html#frozenset" rel="nofollow"><code>frozenset</code></a> of <code>(key, value)</code> tuples which you can use as a key. This way you wouldn't have to worry about sorting and it would be more efficient as well:</p>
<pre><code>dicts = [{1:'a', 2:'b'}, {1:'b', 2:'a'}]
corresponding_name = ['normal', 'switcheroo']

d = dict(zip((frozenset(x.iteritems()) for x in dicts), corresponding_name))

print d.get(frozenset({1:'a', 2:'b'}.iteritems()), "Doesn't exist")
print d.get(frozenset({'foo':'a', 2:'b'}.iteritems()), "Doesn't exist")
</code></pre>
<p>Output:</p>
<pre><code>normal
Doesn't exist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A dictionary key has to be immutable. A dictionary is mutable, and hence can't be used as a dictionary key. <a href="https://docs.python.org/2/faq/design.html#why-must-dictionary-keys-be-immutable" rel="nofollow">https://docs.python.org/2/faq/design.html#why-must-dictionary-keys-be-immutable</a></p>
<p>If you can guarantee that the dictionary items are also going to be immutable (ie. strings, tuples, etc), you could do this:</p>
<pre><code>dict_dict = {}
dictionary_key = {1:'a', 2:'b'}
tuple_key = tuple(sorted(dictionary_key.items()))
dict_dict[tuple_key] = 'normal'
</code></pre>
<p>Essentially, we are converting each dictionary into a tuple, sorting the <code>(key,value)</code> pairs to ensure a consistent ordering within the tuple. We then use this tuple as the key to your dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess this will help you</p>
<pre><code>dicts = {
    'normal' : "we could initialize here, but we wont",
    'switcheroo' : None,
}
dicts['normal'] = {
    1 : 'a',
    2 : 'b',
}
dicts['switcheroo'] = {
    1:'b',
    2:'a'
}

if dicts.has_key('normal'):
    if dicts['normal'].has_key(1):
        print dicts['normal'][1]

print dicts['switcheroo'][2]
</code></pre>
</div>
<span class="comment-copy">You can't use mutable objects as dictionary keys, so no.  That is impossible.</span>
<span class="comment-copy">Can't do that but you might find <a href="http://stackoverflow.com/questions/2970608/what-are-named-tuples-in-python">named tuples</a> a good alternative</span>
<span class="comment-copy">It might be better to use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> for this. That way OP doesn't have to remember to sort the dictionaries every time.</span>
