<div class="post-text" itemprop="text">
<p>Considering a endpoint on my backend, that returns the following response:</p>
<pre><code>class Arc_Edges_Data(Resource):
  def get(self):
        #Connect to databse
        conn = connectDB()
        cur = conn.cursor()
        #Perform query and return JSON data
        try:
          cur.execute("select json_build_object('source', start_location, 'target', end_location, 'frequency', 1) from trips")
        except:
          print("Error executing select")
        ArcList = list (i[0] for i in cur.fetchall())
        return ArcList
</code></pre>
<p>The frequency here is supposed to be always of 1 for each trip. So this <code>ArcList</code> originates a response like this:</p>
<pre><code>[
    {
        "frequency": 1, 
        "source": "c", 
        "target": "c"
    }, 
    {
        "frequency": 1, 
        "source": "a", 
        "target": "b"
    }, {
        "frequency": 1, 
        "source": "a", 
        "target": "b"
    }, ...
]
</code></pre>
<p>How can I iterate this response and sum the items that have the same <code>source</code> and <code>target</code>? In this case, the resulting list would have only one pair source/target with "a" and "b", but the frequency would be 2, because of the sum.</p>
<p>I know that for Javascript I could use something like <code>Array.reduce</code>, but I don't think it exists for Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this?</p>
<pre><code>import collections

data = [
    {
        "frequency": 1, 
        "source": "c", 
        "target": "c",
    }, 
    {
        "frequency": 1, 
        "source": "a", 
        "target": "b",
    },
    {
        "frequency": 1, 
        "source": "a", 
        "target": "b",
    },
]

counter = collections.Counter()

for datum in data:
    counter[(datum['source'], datum['target'])] += datum['frequency']

print(counter)

# Output:
# Counter({('a', 'b'): 2, ('c', 'c'): 1})
</code></pre>
<p>Oh, if you want to put the data back into the same format again, add this code:</p>
<pre><code>newdata = [{
    'source': k[0],
    'target': k[1],
    'frequency': v,
} for k, v in counter.items()]

print(newdata)

# Output:
# [{'frequency': 1, 'target': 'c', 'source': 'c'}, {'frequency': 2, 'target': 'b', 'source': 'a'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do this:</p>
<pre><code>r = {}
for d in ArcList:
    key = (d['source'], d['target'])
    r[key] = r.setdefault(key, 0) + d['frequency']
return [{'source': k[0], 'target': k[1], 'frequency': v} for k, v in r.items()]
</code></pre>
<p>If you want to preserve the original ordering of the items:</p>
<pre><code>from collections import OrderedDict
r = OrderedDict()
# The rest of the solution is the same
...
</code></pre>
</div>
<span class="comment-copy">python has reduce <a href="https://docs.python.org/2/library/functions.html#reduce" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#reduce</a></span>
<span class="comment-copy">Python Counter may help you: <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">This works perfectly! But I've also read what @Brendan Abel said and which way is the most efficient for a large dataset?</span>
<span class="comment-copy">@Shoplifter.Doe I haven't tested their performance, but my guess is that they're very close to identical.</span>
<span class="comment-copy">Ok thank you, I can always come back an check the other way if I need it.</span>
<span class="comment-copy">This is equivalent to my answer but using a <code>dict</code> instead of a <code>Counter</code>. (I personally prefer <code>Counter</code>, just because the intent of the code is clearer, but there's nothing wrong with this answer.)</span>
<span class="comment-copy">@smarx Yeah, I thought of using Counter, but it doesn't really work if <code>frequency</code> isn't always 1.  You're basically just using Counter like a regular dict, though it is nice that it works like a <code>defaultdict</code> without the need for <code>setdefault</code></span>
<span class="comment-copy">What do you mean "it doesn't really work if <code>frequency</code> isn't always 1?"</span>
<span class="comment-copy">@smarx Generally, they way I would use counter would be to just feed it a list of values and let it do the counting.  In this case, we're not really counting the number of occurrences of <code>source/target</code>, we're adding up all the frequency values (unless frequency was always 1, in which case the count and the frequency total would be the same)</span>
<span class="comment-copy">That's fine but not the only way to use a <code>Counter</code>. In my use, it's basically just a dictionary with the default value 0.</span>
