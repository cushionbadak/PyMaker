<div class="post-text" itemprop="text">
<p>I needed to make a class that extended dict and ran into an interesting problem illustrated by the dumb example in the image below.</p>
<p><a href="https://i.stack.imgur.com/0ClOH.png" rel="nofollow noreferrer"><img alt="subclassing_dict_problem" src="https://i.stack.imgur.com/0ClOH.png"/></a></p>
<p>Why is <code>d.update()</code> ignoring the class's <code>__getitem__</code>?</p>
<p>EDIT: This is in python2.7 which does not appear to contain collections.UserDict
Thinking UserDict.UserDict is the equivalent I tried this, and it gets closer, but still behaves interestingly.</p>
<p><a href="https://i.stack.imgur.com/2NZd7.png" rel="nofollow noreferrer"><img alt="updated to use UserDict" src="https://i.stack.imgur.com/2NZd7.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is an example of the <a href="https://en.wikipedia.org/wiki/Open/closed_principle">open-closed-principle</a> (the class is open for extension but closed for modification).  It is good thing to have because it allows subclassers to extend or override a method without unintentionally triggering behavior changes in others and without breaking the classes's invariants.</p>
<p>We even do this in pure python code as well; for example, <a href="https://hg.python.org/cpython/file/2.7/Lib/collections.py#l69">inside the pure python ordered dict code</a>, the class local call from <code>__init__()</code> to <code>update()</code> is done using <a href="https://docs.python.org/2.7/tutorial/classes.html#private-variables-and-class-local-references">name mangling</a>.  This allows a subclasser to override <code>update()</code> <a href="https://hg.python.org/cpython/file/2.7/Lib/collections.py#l145">without accidentally breaking</a> <code>__init__()</code>.</p>
<p>Sometimes, this is inconvenient.  It means that a subclasser has to override every method whose behavior they want to change including <code>get()</code>, <code>update()</code>, and others.  However, there are offsetting benefits (protection of internal invariants, preventing implementation details from leaking from the abstraction, and allowing users to assume the methods are independent of one another).</p>
<p>This style (chosen by Guido from the outset) is the default for the builtin types (otherwise we would forever be fighting segfaulting invariant violations) and for some pure python classes.</p>
<p>We do document when there is a departure from the default.  For example, the <a href="https://docs.python.org/3.5/library/cmd.html#cmd-example">cmd module</a> uses the <a href="https://en.wikipedia.org/wiki/Software_framework">framework design pattern</a>, letting the user define various do_action() methods.  Also, some of the http modules do the same, specifically documenting that a user's <a href="https://docs.python.org/2.7/library/simplehttpserver.html#SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET"><code>do_GET()</code> method</a> is called and that is how you attach customized HTTP event handlers.</p>
<p>In the absence of specifically documented method hooks (i.e. those listed above or methods like <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict"><code>dict.__missing__()</code></a>, a subclasser should presume method independence.  Otherwise, how are you to know whether <code>__getitem__()</code> calls <code>get()</code> under the hood or vice-versa?</p>
<p>FWIW, this isn't unique to Python.  It comes up quite a bit in object oriented programming.  Correctly designed classes either document root methods that affect the behavior of other methods or they are presumed to be independent.</p>
<p>There may need to be a FAQ for this, but nothing is broken or wrong here (other than Python having way too many dict variants to chose from).  If someone mistakenly assumes or believes that <code>__getitem__()</code> must be called by the other accessor methods, they find out very quickly that assumption is wrong (that is if they run even minimal tests on the code).</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/3387691/python-how-to-perfectly-override-a-dict">Python: How to "perfectly" override a dict</a></span>
<span class="comment-copy">My question isn't how to get around this, but 'why' this is happening. I ended up subclassing MutableMapping to get my job done, but this seems like odd, undocumented behavior.</span>
<span class="comment-copy"><a href="https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types" rel="nofollow noreferrer">Subclasses of built-in types</a></span>
<span class="comment-copy">@ssdms Useful link, however I wouldn't classify a tiny blip in PyPy documentation documented behavior of built-in classes for CPython. If it is to be expected behavior, why not have a big warning about subclassing builtins <a href="https://docs.python.org/2/library/stdtypes.html#built-in-types" rel="nofollow noreferrer">here</a> The note is quite misleading.</span>
<span class="comment-copy">It sounds like something to submit a documentation bug/request - <a href="https://docs.python.org/2/bugs.html" rel="nofollow noreferrer">docs.python.org/2/bugs.html</a></span>
