<div class="post-text" itemprop="text">
<p>My questions concern instance variables that are initialized <em>in methods outside the class constructor</em>. This is for Python. </p>
<p>I'll first state what I understand: </p>
<ol>
<li>Classes may define a constructor, and it may also define other methods.</li>
<li>Instance variables are generally defined/initialized within the constructor.</li>
<li>But instance variables can also be defined/initialized <em>outside</em> the constructor, e.g. in the other methods of the same class. </li>
<li><p>An example of (2) and (3) -- see <em>self.meow</em> and <em>self.roar</em> in the <strong>Cat</strong> class below:</p>
<pre><code>class Cat():

    def __init__(self):
        self.meow = "Meow!"
    def meow_bigger(self):
        self.roar = "Roar!"
</code></pre></li>
</ol>
<p>My questions:</p>
<ol>
<li><p>Why is it best practice to initialize the instance variable within the constructor? </p></li>
<li><p>What general/specific mess could arise if instance variables are regularly initialized in methods other than the constructor? (E.g. Having read Mark Lutz's  Tkinter guide in his Programming Python, which I thought was excellent, I noticed that the instance variable used to hold the PhotoImage objects/references were initialized in the further methods, not in the constructor. It seemed to work without issue there, but could that practice cause issues in the long run?)</p></li>
<li><p>In what scenarios would it be <em>better</em> to initialize instance variables in the other methods, rather than in the constructor?</p></li>
</ol>
<hr/>
<ol start="4">
<li><p>To my knowledge, instance variables exist not when the class object is created, but <em>after</em> the class object is instantiated. Proceeding upon my code above, I demonstrate this: </p>
<pre><code>&gt;&gt; c = Cat() 
&gt;&gt; c.meow
'Meow!'
&gt;&gt; c.roar
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Cat' object has no attribute 'roar'
&gt;&gt;&gt; c.meow_bigger()
&gt;&gt;&gt; c.roar
'Roar!'
</code></pre>
<p>As it were:</p>
<ul>
<li>I cannot access the instance variable (<em>c.roar</em>) at first. </li>
<li>However, after I have called the instance method <em>c.meow_bigger()</em> once, I am suddenly able to access the instance variable <em>c.roar</em>. </li>
<li>Why is the above behaviour so?</li>
</ul></li>
</ol>
<p>Thank you for helping out with my understanding.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why is it best practice to initialize the instance variable within the
  constructor?</p>
</blockquote>
<h2>Clarity.</h2>
<p>Because it makes it easy to see at a glance all of the attributes of the class. If you initialize the variables in multiple methods, it becomes difficult to understand the complete data structure without reading every line of code.</p>
<p>Initializing within the <code>__init__</code> also makes documentation easier. With your example, you can't write "an instance of Cat has a <code>roar</code> attribute". Instead, you have to add a paragraph explaining that an instance of Cat might have a "roar" attribute, but only after calling the "meow_louder" method. </p>
<p>Clarity is king. One of the smartest programmers I ever met once told me "show me your data structures, and I can tell you how your code works without seeing any of your code". While that's a tiny bit hyperbolic, there's definitely a ring of truth to it. One of the biggest hurdles to learning a code base is understanding the data that it manipulates. </p>
<blockquote>
<p>What general/specific mess could arise if instance variables are
  regularly initialized in methods other than the constructor?</p>
</blockquote>
<p>The most obvious one is that an object may not have an attribute available during all parts of the program, leading to having to add a lot of extra code to handle the case where the attribute is undefined.</p>
<blockquote>
<p>In what scenarios would it be better to initialize instance variables
  in the other methods, rather than in the constructor?</p>
</blockquote>
<p>I don't think there are any.</p>
<p>Note: you don't necessarily have to initialize an attribute with it's final value. In your case it's acceptable to initialize <code>roar</code> to <code>None</code>. The mere fact that it has been initialized to <em>something</em> shows that it's a piece of data that the class maintains. It's fine if the value changes later. </p>
</div>
<div class="post-text" itemprop="text">
<p>Remember that class members in "pure" Python are just a dictionary.  Members aren't added to an instance's dictionary until you run the function in which they are defined.  Ideally this is the constructor, because that then guarantees that your members will all exist regardless of the order that your functions are called.</p>
<p>I believe your example above could be translated to:</p>
<pre><code>class Cat():
    def __init__(self):
        self.__dict__['meow'] = "Meow!"
    def meow_bigger(self):
        self.__dict__['roar'] = "Roar!"

&gt;&gt;&gt; c = Cat()        # c.__dict__ = { 'meow': "Meow!" }
&gt;&gt;&gt; c.meow_bigger()  # c.__dict__ = { 'meow': "Meow!", 'roar': "Roar!" }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To initialize instance variables within the constructor, is - as you already pointed out - only recommended in python.</p>
<p>First of all, defining all instance variables within the constructor is a <strong>good way to document a class</strong>. Everybody, seeing the code, knows what kind of internal state an instance has. </p>
<p>Secondly, <strong>order matters</strong>. if one defines an instance variable <code>V</code> in a  function <code>A</code> and there is another function B also accessing <code>V</code>, it is important to call <code>A</code> before <code>B</code>. Otherwise <code>B</code> will fail since V was never defined. Maybe, <code>A</code> has to be invoked before <code>B</code>, but then it should be ensured by an internal state, which would be an instance variable. </p>
<p>There are many more examples. Generally it is just a good idea to define everything in the <code>__init__</code> method, and set it to <code>None</code> if it can not / should not be initialized at initialization. </p>
<p>Of course, one could use <code>hasattr</code> method to derive some information of the state. But, also one could check if some instance variable <code>V</code> is for example None, which can imply the same then. 
So in my <strong>opinion</strong>, it is never a good idea to define an instance variable anywhere else as in the constructor.</p>
<p>Your examples state some basic properties of python. An object in Python is basically just a dictionary. 
Lets use a dictionary: One can add functions and values to that dictionary and construct some kind of OOP. Using the class statement just brings everything into a clean syntax and provides extra stuff like <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">magic methods</a>.</p>
<p>In other languages all information about instance variables and functions are present before the object was initialized. Python does that at runtime. You can also add new methods to any object outside the class definition: <a href="https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object-instance">Adding a Method to an Existing Object Instance</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Let me try to shed some light on this specific issue:</p>
<blockquote>
<p>3.) But instance variables can also be defined/initialized outside the constructor, e.g. in the other methods of the same class.</p>
</blockquote>
<p>I'd recommend providing a default state in initialization, just so its clear what the class should expect.  In statically typed languages, you'd have to do this, and it's good practice in python.</p>
<p>Let's convey this by replacing the variable <code>roar</code> with a more meaningful variable like <code>has_roared</code>.</p>
<p>In this case, your <code>meow_bigger()</code> method now has a reason to set <code>has_roar</code>.  You'd initialize it to false in <code>__init__</code>, as the cat has not roared yet upon instantiation.</p>
<pre><code>class Cat():
    def __init__(self):
        self.meow = "Meow!"
        self.has_roared = False

    def meow_bigger(self):
         print self.meow + "!!!"
         self.has_roared = True
</code></pre>
<p>Now do you see why it often makes sense to initialize attributes with default values?</p>
<p>All that being said, why does python not enforce that we HAVE to define our variables in the <code>__init__</code> method?  Well, being a dynamic language, we can now do things like this.</p>
<pre><code>&gt;&gt;&gt; cat1 = Cat()
&gt;&gt;&gt; cat2 = Cat()
&gt;&gt;&gt; cat1.name = "steve"
&gt;&gt;&gt; cat2.name = "sarah"
&gt;&gt;&gt; print cat1.name
... "steve"
</code></pre>
<p>The <code>name</code> attribute was not defined in the <code>__init__</code> method, but we're able to add it anyway. This is a more realistic use case of setting variables that aren't defaulted in <code>__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h1>I try to provide a case where you would do so for:</h1>
<h2>3.) But instance variables can also be defined/initialized outside the constructor, e.g. in the other methods of the same class.</h2>
<p>I agree it would be clear and organized to include instance field in the constructor, but sometimes you are inherit other class, which is created by some other people and has many instance fields and api. </p>
<p>But if you inherit it only for certain apis and you want to have your own instance field for your own apis, in this case, it is easier for you to just declare extra instance field in the method instead override the other's constructor without bothering to deep into the source code. This also support Adam Hughes's answer, because in this case, you will always have your defined instance because you will guarantee to call you own api first.</p>
<p>For instance, suppose you inherit a package's handler class for web development, you want to include a new instance field called <strong>user</strong> for handler, you would probability just declare it directly in the method--<strong>initialize</strong> without override the constructor, I saw it is more common to do so.</p>
<pre><code>class BlogHandler(webapp2.RequestHandler):
     def initialize(self, *a, **kw):
         webapp2.RequestHandler.initialize(self, *a, **kw)
         uid = self.read_cookie('user_id') #get user_id by read cookie in the browser
         self.user = User.by_id(int(uid)) #run query in data base find the user and return user
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i think to keep it simple and understandable, better to initialize the class variables in the class constructor, so they can be directly called without the necessity of compiling of a specific class method.</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>class Cat():

        def __init__(self,Meow,Roar):
            self.meow = Meow
            self.roar = Roar
        def meow_bigger(self):
            return self.roar
        def mix(self):
            return self.meow+self.roar

    
c=Cat("Meow!","Roar!")
print(c.meow_bigger())
print(c.mix())</code></pre>
</div>
</div>
</p>
<p><strong>Output</strong></p>
<p>Roar!</p>
<p>Roar!</p>
<p>Meow!Roar!</p>
</div>
<span class="comment-copy">These are good questions, but sadly, not really a good fit for Stack Overflow. It's too open-ended and general. See <a href="https://stackoverflow.com/help/on-topic">What topics can I ask about here?</a> and <a href="https://stackoverflow.com/help/dont-ask">What types of questions should I avoid asking?</a>. You may find it better to ask in the <a href="https://chat.stackoverflow.com/rooms/6/python">Python Chat Room</a></span>
<span class="comment-copy">As far as what "general mess" could occur if you are initializing instance variables in other functions-- you'd have no access to those variables from instances which hadn't called the functions. Having several instances, all with different <i>existing</i> variables, could get quite messy.</span>
<span class="comment-copy">these are in depth concepts. good one.</span>
<span class="comment-copy">I learned something new. Did not know that class members were a dictionary. Thank you!</span>
