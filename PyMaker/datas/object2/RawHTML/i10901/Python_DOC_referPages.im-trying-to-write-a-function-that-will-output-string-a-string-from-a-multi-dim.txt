<div class="post-text" itemprop="text">
<p>Here's the function that I wrote: </p>
<pre><code>def print_dict(d, indent, CMD_str, index = 0):
if isinstance(d,dict):
    for key, value in d.items():

        CMD_str += ('\t' * indent + str(key) + '\n')
        # print('\t' * indent + str(key) + '\n')
        if isinstance(value, dict):
            CMD_str += print_dict(value, indent+1, CMD_str, index = index+1)
        elif isinstance(value,list):
            for i in value:
                if isinstance(i,list):
                    CMD_str += print_dict(i,indent+1, CMD_str = CMD_str, index = index+1)
                else:
                    CMD_str += ('\t'*(indent+1) + i + '\n')
        else:
            CMD_str += ('\t' * (indent+1) + str(value) + '\n')
elif isinstance(d,list):
    for i in d:
        print(index)
        if isinstance(i,list):
            CMD_str += print_dict(i,indent+1, CMD_str, index = index+1)
        else:
            CMD_str += ('\t'*(indent) + i)

return CMD_str
</code></pre>
<p>This function originally printed the dictionary and worked perfectly. However, I now need it to output a string instead of printing, so I added the CMD_str input argument, so I can keep passing the string into the function until I've made my way through the dictionary. However, it's getting stuck somewhere and I can't figure out why. By printing indent values, I can tell that it runs through about 10 times before getting stuck. Any help would be greatly appreciated. </p>
</div>
<div class="post-text" itemprop="text">
<p>You have some duplicate code in your recursive function that could be reorganized for clarity and to lessen the chances of a bug occurring. Here is an example:</p>
<pre><code>tab = "  "

def print_dict(d, indent):
    result = []
    for key, value in d.items():
        result.append(tab*indent + str(key))
        result.append(print_obj(value, indent+1))
    return '\n'.join(result)

def print_list(a, indent):
    result = []
    for value in a:
        result.append(print_obj(value, indent))
    return '\n'.join(result)

def print_obj(obj, indent):
    result = ""

    if type(obj) is dict:
        result = print_dict(obj, indent)
    elif type(obj) is list:
        result = print_list(obj, indent)
    else:
        result = tab*indent + str(obj)

    return result

d = {
    'key1': ['val1', 'val2', {'key3':'val3'}],
    'key4': 'val5',
    'key5': {
        'key6': 'val6',
        'key7': [1, 2, 3, 4]
    }
}

import pprint

pprint.pprint(d, width=1)
print print_obj(d, 0)
</code></pre>
<p>The output is</p>
<pre><code>{'key1': ['val1',
          'val2',
          {'key3': 'val3'}],
 'key4': 'val5',
 'key5': {'key6': 'val6',
          'key7': [1,
                   2,
                   3,
                   4]}}
key1
  val1
  val2
  key3
    val3
key5
  key7
    1
    2
    3
    4
  key6
    val6
key4
  val5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li>Be aware of <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow">pprint</a>.</li>
<li>Separate work by scopes - your function does some work itself and expects caller to do the same work too, which leads to code duplication. I've reworked your code a bit:</li>
</ol>
<hr/>
<pre><code>from numbers import Number

def recursive_print(item, level=0):
    result = ''
    indent = '\t' * level
    if isinstance(item, dict):
        result += '\n'.join(
            indent + str(key) + '\n' +
            recursive_print(value, level+1)
            for (key, value) in item.items()
        )
    elif isinstance(item, list):
        def one_line_printable(x): return isinstance(x, str) or isinstance(x, Number)
        if all(one_line_printable(element) for element in item):
            result += indent + '\t'.join(str(element) for element in item)
        else:
            result += '\n'.join(recursive_print(element, level) for element in item)
    else:
        result += indent + str(item)
    return result
</code></pre>
<p>Note that the function is supposed to take care of its indentation on each call. However, it's the caller that is supposed to supply <code>'\n'</code> after the text - returned string does not end with <code>'\n'</code>.</p>
</div>
<span class="comment-copy">Thank you! I replaced my function with yours and it works. I'm not sure why mine wasn't working, but I do see where code was duplicated. I don't think the one_line_printable(element) part is necessary because I'm working exclusively with strings but I'll keep it there for completeness' sake. Thanks again!</span>
