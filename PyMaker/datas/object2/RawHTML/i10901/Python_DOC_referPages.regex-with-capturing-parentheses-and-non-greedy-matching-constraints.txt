<div class="post-text" itemprop="text">
<p>I just spent an hour trying to figure out the magic syntax to solve the following problem in Python with the 're' package. I have hacked around it for the moment, but would like to set out the challenge:</p>
<p>The following strings represent our test:</p>
<pre><code>*Structure song &amp;lt;!-- See Project:Project_Songs --&amp;gt;
*Structure song |
*Structure song title |
</code></pre>
<p>The objective is to extract 'song', 'song', and 'song title' from these with a single regex.</p>
<p>My attempt:</p>
<pre><code>r'\*Structure ([^\|]*)(?:&amp;lt;)?'
</code></pre>
<p>I won't bore you with the various combinations I tried so far. My workaround adds the ampersand '&amp;' to the exclusion set in the capturing parentheses. However, I'd rather not assume that the extracted string cannot include '&amp;'.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use a similar pattern as Dmitriy's, but a more linear one:</p>
<pre><code>\*Structure\s(.*?)(?=\s(?:&amp;lt;|\|))
</code></pre>
<p>See <a href="https://regex101.com/r/cF0fE7/2" rel="nofollow">regex demo</a>.</p>
<p><strong>Explanation</strong>:</p>
<ul>
<li><code>\*Structure</code> - a literal substring <code>*Structure</code></li>
<li><code>\s</code> - a whitespace (replace with <code>[ \t]</code> to only match a normal space or tab, or with a mere space if you only need to match a space)</li>
<li><code>(.*?)</code> - Group 1 capturing 0+ chars other than a newline, as few as possible up to the first ...</li>
<li><code>(?=\s(?:&amp;lt;|\|))</code> - (a positive lookahead requiring) 

<ul>
<li><code>\s</code> - a whitespace followed with either...

<ul>
<li><code>&amp;lt;</code> - a substring <code>&amp;lt;</code></li>
<li><code>|</code> - or... </li>
<li><code>\|</code>  - a literal pipe symbol.</li>
</ul></li>
</ul></li>
</ul>
<p>A faster synonymic alternative (as it is based on the unroll-the-loop principle) regex will look like</p>
<pre><code>\*Structure\s(\S*(?:\s(?!&amp;lt;|\|)\S*)*)
</code></pre>
<p>See <a href="https://regex101.com/r/cF0fE7/3" rel="nofollow">this demo</a></p>
<p>It is the same regex but written in the most linear way.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using non-greedy "anything" followed by "&amp;lt;" or pipe char represented as lookahead:</p>
<pre><code>\*Structure (.*?(?= &amp;lt;)|.*?(?= \|))
</code></pre>
<p>Demo: <a href="https://regex101.com/r/rT3oV5/2" rel="nofollow">https://regex101.com/r/rT3oV5/2</a></p>
</div>
<span class="comment-copy">Rather, what do you consider a trailing boundary for your matches?</span>
<span class="comment-copy">what is the striking difference between 'title' pattern and some other thing you want to omit?</span>
<span class="comment-copy">Rather than write complicated regexes, why not simply <a href="https://docs.python.org/3/library/html.html#html.unescape" rel="nofollow noreferrer"><code>unescape</code></a> it?</span>
<span class="comment-copy">One way is to use negative lookahead. <code>re.compile(r'\*Structure ((?:[^\|](?!&amp;lt;))+)')</code> although this will add a space in the <code>&amp;lt;</code> case. Seems <i>marginally</i> faster than Dmitry's regex.</span>
<span class="comment-copy">I am looking to extract the strings mentioned in the post: 'song' and 'song title'. I could certainly unescape the string, but I am working with a multi-TB file and doing additional scans of a string seems like it would be worse than a pure regex solution.</span>
<span class="comment-copy">180 steps (Regex 1) vs. 98 steps (Regex 2). I would use Regex 2 in production.</span>
<span class="comment-copy">Yes, this does what I'm looking for. I only updated to allow for variable numbers of spaces, since they are not fixed.</span>
<span class="comment-copy">Well, if there is always at least 1 space, you just need to add a <code>+</code> quantifier: <code>\*Structure\s+(.*?)(?=\s+(?:&amp;lt;|\|))</code> or <code>\*Structure\s+(\S+(?:\s+(?!&amp;lt;|\|)\S+)*)</code>. Also, just in case you have a multiline input, you need to use a regular space  rather than <code>\s</code>.</span>
<span class="comment-copy"><code>\*Structure\s([^&amp;\|]*)</code> seems to work also</span>
<span class="comment-copy">@boardrider: It <a href="https://regex101.com/r/lT9dM8/1" rel="nofollow noreferrer">does not work</a> if the song has a <code>&amp;</code> symbol.</span>
<span class="comment-copy">Thanks for this, but it still breaks in the case that you have "| &amp;lt;" following the desired string.</span>
