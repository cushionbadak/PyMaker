<div class="post-text" itemprop="text">
<p>I have some paired objects linked together in a same level priority basis. They can be grouped as fixed length tuples, all have to be in a list. Some objects type are unique, other can be common).
For example, in this data structure i have an object, an object name (both unique), an object type and a bool (both common).</p>
<pre><code>[(Banana, myBanana, fruit, True),
(Water, myWater, liquid, True),
(Car, myCar, vehicle, False)]
</code></pre>
<p>Then I need to find an easy way to access to the other data knowing the unique objects. If I pick up "Banana" I'd get (myBanana, fruit, True), if I pick "myCar" I get (Car, vehicle, False). I don't need to access by the common values, they're just there to show that the data structure can have common values and they might change. The order might not be important, I used a list for simplicity.</p>
<p>Obviously, I can create 2 dictionaries using one of the unique objects each as keys, but I could actually have a more complex situation with more unique objects types and some related data (e.g. the last bool) might change, which would force me to change all the other dictionaries.
One idea could be create a class which contains separate lists for each data type, use index() for a selected "column" and return a tuple of the other list[index] values.
Is there a better/faster/nicer/more elegant and pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I tried the solution in making a class. It does work and I believe it's fairly pythonic. It uses two dicts: one where each unique is a key for the commons and one dict containing the keys. Since no one has given an answer I thought I might as well share it.</p>
<pre><code>class Foo(object):  # Didn't know how to name it.

    def __init__(self):
        self.value = dict()
        self.key = dict()

    def add(self, keys, values):
        for key in keys:
            self.value[key] = values  # Each key reference the values.
            self.key[key] = keys  # Each key reference to all the keys that reference the values.

    def remove(self, key):
        keys = self.key[key]  # Get all the keys that reference the same values as key.
        for key in keys:
            del self.key[key]  # Delete all keys associated with the key.
            del self.value[key]  # Delete all values associated with the key.

    def __getitem__(self, key):
        return self.value[key]

    def __setitem__(self, key, value):
        keys = self.key[key]  # Get all the keys that reference the same values as key.
        for key in keys:
            self.value[key] = value  # Make all the keys reference the new value.

    def __repr__(self):
        output = []
        temp = []
        for key in self.key:
            if key not in temp:
                temp.extend(self.key[key])
                output.append("{}: {}".format(self.key[key], self.value[key]))
        return "{" + ", ".join(output) + "}"
</code></pre>
<p>I tried it out and it does work as expected.</p>
<pre><code>a = Foo()
a.add(["Car", "My_car"], [0, True])

print(a["Car"])  # OUTPUT: [0, True]
print(a["My_car"])  # OUTPUT: [0, True]

a["Car"][0] = -1
print(a["Car"])  # OUTPUT: [-1, True]
print(a["My_car"])  # OUTPUT: [-1, True]

a["Car"][1] = False
print(a["Car"])  # OUTPUT: [-1, False]
print(a["My_car"])  # OUTPUT: [-1, False]

a["Car"] = [100, None]
print(a["Car"])  # OUTPUT: [100, None]
print(a["My_car"])  # OUTPUT: [100, None]

a["My_car"][0] = -1
print(a["My_car"])  # OUTPUT: [-1, None]
print(a["Car"])  # OUTPUT: [-1, None]

a["My_car"][1] = False
print(a["My_car"])  # OUTPUT: [-1, False]
print(a["Car"])  # OUTPUT: [-1, False]

a["My_car"] = [100, None]
print(a["My_car"])  # OUTPUT: [100, None]
print(a["Car"])  # OUTPUT: [100, None]

print(a)  # OUTPUT: {['Car', 'My_car']: [100, None]}
a.remove("My_car")
print(a)  # OUTPUT: {}
a.add(["Car", "My_car"], [0, True])
print(a)  # OUTPUT: {['Car', 'My_car']: [0, True]}
a.remove("Car")
print(a)  # OUTPUT: {}
</code></pre>
<p>It works for multiple keys and multiple values as well:</p>
<pre><code>a.add(["Car", "My_car"], [0, True])
a.add(["Boat", "My_boat", "Sea"], [1, False, "testing"])
a.add(["Soap", "My_soap", "Bath", "Water"], [3])

print(a["Car"])  # OUTPUT: [0, True]
print(a["My_boat"])  # OUTPUT: [1, False, 'testing']
print(a["Soap"])  # OUTPUT: [3]
print(a["Water"])  # OUTPUT: [3]
</code></pre>
<p>The problem is that it'll might use up some memory when it grows in size.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came out with three different solutions, in the meantime.</p>
<p><strong>1. Common dictionary</strong></p>
<p>The first is a common dictionary that uses <em>every</em> unique field as a key and the full group tuple transformed in a dictionary as a value. This doesn't need a class, a function returning the common dictionary is enough. That's a test function:</p>
<pre><code>def build_structure(data, indexes=(0, )):
    result = {}
    for elem in data:
        for index in indexes:
            result[elem[index]] = elem
    return result
</code></pre>
<p>Using the example list, the returned structure is like this:</p>
<pre><code>{
Banana: {key1: Banana, key2: myBanana, value1: fruit, value2: True},
myBanana: {key1: Banana, key2: myBanana, value1: fruit, value2: True},
...: {..:..},
myCar: {key1: Car, key2: myCar, value1: vehicle, value2: False},
}
</code></pre>
<p>This doesn't eat much memory when the data grows, since every value is a reference to the full group dictionary, is easy to use since I can call <code>structure['somekey']</code> and obtain directly the result and appending values is just a matter of <code>structure.update(structure_func(new_data))</code>; also the implementation is very simple, but some side effects: it returns a (obviously unordered) dictionary which contains the search key itself too, while I'd prefer to keep the insertion order without the search key, and if you have two similar keys in different key fields, the result will be overwritten.</p>
<p><strong>2. List of lists with inverted axes</strong></p>
<p>The second solution is a class that uses list of lists from the originally given data, where every embedded list actually contains the field values for each one of the group data list. A test code:</p>
<pre><code>class MyStructure(object):
    def __init__(self, data):
        self.data = [[data[i][col] for i in range(len(data))] for col in range(len(data[0]))]
    def get(self, col, data):
        index = self.data[col].index(data)
        return [self.data[c][index] for c in range(len(self.data)) if c!= col]
    def append(self, data):
        for i, v in enumerate(data):
            self.data[i].append(v)
</code></pre>
<p>Then, the final structure would be like this:</p>
<pre><code>[[Banana, Water, Car],
[myBanana, myWater, myCar],
[fruit, liquid, vehicle],
[True, True, False]]
</code></pre>
<p>The only disadvantage from the first solution (which uses a simple structure.get()) is that a search query will involve at first a list.index() for a given field, and then a data[field_id][index] for every other search field. Also, you have to know the field id for the search query.</p>
<p><strong>3. Dictionary with list reference</strong></p>
<p>The third solution is a class that uses the original list of lists and a list containing a dictionary for every key field, which has a reference to the forementioned list index. The structure would be like this:</p>
<pre><code>[{
  Banana: [Banana, myBanana, fruit, True],
  Water: [Water, myWater, liquid, True],
  [...]
 },
 {
  myBanana: [Banana, myBanana, fruit, True],
  [...]
}]
</code></pre>
<p>Again, calling search query requires the user to know the field where the search will occur: given a field id and the search key, the method will do a get for that dict and will return a list of the other field values (minus the given key). I could also create a method that would search for every search field and returns a list of possible matches.</p>
<p>This is a test class I made:</p>
<pre><code>class NewStructure(object):
    def __init__(self, data):
        self.data = data
        self.field_dicts = []
        for field in range(len(data[0])):
            self.field_dicts.append({data[index][field]:item for index, item in enumerate(data)})
    def get(self, column, value):
        return [v for i, v in enumerate(self.field_dicts[column][value]) if i!=column]
    def append(self, data):
        self.data.append(data)    
        for index, field in enumerate(self.field_dicts):    
            field[data[index]] = self.data[-1]```
</code></pre>
<p>This is actually a much more complex solution, but I think it has more advantages than the others: the original data structure doesn't ever change, even if there are similar keys for different fields; when the main data structure grows, the actual growth for the dictionaries is minimal, since they just contain a reference to the main data structure index. In the given example I used <em>every</em> field as a possible search field, adding an allowed search field index to the <code>__init__</code> might use much less memory: for example, specifying that only the first two fields can be search fields, will need only 2 reference dictionaries, not 4.</p>
<p>I suppose that one should choose the solution according to his/her case scenario. In my case I don't actually need "real time" results, and I think that I'd stick with the last solution, maybe adding dynamic method creation and requiring field names on class init, allowing something like <code>structure.get_from_key1(Banana)</code>.</p>
<p>But. I'm no programmer, I just do this for fun; so, if anyone has other ideas, I'd like to know, even if it's just to know about a different point of view. :)</p>
<p>Thanks!</p>
<p>PS: Also, if anyone has a better and clearer title for this question, I'd be happy to edit it.</p>
</div>
<span class="comment-copy">Maybe use named tuples? <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">These look like textbook Classes to me.</span>
<span class="comment-copy">@TedKleinBergman I can't use named tuples, because they're immutable: as I wrote, I could have to change the "common" values (the last bool, for example)</span>
<span class="comment-copy">@msvalkon: what do you mean?</span>
<span class="comment-copy">That's interesting, expecially about using multiple editable values, but it doesn't show the remaining keys (which is something I need). I came out with two possible solutions, in the meantime, I'll post them as a possible answer.</span>
