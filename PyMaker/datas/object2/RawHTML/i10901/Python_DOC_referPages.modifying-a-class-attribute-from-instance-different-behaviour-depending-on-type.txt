<div class="post-text" itemprop="text">
<p>If I create a class in Python and I give it a class attribute (this is taken directly from the docs, <a href="https://docs.python.org/2/tutorial/classes.html#class-and-instance-variables" rel="nofollow">here</a>), as </p>
<pre><code>class Dog:

    tricks = []            

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)
</code></pre>
<p>I see that, as the docs suggest, when doing </p>
<pre><code>d1 = Dog('d1') 
d2 = Dog('d2') 

d1.add_trick('trick') 
print d2.tricks
</code></pre>
<p>I get that the trick is added to d2 as well:</p>
<pre><code>['trick']
</code></pre>
<p>This is because <code>tricks</code> is a class attribute rather than an instance attribute so gets shared across all instances (correct me if this is not orthodox!).</p>
<p>Now, suppose I do this instead</p>
<pre><code>class Dog:

    a = 1

    def __init__(self, name):
        self.name = name

    def improve_a(self):
        self.a += 1
</code></pre>
<p>and I run </p>
<pre><code>d1 = Dog('d1') 
d2 = Dog('d2') 

d1.improve_a() 
print d1.a, d2.a
</code></pre>
<p>this gives me 2 and 1 respectively, namely the count for the second instance has not changed. Why is this, why the behaviour difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>int</code> class does not define the += operator (<code>__iadd__</code> method). That wouldn't make sense because it is immutable.</p>
<p>That's why <code>+=</code> defaults to <code>+</code> and then <code>=</code>. <a href="https://docs.python.org/3/reference/datamodel.html#object.__iadd__" rel="nofollow">reference</a></p>
<p><code>self.a += 1</code> becomes <code>self.a = self.a + 1</code></p>
<p>Now the first time you call <code>improve_a</code> the following happens:</p>
<ol>
<li>read class attribute <code>a</code> and put it on the stack</li>
<li>add <code>1</code> to the item on the stack</li>
<li><strong>create a new instance attribute <code>a</code></strong> and assign it the value on the stack</li>
</ol>
<p>That means the class attribute is <strong>not changed at all</strong> and you add a new instance attribute.</p>
<p>On every subsequent call of <code>improve</code> on the same object the instance attribute is incremented, because attribute lookup starts on the instance dict and will only go to the class dict if that attribute does not exist.</p>
<p>If you do the same with a mutable class which overloads the <code>__iadd__</code> method you can get different behaviour:</p>
<pre><code>class HasList:
    some_list = []

    def add_something(self, value):
        some_list += [value]

fst = HasList()
sec = HasList()

fst.add_something(1)
fst.add_something(2)
sec.add_something(3)

print(HasList.some_list, fst.some_list, sec.some_list)
</code></pre>
<p>You will see that all instances and the class itself still hold the same list. The print shows the same list <code>[1, 2, 3]</code> each time. You can also check that all three lists are identical: <code>fst.some_list is sec.some_list and fst.some_list is HasList.some_list  # -&gt; True</code>.</p>
<p>That is because <code>list.__iadd__</code> just calls <code>list.extend</code> and returns itself inside the method (at least if it was written in python).</p>
</div>
<span class="comment-copy"><code>self.a += 1</code> really executes as <code>self.a = self.a + 1</code>...</span>
<span class="comment-copy">Because in one case you're mutating a mutable class attribute, shared by all instances (<a href="http://stackoverflow.com/q/1680528/3001761">stackoverflow.com/q/1680528/3001761</a>), in the other you're shadowing an immutable class attribute with an immutable instance attribute. They're really not the same situation. <i>"different behaviour depending on type"</i> is exactly what you <b>should</b> expect, otherwise things in OOP would be very boring indeed!</span>
