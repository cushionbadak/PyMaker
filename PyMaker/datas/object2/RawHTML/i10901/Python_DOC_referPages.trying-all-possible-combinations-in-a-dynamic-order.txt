<div class="post-text" itemprop="text">
<p>Basically I'm looking for an implementation of <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> that allows me to change the order in which the combinations are generated.</p>
<p>Example: If I use <code>itertools.product('AB', 'xy')</code> it generates the combinations in this exact order:</p>
<pre><code>[('A', 'x'), ('A', 'y'), ('B', 'x'), ('B', 'y')]
</code></pre>
<p>I need an implementation that responds to requests like "Please change A to B next", for example like this:</p>
<pre><code>&gt;&gt;&gt; generator = DynamicOrderProduct({'var1': 'AB', 'var2': 'xy'})
&gt;&gt;&gt; generator.first()
{'var1': 'A', 'var2': 'x'}
&gt;&gt;&gt; generator.change('var1')
{'var1': 'B', 'var2': 'x'}
&gt;&gt;&gt; generator.change('var2')
{'var1': 'B', 'var2':, 'y'}
&gt;&gt;&gt; generator.change('var2') # here it can't generate a new combination by
                             # changing var2, so it changes var1 instead
{'var1': 'A', 'var2': 'y'}
&gt;&gt;&gt; generator.change('var2')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<hr/>
<p>Ideally, the generator would accept a list of variables like this:</p>
<pre><code>generator.change(['var1', 'var2'])
</code></pre>
<p>It should then attempt to change the value of <code>var1</code>, and if that isn't possible, change the value of <code>var2</code> instead, and so on.</p>
<hr/>
<p>How would I go about implementing this? Is there something in the standard lib that can help me?</p>
</div>
<div class="post-text" itemprop="text">
<p>Alright, I've managed to write an iterator that does what I want. It's the ugliest piece of code I've ever written, but it gets the job done.</p>
<p>I'm still hoping for a better solution though - this implementation keeps a set of all returned combinations, which can grow to use quite a bit of memory.</p>
<pre><code>class DynamicOrderProduct:
    """
    Given a dict of {variable: [value1,value2,value3,...]}, allows iterating
      over the cartesian product of all variable values.
    Each step in the iteration returns a mapping of {variable: value}.
    To start the iteration, retrieve the first mapping by calling .first().
    To retrieve subsequent mappings, call
      .next(order_in_which_to_change_variable_values). This function's
      parameter should be a list of variables sorted by which variable's value
      should change next. If possible, the first variable in the list will
      change value. If not, the 2nd variable in the list will change value
      instead, and so on. Raises StopIteration if all combinations are
      exhausted.

    Example:

        possible_values = {'B': [0,1], # B can take the value 0 or the value 1
                           'L': [1,2,3]}
        iterator = DynamicOrderProduct(possible_values)
        print(iterator.first())

        import random
        variables = list(possible_values.keys())
        while True:
            order = random.sample(variables, len(variables))
            print('advancing variables in this order:', order)
            try:
                print(iterator.next(order))
            except StopIteration:
                break

    You may also pass an incomplete list of variables to the .next function.
    If no new combination of the given variables is possible, StopIteration is
      raised. For example:

        iterator = DynamicOrderProduct({var1: [1],
                                        var2: [1,2]})
        iterator.first() # this returns {var1: 1, var2: 1}
        iterator.next([var1]) # raises StopIteration

    Also, you may pass multiple lists to .next in order to change the value of
      multiple variables. StopIteration will be raised only if no variable can
      change value.

        iterator = DynamicOrderProduct({var1: [1,2],
                                        var2: [1,2]})
        iterator.first() # this returns {var1: 1, var2: 1}
        iterator.next([var1], [var2]) # returns {var1: 2, var2: 2}
    """
    def __init__(self, possible_variable_values):
        self.possible_variable_values = {k:tuple(v) for k,v in \
                                        possible_variable_values.items()}
        self.variable_order = list(possible_variable_values)
        self.exhausted_combinations = set()

    def first(self):
        self.mapping = {var:vals[0] for var,vals in \
                       self.possible_variable_values.items()}
        t = tuple(self.mapping[var] for var in self.variable_order)
        self.exhausted_combinations.add(t)
        return self.mapping

    def next(self, *orders):
        def advance(order, index, maxindex=2147483648):
            while True: # loop to reduce recursion
                try:
                    variable = order[index]
                except IndexError:
                    raise StopIteration

                value = self.mapping[variable]
                valindex = self.possible_variable_values[variable].index(value)
                start_index = valindex
                while True: # change the value until we find a new combination
                    valindex += 1
                    try:
                        possible_values = self.possible_variable_values
                        value = possible_values[variable][valindex]
                    except IndexError:
                        valindex = 0
                        value = self.possible_variable_values[variable][0]
                    self.mapping[variable] = value

                    # if we've tried all values but none of them
                    # worked, try to change the next variable's
                    # value instead
                    if valindex == start_index:
                        if index+1 &gt;= maxindex:
                            raise StopIteration
                        # instead of recursing, update our own parameters and
                        # start a new iteration
                        index += 1
                        break

                    t = tuple(self.mapping[var] for var in self.variable_order)
                    # if this combination isn't new, try
                    # changing the previous variables' values
                    if t in self.exhausted_combinations:
                        if index == 0:
                            continue
                        try:
                            return advance(order, 0, index)
                        except StopIteration:
                            continue
                    return t

        total_order = []
        fail = True
        for order in orders:
            # each iteration may also change the previous
            # iterations' variables
            total_order = order + total_order
            try:
                t = advance(total_order, 0)
            except StopIteration:
                fail = True
            else:
                fail = False
        if fail:
            raise StopIteration

        self.exhausted_combinations.add(t)
        return self.mapping
</code></pre>
</div>
