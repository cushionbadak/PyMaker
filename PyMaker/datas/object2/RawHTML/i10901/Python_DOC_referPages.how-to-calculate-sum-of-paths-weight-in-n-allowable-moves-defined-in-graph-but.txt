<div class="post-text" itemprop="text">
<pre><code>gr = {'0': {'4': 4, '6': 6},
      '4': {'3': 7, '9': 13, '0':4},
      '6': {'1': 7, '7':13,'0':6},
      '3': {'4': 7, '8': 11},
      '9': {'4': 13, '2': 11},
      '1': {'6': 7, '8': 9},
      '7': {'2': 9, '6': 13},
      '8': {'1': 9, '3': 11},
      '2': {'9': 11, '7': 9}}
</code></pre>
<p>This is the graph, I have made for the allowable moves and defined the weights in moves as I need to calculate sum of the weight of the path after certain number of moves(n) starting from '0'. The path can be random but from within those paths defined in graph, given the destination is not defined.</p>
<p>I have tried the functions like this where the parameters given are starting and ending point. This works to find the path and calculate the weight traveled. But I need to be able to have the parameters as starting point and the number of moves but not the destination and find the sum of path's weight. Also the nodes can be visited as many number of times. Please help me to edit this function or may be my approach should be different.</p>
<pre><code>def paths(gr, frm, to, path_len = 0, visited = None):
   if frm == to:
        return [[to, path_len]]

   visited = visited or []
   result = []
   for point, length in gr[frm].items():
       if point in visited:
           continue
       visited.append(point)
       for sub_path in paths(gr, point, to, path_len + length, visited[:]):
           result.append([frm] + sub_path)

   return result

print (paths(gr, '0', '9'))
</code></pre>
<p>My Desired Output is:</p>
<pre><code>Path: 0-&gt;4-&gt;3-&gt;8&gt;1-&gt;6-&gt;7-&gt;2-&gt;9-&gt;4, Sum: 44

Path: 0-&gt;6-&gt;7-&gt;2-&gt;9-&gt;4-&gt;3-&gt;8-&gt;1-&gt;6, Sum: 46
</code></pre>
<hr/>
<p>From the <a href="https://stackoverflow.com/questions/38419011/how-to-calculate-sum-of-paths-weight-in-n-allowable-moves-defined-in-graph-but/38422175#comment64253343_38422175">comments</a>:</p>
<p>The problem statement is "It chooses amongst the allowable moves uniformly at random and keeps track of the running sum S of nodes on which it lands." So my problem is to find the sum S of all the nodes on which it lands in K moves.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a diagram of the graph that I created using some Python code and Graphviz. </p>
<p><img alt="graph diagram" src="https://i.stack.imgur.com/x7mkN.png"/></p>
<p>In the code you posted you have a <code>visited</code> list. The purpose of that list is to prevent a node from being visited more than once. However, you aren't adding the initial <code>frm</code> node to the <code>visited</code> list, so that node can get visited twice. Here's a repaired version:</p>
<pre><code>gr = {
    '0': {'4': 4, '6': 6},
    '4': {'3': 7, '9': 13, '0': 4},
    '6': {'1': 7, '7':13, '0': 6},
    '3': {'4': 7, '8': 11},
    '9': {'4': 13, '2': 11},
    '1': {'6': 7, '8': 9},
    '7': {'2': 9, '6': 13},
    '8': {'1': 9, '3': 11},
    '2': {'9': 11, '7': 9},
}

def paths(gr, frm, to, path_len=0, visited=None):
    if frm == to:
        return [[to, path_len]]

    visited = visited or [frm]
    result = []
    for point, length in gr[frm].items():
        if point in visited:
            continue
        for sub_path in paths(gr, point, to, path_len + length, visited + [point]):
            result.append([frm] + sub_path)

    return result

# Test
frm, to = '2', '8'
for p in paths(gr, frm, to):
    print(p)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['2', '9', '4', '0', '6', '1', '8', 50]
['2', '9', '4', '3', '8', 42]
['2', '7', '6', '0', '4', '3', '8', 50]
['2', '7', '6', '1', '8', 38]
</code></pre>
<p>As Antti mentioned in the comments, it's better to do this using a generator which yields paths as it finds them, rather than saving all the results in a big list that gets returned at the end. And we can make the "visited" test more efficient by using a set instead of a list:</p>
<pre><code>def paths(gr, frm, to, path_len=0, visited=None):
    if frm == to:
        yield [to, path_len]
        return

    visited = visited or {frm}
    for point, length in gr[frm].items():
        if point in visited:
            continue
        for sub_path in paths(gr, point, to, path_len + length, visited | {point}):
            yield [frm] + sub_path
</code></pre>
<hr/>
<p>We can use a similar approach to generate all the paths of a fixed length from a given starting node.</p>
<pre><code>gr = {
    '0': {'4': 4, '6': 6},
    '4': {'3': 7, '9': 13, '0': 4},
    '6': {'1': 7, '7':13, '0': 6},
    '3': {'4': 7, '8': 11},
    '9': {'4': 13, '2': 11},
    '1': {'6': 7, '8': 9},
    '7': {'2': 9, '6': 13},
    '8': {'1': 9, '3': 11},
    '2': {'9': 11, '7': 9},
}

def paths_by_length(gr, frm, steps, path_len=0, path=None):
    if steps == 0:
        yield path, path_len
        return

    path = path or [frm]
    steps -= 1
    for point, weight in gr[frm].items():
        new_path = path + [point]
        new_len = path_len + weight
        for sub_path, sub_length in paths_by_length(gr, point, steps, new_len, new_path):
            yield sub_path, sub_length

frm = '0'
steps = 3
for path, path_len in paths_by_length(gr, frm, steps):
    print(path, path_len)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['0', '4', '9', '2'] 28
['0', '4', '9', '4'] 30
['0', '4', '0', '4'] 12
['0', '4', '0', '6'] 14
['0', '4', '3', '4'] 18
['0', '4', '3', '8'] 22
['0', '6', '7', '2'] 28
['0', '6', '7', '6'] 32
['0', '6', '1', '8'] 22
['0', '6', '1', '6'] 20
['0', '6', '0', '4'] 16
['0', '6', '0', '6'] 18
</code></pre>
<hr/>
<p>Because your graph has such a simple structure, and the edge weights conform to <code>weight = frm + to</code> there's probably a more efficient way to do this. Also, you could simplify <code>gr</code> in various ways, eg you could use integers instead of strings for the node names, which would allow <code>gr</code> to be a list or tuple instead of a <code>dict</code>, and instead of each node having a <code>dict</code> of (node, weight) pairs, each node could just be a list or tuple of the nodes it connects to, since it's so easy to calculate the edge weights.</p>
<hr/>
<h2>Update</h2>
<p>Your actual problem is <em>much</em> simpler than what you originally asked for.</p>
<p>We don't need to use recursion for this, we can just use a simple <code>for</code> loop which calls the <code>choice</code> function from the <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer"><code>random</code> module</a> to choose moves uniformly at random.</p>
<pre><code>from random import choice, seed

gr = (
    (4, 6), # 0
    (6, 8), # 1
    (7, 9), # 2
    (4, 8), # 3
    (0, 3, 9), # 4
    (), # 5
    (0, 1, 7), # 6
    (2, 6), # 7
    (1, 3), # 8
    (2, 4), # 9
)

# Seed the randomizer
seed(42)

def random_path(gr, node, steps):
    path = [node]
    for i in range(steps):
        node = choice(gr[node])
        path.append(node)
    return path

# Test

frm = 0
steps = 3
for i in range(10):
    path = random_path(gr, frm, steps)
    print(path, sum(path))
print()

# Find the mean score of a number of paths
steps = 1024
num = 10000
total = 0
for i in range(num):
    path = random_path(gr, frm, steps)
    total += sum(path)
print('Steps: {}, Trials: {}, Mean: {}'.format(steps, num, total / num))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[0, 4, 0, 6] 10
[0, 4, 0, 4] 8
[0, 4, 9, 2] 15
[0, 6, 0, 4] 10
[0, 4, 0, 4] 8
[0, 4, 9, 2] 15
[0, 6, 0, 6] 12
[0, 6, 0, 4] 10
[0, 6, 1, 8] 15
[0, 4, 0, 6] 10

Steps: 1024, Trials: 10000, Mean: 4607.2152
</code></pre>
<p>If you don't need the actual paths, just the node sums, this function can be simplified even further, but that will be left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you need only the sum, the solution is much easier.</p>
<p>Start with a dictionary with only <code>{start_node: 0}</code>; this is your starting position. </p>
<p>For a new position after a move:</p>
<ul>
<li><p>make a <em>new</em> empty <code>defaultdict(int)</code>. </p></li>
<li><p>then for for each <code>(node, weight_sum)</code> pair in your current position</p>
<ul>
<li><p>find the each <code>(new_node, new_weight)</code> connected to <code>node</code></p></li>
<li><p>add the sum of <code>weight_sum + new_weight</code> to the value of key <code>new_node</code> in the new dictionary. </p></li>
</ul></li>
</ul>
<p>Repeat these steps until you've done all K moves. The time complexity for this algorithm is O(N<em>M</em>K) where N is number of nodes, M is number of connections between pair of nodes, K is the number of moves.</p>
</div>
<span class="comment-copy">must the number of moves be exact? Or if you have 3 moves and start from one node you can just spend 1 move to move to another node and stay there?</span>
<span class="comment-copy">Also, it is probably easier to just let the code to return a generator. Are you using Python 3?</span>
<span class="comment-copy">yes, the number of moves will be sent through the parameter, For example the desired output is shown for 10 random moves. I am using python 3.5.2. The path I am showing is only to make sure whether the moves are correct. I just need the sum with the given number of moves as output and not the path.</span>
<span class="comment-copy">1) You say: "the nodes can be visited as many number of times". Is that a bug, or do you really want a node to be visited only once per path? 2) In the function that finds the total path weight for a given number of moves do you want all possible solutions or just the minimum solutions?</span>
<span class="comment-copy">Also, is that graph data fixed, or will you need to handle other graphs? And if you <i>do</i> want to use other graphs will they also have the property that <code>edge_weight = to + from</code>?</span>
<span class="comment-copy">Thank you so much for the detailed explanation so far. The last set of code you have posted matches very close to my requirement but there is one problem that I tried but could not solve is the sum, the sum is not matching. I think the nodes are adding their weights for twice. For example ['0','6','0','6'] should sum 12. But this is yielding as 0+6=6,6+6=12,12+0=12,12+6=18. Please help me to fix this and its done :P</span>
<span class="comment-copy">@pari: We have 3 steps in <code>['0','6','0','6']</code>: <code>0-6</code> + <code>6-0</code> + <code>0-6</code>, and each of those steps has a weight of 6, so the total <i>should</i> be 18. If you want to get a total of 12 for <code>['0','6','0','6']</code> what total do you expect for <code>['0', '6', '1', '8']</code>? Is it 22 like my code calculates, or do you want something else, eg 15?</span>
<span class="comment-copy">may be I explained it wrong for the weights approach.The problem statement is " It chooses amongst the allowable moves uniformly at random and keeps track of the running sum S of nodes on which it lands." So my problem is to find the sum S of all the nodes on which it lands in K moves.</span>
<span class="comment-copy">['0', '6', '1', '8'] should be 15 instead of 22</span>
<span class="comment-copy">@pari: That's <i>much</i> simpler; we don't need the edge weights at all. But I won't write any more code now; it's 3:30AM here. I'll take a look at it tomorrow. And maybe in the meantime you can figure out the changes required for yourself...</span>
<span class="comment-copy">thank you for the algorithm but I am still not sure to implement this, do you mean to have a for loop until K moves for the paths function above and how will I omit the "to" parameter in the function as this "to" is not fixed. Please help me to implement this</span>
