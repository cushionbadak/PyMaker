<div class="post-text" itemprop="text">
<p>I have the following piece of code in Python, it is organizing(grouping) playing cards by their ranks. I did this in old-school way but I am sure there is a better way as Python is actually famous of that kind of thing.
How can I do the same in shorter and more elegant way?</p>
<p>Here is the method code:</p>
<pre><code>def gatherRanks(self, hand):
        self.value1 = []
        self.value2 = []
        self.value3 = []
        self.value4 = []

        card1 = hand.cards[0]
        self.value1.append(card1)

        card2 = hand.cards[1]
        if card2.rank == card1.rank:
            self.value1.append(card2)
        else:
            self.value2.append(card2)

        card3 = hand.cards[2]
        if card3.rank == card1.rank:
            self.value1.append(card3)
        elif card3.rank == card2.rank:
            self.value2.append(card3)
        else:
            self.value3.append(card3)

        card4 = hand.cards[3]
        if card4.rank == card1.rank:
            self.value1.append(card4)
        elif card4.rank == card2.rank:
            self.value2.append(card4)
        elif card4.rank == card3.rank:
            self.value3.append(card4)
        else:
            self.value4.append(card4)

        card5 = hand.cards[4]
        if card5.rank == card1.rank:
            self.value1.append(card5)
        elif card5.rank == card2.rank:
            self.value2.append(card5)
        elif card5.rank == card3.rank:
            self.value3.append(card5)
        elif card5.rank == card4.rank:
            self.value4.append(card5)
</code></pre>
<p>The idea behind that method is to group cards by their RANKs (not suits). I also decided to have 4 self variables because it is  easier to use than the list. 
The reason is quite simple: figuring out the hands later on. 
Having cards grouped by ranks I can then easily check the figure, for instance:</p>
<pre><code>#(checking if hand is a Trip)
def isThreeOfKind(self, hand):
        self.gatherRanks(hand)
        return len(self.value1)==3 or len(self.value2)==3 or len(self.value3)==3
</code></pre>
<p>and so on, every check is a matter of 1 - 3 lines of code (except Straight which requires loop).</p>
</div>
<div class="post-text" itemprop="text">
<p>Real improvement is only possible here if you get rid of your <code>self.value1</code>, <code>self.value2</code>, etc. lists. Whenever you see yourself creating variables like that, you should be using a list instead.</p>
<p>The following code does what you want (I omitted the <code>self</code> because it's not relevant to the code):</p>
<pre><code>def gather(hand):
    values= []

    for card in hand.cards:
        #for each card, check if a list containing cards of the same rank already exists
        for card_list in values:
            if card_list[0].rank==card.rank:
                #found one, add the card to this list
                card_list.append(card)
                break
        else:#if no list with the same rank exists, create one
            values.append([card])

    #and if you insist on having your 4 lists:
    values1= values[0] if len(values)&gt;0 else []
    values2= values[1] if len(values)&gt;1 else []
    values3= values[2] if len(values)&gt;2 else []
    values4= values[3] if len(values)&gt;3 else []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a>
<ul>
<li><code>gather_ranks</code> instead of <code>gatherRanks</code></li>
<li>Indent using 4 spaces instead of 8</li>
</ul></li>
<li>Use lists / dicts and for loops to make it more compact and thus more readable (and less prone to make an error)</li>
<li>Add a docstring (I like <a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt" rel="nofollow">Numpydoc</a>)</li>
</ul>
<p>So here is the adjusted code:</p>
<pre><code>def gather_ranks(self, hand):
    self.value = []
    for i in range(4):
        self.value.append([])

    # The first card always goes to the first hand
    self.value[0].append(hand.cards[0])

    # Go through the next cards. Foreach card, check
    # if the first hands card(s) has / have the same value.
    # If so, add it there. Otherwiese go to the next hand.
    # If none had the same, add it to the next players hand.
    for card_index in [1, 2, 3, 4]:
        for i in range(card_index):
            if hand.cards[card_index].rank == hand.cards[i].rank:
                self.value[i].append(hand.cards[card_index])
                break
        else:
            # loop fell through without break
            # Card was not added to any player
            if card_index &lt; 5:
                self.value[card_index].append(hand.cards[card_index])
</code></pre>
<p>Of course, I can't make really good comments as I don't know what the meaning behind this is. You should replace this by whatever makes sense in this game.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like the number of ranks is pre-determined, judging from the use of variables self.value1 to self.value4.</p>
<p>If that is in fact the case, dictionary could come in handy.</p>
<pre><code>def gather_ranks(self, hand):
    # initialize the dictionary with card ranks
    # r1...r4 represents card ranks
    self.ranked_cards = {"r1": [], "r2": [], "r3": [], "r4": []}

    for card in hand.cards:
        self.ranked_cards[card.rank].append(card)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(Edited example)</p>
<p>I would use a <a href="https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict" rel="nofollow">defaultdict</a>:</p>
<pre><code>from collections import defaultdict
from pprint import pprint
import itertools
import random


class Card(object):
    def __init__(self, rank_color):
        self.rank, self.color = rank_color
    def __repr__(self):
        return '{} of {}'.format(self.rank, self.color)

class Hand(object):
    def __init__(self):
        self.cards = []
        self.gathered_ranks = defaultdict(list)
    def add_card(self, card):
        self.cards.append(card)
        self.gathered_ranks[card.rank].append(card)
    def get_gathered_ranks(self):
        return dict(self.gathered_ranks)

if __name__ == '__main__':
    hand = Hand()

    colors = ['spade', 'club', 'heart', 'diamond']
    ranks = range(1, 15)
    deck = [e for e in itertools.product(ranks, colors)]
    random.shuffle(deck)
    # We suppose players have 5 random cards
    for i in range(5):
        card = deck.pop()
        hand.add_card(Card(card))
    pprint(hand.get_gathered_ranks())
</code></pre>
</div>
<span class="comment-copy">If your current version is working and you simply want to improve it, <code>CodeReview</code> is the place for you. <a href="http://codereview.stackexchange.com/">codereview.stackexchange.com</a></span>
<span class="comment-copy">If the rank of card5 doesn't match the rank of any other card, it won't get appended to any of your 4 lists, is that intentional?</span>
<span class="comment-copy">Following on from Rawing's comment, I suspect you should be grouping cards by their suit instead of their rank. And yes, there are more efficient ways to do that sort of thing.</span>
<span class="comment-copy">I'm voting to close this question as off-topic because it belongs to <a href="http://codereview.stackexchange.com/">codereview.stackexchange.com</a></span>
<span class="comment-copy">I can't understand the inner loop actually so it's hard to comment. Your code generally works but unfortunately doesn't gather anything, the final values variable is always empty.</span>
<span class="comment-copy">@smoczyna This code definitely works, I've created a <code>Card</code> and <code>Hand</code> class just to test it. Maybe you're looking at the <code>self.values</code> variable instead of <code>values</code>? In the line <code>if card_list[0].rank==card.rank</code>, <code>card_list</code> is a list of cards with the same rank and so if <code>card.rank</code> is the same, it'll also be added to that list.</span>
<span class="comment-copy">The only way <code>values</code> could possibly be empty is if <code>hand.cards</code> is also empty or doesn't allow iteration with a <code>for...in</code> loop.</span>
<span class="comment-copy">my apologies, I wasn't careful enough, your code is actually the thing I was looking for</span>
<span class="comment-copy">For what it's worth, OP's code was more readable than this.</span>
<span class="comment-copy">@Rawing I've made a few edits. Do you still think so?</span>
<span class="comment-copy">Yes, definitely. In fact your code is so hard to read that you didn't notice that it raises an IndexError.</span>
<span class="comment-copy">I agree, your code is really hard to understand and it doesn't work at all. In terms of other remarks, I don't care about style and coding standards because I have that comfort to use my own rules. It is also insignificant here.</span>
<span class="comment-copy">It is actually not, since it is Poker Game there are 5 cards and each of them has its rank (value) and suit (colour). The goal is to group cards by their ranks to make further estimations easily (chec kmy updated post above). So to gather ranks they need to be compared to each other.</span>
<span class="comment-copy">I think you missed the point, the whole idea here is to group card by their values (ranks) and all cards are already shuffled. I mean all player hands has been served already and each has 5 cards.</span>
<span class="comment-copy">@smoczyna the keys of the dict returned by <code>gatherRanks</code> are the ranks, the values are the list of cards with the corresponding rank. The lines in the <code>if __name__ == '__main__':</code> are just here to test the function.</span>
<span class="comment-copy">@smoczyna I changed the example: cards are gathered by rank each time they are added</span>
