<div class="post-text" itemprop="text">
<p><strong>DJANGO APP</strong></p>
<p>I have interface for sending e-mail in Django:</p>
<pre><code>from my_app.utils import com

com.mail.email_category1(subject, template, ...)
...
com.mail.email_category2(subject, template, ...)
</code></pre>
<p>I have also another interafces for ie. for SMS:</p>
<pre><code>com.sms.sms_category1(template, ...)
</code></pre>
<p>In <code>my_app.utils.com</code> there are functions defined:</p>
<pre><code># my_app.utils.com
mail = CommunicationMail()
sms = CommunicationSms()
...
</code></pre>
<p>and categories are methods of above classes.</p>
<p><strong>QUESTION</strong></p>
<p>Is it possible to call new instance of <code>CommunicationMail</code> every time I call <code>com.mail.email_category...</code>? The problem is that it is the same object instance every call, so ie. when running in parallel as a task, they share properties and overlaps.</p>
</div>
<div class="post-text" itemprop="text">
<p>This would be the recommended structure:</p>
<pre><code>from my_app.utils import com
com.Mail().email_category1(template, ...)
</code></pre>
<p>where <code>my_app.utils.com</code> is:</p>
<pre><code>Mail = CommunicationMail
</code></pre>
<hr/>
<p>If you <em>really</em> wanted to keep the <code>com.mail.email_category1</code> notation, Python would let you, of course, being the dynamic language that it is 
(<a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow"><code>__getattr__</code> documentation</a>):</p>
<pre><code># my_app.utils.com

class CommunicationMailFactory:
    def __getattr__(self, name):
        instance = CommunicationMail()
        return getattr(instance, name)

mail = CommunicationMailFactory()
</code></pre>
<hr/>
<p><strong>But use the first method!</strong> “Why,” you ask.</p>
<p>For one, it is makes it clear what you are doing: You are instantiating a new instance and calling a method. This is not clear with the <code>__getattr__</code> hackery.</p>
<p>Second, you can assign the freshly instantiated instance to a variable <code>mail1</code> and then call <code>mail1.email_category1(subject, template, ...)</code> or whatever. You have no such normal, expected flexibility with the <code>__getattr__</code> hackery.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python modules are singleton, so it will only import it once, so <code>mail = CommunicationMail()</code> is executed once.</p>
<p>you can:</p>
<pre><code>from my_app.utils import com

com.CommunicationSms().sms_category1(template, ...)
</code></pre>
</div>
<span class="comment-copy">Not nearly enough information here. You should show the definition of CommunicationMail, and exactly where you are calling it.</span>
<span class="comment-copy">@DanielRoseman: I call <code>CommunicationMail</code> every time I call <code>com.mail....</code>, because <code>mail</code> is variable in <code>com</code> module, and <code>mail = CommunicationMail()</code></span>
<span class="comment-copy">Well, those two things don't follow from each other at all. If you've already defined <code>mail</code> as an instance of CommunicationMail, then you are not calling CommunicationMail every time you refer to <code>mail</code>, you will just get the same instance. So, don't do that.</span>
<span class="comment-copy">Ok, so how to define modules/variables/classes so as to be able to send mails by calling "com.mail.xxx()", "com.mail.yyy()"? It is very convenient notation style and I use it in my entire application. Works great except from overlapping issue when many tasks run in parallel.</span>
<span class="comment-copy">Well those desires are incompatible. You can define instances at module level so they can be referenced from outside, but they can't keep any state otherwise you will see the issues you have. You need to choose one thing or the other.</span>
