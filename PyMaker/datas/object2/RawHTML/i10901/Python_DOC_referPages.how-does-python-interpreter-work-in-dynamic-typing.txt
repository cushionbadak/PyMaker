<div class="post-text" itemprop="text">
<p>I read this question, but it didn't give me a clear answer:
<a href="https://stackoverflow.com/questions/25363034/how-does-python-interpreter-look-for-types">How does Python interpreter look for types?</a></p>
<p>How does python interpreter know the type of a variable? I'm not looking how do get the type. I'm here looking at what happens behind the scene. In the example below, how does it associate the class int or string to my variable.</p>
<p>How does it know that is an int:</p>
<pre><code>&gt;&gt;&gt; i = 123
&gt;&gt;&gt; type(i) 
&lt;class 'int'&gt;
</code></pre>
<p>or that string:</p>
<pre><code>&gt;&gt;&gt; i = "123"
&gt;&gt;&gt; type(i)
&lt;class 'str'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>how does it associate the class int or string to my variable</p>
</blockquote>
<p>Python doesn't. <em>Variables have no type</em>. Only the object that a variable references has a type. Variables are simply <em>names pointing to objects</em>.</p>
<p>For example, the following also shows the type of an object, but <em>no variable is involved</em>:</p>
<pre><code>&gt;&gt;&gt; type(1)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('foobar')
&lt;class 'str'&gt;
</code></pre>
<p>When you use <code>type(variable)</code>, the <code>variable</code> part of the expression simply returns the object that name references, passing in the <em>object</em> to the <code>type()</code> function. When using <code>1</code> or <code>'foobar'</code>, the expression is a literal producing the object, which is then passed to the <code>type()</code> function.</p>
<p>Python objects are simply datastructures in the interpreter memory; in CPython C structs are used. Variables are merely references (pointers) to those structures. The basic type struct in CPython is called <a href="https://docs.python.org/3/c-api/structures.html#c.PyObject" rel="noreferrer"><code>PyObject</code></a>, and this struct has a <a href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" rel="noreferrer"><code>ob_type</code> slot</a> that tells Python what type something is. Types are simply <a href="https://docs.python.org/3/c-api/typeobj.html" rel="noreferrer">more C structures</a>.</p>
<p>If you wanted to follow along in the CPython source code, you'd start at the <a href="https://hg.python.org/cpython/file/v3.5.2/Python/bltinmodule.c" rel="noreferrer"><code>bltinmodule.c</code> source code</a> (since <code>type</code> is a built-in name), which <a href="https://hg.python.org/cpython/file/v3.5.2/Python/bltinmodule.c#l2710" rel="noreferrer">defines <code>type</code> as the <code>PyType_Type</code> structure</a>. Calling a <em>type</em> (<code>type</code> is a <em>type</em> too) invokes their <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new" rel="noreferrer"><code>tp_new</code> function</a>, and <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/typeobject.c#l3282" rel="noreferrer"><code>PyType_Type</code></a> <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/typeobject.c#3321" rel="noreferrer">defines that</a> as <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/typeobject.c#l2263" rel="noreferrer">the <code>type_new</code> function</a>. This function handles calls with <em>one</em> argument as follows:</p>
<pre class="lang-c prettyprint-override"><code>/* Special case: type(x) should return x-&gt;ob_type */
{
    const Py_ssize_t nargs = PyTuple_GET_SIZE(args);
    const Py_ssize_t nkwds = kwds == NULL ? 0 : PyDict_Size(kwds);

    if (PyType_CheckExact(metatype) &amp;&amp; nargs == 1 &amp;&amp; nkwds == 0) {
        PyObject *x = PyTuple_GET_ITEM(args, 0);
        Py_INCREF(Py_TYPE(x));
        return (PyObject *) Py_TYPE(x);
    }
</code></pre>
<p>Here <code>x</code> is the <code>PyObject</code> object you passed in; note, not a variable, but an object! So for your <code>1</code> integer object or <code>'foobar'</code> string object, the <code>Py_TYPE()</code> macro result is returned. <a href="https://docs.python.org/3/c-api/structures.html#c.Py_TYPE" rel="noreferrer"><code>Py_TYPE</code> is a macro</a> that simply returns the <code>ob_type</code> value of any <code>PyObject</code> struct. </p>
<p>So now you have the type object for either <code>1</code> or <code>'foobar'</code>; how come you see <code>&lt;class 'int'&gt;</code> or <code>&lt;class 'str'&gt;</code> in your interpreter session? The Python interactive interpreter automatically uses the <a href="https://docs.python.org/3/library/functions.html#repr" rel="noreferrer"><code>repr()</code> function</a> on any expression results. In the C structure for <code>PyType_Type</code> definitions the <code>PyType_Type</code> struct is incorporated so all the slots for that type are directly available; I'll omit here exactly how <em>that</em> works. For type objects, using <code>repr()</code> means the <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/typeobject.c#l843" rel="noreferrer"><code>type_repr</code> function</a> is called which returns this:</p>
<pre class="lang-c prettyprint-override"><code>rtn = PyUnicode_FromFormat("&lt;class '%s'&gt;", type-&gt;tp_name);
</code></pre>
<p>So in the end, <code>type(1)</code> gets the <code>-&gt;ob_type</code> slot, (which turns out to be the <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/longobject.c#l5178" rel="noreferrer"><code>PyLong_Type</code> struct</a> in Python 3, long story), and that structure has a <a href="https://hg.python.org/cpython/file/v3.5.2/Objects/longobject.c#l5180" rel="noreferrer"><code>tp_name</code> slot set to <code>"int"</code></a>.</p>
<p><strong>TL;DR</strong>: Python variables have no type, they are simply pointers to objects. <em>Objects</em> have types, and the Python interpreter will follow a series of indirect references to reach the type name to print if you are echoing the object in your interpreter.</p>
</div>
<div class="post-text" itemprop="text">
<p>The concept "type" of a variable is "implemented" by using objects of a specific class.</p>
<p>So in</p>
<p><code>a=float()</code></p>
<p>an object of type <code>float</code>, as defined by the class <code>float</code> is returned by <code>float()</code>.   Python knows what type it is because that's how objects work: you know what type they are.  <code>a</code> is now a <code>float</code> object, with value 0.0.</p>
<p>With builtins, it's the same, it's just that they have shorthands for declaring them.</p>
<p><code>i=123</code></p>
<p>is the same as </p>
<p><code>i=int(123)</code></p>
<p><code>int()</code> returns an object of class integer, with value 123.</p>
<p>similarly </p>
<p><code>i="123"</code></p>
<p>is the same as</p>
<p><code>i=str("123")</code></p>
<p><code>str("123")</code> returns an object of class str, with value "123"</p>
</div>
<div class="post-text" itemprop="text">
<p>Python variables have no type, they are just references to objects.  The size of a reference is the same regardless of what it is referring to.  In the C implementation of Python it is a pointer, and <em>does</em> have a type, it a pointer to a Python object: <code>PyObject *</code>.  The pointer is the same type regardless of class of object.  Objects, on the other hand, know which class they belong to. </p>
<p>It has been argued that Python has no variables, only names, although that's a step too far for most people.</p>
<p>References in the CPython implementation have an id (identifier) which is actually a virtual address.  The detail and value of this address is not worth pursuing - it can (and probably will) change between versions and is not meant to be used for anything other than a unique number identifying the object.  Nevertheless it can provide interesting pointers (pardon the pun) to what is happening:</p>
<pre><code>&gt;&gt;&gt; x = 42
&gt;&gt;&gt; y = x
&gt;&gt;&gt; id(x)
4297539264
&gt;&gt;&gt; id(y)
4297539264
</code></pre>
<p>Note that the id (address) of <code>x</code> and <code>y</code> are the same - they are referencing the same object, an <code>int</code> with the value 42.  So, what happens when we change <code>x</code>, does <code>y</code> change as well?</p>
<pre><code>&gt;&gt;&gt; x = "hello"
&gt;&gt;&gt; id(x)
4324832176
&gt;&gt;&gt; id(y)
4297539264
</code></pre>
<p>Thankfully not.  Now <code>x</code> is just referring to a new object of class <code>str</code> with the value "Hello".  </p>
<p>When we:</p>
<pre><code>&gt;&gt;&gt; id(y)
4297539264
&gt;&gt;&gt; y = 37
&gt;&gt;&gt; id(y)
4297539104 
</code></pre>
<p>The id of <code>y</code> changed!  This is because it is now referencing a different object.  <code>int</code>s are <em>immutable</em>, so the assignment <code>y = 37</code> did not change the original object (42) it created a new one.  The object with the value 42 has its reference count decremented and can now (in theory) be deleted.  In practice it would probably remain in memory for efficiency reason, but thats an implementation detail.   </p>
<p>However:</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3,4]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; id(a)
4324804808
&gt;&gt;&gt; id(b)
4324804808
&gt;&gt;&gt; a[0] = 99
&gt;&gt;&gt; b
[99, 2, 3, 4]
</code></pre>
<p>So changing the list <code>a</code> <em>has</em> changed <code>b</code>!  This is because lists are <em>mutable</em>, they can change.  The assignment <code>b = a</code> only copied the reference, not the list.  See <a href="https://docs.python.org/3.5/library/copy.html" rel="nofollow">copy</a> in the standard library.</p>
</div>
<span class="comment-copy">@GreenAsJade: The OP is using Python 3, where the representation for <code>type</code> objects uses <code>'class'</code>, not <code>'type'</code>; this was done to reflect that C-defined types are just classes too.</span>
<span class="comment-copy">@MartijnPieters maybe needs a python3 tag then?</span>
<span class="comment-copy">@GreenAsJade: no, the answer is the same in Python 2 and 3. But the output provided did not need correcting.</span>
<span class="comment-copy">Ah OK.  But the string example did :)</span>
