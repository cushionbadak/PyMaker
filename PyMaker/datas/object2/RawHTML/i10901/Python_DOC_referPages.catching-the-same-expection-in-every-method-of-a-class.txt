<div class="post-text" itemprop="text">
<p>I, a beginner, am working on a simple card-based GUI. written in Python. There is a base class that, among other things, consists a vocabulary of all the cards, like <code>_cards = {'card1_ID': card1, 'card2_ID': card2}</code>. The cards on the GUI are referenced by their unique IDs. </p>
<p>As I plan to make the code avabile for other beginners, I want to explicitly inform them if they gave a card ID that does not exists (instead of throwing a KeyError). Now I have a ton of repetitive try-expect clause that makes me suspicious:</p>
<p><em>Part of the code, one-line methods without try-catching:</em></p>
<pre><code>def shift(self, card_ID, amount):
        """Moves the card by the given amount of pixels.
            :param amount: the horizontal and vertical amount of shifting in pixels; tuple"""

        try:
            self._cards[card_ID].shift(amount)
        except KeyError:
            raise ValueError("Invaild card ID")


    def align(self, card_ID, horizontal, vertical):
        """Aligns the card to the given position."""

        try:
            card = self._cards[card_ID]
            card.align(horizontal, vertical)
        except KeyError:
            raise ValueError("Invaild card ID") 


    def invert(self, card_ID):
        """Inverts the card's colour"""

        try:
            self._cards[card_ID].invert()
        except KeyError:
            raise ValueError("Invaild card ID")
</code></pre>
<p><strong>Is this an accepted practice? Are there any better way to catch this KeyError in every method of the class?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Extract the actual getting of the card from the id into a separate method, with a try/except there, and call that method from everywhere else.</p>
<pre><code>def get_card(self, card_id):
    try:
        return self._cards[card_ID]
    except KeyError:
        raise ValueError("Invaild card ID")

def invert(self, card_id):
    return self.get_card(card_id).invert()

...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a decorator to remove some of that repetitive boiler plate.</p>
<pre><code>from functools import wraps

def replace_keyerror(func):
    """Catches KeyError and replaces it with ValueError"""

    @wraps(func)
    def inner(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except KeyError:
            raise ValueError("Invaild card ID")
    return inner
</code></pre>
<p>Then you would use it like this:</p>
<pre><code>@replace_keyerror
def align(self, card_ID, horizontal, vertical):
"""Aligns the card to the given position."""
    card = self._cards[card_ID]
    card.align(horizontal, vertical)

@replace_keyerror
def invert(self, card_ID):
    """Inverts the card's colour"""
    self._cards[card_ID].invert()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can always use a decorator function to get what you want. <a href="http://thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow">This link</a> is an excellent tutorial to learn what decorators are and how to use them. I'll give an example solution using decorators in your case. </p>
<p>Basically, you just create a function that takes a function as a parameter and returns the wrapper that does something special with it. One that might fit your solution would look like this:</p>
<pre><code>def catch_invalid_card_exception(func):
    def wrapper(*args, **kwargs):    
        try:
            return func(*args, **kwargs)
        except KeyError:
            raise ValueError("Invalid card ID") # Not "invaild" ;)
    return wrapper
</code></pre>
<p>...then you can decorate your functions/methods like this:</p>
<pre><code>@catch_invalid_card_exception
def shift(self, card_ID, amount):
    """Moves the card by the given amount of pixels.
        :param amount: the horizontal and vertical amount of shifting in pixels; tuple"""
    self._cards[card_ID].shift(amount)

@catch_invalid_card_exception
def align(self, card_ID, horizontal, vertical):
    """Aligns the card to the given position."""
    card = self._cards[card_ID]
    card.align(horizontal, vertical)

@catch_invalid_card_exception
def invert(self, card_ID):
    """Inverts the card's colour"""
    self._cards[card_ID].invert()
</code></pre>
<p>...which is really just syntactic sugar for this:</p>
<pre><code>def shift(self, card_ID, amount):
    # ...
shift = catch_invalid_card_exception(shift)

def align(self, card_ID, horizontal, vertical):
    # ...
align = catch_invalid_card_exception(align)

def invert(self, card_ID):
    # ...
invert = catch_invalid_card_exception(invert)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may consider making your cards collection into your own type of collection that can provide the customized exceptions you require. If you are using a <code>dict</code> for your cards collection, you might make your own <code>dict</code> with custom behavior like this: </p>
<pre><code>class CardsCollection(dict):
    '''A dict-like collection of cards'''
    def __getitem__(self, key):
        try:
            # first try default behavior
            super().__self__(key)
        except KeyError:
            # it didn't work! 
            raise ValueError("Invalid card ID: {!r}".format(key))
</code></pre>
<p>Now you can just do your various methods like this:</p>
<pre><code>    def align(self, card_ID, horizontal, vertical):
        """Aligns the card to the given position."""
            card = self._cards[card_ID]
            card.align(horizontal, vertical)
etc. etc. 
</code></pre>
<p>...just make sure to use your class for your <code>._cards</code> attribute. </p>
<pre><code>_cards = CardsCollection(card1_ID = card1, card2_ID = card2)
</code></pre>
<p>OR: </p>
<pre><code>_cards = CardsCollection({'card1_ID': card1, 'card2_ID': card2})
</code></pre>
<p>The nice thing about this is that your UI class is not committed to some kind of customized or unusual interface (i.e., <code>getcard()</code>) for the object holding the data. The interface here is consistent with the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python data model</a>. Therefore, if for some reason you decide that you would like to use the same UI for another object class, you have used a tried-and-true API that will translate across just about anything that has been written in a way consistent with the Python data model. </p>
</div>
<span class="comment-copy">Consider a <a href="http://thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow noreferrer">decorator</a></span>
<span class="comment-copy">An other approach will be overwrite _<i>getitem_</i> of _cards instance.</span>
<span class="comment-copy">Is there a reason you are using an object for your cards collection that raises a <code>KeyError</code> when what you want is a <code>ValueError</code>? Or alternatively, why do you want a <code>ValueError</code> in the first place? Why not just catch a <code>KeyError</code> rather than a <code>ValueError</code> at the place in your code that is making use of your class? If the issue is the custom error message, probably the best thing to do is create your own <code>CardsCollection</code> type with its own error message built-in.</span>
<span class="comment-copy">I would have named the method <code>get_card()</code> (it doesn't return a card_id does it ?)...</span>
<span class="comment-copy">@brunodesthuilliers you're right of course, updated.</span>
<span class="comment-copy">Honestly, I have no idea why I haven't thought of this... thanks!</span>
<span class="comment-copy">While it's a perfectly valid answer (and a nice-to-know feature for python newcomers) for the OP's use case I'd rather use Daniel Roseman's much more obvious solution...</span>
<span class="comment-copy">@brunodesthuilliers Agreed in both statement. I am glad to get decorators know, and any other cases I would accept this answer. I choose Daniel Rosemann's now because that's what I going to actually implememt, but I like this more.</span>
<span class="comment-copy">Thank you for the link and the explanation, they helped a lot.</span>
<span class="comment-copy">@Neinstein: If it helped, don't forget to upvote it or mark it as the answer!</span>
