<div class="post-text" itemprop="text">
<p>After reading Eli Bendersky's article <a href="http://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines/">on implementing state machines via Python coroutines</a> I wanted to...</p>
<ul>
<li>see his example run under Python3</li>
<li>and also add the appropriate type annotations for the generators</li>
</ul>
<p>I succeeded in doing the first part (<em>but without using <code>async def</code>s or <code>yield from</code>s, I basically just ported the code - so any improvements there are most welcome</em>). </p>
<p>But I need some help with the type annotations of the coroutines:</p>
<pre><code>#!/usr/bin/env python3

from typing import Callable, Generator

def unwrap_protocol(header: int=0x61,
                    footer: int=0x62,
                    dle: int=0xAB,
                    after_dle_func: Callable[[int], int]=lambda x: x,
                    target: Generator=None) -&gt; Generator:
    """ Simplified protocol unwrapping co-routine."""
    #
    # Outer loop looking for a frame header
    #
    while True:
        byte = (yield)
        frame = []  # type: List[int]

        if byte == header:
            #
            # Capture the full frame
            #
            while True:
                byte = (yield)
                if byte == footer:
                    target.send(frame)
                    break
                elif byte == dle:
                    byte = (yield)
                    frame.append(after_dle_func(byte))
                else:
                    frame.append(byte)


def frame_receiver() -&gt; Generator:
    """ A simple co-routine "sink" for receiving full frames."""
    while True:
        frame = (yield)
        print('Got frame:', ''.join('%02x' % x for x in frame))

bytestream = bytes(
    bytearray((0x70, 0x24,
               0x61, 0x99, 0xAF, 0xD1, 0x62,
               0x56, 0x62,
               0x61, 0xAB, 0xAB, 0x14, 0x62,
               0x7)))

frame_consumer = frame_receiver()
next(frame_consumer)  # Get to the yield

unwrapper = unwrap_protocol(target=frame_consumer)
next(unwrapper)  # Get to the yield

for byte in bytestream:
    unwrapper.send(byte)
</code></pre>
<p>This runs properly...</p>
<pre><code>$ ./decoder.py 
Got frame: 99afd1
Got frame: ab14
</code></pre>
<p>...and also typechecks:</p>
<pre><code>$ mypy --disallow-untyped-defs decoder.py 
$
</code></pre>
<p>But I am pretty sure I can do better than just use the <code>Generator</code> base class in the type specs (just as I did for the <code>Callable</code>). I know it takes 3 type parameters (<code>Generator[A,B,C]</code>), but I am not sure how exactly they'd be specified here.</p>
<p>Any help most welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>I figured out the answer on my own. </p>
<p>I searched, but found no documentation for the 3 type parameters of <code>Generator</code> in the <a href="https://docs.python.org/3/library/typing.html">official typing documentation for Python 3.5.2</a> - beyond a truly cryptic mention of...</p>
<pre><code>class typing.Generator(Iterator[T_co], Generic[T_co, T_contra, V_co])
</code></pre>
<p>Luckily, <a href="https://www.python.org/dev/peps/pep-0484/">the original PEP484</a> (that started all this) was far more helpful:</p>
<p><em>"The return type of generator functions can be annotated by the generic type Generator[yield_type, send_type, return_type] provided by typing.py module:</em></p>
<pre><code>def echo_round() -&gt; Generator[int, float, str]:
    res = yield
    while res:
        res = yield round(res)
    return 'OK'
</code></pre>
<p>Based on this, I was able to annotate my Generators, and saw <code>mypy</code> confirm my assignments:</p>
<pre><code>from typing import Callable, Generator

# A protocol decoder:
#
# - yields Nothing
# - expects ints to be `send` in his yield waits
# - and doesn't return anything.
ProtocolDecodingCoroutine = Generator[None, int, None]

# A frame consumer (passed as an argument to a protocol decoder):
#
# - yields Nothing
# - expects List[int] to be `send` in his waiting yields
# - and doesn't return anything.
FrameConsumerCoroutine = Generator[None, List[int], None]


def unwrap_protocol(header: int=0x61,
                    footer: int=0x62,
                    dle :int=0xAB,
                    after_dle_func: Callable[[int], int]=lambda x: x,
                    target: FrameConsumerCoroutine=None) -&gt; ProtocolDecodingCoroutine:
    ...

def frame_receiver() -&gt; FrameConsumerCoroutine:
    ...
</code></pre>
<p>I tested my assignments by e.g. swaping the order of the types - and then as expected, <code>mypy</code> complained and asked for the proper ones (as seen above).</p>
<p>The complete code <a href="https://gist.github.com/ttsiodras/fe32284ac204907249d479b4225eb83c">is accessible from here</a>. </p>
<p>I will leave the question open for a couple of days, in case anyone wants to chime in - especially in terms of using the new coroutine styles of Python 3.5 (<code>async def</code>, etc) - I would appreciate a hint on exactly how they'd be used here.</p>
</div>
<span class="comment-copy">Regarding <code>async def</code> and friends -- they currently aren't supported by mypy, but are under active development/should be ready in the near future! See <a href="https://github.com/python/mypy/pull/1808" rel="nofollow noreferrer">github.com/python/mypy/pull/1808</a> and <a href="https://github.com/python/mypy/issues/1886" rel="nofollow noreferrer">github.com/python/mypy/issues/1886</a> for more details.</span>
<span class="comment-copy">Just as an FYI, mypy 0.4.4 (which has experimental support for async/await) <a href="http://mypy-lang.blogspot.com/2016/08/mypy-044-released.html" rel="nofollow noreferrer">was just released</a>. You can find more information on typing coroutines and async/await stuff in general in the <a href="http://mypy.readthedocs.io/en/latest/kinds_of_types.html#typing-async-await" rel="nofollow noreferrer">mypy docs</a>. Currently, I don't think the docs for the typing module itself mention stuff related to async/await, but that'll probably be fixed sometime in the next few days.</span>
<span class="comment-copy">Thanks, Michael - will check it out.</span>
