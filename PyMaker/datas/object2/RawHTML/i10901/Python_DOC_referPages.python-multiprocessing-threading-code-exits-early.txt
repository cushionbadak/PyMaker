<div class="post-text" itemprop="text">
<p>I'm trying to create multiple processes which each call multiple threads.
I'm running the following code with python3.5</p>
<p>A simplified example of the problem looks like this: </p>
<pre><code>import multiprocessing
import time
import threading    

class dumb(threading.Thread):
    def __init__(self):
        super(dumb, self).__init__()
    def run(self):
        while True:
            print("hi")
            time.sleep(1)    

def test():
    for i in range(2):
        bar = dumb()
        bar.start()
def main():
    p = []
    for i in range(2):
        p.append(multiprocessing.Process(target=test))
    for i in p:
        i.start()
    for i in p:
        i.join()
if __name__ == '__main__':
    main()
</code></pre>
<p>I expect this code to print "hi" forever, but it prints exactly once for each thread in each process (4 times total). </p>
<p>When I remove the multiprocessing, the multi-threading works. </p>
<p>When I remove the multi-threading, the multiprocessing works. </p>
<p>The part that I think is the problem after I read the multiprocessing documentation:
The documentation for join states: "Block the calling thread until the process whose join() method is called terminates or until the optional timeout occurs."</p>
<p>If this was working as I expect it to, main would wait forever when trying to join.  </p>
<p>I put try/except blocks around the while loop and didn't see any errors. </p>
<p>I have tried passing the "dumb" class a queue and passing exceptions through, but the queue stays empty. </p>
<p>Any tips on how to debug this would be greatly appreciated. My best guesses are </p>
<ul>
<li><p>The thread is exiting early (print statements after while loop were never hit though)</p></li>
<li><p>Main exits and the processes are killed</p></li>
<li><p>Join is working properly, but not the way I expect it to?</p></li>
</ul>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>Resolution:  the new bug was closed as a duplicate of <a href="http://bugs.python.org/issue18966" rel="nofollow">http://bugs.python.org/issue18966</a></p>
<p>Alas, there's no simple, satisfying explanation "for why".  The cause is that <code>multiprocessing</code> arranges for worker processes to leave Python via calling <code>os._exit()</code> rather than the normal <code>sys.exit()</code>.  <code>os._exit()</code> skips all "normal" shutdown processing.  Part of what's skipped is <code>.join()</code>-ing non-daemon threads, so the process just vanishes <em>while</em> the threads are still running.</p>
<p>That should at least (according to me) be documented, or preferably changed.</p>
<p>In the meantime, the workaround - as you already know - is to explicitly <code>.join()</code> the threads yourself.</p>
<h2>ANOTHER WAY</h2>
<p>Under Python 3.4 or later, you could also use <code>multiprocessing</code>'s <code>spawn</code> start method:</p>
<p><a href="https://docs.python.org/3/library/multiprocessing.html?highlight=spawn#contexts-and-start-methods" rel="nofollow">https://docs.python.org/3/library/multiprocessing.html?highlight=spawn#contexts-and-start-methods</a></p>
<p>That causes worker processes to finish via <code>sys.exit(exitcode)</code>, which does all the normal shutdown processing (including <code>.join()</code>-ing non-daemon threads).</p>
<p><code>spawn</code> is the <em>only</em> start method available on Windows, which explains why I had no problem running your original example.</p>
</div>
<span class="comment-copy">Which OS and Python version?  I tried it just now under Python 3.5.2 (64-bit)  on Windows 10, and it worked fine (keeps printing <code>hi</code> "forever").</span>
<span class="comment-copy">I'm on Ubuntu 16.04 and python version 3.5.1+, I'll try upgrading</span>
<span class="comment-copy">Let's see whether someone on the same OS can reproduce - the code looks fine to me.  Please show the value of <code>sys.version</code> too.</span>
<span class="comment-copy">sys.version:'3.5.1+ (default, Mar 30 2016, 22:46:26) \n[GCC 5.3.1 20160330]' Thanks for the quick reply, I really appreciate it</span>
<span class="comment-copy">In case there's some screwup related to daemon threads, you could try <code>.join()</code>-ing the threads in <code>test()</code>, so that a worker process doesn't <i>try</i> to exit before the threads complete.  They "should" wait for the threads regardless, but won't if the threads are mistakenly treated as daemons.</span>
