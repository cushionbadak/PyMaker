<div class="post-text" itemprop="text">
<p>I have a string template that looks like <code>'my_index-{year}'</code>. <br/> 
I do something like  <code>string_template.format(year=year)</code> where year is some string. Result of this is some string that looks like <code>my_index-2011</code>. </p>
<p>Now. to my question. I have a string like <code>my_index-2011</code> and my template <code>'my_index-{year}'</code> What might be a slick way to extract the <code>{year}</code> portion? </p>
<p>[Note: I know of the existence of <a href="https://github.com/r1chardj0n3s/parse" rel="nofollow"><code>parse library</code></a>]</p>
</div>
<div class="post-text" itemprop="text">
<p>There is this module called <a href="https://pypi.python.org/pypi/parse" rel="nofollow"><code>parse</code></a> which provides an opposite to <code>format()</code> functionality:</p>
<blockquote>
<p>Parse strings using a specification based on the Python format() syntax.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from parse import parse
&gt;&gt;&gt; s = "my_index-2011"
&gt;&gt;&gt; f = "my_index-{year}"
&gt;&gt;&gt; parse(f, s)['year']
'2011'
</code></pre>
<hr/>
<p>And, an alternative option and, since you are extracting a year, would be to use the <a href="https://pypi.python.org/pypi/python-dateutil" rel="nofollow"><code>dateutil</code> parser</a> in a fuzzy mode:</p>
<pre><code>&gt;&gt;&gt; from dateutil.parser import parse
&gt;&gt;&gt; parse("my_index-2011", fuzzy=True).year
2011
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>split()</code> string function to split the string into two parts around the dash, then grab just the second part.</p>
<pre><code>mystring = "my_index-2011"
year = mystring.split("-")[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I assume "year" is 4 digits and you have multiple indexes </p>
<pre><code>import re
res = ''
patterns = [ '%s-[0-9]{4}'%index for index in idx ] 
for index,pattern in zip(idx,patterns):
    res +=' '.join( re.findall(pattern ,data) ).replace(index+'-','') + ' '
</code></pre>
<p>---update---</p>
<pre><code>dummyString = 'adsf-1234 fsfdr lkjdfaif ln ewr-1234 adsferggs sfdgrsfgadsf-3456'
dummyIdx = ['ewr','adsf']
</code></pre>
<p>output</p>
<pre><code>1234 1234 3456 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, a regex would be helpful here.  </p>
<pre><code>In [1]: import re
In [2]: s = 'my_string-2014'
In [3]: print( re.search('\d{4}', s).group(0) )
2014
</code></pre>
<p>Edit: I should have mentioned your regex can be more sophisticated.  You can haul out a subcomponent of a more specific string, for example:</p>
<pre><code>In [4]: print( re.search('my_string-(\d{4})$', s).group(1) )
2014
</code></pre>
<p>Given the problem you presented, I think any "find the year" formula should be expressible in terms of a regular expression.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You are going to want to use the <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow">string method <code>split</code></a> to split on "-", and then catch the last element as your year:</p>
<pre><code>year = "any_index-2016".split("-")[-1]
</code></pre>
<p>Because you caught the last element (using -1 as the index), your index can have hyphens in them, and you will still extract the year appropriately.</p>
</div>
<span class="comment-copy">I didn't know about the dateutil parser. Nice note. I was a little iffy about installing a new package for just this one functionality, and was wondering if there was a nifty <code>re.match(..)</code> way of doing this. But yea. Seems like I'll just stick to using the parse module. +1</span>
<span class="comment-copy">Good answer. I thought of that. Something like this would break as soon as the year became a time or the formatting changed or something of that sort. I wanted to focus on using just the template to get the year part out. If you check the link, the <a href="https://github.com/r1chardj0n3s/parse" rel="nofollow noreferrer">parse module</a> does a good job at this. I just dont want to install a new library for just this, and was wondering if there was a slick way of achieving the same result. Regardless, a +1 for you. :)</span>
<span class="comment-copy">@DebosmitRay <i>Something like this would break as soon as the year became a time</i> Why?  As long as the basic pattern remains intact (i.e. the target portion of the string comes after a dash), <code>split()</code> will continue to work just fine.  (If the target portion itself contains dashes, you can tell <code>split()</code> to only split on the <i>first</i> dash.)</span>
<span class="comment-copy">I apologize for the ambiguity. Say, I decide to replace this with 'my-index'. The template changed, but our function, having not used it, broke. Again, this is for a healthy debate to see if there is a good answer. I am pretty sure this cannot have a "correct" answer haha</span>
<span class="comment-copy">@DebosmitRay If the string template can change, I'm not sure any solution would be foolproof...</span>
<span class="comment-copy">Why do we need the for loop in this approach?</span>
<span class="comment-copy">@DebosmitRay i don't how many indexes(perfix) do you have.</span>
<span class="comment-copy">Like. I think this is a decent idea. But, its overkill to be honest. That loop with a <code>+=</code> on a string is bad for performance, as is using re.match in a loop. +1 for the answer for the effort, though.</span>
<span class="comment-copy">@DebosmitRay agree. if you have pattern for your indexes, it can also be regax. for example, if the format always like 5 letters plus "-" plus 4 digits index-1234 = &gt; pattern = r'\d{5}-\d{4}', therefore no need loop all the indexes. my first assumption is all the indexes are unique</span>
<span class="comment-copy">I like the idea behind this one. Its kind of like using the length of the 'needle' to get the result. Always enjoyed going over <a href="https://docs.python.org/3/library/re.html#simulating-scanf" rel="nofollow noreferrer">this</a>. +1</span>
<span class="comment-copy">I have already addressed this in John Gordon's answer. There are multiple ways of breaking this.</span>
<span class="comment-copy">For example. Year changed to time of the format <code>hh-mm</code></span>
