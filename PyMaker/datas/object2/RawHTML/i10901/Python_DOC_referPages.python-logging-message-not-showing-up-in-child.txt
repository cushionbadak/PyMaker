<div class="post-text" itemprop="text">
<p>I am having some difficulties using python's logging.  I have two files, main.py and mymodule.py.  Generally main.py is run, and it will import mymodule.py and use some functions from there.  But sometimes, I will run mymodule.py directly. </p>
<p>I tried to make it so that logging is configured in only 1 location, but something seems wrong.  </p>
<p>Here is the code.
</p>
<pre><code># main.py
import logging
import mymodule

logger = logging.getLogger(__name__)

def setup_logging():
    # only cofnigure logger if script is main module
    # configuring logger in multiple places is bad
    # only top-level module should configure logger
    if not len(logger.handlers):
        logger.setLevel(logging.DEBUG)
        # create console handler with a higher log level
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(levelname)s: %(asctime)s %(funcName)s(%(lineno)d) -- %(message)s', datefmt = '%Y-%m-%d %H:%M:%S')
        ch.setFormatter(formatter)
        logger.addHandler(ch)

if __name__ == '__main__':
    setup_logging()
    logger.info('calling mymodule.myfunc()')
    mymodule.myfunc()
</code></pre>
<p>and the imported module:</p>
<pre><code># mymodule.py
import logging

logger = logging.getLogger(__name__)

def myfunc():
    msg = 'myfunc is being called'
    logger.info(msg)
    print('done with myfunc')


if __name__ == '__main__':
     # only cofnigure logger if script is main module
    # configuring logger in multiple places is bad
    # only top-level module should configure logger
    if not len(logger.handlers):
        logger.setLevel(logging.DEBUG)
        # create console handler with a higher log level
        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(levelname)s: %(asctime)s %(funcName)s(%(lineno)d) -- %(message)s', datefmt = '%Y-%m-%d %H:%M:%S')
        ch.setFormatter(formatter)
        logger.addHandler(ch)
    logger.info('myfunc was executed directly')
    myfunc()
</code></pre>
<p>When I run the code, I see this output:</p>
<pre><code>$&gt;python main.py
INFO: 2016-07-14 18:13:04 &lt;module&gt;(22) -- calling mymodule.myfunc()
done with myfunc
</code></pre>
<p>But I expect to see this:</p>
<pre><code>$&gt;python main.py
INFO: 2016-07-14 18:13:04 &lt;module&gt;(22) -- calling mymodule.myfunc()
INFO: 2016-07-14 18:15:09 myfunc(8) -- myfunc is being called
done with myfunc
</code></pre>
<p>Anybody have any idea why the second logging.info call doesn't print to screen?  thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Loggers exist in a hierarchy, with a root logger (retrieved with <code>logging.getLogger()</code>, no arguments) at the top. Each logger inherits configuration from its parent, with any configuration on the logger itself overriding the inherited configuration. In this case, you are never configuring the root logger, only the module-specific logger in <code>main.py</code>. As a result, the module-specific logger in <code>mymodule.py</code> is never configured.</p>
<p>The simplest fix is probably to use <code>logging.basicConfig</code> in <code>main.py</code> to set options you want shared by <em>all</em> loggers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Chepner is correct.  I got absorbed into this problem.  The problem is simply in your main script</p>
<pre><code>16 log = logging.getLogger() # use this form to initialize the root logger
17 #log = logging.getLogger(__name__) # never use this one
</code></pre>
<p>If you use line 17, then your imported python modules will not log any messages</p>
<p>In you submodule.py</p>
<pre><code>import logging
logger = logging.getLogger()
logger.debug("You will not see this message if you use line 17 in main")
</code></pre>
<p>Hope this posting can help someone who got stuck on this problem.  </p>
</div>
<div class="post-text" itemprop="text">
<p>While the <em>logging</em>-package is conceptually arranged in a namespace hierarchy using dots as separators, <strong>all</strong> loggers implicitly inherit from the <code>root</code> logger (like every class in Python 3 silently inherits from <code>object</code>). Each logger passes log messages on to its parent.</p>
<p>In your case, your loggers are incorrectly chained. Try adding <code>print(logger.name)</code> in your both modules and you'll realize, that your instantiation of logger in <strong><em>main.py</em></strong> is equivalent to </p>
<p><code>logger = logging.getLogger('__main__')</code></p>
<p>while in <strong><em>mymodule.py</em></strong>, you effectively produce</p>
<p><code>logger = logging.getLogger('mymodule')</code></p>
<p>The call to log INFO-message from <code>myfunc()</code> passes directly the <code>root</code> logger (as the logger in <em>main.py</em> is <strong>not</strong> among its ancestors), which has <strong>no</strong> handler set up (in this case the <em>default</em> message dispatch will be triggered, see <a href="https://docs.python.org/3/howto/logging.html#advanced-logging-tutorial" rel="nofollow noreferrer">here</a>) </p>
</div>
<span class="comment-copy">Thanks, but it still doesn't seem to work.  I set logging level to INFO before I created the logger obj.  like so      logging.basicConfig(level=logging.INFO)     logger = logging.getLogger(<b>name</b>)  Then inside setup_logging, I add the ch handler, with a level of debug.   Then inside mymodule, I added a logger.debug statement.  When I call main.py, the debug message in mymodule does not show.</span>
<span class="comment-copy">I am not sure the problem is python 3.5 specific or not because I was coding in 3.5 when encountering this problem.</span>
<span class="comment-copy">This does not work for me. If I hard-code in a logger name <code>log = logging.getLogger("main_log")</code>, I can get it to work, but only for the main module. Submodules that use the same method are not showing their messages in the logs. But if I use <code>log = logging.getLogger()</code>, I do not get any messages from the main module, or its submodules.</span>
