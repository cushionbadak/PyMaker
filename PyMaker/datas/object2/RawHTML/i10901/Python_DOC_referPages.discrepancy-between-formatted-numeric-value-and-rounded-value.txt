<div class="post-text" itemprop="text">
<p>I found this weird behavior using python and numpy:</p>
<pre><code>print('%10.3f' %0.4975)
</code></pre>
<p>returns 0.497, while</p>
<pre><code>numpy.round(0.4975,3)
</code></pre>
<p>returns 0.498 as expected.
With other similar numbers I always get the print statement to deliver the correctly rounded value (for example: 0.5975 --&gt; 0.598).
Why is this?
I'm using python 3.4 and numpy 1.9.2 on windows 7.</p>
</div>
<div class="post-text" itemprop="text">
<p>In double precision, 0.4975 is 8962163258467287/18014398509481984 which is slightly <strong>less</strong> than the real number 0.4975. Hence, Python's <code>round</code> function rounds it to 0.497. </p>
<p>In contrast, 0.5975 becomes 5381801554707743/9007199254740992 which is slightly <strong>more</strong> than the real number 0.5975. So we get the expected 0.598 when rounding.</p>
<p>Why does NumPy round 0.4975 to 0.498?  Its algorithm is a bit different: to round to N digits, it multiplies the given number by the Nth power of 10, rounds to nearest integer (preferring even), and then divides by 10^N. In the process of multiplication by powers of 10, the direction of truncation changes; often one will get exactly a half-integer as a result. (Example: 0.15*10 = 1.5 which is exactly 3/2, although 0.15 is not exactly 3/20).</p>
<p>Simply put, <code>np.round(x, 3)</code>  is the same as <code>round(x*1000)/1000</code>. You can check that both return 0.498 when applied to x = 0.4975. Indeed, in double precision 0.4975*1000 is <em>exactly</em> 497.5 (that is, 995/2), and the direction of rounding is then picked correctly.</p>
<p>Here is a comparison of how 0.05, 0.15, 0.25, ... are rounded:</p>
<h3>Python</h3>
<pre><code>&gt;&gt;&gt; [round((2*i+1)/20, 1) for i in range(10)] 
[0.1, 0.1, 0.2, 0.3, 0.5, 0.6, 0.7, 0.8, 0.8, 0.9]  
</code></pre>
<h3>NumPy</h3>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.around([(2*i+1)/20 for i in range(10)], 1)
array([ 0. ,  0.2,  0.2,  0.4,  0.4,  0.6,  0.6,  0.8,  0.8,  1. ])
</code></pre>
<p>Here NumPy output is what one'd expect without thinking of binary representation.</p>
<p>However, <code>np.around([(2*i+1)/200 for i in range(100)], 2)</code> shows that NumPy's algorithm won't always match the expectation, either: there are two numbers (0.55 and 0.57) with an odd digit at the end. The problem is that, for example, 0.545*100 is not exactly 109/2; rather, it is 7670193115365377/140737488355328.</p>
</div>
<span class="comment-copy">It should have to do with the binary representation of floats in python and Numpy. Note that <code>.4975 - .497</code> results in <code>0.0005000000000000004</code> which is unequal to <code>0.0005</code>.</span>
<span class="comment-copy">and to add to that, check the comments under 'round' in this link <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#round</a></span>
<span class="comment-copy">Thanks to @Dietrich and Dan Patterson. It really has to do with the way float numbers are represented. Bizarre but true.</span>
