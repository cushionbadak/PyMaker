<div class="post-text" itemprop="text">
<p>
<strong>Preamble</strong>: I'm writing a python API against a service that delivers JSON.
The files are stored in JSON format on disk to cache the values.
The API should sport classful access to the JSON data, so IDEs and users can have a clue what (read-only) attributes there are in the object before runtime while also providing some convenience functions.</p>
<p><strong>Question</strong>: I have two possible implementations, I'd like to know which is nicer or 'pythonic'. While I like both, I am open for suggestions, if you come up with a better solution.</p>
<p><strong>First Solution: defining and inheriting JSONWrapper</strong> while nice, it is pretty verbose and repetitive.</p>
<pre class="lang-py prettyprint-override"><code>class JsonDataWrapper:
    def __init__(self, json_data):
        self._data = json_data

    def get(self, name):
        return self._data[name]


class Course(JsonDataWrapper):
    def __init__(self, data):
        super().__init__(data)
        self._users = {}  # class omitted
        self._groups = {}  # class omitted
        self._assignments = {}

    @property
    def id(self): return self.get('id')

    @property
    def name(self): return self.get('full_name')

    @property
    def short_name(self): return self.get('short_name')

    @property
    def users(self): return self._users

    @users.setter
    def users(self, data):
        users = [User(u) for u in data]
        for user in users:
            self.users[user.id] = user
            # self.groups = user  # this does not make much sense without the rest of the code (It works, but that decision will be revised :D)
</code></pre>
<p><strong>Second solution: using lambda for shorter syntax.</strong> While working and short, it does not quite look right (see edit1 below.)</p>
<pre class="lang-py prettyprint-override"><code>def json(name): return property(lambda self: self.get(name))

class Group(JsonDataWrapper):
    def __init__(self, data):
        super().__init__(data)
        self.group_members = []  # elements are of type(User). edit1, was self.members = []

    id = json('id')
    description = json('description')
    name = json('name')
    description_format = json('description_format')
</code></pre>
<p>(Naming this function 'json' is not a problem, since I don't import json there.)</p>
<p>I have a possible third solution in mind, that I cant quite wrap my head around: overriding the property builtin, so I can define a decorator that wraps the returned field name for lookup:</p>
<pre class="lang-py prettyprint-override"><code>@json  # just like a property fget
def short_name(self): return 'short_name'
</code></pre>
<p>That could be a little shorter, dunno if that makes code better.</p>
<p><strong>Disqualified solutions</strong> (IMHO):</p>
<ul>
<li>JSON{De,En}coder: kills all flexibility, provide no means of read-only attributes</li>
<li><code>__{get,set}attr__</code>: makes it impossible to determine attributes before runtime. While it whould shorten <code>self.get('id')</code> to <code>self['id']</code> it whould also further complicate matters where an attribute was not in the underlying json data.</li>
</ul>
<p>Thank you for reading!</p>
<p><strong>Edit 1: 2016-07-20T08:26Z</strong> </p>
<p>To further clarify (@SuperSaiyan) why I don't quite like the second solution:
I feel the lambda function is completely disconnected from the rest of classes semantics (which is also the reason why it is shorter :D). I think I can help myself liking it more by properly documenting the decision in the code. The first solution is easy to understand for everybody who understands the meaning of <code>@property</code> without any additional explaination.</p>
<p>On the second comment of @SuperSaiyan: Your question is, why I put <code>Group.members</code> as attribute in there? The list stores type(User) entities, might not be what you think it is, I changed the example.</p>
<p>@jwodder: I will use Code Review next time, did not know that was a thing.</p>
<p>(Also: I really think the <code>Group.members</code> threw some of you off, I edited the code to make it a little more obvious: Group members are Users that will be added to the list.</p>
<p><a href="https://github.com/manly-man/moodle-destroyer-tools/blob/7b60b57122b9eacc7d77d21debea89668c53487c/moodle/models.py" rel="nofollow">The complete code is on github</a>, while undocumented it may be interesting for somebody. Keep in mind: this is all WIP :D)</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you considered using a meta-class?</p>
<pre><code>class JsonDataWrapper(object):
    def __init__(self, json_data):
        self._data = json_data

    def get(self, name):
        return self._data[name]

class JsonDataWrapperMeta(type):
    def __init__(self, name, base, dict):
        for mbr in self.members:
            prop = property(lambda self: self.get(mbr))
            setattr(self, mbr, prop)

# You can use the metaclass inside a class block
class Group(JsonDataWrapper):
    __metaclass__ = JsonDataWrapperMeta
    members = ['id', 'description', 'name', 'description_format']

# Or more programmatically
def jsonDataFactory(name, members):
    d = {"members":members}
    return JsonDataWrapperMeta(name, (JsonDataWrapper,), d)

Course = jsonDataFactory("Course", ["id", "name", "short_name"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I myself am a newbie in python and so excuse me if I sound naive. One of the solution could be using <code>__dict__</code> as discussed in the article below:</p>
<p><a href="https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch06s02.html" rel="nofollow noreferrer">https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch06s02.html</a></p>
<p>Of course this solution will create issues if there are objects inside a class which below to other class and need to be serialized or de-serialized. I would love to hear the opinion of the experts here on this solution and different limitations.</p>
<p>Any feedback on <strong>jsonpickle</strong>.</p>
<p><strong>Update:</strong></p>
<p>I just saw your objection about the serialization and how you don't like it as everything is runtime. Understood. Thanks a lot. </p>
<p>Below is the code I wrote to get around that. A bit of a stretch but works well and I do not have to add get/set everytime !!!</p>
<pre><code>import json

class JSONObject:
    exp_props = {"id": "", "title": "Default"}

    def __init__(self, d):
        self.__dict__ = d
        for key in [x for x in JSONObject.exp_props if x not in self.__dict__]:
            setattr(self, key, JSONObject.exp_props[key]) 

    @staticmethod
    def fromJSON(s):
        return json.loads(s, object_hook=JSONObject)

    def toJSON(self):
        return json.dumps(self.__dict__, indent=4)


s = '{"name": "ACME", "shares": 50, "price": 490.1}'
anObj = JSONObject.fromJSON(s)

print("Name - {}".format(anObj.name))
print("Shares - {}".format(anObj.shares))
print("Price - {}".format(anObj.price))
print("Title - {}".format(anObj.title))

sAfter = anObj.toJSON()

print("Type of dumps is {}".format(type(sAfter)))
print(sAfter)
</code></pre>
<p>Results below </p>
<pre><code>Name - ACME
Shares - 50
Price - 490.1
Title - Default
Type of dumps is &lt;type 'str'&gt;
{
    "price": 490.1, 
    "title": "Default", 
    "name": "ACME", 
    "shares": 50, 
    "id": ""
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When developing an API like this- in which all the members are read-only (meaning you do not want them overwritten, but may still have mutable data structures as members), I have often considered using <code>collections.namedtuple</code> a hard-to-beat approach unless I have a very good reason to do otherwise. It is fast, and needs a bare minimum of code. </p>
<pre><code>from collections import namedtuple as nt

Group = nt('Group', 'id name shortname users')
g = Group(**json)
</code></pre>
<p>Simple. </p>
<p>If there is more data in your <code>json</code> than will be used in the object, just filter it out:</p>
<pre><code>g = Group(**{k:v for k,v in json.items() if k in Group._fields})
</code></pre>
<p>If you want defaults for missing data, you can do that, too:</p>
<pre><code>Group.__new__.__defaults__ = (0, 'DefaultName', 'DefN', None)
# now this works:
g = Group()
# and now this will still work even if some keys are missing; 
g = Group(**{k:v for k,v in json.items() if k in Group._fields})
</code></pre>
<p>One gotcha using the above technique of setting defaults: don't set the default value for one of the members to any mutable object, such as a <code>list</code>, because it will be the same mutable shared object across all instances:</p>
<pre><code># don't do this:
Group.__new__.__defaults__(0, 'DefaultName', 'DefN', [])
g1 = Group()
g2 = Group()
g1.users.append(user1)
g2.users # output: [user1] &lt;-- whoops!
</code></pre>
<p>Instead, wrap it all up in a nice factory that instantiates a new <code>list</code> (or <code>dict</code> or whatever user-defined data structure you need) for the members that need them:</p>
<pre><code># jsonfactory.py

new_list = Object()

def JsonClassFactory(name, *args, defaults=None):
    '''Produces a new namedtuple class. Any members 
    intended to default to a blank list should be set to 
    the new_list object.
    '''
    cls = nt(name, *args)
    if defaults is not None:
        cls.__new__.__defaults__ = tuple(([] if d is new_list else d) for d in defaults)
</code></pre>
<p>Now given some json object that defines the fields you want present: </p>
<pre><code>from jsonfactory import JsonClassFactory, new_list

MyJsonClass = JsonClassFactory(MyJsonClass, *json_definition,
                               defaults=(0, 'DefaultName', 'DefN', new_list))
</code></pre>
<p>And then as before: </p>
<pre><code>obj = MyJsonClass(**json)
</code></pre>
<p>OR, if there is extra data: </p>
<pre><code>obj = MyJsonClass(**{k:v for k,v in json.items() if k in MyJsonClass._fields})
</code></pre>
<p>If you want the default container to be something other than a list, this is simple enough- just replace the <code>new_list</code> sentinel with whatever sentinel you wish. If needed you could have multiple sentinels at the same time. </p>
<p>And if you still need extra functionality, you can always extend your <code>MyJsonClass</code>:</p>
<pre><code>class ExtJsonClass(MyJsonClass):
    __slots__ = () # optional- needed if you want the low memory benefits of namedtuple
    def __new__(cls, *args, **kwargs):
        self = super().__new__(cls, *args, **{k:v for k,v in kwargs.items()
                                              if k in cls._fields})
        return self
    def add_user(self, user):
        self.users.append(user)
</code></pre>
<p>The <code>__new__</code> method above takes care of the missing data problem for good. So now you can always just do this: </p>
<pre><code>obj = ExtJsonClass(**json)
</code></pre>
<p>Simple.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, it's been a year and I'm going to answer my own question. I don't quite like answering it myself, but: this will mark the thread as resolved which in itself might help others.</p>
<p>On the other hand, I want to document and give reason to why I chose my solution over proposed answers. Not, to prove me right, but to highlight the different tradeoffs.</p>
<p>I just realized, that this got quite long, so:</p>
<h1>tl;dr</h1>
<p><code>collections.abc</code> contains powerful abstractions and you should use them if you have access to it (cpython &gt;= 3.3).
<code>@property</code> is nice to use, enables to add documentation easily and provides read only access.
Nested classes look weird but replicate the structure of deeply nested JSON just fine.</p>
<h1>Proposed solutions</h1>
<h2>python meta-classes</h2>
<p>So first off: I love the concept.
I've considered many applications for where they prove useful, especially when: </p>
<ol>
<li>writing a pluggable API where meta-classes enforce correct usage of derived classes and their implementation specifics</li>
<li>having a fully automated registry of classes that derive a from a meta-class.</li>
</ol>
<p>On the other hand, python's meta-class logic felt obscure to wrap my head around (took me at least three days to figure it out). While simple in principle, the devil is in the details.
So, I decided against it, simply because I might abandon the project in the not so far future and others should be able to pick up where I left off easily.</p>
<h2>namedtuple</h2>
<p><code>collections.namedtuple</code> is very efficient and concise enough to boil my solution down to several lines instead of the current 800+ lines. My IDE will also be able to introspect possible members of the generated class.</p>
<p>Cons: the breverity of namedtuple leaves much less room for the awfully necessary documentation of the APIs returned values. So with less insane APIs you will possibly get away with just that.
It also feels wierd to nest class objects into the namedtuple, but that's just personal preference.</p>
<h1>What I went with</h1>
<p>So in the end, I chose to stick to my first original solution with a few minor details added, if you find the details interesting, you can look at the <a href="https://github.com/manly-man/moodle-destroyer-tools/blob/master/moodle/models.py" rel="nofollow noreferrer">source on github</a>.</p>
<h2>collections.abc</h2>
<p>When I started the project, my python knowledge was next to none, so I went with what I knew about python ("everything is a dict") and wrote code like that. For example: classes that work like a dict, but have a file structure underneath (that was before <code>pathlib</code>).</p>
<p>While looking through python's code I noticed how they implement and enforce container "traits" through <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">abstract base classes</a> which sounds far more complicated than it really is in python.</p>
<h3>the very basics</h3>
<p>The following is indeed <em>very</em> basic, but we'll build up from there.</p>
<pre><code>from collections import Mapping, Sequence, Sized

class JsonWrapper(Sized):
    def __len__(self):
        return len(self._data)

    def __init__(self, json):
        self._data = json

    @property
    def raw(self): return self._data
</code></pre>
<p>The most basic class I could come up with, this will just enable you to call <code>len</code> on the container. You also can get read-only access through <code>raw</code> if you really want to bother with the underlying dictionary.</p>
<p>So why am I inheriting from <code>Sized</code> instead of just starting from scratch and  <code>def __len__</code> just like that?</p>
<ol>
<li>not overriding <code>__len__</code> will not be accepted by the python interpreter. I forget when exactly, but AFAIR it's when you import the module that contains the class, so you're not getting screwed at runtime.</li>
<li>While <code>Sized</code> does not provide any mixin methods, the next two abstractions do provide them. I'll explain there.</li>
</ol>
<p>With that down, we only got two more basic cases in JSON lists and dicts.</p>
<h3>Lists</h3>
<p>So, with the API I had to worry about, we we're not always sure what we got; so I wanted a way of checking if I got a list when we initialize the wrapper class, mostly to abort early instead of "object has no member" during more complicated processes.</p>
<p>Deriving from Sequence will enforce overriding <code>__getitem__</code> and <code>__len__</code> (which is already implemented in <code>JsonWrapper</code>). </p>
<pre><code>class JsonListWrapper(JsonWrapper, Sequence):
    def __init__(self, json_list):
        if type(json_list) is not list:
            raise TypeError('received type {}, expected list'.format(type(json_list)))
        super().__init__(json_list)

    def __getitem__(self, index):
        return self._data[index]

    def __iter__(self):
        raise NotImplementedError('__iter__')

    def get(self, index):
        try:
            return self._data[index]
        except Exception as e:
            print(index)
            raise e
</code></pre>
<p>So you might have noted, that I chose to not implement <code>__iter__</code>.
I wanted an iterator that yielded typed objects, so my IDE is able to autocomplete. To illustrate:</p>
<pre><code>class CourseListResponse(JsonListWrapper):
    def __iter__(self):
        for course in self._data:
            yield self.Course(course)

    class Course(JsonDictWrapper):
        pass  # for now
</code></pre>
<p>Implementing the abstract methods of <code>Sequence</code>, the mixin methods <code>__contains__</code>, <code>__reversed__</code>, <code>index</code> and <code>count</code> are gifted to you, so you don't have to worry about possible side-effects.</p>
<h3>Dictionaries</h3>
<p>To complete the basic types to wrangle JSON, here's the class derived from <code>Mapping</code>:</p>
<pre><code>class JsonDictWrapper(JsonWrapper, Mapping):
    def __init__(self, json_dict):
        super().__init__(json_dict)
        if type(self._data) is not dict:
            raise TypeError('received type {}, expected dict'.format(type(json_dict)))

    def __iter__(self):
        return iter(self._data)

    def __getitem__(self, key):
        return self._data[key]

    __marker = object()

    def get(self, key, default=__marker):
        try:
            return self._data[key]
        except KeyError:
            if default is self.__marker:
                raise
            else:
                return default
</code></pre>
<p>Mapping only enforces <code>__iter__</code>, <code>__getitem__</code> and <code>__len__</code>. 
To avoid confusion: There is also <code>MutableMapping</code> which will enforce the writing methods. But that's neither needed nor wanted here.</p>
<p>With the abstract methods out of the way, python provides the mixins <code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code> based on them.</p>
<p>I'm not sure why I chose to override the <code>get</code> mixin, I might update the post when it get's back to me.
<code>__marker</code> serves as a fallback to detect if the <code>default</code> keyword was not set. If somebody decided to call <code>get(*args, default=None)</code> you won't be able to detect that otherwise.</p>
<p>So to pick up the previous example:</p>
<pre><code>class CourseListResponse(JsonListWrapper):
    # [...]    
    class Course(JsonDictWrapper):
        # Jn is just a class that contains the keys for JSON, so I only mistype once.
        @property
        def id(self): return self[Jn.id]

        @property
        def short_name(self): return self[Jn.short_name]

        @property
        def full_name(self): return self[Jn.full_name]

        @property
        def enrolled_user_count(self): return self[Jn.enrolled_user_count]
        # [...] you get the idea
</code></pre>
<p>The properties provide read-only access to members and can be documented like a function definition.
Altough verbose, for basic accessors you can easily define a template in your editor, so it's less tedious to write.</p>
<p>Properties also allow to abstract from magic numbers and optional JSON return values, to provide defaults instead guarding for <code>KeyError</code> everywhere:</p>
<pre><code>        @property
        def isdir(self): return 1 == self[Jn.is_dir]

        @property
        def time_created(self): return self.get(Jn.time_created, 0)

        @property
        def file_size(self): return self.get(Jn.file_size, -1)

        @property
        def author(self): return self.get(Jn.author, "")

        @property
        def license(self): return self.get(Jn.license, "")
</code></pre>
<h3>class nesting</h3>
<p>It seems a little weird to nest classes in others.
I chose to do that, becaue the API uses the same name for various objects with different attributes, depending on which remote function you called.</p>
<p>Another benefit: new people can easily understand the structure of the returned JSON.</p>
<p>The <a href="https://github.com/manly-man/moodle-destroyer-tools/blob/master/moodle/models.py#L799" rel="nofollow noreferrer">end of the file</a> contains various aliases to the nested classes for easier access from outside the module.</p>
<h2>adding logic</h2>
<p>Now that we have encapsulated most of the returned values, I wanted to have more logic associated with the data, to add some convenience.
It also seemed necessary to merge some of the data into a more comprehensive tree that contained all of the data gathered through several API calls:</p>
<ol>
<li>get all "assignments". each assignment contains many submissions, so:</li>
<li>for(assignment in assigmnents) get all "submissions"</li>
<li>merge submissions into respective assignment.</li>
<li>now get grades for the submissions, and so on...</li>
</ol>
<p>I chose to implement them seperately, so I just inherited from the "dumb" accessors (<a href="https://github.com/manly-man/moodle-destroyer-tools/blob/master/frontend/models.py" rel="nofollow noreferrer">full source</a>):</p>
<p>So in <a href="https://github.com/manly-man/moodle-destroyer-tools/blob/master/frontend/models.py#L163" rel="nofollow noreferrer">this class</a></p>
<pre><code>class Assignment(MoodleAssignment):
    def __init__(self, data, course=None):
        super().__init__(data)
        self.course = course
        self._submissions = {}  # accessed via submission.id
        self._grades = {}  # are accessed via user_id
</code></pre>
<p>these properties do the merging</p>
<pre><code>    @property
    def submissions(self): return self._submissions

    @submissions.setter
    def submissions(self, data):
        if data is None:
            self.submissions = {}
            return
        for submission in data:
            sub = Submission(submission, assignment=self)
            if sub.has_content:
                self.submissions[sub.id] = sub

    @property
    def grades(self):
        return self._grades

    @grades.setter
    def grades(self, data):
        if data is None:
            self.grades = {}
            return
        grades = [Grade(g) for g in data]
        for g in grades:
            self.grades[g.user_id] = g
</code></pre>
<p>and these implement some logic that can be abstracted from the data.</p>
<pre><code>    @property
    def is_due(self):
        now = datetime.now()
        return now &gt; self.due_date

    @property
    def due_date(self): return datetime.fromtimestamp(super().due_date)
</code></pre>
<p>While the setters obscure the wrangling, they are nice to write and use: so it's just a trade-off.</p>
<p>Caveat: The logic implementation is not quite what I want it to be, there's much interdependance where it should not be. It's grown from me not knowing enough of python to get the abstractions right and getting things done, so I can do the actual work with the tedium out of my way.
Now that I know, what could have been done: I look at some of that spaghetti, and well … you know the feeling.</p>
<h1>Conclusion</h1>
<p>Encapsulating the JSON into classes proved quite useful to me and the project's structue and I'm quite happy with it.
The rest of the project is fine and works, although some parts are just awful :D
Thank you all for the feedback, I'll be around for questions and remarks.</p>
</div>
<span class="comment-copy">Great question! Can you elaborate (by editing the question) as to why you feel the second solution doesn't look right? I, personally, like it (and there are a few libraries/frameworks that implement the 2nd solution.</span>
<span class="comment-copy">.. also, you'd want <code>cls.members</code> to be defined at a class level. <code>self</code> doesn't make sense in that context of <code>property</code></span>
<span class="comment-copy">This question seems far better suited to <a href="https://codereview.stackexchange.com">Code Review</a> — see its <a href="http://codereview.stackexchange.com/questions/tagged/comparative-review"><code>comparative-review</code></a> tag.</span>
<span class="comment-copy">use <b>class JsonDataWrapper(object)</b> to get new style classes, at least on Python 2.x</span>
<span class="comment-copy">@SuperSaiyan I posted an edit, not sure if that notified all of you already, but I think this comment will? not sure tho.</span>
<span class="comment-copy">I think IDE support for discovering the properties will be limited with this approach.</span>
<span class="comment-copy">I think there may be a closure-related bug in this implementation</span>
<span class="comment-copy">@BiRico Yes, I did: while this would be nice for a fast script, I don't think that this keeps the Code readable. I also tried it, and neither helm nor pycharm could guess the classes' attributes (besides <code>members</code>), which defeats the purpose. (You might also have gotten the wrong Idea of Group.members, I tried to clarify that in the post.)</span>
