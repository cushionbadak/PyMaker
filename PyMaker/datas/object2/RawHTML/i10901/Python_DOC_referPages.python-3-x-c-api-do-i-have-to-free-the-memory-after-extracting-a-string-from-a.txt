<div class="post-text" itemprop="text">
<p>I extract strings from a <code>PyObject</code> pointer using:</p>
<pre><code>char* str = PyBytes_AsString(PyUnicode_AsASCIIString(strObj));
</code></pre>
<p>I'm wondering whether I have to free the memory after doing this. <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsASCIIString" rel="nofollow">The manual</a> doesn't seem to provide any information about this for these functions, but other functions do provide information to free memory using <code>PyMem_Free()</code>.</p>
<p><strong>More details</strong> </p>
<p>After all <code>str</code> is a pointer to something reserved. I would've thought that this is like <code>std::string::c_str()</code>, where the return is a <code>const char*</code> to something inside the object, but Python strings can have any kind of encoding, which is in general not ASCII. Meaning that if we convert formatting, we need to reserve some new space.</p>
<p>Free or not? If not, how does Python do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the documentation for <a href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_AsASCIIString" rel="nofollow"><code>PyUnicode_AsASCIIString</code></a>, you will see</p>
<blockquote>
<p><em>Return value: New reference.</em><br/>
  Encode a Unicode object using ASCII and return the result as Python bytes object. Error handling is “strict”. Return <em>NULL</em> if an exception was raised by the codec.</p>
</blockquote>
<p>The returned object is a regular Python bytes object, subject to regular Python reference handling. The reference you receive is a new reference, so you own that reference, and you are responsible for <code>Py_DECREF</code>ing it when you're done with it. Since you do not do this, your code leaks this object.</p>
<p>You also need to handle the null return case. Since you do not, your code currently invokes undefined behavior if the codec raises an exception.</p>
<hr/>
<p>If you look at the documentation for <a href="https://docs.python.org/3/c-api/bytes.html#c.PyBytes_AsString" rel="nofollow"><code>PyBytes_AsString</code></a>, you will see</p>
<blockquote>
<p>Return a pointer to the contents of <em>o</em>. The pointer refers to the internal buffer of o, which consists of <code>len(o) + 1</code> bytes. The last byte in the buffer is always null, regardless of whether there are any other null bytes. The data must not be modified in any way, unless the object was just created using <code>PyBytes_FromStringAndSize(NULL, size)</code>. It must not be deallocated. If <em>o</em> is not a bytes object at all, PyBytes_AsString() returns <em>NULL</em> and raises TypeError.</p>
</blockquote>
<p>This function returns a pointer to the internals of a bytes object. You should not free the pointer, and you should not modify the data it points to. You should also wait until you're done with this pointer before <code>Py_DECREF</code>ing the bytes object whose internals you're looking at.</p>
</div>
