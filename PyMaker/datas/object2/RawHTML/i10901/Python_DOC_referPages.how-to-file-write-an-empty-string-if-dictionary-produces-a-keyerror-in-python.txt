<div class="post-text" itemprop="text">
<p>I have a particular problem with json files. The following code reads json, and writes to a txt file. I have shortened the code for readability, in my real code it is hundereds of fields and write statements.</p>
<pre><code>import os
import json


def _getjson(filename):
    """ returns a list of dictionaries """
    if not os.path.exists(filename): return []
    with open(filename, 'r') as openfileobject:
        data = json.loads(openfileobject.read())
    return data

def writefile(filename, data):
    """writes to file"""
    with open(filename, 'w') as f:
        for d in data:
            f.write(d['field1'] + ' ' + d['field2'] + ' ' + d['field3'] + '\n')
            ## a lot more code here


def main():
    filename = r'c:\input.json'
    data = _getjson(filename)
    outfile = r'c:\output.txt'
    writefile(outfile, data)

if __name__ == '__main__':
    main()
</code></pre>
<p>The problem is, sometimes a field is not in json, and it produces a <code>KeyError</code>
While I can trap this with a <code>try: except KeyError</code>. It would mean that I need to put this try around every field in my <code>writefile</code> function.</p>
<p>Is there a way that without changing the <code>f.write()</code> statements, that upon <code>KeyError</code> it will write an empty string ? (so I do not have to capture this in hundereds of <code>try</code> blocks)</p>
<p>So this is a dictionary problem, I have no problem with the json itself. I cannot control which fields are in my input, so one file may have <code>field1</code> and <code>field2</code>. The next could have all three, or only one. The json part works, just that I will be missing some fields, sometimes. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get</code></a>:</p>
<pre><code>f.write(d.get('field1', '') + ' ' +
        d.get('field2', '') + ' ' +
        d.get('field3', '') + '\n')
</code></pre>
<p><code>get()</code> returns the value for <em>key</em>, or given <em>default</em> or <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>More simpler is <code>str.join</code> with <code>dict.values</code>.</p>
<p><code>f.write(' '.join(d.values()))</code> </p>
<p>or if values are not strings use genexps like</p>
<p><code>f.write(' '.join(str(value) for value in d.values()))</code> </p>
</div>
<span class="comment-copy">Thank you ! That did the trick !</span>
<span class="comment-copy">You could also apply the <code>join()</code> idea to this as well: <code>f.write(' '.join(d.get(k, '') for k in ['field1', 'field2', 'field3']) + '\n')</code></span>
<span class="comment-copy"><code>d.values()</code> has arbitrary order, or in other words no order at all. That might not matter, but most of the time it does.</span>
<span class="comment-copy"><code>dict.values()</code> will not work for me, as I cannot select the exact key I want to write to the file (and format and put other text around)... but thank you for your answer, I learned another trick, which I will use in the future !</span>
