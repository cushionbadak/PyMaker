<div class="post-text" itemprop="text">
<p>I saw <a href="https://stackoverflow.com/a/22152693/2505645">"Why doesn't join() automatically convert its arguments to strings?"</a> and <a href="https://stackoverflow.com/a/22152693/2505645">the accepted answer</a> made me think: since</p>
<blockquote>
<p>Explicit is better than implicit.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Errors should never pass silently.</p>
</blockquote>
<p>why does <code>str.format()</code> ignore additional/unused (sometimes accidentally passed) arguments? To me it looks like an error which is passed silently, and it surely isn't explicit:</p>
<pre><code>&gt;&gt;&gt; 'abc'.format(21, 3, 'abc', object(), x=5, y=[1, 2, 3])
'abc'
</code></pre>
<p>This actually lead my friend to an issue with <code>os.makedirs(path, exist_ok=True)</code> still raising an error even though <a href="https://docs.python.org/3/library/os.html#os.makedirs" rel="nofollow noreferrer">the docs for <code>os.makedirs()</code></a> said that <code>exist_ok=True</code> won't raise an error even if <code>path</code> already exists.
It turned out he just had a long line with nested function calls, and the <code>exist_ok</code> was passed in to a nested <code>.format()</code> call instead of the <code>os.makedirs()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ignoring un-used arguments makes it possible to create arbitrary format strings for arbitrary-sized dictionaries or objects.</p>
<p>Say you wanted to give your program the feature to let the end-user change the output. You document what <em>fields</em> are available, and tell users to put those fields in <code>{...}</code> slots in a string. The end-user then can create templating strings with <em>any number</em> of those fields being used, including none at all, <em>without error</em>.</p>
<p>In other words, the choice is deliberate, because there are practical reasons for allowing more arguments than are converted. Note that the C# <code>String.Formatter</code> implementation that inspired the Python PEP does the same, for those same reasons.</p>
<p>Not that the discussion on this part of the PEP is that clear cut; Guido van Rossum at some point <a href="https://mail.python.org/pipermail/python-dev/2006-May/065059.html">tries to address this issue</a>:</p>
<blockquote>
<p>The PEP appears silent on what happens if there are too few or too
  many positional arguments, or if there are missing or unused keywords.
  Missing ones should be errors; I'm not sure about redundant (unused)
  ones. On the one hand complaining about those gives us more certainty
  that the format string is correct. On the other hand there are some
  use cases for passing lots of keyword parameters (e.g. simple web
  templating could pass a fixed set of variables using **dict). Even in
  i18n (translation) apps I could see the usefulness of allowing unused
  parameters</p>
</blockquote>
<p>to which the PEP author <a href="https://mail.python.org/pipermail/python-dev/2006-May/065060.html">responded</a> that they were still undecided on this point. </p>
<p>For use-cases where you must raise an exception for unused arguments you are expected to subclass the <a href="https://docs.python.org/2/library/string.html#string.Formatter"><code>string.Formatter()</code> class</a> and provide an implementation for <a href="https://docs.python.org/2/library/string.html#string.Formatter.check_unused_args"><code>Formatter.check_unused_args()</code></a>; the default implementation does nothing. This of course doesn't help your friend's case where you used <code>str.format(*args, **kwargs)</code> rather than <code>Formatter().format(str, *args, **kwargs)</code>. I believe that at <em>some point</em> the idea was that you could replace the formatter used by <code>str.format()</code> with a custom implementation, but that never came to pass.</p>
<p>If you use the <a href="https://pypi.python.org/pypi/flake8"><code>flake8</code> linter</a>, then you can add the <a href="https://pypi.python.org/pypi/flake8-string-format"><code>flake8-string-format</code> plugin</a> to detect the obvious cases, where you passed in an <em>explicit</em> keyword argument that is not being used by the format string.</p>
</div>
<span class="comment-copy">Would you prefer that something simple like: <code>'{6} {3}'.format(*range(100))</code> fail? Or maybe: <code>'Hi {name} your favourite colour is {colour}'.format(name='Bob', colour='blue', age=21, planet='Earth')</code></span>
<span class="comment-copy">@JonClements Actually yes. If the string needs <code>name</code> and <code>colour</code>, I believe it's an error to pass it <code>age</code> and <code>planet</code>. As mentioned, "errors should neve pass silently.". An error would also force you to be explicit with your statements.</span>
<span class="comment-copy">So, if I have a <code>dict</code> called <code>person</code> that I'm passing around and to simply print a string based on certain elements of it, I should be responsible to <b>subset</b> that dict to match my formatting? That's an insane requirement -- or do you think people really fancy doing <code>.format(name=person['name'], colour=['person'])</code> ?</span>
<span class="comment-copy">According to what I understand from the Zen of Python, you shouldn't just be "passing around" the whole dict. If you want to print the person's name and age, pass in the person's name and age. Have a function take the person and print out his name and age to simplify the main function.</span>
<span class="comment-copy">@MarkusMeskanen You are quoting <code>"errors should never pass silently."</code>. The <i>real</i> question here is <i>is the scenario you describe should even be considered as an error</i>. I think it is not.</span>
<span class="comment-copy">Referring to <a href="http://stackoverflow.com/questions/22152668/why-doesnt-join-automatically-convert-its-arguments-to-strings-when-would-yo/22152693#22152693">your answer on the other question which inspired me to ask this question</a>, how's this case any different? The <code>.format()</code>'s behaviour can hide bugs (as it did with my friend's case), and <code>.format()</code> just ignores everything you pass to it. Imo it's even worse than the <code>join()</code> would be.</span>
<span class="comment-copy">@MarkusMeskanen: Also in the Zen: <i>Although practicality beats purity.</i> There are good practical reasons to not raise an exception here. I'm trolling through the original PEP discussion at the moment to find the specific decision on this.</span>
<span class="comment-copy">To me it just feels that the Zen is like the US law: it has everything and you can justify anything just by referring to different parts of it. Imo <i>"practicality beats purity"</i> would also apply on the other question asked, <code>str.join()</code> should actually convert everything to string cause that's just practical. If you're joining <code>1</code> and <code>2</code> with a dash, what else should it do than <code>'1-2'</code>. Although that's a discussion to have in the other question...</span>
<span class="comment-copy">@MarkusMeskanen: the Zen is a <i>guideline</i>, not a law. Even better, it started as a <i>joke</i>. It is a philosophy, not a binding document.</span>
<span class="comment-copy">@SkamahOne: you are free to take that up with the Python core developers.</span>
