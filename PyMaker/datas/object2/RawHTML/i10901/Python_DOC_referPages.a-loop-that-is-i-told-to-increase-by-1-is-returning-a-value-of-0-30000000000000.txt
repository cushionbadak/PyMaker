<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>Basically I thought I created a loop to just increase .1 every iteration.  What I have got is these numbers below like 0.30000000000000004,0.7999999999999999, 3.0000000000000013.  Here is my code and the results.  Why is it not .1, .2. .3, etc. and/or why is it 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, etc.  Basically why are their unexpected, for me, decimals.</p>
<pre><code>&gt;&gt;&gt; tph_bin = []
&gt;&gt;&gt; bin_num = 0
&gt;&gt;&gt; while bin_num &lt;= 3.5:
    tph_bin.append(bin_num)
    bin_num = bin_num + .1


&gt;&gt;&gt; tph_bin
[0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, 0.8999999999999999, 0.9999999999999999, 1.0999999999999999, 1.2, 1.3, 1.4000000000000001, 1.5000000000000002, 1.6000000000000003, 1.7000000000000004, 1.8000000000000005, 1.9000000000000006, 2.0000000000000004, 2.1000000000000005, 2.2000000000000006, 2.3000000000000007, 2.400000000000001, 2.500000000000001, 2.600000000000001, 2.700000000000001, 2.800000000000001, 2.9000000000000012, 3.0000000000000013, 3.1000000000000014, 3.2000000000000015, 3.3000000000000016, 3.4000000000000017]
</code></pre>
<p>Bonus Question: Is there a better way to create a list of numbers increasing by .1?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a floating point precision limitation. Please refer to:</p>
<p><a href="https://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow">https://docs.python.org/2/tutorial/floatingpoint.html</a></p>
<p>0.1 is actually stored as the binary fraction:</p>
<blockquote>
<p>0.00011001100110011001100110011001100110011001100110011010</p>
</blockquote>
<p>As you can see, that can lead to binary rounding errors as numbers are added.</p>
<p>Try using Decimal as an alternative if all you care is 1 decimal place precision:</p>
<pre><code>from decimal import *
value = Decimal("0.1")+Decimal("0.1")+Decimal("0.1")
print value
# 0.3
if Decimal('0.3') == value
  print 'This works!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Answer to Bonus Question: Is there a better way to create a list of numbers increasing by .1?</p>
<p>with numpy</p>
<pre><code>numpy.arange(0,3.5,0.1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Its basically the disadvantages of using float numbers. The number 0.2 plus 0.1 just got overflowed and the result wont fit inside a memory block reserved to float types so it cuts of the part overflowed and rounds it around that value. If you want to work with numbers that way, you should operate with integers and then divide the result by 10 or just round up the values, but never try to compare floats by value because the outcome could be surprising.</p>
</div>
<span class="comment-copy">There's no question before the bonus.</span>
<span class="comment-copy">If you want precision, use the decimal lib, <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">docs.python.org/3/library/decimal.html</a></span>
<span class="comment-copy">Sorry.  I thought I was clear but re reading it I wasn't.  I was just wondering why it would round up to 0.30000000000000004.</span>
<span class="comment-copy">@DonQuixote, rounding up to what? Did you read the duplicate?</span>
<span class="comment-copy">I didn't understand that .1 in binary was different than .1 in decimal.  PressingOnAlways answered my question.  And thanks for linking the duplicate.</span>
<span class="comment-copy">Thanks!  Here's is a video that explains why this is in case anyone is curious in the future.  <a href="https://www.youtube.com/watch?v=KMcUWgIAu1c" rel="nofollow noreferrer">youtube.com/watch?v=KMcUWgIAu1c</a></span>
<span class="comment-copy">@DonQuixote - no problem. If this answer works for you, please accept it. Thanks.</span>
<span class="comment-copy">I don't understand the downvotes here.</span>
<span class="comment-copy">Thanks.  I would have never thought of that.  I changed by code to the below and it worked!  I really appreciate it.     for num in range(35):         bin_num = (num / 10)         tph_bin.append(bin_num)         num =+ 1.      I can't get the formatting to work but you're a smart guy.  Appreciate it.</span>
