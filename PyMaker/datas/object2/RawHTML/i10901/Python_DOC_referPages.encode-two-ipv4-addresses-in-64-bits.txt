<div class="post-text" itemprop="text">
<p>If I have pairs of IP addresses like:</p>
<pre><code>IP1="168.2.65.33"
IP2="192.4.2.55"
</code></pre>
<p>I would like to encode each pair as a 64 bit value so that the first 32 bits is the first IP address and the second is the second IP address. I would then like to be able to save the 64 bit value to a file in such a way that I can read it back in and recover the two IP addresses.</p>
<p>The aim is save space.</p>
<p>Is it possible to do this in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't worry about encoding them in 64 bits. An IPv4 address is 32 bits (4 bytes). If you write two of them to a file, it will be 8 bytes in size.</p>
<p>Use <a href="https://docs.python.org/2/library/socket.html#socket.inet_aton" rel="nofollow"><code>socket.inet_aton</code></a> to convert a human-readable IP address <em>string</em> to a packed binary raw 4-byte string:</p>
<pre><code>import socket
ip_addrs = ["168.2.65.33", "192.4.2.55"]

with open('data.out', 'wb') as f:
    for ip in ip_addrs:
        raw = socket.inet_aton(ip)
        f.write(raw)
</code></pre>
<p>Result:</p>
<pre class="lang-none prettyprint-override"><code>$ hexdump -Cv data.out 
00000000  a8 02 41 21 c0 04 02 37                           |..A!...7|
00000008
</code></pre>
<p>The complementary conversion function <a href="https://docs.python.org/2/library/socket.html#socket.inet_ntoa" rel="nofollow"><code>socket.inet_ntoa</code></a> will convert a packed 4-byte string back into a human-readable IP address.</p>
<hr/>
<p>Here's an example of writing and reading them back:</p>
<pre><code>import socket

ip_pairs = [
    ('1.1.1.1', '1.1.1.2'),
    ('2.2.2.2', '2.2.2.3'),
    ('3.3.3.3', '3.3.3.4'),
]

# Write them out
with open('data.out', 'wb') as f:
    for ip1, ip2 in ip_pairs:
        raw = socket.inet_aton(ip1) + socket.inet_aton(ip2)
        f.write(raw)

def read_with_eof(f, n):
    res = f.read(n)
    if len(res) != n:
        raise EOFError
    return res

# Read them back in
result = []
with open('data.out', 'rb') as f:
    while True:
        try:
            ip1 = socket.inet_ntoa(read_with_eof(f, 4))
            ip2 = socket.inet_ntoa(read_with_eof(f, 4))
            result.append((ip1, ip2))
        except EOFError:
            break

print 'Input:', ip_pairs
print 'Result:', result
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>$ python pairs.py 
Input: [('1.1.1.1', '1.1.1.2'), ('2.2.2.2', '2.2.2.3'), ('3.3.3.3', '3.3.3.4')]
Result: [('1.1.1.1', '1.1.1.2'), ('2.2.2.2', '2.2.2.3'), ('3.3.3.3', '3.3.3.4')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's possible, like this:</p>
<pre><code>import struct
import os
IP1="168.2.65.233"
IP2="192.4.2.55"
s = struct.pack('&gt;8B', *map(int, IP1.split('.') + IP2.split('.')))
with open('f', 'wb') as f:
  f.write(s)
print(os.stat('f').st_size)  #: 8.
</code></pre>
<p>This works in Python 2 and 3.</p>
<p>Based on Jonathon Reinhart's answer, you can also use <code>socket.inet_aton</code> instead of <code>struct.pack</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python3 there is an <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow"><code>ipaddress</code></a> module for working with IPs. Pack them into 32 bits each and add them together:</p>
<pre><code>from ipaddress import ip_address

original1 = ip_address('192.168.0.1')
original2 = ip_address('8.8.8.8')

out = original1.packed + original2.packed
</code></pre>
<p>Load them back in:</p>
<pre><code>loaded1 = ip_address(out[0:4])
loaded2 = ip_address(out[4:])
</code></pre>
<p>Try it online: <a href="https://repl.it/Ce3k/1" rel="nofollow">https://repl.it/Ce3k/1</a></p>
</div>
<span class="comment-copy">@Hurkyl Thanks. Fixed.</span>
<span class="comment-copy">How would you then read them back in? I have many thousands of such pairs I need to save.</span>
<span class="comment-copy">@eleanora: If you have a byte string of 8 bytes read from the file, use <code>socket.inet_ntoa(s[:4])</code> to get the human-readable version of the 1st IP address.</span>
<span class="comment-copy">@eleanora I added an example of reading them back.</span>
