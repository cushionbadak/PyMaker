<div class="post-text" itemprop="text">
<p>I'm aware that attribute getters and setters are considered "unpythonic", and the pythonic way to do things is to simply use an normal attribute and use the property decorator if you later need to trigger some functionality when an attribute is accessed or set.</p>
<p>e.g. <a href="https://stackoverflow.com/questions/2627002/whats-the-pythonic-way-to-use-getters-and-setters">What's the pythonic way to use getters and setters?</a></p>
<p>But how does this apply when the value of an attribute is a list, for example?</p>
<pre><code>class AnimalShelter(object):
    def __init__(self):
        dogs = []
        cats = []

class Cat(object):
    pass

class Dog(object):
    pass
</code></pre>
<p>Say that initially, the interface works like this:</p>
<pre><code># Create a new animal shelter
woodgreen = AnimalShelter()

# Add some animals to the shelter
dog1 = Dog()
woodgreen.dogs.append(dog1)
</code></pre>
<p>This would seem to be in line with the "pythonic" idea of just using straightforward attributes rather than creating getters, setters, mutators etc. I could have created an <code>addDog</code> method instead. But while not strictly speaking a setter (since it mutates the value of an attribute rather than setting an attribute), it still seems setter-like compared to my above solution.</p>
<p>But then, say that later on you need to trigger some functionality when dogs are added. You can't fall back on the using the property decorator, since adding a dog is not setting a property on the object, but retrieving a list which is the value of that attribute, and mutating that list.</p>
<p>What would be the "pythonic" way of dealing with such a situation?</p>
</div>
<div class="post-text" itemprop="text">
<p>What's unpythonic are <em>useless</em> getters and setters - since Python have a strong support for computed attributes. This doesn't mean you shouldn't properly encapsulate your implementation.</p>
<p>In your above exemple, the way your <code>AnimalShelter</code> class handles it's "owned" animals is an implementation detail and should not be exposed, so it's totally pythonic to use protected attribute and expose a relevant set of public methods / properties:</p>
<pre><code>class AnimalShelter(object):
    def __init__(self):
        self._dogs = []
        self._cats = []

    def add_dog(self, dog):
        if dog not in self._dogs:     
            self._dogs.append(dog)

    def get_dogs(self):
        return self._dogs[:] # return a shallow copy

    # etc
</code></pre>
</div>
<span class="comment-copy">If you need to modify the behaviour when an item is added to a list, you could make e.g. <code>cats</code> an instance of a custom <code>list</code> subclass, rather than a vanilla list, and implement the behaviour on that, or use<code>AnimalShelter.__getattribute__</code> to return the list with a custom wrapper. Alternatively, make the shelter itself list-like (see <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>), so e.g. <code>woodgreen.append(Dog())</code> would choose the right inner list and do whatever else you needed. What additional behaviour do you need?</span>
<span class="comment-copy">@samfrances the underscore in <code>self._dogs</code> are a way to tell that your attribute is protected (it's just semantic, it does not intruct python to do anything special) <a href="http://stackoverflow.com/questions/14671487/what-is-the-difference-in-python-attributes-with-underscore-in-front-and-back">about underscores</a></span>
