<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2/tutorial/inputoutput.html#fancier-output-formatting" rel="noreferrer">Python 2.7.12 documentation</a>:</p>
<blockquote>
<p><code>!s</code> (apply <code>str()</code>) and <code>!r</code> (apply <code>repr()</code>) can be used to convert
  the value before it is formatted.</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print 'The value of PI is approximately {}.'.format(math.pi)
The value of PI is approximately 3.14159265359.
&gt;&gt;&gt; print 'The value of PI is approximately {!r}.'.format(math.pi)
The value of PI is approximately 3.141592653589793.
</code></pre>
</blockquote>
<p>Interestingly, the converted value is the output of <code>repr()</code>, rather than <code>str()</code>.</p>
<pre><code>&gt;&gt;&gt; str(math.pi)
'3.14159265359'
&gt;&gt;&gt; repr(math.pi)
'3.141592653589793'
</code></pre>
<p>So what does "convert the value" mean here? Making it less human-readable?</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to format something <em>in</em> a string, a string representation of that something must first be created.  "convert the value" is basically talking about how the string representation is to be constructed.  In python, there are two fairly natural choices to get a string representation of something ... <code>str</code> and <code>repr</code>.  <code>str</code> is generally a little more human friendly, <code>repr</code> is generally more precise.  Perhaps the <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="noreferrer">official documentation</a> is the best place to go looking for the difference:</p>
<blockquote>
<p><code>object.__repr__(self)</code><br/></p>
<ul>
<li><p>Called by the <code>repr()</code> built-in function to compute the “official” string representation of an object. If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form <code>&lt;...some useful description...&gt;</code> should be returned. The return value must be a string object. If a class defines <code>__repr__()</code> but not <code>__str__()</code>, then <code>__repr__()</code> is also used when an “informal” string representation of instances of that class is required.</p></li>
<li><p>This is typically used for debugging, so it is important that the representation is information-rich and unambiguous.</p></li>
</ul>
<p><code>object.__str__(self)</code><br/></p>
<ul>
<li><p>Called by str(object) and the built-in functions format() and print() to compute the “informal” or nicely printable string representation of an object. The return value must be a string object.</p></li>
<li><p>This method differs from <code>object.__repr__()</code> in that there is no expectation that <code>__str__()</code> return a valid Python expression: a more convenient or concise representation can be used.</p></li>
<li><p>The default implementation defined by the built-in type object calls <code>object.__repr__()</code>.</p></li>
</ul>
</blockquote>
<p>In <code>str.format</code>, <code>!s</code> chooses to use <code>str</code> to format the object whereas <code>!r</code> chooses <code>repr</code> to format the value.</p>
<p>The difference can easily be seen with strings (as <code>repr</code> for a string will include outer quotes).:</p>
<pre><code>&gt;&gt;&gt; 'foo {}'.format('bar')
'foo bar'
&gt;&gt;&gt; 'foo {!r}'.format('bar')
"foo 'bar'"
</code></pre>
<p>What the difference between these two methods really depends critically on the objects being formatted.  For many objects (e.g. those that don't override the <code>__str__</code> method), there will be no difference in the formatted output.</p>
</div>
<span class="comment-copy">It is interesting to observe different precision for <code>str(..)</code> and <code>repr(..)</code> though</span>
<span class="comment-copy">So <code>str()</code> is used on default, right?</span>
<span class="comment-copy">@sunqingyao that is correct.</span>
