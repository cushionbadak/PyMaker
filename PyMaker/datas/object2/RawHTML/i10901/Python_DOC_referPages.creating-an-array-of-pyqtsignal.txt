<div class="post-text" itemprop="text">
<p>For a QThread I would like to create an array of pyqtSignal</p>
<pre><code>class MyThread(QtCore.QThread):
    Trigger = []
    for i in range(0,10):
        Trigger.append(QtCore.pyqtSignal(int))
    def __init__(self, Function):
        self.Function = Function
        super(MyThread, self).__init__(None)

    def run(self):
        self.Function()
</code></pre>
<p>The main part of the following code looks like:</p>
<pre><code>class Main(QtWidgets.QMainWindow):
    def __init__(self):
        self.MyQThread = MyThread(lambda: self.PrintTest(5))

    def StartTestThread(self):
            self.MyQThread.Trigger[0].connect(self.update_text)           
            self.MyQThread.start()

    def PrintTest(self,InputValue):
        for i in range (0,100):
            print(InputValue*i)
            time.sleep(0.2)
        self.MyQThread.Trigger[0].emit(5)

    def update_text(self, thread_no):
        self.ui.MY_LISTWIDGET.addItem('123')
</code></pre>
<p>executing the StartTestThread leads to the following error</p>
<blockquote>
<p>AttributeError: 'PyQt5.QtCore.pyqtSignal' object has no attribute
  'connect'</p>
</blockquote>
<p>If I initiliaize the pyqtSignal without being an array, it works.
What am I doing wrong? Thanks for the help in advance! </p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot create a list of pyqtSignal(s).</p>
<p>Unfortunately the way pyqt implement signals use a bit of python magics, and the <code>pyqtSignal</code> objects are actually "converted" into <code>pyqtBoundSignal</code> when a <code>QObject</code> subclass (technically a class that have <code>pyqtWrapperType</code> as a metaclass) is loaded.</p>
<p>You can solve your problem in different ways:</p>
<h2>1) Wrap the signal</h2>
<p>I'm not 100% sure about this, but it's a modified version of your attempt:</p>
<pre><code>class FooWrap(QObject):
    Signal = QtCore.pyqtSignal(int)

class MyThread(QtCore.QThread):
    Trigger = [FooWrap] * 10
</code></pre>
<h2>2) Don't use a list</h2>
<p>If the number of signals is fixed, just create them directly as <code>signal1</code>, <code>signal2</code>, <code>signalN</code>, then you can call them directly</p>
<p>If you can determine which signal to call only at runtime you can get the signal you need using the <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow"><code>gettattr(object, name)</code></a> function, for example:</p>
<pre><code>getattr(self.MyQThread, 'signal' + str(n)).connect(self.update_text)
</code></pre>
<p>and</p>
<pre><code>getattr(self.MyQThread, 'signal' + str(n)).emit(value)
</code></pre>
<h2>3) Use only one signal</h2>
<p>Use only one signal that emit two values, one identify the "step" in which the signal is emitted, and the second is your value, doing so the connected functions can decide what to do based on the "step" value.</p>
</div>
<span class="comment-copy">Also building up a Wrap function: class FooWrap():         Signal = QtCore.pyqtSignal(int)  Then  class MyThread(QtCore.QThread):     Trigger = [FooWrap] * 10  and later on  self.MyQThread.Trigger[0].Signal.connect(self.update_text)  leads to the same error...</span>
<span class="comment-copy">Why do you want to do this? Sounds a bit like an XY problem...</span>
<span class="comment-copy">Because I want to set up a class, which can have many pyqtSignals. In a few cases I will need more than one signal, because different signals will occur at different steps in the code.</span>
<span class="comment-copy">@three_pineapples : To give more details:  I'm developing a new gui for the physics experiment I'm doing my PhD at. I want to disable, enable buttons and update the gui continously from an asychronous thread.</span>
<span class="comment-copy">Cool (I'm doing a physics PhD too!). I would suggest you go with option 3 in the answer below. Just use one signal and emit a list of parameters that allows your slot to determine what to do.</span>
