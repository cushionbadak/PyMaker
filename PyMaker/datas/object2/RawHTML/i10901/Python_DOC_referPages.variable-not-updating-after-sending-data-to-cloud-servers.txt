<div class="post-text" itemprop="text">
<p>I have been having trouble with updating this global variable that is an array of strings. This <code>rfDataArray</code> is supposed to be updated as the rf data is coming in from another device. Now, when I have tested this <strong>without</strong> sending anything over to the cloud servers, it works (the <code>rfDataArray</code> gets updated as frequently as the data is being sent) however as soon as I start sending the data, the <code>rfDataArray</code> array seems to be stuck at the initial array and does not get updated ever again...</p>
<pre><code>import httplib, urllib
import time, sys
import serial

key = 'MY_API_KEY'
rfDataArray = []
rfWaterLevelVal = 0

ser = serial.Serial('/dev/ttyUSB0',9600)

def rfWaterLevel():
    global rfWaterLevelVal
    global rfDataArray

    rfDataArray = ser.readline().strip().split()
    print 'incoming: %s' %rfDataArray
    if len(rfDataArray) == 5:
        rfWaterLevelVal = float(rfDataArray[4])
        print 'RFWater Level1: %.3f cm' % (rfWaterLevelVal)


def sendRFWaterlevel():
    params = urllib.urlencode({'field1':rfWaterLevelVal, 'key':key})
    headers = {"Content-type": "application/x-www-form-urlencoded",
               "Accept": "text/plain"}
    conn = httplib.HTTPConnection("api.thingspeak.com:80", timeout = 5)
    conn.request("POST", "/update", params, headers)
    print 'RFWater Level2: %.3f cm' % (rfWaterLevelVal)
    response = conn.getresponse()
    print response.status, response.reason
    data = response.read()
    conn.close()

while True:
    try:
        rfWaterLevel()
        time.sleep(1)
        sendRFWaterlevel()
        time.sleep(3)
    except KeyboardInterrupt:
        print "caught keyboard interrupt"
        sys.exit()
</code></pre>
<p>I need to update the<code>rfDataArray</code> variable (so the <code>rfWaterlevelVal</code> is updated to send over to the cloud servers).</p>
</div>
<div class="post-text" itemprop="text">
<p>You are running into a race condition. The array is trying to store values before the cloud can send it back. You need to do the operations asynchronously. One solution is to use the callback methods from Python multithreading. Alternatively, you could use some 'locking' mechanism and not execute the rest of the program till you get a response from the cloud.</p>
</div>
<span class="comment-copy">Could you possibly give me pointers to how to apply both of those potential solutions?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1239035/asynchronous-method-call-in-python">Here is a simple Stack Overflow Solution</a> for asynchronous calls. [Here] is python documentation for Synchronous calls (<a href="https://docs.python.org/3/library/asyncio-sync.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-sync.html</a>)</span>
