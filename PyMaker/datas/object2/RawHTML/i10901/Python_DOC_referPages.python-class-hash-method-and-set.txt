<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10547343/add-object-into-pythons-set-collection-and-determine-by-objects-attribute">add object into python's set collection and determine by object's attribute</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm using <code>set()</code> and <code>__hash__</code> method of <code>python</code> class to prevent adding same hash object in set. According to <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="noreferrer">python data-model document</a>, <code>set()</code> consider same hash object as same object and just add them once. </p>
<p>But it behaves different as below:  </p>
<pre><code>class MyClass(object):

    def __hash__(self):
        return 0

result = set()
result.add(MyClass())
result.add(MyClass())

print(len(result)) # len = 2
</code></pre>
<p>While in case of string value, it works correctly.</p>
<pre><code>result.add('aida')
result.add('aida')

print(len(result)) # len = 1
</code></pre>
<p>My question is: why the same hash objects are not same in set?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your reading is incorrect. The <code>__eq__</code> method is used for equality checks. The documents just state that the <code>__hash__</code> value must also be the same for 2 objects <code>a</code> and <code>b</code> for which <code>a == b</code> (i.e.  <code>a.__eq__(b)</code>) is true.</p>
<p>This is a common logic mistake: <code>a == b</code> being true <em><a href="https://en.wikipedia.org/wiki/Material_conditional" rel="nofollow noreferrer">implies</a></em> that <code>hash(a) == hash(b)</code> is also true. However, an implication does not necessarily mean <em><a href="https://en.wikipedia.org/wiki/Logical_equivalence" rel="nofollow noreferrer">equivalence</a></em>, that in addition to the prior, <code>hash(a) == hash(b)</code> would mean that <code>a == b</code>.</p>
<p>To make all instances of <code>MyClass</code> compare equal to each other, you need to provide an <code>__eq__</code> method for them; otherwise Python will compare their <em>identities instead</em>. This might do:</p>
<pre><code>class MyClass(object):
    def __hash__(self):
        return 0
    def __eq__(self, other):
        # another object is equal to self, iff 
        # it is an instance of MyClass
        return isinstance(other, MyClass)
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; result = set()
&gt;&gt;&gt; result.add(MyClass())
&gt;&gt;&gt; result.add(MyClass())
1
</code></pre>
<hr/>
<p>In reality you'd base the <code>__hash__</code> on those properties of your object that are used for <code>__eq__</code> comparison, for example:</p>
<pre><code>class Person
    def __init__(self, name, ssn):
        self.name = name
        self.ssn = ssn

    def __eq__(self, other):
        return isinstance(other, Person) and self.ssn == other.ssn

    def __hash__(self):
        # use the hashcode of self.ssn since that is used
        # for equality checks as well
        return hash(self.ssn)

p = Person('Foo Bar', 123456789)
q = Person('Fake Name', 123456789)
print(len({p, q})  # 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sets need <strong>two</strong> methods to make an object hashable: <code>__hash__</code> and <code>__eq__</code>. Two instances <strong>must</strong> return the same hash value when they are considered equal. An instance is considered already present in a set if both the hash is present in the set <em>and</em> the instance is considered equal to one of the instances with that same hash in the set.</p>
<p>Your class doesn't implement <code>__eq__</code>, so the default <code>object.__eq__</code> is used instead, which only returns true if <code>obj1 is obj2</code> is also true. In other words, two instances are only considered equal if they are <em>the exact same instance</em>. </p>
<p>Just because their hashes match, doesn't make them unique as far as a set is concerned; even objects with different hashes can end up in the same hash table slot, as the <em>modulus</em> of the hash against the table size is used.</p>
<p>Add your a custom <code>__eq__</code> method that returns <code>True</code> when two instances are supposed to be equal:</p>
<pre><code>def __eq__(self, other):
    if not isinstance(other, type(self)):
        return False
    # all instances of this class are considered equal to one another
    return True
</code></pre>
</div>
