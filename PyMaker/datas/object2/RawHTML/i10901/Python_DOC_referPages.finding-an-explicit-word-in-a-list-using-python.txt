<div class="post-text" itemprop="text">
<p>I have a key-value (ID, tag) formatted CSV file containing the following:</p>
<p>1,art</p>
<p>2,fine art;masterpiece</p>
<p>3,modern art</p>
<p>4,artifact;artefact</p>
<p>5,article</p>
<p>My goal is to use python to return only IDs 1, 2, and 3, which are the tags with the word "art" explicitly within them. When I use the find() function (myfile.find("art")), it finds IDs 1-5.  </p>
<p>My first thought was to look to the characters around the string "art" in the tags.  Maybe I could use the isalpha() function to ask if the character before and after the string "art" are indeed letters, not punctuation. However, this is one of the first python scripts I have written, so there may very well be a REGEX that does this in one line that I am not aware of.</p>
<p>Any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regex</a> with a <code>\b</code> assertion:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; pairs = ((1, "art"), (2, "fine art;masterpiece"), (3, "modern art"),
             (4, "artifact;artefact"), (5, "article"))
&gt;&gt;&gt; [id for id, tag in pairs if re.search(r"\bart\b", tag)]
[1, 2, 3]
</code></pre>
<p>As explained in the docs, <code>\b</code> matches a <em>boundary</em> between a 'word' and a 'non-word' character (or vice versa), or between a word character and the beginning/end of the string. </p>
</div>
<div class="post-text" itemprop="text">
<p>You need to build a lookup index which implements your indexing logic. Read your file, parse each CSV line, and update a lookup index based on a <code>dict</code> for example. Each item in the lookup index should be normalized, lower case for example, and points to a list of IDs.</p>
<p>Here is a small snippet:</p>
<pre><code>from StringIO import StringIO

file_content = StringIO('''1,art
2,fine art;masterpiece
3,modern art
4,artifact;artefact
5,article''')

_index = {}

for line in file_content:
    # parse CSV
    (_id, _, tags) = line.strip().partition(',')


    # parse tags
    tags = tags.split(';')

    tokens = set([])

    # tokenize tags
    for tag in tags:
        for token in tag.split(' '):
            # add normalized token to tokens set
            tokens.add(token.lower())

    # update index
    for token in tokens:
        if token in _index:
            _index[token].append(_id)
        else:
            _index[token] = [_id]

# lookup tag arg in your index
print _index['art']

&gt;&gt;&gt; ['1', '2', '3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this code:</p>
<pre><code>lines = ['art', 'fine art;masterpiece', 'modern art', 'artifact;artefact', 'article']
for l in lines:
    lis = [_.split(' ') for _ in l.split(';')] # Split the values.
    lis = [item for sublist in lis for item in sublist] # Flatten the list.
    print 'art' in lis # Check if 'art' is contained.
</code></pre>
<p>This allows you to determine the lines in which art (and not artifact) is containted. Or like this:</p>
<pre><code>lines = ['art', 'fine art;masterpiece', 'modern art', 'artifact;artefact', 'article']
idx = 1
for l in lines:
    lis = [_.split(' ') for _ in l.split(';')] # Split the values.
    lis = [item for sublist in lis for item in sublist] # Flatten the list.
    if 'art' in lis: # Check if 'art' is contained.
        print idx
    idx = idx + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple and Sweet : use \b - Word Boundaries</p>
<pre><code>a = ['1,art','2,fine art;masterpiece','3,modern art','4,artifact,artefact','5,article']
for data in a:
    output = re.search(r'\bart\b',data)
    if 'art' in str(output):
       ids = re.findall('\d+', data)
       print(ids)
</code></pre>
</div>
<span class="comment-copy">Wow, harsh to downvote this answer but its actually quite a duplicate of eugene y's answer... maybe because of that someone downvoted...</span>
