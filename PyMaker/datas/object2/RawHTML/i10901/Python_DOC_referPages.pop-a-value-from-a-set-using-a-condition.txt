<div class="post-text" itemprop="text">
<p>I have a set of objects, and I'd like to remove values of the set using a lambda expression or some kind of condition.</p>
<p>I'd do this like that:</p>
<pre><code>def pop(container, cond):
    value = None
    removed = False

    for x in container:
        if cond(x):
            value = x
            removed = True
            container.remove(x)
            break

     if not removed:
         raise Exception('No value to pop')

     return value
</code></pre>
<p>An example usecase is:</p>
<pre><code>compare_object = {"price": 100, "quantity": 1, "product_id": 2}
objs = set([....])

def comparison(obj):
    def wrap(obj2):
        return (
            obj2['price'] == obj['price'] and
            obj2['quantity'] == obj['quantity'] and
            obj2['product_id'] == obj['product_id']
        )


similar_obj = pop(objs, comparison(compare_object))
</code></pre>
<p>This way, we can get a similar object from a set and consequently the set will be reduced after a call to the method.</p>
<p>I'd like to know if there is a simpler way to do this with an actual data structure already available in python instead of looping over the set which could be expensive on big sets?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of your complicated <code>for</code> loop, you could create a <code>filter</code> from that condition (or <code>itertools.ifilter</code> for Python 2) and remove the <code>next</code> element from that filter.</p>
<pre><code>def pop(container, cond):
    try:
        value = next(filter(cond, container))
        container.remove(value)
        return value
    except StopIteration:
        raise Exception("No Value to pop")
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; cond = lambda x: x % 2 == 0
&gt;&gt;&gt; pop(lst, cond)
2
&gt;&gt;&gt; pop(lst, cond)
4
&gt;&gt;&gt; pop(lst, cond)
Exception: No Value to pop
&gt;&gt;&gt; lst
[1, 3, 5]
</code></pre>
<p>Or you could just simplify your function by immediately returning the found value:</p>
<pre><code>def pop(container, cond):
    for x in container:
        if cond(x):
            container.remove(x)
            return x
    raise Exception('No value to pop')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>pop()</code> method is basically a duplicate of the already builtin <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow"><code>filter()</code></a> in combination with calling <code>next()</code> on the resulting <code>filter</code> object. You can simplify your code to this:</p>
<pre><code>compare_object = {"price": 100, "quantity": 1, "product_id": 2}
objs = set([....])

def comparison(obj):
    def wrap(obj2):
        return (
            obj2['price'] == obj['price'] and
            obj2['quantity'] == obj['quantity'] and
            obj2['product_id'] == obj['product_id']
        )

similar_obj = next(filter(comparison(compare_object), objs))
</code></pre>
<p>This will raise <code>StopIteration</code> if there was no match.</p>
<p>As for performance: If you have a set, which by definition is unordered, and your condition has to get checked for each entry, there's no way around iterating over all the elements. But since you only retrieve the first occurence, it will practically never need to iterate over the whole set. Since <code>filter()</code> evaluates its results lazily, it behaves the same way and only iterates through the set until it finds the first match.</p>
</div>
<div class="post-text" itemprop="text">
<p>For some reasons, I decided to go with a <code>defaultdict</code> variant. Instead of using a <code>set</code>. I just store the data in a defaultdict with a list.</p>
<p>Setup the container:</p>
<pre><code>container = defaultdict(list)
for exp_line in exp_lines:
    container[(
        exp_line.unit_amount,
        exp_line.unit_quantity,
        exp_line.product_id,
        exp_line.uom_id
    )].append(exp_line)
</code></pre>
<p>Pop from the container:</p>
<pre><code>obj = container[(
    -(aal.amount/aal.unit_amount),
    aal.unit_amount,
    aal.product_id,
    aal.product_uom_id
)].pop()
</code></pre>
<p>The only downside I see with this method is that, there is no easy way to know if the container is empty or not. But trying to pop from an empty list will raise an exception just as expected and the data get actually removed from the container.</p>
<p>Since the condition is quite "fixed" just as if I was using a single condition for the set, it's much simpler that way. But if I had to use "custom" keys that can't be hashed. The other answers with "next/filter" would be a better tool I guess.</p>
<p>No algorithm there really.</p>
</div>
<span class="comment-copy">Ok ... So what is the problem?  Is there an error?</span>
<span class="comment-copy">Well no, I'd like to know if I'm reinventing the wheel or if there is a datastructure that just does that already.</span>
<span class="comment-copy">I don't think there is a builtin set-like object that does this.  <code>set</code> <i>does</i> have a <code>.pop</code> method, but it doesn't give you any control over what item is removed...</span>
<span class="comment-copy">The only problem I see with this method, is that I'm looping over the set.</span>
<span class="comment-copy">But unless the condition is related to the hash value of the item, there's no good way to map a condition to a particular item unless you know the conditions ahead of time and build some sort of auxiliary index.</span>
<span class="comment-copy">I like that, the filter is much more simpler and since it returns an iterator, I guess it won't be scanning the whole list.</span>
<span class="comment-copy">Ended up doing it with a defaultdict as my condition can be generated as keys of a dict of list.</span>
<span class="comment-copy">But this does not <code>pop</code> the element from the collection, right? Also, OP's original code will also stop as soon as it finds the first match, using <code>break</code>.</span>
<span class="comment-copy">Right, it does not. But since removing elements from a set is <code>O(1)</code> that can be done by calling <code>objs.remove(similar_obj)</code> afterwards without much extra cost.</span>
<span class="comment-copy">My version also stops at the first occurence, because <code>next()</code> is only called once on the <code>filter</code> object, which evaluates lazily</span>
<span class="comment-copy">Right, I might have misread, or maybe the wording was slightly off in the first version. I though you meant that OP's version would not do that.</span>
