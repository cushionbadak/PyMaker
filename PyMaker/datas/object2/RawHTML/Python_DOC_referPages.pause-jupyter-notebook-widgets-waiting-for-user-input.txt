<div class="post-text" itemprop="text">
<p>I have the same issue as TheInterestedOne <a href="https://stackoverflow.com/questions/54629964/how-to-pause-jupyter-notebook-widgets-waiting-for-user-input">asked</a>. I need to create two button for user, and suggest the user to click one of the two buttons in the loop, so that the next iteration of the loop occurs only after the user's choice. I read <a href="https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Asynchronous.html" rel="nofollow noreferrer">this source</a>, but I can't make it work for button. I don't understand, how widget attribute change in case of using button.</p>
<pre><code>from functools import wraps
def yield_for_change(widget, attribute):
    def f(iterator):
        @wraps(iterator)
        def inner():
            i = iterator()
            def next_i(change):
                try:
                    i.send(change.new)
                except StopIteration as e:
                    widget.unobserve(next_i, attribute)
            widget.observe(next_i, attribute) //**button.on_click(on_button_clicked) 
                                                                may be?**
            # start the generator
            next(i)
        return inner
    return f


from ipywidgets import Button
button=Button()


def on_button_clicked():
    print("Button clicked.")


@yield_for_change(button, 'value')
def f():
    for i in range(10):
        print('did work %s'%i)
        x = yield
        button.on_click(on_button_clicked)
</code></pre>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the example adapted for <code>Button</code>. Main changes are in the decorator, swapping <code>observe</code> for an <code>on_click</code>, which is sort of equivalent to observe for a Button.</p>
<pre class="lang-python prettyprint-override"><code>from functools import wraps
def yield_for_change(widget):
    def f(iterator):
        @wraps(iterator)
        def inner():
            i = iterator()
            def next_i(change):
                try:
                    i.send(change)
                except StopIteration as e:
                    widget.unobserve(next_i, attribute)
            widget.on_click(next_i)
            # start the generator
            next(i)
        return inner
    return f


from ipywidgets import Button
button=Button()

def on_button_clicked():
    print("Button clicked.")


@yield_for_change(button)
def f():
    for i in range(10):
        print('did work %s'%i)
        x = yield

f()

button
</code></pre>
</div>
<span class="comment-copy">Hi, and welcome to stackoverflow. You'll have a better chance of getting an answer from someone if you show a specific example of the code you've tried, and where it failed. See <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
