<div class="post-text" itemprop="text">
<p>I've extracted keywords based on 1-gram, 2-gram, 3-gram within a tokenized sentence</p>
<pre><code>list_of_keywords = []
for i in range(0, len(stemmed_words)):
    temp = []
    for j in range(0, len(stemmed_words[i])):
        temp.append([' '.join(x) for x in list(everygrams(stemmed_words[i][j], 1, 3)) if ' '.join(x) in set(New_vocabulary_list)])
    list_of_keywords.append(temp)
</code></pre>
<p>I've obtained keywords list as </p>
<pre><code>['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']
['sleep', 'anxiety', 'lack of sleep']
</code></pre>
<p>How can I simply the results by removing all substring within the list and remain:</p>
<pre><code>['high blood pressure']
['anxiety', 'lack of sleep']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use this one liner:</p>
<pre><code>b = ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']
result = [ i for i in b if not any( [ i in a for a in b if a != i]   )]
</code></pre>
<p>I admit this is O(n<sup>2</sup>) and maybe will be slow in performance for large inputs.</p>
<p>This is basically a list comprehension of the following:</p>
<pre><code>word_list =  ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']

result = []
for this_word in word_list:
    words_without_this_word = [ other_word  for other_word in word_list if other_word != this_word]  
    found = False
    for other_word in words_without_this_word:
        if this_word in other_word:
            found = True

    if not found:
        result.append(this_word)

result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have a large list of words, it might be a good idea to use a <a href="https://en.wikipedia.org/wiki/Suffix_tree" rel="nofollow noreferrer">suffix tree</a>.</p>
<p>Here's a <a href="https://pypi.org/project/suffix-trees/" rel="nofollow noreferrer">package</a> on PyPI.</p>
<p>Once you created the tree, you can call <code>find_all(word)</code> to get the index of every occurence of <code>word</code>. You simply need to keep the strings which only appear once:</p>
<pre><code>from suffix_trees import STree
# https://pypi.org/project/suffix-trees/
# pip install suffix-trees

words = ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure'] + ['sleep', 'anxiety', 'lack of sleep']
st = STree.STree(words)

st.find_all('blood')
# [0, 20, 26, 46]

st.find_all('high blood pressure')
# [41]

[word for word in words if len(st.find_all(word)) == 1]
# ['high blood pressure', 'anxiety', 'lack of sleep']
</code></pre>
<p><code>words</code> needs to be a unique list of strings, so you might need to call <code>list(set(words))</code> before generating the suffix-tree.</p>
<p>As far as I can tell, the whole script should run in <code>O(n)</code>, with <code>n</code> being the total length of the strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>assuming that order of your elements is from shortest string to longest string, you need to check if each element is substring of last one and then remove it from the list:</p>
<pre><code>symptoms = ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']


def removeSubstring(data):
    for symptom in data[:-1]:
        if symptom in data[-1]:
            print("Removing: ", symptom)
            data.remove(symptom)
    print(data)


removeSubstring(symptoms)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>words = ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']

superset_word = ''
#print (words)
for word in words:
    word_list_minus_word = [each for each in words if word != each]
    counter = 0
    for other_word in word_list_minus_word:
        if (other_word not in word):
            break
        else:
            counter += 1
    if (counter == len(word_list_minus_word)):
        superset_word = word
        break
print(superset_word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>grams = ['blood', 'pressure', 'high blood', 'blood pressure', 'high blood pressure']

unique_grams = [grams[i] for i in range(len(grams)) if not grams[i] in ' '.join(grams[i+1:])]
</code></pre>
</div>
<span class="comment-copy">Will all sub strings be split by a space? What should <code>['sub', 'string', 'substring']</code> become?</span>
<span class="comment-copy">I believe this will be slightly faster by removing the inner list comprehension, such that it becomes a generator comprehension, like so: <code>result = [i for i in b if not any(i in a for a in b if a != i)]</code></span>
<span class="comment-copy">Thanks, but the way u suggested would be only workable for 1 longest string, simply tried with <code>symptoms = ['blood', 'sleep', 'high blood pressure', 'lack of sleep']</code></span>
<span class="comment-copy">It’s normally a real bad idea to remove things from a list while you are iterating over it.</span>
<span class="comment-copy">@ChristianSloper can you elaborate why?</span>
<span class="comment-copy"><a href="https://www.quora.com/In-Python-why-cant-you-remove-elements-from-a-list-with-a-for-loop-but-you-can-with-a-while-loop" rel="nofollow noreferrer">quora.com/…</a></span>
<span class="comment-copy">This does not work on OP's second example</span>
<span class="comment-copy">It doesn't seem to work. For example with <code>grams = ['a b c', 'b c', 'a', 'b', 'c']</code>.</span>
