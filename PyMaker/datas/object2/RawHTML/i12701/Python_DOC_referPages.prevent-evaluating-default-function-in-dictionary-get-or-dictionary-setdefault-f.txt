<div class="post-text" itemprop="text">
<p>I'd like to keep track of <code>key-value</code> pairs I've processed already in a dictionary (or something else if it's better), where <code>key</code> is some input and <code>value</code> is the return output of some complex function/calculation. The main purpose is to prevent doing the same process over again if I wish to get the value for a key that has been seen before. I've tried using <code>setdefault</code> and <code>get</code> to solve this problem, but the function I call ends up getting executed regardless if the key exists in the dictionary.</p>
<p>Sample code:</p>
<pre><code>def complex_function(some_key):
    """
    Complex calculations using some_key
    """
    return some_value

# Get my_key's value in my_dict. If my_key has not been seen yet,
# calculate its value and set it to my_dict[my_key]
my_value = my_dict.setdefault(my_key, complex_function(my_key))
</code></pre>
<p><code>complex_function</code> ends up getting carried out regardless if <code>my_key</code> is in <code>my_dict</code>. I've also tried using <code>my_dict.get(my_key, complex_function(my_key))</code> with the same result. For now, this is my fixed solution:</p>
<pre><code>if my_key not in my_dict:
    my_dict[my_key] = complex_function(my_key)

my_value = my_dict[my_key]
</code></pre>
<p>Here are my questions. First, is using a dictionary for this purpose the right approach? Second, am I using <code>setdefault</code> correctly? And third, is my current fix a good solution to the problem? (I end up calling <code>my_dict[my_key]</code> twice if <code>my_key</code> doesn't exist)</p>
</div>
<div class="post-text" itemprop="text">
<p>So I went ahead and took Vincent's suggestion of using a decorator.</p>
<p>Here's what the new fix looks like:</p>
<pre><code>import functools

@functools.lru_cache(maxsize=16)
def complex_function(some_input):
    """
    Complex calculations using some_input
    """
    return some_value

my_value = complex_function(some_input)
</code></pre>
<p>From what I understand so far, <code>lru_cache</code> uses a dictionary to cache the results. The <code>key</code> in this dictionary refers to argument(s) to the decorated function (<code>some_input</code>) and the <code>value</code> refers to the return value of the decorated function (<code>some_value</code>). So, if the function gets called with an argument that's previously been passed before, it would simply return the value referenced in the decorator's dictionary instead of running the function. If the argument hasn't been seen, the function proceeds as normal, and in addition, the decorator creates a new key-value pair in its dictionary. </p>
<p>I set the <code>maxsize</code> to 16 for now as I don't expect <code>some_input</code> to represent more than 10 unique values. One thing to note is that the arguments for the decorated function are required to be non-mutable and hashable, as it uses the arguments as keys for its dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>original_dict = {"a" : "apple", "b" : "banana", "c" : "cat"}
keys = a.keys()
new_dict = {}
</code></pre>
<p>For every key that you access now, run the following command : </p>
<pre><code>new_dict[key] = value
</code></pre>
<p>To check if you have already accessed a key, run the following code : </p>
<pre><code>#if new_key is not yet accessed    
if not new_key in new_dict.keys() :   
   #read the value of new_key from original_dict and write to new_dict
    new_dict[new_key] = original_dict[new_key]  
</code></pre>
<p>I hope this helps</p>
</div>
<div class="post-text" itemprop="text">
<p>Your current solution is fine. You are creating slightly more work, but significantly reducing the computational workload when the key is already present.</p>
<p>However, <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a> is almost what you need here. By modifying it a little bit we can make it work exactly as you want.</p>
<pre><code>from collections import defaultdict

class DefaultKeyDict(defaultdict):
    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError(key)
        self[key] = value = self.default_factory(key)
        return value

d = DefaultKeyDict(lambda key: key * 2)

assert d[1] == 2
print(d)
</code></pre>
</div>
<span class="comment-copy">What you're trying to do is called <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a>. It's usually done by using a decorator. You can read <a href="http://stackoverflow.com/questions/14074249/efficient-generic-python-memoize">this question</a> to know how it's done. It's a better idea than trying to replicate the whole process yourself with a <code>defaultdict</code>.</span>
<span class="comment-copy">From what I've read so far, would simply putting <code>@lru_cache</code> above <code>def complex_function</code> and then have <code>my_value = complex_function(my_key)</code> do the trick?</span>
<span class="comment-copy">Yes, that's the idea. Note that <code>functools.lru_cache</code> is only available in Python 3. If you're running Python 2, you can either write your own function (which should be enough since it's not particularly hard to write) or use a third-party library.</span>
<span class="comment-copy">I would only intend to instantiate this <code>DefaultKeyDict</code> once if I were to define this class. Is this okay?  I'm still new to learning proper coding style and practice.</span>
<span class="comment-copy">That would be fine. If you really only intend to instantiate the class in one specific way then you could give the class a more specific name and put the relevant code directly in <code>__missing__</code>, rather than using <code>default_factory</code>.</span>
