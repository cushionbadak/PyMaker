<div class="post-text" itemprop="text">
<p>How can I wrap an open binary stream – a Python 2 <code>file</code>, a Python 3 <code>io.BufferedReader</code>, an <code>io.BytesIO</code> – in an <code>io.TextIOWrapper</code>?</p>
<p>I'm trying to write code that will work unchanged:</p>
<ul>
<li>Running on Python 2.</li>
<li>Running on Python 3.</li>
<li>With binary streams generated from the standard library (i.e. I can't control what type they are)</li>
<li>With binary streams made to be test doubles (i.e. no file handle, can't re-open).</li>
<li>Producing an <code>io.TextIOWrapper</code> that wraps the specified stream.</li>
</ul>
<p>The <code>io.TextIOWrapper</code> is needed because its API is expected by other parts of the standard library. Other file-like types exist, but don't provide the right API.</p>
<h1>Example</h1>
<p>Wrapping the binary stream presented as the <code>subprocess.Popen.stdout</code> attribute:</p>
<pre class="lang-python prettyprint-override"><code>import subprocess
import io

gnupg_subprocess = subprocess.Popen(
        ["gpg", "--version"], stdout=subprocess.PIPE)
gnupg_stdout = io.TextIOWrapper(gnupg_subprocess.stdout, encoding="utf-8")
</code></pre>
<p>In unit tests, the stream is replaced with an <code>io.BytesIO</code> instance to control its content without touching any subprocesses or filesystems.</p>
<pre class="lang-python prettyprint-override"><code>gnupg_subprocess.stdout = io.BytesIO("Lorem ipsum".encode("utf-8"))
</code></pre>
<p>That works fine on the streams created by Python 3's standard library. The same code, though, fails on streams generated by Python 2:</p>
<pre class="lang-python prettyprint-override"><code>[Python 2]
&gt;&gt;&gt; type(gnupg_subprocess.stdout)
&lt;type 'file'&gt;
&gt;&gt;&gt; gnupg_stdout = io.TextIOWrapper(gnupg_subprocess.stdout, encoding="utf-8")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'file' object has no attribute 'readable'
</code></pre>
<h1>Not a solution: Special treatment for <code>file</code></h1>
<p>An obvious response is to have a branch in the code which tests whether the stream actually is a Python 2 <code>file</code> object, and handle that differently from <code>io.*</code> objects.</p>
<p>That's not an option for well-tested code, because it makes a branch that unit tests – which, in order to run as fast as possible, must not create any <em>real</em> filesystem objects – can't exercise.</p>
<p>The unit tests will be providing test doubles, not real <code>file</code> objects. So creating a branch which won't be exercised by those test doubles is defeating the test suite.</p>
<h1>Not a solution: <code>io.open</code></h1>
<p>Some respondents suggest re-opening (e.g. with <code>io.open</code>) the underlying file handle:</p>
<pre class="lang-python prettyprint-override"><code>gnupg_stdout = io.open(
        gnupg_subprocess.stdout.fileno(), mode='r', encoding="utf-8")
</code></pre>
<p>That works on both Python 3 and Python 2:</p>
<pre class="lang-python prettyprint-override"><code>[Python 3]
&gt;&gt;&gt; type(gnupg_subprocess.stdout)
&lt;class '_io.BufferedReader'&gt;
&gt;&gt;&gt; gnupg_stdout = io.open(gnupg_subprocess.stdout.fileno(), mode='r', encoding="utf-8")
&gt;&gt;&gt; type(gnupg_stdout)
&lt;class '_io.TextIOWrapper'&gt;
</code></pre>
<pre class="lang-python prettyprint-override"><code>[Python 2]
&gt;&gt;&gt; type(gnupg_subprocess.stdout)
&lt;type 'file'&gt;
&gt;&gt;&gt; gnupg_stdout = io.open(gnupg_subprocess.stdout.fileno(), mode='r', encoding="utf-8")
&gt;&gt;&gt; type(gnupg_stdout)
&lt;type '_io.TextIOWrapper'&gt;
</code></pre>
<p>But of course it <strong>relies on re-opening a real file</strong> from its file handle. So it fails in unit tests when the test double is an <code>io.BytesIO</code> instance:</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; gnupg_subprocess.stdout = io.BytesIO("Lorem ipsum".encode("utf-8"))
&gt;&gt;&gt; type(gnupg_subprocess.stdout)
&lt;type '_io.BytesIO'&gt;
&gt;&gt;&gt; gnupg_stdout = io.open(gnupg_subprocess.stdout.fileno(), mode='r', encoding="utf-8")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
io.UnsupportedOperation: fileno
</code></pre>
<h1>Not a solution: <code>codecs.getreader</code></h1>
<p>The standard library also has the <code>codecs</code> module, which provides wrapper features:</p>
<pre class="lang-python prettyprint-override"><code>import codecs

gnupg_stdout = codecs.getreader("utf-8")(gnupg_subprocess.stdout)
</code></pre>
<p>That's good because it doesn't attempt to re-open the stream. But it fails to provide the <code>io.TextIOWrapper</code> API. Specifically, it <strong>doesn't inherit <code>io.IOBase</code></strong> and <strong>doesn't have the <code>encoding</code> attribute</strong>:</p>
<pre class="lang-python prettyprint-override"><code>&gt;&gt;&gt; type(gnupg_subprocess.stdout)
&lt;type 'file'&gt;
&gt;&gt;&gt; gnupg_stdout = codecs.getreader("utf-8")(gnupg_subprocess.stdout)
&gt;&gt;&gt; type(gnupg_stdout)
&lt;type 'instance'&gt;
&gt;&gt;&gt; isinstance(gnupg_stdout, io.IOBase)
False
&gt;&gt;&gt; gnupg_stdout.encoding
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python2.7/codecs.py", line 643, in __getattr__
    return getattr(self.stream, name)
AttributeError: '_io.BytesIO' object has no attribute 'encoding'
</code></pre>
<p>So <code>codecs</code> doesn't provide objects which substitute for <code>io.TextIOWrapper</code>.</p>
<h1>What to do?</h1>
<p>So how can I write code that works for both Python 2 and Python 3, with both the test doubles and the real objects, which <strong>wraps an <code>io.TextIOWrapper</code> around the already-open byte stream</strong>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/codecs.html#codecs.getreader" rel="noreferrer">codecs.getreader</a> to produce a wrapper object:</p>
<pre><code>text_stream = codecs.getreader("utf-8")(bytes_stream)
</code></pre>
<p>Works on Python 2 and Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns out you just need to wrap your <code>io.BytesIO</code> in <code>io.BufferedReader</code> which exists on both Python 2 and Python 3.</p>
<pre><code>import io

reader = io.BufferedReader(io.BytesIO("Lorem ipsum".encode("utf-8")))
wrapper = io.TextIOWrapper(reader)
wrapper.read()  # returns Lorem ipsum
</code></pre>
<p>This answer originally suggested using os.pipe, but the read-side of the pipe would have to be wrapped in io.BufferedReader on Python 2 anyway to work, so this solution is simpler and avoids allocating a pipe.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on multiple suggestions in various forums, and experimenting with the standard library to meet the criteria, my current conclusion is <strong>this can't be done</strong> with the library and types as we currently have them.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay, this seems to be a complete solution, for all cases mentioned in the question, tested with Python 2.7 and Python 3.5. The general solution ended up being re-opening the file descriptor, but instead of io.BytesIO you need to use a pipe for your test double so that you have a file descriptor.</p>
<pre><code>import io
import subprocess
import os

# Example function, re-opens a file descriptor for UTF-8 decoding,
# reads until EOF and prints what is read.
def read_as_utf8(fileno):
    fp = io.open(fileno, mode="r", encoding="utf-8", closefd=False)
    print(fp.read())
    fp.close()

# Subprocess
gpg = subprocess.Popen(["gpg", "--version"], stdout=subprocess.PIPE)
read_as_utf8(gpg.stdout.fileno())

# Normal file (contains "Lorem ipsum." as UTF-8 bytes)
normal_file = open("loremipsum.txt", "rb")
read_as_utf8(normal_file.fileno())  # prints "Lorem ipsum."

# Pipe (for test harness - write whatever you want into the pipe)
pipe_r, pipe_w = os.pipe()
os.write(pipe_w, "Lorem ipsum.".encode("utf-8"))
os.close(pipe_w)
read_as_utf8(pipe_r)  # prints "Lorem ipsum."
os.close(pipe_r)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I needed this as well, but based on the thread here, I determined that it was not possible using just Python 2's <code>io</code> module.  While this breaks your "Special treatment for <code>file</code>" rule, the technique I went with was to create an extremely thin wrapper for <code>file</code> (code below) that could then be wrapped in an <code>io.BufferedReader</code>, which can in turn be passed to the <code>io.TextIOWrapper</code> constructor.  It will be a pain to unit test, as obviously the new code path can't be tested on Python 3.</p>
<p>Incidentally, the reason the results of an <code>open()</code> can be passed directly to <code>io.TextIOWrapper</code> in Python 3 is because a binary-mode <code>open()</code> actually returns an <code>io.BufferedReader</code> instance to begin with (at least on Python 3.4, which is where I was testing at the time).</p>
<pre><code>import io
import six  # for six.PY2

if six.PY2:
    class _ReadableWrapper(object):
        def __init__(self, raw):
            self._raw = raw

        def readable(self):
            return True

        def writable(self):
            return False

        def seekable(self):
            return True

        def __getattr__(self, name):
            return getattr(self._raw, name)

def wrap_text(stream, *args, **kwargs):
    # Note: order important here, as 'file' doesn't exist in Python 3
    if six.PY2 and isinstance(stream, file):
        stream = io.BufferedReader(_ReadableWrapper(stream))

    return io.TextIOWrapper(stream)
</code></pre>
<p>At least this is small, so hopefully it minimizes the exposure for parts that cannot easily be unit tested.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's some code that I've tested in both python 2.7 and python 3.6.</p>
<p>The key here is that you need to use detach() on your previous stream first. This does not close the underlying file, it just rips out the raw stream object so that it can be reused. detach() will return an object that is wrappable with TextIOWrapper.</p>
<p>As an example here, I open a file in binary read mode, do a read on it like that, then I switch to a UTF-8 decoded text stream via io.TextIOWrapper.</p>
<p>I saved this example as this-file.py</p>
<pre class="lang-python prettyprint-override"><code>import io

fileName = 'this-file.py'
fp = io.open(fileName,'rb')
fp.seek(20)
someBytes = fp.read(10)
print(type(someBytes) + len(someBytes))

# now let's do some wrapping to get a new text (non-binary) stream
pos = fp.tell() # we're about to lose our position, so let's save it
newStream = io.TextIOWrapper(fp.detach(),'utf-8') # FYI -- fp is now unusable
newStream.seek(pos)
theRest = newStream.read()
print(type(theRest), len(theRest))
</code></pre>
<p>Here's what I get when I run it with both python2 and python3.</p>
<pre class="lang-bash prettyprint-override"><code>$ python2.7 this-file.py 
(&lt;type 'str'&gt;, 10)
(&lt;type 'unicode'&gt;, 406)
$ python3.6 this-file.py 
&lt;class 'bytes'&gt; 10
&lt;class 'str'&gt; 406
</code></pre>
<p>Obviously the print syntax is different and as expected the variable types differ between python versions but works like it should in both cases.</p>
</div>
<span class="comment-copy">re: <code>io.open</code> you could change unit tests, you know, e.g. a <code>tempfile.TemporaryFile()</code>; That's a hammer of a solution of course...</span>
<span class="comment-copy">This is a rather too limited set of restrictions. Unit tests <i>can</i> open files if that is absolutely the only way to properly test something, for example. So a wrapper function that can special-cases <code>file</code> objects to grab the file descriptor, can be tested with a unittest <i>just fine</i>.</span>
<span class="comment-copy">Thanks for the suggestion. That object doesn't provide enough of the <code>io.TextIOWrapper</code> API though, so isn't a solution.</span>
<span class="comment-copy">Ah, too bad. I guess you could put your test data in a file… :/</span>
<span class="comment-copy">Addressed in the question already: this needs to work also with test doubles that are not real files.</span>
<span class="comment-copy">Eventually I used a custom solution based on this. It doesn't address the requirements fully, so is not a solution; but I'm awarding the bounty as thanks for the help.</span>
<span class="comment-copy">Worked like a charm for me.  Used this technique in concert with the <code>csv</code> package and <code>boto</code> to stream CSV files from S3.</span>
<span class="comment-copy">A Python 2 <code>file</code> object (as created by many standard library functions) does not work when passed to the  <code>io.BufferedReader</code> constructor: <code>AttributeError: 'file' object has no attribute 'readable'</code>.</span>
<span class="comment-copy">Right, I read a few more branches of the question and see what you're getting at now. As you've determined in your own answer, I don't think you can do this for Py2 and Py3 without some tests of the type of object and branching.</span>
<span class="comment-copy">Given how ill advised wrapping the GnuPG binary in subprocess and similar calls is in the first place, that's probably a good thing. <i>Especially</i> in something allegedly meant to be stable, production code. Now granted, the GPGME bindings hadn't been merged with GPGME's master branch when you asked this question originally, but they have now and you've still got my email B1, so if this is a thing and the focus is actually GPG rather than data streams in general; it's time to get in touch. Regards, B2. ;)</span>
<span class="comment-copy">Already addressed in the question: The test doubles are not real files. <code>io.open</code> won't work because the test doubles can't be re-opened by path nor file handle.</span>
<span class="comment-copy">As stated in the answer, I’m addressing that by using pipes instead of BytesIO for the test doubles… or is there some reason you’re constrained to use BytesIO? It occurs to me that the very fact that BytesIO (on Python 2) isn’t enough “like” the objects you use in your real code is a good reason not to use it as a test double…</span>
<span class="comment-copy">The whole unit test suite is using <code>io.StringIO</code> and <code>io.BytesIO</code> for test doubles of a great many file operations. I'm ruling out “make a special set of test doubles just for this case” as a solution; I'm looking for a solution that works with the normal fake files (those that inherit from <code>io.IOBase</code>) and the normal real files of both Python versions.</span>
<span class="comment-copy">You could use the pipe code path for all situations then. Write the contents of your file, file pointer, bytesio etc to the pipe, and attach your reader to the read side, which will always be a file object.. It might be the only solution that works the right way, for all fake and real files, on both Py2 and Py3 with only one code path for all.</span>
