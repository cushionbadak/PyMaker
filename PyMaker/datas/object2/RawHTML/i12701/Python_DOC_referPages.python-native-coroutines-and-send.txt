<div class="post-text" itemprop="text">
<p>Generator based coroutines have a <code>send()</code> method which allow bidirectional communication between the caller and the callee and resumes a yielded generator coroutine from the caller. This is the functionality that turns generators into coroutines.</p>
<p>While the new native <code>async/await</code> coroutines provide superior support for async I/O, I do not see how to get the equivalent of <code>send()</code> with them. The use of <code>yield</code> in <code>async</code> functions is explicitly forbidden, so native coroutines can return only once using a <code>return</code> statement. Although <code>await</code> expressions bring new values into a coroutine, those values come from callees, not the caller, and the awaited call is evaluated from the beginning each time, not from where it left off.</p>
<p>Is there a way to resume a returned coroutine from where it left off and potentially send in a new value?
How can I emulate the techniques in David Beazley's <a href="http://www.dabeaz.com/coroutines/" rel="noreferrer">Curious Course on Coroutines and Concurrency</a> using native coroutines?</p>
<p>The general code pattern I have in mind is something like</p>
<pre><code>def myCoroutine():
  ...
  while True:
    ...
    ping = yield(pong)
    ...
</code></pre>
<p>and in the caller</p>
<pre><code>while True:
  ...
  buzz = myCoroutineGen.send(bizz)
  ...
</code></pre>
<hr/>
<h3>Edit</h3>
<p>I accepted Kevin's answer but I have noticed that the PEP <a href="https://www.python.org/dev/peps/pep-0492/#id63" rel="noreferrer">says</a></p>
<blockquote>
<p>Coroutines are based on generators internally, thus they share the implementation. Similarly to generator objects, coroutines have throw() , send() and close() methods.</p>
</blockquote>
<p>...</p>
<blockquote>
<p>throw() , send() methods for coroutines are used to push values and raise errors into Future-like objects.</p>
</blockquote>
<p>So apparently native coroutines do have a <code>send()</code>? How does it work without <code>yield</code> expression to receive the values inside the coroutine?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a way to resume a returned coroutine from where it left off and potentially send in a new value?</p>
</blockquote>
<p>No.</p>
<p><code>async</code> and <code>await</code> are <em>just</em> syntactic sugar for <code>yield from</code>.  When a coroutine returns (with the <code>return</code> statement), that's it.  The frame is gone.  It is not resumable.  This is exactly how generators have always worked.  For example:</p>
<pre><code>def foo():
    return (yield)
</code></pre>
<p>You can do <code>f = foo(); next(f); f.send(5)</code>, and you will get back 5.  But if you try to <code>f.send()</code> again, it does not work, because you already returned from the frame.  <code>f</code> is no longer a live generator.</p>
<p>Now, as for new coroutines, so far as I can tell, it seems yielding and sending is reserved for communication between the event loop and certain basic predicates such as <code>asyncio.sleep()</code>.  The coroutines yield <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future" rel="nofollow"><code>asyncio.Future</code></a> objects up to the event loop, and the event loop sends those same future objects back into the coroutine once the associated operations have been completed (they are typically scheduled via <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon" rel="nofollow"><code>call_soon()</code></a> and the other event loop methods).</p>
<p>You can yield future objects by awaiting them, but it's not a general-purpose interface like <code>.send()</code> was.  It is specifically intended for use by the event loop implementation.  If you are not implementing an event loop, you probably do not want to be playing around with this.  If you <em>are</em> implementing an event loop, you need to ask yourself why the perfectly good implementations in <code>asyncio</code> are not sufficient for your purposes and explain what <em>specifically</em> you are trying to do before we can help you.</p>
<p>Please note that <code>yield from</code> is not deprecated.  If you want coroutines that are not tied to an event loop at all, just use that instead.  <code>async</code> and <code>await</code> are <a href="https://www.python.org/dev/peps/pep-0492/#abstract" rel="nofollow">specifically designed for asynchronous programming with event loops</a>.  If that is not what you are doing, then <code>async</code> and <code>await</code> are the wrong tool to begin with.</p>
<p>One more thing:</p>
<blockquote>
<p>The use of <code>yield</code> in async functions is explicitly forbidden, so native coroutines can return only once using a <code>return</code> statement.</p>
</blockquote>
<p><code>await</code> expressions <em>do</em> yield control.  <code>await something()</code> is entirely analogous to <code>yield from something()</code>.  They just changed the name so it would be more intuitive to people not familiar with generators.</p>
<hr/>
<p>For those of you who actually are interested in implementing your own event loop, <a href="https://bitbucket.org/NYKevin/nbtparse/src/e1aec5c6b1691d305a94839791b308835cdadaaf/nbtparse/_utils.py?at=optionally-async&amp;fileviewer=file-view-default#_utils.py-85" rel="nofollow">here's some example code</a> showing a (very minimal) implementation.  This event loop is extremely stripped down, because it is designed to run certain specially-written coroutines synchronously as if they were normal functions.  It does not provide the full range of support you would expect from a real <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop" rel="nofollow">BaseEventLoop</a> implementation, and is not safe for use with arbitrary coroutines.</p>
<p>Ordinarily, I would include the code in my answer, rather than linking to it, but there are copyright concerns and it is not critical to the answer itself.</p>
</div>
<span class="comment-copy">It's still not clear to me what problem you are trying to solve by using this code pattern, or why you can't just use <code>yield from</code> generator-coroutines instead.</span>
<span class="comment-copy">I wanted to see how to port David Beazley's code that the question links to, but that is not what async/await are meant for.</span>
<span class="comment-copy"><i>The frame is gone. It is not resumable.</i> Is it correct to call the new feature coroutines then? Historically the ability to save state and resume has been the defining feature of coroutines.  <i>This is exactly how generators have always worked.</i> I do not understand. A loop with a <code>yield</code> behaves exactly</span>
<span class="comment-copy">@DanielMahler: State does get saved and restored every time you <code>await</code>.  It's just that the control ultimately passes back to the event loop, which is code you (usually) did not write.  But <code>return</code> has exactly the same meaning in new coroutines as it did in old generator coroutines: tear down the frame.</span>
<span class="comment-copy">Ok, but <code>yield</code> is what makes generators tick. My question is really about native coroutines being a complete replacement for generator coroutines, as they are being promoted, but I am not sure they are actually coroutines.</span>
<span class="comment-copy">@DanielMahler: Nobody said they were a complete replacement.  They are <a href="https://www.python.org/dev/peps/pep-0492/#abstract" rel="nofollow noreferrer">specifically designed for <i>asynchronous programming</i></a>, which necessarily means you are yielding up to an event loop rather than arbitrary code.</span>
<span class="comment-copy">Ah ok, I thought I read some propaganda to the effect that generator coroutines were being deprecated, but this makes more sense. I think that the name <i>coroutines</i> is misleading for this though.</span>
