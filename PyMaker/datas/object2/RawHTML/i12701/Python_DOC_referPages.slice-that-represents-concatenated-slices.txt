<div class="post-text" itemprop="text">
<p>The indices of a slice <code>slice(start, stop[, step])</code> can be often represented by <code>range(start, stop, step)</code> (or <code>range(*slice(start, stop, step).indices(length))</code> when taking the underlying dimensions into account).</p>
<p>Let's say I have even two, multidimensional slices and the second slice could be used as a slice into the result of applying the first slice.</p>
<p>Example:</p>
<pre><code>import numpy as np
data = np.random.rand(*(100, 100, 100))
a = data[::2, 7, :] # slice 1, a.shape = (50,100)
b = a[1, ::-1] # slice 2, b.shape = (100,)
</code></pre>
<p>I would like to find a general expression for calculating the single slice that does the same job. I know the dimensions of the underlying data structure.</p>
<pre><code>c = data[2, 7, ::-1] # same as b
np.array_equal(b, c) # True
</code></pre>
<p>So, in getting from <code>[::2, 7, :]</code> and <code>[1, ::-1]</code> to <code>[2, 7, ::-1]</code>  in this example I would need a function like:</p>
<pre><code>def concatenate_slices(shape, outer_slice, inner_slice):
    ...
    return combined_slice
</code></pre>
<p>where <code>outer_slice</code> and <code>inner_slice</code> would both be a tuple of slices. In the example <code>shape=(100, 100, 100)</code> and <code>outer_slice=(slice(None, None, 2), 7, slice(None, None, None))</code> and <code>inner_slice=(1, slice(None, None, -1))</code>.</p>
<p>I'm not sure how to do that efficiently.</p>
<p>My objects do something when <code>__getitem__(slice)</code> is called (no intermediate views) and I want to do that only once but still have the possibility to have slices of slices.</p>
<p>As an extension (optional) I would like to know what happens if I have ellipses in the slices. How can I then make the combination?</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect you just have to go through the tedium of a analyzing each dimension, to build up either a new slice or an array of indices.  I doubt if there's a short cut.</p>
<p>To illustrate take your example:</p>
<pre><code>In [77]: shape=(100,100,100)
In [78]: outer_slice=(slice(None, None, 2), 7, slice(None, None, None))
In [79]: inner_slice=(1, slice(None, None, -1))
</code></pre>
<p>The target is (right?):</p>
<pre><code>(2, 7, slice(None,None,-1))
</code></pre>
<p>First dimension - make an array of the whole range of indices, and slice them sequentially:</p>
<pre><code>In [80]: idx=np.arange(shape[0])
In [81]: idx[outer_slice[0]][inner_slice[0]]
Out[81]: 2
</code></pre>
<p>Could I deduce that from [::2] and [1]?  I have to reason that it starts at 0, the shape is large enough to yield a 2nd value, etc </p>
<p>Now for the 2nd dimension.  That's a scalar, so there's no corresponding <code>inner</code> slice.</p>
<pre><code>In [82]: outer_slice[1]
Out[82]: 7
</code></pre>
<p>For the third, let's do that same as with the 1st, but taking into account the offset between outer and inner lists:</p>
<pre><code>In [83]: idx=np.arange(shape[2])
In [84]: idx[outer_slice[2]][inner_slice[1]]
Out[84]: 
array([99, 98, 97, 96, 95, 94, 93, 92, 91,  ....7,  6,  5,  4,  3,  2,  1,  0])
</code></pre>
<p>Or I could deduce that <code>outer_slice[2]</code> does nothing, so I can use <code>inner_slice[1]</code> directly.</p>
<p>Of course it would be just as easy and efficient to apply the two slice tuples to the actual array.</p>
<pre><code>X[outer_slice][inner_slice]
</code></pre>
<p>As long as <code>outer_slice</code> produces a view, combining them into a composite slice is not much of an improvement.</p>
<p>With shape and the slice tuples there's enough information to build a new tuple.  But it appears that the required logic will be quite involved, and require an in depth knowledge of slicing, and lots of testing.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's start with the simple case: 1-d arrays. We'll need to keep track of the <code>start</code>, <code>stop</code>, and <code>step</code> values for the final slice, which we can update like so:</p>
<pre><code>def update_1d(a, b, length):
  a_start, a_stop, a_step = a.indices(length)
  a_length = len(xrange(a_start, a_stop, a_step))
  if a_length == 0:
    # doesn't matter what b is if data[a] is []
    return a
  b_start, b_stop, b_step = b.indices(a_length)
  b_length = len(xrange(b_start, b_stop, b_step))
  if b_length == 0:
    # result will be empty, so we can exit early
    return slice(0, 0, 1)
  # convert b's start into a's coordinates, without wrapping around
  start = max(0, a_start + b_start * a_step)
  # steps are multiplicative, which makes things easy
  step = a_step * b_step
  # the stop index is the hard part because it depends on the sign of both steps
  x = a_start + b_stop * a_step
  if step &lt; 0:
    # indexing backwards, so truncate if b's converted step goes below zero
    stop = x if x &gt;= 0 else None
  elif a_step &gt; 0:
    # both steps are positive, so take the smallest stop index
    stop = min(a_stop, x)
  else:
    # both steps are negative, so take the largest stop index
    stop = max(a_stop, x)
  return slice(start, stop, step)
</code></pre>
<p>Note that this expects <code>a</code> and <code>b</code> to be slices. You can usually convert other forms into slice objects, though. This even includes <code>Ellipsis</code> objects, assuming you know how many dimensions you have.</p>
<p>To extend this to the multidimensional case, we'll need to do some bookkeeping to keep track of which original dimension is getting sliced. For example, if you have <code>data[::2, 7, :][:, 2:-2]</code>, you'll have to map the second dimension of the second slice to the third dimension of the first slice.</p>
</div>
<span class="comment-copy">just for reference: <code>range(start, stop, step)</code> doesn't always produce the correct indices as it may also produce indices out of range, to create a valid range <a href="https://docs.python.org/3/reference/datamodel.html?highlight=slice.indices#slice.indices" rel="nofollow noreferrer"><code>slice.indices()</code></a> needs to be used:<code>range(*slice(start, stop, step).indices(length))</code>. I'm not sure if it is possible to combine slices without taking the shape of the underlying structure into account.</span>
<span class="comment-copy">@mata Thanks. You're right. Also in my case I would know the shape of the underlying structure. I edited a bit.</span>
<span class="comment-copy">I guess it could be done with manually putting together a new slice by looking at the limits of the first two. I started writing it up but it's way too messy for my taste, there should be a better way (so I gave up).</span>
<span class="comment-copy">I think you do need to know the dimensionality of the data.  Say vec=np.arange(10).  vec[::6] will be [0, 6].    vec[::6][::-1] will be [6, 0].  The equivalent slice would have been vec[6:-1:-6].  Now suppose vec=np.arange(13).  Now vec[::6][::-1] gives you [12,  6,  0].  So without knowing the array size you don't know where to start counting down from when you reverse the slice.</span>
<span class="comment-copy">@Peter Right. The shape must be known and used. I added to the question, that I know it.</span>
<span class="comment-copy">Check this case: <code>a = slice(-1, 1, -2)</code>, <code>b = slice(0, -1, 1)</code>, <code>length=16</code>.</span>
<span class="comment-copy">Thanks. That is already a good start. len(xrange()) should be inefficient Could one use floor((stop - start) / step) instead?</span>
<span class="comment-copy"><code>len(xrange(...))</code> is actually quite fast, because the <code>xrange</code> object does essentially the same thing you suggested, but in C code. Also, Warren is right, the code I posted doesn't work for all cases. Stay tuned for a better version soon.</span>
<span class="comment-copy">@WarrenWeckesser this new version should have all the edge cases covered.</span>
