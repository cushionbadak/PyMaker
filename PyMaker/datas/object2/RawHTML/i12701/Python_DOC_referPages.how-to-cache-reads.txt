<div class="post-text" itemprop="text">
<p>I am using python/pysam to do analyze sequencing data. In its tutorial (<a href="http://pysam.readthedocs.org/en/latest/api.html#pysam.AlignmentFile.mate" rel="nofollow noreferrer">pysam - An interface for reading and writing SAM files</a>) for the command mate it says:</p>
<p>'This method is too slow for high-throughput processing. If a read needs to be processed with its mate, work from a read name sorted file or, better, cache reads.'</p>
<p>How would you 'cache reads'?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://en.wikipedia.org/wiki/Memoization">Caching</a> is a typical approach to speed up long running operations. It sacrifices memory for the sake of computational speed.</p>
<p>Let's suppose you have a function which given a set of parameters always returns the same result. Unfortunately this function is very slow and you need to call it a considerable amount of times slowing down your program.</p>
<p>What you could do, is storing a limited amount of {parameters: result} combinations and skip its logic any time the function is called with the same parameters.</p>
<p>It's a dirty trick but quite effective especially if the parameters combination is low compared to the function speed.</p>
<p>In Python 3 there's a <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">decorator</a> for this purpose.<br/>
In Python 2 a <a href="https://pypi.python.org/pypi/Brownie/0.5.1">library</a> can help but you need a bit more work.</p>
</div>
<div class="post-text" itemprop="text">
<p>AlignmentFile takes as the first argument:</p>
<blockquote>
<p>filepath_or_object</p>
</blockquote>
<p>So instead of supplying a filename, you can supply an object that supports a file-like interface, i.e. the methods <code>seek</code>, <code>read</code>, <code>tell</code>.
When implementing a class for this, you can also implement caching on the reads, which of course have to depend on current cursor position.</p>
<p>If filesize is small enough so that it fits into memory, you can read the complete file and operate on an <code>io.BytesIO</code> object, no need to make your own class:</p>
<pre><code>data = io.BytesIO(open('datafile','rb').read())
your_object = AlignmentFile(data, &lt;other args&gt;)
</code></pre>
<p>I am not sure that this will speed things up much, because i assume that modern operating systems (i know linux will do that) do cache file access. So maybe it is enough to rely on that.</p>
</div>
