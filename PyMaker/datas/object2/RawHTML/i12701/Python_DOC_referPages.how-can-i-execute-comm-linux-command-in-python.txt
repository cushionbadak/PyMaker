<div class="post-text" itemprop="text">
<p>I want to extract lines from File1 which are not present in File2</p>
<p>File1</p>
<pre><code>a  
b  
c  
</code></pre>
<p>File2</p>
<pre><code>a  
c  
</code></pre>
<p>so the output should be:</p>
<pre><code>b  
</code></pre>
<p>One possible command in bash is:</p>
<pre><code>comm -23 &lt;(sort File1) &lt;(sort File2) &gt; File  
</code></pre>
<p>And it works perfectly well in bash, but I don't know how correctly to implement in Python.</p>
<p>I've tried with</p>
<pre><code>import os  
os.system("comm -23 &lt;(sort File1) &lt;(sort File2) &gt; File")  
</code></pre>
<p>And is not working.
Any hint?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you <strong>must</strong> use a shell, do it safely:</p>
<pre><code>subprocess.call(['bash', '-c',
    'comm -23 &lt;(sort "$1") &lt;(sort "$2") &gt;"$3"', '_',
    infile1_name, infile2_name, outfile_name])
</code></pre>
<p>That is to say: Instead of passing the filenames in as part of your code, pass them as out-of-band variables such that their names can't be interpreted by the shell.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about a pure python solution?</p>
<pre><code>with open('file1', 'r') as f:
    lines1 = set(f.read().splitlines())

with open('file2', 'r') as f:
    lines2 = set(f.read().splitlines())

print(lines1.difference(lines2))
</code></pre>
<p>Or with less memory overhead:</p>
<pre><code>with open('file1') as f, open('file2') as f2:
    lines1 = set(map(str.rstrip, f))
    print(lines1.difference(map(str.rstrip, f2)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't work because you need use <code>bash</code> run the command:</p>
<pre><code>os.system("bash -c 'comm -23 &lt;(sort File1) &lt;(sort File2) &gt; File'")
</code></pre>
<p>Normally, <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow"><code>os.system()</code></a> use <code>sh</code> run the command. But however, there's little different between <code>bash</code> and <code>sh</code>.</p>
<p>So in this case, I used <code>bash -c 'command'</code> call <code>bash</code> run the command. Then it could works.</p>
<p>From the manual of <code>bash</code>:</p>
<blockquote>
<p><code>-c</code>     If the <code>-c</code> option is present, then commands are read from the first non-option argument <code>command_string</code>.</p>
<p>If there are arguments after the <code>command_string</code>, they are assigned to the positional parameters, starting with <code>$0</code>.</p>
</blockquote>
</div>
<span class="comment-copy">Do yourself a favour and use <code>subprocess</code></span>
<span class="comment-copy">How it will be subprocess implementation? @padraic-cunningham</span>
<span class="comment-copy">Why bother? You can implement this kind of logic natively in Python so, so very easily...</span>
<span class="comment-copy">@josifoski, i meant more in general, I agree with charles, doing it with just python is a whole lot simpler</span>
<span class="comment-copy">Some says, linux in â™¡</span>
<span class="comment-copy">for details, i'll have to accept your answer.</span>
<span class="comment-copy">tnx :) +1, will reconsider will be pure python solution or bash style</span>
<span class="comment-copy">why not just call set on the file objects instead of creating multiple copies of the data?</span>
<span class="comment-copy">Depends on if you want endlines in the sets. I didn't want them.</span>
<span class="comment-copy"><code>set(map(str.rstrip,f))</code> <code>set(itertools.imap(str.rstrip,f))</code></span>
<span class="comment-copy">it does not create potentially huge amounts of data in memory, you can also  completely forget about calling set on the second file and <code>set(map(str.rstrip,f)).difference(map(str.rstrip, f2))</code>, the point of using <code>difference</code> is that you don't need the second iterable to be a set.</span>
<span class="comment-copy">My place works perfectly!</span>
<span class="comment-copy">There's security risk to doing it this way -- look at what happens if one of your filenames contains the literal string <code>$(rm -rf ~)</code>.</span>
<span class="comment-copy">so crossplatform is better then donkey direction. Tnx for advice</span>
<span class="comment-copy">@josifoski, ..."donkey direction"?</span>
<span class="comment-copy">only preffering linux kind of thinking. It will be some difficulties if not crossplatforming implemented in any program</span>
