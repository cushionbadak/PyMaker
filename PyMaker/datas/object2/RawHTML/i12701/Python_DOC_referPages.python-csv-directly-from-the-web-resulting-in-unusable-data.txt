<div class="post-text" itemprop="text">
<p>I'm using Python 3.5 on Windows.</p>
<p>I have this little piece of code that downloads close to one hundred CSV files from different URLs stored in <code>Links.txt</code>:</p>
<pre><code>from urllib import request

new_lines = 'None'


def download_data(csv_url):
    response = request.urlopen(csv_url)
    csv = response.read()
    csv_str = str(csv)
    global new_lines
    new_lines = csv_str.split("\\n")

with open('Links.txt') as file:
    for line in file:
        URL = line
        file_name = URL[54:].rsplit('.ST', 1)[0]
        download_data(URL)
        save_destination = 'C:\\Download data\\Data\\' + file_name + '.csv'
        fx = open(save_destination, "w")
        for lines in new_lines:
            fx.write(lines+"\n")
        fx.close()
</code></pre>
<p>The problem is that the CSV files generated always starts with <code>b '</code> and after the last line of the data follows another <code>'</code> and a couple of empty rows to wrap things up. I do not see these characters when I look at the files from the browser (before I download them).</p>
<p>This creates problems when I want to import and use the data in a database. Do you have any idea on why this happens and how I can get the code to write the CSV files correctly?</p>
<p>Tips that can make the code faster/better, or adjustments for other flaws in the code are obviously very welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>What's happening is that <code>urllib</code> treats its stream as bytes - any string that looks like <code>b'...'</code> means it's a byte-string.</p>
<p>Your immediate problem could be solved by encoding the stream by calling <code>decode('utf-8')</code> (as Chedy2149 shows), which will convert the data's bytes.</p>
<p>However, you can complete elide this problem by downloading the file directly to disk. You go through the work of downloading it, splitting it, and writing it to disk, but all that seems unnecessary because your code just ultimately writes the file's contents to disk without additional work against them.</p>
<p>You can use <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve" rel="nofollow"><code>urllib.request.urlretrieve</code></a> and download to a file directly.</p>
<p>Here's an example, modified from your code.</p>
<pre><code>import urllib.request

def download_data(url, file_to_save):
    filename, rsp = urllib.request.urlretrieve(url, file_to_save)
    # Assuming everything worked, the file has been downloaded to file_to_save

with open('Links.txt') as file:
    for line in file:
        url = line.rstrip() # adding this here to remove extraneous '\n' from string
        file_name = url[54:].rsplit('.ST', 1)[0]
        save_destination = 'C:\\Download data\\Data\\' + file_name + '.csv'
        download_data(url, save_destination)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the <code>download_data</code> function you need to convert the byte string csv response to a plain string.<br/>
<strong>Try replacing</strong> <code>csv_str = str(csv)</code> <strong>by</strong> <code>csv_str = csv.decode('utf-8')</code>.</p>
<p>This should properly decode the byte string returned by <code>response.read()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that your function returns a <code>bytes</code> object; <code>str()</code> doesn't convert it to a string the way you expect. Use <code>csv_str = csv.decode()</code> instead.</p>
</div>
<span class="comment-copy">What mechanism do you use to see the <code>b'...'</code>? That's the python3 representation of a byte string that has not been decoded into a unicode <code>str</code> but nothing in your code is writing the <code>repr</code> version of the string.</span>
<span class="comment-copy">Thank you very much, this works great! As suggested before the problem was solved with the help of <code>decode('utf-8')</code>, however, I chose to use your suggestion of <code>urlretrieve</code> for the sake of readability and simplicity.</span>
<span class="comment-copy">I don't think so. <code>str(csv)</code> decodes using the default codec and you end up with a <code>str</code> not <code>bytes</code>.</span>
<span class="comment-copy">Wow. I take it back. Although the docs prototype it as <code>class str(object=b'', encoding='utf-8', errors='strict')</code> (that is, encoding defaults to utf-8) the description says <i>"If neither encoding nor errors is given, str(object) returns object.__str__(), which is the “informal” or nicely printable string representation of object"</i>. For <code>bytes</code>, that's <code>"b'....'</code>. So, yeah, this is the solution.</span>
<span class="comment-copy">This worked great. Thank you!</span>
