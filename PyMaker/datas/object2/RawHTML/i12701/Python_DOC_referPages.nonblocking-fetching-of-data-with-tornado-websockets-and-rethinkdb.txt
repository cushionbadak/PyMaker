<div class="post-text" itemprop="text">
<p>When I receive a message from a client I want to run multiple RethinkDB queries in parallel and send the results the client immediately. </p>
<p>The blocking way is below. A count can take minutes. I would like the other queries that would return faster to not be held up by the count query. </p>
<pre><code>self.write_message({'count': r.db('public').table(message['table']).count().run(conn)})
self.write_message({'rows': r.db('public').table(message['table']).limit(10).run(conn)})
</code></pre>
<p>I suspect I need a combination of <a href="https://rethinkdb.com/blog/async-drivers/" rel="nofollow">https://rethinkdb.com/blog/async-drivers/</a> and <a href="http://www.tornadoweb.org/en/stable/guide/async.html" rel="nofollow">http://www.tornadoweb.org/en/stable/guide/async.html</a></p>
<p>I'm thinking maybe the answer is to make those two lines something like:</p>
<pre><code>ioloop.IOLoop.current().add_callback(run_query, r.db('public').table(message['table']).count(), 'count', self)
ioloop.IOLoop.current().add_callback(run_query, r.db('public').table(message['table']).limit(10), 'rows', self)
</code></pre>
<p>My run-query would be:</p>
<pre><code>@gen.coroutine
def run_query(query, key, ws):
    conn = yield r.connect(host="localhost", port=28015)
    results = yield query.run(conn)
    ws.write_message({key: results})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>tornado.gen</code> <a href="http://tornadokevinlee.readthedocs.org/en/latest/gen.html" rel="nofollow">doc</a> reveals solution:</p>
<blockquote>
<p>You can also yield a list or dict of Futures, which will be started at
  the same time and run in parallel; a list or dict of results will be
  returned when they are all finished.</p>
</blockquote>
<pre><code># do not forget about this
r.set_loop_type("tornado")

@gen.coroutine
def run_parallel(query, key, ws):
    conn = yield r.connect(host="localhost", port=28015)
    ret = yield {
        'count': r.db('public').table(message['table']).count().run(conn),
        'rows': r.db('public').table(message['table']).limit(10).run(conn)
    }
    ws.write_message(ret)
</code></pre>
<p>Yielding list or dict directly has important behaviour - if any of Futures  has failed, <code>yield</code> will return immediately and will re-raise exception regardless of whether the other Futures are completed. To bypass it you can instead use <a href="http://tornadokevinlee.readthedocs.org/en/latest/gen.html#tornado.gen.Multi" rel="nofollow">Mulit</a> or <a href="http://tornadokevinlee.readthedocs.org/en/latest/gen.html#tornado.gen.multi_future" rel="nofollow">multi_future</a>.</p>
<p>Note: I really don't know if RethinkDB requires separate connections, but I want to show concept.</p>
</div>
<span class="comment-copy">Is there any reason why this needs to happen in tornado? This is exactly what node.js is very good at.</span>
<span class="comment-copy">Only because I find the Python language more enjoyable to work with.</span>
<span class="comment-copy">Agreed. But as much as I love python I've come to accept that javascript is almost always the best tool for the job when it comes to realtime web applications.</span>
<span class="comment-copy">That being said, python might be <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">catching up soon</a> and I'm hoping we'll start to see more python solutions.</span>
