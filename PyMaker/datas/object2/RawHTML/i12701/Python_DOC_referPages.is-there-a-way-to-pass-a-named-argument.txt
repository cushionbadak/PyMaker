<div class="post-text" itemprop="text">
<p>Here's my code:</p>
<pre><code>def update_tags_with_value(tags, many_to_many_class):
    if tags:
        many_to_many_class.objects.filter(
            personne=self.instance,

            date_v_fin=None
        ).update(date_v_fin=django_datetime.now())
        for idx_tag_with_value in tags:
            pl = many_to_many_class.objects.create(
                personne=self.instance,
                langue=TagWithValue.objects.get(
                    pk=idx_tag_with_value
                )
            )
            pl.save()

update_tags_with_value(self.cleaned_data.get('known_languages'),
                       PersonneLangue)
update_tags_with_value(self.cleaned_data.get('types_permis'),
                       PersonneTypesPermis)
</code></pre>
<p>So I found out I can easily pass a class as a parameter. But the last problem is about the named argument. If you watch my code, I do a <code>langue=TagWithValue..[blabla]</code>. The problem is that it's a "named" parameter, and I'd like to be able to pass it like that:</p>
<pre><code>update_tags_with_value(self.cleaned_data.get('known_languages'),
                       PersonneLangue, 'langue')
update_tags_with_value(self.cleaned_data.get('types_permis'),
                       PersonneTypesPermis, 'permis')
</code></pre>
<p>And then to call it somehow like that (it doesn't work <em>yet</em>):</p>
<pre><code>    def update_tags_with_value(tags, many_to_many_class, champ):
        if tags:
            many_to_many_class.objects.filter(
                personne=self.instance,

                date_v_fin=None
            ).update(date_v_fin=django_datetime.now())
            for idx_tag_with_value in tags:
                pl = many_to_many_class.objects.create(
                    personne=self.instance,
                    champ=TagWithValue.objects.get(
                        pk=idx_tag_with_value
                    )
                )
                pl.save()
</code></pre>
<p>For now I get this error:</p>
<pre><code>'champ' is an invalid keyword argument for this function
</code></pre>
<p>To be more precise, I need to call <code>many_to_many_class.objects.create()</code> one time with <code>known_languages=blabla</code> and another time with <code>types_permis=blabla</code> which, in other words, should call once <code>many_to_many_class.objects.create(known_languages=blabla)</code> and <code>many_to_many_class.objects.create(types_permis=blabla)</code> and I would like to know if there's a way to precise <em>only the name of the parameter</em>, <strong>not</strong> <code>blabla</code></p>
<p>How to solve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>That is extremely not recommended, but it is possible by using <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow"><code>exec()</code></a> function.</p>
<pre><code>def update_tags_with_value(tags, many_to_many_class, champ):
    if tags:
        many_to_many_class.objects.filter(
            personne=self.instance,
            date_v_fin=None
            ).update(date_v_fin=django_datetime.now())

        for idx_tag_with_value in tags:
            command = """pl = many_to_many_class.objects.create(
                personne=self.instance,""" 
                +
                champ
                + 
                """=TagWithValue.objects.get(
                    pk=idx_tag_with_value
                )
            )"""
            exec(command) 
            pl.save()
</code></pre>
<p>But as I said, it is not pythonic and can easily fail. You should have it really tested in order to go ahead with this approach.</p>
<p>My suggestion is to encapsulate into functions each situation, and call these functions according to the argument passed. <br/>
But in order to answer your question, that is the way its done.</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems like normal keyword unpacking would work . . .</p>
<pre><code>kwargs = {champ: TagWithValue.objects.get(
                     pk=idx_tag_with_value)}
pl = many_to_many_class.objects.create(
                    personne=self.instance,
                    **kwargs)
</code></pre>
<p>Of course, now <code>champ</code> <em>might</em> not be the best name for the function parameter, but hopefully you get the idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my working solution, I don't know if it's the best "pythonic" way but it works like a charm:</p>
<pre><code>def update_tags_with_value(tags, many_to_many_class, champ):
    if tags:
        many_to_many_class.objects.filter(
            personne=self.instance,
            date_v_fin=None
        ).update(date_v_fin=django_datetime.now())
        for idx_tag_with_value in tags:
            args = {
                'personne': self.instance,
                champ: TagWithValue.objects.get(
                    pk=idx_tag_with_value
                )}
            pl = many_to_many_class.objects.create(**args)
            pl.save()

update_tags_with_value(self.cleaned_data.get('known_languages'),
                       PersonneLangue, 'langue')
update_tags_with_value(self.cleaned_data.get('types_permis'),
                       PersonneTypePermis, 'type_permis')
update_tags_with_value(self.cleaned_data.get('diplomes'),
                       PersonneDiplome, 'diplome')
update_tags_with_value(self.cleaned_data.get('centres_dinteret'),
                       PersonneCentreDInteret, 'centre_dinteret')
update_tags_with_value(self.cleaned_data.get('hobbies'),
                       PersonneHobby, 'hobby')
</code></pre>
</div>
<span class="comment-copy">I don't 100% understand what you want, but <a href="http://stackoverflow.com/questions/36901/what-does-double-star-and-star-do-for-python-parameters">named argument unpacking</a> may be useful to you. You can create a dictionary and pass it to a function as if it was a collection of keyword args.</span>
<span class="comment-copy">My problem is that, strictly speaking, I need to call <code>many_to_many_class.objects.create()</code> one time with <code>known_languages=blabla</code> and another time with <code>types_permis=blabla</code> which, in other words, should call once <code>many_to_many_class.objects.create(known_languages=blabla)</code> and <code>many_to_many_class.objects.create(types_permis=blabla)</code> and I would like to know if there's a way to precise <i>only the name of the parameter</i>, <b>not</b> <code>blabla</code></span>
