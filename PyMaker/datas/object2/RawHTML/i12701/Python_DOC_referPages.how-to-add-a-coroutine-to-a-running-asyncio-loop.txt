<div class="post-text" itemprop="text">
<p>How can one add a new coroutine to a running asyncio loop? Ie. one that is already executing a set of coroutines.</p>
<p>I guess as a workaround one could wait for existing coroutines to complete and then initialize a new loop (with the additional coroutine). But is there a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" rel="noreferrer"><code>create_task</code></a> for scheduling new coroutines:</p>
<pre><code>import asyncio

async def cor1():
    ...

async def cor2():
    ...

async def main(loop):
    await asyncio.sleep(0)
    t1 = loop.create_task(cor1())
    await cor2()
    await t1

loop = asyncio.get_event_loop()
loop.run_until_complete(main(loop))
loop.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add a function to an already running event loop you can use:</p>
<p><code>asyncio.ensure_future(my_coro())</code></p>
<p>In my case I was using multithreading (<code>threading</code>) alongside <code>asyncio</code> and wanted to add a task to the event loop that was already running. For anyone else in the same situation, be sure to explicitly state the event loop (as one doesn't exist inside a <code>Thread</code>). i.e:</p>
<p>In global scope:</p>
<pre><code>event_loop = asyncio.get_event_loop()
</code></pre>
<p>Then later, inside your <code>Thread</code>:</p>
<pre><code>asyncio.ensure_future(my_coro(), loop=event_loop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your question is very close to "How to add function call to running program?"</p>
<p>When exactly you need to add new coroutine to event loop?</p>
<p>Let's see some examples. Here program that starts event loop with two coroutines parallely:</p>
<pre><code>import asyncio
from random import randint


async def coro1():
    res = randint(0,3)
    await asyncio.sleep(res)
    print('coro1 finished with output {}'.format(res))
    return res

async def main():
    await asyncio.gather(
        coro1(),
        coro1()
    ) # here we have two coroutines running parallely

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>coro1 finished with output 1
coro1 finished with output 2
[Finished in 2.2s]
</code></pre>
<p>May be you need to add some coroutines that would take results of <code>coro1</code> and use it as soon as it's ready? In that case just create coroutine that await <code>coro1</code> and use it's returning value:</p>
<pre><code>import asyncio
from random import randint


async def coro1():
    res = randint(0,3)
    await asyncio.sleep(res)
    print('coro1 finished with output {}'.format(res))
    return res

async def coro2():
    res = await coro1()
    res = res * res
    await asyncio.sleep(res)
    print('coro2 finished with output {}'.format(res))
    return res

async def main():
    await asyncio.gather(
        coro2(),
        coro2()
    ) # here we have two coroutines running parallely

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>Output:</p>
<pre><code>coro1 finished with output 1
coro2 finished with output 1
coro1 finished with output 3
coro2 finished with output 9
[Finished in 12.2s]
</code></pre>
<p>Think about coroutines as about regular functions with specific syntax. You can start some set of functions to execute parallely (by <code>asyncio.gather</code>), you can start next function after first done, you can create new functions that call others.</p>
</div>
<div class="post-text" itemprop="text">
<p>None of the answers here seem to exactly answer the question. It is possible to add tasks to a running event loop by having a "parent" task do it for you. I'm not sure what the most pythonic way to make sure that parent doesn't end until it's children have all finished (assuming that's the behavior you want), but this does work.</p>
<pre><code>import asyncio
import random


async def add_event(n):
    print('starting ' + str(n))
    await asyncio.sleep(n)
    print('ending ' + str(n))
    return n


async def main(loop):

    added_tasks = []

    delays = [x for x in range(5)]

    # shuffle to simulate unknown run times
    random.shuffle(delays)

    for n in delays:
        print('adding ' + str(n))
        task = loop.create_task(add_event(n))
        added_tasks.append(task)
        await asyncio.sleep(0)

    print('done adding tasks')

    # make a list of tasks that (maybe) haven't completed
    running_tasks = added_tasks[::]

    # wait until we see that all tasks have completed
    while running_tasks:
        running_tasks = [x for x in running_tasks if not x.done()]
        await asyncio.sleep(0)

    print('done running tasks')

    # extract the results from the tasks and return them
    results = [x.result() for x in added_tasks]
    return results


loop = asyncio.get_event_loop()
results = loop.run_until_complete(main(loop))
loop.close()
print(results)
</code></pre>
</div>
<span class="comment-copy">Thank you for the effort, but as far as I understand, this answer is mistaken. Here the first invocation of <code>main</code> creates the coroutine and the loop starts after that. In other words, this example schedules the coroutines before the loop has started. Which is not what I asked for.</span>
<span class="comment-copy"><code>main</code> is simply there as a wrapper; I just wanted to point out <code>loop.create_task</code>'s usage. <code>create_task</code> does exactly what you want. -- I've edited the example to make it clear that <code>main</code> would block before running <code>create_task</code>.</span>
<span class="comment-copy">you cannot call <code>loop.run_until_complete()</code> while the loop is running</span>
<span class="comment-copy">Coroutines run <i>concurrently</i>, not <i>in parallel</i>. Not quite the same thing.</span>
<span class="comment-copy">This is useful enough that I'm going to edit the example as I find optimizations/extensions.</span>
