<div class="post-text" itemprop="text">
<p>OK, so very, very new to coding and python.  </p>
<p>Goal of this script:  How many times do you have to roll 'x' dice to have them all come up the same value?</p>
<p>Here's what it tries to do:
Take a number of dice from the user
Simulate rolling all those dice
If all the dice match, print out how many attempts were made to succeed, if they don't match, try again.</p>
<p>Here's what happens:</p>
<p>If the user input a small number of dice, 1-4 or so, it works fine.  </p>
<p>Once the user inputs 5 dice (or more) it runs into a 'maximum recursion depth exceeded while calling a python object' error.  it appears to be part of the call to  random.randint </p>
<p>I'm hoping someone can give me a little guidance as to how to avoid this error, given that I'm not sure why the recursion becomes infinite.  I have attempted to comment my code so that it makes sense (at least to me).  </p>
<p>If it matters, I am working in python 2.6 in the Enthought Canopy environment.</p>
<pre><code>import random

#create the empty list to store values
dierolls = []  

#used to roll ythe dice
def diceroll():  
    return random.randint(1,6)

#gets user input to determine how many dice we are rollin    
def askfornumofdicetoroll():  
    return int(input("How many dice should we roll?"))

#fills the dierolls list with the appropriate     
def fillthelist(dicecount): 
    #empty the list and start fresh each iteration
    dierolls[:] = []

    #input a die roll for each die the user says to roll
    for i in range(0,dicecount):
        dierolls.append(diceroll())
    #print dierolls #used to check that this code was running
    return dierolls

#what to do when all the dice match
def wongame(attempts):
    print("You matched all the dice in", attempts , "tries")

#compares all the items in the list, and see's if they match
def comparelist(dicetoroll,attempts):

    fillthelist(dicetoroll)
    #print statement used to make sure this was running
    print dierolls
    #print statment used to see if this section of code was running
    print(all(dierolls[0] == elem for elem in dierolls))

    #gives a check to make sure the code is running and not stopped by
    #printing a result every 100 attempts
    if attempts%100 == True:
        print attempts
    else:
        pass

    #does the actual check to see if all items in the list are the same
    if all(dierolls[0] == elem for elem in dierolls):
        #if all items in list are the same, go to the results function
        wongame(attempts)
    else:
        #increment the attempts counter, and try again
        attempts += 1
        comparelist(dicetoroll, attempts)  

#runs the program
def main():
    attempts = 1
    dicetoroll = askfornumofdicetoroll()
    comparelist(dicetoroll,attempts)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has <a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit" rel="nofollow">fairly low recursion limit by default (IIRC, 1000 stack frames)</a>. Your code doesn't cap the recursion (there is no <code>maximum_attempts</code> check), so if it recurses too many times trying to "win", it hits the limit and dies.</p>
<p>You could <a href="https://docs.python.org/3/library/sys.html#sys.setrecursionlimit" rel="nofollow">set a higher recursion limit</a>, but that only extends the cap a little bit; every additional die reduces the odds of a given roll winning by 1/6, so you always win with one die, win 1/6 for two, 1/36 for three, 1/216 for 4, 1/1296 for 5, etc. The odds of a win drop quickly; a higher recursion limit would still fail occasionally by chance, and it wouldn't give you much in the way of additional capacity for more dice most of the time.</p>
<p>You really need to ditch the recursion in favor of imperative techniques.</p>
</div>
<div class="post-text" itemprop="text">
<p>In answer to your question, the best way to avoid this error is to avoid recursion. Although it can be said that most iterative procedures can be done recursively, that doesn't mean that it should be.</p>
<p>In your case, you are attempting to iterate over a non-determined amount of times that can, possibly, get exponentially larger as the number of dice grows, as the amount of combinations in a dice roll are <code>6^n</code> or <code>O(2^n)</code> for <code>n</code> number of dice.</p>
<p>Not only that, your iterations are simple are just iterating a single variable (<code>attempts</code>) by 1 each time. In other words, you are running the EXACT SAME code over and over and over and ... over again until a certain stop condition. The usual answer to this? a loop. more specifically, a while loop. There is no need for recursion.</p>
<p>So restructure your code to this:</p>
<pre><code>#compares all the items in the list, and see's if they match
def comparelist(dicetoroll,attempts):

    #continue doing this unless break or return
    while True:
        fillthelist(dicetoroll)
        #print statement used to make sure this was running
        print dierolls
        #print statment used to see if this section of code was running
        print(all(dierolls[0] == elem for elem in dierolls))

        #gives a check to make sure the code is running and not stopped by
        #printing a result every 100 attempts
        if attempts%100 == True:
            print attempts
        else:
            pass

        #does the actual check to see if all items in the list are the same
        if all(dierolls[0] == elem for elem in dierolls):
            #if all items in list are the same, go to the results function
            wongame(attempts)
            #break out of the loop
            break
        else:
            #increment the attempts counter, and try again
            attempts += 1
     return #if you want the function to return something
</code></pre>
</div>
<span class="comment-copy">you  have finite, but <b>extremely long</b> recursion in <code>comparelist</code>, you should never code like this - if you are supposed to repeat the code multiple times use <b>loops</b> not recursion.</span>
<span class="comment-copy">Thank you very much!  I made the while loop adjustment and everything worked perfectly!  I will work to not use recursion in the future.  Thanks again!</span>
