<div class="post-text" itemprop="text">
<p>I have a list (myarray) that looks something like this,</p>
<pre><code>[u 'item-01', 52, u 'item-02', 22, u 'item-03', 99, u 'item-04', 84]
</code></pre>
<p>I'm trying to convert this into a dictionary with keys and value.</p>
<p>I've tried looping but doesn't give me the expected results,</p>
<pre><code>mydict = {}
for k,v in myarray:
mydict[k] = v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple: Use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> and extended slicing.</p>
<pre><code>mydict = dict(zip(myarray[::2], myarray[1::2]))
</code></pre>
<p>The first extended slice makes a <code>list</code> of all even indices, the second of all odd, the <code>zip</code> pairs them up into <code>tuple</code>s, and the <code>dict</code> constructor can take an iterable of paired values and initialize using them as key/value pairs.</p>
<p>Note: Padraig's solution of using <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter</code></a> will work faster (and handle non-sequence iterables), though it is somewhat less intuitive (and not quite as succinct as written). Of course, it can be one-lined at the expense of becoming even less intuitive by <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow">using the behavior of <code>list</code> multiplication copying references</a> (see Note 2 on the table of sequence operations; an example of another use for it is found in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code> <code>grouper</code> recipe</a>):</p>
<pre><code>mydict = dict(zip(*[iter(myarray)]*2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can combine <a href="https://docs.python.org/3.5/library/functions.html#iter" rel="nofollow"><code>iter</code></a> and <a href="https://docs.python.org/3.5/library/functions.html#zip" rel="nofollow"><code>zip</code></a>: </p>
<pre><code>l = [u'item-01', 52, u'item-02', 22, u'item-03', 99, u'item-04', 84]

it = iter(l)

print(dict(zip(it, it)))
{u'item-04': 84, u'item-01': 52, u'item-03': 99, u'item-02': 22}
</code></pre>
<p><code>zip(it, it)</code> creates pairs combining every two elements, calling dict on the result uses the first element of each tuple as the key and the second as the vale.</p>
<pre><code>In [16]: it = iter(l)

In [17]: l = list(zip(it,it))

In [18]: l
Out[18]: [('item-01', 52), ('item-02', 22), ('item-03', 99), ('item-04', 84)]

In [19]: dict(l)
Out[19]: {'item-01': 52, 'item-02': 22, 'item-03': 99, 'item-04': 84}
</code></pre>
<p>Using a for loop like your own code:</p>
<pre><code>it = iter(l)
d = {}
for k, v in it:
    d[k] = v
</code></pre>
</div>
<span class="comment-copy">"key called name" and "value called number" sound fishy. A dictionary doesn't have any representation of what its keys and values are called.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python">How do you split a list into evenly sized chunks in Python?</a></span>
