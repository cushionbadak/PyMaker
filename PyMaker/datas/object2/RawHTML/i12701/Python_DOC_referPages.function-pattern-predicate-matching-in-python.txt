<div class="post-text" itemprop="text">
<p>I'd like to be able to dispatch different implementations of a function, based not only on the type of the first parameter, but based on arbitrary predicates. Currently I have to do it like so:</p>
<pre><code>def f(param):
    try:
        if param &gt; 0:
            # do something
    except TypeError:
        pass
    try:
        if all(isinstance(item, str) for item in param):
            # do something else
    except TypeError:
        raise TypeError('Illegal input.')
</code></pre>
<p>Here's something in the spirit of what I'd like to be able to do:</p>
<pre><code>@generic
def f(param):
    raise TypeError('Illegal input.')  # default

@f.when(lambda param: param &gt; 0)
def f_when_param_positive(param):
    # do something

@f.when(lambda param: all(isinstance(item, str) for item in param))
def f_when_param_iterable_of_strings(param):
    # do something else
</code></pre>
<p>It is similar to Python 3's <code>singledispatch</code>, however <code>singledispatch</code> only supports dispatch on types, not on arbitrary predicates.</p>
<p>TL;DR: Is there a library that allows a predicate-based dispatch of a function based on arbitrary predicates (not only the parameter's type)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to the repliers. After asking this question it seemed there was no existing module that does exactly this. So I wrote my own :) It is inspired by @Elazar's suggestion.</p>
<p>Please feel free to check it out. <a href="https://pypi.python.org/pypi/genericfuncs" rel="nofollow">It's on PyPI</a> and you can install it using:</p>
<pre><code>pip install genericfuncs
</code></pre>
<p>It's also <a href="https://github.com/AvivC/genericfuncs" rel="nofollow">hosted on GitHub</a> and I plan to continue development and add features while trying to keep the API simple. Contributions are welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution adjusted from @Yam's to fit your syntax, and to be used as a library. The decision (which is a common one) is that the first predicate wins:</p>
<pre><code>class guarded:
    def __init__(self, default):
        self.funcs = []
        self.default = default

    def when(self, pred):
        def add(func):
            self.funcs.append( (pred, func) )
            return func
        return add

    def __call__(self, *args, **kwargs):
        for pred, func in self.funcs:
            try:  
                match = pred(*args, **kwargs)
            except Exception:
                match = False
            if match:
                return func(*args, **kwargs)
        return self.default(*args, **kwargs)
</code></pre>
<p>User code:</p>
<pre><code>@guarded
def f(param):
    raise TypeError('Illegal input')

@f.when(lambda param: param &gt; 0)
def f_when_param_positive(param):
    return 'param_positive'

@f.when(lambda param: all(isinstance(item, str) for item in param))
def f_when_param_iterable_of_strings(param):
    return 'param_iterable_of_strings'
</code></pre>
<p>Trying it, we get something like:</p>
<pre><code>&gt;&gt;&gt; print(f(123))
param_positive
&gt;&gt;&gt; print(f(['a', 'b']))
param_iterable_of_strings
&gt;&gt;&gt; print(f(-123))
Traceback (most recent call last):
...
TypeError: Illegal input
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know of a library, but here's a basic implementation skeleton. The real problem which prevents this from being a practical solution, in my opinion, is that I have no idea how to make specialized resolution work here<sup>1</sup>. When that's the case, it will probably lead to a lot of maintenance hardships.</p>
<pre><code>#!/usr/bin/python3  

class when(object):
  funcs = {}

  def __init__(self, pred):
    self.pred = pred

  def __call__(self, func):
    if func.__qualname__ not in when.funcs:
        when.funcs[func.__qualname__] = {}

    when.funcs[func.__qualname__][self.pred] = func

    return lambda *args, **kwargs: when.__match(func, *args, **kwargs)

  @staticmethod
  def __match(f, *args, **kwargs):
    for pred, func in when.funcs[f.__qualname__].items():
      if pred(*args, **kwargs):
          return func(*args, **kwargs)
    raise NotImplementedError()


@when(lambda x: x &lt; 0)
def my_func(x):
  return "smaller!"

@when(lambda x: x &gt; 0)
def my_func(x):
  return "greater!"


print(my_func(-123))
print(my_func(123))
</code></pre>
<hr/>
<p>[1]: The problem with resolution is that it's not easy to get right. Here are some alternatives to consider, all of which are severely lacking good reasons to implement and use.</p>
<ol>
<li>Specializing predicates which apply can be complex, and will probably be best laid at the hands of the user so as to manually define ranks/weights for each. This is clumsy, and generally a maintenance/boilerplate headache that's not worth the initial charm of this mechanism.</li>
<li>The user can always add more overloads as the program is being run (Python being interpreted), and this can cause surprising temporal behavior. Spreading this around in your codebase is complacent. When it's not spread around, why not just <code>if/else</code> and be done?</li>
<li>You can somehow restrict the usage, and enforce it so that only one predicate must return True for a given call. This is both weird, inefficient, and useless in many ways, e.g. what if you want to catch all instances of A or its subclasses, but treat subclass C in a special way? Or if you want to further specialize a predicate with an extra condition. How are you going to classify this kind of model?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>isintance</code> and combined it with a <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow">ABC</a> to check the characteristic of the input like this:</p>
<pre><code>from collections.abc import Iterable

def foo(param):
    if isinstance(param,int) and param &gt; 0:
        #do something 
    elif isinstance(param,Iterable) and all(isinstance(item, str) for item in param):
        # do something else
    else:
        raise TypeError('Illegal input.')
</code></pre>
<p>The ABC tell you to what kind of interface the param has, so you can use the appropriate one depending of what you do if you don't care if it is a particular type or not, so defined like that param may be a <code>set</code>, <code>list</code> or <code>tuple</code> of strings and always will past the second check so you can processed it accordingly. There is also and ABC for <a href="https://docs.python.org/3/library/numbers.html" rel="nofollow">numbers</a> is you want to be general in that case too.</p>
</div>
<span class="comment-copy">Oooh. How a demonstrably-accurate, complete answer gets downvoted? I wonder.</span>
