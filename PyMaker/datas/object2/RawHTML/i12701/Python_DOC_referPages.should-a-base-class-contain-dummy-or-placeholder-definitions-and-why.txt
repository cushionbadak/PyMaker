<div class="post-text" itemprop="text">
<p>Let me explain what I mean by "dummy/placeholder defintions" with the following simple example. Don't know how to call them properly.</p>
<pre><code>class GateBase:
    def __init__(self):
        self.inputs = None
        self.output = None

    def eval(self):
        raise NotImplementedError

class AndGate(GateBase):
    def __init__(self, *inputs):
        super().__init__()
        self.inputs = inputs

    def eval(self):
        self.output = all(inp for inp in self.inputs)

class OrGate(GateBase):
   ...

class XorGate(GateBase):
   ...
</code></pre>
<p>The <code>eval</code> function in the base class that just throws an exception has no real function. Without the dummy <code>eval</code> in the base class, if a derived class "forgets" to implement its own <code>eval</code>, an exception will be thrown anyway, just a different type. No reminder necessary.</p>
<p>The <code>self.inputs</code> is a similar case. Each derived class simply must define its input(s) to be usable at all.</p>
<p>So what is the primary purpose of defining <code>self.inputs</code> and <code>self.eval()</code> in the base class? Documentation of API? Pylint? Pythonic style? Or is it an idea taken from the ABC (abstract base classes)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The main purpose of using "dummies", as your called, is the principle of polymorphism:</p>
<p><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="nofollow">Wikipedia - Polymorphism (computer_science)</a></p>
<p>This principle is general for all object oriented languages. The main idea of the principle is to fix the identical interface in base class for each derived class. This is why you should use abstract methods in the base class to ensure their presence and implementation in derived classes.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" rel="nofollow noreferrer"><code>NotImplementedError</code> documentation</a> says: <i>This exception is derived from RuntimeError. In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method.</i></span>
<span class="comment-copy">A derived class doesn't have to override <code>eval</code> at all, so no, an exception <i>won't</i> be thrown if the user forgets to override a method. The <code>NotImplementedError</code> is a neat way to enforce that.</span>
<span class="comment-copy">from py2.6 and in py3, there are better ways to define an ABC and force sublcasses to implement a given method. The solution presented only raises the exception when we try to call the missing method. It is possible to throw the exception earlier, when attempting to make an instance of the class.</span>
<span class="comment-copy">@101 An <code>AttributeError</code> with quite a clear message will be thrown when there is no method in the base class. Sorry if this was not clear from my text.</span>
<span class="comment-copy">when there is no method in the subclass you mean</span>
