<div class="post-text" itemprop="text">
<p>I'm using asyncio to run a piece of blocking code like this:</p>
<pre><code>result = await loop.run_in_executor(None, long_running_function)
</code></pre>
<p>My question is: Can I impose a timeout for the execution of <code>long_running_function</code>? </p>
<p>Basically I don't want <code>long_running_function</code> to last more than 2 seconds and I can't do proper timeout handling within it because that function comes from a third-party library.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow">asyncio.wait_for</a>:</p>
<pre><code>future = loop.run_in_executor(None, long_running_function)
result = await asyncio.wait_for(future, timeout, loop=loop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A warning about cancelling long running functions:</p>
<p>Although wrapping the <code>Future</code> returned by <code>loop.run_in_executor</code> with an <code>asyncio.wait_for</code> call will allow the <em>event loop</em> to stop waiting for <code>long_running_function</code> after some <code>x</code> seconds, it won't necessarily stop the underlying <code>long_running_function</code>. This is one of the shortcomings of <code>concurrent.futures</code> and to the best of my knowledge there is no simple way to just cancel a <code>concurrent.futures.Future</code>.</p>
</div>
<span class="comment-copy">You could possibly try wrapping <code>loop.run_in_executor()</code> in <code>wait_for()</code>, which takes a timeout parameter.</span>
<span class="comment-copy">That works indeed, thanks!</span>
<span class="comment-copy">Perfect, thanks! The expression will throw a <code>asyncio.futures.TimeoutError</code> when timeout is reached.</span>
<span class="comment-copy">Hi Jashandeep, what do you mean by "won't necessarily stop"? Do you mean "won't stop" or can you point out any condition based on which it won't stop?</span>
<span class="comment-copy">By the way, aren't we talking about an "asyncio.futures.Future" object (as opposed to "concurrent.futures.Future") ?</span>
<span class="comment-copy">It won't stop immediate; i.e. the function will run to completion. So, if there is a <code>while True: ...</code> loop in there, it will never stop. --- The default executor in <code>asyncio</code> is a <code>concurrent.futures.ThreadPoolExecutor</code>, which in-turn makes use of <code>concurrent.futures.Future</code>. <code>run_in_executor</code> calls <code>Executor.submit</code> &amp; wraps the returned <code>concurrent.futures.Future</code> to a <code>asyncio.Future</code> such that when one finishes so does the other.</span>
<span class="comment-copy">would the <code>ThreadPoolExecutor</code> respond to a manual cancel? (presumably called once the <code>TimeOutError</code> is raised?</span>
<span class="comment-copy">No it cannot. On cancellation executor will not schedule next task to the pool but it doesn't stop already executed job. Literally there are no way to gracefully stop a thread using Python API. Hackery approaches are exist but they are very unreliable, I don't recommend them.</span>
