<div class="post-text" itemprop="text">
<p>Let's say I have the following:</p>
<pre><code>image_data = """iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="""
</code></pre>
<p>This is just a dot image (from <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" rel="noreferrer">https://en.wikipedia.org/wiki/Data_URI_scheme</a>). But I do not know if it is image or text etc. Is it possible to understand what it is only having this encoded string? I try it in Python, but it is also general question. So any insight in both is highly welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't, at least not without decoding, because the bytes that help identify the filetype are spread across the base64 characters, which don't directly align with whole bytes. Each character encodes 6 <strong>bits</strong>, which means that for every 4 characters, there are 3 bytes encoded.</p>
<p>Identifying a filetype requires access to those bytes in different block sizes. A JPEG image for example, can be identified from the bytes FF D8 or FF D9, but that's <em>two</em> bytes; the third byte that follows must also be encoded as part of the 4-character block. </p>
<p>What you <em>can</em> do is decode <em>just enough</em> of the base64 string to do your filetype fingerprinting. So you can decode the first 4 characters to get the 3 bytes, and then use the first two to see if the object is a JPEG image. A large number of file formats can be identified from just the first or last series of bytes (a PNG image can be identified by the first 8 bytes, a GIF by the first 6, etc.). Decoding just those bytes from the base64 string is trivial.</p>
<p>Your sample is a PNG image; you can test for image types using the <a href="https://docs.python.org/3/library/imghdr.html"><code>imghdr</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import imghdr
&gt;&gt;&gt; image_data = """iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="""
&gt;&gt;&gt; sample = image_data[:44].decode('base64')  # 33 bytes / 3 times 4 is 44 base64 chars
&gt;&gt;&gt; for tf in imghdr.tests:
...     res = tf(sample, None)
...     if res:
...         break
...
&gt;&gt;&gt; print res
png
</code></pre>
<p>I only used the first 33 bytes from the base64 data, to echo what the <code>imghdr.what()</code> function will read from the file you pass it (it reads 32 bytes, but that number doesn't divide by 3).</p>
<p>There is an equivalent <a href="https://docs.python.org/3/library/sndhdr.html"><code>soundhdr</code> module</a>, and there is also the <a href="https://github.com/ahupp/python-magic"><code>python-magic</code> project</a> that lets you pass in a number of bytes to determine a file type.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course, you can. There are few extremely easy approaches to the problem I can think of:</p>
<h1>Partial decode</h1>
<p>Each base64 character encodes 6 bits of input, so you can relate them as follows:</p>
<pre><code>Base64: AAAAAABBBBBBCCCCCCDDDDDDEEEEEEFFFFFFGGGGGGHHHHHH
Data:   xxxxxxxxyyyyyyyyzzzzzzzzqqqqqqqqwwwwwwwweeeeeeee
</code></pre>
<p>If you would like to extract 4 bytes of data, starting with offset 1, like this:</p>
<pre><code>                ................................
Base64: AAAAAABBBBBBCCCCCCDDDDDDEEEEEEFFFFFFGGGGGGHHHHHH
Data:   xxxxxxxxyyyyyyyyzzzzzzzzqqqqqqqqwwwwwwwweeeeeeee
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Then, to decode only parts that you want, you need to know bit distances. They are easy to calculate, just multiply your byte distances by 8. Now, after you know you want 32 bits, starting with bit 8, you can find what base64 character contains your starting bits. To do that, divmod your <code>offset</code> and <code>offset+length</code> by 6:</p>
<pre><code>start = bit  8 = char 1 + bit 2
end   = bit 40 = char 6 + bit 4
</code></pre>
<p>Well, this maps to the scheme above — your span starts after 1 full base64 char and 2 bits, and ends after 6 full base64 chars and 4 bits.</p>
<p>Now, after you know exact base64 chars you want, you need to decode them. To do that, it makes sense to leverage existing base64 decoders, so we won't need to deal with base64 encoding yourself. And to do that, you should know that each 4 chars of base64 code correspond to 3 bytes of data. So, here goes the trick — you can prepend and append gibberish to your extracted base64 code, until base64 and byte boundaries align — and knowing how much invalid input will base64 decoder produce, throw out excess.</p>
<p>So, how much to prepend depends on value of bit remainder. If start bit remainder is 0, it means that <code>A</code> and <code>x</code> are aligned, so no changes required:</p>
<pre><code>           |==========================
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
           |==========================
</code></pre>
<p>If bit remainder is 2, you need to prepend one base64 char, and throw out one leading byte after decoding:</p>
<pre><code>                 ##|==================
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
                   |==================
</code></pre>
<p>If bit remainder is 4, you need to prepend two base64 chars, and throw out two leading bytes after decoding:</p>
<pre><code>                       ####|==========
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
                           |==========
</code></pre>
<p>Same goes for trailing. If end bit remainder is zero, no changes:</p>
<pre><code>        ===|
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
        ===|
</code></pre>
<p>If end bit remainder is 2, you need to append two base64 chars, and throw out two trailing bytes:</p>
<pre><code>        =========##|
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
        ===========|
</code></pre>
<p>If end bit remainder is 4, you need to append one base64 char, and throw out one trailing byte:</p>
<pre><code>        ===============####|
Base64: ...AAAAAABBBBBBCCCCCCDDDDDD...
Data:   ...xxxxxxxxyyyyyyyyzzzzzzzz...
        ===================|
</code></pre>
<p>So, for synthetic example above, one character needs to be prepended (instead of <code>A</code>), and one character appended (in place of <code>H</code>):</p>
<pre><code>                ................................
Base64: ??????BBBBBBCCCCCCDDDDDDEEEEEEFFFFFFGGGGGG??????
Data:   ????????yyyyyyyyzzzzzzzzqqqqqqqqwwwwwwww????????
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Now, after decoding, throw out extra bytes from head and tail and you're done.</p>
<h2>Practical example</h2>
<p>Imagine you have a magic like <code>?PNG\r\n??????IHDR</code>. Then, to check if base64-coded string matches your magic, you can identify bytes in magic that are known, and their bit offsets and lengths:</p>
<pre><code>"PNG\r\n"  -&gt;  offset =  8, length = 40
"IHDR"     -&gt;  offset = 96, length = 32
</code></pre>
<p>So, using our ideas from above:</p>
<pre><code>"PNG\r\n"  -&gt;  start =  8 ( char  1, bits = 2 ), end = 48  ( char 8, bits = 0 )
"IHDR"     -&gt;  start = 96 ( char 16, bits = 0 ), end = 128 ( char 21, bits = 2 )
</code></pre>
<p>To decode <code>"PNG\r\n"</code> part, you need to take 7 full base64 chars, starting with char 1, then prepend 1 char, decode, throw out 1 leading byte and compare.</p>
<p>To decode <code>"IHDR"</code> part, you need to take 6 base64 chars, starting with char 16, then append 2 chars, decode, throw out 2 trailing bytes and compare.</p>
<h1>Translate magics</h1>
<p>Alternative approach to what I had described above is instead of translating data, translate magics themselves.</p>
<p>So, if you have magic <code>?PNG\r\n??????IHDR</code> (I had replaced <code>\r</code> and <code>\n</code> for presentation purposes), like in an example above, when encoded to base64, it looks like this:</p>
<pre><code>Data:   [?PN]  [Grn]  [???]  [???]  [IHD]  [R??]
Base64: (?~BO) (Rw0K) (????) (????) (SUhE) (Ug==)
</code></pre>
<p>In <code>?~BO</code> part, <code>~</code> sign is only partially random. Let's look at that construct bitwise:</p>
<pre><code>Data:   ????????PPPPPPPPNNNNNNNN
Base64: ??????~~~~~~BBBBBBOOOOOO
</code></pre>
<p>So, only two lower bits of <code>~</code> are truly unknown, and that means that you can use that information while testing magic against the data, to narrow the scope of magic.</p>
<p>For this particular case, here is exhaustive list of all encodings:</p>
<pre><code>Data:   ??????00PPPPPPPPNNNNNNNN
Base64: ??????FFFFFFBBBBBBOOOOOO  =&gt; ?FBO

Data:   ??????01PPPPPPPPNNNNNNNN
Base64: ??????VVVVVVBBBBBBOOOOOO  =&gt; ?VBO

Data:   ??????10PPPPPPPPNNNNNNNN
Base64: ??????llllllBBBBBBOOOOOO  =&gt; ?lBO

Data:   ??????11PPPPPPPPNNNNNNNN
Base64: ??????111111BBBBBBOOOOOO  =&gt; ?1BO
</code></pre>
<p>Same applies to trailing <code>R??</code> group, but because there are 4 undefined bits instead of 2, permutation list is longer:</p>
<pre><code>Ug??  &lt;=  0000???? ????????
Uh??  &lt;=  0001???? ????????
Ui??  &lt;=  0010???? ????????
Uj??  &lt;=  0011???? ????????
Uk??  &lt;=  0100???? ????????
Ul??  &lt;=  0101???? ????????
Um??  &lt;=  0110???? ????????
Un??  &lt;=  0111???? ????????
Uo??  &lt;=  1000???? ????????
Up??  &lt;=  1001???? ????????
Uq??  &lt;=  1010???? ????????
Ur??  &lt;=  1011???? ????????
Us??  &lt;=  1100???? ????????
Ut??  &lt;=  1101???? ????????
Uu??  &lt;=  1110???? ????????
Uv??  &lt;=  1111???? ????????
</code></pre>
<p>So, in regexp, your base64-magic for <code>?PNG\r\n??????IHDR</code> would look like this:</p>
<pre><code>rx = re.compile(b'^.[FVl1]BORw0K........SUhEU[g-v]')
if rx.match(base64.b64encode(b'xPNG\r\n123456IHDR789foobar')):
    print('Yep, it works!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Its a PNG image</p>
<pre><code>import base64

encoded_string = 'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='

decoded_string = base64.b64decode(encoded_string)
print 'Decoded :', decoded_string
</code></pre>
<p>Output:</p>
<pre><code>python base_decode.py 
Decoded : �PNG
</code></pre>
</div>
<span class="comment-copy">My spam filter contains a regex for all the possible first few base64 characters of an MS-DOS executable file and blocks any such attachments. It's not terribly elegant, but it gets the job done, eminently.</span>
<span class="comment-copy">Here is another interesting way <a href="https://stackoverflow.com/a/50111377/4765689">stackoverflow.com/a/50111377/4765689</a> It is a javascript solution but it can easily be done in any programming language.</span>
<span class="comment-copy">Thanks a lot, this is exactly what I searched for! One question, it works (obviously) also if you do sample = image_data.decode('base64'), i.e. decoding the whole image. The reason to avoid this is speed?</span>
<span class="comment-copy">@george: speed, memory. Why spend CPU on decoding the whole thing if all you wanted was to identify the file type? For that you only need the first x bytes. If you needed to decode the base64 data <i>anyway</i>, then just decode the whole string, but for file type identification that's overkill, just like reading in the whole file from disk to identify the type would be overkill.</span>
<span class="comment-copy">ok, I get it, thanks again</span>
<span class="comment-copy">this is also very interesting answer, thanks</span>
<span class="comment-copy">The OP wasn't asking if <i>this example</i> was an image or text, but how to determine this in general.</span>
<span class="comment-copy">From the question: <i>it is also general question</i></span>
<span class="comment-copy">It should be fairly obvious from the Wikipedia link that the OP knows that the data example in the question is a PNG file of a small red dot, and so the question is asking how to determine <i>in general</i> the file type of a base64-encoded file. BTW, you don't need to import a module to do standard base64 encoding / decoding - the <code>str</code> <code>.encode</code> and <code>.decode</code> methods can handle that, as Martijn's code illustrates.</span>
<span class="comment-copy">Yes, this is not reply to the question, I was asking what to do if I do NOT know the file type</span>
<span class="comment-copy">and what I showed will tell you what file type is (it will list the extension)</span>
