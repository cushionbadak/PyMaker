<div class="post-text" itemprop="text">
<p>I would like to handle a <code>NameError</code> exception by injecting the desired missing variable into the frame and then continue the execution from last attempted instruction.</p>
<p>The following pseudo-code should illustrate my needs.</p>
<pre><code>def function():
    return missing_var

try:
    print function()

except NameError:

    frame = inspect.trace()[-1][0]

    # inject missing variable
    frame.f_globals["missing_var"] = ...

    # continue frame execution from last attempted instruction
    exec frame.f_code from frame.f_lasti
</code></pre>
<p><a href="https://repl.it/BaLF/1" rel="nofollow noreferrer">Read the whole unittest on repl.it</a> </p>
<h2>Notes</h2>
<ul>
<li>As pointed out by <a href="https://stackoverflow.com/users/648265/ivan-pozdeev">ivan_pozdeev</a> in his <a href="https://stackoverflow.com/a/34426352/2594884">answer</a>, this is known as <strong>resumption</strong>.</li>
<li>After more research, I found <a href="https://stackoverflow.com/users/1763356/veedrac">Veedrac</a>'s <a href="https://stackoverflow.com/a/18956602/2594884">answer</a> to the question <a href="https://stackoverflow.com/questions/18887163/python-resuming-program-at-line-number-in-the-context-before-an-exception-using">Resuming program at line number in the context before an exception using a custom sys.excepthook</a> posted by <a href="https://stackoverflow.com/users/988828/lc2817">lc2817</a> very interesting. It relies on Richie Hindle's <a href="http://entrian.com/goto/" rel="nofollow noreferrer">work</a>.</li>
</ul>
<h2>Background</h2>
<p>The code runs in a slave process, which is controlled by a parent. Tasks (functions really) are written in the parent and latter passed to the slave using <a href="https://pypi.python.org/pypi/dill" rel="nofollow noreferrer">dill</a>. I expect some tasks (running in the slave process) to try to access variables from outer scopes in the parent and I'd like the slave to request those variables to the parent on the fly.</p>
<p><em>p.s.: I don't expect this magic to run in a production environment.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>On the contrary to what various commenters are saying, "resume-on-error" exception handling <em>is</em> possible in Python. The library <a href="https://github.com/ajalt/fuckitpy" rel="nofollow noreferrer"><code>fuckit.py</code></a> implements said strategy. It steamrollers errors by rewriting the source code of your module at import time, <a href="https://github.com/ajalt/fuckitpy/blob/master/fuckit.py#L73" rel="nofollow noreferrer">inserting <code>try...except</code> blocks around every statement</a> and swallowing all exceptions. So perhaps you could try a similar sort of tactic?</p>
<p>It goes without saying: that library is intended as a joke. Don't ever use it in production code.</p>
<hr/>
<p>You mentioned that your use case is to trap references to missing names. Have you thought about using metaprogramming to run your code in the context of a "smart" namespace such as a <code>defaultdict</code>? (This is perhaps only marginally less of a bad idea than <code>fuckit.py</code>.)</p>
<pre><code>from collections import defaultdict

class NoMissingNamesMeta(type):
    @classmethod
    def __prepare__(meta, name, bases):
        return defaultdict(lambda: "foo")

class MyClass(metaclass=NoMissingNamesMeta):
    x = y + "bar"  # y doesn't exist

&gt;&gt;&gt; MyClass.x
'foobar'
</code></pre>
<p><code>NoMissingNamesMeta</code> is a <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass</a> - a language construct for customising the behaviour of the <code>class</code> statement. Here we're using the <code>__prepare__</code> method to customise the dictionary which will be used as the class's namespace during creation of the class. Thus, because we're using a <code>defaultdict</code> instead of a regular dictionary, a class whose metaclass is <code>NoMissingNamesMeta</code> will never get a <code>NameError</code>. Any names referred to during the creation of the class will be auto-initialised to <code>"foo"</code>.</p>
<p>This approach is similar to @AndréFratelli's idea of manually requesting the lazily-initialised data from a <code>Scope</code> object. In production I'd do that, not this. The metaclass version requires less typing to write the client code, but at the expense of a lot more magic. (Imagine yourself debugging this code in two years, trying to understand why non-existent variables are dynamically being brought into scope!)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.stroustrup.com/bs_faq2.html#resume" rel="nofollow">The "resumption" exception handling technique has proven to be problematic</a>, that's why it's missing from C++ and later languages.</p>
<p>Your best bet is to use a <code>while</code> loop to not resume where the exception was thrown but rather repeat from a predetermined place:</p>
<pre><code>while True:
    try:
        do_something()
    except NameError as e:
        handle_error()
    else:
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You really can't unwind the stack after an exception is thrown, so you'd have to deal with the issue before hand. If your requirement is to generate these variables on the fly (which wouldn't be recommended, but you seem to understand that), then you'd have to actually request them. You can implement a mechanism for that (such as having a global custom <code>Scope</code> class instance and overriding <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow"><code>__getitem__</code></a>, or using something like the <a href="https://docs.python.org/2/library/functions.html#dir" rel="nofollow"><code>__dir__</code></a> function), but not as you are asking for it.</p>
</div>
<span class="comment-copy">The Python exception-handling model wouldn't let you do that, since the stack has to be unwound to determine who handles the exception, and you can't un-return from any C functions that had to return to unwind the stack. You'd have to handle this at the point the NameError is generated.</span>
<span class="comment-copy">I don't think what you are trying to do is possible in python because when the stack frame is popped, local state will be lost and there will be no way to recover that.  What is the driver for you wanting to do this?</span>
<span class="comment-copy">Thank you very much for your consideration. @dolan, this code run in a slave process, which is controlled by a parent. Tasks are written in the parent and latter passed to the slave using <a href="https://pypi.python.org/pypi/dill" rel="nofollow noreferrer">dill</a>. I expect some tasks (running in the slave process) to try to access outer variables (defined in the parent) and I wanted the slave to request those variables on the fly while needed.</span>
<span class="comment-copy">@JulesBaratoux: NameErrors are not a good way to go about dealing with that. Why not have the slave process access those values through a lazy mapping that requests values from the parent as needed, or explicitly pass the slave the values it's going to need, or something else that doesn't require the awful, excluded-for-a-reason-in-just-about-every-language technique of resuming after exceptions?</span>
<span class="comment-copy">@user2357112: As explained to ivan_pozdeev, I currently pass those variables as argument to avoid the "awful" magic :D. I'll take a look at lazy mapping. Thank you for the advice!</span>
<span class="comment-copy">Such a library name! Your last suggestion seems to converge with André Fratelli's answer. I'm looking forward to try something related. Thank you!</span>
<span class="comment-copy">That doesn't actually resume "at the same place where the exception was thrown", but rather at the next statement - at "a predetermined place", like I said.</span>
<span class="comment-copy">The while loop was my first choice. As explained in the recently added <b>background</b> section, the goal is to provide the ability to request variables in an outer scope from the parent process on the fly. The ability to retrieve variable from an outer scope would have been plus in my opinion but currently, those variables are passed as arguments, avoiding the need of that magic. Thank you for the link by the way, Stroustrup references are always welcome!</span>
<span class="comment-copy">@JulesBaratoux this asks for hooking into the retrieval process, <a href="http://stackoverflow.com/a/34426840/648265">just like Andre said</a>. Trying to fix things <i>inside a statement</i> and <i>in the same frame</i> when <i>the language only allows flow control at statement granularity in a frame</i> is, by this definition, an absolutely impossible task. You must handle the error lower on the frame stack.</span>
<span class="comment-copy">@JulesBaratoux ...or split the statement at the point where you require flow control.</span>
<span class="comment-copy">It sounds like I should avoid the exception case rather than to mysteriously handle it. I like the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a> approach. Thank you!</span>
