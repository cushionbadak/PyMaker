<div class="post-text" itemprop="text">
<p>I have observed the following behavior in python 3.4.2, and I am unableto explain it. Hopefully someone could shed some light on the matter:</p>
<p>In IPython:</p>
<pre><code>In [129]: import urllib

In [130]: print(urllib.parse)
&lt;module 'urllib.parse' from '/Users/ashwin/.pyenv/versions/3.4.2/lib/python3.4/urllib/parse.py'&gt;
</code></pre>
<p>I've imported a module, and printed one of its attributes. Everything works as expected. So far, life is good.</p>
<p>Now, I do the same thing from the command line:</p>
<pre><code>$ python -c 'import urllib; print(urllib.parse)'  
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'parse'
</code></pre>
<p>Say what?! that's not how that's supposed to work.<br/>
Ok, maybe this is a python-wide behavior; maybe modules are not immediately imported when using the <code>-c</code> flag. Let's try another module:</p>
<pre><code>$ python -c 'import datetime; print(datetime.datetime)'
&lt;class 'datetime.datetime'&gt;
</code></pre>
<p>What?! How does it work for <code>datetime</code> and not for <code>urllib</code>? I'm using the same version of python in both places (3.4.2)</p>
<p>Does anyone have any thoughts on this?</p>
<p><strong>EDIT</strong>:</p>
<p>Per one of the comments:</p>
<pre><code>$ which -a ipython
/Users/ashwin/.pyenv/shims/ipython
/Library/Frameworks/Python.framework/Versions/2.7/bin/ipython
/usr/local/bin/ipython
/usr/local/bin/ipython
</code></pre>
<p>And</p>
<pre><code>$ which -a python
/Users/ashwin/.pyenv/shims/python
/Library/Frameworks/Python.framework/Versions/2.7/bin/python
/usr/bin/python
/usr/bin/python
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you run <code>import urllib</code>, it creates the module object of the <code>urllib</code> module (which is actually a <a href="https://docs.python.org/3/glossary.html#term-package" rel="nofollow"><em>package</em></a>) <em>without importing its submodules</em> (parse, request etc.). </p>
<p>You need the parent module object (<code>urllib</code>) to be in your namespace if you want to access its submodule using attribute access. In addition to that, that submodule <em>must</em> already be loaded (imported). From the <a href="https://docs.python.org/3/reference/import.html#submodules" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>if package <code>spam</code> has a submodule <code>foo</code>, after importing
  <code>spam.foo</code>, <code>spam</code> will have an attribute <code>foo</code> which is bound to the
  submodule. [...] The invariant holding is that if you have
  <code>sys.modules['spam']</code> and <code>sys.modules['spam.foo']</code> (as you would
  after the above import), the latter must appear as the <code>foo</code> attribute
  of the former.</p>
</blockquote>
<p>There is only one instance of each module, thus any changes made to the <code>urllib</code> module object (stored in <code>sys.modules['urllib']</code>) get reflected everywhere.</p>
<p><strong>You don't import <code>urllib.parse</code>, but IPython <em>does</em>.</strong> To prove this I'm going to create a startup file:</p>
<pre><code>import urllib
print('Running the startup file: ', end='')
try:
    # After importing  'urllib.parse' ANYWHERE,
    # 'urllib' will have the 'parse' attribute.
    # You could also do "import sys; sys.modules['urllib'].parse"
    urllib.parse
except AttributeError:
    print("urllib.parse hasn't been imported yet")
else:
    print('urllib.parse has already been imported')
print('Exiting the startup file.')
</code></pre>
<p>and launch <code>ipython</code></p>
<pre><code>vaultah@base:~$ ipython
Running urllib/parse.py
Running the startup file: urllib.parse has already been imported
Exiting the startup file.
Python 3.6.0a0 (default:089146b8ccc6, Sep 25 2015, 14:16:56) 
Type "copyright", "credits" or "license" for more information.

IPython 4.0.0 -- An enhanced Interactive Python.
</code></pre>
<p>It is the side effect of importing <code>pydoc</code> during the startup of IPython (<code>which ipython</code> is <em>/usr/local/bin/ipython</em>):</p>
<pre><code>/usr/local/bin/ipython, line 7:
  from IPython import start_ipython
/usr/local/lib/python3.6/site-packages/IPython/__init__.py, line 47:
  from .core.application import Application
/usr/local/lib/python3.6/site-packages/IPython/core/application.py, line 24:
  from IPython.core import release, crashhandler
/usr/local/lib/python3.6/site-packages/IPython/core/crashhandler.py, line 28:
  from IPython.core import ultratb
/usr/local/lib/python3.6/site-packages/IPython/core/ultratb.py, line 90:
  import pydoc
/usr/local/lib/python3.6/pydoc.py, line 68:
  import urllib.parse
</code></pre>
<p>This explains why the below code fails - you only import <code>urllib</code> and nothing seems to import <code>urllib.parse</code>:</p>
<pre><code>$ python -c 'import urllib; print(urllib.parse)'
</code></pre>
<p>On the other hand, the following command works because <code>datetime.datetime</code> is <em>not</em> a module. It's a class that gets imported during <code>import datetime</code>.</p>
<pre><code>$ python -c 'import datetime; print(datetime.datetime)'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>urllib.parse</code> is available from Python 3 onwards. I think you might need to <code>import urllib.parse</code>, not <code>import urllib</code>. Not sure if (when) submodule import is implicit.</p>
<p>I would guess IPython imports <code>urllib.parse</code> on startup and that is why it is available.</p>
<p><code>parse</code> is a module not an attribute:</p>
<pre><code>Python 3.4.2 (default, Oct 15 2014, 22:01:37)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.40)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import urllib
&gt;&gt;&gt; urllib.parse
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'module' object has no attribute 'parse'
&gt;&gt;&gt; import urllib.parse
&gt;&gt;&gt; urllib.parse
&lt;module 'urllib.parse' from '/opt/local/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/urllib/parse.py'&gt;
</code></pre>
</div>
<span class="comment-copy">you may want to add the output of <code>which -a ipython</code> and <code>which -a python</code></span>
<span class="comment-copy">@cel: I don't understand how that would help, but I've added it</span>
<span class="comment-copy">So <code>python -m IPython -c 'import datetime; print(datetime.datetime)'</code> and <code>python -c 'import datetime; print(datetime.datetime)'</code> give different results?</span>
<span class="comment-copy">No. <code>python -c</code> with <code>datetime</code> gives a different result than <code>python -c</code> with <code>urllib</code>, in that the former throws an <code>AttributeError</code> and the latter does not. Yet, the the code with <code>urllib</code> does not raise and errors when used within the interactive IPython</span>
<span class="comment-copy">Basically <code>python  -c 'import urllib; print(urllib.parse)'</code> and <code>python -m IPython -c 'import urllib; print(urllib.parse)'</code> give different results. I see that too. Indeed a very interesting observation. I would add a regular python tag to increase visibility.</span>
<span class="comment-copy">But if I try <code>pydoc</code> in IPython I get a <code>NameError</code>. Does that not mean that <code>pydoc</code> has not been imported by IPython at startup?</span>
<span class="comment-copy">@inspectorG4dget it <i>has</i> been imported, you can check if it's already in <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a>: <code>'pydoc' in sys.modules</code> returns <code>True</code>. You just have to import it in the current namespace.</span>
<span class="comment-copy">Ok, but <code>urllib</code> isn't in the current namespace OR in <code>sys.modules</code> in IPython. So I'm still not clear on how <code>urllib.parse</code> automagically exists in the namespace</span>
<span class="comment-copy">@inspectorG4dget I'm not so sure... Running <code>[x for x in sys.modules if 'urllib' in x]</code> from IPython, produces <code>['urllib.parse', 'urllib']</code>. When <code>import urllib.parse</code> is executed, Python will check if it can skip creating a module object by looking into <code>sys.modules</code>. When the module object is ready, it'll be put in the local namespace under the name you chose (e.g. using the <code>import</code> statement). Note that namespaces are not shared.</span>
<span class="comment-copy">But I don't try <code>import urllib.parse</code> in IPython. I try <code>import urllib</code> and then call <code>urllib.parse.unquote</code> without any further imports</span>
<span class="comment-copy">Your analysis seems incorrect, as I am using python3.4.2 even when I call <code>python</code> from the command line. As seen in my paths, the first entry is from <code>pyenv</code>, which is currently pointing to v3.4.2</span>
<span class="comment-copy">Try <code>import urllib.parse</code> instead of <code>import urllib</code> as suggested.</span>
<span class="comment-copy">Also thank you for the path clarification. I updated the question and removed the bits which were incorrect.</span>
<span class="comment-copy">IPython does not import <code>urllib.parse</code> on startup. I know this because I setup the IPython startup imports myself. But you're right in that running this in the interactive shell also does not work as expected. I have a feeling that IPython resolves this by creating an invisible <code>import urllib.parse</code> to avoid this error</span>
