<div class="post-text" itemprop="text">
<p>Right now I'm trying to make a small code with a raspberry pi and and a makey makey. The makey makey is a small board that acts as a usb keyboard when certain contacts are powered. My question is what is the easiest way to detect those keypresses inside a python script. I understand using the GPIO pins would be easier, but right now I'm looking for this. I have seen examples such as using using getch() from msvcrt (which from what I understand is windows only,) using pygame.key, and using getKey. Which of theses is easiest to use? Are there any that can detect a key being pressed and a key being released?</p>
<p>Pseudocode Code (... is that what it's called?)</p>
<pre><code>import whatever needs importing    

if the "W" key is pressed:
   print ("You pressed W")

elif the "S" is pressed:
    print ("You pressed S")
</code></pre>
<p>and so on. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a simple loop that will put stdin in raw mode (disabling buffering so you don't have to press enter) to get single characters. You should do something smarter (like a <code>with</code> statement to disable it) but you get the idea here:</p>
<pre><code>import tty
import sys
import termios

orig_settings = termios.tcgetattr(sys.stdin)

tty.setcbreak(sys.stdin)
x = 0
while x != chr(27): # ESC
    x=sys.stdin.read(1)[0]
    print("You pressed", x)

termios.tcsetattr(sys.stdin, termios.TCSADRAIN, orig_settings)    
</code></pre>
<p>I think you'd have to loop to detect key releases in Python.</p>
<p><strong>ETA some more explanation:</strong></p>
<p>On Linux, input to your program will be <strong>line buffered</strong>. This means that the operating system will buffer up input until it has a whole line, so your program won't even see anything the user typed until the user also hits 'enter'. In other words, if your program is expecting the user to type 'w' and the user does this, 'w' will be sitting in the OS's buffer until the user hits 'enter'. At this point the entire line is delivered to your program so you will get the string "w\n" as the user's input.</p>
<p>You can disable this by putting the tty in <strong>raw mode</strong>. You do this with the Python function <code>tty.setcbreak</code> which will make a call down the tty driver in linux to tell it to stop buffering. I passed it the <code>sys.stdin</code> argument to tell it which stream I wanted to turn buffering off for<sup>1</sup>. So after the <code>tty.setcbreak</code> call, the loop above will give you output for every key the user presses.</p>
<p>A complication, though, is that once your program exits, the tty is still in raw mode. You'll generally find this unsatisfying since you don't get any of the power that modern terminal settings offer (like when you use control or escape sequences). For example, notice that you might have trouble exiting the program with <code>ctrl-C</code>. Consequently you should put the terminal back into <strong>cooked mode</strong> once you are done reading input characters. The <code>termios.tcsetattr</code> call simply says "put the terminal back the way I found it". It knows how to do this by first calling <code>termios.tcgetattr</code> at the beginning of the program which is saying "tell me all the current settings for the terminal".</p>
<p>Once you understand all that, you should easily be able to encapsulate the functionality in a function that suits your program.</p>
<p><sup>1</sup> <code>stdin</code> is the stream that input comes to you from the user. Wikipedia can tell you more about <a href="https://en.wikipedia.org/wiki/Standard_streams" rel="nofollow noreferrer">standard streams</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a good lightweight module <a href="https://github.com/thomasballinger/curtsies/">curtsies</a> you could do something like this (taken from their examples/ directory):</p>
<pre><code>from curtsies import Input

def main():
    with Input(keynames='curses') as input_generator:
        for e in input_generator:
            print(repr(e))

if __name__ == '__main__':
    main()
</code></pre>
<p>So pressing keys on your keyboard gives you something like this:</p>
<pre><code>'a'
's'
'KEY_F(1)'
'KEY_F(2)'
'KEY_F(3)'
'KEY_F(4)'
'KEY_F(5)'
'KEY_LEFT'
'KEY_DOWN'
'KEY_UP'
'KEY_RIGHT'
'KEY_NPAGE'
'\n'
</code></pre>
<p>curtsies is used by <a href="https://github.com/bpython/bpython">bpython</a> as a low level abstraction of terminal-related stuff.</p>
<p>The basic problem of decoding the input is that in different terminals and terminal emulator programs like <code>xterm</code> or <code>gnome-terminals</code> physically same keys produce different keycode sequences. That's why one needs to know which terminal settings should be used to decode input. Such a module helps to abstract from those gory details.</p>
</div>
<span class="comment-copy">you might check out graphical interfaces with key bindings see  tk: <a href="https://docs.python.org/3/library/tk.html" rel="nofollow noreferrer">docs.python.org/3/library/tk.html</a></span>
<span class="comment-copy">I faced a problem where <code>print</code> statements inside the loop were not returning to start of line. In "cooked" and "cbreak" mode <code>\n</code> is converted into <code>\r\n</code>. In "raw" mode, that conversion does not happen. See this answer for more details: [<a href="https://stackoverflow.com/a/43929760/6117414]">stackoverflow.com/a/43929760/6117414]</a>. TLDR; use <code>cbreak</code> in place of <code>setraw</code>.</span>
<span class="comment-copy">This solution is the best to me because it handles 'KEY_UP' (among others) while the accepted answer does not</span>
