<div class="post-text" itemprop="text">
<p>I have a list of strings like such, </p>
<pre><code>['happy_feet', 'happy_hats_for_cats', 'sad_fox_or_mad_banana','sad_pandas_and_happy_cats_for_people'] 
</code></pre>
<p>Given a keyword list like <code>['for', 'or', 'and']</code> I want to be able to parse the list into another list where if the keyword list occurs in the string, split that string into multiple parts.</p>
<p>For example, the above set would be split into </p>
<pre><code>['happy_feet', 'happy_hats',  'cats', 'sad_fox', 'mad_banana', 'sad_pandas', 'happy_cats', 'people']
</code></pre>
<p>Currently I've split each inner string by underscore and have a for loop looking for an index of a key word, then recombining the strings by underscore.  Is there a quicker way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; pat = re.compile("_(?:%s)_"%"|".join(sorted(split_list,key=len)))
&gt;&gt;&gt; list(itertools.chain(pat.split(line) for line in data))
</code></pre>
<p>will give you the desired output for the example dataset provided</p>
<p>actually with the <code>_</code> delimiters you dont really need to sort it by length so you could just do </p>
<pre><code>&gt;&gt;&gt; pat = re.compile("_(?:%s)_"%"|".join(split_list))
&gt;&gt;&gt; list(itertools.chain(pat.split(line) for line in data))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; [re.split(r"_(?:f?or|and)_", s) for s in l]
[['happy_feet'],
 ['happy_hats', 'cats'],
 ['sad_fox', 'mad_banana'],
 ['sad_pandas', 'happy_cats', 'people']]
</code></pre>
<p>To combine them into a single list, you can use</p>
<pre><code>result = []
for s in l:
    result.extend(re.split(r"_(?:f?or|and)_", s))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a regular expression:</p>
<pre><code>from itertools import chain
import re

pattern = re.compile(r'_(?:{})_'.format('|'.join([re.escape(w) for w in keywords])))

result = list(chain.from_iterable(pattern.split(w) for w in input_list))
</code></pre>
<p>The pattern is dynamically created from your list of keywords. The string <code>'happy_hats_for_cats'</code> is split on <code>'_for_'</code>:</p>
<pre><code>&gt;&gt;&gt; re.split(r'_for_', 'happy_hats_for_cats')
['happy_hats', 'cats']
</code></pre>
<p>but because we actually produced a set of alternatives (using the <code>|</code> metacharacter) you get to split on any of the keywords:</p>
<pre><code>&gt;&gt;&gt; re.split(r'_(?:for|or|and)_', 'sad_pandas_and_happy_cats_for_people')
['sad_pandas', 'happy_cats', 'people']
</code></pre>
<p>Each split result gives you a list of strings (just one if there was nothing to split on); using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable()</code></a> lets us treat all those lists as one long iterable.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; import re
&gt;&gt;&gt; keywords = ['for', 'or', 'and']
&gt;&gt;&gt; input_list = ['happy_feet', 'happy_hats_for_cats', 'sad_fox_or_mad_banana','sad_pandas_and_happy_cats_for_people']
&gt;&gt;&gt; pattern = re.compile(r'_(?:{})_'.format('|'.join([re.escape(w) for w in keywords])))    
&gt;&gt;&gt; list(chain.from_iterable(pattern.split(w) for w in input_list))
['happy_feet', 'happy_hats', 'cats', 'sad_fox', 'mad_banana', 'sad_pandas', 'happy_cats', 'people']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way of doing this, using only built-in method, is to replace all occurrence of what's in <code>['for', 'or', 'and']</code> in every string with a replacement string, say for example <code>_1_</code> (it could be any string), then at then end of each iteration, to split over this replacement string:</p>
<pre><code>l = ['happy_feet', 'happy_hats_for_cats', 'sad_fox_or_mad_banana','sad_pandas_and_happy_cats_for_people'] 
replacement_s = '_1_'
lookup = ['for', 'or', 'and']
lookup = [x.join('_'*2) for x in lookup] #Changing to: ['_for_', '_or_', '_and_']
results = []
for i,item in enumerate(l):
    for s in lookup:
        if s in item:
            l[i] = l[i].replace(s,'_1_')
    results.extend(l[i].split('_1_'))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>['happy_feet', 'happy_hats', 'cats', 'sad_fox', 'mad_banana', 'sad_pandas', 'happy_cats', 'people']
</code></pre>
</div>
<span class="comment-copy">That's actually probably pretty fast. Is it too slow for your application?</span>
<span class="comment-copy">Not really, I'm just kind of new to Python and didn't know if there was a better, more concise way of doing this.</span>
<span class="comment-copy">I generally recommend measuring before optimizing. :) Basic string operations in particular are often faster than more complex approaches, anyway.</span>
<span class="comment-copy">in python premature optimization can be the root of all evil ... If the way you are doing it is "fast enough" and clear enough for you ... you should stick with it :P</span>
<span class="comment-copy">Thanks for all the help, I figured there way a regex way, but I'm not familiar enough with regex to properly implement it, I'll read up on what exactly the regex code to better help my understanding!</span>
<span class="comment-copy">This needs an extra step to handle any set of words, and this would not work if the word is at the beginning or the end of the string.</span>
<span class="comment-copy">that was not in the requirements stated by OP (hence the disclaimer on my similar answer) ... +1 to this answer from me</span>
<span class="comment-copy">@Holt: Right, Joran's version is better in the first regard. Not sure whether the second one is a problem.</span>
<span class="comment-copy">great minds and all that :P</span>
<span class="comment-copy">@JoranBeasley: this one is on a crappy mobile network at the moment :-( Not much connectivity for the first 20 mins of my train journey (it comes and goes).</span>
