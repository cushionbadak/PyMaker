<div class="post-text" itemprop="text">
<p>I love python one liners:</p>
<pre><code>u = payload.get("actor", {}).get("username", "")
</code></pre>
<p>Problem I face is, I have no control over what 'payload' contains, other than knowing it is a dictionary.  So, if 'payload' does not have "actor", or it does and actor does or doesn't have "username", this one-liner is fine.</p>
<p>Problem of course arises when payload DOES have actor, but actor is not a dictionary.</p>
<p>Is there as pretty a way to do this comprehensively as a one liner, <em>and consider the possibility that 'actor' may not be a dictionary?</em> </p>
<p>Of course I can check the type using 'isinstance', but that's not as nice.</p>
<p>I'm not requiring a one liner per se, just asking for the most efficient way to ensure 'u' gets populated, without exception, and without prior knowledge of what exactly is in 'payload'.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Using EAFP</h3>
<p>As xnx suggested, you can take advantage of the following python paradigm:</p>
<blockquote>
<p><a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">Easier to ask for forgiveness than permission</a></p>
</blockquote>
<p>you can use it on <code>KeyError</code>s as well:</p>
<pre><code>try:
    u = payload["actor"]["username"]
except (AttributeError, KeyError):
    u = ""
</code></pre>
<h3>Using a wrapper with forgiving indexing</h3>
<p>Sometimes it would be nice to have something like null-conditional operators in Python. With some helper class this can be compressed into a one-liner expression:</p>
<pre><code>class Forgive:
  def __init__(self, value = None):
    self.value = value
  def __getitem__(self, name):
    if self.value is None:
      return Forgive()
    try:
      return Forgive(self.value.__getitem__(name))
    except (KeyError, AttributeError):
      return Forgive()
  def get(self, default = None):
    return default if self.value is None else self.value

data = {'actor':{'username': 'Joe'}}
print(Forgive(data)['actor']['username'].get('default1'))
print(Forgive(data)['actor']['address'].get('default2'))
</code></pre>
<p>ps: one could redefine <code>__getattr__</code> as well besides <code>__getitem__</code>, so you could even write <code>Forgive(data)['actor'].username.get('default1')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use an Exception:</p>
<pre><code>try:
    u = payload.get("actor", {}).get("username", "")
except AttributeError:
    u = ""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer hege_hegedus gave is correct, however there's one caveat in that exception handling is a lot slower than going through if..else statement.</p>
<p>For example if you're iterating over thousands of <code>payload</code> object and an actor entry is only occasionally not a dictionary, this code is perfectly valid.</p>
<p>However if you're iterating over thousands of <code>payload</code> objects and every other <code>actor</code> entry is not a dictionary then you'd be better off with this code.</p>
<pre><code>u = ''
if 'actor' in payload and isinstance(payload['actor'], dict):
    u = payload['actor'].get('username', '')
</code></pre>
<p>For more discussion go here -- <a href="https://mail.python.org/pipermail/tutor/2011-January/081143.html" rel="nofollow">https://mail.python.org/pipermail/tutor/2011-January/081143.html</a></p>
<p>UPDATE</p>
<p>Also the code statement can be re-written as a one-liner albeit not nearly as legible as two-line statement</p>
<pre><code>u = payload['actor'].get('username', '') if 'actor' in payload and isinstance(payload['actor'], dict) else ''
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you really need to do it in 1 line, you'll have to implement the functionality yourself. Which is worth doing if you use this semantics many times in your program.</p>
<p>There are two ways to do it: function or custom dictionary-like object for <code>payload</code>.</p>
<p>1) Function handles the case of <code>actor</code> being not a <code>dict</code>. It can check for <code>isinstance</code> or do the <code>try</code> or whatever else -- it's not essential. The usage would look something like <code>u = get("username", "", payload.get("actor", {}))</code> or <code>u = get("", payload, 'actor', 'username')</code> (with arbitrary amount of nested calls for items in <code>payload</code>).</p>
<p>2) A class of custom objects is a powerful thing -- do it if you can and really need this abstraction in the program. A descendant of <code>dict</code> or <code>UserDict</code> (in Python3) can check for what it stores or outputs on <code>__getitem__</code> calls.</p>
</div>
<span class="comment-copy">There seems to be an echo in here... but anyway, if you want to go down the full EAFP route you surely need to catch <code>KeyError</code> as well.</span>
<span class="comment-copy">@xnx sorry for that, I started to write you a comment like 'why not this and why dont you include that link in your answer', but then it looked easier to just post a new answer.. I didn't mean to rob you, is there any SO policy about this?</span>
<span class="comment-copy">@hege_hegedus,  there is no policy but your answer is actually wrong. If actor is a dict and username does not exist you get a KeyError</span>
<span class="comment-copy">I would add <code>KeyError</code> to your exception catch and let people vote on it. Our answers are really distinguished by the "pure EAFP" vs. "bit of both" approaches and as PM 2Ring says, which one is faster (if that matters) will depend on which exception is most likely to be raised.</span>
<span class="comment-copy">@xnx (and Padraic Cunningham) thank you, fixed</span>
<span class="comment-copy">Using exceptions for control flow is probably not a good idea</span>
<span class="comment-copy">I don't think most Python programmers would agree with you in this case: this is simply the application of the <a href="https://docs.python.org/2/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> paradigm.</span>
<span class="comment-copy">@deborah-digges: This is a fairly standard Python idiom. Exceptions in Python are <i>very</i> efficient: generally speaking, if the exceptional condition is rare then using exceptions is actually faster than equivalent <code>if</code>... <code>else</code> logic. However, if the exception is actually raised more than around 5-10% of the time, then it will be slower than using <code>if</code>... <code>else</code>.</span>
<span class="comment-copy">OTOH, I should note that <code>u=d.get(key, default)</code> is a little slower (on average) than <code>if key in d: u=d[key]</code> <code>else u=default</code>.</span>
<span class="comment-copy">Then abstract it to a function?</span>
