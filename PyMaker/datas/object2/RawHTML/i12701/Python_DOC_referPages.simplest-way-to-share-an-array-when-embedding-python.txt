<div class="post-text" itemprop="text">
<p>I'm writing a simulation in C++ and decided to delegate the initialization of some arrays to Python by <a href="https://docs.python.org/3/extending/embedding.html" rel="nofollow">embedding it</a> into my application and use some Python functions for the generation of the initial data.</p>
<p>Since my 2D/3D arrays are allocated and managed by the C++ part, I need to pass them to Python. The best way is probably the <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow">buffer protocol</a>. I could write a Python class in C++, which implements the buffer protocol and creates a buffer object to the storage I have in C++.</p>
<p>Now, I would like to avoid over-engineering this procedure. In facts, I just need to pass a pointer, a tuple of sizes and strides to a Python function.</p>
<p>The question is thus: What is the simplest way to pass this information to a Python routine which can then use it, possibly with Numpy, to initialize the pointed storage?</p>
<p>Just to give an example of what I need to do, the Python function I want to call from C++ is:</p>
<pre><code>def init_field(field, X, Y):
    field[:, :] = np.sqrt(X) + np.tanh(Y)
</code></pre>
<p>where <code>X</code> and <code>Y</code> are numpy arrays which are created by Python and borrowed by the C++ application and <code>field</code> is exactly this 2D array which is managed by C++. I could of course substitute <code>field</code> with one or more parameters carrying information about the pointer, the sizes and the strides and construct the numpy array. How do I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Something not too hard is to use <code>PyArray_SimpleNewFromData</code>. Using that might lead to code like:</p>
<pre><code>void use_array(float* ptr, int width, int height)
{
    PyObject *pFunc = pyFunction("python_function_name");
    if (pFunc == 0)
        return;
    PyObject *pArgs = PyTuple_New(1);
    npy_intp dims[2];
    dims[1] = width;
    dims[0] = height;
    PyTuple_SetItem(pArgs, 0, PyArray_SimpleNewFromData(2, dims, NPY_FLOAT, ptr));
    PyObject *pValue = PyObject_CallObject(pFunc, pArgs);
    Py_DECREF(pArgs);
    if (pValue != NULL) {
        Py_DECREF(pValue);
    }
    else 
    {
        PyErr_Print();
        fprintf(stderr,"Call failed\n");
        return;
    }
    Py_DECREF(pFunc);
}
</code></pre>
<p>When setting up the embedded Python environment you should call <code>import_array()</code>  as described in <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/c-api.array.html#miscellaneous" rel="nofollow">http://docs.scipy.org/doc/numpy-1.10.0/reference/c-api.array.html#miscellaneous</a> </p>
</div>
<span class="comment-copy">There exists a <a href="http://www.boost.org/doc/libs/1_60_0/libs/python/doc/html/index.html" rel="nofollow noreferrer">boost library</a> for Python. Have you looked into that? (Note that I have not, I'm just curious if you have, since you're looking for a simple integration.)</span>
<span class="comment-copy">Yes, I'm aware of that library, but it does not seem to directly help in my case. The hard thing is not really interfacing with Python, but to make it understand the pointer and the data structure I have. There is a <a href="https://github.com/ndarray/Boost.NumPy/" rel="nofollow noreferrer">boost::python version of the numpy C interface</a>, but I don't know how well maintained and how future-proof it is. I would like to avoid too many dependencies because the systems where I will deploy this code are not very straighforward.</span>
<span class="comment-copy">Spiros, definition of <code>PyArray_SimpleNewFromData</code> in .../Python27/Lib/site-packages/numpy/core/include/numpy/ndarrayobject.h is <code>#define PyArray_SimpleNewFromData(nd, dims, typenum, data)          PyArray_New(&amp;PyArray_Type, nd, dims, typenum, NULL,                      data, 0, NPY_ARRAY_CARRAY, NULL)</code>. Here the NULL before data can have the pointer to the strides.</span>
<span class="comment-copy">Here's <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/c-api.array.html#from-scratch" rel="nofollow noreferrer">a link</a> to the relevant NumPy's C-API docs. One of those functions is sure to fit your needs.</span>
<span class="comment-copy">Segfaults with no obvious reason when using NumPy's C API are often due to not having called <code>import_array()</code>. It's hard to tell without seeing your full code, but <a href="http://docs.scipy.org/doc/numpy-1.10.1/user/c-info.how-to-extend.html#required-subroutine" rel="nofollow noreferrer">this link</a> should be helpful.</span>
<span class="comment-copy">My code runs more or less unaltered within a larger framework what is hard to reproduce here. Call to import_array as indicated above by Jaime is essential.</span>
<span class="comment-copy">Thanks for your clarifications, now everything works the way I wanted. I wasn't sure about the <code>inport_array</code> function call because I was embedding numpy, not extending it, but I see I need it anyway.</span>
