<div class="post-text" itemprop="text">
<p>I want to use a bit array in Python that I could use like the standard bitset from C++. Example:</p>
<pre><code>#include&lt;bitset&gt;
int main() {
    std::bitset&lt;100&gt; numBits;
}
</code></pre>
<p>However, I don't know if there is something similar in Python, preferably built-in.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thre is nothing built-in for that. If you need such a data structure in order to have a proper output of bytes, with the correct bits set, such as for a network protocol, a binary file structure or hardware control, sequencing a list of True and False values to a sequence of Bytes is easily feasible.</p>
<p>One could also create a class to allow direct manypulation of in-memory bits in a bytearray object.  However, unlikely what takes place in C++, you won't gain speed or memory (ok, for large bitsets you could gain memory) advantages for that - Python will process each bit as a full  reference to the True or False objects (or to full 0 and 1 integers) regardless of what you do in code.</p>
<p>That said, if you have a list with True and False values you want to output to, say, a file, as a sequence of bits, code like this might work:</p>
<pre><code>a = [True, True, False, False, False, True, ...]
with open("myfile.bin", "wb" as file):
    for i, value in enumerate(a):
        if not i % 8:
            if i:
                file.write(byte)
            byte = 0
        byte &lt;&lt;= 1
        byte |= value
     if i % 8:
        byte &lt;&lt;= (8 - i % 8)
        file.write(byte)
</code></pre>
<p>A more sophisticated way is to create a full-class support for it, by keeping the values ina  bytearray object, and computing each bit index at set and reset operations - a minimalist way of doing that is:</p>
<pre><code>class BitArray(object):
    def __init__(self, lenght):
        self.values = bytearray(b"\x00" * (lenght // 8 + (1 if lenght % 8  else 0)))
        self.lenght = lenght

    def __setitem__(self, index, value):
        value = int(bool(value)) &lt;&lt; (7 - index % 8)
        mask = 0xff ^ (7 - index % 8)
        self.values[index // 8] &amp;= mask
        self.values[index // 8] |= value
    def __getitem__(self, index):
        mask = 1 &lt;&lt; (7 - index % 8)
        return bool(self.values[index // 8] &amp; mask)

    def __len__(self):
        return self.lenght

    def __repr__(self):
        return "&lt;{}&gt;".format(", ".join("{:d}".format(value) for value in self))
</code></pre>
<p>As you can see, there is no speed gain in doing so, and you'd need a lot of bits to take any benefit of memory savings with that.  This is an example of the above class in use at the interactive prompt:</p>
<pre><code>In [50]: a = BitArray(16)

In [51]: a[0] = 1

In [52]: a[15] = 1

In [53]: a
Out[53]: &lt;1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, you could make a "bitset" using a list of booleans:</p>
<pre><code>mybitset = [True, False, False, True, False]
</code></pre>
<p>I lack context to give you a more appropriate response.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use an ordinary <code>list</code>; however this would not be very effective memorywise: on 32-bit Python builds it would waste 4 bytes per "bit", and on 64-bit builds 8 bytes. This is because the elements of a list are really (references to) other Python objects.</p>
<p>Python standard library does also have the built-in <a href="https://docs.python.org/3/library/array.html" rel="nofollow"><code>array</code></a> module, which is much more efficient for storing homogeneous values than the generic <code>list</code>, but it unfortunately does not support bits as the data type. Furthermore, it does not provide the <code>Set</code> interface.</p>
<p>Thus, if memory efficiency is of concern, then your choices would boil down to either building your own Python bitset implementation over the <code>array</code>, or installing a 3rd-party module from <a href="https://pypi.python.org/pypi" rel="nofollow"><code>PyPI</code></a>, such as the <a href="https://pypi.python.org/pypi/intbitset/2.2.1" rel="nofollow"><code>intbitset</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Normally, you just the builtin <code>int</code> class (or <code>long</code> in python2). Maybe wrap it in a class if you particularly care about hiding the shifts.</p>
</div>
<span class="comment-copy">I'm guessing you didn't <a href="https://pypi.python.org/pypi/bitsets/0.7.9" rel="nofollow noreferrer">google it</a>?</span>
<span class="comment-copy">@erip,that's mean python doesn't provide built-in utils about this ?</span>
<span class="comment-copy">@LightnessRacesinOrbit,sorry,question has been updated,please help.</span>
<span class="comment-copy">Sorry for changing the question a little too much.</span>
<span class="comment-copy">@jweyrich,thank you for your editing.</span>
<span class="comment-copy">how many bytes will boolean use,1 byte or 8byte?</span>
<span class="comment-copy">That probably depends on the python interpreter used.</span>
<span class="comment-copy"><code>sys.getsizeof(mybitset)</code> returns 104 on my machine. Think of it as a pointer to a singleton, because the <code>id</code> of every True and False is the same: <code>&gt;&gt;&gt; [id(x) for x in mybitset] [139974218568224, 139974218568256, 139974218568256, 139974218568224, 139974218568256] </code>.</span>
