<div class="post-text" itemprop="text">
<p>Is it possible to mock methods of imported modules with unittest.mock in Python 3.5? </p>
<pre><code># file my_function.py
import os
my_function():
    # do something with os, e.g call os.listdir
    return os.listdir(os.getcwd())

# file test_my_function.py
test_my_function():
    os = MagickMock()
    os.listdir = MagickMock(side_effect=["a", "b"])
    self.assertEqual("a", my_function())
</code></pre>
<p>I expected that the the os.listdir method returns the specified side_effect "a" on the first call, but inside of my_function the unpatched os.listdir is called.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unitetest.mock</code></a> have two main duties:</p>
<ul>
<li>Define <code>Mock</code> objects: object designed to follow your screenplay and record every access to your mocked object</li>
<li>patching references and recover the original state</li>
</ul>
<p>In your example you need both functionalities: Patching <code>os.listdir</code> reference used in production code by a mock where you can have a complete control off it will respond. There are a lot of ways to use <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow"><code>patch</code></a>, some <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">details to take care on how use it</a> and <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="nofollow">cavelets to know</a>.</p>
<p>In your case you need to test <code>my_function()</code> behaviour and you need to patch both <code>os.listdir()</code> and <code>os.getcwd()</code>. Moreover what you need is control the <code>return_value</code> (take a look to the pointed documentation for <code>return_value</code> and <code>side_effect</code> differences).</p>
<p>I rewrote your example a little bit to make it more complete and clear:</p>
<pre><code>my_function(nr=0):
    l = os.listdir(os.getcwd())
    l.sort()
    return l[nr]

@patch("os.getcwd")
@patch("os.listdir", return_value=["a","b"])
def test_my_function(mock_ld, mock_g): 
    self.assertEqual("a", my_function(0))
    mock_ld.assert_called_with(mock_g.return_value)
    self.assertEqual("a", my_function())
    self.assertEqual("b", my_function(1))
    with self.assertRaises(IndexError):
        my_function(3)
</code></pre>
<p>I used the decorator syntax because I consider it the cleaner way to do it; moreover to avoid introduction of too much details I didn't use autospecing
that I consider a very best practice.</p>
<p>Last note: mocking is a powerful tool but use it and not abuse of it, patch just you need to patch and nothing more.</p>
</div>
<span class="comment-copy">Yes, that's possible, but you'll have to patch out the original version - see e.g. <a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#the-patchers</a>. As a rule, <i>"how to"</i> questions are a bad fit for SO.</span>
<span class="comment-copy">@jonrsharpe I have read the meta quality page <a href="http://meta.stackexchange.com/questions/92074/what-can-i-do-when-getting-it-does-not-meet-our-quality-standards" title="what can i do when getting it does not meet our quality standards">meta.stackexchange.com/questions/92074/â€¦</a> and tried to improve the question. However, could you elaborate if this does now better fit the quality standards and "How to UPSERT in Oracle (update or insert into a table)?" is even an example for a <b>good</b> title listed there. The question is precise, relevant for others as there obviously is a clear distinction between patching and using binding to MagicMock, which was not clear for me reading the documentation.</span>
<span class="comment-copy">@NoxMortem Now you have a clear question and I can give you a clear answer.</span>
<span class="comment-copy">Some explanation of how/why this works would be nice. Note also that the last two lines seem to be a test that the mocking works as expected, rather than of the actual function under test, which seems odd.</span>
<span class="comment-copy">@jonrsharpe Ok it was just a joke.... I'll fix it at launch time :)</span>
<span class="comment-copy">@jonrsharpe updated</span>
<span class="comment-copy">Thank you very much for your answer, especially for providing the two extra links about details and caveats as well as placing the keyword autospec, which makes the answer especially readworthy! I now know how to solve the problem and dive further into better unittests with unittest.mock.</span>
