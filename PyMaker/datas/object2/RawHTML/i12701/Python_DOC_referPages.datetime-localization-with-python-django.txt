<div class="post-text" itemprop="text">
<p>I am trying to parse an RSS feed. Entries in the feed have date elements like:</p>
<pre><code>&lt;dc:date&gt;2016-09-21T16:00:00+02:00&lt;/dc:date&gt;
</code></pre>
<p>Using feedparser, I try to do:</p>
<pre><code>published_time = datetime.fromtimestamp(mktime(entry.published_parsed))
</code></pre>
<p>But the problem is that I seem to be getting the wrong time stored in the database. In this particular case, the datetime is stored as:</p>
<pre><code>2016-09-21 13:00:00
</code></pre>
<p>... when I would expect 14:00 - the correct UTC time.</p>
<p>I assume the problem is in our django settings, where we have:</p>
<pre><code>TIME_ZONE = 'Europe/Berlin'
</code></pre>
<p>Because when I switch to:</p>
<pre><code>TIME_ZONE = 'UTC'
</code></pre>
<p>... the datatime is stored as correct UTC time:</p>
<pre><code>2016-09-21 14:00:00
</code></pre>
<p>Is there any way to keep the django settings as they are, but to parse and store this datetime correctly, without the django timezone setting affecting it?</p>
<p>EDIT:
Maybe it's more clear like this...</p>
<pre><code>print entry.published_parsed
published_time = datetime.fromtimestamp(mktime(entry.published_parsed))
print published_time
localized_time = pytz.timezone(settings.TIME_ZONE).localize(published_time, is_dst=None)
print localized_time

time.struct_time(tm_year=2016, tm_mon=9, tm_mday=21, tm_hour=14, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=265, tm_isdst=0)
2016-09-21 15:00:00
2016-09-21 15:00:00+02:00
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>feedparser's <code>entry.published_parsed</code> is always a utc time tuple whatever the input time string is. To get timezone-aware <code>datetime</code> object:</p>
<pre><code>from datetime import datetime

utc_time = datetime(*entry.published_parsed[:6], tzinfo=utc)
</code></pre>
<p>where <code>utc</code> is a tzinfo object such as <a href="https://docs.python.org/3/library/datetime.html#datetime.timezone.utc" rel="nofollow noreferrer"><code>datetime.timezone.utc</code></a>, <a href="http://pythonhosted.org/pytz/" rel="nofollow noreferrer"><code>pytz.utc</code></a>, or just your <a href="https://stackoverflow.com/a/25421145/4279">custom tzinfo (for older python versions)</a>.</p>
<p>You shouldn't pass utc time to <code>mktime()</code> that expects a local time. Same error: <a href="https://stackoverflow.com/q/30130588/4279">Have a correct datetime with correct timezone</a>.</p>
<p>Make sure <code>USE_TZ=True</code> so that django uses aware datetime objects everywhere. Given a timezone-aware datetime object, django should save it to db correctly whatever your <a href="https://docs.djangoproject.com/en/1.9/topics/i18n/timezones/#default-current-time-zone" rel="nofollow noreferrer"><code>TIME_ZONE</code> or <code>timezone.get_current_timezone()</code> are</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried using <code>datetime.utcfromtimestamp()</code> instead of <code>datetime.fromtimestamp()</code>?</p>
<p>As a secondary solution, you can get the unparsed data (I believe it's available as <code>entry.published</code>?) and just use python-dateutil to parse the string, then convert it to <code>pytz.utc</code> timezone like this.</p>
<pre><code>&gt;&gt;&gt; import pytz
&gt;&gt;&gt; from dateutil import parser
&gt;&gt;&gt; dt = parser.parse('2016-09-21T16:00:00+02:00')
&gt;&gt;&gt; dt
datetime.datetime(2016, 9, 21, 16, 0, tzinfo=tzoffset(None, 7200))
&gt;&gt;&gt; dt.astimezone(pytz.utc)
datetime.datetime(2016, 9, 21, 14, 0, tzinfo=&lt;UTC&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use</p>
<pre><code>published_time = pytz.utc.localize(datetime.utcfromtimestamp(calendar.timegm(parsed_entry.published_parsed)))
</code></pre>
<p>Feedparser can parse a large range of date formats, you can find them <a href="https://pythonhosted.org/feedparser/date-parsing.html" rel="nofollow">here</a>.</p>
<p>As you can see in <code>feedparser/feedparser/datetimes/__init__.py</code>, the built-in function from Feedparser <code>_parse_date</code> does the following:</p>
<blockquote>
<p>Parses a variety of date formats into a 9-tuple in GMT</p>
</blockquote>
<p>This means that in <code>parsed_entry.published_parsed</code> you have a <code>time.struct_time</code> object in GMT timezone.</p>
<p>When you convert it to a <code>datetime</code> object using</p>
<pre><code>published_time = datetime.fromtimestamp(mktime(parsed_entry.published_parsed))
</code></pre>
<p>the problem is that <code>mktime</code> assumes that the passed tuple is in <em>local time</em>, which is not, it's GMT/UTC! Other than that you don't properly localize the <code>datetime</code> object at the end of the conversion.</p>
<p>You need to replace that conversion with the following, remembering that Feedparser returns a GMT <code>struct_time</code>, and localize that with the timezone you like (UTC for the sake of simplicity).</p>
<ul>
<li>You use <code>calendar.timegm</code>, which gives the number of seconds between epoch and the date passed as a parameter, assuming that the passed object is in UTC/GMT (we know from Feedparser it is)</li>
<li>You use <code>utcfromtimestamp</code> to obtain a naive <code>datetime</code> object (which we know represents a datetime in UTC, but Python does not at this moment)</li>
<li>With <code>pytz.utc.localize</code> you properly localize in UTC the <code>datetime</code> object.</li>
</ul>
<p>Example:</p>
<pre><code>import calendar
from datetime import datetime
import pytz
localized_dt = pytz.utc.localize(datetime.utcfromtimestamp(calendar.timegm(parsed_entry.published_parsed)))
</code></pre>
<p>As long as you are consistent, it doesn't matter if you use <code>fromtimestamp</code> or <code>utcfromtimestamp</code>. If you use <code>fromtimestamp</code> you need to tell Python that the <code>datetime</code> object you created has the local timezone. Supposing you are in Europe/Berlin, this is also fine:</p>
<pre><code>pytz.timezone('Europe/Berlin').localize(datetime.fromtimestamp(calendar.timegm(parsed_entry.published_parsed)))
</code></pre>
<p>Were <code>parsed_entry.published_parsed</code> also in local timezone, <code>mktime</code> must be used in place of <code>calendar.timegm</code>.</p>
<p>As an alternative you can parse yourself the data string you get from Feedparser <code>parsed_entry['published']</code></p>
<pre><code>from dateutil import parser
localized_dt = parser.parse(parsed_entry['published'])
</code></pre>
<p>You can check that the following returns <code>True</code>:</p>
<pre><code>parser.parse(parsed_entry['published']) == pytz.utc.localize(datetime.utcfromtimestamp(calendar.timegm(parsed_entry.published_parsed)))
</code></pre>
<p>The Django <code>TIME_ZONE</code> setting doesn't actually matter, because it's used only for visualization purposes or to automatically convert naive datetimes.</p>
<blockquote>
<p>When USE_TZ is True, this is the default time zone that Django will use to display datetimes in templates and to interpret datetimes entered in forms.</p>
</blockquote>
<p>What is important is to always use properly localized datetimes, no matter which time zone is used. As long as they are not in naive format, they will be properly handled by Django.</p>
</div>
<span class="comment-copy">Are you interested in a time zone conversion or would you be open to simply adding an hour with a datetime.timedelta operation?</span>
<span class="comment-copy">Ultimately, I'd like to have the correct time in UTC. Taking an hour away now (two hours in day saving period) may be a way to go. I haven't looked at it yet though. I was wondering if there was another way. I tried for instance timezone.activate() and timezone.deactivate() which seemed to change the current_timezone in the right way, but that didn't fix the problem.</span>
<span class="comment-copy">You can make a datetime aware, or change the timezone if it's already aware but wrong.</span>
<span class="comment-copy">I also tried this solution. It works too. Thanks!</span>
<span class="comment-copy">time.struct_time(tm_year=2016, tm_mon=9, tm_mday=21, tm_hour=14, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=265, tm_isdst=0)     2016-09-21 13:00:00     2016-09-21 13:00:00+00:00 ... This is the output of utcfromtimestamp(). The timezone is changed, but the time is still not correct.</span>
<span class="comment-copy">Second solution could work. My only concern is that there are many different date formats. From what we encountered so far, feedparser didn't have a problem with any of them. I am wondering if the parser you suggest works equally well. Do you use it for many different date formats?</span>
<span class="comment-copy">@apiljic: use feedparser to parse input time strings (<code>_parsed</code> attributes). <code>dateutil</code> accepts too many input time formats and therefore may return a wrong result silently.</span>
<span class="comment-copy">it is unnecessary complicated. Here's a <a href="http://stackoverflow.com/a/34292796/4279">simpler solution</a></span>
<span class="comment-copy">I agree, you need this complication when you need to consider the dst flag, which is the case for a local time (that is where you use mktime) and not for UTC, which hasn't it.</span>
<span class="comment-copy">if the time is not UTC then the code is not merely complicated; it is just wrong.</span>
<span class="comment-copy">What is wrong with <code>local_tz.localize(datetime.fromtimestamp(mktime(x)))</code>?</span>
<span class="comment-copy">there are several things wrong but I'm talking about the very first code example in your answer (with <code>timegm()</code>).</span>
