<div class="post-text" itemprop="text">
<p>Is there a way to have a class delete an instance of itself. I know for variables you can do <code>del x</code> but how do you do that for classes? If I do something like:</p>
<pre><code>class foo(object):
    x=5
    def __init__(self):
        print "hi"
    def __del__(self):
        del self
        print "bye"

a = foo()
a.__del__()
print a.x
</code></pre>
<p>The output of the code is</p>
<pre><code>hi
bye
5
</code></pre>
<p>The instance of foo wasn't deleted. Is there a way to make a class do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, if you have a reference to an instance of the class, then by definition it has remaining references. You can use the <code>del</code> keyword to delete a name (releasing the reference from that name to the object), but if a reference to the instance is held elsewhere, the instance remains.</p>
<p>If what you're going for is deterministic cleanup behavior, don't use <code>__del__</code> (which is not deterministic in an obvious or consistent way, and prior to Python 3.4, could cause reference cycle leaks if any member of the cycle was an instance of a class that defined a <code>__del__</code> finalizer). Have the class implement <a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager" rel="nofollow">the context manager protocol</a>, and use instances with <code>with</code> statements to get deterministic cleanup; the instance will still exist until the last reference goes away, but as long as <code>__exit__</code> performs the necessary release of resources, the empty shell of the instance costs you almost nothing.</p>
<p>As an example of context management, we'll make <code>x</code> an instance attribute of <code>foo</code>, not a class attribute, and we'll say we need ensure the instance's reference to <code>x</code> goes away at a known time (note, because <code>del</code> just deletes our reference, if someone else saved off <code>a.x</code>, the object won't actually be freed until the other reference(s) are also released):</p>
<pre><code>class foo(object):
    def __init__(self, x):
        self.x = x
        print "hi"
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print "bye"
        del self.x

with foo(123456789) as a:
    print a.x  # This works, because a.x still exists
# bye is printed at this point
print a.x # This fails, because we deleted the x attribute in __exit__ and the with is done
# a still exists until it goes out of scope, but it's logically "dead" and empty
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By defining <code>__del__</code> I believe you're overriding the default behavior of <code>del</code>. As you can read <a href="https://docs.python.org/2/reference/datamodel.html#object.__del__" rel="nofollow">here</a>, <code>__del__</code> is called once the reference count of an object reaches 0. It is not recommended to use <code>__del__</code> unless you know what you're doing.</p>
<p>EDIT: this is incorrect, please check shadowranger's answer. Although the link is still relevant to python 2</p>
</div>
<div class="post-text" itemprop="text">
<p><code>del a</code> should do the trick:</p>
<p>Code: </p>
<pre><code>class foo(object):
    x=5
    def __init__(self):
        print "hi"
    def __del__(self):
        del self
        print "bye"

a = foo()
del a
print a.x
</code></pre>
<p>Output:</p>
<pre><code>$ python test.py
hi
here
bye
Traceback (most recent call last):
  File "test.py", line 12, in &lt;module&gt;
    print a.x
NameError: name 'a' is not defined
</code></pre>
</div>
<span class="comment-copy"><code>del a</code> maybe? It did the trick here</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/16686788/python-how-to-kill-a-class-instance-object" title="python how to kill a class instance object">stackoverflow.com/questions/16686788/â€¦</a></span>
<span class="comment-copy">For the record, <code>x</code> isn't even an attribute of <code>a</code>, it's a class attribute of <code>foo</code>; it's not going to go away whether or not the <code>foo</code> instance referenced by <code>a</code> exists or not.</span>
<span class="comment-copy">This is flat wrong. <code>del</code> the keyword deletes a name (or in some cases, references from within a container) and thereby releases references to the object associated with that name. But if there are other references elsewhere, <code>del</code> does nothing but (in CPython) decrement the reference count. <code>__del__</code> is invoked when the last reference goes away, regardless of whether <code>del</code> was involved or not. The two are only tangentially related; <code>del</code> itself does nothing differently for instances of classes with or without <code>__del__</code>, only the Python garbage disposal process changes.</span>
<span class="comment-copy">Well there you go, I obviously haven't done my homework on CPython garbage collection. Looks like I learned something today too, however I believe you jumped the gun a bit. I never said <code>__del__</code> was invoked specifically by <code>del</code> and reference count equaling zero is the same as no references however I'll absolutely 100% concede my answer was misleading and the first sentence was wrong.</span>
