<div class="post-text" itemprop="text">
<p>Say there is</p>
<pre><code>class thing(object):
    def __init__(self):
        self.text = "foo"


def bar():
    obj = thing()
    #do something with the object

bar()
</code></pre>
<p>Is obj deleted from memory after bar() finishes, or is it still in memory, just can't be accessed since it is a local variable of bar? (This assumes obj is not put into a global or external container such as a dictionary or list, of course).</p>
</div>
<div class="post-text" itemprop="text">
<p>The object <code>obj</code> references will be deleted when the function exits.</p>
<p>That's because CPython (the default Python implementation) uses reference counting to track object lifetimes. <code>obj</code> is a local variable and only exists for the duration of the function. <code>thing()</code> is an instance with just one reference, <code>obj</code>, and when <code>obj</code> is cleaned up, the reference count drops to 0 and <code>thing()</code> is immediately deleted.</p>
<p>If you are using PyPy, IronPython, Jython or some other implementation, object destruction can be delayed as implementations are free to use different garbage collection schemes. This is only important for implementing a <code>__del__</code> method, as their invocation can be delayed. </p>
<p>I recommend you read the excellent <a href="http://nedbatchelder.com/text/names.html" rel="nofollow"><em>Facts and myths about Python names and values</em></a> if you want to know more about how Python names work.</p>
</div>
<div class="post-text" itemprop="text">
<p>Incorporating corrections:</p>
<p>Yes, objects with a reference count of 0 are reclaimed when a function goes out of scope.</p>
<p>Python has builtins, global (module) scope and function scope.</p>
<p>If you have a resource that needs to get freed as soon as the scope exits, put it in a <code>with</code> block and put the logic to free the resource in <code>__exit__</code>. The variable associated with the <code>with</code> block is still local to the enclosing function or module.</p>
<p>The idiom for resources that should be freed as soon as they go out of scope is <code>with</code>, e.g.</p>
<pre><code>with open("frodo.txt","r") as fh:
    for line in fh:
        do_something(line)
</code></pre>
<p>In CPython, prior to version 3.4, objects with a custom <code>__del__</code> method might be deleted in a non-deterministic order if they are involved in a cycle.</p>
</div>
<span class="comment-copy">The distinction between "deleted" and "eligible for deletion" is one that very much exists. Those objects are eligible for deletion as soon as the function completes, regardless of the active language implementation; whether they're actually deleted immediately (or deleted later when GC is periodically triggered) depends on which interpreter you're running.</span>
<span class="comment-copy"><code>fh</code> is not cleaned up just because the <code>with</code> block exited. Merely, <code>fh.__exit__()</code> is guaranteed to have been called. <code>with</code> blocks are not a new scope.</span>
<span class="comment-copy">The example the OP stated has no cycles, the cycle detection algorithm is not involved.</span>
<span class="comment-copy">Last but not least, CPython <i>does</i> have deterministic destruction, for any object not involved in a cycle. Even those involved in a cycle usually will have their cycle broken in a deterministic manner. The exception are instances of classes with a <code>__del__</code> hook, and only in Python versions before 3.4.  See the <a href="https://docs.python.org/3/library/gc.html" rel="nofollow noreferrer"><code>gc</code> module documenation</a> for more details.</span>
<span class="comment-copy">@MartijnPieters Thanks. Are deleting objects immediately when their reference count goes to 0 and breaking GC cycles deterministically things every conforming Python implementation must do or an implementation detail of CPython?</span>
<span class="comment-copy">It is a CPython implementation detail. Jython and IronPython use their VM GC strategy and cleanup can be delayed.</span>
