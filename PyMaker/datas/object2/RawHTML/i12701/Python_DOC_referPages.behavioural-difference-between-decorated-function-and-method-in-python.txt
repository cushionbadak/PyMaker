<div class="post-text" itemprop="text">
<p>I use the following workaround for "Pythonic static variables":</p>
<pre><code>def static_vars(**kwargs):
    """decorator for funciotns that sets static variables"""
    def decorate(func):
        for k, v in kwargs.items():
            setattr(func, k, v)
        return func
    return decorate

@static_vars(var=1)
def global_foo():
    _ = global_foo
    print _.var
    _.var += 1

global_foo()  # &gt;&gt;&gt; 1
global_foo()  # &gt;&gt;&gt; 2
</code></pre>
<p>It works just as supposed to. But when I move such a decorated function inside a class I get a strange change:</p>
<pre><code>class A(object):
    @static_vars(var=1)
    def foo(self):
        bound = self.foo
        unbound = A.foo
        print bound.var  # OK, print 1 at first call
        bound.var += 1   # AttributeError: 'instancemethod' object has no attribute 'var'

    def check(self):
        bound = self.foo
        unbound = A.foo
        print 'var' in dir(bound)
        print 'var' in dir(unbound)
        print bound.var is unbound.var  # it doesn't make much sense but anyway

a = A()
a.check()  # &gt;&gt;&gt; True
           # &gt;&gt;&gt; True
           # &gt;&gt;&gt; True

a.foo()    # ERROR
</code></pre>
<p>I can not see what causes such behaviour. It seems to me that it has something to do with python descriptors protocol, all that bound vs unbound method stuff. Somehow the <code>foo.var</code> attribute is accessible but is not writable.</p>
<p>Any help is appreciated.</p>
<p>P.S. I understand that static function variables are essentially class variables and this decorator is unnecessary in the second case but the question is more for understanding the Python under the hood than to get any working solution.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>a.foo</code> doesn't return the actual function you defined; it returns a bound method of it, which wraps up the function and has <code>self</code> assigned to<code>a</code>.</p>
<p><a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow">https://docs.python.org/3/howto/descriptor.html#functions-and-methods</a></p>
<p>That guide is out of date a little, though, since unbound methods just return the function in Python 3.</p>
<p>So, to access the attributes on the function, you need to go through <code>A.foo</code> (or <code>a.foo.__func__</code>)instead of <code>a.foo</code>. And this will only work in Python 3. In Python 2, I think <code>A.foo.__func__</code> will work.</p>
</div>
<span class="comment-copy">But why then I can read these attributes? <code>print a.foo.var</code> works, as well as <code>print A.foo.var</code></span>
<span class="comment-copy">I guess the type <code>instancemethod</code> implements <code>__getattribute__()</code> to fetch unknown attributes from the enclosed unbound method/function. Setting attributes on bound methods isn't a good idea anyway because every time you get such a method from the instance you get a <i>different</i>, <i>new</i> object! <code>x, y = a.foo, a.foo; print x is y</code> â†’ prints <code>False</code>.</span>
<span class="comment-copy">I would say that @BlackJack is right. Except that I'd guess that they implements __getattr__() instead of <code>__getattribute_()</code>, since that's the last-ditch effort version. Either way, he's almost definitely correct about it not allowing attributes to be set on a bound method, since it's a new instance every time.  Again, I recommend going straight to the function using <code>instancemethod</code>'s <code>__func__</code> attribute.</span>
<span class="comment-copy">@JacobZimmerman I've looked at an actual <code>instancemethod</code> instance and it has a <code>__getattribute__()</code> but no <code>__getattr__()</code>.</span>
<span class="comment-copy">I see. You're right. Interesting.</span>
