<div class="post-text" itemprop="text">
<p>Today I'm learning using <code>*</code> and <code>**</code> to unpack arguments.<br/>
I find that both <code>list</code>, <code>str</code>, <code>tuple</code>, <code>dict</code> can be unpacked by <code>*</code>.<br/>
I guess because they are all iterables. So I made my own class.</p>
<pre><code># FILE CONTENT
def print_args(*args):
    for i in args:
        print i

class MyIterator(object):
    count = 0
    def __iter__(self):
        while self.count &lt; 5:
            yield self.count
            self.count += 1
        self.count = 0

my_iterator = MyIterator()

# INTERPRETOR TEST
In [1]: print_args(*my_iterator)
0
1
2
3
4
</code></pre>
<p>It works! But how to make a <code>mapping</code> object like <code>dict</code> in python so that <code>**</code> unpacking works on it? Is it possible to do that? And is there already another kind of <code>mapping</code> object in python except <code>dict</code>?</p>
<hr/>
<p>PS:
I know I can make an object inherit from <code>dict</code> class to make it a mapping object. But is there some key <code>magic_method</code> like <code>__iter__</code> to make a mapping object without class inheritance?</p>
<hr/>
<p>PS2:
With the help of @mgilson's answer, I've made an object which can be unpacked by <code>**</code> without inherit from current mapping object:</p>
<pre><code># FILE CONTENT
def print_kwargs(**kwargs):
    for i, j in kwargs.items():
        print i, '\t', j

class MyMapping(object):
    def __getitem__(self, key):
        if int(key) in range(5):
            return "Mapping and unpacking!"

    def keys(self):
        return map(str, range(5))

my_mapping = MyMapping()
print_kwargs(**my_mapping)

# RESULTS
1   Mapping and unpacking!
0   Mapping and unpacking!
3   Mapping and unpacking!
2   Mapping and unpacking!
4   Mapping and unpacking!
</code></pre>
<p>Be aware, when unpacking using <code>**</code>, the key in your mapping object should be type <code>str</code>, or TypeError will be raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>Any mapping can be used.  I'd advise that you inherit from <a href="https://docs.python.org/2/library/collections.html#collections.Mapping" rel="nofollow noreferrer"><code>collections.Mapping</code></a> or <code>collections.MutableMapping</code><sup>1</sup>.  They're abstract base classes -- you supply a couple methods and the base class fills in the rest.</p>
<p>Here's an example of a "frozendict" that you could use:</p>
<pre><code>from collections import Mapping

class FrozenDict(Mapping):
    """Immutable dictionary.

    Abstract methods required by Mapping are
    1. `__getitem__`
    2. `__iter__`
    3. `__len__`
    """

    def __init__(self, *args, **kwargs):
        self._data = dict(*args, **kwargs)

    def __getitem__(self, key):
        return self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)
</code></pre>
<p>And usage is just:</p>
<pre><code>def printer(**kwargs):
    print(kwargs)

d = FrozenDict({'a': 1, 'b': 2})
printer(**d)
</code></pre>
<p><sup>To answer your question about which "magic" methods are necessary to allow unpacking -- just based on experimentation alone -- in Cpython a class with <code>__getitem__</code> and <code>keys</code> is enough to allow it to be unpacked with <code>**</code>.  With that said, there is no <em>guarantee</em> that works on other implementations (or future versions of CPython).  To get the guarantee, you need to implement the full mapping interface (usually with the help of a base class as I've used above).</sup></p>
<p>In python2.x, there's also <a href="https://docs.python.org/2/library/userdict.html" rel="nofollow noreferrer"><code>UserDict.UserDict</code></a> which can be accessed in python3.x as <code>collections.UserDict</code> -- However if you're going to use this one, you can frequently just <a href="https://stackoverflow.com/a/1394572/748858">subclass from <code>dict</code></a>.</p>
<p><sup><sup>1</sup>Note that as of Python3.3, those classes were moved to the<code>collections.abc</code> module.</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>First, let's define unpacking:</p>
<pre><code>def unpack(**kwargs): 
    """
    Collect all keyword arguments under one hood
    and print them as 'key: value' pairs
    """
    for key_value in kwargs.items(): 
       print('key: %s, value: %s' % key_value)
</code></pre>
<p>Now, the structure: two built-in options available are <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow">collections.abc.Mapping</a> and <a href="https://docs.python.org/3.5/library/collections.html?highlight=userdict#collections.UserDict" rel="nofollow">collections.UserDict</a>. As there's another answer exploring highly-customizable <code>Mapping</code> type,  I will focus on <code>UserDict</code>: <code>UserDict</code> can be easier to start with if all you need is a basic dict structure with some twist. After definition, underlying <code>UserDict</code> dictionary of is also accessible as <code>.data</code> attribute. </p>
<p>1.It can be used inline, like so: </p>
<pre><code>from collections import UserDict
&gt;&gt;&gt; d = UserDict({'key':'value'})

&gt;&gt;&gt; # UserDict makes it feel like it's a regular dict
&gt;&gt;&gt; d, d.data
({'key':'value'}, {'key':'value'})
</code></pre>
<p>Breaking <code>UserDict</code> into key=value pairs:</p>
<pre><code>&gt;&gt;&gt; unpack(**d)
key: key, value: value
&gt;&gt;&gt; unpack(**d.data) # same a above
key: key, value: value
</code></pre>
<p>2.If subclassing, all you have to do is to define self.data within <code>__init__</code>. Note that i expanded the class with additional functionality with (self+other) 'magic' methods:</p>
<pre><code>class CustomDict(UserDict):
    def __init__(self, dct={}):
        self.data = dct

    def __add__(self, other={}):
        """Returning new object of the same type
           In case of UserDict, unpacking self is the same as unpacking self.data
        """
        return __class__({**self.data, **other})

    def __iadd__(self, other={}):
        """Returning same object, modified in-place"""
        self.update(other)
        return self
</code></pre>
<p>Usage is:</p>
<pre><code>&gt;&gt;&gt; d = CustomDict({'key': 'value', 'key2': 'value2'})
&gt;&gt;&gt; d
{'key': 'value', 'key2': 'value2'}
&gt;&gt;&gt; type(d), id(d)
(&lt;class '__main__.CustomDict'&gt;, 4323059136)
</code></pre>
<p>Adding other dict (or any <code>mapping</code> type) to it will call <code>__add__</code>, returning new object:</p>
<pre><code>&gt;&gt;&gt; mixin = {'a': 'aaa', 'b': 'bbb'}
&gt;&gt;&gt; d_new = d + mixin # __add__
&gt;&gt;&gt; d_new
{'key': 'value', 'a': 'aaa', 'key2': 'value2', 'b': 'bbb'} 
&gt;&gt;&gt;type(d_new), id(d_new)
(&lt;class '__main__.CustomDict'&gt;, 4323059248) # new object
&gt;&gt;&gt; d # unmodified
{'key': 'value', 'key2': 'value2'}
</code></pre>
<p>In-place modification with <code>__iadd__</code> will return the same object (same id in memory)</p>
<pre><code>&gt;&gt;&gt; d += {'a': 'aaa', 'b': 'bbb'} # __iadd__
&gt;&gt;&gt; d
{'key': 'value', 'a': 'aaa', 'key2': 'value2', 'b': 'bbb'}
&gt;&gt;&gt; type(d), id(d)
(&lt;class '__main__.CustomDict'&gt;, 4323059136)
</code></pre>
<p>Btw, i agree with other contributors that you should also be familiar with <code>collections.abc.Mapping</code> and brethren types. For basic dictionary exploration  UserDict has all the same features and does not require from you to override abstract methods before becoming usable.</p>
</div>
<span class="comment-copy">You can use the <code>collections</code> module's <a href="https://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="nofollow noreferrer">Abstract Base Classes</a> <code>collections.Mapping</code> and <code>collections.MutableMapping</code> to define your own mapping classes that don't inherit from <code>dict</code>.</span>
<span class="comment-copy">I'm not quite understand what does the <code>2.</code> statement mean. Could you explain it with more explicit statements?</span>
<span class="comment-copy">"The need for this class [UserDict] has been largely supplanted by the ability to subclass directly from dict (a feature that became available starting with Python version 2.2)." - <a href="https://docs.python.org/2/library/userdict.html" rel="nofollow noreferrer">docs.python.org/2/library/userdict.html</a></span>
<span class="comment-copy">@Moberg -- That's true.  I find it interesting that it managed to migrate into <code>collections</code> for python3.x... I would have thought they'd just cut it out completely. . .</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/8601389/1256112">stackoverflow.com/a/8601389/1256112</a> that is exactly what OP was looking for.</span>
