<div class="post-text" itemprop="text">
<p>I'm somewhat new to SWIG and C++, so this may be obvious, but I cannot seem to figure it out. I have a C++ collection object (in the MWE, a <code>Pantry</code>), that in C++ is indexed by a <code>std::string</code>, but iterates over the objects. This works in C++ using a ranged-based for loop with the implementations of <code>begin()</code> and <code>end()</code>.</p>
<p>Here's a MWE:</p>
<p><strong>pantry.i</strong></p>
<pre><code>%module(directors="1") my_collection
%include "stdint.i"
%include "std_string.i"
%include "std_shared_ptr.i"
%include "std_vector.i"
%{
#include "my_collection.cpp"
%}
%nodefaultctor;
%shared_ptr(Food);
%include "my_collection.cpp"
</code></pre>
<p><strong>pantry.cpp</strong></p>
<pre><code>#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;sstream&gt;

#ifdef SWIG

%define TO_STRING()
    %extend {
        %feature("python:slot", "tp_repr", functype="reprfunc") to_string;
    }
    std::string to_string()
%enddef

%define SUBSCRIPT(return_type, subscript_type)
    %feature("python:slot", "mp_subscript", functype="binaryfunc") __getitem__;
    %extend {
        return_type __getitem__(subscript_type key) {
            return (*($self))[key];
        };
    };
    return_type operator[](subscript_type key)
%enddef

#else

#define TO_STRING() \
        std::string to_string()

#define SUBSCRIPT(return_type, subscript_type) \
        return_type operator[](subscript_type key)

#endif


class Food {
public:

    std::string name;

    Food(std::string name) {
        this-&gt;name = name;
    };

    TO_STRING() {
        std::ostringstream stream;
        stream &lt;&lt; "&lt;Food " &lt;&lt; this-&gt;name &lt;&lt; "&gt;";
        return stream.str();
    };

};

class Pantry {
private:

    // _foods is not grammatically correct
    std::map&lt;std::string, std::shared_ptr&lt;Food&gt;&gt; _food_map;
    std::vector&lt;std::shared_ptr&lt;Food&gt;&gt; _food_vec;

public:
    Pantry() {
    };

    std::shared_ptr&lt;Food&gt; add(std::string name) {
        auto food = std::shared_ptr&lt;Food&gt;(new Food(name));
        this-&gt;_food_map[food-&gt;name] = food;
        this-&gt;_food_vec.push_back(food); // p.s., how do I prevent making a copy?
        return food;
    };

    SUBSCRIPT(std::shared_ptr&lt;Food&gt;, std::string) {
        return this-&gt;_food_map.at(key);
    };

    TO_STRING() {
        return "&lt;Pantry&gt;";
    };

    std::vector&lt;std::shared_ptr&lt;Food&gt;&gt;::const_iterator begin() {
        return this-&gt;_food_vec.begin();
    };

    std::vector&lt;std::shared_ptr&lt;Food&gt;&gt;::const_iterator end() {
        return this-&gt;_food_vec.end();
    };

    size_t size() {
        return this-&gt;_food_vec.size();
    };

};
</code></pre>
<p>I've also put together a short Python script:</p>
<pre><code>import pantry
pant = mc.Pantry()
print(pant.add('Bacon'))
print(pant.add('Cheese'))
print('subscript[Bacon]: {}'.format(pant['Bacon']))
for food in pant:
    print('iter: ... {}'.format(food))
</code></pre>
<p>Then, depending on whether the <code>-builtin</code> flag is passed to SWIG, I get the error:</p>
<ul>
<li>without <code>-builtin</code>: <code>TypeError: in method 'Pantry___getitem__', argument 2 of type 'std::string'</code> -- <em>which makes sense because I've chosen to index by strings</em></li>
<li>with <code>-builtin</code>: <code>TypeError: 'my_collection.Pantry' object is not iterable</code> -- <em>I think this is caused by SWIG not implicitly creating methods I haven't declared, which is seems correct in this instance</em>.</li>
</ul>
<p>How can I iterate over the collection contents without explicitly calling a method? I realize I could just make the <code>_food_vec</code> public and iterate over that, but my actual code is more complicated and I'd prefer not to do that. Likewise, I could implement some other <code>.iterate()</code> method, but I've already done the work with <code>begin()</code> and <code>end()</code>.</p>
<p><strong>Edit</strong>: What would be a target-language agnostic method that I could implement similar to the macros I made for <code>TO_STRING()</code> and <code>SUBSCRIPT</code>, and what would be the correct template to add to the interface file (something like <code>%template(FoodIterator) std::vector&lt;Food&gt;::iterator;</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have <a href="https://stackoverflow.com/a/24377/1746434">two options</a> to implement iterable interface:</p>
<ol>
<li>Implement <code>__iter__()</code> which returns an object instance having <code>next()</code>.</li>
<li>Implement <code>__getitem__()</code> which accepts <strong><a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">integers or slice objects</a></strong>.</li>
</ol>
<p>I guess this should explain both errors as well as give a clue of how to fix.</p>
</div>
<span class="comment-copy">The iterator returned by <code>__iter__()</code> should also have a <code>__next__()</code> method to make sure it works in both 2 and 3</span>
<span class="comment-copy">I think #2 is the only option, since I've intentionally indexed by strings. I think you are correct that I need to implement a <code>__getitem__()</code> method, but I am struggling to understand how to do that in a target-language agnostic way. I also added an explanation for the errors, or at least my understanding of them.</span>
<span class="comment-copy">There's one more thing. In Python the iterator instance is independent of its container instance, so e.g. when you write the code like <code>for food in Pantry()</code> an instance of <code>Pantry</code> will be created and deleted right after the inner call to <code>Pantry.__iter__()</code>. Thus if your C++ iterator implementation simply holds <code>std::map::iterator</code> then you'll get a segfault. That said I see the only safe and easy way to make your collection iterable in copying the underlying collection and let the SWIG generate the iterator for you.</span>
