<div class="post-text" itemprop="text">
<p>I have the following statement in one of the methods under unit test.</p>
<pre><code>db_employees = self.db._session.query(Employee).filter(Employee.dept ==   
    new_employee.dept).all()
</code></pre>
<p>I want db_employees to get mock list of employees. I tried to achieve this using:</p>
<pre><code> m = MagickMock()
 m.return_value.filter().all().return_value = employees
</code></pre>
<p>where employees is a list of employee object. But this did not work. When I try to print the value of any attribute, it has a mock value. This is how the code looks:</p>
<pre><code>class Database(object):
    def __init__(self, user=None, passwd=None, db="sqlite:////tmp/emp.db"):
        try:
            engine = create_engine(db)
        except Exception:
            raise ValueError("Database '%s' does not exist." % db)

        def on_connect(conn, record):
            conn.execute('pragma foreign_keys=ON')

        if 'sqlite://' in db:
            event.listen(engine, 'connect', on_connect)
        Base.metadata.bind = engine
        DBSession = sessionmaker(bind=engine)
        self._session = DBSession()


class TestEmployee(MyEmployee):
    def setUp(self):
        self.db = emp.database.Database(db=options.connection)
        self.db._session._autoflush()

    @mock.patch.object(session.Session, 'add')     
    @mock.patch.object(session.Session, 'query')  
    def test_update(self, mock_query, mock_add):
        employees = [{'id': 1,
                      'name': 'Pradeep',
                      'department': 'IT',
                      'manager': 'John'}]
        mock_add.side_effect = self.add_side_effect
        mock_query.return_value = self.query_results()  
        self.update_employees(employees)

    def add_side_effect(self, instance, _warn=True):
        // Code to mock add
        // Values will be stored in a dict which will be used to 
        // check with expected value.

    def query_results(self):  
        m = MagicMock()  
        if self.count == 0:  
             m.return_value.filter.return_value.all.return_value = [employee]  
        elif:  
             m.return_value.filter.return_value.all.return_value = [department]  
        return m  
</code></pre>
<p>I have query_results as the method under test calls query twice. First the employee table and next the department table.</p>
<p>How do I mock this chained function call?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should patch <code>query()</code> method of <code>_session</code>'s <code>Database</code> attribute and configure it to give you the right answer. You can do it in a lot of way, but IMHO the cleaner way is to patch <code>DBSession</code>'s <code>query</code> static reference. I don't know from witch module you imported <code>DBSession</code> so I'll patch the local reference.</p>
<p>The other aspect is the mock configuration: we will set <code>query</code>'s return value that in your case become the object that have <code>filter()</code> method.</p>
<pre><code>class TestEmployee(MyEmployee):
    def setUp(self):
        self.db = emp.database.Database(db=options.connection)
        self.db._session._autoflush()
        self.log_add = {}

    @mock.patch.object(__name__.'DBSession.add')     
    @mock.patch.object(__name__.'DBSession.query')  
    def test_update(self, mock_query, mock_add):
        employees = [{'id': 1,
                      'name': 'Pradeep',
                      'department': 'IT',
                      'manager': 'John'}]
        mock_add.side_effect = self.add_side_effect
        mock_query.return_value = self.query_results()  
        self.update_employees(employees)
        .... your test here

    def add_side_effect(self, instance, _warn=True):
        # ... storing data
        self.log_add[...] = [...]

    def query_results(self):  
        m = MagicMock()
        value = "[department]"
        if not self.count:  
             value = "[employee]"  
        m.filter.return_value.all.return_value = value 
        return m
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>m = MagickMock()
m.session.query().filter().all.return_value = employees
</code></pre>
<p><a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer">https://docs.python.org/3/library/unittest.mock.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I found a solution to a similar problem where I needed to mock out a nested set of filtering calls.</p>
<p>Given code under test similar to the following:</p>
<pre><code>interesting_cats = (session.query(Cats)
                           .filter(Cat.fur_type == 'furry')
                           .filter(Cat.voice == 'meowrific')
                           .filter(Cat.color == 'orande')
                           .all())
</code></pre>
<p>You can setup mocks like the following:</p>
<pre><code>mock_session_response = MagicMock()
# This is the magic - create a mock loop
mock_session_response.filter.return_value = mock_session_response
# We can exit the loop with a call to 'all'
mock_session_response.all.return_value = provided_cats

mock_session = MagicMock(spec=Session)
mock_session.query.return_value = mock_session_response
</code></pre>
</div>
<span class="comment-copy">First of all replace <code>m.return_value.filter...</code> by <code>m.filter...</code> because <code>m</code> is already set as <code>query</code> return value. And the add to your question that <code>mock_query.mock_calls</code> is empty. As far as I can understand you are patching the wrong object.</span>
<span class="comment-copy">Now try to use <code>@mock.patch(__name__ + '.DBSession.query')</code> to patch query.</span>
<span class="comment-copy">It worked. Changed mock_query.return_value to mock_query.side_effect = self.query_results. Now I am able to get the objects as expected. I am accepting your answer, as it helped me to resolve the chained function call.</span>
<span class="comment-copy">No need to use <code>MagicMock</code> here as no special methods are being called.</span>
