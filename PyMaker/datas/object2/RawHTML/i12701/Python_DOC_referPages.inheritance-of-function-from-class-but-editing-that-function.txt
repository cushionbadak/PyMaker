<div class="post-text" itemprop="text">
<p>I'm using Python and I have two classes. I want to import a function for a class but with the ability of adding things to that function.</p>
<pre><code>class Main(self):
    def __init__(self):
        thingstodo()
    def function(self, keypressed):
        #LOTS OF CODE
        keyname = keypressed
        if keyname = "Escape":
            dosomething()

class Main2(Main):
   def __init(self):
      Main.__init__(self)
   def function(self, keypressed):
      Main.function(self, keypressed)
      if keyname = "control":
          dootherthing()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Basic principles</h2>
<ol>
<li><p>You cannot access local variables from one function (or method) in another function. This is by design. </p></li>
<li><p>This <code>class Main(self):</code> is wrong. In Python 3 do <code>class Main:</code>. While using <code>self</code> as the name of the first argument in method is a <strong>strong</strong> convention, <code>self</code> is just an ordinary name not a reserved keyword or built-in.</p></li>
<li><p>There are several problems here:</p>
<pre><code>def __init(self):
    Main.__init__(self)
</code></pre>
<p>a. The method name needs to <code>__init__()</code> not <code>__init</code>.</p>
<p>b. Don't hardwire the name of the parent class with <code>Main.__init__(self)</code> use <code>super().__init__()</code>.</p>
<p>c. If you don't do anything extra in the <code>__init__()</code> of <code>Main2</code>, than you don't need to implement the <code>__init__()</code> at all.</p></li>
</ol>
<h2>Possible solution</h2>
<p>For your problem, using a dictionary with the key press names as keys and the functions for the actions as values seems useful.</p>
<p>First define a few small helper functions: </p>
<pre><code>def thingstodo():
    print('thingstodo')

def dosomething():
    print('something')

def dootherthing():
    print('dootherthing')
</code></pre>
<p>Now your main class:</p>
<pre><code>class KeyAction: # Python 3

    def __init__(self):
        thingstodo()
        self.key_actions = {'Escape': dosomething}

    def handel_key_press(self, keypressed):
        #LOTS OF CODE
        keyname = keypressed
        func = self.key_actions.get(keyname)
        if func is not None:
            func()
</code></pre>
<p>Names are important, therefore I use <code>KeyAction</code> instead of <code>Main</code>.
This line <code>self.key_actions = {'Escape': dosomething}</code> is the core of this solution. Here <code>self.key_actions</code> is a dictionary that maps names of key press events to functions. Note <code>dosomething</code> without the <code>()</code> because I put the function object into the dictionary rather than calling this function.</p>
<p>Calling this function is a bit different:</p>
<pre><code>func = self.key_actions.get(keyname)
if func is not None:
    func()
</code></pre>
<p>I use the <code>get()</code> method of the dictionary. This returns the value for the key if the key is in it and <code>None</code> if not. Now <code>func</code> holds either a reference to the function <code>dosomething</code> if the key was <code>Escape</code> or <code>None</code>. If it is a function I call it with <code>func()</code>.</p>
<p>An alternative here could be a <code>try</code>-<code>except</code>: </p>
<pre><code>def handel_key_press(self, keypressed):
    #LOTS OF CODE
    keyname = keypressed
    try:
        self.key_actions[keyname]()
    except KeyError:
        pass
</code></pre>
<p>Now, in your child class, you only need to add another key-value pair to <code>self.key_actions</code> to extend its functionality:</p>
<pre><code>class ExtendedKeyAction(KeyAction):

    def __init__(self):
        super().__init__()
        self.key_actions['control'] = dootherthing
</code></pre>
<p>Make two instances and test your code:</p>
<pre><code>key_action = KeyAction()
key_action.handel_key_press('Escape')
key_action.handel_key_press('undefined')
extended_key_action = ExtendedKeyAction()
extended_key_action.handel_key_press('Escape')
extended_key_action.handel_key_press('control')
extended_key_action.handel_key_press('undefined')
</code></pre>
<p>prints:</p>
<pre><code>thingstodo
something
thingstodo
something
dootherthing
</code></pre>
</div>
<span class="comment-copy">If I understand what you want to do ("import" isn't the word you want to use; inherit, as per your title, is better), you're on the right track. Two things 1/ use <code>super().function(keypressed)</code> instead of calling it through the base class; ditto for <code>__init__</code>, 2/ if the base function returns something, make sure you capture that.</span>
<span class="comment-copy">Note: Python's tutorial is lacking info on this point, but the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">documentation on <code>super()</code></a> has a decent example of how to do this. The end of that section also has a link to a further read on super, inheritance and methods: <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer">rhettinger.wordpress.com/2011/05/26/super-considered-super</a></span>
<span class="comment-copy">Last point: <code>class Main(self):</code> is incorrect. In Python 3, it is simply <code>class Main:</code>. I'm curious where you picked that up.</span>
<span class="comment-copy">It helps to have a program that runs (e.g, instead of calling <code>thingstodo</code>, and having to define that to get the code to work, do <code>print("thingstodo")</code>) so the example shows the code being executed.</span>
<span class="comment-copy">When your code is cleaned up, it works. What are you having problems with? In your case, you might want to call the parent function only after checking for "control", but otherwise its workable.</span>
<span class="comment-copy">Thanks, now it works well</span>
