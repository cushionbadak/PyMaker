<div class="post-text" itemprop="text">
<p>I want to bind some QWidgets to the attributes of an existing class in <strong>Python 3</strong> so that any changes made through the GUI are applied to the underlying data objects in a clean and simple fashion.</p>
<p>My existing class looks like this (simplified):</p>
<pre><code>class Player:

    def __init__(self):
        self._health = 100

    @property
    def health(self):
        return self._health

    @health.setter
    def health(self, value):
        self._health = value
</code></pre>
<p><strong>PyQt5</strong> allows connecting Qt signals to any method, so I can easily achieve my goal by calling <code>someWidget.valueChanged.connect(player.someSetterMethod)</code>.</p>
<p>However, I use <code>@property</code> and thus, the setter name is identical to the attribute name. When I try using <code>player.health</code>, it is interpreted as an integer (as expected, but obviously not what I want here).</p>
<p>I am aware that I could define getter/setter methods with custom names and then use <code>property()</code> instead of <code>@property</code>, but I am hoping there is a way of obtaining the reference to the setter method so that I can pass it to <code>connect()</code>.</p>
<p>Thank you!</p>
<p>Edit: I doubt it is relevant to this question, but perhaps I should add that in the next step, I want to report changes that are not applied as received back to the GUI.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to use a <code>lambda</code>, because you need a <em>bound property</em> to get the right context:</p>
<pre><code>someWidget.valueChanged.connect(lambda v: setattr(player, 'health', v))
</code></pre>
<p>Property objects do have <code>.fget</code> and <code>.fset</code> attributes, and the property object itself can be accessed on the class:</p>
<pre><code>Player.health.fset
Player.health.fget
</code></pre>
<p>but these give you access to the original <em>unbound</em> function objects, which require the <code>self</code> parameter still.</p>
<p>You could use those functions too, but then you'd have to bind them to your instance first:</p>
<pre><code>someWidget.valueChanged.connect(Player.health.fset.__get__(player))
</code></pre>
<p>The <a href="https://docs.python.org/2/reference/datamodel.html#object.__get__" rel="nofollow"><code>__get__</code> method</a> on the function (which is a <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow"><em>descriptor</em></a>) to provide you with a bound method which passes in the <code>self</code> argument for you (the <code>player</code> instance object in this case).</p>
</div>
<div class="post-text" itemprop="text">
<p>As seen here <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow">https://docs.python.org/3/library/functions.html#property</a></p>
<blockquote>
<p>The returned property object also has the attributes fget, fset, and fdel corresponding to the constructor arguments</p>
</blockquote>
<p>So you can access the getter, setter and deleter via these attributes.
In your example <code>Player.health.fset(some_instance, new_health)</code></p>
<p>In order to connect that to your signal you must bind the instance to the setter. This can be done with <code>functools.partial</code></p>
<pre><code>from functools import partial

someWidget.valueChanged.connect(partial(Player.health.fset, player))
</code></pre>
</div>
<span class="comment-copy">While the lambda statement doesn't work for me (<code>SyntaxError: lambda cannot contain assignment</code>), fset and fget are exactly what I was missing. Thank you very much!</span>
<span class="comment-copy">Oops, that's the eggnog speaking. Lambda corrected for you.</span>
<span class="comment-copy">Thank you very much for pointing me towards fset and fget! I somehow missed these while scanning the documentation. I assume that using <b>get</b> instead of the functools module is the cleaner solution, so I am marking the other answer.</span>
