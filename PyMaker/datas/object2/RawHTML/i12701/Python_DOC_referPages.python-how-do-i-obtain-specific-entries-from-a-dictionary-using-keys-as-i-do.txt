<div class="post-text" itemprop="text">
<p>With an array <code>x=['A','B','C']</code>, I can obtain several elements from it by just stating the index: eg.<code>print(x[0:2])</code> yields <code>['A','B']</code>.</p>
<p>Now for a similar (<strong>ordered</strong>) dictionary <code>x={1:'A', 2:'B', 3:'C'}</code>, how would I obtain 'A' and 'B' in the same way, by referencing the keys 1 and 2? Trying a method similar to the array above gives me an error:</p>
<pre><code>TypeError: unhashable type: 'slice'
</code></pre>
<p>Note that the key tied to the entries are important, so it won't help converting the dictionary into a list.</p>
<p>Also, I plan on doing this to a lot of entries (&gt;100), so calling each individual one won't be useful. My real program will involve numbered keys starting from 100 and calling keys 200 to 300, for example.</p>
</div>
<div class="post-text" itemprop="text">
<p>The way to retrieve a value from a dictionary is <code>dict_name[key]</code>: </p>
<pre><code>print x[1], x[2]
&gt;&gt; 'A', 'B'
</code></pre>
<p>Note that if the key doesn't exist this will raise a <code>KeyError</code>. 
A way around it is to use <code>get(key, default_value)</code>:</p>
<pre><code>print x[9]
&gt;&gt; KeyError
print x.get(9, None)
&gt;&gt; None
</code></pre>
<p>You can use a <code>for</code> loop in order to check multiple keys:</p>
<pre><code>for potential_key in range(10):
    print x[potential_key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>operator.itemgetter</code></a>:</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; x = {1:'A', 2:'B', 3:'C'}
&gt;&gt;&gt; itemgetter(1, 2)(x)
('A', 'B')

&gt;&gt;&gt; get_1_2 = itemgetter(1, 2)  # Alternative: Save the result function
&gt;&gt;&gt; get_1_2(x)                  #              call it later
('A', 'B')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can map <code>get()</code> to the object that describes which keys you want, such as <code>range()</code> (which has syntax and results similar to that of slicing):</p>
<pre><code>&gt;&gt;&gt; x={1:'A', 2:'B', 3:'C'}
&gt;&gt;&gt; print(*map(x.get, range(1,3)))
A B
</code></pre>
<p>Or a generator expression instead of <code>map()</code>:</p>
<pre><code>&gt;&gt;&gt; x={1:'A', 2:'B', 3:'C'}
&gt;&gt;&gt; print(*(x.get(item) for item in range(1,3)))
A B
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><code>&gt;&gt; list(x.values())[0:2]</code> </p>
</blockquote>
<p>This gives the output: ['A', 'B']</p>
<p>Since you mentioned 'ordered' dictionary, this could be a possible solution but without referencing the keys.</p>
</div>
<span class="comment-copy">If your dict will have numbered keys on your real program, then just use <code>dict.get(number)</code> in a loop with range 200 to 300.</span>
<span class="comment-copy">Thanks, but I plan on doing this to a lot of entries (&gt;100), so calling each individual one won't be useful. (sorry for not clarifying this)</span>
<span class="comment-copy">@teachmyselfhowtocode Either way you will have to call each key individually or use a <code>for</code> loop. There is nothing resembling slices with dictionaries since dictionaries have no sense of order.</span>
<span class="comment-copy">Thanks, I am actually using <code>OrderedDict</code>, which places entries in order of assignment. (for loop works fine as well.)</span>
<span class="comment-copy">@teachmyselfhowtocode, You can combine <code>operator.itemgetter</code> with <code>range</code>: <code>itemgetter(*range(20, 100))</code></span>
<span class="comment-copy">Is <code>itemgetter</code> a pythonic term?</span>
<span class="comment-copy">to clarify, <code>itemgetter(1, 2)</code> calls <code>__init__</code> and then <code>(x)</code> invokes <code>__call__</code>?</span>
<span class="comment-copy">@timgeb, You're right.</span>
<span class="comment-copy">@teachmyselfhowtocode, yes itemgetter is pythonic and the most efficient method here.</span>
