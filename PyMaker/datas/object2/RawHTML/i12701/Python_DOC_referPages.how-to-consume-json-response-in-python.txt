<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6386308/http-requests-and-json-parsing-in-python">HTTP requests and JSON parsing in Python</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>I am creating a Django web app.
There is a function which creates a JSON response like this:</p>
<pre><code>def rest_get(request, token):
    details = Links.get_url(Links, token)
    result={}
    if len(details)&gt;0:
            result['status'] = 200
            result['status_message'] = "OK"
            result['url'] = details[0].url
    else:
            result['status'] = 404
            result['status_message'] = "Not Found"
            result['url'] = None

    return JsonResponse(result)</code></pre>
<p>And I get the response in the web browser like this:</p>
<pre><code>{"status": 200, "url": "http://www.bing.com", "status_message": "OK"}
</code></pre>
<p>Now from another function I want to consume that response and extract the data out of it. How do I do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>json</code> library in python to do your job. for example :</p>
<pre><code>json_string = '{"first_name": "tom", "last_name":"harry"}'
import json
parsed_json = json.loads(json_string)
print(parsed_json['first_name'])
"tom" 
</code></pre>
<p>Since you have created a web app. I am assuming you have exposed a URL from which you can get you JSON response, for example <a href="http://jsonplaceholder.typicode.com/posts/1" rel="nofollow">http://jsonplaceholder.typicode.com/posts/1</a>.</p>
<pre><code>import urllib2
import json
data = urllib2.urlopen("http://jsonplaceholder.typicode.com/posts/1").read()
parsed_json = json.loads(data)
</code></pre>
<p>The <code>urlopen</code> function sends a <code>HTTP GET</code> request at the given URL. <code>parsed_json</code> is a variable of the type map and you can extract the required data from it.</p>
<pre><code>print parsed_json['userId']
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer I want to suggest is a little different. In your scenario - where one function needs to be accessed from both server and client end, I would suggest provide some extra parameter and change the output based on that. This reduces overheads and unnecessary conversions. </p>
<p>For example, if you pass in an extra parameter and change the result like this, you don't need JSON parsing on python. Of course there are solutions to do that, <strong>but why need converting to <code>json</code> and then parsing back when you can avoid that totally</strong>?</p>
<pre><code>def rest_get(request, token, return_json=True):

    details = Links.get_url(Links, token)
    result={}
    if len(details)&gt;0:
            result['status'] = 200
            result['status_message'] = "OK"
            result['url'] = details[0].url
    else:
            result['status'] = 404
            result['status_message'] = "Not Found"
            result['url'] = None
    if return_json: # this is web response, so by default return_json = True
        return JsonResponse(result)
    return result
</code></pre>
<p>Then in your python code call like this - </p>
<pre><code>rest_get(request, token, return_json=False): # we are passing False, so the return type is dictionary and we can use it right away.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>literal_eval</code> on the json string to parse it as dict. 
</p>
<pre><code>from ast import literal_eval
#data recieved 
responseText = '{"status": 200, "url": "http://www.bing.com", "status_message": "OK"}'

#dict response 
response = literal_eval(responseText)

print(response)
# -&gt; {"status": 200, "url": "http://www.bing.com", "status_message": "OK"}

print(response['url'])
# -&gt; http://www.bing.com
</code></pre>
<p><code>literal_eval</code> is part of the <code>ast</code> (<a href="https://docs.python.org/2/library/ast.html" rel="nofollow">Abstract Syntax Trees</a>) module. You can use it to:</p>
<blockquote>
<p>Safely evaluate an expression node or a Unicode or Latin-1 encoded
  string containing a Python literal or container display. The string or
  node provided may only consist of the following Python literal
  structures: strings, numbers, tuples, lists, dicts, booleans, and
  None.</p>
</blockquote>
</div>
<span class="comment-copy">Use the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code></a> module?</span>
<span class="comment-copy">You  want to consume the response in the python app or in the web browser via Ajax or something?</span>
<span class="comment-copy">@RobertMoskal In the python app.</span>
<span class="comment-copy">See my duplicate note.</span>
<span class="comment-copy">@anirban: it sounds overly complicated to call this view from the Python function, better make a separate function that creates the dict, then call that from both this view and your other code.</span>
<span class="comment-copy">That is one nice workaround. Thanks!</span>
