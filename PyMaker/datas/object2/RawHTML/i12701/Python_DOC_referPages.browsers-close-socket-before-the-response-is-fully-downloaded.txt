<div class="post-text" itemprop="text">
<p>I have a simple Python server that uses <a href="https://docs.python.org/3/library/http.server.html#module-http.server" rel="nofollow noreferrer"><code>http.server</code></a>. The goal is not to show the video in a html page, or to download the video file, but to display the video in the browser directly. This is what I have so far:</p>
<pre><code>import http.server

class SuperHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        path = self.path
        encodedFilePath = 'file.mp4'

        with open(encodedFilePath, 'rb') as videoFile:
            self.send_response(200)
            self.send_header('Content-type', 'video/mp4')
            self.end_headers()
            self.wfile.write(videoFile.read())
            print('File sent: ' + videoFile.name)

server_address = ('', 8000)
handler_class = SuperHandler
httpd = http.server.HTTPServer(server_address, handler_class)
httpd.serve_forever()
</code></pre>
<p>The problem that I have is that the response doesn't contain the full video. <code>file.mp4</code> is 50MB, but when I look in the network tab of either Chrome or Firefox, it says that the response is only 1MB. Is there a reason why the full file isn't transferred? Do I need to add some sort of HTTP header to make this work?</p>
<p><strong>EDIT:</strong></p>
<p>This is my code now:</p>
<pre><code>server_address = ('', 8000)
handler_class = http.server.SimpleHTTPRequestHandler
httpd = http.server.HTTPServer(server_address, handler_class)

httpd.serve_forever()
</code></pre>
<p>I am now using the default SimpleHTTPRequestHandler's <code>do_GET</code>, but it's still not working (although the response is now 40MB/30MB instead of 1MB).</p>
<p>When I request <code>file.mp4</code> on Chrome, the socket connexion is closed after ~7 seconds (~5 seconds on Firefox), which makes the script throw a <code>BrokenPipeError: [Errno 32] Broken pipe</code>, <a href="https://stackoverflow.com/questions/11866792/how-to-prevent-errno-32-broken-pipe">because the server is still trying to write the rest of the video file on a closed socket</a>.</p>
<p>So my question is: how can I make the browser download the full response before it closes the socket?</p>
<p><strong>Additional info</strong></p>
<p>HTTP Response headers sent to the client:</p>
<pre><code>HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.5.0
Date: Mon, 28 Dec 2015 02:36:39 GMT
Content-type: video/mp4
Content-Length: 53038876
Last-Modified: Fri, 25 Dec 2015 02:09:52 GMT
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To stream videos you should support at least <a href="https://en.wikipedia.org/wiki/Byte_serving" rel="nofollow">range requests</a> and <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" rel="nofollow">transfer-encoding: chunked</a></p>
<p>As far as I can see <code>http.server</code> does not support that directly. You can of course implement that on top.</p>
<p>Alternatively use a simple framework, e.g. <code>bottle</code> (one file, already supports both) or <code>cherrypy</code> (more solid, multi-threaded, etc)</p>
<p>You can also get by without any Python code, e.g. if you use <code>nginx</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Fundamentally, @qarma is right. To stream videos, you need to use a library or framework that supports, at the very least, <code>Range:</code> headers.</p>
<p>But, you are not /trying/ to stream video. The browser is doing it for you. When you return the <code>video/mp4</code> content type, the browser, which knows how to stream video itself, immediately switches to a streaming mode. It stops the file download it had going (the source of your pipe errors), and restarts with a <code>Range:</code> header. It leverages existing media player code within the browser to do so. Since the <code>SimpleHTTPServer</code> class doesn't support the <code>Range:</code> header, it doesn't handle the response properly.</p>
<p>If you want to prevent this streaming behavior and force the browser to download the file without playing it, then return the <code>Content-Disposition</code> header forcing it to treat the video file as a downloaded file rather than as a piece of content to be rendered.</p>
<p>Here's some code based on your initial question that does what you want:</p>
<pre><code>import http.server

class SuperHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        path = self.path
        encodedFilePath = 'file.mp4'

        with open(encodedFilePath, 'rb') as videoFile:
            self.send_response(200)
            self.send_header('Content-type', 'video/mp4')
            self.send_header('Content-Disposition', 'attachment; filename=' + encodedFilePath)
            self.end_headers()
            self.copyfile(videoFile, self.wfile)

server_address = ('', 8000)
handler_class = SuperHandler
httpd = http.server.HTTPServer(server_address, handler_class)
httpd.serve_forever()
</code></pre>
<p>Theoretically, you also send back <code>Accept-Ranges: none</code>, but Chrome, at least, seems to ignore that.</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns out that the video file I was using was corrupted (maybe it had some dropped frames or something like that). I tested with multiple other .mp4 and it worked like a charm.</p>
<p>All you really need to play a video file (or more accurately stream a video file as pointed by @hrunting) as far as http headers for the response are concerned is:</p>
<pre><code>HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.5.0
Date: Sat, 02 Jan 2016 02:45:34 GMT
Content-type: video/mp4
Content-Length: 33455269
Last-Modified: Sat, 02 Jan 2016 02:45:27 GMT
</code></pre>
<p>I think even the <code>Server</code>, <code>Date</code> and <code>Last-Modified</code> headers aren't mandatory (they are sent automatically by <a href="https://docs.python.org/3/library/http.server.html#http.server.SimpleHTTPRequestHandler" rel="nofollow"><code>SimpleHTTPRequestHandler</code></a>).</p>
<p>As pointed by @qarma and @hrunting, if you want to enable the user to jump to a specific time in video, you should support the <code>Range</code> header. It's simply a good idea to support the <code>Range</code> header as it is sent by default by Chrome.</p>
</div>
<span class="comment-copy">Why do you want to use <code>http.server</code> to serve static files? You could run: <code>python3 -mhttp.server</code> to serve files in a directory (assuming you use it as a quick-n-dirty hack).</span>
<span class="comment-copy">Serving static files is just a part of what I want to do, so I need to code it myself.</span>
<span class="comment-copy">If you are determined to use <code>http.server</code> here, look at at how <code>http.server.SimpleHTTPRequestHandler</code> is implemented (<code>copyfile()</code> reads the file from disk and sends it to the user).</span>
<span class="comment-copy">Where exactly can I find the implementation code of SimpleHTTPRequestHandler?</span>
<span class="comment-copy">The official mercurial repository is at <a href="https://hg.python.org/cpython/file/tip/Lib/http/server.py" rel="nofollow noreferrer">http://hg.python.org/</a></span>
<span class="comment-copy">But is it streaming that I am attempting to do? Am I not trying to simply serve a video file? Maybe it's the same thing.</span>
<span class="comment-copy">Also why do the browsers download for only 5/7 seconds?</span>
<span class="comment-copy">I don't see why I would need to support range requests, as I want to transfer the entire file and I also don't see why I would need to support transfer-encoding: chunked, as the server already provides a Content-Length.</span>
<span class="comment-copy">@maximedupre capture network traffic against a reference server and go from there. Range makes sense if user may jump to a specific time in video. Broken pipe suggests that browsers wants less data than is sent, quite possible if you ignored range header.</span>
<span class="comment-copy"><a href="http://ronallo.com/blog/html5-video-everything-i-needed-to-know/" rel="nofollow noreferrer">ronallo.com/blog/html5-video-everything-i-needed-to-know</a> and also "buffering" section of <a href="http://www.chromium.org/audio-video" rel="nofollow noreferrer">chromium.org/audio-video</a></span>
<span class="comment-copy">I still don't see why I would need to support the <code>Range</code> headers. I always want the full video file to be transferred, not just part of the video. Maybe you are saying that because as @qarma said, "the user may jump to a specific time in video", but I don't think it has anything to do with my problem (although thanks for the tip). When you say: "It stops the file download it had going (the source of your pipe errors), and restarts with a Range: header", you are right, but it only occurs in Chrome (not Firefox). And no, I don't want to download the video file, I want to play it in the browser.</span>
<span class="comment-copy">I have actually found the solution to my problem, I will post it as an answer, but thank you for the help.</span>
