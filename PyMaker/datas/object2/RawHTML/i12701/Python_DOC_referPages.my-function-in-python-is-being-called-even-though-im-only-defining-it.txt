<div class="post-text" itemprop="text">
<p>I have a function called attack:</p>
<pre><code>def attack(name,minmultiplier,maxmultiplier,critchance,attacker,attackee):
    print(attacker[0],"used",name)
    multiplier=random.randint(minmultiplier,maxmultiplier)
    crit=random.randint(critchance,100)
    if crit==100 and ((attacker[2]*multiplier*2)-attackee[3]) &gt; 0:
        attackee[1]=attackee[1]-((attacker[2]*multiplier*2)-attackee[3])
    elif ((attacker[2]*multiplier)-attackee[3]) &gt; 0:
        attackee[1]=attackee[1]-((attacker[2]*multiplier)-attackee[3])
    else:
        print("You fail to hit",attackee[0])
    print(attackee[0],"'s health after",attacker[0],"'s attack is",attackee[1])
</code></pre>
<p>And I am making a few actual attacks for bosses and the player here:</p>
<pre><code>boss=["Greed",1000,10,10,1]
slashp=attack("slash",1,2,5,player,boss)
slashb=attack("slash",1,2,5,boss,player)
kick=attack("kick",1,1,1,player,boss)
aiattacklist=[slashb]
attacknamelist=["slash","kick"]
attackfunclist=[slashp,kick]
</code></pre>
<p>Even though I am only saving these versions as variables, they are still being called:</p>
<pre><code>template used slash
You fail to hit Greed
Greed 's health after template 's attack is 1000
Greed used slash
template 's health after Greed 's attack is 58
template used kick
You fail to hit Greed
Greed 's health after template 's attack is 1000
</code></pre>
<p>Is this something that python always does, or am I doing something wrong, because I don't want these to be called (sorry if I didn't use the correct terminology, I am kind of new)</p>
</div>
<div class="post-text" itemprop="text">
<p>You are calling the functions here:</p>
<pre><code>slashp=attack("slash",1,2,5,player,boss)
slashb=attack("slash",1,2,5,boss,player)
kick=attack("kick",1,1,1,player,boss)
</code></pre>
<p>You are storing the return value there, not the function.</p>
<p>If you wanted to store some predefined arguments, either use another function to wrap the call, use a lambda (which is basically a simplified form of creating a function), or use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial()</code></a> to predefine some arguments and store a new callable for those.</p>
<p>Using a lambda would look like this:</p>
<pre><code>shlashp = lambda player, boss: attack("slash", 1, 2, 5, player, boss)
shlashb = lambda player, boss: attack("slash", 1, 2, 5, boss, player)
kick = lambda player, boss: attack("kick", 1, 1, 1, player, boss)
</code></pre>
<p>This assumes that you still want to specify the player and the boss <em>later on</em> when calling these functions. You'd call <code>kick(player, boss)</code>, for example.</p>
<p>Using <code>functools.partial()</code> is not as suitable here, because you are swapping the <code>boss</code> and <code>player</code> arguments around; you'd just define a <code>slash</code> variable and pass in the <code>boss</code> and the <code>player</code> arguments in the right order:</p>
<pre><code>from functools import partial

slash = partial(attack, 'slash', 1, 2, 5)
kick = partial(attack, 'kick', 1, 1, 1)
</code></pre>
<p>Calling either <code>slash</code> or <code>kick</code> would <em>add on</em> any extra arguments, so <code>slash(player, boss)</code> calls the function with those two arguments added on to the ones you already defined.</p>
<p>All of this makes the assumption you want to be able to manage multiple players and bosses. If your <code>player</code> and <code>boss</code> variables are globals (perhaps there is only ever <em>one</em> player and <em>one</em> boss to fight), then you'd just pass those in when defining the <code>lambda</code> or the <code>partial</code> and you don't pass in extra arguments. For example:</p>
<pre><code>slashp = partial(attack, 'slash', 1, 2, 5, player, boss)
slashb = partial(attack, 'slash', 1, 2, 5, boss, player)
kick = partial(attack, 'kick', 1, 1, 1, player, boss)
</code></pre>
<p>and to have the player kick the boss, you'd just call <code>kick()</code>.</p>
<p>The difference between a <code>partial</code> object and a <code>lambda</code> is that you can <em>introspect</em> the <code>partial</code> object; you can easily see what arguments  you defined to be always pass in:</p>
<pre><code>&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; def attack(*args): return args
...
&gt;&gt;&gt; demo = partial(attack, 'kick', 1, 2, 5)
&gt;&gt;&gt; demo.args
('kick', 1, 2, 5)
&gt;&gt;&gt; demo()
('kick', 1, 2, 5)
&gt;&gt;&gt; demo('player1', 'boss2')
('kick', 1, 2, 5, 'player1', 'boss2')
</code></pre>
<p>A <code>partial</code> object can not be used as a method on a class, a function object can. Use a <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow"><code>functools.partialmethod()</code> object</a> if you need to use this feature on a class.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> is for.</p>
<blockquote>
<p>Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords.</p>
</blockquote>
<p><a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow">https://docs.python.org/2/library/functools.html#functools.partial</a></p>
<p>Sample usage:</p>
<pre><code>import functools
slashp = functools.partial("slash",1,2,5,player,boss)
slashp()  # actual call 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Wrapp your funtion into a lambda:</p>
<pre><code>slashp=lambda : attack("slash",1,2,5,player,boss)
</code></pre>
<p>or use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">partial</a>:</p>
<pre><code>slashp=partial(attack, name="slash",minmultiplier=1,maxmultiplier=2,critchance=5,attacker=player,attackee=boss)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Classes would seem a better fit, and provide more flexibility in the future</p>
<pre><code>class AttackType(object):
    def __init__(name, minmult, maxmult, crit):
        self.name = name
        self.minmult = minmult
        self.maxmult = maxmult
        self.crit = crit
    def attack(self, attackee, attacker):
        // all your logic here

kick = AttackType("kick", 1, 1, 1)
##... later
kick(player, boss)
</code></pre>
</div>
<span class="comment-copy">If you need any other code, just ask</span>
<span class="comment-copy">You <b>are</b> calling the functions, and storing the results of those calls. What did you expect to happen instead?</span>
<span class="comment-copy">You call them in the assignment...</span>
<span class="comment-copy">I wanted to save the versions of the function attack, as those variables</span>
<span class="comment-copy">You may have <code>function</code> and <code>class</code> a little confused - <code>def attack</code> defines a function, which is called wherever you write <code>slashp=attack(..)</code> or whatever. A <code>class</code> on the other hand, could save off some variable, and then the <code>AttackType</code> class could have an <code>attack</code> method</span>
<span class="comment-copy">boss is already declared, I think palyer is declared too</span>
<span class="comment-copy">@DanielSanchez: we don't know if that is a beginners mistake or intentional. We don't know if they are globals or not.</span>
<span class="comment-copy">well, thats true, we lack information.</span>
<span class="comment-copy">Thank you very much</span>
<span class="comment-copy">This isn't recommended practice, though. Define a function named <code>slashp</code> that calls <code>attack</code>, since that's what <code>slashp</code> is.</span>
<span class="comment-copy">@chepner, it is actually a good practice, you are just wrapping your function to take predefined values</span>
<span class="comment-copy">@DanielSanchez - based on how the OP wants to use this, they need classes instead; <code>lambda</code>, while it would work, has poor readability, especially since it will come up again and again (for all the different attack types, etc)</span>
<span class="comment-copy">@dwanderson, you dont call a lamba, but bind it to a name so the readability is ok in my opinion.</span>
<span class="comment-copy">I think this is pretty too much, you are creating a whole object for calling a method, at least implement the <b>call</b> method.</span>
