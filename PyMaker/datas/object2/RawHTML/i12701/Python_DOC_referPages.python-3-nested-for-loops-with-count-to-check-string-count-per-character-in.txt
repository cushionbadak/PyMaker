<div class="post-text" itemprop="text">
<p>Here I'm asking for a word, and generating a list of all combinations for the letters in <code>word</code> variable, in theory (in my head) the for loop's <code>if</code> statement <i>should</i> work.</p>
<pre><code>from itertools import product
from string import ascii_lowercase

word = input("Enter a word, preferably short")


PossibleWithWordLetters = [''.join(i) for i in product(word, repeat = len(word))]

for a in PossibleWithWordLetters:
    if word.count(word[i]) [for i in range(len(word))] == 1 and a in PossibleWithWordLetters:
        print(a)
</code></pre>
<p>The aim of the program is to list all valid anagrams from a word inputted - and checked where it only contains one of each of the letters in <code>word</code> - then i'll check this against a word file of real words - which I haven't got round to yet.</p>
<p>Any help is appreciated on getting the <code>for</code> loop to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>To be honest I didn't quite understood your question, but it looks like you are trying to generate anagrams of a word, which are <em>permutations</em> of <em>characters</em>.
There is no need to count the letters, as python can generate the permutations directly:</p>
<pre><code>from itertools import permutations
from string import ascii_lowercase

word = input("Enter a word, preferably short: ")

PossibleWithWordLetters = [''.join(i) for i in permutations(word)]

for a in PossibleWithWordLetters:
    print(a)
</code></pre>
<p>If you want to check if two worstrings are anagrams of each other, here are some examples:</p>
<pre><code># using string.count
def check_anagram1(a, b):
    return all(a.count(c) == b.count(c) for c in set(a) | set(b))

# using collections.Counter
from collections import Counter
def check_anagram2(a, b):
    return Counter(a) == Counter(b)
</code></pre>
</div>
<span class="comment-copy">Don't generate all permutations of the word if you are going to match it against a dictionary. There are much less words in any dictionary than permutations of a 11-12 letter word. Instead, go through you rictionary and check if any word is an anagram of yours</span>
<span class="comment-copy">I am unable to understand the title (what is this "with to"?).  Can you fix it?</span>
<span class="comment-copy">@adl - yes sorry - missed out a word.</span>
<span class="comment-copy">@hege_hegedus ok that's a good way to think about it, I will try this later today.</span>
<span class="comment-copy">Think more about what data you actually <i>need</i>, and how you would store and retrieve it.  If you're allowed to use the standard library, look at the things <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> can do.  If that's not allowed, you can do the same things with a dictionary and judicious use of <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a>.</span>
<span class="comment-copy">yeah - sorry I didn't make it very clear - creating the permutations is ok - that looks like a simpler way to do the same thing, it's just then checking to see if <code>word</code> letters can be reordered to make another or any word in <code>PossibleWithWordLetters</code> - which is what I tried to do with the <code>for</code> loop.</span>
<span class="comment-copy">@RPiPasswordGen With permutations you don't need that check. But just in case, I updated the answer, so you have functions to check if two strings are anagrams</span>
