<div class="post-text" itemprop="text">
<p>I have a DataFrame with two columns, A and B, all integers. In A they are repeated. I group by them, then sort by them, then I want to apply a rolling window over A to get the elements in column B grouped. How they are grouped is not crucial, anything will do, then I have to do a number of things over them, so I will most likely need to convert that collection into something else (a pandas.Series would probably be the best, concatenating groups in each window).</p>
<p>I think I have to start with something like this:</p>
<pre><code>df.groupby('A').rolling(w)

</code></pre>
<p>but then how to get the elements?</p>
<p>I have tried to use apply, but I get only one window as a numpy array, not a window over groups.</p>
<p>Example:</p>
<pre><code>In [1]: import pandas as pd
   ...: import numpy as np
   ...: import random
   ...: 
   ...: random.seed(2)
   ...: 
   ...: indexes = [i for i in range(1,100) for _ in range(10)]
   ...: dfi = pd.DataFrame({'A': indexes, 'B': [random.randint(1,99) for e in indexes]})
   ...: print(dfi.head()) # this is an input example
   A   B
0  1   8
1  1  12
2  1  11
3  1  47
4  1  22
In [2]: result = []
   ...: w = 3
   ...: for i in range(1,100):
   ...:     result.append({'A': i, 'B': np.array([e for j, e in dfi.values if abs(i-j) &lt; w or abs(min(i,j)+99-max(i,j)
   ...: ) &lt; w])})
   ...: dfo = pd.DataFrame(result) # this is the expected output, to be obtained with groupby and rolling operations
   ...: print(dfo.head())
   A                                                  B
0  1  [8, 12, 11, 47, 22, 95, 86, 40, 33, 78, 28, 78...
1  2  [8, 12, 11, 47, 22, 95, 86, 40, 33, 78, 28, 78...
2  3  [8, 12, 11, 47, 22, 95, 86, 40, 33, 78, 28, 78...
3  4  [28, 78, 5, 75, 88, 21, 56, 82, 51, 93, 66, 48...
4  5  [66, 48, 70, 57, 65, 35, 5, 4, 47, 60, 41, 49,...
</code></pre>
<p>Note that there are 50 elements in each array, 10 for each group, and then a window size of 5 (3 radius, non-inclusive)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using aggregate:</p>
<pre><code>dfo = dfi.groupby('A').agg(lambda x: list(x))
dfo.head()
                                               B
    A                                           
    1    [8, 12, 11, 47, 22, 95, 86, 40, 33, 78]
    2    [28, 78, 5, 75, 88, 21, 56, 82, 51, 93]
    3     [66, 48, 70, 57, 65, 35, 5, 4, 47, 60]
    4    [41, 49, 55, 68, 22, 72, 23, 31, 30, 4]
    5   [23, 42, 23, 18, 66, 66, 47, 66, 87, 72]
</code></pre>
<p>And you can return a Series instead of a DataFrame by accessing column 'B' in the DataFrameGroupBy object like this:</p>
<pre><code>dfo = dfi.groupby('A')['B'].apply(lambda x: list(x))

</code></pre>
</div>
<span class="comment-copy">Please add an example dataframe and expected output, see more information here: <a href="https://stackoverflow.com/questions/20109391/how-to-make-good-reproducible-pandas-examples" title="how to make good reproducible pandas examples">stackoverflow.com/questions/20109391/â€¦</a></span>
<span class="comment-copy">this isn't clear at all, please make a simple reproducible dataframe so that we can practice, and please give expected output.</span>
<span class="comment-copy">See example with input DataFrame and output DataFrame here: <a href="http://dpaste.com/1EZTW1A" rel="nofollow noreferrer">dpaste.com/1EZTW1A</a> I will convert to a rendered notebook when possible</span>
<span class="comment-copy">I think I cannot do what I wanted to do, after hitting my head against a wall repeatedly, I was getting a very prevalent error (<code>cannot handle this type -&gt; object</code>), apparently rolling is mostly for numbers, not lists, according to this: <a href="https://github.com/pandas-dev/pandas/issues/23002" rel="nofollow noreferrer">github.com/pandas-dev/pandas/issues/23002</a> I guess my only option is forgetting about pandas and trying to optimize python code...</span>
<span class="comment-copy">Added how to get series from grouper to Nathaniel's answer.</span>
<span class="comment-copy">certainly I was missing the application of the list function, BTW it can be done like this: <code>dfi.groupby('A').agg(list)</code>, but after doing that I need to do a rolling window and aggregate the lists again</span>
