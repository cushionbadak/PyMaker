<div class="post-text" itemprop="text">
<p>I've tried doing a lot of research on this topic, but haven't been able to find a good answer yet. </p>
<p>I know, on <code>mac</code> or <code>windows</code> to create an <em>encrypted zip</em> pretty easily, but for <code>python</code>, I cannot seem to find an easy way to take an <code>existing file</code> like <code>myfile.db</code>, and take the contents and encrypt it, then create another file, like <code>encrypted_myfile.db</code></p>
<p>Does anyone have some samples they could share? or good tutorials on this?</p>
<p>I'm using <code>Python3</code>.</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>I did not write this myself, but have successfully used it:</p>
<pre><code>from os import urandom
from hashlib import md5

from Crypto.Cipher import AES

def derive_key_and_iv(password, salt, key_length, iv_length):
    d = d_i = b''  # changed '' to b''
    while len(d) &lt; key_length + iv_length:
        # changed password to str.encode(password)
        d_i = md5(d_i + str.encode(password) + salt).digest()
        d += d_i
    return d[:key_length], d[key_length:key_length+iv_length]

def encrypt(in_file, out_file, password, salt_header='', key_length=32):
    # added salt_header=''
    bs = AES.block_size
    # replaced Crypt.Random with os.urandom
    salt = urandom(bs - len(salt_header))
    key, iv = derive_key_and_iv(password, salt, key_length, bs)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    # changed 'Salted__' to str.encode(salt_header)
    out_file.write(str.encode(salt_header) + salt)
    finished = False
    while not finished:
        chunk = in_file.read(1024 * bs) 
        if len(chunk) == 0 or len(chunk) % bs != 0:
            padding_length = (bs - len(chunk) % bs) or bs
            # changed right side to str.encode(...)
            chunk += str.encode(
                padding_length * chr(padding_length))
            finished = True
        out_file.write(cipher.encrypt(chunk))

def decrypt(in_file, out_file, password, salt_header='', key_length=32):
    # added salt_header=''
    bs = AES.block_size
    # changed 'Salted__' to salt_header
    salt = in_file.read(bs)[len(salt_header):]
    key, iv = derive_key_and_iv(password, salt, key_length, bs)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    next_chunk = ''
    finished = False
    while not finished:
        chunk, next_chunk = next_chunk, cipher.decrypt(
            in_file.read(1024 * bs))
        if len(next_chunk) == 0:
            padding_length = chunk[-1]  # removed ord(...) as unnecessary
            chunk = chunk[:-padding_length]
            finished = True 
            out_file.write(
                bytes(x for x in chunk))  # changed chunk to bytes(...)
</code></pre>
<p>Hope it helps.</p>
</div>
<span class="comment-copy">Check out <code>gnupg</code> package (after setting up a gpg key on the system). <a href="https://fedoraproject.org/wiki/Creating_GPG_Keys" rel="nofollow noreferrer">fedoraproject.org/wiki/Creating_GPG_Keys</a></span>
<span class="comment-copy">There are lots of options for encrypting file. <a href="https://www.google.com/search?q=python+encrypt+file&amp;gws_rd=ssl" rel="nofollow noreferrer">google</a> has some good ideas.</span>
<span class="comment-copy">There's also PyCrypto, which is quite powerful, but It doesn't have a simple "encrypt this file" method. It only provides the building blocks - the algorithms for encryption, hashing and random number generation.</span>
<span class="comment-copy">@user5728855 - do you know of a library, or way to do the "simple" method?</span>
<span class="comment-copy">Don't roll your own password based key derivation function if you don't need to; even restricting yourself to built-ins + <code>pycrypto</code>, Python 3.4 and higher <a href="https://docs.python.org/3/library/hashlib.html#hashlib.pbkdf2_hmac" rel="nofollow noreferrer">provides a decent one in <code>hashlib.pbkdf2_hmac</code></a>. Getting crypto right is hard, don't try to do any more of it than you absolutely have to.</span>
