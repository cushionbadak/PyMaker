<div class="post-text" itemprop="text">
<p>Well simply making a class iterable is easy enough using meta classes (so some other answers here). However I wish to make a class iterable, and also enabling one to "iterate a subgroup based on inheritance". An example of my use:</p>
<pre><code>class IterPartRegistry(type):
    def __iter__(cls):
        return iter(cls._registry)


class A(object, metaclass=IterPartRegistry):
    _registry = []
    def __init__(self, name):
        self.name = name
        self._registry.append(self)

class B(A):
    pass

class C(A):
    pass


A("A - first")
B("B - first")
B("B - second")
C("C - first")

for t in A:
    print(t.name)

print(" --- ")
for t in B:
    print(t.name)

exit()
</code></pre>
<p>The first loop works - it iterates over all instances and childs of "A". However the second loop should only run over the specific subgroup of "A" - those that are instances of the child "B" (or children further down the line).</p>
<p>(How) can this be achieved easiest? In such a way adding more subclasses require least amount of work/change?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use isinstance to insure that you are getting only class instances</p>
<p>In your code its a one line change:</p>
<pre><code>class IterPartRegistry(type):
    def __iter__(cls):
        return (c for c in cls._registry if isinstance(c, cls))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could let each class maintain its own list of instances by giving each
its own <code>_registry</code> class attribute. Then, instead of checking if each
instance is of a particular class, you could instead iterate over all the values in the <code>_registry</code>s for each subclass of <code>cls</code>. To find those subclasses you could use the 
<a href="https://docs.python.org/3/library/stdtypes.html#class.__subclasses__" rel="nofollow"><code>cls.__subclasses__()</code></a> method:</p>
<pre><code>import itertools as IT
class IterPartRegistry(type):
    def __init__(cls, name, bases, attrs):
        super(IterPartRegistry, cls).__init__(name, bases, attrs)
        cls._registry = []
    def __iter__(cls):
        yield from cls._registry
        for subcls in cls.__subclasses__():
            yield from subcls

class A(object, metaclass=IterPartRegistry):
    def __init__(self, name):
        self.name = name
        self._registry.append(self)

class B(A): pass

class C(A): pass

class D(B, C): pass

A("A - first")
B("B - first")
B("B - second")
C("C - first")
D("D - first")

for t in A:
    print(t.name)

print(" --- ")
for t in B:
    print(t.name)
</code></pre>
<p>yields</p>
<pre><code>A - first
B - first
B - second
D - first
C - first
D - first
 --- 
B - first
B - second
D - first
</code></pre>
</div>
<span class="comment-copy">This looks really good. Just wondering - when iterating won't it iterate the _registry each time I go to the next element. (in other words iterating n elements now takes O(n^2) instead of O(n) time?</span>
<span class="comment-copy">since the iterator returned by a generator is the generator itself, maybe that could simply be <code>return (c for c in cls._registry if isinstance(c, cls))</code></span>
<span class="comment-copy">@Pynchia - Fixed, thanks</span>
<span class="comment-copy">@paul23, No it would only iterate once, O(n)</span>
<span class="comment-copy">Oops, my mistake. That can be fixed by iterating over the subclasses recursively. I've edited the post to show what I mean.</span>
