<div class="post-text" itemprop="text">
<p>In my utility.py I have,</p>
<pre><code>@contextmanager
def rate_limit_protection(max_tries=3, wait=300):
    tries = 0
    while max_tries &gt; tries:
        try:
            yield
            break
        except FacebookRequestError as e:
            pprint.pprint(e)
            if e._body['error']['message'] == '(#17) User request limit reached':
                print("waiting...")
                time.sleep(wait)
                tries += 1
</code></pre>
<p>In my task.py I call:</p>
<pre><code>for date in interval:
   with utility.rate_limit_protection():
      stats = account.get_insights(params=params)
</code></pre>
<p>After runing the task for a given date range, once Facebook rate limit kicks in, the program waits for 300 seconds after which it fails with the error.</p>
<pre><code>File "/Users/kamal/.pyenv/versions/3.4.0/lib/python3.4/contextlib.py", line 78, in __exit__
    raise RuntimeError("generator didn't stop")
RuntimeError: generator didn't stop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>with</code> statement is not a looping construct.  It cannot be used to execute code repeatedly.  A context manager created with <code>@contextmanager</code> should only <code>yield</code> once.</p>
<p>A context manager does (basically) three things:</p>
<ol>
<li>It runs some code before a code block.</li>
<li>It runs some code after a code block.</li>
<li>Optionally, it suppresses exceptions raised within a code block.</li>
</ol>
<p>If you want to do something like this, you need to rewrite it so that the loop is moved outside the context manager, or so that there is no context manager at all.</p>
<p>One option would be to write a function that accepts a callback as an argument, and then calls the callback in a loop like the one you currently have in your context manager:</p>
<pre><code>def do_rate_protection(callback, max_tries=3):
    tries = 0
    while max_tries &gt; tries:
        try:
            callback()
            break
        except FacebookRequestError as e:
            # etc.
</code></pre>
<p>You can then call it like this:</p>
<pre><code>for date in interval:
    def callback():
        # code
    do_rate_protection(callback)
</code></pre>
<p>If the callback doesn't need the <code>date</code> variable, you can move it outside the loop to avoid repeatedly recreating the same function (which is wasteful of resources).  You could also make <code>date</code> a parameter of the <code>callback()</code> function and pass it using <a href="https://docs.python.org/3/library/functools.html#functools.partial"><code>functools.partial</code></a>.</p>
</div>
<span class="comment-copy">Are you expecting this <code>rate_limit_protection</code> context manager to run the body of the <code>with</code> statement repeatedly? <code>with</code> doesn't do that. The body runs once.</span>
<span class="comment-copy">No no.. There is a for loop surrounding the with statement. the with statement runs once for the entire body of the for loop. Do you mean I can't have a while loop inside my rate_limit_protection() function</span>
<span class="comment-copy">Why would you expect the with statement to run once for the entire loop, if it's inside the loop body?</span>
<span class="comment-copy"><code>for date in interval:       with utility.rate_limit_protection():            stats = account.get_insights(params=params)</code> I have edited the question. Now you might get some clarity on what I am trying to do</span>
<span class="comment-copy">This is pretty much the same as <a href="http://stackoverflow.com/q/29708445/245173">stackoverflow.com/q/29708445/245173</a></span>
