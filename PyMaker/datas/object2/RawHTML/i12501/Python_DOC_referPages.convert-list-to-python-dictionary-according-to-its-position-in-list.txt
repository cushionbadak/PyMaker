<div class="post-text" itemprop="text">
<p>I have a list like this:</p>
<pre><code>c = ['A','B','C']
</code></pre>
<p>and I want it to convert it into <code>dict</code> object like</p>
<pre><code>d = {"alphabets":{"0":"A","1":"B","2":"C"}}
</code></pre>
<p>I have currently implemented the following code:</p>
<pre><code>c = ["A","B","C"]
d={}
for i in range(len(c)):
    d.update({"alphabets":{str(i): c[i]}})
print d
</code></pre>
<p>But this gives the output <code>{'alphabets': {'2': 'C'}}</code>. Does anybody know how to deal with this bug?</p>
</div>
<div class="post-text" itemprop="text">
<p>That is because you are updating the dictionary.</p>
<p><strong>Warning:</strong> </p>
<p>I have used normal dictionary. There is no orders in them you could use ordered dictionary if you want. </p>
<p><strong>Code:</strong></p>
<pre><code>c = ["A","B","C"]
d={"alphabets":{}}
for i,v in enumerate(c):
    d["alphabets"][str(i)]=v
print d
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>{'alphabets': {'1': 'B', '0': 'A', '2': 'C'}}
</code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>The issue in your program  was you were always updating the key <code>alphabets</code> to a new dictionary.</li>
<li>That is why you got <code>c:2</code> since that is the last updated dictionary
-What I have done is created a dictionary with key <code>alphabets</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You could do it with <code>dict comprehension</code>:</p>
<pre><code>In [196]: {'alphabets': {str(i):v for i, v in enumerate(c)}}
Out[196]: {'alphabets': {'0': 'A', '1': 'B', '2': 'C'}}
</code></pre>
<p>If you need an order you could use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>OrderedDict</code></a> from <a href="https://docs.python.org/3/library/collections.html#module-collections" rel="nofollow"><code>collections</code></a></p>
<pre><code>from collections import OrderedDict
l1 = [(str(i),v) for i, v in enumerate(c)]
d2 = OrderedDict(l1)

In [284]: d2
Out[284]: OrderedDict([('0', 'A'), ('1', 'B'), ('2', 'C')])

d = {'alphabets': d2}

In [286]: d
Out[286]: {'alphabets': OrderedDict([('0', 'A'), ('1', 'B'), ('2', 'C')])}
</code></pre>
<p>Or onliner suggested by @cezar:</p>
<pre><code>d = {'alphabets': OrderedDict([(str(i), v) for i, v in enumerate(c)])}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>zip</code> too though it does not maintain <strong>order</strong>.</p>
<pre><code>&gt;&gt;&gt;{'alphabets':{k:v for k,v in zip(range(len(c)),c)}}
&gt;&gt;&gt;{'alphabets': {0: 'A', 1: 'B', 2: 'C'}}
</code></pre>
</div>
<span class="comment-copy">Do you want the order i.e <code>0,1,2,3</code> as posted above- then mind dictionary does not cares about the order</span>
<span class="comment-copy">May I ask why you want that? As it is, I see no point to it.</span>
<span class="comment-copy">@TigerhawkT3 I am also asking myself why would one create a dictionary with integers as keys like in this example. Having a list is much simpler and one can still access the list items by their index: <code>my_list[0]</code> is easier to manage than <code>my_dict['0']</code>.</span>
<span class="comment-copy">@abhi1610 They are already arranged in the list and you can access every item by its index. You can just put the list as a value for the key <code>alphabets</code>. It is important that a list can't be a key in a dictionary. You could have <code>d = {'alphabets': ['A', 'B', 'C']}</code>. Having a list you have many more possibilities, for example slicing: <code>d['alphabets'][::-1]</code> for reversing.</span>
<span class="comment-copy">"I want to arrange the items in list by their position as a key in dictionary" is a repetition of what you're doing, not the reasoning of why you want to do it. It would be just as easy to add attributes to them in the <code>list</code> as it would in the dictionary, if you're still using that kind of "index" as a key. You can <i>already</i> access them with <code>mylist[key]</code>. There is <i>no difference or improvement here</i>.</span>
<span class="comment-copy">Thank you. It is working like charm.</span>
<span class="comment-copy">@abhi1610 happy to help.You could also use the other methods using dict comprehension which is faster but little untidy.</span>
<span class="comment-copy">@The6thSense The dict comprehension is a way better, but your answer is more comprehensive for beginners. So, it is ok to iterate in a loop for a better demonstration.</span>
<span class="comment-copy">@ Anton Protopopov -May i ask you a question why <code>The6thSense's</code> answer does not maintain order as your's does?</span>
<span class="comment-copy">It is more important that <code>d['alphabets']</code> is an <code>OrderedDict</code>, not <code>d</code> itself.</span>
<span class="comment-copy">I think it's just coincidence because dict isn't taking in acoount order of keys</span>
<span class="comment-copy">@cezar yes, thanks. It's strange but with <code>OrderedDict</code> for that resulted <code>dict</code> I get <code>OrderedDict([('0', 'A'), ('2', 'C'), ('1', 'B')])</code> which I thought should be: <code>OrderedDict([('0', 'A'), ('1', 'B'), ('2', 'C')])</code></span>
<span class="comment-copy">The oneliner can be made with a simple list comprehension: <code>d = {'alphabets': OrderedDict([(str(i), v) for i, v in enumerate(c)])}</code>. This way it should be sorted from the start on.</span>
<span class="comment-copy">you could just use <code>enumerate</code> then zip and range.</span>
<span class="comment-copy">@  The6thSense Yeah! ofcourse- more like <code>Anton Protopopov</code>.</span>
