<div class="post-text" itemprop="text">
<p>I recently had to debug some code that went something like this:</p>
<pre><code>for key, group in itertools.groupby(csvGrid, lambda x: x[0]):
    value1 = sum(row[1] for row in group)
    value2 = sum(row[2] for row in group)
    results.append([key, value1, value2])
</code></pre>
<p>In every result set, <code>value2</code> came out as <code>0</code>.  When I looked into it, I found that the first time the code iterated over <code>group</code>, it consumed it, so that the second time there were zero elements to iterate over.</p>
<p>Intuitively, I would expect <code>group</code> to be a list which can be iterated over an indefinite number of times, but instead it behaves like an iterator which can only be iterated once.  Is there any good reason why this is the case?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools</code> is an iterator library, and like just about everything else in the library, the <code>itertools.groupby</code> groups are iterators. There isn't a single function in all of <code>itertools</code> that returns a sequence.</p>
<p>The reasons the groupby groups are iterators are the same reasons everything else in itertools is an iterator:</p>
<ol>
<li>It's more memory efficient.</li>
<li>The groups could be infinite.</li>
<li>You can get results immediately instead of waiting for the whole group to be ready.</li>
</ol>
<p>Additionally, the groups are iterators because you might only want the keys, in which case materializing the groups would be a waste.</p>
<p><code>itertools.groupby</code> is not intended to be an exact match for any LINQ construct, SQL clause, or other thing that goes by the name "group by". Its grouping behavior is closer to an extension of Unix's <code>uniq</code> command than what LINQ or SQL do, although the fact that it makes groups means it's not an exact match for <code>uniq</code> either.</p>
<p>As an example of something you could do with <code>itertools.groupby</code> that you couldn't with the other tools I've named, here's a run-length encoder:</p>
<pre><code>def runlengthencode(iterable):
    for key, group in groupby(iterable):
        yield (key, sum(1 for val in group))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Intuitively, I would expect group to be a list which can be iterated over an indefinite number of times, but instead it behaves like an iterator which can only be iterated once.</p>
</blockquote>
<p>That's correct.</p>
<blockquote>
<p>Is there any good reason why this is the case?</p>
</blockquote>
<ol>
<li><p>It's potentially more memory efficient: you don't need to build an entire list first and then store it in memory, only to then iterate over it. Instead, you can process the elements as you iterate.</p></li>
<li><p>It's potentially more CPU efficient: by not generating all data up front, e.g. by producing a list, you can bail out early: if you find a particular group which matches some predicate, you can stop iteration - no further work needs to be done.</p></li>
</ol>
<p>The decision of whether you need all data and iterate it multiple times is not hardcoded by the callee but is left to the caller.</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3.5/library/itertools.html#itertools.groupby" rel="nofollow">docs</a></p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list</p>
</blockquote>
<p>Interestingly, if you don't consume <code>g</code> yourself, <code>groupby</code> will do it before returning the next iteration.</p>
<pre><code>&gt;&gt;&gt; def vals():
...     for i in range(10):
...         print(i)
...         yield i
... 
&gt;&gt;&gt; for k,g in itertools.groupby(vals(), lambda x: x&lt;5):
...     print('processing group')
... 
0
processing group
1
2
3
4
5
processing group
6
7
8
9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I got the same issue when trying to access a "groupby" returned iterator multiple times.
Based on <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">Python3 doc</a> , it suggests transfer iterator to list , so that is can be accessed later. </p>
</div>
<span class="comment-copy">Considering how <a href="http://stackoverflow.com/a/7286/32914">itertools.groupby doesn't even work unless you sort your data set first</a>, and sorting can't be done on an infinite sequence, point 2 makes no sense.</span>
<span class="comment-copy">@MasonWheeler: The idea is that the input might be generated pre-sorted, perhaps because it's an order-preserving <code>imap</code> over a sorted sequence, or because you're streaming results from a database and the database ordered them for you, or because of some other property of the data source. If <code>itertools.groupby</code> couldn't operate on and return iterators, it probably wouldn't be in itertools at all.</span>
<span class="comment-copy">Sure, I expect it to <i>operate on</i> iterators, sure, but <i>return</i> iterators?  Not on a function like this!  If <a href="http://sayspy.blogspot.com/2006/02/why-python-doesnt-need-something-like.html" rel="nofollow noreferrer"><code>itertools.groupby</code> is supposed to be equivalent to LINQ's <code>GroupBy()</code>,</a> I expect it to return <a href="https://msdn.microsoft.com/library/bb344977%28v=vs.100%29.aspx" rel="nofollow noreferrer">a grouping.</a>  Eager evaluation is the only way to do a GroupBy operation correctly.</span>
<span class="comment-copy">@MasonWheeler: <code>itertools.groupby</code> is not intended to be equivalent to any LINQ construct. It predates LINQ, anyway, so it wouldn't be reasonable to expect it to imitate LINQ's design decisions.</span>
