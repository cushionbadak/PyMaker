<div class="post-text" itemprop="text">
<p>I have a certain string <code>fruits</code> as such:</p>
<pre><code>Apples
Bananas
Pineapples
</code></pre>
<p>There is a carriage return <code>\r</code> at the end of each line, as well as at the beginning and end of the string. Using RegEx, how would I go about appending <code>: 1</code> to the end of the first line <code>Apples</code>? I have tried the following to no avail:</p>
<pre><code>re.sub("Apples(\r)", "\1:1", fruits)
</code></pre>
<p>My thinking was that <code>\1</code> should replace what's in the brackets <code>(\r)</code>, however everything in the pattern is being replaced.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are doing is matching <code>"Apples\r"</code>, capturing the <code>"\r"</code> in the process, and then replacing the entire match with <code>"\r:1"</code>. </p>
<p>For this simple example, there's no need to capture matches to <code>\r</code>, anyway, since the only thing that will match it is <code>\r</code>. You can hard code that into the replacement string.</p>
<p>I'll assume you want the resulting string to be <code>"\rApples: 1\rBananas\rPineapples\r</code>.</p>
<p>You can use a <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow">lookbehind</a> so that <code>Apples</code> is not consumed (though I hear that consuming one a day keeps the doctor away):</p>
<pre><code>re.sub("(?&lt;=Apples)\r", ": 1\r", fruits)
</code></pre>
<p>But you could also just do:</p>
<pre><code>re.sub("Apples\r", "Apples: 1\r", fruits)
</code></pre>
<p>The lookbehind would be more useful if you wanted to add <code>: 1</code> after each fruit:</p>
<pre><code>re.sub("(?&lt;=[^\r])\r", ": 1\r", fruits)
</code></pre>
<p>The above says find every <code>\r</code> that follows a character that isn't an <code>\r</code>, and replace them with <code>: 1\r</code>. The result would then be:</p>
<pre><code># \rApples: 1\rBananas: 1\rPineapples: 1\r\r
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you do</p>
<pre><code>re.sub("A(B)", "\1C", "AB")
</code></pre>
<p>you will get <code>BC</code>, because <code>\1</code> <em>is replaced</em> by what is in the bracket.</p>
<p>To get <code>AC</code>, you should do:</p>
<pre><code>re.sub("(A)B", "\1C", "AB")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Having \r as your fruit separator makes it awkward to print things out; so for the purposes of this answer I am going to use the @ character in its place.  The code that follows works just the same if you assign \r to my separator variable and use your actual \r separated string for fruit_str.</p>
<p>Some explanation follows the code.</p>
<pre><code>import re

def updateFruitQuantity(the_fruit, the_quantity, fruit_str, separator):
    re_1 = r"(" + the_fruit + r")(:.*?|)" + separator
    re_2 = r'\1:' + str(the_quantity) + separator
    fruit_str = re.sub(re_1, re_2, fruit_str)
    return(fruit_str)

separator = "@"
fruit_str = "@Apples@Bananas@Pineapples@"
print(fruit_str)

fruit_str = updateFruitQuantity("Pineapples", 25, fruit_str, separator)
print(fruit_str)
fruit_str = updateFruitQuantity("Bananas", 17, fruit_str, separator)
print(fruit_str)
fruit_str = updateFruitQuantity("Pineapples", 3, fruit_str, separator)
print(fruit_str)
fruit_str = updateFruitQuantity("Apples", 94, fruit_str, separator)
print(fruit_str)
fruit_str = updateFruitQuantity("Apples", 102, fruit_str, separator)
print(fruit_str)
</code></pre>
<p><strong>And here is the code's output:</strong></p>
<pre><code>@Apples@Bananas@Pineapples@

@Apples@Bananas@Pineapples:25@
@Apples@Bananas:17@Pineapples:25@
@Apples@Bananas:17@Pineapples:3@
@Apples:94@Bananas:17@Pineapples:3@
@Apples:102@Bananas:17@Pineapples:3@
</code></pre>
<p>I am building separate regular expressions for the target text and for the replacement text.  </p>
<p>These target expression assumes that each fruit:quantity is followed by the separator.  There are two capture groups in the target expression -- each is surrounded by parenthesis.  The second grouping is important in the target expression because it sweeps up any :quantity element that might be present.</p>
<p>The replacement expression starts with \1 which stands for the text matched by the first grouping in the target expression (eg "Apples").  That is followed by the colon and then the quantity string to be used.  Doing it this way ensures that any existing :quantity is properly replaced with the new quantity and that it also works in the case where there were no existing :quantity.  So for example in our third change you see the quantity for Pineapples go back from 25 to 3.</p>
<p>You will need another mechanism for adding new types of fruit to fruit_str as time went on.</p>
</div>
