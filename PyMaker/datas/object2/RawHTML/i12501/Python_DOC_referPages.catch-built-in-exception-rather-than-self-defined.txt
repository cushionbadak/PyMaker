<div class="post-text" itemprop="text">
<p>I want to patch a library to catch the built-in <a href="https://docs.python.org/3/library/exceptions.html#ConnectionError" rel="nofollow">ConnectionError</a> (which inherits from OSError).</p>
<p>So far so good. As it happens, the library has a "self-defined" Exception that is also called ConnectionError:</p>
<pre><code>class LibraryError(Exception):
    pass


class ConnectionError(LibraryError):
    pass
</code></pre>
<p>I guess, if I now tried to catch a <code>ConnectionError</code>, doing something like</p>
<pre><code>try:
    do_something()
except ConnectionError as e:
    try_to_get_it_right_again()
</code></pre>
<p>I would only catch the self-defined <code>ConnectionError</code>, which inherits from <code>LibraryError</code>. (Disclaimer: I have to admit, I haven't tested that myself, as I didn't know how).</p>
<p>How would I get Python to catch the built-in <code>ConnectionError</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code></a> module, the explicit name for the namespace where built-in names like <code>int</code> and <code>ConnectionError</code> live.</p>
<pre><code>import builtins

try:
    ...
except builtins.ConnectionError:
    ...
</code></pre>
<p>In Python 2, this would be <code>__builtin__</code>, although Python 2 doesn't have <code>ConnectionError</code>. Note that <code>__builtins__</code> is its own weird thing; even if it looks like what you want, it's not.</p>
<hr/>
<p>If you want code that works in both Python 2 and Python 3... well, the exception hierarchy looks pretty different in Python 2, and ConnectionError doesn't even exist, so it's not as simple as deciding whether to use <code>builtins</code> or <code>__builtin__</code>. The <code>builtins</code>/<code>__builtin__</code> thing is easy enough to solve, at least.</p>
<p>To import the right module depending on Python version, you can catch the <code>ImportError</code> and import the other module:</p>
<pre><code>try:
    import builtins
except ImportError:
    import __builtin__ as builtins
</code></pre>
<p>Pretending for a moment that Python 2 has ConnectionError, you could save a reference to the built-in <code>ConnectionError</code> before shadowing the name:</p>
<pre><code>_builtin_ConnectionError = ConnectionError

class ConnectionError(LibraryError):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the the <strong><a href="https://docs.python.org/3/library/exceptions.html#ConnectionError" rel="nofollow"><code>ConnectionError</code></a></strong> defined along with the other exceptions in the <strong><a href="https://docs.python.org/3/library/builtins.html" rel="nofollow"><code>builtins</code></a></strong> library:</p>
<pre><code>import builtins

try:
    # connection error raised
except builtins.ConnectionError as conerr:
    # handle stuff
</code></pre>
</div>
<span class="comment-copy">About your disclaimer part, its about scope resolution, so you are right as the built-ins are checked last. Take a look at this <a href="http://stackoverflow.com/a/292502/5050917">SO answer</a> if you want.</span>
<span class="comment-copy">Thank you. Another problem is that the original author wrote the library to run in Python2 <i>and</i> in Python3 - so I probably couldn't <code>import builtins</code> without breaking Python2 support :(</span>
<span class="comment-copy">@speendo: <code>try: import builtins</code> <code>except ImportError: import __builtin__ as builtins</code>. Catching ImportError is pretty standard when a module might or might not exist. Alternatively, you can save a reference to the builtin <code>ConnectionError</code> before shadowing the name: <code>_builtin_ConnectionError = ConnectionError</code>.</span>
<span class="comment-copy">oh, the last option would be a great way to deal with it without hacking around too much! Still, I will ask the original author if he would like to rename his ConnectionError, which would improve readability even more :)</span>
<span class="comment-copy">@speendo: Wait, if you need code that works on both Python 2 and Python 3, you're just going to be catching OSError instead of ConnectionError either way, since Python 2 doesn't have ConnectionError.</span>
<span class="comment-copy">@speendo: Actually, catching OSError wouldn't work, since the exception hierarchy changed in more ways than I realized. In Python 2, <code>socket.error</code> doesn't even descend from OSError.</span>
<span class="comment-copy">Thank you! The comment I made above would of course also fit to your answer</span>
<span class="comment-copy">thank you for your great help! I really appreciate that! I will still accept @user2357112's answer just because it's a bit more extensive. But please keep up your great work!</span>
<span class="comment-copy">@speendo I really do not mind; there's no need to justify your accepting :-)</span>
