<div class="post-text" itemprop="text">
<p>I have two lists that look like this:</p>
<pre><code>list1 = ['filename1', 'filename2', 'filename3']
list2 = ['1', '2', ['3', '4', '5']]
</code></pre>
<p>How can I write to a csv file that will end up like this?</p>
<pre><code>filename1,1
filename2,2
filename3,3,4,5
</code></pre>
<p>I've tried two things but neither work:</p>
<pre><code>with open(outfname, 'wb') as fout:
        csv_out = csv.writer(fout)
        csv_out.writerows(izip(list1, list2))
</code></pre>
<p>This shows:</p>
<pre><code>filename1,['1']
filename2,['2']
filename3,['3','4','5']
</code></pre>
<p>I tried adding this prior to writerows:</p>
<pre><code>",".join(list2)
</code></pre>
<p>But the results will show:</p>
<pre><code>filename1,1
filename2,2
filename3,"1,2,3"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@Satya has a good idea to use pandas but you need to flatten list2, you can do that with <code>.apply()</code>:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import sys
&gt;&gt;&gt; df = pd.DataFrame({'list1': list1, 'list2': list2})
&gt;&gt;&gt; df = df.join(df.list2.apply(lambda x: pd.Series(x)))
&gt;&gt;&gt; df.drop('list2', axis=1).to_csv(sys.stdout, header=False, index=False)
filename1,1,,
filename2,2,,
filename3,3,4,5
</code></pre>
<p>This puts empty fields where there is missing data.<br/>
Alternatively you can write your own special zip:</p>
<pre><code>def my_zip(l1, l2):
    for a, b in zip(l1, l2):
        try:
            yield [a]+b
        except TypeError:
            yield [a, b]

&gt;&gt;&gt; csv_out = csv.writer(sys.stdout)
&gt;&gt;&gt; csv_out.writerows(my_zip(list1, list2))
filename1,1
filename2,2
filename3,3,4,5
</code></pre>
<p>Which is exactly the output requested.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like this. It requires a few temporary lists, but gets the job done.</p>
<pre><code>import csv

list1 = ['filename1', 'filename2', 'filename3']
list2 = ['1', '2', ['3', '4', '5']]

with open('out.csv', 'w') as f:
    r = csv.writer(f)
    for name, num in zip(list1, list2):
        r.writerow([name] + list(num))
</code></pre>
<p><code>out.csv</code> looks like</p>
<pre><code>filename1,1
filename2,2
filename3,3,4,5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You do not need pandas for that. First to get your desired data structure you can just use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a>. To save to CSV you can use standard CSV module.</p>
<pre><code>import csv
list1 = ['filename1', 'filename2', 'filename3']
list2 = ['1', '2', ['3', '4', '5']]

zipped = zip(list1, list2)
with open('some.csv', 'w', newline='') as f:
   writer = csv.writer(f)
   writer.writerows(zipped)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Remember that a string is a one item list. Why do you need pandas and all for this simple task?</p>
<pre><code>list1 = ['filename1', 'filename2', 'filename3']
list2 = ['1', '2', ['3', '4', '5']]
with open(outfname, 'w') as fout:
    for item in zip(list1,list2):
        fout.write(item[0])
        fout.write(',')
        fout.write(','.join(item[1]))
        fout.write('\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use pandas data-frame instead to form the desired .csv file </p>
<pre><code>import pandas as pd
list1 = ['filename1', 'filename2', 'filename3']
list2 = ['1', '2', ['3', '4', '5']]
df = pd.DataFrame()
df['a'] = list1
df['b'] = list2
df.to_csv('D:/sx.csv',index=False) ####you can give any desired path for csv
</code></pre>
<p>TO FLATTEN the list just do</p>
<pre><code>df['b']=[','.join(x) for x in df['b']]  ####i have separated the list items by comma as of now, but you can give your own separator
</code></pre>
<p>continuing the code</p>
<pre><code>  df.to_csv('D:/sx.csv',index=False)
  d = pd.read_csv('D:/sx.csv')
  d 
       a      b
 0  filename1      1
 1  filename2      2
 2  filename3  3,4,5
</code></pre>
<p>Again modifying</p>
<pre><code>  d['a'] = d['a']+','+d['b']
  d
  Out[39]: 
             a      b
0      filename1,1      1
1      filename2,2      2
2  filename3,3,4,5  3,4,5
</code></pre>
<p>then drop the column b</p>
<pre><code> df = d.drop('b',axis=1)
 df
Out[44]: 
             a
 0      filename1,1
 1      filename2,2
 2  filename3,3,4,5
 ######column a shows the desired output...
</code></pre>
<p>now you can form the csv by df.to_csv('path+file.csv')</p>
</div>
<span class="comment-copy">Did you try this? This is not what the OP was looking for, and they had already tried <code>[i]zip</code>.</span>
<span class="comment-copy">This is native. No modules imported. Super trivial folks!</span>
<span class="comment-copy">Works for the example input but is a bit limited, any non-nested 2 digit number (e.g. <code>['11','22',['3','4','5']]</code>) would also get a <code>','</code> put between the digits.</span>
<span class="comment-copy">This still doesn't flatten <code>list[2]</code>.</span>
<span class="comment-copy">@AChampion-modified my answer..</span>
<span class="comment-copy">That would still put delimiters around the field which the OP was trying to avoid, see the last example output.</span>
<span class="comment-copy">@AChampion-may be i misinterpreted the OP's question..the columns need to be zipped.</span>
<span class="comment-copy">If you replace <code>'D:/sx.csv'</code> with <code>sys.stdout</code> (or look at the file created) you would see <code>3,4,5</code> is delimiter <code>"3,4,5"</code>. When you read it back it pandas strips the delimeters.</span>
