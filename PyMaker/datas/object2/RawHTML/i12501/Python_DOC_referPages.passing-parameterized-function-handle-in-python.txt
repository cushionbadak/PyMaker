<div class="post-text" itemprop="text">
<p>I have a general function that defines a form of an ODE that I plan to integrate using <a href="http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.odeint.html" rel="nofollow"><code>scipy.integrate.odeint</code></a>, for example:</p>
<pre><code>def my_ode(K, tau, y, u):
  return K*u/tau - y/tau  # dydt
</code></pre>
<p>I have several objects in my code that all have dynamics of the form defined in <code>my_ode</code>, but with unique parameters <code>K</code> and <code>tau</code>. I would love to be able to just pass a unique handle to <code>my_ode</code> with those parameters already set when I initialize my objects, so that when I update my objects, all I have to do is something like <code>soln = odeint(my_ode, t, y, u)</code> for some simulation time <code>t</code>.</p>
<p>For example, if I define a class:</p>
<pre><code>class MyThing:
  def __init__(self, ode, y0):
    # I would rather not maintain K and tau in the objects, I just want the ODE with unique parameters here.
    self.ode = ode
    self.y = y0
    self.time = 0.0

  def update(self, t, u):
    # I want this to look something like:
    self.y = scipy.integrate.odeint(self.ode, t, self.y, u)
</code></pre>
<p>Can I do something with Lambdas when I initialize instances of <code>MyThing</code> to basically assign parameters <code>K</code> and <code>tau</code> at initialization and never need to pass them again? I am a bit stuck.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have:</p>
<pre><code>def my_ode(K, tau, y, u):
    return K*u/tau - y/tau
</code></pre>
<p>you could define something like:</p>
<pre><code>def make_ode_helper(k, tau): 
    return lambda (y, u): my_ode(K, tau, y, u)
</code></pre>
<p>and should be able to initialize MyThing with:</p>
<pre><code>mt = new MyThing(make_ode_helper(k, tau), y0)
</code></pre>
<p>then you could call this helper with only y and u parameters:</p>
<pre><code>someresult = ode_helper(y, u)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Solution with lambdas</h1>
<p>It looks like I can make this work using lambdas to generate unique function handles when I initialize my objects. For compatibility with <code>odeint</code>, I need to define my functions so that the first two arguments are time and initial state:</p>
<pre><code>def my_ode(t, y, u, K, tau):
  return K*u/tau - y/tau  # dydt
</code></pre>
<p>Next I can initialize objects of <code>MyThing</code> using lambdas to set <code>K</code> and <code>tau</code> as:</p>
<pre><code>thing1 = MyThing(lambda t, y, u: my_ode(t, y, u, 10.0, 0.5), 0.0)
</code></pre>
<p>The function handle that gets assigned to <code>thing1.ode</code> is now the function handle returned by the lambda (this may not be the right way to say this) with values for <code>K</code> and <code>tau</code> set. Now in <code>thing1.update</code>, I need to make some changes to get it to work with <code>odeint</code>:</p>
<pre><code>def update(self, t_step, t_end, u):
  t_array = np.arange(self.time, t_end, t_step)  # time values at which to evaluate ODE
  response = scipy.integrate.odeint(self.ode, self.y, t_array, (u,))
  self.y = response[-1]  # current state is the last evaluated state
</code></pre>
<p>One thing that tripped me up a bit is that any extra arguments to your ODE need to be passed as a tuple to <code>odeint</code>. This seems to work pretty well for what I want. </p>
<p>There is also the more object-oriented approach using <a href="http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.ode.html" rel="nofollow noreferrer"><code>scipy.integrate.ode</code></a>, which allows for step-wise integration of the function and is great for my simulation purposes. For this, I set the object's ODE and update it with something like:</p>
<pre><code>class MyThing():
  def __init__(self, ode, y0):
    self.ode = integrate.ode(ode)  # define the ODE
    self.ode.set_integrator("dopri5")  # choose an integrator
    self.ode.set_initial_value(y0)

  def update(self, u, t_step):
    """Update the ODE step-wise."""
    self.ode.set_f_params(u)  # need to pass extra parameters with this method
    self.ode.integrate(self.ode.t + t_step)  # step-wise update
    return self.ode.successful()

  def get_output(self):
    """Get output from ODE function."""
    return self.ode.y
</code></pre>
</div>
<span class="comment-copy">Maybe you should take a look a the <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>partial</code></a> function of <code>functools</code> module, it may be useful in your case.</span>
<span class="comment-copy">Can I just initialize my object with <code>thing = MyThing(lambda t, y, u: my_ode(K1, tau1, t, y, u), y0)</code>, providing values for <code>K1</code> and <code>tau1</code> at initialization? Will these values then persist? I am not yet at a place where I can test it in my code.</span>
<span class="comment-copy">Could I then call <code>self.ode(y, u)</code> as shown in your example, since the lambda function returned by <code>make_ode_helper</code> will be assigned to this attribute of my class? I think this is what I am looking for if so!</span>
<span class="comment-copy">Most probably yes, give it a try.</span>
