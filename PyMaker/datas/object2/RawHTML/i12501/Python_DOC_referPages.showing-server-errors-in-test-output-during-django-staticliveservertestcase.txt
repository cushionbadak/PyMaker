<div class="post-text" itemprop="text">
<p>Is there a way to show the errors that occurred on the server during a StaticLiveServerTestCase directly in the test feedback? That being, when some server function call errors and page just doesn't show up, the test execution by default has no knowledge of the server error. Is there someway to pass that output onto the testing thread?</p>
<p>Preferably the these errors would show up in the same place that errors directly in the test code execution show up. If this isn't (easily) possible though, what's the next best way to quickly see those server errors?</p>
<p>Thanks!</p>
<p><strong>Code (as requested):</strong></p>
<pre><code>class TestFunctionalVisitor(StaticLiveServerTestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_visitor(self):
        self.browser.get(self.live_server_url)
        self.assertEqual(self.browser.title, "Something")

...

class Home(TemplateView):
    template_name = 'home.html'

    def get_context_data(self):
        context = {}
        MyModel = None
        context['my_models'] = MyModel.objects.all()
        return context
</code></pre>
<p>This has been significantly altered to make it simple and short. But when <code>MyModel</code> is <code>None</code> and tries to call <code>objects.all()</code> the server has a server 500 error, but all I get is the <code>"Something" not in self.browser.title</code> error from the test output, when I'd like to see the <code>NoneType has no...</code> error in the test output.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is exactly why <a href="http://googletesting.blogspot.com/2015/04/just-say-no-to-more-end-to-end-tests.html" rel="nofollow">it is recommended</a> to have much more unit tests than integration and UI/end-to-end. Aside from other things, the latter don't provide you with a specific feedback and you often need more time debugging and investigating why a UI test failed. On the other hand, when a unit test fails, it is usually a failure or an exception pointing you to a specific line in the code - you get the "What went wrong" answer right away.</p>
<p>In other words, the point is: <em>Cover this particular problem with unit tests</em> leaving your UI test as is.</p>
<hr/>
<p>To help you gather more information about the <code>"Something" not in self.browser.title</code> failure, <em>turn the logging on and log as much details as possible</em>. You may also use the <a href="https://docs.djangoproject.com/en/1.9/howto/error-reporting/#error-reporting" rel="nofollow">built-in Error Reporting</a> and, for instance, let Django send you an email on 500 error. In other words, collect all the details and troubleshoot the failure manually.</p>
</div>
<div class="post-text" itemprop="text">
<p>To see the errors immediately, run the test in DEBUG mode:</p>
<pre><code>from django.test.utils import override_settings

@override_settings(DEBUG=True)
class DjkSampleTestCase(StaticLiveServerTestCase):
    # fixtures = ['club_app_phase01_2017-01-09_13-30-19-169537.json']

    reset_sequences = True
</code></pre>
<p>But one should also configure logging of server-side errors, either via custom <code>django.core.handlers.base.BaseHandler</code> class <code>handle_uncaught_exception()</code> method implementation or via sentry.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use to override the default logger using:</p>
<pre><code>import logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s -%(filename)s:%(lineno)d - %(message)s')
</code></pre>
<p>This will display stderr on your terminal. You can even do:</p>
<pre><code>logging.debug('My var %s', var)
</code></pre>
<p>I only do this for debugging, if you want to use logging for non-debugging things I'd suggest to create custom loggers.</p>
<p>More details about logging:</p>
<ul>
<li><a href="https://docs.djangoproject.com/en/1.10/topics/logging/" rel="nofollow noreferrer">https://docs.djangoproject.com/en/1.10/topics/logging/</a></li>
<li><a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html</a></li>
</ul>
</div>
<span class="comment-copy">Can you please show your code?</span>
<span class="comment-copy">@MedhatGayed: I added an (abridged) example of my code.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/8159414/how-do-i-debug-error-500s-served-up-by-the-django-test-server">How do I debug error 500's served up by the DJango test server?</a></span>
<span class="comment-copy">I do plan to have more unit tests. But I'm actually trying out TDD and so I'm writing the functional test which leads me to what unit test I should be writing next. So these unit tests will go in place soon. But there's not a particularly good way to get these unit tests to show up in the output easily without manually looking somewhere else? (I'm mostly talking about local testing if that makes any difference)</span>
<span class="comment-copy">Oops, perhaps my IDE was just being a bit too "smart". It looks like the errors I was looking for were already being shown in the console output, but when clicking on the specific test I only saw the output of the client part of the test.</span>
<span class="comment-copy">@JennyShoars good to hear you've found the server-side errors logged. You should probably add some details, make an answer and accept it. Hope my answer was at least partially helpful. Thanks.</span>
<span class="comment-copy">It was, but I'm going to leave this open for a couple more days simply because there are other logging options that someone might have a clever idea about.</span>
<span class="comment-copy">@user1158559 of course, and this is not a comment.</span>
