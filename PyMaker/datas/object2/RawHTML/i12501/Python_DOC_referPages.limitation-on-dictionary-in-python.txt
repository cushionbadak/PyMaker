<div class="post-text" itemprop="text">
<p>Does anyone know how the built in dictionary type for python is implemented?  My understanding is that it is some sort of hash table, but I haven't been able to find any sort of definitive answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is everything about Python dicts that I was able to put together (probably more than anyone would like to know; but the answer is comprehensive). </p>
<ul>
<li>Python dictionaries are implemented as <strong>hash tables</strong>.</li>
<li>Hash tables must allow for <strong>hash collisions</strong> i.e. even if two distinct keys have the same hash value, the table's implementation must have a strategy to insert and retrieve the key and value pairs unambiguously.</li>
<li>Python <code>dict</code> uses <strong>open addressing</strong> to resolve hash collisions (explained below) (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c#l296" rel="noreferrer">dictobject.c:296-297</a>).</li>
<li>Python hash table is just a contiguous block of memory (sort of like an array, so you can do an <code>O(1)</code> lookup by index). </li>
<li><strong>Each slot in the table can store one and only one entry.</strong> This is important.</li>
<li>Each <strong>entry</strong> in the table actually a combination of the three values: <strong>&lt; hash, key, value &gt;</strong>. This is implemented as a C struct (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Include/dictobject.h#l51" rel="noreferrer">dictobject.h:51-56</a>).</li>
<li><p>The figure below is a logical representation of a Python hash table. In the figure below, <code>0, 1, ..., i, ...</code> on the left are indices of the <strong>slots</strong> in the hash table (they are just for illustrative purposes and are not stored along with the table obviously!).</p>
<pre><code># Logical model of Python Hash table
-+-----------------+
0| &lt;hash|key|value&gt;|
-+-----------------+
1|      ...        |
-+-----------------+
.|      ...        |
-+-----------------+
i|      ...        |
-+-----------------+
.|      ...        |
-+-----------------+
n|      ...        |
-+-----------------+
</code></pre></li>
<li><p>When a new dict is initialized it starts with 8 <em>slots</em>. (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Include/dictobject.h#l49" rel="noreferrer">dictobject.h:49</a>)</p></li>
<li>When adding entries to the table, we start with some slot, <code>i</code>, that is based on the hash of the key. CPython initially uses <code>i = hash(key) &amp; mask</code> (where <code>mask = PyDictMINSIZE - 1</code>, but that's not really important). Just note that the initial slot, <code>i</code>, that is checked depends on the <em>hash</em> of the key.</li>
<li>If that slot is empty, the entry is added to the slot (by entry, I mean, <code>&lt;hash|key|value&gt;</code>). But what if that slot is occupied!? Most likely because another entry has the same hash (hash collision!)</li>
<li>If the slot is occupied, CPython (and even PyPy) compares <strong>the hash AND the key</strong> (by compare I mean <code>==</code> comparison not the <code>is</code> comparison)  of the entry in the slot against the hash and key of the current entry to be inserted (<a href="http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c#l337" rel="noreferrer">dictobject.c:337,344-345</a>) respectively. If <em>both</em> match, then it thinks the entry already exists, gives up and moves on to the next entry to be inserted. If either hash or the key don't match, it starts <strong>probing</strong>. </li>
<li>Probing just means it searches the slots by slot to find an empty slot. Technically we could just go one by one, <code>i+1, i+2, ...</code> and use the first available one (that's linear probing). But for reasons explained beautifully in the comments (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c#l33" rel="noreferrer">dictobject.c:33-126</a>), CPython uses <strong>random probing</strong>. In random probing, the next slot is picked in a pseudo random order. The entry is added to the first empty slot. For this discussion, the actual algorithm used to pick the next slot is not really important (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c#l33" rel="noreferrer">dictobject.c:33-126</a> for the algorithm for probing). What is important is that the slots are probed until first empty slot is found.</li>
<li>The same thing happens for lookups, just starts with the initial slot i (where i depends on the hash of the key). If the hash and the key both don't match the entry in the slot, it starts probing, until it finds a slot with a match. If all slots are exhausted, it reports a fail.</li>
<li>BTW, the <code>dict</code> will be resized if it is two-thirds full. This avoids slowing down lookups. (see <a href="http://hg.python.org/cpython/file/52f68c95e025/Include/dictobject.h#l64" rel="noreferrer">dictobject.h:64-65</a>)</li>
</ul>
<p>NOTE: I did the research on Python Dict implementation in response to my own <a href="https://stackoverflow.com/questions/9010222/">question</a> about how multiple entries in a dict can have same hash values. I posted a slightly edited version of the response here because all the research is very relevant for this question as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python Dictionaries use <a href="http://en.wikipedia.org/wiki/Hash_table#Open_addressing" rel="nofollow noreferrer">Open addressing</a> (<a href="http://books.google.co.in/books?id=gJrmszNHQV4C&amp;lpg=PP1&amp;hl=sv&amp;pg=PA298#v=onepage&amp;q&amp;f=false" rel="nofollow noreferrer">reference inside Beautiful code</a>)</p>
<p><strong>NB!</strong> <em>Open addressing</em>, a.k.a <em>closed hashing</em> should, as noted in Wikipedia, not be confused with its opposite <em>open hashing!</em></p>
<p>Open addressing means that the dict uses array slots, and when an object's primary position is taken in the dict, the object's spot is sought at a different index in the same array, using a "perturbation" scheme, where the object's hash value plays part.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How are Python's Built In Dictionaries Implemented?</p>
</blockquote>
<p>Here's the short course:</p>
<ul>
<li>They are hash tables.</li>
<li>A new procedure/algorithm, as of Python 3.6, makes them

<ul>
<li>ordered by key insertion, and</li>
<li>take up less space,</li>
<li>at virtually no cost in performance.</li>
</ul></li>
<li>Another optimization saves space when dicts share keys (in special cases).</li>
</ul>
<p>The ordered aspect is unofficial as of Python 3.6, but <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="noreferrer">official in Python 3.7</a>.</p>
<h2>Python's Dictionaries are Hash Tables</h2>
<p>For a long time, it worked exactly like this. Python would preallocate 8 empty rows and use the hash to determine where to stick the key-value pair. For example, if the hash for the key ended in 001, it would stick it in the 1 index (like the example below.) </p>
<pre><code>     hash         key    value
     null        null    null
...010001    ffeb678c    633241c4 # addresses of the keys and values
     null        null    null
      ...         ...    ...
</code></pre>
<p>Each row takes up 24 bytes on a 64 bit architecture, 12 on a 32 bit. (Note that the column headers are just labels - they don't actually exist in memory.)</p>
<p>If the hash ended the same as a preexisting key's hash, this is a collision, and then it would stick the key-value pair in a different location.</p>
<p>After 5 key-values are stored, when adding another key-value pair, the probability of hash collisions is too large, so the dictionary is doubled in size. In a 64 bit process, before the resize, we have 72 bytes empty, and after, we are wasting 240 bytes due to the 10 empty rows.</p>
<p>This takes a lot of space, but the lookup time is fairly constant. The key comparison algorithm is to compute the hash, go to the expected location, compare the key's id - if they're the same object, they're equal. If not then compare the hash values, if they are <em>not</em> the same, they're not equal. Else, then we finally compare keys for equality, and if they are equal, return the value. The final comparison for equality can be quite slow, but the earlier checks usually shortcut the final comparison, making the lookups very quick.</p>
<p>(Collisions slow things down, and an attacker could theoretically use hash collisions to perform a denial of service attack, so we randomized the hash function such that it computes a different hash for each new Python process.)</p>
<p>The wasted space described above has led us to modify the implementation of dictionaries, with an exciting new (if unofficial) feature that dictionaries are now ordered (by insertion).</p>
<h2>The New Compact Hash Tables</h2>
<p>We start, instead, by preallocating an array for the index of the insertion.</p>
<p>Since our first key-value pair goes in the second slot, we index like this:</p>
<pre><code>[null, 0, null, null, null, null, null, null]
</code></pre>
<p>And our table just gets populated by insertion order:</p>
<pre><code>     hash         key    value
...010001    ffeb678c    633241c4 
      ...         ...    ...
</code></pre>
<p>So when we do a lookup for a key, we use the hash to check the position we expect (in this case, we go straight to index 1 of the array), then go to that index in the hash-table (e.g. index 0), check that the keys are equal (using the same algorithm described earlier), and if so, return the value.</p>
<p>We retain constant lookup time, with minor speed losses in some cases and gains in others, with the upside that we save quite a lot of space over the pre-existing implementation. The only space wasted are the null bytes in the index array.</p>
<p>Raymond Hettinger introduced this to <a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html" rel="noreferrer">python-dev</a> in December of 2012. It finally got into CPython in <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation" rel="noreferrer">Python 3.6</a>. Ordering by insertion is still considered an implementation detail to allow other implementations of Python a chance to catch up.</p>
<h2>Shared Keys</h2>
<p>Another optimization to save space is an implementation that shares keys. Thus, instead of having redundant dictionaries that take up all of that space, we have dictionaries that reuse the shared keys and keys' hashes. You can think of it like this:</p>
<pre><code>     hash         key    dict_0    dict_1    dict_2...
...010001    ffeb678c    633241c4  fffad420  ...
      ...         ...    ...       ...       ...
</code></pre>
<p>For a 64 bit machine, this could save up to 16 bytes per key per extra dictionary.</p>
<h2>Shared Keys for Custom Objects &amp; Alternatives</h2>
<p>These shared-key dicts are intended to be used for custom objects' <code>__dict__</code>. To get this behavior, I believe you need to finish populating your <code>__dict__</code> before you instantiate your next object (<a href="https://www.python.org/dev/peps/pep-0412/" rel="noreferrer">see PEP 412</a>). This means you should assign all your attributes in the <code>__init__</code> or <code>__new__</code>, else you might not get your space savings.</p>
<p>However, if you know all of your attributes at the time your <code>__init__</code> is executed, you could also provide <code>__slots__</code> for your object, and guarantee that <code>__dict__</code> is not created at all (if not available in parents), or even allow <code>__dict__</code> but guarantee that your foreseen attributes are stored in slots anyways. For more on <code>__slots__</code>, <a href="https://stackoverflow.com/q/472000/541136">see my answer here</a>.</p>
<h2>See also:</h2>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0509/" rel="noreferrer">PEP 509</a> -- Add a private version to dict</li>
<li><a href="https://www.python.org/dev/peps/pep-0468/" rel="noreferrer">PEP 468</a> -- Preserving the order of <code>**kwargs</code> in a function.</li>
<li><a href="https://www.python.org/dev/peps/pep-0520/" rel="noreferrer">PEP 520</a> -- Preserving Class Attribute Definition Order</li>
<li><a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" rel="noreferrer">PyCon 2010: The Might Dictionary</a> - Brandon Rhodes</li>
<li><a href="https://www.youtube.com/watch?v=66P5FMkWoVU" rel="noreferrer">PyCon 2017: The Dictionary Even Mightier</a> - Brandon Rhodes</li>
<li><a href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="noreferrer">PyCon 2017: Modern Python Dictionaries A confluence of a dozen great ideas</a> - Raymond Hettinger</li>
<li><a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c" rel="noreferrer">dictobject.c</a> - CPython's actual dict implementation in C.</li>
</ul>
</div>
<span class="comment-copy">I did experiments in both py2 and py3, by using <code>d={1:1, 1:2, 1:1.5, 1:False}</code>, I will always get a dict <code>{1:False}</code>, which reserves the last item. All the items in the initial statements have the same key and different value, which means their hash of the key are the same. And why it always picks the last item? Does python dict always pick the last item as first entry trying to initialize and ignored the keys with same hash as you mentioned in your answer? If python doesn't pick the last item as the first entry, then the experiment result makes me really confusing.</span>
<span class="comment-copy">Because you have only 1 key and you are over-writing it's value.What you should be checking for is different keys that have the same hash value. Think about it, how will you fetch different values using the same key as the index? If you want multiple values for the same key, you can use a tuple/list.</span>
<span class="comment-copy">You said, when both hash and the key match, it (insert op) gives up and moves on. Doesn't insert overwrite existing entry in this case?</span>
<span class="comment-copy"><i>"not be confused with its opposite open hashing! (which we see in the accepted answer)."</i> - I'm not sure which answer was accepted when you wrote that, or what that answer said at the time - but this parenthesised comment is not currently true of the accepted answer and would best be removed.</span>
<span class="comment-copy">You said "we", and "to allow other implementations of Python a chance to catch up" - does this mean you "know things" and that that might become a permanent feature? Is there any downside to dicts being ordered by spec?</span>
<span class="comment-copy">The downside to being ordered is that if dicts are expected to be ordered they can't easily switch to a better/faster implementation that isn't ordered. It seems unlikely that will be the case though. I "know things" because I watch lots of talks and read lots of things written by core members and others with a better real-world reputation than me, so even if I don't have an immediately available source to cite, I usually know what I'm talking about. But I think you can get that point from one of Raymond Hettinger's talks.</span>
<span class="comment-copy">You explained somewhat vaguely how insertion works ("If the hash ended the same as a preexisting key's hash, ... then it would stick the key-value pair in a different location" -- any?), but you didn't explain how lookup and membership test work.  It is not quite clear how the location is determined by the hash either, but i suppose that the size is always a power of 2, and you take the last few bits of the hash...</span>
<span class="comment-copy">@Alexey The last link I provide gives you the well-annotated dict implementation - where you can find the function that does this, currently on line 969, called <code>find_empty_slot</code>: <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c#L969" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/dictobject.c#L969</a> - and starting on line 134 there's some prose that describes it.</span>
