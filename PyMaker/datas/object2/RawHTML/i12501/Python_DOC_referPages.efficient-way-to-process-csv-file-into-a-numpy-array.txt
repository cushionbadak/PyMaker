<div class="post-text" itemprop="text">
<p>CSV file may not be clean (lines with inconsistent number of elements), unclean lines would need to be disregarded.
String manipulation is required during processing.</p>
<p>Example input:</p>
<pre><code>20150701 20:00:15.173,0.5019,0.91665
</code></pre>
<p>Desired output: float32 (pseudo-date, seconds in the day, f3, f4)</p>
<pre><code>0.150701 72015.173 0.5019 0.91665 (+ the trailing trash floats usually get)
</code></pre>
<p>The CSV file is also very big, the numpy array in memory would be expected to take 5-10 GB, CSV file is over 30GB.</p>
<p>Looking for an efficient way to process the CSV file and end up with a numpy array.</p>
<p>Current solution: use csv module, process line by line and use a list() as a buffer that later gets turned to numpy array with asarray(). Problem is, during the turning process memory consumption is doubled and the copying process adds execution overhead.</p>
<p>Numpy's genfromtxt and loadtxt don't appear to be able to process the data as desired.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know in advance how many rows are in the data, you could dispense with the intermediate <code>list</code> and write directly to the array.</p>
<pre><code>import numpy as np

no_rows = 5
no_columns = 4

a = np.zeros((no_rows, no_columns), dtype = np.float)

with open('myfile') as f:
    for i, line in enumerate(f):
        a[i,:] = cool_function_that_returns_formatted_data(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>did you think for using pandas read_csv (with engine='C')</p>
<p>I find it as one of the best and easy solutions to handling csv. I worked with 4GB file and it worked for me. </p>
<pre><code>import pandas as pd
df=pd.read_csv('abc.csv',engine='C')
print(df.head(10))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think <a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-tools-text-csv-hdf5" rel="nofollow">i/o capability of pandas</a> is the best way to get data into a numpy array. Specifically the <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html#pandas.read_csv" rel="nofollow">read_csv</a> method will read into a pandas DataFrame. You can then access the underlying numpy array using the <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.as_matrix.html?highlight=as_matrix#pandas.DataFrame.as_matrix" rel="nofollow">as_matrix</a> method of the returned <code>DataFrame</code>. </p>
</div>
<span class="comment-copy">can you post your code?</span>
<span class="comment-copy">Do (Can) you know, in advance, how many <i>rows</i> the final array has?</span>
<span class="comment-copy">Take a look at  [pandas.read_csv] (<a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.read_csv.html#pandas.read_csv" rel="nofollow noreferrer">pandas.pydata.org/pandas-docs/version/0.17.1/generated/â€¦</a>). There is a lot of tools for dates format  in particular.</span>
<span class="comment-copy">Counting lines is trivial unless it's a tape drive, I was hoping there was some way in python to use a buffer you can expand and then treat it as a numpy array, but failing that your solution is what comes to mind and provided that the number of bad lines is not large, very efficient.</span>
<span class="comment-copy">@dingrite - you have to process the string data before putting it into an array and I understood that there were memory constraints that couldn't handle two copies of the data.  So it seems like you need to process the data in chunks and add to an existing array.  Did you try a <code>pandas</code> solution as suggested by others?  Maybe there is a way with somthing in the IO module or with <a href="https://docs.python.org/3/library/mmap.html" rel="nofollow noreferrer"><code>mmap</code></a> which I really don't quite understand.</span>
<span class="comment-copy">Can you give an example of that?  The documentation doesn't show anything other than examples where out=None.  I think it's supposed to look something like np.divide(train_inputs, 255, out=train_inputs), with no return value.  But I get an error: TypeError: No loop matching the specified signature and casting</span>
