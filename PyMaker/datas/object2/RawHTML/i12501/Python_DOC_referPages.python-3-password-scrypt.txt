<div class="post-text" itemprop="text">
<p>Hello i am looking for some assistance making my password script for python 3. I have a basic understanding of the program but python is a new language for me. I am trying to make an AI for the assisted moving suit my friend and I build consisting of old bike parts such as gears and chains, Dc motors, and lots and lots of metal bars... For the heavy duty things we are using an arduino but my friend is in charge of that part.. I have worked on the AI but before i go any further i was wondering if anyone could help me make a pass code scrip. I am actually using a raspberry pi because i know how to operate the GPIO (or general purpose input output. I have tried using things like:</p>
<pre><code>The_man113 = 'Password correct'
else:
     print'passcode incorrect'
</code></pre>
<p>this is a bad example that i know wont work but can someone please give me some suggestions. I know how to use things like making a calculator or making  something act like it knows everything about just by adding a few numbers in the background but this one really stumped me. I appreciate anyone that helps me. Thank you </p>
</div>
<div class="post-text" itemprop="text">
<p>Well, if the goal is just to verify a single password (no password DB), but you don't want to store that password in the script (where anyone who can read the file can see it), you can use hashing. First, decide on a password, then generate a salt and hash (passing the hash method generates an appropriate salt implicitly):</p>
<pre><code>&gt;&gt;&gt; import crypt
&gt;&gt;&gt; password = input("Enter password:")
&gt;&gt;&gt; print(crypt.crypt(password, crypt.METHOD_SHA512)) # Save this to add to verifier
</code></pre>
<p>We use <code>input</code> instead of actually initializing the variable directly in the terminal because as of 3.4, the Python interactive terminal saves history by default, and we don't want the password in the Python history. We'll accept the risk of shoulder surfing at generation time in exchange for knowing you didn't make a typo (at use time, we'll use <code>getpass.getpass</code> to foil shoulder surfers).</p>
<p>Now in your verification code:</p>
<pre><code>import crypt
import getpass

PASSHASH = '...'  # Hash from generation stage

# Loop until correct password given or user hits Ctrl-C to kill program
# crypt.crypt hashes include their salt, and can be used to salt another crypt
while crypt.crypt(getpass.getpass(), PASSHASH) != PASSHASH:
    pass

# If we get here, the password was correct
print("Password accepted")
</code></pre>
<p>This design means users who can see the source code can't see the password; as long as they can't overwrite the file, they can't change the password either.</p>
<p>By using <a href="https://docs.python.org/3/library/getpass.html#getpass.getpass" rel="nofollow"><code>getpass.getpass</code></a> instead of <code>input</code>, you also avoid echoing the password as it is being typed, which minimizes the risk of shoulder surfers seeing the password.</p>
<p>Note: This code requires Python 3.3 or higher; the <a href="https://docs.python.org/3/library/crypt.html" rel="nofollow"><code>crypt</code> module</a> is no good for secure password hashing before then since it uses <code>crypt(3)</code>, a known weak password hashing system.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way is using a one-way Cryptographic hash function, for instance: sha-256.</p>
<p>From <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="nofollow">wikipedia</a>:</p>
<blockquote>
<p>A cryptographic hash function is a hash function which is considered
  practically impossible to invert, that is, to recreate the input data
  from its hash value alone.</p>
</blockquote>
<p>Python has a built-in library for that: <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow">hashlib</a>.</p>
<p>You have to store a previously hashed password inside your code:</p>
<pre><code>secure_hash = hashlib.sha256("This is the original password that will be hashed").hexdigest()
</code></pre>
<p>This code will output this:</p>
<pre><code>759deb001f7fc1fceea917efd3b3dc7628f3b67633c7b77a2b77a7c3afa736a8
</code></pre>
<p>You will store this hashed string inside your script, then when the user "logs in" you do the same operation with the user password and compare:</p>
<pre><code>password_hash = hashlib.sha256("Incorrect password from the user").hexdigest()
</code></pre>
<p>Then compare:</p>
<pre><code>if secure_hash != password_hash:
    print("Incorrect password")
    ...
</code></pre>
<p>There are some caveats, though...
One way encryption functions are not perfect, there is a very very very small chance that two different string have the same hash, this chance is really small but it exists.</p>
<p>Note:
If you have a TypeError when using hashlib, you must encode your string to utf-8:</p>
<pre><code>secure_hash = hashlib.sha256("This is the original password that will be hashed".encode("utf-8")).hexdigest()
</code></pre>
<p>And... you must <strong>not</strong> store the string you use to create the secure_hash in your script.</p>
</div>
<span class="comment-copy"><code>if raw_input("Enter password:") != "hunter2": print "access denied"</code>.</span>
<span class="comment-copy">(oops, that's for 2.7. Use <code>input</code> instead of <code>raw_input</code> for Python 3, and properly parenthesize your <code>print</code> calls)</span>
<span class="comment-copy">Unsalted password hashes are subject to precomputed table attacks. Plain hashes, even cryptographic hashes, are not sufficient to prevent hash reversal. There is a reason Python provides <code>crypt</code> and <code>hashlib.pbkdf2_hmac</code>.</span>
<span class="comment-copy">I would agree if we were talking about an internet connected device, since we are talking about some type of assistive hardware, like a wheelchair, unless the hacker would phisically be hacking the hardware through an usb port, i dont think there is need for the extra measures.</span>
