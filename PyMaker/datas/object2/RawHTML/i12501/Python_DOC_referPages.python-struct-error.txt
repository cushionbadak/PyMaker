<div class="post-text" itemprop="text">
<p>I'm trying to design a system to react to different binary flags.</p>
<pre><code>0 = Error
1 = Okay
2 = Logging
3 = Number
</code></pre>
<p>The sequence of this data represents a unique ID to reference the work, the flag and the number. Everything works, except the number flag. This is what I get...</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; data = (1234, 3, 12345678)
&gt;&gt;&gt; bin = struct.pack('QHL', *data)
&gt;&gt;&gt; print(bin)
b'\xd2\x04\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00Na\xbc\x00\x00\x00\x00\x00'
&gt;&gt;&gt; result = struct.unpack_from('QH', bin, 0)
&gt;&gt;&gt; print(result)
(1234, 3)
&gt;&gt;&gt; offset = struct.calcsize('QH')
&gt;&gt;&gt; result += struct.unpack_from('L', bin, offset)
&gt;&gt;&gt; print(result)
(1234, 3, 7011541669862440960)
</code></pre>
<p>A long should be plenty big to represent the number <code>12345678</code>, but why is it incorrectly unpacked?</p>
<p><strong>Edit:</strong></p>
<p>When I try to pack them separately, it looks like struct is adding too many null bytes between the flag and the long.</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('QH', 1234, 3)
b'\xd2\x04\x00\x00\x00\x00\x00\x00\x03\x00'
&gt;&gt;&gt; struct.pack('L', 12345678)
b'Na\xbc\x00\x00\x00\x00\x00'
</code></pre>
<p>I can reproduce this error by adding padding before the long.</p>
<pre><code>&gt;&gt;&gt; struct.unpack('L', struct.pack('L', 12345678))
(12345678,)
&gt;&gt;&gt; struct.unpack('xL', struct.pack('xL', 12345678))
(12345678,)
&gt;&gt;&gt; struct.pack('xL', 12345678)
b'\x00\x00\x00\x00\x00\x00\x00\x00Na\xbc\x00\x00\x00\x00\x00'
</code></pre>
<p><strong>Potential fix?</strong></p>
<p>When I use little-endian order, the problem seems to correct itself and make the binary string shorter. Since this is destined for a SSL wrapped TCP socket, that's a win win, right? Keeping bandwidth low is generally good, yes?</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; data = (1234, 3, 12345678)
&gt;&gt;&gt; bin = struct.pack('&lt;QHL', *data)
&gt;&gt;&gt; print(bin)
b'\xd2\x04\x00\x00\x00\x00\x00\x00\x03\x00Na\xbc\x00'
&gt;&gt;&gt; result = struct.unpack_from('&lt;QH', bin, 0)
&gt;&gt;&gt; print(result)
(1234, 3)
&gt;&gt;&gt; offset = struct.calcsize('&lt;QH')
&gt;&gt;&gt; result += struct.unpack_from('&lt;L', bin, offset)
&gt;&gt;&gt; print(result)
(1234, 3, 12345678)
</code></pre>
<p>Why does this happen? I am perplexed.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are running into byte alignment issues. You need to know that by default the individual parts of a struct are not just placed next to each other but they are properly aligned in memory. This makes it more efficient, especially for other applications, as they have more direct way to access individual bytes from it without having to account for overlap.</p>
<p>You can easily see this by using <a href="https://docs.python.org/3/library/struct.html#struct.calcsize"><code>struct.calcsize</code></a> to see the required space needed to encode using a format:</p>
<pre><code>&gt;&gt;&gt; struct.calcsize('QHL')
16
&gt;&gt;&gt; struct.calcsize('QH')
10
</code></pre>
<p>As you can see <code>QHL</code> requires 16 bytes, but <code>QH</code> requires 10. The <code>L</code> we left off is however only 4 bytes wide. So there is some padding going to on make sure that the <code>L</code> starts again on “a fresh block”. This is because any type requires (with padding) that it starts on a offset that is a multiple of its own size. For <code>QH</code> it looks like this:</p>
<pre><code>QQ QQ | QQ QQ | HH
</code></pre>
<p>Once you use <code>QHL</code>, you get the following:</p>
<pre><code>QQ QQ | QQ QQ | HH 00 | LL LL
</code></pre>
<p>As you can see, there were two padding bytes added to make sure that <code>L</code> starts on a new block of four.</p>
<p>You can modify the alignment (as well as the endianness) using a special character at the beginning of the format string. In your case, you could use <code>=QHL</code> to disable alignment altogether:</p>
<pre><code>QQ QQ | QQ QQ | HH LL | LL
</code></pre>
<hr/>
<blockquote>
<p>When I use little-endian order, the problem seems to correct itself and make the binary string shorter. Since this is destined for a SSL wrapped TCP socket, that's a win win, right? Keeping bandwidth low is generally good, yes?</p>
</blockquote>
<p>Using an explicit byte order <a href="https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment">also disables alignment</a> yes, so that’s where the effect comes from. If it’s a good idea to turn of alignment depends though. If you want to use consume your data somewhere else, in other programs, it would be a good idea to stick to native alignment.</p>
</div>
<div class="post-text" itemprop="text">
<p>The correct output in your case:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; data = (1234, 3, 12345678)
&gt;&gt;&gt; bin = struct.pack('QHL', *data)
&gt;&gt;&gt; print(bin)
b'\xd2\x04\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00Na\xbc\x00\x00\x00\x00\x00'
&gt;&gt;&gt; result = struct.unpack_from('QH', bin, 0)
&gt;&gt;&gt; print(result)
(1234, 3)
&gt;&gt;&gt; result += struct.unpack_from('L', bin, 16)
&gt;&gt;&gt; print(result)
(1234, 3, 12345678)
</code></pre>
<p>This happens because:</p>
<blockquote>
<p>Padding is only automatically added between successive structure members.</p>
</blockquote>
<p>Also, the reason your fix works is:</p>
<blockquote>
<p>No padding is added when using non-native size and alignment, e.g. with ‘&lt;’, ‘&gt;’, ‘=’, and ‘!’.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It is a byte alignment issue. In your case the following replacement will give you the correct output.</p>
<pre><code>result += struct.unpack_from('L', bin, offset+2)
</code></pre>
</div>
<span class="comment-copy">excuse my ignorance: <code>hex(12345678)</code> is  <code>0xbc614e</code>, which looks quite different than <code>Na\xbc\x00\x00\x00\x00\x00</code>. Why is that? What's the meaning of <code>Na</code>? <code>struct.pack('L', 65536*1024)</code> gives <code>\x00\x00\x00\x04\x00\x00\x00\x00</code>, correctly (same order of magnitude as 12345678)</span>
<span class="comment-copy">@Pynchia Yea, my point exactly! I don't know what is going on. I read somewhere else that this module might be bugged.</span>
<span class="comment-copy">FYI: <code>bin()</code> is a builtin function, which you hide by overwriting it.</span>
<span class="comment-copy">@Pynchia <code>hex()</code> returns an integer, while <code>struct</code> returns a byte string. If you take the bytes from <code>0x00bc614e</code> and align them in the proper way (=reversed) in a byte string like so: <code>b'\x4e\x61\xbc\x00'</code> then you get back <code>b'Na\xbc\x00'</code>. The <code>Na</code> is simply the ASCII-rendered version of <code>\x4e\x61</code>.</span>
<span class="comment-copy">Thank you all for helping!</span>
<span class="comment-copy">This data will be packed on one computer with Python and unpacked on another using Python as well. Does that man alignment isn't as important?</span>
<span class="comment-copy">As long as you’re using the same platform-independent format on all machines, then yes, disabling alignment is fine.</span>
