<div class="post-text" itemprop="text">
<p>I have written a Python class for parsing a specialized text format. </p>
<pre><code>class Parser(object):

   def __init__(self):
       # Initialize parser instance


   def parseFile(self , filename):
       pass

   def modifyParser(self , *args , **kwargs):
       pass 

   #Classmethod has same name as instance method - this does not work.
   @classmethod 
   def parseFile(cls , filename)
       parser = Parser( )
       return parser.parseFile( filename )
</code></pre>
<p>As indicated the parser can be modified with the <code>modifyParser</code> method - but in most cases I will just use the Parser instance as it comes from the <code>Parser.__init__()</code>. I would like to be able to do this:</p>
<pre><code># Parse file using 'custom' parser:
parser = Parser( )
parser.modifyParser( ... )
result = parser.parseFile("file.input")


# Parse using the default parser - do not explicitly instantiate an object:
result = Parser.parseFile("file.input")
</code></pre>
<p>This requires that the <code>parseFile( )</code> method can be called both as an instance method - with a <code>self</code> - and as a classmethod. Is this possible? Bad form?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I were you, I'd offer two distinct functions:</p>
<ol>
<li><code>mymodule.Parser().parseFile()</code> (instance method), and</li>
<li><code>mymodule.parseFile()</code> (module-level function that uses the default instance).</li>
</ol>
<p>This is what happens for example with the standard <a href="https://docs.python.org/3/library/json.html"><code>json</code></a> module, where you have <code>json.JSONDecoder().decode()</code> and <code>json.loads()</code>. Offering two distinct functions makes the code less ambiguous, more explicit and more predictable (in my opinion).</p>
<p>However, yes: what you want to do is possible. You have to implement your own <a href="https://docs.python.org/3/howto/descriptor.html">descriptor</a> using <code>__get__</code>. Here's an example:</p>
<pre><code>from functools import partial

class class_and_instance_method(object):

    def __init__(self, func):
        self.func = func

    def __get__(self, obj, type=None):
        first_arg = obj if obj is not None else type
        return partial(self.func, first_arg)

class Parser(object):

    @class_and_instance_method
    def parseFile(self):
        if isinstance(self, type):
            print('using default parser')
        else:
            print('using the current instance')
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; Parser.parseFile()
using default parser
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; p = Parser()
&gt;&gt;&gt; p.parseFile()
using the current instance
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to use two separate names. In python due to it's dynamic nature there's no operator overloading as in C++, when one function has same name with different arguments.</p>
<p>When you say <code>def</code> in your script, you tell Python "set the following object(function object) to this name". So in your code you just redefine the name to reference <code>classmethod</code> and your instance method function object is lost.</p>
<p>Solution: use different names for instace method and class method.</p>
</div>
<span class="comment-copy">IMO, I would skip the class method unless you had an absolute need for it, and just use <code>result = Parser().parseFile("file.input")</code>.</span>
<span class="comment-copy">Yes - I see that the alternative with a module level function works - it does not sit nicely with my current scheme for imports++. I tried to look at the descriptor documentation - that was quite terse; do you have a three line tip?</span>
<span class="comment-copy">@user422005: I provided an example</span>
<span class="comment-copy">Thanks a lot - that worked perfectly!</span>
