<div class="post-text" itemprop="text">
<p>Help me. I'm stuck. I have a <code>class</code> of <code>point</code>. The attributes of that class are <code>lat</code>, <code>Long</code>, <code>point_id</code>, <code>name</code>. There some points that has same <code>Lat</code>, and <code>Long</code>. So, i need <code>point_id</code> as points identity. Actually, I want to get nearest neighbor of my point using tree of <code>kdTree</code>. I have no problem when I construct <code>kdTree</code>, but when I want to know my point nearest neighbor, the result is list <code>(Lat,Long)</code> of nearest neighbor whereas I want <code>point_id</code> as my result because there are some points have same <code>Lat</code>, and <code>Long</code>. </p>
<p>This is my code: </p>
<pre><code>import numpy as np
from scipy import spatial
import psycopg2
import math
import psycopg2.extensions   

class Point:
def __init__(self, id_point, name, Lat, Long):
    self.id_point=id_point
    self.name=name
    self.Lat=Lat
    self.Long=Long

def Struktur_KdTree(points):
    tree= spatial.KDTree(points)
    return tree

def getNearestPoint(tree,point,radius):
    return tree.query_ball_point(point,radius)

try:
   conn = psycopg2.connect("dbname='Chicago_crime' user='postgres' host='localhost' password='1234'")
except :
    print "I'm unable to connect to the database"

cur = conn.cursor()
cur.execute("""SELECT id_objek, primary_descript, lat, long from data_crime""")

data = []
Lat = []
Long = []
for id_jenis, jenis, lat, long in cur.fetchall():
     data.append(Point(id_point,name,Lat,Long))
     Lat.append(lat)
     Long.append(long)

dataPoints = zip (Lat,Long)

tree = Struktur_KdTree(dataPoints)
result=[]
radius=2
for point in dataPoint:
   result.append(getNearestPoint(tree,point,radius))
</code></pre>
<p>Please give me any suggestion? </p>
</div>
<div class="post-text" itemprop="text">
<p>Use a dict (or <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow">collections.defaultdict</a>) to record a mapping from <code>(lat, lng)</code> tuples to lists of <code>Points</code>.
Armed with this dict (let's call it <code>pointmap</code>), given a <code>(lat, lng)</code> you will
be able to look up all the <code>Points</code> at that location.</p>
<pre><code>pointmap = collections.defaultdict(list)
locations = set()
for id_jenis, jenis, lat, lng in np.random.randint(10, size=(N, 4)):
    point = Point(id_jenis, jenis, lat, lng)
    pointmap[lat, lng].append(point)
</code></pre>
<p>The keys in the <code>pointmap</code> dict are <code>(lat, lng)</code> tuples which we can form into a NumPy array to be passed to <code>spatial.KDTree</code>:</p>
<pre><code>locations = np.array(pointmap.keys())
tree = spatial.KDTree(locations)
</code></pre>
<p>Now, we can iterate through each location and find
the nearest points:</p>
<pre><code>for loc in locations:
    indices = getNearestPoint(tree, loc, radius)
</code></pre>
<p>Note that <code>query_ball_point</code> returns a list of indices (that index into
<code>locations</code>). The actual locations are given by <code>locations[indices]</code>. Here we're
taking advantage of NumPy fancy indexing -- made possible because <code>locations</code> is
a NumPy array.</p>
<p>For each location in <code>location[indices]</code>, we can now obtain a list of <code>Points</code> by looking up the associated point using our dict, <code>pointmap</code>:</p>
<pre><code>near_points = [point for near_loc in locations[indices]
               for point in pointmap[tuple(near_loc)]]
</code></pre>
<hr/>
<p>Putting it all together:</p>
<pre><code>import numpy as np
from scipy import spatial
import collections

class Point:

    def __init__(self, id_point, name, Lat, Long):
        self.id_point = id_point
        self.name = name
        self.Lat = Lat
        self.Long = Long

    def __repr__(self):
        return 'Point({}, {}, {}, {})'.format(
            self.id_point, self.name, self.Lat, self.Long)

def getNearestPoint(tree, point, radius):
    return tree.query_ball_point(point, radius)

pointmap = collections.defaultdict(list)

N = 10
for id_jenis, jenis, lat, lng in np.random.randint(10, size=(N, 4)):
    point = Point(id_jenis, jenis, lat, lng)
    pointmap[lat, lng].append(point)

locations = np.array(pointmap.keys())
tree = spatial.KDTree(locations)

result = []
radius = 2

for loc in locations:
    indices = getNearestPoint(tree, loc, radius)
    near_points = [point for near_loc in locations[indices]
                   for point in pointmap[tuple(near_loc)]]
    print('{} close to {}'.format(loc, near_points))
</code></pre>
<p>yields output like:</p>
<pre><code>[8 3] close to [Point(2, 9, 8, 3)]
[7 1] close to [Point(8, 6, 7, 1), Point(2, 1, 6, 1)]
[4 5] close to [Point(7, 1, 4, 5), Point(4, 9, 3, 6)]
[6 1] close to [Point(8, 6, 7, 1), Point(2, 1, 6, 1)]
[2 0] close to [Point(0, 1, 2, 0), Point(4, 3, 4, 0)]
[3 6] close to [Point(7, 1, 4, 5), Point(4, 9, 3, 6)]
[7 9] close to [Point(1, 9, 7, 9)]
[9 6] close to [Point(8, 5, 9, 6)]
[2 4] close to [Point(4, 4, 2, 4)]
[4 0] close to [Point(0, 1, 2, 0), Point(4, 3, 4, 0)]
</code></pre>
</div>
<span class="comment-copy">Thank you @unutbu . But I get error: <code>Traceback (most recent call last):   File "D:/s2/semester 3/tesis/phyton/Kdtree2.py", line 35, in &lt;module&gt;     tree = spatial.KDTree(locations)   File "C:\Python27\lib\site-packages\scipy\spatial\kdtree.py", line 229, in __init__     self.n, self.m = np.shape(self.data) ValueError: need more than 0 values to unpack</code></span>
<span class="comment-copy">My mistake. When converting a set to a NumPy array, you must convert the set to a tuple or list first: <code>locations = np.array(list(locations))</code>.</span>
<span class="comment-copy">Thank you for your best solution and detail explanation. You save me ðŸ˜ƒðŸ˜ŠðŸ˜Š</span>
