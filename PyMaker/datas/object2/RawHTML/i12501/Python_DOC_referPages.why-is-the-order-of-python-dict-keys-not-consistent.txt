<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15479928/why-is-the-order-in-dictionaries-and-sets-arbitrary">Why is the order in dictionaries and sets arbitrary?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>First of all, I know how to deal with this situation. I am not asking how I can make an <code>OrderedDict</code>. </p>
<p>I am asking why the same dictionary created same way can have different order of keys? What is the logic behind this? Isn't it the exact same code running time-independent and environment-independent? What changes and makes python create a different result?</p>
</div>
<div class="post-text" itemprop="text">
<p>This behavior is detailed in <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>object.__hash__()</code></a>'s specification; it's to prevent certain types of malicious input from breaking applications:</p>
<blockquote>
<p>Note By default, the <code>__hash__()</code> values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.</p>
<p>This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n^2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html" rel="nofollow noreferrer">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
</blockquote>
<p>Before Python 3.3 this wasn't the case, and a dictionary <em>would</em> have the same order between different runs of the same application. </p>
<p>I answered a <a href="https://stackoverflow.com/a/30586046/113632">related question</a> about disabling this behavior, which links to some of the relevant source code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3, <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="nofollow">hash randomization is enabled by default</a> for security reasons. </p>
<p>The concern is that an attacker can feed a specially crafted program input that led to many hash collisions. This will cause the dictionary to perform at worse case scenario and may effectively cause a denial of service on a system.</p>
<p>Many other languages that are often used for web programming also implemented hash randomization in roughly the same timeframe with their respective hash maps.</p>
<p>Prior to hash randomization being implemented, due to collision resolution and internal hash table resizing you may not end always up with the same order if you use different sequence of inserts and removes that produces the same set of final keys, but you'd usually get the same ordering in a dictionary when you insert and remove keys in the same sequence. However, this was an accident of implementation, which was never guaranteed by the language specification.</p>
</div>
<span class="comment-copy">Python dictionaries, as well as the mapping types in many other languages, are implemented using <a href="https://en.wikipedia.org/wiki/Hash_table" rel="nofollow noreferrer">hash tables</a>. If you understand how they work, you will then understand why dictionaries do not have a useful ordering.</span>
<span class="comment-copy">The hash function in Python is quite well defined (here is one explanation <a href="http://www.laurentluce.com/posts/python-dictionary-implementation/" rel="nofollow noreferrer">laurentluce.com/posts/python-dictionary-implementation</a>).  The resulting values from the hash function may vary depending on the underlying hardware (32/64 bit) or  possibly other nuances (endian-ness).  I would expect the order to be the same for the same code running on the same machine using the same version of Python.  However, I would never rely on that.</span>
<span class="comment-copy">@Reti43, ...though the accepted answer there isn't yet accurate for versions of Python implementing hash randomization.</span>
<span class="comment-copy">It's related, but they're not the same question. That is asking "why is the ordering arbitrary", this asking "why is it not consistent (between runs)".</span>
<span class="comment-copy">I think the question is more about why things don't hash the same way each time, end up in the same table slots, and thus end up in the same order, even if that order isn't user-specified / clearly-sorted / etc. That's a more interesting one. :)</span>
<span class="comment-copy">You're right; corrected :)</span>
