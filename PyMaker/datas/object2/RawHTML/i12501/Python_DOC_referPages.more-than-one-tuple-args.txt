<div class="post-text" itemprop="text">
<p>I know you can use <code>*args</code> in Python to allow a tuple or arguments. But how could one have two of these. Like <code>*args</code> and <code>*args1</code>?</p>
<p>Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't have multiple variadic parameters of the same type in a function definition (e.g. <code>def func(*args, *args1)</code>, but, <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="nofollow">in Python 3.5</a>, you can pass arguments in that form when calling a function.</p>
<p>Python 3.4:</p>
<pre><code>&gt;&gt;&gt; print(*range(3), *range(3))
  File "&lt;stdin&gt;", line 1
    print(*range(3), *range(3))
                     ^
SyntaxError: invalid syntax
</code></pre>
<p>Python 3.5:</p>
<pre><code>&gt;&gt;&gt; print(*range(3), *range(3))
0 1 2 0 1 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I assume you mean in terms of function arguments, then no it isn't possible. The reason why is a tuple <code>*args</code> can be of any length of 0 or more arguments. If you had another one, <code>*args2</code>, how would you determined which arguments belong to <code>*args</code> and which to <code>*args2</code>? You can however include a <code>**kwargs</code> which is a dictionary object of keyword arguments. For example:</p>
<pre><code>def my_function(x, *args):
    ...
</code></pre>
<p>You can figure out what the args of <code>*args</code> are. However, in</p>
<pre><code>def my_function2(x, *args, *args):
    ...
</code></pre>
<p>You cannot determine which arguments go into <code>args1</code> and which go into <code>*args2</code>. However, for</p>
<pre><code>def my_function3(x, *args, **kwargs):
    ...
</code></pre>
<p>It's possible to differentiate the arguments that belong to <code>*args</code> and those that belong to <code>**kwargs</code> because the arguments that belong to the <code>**kwargs</code> take the form of <code>arg = val</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible to pass <code>*args</code> twice when calling a function (up until in <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="nofollow">Python 3.5</a>)</p>
<pre><code>&gt;&gt;&gt; fun(*a, *b)
  File "&lt;stdin&gt;", line 1
    fun(*a, *b)
            ^
SyntaxError: invalid syntax    
</code></pre>
<p>However, what you <em>can</em> do is concatenate two <code>args</code> (<code>list</code> or <code>tuple</code>) as you pass them using <code>+</code>. For example: </p>
<pre><code>&gt;&gt;&gt; def fun(*args):
...    print(args)
...
&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; b = [6,7,8,9]
&gt;&gt;&gt;
&gt;&gt;&gt; fun(*a)
(1, 2, 3, 4, 5)
&gt;&gt;&gt; fun(*b)
(6, 7, 8, 9)
&gt;&gt;&gt; fun(*a+b)
(1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></pre>
<p>The function definition can only have a single <code>*args</code> definition, and all passed position arguments will end up in the <code>args</code> variable in the order they were passed.</p>
</div>
<span class="comment-copy">Then what do you want to get? What do you want <code>*args1</code> be?</span>
<span class="comment-copy">Also if you just try it, you can get a <code>SyntaxError: invalid syntax</code>.</span>
<span class="comment-copy">Short answer, <b>no</b>.</span>
<span class="comment-copy">How would you differentiate <code>*args</code> and <code>args1</code> you can't. So as jim stated  <b>no</b></span>
<span class="comment-copy">You probably need to read up on python function arguments in more detail for what these mean.  The short answer, though, is that when you see a function defined like <code>def f(*args)</code> python just takes all extra positional arguments and creates a tuple to hold them.  If you want a function taking multiple tuples you can explicitly define such like <code>f(x1,x2)</code> where <code>x1</code> and <code>x2</code> are tuples.  The star-ed form is simply for when you need any number of arguments and can't specify how many before hand.  It doesn't mean a tuple, but "everything I haven't specifed".</span>
<span class="comment-copy">I see now. Kwargs is a dictionary. Okay. Meaning I can run</span>
<span class="comment-copy">"Kwargs" isn't a dictionary - any name preceded by <code>**</code>, syntax permitting, represents an unpacked dictionary. See <a href="http://stackoverflow.com/questions/287085/what-do-args-and-kwargs-mean?rq=1">here</a> and <a href="http://stackoverflow.com/questions/3394835/args-and-kwargs?rq=1">here</a> for more.</span>
<span class="comment-copy">I see now. Kwargs is a dictionary. Okay. Meaning I can run: <code>def swag(**kwargs): print(kwargs["name"]</code> with <code>swag(name="Tristan")</code> which will print out Tristan then.</span>
<span class="comment-copy">Oh okay. So I can do **swag and use it as a dictionary. What is an unpacked dictionary. Does ** make it a dictionary without having to do d = {}</span>
<span class="comment-copy">Yes, that <code>swag()</code> example would work (I encourage you to experiment with the interpreter). An unpacked dictionary looks like <code>swag(name='Tristan')</code>, which is different from sending in an actual dictionary with <code>swag({'name':'Tristan'})</code>.</span>
