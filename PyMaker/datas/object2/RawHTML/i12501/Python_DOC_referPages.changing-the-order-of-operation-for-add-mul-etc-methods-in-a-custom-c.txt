<div class="post-text" itemprop="text">
<p>I have a vector class:</p>
<pre><code>class Vector:
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __str__(self):
        return '(%s,%s)' % (self.x, self.y)
    def __add__(self, n):
        if isinstance(n, (int, long, float)):
            return Vector(self.x+n, self.y+n)
        elif isinstance(n, Vector):
            return Vector(self.x+n.x, self.y+n.y)
</code></pre>
<p>which works fine, i.e. I can write:</p>
<pre><code>a = Vector(1,2)
print(a + 1) # prints (2,3)
</code></pre>
<p>However if the order of operation is reversed, then it fails:</p>
<pre><code>a = Vector(1,2)
print(1 + a) # raises TypeError: unsupported operand type(s)
             #                   for +: 'int' and 'instance'
</code></pre>
<p>I understand the error: the addition of an <code>int</code> object to an <code>Vector</code> object is undefined because I haven't defined it in the <code>int</code> class. Is there a way to work around this without defining it in the <code>int</code> (or parent of <code>int</code>) class?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to also define <code>__radd__</code></p>
<p>Some operations do not necessarily evaluate like this a + b == b + a and that's why Python defines the <strong>add</strong> and <strong>radd</strong> methods.</p>
<p>Explaining myself better: it supports the fact that "int" does not define a <code>+</code> operation with <code>class Vector</code> instances as part of the operation. Therefore vector + 1 is not the same as 1 + vector.</p>
<p>When Python tries to see what the <code>1.__add__</code> method can do, an exception is raised. And Python goes and looks for <code>Vector.__radd__</code> operation to try to complete it.</p>
<p>In the OP's case the evaluation is <strong>true</strong> and suffices with <code>__radd__ = __add__</code></p>
<pre><code>class Vector(object):

    def __init__(self, x, y):
        self.x, self.y = x, y

    def __str__(self):
        return '(%s,%s)' % (self.x, self.y)

    def __add__(self, n):
        if isinstance(n, (int, long, float)):
            return Vector(self.x+n, self.y+n)
        elif isinstance(n, Vector):
            return Vector(self.x+n.x, self.y+n.y)

    __radd__ = __add__


a = Vector(1, 2)
print(1 + a)
</code></pre>
<p>Which outputs:</p>
<pre><code>(2,3)
</code></pre>
<p>The same applies to all number-like operations.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you say <code>x + y</code>, Python calls <code>x.__add__(y)</code>. If x does not implement <code>__add__</code> (or that method returns <code>NotImplemented</code>), Python tries to call <code>y.__radd__(x)</code> as a fallback.</p>
<p>Thus all you have to do is to define the <code>__radd__()</code> method in your Vector class and <code>1 + y</code> will work as you would expect.</p>
<p>Note: you would have to do similar for other operations too, e.g. implement <code>__mul__()</code> and <code>__rmul__()</code> pair, etc.</p>
<p>You might also want to look at <a href="https://stackoverflow.com/questions/5181320/under-what-circumstances-are-rmul-called">this question</a>, it explains the same principle in more details.</p>
<p><strong>Update:</strong>
Depending on your use case, you might also want to implement the <a href="https://docs.python.org/2/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer"><code>__iadd__()</code></a> method (and its cousins) to override the <code>+=</code> operator.</p>
<p>For example, if you say <code>y += 1</code> (<code>y</code> being an instance of <code>Vector</code> here), you might want to modify the <code>y</code> instance itself, and not return a new <code>Vector</code> instance as a result, which what your <code>__add__()</code> method currently does.</p>
</div>
<span class="comment-copy">You may find this helpful: <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">Special method names</a>. Also see <a href="http://www.rafekettler.com/magicmethods.html" rel="nofollow noreferrer">A Guide to Python's Magic Methods</a> by Rafe Kettler, and <a href="https://pythonconquerstheuniverse.wordpress.com/2012/03/09/pythons-magic-methods" rel="nofollow noreferrer">Pythonâ€™s magic methods</a></span>
<span class="comment-copy">Maybe some more explanation is needed here?</span>
<span class="comment-copy">is it similar for <code>__mul__</code>, <code>__div__</code>, etc? so <code>__rmul__</code>, <code>__rdiv__</code>, etc?</span>
<span class="comment-copy">Yes if the first object in the operation (everything is an object) does not support the operation with the 2nd object</span>
<span class="comment-copy">good answer, I'm accepting this answer mainly because of the hint <code>__radd__=__add__</code>, i like one-line solutions :)</span>
<span class="comment-copy">In your case it is the solution ;)</span>
