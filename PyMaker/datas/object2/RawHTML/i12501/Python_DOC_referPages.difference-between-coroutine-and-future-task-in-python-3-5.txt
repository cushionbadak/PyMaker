<div class="post-text" itemprop="text">
<p>Let's say we have a dummy function:</p>
<pre><code>async def foo(arg):
    result = await some_remote_call(arg)
    return result.upper()
</code></pre>
<p>What's the difference between:</p>
<pre><code>coros = []
for i in range(5):
    coros.append(foo(i))

loop = get_event_loop()
loop.run_until_complete(wait(coros))
</code></pre>
<p>And:</p>
<pre><code>from asyncio import ensure_future

futures = []
for i in range(5):
    futures.append(ensure_future(foo(i)))

loop = get_event_loop()
loop.run_until_complete(wait(futures))
</code></pre>
<p><em>Note</em>: The example returns a result, but this isn't the focus of the question. When return value matters, use <code>gather()</code> instead of <code>wait()</code>.</p>
<p>Regardless of return value, I'm looking for clarity on <code>ensure_future()</code>. <code>wait(coros)</code> and <code>wait(futures)</code> both run the coroutines, so when and why should a coroutine be wrapped in <code>ensure_future</code>?</p>
<p>Basically, what's the Right Way (tm) to run a bunch of non-blocking operations using Python 3.5's <code>async</code>?</p>
<p>For extra credit, what if I want to batch the calls? For example, I need to call <code>some_remote_call(...)</code> 1000 times, but I don't want to crush the web server/database/etc with 1000 simultaneous connections. This is doable with a thread or process pool, but is there a way to do this with <code>asyncio</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>A coroutine is a generator function that can both yield values and accept values from the outside. The benefit of using a coroutine is that we can pause the execution of a function and resume it later. In case of a network operation, it makes sense to pause the execution of a function while we're waiting for the response. We can use the time to run some other functions. </p>
<p>A future is like the <code>Promise</code> objects from Javascript. It is like a placeholder for a value that will be materialized in the future. In the above-mentioned case, while waiting on network I/O, a function can give us a container, a promise that it will fill the container with the value when the operation completes. We hold on to the future object and when it's fulfilled, we can call a method on it to retrieve the actual result. </p>
<p><strong>Direct Answer:</strong> You don't need <code>ensure_future</code> if you don't need the results. They are good if you need the results or retrieve exceptions occurred. </p>
<p><strong>Extra Credits:</strong> I would choose <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a> and pass an <code>Executor</code> instance to control the number of max workers. </p>
<h3>Explanations and Sample codes</h3>
<p>In the first example, you are using coroutines. The <code>wait</code> function takes a bunch of coroutines and combines them together. So <code>wait()</code> finishes when all the coroutines are exhausted (completed/finished returning all the values). </p>
<pre><code>loop = get_event_loop() # 
loop.run_until_complete(wait(coros))
</code></pre>
<p>The <code>run_until_complete</code> method would make sure that the loop is alive until the execution is finished. Please notice how you are not getting the results of the async execution in this case. </p>
<p>In the second example, you are using the <code>ensure_future</code> function to wrap a coroutine and return a <code>Task</code> object which is a kind of <code>Future</code>. The coroutine is scheduled to be executed in the main event loop when you call <code>ensure_future</code>. The returned future/task object doesn't yet have a value but over time, when the network operations finish, the future object will hold the result of the operation. </p>
<pre><code>from asyncio import ensure_future

futures = []
for i in range(5):
    futures.append(ensure_future(foo(i)))

loop = get_event_loop()
loop.run_until_complete(wait(futures))
</code></pre>
<p>So in this example, we're doing the same thing except we're using futures instead of just using coroutines. </p>
<p>Let's look at an example of how to use asyncio/coroutines/futures:</p>
<pre><code>import asyncio


async def slow_operation():
    await asyncio.sleep(1)
    return 'Future is done!'


def got_result(future):
    print(future.result())

    # We have result, so let's stop
    loop.stop()


loop = asyncio.get_event_loop()
task = loop.create_task(slow_operation())
task.add_done_callback(got_result)

# We run forever
loop.run_forever()
</code></pre>
<p>Here, we have used the <code>create_task</code> method on the <code>loop</code> object. <code>ensure_future</code> would schedule the task in the main event loop. This method enables us to schedule a coroutine on a loop we choose. </p>
<p>We also see the concept of adding a callback using the <code>add_done_callback</code> method on the task object. </p>
<p>A <code>Task</code> is <code>done</code> when the coroutine returns a value, raises an exception or gets canceled. There are methods to check these incidents. </p>
<p>I have written some blog posts on these topics which might help:</p>
<ul>
<li><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html" rel="nofollow noreferrer">http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a></li>
<li><a href="http://masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html" rel="nofollow noreferrer">http://masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html</a></li>
<li><a href="http://masnun.com/2015/12/07/python-3-using-blocking-functions-or-codes-with-asyncio.html" rel="nofollow noreferrer">http://masnun.com/2015/12/07/python-3-using-blocking-functions-or-codes-with-asyncio.html</a></li>
</ul>
<p>Of course, you can find more details on the official manual: <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>A comment by Vincent linked to <a href="https://github.com/python/asyncio/blob/7300dc14bbce515f85d44afb9edcb4ee16ee7f02/asyncio/tasks.py#L346" rel="noreferrer">https://github.com/python/asyncio/blob/master/asyncio/tasks.py#L346</a>, which shows that <code>wait()</code> wraps the coroutines in <code>ensure_future()</code> for you!</p>
<p>In other words, we do need a future, and coroutines will be silently transformed into them.</p>
<p>I'll update this answer when I find a definitive explanation of how to batch coroutines/futures.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Simple answer is</h1>
<ul>
<li>Call a croutine function(<code>async def</code>) does NOT run it. it returns just coroutine objects, like generator function returns generator objects.</li>
<li><code>await</code> retrieves values from coroutines, i.e. calls the coroutine</li>
<li><code>eusure_future/create_task</code> schedule the coroutine to run on the event loop on next iteration(although not waiting them to finish, like a daemon thread).</li>
</ul>
<h1>Some code examples</h1>
<p>Let's first clear some terms:</p>
<ul>
<li>coroutine function, the one you <code>async def</code>s</li>
<li>coroutine, what you got when you call a corotine function</li>
</ul>
<p>seem comments below.</p>
<h2>Case 1, <code>await</code> on a coroutine</h2>
<p>We create two coroutines, <code>await</code> one, and use create_task run the other one.</p>
<pre><code>import asyncio
import time

# coroutine function
async def p(word):
    print(f'{time.time()} - {word}')


async def main():
    loop = asyncio.get_event_loop()
    coro = p('await')  # coroutine
    task2 = loop.create_task(p('create_task'))  # &lt;- runs in next iteration
    await coro  # &lt;-- run directly
    await task2

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
</code></pre>
<p>you will get result:</p>
<pre><code>1539486251.7055213 - await
1539486251.7055705 - create_task
</code></pre>
<p>Explain:</p>
<p>task1 was executed directly, and task2 was executed in the following iteration.</p>
<h2>Case 2, yielding control to event loop</h2>
<p>If we replace the main function, we can see a different result:</p>
<pre><code>async def main():
    loop = asyncio.get_event_loop()
    coro = p('await')
    task2 = loop.create_task(p('create_task'))  # scheduled to next iteration
    await asyncio.sleep(1)  # loop got control, and runs task2
    await coro  # run coro
    await task2
</code></pre>
<p>you will get result:</p>
<pre><code>-&gt; % python coro.py
1539486378.5244057 - create_task
1539486379.5252144 - await  # note the delay
</code></pre>
<p>Explain:</p>
<p>When calling <code>asyncio.sleep(1)</code>, the control was yielded back to the event loop, and the loop checks for tasks to run, then it runs the task created by <code>create_task</code>.</p>
<p>Note that, we first invoke the corotine function, but not <code>await</code> it, so we just created a single corotine, and not make it running. Then, we call the corotine function again, and wrap it in a <code>create_task</code> call, creat_task will actully schedule the coroutine to run on next iteration. So, in the result, <code>create task</code> is executed before <code>await</code>.</p>
<p>Actually, the point here is to give back control to the loop, you could use <code>asyncio.sleep(0)</code> to see the same result.</p>
<h2>Under the hood</h2>
<p><code>loop.create_task</code> actually calls <code>asyncio.tasks.Task()</code>, which will call <code>loop.call_soon</code>. And <code>loop.call_soon</code> will put the task in <code>loop._ready</code>. During each iteration of the loop, it checks for every callbacks in loop._ready and runs it.</p>
<p><code>asyncio.wait</code>, <code>asyncio.eusure_future</code> and <code>asyncio.gather</code> actully call <code>loop.create_task</code> directly or indirectly.</p>
<p>Also note in the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>Callbacks are called in the order in which they are registered. Each callback will be called exactly once.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://www.youtube.com/watch?v=1coLC-MUCJc" rel="nofollow noreferrer">From the BDFL [2013]</a></p>
<h2>Tasks</h2>
<ul>
<li>It's a coroutine wrapped in a Future</li>
<li>class Task is a subclass of class Future</li>
<li>So it works with <strong>await</strong> too!</li>
</ul>
<hr/>
<ul>
<li>How does it differ from a bare coroutine?</li>
<li>It can make progress without waiting for it

<ul>
<li>As long as you wait for something else, i.e. 

<ul>
<li><strong>await</strong> [something_else]</li>
</ul></li>
</ul></li>
</ul>
<p>With this in mind, <code>ensure_future</code> makes sense as a name for creating a Task since the Future's result will be computed whether or not you <strong>await</strong> it (as long as you await something). This allows the event loop to complete your Task while you're waiting on other things. Note that in Python 3.7 <code>create_task</code> is the preferred way <a href="https://docs.python.org/3/library/asyncio-task.html#creating-tasks" rel="nofollow noreferrer">ensure a future</a>.</p>
<p><em>Note: I changed "yield from" in Guido's slides to "await" here for modernity.</em></p>
</div>
<span class="comment-copy">I've updated my question to be a bit more clear - if I don't need the result from the coroutine, do I still need to use <code>ensure_future()</code>? And if I do need the result, can't I just use <code>run_until_complete(gather(coros))</code>?</span>
<span class="comment-copy"><code>ensure_future</code> schedules the coroutine to be executed in the event loop. So I would say yes, it's required. But of course you can schedule the coroutines using other functions/methods too. Yes, you can use <code>gather()</code> - but gather will wait until all the responses are collected.</span>
<span class="comment-copy">@AbuAshrafMasnun @knite <code>gather</code> and <code>wait</code> actually wrap the given coroutines as tasks using <code>ensure_future</code> (see the sources <a href="https://github.com/python/asyncio/blob/master/asyncio/tasks.py#L614" rel="nofollow noreferrer">here</a> and <a href="https://github.com/python/asyncio/blob/master/asyncio/tasks.py#L346" rel="nofollow noreferrer">here</a>). So there is no point in using <code>ensure_future</code> beforehand, and it has nothing to do with getting the results or not.</span>
<span class="comment-copy">@AbuAshrafMasnun @knite Also, <code>ensure_future</code> has a <code>loop</code> argument, so there is no reason to use <code>loop.create_task</code> over <code>ensure_future</code>. And <code>run_in_executor</code> won't work with coroutines, a <a href="https://docs.python.org/3.4/library/asyncio-sync.html#semaphores" rel="nofollow noreferrer">semaphore</a> should be used instead.</span>
<span class="comment-copy">@vincent there is a reason to use <code>create_task</code> over <code>ensure_future</code>, see <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer">docs</a>. Quote <code>create_task() (added in Python 3.7) is the preferable way for spawning new tasks. </code></span>
<span class="comment-copy">Thanks for a clean explanation! Have to say, it's a pretty terrible design. High-level API is leaking low-level abstraction, which overcomplicate the API.</span>
<span class="comment-copy">check out the curio project, which is well-designed</span>
