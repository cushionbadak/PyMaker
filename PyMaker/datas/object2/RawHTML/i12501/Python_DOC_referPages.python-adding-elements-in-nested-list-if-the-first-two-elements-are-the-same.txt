<div class="post-text" itemprop="text">
<p>I have a nested list: </p>
<pre><code> a = [[1,2,3,4,5],[1,2,5,6,7],[1,2,5,2,1],[1,3,4,5,7],[3,4,1,2,3],[3,4,1,1,1]]
</code></pre>
<p>If the first two elements of the sub lists are same, then I want to add their corresponding 3rd, 4th and 5th elements, while retaining the first two elements. For the above case the result should be: </p>
<pre><code>a = [[1,2,13,12,13],[1,3,4,5,7],[3,4,2,3,4]]
</code></pre>
<p>Is there a way to do this? </p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary to categorize the sub-lists based on first two items then iterate over the items and calculate the sum :</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for sub in a:
...    d.setdefault(tuple(sub[:2]),[]).append(sub[2:])
... 

&gt;&gt;&gt; 
&gt;&gt;&gt; [k+tuple(map(sum, zip(*v))) for k,v in d.items()]
[(1, 2, 13, 12, 13), (1, 3, 4, 5, 7), (3, 4, 2, 3, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Pandas one-liner</h2>
<p>How about a <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a> one-liner.</p>
<p>Import and data:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; a = [[1,2,3,4,5],[1,2,5,6,7],[1,2,5,2,1],[1,3,4,5,7],[3,4,1,2,3],[3,4,1,1,1]]
</code></pre>
<p>Pandas in action:</p>
<pre><code>&gt;&gt;&gt; pd.DataFrame(a).groupby([0, 1]).sum().reset_index().values.tolist()
[[1, 2, 13, 12, 13], [1, 3, 4, 5, 7], [3, 4, 2, 3, 4]]
</code></pre>
<h2>Step-by-step</h2>
<p>Make a dataframe:</p>
<pre><code>&gt;&gt;&gt; df = pd.DataFrame(a)

   0  1  2  3  4
0  1  2  3  4  5
1  1  2  5  6  7
2  1  2  5  2  1
3  1  3  4  5  7
4  3  4  1  2  3
5  3  4  1  1  1
</code></pre>
<p>Group by the first two columns and sum the other columns:</p>
<pre><code>&gt;&gt;&gt; df2 = df.groupby([0, 1]).sum()
&gt;&gt;&gt; df2

      2   3   4
0 1            
1 2  13  12  13
  3   4   5   7
3 4   2   3   4
</code></pre>
<p>The <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.DataFrame.groupby.html?highlight=groupby#pandas.DataFrame.groupby" rel="nofollow noreferrer">groupby</a> method groups by the columns <code>0</code> and <code>1</code>. The result is a <code>GroupBy</code> object. You need to "do" something with it to visualize it. Here we sum the values in the groups. Maybe it becomes bit clearer looking at a nicely formatted table:</p>
<p><a href="https://i.stack.imgur.com/27flH.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/27flH.png"/></a></p>
<p>This index is a <a href="http://pandas.pydata.org/pandas-docs/version/0.17.1/advanced.html?highlight=multiindex" rel="nofollow noreferrer">MultiIndex</a>:</p>
<pre><code>MultiIndex(levels=[[1, 3], [2, 3, 4]],
           labels=[[0, 0, 1], [0, 1, 2]],
           names=[0, 1])
</code></pre>
<p>There are two levels with names <code>0</code> and <code>1</code>.  The leftmost column is the first level with the labels <code>1</code> and <code>3</code> and the one next it is the second level with the labels <code>2</code>, <code>3</code>, and <code>4</code>. The label <code>1</code> in the first level is used for the first two rows. All other labels are used only for one row.</p>
<p>Flatten the multi-index:</p>
<pre><code>&gt;&gt; df3 = df2.reset_index()

   0  1   2   3   4
0  1  2  13  12  13
1  1  3   4   5   7
2  3  4   2   3   4
</code></pre>
<p>Convert into a list:</p>
<pre><code>&gt;&gt;&gt; df3.values.tolist()
[[1, 2, 13, 12, 13], [1, 3, 4, 5, 7], [3, 4, 2, 3, 4]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would create a dictionary with first couples as a key and value would be a list or a tuple:</p>
<pre><code>a=[[1,2,3,4,5],[1,2,5,6,7],[1,2,5,2,1],[1,3,4,5,7],[3,4,1,2,3],[3,4,1,1,1]]

#create empty dict
d = {}

# function for adding list b to lists a
def addlist(a,b): return [a[i]+b[i] for i in range(len(a))]  

# now iter through each item and add to existing or create a new record in dictionary
for i in a:
    d[tuple(i[:2])] = addlist(d.setdefault(tuple(i[:2]),[0,0,0]),i[2:])

#the wanted output would be
[list(k)+v for k,v in d.items()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a relatively straight-forward application of <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>.</p>
<p>Here's how to do it with a nested list comprehension.</p>
<pre><code>from itertools import groupby
from operator import itemgetter

a = [[1,2,3,4,5],[1,2,5,6,7],[1,2,5,2,1],[1,3,4,5,7],[3,4,1,2,3],[3,4,1,1,1]]
expected = [[1,2,13,12,13],[1,3,4,5,7],[3,4,2,3,4]]
print(expected)

a = [list(k) + [sum(t) for t in zip(*[u[2:] for u in g])]
    for k, g in groupby(a, itemgetter(0, 1))]
print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[[1, 2, 13, 12, 13], [1, 3, 4, 5, 7], [3, 4, 2, 3, 4]]
[[1, 2, 13, 12, 13], [1, 3, 4, 5, 7], [3, 4, 2, 3, 4]]
</code></pre>
<p>Note that this assumes that the list <code>a</code> already has the sub-lists that commence with the same 2 elements adjacent. If that's not the case then it should be sorted, eg</p>
<pre><code>a.sort(key=itemgetter(0, 1))
</code></pre>
<p>before running the above code.</p>
<p>Here's essentially the same algorithm split up for easier reading and analysis.</p>
<pre><code>keyfunc = lambda seq: seq[:2]

a.sort(key=keyfunc)
new_a = []
for k, g in groupby(a, key=keyfunc):
    tails = [u[2:] for u in g]
    sums = [sum(t) for t in zip(*tails)]
    new_a.append(k + sums)

print(new_a)
</code></pre>
</div>
<span class="comment-copy">These structures are lists. What have you tried?</span>
<span class="comment-copy">Wow! I had no idea about pandas. Thanks!</span>
<span class="comment-copy">@mike: Would be good if you could add more explanation abt how 'groupby' works. I get the idea, but still unclear.</span>
<span class="comment-copy">@kmario23 Added more explanation.</span>
<span class="comment-copy">I am not sure why I am getting [[1L, 2L, 13L, 12L, 13L], [1L, 3L, 4L, 5L, 7L], [3L, 4L, 2L, 3L, 4L]] instead!</span>
<span class="comment-copy">Your are using Python 2 and you are probably on Windows.  On Windows, the standard integer is 32 bit even on 64 bit systems. But the dataframe uses 64 bit integers. These  are converted into Python <code>long</code> (integers). Their string representation is postfixed with an <code>L</code>. Try with Python 3 and you will not see the <code>L</code>.  If you don't like longs convert to int32: <code>import numpy as np; df3.values.astype(np.int32).tolist()</code>.</span>
