<div class="post-text" itemprop="text">
<p>i am working on a piece of software and got some major problems (i am new to python)...
The app should deal with some tasks from a .csv. When the program starts, it should read the file and displays the tasks nicely in a GUI. In the GUI are some tools like editing, deleting and moving certain tasks.
There is also running a socket server which sends sorted tasks to clients.
Both of these functions are working, but not parallel.
Everytime a client connects to the server the GUI crashes. I know this happens because the socket is blocking the process and i need to create a separate thread for the GUI, but i can't figure out how to do it.</p>
<p>I stuffed all the Tkinter-Code for the GUI in one function and tried threading.Thread(target=guiStart, args=()). But then the GUI stopped working due to error messages like "Calling Tcl from different appartment" (working on OSX, but should also run on Win) and some undefinied global variables from functions modifing GUI-stuff...</p>
<p>I have no Idea what to do, i read so many threading example code but i cant figure out how to solve my problem.</p>
<p>Is there anybody who can tell me what to do?</p>
<p>Here is my Code (without my threading attempt):</p>
<pre><code>from Tkinter import *
import csv
import socket
import sys
import json
from thread import *
import threading

root = Tk()

#------------Server Config------

HOST = ''   
PORT = 8888 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #test
print 'Socket created'

#Bind socket to local host and port
try:
    s.bind((HOST, PORT))
except socket.error as msg:
    print 'Bind failed. Error Code : ' + str(msg[0]) + ' Message: ' + msg[1]
    sys.exit()

print 'Socket bind complete'

#Start listening on socket
s.listen(10)
print 'Socket now listening'

#------------Functions---------


# a lot of functions...       


def clientthread(conn):

    conn.send('CONNECTED \n')
    #conn.send(json.dumps(tasksA))
    station = ""


    while True:
        print "Entered loop" #

        databytes = conn.recv(1024)
        if not databytes: break

        data = databytes.decode("utf-8")
        print "Client: " + data


        if data =='STATION_A':
            station = "Station A"
            print "Connected to: " + station
            conn.send(json.dumps(tasksA))

        #some more if-clauses


    conn.close()

def runServer():
    while True:
        conn, addr = s.accept()
        #conn.setblocking(0)
        print 'Connected with ' + addr[0] + ':' + str(addr[1])

        #start new thread takes 1st argument as a function name to be run, second is the tuple of arguments to the function.
        start_new_thread(clientthread ,(conn,))
        root.after(100, runServer)
    s.close()



#------------GUI-----------------------

root.geometry("1024x768")
root.minsize(width="1024", height="768")
root.title("FTS v04")

#... left out most of the gui stuff... just too much code



loadTasks()   
thread = threading.Thread(target = runServer)
thread.deamon = True
thread.start()
root.mainloop()
</code></pre>
<p>(there is also another little bug i cant get rid of: <a href="https://stackoverflow.com/questions/34708101/python-2-7-data-from-socket-client-wont-trigger-commands-on-server">see here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you look into <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow">asyncio</a> and use asynchronous sockets as opposed to spawning a new thread per connection.  This will remove all ideas of "blocking" from reading/accepting from a socket.  Asyncio handles a lot of the tough stuff when it comes to asynchronous file I/O but takes a little time to get used to the whole "Future" concept.  I recommend you give the documentation a read.</p>
</div>
<span class="comment-copy">Welcome to SO. Please read <a href="https://stackoverflow.com/help/mcve">How to create a Minimal, Complete, and Verifiable example</a>. I don't think anyone would like to read wall of text.</span>
<span class="comment-copy">Have you tried keeping the GUI code in the main thread, and moving the socket code to a separate thread?</span>
<span class="comment-copy">Lafexlos, thanks for the hint. I will edit the code! Bryan, i thought the socket will create a seperate thread for every client... what do you mean exactly?</span>
<span class="comment-copy">Thanks, but this looks really complicated. Can you give me a hint how to add this modul in the existing code?</span>
<span class="comment-copy">Oasiscircle, i forgot to mention that i have to use Python 2.7. There is no other way, because i need to use some third party modules whicht dont work with Python 3.x..</span>
<span class="comment-copy">Oh, asyncio is only for Python 3+.  Try looking up "non-blocking sockets" and using those instead to remove the blocking on read for a socket.</span>
