<div class="post-text" itemprop="text">
<p>I'm interested in using the <code>__new__</code> functionality to inject code into the <code>__init__</code> function of subclasses. My understanding from the documentation is that python will call <code>__init__</code> on the instance returned by <code>__new__</code>. However, my efforts to change the value of <code>__init__</code> in the instance before returning it from <code>__new__</code> don't seem to work.</p>
<pre class="lang-python prettyprint-override"><code>class Parent(object):

    def __new__(cls, *args, **kwargs):
        new_object = super(Parent, cls).__new__(cls)
        user_init = new_object.__init__
        def __init__(self, *args, **kwargs):
            print("New __init__ called")
            user_init(self, *args, **kwargs)
            self.extra()
        print("Replacing __init__")
        setattr(new_object, '__init__', __init__)
        return new_object

    def extra(self):
        print("Extra called")

class Child(Parent):

    def __init__(self):
        print("Original __init__ called")
        super(Child, self).__init__()

c = Child()
</code></pre>
<p>The above code prints:</p>
<pre class="lang-none prettyprint-override"><code>Replacing __init__
Original __init__ called
</code></pre>
<p>but I would expect it to print</p>
<pre class="lang-none prettyprint-override"><code>Replacing __init__
New __init__ called
Original __init__ called
Extra called
</code></pre>
<p>Why not?</p>
<p>I feel like Python is calling the original value of <code>__init__</code>, regardless of what I set it to in <code>__new__</code>. Running introspection on <code>c.__init__</code> shows that the new version is in place, but it hasn't been called as part of the object creation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, the new object is expected to be empty before the <code>__init__</code> is called. So probably python, as optimization, does not bother to query the object and goes to fetch <code>__init__</code> straight from the class.</p>
<p>Therefore you'll have to modify <code>__init__</code> of the subclasses themselves. Fortunately Python has a tool for that, metaclasses.</p>
<p>In Python 2, you set metaclass by setting special member:</p>
<pre><code>class Parent(object):
    __metaclass__ = Meta
    ...
</code></pre>
<p>See <a href="https://docs.python.org/2.7/reference/datamodel.html#customizing-class-creation" rel="nofollow">Python2 documentation</a></p>
<p>In Python 3, you set metaclass via keyword attribute in the parent list, so</p>
<pre><code>class Parent(metaclass=Meta):
    ...
</code></pre>
<p>See <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow">Python3 documentation</a></p>
<p>The metaclass is a base class for the class instance. It has to be derived from <code>type</code> and in it's <code>__new__</code> it can modify the class being created (I believe the <code>__init__</code> should be called too, but the examples override <code>__new__</code>, so I'll go with it). The <code>__new__</code> will be similar to what you have:</p>
<pre><code>class Meta(type):
    def __new__(mcs, name, bases, namespace, **kwargs):
        new_cls = super(Meta, mcs).__new__(mcs, name, bases, namespace, **kwargs)
        user_init = new_cls.__init__
        def __init__(self, *args, **kwargs):
            print("New __init__ called")
            user_init(self, *args, **kwargs)
            self.extra()
        print("Replacing __init__")
        setattr(new_cls, '__init__', __init__)
        return new_cls
</code></pre>
<p>(using the Python 3 example, but the signature in Python 2 seems to be the same except there are no <code>**kwargs</code>, but adding them shouldn't hurt; I didn't test it).</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect the answer is that <code>__init__</code> is a special function, internally it is defined as a class method, and as a result cannot be replaced by reassigning it in an instance of the object.</p>
<p>In Python, all objects are represented by the <code>PyObject</code> in C, which has a pointer to a <code>PyTypeObject</code>. This contains a member called <code>tp_init</code> that I believe contains a pointer to the <code>__init__</code> function.</p>
<p>The other solution works, because we are modifying the class, not an instance of the object.</p>
</div>
<span class="comment-copy">What's your question?</span>
<span class="comment-copy"><code>PyTypeObject</code> represents <code>type</code> object, not all objects, no?</span>
<span class="comment-copy">Argh. Was looking for <code>PyObject</code> in the source code via github and found <code>PyTypeObject</code> instead. A <code>PyObject</code> has a <code>ob_type</code> method that does point to a <code>PyTypeObject</code> so I think my reasoning still could stands. It really depends on how the <code>__init__</code> method is called.</span>
<span class="comment-copy">Rewrote my answer to try and simplify.</span>
