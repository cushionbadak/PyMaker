<div class="post-text" itemprop="text">
<p>(This question is related to <a href="https://stackoverflow.com/q/8290397/647991">this one</a> and <a href="https://stackoverflow.com/q/312443/647991">this one</a>, but those are pre-walking the generator, which is exactly what I want to avoid)</p>
<p>I would like to split a generator in chunks. The requirements are:</p>
<ul>
<li>do not pad the chunks: if the number of remaining elements is less than the chunk size, the last chunk must be smaller.</li>
<li>do not walk the generator beforehand: computing the elements is expensive, and it must only be done by the consuming function, not by the chunker</li>
<li>which means, of course: do not accumulate in memory (no lists)</li>
</ul>
<p>I have tried the following code:</p>
<pre><code>def head(iterable, max=10):
    for cnt, el in enumerate(iterable):
        yield el
        if cnt &gt;= max:
            break

def chunks(iterable, size=10):
    i = iter(iterable)
    while True:
        yield head(i, size)

# Sample generator: the real data is much more complex, and expensive to compute
els = xrange(7)

for n, chunk in enumerate(chunks(els, 3)):
    for el in chunk:
        print 'Chunk %3d, value %d' % (n, el)
</code></pre>
<p>And this somehow works:</p>
<pre><code>Chunk   0, value 0
Chunk   0, value 1
Chunk   0, value 2
Chunk   1, value 3
Chunk   1, value 4
Chunk   1, value 5
Chunk   2, value 6
^CTraceback (most recent call last):
  File "xxxx.py", line 15, in &lt;module&gt;
    for el in chunk:
  File "xxxx.py", line 2, in head
    for cnt, el in enumerate(iterable):
KeyboardInterrupt
</code></pre>
<p>Buuuut ... it never stops (I have to press <code>^C</code>) because of the <code>while True</code>. I would like to stop that loop whenever the generator has been consumed, but I do not know how to detect that situation. I have tried raising an Exception:</p>
<pre><code>class NoMoreData(Exception):
    pass

def head(iterable, max=10):
    for cnt, el in enumerate(iterable):
        yield el
        if cnt &gt;= max:
            break
    if cnt == 0 : raise NoMoreData()

def chunks(iterable, size=10):
    i = iter(iterable)
    while True:
        try:
            yield head(i, size)
        except NoMoreData:
            break

# Sample generator: the real data is much more complex, and expensive to compute    
els = xrange(7)

for n, chunk in enumerate(chunks(els, 2)):
    for el in chunk:
        print 'Chunk %3d, value %d' % (n, el)
</code></pre>
<p>But then the exception is only raised in the context of the consumer, which is not what I want (I want to keep the consumer code clean)</p>
<pre><code>Chunk   0, value 0
Chunk   0, value 1
Chunk   0, value 2
Chunk   1, value 3
Chunk   1, value 4
Chunk   1, value 5
Chunk   2, value 6
Traceback (most recent call last):
  File "xxxx.py", line 22, in &lt;module&gt;
    for el in chunk:
  File "xxxx.py", line 9, in head
    if cnt == 0 : raise NoMoreData
__main__.NoMoreData()
</code></pre>
<p>How can I detect that the generator is exhausted in the <code>chunks</code> function, without walking it?</p>
</div>
<div class="post-text" itemprop="text">
<p>One way would be to peek at the first element, if any, and then create and return the actual generator.</p>
<pre><code>def head(iterable, max=10):
    first = next(iterable)      # raise exception when depleted
    def head_inner():
        yield first             # yield the extracted first element
        for cnt, el in enumerate(iterable):
            yield el
            if cnt + 1 &gt;= max:  # cnt + 1 to include first
                break
    return head_inner()
</code></pre>
<p>Just use this in your <code>chunk</code> generator and catch the <code>StopIteration</code> exception like you did with your custom exception.</p>
<hr/>
<p><strong>Update:</strong> Here's another version, using <a href="https://docs.python.org/2/library/itertools.html#itertools.islice"><code>itertools.islice</code></a> to replace most of the <code>head</code> function, and a <code>for</code> loop. This simple <code>for</code> loop in fact does <em>exactly the same thing</em> as that unwieldy <code>while-try-next-except-break</code> construct in the original code, so the result is <em>much</em> more readable.</p>
<pre><code>def chunks(iterable, size=10):
    iterator = iter(iterable)
    for first in iterator:    # stops when iterator is depleted
        def chunk():          # construct generator for next chunk
            yield first       # yield element from for loop
            for more in islice(iterator, size - 1):
                yield more    # yield more elements from the iterator
        yield chunk()         # in outer generator, yield next chunk
</code></pre>
<p>And we can get even shorter than that, using <a href="https://docs.python.org/2/library/itertools.html#itertools.chain"><code>itertools.chain</code></a> to replace the inner generator:</p>
<pre><code>def chunks(iterable, size=10):
    iterator = iter(iterable)
    for first in iterator:
        yield chain([first], islice(iterator, size - 1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way to create groups/chunks and not <em>prewalk</em> the generator is using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> on a key function that uses an <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> object. Since the <code>count</code> object is independent of the <em>iterable</em>, the chunks can be easily generated without any knowledge of what the <em>iterable</em> holds.</p>
<p>Every iteration of <code>groupby</code> calls the <code>next</code> method of the <code>count</code> object and generates a group/chunk <em>key</em> (followed by items in the chunk) by doing an integer division of the current count value by the size of the chunk.</p>
<pre><code>from itertools import groupby, count

def chunks(iterable, size=10):
    c = count()
    for _, g in groupby(iterable, lambda _: next(c)//size):
        yield g
</code></pre>
<p>Each group/chunk <code>g</code> <em>yielded</em> by the generator function is an iterator. However, since <code>groupby</code> uses a shared iterator for all groups, the group iterators cannot be stored in a list or any container, each group iterator should be consumed before the next.</p>
</div>
<div class="post-text" itemprop="text">
<p>Fastest possible solution I could come up with, thanks to (in CPython) using purely C-level builtins. By doing so, no Python byte code is needed to produce each chunk (unless the underlying generator is implemented in Python) which has a huge performance benefit. It does walk each <em>chunk</em> before returning it, but it doesn't do any pre-walking beyond the chunk it's about to return:</p>
<pre><code># Py2 only to get generator based map
from future_builtins import map

from itertools import islice, repeat, starmap, takewhile
# operator.truth is *significantly* faster than bool for the case of
# exactly one positional argument
from operator import truth

def chunker(n, iterable):  # n is size of each chunk; last chunk may be smaller
    return takewhile(truth, map(tuple, starmap(islice, repeat((iter(iterable), n)))))
</code></pre>
<p>Since that's a bit dense, the spread out version for illustration:</p>
<pre><code>def chunker(n, iterable):
    iterable = iter(iterable)
    while True:
        x = tuple(islice(iterable, n))
        if not x:
            return
        yield x
</code></pre>
<p>Wrapping a call to <code>chunker</code> in <code>enumerate</code> would let you number the chunks if it's needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about using <a href="https://docs.python.org/2/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice</code></a>:</p>
<pre><code>import itertools

els = iter(xrange(7))

print list(itertools.islice(els, 2))
print list(itertools.islice(els, 2))
print list(itertools.islice(els, 2))
print list(itertools.islice(els, 2))
</code></pre>
<p>Which gives:</p>
<pre><code>[0, 1]
[2, 3]
[4, 5]
[6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>from itertools import islice
def chunk(it, n):
    '''
    # returns chunks of n elements each

    &gt;&gt;&gt; list(chunk(range(10), 3))
    [
        [0, 1, 2, ],
        [3, 4, 5, ],
        [6, 7, 8, ],
        [9, ]
    ]

    &gt;&gt;&gt; list(chunk(list(range(10)), 3))
    [
        [0, 1, 2, ],
        [3, 4, 5, ],
        [6, 7, 8, ],
        [9, ]
    ]
    '''
    def _w(g):
        return lambda: tuple(islice(g, n))
    return iter(_w(iter(it)), ())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Started to realize the usefulness of this scenario when crafting a solution to DB insertion of 500k+ rows at higher speed.</p>
<p>A generator processes the data from source and "yield"s it line by line; and then another generator groups the output in chunks and "yield "s it chunk by chunk.  The second generator is only aware of the chunk size and nothing more.</p>
<p>Below is a sample to highlight the concept:</p>
<pre><code>#!/usr/bin/python

def firstn_gen(n):
    num = 0
    while num &lt; n:
        yield num
        num += 1

def chunk_gen(some_gen, chunk_size=7):
    res_chunk = []
    for count, item in enumerate(some_gen, 1):
        res_chunk.append(item)
        if count % chunk_size == 0:
            yield res_chunk
            res_chunk[:] = []
    else:
        yield res_chunk


if __name__ == '__main__':
    for a_chunk in chunk_gen(firstn_gen(33)):
        print(a_chunk)
</code></pre>
<p>Tested in Python 2.7.12:</p>
<pre><code>[0, 1, 2, 3, 4, 5, 6]
[7, 8, 9, 10, 11, 12, 13]
[14, 15, 16, 17, 18, 19, 20]
[21, 22, 23, 24, 25, 26, 27]
[28, 29, 30, 31, 32]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had this same issue, but found a simpler solution than those mentioned here:</p>
<pre><code>def chunker(iterable, chunk_size):
    els = iter(iterable)
    while True:
        next_el = next(els)
        yield chain([next_el], islice(els, chunk_size - 1))

for i, chunk in enumerate(chunker(range(11), 2)):
    for el in chunk:
        print(i, el)

# Prints the following:
0 0
0 1
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've said you don't wish to store things in memory, so does this mean that you can't build an intermediate list for the current chunk?</p>
<p>Why not traverse the generator and insert a sentinel value between chunks? The consumer (or a suitable wrapper) could ignore the sentinel:</p>
<pre><code>class Sentinel(object):
    pass

def chunk(els, size):
    for i, el in enumerate(els):
        yield el
        if i &gt; 0 and i % size == 0:
            yield Sentinel
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>EDIT other solution with a generator of generators</p>
<p>You should not do a <code>while True</code> in your iterator, but simply iterate through it and update the chunk number at each iteration :</p>
<pre><code>def chunk(it, maxv):
    n = 0
    for i in it:
        yield n // mavx, i
        n += 1
</code></pre>
<p>If you want a generator of generators, you can have :</p>
<pre><code>def chunk(a, maxv):
    def inner(it, maxv, l):
        l[0] = False
        for i in range(maxv):
            yield next(it)
        l[0] = True
        raise StopIteration
    it = iter(a)
    l = [True]
    while l[0] == True:
        yield inner(it, maxv, l)
    raise StopIteration
</code></pre>
<p>with a being an iterable.</p>
<p>Tests : on python 2.7 and 3.4:</p>
<pre><code>for i in chunk(range(7), 3):
    print 'CHUNK'
    for a in i:
        print a
</code></pre>
<p>gives :</p>
<pre><code>CHUNK
0
1
2
CHUNK
3
4
5
CHUNK
6
</code></pre>
<p>And on 2.7 :</p>
<pre><code>for i in chunk(xrange(7), 3):
    print 'CHUNK'
    for a in i:
        print a
</code></pre>
<p>gives same result.</p>
<p>But <strong>BEWARE</strong> : <code>list(chunk(range(7))</code> blocks on 2.7 and 3.4</p>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by <a href="https://stackoverflow.com/users/3125566/moses-koledoye">Moses Koledoye's answer</a>, I tried to make a solution that uses <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a> but doesn't require a divide at each step.</p>
<p>The following function can be used as a key to groupby, and it simply returns a boolean, which flips after a pre-defined number of calls.</p>
<pre><code>def chunks(chunksize=3):

    def flag_gen():
        flag = False
        while True:
            for num in range(chunksize):
                yield flag
            flag = not flag

    flag_iter = flag_gen()

    def flag_func(*args, **kwargs):
        return next(flag_iter)

    return flag_func
</code></pre>
<p>Which can be used like this:</p>
<pre><code>from itertools import groupby

my_long_generator = iter("abcdefghijklmnopqrstuvwxyz")

chunked_generator = groupby(my_long_generator, key=chunks(chunksize=5))

for flag, chunk in chunked_generator:
    print("Flag is {f}".format(f=flag), list(chunk))
</code></pre>
<p>Output:</p>
<pre><code>Flag is False ['a', 'b', 'c', 'd', 'e']
Flag is True ['f', 'g', 'h', 'i', 'j']
Flag is False ['k', 'l', 'm', 'n', 'o']
Flag is True ['p', 'q', 'r', 's', 't']
Flag is False ['u', 'v', 'w', 'x', 'y']
Flag is True ['z']
</code></pre>
<p>I've made a <a href="https://pyfiddle.io/fiddle/a2912b2c-b1fe-42f0-b13d-f03d16bbf5c9/?i=true" rel="nofollow noreferrer">fiddle demonstrating this code</a>. </p>
</div>
<span class="comment-copy">Don't know how to fix it, but that <code>except</code> will only catch the exception if it is raised when <i>creating</i> <code>head</code>, not when iterating it.</span>
<span class="comment-copy">@tobias_k: sure, I understand that. I am looking for a fix for that ...</span>
<span class="comment-copy">Would it be okay to peek at the first element? You could try to <code>next</code> the first element, then raise an exception or return the actual chunk iterator.</span>
<span class="comment-copy">@tobias_k: that would be a good compromise, but not sure how to implement that without losing that element ...</span>
<span class="comment-copy">Can you clarify what do you mean by "pre-walking the generator"?</span>
<span class="comment-copy">That works! Thanks! I have the full example: if you want I can edit your answer to include it and have it as reference.</span>
<span class="comment-copy">@jeckyll2hide See my edit. Its now all in one much smaller and saner function.</span>
<span class="comment-copy">Using the initial example of <code>for n, chunk in enumerate(chunks(xrange(0,100), 10)):</code>, this does not appear to work for me. If I <code>print(n)</code> in that for loop, I end up with 100 chunks. Am I misunderstanding something here?</span>
<span class="comment-copy">@kadrach That is because you are not consuming the chunks before generating the next one. The code only works if each chunk is consumed before the next one is generated; otherwise, how should chunk n know what it's first element is, without actually advancing the iterator until the end of chunk n-1?</span>
<span class="comment-copy">This works 7 to 8 times slower than itertools.chain method published by tobias_k above</span>
<span class="comment-copy">Thanks, but incomplete. Where is the chunker here?</span>
<span class="comment-copy">I've thought about <code>islice</code>, as well, but you'd again need some mechanism to find out when the slice is empty and stop then.</span>
<span class="comment-copy">I do not want to traverse the generator. I want to produce a list of generators which <b>will</b> walk the original generator <i>only when</i> the consumers decide. This way I can pass the list of chunks around for other parts of my code to consume it, without pre-walking the data (which is expensive to compute in my case)</span>
<span class="comment-copy">This does not provide me with a series of chunks, but with a single iterator with an indication of the chunk it belongs too. It pre-walks the iterator, which is exactly what I want to avoid.</span>
<span class="comment-copy">@jeckyll2hide : post updated with a generator of generators</span>
