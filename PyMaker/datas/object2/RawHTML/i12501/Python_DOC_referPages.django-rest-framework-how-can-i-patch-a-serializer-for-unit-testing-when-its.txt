<div class="post-text" itemprop="text">
<p>I have a serializer with an create() function. When I do a POST request, then I want to get this function called and create a new object. When I do it in the browser, it works and it also calls the function. But inside the test, it says that the function is not called. I think that I have done something wrong with the patch, because in the API it is only set as an <strong>serializer_class</strong> and the class is likely called somewhere inside the framework. Another thought was, that I do not need to test this, because it should be <strong>guaranteed by the rest_framework</strong>, that if I do it this way, the framework should call the function with the correct parameters.</p>
<pre><code># serializers.py
class FooSerializer(models.ModelSerializer):
    class Meta:
        ...

    def create(self, validated_data):
        ...

# apis.py
class FooAPI(generics.CreateAPIView):
    serializer_class = FooSerializer

# tests.py
@patch('apis.FooSerializer'):
def test_that_create_is_called(self, mock):
    mock.create = MagicMock()
    mock.create.return_value = Foo() # Foo is my model
    response = self.client.post('/foo', {name: 'Test'})
    self.assertTrue(mock.create.called) # =&gt; Output says "False is not true"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your current code is mocking the entire Serializer object, which is probably overkill and could stop the create method ever being called if it's expected to be called by internal logic on the serializer.</p>
<p>Instead you want to just patch a single method - like this:</p>
<pre><code>@patch('apis.FooSerializer', 'create')
</code></pre>
<p>Now your test method receives the MagicMock object instance that has replaced the create method.</p>
<p>So your test method becomes:</p>
<pre><code>def test_that_create_is_called(self, mock_method):
    response = self.client.post('/foo', {name: 'Test'})
    self.assertTrue(mock_method.called)
</code></pre>
</div>
<span class="comment-copy">You shouldn't call the patched object 'mock' you will have conflicts because that's the name of the python built-in module. I think the error is in the patch's path maybe should be like <code>my_module.apis.FooSerializer</code>. From the mock's model documentation <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">"target should be a string in the form 'package.module.ClassName'"</a></span>
<span class="comment-copy">Thank you for answering! When I saw this answer I already have changed my code and now I couldn't reproduce it, so I can't say if this answer would have solved my problem... But thank's anyway :)</span>
