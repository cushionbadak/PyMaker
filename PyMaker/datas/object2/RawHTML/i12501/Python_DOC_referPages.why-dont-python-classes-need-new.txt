<div class="post-text" itemprop="text">
<p>I'm just trying to streamline one of my classes and have introduced some functionality in the same style as the <a href="https://en.wikipedia.org/wiki/Flyweight_pattern" rel="noreferrer">flyweight design pattern</a>.</p>
<p>However, I'm a bit confused as to why <code>__init__</code> is always called after <code>__new__</code>. I wasn't expecting this. Can anyone tell me why this is happening and how I can implement this functionality otherwise? (Apart from putting the implementation into the <code>__new__</code> which feels quite hacky.)</p>
<p>Here's an example:</p>
<pre><code>class A(object):
    _dict = dict()

    def __new__(cls):
        if 'key' in A._dict:
            print "EXISTS"
            return A._dict['key']
        else:
            print "NEW"
            return super(A, cls).__new__(cls)

    def __init__(self):
        print "INIT"
        A._dict['key'] = self
        print ""

a1 = A()
a2 = A()
a3 = A()
</code></pre>
<p>Outputs:</p>
<pre><code>NEW
INIT

EXISTS
INIT

EXISTS
INIT
</code></pre>
<p>Why?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Use <strong>__new__</strong> when you need to control
  the creation of a new instance. Use
  <strong>__init__</strong> when you need to control initialization of a new instance.</p>
<p><strong>__new__</strong> is the first step of instance creation.  It's called first, and is
  responsible for returning a new
  instance of your class.  In contrast,
  <strong>__init__</strong> doesn't return anything; it's only responsible for initializing the
  instance after it's been created.</p>
<p>In general, you shouldn't need to
  override <strong>__new__</strong> unless you're
  subclassing an immutable type like
  str, int, unicode or tuple.</p>
</blockquote>
<p>From: <a href="http://mail.python.org/pipermail/tutor/2008-April/061426.html" rel="noreferrer">http://mail.python.org/pipermail/tutor/2008-April/061426.html</a></p>
<p>You should consider that what you are trying to do is usually done with a <a href="http://en.wikipedia.org/wiki/Factory_object" rel="noreferrer">Factory</a> and that's the best way to do it. Using <strong>__new__</strong> is not a good clean solution so please consider the usage of a factory. Here you have <a href="http://code.activestate.com/recipes/86900/" rel="noreferrer">a good factory example</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>__new__</code></strong> is static class method, while <strong><code>__init__</code></strong> is instance method. 
<strong><code>__new__</code></strong> has to create the instance first, so <strong><code>__init__</code></strong> can initialize it. Note that <strong><code>__init__</code></strong> takes <strong><code>self</code></strong> as parameter. Until you create instance there is no <strong><code>self</code></strong>.</p>
<p>Now, I gather, that you're trying to implement <a href="http://en.wikipedia.org/wiki/Singleton_pattern" rel="noreferrer">singleton pattern</a> in Python. There are a few ways to do that.</p>
<p>Also, as of Python 2.6, you can use class <a href="http://www.python.org/dev/peps/pep-0318/" rel="noreferrer">decorators</a>. </p>
<pre><code>def singleton(cls):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In most well-known OO languages, an expression like <code>SomeClass(arg1, arg2)</code> will allocate a new instance, initialise the instance's attributes, and then return it.</p>
<p>In most well-known OO languages, the "initialise the instance's attributes" part can be customised for each class by defining a <strong>constructor</strong>, which is basically just a block of code that operates on the new instance (using the arguments provided to the constructor expression) to set up whatever initial conditions are desired. In Python, this corresponds to the class' <code>__init__</code> method.</p>
<p>Python's <code>__new__</code> is nothing more and nothing less than similar per-class customisation of the "allocate a new instance" part. This of course allows you to do unusual things such as returning an existing instance rather than allocating a new one. So in Python, we shouldn't really think of this part as necessarily involving allocation; all that we require is that <code>__new__</code> comes up with a suitable instance from somewhere.</p>
<p>But it's still only half of the job, and there's no way for the Python system to know that sometimes you want to run the other half of the job (<code>__init__</code>) afterwards and sometimes you don't. If you want that behavior, you have to say so explicitly.</p>
<p>Often, you can refactor so you only need <code>__new__</code>, or so you don't need <code>__new__</code>, or so that <code>__init__</code> behaves differently on an already-initialised object. But if you really want to, Python does actually allow you to redefine "the job", so that <code>SomeClass(arg1, arg2)</code> doesn't necessarily call <code>__new__</code> followed by <code>__init__</code>. To do this, you need to create a metaclass, and define its <code>__call__</code> method.</p>
<p>A metaclass is just the class of a class. And a class' <code>__call__</code> method controls what happens when you call instances of the class. So a <em>metaclass</em>' <code>__call__</code> method controls what happens when you call a class; i.e. it allows you to <strong>redefine the instance-creation mechanism from start to finish</strong>. This is the level at which you can most elegantly implement a completely non-standard instance creation process such as the singleton pattern. In fact, with less than 10 lines of code you can implement a <code>Singleton</code> metaclass that then doesn't even require you to futz with <code>__new__</code> <strong>at all</strong>, and can turn <em>any</em> otherwise-normal class into a singleton by simply adding <code>__metaclass__ = Singleton</code>!</p>
<pre><code>class Singleton(type):
    def __init__(self, *args, **kwargs):
        super(Singleton, self).__init__(*args, **kwargs)
        self.__instance = None
    def __call__(self, *args, **kwargs):
        if self.__instance is None:
            self.__instance = super(Singleton, self).__call__(*args, **kwargs)
        return self.__instance
</code></pre>
<p>However this is probably deeper magic than is really warranted for this situation!</p>
</div>
<div class="post-text" itemprop="text">
<p>To quote the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>Typical implementations create a new instance of the class by invoking
  the superclass's __new__() method using "super(currentclass,
  cls).__new__(cls[, ...])"with appropriate arguments and then
  modifying the newly-created instance as necessary before returning it.</p>
<p>...</p>
<p>If __new__() does not return an instance of cls, then the new
  instance's __init__() method will not be invoked.</p>
<p>__new__() is intended mainly to allow subclasses of immutable
  types (like int, str, or tuple) to customize instance creation.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I realize that this question is quite old but I had a similar issue.
The following did what I wanted:</p>
<pre><code>class Agent(object):
    _agents = dict()

    def __new__(cls, *p):
        number = p[0]
        if not number in cls._agents:
            cls._agents[number] = object.__new__(cls)
        return cls._agents[number]

    def __init__(self, number):
        self.number = number

    def __eq__(self, rhs):
        return self.number == rhs.number

Agent("a") is Agent("a") == True
</code></pre>
<p>I used this page as a resource <a href="http://infohost.nmt.edu/tcc/help/pubs/python/web/new-new-method.html">http://infohost.nmt.edu/tcc/help/pubs/python/web/new-new-method.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think the simple answer to this question is that, if <code>__new__</code> returns a value that is the same type as the class, the <code>__init__</code> function executes, otherwise it won't. In this case your code returns <em><code>A._dict('key')</code></em> which is the same class as <em><code>cls</code></em>, so <code>__init__</code> will be executed.</p>
</div>
<div class="post-text" itemprop="text">
<p>When <code>__new__</code> returns instance of the same class, <code>__init__</code> is run afterwards on returned object. I.e. you can NOT use <code>__new__</code> to prevent <code>__init__</code> from being run. Even if you return previously created object from <code>__new__</code>, it will be double (triple, etc...) initialized by <code>__init__</code> again and again.</p>
<p>Here is the generic approach to Singleton pattern which extends vartec answer above and fixes it:</p>
<pre><code>def SingletonClass(cls):
    class Single(cls):
        __doc__ = cls.__doc__
        _initialized = False
        _instance = None

        def __new__(cls, *args, **kwargs):
            if not cls._instance:
                cls._instance = super(Single, cls).__new__(cls, *args, **kwargs)
            return cls._instance

        def __init__(self, *args, **kwargs):
            if self._initialized:
                return
            super(Single, self).__init__(*args, **kwargs)
            self.__class__._initialized = True  # Its crucial to set this variable on the class!
    return Single
</code></pre>
<p>Full story is <a href="http://tech.zarmory.com/2015/01/python-singleton-pattern-generic.html" rel="noreferrer">here</a>.</p>
<p>Another approach, which in fact involves <code>__new__</code> is to use classmethods:</p>
<pre><code>class Singleton(object):
    __initialized = False

    def __new__(cls, *args, **kwargs):
        if not cls.__initialized:
            cls.__init__(*args, **kwargs)
            cls.__initialized = True
        return cls


class MyClass(Singleton):
    @classmethod
    def __init__(cls, x, y):
        print "init is here"

    @classmethod
    def do(cls):
        print "doing stuff"
</code></pre>
<p>Please pay attention, that with this approach you need to decorate ALL of your methods with <code>@classmethod</code>, because you'll never use any real instance of <code>MyClass</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class M(type):
    _dict = {}

    def __call__(cls, key):
        if key in cls._dict:
            print 'EXISTS'
            return cls._dict[key]
        else:
            print 'NEW'
            instance = super(M, cls).__call__(key)
            cls._dict[key] = instance
            return instance

class A(object):
    __metaclass__ = M

    def __init__(self, key):
        print 'INIT'
        self.key = key
        print

a1 = A('aaa')
a2 = A('bbb')
a3 = A('aaa')
</code></pre>
<p>outputs:</p>
<pre><code>NEW
INIT

NEW
INIT

EXISTS
</code></pre>
<p>NB As a side effect <code>M._dict</code> property automatically becomes accessible from <code>A</code> as <code>A._dict</code> so take care not to overwrite it incidentally.</p>
</div>
<div class="post-text" itemprop="text">
<p>__new__ should return a new, blank instance of a class. __init__ is then called to initialise that instance. You're not calling __init__ in the "NEW" case of __new__, so it's being called for you. The code that is calling <code>__new__</code> doesn't keep track of whether __init__ has been called on a particular instance or not nor should it, because you're doing something very unusual here.</p>
<p>You could add an attribute to the object in the __init__ function to indicate that it's been initialised. Check for the existence of that attribute as the first thing in __init__ and don't proceed any further if it has been.</p>
</div>
<div class="post-text" itemprop="text">
<p>An update to @AntonyHatchkins answer, you probably want a separate dictionary of instances for each class of the metatype, meaning that you should have an <code>__init__</code> method in the metaclass to initialize your class object with that dictionary instead of making it global across all the classes.</p>
<pre><code>class MetaQuasiSingleton(type):
    def __init__(cls, name, bases, attibutes):
        cls._dict = {}

    def __call__(cls, key):
        if key in cls._dict:
            print('EXISTS')
            instance = cls._dict[key]
        else:
            print('NEW')
            instance = super().__call__(key)
            cls._dict[key] = instance
        return instance

class A(metaclass=MetaQuasiSingleton):
    def __init__(self, key):
        print 'INIT'
        self.key = key
        print()
</code></pre>
<p>I have gone ahead and updated the original code with an <code>__init__</code> method and  changed the syntax to Python 3 notation (no-arg call to <code>super</code> and metaclass in the class arguments instead of as an attribute).</p>
<p>Either way, the important point here is that your class initializer (<code>__call__</code> method) will not execute either <code>__new__</code> or <code>__init__</code> if the key is found. This is much cleaner than using <code>__new__</code>, which requires you to mark the object if you want to skip the default <code>__init__</code> step.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://www.python.org/download/releases/2.2/descrintro/#__new__" rel="nofollow">Referring to this doc</a>: </p>
<blockquote>
<p>When subclassing immutable built-in types like numbers and strings,
  and occasionally in other situations, the static method <strong>new</strong> comes
  in handy. <strong>new</strong> is the first step in instance construction, invoked
  before <strong>init</strong>. </p>
<p>The <strong>new</strong> method is called with the class as its
  first argument; its responsibility is to return a new instance of that
  class. </p>
<p>Compare this to <strong>init</strong>: <strong>init</strong> is called with an instance
  as its first argument, and it doesn't return anything; its
  responsibility is to initialize the instance. </p>
<p>There are situations
  where a new instance is created without calling <strong>init</strong> (for example
  when the instance is loaded from a pickle). There is no way to create
  a new instance without calling <strong>new</strong> (although in some cases you can
  get away with calling a base class's <strong>new</strong>).</p>
</blockquote>
<p>Regarding what you wish to achieve, there also in same doc info about Singleton pattern</p>
<pre><code>class Singleton(object):
        def __new__(cls, *args, **kwds):
            it = cls.__dict__.get("__it__")
            if it is not None:
                return it
            cls.__it__ = it = object.__new__(cls)
            it.init(*args, **kwds)
            return it
        def init(self, *args, **kwds):
            pass
</code></pre>
<p>you may also use this implementation from PEP 318, using a decorator</p>
<pre><code>def singleton(cls):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

@singleton
class MyClass:
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Digging little deeper into that!</p>
<p>The type of a generic class in CPython is <code>type</code> and its base class is <code>Object</code> (Unless you explicitly define another base class like a metaclass). The sequence of low level calls can be found <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L877" rel="nofollow noreferrer">here</a>. The first method called is the <code>type_call</code> which then calls <code>tp_new</code> and then <code>tp_init</code>. </p>
<p>The interesting part here is that <code>tp_new</code> will call the <code>Object</code>'s (base class) new method <code>object_new</code> which does a <code>tp_alloc</code> (<code>PyType_GenericAlloc</code>) which allocates the memory for the object :)</p>
<p>At that point the object is created in memory and then the <code>__init__</code> method gets called. If <code>__init__</code> is not implemented in your class then the <code>object_init</code> gets called and it does nothing :)</p>
<p>Then <code>type_call</code> just returns the object which binds to your variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>One should look at <code>__init__</code> as a simple constructor in traditional OO languages. For example, if you are familiar with Java or C++, the constructor is passed a pointer to its own instance implicitly. In the case of Java, it is the <code>this</code> variable. If one were to inspect the byte code generated for Java, one would notice two calls. The first call is to an "new" method, and then next call is to the init method (which is the actual call to the user defined constructor). This two step process enables creation of the actual instance before calling the constructor method of the class which is just another method of that instance.</p>
<p>Now, in the case of Python, <code>__new__</code> is a added facility that is accessible to the user. Java does not provide that flexibility, due to its typed nature. If a language provided that facility, then the implementor of <code>__new__</code> could do many things in that method before returning the instance, including creating a totally new instance of a unrelated object in some cases. And, this approach also works out well for especially for immutable types in the case of Python.    </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__init__</code> is called after <code>__new__</code> so that when you override it in a subclass, your added code will still get called.</p>
<p>If you are trying to subclass a class that already has a <code>__new__</code>, someone unaware of this might start by adapting the <code>__init__</code> and forwarding the call down to the subclass <code>__init__</code>.  This convention of calling <code>__init__</code> after <code>__new__</code> helps that work as expected.</p>
<p>The <code>__init__</code> still needs to allow for any parameters the superclass <code>__new__</code> needed, but failing to do so will usually create a clear runtime error.  And the <code>__new__</code> should probably explicitly allow for <code>*args</code> and '**kw', to make it clear that extension is OK.</p>
<p>It is generally bad form to have both <code>__new__</code> and <code>__init__</code> in the same class at the same level of inheritance, because of the behavior the original poster described.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<blockquote>
<p>However, I'm a bit confused as to why <strong>init</strong> is always called after <strong>new</strong>.</p>
</blockquote>
</blockquote>
<p>I think the C++ analogy would be useful here:
(A)    <strong>new</strong> simply allocates memory for the object. The instance variables of an object needs memory to hold it, and this is what the step <strong>new</strong> would do.
(B)    <strong>init</strong> initialize the internal variables of the object to specific values (could be default).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>However, I'm a bit confused as to why <code>__init__</code> is always called after <code>__new__</code>.</p>
</blockquote>
<p>Not much of a reason other than that it just is done that way. <code>__new__</code> doesn't have the responsibility of initializing the class, some other method does (<code>__call__</code>, possibly-- I don't know for sure).</p>
<blockquote>
<p>I wasn't expecting this. Can anyone tell me why this is happening and how I implement this functionality otherwise? (apart from putting the implementation into the <code>__new__</code> which feels quite hacky).</p>
</blockquote>
<p>You could have <code>__init__</code> do nothing if it's already been initialized, or you could write a new metaclass with a new <code>__call__</code> that only calls <code>__init__</code> on new instances, and otherwise just returns <code>__new__(...)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simple reason is that the <strong>new</strong> is used for creating an instance, while <strong>init</strong> is used for initializing the instance. Before initializing, the instance should be created first. That's why <strong>new</strong> should be called before <strong>init</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Now I've got the same problem, and for some reasons I decided to avoid decorators, factories and metaclasses. I did it like this:</p>
<h3>Main file</h3>
<pre><code>def _alt(func):
    import functools
    @functools.wraps(func)
    def init(self, *p, **k):
        if hasattr(self, "parent_initialized"):
            return
        else:
            self.parent_initialized = True
            func(self, *p, **k)

    return init


class Parent:
    # Empty dictionary, shouldn't ever be filled with anything else
    parent_cache = {}

    def __new__(cls, n, *args, **kwargs):

        # Checks if object with this ID (n) has been created
        if n in cls.parent_cache:

            # It was, return it
            return cls.parent_cache[n]

        else:

            # Check if it was modified by this function
            if not hasattr(cls, "parent_modified"):
                # Add the attribute
                cls.parent_modified = True
                cls.parent_cache = {}

                # Apply it
                cls.__init__ = _alt(cls.__init__)

            # Get the instance
            obj = super().__new__(cls)

            # Push it to cache
            cls.parent_cache[n] = obj

            # Return it
            return obj
</code></pre>
<h3>Example classes</h3>
<pre><code>class A(Parent):

    def __init__(self, n):
        print("A.__init__", n)


class B(Parent):

    def __init__(self, n):
        print("B.__init__", n)
</code></pre>
<h2>In use</h2>
<pre><code>&gt;&gt;&gt; A(1)
A.__init__ 1  # First A(1) initialized 
&lt;__main__.A object at 0x000001A73A4A2E48&gt;
&gt;&gt;&gt; A(1)      # Returned previous A(1)
&lt;__main__.A object at 0x000001A73A4A2E48&gt;
&gt;&gt;&gt; A(2)
A.__init__ 2  # First A(2) initialized
&lt;__main__.A object at 0x000001A7395D9C88&gt;
&gt;&gt;&gt; B(2)
B.__init__ 2  # B class doesn't collide with A, thanks to separate cache
&lt;__main__.B object at 0x000001A73951B080&gt;
</code></pre>
<ul>
<li><strong>Warning:</strong> You shouldn't initialize Parent, it <em>will</em> collide with other classes - unless you defined separate cache in each of the children, that's not what we want.</li>
<li><strong>Warning:</strong> It seems a class with Parent as grandparent behaves weird. [Unverified]</li>
</ul>
<p><a href="https://tio.run/##nZNPSyQxEMXP5lMU4yUtMrDsTfAwriLeZNmbSMikq@1omw5JNbPt4mcfk/QfezLiYQMDQ7rye69eKranujU/9/sSKxCyIV51RhUXDMKKe9po4h6b6hzObPidvYwf49IV1NJLIjeWrKx0aEjEU1o2@g3L1aI@LofUOTNvYePxsCCS1sccuIQ/rsOD0ug1M8fYp0gyzxhTjfQe7hNy0DqFm1dLPZRakW6NdH3aHlWVVDUGvX/vbM5BCIM7Ibhq/DmYoCXdk0@Su/gvNDk7O4VfNaoXH@Npt8@oCHaaaqBae7i7Bm6KGBtsEQ0oh5KwXEYafUPQWS/tLPiDxl2gyuBgapW@SPmI8mAeWRZ9hk3Wowud@PDalrrSIf5tPzQQM4@ZHZyLrluahyGFNM3CRMgHYdDblGXgIsRzetsRHtUsepjNfDELWWl@h5mqtU2fZzYRRBo7IcLp9CKWe0We1y1S8q@NJ2nUoadw@wHiO4uOF@vFCB1h7jtfx8ipheScfddWuMWADfCc8vu7WUj141vY8OE1TGM7TPjQ4vigzOK6rNOG@Gozx7CK32fa1X/RrnLartYNpou9YCf4FxXXxnbEi2K/3/AfxQc" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<span class="comment-copy">The way it's put right now it's a Singleton, not a Factory.</span>
<span class="comment-copy">Ended up using <code>__new__</code> inside a Factory class, which has become quite clean, so thanks for your input.</span>
<span class="comment-copy">Sorry, I disagree that the use of <code>__new__</code> should be strictly limited to the cases stated. I've found it very useful for implementing extensible generic class factories -- see <a href="http://stackoverflow.com/a/28076300/355230">my answer</a> to the question <i>Improper use of <code>__new__</code> to generate classes in Python?</i> for an example of doing so.</span>
<span class="comment-copy">@Tyler Long, I don't quite understand how does the "@singleton" work? Because the decorator returns a function but MyClass is a class.</span>
<span class="comment-copy">Why the dictionary? Since cls will always be the same and you get a fresh dictionary for instance for each singleton you are creating a dictionary with only one item in it.</span>
<span class="comment-copy">@Alcott: No opinion needed -- <a href="http://docs.python.org/reference/datamodel.html?highlight=__new__#object.__new__" rel="nofollow noreferrer">the docs</a> agree with you.</span>
<span class="comment-copy">@Alcott. yes the decorator returns a function. but both the class and the function are a callable. I think instances = {} should be a global variable.</span>
<span class="comment-copy">@TylerLong Alcott has a good point. This results in the name <code>MyClass</code> being bound to a function that returns instances of the original class. But there's now no way to refer to the original class at all, and <code>MyClass</code> being a function breaks <code>isinstance</code>/<code>issubclass</code> checks, access to class attributes/methods directly as <code>MyClass.something</code>, naming the class in <code>super</code> calls, etc, etc. Whether that's a problem or not depends on the class you're applying it to (and the rest of the program).</span>
<span class="comment-copy"><code>If __new__() does not return an instance of cls, then the new instance's __init__() method will not be invoked.</code> That's an important point. If you return a different instance, original <code>__init__</code> is never called.</span>
<span class="comment-copy">Note: __new__ always returns an appropriate object, so __init__ is always called - even if the instance already exists.</span>
<span class="comment-copy">You are missing an <code>__init__</code> method that sets <code>cls._dict = {}</code>. You probably don't want a dictionary shared by all classes of this metatype (but +1 for the idea).</span>
<span class="comment-copy">Calling a bastardized form of <code>init</code> from <code>__new__</code> sounds really hacky. This is what metaclasses are for.</span>
