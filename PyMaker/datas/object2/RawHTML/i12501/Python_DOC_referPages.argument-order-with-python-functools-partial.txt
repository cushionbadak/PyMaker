<div class="post-text" itemprop="text">
<p>I am trying to using multiprocessing with <code>pool.map</code> to speed execution of a function, but the iterable is not the first argument for that function.  Lambdas won't work because they aren't pickleable.  I tried to use <code>functools.partial</code> to create a new function, but it fails with a <code>TypeError</code>.  Below is a very simple example with the same result.  If I switch the argument order to <code>f(i, s1, s2)</code>, it works as expected.</p>
<p>Why does the argument order matter here?  It is not obvious to me when I read the <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow">doc</a>.</p>
<p>What are my options (other than the obvious of changing the original function)?</p>
<pre><code>import multiprocessing
from functools import partial


def f(s1, s2, i):
    return [s1] + [s2]*i

def main():
    # other code... constants for f aren't known until runtime
    pool = multiprocessing.Pool()
    func = partial(f, s1='a', s2='c')
    for strings in pool.map(func, range(10)):
        print(strings)
    pool.close()
    pool.join()

if __name__ == '__main__':
    main()
</code></pre>
<p>Update:
The best I can think of is to create a wrapper at the module level to switch argument order, then a partial from the wrapper.  Doesn't look pretty or seem pythonic at all.</p>
<pre><code>import multiprocessing
from functools import partial


def f(s1, s2, i):
    return [s1] + [s2]*i

def wrapper(i, s1, s2):
    return f(s1, s2, i)

def main():
    # other code... constants for f aren't known until runtime
    pool = multiprocessing.Pool()
    func = partial(wrapper, s1='foo', s2='bar')
    for strings in pool.map(func, range(10)):
        print(strings)
    pool.close()
    pool.join()

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The order matters because <code>pool.map</code> is invoking <code>f(i, s1='a', s2='c')</code>.
You could write your partial like this:</p>
<pre><code>import multiprocessing

def f(s1, s2, i):
    return [s1] + [s2]*i

def f2(i):
    return f('a','c',i)

if __name__ == '__main__':
    pool = multiprocessing.Pool()
    for strings in pool.map(f2, range(10)):
        print(strings)
    pool.close()
    pool.join()
</code></pre>
<p>If you are using python3.3, <code>pool.starmap</code> is available to you:</p>
<pre><code>import multiprocessing
from itertools import repeat

def f(s1, s2, i):
    return [s1] + [s2]*i

if __name__ == '__main__':
    pool = multiprocessing.Pool()
    for strings in pool.starmap(f, zip(repeat('a'), repeat('c'), range(10))):
        print(strings)
    pool.close()
    pool.join()
</code></pre>
</div>
<span class="comment-copy">I can't just hard code the arguments with something like f2.  Those values aren't known until runtime.  I'll edit my question to make that clearer.  Also I still don't understand why argument order results in this error.  Thanks</span>
<span class="comment-copy">@user2133814, sorry i meant invoking <code>f(i, s1='a', s2='c')</code> instead of <code>func(i, s1='a', s2='b')</code>. In other words, <code>partial</code> returns a callable object with 3 arguments and 2 of them now have default values.</span>
