<div class="post-text" itemprop="text">
<p>I have a python Presenter class that has a method which creates an instance of a different Presenter class:</p>
<pre><code>class MainPresenter(object):
    def showPartNumberSelectionDialog(self, pn):
        view = self.view.getPartNumberSelectionDialog(pn)
        dialog = SecondPresenter(self.model, view)
        dialog.show()
</code></pre>
<p>my intent was to write a separate Presenter class for each window in my application, in order to keep things orderly. Unfortunately, I find it difficult to test the <code>showPartNuberSelectionDialog</code> method, particularly to test that <code>dialog.show()</code> was called, because the instance is created within the method call. So, even if I patch <code>SecondPresenter</code> using python's mock framework, it still doesn't catch the call to the local <code>dialog</code> instance.</p>
<p>So, I have a two questions:</p>
<ol>
<li>How can I change my approach in order to make this code more testable?</li>
<li>Is it considered good practice to test simple code blocks such as this?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Is it possible to patch <code>SecondPresenter</code> and check both how you call it and  if your code call <code>show()</code> too.</p>
<p>By use <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>mock</code></a> framework and <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow"><code>patch</code></a> you should replace <code>SecondPresenter</code> class instance by a <code>Mock</code> object. Take care the <code>dialog</code> instance will be the return value of the mock used to replace the original class instance. Moreover you should take care of <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">where to patch</a>, now I can just guess how to do it but it will not far from the final test version:</p>
<pre><code>@patch("mainpresentermodule.SecondPresenter", autospec=True)
def test_part_number_selection_dialog(self, mock_second_presenter_class):
    main = MainPresenter()
    main.showPartNumberSelectionDialog(123456)
    dialog = mock_second_presenter_class.return_value
    dialog.show.assert_called_with()
</code></pre>
<p>I used <code>autospec=True</code> just because I consider it a best practice, take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="nofollow">Autospeccing</a> for more details.</p>
<p>You can also patch <code>main.view</code> and <code>main.model</code> to test how your code call <code>dialog</code>'s constructor... but you should use mock and not abuse of it, more things you mock and patch and more your tests will be tangled to the code.</p>
<hr/>
<p>For the second question I think it is a good practice test these kind of block also, but try to patch and mock too far as possible and just what you can not use in testing environment: you will have a more flexible tests and you'll can refactor your code by rewriting less test code.</p>
</div>
<span class="comment-copy">You certainly can patch SecondPresenter here.</span>
