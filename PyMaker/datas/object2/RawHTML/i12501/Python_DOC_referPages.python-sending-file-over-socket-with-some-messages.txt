<div class="post-text" itemprop="text">
<p>I have a client-server script using python <a href="https://docs.python.org/2/library/socket.html" rel="nofollow"><code>socket</code></a>, where the client reads a file and sends it over the socket. It works until I try to send something from server to client after the file has been transferred. i.e. after the server receives the file it sends a message that "File Received"
The Server is also using <a href="https://docs.python.org/2/library/threading.html" rel="nofollow"><code>Threading</code></a> (to accommodate concurrent clients) </p>
<p>Here's the server script: </p>
<pre><code>#!/usr/bin/python
import socket
from threading import Thread
from SocketServer import ThreadingMixIn

HOST = '192.168.56.106'
TCP_PORT = 60001
BUFFER_SIZE = 1024


class ClientThread(Thread):

    def __init__(self, ip, port, sock):
        Thread.__init__(self)
        self.ip = ip
        self.port = port
        self.sock = sock

    def run(self):
        filename = 'mytext.txt'
        f = open(filename, 'wb')
        while True:
            data = self.sock.recv(1024)
            if not data:
                f.close()
                # self.sock.close()
                break
            f.write(data)
        self.sock.sendall("File received")
        self.sock.close()


tcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
tcpsock.bind((HOST, TCP_PORT))
threads = []

while True:
    tcpsock.listen(5)
    (conn, (ip, port)) = tcpsock.accept()
    newthread = ClientThread(ip, port, conn)
    newthread.start()
    threads.append(newthread)

for t in threads:
    t.join()
</code></pre>
<p>And client script: </p>
<pre><code>#!/usr/bin/python
import socket

# TCP_IP = 'localhost'
HOST = '192.168.56.106'
TCP_PORT = 60001

BUFFER_SIZE = 1024

socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
socket.connect((HOST, TCP_PORT))

filename='/tmp/f'
f = open(filename, 'rb')

while True:
    chunk = f.read(BUFFER_SIZE)
    if not chunk:
        print "File transfer completed"
        f.close()
        break
    socket.send(chunk)

c = socket.recv(BUFFER_SIZE)
print c
socket.close()
print('connection closed')
</code></pre>
<p>They both apparently stuck in <a href="http://linux.die.net/man/2/recvfrom" rel="nofollow"><code>recevfrom()</code></a> waiting on the other end to send data. </p>
<pre><code># strace -f -e network ./server.py
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(60001), sin_addr=inet_addr("192.168.56.106")}, 16) = 0
listen(3, 5)                            = 0
accept(3, {sa_family=AF_INET, sin_port=htons(49045), sin_addr=inet_addr("192.168.56.106")}, [16]) = 4
Process 4537 attached
[pid  4532] listen(3, 5)                = 0
[pid  4532] accept(3,  &lt;unfinished ...&gt;
[pid  4537] recvfrom(4, "This is test file\n", 1024, 0, NULL, NULL) = 18
[pid  4537] recvfrom(4,


# strace -e network ./client.py
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(60001), sin_addr=inet_addr("192.168.56.106")}, 16) = 0
sendto(3, "This is test file\n", 18, 0, NULL, 0) = 18
File transfer completed
recvfrom(3,
</code></pre>
<p>EDIT:
As suggested by Pynchia, setting a timeout fixed it, here's the working snippet. </p>
<pre><code>while True:
    tcpsock.listen(5)
    (conn, (ip, port)) = tcpsock.accept()
    conn.settimeout(2)
    newthread = ClientThread(ip, port, conn)
    newthread.start()
    threads.append(newthread)
</code></pre>
<p>....</p>
<pre><code> def run(self):
        filename = 'mytext.txt'
        f = open(filename, 'wb')
        while True:
            try:
                data = self.sock.recv(1024)
            except timeout:
                pass
            if not data:
                f.close()
                # self.sock.close()
                break
            f.write(data)
            self.sock.sendall("File received")
        self.sock.close()
</code></pre>
<p>worked like a charm. Of course the above handling of timeout exception needs a bit more tuning (at least I know where to look for now). </p>
<pre><code># strace -f -e network ./server.py
socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(60001), sin_addr=inet_addr("192.168.56.106")}, 16) = 0
listen(3, 5)                            = 0
accept(3, {sa_family=AF_INET, sin_port=htons(49566), sin_addr=inet_addr("192.168.56.106")}, [16]) = 4
Process 13161 attached
[pid 13156] listen(3, 5)                = 0
[pid 13156] accept(3,  &lt;unfinished ...&gt;
[pid 13161] recvfrom(4, "Hello 124\nThis is test file\n&lt;/em"..., 1024, 0, NULL, NULL) = 37
[pid 13161] sendto(4, "File received", 13, 0, NULL, 0) = 13
[pid 13161] recvfrom(4, "", 1024, 0, NULL, NULL) = 0
[pid 13161] +++ exited with 0 +++
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sockets by default are created as blocking (see <a href="https://docs.python.org/3/library/socket.html#notes-on-socket-timeouts" rel="nofollow noreferrer">this note</a> in the official docs).</p>
<p>Therefore in the server the line</p>
<pre><code>data = self.sock.recv(1024)
</code></pre>
<p>blocks indefinitely when the client has finished sending file chunks.</p>
<p>And since the client then goes on to receive something back from the server, the two end up in a deadlock.</p>
<p>In the server code, one solution is to set the socket to non-blocking using</p>
<p><a href="https://docs.python.org/3/library/socket.html#socket.socket.setblocking" rel="nofollow noreferrer">socket.setblocking(flag)</a></p>
<p>or set a timeout using</p>
<p><a href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" rel="nofollow noreferrer">socket.settimeout(value)</a></p>
<p>Please also see this <a href="https://stackoverflow.com/questions/9770567/python-tcp-socket-blocks-on-recv-method">SO Q&amp;A</a></p>
</div>
<span class="comment-copy">Thank you, indeed setting a timeout worked.</span>
