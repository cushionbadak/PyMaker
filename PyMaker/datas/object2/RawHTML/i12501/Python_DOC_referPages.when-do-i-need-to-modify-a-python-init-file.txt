<div class="post-text" itemprop="text">
<p>Suppose that you create a Python package called <code>app</code>, and it contains a module called <code>foo</code>, which has a function called <code>say_hello</code> that prints out <code>Hello!</code> to the console.</p>
<p>Suppose that you also create a second Python package called <code>boss_app</code> that has a module <code>main</code>. The <code>app</code> and <code>boss_app</code> are in the same directory, and the directory is on the Python path. Also, the <code>__init__</code> files are all blank. The structure is:</p>
<pre><code>app
    __init__.py
    foo.py
boss_app
    __init__.py
    main.py
</code></pre>
<p>I want to import <code>app</code> into <code>boss_app.main</code> so that I can call <code>app.foo.say_hello</code>.</p>
<p>I use this command:</p>
<pre><code>import app

app.foo.say_hello()
</code></pre>
<p>and I expect to see in the console:</p>
<pre><code>&gt;&gt;&gt;&gt; Hello!
</code></pre>
<p>Instead, the behavior I get is that <code>app</code> is imported <em>but</em> it does not have access to <code>foo</code>.</p>
<p>The solution I came up with was to modify <code>app.__init__</code> so that it contained the following command:</p>
<pre><code>from .foo import *
</code></pre>
<p>Now I get the expected behavior.</p>
<p>Is it always necessary to make a custom <code>__init__</code> for a package if that package is going to be imported from an outside package?</p>
</div>
<div class="post-text" itemprop="text">
<p>Saying </p>
<pre><code>import app
</code></pre>
<p>only runs <code>app/__init__.py</code> and makes everything it initializes available to be used as <code>app.SOMENAME</code>.  If you want <code>app.foo</code> module to be available, you need to say <code>import app.foo</code>.  This will load the module.  A common example of this distinction is probably <code>import os</code> vs <code>import os.path</code>.  Just because you say <code>import os</code>, you won't have the contents of <code>os.path</code> package available.</p>
<p>You don't have to break modules into packages, but it helps to avoid module-name collision.  It may also help to keep concepts clear in the mind of a user of these modules.</p>
</div>
<span class="comment-copy">If you want to specifically <code>import app.foo</code> before you can use <code>app.foo.say_hello()</code>, then it's perfectly fine to leave <code>__init__.py</code> empty. So it's really your choice how much convenience versus namespacing you want.</span>
<span class="comment-copy">But in the case that I want to <code>import app</code> and have access to it's namespace, then I have to modify the <code>__init__</code> right?</span>
<span class="comment-copy">Recommended reading: <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html</a></span>
<span class="comment-copy">"<code>import app</code> and have access to it's namespace": that doesn't require modifying<code>__init__.py</code>: <code>import app</code> gives you its namespace and access. What you want to do in your question, however, does. But do read jonrsharpe's link, in particular secction 6.4, and take note of <code>__all__</code>.\</span>
<span class="comment-copy">But <code>import app</code> does not give me access (and does not give an error). I cannot write in the code <code>app.foo.say_hello()</code>. The error I get says that <code>app</code> does not have a member <code>foo</code>. I can do a direct, absolute import and it works, i.e. <code>import app.foo as foo</code>... or <code>from app import foo</code>. I have in fact read this doc, but I'm not seeing where it address this particular use case.</span>
<span class="comment-copy">This seems like it could be the answer to my question. However, in your example, if I import <code>import os</code>, I can still do something like <code>os.path.exists(file_name)</code>. I have not looked at the associated <code>__init__</code> file. It could very well have the appropriate import statements included. What do you think?</span>
<span class="comment-copy">Yes, it means there is a <code>path</code> class inside of the <code>os</code> module (and there is).</span>
<span class="comment-copy">So what you're saying is that a blank <code>__init__</code> will allow classes to be recognized without extra effort but not functions not associated with a class?</span>
<span class="comment-copy"><code>__init__.py</code> makes a directory into a package.  Without it, you can't say <code>import app.foo</code>.  You would have to say <code>import foo</code> and make sure that app is in your import search path.</span>
<span class="comment-copy">So <code>os</code> is not broken up into separate modules? I understand that the <code>__init__</code> is required to make a package. What I don't understand is why when you import the package, it doesn't automatically make everything available as when you import a single module.</span>
