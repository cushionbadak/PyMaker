<div class="post-text" itemprop="text">
<p>Recently, I got an interview question which says to convert string expressions like "1+2-3" and "-2+4" to 0 and 2 respectively. Assuming the inputs are single digits numbers followed by signs and no NULL input. I tried this output but the interviewer said I am close but not perfect solution. Please help me here. Thanks.</p>
<pre><code>def ans(input):
    result, j = 0, 0
    for i in input:
        if i == '+' or i == '-':
            j = i
        else:
            i = int(i)
            result = result j i
    return result       
ans("1+2-3")
ans("-2+4")
</code></pre>
<p>I am making some silly mistake but I am learning. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two things <em>need</em> fixing to work at all:</p>
<ol>
<li><p>You need to handle the initial value properly; when the initial value is non-negative, this fails. Before the loop, set <code>j = '+'</code> so a non-sign prefixed value is added (also, for style points, <code>j</code> is a terrible name, could you use <code>op</code> or something?).</p></li>
<li><p>You can't use variables as operators.</p></li>
</ol>
<p>Replace:</p>
<pre><code>result = result j i
</code></pre>
<p>with:</p>
<pre><code>if j == '+':
    result += i
else:
    result -= i
</code></pre>
<p>Note: If modules are allowed, a generalization can be used to handle operators the "nice" way (though more work would be needed to obey operator precedence). You'd define:</p>
<pre><code>import operator

ops = {'+': operator.add, '-': operator.sub, ...}
</code></pre>
<p>then make the initial value of <code>op</code> <code>operator.add</code> and change the test for operators to:</p>
<pre><code>if i in ops:
    op = ops[i]
else:
    result = op(result, int(i))
</code></pre>
<p>which scales to many more operators, dynamically selecting the operation to perform without cascading <code>if</code>/<code>elif</code> checks.</p>
<p>Side-note: While violating the spirit of the challenge, <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>ast.literal_eval</code></a> (at least as of Python 3.5, and this may change, see <a href="http://bugs.python.org/issue22525" rel="nofollow">bug #22525</a>) will actually safely parse strings like this (<code>eval</code> is unsafe, since it can execute arbitrary code, but <code>ast.literal_eval</code> can only parse Python literals and apparently some basic compile-time math). So you could just do:</p>
<pre><code>import ast

ans = ast.literal_eval
</code></pre>
<p>Sure, it handles many other literals too, but we never defined the failure case behavior anyway. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <strong>eval()</strong> is the simplest solution. Like</p>
<pre><code>eval("1+2-3")
</code></pre>
<p>The following code give another solution without using built-in <strong>eval</strong></p>
<pre><code>import operator


class Parse(object):
    def __init__(self, input):
        self.input = input
        self.pos = 0
        self.end = len(input)

    def eval(self):
        result = self.match_digits()

        while self.pos &lt; self.end:
            op = self.match_operator()
            operand = self.match_digits()
            result = op(result, operand)
        return result

    def match_operator(self):
        look_ahead = self.input[self.pos]
        self.advance()
        return operator.add if look_ahead == '+' else operator.sub

    def match_digits(self):
        look_ahead = self.input[self.pos]

        positive = 1
        if look_ahead == '-':
            positive = -1
            self.advance()

        digits, s = 0, self.pos
        while s &lt; self.end and self.input[s].isdigit():
            digits = digits * 10 + int(self.input[s])
            s += 1
        self.advance(s-self.pos)
        return digits * positive

    def advance(self, offset=1):
        self.pos += offset
</code></pre>
<p>For testing</p>
<pre><code>p = Parse(input='2+1+0-3')
print p.eval()

p = Parse(input='-2+-13+3')
print p.eval()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the most flexible solution (not using <code>eval</code> and able to handle any operations) is to parse the string into a binary (red-black) tree, where leafs are numbers and branches operators (+,-,/,*,etc).</p>
<p>For example, <code>"1+(5*12)/17"</code> would be parsed into following structure:</p>
<pre><code>       "+"
       / \
      1   "/"
         /   \
       "()"   17
       /
      "*"
      / \
     5   12
</code></pre>
<p>Once you've parsed a string into this structure, it's easy to compute by traversing branches depth-first, right to left.</p>
<p>If you need to handle variables, then you'd have to get <code>locals()</code> and replace accordingly, either as you parse the string, or as you traverse the tree.</p>
<p>EDIT:</p>
<p>I created a working example to illustrate this, you can find the source on github: <a href="https://github.com/MJWunderlich/py-math-expression-evaluator" rel="nofollow">https://github.com/MJWunderlich/py-math-expression-evaluator</a></p>
</div>
<div class="post-text" itemprop="text">
<p>what about:</p>
<pre><code>def f(s):
    s = s.strip()
    for i, c in enumerate(s):
        if c == '+':
            return f(s[:i]) + f(s[i+1:])
        if c == '-':
            return f(s[:i]) - f(s[i+1:])
    for i, c in enumerate(s):
        if c == '*':
            return f(s[:i]) * f(s[i+1:])
        if c == '/':
            return f(s[:i]) / f(s[i+1:])
    return 0 if s == '' else int(s)
</code></pre>
<p>? Doesn't work with parenthesis</p>
</div>
<span class="comment-copy">FYI, naming variables <code>str</code> is considered very bad form, as it shadows the Python built-in string constructor, <code>str</code>, which means you can't stringify things for as long as the local <code>str</code> remains in scope.</span>
<span class="comment-copy">Made the updates. Thanks.</span>
<span class="comment-copy"><code>input</code> is a Python built-in function too (though admittedly a less commonly used one).</span>
<span class="comment-copy">The result I my getting in the first case is -2 instead of 0. Any suggestions. Thanks.</span>
<span class="comment-copy">@deep: You must have an indentation or other error somewhere. I ran your exact code with my modifications and it came up with <code>0</code> and <code>2</code>.</span>
<span class="comment-copy">is this right way: if j == '+':                 result += i             elif j == '-':                 result -= i             else:                 result = i</span>
<span class="comment-copy">You don't need the second test. If you initialize <code>j = '+'</code> before the loop begins, then <code>j</code> can only be <code>+</code> or <code>-</code>, nothing else. The code I gave in my numbered list is enough: Initialize <code>j</code> before the loop, and have a single <code>if</code>/<code>else</code> to handle the only possible <code>j</code> values, <code>+</code> and <code>-</code>.</span>
<span class="comment-copy">Not using any "python buildins". Any other way? Thanks.</span>
<span class="comment-copy">@kwarunek: There are nicer ways to point out the danger of <code>eval</code>...</span>
<span class="comment-copy">true, <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">nedbatchelder.com/blog/201206/eval_really_is_dangerous.html</a></span>
<span class="comment-copy">Please don't name stomp/shadow on Python built-ins; there is already an <code>eval</code> function.</span>
<span class="comment-copy">yeah, name it as you want. They are looking for non built in functions so not <code>eval</code>. But true better keep the namespace in order</span>
