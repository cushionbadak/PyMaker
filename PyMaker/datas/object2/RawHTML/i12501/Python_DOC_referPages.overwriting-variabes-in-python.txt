<div class="post-text" itemprop="text">
<p>I wonder if overwriting variables makes any difference in python code.
for example this two codes (function argument is long string in both cases):</p>
<p>first:</p>
<pre><code>def f(a):
    b=a.encode('utf-8')
    c=b[3:]
    return c
</code></pre>
<p>and second:</p>
<pre><code>def f(a):
    a=a.encode('utf-8')
    a=a[3:]
    return a
</code></pre>
<p>I think in first case it will use more memory than in the second.</p>
</div>
<div class="post-text" itemprop="text">
<h2>No differences in the bytecode</h2>
<p>Looking at the byte code, there seems to be no difference:</p>
<pre><code>def f1(a):
    b=a.encode('utf-8')
    c=b[3:]
    return c

def f2(a):
    a=a.encode('utf-8')
    a=a[3:]
    return a


import dis

dis.dis(f1)
  2           0 LOAD_FAST                0 (a)
              3 LOAD_ATTR                0 (encode)
              6 LOAD_CONST               1 ('utf-8')
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             12 STORE_FAST               1 (b)

  3          15 LOAD_FAST                1 (b)
             18 LOAD_CONST               2 (3)
             21 LOAD_CONST               0 (None)
             24 BUILD_SLICE              2
             27 BINARY_SUBSCR
             28 STORE_FAST               2 (c)

  4          31 LOAD_FAST                2 (c)
             34 RETURN_VALUE

dis.dis(f2)
  7           0 LOAD_FAST                0 (a)
              3 LOAD_ATTR                0 (encode)
              6 LOAD_CONST               1 ('utf-8')
              9 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             12 STORE_FAST               0 (a)

  8          15 LOAD_FAST                0 (a)
             18 LOAD_CONST               2 (3)
             21 LOAD_CONST               0 (None)
             24 BUILD_SLICE              2
             27 BINARY_SUBSCR
             28 STORE_FAST               0 (a)

  9          31 LOAD_FAST                0 (a)
             34 RETURN_VALUE
</code></pre>
<h2>No differences in timings</h2>
<p>Look at the run times:</p>
<pre><code>%timeit f1('x')
1000000 loops, best of 3: 547 ns per loop

%timeit f2('x')
1000000 loops, best of 3: 570 ns per loop
</code></pre>
<p>When you repeat this, the values vary and one is tiny bit faster than other. So no difference.</p>
<h2>No difference in memory consumption</h2>
<pre><code>%memit f1('x')
peak memory: 66.32 MiB, increment: 0.02 MiB

%memit f2('x')
peak memory: 66.28 MiB, increment: 0.04 MiB
</code></pre>
</div>
<span class="comment-copy">This is an extreme case of premature optimisation, it really makes no difference which snippet you choose here</span>
<span class="comment-copy">In general, I'd prefer first form: 1) it allows explicit variable names and 2) future modifications where you realize you need one of the former steps at a later point are easier to make.</span>
<span class="comment-copy">the content of <code>a</code> is probably retained outside of the function anyway, so no, you are not saving memory.</span>
<span class="comment-copy"><code>def f(a): return a.encode('utf-8')[3:]</code> have shorter bytecode than both of your functions. (<a href="https://docs.python.org/3/library/dis.html#dis.dis" rel="nofollow noreferrer"><code>dis.dis</code></a>)</span>
<span class="comment-copy">The only opportunity <code>f</code> would have to reuse memory is after the slice operation but before the return statement. Since <code>f</code> doesn't do anything in that interval, there is no effective difference in the memory used by either function. Once each returns, the same memory will be eligible for garbage collection.</span>
