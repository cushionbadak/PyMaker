<div class="post-text" itemprop="text">
<p>Consider two lists of tuples:</p>
<pre><code>data1 = [([X1], 'a'), ([X2], 'b'), ([X3], 'c')]
data2 = [([Y1], 'a'), ([Y2], 'b'), ([Y3], 'c')]
</code></pre>
<p>Where <code>len(data1) == len(data2)</code></p>
<p>Each tuple contains two elements:</p>
<ol>
<li>list of some strings (i.e <code>[X1]</code>)</li>
<li>A <strong>common</strong> element for <code>data1</code> and <code>data2</code>: strings <code>'a'</code>, <code>'b'</code>, and so on.</li>
</ol>
<p>I would like to combine them into following:</p>
<pre><code>[('a', [X1], [Y1]), ('b', [X2], [Y2]),...]
</code></pre>
<p>Does anyone know how I can do this?  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>zip</code> function and a list comprehension:</p>
<pre><code>[(s1,l1,l2) for (l1,s1),(l2,s2) in zip(data1,data2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/users/2867928/kasramvd">@Kasramvd</a>'s solution is good <em>if the order is the same among all elements in the <code>data</code> lists</em>. If they are not, it doesn't take that into account.</p>
<p>A solution that <em>does</em>, utilizes a <strong><a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a></strong>:</p>
<pre><code>from collections import defaultdict

d = defaultdict(list)  # values are initialized to empty list

data1 = [("s1", 'a'), ("s2", 'c'), ("s3", 'b')]
data2 = [("s1", 'c'), ("s2", 'b'), ("s3", 'a')]

for value, common in data1 + data2:
    d[common].append(value)
</code></pre>
<p>In order to get a list of it, simply wrap it in a <a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer"><code>list()</code></a> call:</p>
<pre><code>res = list(d.items())
print(res)
# Prints: [('b', ['s3', 's2']), ('a', ['s1', 's3']), ('c', ['s2', 's1'])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can do this in a single comprehension expression, using the reduce function</p>
<pre><code>from functools import reduce
from operator import add
[tuple([x]+reduce(add,([y[0]] for y in data1+data2 if y[1]==x))) for x in set(y[1] for y in data1+data2)]
</code></pre>
<p>If the lists are large, so that <code>data1+data2</code> imposes a severe time or memory penalty, it might be better to pre-compute it</p>
<pre><code>combdata = data1+data2
[tuple([x]+reduce(add,[y[0]] for y in combdata if y[1]==x))) for x in set(y[1] for y in combdata)]
</code></pre>
<p>This solution does not rely on all "keys" occurring in both lists, or the order being the same.</p>
<p>If returned order is important, we can even do</p>
<pre><code>sorted([tuple([x]+reduce(add,([y[0]] for y in data1+data2 if y[1]==x))) for x in set(y[1] for y in data1+data2)],key = lambda x,y=[x[0] for x in data1+data2]: y.index(x[1]))
</code></pre>
<p>to ensure that the order is the same as in the original lists.  Again, pre-computing <code>data1+data2</code> gives</p>
<pre><code>sorted([tuple([x]+reduce(add,([y[0]] for y in combdata if y[1]==x))) for x in set(y[1] for y in combdata)],key = lambda x,y=[x[0] for x in combdata]: y.index(x[1]))
</code></pre>
</div>
<span class="comment-copy">@Idio, yes I did but was willing to see other's folk's idea's, what turns out to be very helpfull.</span>
