<div class="post-text" itemprop="text">
<p>I have a list of integers called shoesizes and quantities. The integers in the shoesizes list act like bins which have a quantity (in the same index) in the quantities list. I want to reorganise the lists so that I have the shoesizes in ascending order with all the quantities for each shoesize summed together.</p>
<pre><code>shoesizes    = [ 2 ,  5 ,  6 , 1 , 3 , 2 ,  4 ,  5 , 2 , 3 , 1 ]    
quantities   = [ 50, 100, 120, 20, 40, 10, 90 , 10 ,30 , 20, 80]
</code></pre>
<p>So the desired output would be:</p>
<pre><code>orderedsizes = [ 1 , 2 , 3 , 4 , 5 ,  6 ]
totalquant   = [100, 90, 60, 90,110, 120] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you need to sort anyway, <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code> can be used to do this pretty nicely</a>:</p>
<pre><code>from operator import itemgetter
from itertools import groupby

shoesizes    = [ 2 ,  5 ,  6 , 1 , 3 , 2 ,  4 ,  5 , 2 , 3 , 1 ]    
quantities   = [ 50, 100, 120, 20, 40, 10, 90 , 10 ,30 , 20, 80]

# For convenience, short names for itemgetters
getsize, getcnt = itemgetter(0), itemgetter(1)

# Sort to bins of same size next to each other
sorted_bins = sorted(zip(shoesizes, quantities), key=getsize)

# Group and sum bins of same size
summed_sizes = [(k, sum(map(getcnt, g))) for k, g in groupby(sorted_bins, key=getsize)]

# Convert back to separate lists
orderedsizes, totalquant = map(list, zip(*summed_sizes))

print(orderedsizes)
print(totalquant)
</code></pre>
<p>Which outputs:</p>
<pre><code>[1, 2, 3, 4, 5, 6]
[100, 90, 60, 90, 110, 120]
</code></pre>
<p>It's also possible to do this with <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a> (or just <code>collections.defaultdict(int)</code>), then sorting the <code>.items()</code> of the <code>Counter</code>; unless the number of bins is huge, the performance differences are unlikely to matter; if you didn't want to sort in the first place though, <code>Counter</code> makes more sense by avoiding the sort entirely. Example code:</p>
<pre><code>from collections import defaultdict

size_counts = defaultdict(int)
for size, cnt in zip(shoesizes, quantities):
    size_counts[size] += cnt

orderedsizes, totalquant = map(list, zip(*sorted(size_counts.items())))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're creating a dictionary-like structure with duplicate keys. I would accumulate the values like so:</p>
<pre><code># ordersizes is just the set of unique size values in a list: sorted(list(set(shoesizes)))

[sum(v for key, v in zip(shoesizes, quantities) if key == index) for index in orderedsizes]
</code></pre>
</div>
<span class="comment-copy">Why turn an approximately <code>O(n)</code> to <code>O(n log n)</code> (depending on whether you sort first then group or group in a <code>dict</code> then sort, and how much cutdown you get by grouping) algorithm into a <code>O(n**2)</code> algorithm when you don't need to? I mean yes, you can two-line it this way, but to what end? Also, side-note: <code>sorted(list(set(shoesizes)))</code> is redundantly converting to <code>list</code>; <code>sorted</code> already does that, so drop the <code>list</code> constructor and just use <code>sorted(set(shoesizes))</code>.</span>
