<div class="post-text" itemprop="text">
<p>I was working on a problem in which I had to write a program that will count the number of each item needed for the chefs to prepare. The items that a customer can order are: salad, hamburger, and water. <code>salad:[# salad] hamburger:[# hamburger] water:[# water]</code> for example <code>If order = "hamburger water hamburger"</code> then the function returns <code>"salad:0 hamburger:2 water:1"</code></p>
<p>My code is :</p>
<pre><code>def ite(order,item):
    v=order.split()
    t=[]
    for salad in v:
        if salad==item:
            t.append(item)
            v.remove(item)
    return len (t)

def item_order(order):
    s=ite(order,'salad')
    h=ite(order,'hamburger')
    w=ite(order,'water')
    x='salad:%s hamburger:%s water:%s' %(s,h,w)
    return x
</code></pre>
<p>but when we give the input <code>item_order('water water water')</code>, my program prints </p>
<pre><code>salad:0 hamburger:0 water:2  
</code></pre>
<p>instead of </p>
<pre><code>salad:0 hamburger:0 water:3
</code></pre>
<p>It works fine if there are no two consecutive words. How can I correct this?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Solution</h2>
<p>You can use <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter" rel="nofollow">collections.Counter</a>: </p>
<pre><code>from collections import Counter

def item_order(order, items=('salad', 'hamburger', 'water')):
    counter = Counter(order.split())
    return ' '.join(['{}: {}'.format(item, counter.get(item, 0)) for item in items])

print(item_order('water water water'))
print(item_order('water salad, salad'))
print(item_order('water hamburger'))
</code></pre>
<p>test it:</p>
<pre><code>print(item_order('water water water'))
print(item_order('water salad, salad'))
print(item_order('water hamburger'))
</code></pre>
<p>prints:</p>
<pre><code>salad: 0 hamburger: 0 water: 3
salad: 1 hamburger: 0 water: 1
salad: 0 hamburger: 1 water: 1
</code></pre>
<h2>Explanation</h2>
<p>The items are given as default parameter:</p>
<pre><code>def item_order(order, items=('salad', 'hamburger', 'water')):
</code></pre>
<p>This make the function more flexible because you can hand in other items if desired:</p>
<pre><code>def item_order(order, items=('salad', 'fruit', 'water')):
</code></pre>
<p>The use of a tuple is intentional here because mutable default parameters such as a list may cause unintentional side effects. No problem here but could be the vase in general.</p>
<p>After splitting the input string at white spaces into a list, <code>Counter</code> will create a new <code>counter</code> instance:</p>
<pre><code>counter = Counter(order.split())
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; Counter('water water salad'.split())
Counter({'salad': 1, 'water': 2})
</code></pre>
<p>Finally, a list comprehension helps to create anew string:</p>
<pre><code>' '.join(['{}: {}'.format(item, counter.get(item, 0)) for item in items])
</code></pre>
<p>The <code>' '.join</code> makes a new string form a list of strings, where the list elements are separated by white space. For example:</p>
<pre><code>&gt;&gt;&gt; ' '.join(['abc', 'xyz', 'uvw'])
'abc xyz uvw'
</code></pre>
<p>The method <code>get()</code> of the Python dictionary returns the value for the key if the key is in it, otherwise the default value. For example:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 100, 'b': 200}
&gt;&gt;&gt; d.get('a', 0)
100
&gt;&gt;&gt; d.get('x', 0)
0
</code></pre>
<p>Setting this default to <code>0</code>, gives a zero count for items not contained in the order: </p>
<pre><code>counter.get(item, 0))
</code></pre>
<p>Finally, the <code>format()</code> method helps to put the value for the count in a string. For example:</p>
<pre><code>&gt;&gt;&gt; '{}: {}'.format('abc', 10)
'abc: 10'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't do</p>
<pre><code>v.remove(salad)
</code></pre>
<p>Remove that line and it will solve your problem.</p>
<pre><code>In [18]: def ite(order,item):
             v=order.split()
             t=[]                        
             for salad in v:
                 if salad==item:
                     t.append(item)
             return len(t)         

In [19]: item_order('salad salad water')
Out[19]: 'salad:2 hamburger:0 water:1'

In [20]: item_order('salad water salad')
Out[20]: 'salad:2 hamburger:0 water:1'

In [21]: item_order('salad water hamburger')
Out[21]: 'salad:1 hamburger:1 water:1'
</code></pre>
<p>Reason why it wouldn't work for back to back duplicate elements is, in Python, iterating over a sequence does not implicitly make a copy of the list. The list will be modified. You can make the duplicate copy by v[:],</p>
<pre><code>In [98]: def ite(order,item):
    v=order.split()
    t=[]
    for salad in v[:]:
        if salad==item:
            t.append(item)
            v.remove(item)
    return len(t)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You shouldn't use t.remove() while iterating on it. But why?
I tried to simulate your problem </p>
<pre><code>t = ['a', 'b', 'c']
it = iter(it)  # for loop internally use iter() to iterate
it.next()      # it should print 1st element of list which is 'a'
t.remove('a')  #Now list t becomes ['b', 'c']
it.next()      # it should print 2nd element of list which is 'c'
t.remove('b')  #Now list t becomes ['c']
it.next()      #it should print 3rd element of list, But list has only one element
# It throws exception - "StopIteration"
</code></pre>
<p>This exception is handled by "for" loop silently, so "for" loop won't iterate on 3rd element. </p>
</div>
<div class="post-text" itemprop="text">
<p>Altering a list while iterating over it is generally a bad idea - i.e. have you removed an item python has already iterated over or not?</p>
<p>The list object has a count method that may help!</p>
<pre><code>split_order = order.split(" ")
salads = split_order.count('salad')
</code></pre>
<p><a href="https://docs.python.org/2/tutorial/datastructures.html" rel="nofollow">https://docs.python.org/2/tutorial/datastructures.html</a></p>
</div>
<span class="comment-copy">This answer would be better if you explained <i>why</i> it's not a good idea to remove it.</span>
<span class="comment-copy">but why  is it so</span>
<span class="comment-copy">@siddharthyadav Now I cannot find the exact quote in the documentation, but the golden rule is: unless <i>explicitly</i> stated in the documentation, <b>never</b> remove an element while iterating something</span>
<span class="comment-copy">This actually is the only answer that explains why the OP's code doesn't work.</span>
<span class="comment-copy">Although this works fine, you would have to do a <code>order.count('something')</code> for every item to check, which implies iterating the whole list <code>N</code> times, one per item type (not very efficient).</span>
<span class="comment-copy">Agree completely (it isn't more efficient than the original question), however how big a restaurant are we talking about here?!  Either the Counter solution or using defaultdict (with int initialiser)  would be more efficient.  [<a href="https://docs.python.org/2/library/collections.html#collections.defaultdict]" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
