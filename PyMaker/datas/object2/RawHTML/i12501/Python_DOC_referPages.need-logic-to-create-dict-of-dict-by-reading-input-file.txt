<div class="post-text" itemprop="text">
<p>I have a configuration file which contains these lines: </p>
<pre><code>router1 = { 
   hostname: abcd 
      interfaces:{ 
          interface: gigabit 0/1 
          valn: 100 
          name: vlan1
          ip_address: 1.1.1.1 
       } 
   clear: clear config all          
  } 
</code></pre>
<p>My script should read from the configuration file and create a dictionary of dictionaries in the same format. Based on this dictionary I can proceed further with my automation.</p>
</div>
<div class="post-text" itemprop="text">
<p>To solve your problem you need a <a href="https://en.wikipedia.org/wiki/Parsing#Parser" rel="nofollow">parser</a>. There are various libraries that can be used for parsing in Python, see <a href="http://nedbatchelder.com/text/python-parsers.html" rel="nofollow">Python parsing tools</a> by SO veteran Ned Batchelder for a list of what's available.</p>
<p>However, your data format isn't too complicated, so it's easy enough to write a simple parser that doesn't rely on any 3rd-party modules. To break the data up into individual tokens (aka <a href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="nofollow">lexical analysis</a>) we can use the standard <a href="https://docs.python.org/3/library/shlex.html" rel="nofollow">shlex</a> module.</p>
<p>The code below implements a very simple recursive decent parser. It was developed &amp; tested on Python 2.6.6, but it <em>should</em> function correctly on Python 3. You might like to encapsulate it by putting it into a class. IMHO that's probably not really necessary, but I guess that depends on your actual use case.</p>
<p>This code uses the <code>json</code> module to print the parsed dictionary; that's not strictly necessary, but it does make it easy to print nested dictionaries nicely.</p>
<p>The code incorporates some error checking, but it can easily be fooled into accepting weird data, so you may wish to enhance the error checking if you can't guarantee that the input data will always be correct. </p>
<pre><code>#!/usr/bin/env python

''' Parse config file data; see below for example data format
    See http://stackoverflow.com/q/34898816/4014959
    Written by PM 2Ring 2016.01.21
'''

from __future__ import print_function
import shlex
import string
import json

data = '''
router1 = {
    hostname: abcd
        interfaces:{
            interface: gigabit 0/1
            valn: 100
            name: vlan1
            ip_address: 1.1.1.1
        }
    clear: clear config all
}
'''

#Set up a simple lexer. `data` must be a file-/stream-like object
# with read() and readline() methods, or a string 
lex = shlex.shlex(data)
lex.wordchars = string.ascii_letters + string.digits + "./:_"

def t_is(ch):
    ''' verify that the next token is ch '''
    token = next(lex)
    if token != ch:
        raise ValueError('Line %d: Expected %r got %r' 
            % (lex.lineno, ch, token))

def get_word():
    ''' get next token if it's a word.
        Otherwise, push it back &amp; return None
    '''
    token = next(lex)
    if token not in '{}':
        return token
    lex.push_token(token)

def is_key(token):
    return token[-1] == ':'

def get_value():
    ''' get value, which may be a list of words or a dict '''
    token = next(lex)
    if token == '{':
        #Value is a dict
        lex.push_token(token)
        return get_dict()

    #Value consists of one or more non-key words
    value = [token]
    while True:
        token = get_word()
        if token is None:
            break
        if is_key(token):
            lex.push_token(token)
            break
        value.append(token)
    return ' '.join(value)

def get_dict():
    ''' parse a dictionary '''
    t_is('{')
    d = {}
    while True:
        #get key, value pairs
        key = get_word()
        if key is None:
            t_is('}')
            return d
        if not is_key(key):
            raise ValueError('Line %d: Bad key %r' 
                % (lex.lineno, key))
        d[key[:-1]] = get_value()

def get_cfg():
    ''' parse config data, returning the name and the dict '''
    name = get_word()
    if name is None:
        raise ValueError('Line %d: Expected name, got %r' 
            % (lex.lineno, next(lex)))
    t_is('=')
    d = get_dict()
    return name, d

#----------------------------------------------------------

print(data)
print(20 * '- ' + '\n')
#for token in lex: print(token)

name, cfg = get_cfg()
print(name)
print(json.dumps(cfg, indent=4, sort_keys=True))
</code></pre>
<p><strong>output</strong> </p>
<pre><code>router1 = {
    hostname: abcd
        interfaces:{
            interface: gigabit 0/1
            valn: 100
            name: vlan1
            ip_address: 1.1.1.1
        }
    clear: clear config all
}

- - - - - - - - - - - - - - - - - - - - 

router1
{
    "clear": "clear config all", 
    "hostname": "abcd", 
    "interfaces": {
        "interface": "gigabit 0/1", 
        "ip_address": "1.1.1.1", 
        "name": "vlan1", 
        "valn": "100"
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure why you'd want to do that, but may I suggest JSON?</p>
<p>Try this, save your document (dictionary) as a valid .json file and in python just do this</p>
<pre><code>import json
with open("filename.json",'r') as f:
    data=json.load(f)
print(data)
</code></pre>
<p>The <strong>data</strong> variable should have the same data structure that is stored. If you want something more complex like saving Objects, try pickle </p>
<p><a href="https://docs.python.org/3/library/pickle.html" rel="nofollow">https://docs.python.org/3/library/pickle.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This pyparsing code will parse your config entry into a mapping you can use like a dict or an object:</p>
<pre><code>from pyparsing import *

LBRACE,RBRACE,LBRACK,RBRACK,COLON,EQ = map(Suppress, "{}[]:=")
NL = LineEnd()

key = Word(alphas, alphanums+'_')
# forward declare value, since this will be a recursive definition
value = Forward()
key_value = Group(key + COLON + value)

# parse actions will do string-&gt;int and string-&gt;float conversions at parse time
integer = Regex(r'[+-]?\d+').setParseAction(lambda t: int(t[0]))
real = Regex(r'[+-]?\d+\.\d*').setParseAction(lambda t: float(t[0]))
string = restOfLine.setParseAction(lambda t: t[0].strip())

dictvalue = Group(LBRACE + Dict(ZeroOrMore(key_value)) + RBRACE)
listvalue = Group(LBRACK + Dict(ZeroOrMore(value)) + RBRACK)

# assign recursive contents to value using &lt;&lt;=
value &lt;&lt;= (real | integer) + FollowedBy(NL) | dictvalue | listvalue | string

setting = Group(key + EQ + value)

config_parser = Dict(OneOrMore(setting))

config = config_parser.parseString(data)

# dump out parsed contents
print config.dump()

# access parsed contents like a dict or an object
print config.keys()
print config.router1.keys()
print config.router1.hostname
</code></pre>
<p>prints:</p>
<pre><code>[['router1', [['hostname', 'abcd '], ['interfaces', [['interface', ...
- router1: [['hostname', 'abcd '], ['interfaces', [['interface', ...
  - clear: clear config all          
  - hostname: abcd 
  - interfaces: [['interface', 'gigabit 0/1 '], ['valn', 100], ...
    - interface: gigabit 0/1 
    - ip_address: 1.1.1.1 
    - name: vlan1
    - valn: 100
['router1']
['interfaces', 'hostname', 'clear']
abcd 
</code></pre>
<p>Note that those values that are valid floats or ints will have already been converted from strings as part of the parsing process.</p>
</div>
<span class="comment-copy">You are pasting the same dictonary twice.</span>
<span class="comment-copy">I need to create dictionary in the same format</span>
<span class="comment-copy">I can't understand what are you looking for. I see the same content in the first piece of code and the second.</span>
<span class="comment-copy">There's a problem with this approach, OP's input is not a valid JSON document.</span>
<span class="comment-copy">I am getting following error after using above code:ValueError: No JSON object could be decoded</span>
<span class="comment-copy">@vaultah I think the OP only wants to store and retrieve his data from disk. He just cannot put it in better words. Maybe I'm wrong.  OP: Please read about JSON if you're actually trying this approach since you need to create a valid JSON file if you want to use it.</span>
<span class="comment-copy">Any other method which can help?</span>
<span class="comment-copy">I guess you should edit the question to make your requirement a bit more clear. What is it that you want to do exactly? And what have you done/thought of so far?</span>
