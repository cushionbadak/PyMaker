<div class="post-text" itemprop="text">
<p>I have code that expects <code>str</code> but will handle the case of being passed <code>bytes</code> in the following way:</p>
<pre><code>if isinstance(data, bytes):
    data = data.decode()
</code></pre>
<p>Unfortunately, this does not work in the case of <code>bytearray</code>.  Is there a more generic way to test whether an object is either <code>bytes</code> or <code>bytearray</code>, or should I just check for both?  Is <code>hasattr('decode')</code> as bad as I feel it would be?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few approaches you could use here.</p>
<h1>Duck typing</h1>
<p>Since Python is <a href="http://en.wikipedia.org/wiki/Duck_typing">duck typed</a>, you could simply do as follows (which seems to be the way usually suggested):</p>
<pre><code>try:
    data = data.decode()
except AttributeError:
    pass
</code></pre>
<p>You could use <code>hasattr</code> as you describe, however, and it'd probably be fine. This is, of course, assuming the <code>.decode()</code> method for the given object returns a string, and has no nasty side effects.</p>
<p>I personally recommend either the exception or <code>hasattr</code> method, but whatever you use is up to you.</p>
<h1>Use str()</h1>
<p>This approach is uncommon, but is possible:</p>
<pre><code>data = str(data, "utf-8")
</code></pre>
<p>Other encodings are permissible, just like with the buffer protocol's <code>.decode()</code>. You can also pass a third parameter to specify error handling.</p>
<h1>Single-dispatch generic functions (Python 3.4+)</h1>
<p>Python 3.4 and above include a nifty feature called single-dispatch generic functions, via <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch">functools.singledispatch</a>. This is a bit more verbose, but it's also more explicit:</p>
<pre><code>def func(data):
    # This is the generic implementation
    data = data.decode()
    ...

@func.register(str)
def _(data):
    # data will already be a string
    ...
</code></pre>
<p>You could also make special handlers for <code>bytearray</code> and <code>bytes</code> objects if you so chose.</p>
<p><b>Beware</b>: single-dispatch functions only work on the first argument! This is an intentional feature, see <a href="https://www.python.org/dev/peps/pep-0443/">PEP 433</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>isinstance(data, (bytes, bytearray))
</code></pre>
<p>Due to the different base class is used here. </p>
<pre><code>&gt;&gt;&gt; bytes.__base__
&lt;type 'basestring'&gt;
&gt;&gt;&gt; bytearray.__base__
&lt;type 'object'&gt;
</code></pre>
<p>To check <code>bytes</code></p>
<pre><code>&gt;&gt;&gt; by = bytes()
&gt;&gt;&gt; isinstance(by, basestring)
True
</code></pre>
<p>However, </p>
<pre><code>&gt;&gt;&gt; buf = bytearray()
&gt;&gt;&gt; isinstance(buf, basestring)
False
</code></pre>
<p>The above codes are test under python 2.7</p>
<p>Unfortunately, under python 3.4, they are same....</p>
<pre><code>&gt;&gt;&gt; bytes.__base__
&lt;class 'object'&gt;
&gt;&gt;&gt; bytearray.__base__
&lt;class 'object'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code is not correct unless you know something we don't:</p>
<pre><code>if isinstance(data, bytes):
    data = data.decode()
</code></pre>
<p>You do not (appear to) know the encoding of <code>data</code>.  You are assuming <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="noreferrer">it's UTF-8</a>, but that could very well be wrong.  Since you do not know the encoding, <a href="http://www.joelonsoftware.com/articles/Unicode.html" rel="noreferrer">you do not have text</a>.  You have bytes, which could have any meaning under the sun.</p>
<p>The good news is that most random sequences of bytes are not valid UTF-8, so when this breaks, it will break loudly (<code>errors='strict'</code> is the default) instead of silently doing the wrong thing.  The even better news is that most of those random sequences that happen to be valid UTF-8 are also valid ASCII, which (<a href="https://blogs.msdn.microsoft.com/oldnewthing/20070417-00/?p=27223" rel="noreferrer">nearly</a>) everyone agrees on how to parse anyway.</p>
<p>The bad news is that there is no reasonable way to fix this.  There is a standard way of providing encoding information: use <code>str</code> instead of <code>bytes</code>.  If some third-party code handed you a <code>bytes</code> or <code>bytearray</code> object without any further context or information, the only correct action is to fail.</p>
<hr/>
<p>Now, assuming you do know the encoding, you can use <code>functools.singledispatch</code> here:</p>
<pre><code>@functools.singledispatch
def foo(data, other_arguments, ...):
    raise TypeError('Unknown type: '+repr(type(data)))

@foo.register(str)
def _(data, other_arguments, ...):
    # data is a str

@foo.register(bytes)
@foo.register(bytearray)
def _(data, other_arguments, ...):
    data = data.decode('encoding')
    # explicit is better than implicit; don't leave the encoding out for UTF-8
    return foo(data, other_arguments, ...)
</code></pre>
<p>This doesn't work on methods, and <code>data</code> has to be the first argument.  If those restrictions don't work for you, use one of the other answers instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends what you want to solve. If you want to have the same code that converts both cases to a string, you can simply convert the type to <code>bytes</code> first, and then decode. This way, it is a one-liner:</p>
<pre><code>#!python3

b1 = b'123456'
b2 = bytearray(b'123456')

print(type(b1))
print(type(b2))

s1 = bytes(b1).decode('utf-8')
s2 = bytes(b2).decode('utf-8')

print(s1)
print(s2)
</code></pre>
<p>This way, the answer for you may be:</p>
<pre><code>data = bytes(data).decode()
</code></pre>
<p>Anyway, I suggest to write <code>'utf-8'</code> explicitly to the decode, if you do not care to spare few bytes. The reason is that the next time you or someone else will read the source code, the situation will be more apparent.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two questions here, and the answers to them are different.</p>
<p>The first question, the title of this post, is <em>What is the proper way to determine if an object is a bytes-like object in Python?</em> This includes a number of built-in types (<code>bytes</code>, <code>bytearray</code>, <code>array.array</code>, <code>memoryview</code>, others?) and possibly also user-defined types. The best way I know of to check for these is to try to create a <code>memoryview</code> out of them:</p>
<pre><code>&gt;&gt;&gt; memoryview(b"foo")
&lt;memory at 0x7f7c43a70888&gt;
&gt;&gt;&gt; memoryview(u"foo")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: memoryview: a bytes-like object is required, not 'str'
</code></pre>
<p>In the body of the original post, though, it sounds like the question is instead <em>How do I test whether an object supports decode()?</em> @elizabeth-myers' above answer to this question is great. <strong>Note that not all bytes-like objects support decode().</strong></p>
</div>
<span class="comment-copy">Personally, I love python's duck typing as much as the next guy.  But if you need to be doing checks on your input arguments and coercing to different types, then you're no longer duck typing -- You're just making your code more difficult to read an maintain.  My suggestion here (and others may disagree) would be to make multiple functions (which handle the type coercion and delegate to a base implementation).</span>
<span class="comment-copy">(1) Unless you need it for compatibility with legacy Python 2 code; avoid accepting both text and binary data simultaniously. If your function works with text then it should accept only <code>str</code>. Some other code should convert from bytes to Unicode on input as soon as possible. (2) "bytes-like" has a special meaning in Python (objects that support the buffer protocol (C only))</span>
<span class="comment-copy">+1 for the mention of single-dispatch generics, which I completely forgot the standard library provided.</span>
<span class="comment-copy">Since calling str on str does nothing, and seemed to me the most clear, I went with that.</span>
<span class="comment-copy">overall i like <code>hasattr</code> more than the try/except to prevent you from accidentally swallowing some bug in the decode function, but +1.</span>
<span class="comment-copy">This works very well.  I'm wondering if there is anything more generic, though.</span>
<span class="comment-copy">six.string_types should be 2/3 compatible.</span>
<span class="comment-copy">In the library I am writing, for this specific method, I definitely know that the bytes and/or bytearray I am receiving is UTF-8 encoded.</span>
<span class="comment-copy">@AndrewWilcox: Fair enough, but I'm leaving this information up for future Google traffic.</span>
