<div class="post-text" itemprop="text">
<p>I'm trying to create object dynamically using <code>type</code>. Specifically, I want to create a float which has a <code>len</code>.</p>
<p>This is what I tried:</p>
<pre><code>_float = type('_float', (float,), {})
</code></pre>
<p>Another file, where's the instance created using function (constructor) reference:</p>
<pre><code>obj = x[1](x[0])  # `x` is a 2-length tuple: (value, function)

obj.old = x[0]
obj.__len__ = lambda: len(x[0])  # I'm not sure if this lambda should take argument 'self'

out.append(obj)  # 'out' is a list of output
</code></pre>
<p>This code is in loop, and when it's done, I run following (for testing where's the bug):</p>
<pre><code>print(out[0].old)  # =&gt; 1, correct
print(out[0].__len__)  # &lt;function bla.bla.&lt;lambda&gt; at: 0xblabla&gt;
print(out[0].__len__())  # 1, correct (number of digits)
print(len(out[0]))  # TypeError: object of type '_float' has no len()
</code></pre>
<p>The basic idea is that the user imports my module, gives it a <code>str</code> value and a function. My module's object then applies that function to the <code>str</code> value and returns a resulting object. However, it must keep the original value or at least its <code>__len__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one of the differences between python 3 and python 2.  This would work in python 2 (using "old style" classes), but fails in python 3.</p>
<p>For example, in python 2 the following works:</p>
<pre><code>class test: pass # "old style" class
a = test()
a.__len__ = lambda: 10
len(a) # 10
</code></pre>
<p>but this doesn't</p>
<pre><code>class test(object): pass # inherit from object, "new style" class
a = test()
a.__len__ = lambda self: 10
len(a) # TypeError: object of type 'test' has no len()
</code></pre>
<p>and it doesn't work in python 3 as all classes are "new style".</p>
<p>Essentially, in new style classes anything that uses a built in overloaded method (methods with double underscores on both sides) will bypass the instance altogether, and go straight to the class.</p>
<p>As long as you define the method on the class, it works fine.  For example (python 3)</p>
<pre><code>class test: pass
test.__len__ = lambda self: 10
a = test()
len(a) # 10
</code></pre>
<p>In fact, you can even create the method after instance creation</p>
<pre><code>class test: pass
a = test()
a.__class__.__len__ = lambda self: 10
len(a) # 10
</code></pre>
<p>A search for "python new style classes method lookup" should give you more information than you could ever want on this.  Additionally, chapters 32 and 38 of <em>Learning Python, 5th edition</em> (Oreilly, 2013) discusses these differences in depth.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason why it does not work is explained <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow">here</a></p>
<p>TL;DR You are adding the <code>__len__</code> method to the instance dict and not to the class itself.</p>
<p>Try this:</p>
<pre><code>_float.__len__ = lambda self: YOUR_LEN
</code></pre>
<p>Then this works:</p>
<pre><code>print(len(_float(1)))
</code></pre>
<p>But as the comments suggest subclassing float by defining a class the normal way is somewhat less hacky.</p>
<p><strong>Edit:</strong></p>
<p>If you want your <code>__len__</code> method to return the length of the <code>old</code> attribute  you can do it like this:</p>
<pre><code>_float.__len__ = lambda self: self.old
</code></pre>
<p>This might fail if <code>len</code> is called on an object without an <code>old</code> attribute</p>
<pre><code>AttributeError: '_float' object has no attribute 'old'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe this is enough:</p>
<pre><code>class _float(float):
    def __len__(self):
        return len(str(self))
</code></pre>
<p>Doesn't use dynamic type.</p>
</div>
<span class="comment-copy">Why do you want to create this dynamically, rather than simply subclassing <code>float</code>?</span>
<span class="comment-copy">@DanielRoseman I thought that when I'm calling <code>type(..., (float,), {})</code> I'm subclassing that type, no? I'm pretty new to that, sorry if it's obvious for you.</span>
<span class="comment-copy">Yes but what's the point? Why not do the standard <code>class _float(float):...</code>, and define the <code>__len__</code> method normally on that class?</span>
<span class="comment-copy">@DanielRoseman I want to add the <code>__len__</code> attribute dynamically inside my module and create that module portable, so the user doesn't need to define his custom class (using statement). I also want the <code>__len__</code> to act exactly as I want, so I want it also redefined if user defined it itself.</span>
<span class="comment-copy">@R.O.S.S Some example usage would be good. From the description I can't tell if you're trying to do something really cool, or something very silly and over the top... Can you add the full example of <code>_float</code> and how it's supposed to be used? (and show which bits you mean as "portable" / "custom class")</span>
