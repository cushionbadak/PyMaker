<div class="post-text" itemprop="text">
<p>I am trying to create a basic mathematical quiz and need to be able to store the name of the user next to their score. To ensure that I could edit the data dynamically regardless of the length of the user's name or the number of digits in their score, I decided to split up the name and score with a comma and use the split function. I'm new to file handling in python so don't know if I am using the wrong mode ("r+") but when I complete the quiz, my score is not recorded at all, nothing is added to the file. Here is my code:</p>
<pre><code>for line in class_results.read():
if student_full_name in line:
    student = line.split(",")
    student[1] = correct
    line.replace(line, "{},{}".format(student_full_name, student[1]))
else:
    class_results.write("{},{}".format(student_full_name, correct))
</code></pre>
<p>Please let me know how I can get this system to work. Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes <code>r+</code> opens the file for both reading and writing and to summarize:</p>
<p><code>r</code> when the file will only be read</p>
<p><code>w</code> for only writing (an existing file with the same name will be erased)</p>
<p><code>a</code> opens the file for appending; any data written to the file is automatically added to the end. </p>
<hr/>
<p>I will recommend instead of comma separation to benifit from <strong>json</strong> or <strong>yaml</strong> syntax, it fits better in this case.</p>
<ol>
<li><strong>scores.json</strong>:</li>
</ol>
<pre class="lang-py prettyprint-override"><code>{
      "student1": 12,
      "student2": 798
}
</code></pre>
<p>The solution:</p>
<pre class="lang-py prettyprint-override"><code>import json

with open(filename, "r+") as data:
    scores_dict = json.loads(data.read())
    scores_dict[student_full_name] = correct # if already exist it will be updated otherwise it will be added
    data.seek(0)
    data.write(json.dumps(scores_dict))
    data.truncate()
</code></pre>
<ol start="2">
<li><strong>scores.yml</strong> will looks as follow:</li>
</ol>
<pre class="lang-py prettyprint-override"><code>student1: 45
student2: 7986
</code></pre>
<p>Solution:</p>
<pre class="lang-py prettyprint-override"><code>import yaml

with open(filename, "r+") as data:
    scores_dict = yaml.loads(data.read())
    scores_dict[student_full_name] = correct # if already exist it will be updated otherwise it will be added
    data.seek(0)
    data.write(yaml.dump(scores_dict, default_flow_style=False))
    data.truncate()
</code></pre>
<p>to instal <a href="http://pyyaml.org/wiki/PyYAMLDocumentation" rel="nofollow">yaml python</a> package: <code>pip install pyyaml</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Modifying a file in place is generally a poor way to do this. It risks errors causing the resulting file to be half new data, half old, with the split point being corrupted. The usual pattern is to write to a new file, then atomically replace the old file with the new file, so either you have the entire original old file and a partial new file, or the new file, not a mish-mash of both.</p>
<p>Given your example code, here is how you would fix it up to do that:</p>
<pre><code>import csv
import os
from tempfile import NamedTemporaryFile

origfile = '...'
origdir = os.path.dirname(origfile)

# Open original file for read, and tempfile in same directory for write
with open(origfile, newline='') as inf, NamedTemporaryFile('w', dir=origdir, newline='') as outf:
    old_results = csv.reader(inf)
    new_results = csv.writer(outf)
    for name, oldscore in old_results:
        if name == student_full_name:
            # Found our student, replace their score
            new_results.writerow((name, correct))
            # The write out the rest of the lines unchanged
            new_results.writerows(old_results)
            # and we're done
            break
        else:
            new_results.writerow((name, oldscore))
    else:
        # else block on for loop executes if loop ran without break-ing
        new_results.writerow((student_full_name, correct))

    # If we got here, no exceptions, so let's keep the new data to replace the old
    outf.delete = False

# Atomically replaces the original file with the temp file with updated data
os.replace(outf.name, origfile)
</code></pre>
</div>
<span class="comment-copy"><code>for line in class_results.read()</code> is slurping the whole file into a single <code>str</code> (assuming opened in text mode) and running a loop for every character in the file, not every line. You almost certainly want <code>for line in class_results:</code> which iterates over the lines in the file.</span>
<span class="comment-copy">Also, don't hand-roll CSV parsing, we have the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a>, and you should use it.</span>
<span class="comment-copy">You need to call <code>data.truncate()</code> (probably after <code>seek</code>ing to <code>0</code> for maximum reliability) or writing a smaller output will leave trailing junk.</span>
<span class="comment-copy">You are right, I forget it. It's updated. Thanks!</span>
<span class="comment-copy">Thank you very much, you've been extremely helpful :)</span>
<span class="comment-copy">Thanks for your help! Much Appreciated!</span>
