<div class="post-text" itemprop="text">
<p>One of the use cases python's docs propose for weak references is to keep references to large cached objects without increasing their reference count, <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow">thus not preventing them from being garbage collected when their time  comes</a>.</p>
<p>However, garbage collection is not guaranteed to happen immediately after an object's refcount reaches zero, and a weakref is only invalidated when the GC collects its target. So essentially one can be left holding a valid (not dead) weakref to an invalid object - <a href="https://bitbucket.org/pypy/pypy/issues/1269/weakrefweakset-does-not-work-correctly" rel="nofollow">PyPy's broken WeakSet is one example of such a scenario</a>. </p>
<p>So assuming an adversarialy-minded garbage collector, is there a scenario (apart from finalizers) where weak references provide deterministic and useful behavior to the user?</p>
</div>
<div class="post-text" itemprop="text">
<p>It’s really not about making an object get garbage collected as soon as the references are gone, and making the weak reference invalid in that case. It’s really just about allowing the object to be garbage collected when nothing else references it.</p>
<p>A common use case is the observer pattern, where you add an observer (or listener) to an observable. This is often used for event systems. Let’s say you have a button with a click event; when you now register for that click event with a handler, then you need to make sure to unregister those handlers properly or you will run into memory leaks. The observable will keep a reference to its listeners so those object will never be garbage collected even if they are no longer used (aside from their job as handlers).</p>
<p>Using weak references here prevents listener registrations from counting as references when determining whether to garbage collect an object. So you remove the need to explicitly unregister the event handler, making it easier to use. You can just register the handler with a weak reference, and delete the listener whenever you want.</p>
<p>There are other legitimate use cases, <a href="https://en.wikipedia.org/wiki/Weak_reference" rel="nofollow">Wikipedia has some</a>, but in general, weak references are used to prevent objects from being kept in the memory when there are no other strong references. But that says nothing about when the object actually gets garbage collected.</p>
</div>
<span class="comment-copy">Nowhere in the <code>weakref</code> docs does it guarantee that the object will <i>immediately</i> be deleted when only weak references remain, only that it will be <i>allowed</i> to be deleted: <i>"when the only remaining references to a referent are weak references, garbage collection <b>is free to</b> destroy the referent and reuse its memory for something else"</i>. The GC might <i>never</i> actually delete the object, or reuse that memory, within the program's lifetime.</span>
<span class="comment-copy">Jon, that is exactly my problem with weakrefs.  On refcount==0, I might still have a valid weakref in my hand because the object it's pointing to hasn't been GC'd yet. If I cannot trust the weakref to be invalid in such a case, what useful role can it have in my code?</span>
<span class="comment-copy">Then... don't use them? Why does it matter if you have a valid weakref <i>to an object that still exists</i>, so long as it's correctly invalid once the object stops existing? <i>"What is the use case for python's weakref"</i> -&gt; <i>"A primary use for weak references is to implement caches or mappings holding large objects, where it’s desired that a large object not be kept alive solely because it appears in a cache or mapping."</i></span>
<span class="comment-copy">In the scenario you've described, suppose you have a list of handlers which receive the click event, each handler performing it's own action. And suppose you've implemented this handler list via WeakSet and it is currently: handler_list = {handlerA, handlerB}. Now you invalidate handlerA and delete all strong references to it, but the GC hasn't collected it yet.  Thus, the click event will still be transmitted via the handlerA weakref, causing unwanted behaviour. The only way for you to prevent this, is to .discard if from the set manually, but then why not use set() in the first place?</span>
<span class="comment-copy">But if you cut all other ties of <code>handlerA</code>, then it’s very likely that it will no longer do anything meaningful. And at that point, it simply does not have an actual effect. And that’s better than keeping the object around forever (and <i>also</i> having the same effect). Again, weak references is not about making the reference invalid; it’s about no longer preventing the object from being garbage collected.</span>
<span class="comment-copy">The point I'm trying to make, is that given that the time of weakref invalidation is unknown, you might as well have never used the weakref in the first place. For example, when the role of  HandlerA is to write the click event timestamp to a DB.</span>
<span class="comment-copy">If you use a weak reference, the time of garbage collection is unknown. If you use a strong reference, you know the time is 'at least not as long as the object remains cached', for example. Which is an undesirable, so there are definitely valid use cases for using weak references.</span>
