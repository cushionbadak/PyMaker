<div class="post-text" itemprop="text">
<p>I am using the scipy stats module to calculate the linear regression. ie</p>
<pre><code> slope, intercept, r_value, p_value, std_err 
= stats.linregress(data['cov_0.0075']['num'],data['cov_0.0075']['com'])
</code></pre>
<p>where <code>data</code> is a dictionary containing several <code>'cov_x'</code> keys corresponding to a dataframe with columns <code>'num'</code> and <code>'com'</code></p>
<p>I want to be able to loop through this dictionary and do linear regression on each <code>'cov_x'</code>.  I am not sure how to do this. I tried:</p>
<pre><code>for i in data:
    slope_+str(i), intercept+str(i), r_value+str(i),p_value+str(i),std_err+str(i)= stats.linregress(data[i]['num'],data[i]['com'])
</code></pre>
<p>Essentially I want len(x) slope_x values.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="nofollow">a list comprehension</a> to collect all the <code>stats.linregress</code> return values:</p>
<pre><code>result = [stats.linregress(df['num'],df['com']) for key, df in data.items()]
</code></pre>
<p><code>result</code> is a list of 5-tuples. To collect all the first, second, third, etc... elements from each 5-tuple into separate lists, use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip(*[...])</code></a>:</p>
<pre><code>slopes, intercepts, r_values, p_values, stderrs = zip(*result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be able to do what you're trying to, but there are a couple of things you should watch out for. </p>
<p>First, you can't add a string to a variable name and store it that way. No plus signs on the left of the equals sign. Ever.</p>
<p>You should be able to accomplish what you're trying to do, however. Just make sure that you use the <code>dict</code> data type if you want string indexing.</p>
<pre><code>import scipy.stats as stats
import pandas as pd
import numpy as np
data = {}
l = ['cov_0.0075','cov_0.005']
for i in l:
    x = np.random.random(100)
    y = np.random.random(100)+15
    d = {'num':x,'com':y}
    df = pd.DataFrame(data=d)
    data[i] = df
slope = {}
intercept = {}
r_value = {}
p_value = {}
std_error = {}
for i in data:
    slope[str(i)], \
    intercept[str(i)], \
    r_value[str(i)],\
    p_value[str(i)], std_error[str(i)]= stats.linregress(data[i]['num'],data[i]['com'])
print(slope,intercept,r_value,p_value,std_error)
</code></pre>
<p>should work just fine. Otherwise, you can store individual values and put them in a list later.</p>
</div>
<span class="comment-copy">When I do this it returns the values in reverse order. Ie slope should go from max value to min value rather than min value to max value.</span>
<span class="comment-copy">The keys in a dict (such as <code>data</code>) have no order. In other words, <code>data.items()</code> may return the key/value pairs in any order. If you want the slopes in sorted descending order, then could sort them after the fact: <code>slopes = sorted(slopes, reverse=True)</code> .</span>
<span class="comment-copy">I need them in the indexed order to put the values back into a dataframe. is that possible?</span>
<span class="comment-copy">Sure, but you need to explain in your question what is the indexed order. If the order of the keys in given in a list <code>keys</code>, then you could use <code>result = [stats.linregress(data[key]['num'],data[key]['com']) for key in keys]</code>. Also note that if the order of the keys in <code>data</code> matters, then perhaps <code>data</code> should not be a dict. An ordered data structure such as a list might serve you better.</span>
<span class="comment-copy">The data is in a dict from a previous function I had to do. I will just try and find another way.</span>
<span class="comment-copy">@Riett when I do this I get the following error:    <code>TypeError   Traceback (most recent call last) &lt;ipython-input-135-733714017ed2&gt; in &lt;module&gt;()       5 std_error = {}       6 for i in data: ----&gt; 7     slope[str(i)], intercept[str(i)], r_value[str(i)],p_value[str(i)],std_err[str(i)]= stats.linregress(data[i]['num'],data[i]['RTLnVn'])  TypeError: 'numpy.float64' object does not support item assignment</code></span>
<span class="comment-copy">@Fungie I had an error in my code, used the wrong name for std_error in one of the lines. I can't replicate your problem, however.</span>
<span class="comment-copy">@Fungie I replaced my example with a minimum working example. Does it work now?</span>
