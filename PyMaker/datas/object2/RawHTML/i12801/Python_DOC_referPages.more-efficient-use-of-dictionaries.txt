<div class="post-text" itemprop="text">
<p>I'm going to store on the order of 10,000 securities X 300 date pairs X 2 Types in some caching mechanism.</p>
<p>I'm assuming I'm going to use a dictionary.</p>
<p>Question Part 1:</p>
<p>Which is more efficient or Faster?  Assume that I'll be generally looking up knowing a list of security IDs and the 2 dates plus type.  If there is a big efficiency gain by tweaking my lookup, I'm happy to do that.  Also assume I can be wasteful of memory to an extent.</p>
<p>Method 1: store and look up using keys that look like strings <strong>"securityID_date1_date2_type"</strong></p>
<p>Method 2: store and look up using keys that look like tuples <strong>(securityID, date1, date2, type)</strong></p>
<p>Method 3: store and look up using nested dictionaries of some variation mentioned in methods 1 and 2</p>
<p>Question Part 2:</p>
<p>Is there an easy and better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's going to depend a lot on your use case. Is lookup the only activity or will you do other things, e.g:</p>
<ol>
<li>Iterate <em>all</em> keys/values? For simplicity, you wouldn't want to nest dictionaries if iteration is relatively common.</li>
<li>What about iterating a subset of keys with a given <code>securityID</code>, <code>type</code>, etc.? Nested dictionaries (each keyed on one or more components of your key) would be beneficial if you needed to iterate "keys" with one component having a given value.</li>
<li>What about if you need to iterate based on a different subset of the key components? If that's the case, plain <code>dict</code> is probably not the best idea; you may want relational database, either the built-in <a href="https://docs.python.org/3/library/sqlite3.html" rel="nofollow"><code>sqlite3</code> module</a> or a third party module for a more "production grade" DBMS.</li>
</ol>
<p>Aside from that, it matters quite a bit how you construct and use keys. Strings cache their hash code (and can be interned for even faster comparisons), so if you reuse a string for lookup having stored it elsewhere, it's going to be fast. But <code>tuple</code>s are usually safer (strings constructed from multiple pieces can accidentally produce the same string from different keys if the separation between components in the string isn't well maintained). And you can easily recover the original components from a <code>tuple</code>, where a string would need to be parsed to recover the values. Nested <code>dict</code>s aren't likely to win (and require some finesse with methods like <code>setdefault</code> to populate properly) in a simple contest of lookup speed, so it's only when iterating a subset of the data for a single component of the key that they're likely to be beneficial.</p>
<p>If you want to benchmark, I'd suggest populating a <code>dict</code> with sample data, then use the <code>timeit</code> module (or <code>ipython</code>'s <code>%timeit</code> magic) to test something approximating your use case. Just make sure it's a fair test, e.g. don't lookup the same key each time (using <code>itertools.cycle</code> to repeat a few hundred keys would work better) since <code>dict</code> optimizes for that scenario, and make sure the key is constructed each time, not just reused (unless reuse would be common in the real scenario) so string's caching of hash codes doesn't interfere.</p>
</div>
<span class="comment-copy">What do you mean by efficient? Least lines of code? Easiest to code review? Easiest to document? Least memory use? Fastest? Also, does the data need to persist from one run to the next, or will you load your dictionary each time?</span>
<span class="comment-copy">@Rob: Efficiency means speed.  That's what I meant.</span>
<span class="comment-copy">This is pretty trivial to measure, chances are string will be fastest and ugliest. Although For these tiny numbers, it's hard to imagine speed mattering much. Plus, if you care about speed, why write it in python?</span>
<span class="comment-copy">The question is about using the cartesian product of all the params as keys for an in-memory store. There is essentially no case in which this is going to be slower than using an RDBS of any kind. There's also no mention of iterating, just lookup</span>
