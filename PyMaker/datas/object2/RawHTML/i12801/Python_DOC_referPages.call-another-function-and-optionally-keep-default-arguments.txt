<div class="post-text" itemprop="text">
<p>I have a function with one optional argument, like this:</p>
<pre><code>def funA(x, a, b=1):
   return a+b*x
</code></pre>
<p>I want to write a new function that calls <code>funA</code> and also has an optional argument, but if no argument is passed, I want to keep the default in <code>funA</code>.</p>
<p>I was thinking something like this:</p>
<pre><code>def funB(x, a, b=None):
   if b:
     return funA(x, a, b)
   else:
     return funA(x, a)
</code></pre>
<p>Is there a more pythonic way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would replace <code>if b</code> with <code>if b is not None</code>, so that if you pass <code>b=0</code> (or any other "falsy" value) as argument to <code>funB</code> it will be passed to <code>funA</code>.</p>
<p>Apart from that it seems pretty pythonic to me: clear and explicit. (albeit maybe a bit useless, depending on what you're trying to do!)</p>
<p>A little more cryptic way that relies on calling <code>funB</code> with the correct keyword arguments (e.g. <code>funB(3, 2, b=4)</code>:</p>
<pre><code>def funB(x, a, **kwargs):
    return funA(x, a, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def funA(x, a, b=1):
    return a+b*x

def funB(x, a, b=1):     
   return funA(x, a, b)
</code></pre>
<p>Make the default value of <code>b=1</code> in <code>funB()</code> and then pass it always to <code>funA()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The way you did it is fine. Another way is for <code>funB</code> to have the same defaults as <code>funA</code>, so you can pass the same parameters right through. E.g., if you do <code>def funB(x, a, b=1)</code>, then you can always call <code>return funA(x, a, b)</code> just like that.</p>
<p>For simple cases, the above will work fine. For more complex cases, you may want to use <code>*args</code> and <code>**kwargs</code> (explained <a href="https://stackoverflow.com/questions/3394835/args-and-kwargs">here</a> and <a href="https://stackoverflow.com/questions/36901/what-does-double-star-and-star-do-for-python-parameters">here</a>). Specifically, you can pass in all your keyword arguments as a dictionary (conventionally called <code>kwargs</code>). In this case, each function would set its own independent defaults, and you would just pass the whole dictionary through:</p>
<pre><code>def funA(x, a, **kwargs):
   b = kwargs.get("b", 1)
   return a+b*x

def funB(x, a, **kwargs):
   return funA(x, a, **kwargs)
</code></pre>
<p>If <code>kwargs</code> is empty when passed to <code>funB</code> (<code>b</code> is not specified), it will be set to the default in <code>funA</code> by the statement <code>b = kwargs.get("b", 1)</code>. If <code>b</code> is specified, it will be passed through as-is. Note that in <code>funB</code>, you can access <code>b</code> with its own, independent default value and still get the behavior you are looking for.</p>
<p>While this may seem like overkill for your example, extracting a couple of arguments at the beginning of a function is not a big deal if the function is complex enough. It also gives you a lot more flexibility (such as avoiding many of the common <a href="http://docs.python-guide.org/en/latest/writing/gotchas/" rel="nofollow noreferrer">gotchas</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>FunctionType</code> from <code>types</code>, you can just take a function and create a new one specifying the defaults at runtime. You can put all this in a decorator so that at the point of where you write your code it will keep things tidy, whilst still giving the reader a clue about what you are trying to accomplish. It also allows the exact same call signature for <code>funB</code> as <code>funA</code> -- all arguments can be positional, or all arguments can be keywords, or any valid mix thereof, and any arguments with default values are optional. Should play nice with positional arguments (<code>*args</code>) and keyword arguments (<code>**kwargs</code>) too.</p>
<pre><code>import inspect
from types import FunctionType

def copy_defaults(source_function):
    def decorator(destination_function):
        """Creates a wrapper for the destination function with the exact same 
        signature as source_function (including defaults)."""

        # check signature matches
        src_sig = inspect.signature(source_function)
        dst_sig = inspect.signature(destination_function)
        if list(src_sig.parameters) != list(dst_sig.parameters):
            raise ValueError("src func and dst func do not having matching " \
                "parameter names / order")

        return FunctionType(
            destination_function.__code__,
            destination_function.__globals__,
            destination_function.__name__,
            source_function.__defaults__, # use defaults from src
            destination_function.__closure__
        )
    return decorator

def funA(x, a, b=1):
   return a+b*x

@copy_defaults(funA)
def funB(x, a, b):
    """this is fun B"""
    return funA(x, a, b)

assert funA(1, 2) == funB(1, 2)
assert funB.__name__ == "funB"
assert funB.__doc__ == "this is fun B"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/2/library/inspect.html#inspect.getargspec" rel="nofollow"><code>inspect.getargspec</code></a>, you can get the default values (fourth item of the returned tuple = <code>defaults</code>):</p>
<pre><code>import inspect

def funA(x, a, b=1):
   return a + b * x

# inspect.getargspec(funA) =&gt;
#     ArgSpec(args=['x', 'a', 'b'], varargs=None, keywords=None, defaults=(1,))
def funcB(x, a, b=inspect.getargspec(funA)[3][0]):
    return funA(x, a, b)
</code></pre>
<p>OR (in Python 2.7+)</p>
<pre><code>def funcB(x, a, b=inspect.getargspec(funA).defaults[0]):
    return funA(x, a, b)
</code></pre>
<p>In Python 3.5+, it's recommend to use <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow"><code>inspect.signature</code></a> instead:</p>
<pre><code>def funcB(x, a, b=inspect.signature(funA).parameters['b'].default):
    return funA(x, a, b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use: </p>
<pre><code>def funA(x, a, b=1):
   return a+b*x

def funB(x, a, b=None):
   return funA(*filter(lambda o: o is not None, [x, a, b]))
</code></pre>
<p>Version which will not fail if x or a are None:</p>
<pre><code>def funB(x, a, b=None):
    return funA(*([x, a]+filter(lambda o: o is not None, [b])))
</code></pre>
</div>
<span class="comment-copy">Why not setting the default value for <code>b</code> in <code>funB</code> and then always send with <code>b</code> parameter to <code>funA()</code>?</span>
<span class="comment-copy">The cryptic way is a step backwards. Harder to read with no gain in functionality.</span>
<span class="comment-copy">Yes, you are right ("cryptic" rarely indicates something positive) and it also isn't really the same thing functionally, but still something that may be useful and avoid a lot of code in some situations, probably not this one. But it starts to be convenient if, instead of 1, we have 2,3,4... optional default arguments</span>
<span class="comment-copy">@falsetru that's why I specified "that relies on calling <code>funB</code> with the correct keyword arguments"</span>
<span class="comment-copy">The "cryptic" way is better if you ever use multiple inheritance since you may not know all of the arguments.</span>
<span class="comment-copy">I can't change <code>funA</code>. Take it as given.</span>
<span class="comment-copy">No need to change <code>funA()</code> if you don't want to.</span>
<span class="comment-copy">@itzy if the default of funB is the same as the default of funA this is a good solution</span>
<span class="comment-copy">Ah, sorry, I wasn't clear on this in the question: I don't know what the default argument to <code>funA</code> is. (It's code maintained somewhere else that may change.)</span>
<span class="comment-copy">I would make <code>funB</code> independent of the actual default value used by <code>A</code>. Ideally, you don't want to change <code>funB</code> if <code>funA</code> chooses a different default.</span>
<span class="comment-copy">What, why?! I assume x, a and b must always be passed to x, a and b, not "take the non None values and pass them to the underlying function completely disregarding what/where each parameter is"</span>
<span class="comment-copy">You are right it will fail if x or a is None</span>
<span class="comment-copy">see updated answer</span>
