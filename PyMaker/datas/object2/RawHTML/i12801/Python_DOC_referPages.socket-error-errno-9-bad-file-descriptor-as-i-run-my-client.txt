<div class="post-text" itemprop="text">
<p>as I run my client, my server collapse,</p>
<p>it says:</p>
<pre><code>Traceback (most recent call last):
      File "C:/Users/Or/PycharmProjects/2.6/cyber.py", line 17, in &lt;module&gt;
        data = client_socket.recv(1024)
      File "C:\Python27\lib\socket.py", line 174, in _dummy
        raise error(EBADF, 'Bad file descriptor')
    socket.error: [Errno 9] Bad file descriptor
</code></pre>
<p>server:</p>
<pre><code>import socket
import random
import time

server_socket = socket.socket()
server_socket.bind(('0.0.0.0', 8820))
server_socket.listen(1)

(client_socket, client_address) = server_socket.accept()

TIME = time.asctime(time.localtime())
NAME = "Frank"
RAND = random.randrange(1,10)
EXIT = client_socket.close()
options = [TIME, NAME, RAND, EXIT]

data = client_socket.recv(1024)
if data == str(TIME):
    client_socket.send('Time is: ' + TIME)
elif data == str(NAME):
    client_socket.send('My name is: ' + NAME)
elif data == str(RAND):
    client_socket.send(RAND)
elif data == str(EXIT):
    EXIT




client_socket.close()
server_socket.close()
</code></pre>
<p>client:</p>
<pre><code>import socket

my_socket = socket.socket()
my_socket.connect(('127.0.0.1', 8820))

theData = raw_input("enter command")
options = ['TIME', 'NAME', 'RAND', 'EXIT']
for z in options:
    if theData == z:
        my_socket.send(theData)
        data = my_socket.recv(1024)
        print data
    else:
        theData = raw_input("enter a real command")
</code></pre>
<p>what should I do?</p>
</div>
<div class="post-text" itemprop="text">
<p>The following line in your server <code>blocks</code> until your client connects:</p>
<pre><code>(client_socket, client_address) = server_socket.accept()
</code></pre>
<p>After your client connects, your server does this:</p>
<pre><code>  .... = client_socket.close()
</code></pre>
<p>Then your server does this:</p>
<pre><code> client_socket.recv(1024)
</code></pre>
<p>That ain't ever going to work. </p>
<blockquote>
<p>what should I do?</p>
</blockquote>
<p>Delete this line:</p>
<pre><code>EXIT = client_socket.close()
</code></pre>
<p>Your code has several other problems:</p>
<p>1) You have no idea how much of the data that <code>send()</code> will actually send:</p>
<blockquote>
<p><strong>socket.send(bytes[, flags])</strong><br/>
  ...<br/>
  Applications are responsible for checking that all data has been sent;
  if only some of the data was transmitted, the application needs to
  attempt delivery of the remaining data.
  <a href="https://docs.python.org/3/library/socket.html#socket.socket.send" rel="nofollow">https://docs.python.org/3/library/socket.html#socket.socket.send</a></p>
</blockquote>
<p>In other words, send() won't necessarily be able to send your entire message in one shot--hence the reason send() returns the number of bytes actually sent.  You can use <code>sendall()</code> to ameliorate that problem.</p>
<p>2) However, with both <code>send()</code> and <code>sendall()</code> you have no idea whether your data was sent in 10 chunks, 5 chunks, or all in 1 chunk, so you have to use a loop in order to <code>recv()</code> the entire message:</p>
<pre><code>data = []

while True:
    chunk = my_socket.recv()
    if not chunk: break  #When the other side closes the socket, chunk = ''
    data.append(chunk)

all_data = ''.join(data)
</code></pre>
<p>When the other side closes the socket, <code>recv()</code> will return a blank string.</p>
<p>3) Now the big one: </p>
<pre><code>data = client_socket.recv(1024)
</code></pre>
<p>Your server has to use <code>recv()</code> in a loop to ensure that it reads the entire message from the client:</p>
<pre><code>data = []

while True:
    chunk = client_socket.recv()
    if not chunk: break  #When the other side closes the socket, chunk = ''
    data.append(chunk)

all_data = ''.join(data)
</code></pre>
<p>But how is the read loop going to know when it has read all the data?  Note that as written, the loop terminates when the other side closes the socket causing the <code>recv()</code> to return a blank string, which terminates the while loop.  But, in your case the client doesn't close the socket after its <code>send()</code>, so the server's <code>recv()</code> will never return a blank string, and the while loop will continue trying to <code>recv()</code>--yet the client will have finished sending the message and will be waiting for a response.  Deadlock.</p>
</div>
<span class="comment-copy">iterate a closed port. which ending socket session, server, client ? Always server forever why ? How to check socket errors or bugs ? Don't use auto close (single command or message) function on server. define a close command for shutdown all actions(example: socket already use).</span>
