<div class="post-text" itemprop="text">
<p>So I was trying some things out and then I found a problem with my code.
I am trying to get the user to select a list and then iterate something for the number of items in that list.</p>
<p>I have simplified it here but you can still see the problem.</p>
<pre><code>list1 = [0,1,0,1,0,1]
list2 = [1,0,1,0,1,0]

a = input("Which list do you want to search for?")
for item in range(len(a)):
    print(item)
</code></pre>
<p>This outputs the following:</p>
<pre><code>Which list do you want to search for?list1
0
1
2
3
4
&gt;&gt;&gt; 
</code></pre>
<p>You can see this code does not iterate the number of times I want it to. 
I was wondering if anyone could explain why this is or help me find a solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you get user input into a, it is a string. When you are iterating through it in your example; you are iterating through the actual string 'list1'. </p>
<p>If you wanted to go through the items in the list you need to link them somehow. </p>
<p>Try this:</p>
<pre><code>lists = {
'list1': [0,1,0,1,0,1],
'list2': [1,0,1,0,1,0]}

a = input("Which list do you want to search for?")
if a in lists:
    for item in lists[a]:
        print(item)
else:
    print("Don't have that list")
</code></pre>
<p>Note:</p>
<pre><code>for item in lists[a]
</code></pre>
<p>That lists[a] references that list; you can do what you want with it now; like use range/len....</p>
</div>
<div class="post-text" itemprop="text">
<p>In case you are using Python3 (you must be, otherwise the code works fine),</p>
<p><code>a</code> is a string, not the variable itself.</p>
<p>You can verify it doing</p>
<pre><code>list1 = [0,1,0,1,0,1]
list2 = [1,0,1,0,1,0]
a = input("Which list do you want to search for?")
print(type(a))
</code></pre>
<p>which gives you</p>
<pre><code>&lt;class 'str'&gt;
</code></pre>
<p>So you can try this instead:</p>
<pre><code>for item in range(len(vars()[a])):
    print(item)
</code></pre>
<p>which produces</p>
<pre><code>0
1
2
3
4
5
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow">official docs</a>:</p>
<blockquote>
<p>vars([object])</p>
<p>Return the <strong>dict</strong> attribute for a module, class, instance, or any other object with a <strong>dict</strong> attribute.
  Objects such as modules and instances have an updateable <strong>dict</strong> attribute; however, other objects may have write restrictions on their
  <strong>dict</strong> attributes (for example, classes use a dictproxy to prevent direct dictionary updates).
  Without an argument, vars() acts like locals(). Note, the locals dictionary is only useful for reads since updates to the locals
  dictionary are ignored.</p>
</blockquote>
<p>As an alternative, you can use <code>eval</code></p>
<pre><code>for item in range(len(eval(a))):
    print(item)
</code></pre>
<p>but it's not recommended (see the <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow">official docs</a>) since</p>
<blockquote>
<p>This function can also be used to execute arbitrary code</p>
</blockquote>
<p>Note: there are several ways to solve this problem. For example, as pointed out below, you could decide which list to use by checking the input with an <code>if</code> and hard-code the list in either branch taken. The problem with this option is that it does not fit a higher/variable/dynamic number of lists.</p>
<p>Another approach could be to store the lists in a dictionary and look them up using the input key, as suggested in another answer. This one and mine have the benefit of being able to handle any number of lists, not just a few and even lists created dynamically in the namespace.</p>
</div>
<span class="comment-copy"><code>a</code> is a number or a string, not the name of your variable</span>
<span class="comment-copy">See what happens when you use <code>print(a)</code></span>
<span class="comment-copy"><code>a</code> is the variable if he's using Python 2.x</span>
<span class="comment-copy">@AbuAshrafMasnun thank you for your exact comment. However, had the OP used Python2.x, he'd not have posted the question, since the code would have worked correctly.</span>
<span class="comment-copy">This seems excessively complex for someone who is just learning python. "Return the dict attribute for a module..." hmmmm . And eval is equally confusing. How about an if statement or manual lookup in a dictionary? Could you show the simpler alternatives? There is also know clear way to error check either of these solutions for simple input typos</span>
<span class="comment-copy">@en_Knight Yes, there are many possible ways to solve the problem. Feel free to add your answer.</span>
<span class="comment-copy">@Pynchia fair enough; I know it's  not your job to address all possible answers, I just mean that it seems surprising to have a moderately complicated answer when it there may be considerably simpler ones. Is there a particular reason you recommend these two styles?</span>
