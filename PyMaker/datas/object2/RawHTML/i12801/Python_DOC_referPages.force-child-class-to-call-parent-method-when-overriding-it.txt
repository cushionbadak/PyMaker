<div class="post-text" itemprop="text">
<p>I am curious whether there is a way in Python to force (from the Parent class) for a parent method to be called from a child class when it is being overridden.</p>
<p>Example:</p>
<pre><code>class Parent(object):

    def __init__(self):
        self.someValue=1

    def start(self):
        ''' Force method to be called'''
        self.someValue+=1
</code></pre>
<p>The correct implementation of what I wanted my child Child class to do would be:</p>
<pre><code>class ChildCorrect(Parent):

    def start(self):
        Parent.start(self)
        self.someValue+=1
</code></pre>
<p>However, is there a way to force developers that develop Child classes to specifically call(not just override) the 'start' method defined in the Parent class in case they forget to call it:</p>
<pre><code>class ChildIncorrect(Parent):

    def start(self):
        '''Parent method not called, but correctly overridden'''
        self.someValue+=1
</code></pre>
<p>Also, if this is not considered best practice, what would be an alternative?</p>
</div>
<div class="post-text" itemprop="text">
<h1>How (not) to do it</h1>
<p>No, there is no safe way to force users to call super. Let us go over a few options which would reach that or a similar goal and discuss why it’s a bad idea. In the next section, I will also discuss what the sensible (with respect to the Python community) way to deal with the situation is.</p>
<ol>
<li><p>A metaclass could check, at the time the subclass is defined, whether a method overriding the target method (= has the same name as the target method) calls super with the appropriate arguments.</p>
<p>This requires deeply implementation-specific behaviour, such as using the <a href="https://docs.python.org/3/library/dis.html" rel="noreferrer"><code>dis</code></a> module of CPython. There are no circumstances where I could imagine this to be a good idea—it is dependent on the specific version of CPython and on the fact that you are using CPython at all.</p></li>
<li><p>A metaclass could co-operate with the baseclass. In this scenario, the baseclass notifies the metaclass when the inherited method is called and the metaclass wraps any overriding methods with a piece of guard code.</p>
<p>The guard code tests whether the inherited method got called during the execution of the overriding method. This has the downside that a separate notification channel for each method which needs this "feature" is required, and in addition thread-safety and re-entrance would be a concern. Also, the overriding method has finished execution at the point you notice that it has not called the inherited method, which may be bad depending on your scenario. </p>
<p>It also opens the question: What to do if the overriding method has not called the inherited method? Raising an exception might be unexpected by the code using the method (or, even worse, it might assume that the method had no effect at all, which is not true).</p>
<p>Also the late feedback the developer overriding the class (if they get that feedback at all!) is bad.</p></li>
<li><p>A metaclass could generate a piece of guard code for every overriden method which calls the inherited method <em>automatically</em> before or after the overriding method has executed.</p>
<p>The downside here is developers will not be expecting that the inherited method is being called automatically and have no way to stop that call (e.g. if a precondition special to the subclass is not met) or control when in their own overriding method the inherited method is called.</p>
<p>This violates a good bunch of sensible principles when coding python (avoid surprises, explicit is better than implicit, and possibly more).</p></li>
<li><p>A combination of point 2 and 3. Using the co-operation of base- and metaclass from point 2, the guard code from point 3 could be extended to automatically call super <em>iff</em> the overriding method has not called super themselves.</p>
<p>Again, this is unexpected, but it resolves the issues with duplicate super calls and how to handle a method which does not call super.</p>
<p>However, there are still remaining problems. While thread-safety could be fixed with thread-locals, there is still no way for an overriding method to abort the call to super when a precondition is not met, except by raising an exception which may not be desirable in all cases. Also, super can only be called automatically <em>after</em> the overriding method, not before, which, again, in some scenarios is undesirable.</p></li>
</ol>
<p>Also, none of this help against re-binding the attribute during the lifetime of the object and class, although this can be helped by using descriptors and/or extending the metaclass to take care of it.</p>
<h1>Why not to do it</h1>
<blockquote>
<p>Also, if this is not considered best practice, what would be an alternative?</p>
</blockquote>
<p>A common best-practice with Python is to assume that you are among consenting adults. That means, that noone is actively trying to do nasty things to your code, unless you allow them to. In such an ecosystem, it would make sense to tack a <code>.. warning::</code> in the documentation of the method or class, so that anyone inheriting from that class knows what they have to do.</p>
<p>Also, calling the super method at an appropriate point makes sense in so many contexts that developers using the base class will consider it anyways and only forget about it accidentally. In such a case, using the metaclass from the third point above would not help either—users would have to remember <strong>not</strong> to call super, which might be an issue by itself, especially for experienced programmers. </p>
<p>It also violates the principle of least surprise and "explicit is better than implicit" (noone expects the inherited method to be called implicitly!). This, again, would have to be documented well, in which case you can also resort to just not have super be called automatically and just document that it makes <em>even more sense than usual</em> to call the inherited method.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the class hierarchy is under your control, you can use what the Gang of Four (Gamma, et al) <em>Design Patterns</em> book calls the Template Method Pattern:</p>
<pre><code>class MyBase:
   def MyMethod(self):
      # place any code that must always be called here...
      print "Base class pre-code"

      # call an internal method that contains the subclass-specific code
      self._DoMyMethod()

      # ...and then any additional code that should always be performed
      # here.
      print "base class post-code!"

   def _DoMyMethod(self):
      print "BASE!"


class MyDerived(MyBase):
   def _DoMyMethod(self):
      print "DERIVED!"


b = MyBase()
d = MyDerived()

b.MyMethod()
d.MyMethod()
</code></pre>
<p>outputs:</p>
<pre><code>Base class pre-code
BASE!
base class post-code!
Base class pre-code
DERIVED!
base class post-code!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>However, is there a way to force developers that develop Child classes
  to specifically call(not just override) the 'start' method defined in
  the Parent class in case they forget to call it</p>
</blockquote>
<p>In Python you can not control how others override your functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Very little in Python is about forcing other programmers to code a certain way.  Even in the standard library you will find warnings <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow">such as this</a>:</p>
<blockquote>
<p>If the subclass overrides the constructor, it must make sure to invoke the base class constructor before doing anything else to the thread.</p>
</blockquote>
<p>While it would be possible to use a metaclass to modify subclasses' behavior, the best it could reliably do in this case would be to replace the new methods with yet another method that would take care of calling both the replaced method and the original method.  However, that would have problems if the programmer then <em>did</em> call the parent method in the new code, plus it would lead to bad habits of not calling parent methods when one should.</p>
<p>In other words, Python is not built that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>With some metaclass hacks, you could detect <strong>at runtime</strong> whether the parent start has been called or not. However I will certainly <strong>NOT</strong> recommand using this code in real situations, it's probably buggy in many ways and it's not pythonic to enforce such restrictions.</p>
<pre><code>class ParentMetaClass(type):

    parent_called = False

    def __new__(cls, name, bases, attrs):
        print cls, name, bases, attrs
        original_start = attrs.get('start')
        if original_start:
            if name == 'Parent':
                def patched_start(*args, **kwargs):
                    original_start(*args, **kwargs)
                    cls.parent_called = True

            else:
                def patched_start(*args, **kwargs):
                    original_start(*args, **kwargs)
                    if not cls.parent_called:
                        raise ValueError('Parent start not called')
                    cls.parent_called = False  

            attrs['start'] = patched_start

        return super(ParentMetaClass, cls).__new__(cls, name, bases, attrs)


class Parent(object):
    __metaclass__ = ParentMetaClass

    def start(self):
        print 'Parent start called.'


class GoodChild(Parent):
    def start(self):
        super(GoodChild, self).start()
        print 'I am a good child.'


class BadChild(Parent):
    def start(self):
        print 'I am a bad child, I will raise a ValueError.'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All you need is <a href="https://docs.python.org/3.5/library/functions.html#super" rel="nofollow">super</a>.</p>
<p>With it, your code could look like this:</p>
<pre><code>class Parent(object):
    def __init__(self):
        self.someValue = 1

    def start(self):
        self.someValue += 1


class Child(Parent):
    def start(self):
        # put code here
        super().start()
        # or here
</code></pre>
</div>
<span class="comment-copy">Does the overriding method have to have freedom <i>when</i> it calls super? I.e. would it be okay if the overriding method was forced to call super at the beginning or end of its execution? (Probably, it isn’t okay to restrict that in the general case.) If it is, a metaclass can be used to wrap any overriding method and implicitly call super; the overriding method would then not be allowed to call super by itself (which you might not be able to enforce).</span>
<span class="comment-copy">What about hinting that a user should call the superclass method, similar to the way missing abstract method implementations are picked up with a linter?</span>
<span class="comment-copy">What is a real world example which requires this behavior? The overrider should handle any issues that arise from failing to call <code>super()</code> (for example, resulting in a garbage state in the child instance). I also prefer the pattern of giving the overrider enough rope to hang themselves with (because that's sort of the point in allowing them to extend/customize in the first place).</span>
<span class="comment-copy">And then document that the private method is the one to override.  +1 for the technique, but I advise against actually using it.  ;)</span>
<span class="comment-copy">@EthanFurman Hm, why? Having both pre- and post-code which needs to run seems like a sensible use-case to me (not neccessarily for the original question though). Are there nicer idioms to use here?</span>
<span class="comment-copy">@JonasWielicki:  It is a sensible use-case, but that's not what the OP needed.  To fit the OP's case it would still need to be documented, in which case you may as well just document that the parent method needs to be called.</span>
<span class="comment-copy">@EthanFurman Right, we agree at that point. (I made that not clear enough in my initial version of the comment, to which you, I think, replied.) I was mainly asking because I did exactly that for the use case of having both pre- and post-code, so I was wondering whether I could improve my code.</span>
<span class="comment-copy">@JonasWielicki:  Heh.  Yeah, I think the take-away here is "Document! Document! Document!"  and "Read the docs!"  :)</span>
<span class="comment-copy">Check if you can use <code>metaclass</code> for this demand.</span>
<span class="comment-copy">A metaclass won’t be of any help. In this context, the most useful thing it can do is detecting that the function has been overridden. This is not sufficient though. You would have to check that it calls super appropriately (which cannot be done without relying on implementation-defined behaviour like the <code>dis</code> module in CPython or actually calling the method and tracing the call) and that it does not get re-assigned during lifetime of the instance. Tracing the call when the method is being called can be done with a metaclass, but certainly is overkill.</span>
<span class="comment-copy">Thanks for the explanation; this is what I was aiming to understand and I certainly do not want to implement something that is not pythonic. I thought that maybe, maybe there would be a hidden type of method that I could use to enforce this.</span>
<span class="comment-copy">Thanks for the reply! However, what I am referring to is whether there is anything that I can do to the method defined in the Parent class to force it to be called even though it is overridden. What would happen if a developer would not call this: super(Child, self).start()</span>
<span class="comment-copy">Ugh, I misunderstood you. So, I think that it's impossible in Python by the construction of inheritance - you can override each function, so there is no guarantee that any of your function will be called.  Although, Python has convention that methods/properties which names starts with single underscore (eg. _my_method) are "protected" and you use them at your own risk.</span>
<span class="comment-copy">Well since there is no way to force how your methods are overridden, the only option is to document your base class specifying that they must call the method from super(). The only thing terrible about this answer is that it didn't specify "No."</span>
