<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>list1 = [IM12345, IM12346, IM12347, IM12348]
list2 = [ID300, ID404, ID300, ID601]
</code></pre>
<p><code>list2</code> associates with the corresponding <code>list1</code> values. <code>list1</code> has unique values where as <code>list2</code> has duplicates. </p>
<p>I want to make <code>list2</code> unique corresponding associated value will add in the that <code>list2</code> value.</p>
<pre><code>Dict= {ID300: {IM12345, IM12347}, ID404: IM12346, ID601: IM12348}
</code></pre>
<p>Above pattern can be in list, set or dictionary.</p>
<p>Which algorithm in python should I use to get the above result?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try <a href="http://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>from collections import defaultdict
d = defaultdict(set)

list1 = ['IM12345', 'IM12346', 'IM12347', 'IM12348']
list2 = ['ID300', 'ID404', 'ID300', 'ID601']

for key, value in zip(list2, list1):
    d[key].add(value)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; d
defaultdict(&lt;class 'set'&gt;, {'ID300': {'IM12345', 'IM12347'}, 'ID404': {'IM12346'}, 'ID601': {'IM12348'}})
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; for i, j in d.items():
...     print(i, j)
...     
... 
ID601 {'IM12348'}
ID300 {'IM12345', 'IM12347'}
ID404 {'IM12346'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a dict to save the dataset</p>
<pre><code>list1 = ["IM12345", "IM12346", "IM12347", "IM12348"]
list2 = ["ID300", "ID404", "ID300", "ID601"]

dictResult=dict()
i=0
for item in list2:
    print item
    if dictResult.has_key(item):
        dictResult[item].append(list1[i])
    else:
        dictResult[item]=[list1[i]]
    i=i+1

print dictResult
</code></pre>
<p>Result:</p>
<pre><code>{'ID404': ['IM12346'], 'ID300': ['IM12345', 'IM12347'], 'ID601': ['IM12348']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Might not completely be a pythonic way but - here it goes:
Map the input:</p>
<pre><code>map = dict(zip(list1, list2))
</code></pre>
<p>Now you can do an inverse mapping:</p>
<pre><code>inv_map = {}
for k, v in map.iteritems():
    inv_map[v] = inv_map.get(v, [])
    inv_map[v].append(k)
</code></pre>
<p>Result for the example above:</p>
<pre><code>&gt;&gt;&gt; inv_map
{'ID404': ['IM12346'], 'ID300': ['IM12345', 'IM12347'], 'ID601': ['IM12348']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way of doing it could be with list operations.</p>
<pre><code>yourList = ["1","2","3","4","1","2"] 
newList = [] 
for f in yourList:
    if f not in newList:
       newList.append(f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution</p>
<pre><code>from collections import defaultdict

list1 = ['IM12345', 'IM12346', 'IM12347', 'IM12348']
list2 = ['ID300', 'ID404', 'ID300', 'ID601']

d = defaultdict(list)

for n in range(len(list2)):
    d[list2[n]].append(list1[n])

print d.items()
</code></pre>
<p>Result:</p>
<pre><code>[('ID404', ['IM12346']), ('ID300', ['IM12345', 'IM12347']), ('ID601', ['IM12348'])]
</code></pre>
<p><a href="https://docs.python.org/2/library/collections.html" rel="nofollow">Python2.7 Documentation----defaultdict</a></p>
</div>
