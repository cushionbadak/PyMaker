<div class="post-text" itemprop="text">
<p>I was wondering if there was a relatively simple way to find all subsets of list iteratively. Using recursion, this is easily done and very concise...</p>
<pre><code>def partial(alist, pos, chosen):
    if pos == len(alist):
        return [chosen]
    else:
        return partial(a list, pos+1, chosen) \
               + partial(alist, pos+1, chosen + [alist[pos]])
</code></pre>
<p>This will return a list of lists containing all subsets of a list.</p>
<p>Is there a way to do something like this iteratively without it being overly complicated, or is recursion the best way? Some pseudo-code or something explaining a way to do this iteratively would be helpful. I know <code>itertools</code> is helpful but I would like a solution without the need for it if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>As there are <code>2**n</code> subsets (<code>n</code> is length of the list). You can create a counter from <code>0</code> to <code>2**(n-1)</code>. Then create a list (which is a subset) in each iteration by adding the elements who's corresponding bit is set to <code>1</code> in the counter binary form.</p>
<pre><code>counter = 5
binary_form = 101
you create a subset using first and third element of the original list

counter = 7
binary_form = 111
you create a subset using first, second and third element of the original list
</code></pre>
<p>One could implement this like this,</p>
<pre><code>result = [] 
A = [1,2,3,4]
for i in range(0,2**len(A)):
    binary = bin(i)[2:] 
    binary = '0'*(len(A)-len(binary)) + binary
    subset = [ A[i] for i,x in enumerate(binary) if x=='1' ]
    print binary,subset
    result.append(subset)
print result
</code></pre>
<p>Output</p>
<pre><code>0000 []
0001 [4]
0010 [3]
0011 [3, 4]
0100 [2]
0101 [2, 4]
0110 [2, 3]
0111 [2, 3, 4]
1000 [1]
1001 [1, 4]
1010 [1, 3]
1011 [1, 3, 4]
1100 [1, 2]
1101 [1, 2, 4]
1110 [1, 2, 3]
1111 [1, 2, 3, 4]
</code></pre>
<p>But as mentioned in comments and other answers it is better not to make the binary string. If you want to check if a certain bit is set, you can shift <code>1</code> by desired amount and do a bitwise-and with that number. For example to check if the <code>third</code> bit is set in <code>423</code> you can do this:</p>
<pre><code>number = 423
if number &amp; 1&lt;&lt;3:
    print 'this bit is set'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @sudomakeinstall2 mentioned, you can use a counter from <code>0</code> to <code>2**(n-1)</code> to iterate over the list, and use it as the mask to pick values from <code>alist</code>.</p>
<pre><code>def partial(alist):
    result = []
    for i in range(2 ** len(alist)): # iterate over all results
        tmp = []
        for j in range(len(alist)):
            if (2 ** j) &amp; i:         # use bit mask to pick the value
                tmp.append(alist[j])
        result.append(tmp)

    return result
</code></pre>
<p>The result may be very very large, you may want to create a generator to evaluate lazily.</p>
<p>With list comprehension and generator:</p>
<pre><code>def partial(alist):
    for i in range(2 ** len(alist)):
        yield [alist[j] for j in range(len(alist)) if 2 ** j &amp; i]
</code></pre>
<p>You can call it with</p>
<pre><code>for i in partial([1, 2, 3]):
    print(i)
</code></pre>
<p>or</p>
<pre><code>result = list(partial([1, 2, 3]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Essentially building the list of subsets is the same as building the list of all combinations of sizes 1 through to length of the input. So one solution involves using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">itertools</a>:</p>
<pre><code>import itertools

def all_subsets(l):
    res = []
    for subset_len in range(1, len(l)+1):
        for combo in itertools.combinations(l, subset_len):
            res.append(combo)
    return res

data = [1, 2, 3, 4]
print(all_subsets(data))
</code></pre>
<p>see this in action here: <a href="http://ideone.com/geTdUS" rel="nofollow">http://ideone.com/geTdUS</a></p>
<p>The main reason I'd shy away from using recursion too much in a case such as this is because you might end up with a very large number of recursive calls and the maximum recursion depth in Python might not be deep enough. That said I'm not entirely sure how large an input size this itertools solution will work for.</p>
</div>
<span class="comment-copy">Just to clarify <code>partial([a, b, c])</code> creates: <code>[[a], [b], [c], [a,b], [a,c], [b,c], [a,b,c]]</code>?</span>
<span class="comment-copy">@shuttle87 yeah thats what it does, it also includes empty list but that's not necessary</span>
<span class="comment-copy">What are the other parameters used for here? If the only task is to generate the <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">power set</a> this is fairly easy using itertools.</span>
<span class="comment-copy">@shuttle87 the other parameters are the counter, and the list of lists, so you would run it as so <code>partial(list, 0,[])</code>.</span>
<span class="comment-copy">if it is for creating powersets I'd have a look at <a href="https://stackoverflow.com/questions/18826571/python-powerset-of-a-given-set-with-generators">powerset of a given set</a> - which has both the generator and linear itertools methods listed</span>
<span class="comment-copy">I like the overall idea here but I'd avoid using strings here for the indexing.</span>
<span class="comment-copy">I don't understand. Which part do you mean?</span>
<span class="comment-copy">This answer <a href="http://stackoverflow.com/a/34188401/296460">stackoverflow.com/a/34188401/296460</a> does something very similar to your approach but does not use any strings.</span>
<span class="comment-copy">Essentially the numbers are <i>already</i> binary in the computer, you just need to do bitwise operations on them to extract the information you need. By creating a string that contains the ascii characters for '0' and '1' then testing against that you are essentially creating at the minimum 8times more memory usage because each ascii character needs to be stored in 8 bits at the minimum.</span>
<span class="comment-copy">Yes I know and you are right. I just wanted to show what really happens and print the output of each iteration. But I totally agree with you.</span>
