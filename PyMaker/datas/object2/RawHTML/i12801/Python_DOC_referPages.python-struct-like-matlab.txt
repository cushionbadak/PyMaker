<div class="post-text" itemprop="text">
<p>I seem to have found lots of hack answers, without a 'standardized' answer to this questions. I am looking for an implementation of Matlab's struct in Python, specifically with the two following capabilities:</p>
<ol>
<li>in struct 's', access field value 'a' using dot notation (i.e. s.a)</li>
<li>create fields on the fly, without initialization of dtype, format (i.e. s.b = np.array([1,2,3,4]) )</li>
</ol>
<p>Is there no way to do this in Python? To date, the only solution I have found is <a href="https://stackoverflow.com/questions/11637045/complex-matlab-like-data-structure-in-python-numpy-scipy">here</a>, using a dummy class structtype(). This works but feels a little hackish. 
I also thought maybe scipy would expose its mat_struct, used in loadmat(), but I couldn't find a public interface to it. 
What do other people do? I'm not too worried about performance for this struct, its more of a convenience.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're on 3.3 and up, there's <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow"><code>types.SimpleNamespace</code></a>. Other than that, an empty class is probably your best option.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest and intuitively most similar Python implementation would be to use <code>type</code> to instantiate a temporary class. It is practically similar to making a dummy class, but I think it semantically expresses the intent of a struct--like object more clearly.</p>
<pre><code>&gt;&gt;&gt; s = type('', (), {})()
&gt;&gt;&gt; s.a = 4
&gt;&gt;&gt; s.a
4
</code></pre>
<p>Here, type is used to create a nameless class (hence the <code>''</code>) with no bases (or parent classes, indicated by the empty tuple) and no default class attributes (the empty dictionary) and the final <code>()</code> instantiates the class/struct. Bear in mind that values passed to the dictionary do not show up in the instance's <code>__dict__</code> attribute, but this fact may not be relevant to you. This method also works in older versions (&lt; 3.x) of Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Octave I did:</p>
<pre><code>octave:2&gt;      x.a = 1;
octave:3&gt;      x.b = [1, 2; 3, 4];
octave:4&gt;      x.c = "string";
octave:7&gt; save -7 test.mat x
</code></pre>
<p>In ipython (2.7):</p>
<pre><code>In [27]: from scipy.io import loadmat    
In [28]: A=loadmat('test.mat')

In [29]: A
Out[29]: 
{'__globals__': [],
 '__header__': 'MATLAB 5.0 MAT-file, written by Octave 3.8.2, 2015-12-04 02:57:47 UTC',
 '__version__': '1.0',
 'x': array([[([[1.0]], [[1.0, 2.0], [3.0, 4.0]], [u'string'])]], 
      dtype=[('a', 'O'), ('b', 'O'), ('c', 'O')])}
</code></pre>
<p>In this case <code>A['x']</code> is a numpy structured array, with 3 dtype=object fields.</p>
<pre><code>In [33]: A['x']['b'][0,0]
Out[33]: 
array([[ 1.,  2.],
       [ 3.,  4.]])

In [34]: A['x'][0,0]
Out[34]: ([[1.0]], [[1.0, 2.0], [3.0, 4.0]], [u'string'])

In [35]: A['x'][0,0]['b']
Out[35]: 
array([[ 1.,  2.],
       [ 3.,  4.]])
</code></pre>
<p>Since <code>x</code> comes from MATLAB I have to index it with <code>[0,0]</code>.</p>
<pre><code>octave:9&gt; size(x)
ans =
   1   1
</code></pre>
<p>I can load <code>A</code> with a different switch, and access attributes with <code>.b</code> format:</p>
<pre><code>In [62]: A=loadmat('test.mat',struct_as_record=False)

In [63]: A['x'][0,0].b
Out[63]: 
array([[ 1.,  2.],
       [ 3.,  4.]])
</code></pre>
<p>In this case the elements of <code>A['x']</code> are of type <code>&lt;scipy.io.matlab.mio5_params.mat_struct at 0x9bed76c&gt;</code></p>
<p>Some history might help.  MATLAB originally only had 2d matricies.  Then they expanded it to allow higher dimensions.  <code>cells</code> were added, with the same 2d character, but allowing diverse content.  <code>structures</code> were added, allow 'named' attributes.  The original MATLAB class system was built on structures (just link certain functions to a particular class structure). MATLAB is now in its 2nd generation class system.</p>
<p>Python started off with classes, dictionaries, and lists.  Object attributes are accessed with the same <code>.</code> syntax as MATLAB structures. dictionaries with keys (often, but not always strings).  Lists indexed with integers, and have always allowed diverse content (like <code>cells</code>).  And with a mature object class system, it is possible construct much more elaborate data structures in Python, though access is still governed by basic Python syntax.</p>
<p><code>numpy</code> adds n-dimensional arrays.  A subclass <code>np.matrix</code> is always 2d, modeled on the old style MATLAB matrix.  An array always has the same kind of elements.  But <code>dtype=object</code> arrays contain pointers to Python objects.  In many ways they are just Python lists with an array wrapper.  They are close to MATLAB cells.  </p>
<p><code>numpy</code> also has structured arrays, with a compound <code>dtype</code>, composed of <code>fields</code>.  <code>fields</code> are accessed by name.  <code>np.recarray</code> is a structured array, with added ability to access fields with the <code>.</code> syntax.  That makes them look a lot like MATLAB arrays of structures.</p>
</div>
<span class="comment-copy">Why do you need to use <code>.</code> notation?  Why can't you just use a <code>dict</code>?</span>
<span class="comment-copy">Not a need, more a preference. Maybe I just have to get over it. Without requirement (1), a <code>dict</code> works fine</span>
<span class="comment-copy">A dict is going to be much, much easier to work with, thanks to all the methods it provides.  And it will be shorter to write and will do most, if not all, operations faster.  Plus most built-in and third-party functions and classes you are going to find are designed to work with dicts.</span>
<span class="comment-copy">Matlab's struct is basically a Python dict, (key,value) pairs...</span>
<span class="comment-copy">And if you aren't on 3.3 yet, copying that example implementation into your own code is a perfectly reasonable option. I use something similar a fair bit. Sometimes, it's called a <code>Bunch</code>, e.g. in <code>scikit-learn</code>.</span>
