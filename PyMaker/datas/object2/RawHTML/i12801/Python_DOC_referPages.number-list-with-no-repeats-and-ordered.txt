<div class="post-text" itemprop="text">
<p>This code returns a list [0,0,0] to [9,9,9], which produces no repeats and each element is in order from smallest to largest.</p>
<pre><code>def number_list():
    b=[]
    for position1 in range(10):
        for position2 in range(10):
            for position3 in range(10):
                if position1&lt;=position2 and position2&lt;=position3:
                    b.append([position1, position2, position3])

    return b
</code></pre>
<p>Looking for a shorter and better way to write this code without using multiple variables (position1, position2, position3), instead only using one variable <code>i</code>.</p>
<p>Here is my attempt at modifying the code, but I'm stuck at implementing the <code>if</code> statements:</p>
<pre><code>def number_list():
    b=[]
    for i in range(1000):
        b.append(map(int, str(i).zfill(3)))
    return b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On the same note as the other <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a> answer, there is another way with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow"><code>combinations_with_replacement</code></a>:</p>
<pre><code>list(itertools.combinations_with_replacement(range(10), 3))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply use list comprehension, one way to do it:</p>
<pre><code> &gt;&gt;&gt; [[x,y,z] for x in range(10) for y in range(10) for z in range(10) if x&lt;=y and y&lt;=z]
    [[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 0, 4], [0, 0, 5], [0, 0, 6], 
[0, 0, 7], [0, 0, 8], [0, 0, 9], [0, 1, 1], [0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 1, 5], [0, 1, 6], [0, 1, 7], [0, 1, 8], [0, 1, 9], [0, 2, 2], [0, 2, 3], 
[0, 2, 4], [0, 2, 5], [0, 2, 6], [0, 2, 7], [0, 2, 8], [0, 2, 9], [0, 3, 3], 
[0, 3, 4], [0, 3, 5], [0, 3, 6], [0, 3, 7], [0, 3, 8],....[6, 8, 8], [6, 8, 9], 
[6, 9, 9], [7, 7, 7], [7, 7, 8], [7, 7, 9], [7, 8, 8], [7, 8, 9], [7, 9, 9], 
[8, 8, 8], [8, 8, 9], [8, 9, 9], [9, 9, 9]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simpler way than doing the checks, but which is still IMO worse than <code>combinations_with_replacement</code>:</p>
<pre><code>[(a, b, c) for a in range(10)
           for b in range(a, 10)
           for c in range(b, 10)]
</code></pre>
<p>Namely, instead of filtering values after production you just only produce those values you want in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product()</code></a> to eliminate nested loops:</p>
<pre><code>&gt;&gt;&gt; filter(lambda i: i[0] &lt;= i[1] &lt;= i[2],
...     itertools.product(range(10), range(10), range(10)))
</code></pre>
<p>Or better with list comprehensions:</p>
<pre><code>&gt;&gt;&gt; numbers = itertools.product(range(10), range(10), range(10))
&gt;&gt;&gt; [(a, b, c) for a, b, c in numbers if a &lt;= b &lt;= c]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think it is worthwhile to point out that the original code is weird and can be rewritten easily to be simpler:</p>
<pre><code>def number_list2():
    b=[]
    for position1 in range(10):
        for position2 in range(position1, 10):
            for position3 in range(position2, 10):
                if position1&lt;=position2 and position2&lt;=position3:
                    b.append([position1, position2, position3])

    return b
</code></pre>
<p>There are better solutions here, but this one is the stepping stone to getting to them.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code could be done pretty easily with recursion, without using <code>itertools</code>.</p>
<ol>
<li><code>n</code> - being the length of the tuple</li>
<li><code>m</code> - being the upper bound of each value</li>
</ol>
<p>The Code:</p>
<pre><code>def non_decreasing(n, m):
  if n==0:
    return []
  if n==1:
    return [[i] for i in range(1,m+1)]
  return [[i] + t for t in non_decreasing(n-1, m) for i in range(1,t[0]+1)]
</code></pre>
<p>The result is the output of <code>non_decreasing(3,9)</code></p>
</div>
<span class="comment-copy">Just an FYI, you <b>could</b> write <code>if pos1&lt;=position2&lt;=position3:</code> - this is valid python. Doesn't help, but good to know.</span>
<span class="comment-copy">sounds like you are looking for a recursive algorithm</span>
<span class="comment-copy">Here's a not-serious one: <code>list(set(map(tuple, map(sorted, product(range(10), repeat=3)))))</code>.</span>
<span class="comment-copy">This doesn't accomplish OP's goal. OP expressed an invariant that each element is in order from smallest to largest.</span>
<span class="comment-copy">You need to add the if condition</span>
<span class="comment-copy">@dursk, I still don't get it, aren't they from smallest to largest?</span>
<span class="comment-copy"><code>[0, 1, 0]</code>, for instance, is illegal in OP's condition.</span>
<span class="comment-copy">I think this is the best answer as it uses only vanilla python - no modules.</span>
<span class="comment-copy">Almost there but the checks should be <code>&lt;=</code> instead of <code>&lt;</code></span>
