<div class="post-text" itemprop="text">
<p>I am trying to use Python's <code>__new__</code> in order to return something different than the actual object instance upon instantiating the class (whether that's clever or not is a different discussion). Below is a minimal example, in which I return a list of two class instances from <code>__new__</code>, instead of the actual class instance.</p>
<pre class="lang-python prettyprint-override"><code>from copy import deepcopy

class TestClass:

    def __new__(self, param=None):

        self.__init__(self, param=param)

        return [deepcopy(self), deepcopy(self)]

    def __init__(self, param=None):
        self.param = param


if __name__ == '__main__':
    a = TestClass(param=1)
    b = TestClass(param=2)
    print(a[0].param) #  prints 2!
</code></pre>
<p>However, it appears that I am not able to create actual object instances with this method, as can be seen in the minimal example. The <code>print</code> statement should print 1, but prints 2, meaning the parameters passed to the second invocation of <code>TestClass</code> overwrite the parameters of the first invocation. My guess is that <code>a</code> and <code>b</code> are references to the same <em>static</em> class TestClass, and my deepcopy isn't helping either, because it makes no sense for a static class.</p>
<p>How do I have to tweak <code>__new__</code> and <code>__init__</code> of <code>TestClass</code> such that I'm actually creating new instances (i.e. the print statement should print 1, not 2)?</p>
<p>(Python 3.5)</p>
<p>edit/small clarification: I actually do not want TestClass to be static (if that's the correct lingo anyway), but my non-functional implementation seems to produce something like a static class.</p>
<p><strong>Solution</strong></p>
<p>Thanks to Kay, the following code works:</p>
<pre class="lang-python prettyprint-override"><code>class TestClass(object):

    def __new__(cls, param):

        instance1 = object.__new__(cls)
        instance1.__init__(param)
        instance2 = object.__new__(cls)
        instance2.__init__(param)

        return instance1, instance2

    def __init__(self, param):
        self.param = param
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are calling the first parameter to <code>__new__</code> <code>self</code>, but it is actually the class, commonly referred to as <code>cls</code>. So you are writing to the class, not the instances.</p>
<p>To actually get two instances use:</p>
<pre><code>class X(object):
    def __new__(cls, param):
        self1 = object.__new__(cls)
        self1.__init__(param)
        self2 = object.__new__(cls)
        self2.__init__(param)
        return self1, self2
</code></pre>
<p>You cannot use deepcopy, since it will invoke <code>X.__new__()</code> (without the <code>param</code> parameter), which will cause a loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>The specific problem that causes <code>param</code> to be shared class-wide is highlighted if you use the right parameters for <code>__new__</code>. As @Kay mentions in his answer, <code>__new__</code> accepts a class as the first argument, not an instance.</p>
<pre><code>class Foo(object):
    def __new__(cls, param):
        cls.__init__(cls, param=param)
</code></pre>
<p>That's the error, because then it follows that <code>__init__</code> gets a class when it expects an instance.</p>
<pre><code>def __init__(self, param):
    # remember that `self` here is `Foo`! so...
    self.param = param
    # ...means Foo.param = param, setting it class-wide!
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__new__</a></span>
<span class="comment-copy"><code>return self1, self2</code> - that makes no sense....</span>
<span class="comment-copy">@KarolyHorvath, OP acknowledged the questionable sense of the task. Of cause you should not do that in production. But if you only want to learn the meaning of <code>__new__</code>, then I guess the question is acceptable.</span>
<span class="comment-copy">@KarolyHorvath why not? OP wants <code>TestClass(1)</code> to give a tuple of two objects of type <code>TestClass</code> whose attribute <code>param</code> is equal to <code>1</code>. It's bizarre, and nothing I'd want to encounter in the wild, but it's a valid learning tool.</span>
<span class="comment-copy">Great, thanks! And obviously the example doesn't make sense, it was really only a proxy to learn about <code>__new__</code>.</span>
<span class="comment-copy">Thanks, that helped me understand!</span>
