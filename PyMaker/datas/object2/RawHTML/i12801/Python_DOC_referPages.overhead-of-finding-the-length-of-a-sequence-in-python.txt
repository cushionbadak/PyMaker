<div class="post-text" itemprop="text">
<p>I was going to find the length of a sequence in <strong>python3</strong> and found that <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow"><code>range</code></a> is now of <code>&lt;class type&gt;</code> not <code>&lt;type builtin_function_or_method&gt;</code></p>
<p>Being so, the <code>range</code> call seems to create a generator in memory without the overhead of creating a <code>list</code> and populating it as in <strong>python2</strong> (please correct me if I'm misunderstanding or I am wrong about this).</p>
<p>My question now is, would there be any noticeable improvement for calculating the length of a sequence where, I call <code>len(range(start, stop, step))</code> instead of calculating <code>int(math.ceil((stop - start) / step))</code>.</p>
<p>This is a rough example of what I would be doing:</p>
<pre><code>s = list(range(limit))
s[1] = 0
for i in range(2, sqrtn + 1):
    if s[i]:
        s[i*i: limit: i] = [0] * len(range(i*i, limit, i)) # call to range
</code></pre>
<p>Would the above be actually more efficient then calculating the length?</p>
<pre><code>from math import ceil

s = list(range(limit))
s[1] = 0
for i in range(2, sqrtn + 1):
if s[i]:
    s[i*i: limit: i] = [0] * int(math.ceil((limit - i*i) / i)) # no range call
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In theory, yes, in practice, no. All timings on Windows x64 build of CPython 3.5.0 (specific times irrelevant; the relative times for each approach are what matter):</p>
<pre><code>&gt;&gt;&gt; from math import ceil
&gt;&gt;&gt; start, stop, step = 100*100, 100000, 100
&gt;&gt;&gt; min(timeit.repeat('(stop - start + (step - 1)) // step', 'from __main__ import start, stop, step', number=100000))
0.016031580173375914
&gt;&gt;&gt; min(timeit.repeat('ceil((stop - start) / step)', 'from __main__ import start, stop, step, ceil', number=100000))
0.024184756985505373
&gt;&gt;&gt; min(timeit.repeat('len(range(start, stop, step))', 'from __main__ import start, stop, step', number=100000))
0.03917228338013956
</code></pre>
<p>I've run those tests with a few different endpoints; if the values get large enough that the math can't be done in <code>Py_ssize_t</code>, the <code>range</code> and <code>ceil</code> approaches get closer together (<code>ceil</code> slows down), but the pure <code>int</code> math approach wins every test I've run. And both <code>range</code> and <code>ceil</code> have problems; for very large numbers, <code>range</code> will throw <code>OverflowError</code> (it can't have more elements than a <code>Py_ssize_t</code> can represent), and <code>ceil</code> (or rather, the float division before the <code>ceil</code>) will have floating point accuracy errors as you exceed ~53 bit values. The pure <code>int</code> math is both fast and reliable, and should probably be preferred.</p>
<p>That said, other Python interpreters (PyPy, IronPython, Jython, Cython) can special case stuff like <code>range</code> (and integer math for that matter), and could easily have completely different performance characteristics.</p>
<p>The real overhead here is not the <code>len</code> calculation. <code>range</code> actually computes the length and caches it internally during construction; retrieving it is as close to free as any named function call gets (and the same is true of all built-in sequences; at worst they have to construct a Python level <code>int</code> from a C level <code>int</code>, but all math operations do the same thing). The actual cost to retrieve the length:</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat('len(r)', 'from __main__ import start, stop, step; r = range(start, stop, step)', number=100000))
0.0076398965929911355
</code></pre>
</div>
<span class="comment-copy">in python 3, <code>range</code> is not a generator. And since it is a class, I doubt that creating a class instance is faster than doing a simple arithmetic operation.</span>
<span class="comment-copy">@RNar The number of names you import has no bearing on the execution time of the <code>import</code> statement. The module is always imported in full; qualified imports only hide the unwanted names.</span>
<span class="comment-copy">@BenjaminHodgson noted, good to know. deleted the comment</span>
<span class="comment-copy">@RNar: All things in Python are instances of classes you know. Even <code>int</code>. <code>int</code> gets some optimization, but it's still a class, and its instances are still created and destroyed constantly during basic math operations.</span>
<span class="comment-copy">@ShadowRanger I guess my wording is really unclear in that, but I definitely meant specifically a class instance of <code>range</code> :/</span>
<span class="comment-copy">I've run these tests several times and get very similiar results.  Funny though that on a couple the <code>ceil</code> beats out the pure <code>int</code></span>
<span class="comment-copy">@tijko: That will happen on occasion, but it's most likely to happen in cases where the numbers are large enough (and therefore <code>int</code> math involves array based math, where <code>float</code> is always native CPU <code>double</code> math) that the result of the <code>ceil</code> calculation is <i>wrong</i>; fastest to the wrong answer is still wrong. Example to try out: <code>start, stop, step = (1 &lt;&lt; 250) + 7, (1 &lt;&lt; 256) + 11, (1 &lt;&lt; 200) - 3</code>, <code>ceil((stop - start) / step)</code>, <code>(stop - start + (step - 1)) // step</code>. <code>range</code> gets this one right, but for smaller <code>step</code>, it eventually starts raising <code>OverflowError</code>.</span>
