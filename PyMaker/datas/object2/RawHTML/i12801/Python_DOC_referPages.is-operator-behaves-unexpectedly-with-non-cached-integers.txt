<div class="post-text" itemprop="text">
<p>When playing around with the Python interpreter, I stumbled upon this conflicting case regarding the <code>is</code> operator: </p>
<p>If the evaluation takes place in the function it returns <code>True</code>, if it is done outside it returns <code>False</code>.</p>
<pre><code>&gt;&gt;&gt; def func():
...     a = 1000
...     b = 1000
...     return a is b
...
&gt;&gt;&gt; a = 1000
&gt;&gt;&gt; b = 1000
&gt;&gt;&gt; a is b, func()
(False, True)
</code></pre>
<p>Since the <code>is</code> operator evaluates the <code>id()</code>'s for the objects involved, this means that <code>a</code> and <code>b</code> point to the same <code>int</code> instance when declared inside of function <code>func</code> but, on the contrary, they point to a different object when outside of it. </p>
<p>Why is this so?</p>
<hr/>
<p><sup><strong>Note</strong>: I am aware of the difference between identity (<code>is</code>) and equality (<code>==</code>) operations as described in <a href="https://stackoverflow.com/questions/13650293/understanding-pythons-is-operator">Understanding Python's "is" operator</a>. In addition, I'm also aware about the caching that is being performed by python for the integers in range <code>[-5, 256]</code> as described in <a href="https://stackoverflow.com/questions/306313/pythons-is-operator-behaves-unexpectedly-with-integers">"is" operator behaves unexpectedly with integers</a>. 
<br/><br/> 
This <strong>isn't the case here</strong> since the numbers are outside that range and <strong>I do</strong> want to evaluate identity and <strong>not</strong> equality.
</sup></p>
</div>
<div class="post-text" itemprop="text">
<h2>tl;dr:</h2>
<p>As the <a href="https://docs.python.org/3.5/reference/executionmodel.html#structure-of-a-program" rel="nofollow noreferrer">reference manual</a> states:</p>
<blockquote>
<p>A block is a piece of Python program text that is executed as a unit.
  The following are blocks: a module, a function body, and a class definition.
  <strong>Each command typed interactively is a block.</strong></p>
</blockquote>
<p>This is why, in the case of a function, you have a <strong>single</strong> code block which contains a <strong>single</strong> object for the numeric literal
<code>1000</code>, so <code>id(a) == id(b)</code> will yield <code>True</code>.</p>
<p>In the second case, you have <strong>two distinct code objects</strong> each with their own different object for the literal <code>1000</code> so <code>id(a) != id(b)</code>.</p>
<p>Take note that this behavior doesn't manifest with <code>int</code> literals only, you'll get similar results with, for example, <code>float</code> literals (see <a href="https://stackoverflow.com/questions/38834770/is-operator-gives-unexpected-results-on-floats/38835101#38835101">here</a>).</p>
<p>Of course, comparing objects (except for explicit <code>is None</code> tests ) should always be done with the equality operator <code>==</code> and <em>not</em> <code>is</code>.</p>
<p><sub><em>Everything stated here applies to the most popular implementation of Python, CPython. Other implementations might differ so no assumptions should be made when using them.</em></sub></p>
<hr/>
<h2>Longer Answer:</h2>
<p>To get a little clearer view and additionally verify this <em>seemingly odd</em> behaviour we can look directly in the <a href="https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer"><code>code</code></a> objects for each of these cases using the <a href="https://docs.python.org/3.5/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module.</p>
<p><strong>For the function <code>func</code></strong>:</p>
<p>Along with all other attributes, function objects also have a <code>__code__</code> attribute that allows you to peek into the compiled bytecode for that function. Using <a href="https://docs.python.org/3.5/library/dis.html#dis.code_info" rel="nofollow noreferrer"><code>dis.code_info</code></a> we can get a nice pretty view of all stored attributes in a code object for a given function:</p>
<pre><code>&gt;&gt;&gt; print(dis.code_info(func))
Name:              func
Filename:          &lt;stdin&gt;
Argument count:    0
Kw-only arguments: 0
Number of locals:  2
Stack size:        2
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
   1: 1000
Variable names:
   0: a
   1: b
</code></pre>
<p>We're only interested in the <code>Constants</code> entry for function <code>func</code>. In it, we can see that we have two values, <code>None</code> (always present) and <code>1000</code>. We only have a <strong>single</strong> int instance that represents the constant <code>1000</code>. This is the value that <code>a</code> and <code>b</code> are going to be assigned to when the function is invoked. </p>
<p>Accessing this value is easy via <code>func.__code__.co_consts[1]</code> and so, another way to view our <code>a is b</code> evaluation in the function would be like so:</p>
<pre><code>&gt;&gt;&gt; id(func.__code__.co_consts[1]) == id(func.__code__.co_consts[1]) 
</code></pre>
<p>Which, of course, will evaluate to <code>True</code> because we're referring to the same object.</p>
<p><strong>For each interactive command:</strong></p>
<p>As noted previously, each interactive command is interpreted as a single code block: parsed, compiled and evaluated independently.</p>
<p>We can get the code objects for each command via the <a href="https://docs.python.org/3.5/library/functions.html#compile" rel="nofollow noreferrer"><code>compile</code></a> built-in:</p>
<pre><code>&gt;&gt;&gt; com1 = compile("a=1000", filename="", mode="single")
&gt;&gt;&gt; com2 = compile("b=1000", filename="", mode="single")
</code></pre>
<p>For each assignment statement, we will get a similar looking code object which looks like the following:</p>
<pre><code>&gt;&gt;&gt; print(dis.code_info(com1))
Name:              &lt;module&gt;
Filename:          
Argument count:    0
Kw-only arguments: 0
Number of locals:  0
Stack size:        1
Flags:             NOFREE
Constants:
   0: 1000
   1: None
Names:
   0: a
</code></pre>
<p>The same command for <code>com2</code> looks the same but <em>has a fundamental difference</em>: each of the code objects <code>com1</code> and <code>com2</code> have different int instances representing the literal <code>1000</code>. This is why, in this case, when we do <code>a is b</code> via the <code>co_consts</code> argument, we actually get: </p>
<pre><code>&gt;&gt;&gt; id(com1.co_consts[0]) == id(com2.co_consts[0])
False
</code></pre>
<p>Which agrees with what we actually got.</p>
<p><em>Different code objects, different contents.</em></p>
<hr/>
<p><strong>Note:</strong> I was somewhat curious as to how exactly this happens in the source code and after digging through it I believe I finally found it.</p>
<p>During compilations phase the <a href="https://github.com/python/cpython/blob/master/Python/compile.c#L595" rel="nofollow noreferrer"><strong><code>co_consts</code></strong></a> attribute is represented by a dictionary object. In <a href="https://github.com/python/cpython/blob/master/Python/compile.c" rel="nofollow noreferrer"><code>compile.c</code></a> we can actually see the initialization:</p>
<pre><code>/* snippet for brevity */

u-&gt;u_lineno = 0;
u-&gt;u_col_offset = 0;
u-&gt;u_lineno_set = 0;
u-&gt;u_consts = PyDict_New();  

/* snippet for brevity */
</code></pre>
<p>During compilation this is checked for already existing constants. See <a href="https://stackoverflow.com/a/39325641/4952130">@Raymond Hettinger's answer below</a> for a bit more on this.</p>
<hr/>
<h3>Caveats:</h3>
<ul>
<li><p>Chained statements will evaluate to an identity check of <code>True</code> </p>
<p>It should be more clear now why exactly the following evaluates to <code>True</code>:</p>
<pre><code>&gt;&gt;&gt; a = 1000; b = 1000;
&gt;&gt;&gt; a is b
</code></pre>
<p>In this case, by chaining the two assignment commands together we tell the interpreter to compile these <strong>together</strong>. As in the case for the function object, only one object for the literal <code>1000</code> will be created resulting in a <code>True</code> value when evaluated.</p></li>
<li><p>Execution on a module level yields <code>True</code> again:</p>
<p>As previously mentioned, the reference manual states that: </p>
<blockquote>
<p>... The following are blocks: <strong>a module</strong> ...</p>
</blockquote>
<p>So the same premise applies: we will have a single code object (for the module) and so, as a result, single values stored for each different literal.</p></li>
<li><p>The same <strong>doesn't</strong> apply for <strong>mutable</strong> objects:</p>
<p>Meaning that unless we explicitly initialize to the same mutable object (for example with a = b = []), the identity of the objects will never be equal, for example:</p>
<pre><code>a = []; b = []
a is b  # always returns false
</code></pre>
<p>Again, in <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">the documentation</a>, this is specified:</p>
<blockquote>
<p>after a = 1; b = 1, a and b may or may not refer to the same object with the value one, depending on the implementation, but after c = []; d = [], c and d are guaranteed to refer to two different, unique, newly created empty lists.</p>
</blockquote></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>At the interactive prompt, entry are <a href="https://docs.python.org/3/library/functions.html#compile" rel="noreferrer">compiled in a <em>single</em> mode</a> which processes one complete statement at a time.  The compiler itself (in <a href="https://hg.python.org/cpython/file/tip/Python/compile.c" rel="noreferrer">Python/compile.c</a>) tracks the constants in a dictionary called <a href="https://hg.python.org/cpython/file/tip/Python/compile.c#l114" rel="noreferrer"><em>u_consts</em></a> that maps the constant object to its index.  </p>
<p>In the <a href="https://hg.python.org/cpython/file/tip/Python/compile.c#l1099" rel="noreferrer"><em>compiler_add_o()</em></a> function, you see that before adding a new constant (and incrementing the index), the dict is checked to see whether the constant object and index already exist.  If so, they are reused.  </p>
<p>In short, that means that repeated constants in one statement (such as in your function definition) are folded into one singleton.  In contrast, your <code>a = 1000</code> and <code>b = 1000</code> are two separate statements, so no folding takes place.</p>
<p>FWIW, this is all just a CPython implementation detail (i.e. not guaranteed by the language).  This is why the references given here are to the C source code rather than the language specification which makes no guarantees on the subject.</p>
<p>Hope you enjoyed this insight into how CPython works under the hood :-)</p>
</div>
<span class="comment-copy">The definition of Python, the language, guarantees that the singletons None, False, and True are themselves, and that multiple instances of mutable bultin classes are not different.  The isness of multiple instances of immutable builtin classes with the same value is value, version, and implementation dependent  I presume that by 'the Python interpreter', you mean CPython.  You might get different results with other interpreters.  You will get a different result with CPython for 'small' int values.  Try 250 instead of 1000.  You might get a different result for older versions of CPython.</span>
<span class="comment-copy">Why is this of interest to you?  Using <code>is</code> on integers feels wrong to me.</span>
<span class="comment-copy">@MartinBonner I'm mainly interested in how CPython is implemented. I bumped into this behavior, examined it and decided to post a Q &amp; A thinking others might find it interesting too. It is wrong, I don't suggest using it ;-)</span>
<span class="comment-copy">Thanks, an authoritative answer in order to verify what I was writing was much needed (and I also need a place to award the bounty  :-)</span>
<span class="comment-copy">@Jim Happy to help.  Once in a while a Python core developer happens to be lurking on StackOverflow and can take you right to the heart of the matter.</span>
