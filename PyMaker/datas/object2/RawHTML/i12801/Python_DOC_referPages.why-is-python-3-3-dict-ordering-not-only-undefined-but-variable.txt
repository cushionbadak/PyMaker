<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/14956313/why-is-dictionary-ordering-non-deterministic">Why is dictionary ordering non-deterministic?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I'm asking this question out of curiosity (specifically, insight into how python is working under the hood).</p>
<p>I am fully aware that the python <code>dict</code> object is unordered - you can put in a bunch of items, and print out some representation of the <code>dict</code>, and the ordering of the items in the representation will have no correspondence to the order that the items were entered.</p>
<p>What I'm curious about, however, is why the ordering changes from one execution of the code to the next?</p>
<p>I have a really simple python script that is printing a <code>dict</code> to the console. The dict looks like this (content is pretty irrelevant):</p>
<pre><code>{
    'hello': 'hi',
    'goodbye': 'bye',
    'hahaha': 'lol',
}
</code></pre>
<p>Printing it to the console causes the items to not only be printed in a random order, but to be printed <strong>in a different order each time I run the program</strong>. Here's my question: <em>Why is this the case?</em></p>
<p>NOTE: The python code is inside a django project (but I'm not using any django functionality in this case - just mentioning this in case it's somehow relevant).</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a note about this here: <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__">https://docs.python.org/3/reference/datamodel.html#object.__hash__</a></p>
<p>Here is the note:</p>
<blockquote>
<blockquote>
<p><strong>Note:</strong> By default, the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__"><code>__hash__()</code></a> values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.
    This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n^2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.
    Changing hash values affects the iteration order of dicts, sets and other mappings. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).</p>
<p>See also <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED"><code>PYTHONHASHSEED</code></a>.</p>
</blockquote>
<p><em>Changed in version 3.3:</em> Hash randomization is enabled by default.</p>
</blockquote>
</div>
<span class="comment-copy">Python 2, or Python 3? You're probably running into hash randomization, in which case <a href="http://stackoverflow.com/questions/14956313/dictionary-ordering-non-deterministic-in-python3">this</a> would be an appropriate dupe target.</span>
<span class="comment-copy">This doesn't happen in python2.</span>
<span class="comment-copy">Python 3? And did you mean 'variable between OSes (Windows, Linux/MacOS, Android, iOS...) and/or between implementations (CPython/PyPi)'? This is a good question but please add detail!</span>
<span class="comment-copy">@sudomakeinstall2 - It can be enabled in python 2.7 if you want by setting an environment variable <code>export PYTHONHASHSEED=random</code>.</span>
<span class="comment-copy">@tdelaney: is there any more Pythonic way/package to get that backward-compatibility in Python 2.x?</span>
