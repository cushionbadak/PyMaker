<div class="post-text" itemprop="text">
<p>I am trying to generate substrings from a bunch of sequences using a for loop so I can then remove all common substrings from each sequence.</p>
<p>My code:</p>
<pre><code>class Unique():
    def __init__(self, seq = ''):
        self.head = head
        self.sequence = seq.replace('-','').replace('_','')
        self.original = {}
        self.substrings = {}



    def get_all_substrings(input_string):
        length = len(input_string)
        for i in range(length):
            for j in range(i + 1, length + 1):
                yield input_string[i:j]

    def sites(self):

        self.original[self.head] = self.sequence
        for key in self.original:
            self.substrings[key] = Unique.get_all_substrings(self.original[key])

#myReader.readFasta simply extracts the header and sequences which I'll be using
for head, seq in myReader.readFasta(): 
    myprog = Unique(seq)
    myprog.sites()
</code></pre>
<p>When I run what I have so far and printing the new dictionary self.substrings, all the values from the function get_all_substrings is:</p>
<pre><code>[&lt;generator object Unique.get_all_substrings at 0x00000198A22C7258&gt;]
</code></pre>
<p>I know this has something to do with the yield, but searches haven't been able to help me fix it.</p>
</div>
<div class="post-text" itemprop="text">
<p>get_all_substring() is a generator. That means that it will generate values if you iterate through it, however you are only calling its method.</p>
<p>If you want to save it into  self.substrings[key] 
you can do something like </p>
<pre><code>self.substrings[key] = list(Unique.get_all_substrings(self.original[key]))
</code></pre>
<p>or</p>
<pre><code>self.substrings[key] = [substr for substr in Unique.get_all_substrings(self.original[key])]
</code></pre>
<p>If this is the only use case of get_all_substring(), you definitely do not need the generator. So you can simply remove the <code>yield</code> key and return an array.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>self.substrings[key] = list(Unique.get_all_substrings(self.original[key]))
</code></pre>
<p>you must iterate a generator in order to get its values (<code>list</code> does that ... but defeats some of the purpose of a generator)</p>
<pre><code>strings = Unique.get_all_substrings(self.original[key])
print next(strings) # get the next one out of the generator
print next(strings) # and the next after that
for string in strings: # get the rest (skips first 2 since already consumed)
     print string
</code></pre>
<p>is typically how you interact with a generator</p>
<p>you could just return an iterator if you like the generator behaviour</p>
<pre><code>return (  input_string[i:j] for i in range(length) for j in range(i + 1, length + 1))
</code></pre>
<p>or a list comprehension if what you want is actually a list </p>
<pre><code>return [  input_string[i:j] for i in range(length) for j in range(i + 1, length + 1)]
</code></pre>
</div>
<span class="comment-copy">Perhaps you should take a look at the information on making and using <a href="https://docs.python.org/3/howto/functional.html#generators" rel="nofollow noreferrer">generator functions</a>?</span>
<span class="comment-copy">Thanks for the response! So is there a cleaner way I can accomplish this or should I stick with just iterating a generator?</span>
