<div class="post-text" itemprop="text">
<p>I have this code in a django template page</p>
<pre><code>&lt;select class="selectpicker datatable-column-control" multiple
{% for q_group in question_groups %}
    &lt;optgroup label="{{ q_group.name }}"&gt;
    {% for q in  q_group.questions %}
        &lt;option value="{{ forloop.counter0 }}"&gt;{{ q.title }}&lt;/option&gt;
    {% endfor %}
    &lt;/optgroup&gt;
{% endfor %}
</code></pre>
<p></p>
<p>I want a value for every option tag that increases in each iteration. If I have 10 option tags, then their values will be from 0 to 9. 
<code>forloop.counter0</code> does not fulfill my need as the inner loop counter initializes to 0 when outer loop finishes once.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about passing  a <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>itertools.count</code></a> object to the template?</p>
<p>Template:</p>
<pre><code>&lt;select class="selectpicker datatable-column-control" multiple&gt;
{% for q_group in question_groups %}
    &lt;optgroup label="{{ q_group.name }}"&gt;
    {% for q in  q_group.questions %}
        &lt;option value="{{ counter }}"&gt;{{ q.title }}&lt;/option&gt;
    {% endfor %}
    &lt;/optgroup&gt;
{% endfor %}
&lt;/select&gt;
</code></pre>
<p>View:</p>
<pre><code>import itertools
import functools

render(request, 'template.html', {
    question_groups: ...,
    counter: functools.partial(next, itertools.count()),
})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reviving this post to provide solutions using only the template language.</p>
<p>If you know you only have one <code>{% for %}</code> in between the counter (as in example above), use <a href="https://docs.djangoproject.com/en/stable/ref/templates/builtins/#for" rel="nofollow noreferrer">forloop.parentloop</a>. You can chain many of these together, but the number of loops separating the desired loop must be known, and using it becomes less desirable after a few (<code>forloop.parentloop.parentloop...</code>).</p>
<pre><code>{% for foo in foos %}
  {% for bar in bars %} {# exactly one for loop between here #}
    {{ forloop.parentloop.counter0 }} is the index of foo. 
  {% endfor %}
{% endfor %}
</code></pre>
<p>If you have an arbitrary number of for loops between the two (say in a template you can't control, or django-crispy-forms), save the loop variable with a <a href="https://docs.djangoproject.com/en/stable/ref/templates/builtins/#with" rel="nofollow noreferrer">with statement</a>:</p>
<pre><code>{% for foo in foos %}
  {% with foo_num=forloop.counter0 %}
    {% for bar in bars %} {# any number of for loops between #}
      {{ foo_num }} is the index of foo. 
    {% endfor %}
  {% endwith %}
{% endfor %}
</code></pre>
<p>Falsetru's solution is a best fit for a counter that lacks a for loop, or one that keeps counting after one has ended. This feature isn't really possible with only the builtins, so the itertools from falsetru's answer is necessary.</p>
<pre><code>{% for foo in foos %}
  {{ counter }} is the index of foo
{% endfor %}
{% for bar in bars %}
  {{ counter }} is the index of bar + len(foos)
{% endfor %}
</code></pre>
</div>
<span class="comment-copy"><a href="https://asciinema.org/a/al1ctm3wwwgf5ey0lfpin10yr" rel="nofollow noreferrer">asciinema.org/a/al1ctm3wwwgf5ey0lfpin10yr</a></span>
