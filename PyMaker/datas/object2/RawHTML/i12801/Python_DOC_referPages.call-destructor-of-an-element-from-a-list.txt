<div class="post-text" itemprop="text">
<p>I have something like that:</p>
<pre><code>a = [instance1, instance2, ...]
</code></pre>
<p>if I do a</p>
<pre><code>del a[1]
</code></pre>
<p>instance2 is removed from list, but is instance2 desctructor method called?</p>
<p>I'm interested in this because my code uses a lot of memory and I need to free memory deleting instances from a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Coming from a language like c++ (as I did), this tends to be a subject many people find difficult to grasp when first learning Python. </p>
<p>The bottomline is this: when you do <code>del XXX</code>, you are never* deleting <em>an object</em> when you use <code>del</code>. You are only deleting an <strong>object reference</strong>. However, in practice, assuming there are no other references laying about to the <code>instance2</code> object, deleting it from your list will free the memory as you desire. </p>
<p>If you don't understand the difference between an object and an object reference, read on. </p>
<h1>Python: Pass by value, or pass by reference?</h1>
<p>You are likely familiar with the concept of passing arguments to a function by reference, or by value. However, Python does things differently. Arguments are always passed by <em>object reference</em>. Read <a href="http://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow">this article</a> for a helpful explanation of what this means. </p>
<p>To summarize: this means that when you pass a variable to a function, you are not passing a copy of the value of the variable (pass by value), nor are you passing the object itself - i.e., the address of the value in memory. You are passing the name-object that indirectly refers to the value held in memory. </p>
<h1>What does this have to do with <code>del</code>...?</h1>
<p><a href="https://www.youtube.com/watch?v=x2Y7_1dILlQ" rel="nofollow">Well, I'll tell you.</a> </p>
<p>Say you do this:</p>
<pre><code>def deleteit(thing):
    del thing

mylist = [1,2,3]
deleteit(mylist)
</code></pre>
<p>...what do you think will happen? Has <code>mylist</code> been deleted from the global namespace? </p>
<p>The answer is NO:</p>
<pre><code>assert mylist # No error
</code></pre>
<p>The reason is that when you do <code>del thing</code> in the <code>deleteit</code> function, you are only deleting <em>a local object reference</em> to the object. That object reference exists ONLY inside of the function. As a sidebar, you might ask: is it possible to delete an object reference from the global namespace while inside a function? The answer is yes, but you have to declare the object reference to be part of the global namespace first: </p>
<pre><code>def deletemylist():
    global mylist
    del mylist

mylist = [1,2,3]
deletemylist()
assert mylist #ERROR, as expected
</code></pre>
<h1>Putting it all together</h1>
<p>Now to get back to your original question. When, in ANY namespace, you do this:</p>
<pre><code>del XXX
</code></pre>
<p>...you have NOT deleted the object signified by XXX. You CAN'T do that. You have only deleted the <em>object reference</em> <code>XXX</code>, which refers to some object in memory. The object itself is managed by the <a href="https://docs.python.org/3/c-api/memory.html" rel="nofollow">Python memory manager</a>. This is a very important distinction. </p>
<p>Note that as a consequence, when you override the <code>__del__</code> method of some object, which gets called when <strong><em>the object</em></strong> is deleted (NOT the object reference!):</p>
<pre><code>class MyClass():
    def __del__(self):
        print(self, "deleted")
        super().__del__()

m = MyClass()
del m
</code></pre>
<p>...the print statement inside the <code>__del__</code> method does not necessarily occur immediately after you do <code>del m</code>. It only occurs at the point in time the object itself is deleted, and that is not up to you. It is up to the Python memory manager. When all object references in all the namespaces have been deleted, the <code>__del__</code> method will eventually be executed. But not necessarily immediately. </p>
<p>The same is true when you delete an object reference that is part of a list, like in the original example. When you do <code>del a[1]</code>, only the object reference to the object signified by <code>a[1]</code> is deleted, and the <code>__del__</code> method of that object may or may not be called immediately (though as stated before, it will eventually be called once there are no more references to the object, and the object is garbage collected by the memory manager). </p>
<p>As a result of this, it is not recommended that you put things in the <code>__del__</code> method that you want to happen immediately upon <code>del mything</code>, because it may not happen that way.  </p>
<hr/>
<p>*I believe it is never. Inevitably someone will likely downvote my answer and leave a comment discussing the exception to the rule. But whatevs. </p>
</div>
<div class="post-text" itemprop="text">
<p>No. Calling <code>del</code> on a list element only removes a reference to an object from the list, it doesn't do anything (explicitly) to the object itself. However: If the reference in the list was the last one referring to the object, the object can now be destroyed and recycled. I think that the "normal" CPython implementation will immediately destroy and recycle the object, other variants' behaviour can vary.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your object is resource-heavy and you want to be sure that the resources are freed correctly, use the <code>with()</code> construct. It's very easy to leak resources when relying on destructors. See <a href="https://stackoverflow.com/questions/865115/how-do-i-correctly-clean-up-a-python-object">this SO post</a> for more details.</p>
</div>
<span class="comment-copy">related/possible duplicate of <a href="http://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour">this</a>?</span>
<span class="comment-copy">Python is a garbage-collected language. If you're expecting <code>del</code> to be anything like C++'s <code>delete</code>, you're expecting the wrong thing. There is no way to manually delete an object in Python.</span>
<span class="comment-copy">Thanks for that!</span>
<span class="comment-copy">Yeah, it's pretty much never. To make <code>del thing</code> actually delete the object instead of the reference, you'd need to do something like <code>exec</code> your code with a custom mapping class as the locals, and have the custom mapping call an object's <code>tp_dealloc</code> when you delete entries. This would break a lot of Python's rules and probably cause a segfault down the line.</span>
<span class="comment-copy">Also, <a href="http://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour">there's actually no guarantee that <code>__del__</code> will ever be called at all</a>.</span>
<span class="comment-copy">Deleting all references to object and calling gc.collect() should also remove all orphan objects.</span>
<span class="comment-copy">I forgot about the gc module (I've never used it).</span>
<span class="comment-copy">Ok, that was what I needed =) Thanks!</span>
