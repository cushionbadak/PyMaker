<div class="post-text" itemprop="text">
<p>What is the purpose of <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="noreferrer"><code>__slots__</code></a> in Python — especially with respect to when I would want to use it, and when not?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>In Python, what is the purpose of <code>__slots__</code> and what are the cases one should avoid this?</h1>
</blockquote>
<h2>TLDR:</h2>
<p>The special attribute <code>__slots__</code> allows you to explicitly state which instance attributes you expect your object instances to have, with the expected results:</p>
<ol>
<li><strong>faster</strong> attribute access.</li>
<li><strong>space savings</strong> in memory. </li>
</ol>
<p>The space savings is from </p>
<ol>
<li>Storing value references in slots instead of <code>__dict__</code>.</li>
<li>Denying <code>__dict__</code> and <code>__weakref__</code> creation if parent classes deny them and you declare <code>__slots__</code>.</li>
</ol>
<h3>Quick Caveats</h3>
<p>Small caveat, you should only declare a particular slot one time in an inheritance tree. For example:</p>
<pre><code>class Base:
    __slots__ = 'foo', 'bar'

class Right(Base):
    __slots__ = 'baz', 

class Wrong(Base):
    __slots__ = 'foo', 'bar', 'baz'        # redundant foo and bar
</code></pre>
<p>Python doesn't object when you get this wrong (it probably should), problems might not otherwise manifest, but your objects will take up more space than they otherwise should.</p>
<pre><code>&gt;&gt;&gt; from sys import getsizeof
&gt;&gt;&gt; getsizeof(Right()), getsizeof(Wrong())
(64, 80)
</code></pre>
<p>The biggest caveat is for multiple inheritance - multiple "parent classes with nonempty slots" cannot be combined. </p>
<p>To accommodate this restriction, follow best practices: Factor out all but one or all parents' abstraction which their concrete class respectively and your new concrete class collectively will inherit from - giving the abstraction(s) empty slots (just like abstract base classes in the standard library). </p>
<p>See section on multiple inheritance below for an example.</p>
<h3>Requirements:</h3>
<ul>
<li><p>To have attributes named in <code>__slots__</code> to actually be stored in slots instead of a <code>__dict__</code>, a class must inherit from <code>object</code>.</p></li>
<li><p>To prevent the creation of a <code>__dict__</code>, you must inherit from <code>object</code> and all classes in the inheritance must declare <code>__slots__</code> and none of them can have a <code>'__dict__'</code> entry. </p></li>
</ul>
<p>There are a lot of details if you wish to keep reading.</p>
<h2>Why use <code>__slots__</code>: Faster attribute access.</h2>
<p>The creator of Python, Guido van Rossum, <a href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html" rel="noreferrer">states</a> that he actually created <code>__slots__</code> for faster attribute access.  </p>
<p>It is trivial to demonstrate measurably significant faster access:</p>
<pre><code>import timeit

class Foo(object): __slots__ = 'foo',

class Bar(object): pass

slotted = Foo()
not_slotted = Bar()

def get_set_delete_fn(obj):
    def get_set_delete():
        obj.foo = 'foo'
        obj.foo
        del obj.foo
    return get_set_delete
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(slotted)))
0.2846834529991611
&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(not_slotted)))
0.3664822799983085
</code></pre>
<p>The slotted access is almost 30% faster in Python 3.5 on Ubuntu.</p>
<pre><code>&gt;&gt;&gt; 0.3664822799983085 / 0.2846834529991611
1.2873325658284342
</code></pre>
<p>In Python 2 on Windows I have measured it about 15% faster.</p>
<h2>Why use <code>__slots__</code>:  Memory Savings</h2>
<p>Another purpose of <code>__slots__</code> is to reduce the space in memory that each object instance takes up.  </p>
<p><a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="noreferrer">My own contribution to the documentation clearly states the reasons behind this</a>: </p>
<blockquote>
<p>The space saved over using <code>__dict__</code> can be significant.</p>
</blockquote>
<p><a href="http://docs.sqlalchemy.org/en/rel_1_0/changelog/migration_10.html#significant-improvements-in-structural-memory-use" rel="noreferrer">SQLAlchemy attributes</a> a lot of memory savings to <code>__slots__</code>.</p>
<p>To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux, with <code>guppy.hpy</code> (aka heapy) and <code>sys.getsizeof</code>, the size of a class instance without <code>__slots__</code> declared, and nothing else, is 64 bytes. That does <em>not</em> include the <code>__dict__</code>. Thank you Python for lazy evaluation again, the <code>__dict__</code> is apparently not called into existence until it is referenced, but classes without data are usually useless. When called into existence, the <code>__dict__</code> attribute is a minimum of 280 bytes additionally. </p>
<p>In contrast, a class instance with <code>__slots__</code> declared to be <code>()</code> (no data) is only 16 bytes, and 56 total bytes with one item in slots, 64 with two.</p>
<p>For 64 bit Python, I illustrate the memory consumption in bytes in Python 2.7 and 3.6, for <code>__slots__</code> and <code>__dict__</code> (no slots defined) for each point where the dict grows in 3.6 (except for 0, 1, and 2 attributes):</p>
<pre><code>       Python 2.7             Python 3.6
attrs  __slots__  __dict__*   __slots__  __dict__* | *(no slots defined)
none   16         56 + 272†   16         56 + 112† | †if __dict__ referenced
one    48         56 + 272    48         56 + 112
two    56         56 + 272    56         56 + 112
six    88         56 + 1040   88         56 + 152
11     128        56 + 1040   128        56 + 240
22     216        56 + 3344   216        56 + 408     
43     384        56 + 3344   384        56 + 752
</code></pre>
<p>So, in spite of smaller dicts in Python 3, we see how nicely <code>__slots__</code> scale for instances to save us memory, and that is a major reason you would want to use <code>__slots__</code>. </p>
<p>Just for completeness of my notes, note that there is a one-time cost per slot in the class's namespace of 64 bytes in Python 2, and 72 bytes in Python 3, because slots use data descriptors like properties, called "members".</p>
<pre><code>&gt;&gt;&gt; Foo.foo
&lt;member 'foo' of 'Foo' objects&gt;
&gt;&gt;&gt; type(Foo.foo)
&lt;class 'member_descriptor'&gt;
&gt;&gt;&gt; getsizeof(Foo.foo)
72
</code></pre>
<h2>Demonstration of <code>__slots__</code>:</h2>
<p>To deny the creation of a <code>__dict__</code>, you must subclass <code>object</code>:</p>
<pre><code>class Base(object): 
    __slots__ = ()
</code></pre>
<p>now:</p>
<pre><code>&gt;&gt;&gt; b = Base()
&gt;&gt;&gt; b.a = 'a'
Traceback (most recent call last):
  File "&lt;pyshell#38&gt;", line 1, in &lt;module&gt;
    b.a = 'a'
AttributeError: 'Base' object has no attribute 'a'
</code></pre>
<p>Or subclass another class that defines <code>__slots__</code></p>
<pre><code>class Child(Base):
    __slots__ = ('a',)
</code></pre>
<p>and now:</p>
<pre><code>c = Child()
c.a = 'a'
</code></pre>
<p>but:</p>
<pre><code>&gt;&gt;&gt; c.b = 'b'
Traceback (most recent call last):
  File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt;
    c.b = 'b'
AttributeError: 'Child' object has no attribute 'b'
</code></pre>
<p>To allow <code>__dict__</code> creation while subclassing slotted objects, just add <code>'__dict__'</code> to the <code>__slots__</code> (note that slots are ordered, and you shouldn't repeat slots that are already in parent classes):</p>
<pre><code>class SlottedWithDict(Child): 
    __slots__ = ('__dict__', 'b')

swd = SlottedWithDict()
swd.a = 'a'
swd.b = 'b'
swd.c = 'c'
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; swd.__dict__
{'c': 'c'}
</code></pre>
<p>Or you don't even need to declare <code>__slots__</code> in your subclass, and you will still use slots from the parents, but not restrict the creation of a <code>__dict__</code>:</p>
<pre><code>class NoSlots(Child): pass
ns = NoSlots()
ns.a = 'a'
ns.b = 'b'
</code></pre>
<p>And:</p>
<pre><code>&gt;&gt;&gt; ns.__dict__
{'b': 'b'}
</code></pre>
<p>However, <code>__slots__</code> may cause problems for multiple inheritance:</p>
<pre><code>class BaseA(object): 
    __slots__ = ('a',)

class BaseB(object): 
    __slots__ = ('b',)
</code></pre>
<p>Because creating a child class from parents with both non-empty slots fails:</p>
<pre><code>&gt;&gt;&gt; class Child(BaseA, BaseB): __slots__ = ()
Traceback (most recent call last):
  File "&lt;pyshell#68&gt;", line 1, in &lt;module&gt;
    class Child(BaseA, BaseB): __slots__ = ()
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict
</code></pre>
<p>If you run into this problem, You <em>could</em> just remove <code>__slots__</code> from the parents, or if you have control of the parents, give them empty slots, or refactor to abstractions:</p>
<pre><code>from abc import ABC

class AbstractA(ABC):
    __slots__ = ()

class BaseA(AbstractA): 
    __slots__ = ('a',)

class AbstractB(ABC):
    __slots__ = ()

class BaseB(AbstractB): 
    __slots__ = ('b',)

class Child(AbstractA, AbstractB): 
    __slots__ = ('a', 'b')

c = Child() # no problem!
</code></pre>
<h3>Add <code>'__dict__'</code> to <code>__slots__</code> to get dynamic assignment:</h3>
<pre><code>class Foo(object):
    __slots__ = 'bar', 'baz', '__dict__'
</code></pre>
<p>and now:</p>
<pre><code>&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.boink = 'boink'
</code></pre>
<p>So with <code>'__dict__'</code> in slots we lose some of the size benefits with the upside of having dynamic assignment and still having slots for the names we do expect.</p>
<p>When you inherit from an object that isn't slotted, you get the same sort of semantics when you use <code>__slots__</code> - names that are in <code>__slots__</code> point to  slotted values, while any other values are put in the instance's <code>__dict__</code>.</p>
<p>Avoiding <code>__slots__</code> because you want to be able to add attributes on the fly is actually not a good reason - just add <code>"__dict__"</code> to your <code>__slots__</code> if this is required.</p>
<p>You can similarly add <code>__weakref__</code> to <code>__slots__</code> explicitly if you need that feature.</p>
<h3>Set to empty tuple when subclassing a namedtuple:</h3>
<p>The namedtuple builtin make immutable instances that are very lightweight (essentially, the size of tuples) but to get the benefits, you need to do it yourself if you subclass them:</p>
<pre><code>from collections import namedtuple
class MyNT(namedtuple('MyNT', 'bar baz')):
    """MyNT is an immutable and lightweight object"""
    __slots__ = ()
</code></pre>
<p>usage:</p>
<pre><code>&gt;&gt;&gt; nt = MyNT('bar', 'baz')
&gt;&gt;&gt; nt.bar
'bar'
&gt;&gt;&gt; nt.baz
'baz'
</code></pre>
<p>And trying to assign an unexpected attribute raises an <code>AttributeError</code> because we have prevented the creation of <code>__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; nt.quux = 'quux'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'MyNT' object has no attribute 'quux'
</code></pre>
<p>You <em>can</em> allow <code>__dict__</code> creation by leaving off <code>__slots__ = ()</code>, but you can't use non-empty <code>__slots__</code> with subtypes of tuple.</p>
<h2>Biggest Caveat: Multiple inheritance</h2>
<p>Even when non-empty slots are the same for multiple parents, they cannot be used together:</p>
<pre><code>class Foo(object): 
    __slots__ = 'foo', 'bar'
class Bar(object):
    __slots__ = 'foo', 'bar' # alas, would work if empty, i.e. ()

&gt;&gt;&gt; class Baz(Foo, Bar): pass
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict
</code></pre>
<p>Using an empty <code>__slots__</code> in the parent seems to provide the most flexibility, <strong>allowing the child to choose to prevent or allow</strong> (by adding <code>'__dict__'</code> to get dynamic assignment, see section above) <strong>the creation of a <code>__dict__</code></strong>:</p>
<pre><code>class Foo(object): __slots__ = ()
class Bar(object): __slots__ = ()
class Baz(Foo, Bar): __slots__ = ('foo', 'bar')
b = Baz()
b.foo, b.bar = 'foo', 'bar'
</code></pre>
<p>You don't <em>have</em> to have slots - so if you add them, and remove them later, it shouldn't cause any problems.</p>
<p><strong>Going out on a limb here</strong>: If you're composing <a href="https://stackoverflow.com/questions/860245/mixin-vs-inheritance/27907511#27907511">mixins</a> or using <a href="https://stackoverflow.com/questions/372042/difference-between-abstract-class-and-interface-in-python/31439126#31439126">abstract base classes</a>, which aren't intended to be instantiated, an empty <code>__slots__</code> in those parents seems to be the best way to go in terms of flexibility for subclassers.</p>
<p>To demonstrate, first, let's create a class with code we'd like to use under multiple inheritance</p>
<pre><code>class AbstractBase:
    __slots__ = ()
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __repr__(self):
        return f'{type(self).__name__}({repr(self.a)}, {repr(self.b)})'
</code></pre>
<p>We could use the above directly by inheriting and declaring the expected slots:</p>
<pre><code>class Foo(AbstractBase):
    __slots__ = 'a', 'b'
</code></pre>
<p>But we don't care about that, that's trivial single inheritance, we need another class we might also inherit from, maybe with a noisy attribute:</p>
<pre><code>class AbstractBaseC:
    __slots__ = ()
    @property
    def c(self):
        print('getting c!')
        return self._c
    @c.setter
    def c(self, arg):
        print('setting c!')
        self._c = arg
</code></pre>
<p>Now if both bases had nonempty slots, we couldn't do the below. (In fact, if we wanted, we could have given <code>AbstractBase</code> nonempty slots a and b, and left them out of the below declaration - leaving them in would be wrong):</p>
<pre><code>class Concretion(AbstractBase, AbstractBaseC):
    __slots__ = 'a b _c'.split()
</code></pre>
<p>And now we have functionality from both via multiple inheritance, and can still deny <code>__dict__</code> and <code>__weakref__</code> instantiation:</p>
<pre><code>&gt;&gt;&gt; c = Concretion('a', 'b')
&gt;&gt;&gt; c.c = c
setting c!
&gt;&gt;&gt; c.c
getting c!
Concretion('a', 'b')
&gt;&gt;&gt; c.d = 'd'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Concretion' object has no attribute 'd'
</code></pre>
<h2>Other cases to avoid slots:</h2>
<ul>
<li>Avoid them when you want to perform <code>__class__</code> assignment with another class that doesn't have them (and you can't add them) unless the slot layouts are identical. (I am very interested in learning who is doing this and why.)</li>
<li>Avoid them if you want to subclass variable length builtins like long, tuple, or str, and you want to add attributes to them.</li>
<li>Avoid them if you insist on providing default values via class attributes for instance variables. </li>
</ul>
<p>You may be able to tease out further caveats from the rest of the <code>__slots__</code> <a href="https://docs.python.org/3.7/reference/datamodel.html#slots" rel="noreferrer">documentation (the 3.7 dev docs are the most current)</a>, which I have made significant recent contributions to.</p>
<h2>Critiques of other answers</h2>
<p>The current top answers cite outdated information and are quite hand-wavy and miss the mark in some important ways.</p>
<h3>Do not "only use <code>__slots__</code> when instantiating lots of objects"</h3>
<p>I quote:</p>
<blockquote>
<p>"You would want to use <code>__slots__</code> if you are going to instantiate a lot (hundreds, thousands) of objects of the same class." </p>
</blockquote>
<p>Abstract Base Classes, for example, from the <code>collections</code> module, are not instantiated, yet <code>__slots__</code> are declared for them. </p>
<p>Why?</p>
<p>If a user wishes to deny <code>__dict__</code> or <code>__weakref__</code> creation, those things must not be available in the parent classes.</p>
<p><code>__slots__</code> contributes to reusability when creating interfaces or mixins.</p>
<p>It is true that many Python users aren't writing for reusability, but when you are, having the option to deny unnecessary space usage is valuable.</p>
<h3><code>__slots__</code> doesn't break pickling</h3>
<p>When pickling a slotted object, you may find it complains with a misleading <code>TypeError</code>: </p>
<pre><code>&gt;&gt;&gt; pickle.loads(pickle.dumps(f))
TypeError: a class that defines __slots__ without defining __getstate__ cannot be pickled
</code></pre>
<p>This is actually incorrect. This message comes from the oldest protocol, which is the default. You can select the latest protocol with the <code>-1</code> argument. In Python 2.7 this would be <code>2</code> (which was introduced in 2.3), and in 3.6 it is <code>4</code>.</p>
<pre><code>&gt;&gt;&gt; pickle.loads(pickle.dumps(f, -1))
&lt;__main__.Foo object at 0x1129C770&gt;
</code></pre>
<p>in Python 2.7:</p>
<pre><code>&gt;&gt;&gt; pickle.loads(pickle.dumps(f, 2))
&lt;__main__.Foo object at 0x1129C770&gt;
</code></pre>
<p>in Python 3.6</p>
<pre><code>&gt;&gt;&gt; pickle.loads(pickle.dumps(f, 4))
&lt;__main__.Foo object at 0x1129C770&gt;
</code></pre>
<p>So I would keep this in mind, as it is a solved problem.</p>
<h2>Critique of the (until Oct 2, 2016) accepted answer</h2>
<p>The first paragraph is half short explanation, half predictive. Here's the only part that actually answers the question</p>
<blockquote>
<p>The proper use of <code>__slots__</code> is to save space in objects. Instead of having a dynamic dict that allows adding attributes to objects at anytime, there is a static structure which does not allow additions after creation. This saves the overhead of one dict for every object that uses slots</p>
</blockquote>
<p>The second half is wishful thinking, and off the mark:</p>
<blockquote>
<p>While this is sometimes a useful optimization, it would be completely unnecessary if the Python interpreter was dynamic enough so that it would only require the dict when there actually were additions to the object.</p>
</blockquote>
<p>Python actually does something similar to this, only creating the <code>__dict__</code> when it is accessed, but creating lots of objects with no data is fairly ridiculous.</p>
<p>The second paragraph oversimplifies and misses actual reasons to avoid <code>__slots__</code>. The below is <em>not</em> a real reason to avoid slots (for <em>actual</em> reasons, see the rest of my answer above.):</p>
<blockquote>
<p>They change the behavior of the objects that have slots in a way that can be abused by control freaks and static typing weenies.</p>
</blockquote>
<p>It then goes on to discuss other ways of accomplishing that perverse goal with Python, not discussing anything to do with <code>__slots__</code>.</p>
<p>The third paragraph is more wishful thinking. Together it is mostly off-the-mark content that the answerer didn't even author and contributes to ammunition for critics of the site.</p>
<h1>Memory usage evidence</h1>
<p>Create some normal objects and slotted objects:</p>
<pre><code>&gt;&gt;&gt; class Foo(object): pass
&gt;&gt;&gt; class Bar(object): __slots__ = ()
</code></pre>
<p>Instantiate a million of them:</p>
<pre><code>&gt;&gt;&gt; foos = [Foo() for f in xrange(1000000)]
&gt;&gt;&gt; bars = [Bar() for b in xrange(1000000)]
</code></pre>
<p>Inspect with <code>guppy.hpy().heap()</code>:</p>
<pre><code>&gt;&gt;&gt; guppy.hpy().heap()
Partition of a set of 2028259 objects. Total size = 99763360 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0 1000000  49 64000000  64  64000000  64 __main__.Foo
     1     169   0 16281480  16  80281480  80 list
     2 1000000  49 16000000  16  96281480  97 __main__.Bar
     3   12284   1   987472   1  97268952  97 str
...
</code></pre>
<p>Access the regular objects and their <code>__dict__</code> and inspect again:</p>
<pre><code>&gt;&gt;&gt; for f in foos:
...     f.__dict__
&gt;&gt;&gt; guppy.hpy().heap()
Partition of a set of 3028258 objects. Total size = 379763480 bytes.
 Index  Count   %      Size    % Cumulative  % Kind (class / dict of class)
     0 1000000  33 280000000  74 280000000  74 dict of __main__.Foo
     1 1000000  33  64000000  17 344000000  91 __main__.Foo
     2     169   0  16281480   4 360281480  95 list
     3 1000000  33  16000000   4 376281480  99 __main__.Bar
     4   12284   0    987472   0 377268952  99 str
...
</code></pre>
<p>This is consistent with the history of Python, from <a href="https://www.python.org/download/releases/2.2.2/descrintro/" rel="noreferrer">Unifying types and classes in Python 2.2</a></p>
<blockquote>
<p>If you subclass a built-in type, extra space is automatically added to the instances to accomodate <code>__dict__</code> and <code>__weakrefs__</code>. (The <code>__dict__</code> is not initialized until you use it though, so you shouldn't worry about the space occupied by an empty dictionary for each instance you create.) If you don't need this extra space, you can add the phrase "<code>__slots__ = []</code>" to your class.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Quoting <a href="http://code.activestate.com/lists/python-list/531365/" rel="noreferrer">Jacob Hallen</a>:</p>
<blockquote>
<p>The proper use of <code>__slots__</code> is to save space in objects. Instead of having
  a dynamic dict that allows adding attributes to objects at anytime,
  there is a static structure which does not allow additions after creation.
  [This use of <code>__slots__</code> eliminates the overhead of one dict for every object.] While this is sometimes a useful optimization, it would be completely
  unnecessary if the Python interpreter was dynamic enough so that it would
  only require the dict when there actually were additions to the object.</p>
<p>Unfortunately there is a side effect to slots. They change the behavior of
  the objects that have slots in a way that can be abused by control freaks
  and static typing weenies. This is bad, because the control freaks should
  be abusing the metaclasses and the static typing weenies should be abusing
  decorators, since in Python, there should be only one obvious way of doing something.</p>
<p>Making CPython smart enough to handle saving space without <code>__slots__</code> is a major
  undertaking, which is probably why it is not on the list of changes for P3k (yet).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You would want to use <code>__slots__</code> if you are going to instantiate a lot (hundreds, thousands) of objects of the same class. <code>__slots__</code> only exists as a memory optimization tool.</p>
<p>It's highly discouraged to use <code>__slots__</code> for constraining attribute creation, and in general you want to avoid it because it breaks pickle, along with some other introspection features of python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Each python object has a <code>__dict__</code> atttribute which is a dictionary containing all other attributes. e.g. when you type <code>self.attr</code> python is actually doing <code>self.__dict__['attr']</code>. As you can imagine using a dictionary to store attribute takes some extra space &amp; time for accessing it.</p>
<p>However, when you use <code>__slots__</code>, any object created for that class won't have a <code>__dict__</code> attribute. Instead, all attribute access is done directly via pointers.</p>
<p>So if want a C style structure rather than a full fledged class you can use <code>__slots__</code> for compacting size of the objects &amp; reducing attribute access time. A good example is a Point class containing attributes x &amp; y. If you are going to have a lot of points, you can try using <code>__slots__</code> in order to conserve some memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the other answers, here is an example of using <code>__slots__</code>:</p>
<pre><code>&gt;&gt;&gt; class Test(object):   #Must be new-style class!
...  __slots__ = ['x', 'y']
... 
&gt;&gt;&gt; pt = Test()
&gt;&gt;&gt; dir(pt)
['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__', 
 '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', 
 '__repr__', '__setattr__', '__slots__', '__str__', 'x', 'y']
&gt;&gt;&gt; pt.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: x
&gt;&gt;&gt; pt.x = 1
&gt;&gt;&gt; pt.x
1
&gt;&gt;&gt; pt.z = 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Test' object has no attribute 'z'
&gt;&gt;&gt; pt.__dict__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Test' object has no attribute '__dict__'
&gt;&gt;&gt; pt.__slots__
['x', 'y']
</code></pre>
<p>So, to implement <code>__slots__</code>, it only takes an extra line (and making your class a new-style class if it isn't already). This way you can <a href="http://dev.svetlyak.ru/using-slots-for-optimisation-in-python-en/" rel="noreferrer">reduce the memory footprint of those classes 5-fold</a>, at the expense of having to write custom pickle code, if and when that becomes necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Slots are very useful for library calls to eliminate the "named method dispatch" when making function calls.  This is mentioned in the SWIG <a href="http://www.swig.org/Doc2.0/Python.html#Python_builtin_types" rel="noreferrer">documentation</a>.  For high performance libraries that want to reduce function overhead for commonly called functions using slots is much faster.</p>
<p>Now this may not be directly related to the OPs question.  It is related more to building extensions than it does to using the <strong>slots</strong> syntax on an object.  But it does help complete the picture for the usage of slots and some of the reasoning behind them.</p>
</div>
<div class="post-text" itemprop="text">
<p>An attribute of a class instance has 3 properties: the instance, the name of the attribute, and the value of the attribute.</p>
<p>In <strong><em>regular attribute access</em></strong>, the instance acts as a dictionary and the name of the attribute acts as the key in that dictionary looking up value.</p>
<p><strong>instance(attribute) --&gt; value</strong></p>
<p>In <strong><em>__slots__ access</em></strong>, the name of the attribute acts as the dictionary and the instance acts as the key in the dictionary looking up value.</p>
<p><strong>attribute(instance) --&gt; value</strong></p>
<p>In <strong><em>flyweight pattern</em></strong>, the name of the attribute acts as the dictionary and the value acts as the key in that dictionary looking up the instance.</p>
<p><strong>attribute(value) --&gt; instance</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You have — essentially — no use for <code>__slots__</code>.  </p>
<p>For the time when you think you might need <code>__slots__</code>, you actually want to use <strong>Lightweight</strong> or <strong>Flyweight</strong> design patterns. These are cases when you no longer want to use purely Python objects. Instead, you want a Python object-like wrapper around an array, struct, or numpy array.</p>
<pre><code>class Flyweight(object):

    def get(self, theData, index):
        return theData[index]

    def set(self, theData, index, value):
        theData[index]= value
</code></pre>
<p>The class-like wrapper has no attributes — it just provides methods that act on the underlying data. The methods can be reduced to class methods. Indeed, it could be reduced to just functions operating on the underlying array of data.</p>
</div>
<div class="post-text" itemprop="text">
<p>A very simple example of <code>__slot__</code> attribute.</p>
<h2>Problem: Without <code>__slots__</code></h2>
<p>If I don't have <code>__slot__</code> attribute  in my class, I can add new attributes to  my objects. </p>
<pre><code>class Test:
    pass

obj1=Test()
obj2=Test()

print(obj1.__dict__)  #--&gt; {}
obj1.x=12
print(obj1.__dict__)  # --&gt; {'x': 12}
obj1.y=20
print(obj1.__dict__)  # --&gt; {'x': 12, 'y': 20}

obj2.x=99
print(obj2.__dict__)  # --&gt; {'x': 99}
</code></pre>
<p>If you look at example above, you can see that <strong>obj1</strong> and <strong>obj2</strong> have their own <strong>x</strong> and <strong>y</strong> attributes and python has also created  a <code>dict</code> attribute for each object (<strong>obj1</strong> and <strong>obj2</strong>).</p>
<p>Suppose if my class <strong>Test</strong> has thousands of such objects? Creating an additional attribute <code>dict</code> for each object will cause lot of overhead (memory, computing power etc.) in my code. </p>
<h2>Solution: With <code>__slots__</code></h2>
<p>Now in the following example my class <strong>Test</strong> contains <code>__slots__</code> attribute. Now I can't add new attributes to my objects (except attribute <code>x</code>) and python doesn't create a <code>dict</code> attribute anymore. This eliminates overhead for each object, which can become significant if you have many objects.</p>
<pre><code>class Test:
    __slots__=("x")

obj1=Test()
obj2=Test()
obj1.x=12
print(obj1.x)  # --&gt; 12
obj2.x=99
print(obj2.x)  # --&gt; 99

obj1.y=28
print(obj1.y)  # --&gt; AttributeError: 'Test' object has no attribute 'y'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another somewhat obscure use of <code>__slots__</code> is to add attributes to an object proxy from the ProxyTypes package, formerly part of the PEAK project. Its <code>ObjectWrapper</code> allows you to proxy another object, but intercept all interactions with the proxied object. It is not very commonly used (and no Python 3 support), but we have used it to implement a thread-safe blocking wrapper around an async implementation based on tornado that bounces all access to the proxied object through the ioloop, using thread-safe <code>concurrent.Future</code> objects to synchronise and return results.</p>
<p>By default any attribute access to the proxy object will give you the result from the proxied object. If you need to add an attribute on the proxy object, <code>__slots__</code> can be used.</p>
<pre><code>from peak.util.proxies import ObjectWrapper

class Original(object):
    def __init__(self):
        self.name = 'The Original'

class ProxyOriginal(ObjectWrapper):

    __slots__ = ['proxy_name']

    def __init__(self, subject, proxy_name):
        # proxy_info attributed added directly to the
        # Original instance, not the ProxyOriginal instance
        self.proxy_info = 'You are proxied by {}'.format(proxy_name)

        # proxy_name added to ProxyOriginal instance, since it is
        # defined in __slots__
        self.proxy_name = proxy_name

        super(ProxyOriginal, self).__init__(subject)

if __name__ == "__main__":
    original = Original()
    proxy = ProxyOriginal(original, 'Proxy Overlord')

    # Both statements print "The Original"
    print "original.name: ", original.name
    print "proxy.name: ", proxy.name

    # Both statements below print 
    # "You are proxied by Proxy Overlord", since the ProxyOriginal
    # __init__ sets it to the original object 
    print "original.proxy_info: ", original.proxy_info
    print "proxy.proxy_info: ", proxy.proxy_info

    # prints "Proxy Overlord"
    print "proxy.proxy_name: ", proxy.proxy_name
    # Raises AttributeError since proxy_name is only set on 
    # the proxy object
    print "original.proxy_name: ", proxy.proxy_name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The original question was about general use cases not only about memory.
So it should be mentioned here that you also get better <em>performance</em> when instantiating large amounts of objects - interesting e.g. when parsing large documents into objects or from a database.</p>
<p>Here is a comparison of creating object trees with a million entries, using slots and without slots. As a reference also the performance when using plain dicts for the trees (Py2.7.10 on OSX):</p>
<pre><code>********** RUN 1 **********
1.96036410332 &lt;class 'css_tree_select.element.Element'&gt;
3.02922606468 &lt;class 'css_tree_select.element.ElementNoSlots'&gt;
2.90828204155 dict
********** RUN 2 **********
1.77050495148 &lt;class 'css_tree_select.element.Element'&gt;
3.10655999184 &lt;class 'css_tree_select.element.ElementNoSlots'&gt;
2.84120798111 dict
********** RUN 3 **********
1.84069895744 &lt;class 'css_tree_select.element.Element'&gt;
3.21540498734 &lt;class 'css_tree_select.element.ElementNoSlots'&gt;
2.59615707397 dict
********** RUN 4 **********
1.75041103363 &lt;class 'css_tree_select.element.Element'&gt;
3.17366290092 &lt;class 'css_tree_select.element.ElementNoSlots'&gt;
2.70941114426 dict
</code></pre>
<p>Test classes (ident, appart from slots):</p>
<pre><code>class Element(object):
    __slots__ = ['_typ', 'id', 'parent', 'childs']
    def __init__(self, typ, id, parent=None):
        self._typ = typ
        self.id = id
        self.childs = []
        if parent:
            self.parent = parent
            parent.childs.append(self)

class ElementNoSlots(object): (same, w/o slots)
</code></pre>
<p>testcode, verbose mode:</p>
<pre><code>na, nb, nc = 100, 100, 100
for i in (1, 2, 3, 4):
    print '*' * 10, 'RUN', i, '*' * 10
    # tree with slot and no slot:
    for cls in Element, ElementNoSlots:
        t1 = time.time()
        root = cls('root', 'root')
        for i in xrange(na):
            ela = cls(typ='a', id=i, parent=root)
            for j in xrange(nb):
                elb = cls(typ='b', id=(i, j), parent=ela)
                for k in xrange(nc):
                    elc = cls(typ='c', id=(i, j, k), parent=elb)
        to =  time.time() - t1
        print to, cls
        del root

    # ref: tree with dicts only:
    t1 = time.time()
    droot = {'childs': []}
    for i in xrange(na):
        ela =  {'typ': 'a', id: i, 'childs': []}
        droot['childs'].append(ela)
        for j in xrange(nb):
            elb =  {'typ': 'b', id: (i, j), 'childs': []}
            ela['childs'].append(elb)
            for k in xrange(nc):
                elc =  {'typ': 'c', id: (i, j, k), 'childs': []}
                elb['childs'].append(elc)
    td = time.time() - t1
    print td, 'dict'
    del droot
</code></pre>
</div>
<span class="comment-copy">wow, one hell of an answer - thanks! However, I didn't catched the <code>class Child(BaseA, BaseB): __slots__ = ('a', 'b')</code> example with the empy-slot-parents. Why is here a <code>dictproxy</code> created instead of raising an <code>AttributeError</code> for <code>c</code>?</span>
<span class="comment-copy">@Skandix thanks for bringing that typo to my attention, it turned out c was not an instantiation, I probably forgot I was editing that part when I saved it into the post history. It probably would have been caught sooner if I had <i>done the right thing</i> and made the code more copy-pastable... Thanks again!</span>
<span class="comment-copy">This answer should be part of the official Python documentation about <code>__slots__</code>. Seriously! Thank you!</span>
<span class="comment-copy">@NightElfik believe it or not, I contributed to the Python docs on <code>__slots__</code> about a year back: <a href="https://github.com/python/cpython/pull/1819/files" rel="nofollow noreferrer">github.com/python/cpython/pull/1819/files</a></span>
<span class="comment-copy">I'd like to see some elaboration on the "static typing"/decorator point, sans pejoratives. Quoting absent third parties is unhelpful. <code>__slots__</code> doesn't address the same issues as static typing. For example, in C++, it is not the declaration of a member variable is being restricted, it is the assignment of an unintended type (and compiler enforced) to that variable. I'm not condoning the use of <code>__slots__</code>, just interested in the conversation. Thanks!</span>
<span class="comment-copy">I demonstrate pickling a slotted object in my answer and also address the first part of your answer.</span>
<span class="comment-copy">I see your point, but slots offer faster attribute access as well (as others have stated). In that case you don't need <i>"to instantiate a lot (hundreds, thousands) of objects of the same class"</i> in order to gain performance. What you need instead are <i>a lot</i> of accesses to the same (slotted) attribute of the same instance. (Please correct me if I'm wrong.)</span>
<span class="comment-copy">No, an instance of a class with <code>__slots__</code> defined is <i>not</i> like a C-style structure. There is a class-level dictionary mapping attribute names to indexes, otherwise the following would not be possible: <code>class A(object): __slots__= "value",\n\na=A(); setattr(a, 'value', 1)</code> I really think this answer should be clarified (I can do that if you want). Also, I'm not certain that <code>instance.__hidden_attributes[instance.__class__[attrname]]</code> is faster than <code>instance.__dict__[attrname]</code>.</span>
<span class="comment-copy">This is a good share, and won't fit well in a comment on one of the answers that also suggest flyweights, but it is not a complete answer to the question itself. In particular (in just context of the question): why Flyweight, and "what are the cases one should avoid ..." <code>__slots__</code>?</span>
<span class="comment-copy">@Merlyn Morgan-Graham, it serves as a hint on which to pick: regular access, __slots__, or flyweight.</span>
<span class="comment-copy">What has Flyweight to do with <code>__slots__</code>?</span>
<span class="comment-copy">@oefe: I certainly don't get your question.  I can quote my answer, if it helps "when you think you might need <b>slots</b>, you actually want to use ... Flyweight design pattern".  That's what Flyweight has to do with <b>slots</b>.  Do you have a more specific question?</span>
<span class="comment-copy">@oefe: Flyweight and <code>__slots__</code> are both optimization techniques to save memory. <code>__slots__</code> shows benefits when you have many many objects as well as Flyweight design pattern. The both solve the same problem.</span>
<span class="comment-copy">Is there a available comparison between using slots and using Flyweight regarding memory consumption and speed?</span>
<span class="comment-copy">Although Flyweight is certainly useful in some contexts, believe it or not, the answer to "how can I reduce memory usage in Python when I create a zillion objects" is not always "don't use Python for your zillion objects."  Sometimes <code>__slots__</code> really is the answer, and as Evgeni points out, it can be added as a simple afterthought (e.g. you can focus on correctness first, and then add performance).</span>
