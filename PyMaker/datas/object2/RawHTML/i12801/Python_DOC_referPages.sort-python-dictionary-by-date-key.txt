<div class="post-text" itemprop="text">
<p>In the main dictionary, the date was a value. There were data with same date. So then I took the date and grouped it by creating a 2 dimensional dict where date is the key.</p>
<pre><code>data = {
    "01-01-2015" : "some data",
    "05-05-2015" : "some data",
    "03-04-2015" : "some data"
}
</code></pre>
<p>Now I want to sort it by the date descending so that it will look like this:</p>
<pre><code>data = {
    "05-05-2015" : "some data",
    "03-04-2015" : "some data",
    "01-01-2015" : "some data"
}
</code></pre>
<p>How can I achieve that?<br/>
<strong>I am using python 2.6</strong></p>
</div>
<div class="post-text" itemprop="text">
<p><s>The idea here is to use <code>OrderedDict</code> as <code>dictionary</code> has no scope for ordering while OrderedDict preserves the entry order.</s></p>
<p>The idea here is to use <code>list of tuples of (key, value) pairs</code> as <code>dictionary</code> has no scope for ordering while OrderedDict preserves the entry order.
Also we must <strong>convert the keys to actual <code>datetime</code> object</strong> for the sort to work perfectly otherwise sorting on string based fields happen alphabetically.</p>
<p><strong>Code :</strong></p>
<pre><code>from datetime import datetime
#from collections import OrderedDict


data = {
    "01-01-2015" : "some data",
    "05-05-2015" : "some data",
    "03-04-2015" : "some data"
}

#ordered_data = OrderedDict(
#    sorted(data.items(), key = lambda x:datetime.strptime(x[0], '%d-%m-%Y'), reverse=True))

#Since OP is using python 2.6 where OrderedDict is not present, I changed the solution and the original solution is commented out
ordered_data = sorted(data.items(), key = lambda x:datetime.strptime(x[0], '%d-%m-%Y'), reverse=True)

print(ordered_data)
</code></pre>
<p><strong>Output :</strong></p>
<pre><code>[('05-05-2015', 'some data'), ('03-04-2015', 'some data'), 
('01-01-2015', 'some data')]
</code></pre>
<p><strong>Explanation :</strong> (For converting keys to datetime for sorting)</p>
<p>If you keep the date field as string then the lexicographical order is considered and <code>3</code> comes after <code>0</code> hence <code>a&gt;b</code> is <code>True</code> but same is not true for their date counterparts. <code>Feb</code> definitely comes after <code>Jan</code>.</p>
<pre><code>a = "30-01-2015"
b = "01-02-2015"

print(a&gt;b)    #True

a_datetime = datetime.strptime(a, '%d-%m-%Y')
b_datetime = datetime.strptime(b, '%d-%m-%Y')

print(a_datetime&gt;b_datetime) #False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the sorted method of python that will automatically sort your data on date and return a list.</p>
<pre><code>data = {"01-01-2015" : "some data","05-05-2015" : "some data","03-04-2015" : "some data"}
sorted(data.items(), reverse=True)
</code></pre>
<p>that will produce the result:</p>
<pre><code>[('05-05-2015', 'some data'), ('03-04-2015', 'some data'), ('01-01-2015', 'some data')]
</code></pre>
</div>
<span class="comment-copy">why is <code>"03-04-2015"</code>  before <code>"05-05-2015"</code>?</span>
<span class="comment-copy"><i>By date key?</i> The second code block is your expect or the first one is? And by the way, you need <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a>.</span>
<span class="comment-copy">A simple google/stackoverflow search will tell you clearly that <b>a python dictionary can't be sorted.</b> A different structure will have to be used. (ex- OrderedDict). Try it and let us know.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/9001509/how-can-i-sort-a-dictionary-by-key">How can I sort a dictionary by key?</a></span>
<span class="comment-copy">I have edited the question.</span>
<span class="comment-copy">Sorry but I forgot to mention the python version. It's 2.6 that I am using and OrderedDict is from 2.7+</span>
<span class="comment-copy">Just use  <code>ordered_data = sorted(data.items(), key = lambda x:datetime.strptime(x[0], '%d-%m-%Y'), reverse=True)</code>. Only thing is you will not be able to use dictionary's <code>key</code> advantage as you will get a list of tuple as output.</span>
