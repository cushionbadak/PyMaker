<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/8166633/mocking-file-objects-or-iterables-in-python">There's a couple of stack overflow posts out there talking about mocking the open call in Python.</a> That's great but it doesn't really help me if a function takes in a file handle or stream object instead of a file path.</p>
<p>One solution I've been using up until now has been <code>cStringIO</code> objects. I've run into a problem, however.</p>
<p>If I want to test if I'm logging the file name correctly on some sort of failure (say if the file / stream is empty and you expect some kind of data)</p>
<pre><code>cStringIO
fd = cStringIO("")
fd.name = "testing/path" # Throws an AttributeError
</code></pre>
<p>I can't set the name attribute since <code>cStringIO</code> and <code>StringIO</code> are slotted classes.</p>
<p>If switch over to using <code>open_mock</code></p>
<pre><code>with mock.patch('__main__.open', mock.mock_open(read_data=''), create=True) as m:
</code></pre>
<p>I run into </p>
<pre><code>AttributeError: Mock object has no attribute 'tell'
</code></pre>
<p>At this point it feels like I have to use temp files but I'd like to avoid actually calling out to the file system if possible.</p>
<p><strong>How do you test functions that take in file handles without having to create actual files on a file system?</strong> </p>
</div>
<div class="post-text" itemprop="text">
<p>You can set the <code>tell</code> attribute explicitly for the mock object using <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value" rel="nofollow"><code>Mock.return_value</code></a>:</p>
<pre><code>import mock

def function_under_test(f):
    f.tell()  # =&gt; 0
    f.read()
    f.tell()  # =&gt; 0
    return f.name

with mock.patch('__main__.open', mock.mock_open(read_data=''), create=True) as m:
    with open('/tmp/1') as f:
        f.name = '/tmp/1'
        f.tell.return_value = 0
        assert function_under_test(f) == '/tmp/1'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I went down the path of creating a class that inherited from StringIO. It took me more time than I want to admit to figure out that in Python2.7 StringIO is an old style class.</p>
<pre><code>class MockFile(StringIO, object):
    """This is a work around for the fact that StringIO is a slotted class and
    doesn't have a name attribute.
    """
    name = None
    def __init__(self, name, buffer_ = None):
        super(MockFile, self).__init__(buffer_)
        self.name = name
</code></pre>
</div>
<span class="comment-copy">Works fine for me: <a href="http://pastebin.com/6QkKxdER" rel="nofollow noreferrer">pastebin.com/6QkKxdER</a>, Could you show your function under the test?</span>
<span class="comment-copy">Ah, you explicitly set the <code>tell</code> attribute. That also worked for me. You should post that as an answer. I ended up making my own class that inherited from StringIO and object. I think your answer is might be cleaner than the one I ended up using.</span>
