<div class="post-text" itemprop="text">
<p>I recently moved to Python 3.5 and noticed the <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-465" rel="noreferrer">new matrix multiplication operator (@)</a> sometimes behaves differently from the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="noreferrer">numpy dot</a> operator. In example, for 3d arrays:</p>
<pre><code>import numpy as np

a = np.random.rand(8,13,13)
b = np.random.rand(8,13,13)
c = a @ b  # Python 3.5+
d = np.dot(a, b)
</code></pre>
<p>The <code>@</code> operator returns an array of shape:</p>
<pre><code>c.shape
(8, 13, 13)
</code></pre>
<p>while the <code>np.dot()</code> function returns:</p>
<pre><code>d.shape
(8, 13, 8, 13)
</code></pre>
<p>How can I reproduce the same result with numpy dot? Are there any other significant differences?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>@</code> operator calls the array's <code>__matmul__</code> method, not <code>dot</code>. This method is also present in the API as the function <a href="http://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.matmul.html"><code>np.matmul</code></a>.</p>
<pre><code>&gt;&gt;&gt; a = np.random.rand(8,13,13)
&gt;&gt;&gt; b = np.random.rand(8,13,13)
&gt;&gt;&gt; np.matmul(a, b).shape
(8, 13, 13)
</code></pre>
<p>From the documentation:</p>
<blockquote>
<p><code>matmul</code> differs from <code>dot</code> in two important ways.</p>
<ul>
<li>Multiplication by scalars is not allowed.</li>
<li>Stacks of matrices are broadcast together as if the matrices were elements.</li>
</ul>
</blockquote>
<p>The last point makes it clear that <code>dot</code> and <code>matmul</code> methods behave differently when passed 3D (or higher dimensional) arrays. Quoting from the documentation some more:</p>
<p>For <code>matmul</code>:</p>
<blockquote>
<p>If either argument is N-D, N &gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</p>
</blockquote>
<p>For <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html"><code>np.dot</code></a>:</p>
<blockquote>
<p>For 2-D arrays it is equivalent to matrix multiplication, and for 1-D arrays to inner product of vectors (without complex conjugation). <em>For N dimensions it is a sum product over the last axis of a and the second-to-last of b</em></p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The answer by @ajcr explains how the <code>dot</code> and <code>matmul</code> (invoked by the <code>@</code> symbol) differ. By looking at a simple example, one clearly sees how the two behave differently when operating on 'stacks of matricies' or tensors. </p>
<p>To clarify the differences take a 4x4 array and return the <code>dot</code> product and <code>matmul</code> product with a 2x4x3 'stack of matricies' or tensor.</p>
<pre><code>import numpy as np
fourbyfour = np.array([
                       [1,2,3,4],
                       [3,2,1,4],
                       [5,4,6,7],
                       [11,12,13,14]
                      ])


twobyfourbythree = np.array([
                             [[2,3],[11,9],[32,21],[28,17]],
                             [[2,3],[1,9],[3,21],[28,7]],
                             [[2,3],[1,9],[3,21],[28,7]],
                            ])

print('4x4*4x2x3 dot:\n {}\n'.format(np.dot(fourbyfour,twobyfourbythree)))
print('4x4*4x2x3 matmul:\n {}\n'.format(np.matmul(fourbyfour,twobyfourbythree)))
</code></pre>
<p>The products of each operation appear below. Notice how the dot product is, </p>
<blockquote>
<p>...a sum product over the last axis of a and the second-to-last of b</p>
</blockquote>
<p>and how the matrix product is formed by broadcasting the matrix together. </p>
<pre><code>4x4*4x2x3 dot:
 [[[232 152]
  [125 112]
  [125 112]]

 [[172 116]
  [123  76]
  [123  76]]

 [[442 296]
  [228 226]
  [228 226]]

 [[962 652]
  [465 512]
  [465 512]]]

4x4*4x2x3 matmul:
 [[[232 152]
  [172 116]
  [442 296]
  [962 652]]

 [[125 112]
  [123  76]
  [228 226]
  [465 512]]

 [[125 112]
  [123  76]
  [228 226]
  [465 512]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In mathematics, I think the <strong>dot</strong> in numpy makes more sense </p>
<blockquote>
<p><strong>dot</strong>(a,b)_{i,j,k,a,b,c} = \sum_m a_{i,j,k,m}b_{a,b,m,c}</p>
</blockquote>
<p>since it gives the dot product when a and b are vectors, or the matrix multiplication when a and b are matrices</p>
<hr/>
<p>As for <strong>matmul</strong> operation in numpy, it consists of parts of <strong>dot</strong> result, and it can be defined as</p>
<blockquote>
<p><strong>matmul</strong>(a,b)_{i,j,k,c} = \sum_m a_{i,j,k,m}b_{i,j,m,c}</p>
</blockquote>
<hr/>
<p>So, you can see that <strong>matmul(a,b)</strong> returns an array with a small shape,
which has smaller memory consumption and make more sense in applications.
In particular, combining with <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting</a>, you can get </p>
<blockquote>
<p><strong>matmul</strong>(a,b)_{i,j,k,l} = \sum_m a_{i,j,k,m}b_{j,m,l}</p>
</blockquote>
<p>for example.</p>
<hr/>
<p>From the above two definitions, you can see the requirements to use those two operations. Assume <strong>a.shape=(s1,s2,s3,s4)</strong> and <strong>b.shape=(t1,t2,t3,t4)</strong></p>
<ul>
<li><p>To use <strong>dot(a,b)</strong> you need</p>
<pre><code> 1. **t3=s4**;
</code></pre></li>
<li><p>To use <strong>matmul(a,b)</strong> you need </p>
<ol>
<li><strong>t3=s4</strong> </li>
<li><strong>t2=s2</strong>, or one of t2 and s2 is 1</li>
<li><strong>t1=s1</strong>, or one of t1 and s1 is 1</li>
</ol></li>
</ul>
<hr/>
<p>Use the following piece of code to convince yourself. </p>
<h2>Code sample</h2>
<pre><code>import numpy as np
for it in xrange(10000):
    a = np.random.rand(5,6,2,4)
    b = np.random.rand(6,4,3)
    c = np.matmul(a,b)
    d = np.dot(a,b)
    #print 'c shape: ', c.shape,'d shape:', d.shape

    for i in range(5):
        for j in range(6):
            for k in range(2):
                for l in range(3):
                    if not c[i,j,k,l] == d[i,j,k,j,l]:
                        print it,i,j,k,l,c[i,j,k,l]==d[i,j,k,j,l] #you will not see them
</code></pre>
</div>
<span class="comment-copy">You can't get that result out of dot. I think people generally agreed that dot's handling of high-dimension inputs was the wrong design decision.</span>
<span class="comment-copy">Why didn't they implement the <code>matmul</code> function years ago?  <code>@</code> as an infix operator is new, but the function works just as well without it.</span>
<span class="comment-copy">The confusion here is probably because of the release notes, which directly equate the "@" symbol to the dot() function of numpy in the example code.</span>
<span class="comment-copy">dot(a, b) [i,j,k,m] = sum(a[i,j,:] * b[k,:,m]) ------- like documentation says:  it is a sum product over the last axis of a and the second-to-last axis of b:</span>
