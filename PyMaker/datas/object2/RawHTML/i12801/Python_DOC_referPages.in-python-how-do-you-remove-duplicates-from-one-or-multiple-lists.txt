<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7961363/removing-duplicates-in-lists">Removing duplicates in lists</a>
<span class="question-originals-answer-count">
                    44 answers
                </span>
</li>
</ul>
</div>
<p>For example, if I had:</p>
<pre><code>a = ["apples", "bananas", "cucumbers", "bananas"]
</code></pre>
<p>How could I remove the duplicate "bananas" so that:</p>
<pre><code>a = ["apples", "bananas", "cucumbers"]
</code></pre>
<p>Also, if I had:</p>
<pre><code>a = ["apples", "bananas", "cucumbers"]

b = ["pears", "apples", "watermelons"]
</code></pre>
<p>How could I remove the duplicate "apples" from both lists so that:</p>
<pre><code>a = ["bananas", "cucumbers"]

b = ["pears", "watermelons"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The set-based solutions don't retain the order of the items. The following will keep the items in order and delete all but the first occurrence of each, using an auxilary set to keep track of which items have already been seen.</p>
<pre><code>seen = set()
a = [seen.add(item) or item for item in a if item not in seen]
</code></pre>
<p>If you want to reuse the same list object, you can do that this way:</p>
<pre><code>seen = set()
a[:] = (seen.add(item) or item for item in a if item not in seen)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use built-in functions <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow">set</a></p>
<pre><code>a = ["apples", "bananas", "cucumbers", "bananas"]
a = list(set(a))
print(a)
</code></pre>
<p>In second case, use <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a></p>
<pre><code>a = ["apples", "bananas", "cucumbers"]
b = ["pears", "apples", "watermelons"]

r = [i for i in a if i not in b] + [i for i in b if i not in a]    
print(r)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The key to doing this is using Python's <em>set</em>. </p>
<ul>
<li>In Python, a set is a data structure in which every item is unique.</li>
<li>If you call set(list), with a list as a parameter, you will get a set that contains all of the elements in list, with the duplicates removed</li>
<li>You can then convert this back into a list by calling list(). </li>
</ul>
<p>So, in your first example, you can write </p>
<pre><code>a = list(set(a))
</code></pre>
<p>There are a couple of other methods in set that are useful. </p>
<ol>
<li><strong>Intersection</strong> - Calling set1.intersection(<em>set2</em>) returns a set with all of the objects that are in both <em>set1</em> and <em>set2</em>. </li>
<li><strong>Difference</strong> - Calling set1.difference(<em>set2</em>) returns a set with all of the elements in set1 that are not in <em>set2</em>.</li>
</ol>
<p>So, in your second example, you can write</p>
<pre><code>set1 = set(a).intersection(set(b)) #Get elements that are in both lists
set2 = set(a).difference(set1) #Get a set elements that are in a but not in b
a = list(set2) #Convert back to a list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <code>set()</code>:</p>
<pre><code>a = ["apples", "bananas", "cucumbers", "bananas"]

print list(set(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a set object to record the duplicate elements. Like this:</p>
<pre><code>def handle_dumplicate(*lsts):
    s = set()
    result = []
    for lst in lsts:
        no_dump_lst = []
        for ele in lst:
            if ele in s:
                continue
            s.add(ele)
            no_dump_lst.append(ele)
        result.append(no_dump_lst)
    return result

a = ["apples", "bananas", "cucumbers"]
b = ["pears", "apples", "watermelons"]

a, b = handle_dumplicate(a, b)
print a
print b
</code></pre>
</div>
<span class="comment-copy">You may also want to modify the current list rather than replace it, in case he had more than 1 variable referencing the original one. try <code>aux = [...]; for i in range(len(a)): a.pop(); a += aux</code></span>
<span class="comment-copy">I'd use a slice assignment for that. I'll add that as example.</span>
<span class="comment-copy">oh yeah, good old <code>a[::]</code></span>
<span class="comment-copy">the OP never mentioned retaining order.</span>
<span class="comment-copy">True, but he didn't mention it wasn't important either. If it is important, here's a solution.</span>
<span class="comment-copy">along these same lines... you can also use a set comprehension to build a new unique list.  {x for x in a}</span>
<span class="comment-copy">The <code>set(b)</code> is not needed, the point of <code>intersection</code> etc.. is you can pass any iterable</span>
