<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" rel="noreferrer">Python 3.5 docs</a>, subprocess.run() returns an a CompletedProcess object with a stdout member that contains "A bytes sequence, or a string if run() was called with universal_newlines=True." I'm only seeing a byte sequence and not a string, which I was assuming (hoping) would be equivalent to a text line. For example,</p>
<pre><code>import pprint
import subprocess

my_data = ""
line_count = 0

proc = subprocess.run(
         args = [ 'cat', 'input.txt' ],
         universal_newlines = True,
         stdout = subprocess.PIPE)

for text_line in proc.stdout:
    my_data += text_line
    line_count += 1

word_file = open('output.txt', 'w')
pprint.pprint(my_data, word_file)
pprint.pprint(line_count, word_file)
</code></pre>
<p>Note: this uses a new feature in Python 3.5 that won't run in previous versions.</p>
<p>Do I need to create my own line buffering logic, or is there a way to get Python to do that for me?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>proc.stdout</code> is already a string in your case, run <code>print(type(proc.stdout))</code>, to make sure. It contains all subprocess' output -- <code>subprocess.run()</code> does not return until the child process is dead.</p>
<p><code>for text_line in proc.stdout:</code> is incorrect: <code>for char in text_string</code> enumerates characters (Unicode codepoints) in Python, not lines. To get lines, call:</p>
<pre><code>lines = result.stdout.splitlines()
</code></pre>
<p>The result may be different from <code>.split('\n')</code> if there are Unicode newlines in the string.</p>
<p>If you want to read the output line by line (to avoid running out of memory for long-running processes):</p>
<pre><code>from subrocess import Popen, PIPE

with Popen(command, stdout=PIPE, universal_newlines=True) as process:
    for line in process.stdout:
        do_something_with(line)
</code></pre>
<p>Note: <code>process.stdout</code> is a file-like object in this case. <code>Popen()</code> does not wait for the process to finish -- <code>Popen()</code> returns immidiately as soon as the child process is started. <code>process</code> is a <code>subprocess.Popen</code> instance, not <code>CompletedProcess</code> here.</p>
<p>If all you need is to count the number of lines (terminated by <code>b'\n'</code>) in the output, like <code>wc -l</code>:</p>
<pre><code>from functools import partial

with Popen(command, stdout=PIPE) as process:
    read_chunk = partial(process.stdout.read, 1 &lt;&lt; 13)
    line_count = sum(chunk.count(b'\n') for chunk in iter(read_chunk, b''))
</code></pre>
<p>See <a href="https://stackoverflow.com/q/9371238/4279">Why is reading lines from stdin much slower in C++ than Python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>if you need to have STDOUT lines in an array to better manipulate them you simply miss to split output by the "Universal newline" separators</p>
<pre><code>nmap_out = subprocess.run(args = ['nmap', '-T4', '-A', '192.168.1.128'],
                              universal_newlines = True,
                              stdout = subprocess.PIPE)

nmap_lines = nmap_out.stdout.splitlines()
print(nmap_lines)
</code></pre>
<p>output is:</p>
<pre><code>['Starting Nmap 7.01 ( https://nmap.org ) at 2016-02-28 12:24 CET', 'Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn', 'Nmap done: 1 IP address (0 hosts up) scanned in 2.37 seconds']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are seeing a string, compare:</p>
<pre><code>import subprocess
proc = subprocess.run(
    args = [ 'cat', 'input.txt' ],
    universal_newlines = False,
    stdout = subprocess.PIPE)

print (type(proc.stdout))
</code></pre>
<p>class 'bytes'</p>
<p>run calls popen.communicate</p>
<blockquote>
<p>communicate() returns a tuple (stdout_data, stderr_data). The data
  will be bytes or, if universal_newlines was True, strings.</p>
</blockquote>
<p>Have a look <a href="https://pymotw.com/2/subprocess/index.html#module-subprocess" rel="nofollow">here</a> for more explanation and other shell interactions.</p>
</div>
<span class="comment-copy">This doesn't even run for me (in 3.4) -- is that expected?</span>
<span class="comment-copy">I'm using 3.5. I'll make it more clear.</span>
<span class="comment-copy">Are you sure you're getting a byte sequence? You may <code>print type(proc.stdout)</code> or something to check. You're iterating over <code>proc.stdout</code> as though it's a file. Iterating over an open text file gives you each line. Iterating over a string or byte sequence give you each character/byte. If you want to handle each line of a string individually, you could iterate over <code>proc.stdout.split('\n')</code> instead. (Though this won't include newlines in each line like iterating over a file would.)</span>
<span class="comment-copy">Thanks. Chaining split() to proc.stdout was what I was looking for.</span>
