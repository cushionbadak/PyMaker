<div class="post-text" itemprop="text">
<p>I basically have n number of players and for every player I am calculating how similar they are to every other players and storing them in order or similarity. </p>
<p>I am using Pearson Correlation Coefficient to measure similarity between any two players. Now basically I want a data structure in which i can store information for every player including the similarity value between them and all other players. So for player1 i want to keep a list of its similarity value with all other players. As such I thought of creating a list of arrays and every index would represent the player, for example index 0 would be player 1 and so on. Now inside the index we would have an array of dictionaries. Each dictionary would have key of playerId and value as the similarity between itself and the player we are referring to.</p>
<pre><code>Player1 --&gt; [[player2:0.0], [player3:0.5]]

so we would have one array where we have player1,player2,player3
and then in each index we have information as showed above.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let us keep it simple. All you need is one dictionary and two helper methods as below</p>
<p><strong>This considers the case the similarity between player1 &amp; player2 remains the same irrespective of the order during put &amp; get.</strong> </p>
<pre><code>similarities = {}

def set_sim(players, sim):
    similarities[tuple(sorted(players))] = sim

def get_sim(players):
    return similarities.get(tuple(sorted(players)))
</code></pre>
<p>Here is how to use them</p>
<pre><code>&gt;&gt;&gt; set_sim(['Player3', 'Player1'], 2)
&gt;&gt;&gt; set_sim(['Player1', 'Player2'], 3)
&gt;&gt;&gt; set_sim(['Player2', 'Player3'], 3)
&gt;&gt;&gt; get_sim(['Player3','Player2'])
3
&gt;&gt;&gt; similarities
{('Player1', 'Player2'): 3, ('Player2', 'Player3'): 3, ('Player1', 'Player3'): 2}
</code></pre>
<p>If you are in need of finding other players, the helper method should be easy again. </p>
<pre><code>def get_other_players(player):
    for pair in similarities.keys():
        try:
            other_player = pair[(pair.index(player)+1)%2]
            print other_player, "=", similarities[pair]
        except ValueError:
            pass
</code></pre>
<p>logs:</p>
<pre><code>&gt;&gt;&gt; set_sim(['Player9','Player4'], .02)
&gt;&gt;&gt; set_sim(['Player3','Player4'], .8)
&gt;&gt;&gt; set_sim(['Player12','Player4'], 1.5)

&gt;&gt;&gt; get_other_players('Player4')
Player9 = 0.02
Player3 = 0.8
Player12 = 1.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My English is poor, So I think what you mean is </p>
<pre><code>player1 = {'player2': 0.0, 'player3': 0.5}
for x in player1:
    print(x, ' is ', player1[x])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is?</p>
<pre><code>from collections import namedtuple

p1 = namedtuple('p1', ['p2', 'p3'])
p2 = namedtuple('p2', ['p1', 'p3'])
p3 = namedtuple('p3', ['p1', 'p2'])

p1.p2 = 0.4
p1.p3 = 1.1

p2.p1 = 1.5
p2.p3 = 0.0

p3.p1 = 0.5
p3.p2 = 1.0

total = (p1, p2, p3)

for i in total:
    print('* {}'.format(i.__name__))
    for i2 in i._fields:
        print('{}-&gt;{}: {}'.format(i2, i.__name__, eval(i2 + '.' + i.__name__)))
</code></pre>
<p>Perhaps there is a more elegant way to do this, but it works... =P</p>
</div>
<div class="post-text" itemprop="text">
<p>You may be looking for a <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow">dictionary</a></p>
<pre><code>players = {
    "player1": 0.0,
    "player2": 0.0,
    "player3": 0.5,
}
</code></pre>
<p>you can then access it as</p>
<pre><code>players["player1"]
</code></pre>
<p>or change it with</p>
<pre><code>players["player2"] = 0.7
</code></pre>
<p>add new</p>
<pre><code>players["player4"] = 0.1
</code></pre>
<p>and see all</p>
<pre><code>print(players)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>similarity={
   'player1': { 'player2': 0.0,
                'player3': 0.5 },

   'player2': { 'player1': 0.0,
                'player3': 0.8 },

   'player3': { 'player1': 0.5,
                'player2': 0.8 }
   }

print(similarity['player1'])
# will give you: {'player2': 0.0, 'player3': 0.5}

print(similarity['player1']['player3'])
# will give you 0.5
</code></pre>
<p>A more robust solution:</p>
<pre><code>class Sim:

    __data = None

    def __init__(self):
        self.__data = dict()

    def set(self, player1, player2, similarity):

        if not self.__data.has_key(player1):
            self.__data[player1] = dict()

        if not self.__data.has_key(player2):
            self.__data[player2] = dict()

        self.__data[player1][player2] = similarity
        self.__data[player2][player1] = similarity

    def get(self, player1, player2):
        return self.__data[player1][player2]

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)


example=Sim()
example.set('player1', 'player2', 0)
example.set('player1', 'player3', 0.5)

print(example)
# will print: 
# {'player2': {'player1': 0}, 'player3': {'player1': 0.5}, 'player1': {'player2': 0, 'player3': 0.5}}
</code></pre>
</div>
<span class="comment-copy">Could better explain the situation? Give a better example of what you have and what you want.</span>
<span class="comment-copy">@Macabeus take a look now</span>
<span class="comment-copy">This looks good but now say i wanted to get all the similar players for player1 in order would i have to do more processing? because in this method it seems everytime you gotta pass two player ids to get thier value.</span>
<span class="comment-copy">Updated the answer, to me it looks easy thought. See if you can get hold of it... Or you are free to come up with something that works easy for you.</span>
<span class="comment-copy">it is beautiful</span>
<span class="comment-copy">Shouldn't  <code>p1.p3</code> and <code>p3.p1</code> return same for this given requirement ?</span>
<span class="comment-copy">The same concern<code>similarity['player1']['player3']</code> and  <code>similarity['player3']['player1']</code> should remain same. Can you add a mechanism to maintain the integrity ?</span>
<span class="comment-copy">see my updated version</span>
