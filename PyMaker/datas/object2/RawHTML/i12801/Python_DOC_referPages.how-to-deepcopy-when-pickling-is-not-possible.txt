<div class="post-text" itemprop="text">
<p>I'm trying to deepcopy a dictionary in Python 3.4 but some of the values are not "pickable", i.e. when I try to deepcopy the dictionary, it raises a RuntimeError exception</p>
<pre><code>*** RuntimeError: Pickling of "DataObject" instances is not enabled (http://www.boost.org/libs/python/doc/v2/pickle.html)
</code></pre>
<p>What would be the best option to deepcopy the dictionary?</p>
<p>So far, I'm recursively iterating through the dictionary and creating a new one but I would like to know if there's a more robust and elegant solution.</p>
<p>Note: I cannot modify DataObject structure to support pickling.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add copy functions to the <a href="https://docs.python.org/3/library/copyreg.html" rel="nofollow"><code>copyreg</code> module</a> to handle types that cannot be pickled:</p>
<pre><code>import copyreg

pickle_dataobject(do):
    return DataObject, (do.arg1, do.arg2)

copyreg.pickle(DataObject, pickle_dataobject)
</code></pre>
<p>The idea is that you return a constructor and the arguments that are to be passed to the constructor to re-create the original value.</p>
<p>The <code>copy.deepcopy()</code> function then uses the above <code>pickle_dataobject()</code> to obtain a copy whenever <code>ob is DataObject</code> is true (the class is looked up in the <code>copyreg.dispatch_table</code> dictionary that <code>copyreg.pickle()</code> adds your function to).</p>
</div>
<span class="comment-copy">I can see this is the right way to do it. Sadly in my case, I don't have good visibility of all the DataObject arguments. I work with some "special" (annoying) swig interfaces of C++ libraries that have lots of issues like that. I can't see how could I use this method without being able to list all the arguments. That said, I think this is the way to go so I'll mark it as the right answer.</span>
<span class="comment-copy">@zom-pro: well, how do you create new instances now? Is it perhaps a another class that contains these things that you need to hook into instead? The idea is that you leave everything to <code>copy.deepcopy()</code> still, but teach it how to copy specific types without having to alter those types directly. But if these objects are created as internal data structures for some container class, teach <code>copyreg</code> about the container class instead.</span>
<span class="comment-copy">with Python 2.7 copy_reg can be used. The copy_reg module has been renamed to copyreg in Python 3.</span>
