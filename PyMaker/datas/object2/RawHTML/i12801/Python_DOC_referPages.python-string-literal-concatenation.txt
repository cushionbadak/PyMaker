<div class="post-text" itemprop="text">
<p>I can create a multi-line string using this syntax: </p>
<pre><code>string = str("Some chars "
         "Some more chars")
</code></pre>
<p>This will produce the following string:</p>
<pre><code>"Some chars Some more chars"
</code></pre>
<p>Is Python joining these two separate strings or is the editor/compiler treating them as a single string? </p>
<p>P.s: I just want to understand the internals. I know there are other ways to declare or create multi-line strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Read the <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation" rel="noreferrer"><em>reference manual</em></a>, <em>it's in there</em>. 
Specifically: </p>
<blockquote>
<p>Multiple adjacent string or bytes literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation. Thus, "hello" 'world' is equivalent to "helloworld". <em>This feature can be used to reduce the number of backslashes needed, <strong>to split long strings conveniently across long lines</strong>, or even to add comments to parts of strings,</em></p>
</blockquote>
<p><sup>(<em>emphasis mine</em>)</sup></p>
<p>This is why:</p>
<pre><code>string = str("Some chars "
         "Some more chars")
</code></pre>
<p>is exactly the same as: <code>str("Some chars Some more chars")</code>.</p>
<p>This action is performed wherever a string literal might appear, list initiliazations, function calls (as is the case with <code>str</code> above) et-cetera. </p>
<p>The only caveat is when a string literal <strong>is not</strong> contained between one of the <a href="https://docs.python.org/3/reference/lexical_analysis.html#delimiters" rel="noreferrer"><em>grouping delimiters</em> <code>()</code>, <code>{}</code> or <code>[]</code></a> but, instead, spreads between two separate <a href="https://docs.python.org/3/reference/lexical_analysis.html#physical-lines" rel="noreferrer">physical lines</a>. In that case we can alternatively <a href="https://docs.python.org/3/reference/lexical_analysis.html#explicit-line-joining" rel="noreferrer">use</a> the backslash character to join these lines and get the same result:</p>
<pre><code>string = "Some chars " \
         "Some more chars"
</code></pre>
<p>Of course, concatenation of strings on the same physical line does not require the backslash. (<code>string = "Hello " "World"</code> is just fine)</p>
<hr/>
<blockquote>
<p>Is Python joining these two separate strings or is the editor/compiler treating them as a single string?</p>
</blockquote>
<p>Python is, now <em>when</em> exactly does Python do this is where things get interesting.</p>
<p>From what I could gather (<em>take this with a pinch of salt, I'm not a parsing expert</em>), this happens when Python transforms the parse tree (<em><a href="https://en.wikipedia.org/wiki/LL_parser" rel="noreferrer"><code>LL(1)</code> Parser</a></em>) for a given expression to it's corresponding AST <em>(<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noreferrer">Abstract Syntax Tree</a>)</em>. </p>
<p>You can get a view of the parsed tree via the <em><a href="https://docs.python.org/3.5/library/parser.html" rel="noreferrer"><code>parser</code></a></em> module:</p>
<pre><code>import parser

expr = """
       str("Hello "
           "World")
"""
pexpr = parser.expr(expr)
parser.st2list(pexpr)
</code></pre>
<p>This dumps a pretty big and confusing list that represents concrete syntax tree parsed from the expression in <code>expr</code>: </p>
<pre><code>-- rest snipped for brevity --

          [322,
             [323,
                [3, '"hello"'],
                [3, '"world"']]]]]]]]]]]]]]]]]],

-- rest snipped for brevity --
</code></pre>
<p>The numbers correspond to either symbols or tokens in the parse tree  and the mappings from symbol to grammar rule and token to constant are in <em><a href="https://hg.python.org/cpython/file/3.5/Lib/symbol.py" rel="noreferrer"><code>Lib/symbol.py</code></a></em> and <em><a href="https://hg.python.org/cpython/file/2.7/Lib/token.py" rel="noreferrer"><code>Lib/token.py</code></a></em> respectively.</p>
<p>As you can see in the snipped version I added, you have two different entries corresponding to the two different <code>str</code> literals in the expression parsed.</p>
<p>Next, we can view the output of the AST tree produced by the previous expression via the <em><a href="https://docs.python.org/3.5/library/ast.html" rel="noreferrer"><code>ast</code></a></em> module provided in the Standard Library: </p>
<pre><code>p = ast.parse(expr)
ast.dump(p)

# this prints out the following:
"Module(body = [Expr(value = Call(func = Name(id = 'str', ctx = Load()), args = [Str(s = 'hello world')], keywords = []))])"
</code></pre>
<p>The output is more user friendly in this case; you can see that the <code>args</code> for the function call is the single concatenated string <code>Hello World</code>.</p>
<p>In addition, I also stumbled upon a cool <a href="https://github.com/quantifiedcode/python-ast-visualizer" rel="noreferrer">module</a> that generates a visualization of the tree for <code>ast</code> nodes. Using it, the output of the expression <code>expr</code> is visualized like this:</p>
<p>                                           <a href="https://i.stack.imgur.com/XAmuz.png" rel="noreferrer"><img alt="expression tree for the given expression" src="https://i.stack.imgur.com/XAmuz.png"/></a></p>
<p><sup>Image cropped to show only the relevant part for the expression.</sup></p>
<p>As you can see, in the terminal leaf node we have a single <code>str</code> object, the joined string for <code>"Hello "</code> and <code>"World"</code>, i.e <code>"Hello World"</code>. </p>
<hr/>
<p>If you are feeling brave enough, dig into the source, the source code for transforming expressions into a parse tree is located at <em><a href="https://hg.python.org/cpython/file/tip/Parser/parser.c" rel="noreferrer"><code>Parser/pgen.c</code></a></em> while the code transforming the parse tree into an Abstract Syntax Tree is in <em><a href="https://hg.python.org/cpython/file/tip/Python/ast.c" rel="noreferrer"><code>Python/ast.c</code></a></em>.</p>
<p>This information is for <code>Python 3.5</code> and I'm pretty sure that unless you're using some <em>really old</em> version (<code>&lt; 2.5</code>) the functionality and locations <em>should</em> be similar.</p>
<p>Additionally, if you are interested in the whole compilation step python follows, a good gentle intro is provided by one of the core contributors, Brett Cannon, in the video <em><a href="https://www.youtube.com/watch?v=R31NRWgoIWM" rel="noreferrer">From Source to Code: How CPython's Compiler Works</a></em>.</p>
</div>
<span class="comment-copy">"Does python is joining these two separate strings" - Yes, it does. <a href="https://docs.python.org/2/reference/lexical_analysis.html#string-literal-concatenation" rel="nofollow noreferrer">This behaviour is even documented.</a></span>
<span class="comment-copy">It is not a <b>multiline</b> string, though. This feature has nothing to do with line breaks. Python is ignoring the line break because of the parenthesis. BTW, a multiline string could be created using triple quotes (<code>"""</code> or <code>'''</code>).</span>
<span class="comment-copy">Thanks for your answer. Which clears my doubt. Additionally I would like to ask when I say "Some chars " and on the next line I say "Some more chars ", without enclosing in the brackets, it will not produce the same output. So, when they are saying whitespaces they don't mean newlines, do they?</span>
<span class="comment-copy">You can omit <code>str</code>.</span>
<span class="comment-copy">@falsetru without brackets it won't work. That's just placeholder to satisfy python :)</span>
<span class="comment-copy">@GaneshSatpute, I meant omitting only <code>str</code>, not parentheses: <code>("Some char "  "Some more chars")</code></span>
<span class="comment-copy">@Jim thanks for your elaborated answer. It took me a while to read and grasp. :)  I'll probably go and check the source code as well. Thanks again for your inputs</span>
