<div class="post-text" itemprop="text">
<p>I was trying to write a Bubble sort from memory on the train to work this morning, but came up this instead. </p>
<p>Is there a name for this type of sort?</p>
<pre><code>def not_bubble_sort(arr):
    length = len(arr)
    while True:
        is_sorted = True
        for i in range(length - 1):
            if arr[i] &gt; arr[i + 1]:
                is_sorted = False
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
        if is_sorted:
            break

    return arr
</code></pre>
<p>I expected this to be hugely inefficient, for some data it is. But for other randomly generated lists it was very fast, can someone explain why that is. Is there a way to utilise it? Or have I made a mistake somewhere.</p>
<p>I ran some benchmarks against an actual bubble sort and found this to be much faster for certain types of randomly generated lists.</p>
<p>The benchmark runs the sort on a generated list of n <code>randint</code> integers.</p>
<pre><code>N = 5000
------
|  min          |  avg          |  max          |  func             |  name             |
|---------------|---------------|---------------|-------------------|-------------------|
|  0.000463724  |  0.034745610  |  3.425408840  |  not_bubble_sort  |  sarcoma          |
|  1.159517288  |  1.212791989  |  1.768434763  |  bubble_sort      |  geeks_for_geeks  |
</code></pre>
<p>Geeks for Geeks Example Bubble Sort:</p>
<pre><code>
def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

    return arr
</code></pre>
<p><a href="https://github.com/sarcoma/algorithms-python/blob/master/algorithms/sort/bubble_sort.py" rel="nofollow noreferrer">https://github.com/sarcoma/algorithms-python/blob/master/algorithms/sort/bubble_sort.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is just a bubble sort, but with early exit.</p>
<p>In "real" bubble sort you go over the array <code>length-1</code> times no matter what the data looks like, but here if in some earlier step the data is sorted, you <code>break</code>.</p>
<p>And the inefficiency comes from your algorithm having complexity of "O(n^2)" instead of "O(1/2*n^2)"* (because of this <code>for i in range(length - 1):</code> instead of this <code>for j in range(0, n - i - 1):</code>)</p>
<p>*not the real big O notation, but it proves the point</p>
</div>
<span class="comment-copy">obviously it's efficient when data is already sorted. But why not use a really performant <code>sort</code> which works for all data?</span>
<span class="comment-copy">I'm wondering if there is a way to partially sort a list then use this? I don't think any of the lists provided will be sorted they are randomly generated. I'm working my way through algorithms I've learnt and benchmarking them as I go. It's just for my own learning. I thought it'd be ridiculously slow, the speed of some of the benchmarks was a surprise to me.   <a href="https://github.com/sarcoma/algorithms-python" rel="nofollow noreferrer">github.com/sarcoma/algorithms-python</a></span>
<span class="comment-copy">Merge Sort and Quick Sort are up next.</span>
<span class="comment-copy">also, if you compare python loops vs python built-in sort the python vs C/native aspect comes to play (not complexity but raw iteration speed)</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre I'm just comparing the stuff I write. I've written a load of stuff in a few different languages I'm trying to collate it all into a pip package and brushing up on it all as I go. I saw somewhere that Python uses Timsort, I plan to give that a try, perhaps I'll compare that against the built in to see what sort of results I can get.</span>
