<div class="post-text" itemprop="text">
<p>I'm trying to do something like this:</p>
<pre><code>I[ x<sub>r1,c1</sub> &gt; x<sub>r2,c2</sub> ]</code></pre>
<p>where r<sub>i</sub>, c<sub>i</sub> ∈ {0,1,2,...,n} are the row and column indices, respectively, and I[·] is an indicator function whose value is 1 if the condition is true and 0 otherwise.</p>
<p>I'm having trouble getting this set up. I can easily iterate through <em>everything</em> by:</p>
<pre><code>for r1 in range(0,n):
    for c1 in range(0,n):
        for r2 in range(0,n):
            for c2 in range(0,n):
                #do something with (r1,c1,r2,c2)
</code></pre>
<p>However I'm trying to vectorize this code to increase efficiency and make the comparisons in one fellow swoop. How can I do this? I'm using <strong>numpy</strong>.</p>
<hr/>
<p><strong><em>explanation update:</em></strong></p>
<p>i am training a simple smile classifier that analyzes a grayscale image <em>x</em> ∈ R<sup>24×24</sup> and  outputs  a  prediction  y ∈ {0,1}, indicating  whether  the  image  is  smiling  (1)  or  not  (0). the classifier will make its decision based on very simple features of the input image consisting of binary comparisons between pixel values.</p>
<p>each feature is computed as: <pre><code>I[ x<sub>r1,c1</sub> &gt; x<sub>r2,c2</sub> ]</code></pre></p>
<p>where r<sub>i</sub>, c<sub>i</sub> ∈ {0,1,2,...,n} are the row and column indices, respectively, and I[·] is an indicator function whose value is 1 if the condition is true and 0 otherwise. (assume n is defined)</p>
<p>based on what i've mentioned so far, i'm trying to train an ensemble smile classification for 5 features. the output of the ensemble is 1 if it thinks the image is smiling, 0 otherwise. this is determined by the average prediction across all 5 members of the ensemble.  if more than half of the 5 ensemble predictors think that the image is smiling, then the ensemble says it’s a smile; otherwise, the ensemble says it’s not smiling.  </p>
<p>this is what i'm trying to do:</p>
<p>at  each  round j,  i want to choose  the jth  feature (r1,c1,r2,c2) such that – when it is added to the set of j−1 features that have already been selected – the accuracy of the overall classifier on the training set is maximized.  more specifically, at every round j ,i'm considering every possible tuple of pixel locations (r1,c1,r2,c2) if thecurrent tuple is the best yet (for round j), then i save it as my “best seen yet” for round j.  if not, i ignore it. i then move on to the next possible tuple of pixel locations, and repeat until i've searched all of them.  At the end of round j, i will have selected the best feature for that round, and i add it to my set of selected features.  once added, it stays in the set forever – it can never be removed.  (otherwise, it wouldn’t be agreedy algorithm at all.)  then i move on to round j+ 1 until you’ve completed all 5 rounds rounds.</p>
<p>i don't need help with this entire thing. i'm just looking for a way to vectorize code without having to use nested for loops</p>
</div>
<div class="post-text" itemprop="text">
<p>Take advantage of <em><a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting</a></em>:</p>
<pre><code>first = np.reshape(array, (*array.shape, 1, 1))
second = np.reshape(array, (1, 1, *array.shape))

result = (first &gt; second)
</code></pre>
<p>This will produce an <code>array</code> of shape <code>(*array.shape, *array.shape)</code>, where <code>result[r1, c1, r2, c2]</code> is the value you want.</p>
<p>Example:</p>
<pre><code>array = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

first = np.reshape(array, (*array.shape, 1, 1))
second = np.reshape(array, (1, 1, *array.shape))

result = (first &gt; second)

print(result[0, 0, 1, 1]) # 1 &gt; 6
print(result[1, 1, 0, 1]) # 6 &gt; 2
print(result[0, 3, 0, 2]) # 3 &gt; 2
</code></pre>
<p>Output:</p>
<pre><code>False
True
True
</code></pre>
</div>
<span class="comment-copy">So you have a square matrix?</span>
<span class="comment-copy">If I understand you correctly, you should have 24 * 24 features...?</span>
<span class="comment-copy">i'm a little confused. how can i use this to compare (r1,c1) and (r2,c2) and do something if the former is greater than the latter?</span>
<span class="comment-copy">That would depend on what you want to do (can the operation be vectorised)? In any case, this code snippet will produce a 4D array <code>result</code>, where each element is the result of one comparison. The result of <code>(x_{r1, c1}) &gt; (x_{r2, c2})</code> will be stored in <code>result[r1, c1, r2, c2]</code>.</span>
<span class="comment-copy">i think this might be a little more complicated than it needs to be. sorry im pretty bad at explaining what im trying to do (i'm being exposed to this kind of stuff for the first time). do you mind if i link to a document with more detailed instructions?</span>
<span class="comment-copy">I don't mind, but I'm not sure if that's against the SO rules (it would be best if you could explain the exact reason you want to do this comparison, though)</span>
<span class="comment-copy">i've added an update to the original post that is hopefully easier to understand</span>
