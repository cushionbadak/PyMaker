<div class="post-text" itemprop="text">
<p>I'm in a bit of a pickle</p>
<p>I have a data frame: </p>
<p>Old_DF</p>
<pre><code>    Date.               Year    On/Off      Gender. Status.    
0   2019-03-14 09:59:30 Senior  Off Campus  Male    Full Time
1   2019-03-13 15:56:13 Senior  Off Campus  Male    Full Time
</code></pre>
<p>The first dataframe has a column that asks people to rank certain things, however due to the infinite wisdom of Jotform's exporting format it takes their personal rankings and puts it into one string per cell so:</p>
<pre><code>0   2019-03-14 09:59:30 Senior  Off Campus  Male    Full Time   1Food\r 2Lounge or Study Space\r 3Retail\r 4Ev...   NaN
1   2019-03-13 15:56:13 Senior  Off Campus  Male    Full Time   1Lounge or Study Space\r 2Food\r 3Academic Res...   NaN
</code></pre>
<p>My idea is essentially splitting the string into key words and assigning them letter value, i.e. "Food" = 'A', 'Lounge or Study Space' = 'B'</p>
<p>From that I would like to Essentially convert the string into any possible combination of "ABCDEFG", and append that as a new column with just the letter combination, and then count the highest occurring combination.</p>
<pre><code>  'Combo'                 
0  'ABCDEFG'    
1  'BDCFGAE'    
</code></pre>
<p>My problems are mathematically, that's a lot of combinations or its only one,</p>
<p>This is what I've written so far</p>
<pre><code>clean_3 = 

rank
0  food lounge or study space retail event space ...
1  lounge or study space food academic resources ...

Combo_list = []
    small_combo_list = []
    for i in clean_3:

        if clean_3[i] == 'food':
            Combo_list.append('A')

        elif clean_3[i] == 'lounge or study space':
            Combo_list.append('B')

        elif clean_3[i] == 'retail':
            Combo_list.append('C')

        elif  clean_3[i] == 'event space':
            Combo_list.append('D')

        elif  clean_3[i] == 'academic resources':
            Combo_list.append('E')

        elif  clean_3[i] == 'student life':
            NCombo_list.append('F')

        elif  clean_3[i] == 'general services':
            Combo_list.append('G')

        small_combo_list.append(Combo_list)

        print(small_combo_list)
</code></pre>
<p>However I'm getting this error:</p>
<pre><code>ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>Which doesn't make sense (to me at least) since its a dataframe not a series.</p>
<p>Ideally if there is a more efficient way of doing this please knock me over the head with it since the size of this csv is undetermined. Let me know if I need to explain anything else!</p>
<p>EDIT: the only two rows of the current dataframe, and a testament to just how unwieldy jotforms export format is</p>
<pre><code>    Date.               Year    On/Off      Gender. Status.     Rank
0   2019-03-14 09:59:30 Senior  Off Campus  Male    Full Time   1Food
                                                                2Lounge or Study Space
                                                                3Retail
                                                                4Event Space
                                                              5Academic Resources (Tutoring, Career Advice)
                                                               6Student Life (Student Involvement, Diversity Services)
                                                               7General Services (Lockers, Information Desk, Vending Machines)


    Date.               Year    On/Off      Gender. Status.     Rank
1   2019-03-14 09:59:30 Senior  Off Campus  Male    Full Time   1Food
                                                                2Lounge or Study Space
                                                                3Retail
                                                                4Event Space
                                                              5Academic Resources (Tutoring, Career Advice)
                                                               6Student Life (Student Involvement, Diversity Services)
                                                               7General Services (Lockers, Information Desk, Vending Machines)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Would be better if I had more example data, hard to test with just two rows, but heres something you can try.</p>
<p>First clean up your data with <code>.str.replace</code> and <code>.str.split</code>.
After that I convert it to <code>object</code> type.</p>
<p>Now we have all the choices cleaned up and in order.</p>
<p>So we can simply <code>groupby</code> and <code>count</code> like following:</p>
<pre><code># Dataframe I worked with
                  Date    Year      On/Off Gender     Status  \
0  2019-03-14 09:59:30  Senior  Off Campus   Male  Full Time   
1  2019-03-13 15:56:13  Senior  Off Campus   Male  Full Time   

                                             Ranking  
0  1Food\r 2Lounge or Study Space\r 3Retail\r 4Ev...  
1  1Lounge or Study Space\r 2Food\r 3Academic Res... 

# Clean up Ranking column
df['Ranking'] = df.Ranking.str.replace('\d+', '').str.split('\r').astype(str)

# Count the amount of choices and convert it to a column
df['times_chosen'] = df.groupby('Ranking').Ranking.transform('size')
</code></pre>
<p><strong>Output</strong></p>
<pre><code>                                             Ranking  times_chosen
0  ['Food', ' Lounge or Study Space', ' Retail', ...             1
1  ['Lounge or Study Space', ' Food', ' Academic ...             1
</code></pre>
<p><strong>2nd option</strong></p>
<p>Dont convert to a column, just groupby</p>
<pre><code>df.groupby('Ranking').Ranking.size()

Ranking
['Food', ' Lounge or Study Space', ' Retail', ' Ev...']    1
['Lounge or Study Space', ' Food', ' Academic Res...']     1
Name: Ranking, dtype: int64
</code></pre>
<p><strong>Or</strong> with <code>.agg</code></p>
<pre><code>print(df.groupby('Ranking').agg({'Ranking': ['count']}))

                                                   Ranking
                                                     count
Ranking                                                   
['Food', ' Lounge or Study Space', ' Retail', '...       1
['Lounge or Study Space', ' Food', ' Academic R...       1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use groupby on your original column (or a cleaned up version) if the formatting is consistent to quickly get the counts:</p>
<pre><code>df=pd.Series(
        {'rank': ['food lounge or study space retail event space ...',
                  'food lounge or study space retail event space ...',
                  'lounge or study space food academic resources ...',
                  'lounge or study space food academic resources ...',
                  'lounge or study space food academic resources ...']}, 
    dtype=str)

df.groupby('rank').size()

&gt; rank
&gt; food lounge or study space retail event space ...    2
&gt; lounge or study space food academic resources ...    3
&gt; dtype: int64
</code></pre>
</div>
<span class="comment-copy">What is your goal here? You want to count to amount of total choices? Or the combination of the choices together?</span>
<span class="comment-copy">please post a downloadable csv file. overall i think you need to split, melt, split and pivot.  i can post some code if you post a file</span>
<span class="comment-copy">I would like to count the highest occurring combinations. So in each row if "ABCDEFG" occurs the most it's the highest occurring combination.</span>
<span class="comment-copy">Dont understand if y ou want To build th√© ABCDEF from string or just groupby combination or both?</span>
<span class="comment-copy">@SebastianGoslin at least post those two values without truncation: '1Food\r 2Lounge or Study Space\r 3Retail\r 4Ev...' and '1Lounge or Study Space\r 2Food\r 3Academic Res...' thanks</span>
<span class="comment-copy">Groupby did the trick, I overcomplicated the hell out of it</span>
<span class="comment-copy">Groupby did it perfectly, I knew I was overcomplicating things</span>
