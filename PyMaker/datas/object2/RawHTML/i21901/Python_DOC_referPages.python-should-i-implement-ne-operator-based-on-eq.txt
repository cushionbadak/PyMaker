<div class="post-text" itemprop="text">
<p>I have a class where I want to override the <code>__eq__()</code> operator. It seems to make sense that I should override the <code>__ne__()</code> operator as well, but does it make sense to implement <code>__ne__</code> based on <code>__eq__</code> as such?</p>
<pre><code>class A:
    def __eq__(self, other):
        return self.value == other.value

    def __ne__(self, other):
        return not self.__eq__(other)
</code></pre>
<p>Or is there something that I'm missing with the way Python uses these operators that makes this not a good idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, that's perfectly fine.  In fact, <a href="http://docs.python.org/reference/datamodel.html#object.__ne__" rel="noreferrer">the documentation</a> urges you to define <code>__ne__</code> when you define <code>__eq__</code>:</p>
<blockquote>
<p>There are no implied relationships
  among the comparison operators. The
  truth of <code>x==y</code> does not imply that <code>x!=y</code>
  is false. Accordingly, when defining
  <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the operators will behave as expected.</p>
</blockquote>
<p>In a lot of cases (such as this one), it will be as simple as negating the result of <code>__eq__</code>, but not always.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python, should I implement <code>__ne__()</code> operator based on <code>__eq__</code>?</p>
</blockquote>
<h2>Short Answer: No. Use <code>==</code> instead of the <code>__eq__</code></h2>
<p>In Python 3, <code>!=</code> is the negation of <code>==</code> by default, so you are not even required to write a <code>__ne__</code>, and the documentation is no longer opinionated on writing one. </p>
<p>Generally speaking, for Python 3-only code, don't write one unless you need to overshadow the parent implementation, e.g. for a builtin object.</p>
<p>That is, keep in mind <a href="https://bugs.python.org/issue4395" rel="nofollow noreferrer">Raymond Hettinger's comment</a>:</p>
<blockquote>
<p>The <code>__ne__</code> method follows automatically from <code>__eq__</code> only if
  <code>__ne__</code> isn't already defined in a superclass.  So, if you're
  inheriting from a builtin, it's best to override both.</p>
</blockquote>
<p>If you need your code to work in Python 2, follow the recommendation for Python 2 and it will work in Python 3 just fine.</p>
<p>In Python 2, Python itself does not automatically implement any operation in terms of another - therefore, you should define the <code>__ne__</code> in terms of <code>==</code> instead of the <code>__eq__</code>.
E.G. </p>
<pre><code>class A(object):
    def __eq__(self, other):
        return self.value == other.value

    def __ne__(self, other):
        return not self == other # NOT `return not self.__eq__(other)`
</code></pre>
<p>See proof that </p>
<ul>
<li>implementing <code>__ne__()</code> operator based on <code>__eq__</code> and </li>
<li>not implementing <code>__ne__</code> in Python 2 at all</li>
</ul>
<p>provides incorrect behavior in the demonstration below.</p>
<h2>Long Answer</h2>
<p>The <a href="https://docs.python.org/2/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer">documentation</a> for Python 2 says:</p>
<blockquote>
<p>There are no implied relationships among the comparison operators. The
  truth of <code>x==y</code> does not imply that <code>x!=y</code> is false. Accordingly, when
  defining <code>__eq__()</code>, one should also define <code>__ne__()</code> so that the
  operators will behave as expected.</p>
</blockquote>
<p>So that means that if we define <code>__ne__</code> in terms of the inverse of <code>__eq__</code>, we can get consistent behavior. </p>
<p>This section of the documentation has been updated for <a href="https://docs.python.org/3/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer">Python 3:</a></p>
<blockquote>
<p>By default, <code>__ne__()</code> delegates to <code>__eq__()</code> and inverts the result
  unless it is <code>NotImplemented</code>.</p>
</blockquote>
<p>and in the <a href="https://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods" rel="nofollow noreferrer">"what's new" section</a>, we see this behavior has changed: </p>
<blockquote>
<ul>
<li><code>!=</code> now returns the opposite of <code>==</code>, unless <code>==</code> returns <code>NotImplemented</code>.</li>
</ul>
</blockquote>
<p><em>For implementing <code>__ne__</code>, we prefer to use the <code>==</code> operator</em> instead of using the <code>__eq__</code> method directly so that if <code>self.__eq__(other)</code> of a subclass returns <code>NotImplemented</code> for the type checked, Python will appropriately check <code>other.__eq__(self)</code> <a href="https://docs.python.org/2/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">From the documentation</a>:</p>
<h3>The <code>NotImplemented</code> object</h3>
<blockquote>
<p>This type has a single value. There is a single object with this value. This object is accessed through the built-in name
  <code>NotImplemented</code>. Numeric methods and rich comparison methods may return
  this value if they do not implement the operation for the operands
  provided. (The interpreter will then try the reflected operation, or
  some other fallback, depending on the operator.) Its truth value is
  true.</p>
</blockquote>
<p>When given a rich comparison operator, if they're not the same type, Python checks if the <code>other</code> is a subtype, and if it has that operator defined, it uses the <code>other</code>'s method first (inverse for <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code> and <code>&gt;</code>). If <code>NotImplemented</code> is returned, <em>then</em> it uses the opposite's method. (It does <em>not</em> check for the same method twice.) Using the <code>==</code> operator allows for this logic to take place.</p>
<hr/>
<h2>Expectations</h2>
<p>Semantically, you should implement <code>__ne__</code> in terms of the check for equality because users of your class will expect the following functions to be equivalent for all instances of A.:</p>
<pre><code>def negation_of_equals(inst1, inst2):
    """always should return same as not_equals(inst1, inst2)"""
    return not inst1 == inst2

def not_equals(inst1, inst2):
    """always should return same as negation_of_equals(inst1, inst2)"""
    return inst1 != inst2
</code></pre>
<p>That is, both of the above functions should <em>always</em> return the same result. But this is dependent on the programmer. </p>
<h2>Demonstration of unexpected behavior when defining <code>__ne__</code> based on <code>__eq__</code>:</h2>
<p>First the setup:</p>
<pre><code>class BaseEquatable(object):
    def __init__(self, x):
        self.x = x
    def __eq__(self, other):
        return isinstance(other, BaseEquatable) and self.x == other.x

class ComparableWrong(BaseEquatable):
    def __ne__(self, other):
        return not self.__eq__(other)

class ComparableRight(BaseEquatable):
    def __ne__(self, other):
        return not self == other

class EqMixin(object):
    def __eq__(self, other):
        """override Base __eq__ &amp; bounce to other for __eq__, e.g. 
        if issubclass(type(self), type(other)): # True in this example
        """
        return NotImplemented

class ChildComparableWrong(EqMixin, ComparableWrong):
    """__ne__ the wrong way (__eq__ directly)"""

class ChildComparableRight(EqMixin, ComparableRight):
    """__ne__ the right way (uses ==)"""

class ChildComparablePy3(EqMixin, BaseEquatable):
    """No __ne__, only right in Python 3."""
</code></pre>
<p>Instantiate non-equivalent instances:</p>
<pre><code>right1, right2 = ComparableRight(1), ChildComparableRight(2)
wrong1, wrong2 = ComparableWrong(1), ChildComparableWrong(2)
right_py3_1, right_py3_2 = BaseEquatable(1), ChildComparablePy3(2)
</code></pre>
<h3>Expected Behavior:</h3>
<p>(Note: while every second assertion of each of the below is equivalent and therefore logically redundant to the one before it, I'm including them to demonstrate that <em>order does not matter when one is a subclass of the other.</em>)</p>
<p>These instances have <code>__ne__</code> implemented with <code>==</code>:</p>
<pre><code>assert not right1 == right2
assert not right2 == right1
assert right1 != right2
assert right2 != right1
</code></pre>
<p>These instances, testing under Python 3, also work correctly:</p>
<pre><code>assert not right_py3_1 == right_py3_2
assert not right_py3_2 == right_py3_1
assert right_py3_1 != right_py3_2
assert right_py3_2 != right_py3_1
</code></pre>
<p>And recall that these have <code>__ne__</code> implemented with <code>__eq__</code> - while this is the expected behavior, the implementation is incorrect:</p>
<pre><code>assert not wrong1 == wrong2         # These are contradicted by the
assert not wrong2 == wrong1         # below unexpected behavior!
</code></pre>
<h3>Unexpected Behavior:</h3>
<p>Note that this comparison contradicts the comparisons above (<code>not wrong1 == wrong2</code>).</p>
<pre><code>&gt;&gt;&gt; assert wrong1 != wrong2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AssertionError
</code></pre>
<p>and,</p>
<pre><code>&gt;&gt;&gt; assert wrong2 != wrong1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AssertionError
</code></pre>
<h3>Don't skip <code>__ne__</code> in Python 2</h3>
<p>For evidence that you should not skip implementing <code>__ne__</code> in Python 2, see these equivalent objects:</p>
<pre><code>&gt;&gt;&gt; right_py3_1, right_py3_1child = BaseEquatable(1), ChildComparablePy3(1)
&gt;&gt;&gt; right_py3_1 != right_py3_1child # as evaluated in Python 2!
True
</code></pre>
<p>The above result should be <code>False</code>!</p>
<h2>Python 3 source</h2>
<p>The default CPython implementation for <code>__ne__</code> is in <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L3765" rel="nofollow noreferrer"><code>typeobject.c</code> in <code>object_richcompare</code></a>:</p>
<pre><code>    case Py_NE:
        /* By default, __ne__() delegates to __eq__() and inverts the result,
           unless the latter returns NotImplemented. */
        if (self-&gt;ob_type-&gt;tp_richcompare == NULL) {
            res = Py_NotImplemented;
            Py_INCREF(res);
            break;
        }
        res = (*self-&gt;ob_type-&gt;tp_richcompare)(self, other, Py_EQ);
        if (res != NULL &amp;&amp; res != Py_NotImplemented) {
            int ok = PyObject_IsTrue(res);
            Py_DECREF(res);
            if (ok &lt; 0)
                res = NULL;
            else {
                if (ok)
                    res = Py_False;
                else
                    res = Py_True;
                Py_INCREF(res);
            }
        }
</code></pre>
<p>Here we see</p>
<h2>But the default <code>__ne__</code> uses <code>__eq__</code>?</h2>
<p>Python 3's default <code>__ne__</code> implementation detail at the C level uses <code>__eq__</code> because the higher level <code>==</code> (<a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompare" rel="nofollow noreferrer">PyObject_RichCompare</a>) would be less efficient - and therefore it must also handle <code>NotImplemented</code>.</p>
<p>If <code>__eq__</code> is correctly implemented, then the negation of <code>==</code> is also correct - and it allows us to avoid low level implementation details in our <code>__ne__</code>.</p>
<p>Using <code>==</code> allows us to keep our low level logic in <em>one</em> place, and <em>avoid</em> addressing <code>NotImplemented</code> in <code>__ne__</code>.</p>
<p>One might incorrectly assume that <code>==</code> may return <code>NotImplemented</code>.</p>
<p>It actually uses the same logic as the default implementation of <code>__eq__</code>, which checks for identity (see <a href="https://github.com/python/cpython/blob/master/Objects/object.c#L642" rel="nofollow noreferrer">do_richcompare</a> and our evidence below)</p>
<pre><code>class Foo:
    def __ne__(self, other):
        return NotImplemented
    __eq__ = __ne__

f = Foo()
f2 = Foo()
</code></pre>
<p>And the comparisons:</p>
<pre><code>&gt;&gt;&gt; f == f
True
&gt;&gt;&gt; f != f
False
&gt;&gt;&gt; f2 == f
False
&gt;&gt;&gt; f2 != f
True
</code></pre>
<h2>Performance</h2>
<p>Don't take my word for it, let's see what's more performant:</p>
<pre><code>class CLevel:
    "Use default logic programmed in C"

class HighLevelPython:
    def __ne__(self, other):
        return not self == other

class LowLevelPython:
    def __ne__(self, other):
        equal = self.__eq__(other)
        if equal is NotImplemented:
            return NotImplemented
        return not equal

def c_level():
    cl = CLevel()
    return lambda: cl != cl

def high_level_python():
    hlp = HighLevelPython()
    return lambda: hlp != hlp

def low_level_python():
    llp = LowLevelPython()
    return lambda: llp != llp
</code></pre>
<p>I think these performance numbers speak for themselves:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; min(timeit.repeat(c_level()))
0.09377292497083545
&gt;&gt;&gt; min(timeit.repeat(high_level_python()))
0.2654011140111834
&gt;&gt;&gt; min(timeit.repeat(low_level_python()))
0.3378178110579029
</code></pre>
<p>This makes sense when you consider that <code>low_level_python</code> is doing logic in Python that would otherwise be handled on the C level.</p>
<h2>Response to some critics</h2>
<p>Another answerer writes:</p>
<blockquote>
<p>Aaron Hall’s implementation <code>not self == other</code> of the <code>__ne__</code> method is incorrect as it can never return <code>NotImplemented</code> (<code>not NotImplemented</code> is <code>False</code>) and therefore the <code>__ne__</code> method that has priority can never fall back on the <code>__ne__</code> method that does not have priority.</p>
</blockquote>
<p>Having <code>__ne__</code> never return <code>NotImplemented</code> does not make it incorrect. Instead, we handle prioritization with <code>NotImplemented</code> via the check for equality with <code>==</code>. Assuming <code>==</code> is correctly implemented, we're done.</p>
<blockquote>
<p><code>not self == other</code> used to be the default Python 3 implementation of the <code>__ne__</code> method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see issue #21408).</p>
</blockquote>
<p>Well, let's explain this. </p>
<p>As noted earlier, Python 3 by default handles <code>__ne__</code> by first checking if <code>self.__eq__(other)</code> returns <code>NotImplemented</code> (a singleton) - which should be checked for with <code>is</code> and returned if so, else it should return the inverse. Here is that logic written as a class mixin:</p>
<pre><code>class CStyle__ne__:
    """Mixin that provides __ne__ functionality equivalent to 
    the builtin functionality
    """
    def __ne__(self, other):
        equal = self.__eq__(other)
        if equal is NotImplemented:
            return NotImplemented
        return not equal
</code></pre>
<p>This is necessary for correctness for C level Python API, and it was introduced in Python 3, making </p>
<ul>
<li><a href="https://bugs.python.org/file37837/method-not-operator-2.patch" rel="nofollow noreferrer">the <code>__ne__</code> methods in this patch</a> to close <a href="https://bugs.python.org/issue21408" rel="nofollow noreferrer">Issue 21408</a> and</li>
<li><a href="https://hg.python.org/cpython/rev/3603bae63c13" rel="nofollow noreferrer">the <code>__ne__</code> methods in the follow-on cleanup removed here</a></li>
</ul>
<p>redundant. All relevant <code>__ne__</code> methods were removed, including ones implementing their own check as well as ones that delegate to <code>__eq__</code> directly or via <code>==</code> - and <code>==</code> was the most common way of doing so.</p>
<h2>Conclusion</h2>
<p>For Python 2 compatible code, use <code>==</code> to implement <code>__ne__</code>. It is more:</p>
<ul>
<li>correct</li>
<li>simple</li>
<li>performant</li>
</ul>
<p>In Python 3 only, use the low-level negation on the C level - it is even <em>more</em> simple and performant (though the programmer is responsible for determining that it is <em>correct</em>).</p>
<p>Again, do <em>not</em> write low-level logic in high level Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for the record, a canonically correct and cross Py2/Py3 portable <code>__ne__</code> would look like:</p>
<pre><code>import sys

class ...:
    ...
    def __eq__(self, other):
        ...

    if sys.version_info[0] == 2:
        def __ne__(self, other):
            equal = self.__eq__(other)
            return equal if equal is NotImplemented else not equal
</code></pre>
<p>This works with any <code>__eq__</code> you might define:</p>
<ul>
<li>Unlike <code>not (self == other)</code>, doesn't interfere with in some annoying/complex cases involving comparisons where one of the classes involved doesn't imply that the result of <code>__ne__</code> is the same as the result of <code>not</code> on <code>__eq__</code> (e.g. SQLAlchemy's ORM, where both <code>__eq__</code> and <code>__ne__</code> return special proxy objects, not <code>True</code> or <code>False</code>, and trying to <code>not</code> the result of <code>__eq__</code> would return <code>False</code>, rather than the correct proxy object). </li>
<li>Unlike <code>not self.__eq__(other)</code>, this correctly delegates to the <code>__ne__</code> of the other instance when <code>self.__eq__</code> returns <code>NotImplemented</code> (<code>not self.__eq__(other)</code> would be extra wrong, because <code>NotImplemented</code> is truthy, so when <code>__eq__</code> didn't know how to perform the comparison, <code>__ne__</code> would return <code>False</code>, implying that the two objects were equal when in fact the only object asked had no idea, which would imply a default of not equal)</li>
</ul>
<p>If your <code>__eq__</code> doesn't use <code>NotImplemented</code> returns, this works (with meaningless overhead), if it does use <code>NotImplemented</code> sometimes, this handles it properly. And the Python version check means that if the class is <code>import</code>-ed in Python 3, <code>__ne__</code> is left undefined, allowing Python's native, efficient fallback <a href="https://hg.python.org/cpython/file/3.5/Objects/typeobject.c#l3508" rel="nofollow noreferrer"><code>__ne__</code> implementation (a C version of the above)</a> to take over.</p>
<hr/>
<h1>Why this is needed</h1>
<h2>Python overloading rules</h2>
<p>The explanation of why you do this instead of other solutions is somewhat arcane. Python has a couple general rules about overloading operators, and comparison operators in particular:</p>
<ol>
<li>(Applies to all operators) When running <code>LHS OP RHS</code>, try <code>LHS.__op__(RHS)</code>, and if that returns <code>NotImplemented</code>, try <code>RHS.__rop__(LHS)</code>. Exception: If <code>RHS</code> is a subclass of <code>LHS</code>'s class, then test <code>RHS.__rop__(LHS)</code> <em>first</em>. In the case of comparison operators, <code>__eq__</code> and <code>__ne__</code> are their own "rop"s (so the test order for <code>__ne__</code> is <code>LHS.__ne__(RHS)</code>, then <code>RHS.__ne__(LHS)</code>, reversed if <code>RHS</code> is a subclass of <code>LHS</code>'s class)</li>
<li>Aside from the idea of the "swapped" operator, there is no implied relationship between the operators. Even for instance of the same class, <code>LHS.__eq__(RHS)</code> returning <code>True</code> does not imply <code>LHS.__ne__(RHS)</code> returns <code>False</code> (in fact, the operators aren't even required to return boolean values; ORMs like SQLAlchemy intentionally do not, allowing for a more expressive query syntax). As of Python 3, the default <code>__ne__</code> implementation behaves this way, but it's not contractual; you can override <code>__ne__</code> in ways that aren't strict opposites of <code>__eq__</code>.</li>
</ol>
<h2>How this applies to overloading comparators</h2>
<p>So when you overload an operator, you have two jobs:</p>
<ol>
<li>If you know how to implement the operation yourself, do so, using <em>only</em> your own knowledge of how to do the comparison (never delegate, implicitly or explicitly, to the other side of the operation; doing so risks incorrectness and/or infinite recursion, depending on how you do it)</li>
<li>If you <em>don't</em> know how to implement the operation yourself, <em>always</em> return <code>NotImplemented</code>, so Python can delegate to the other operand's implementation</li>
</ol>
<h2>The problem with <code>not self.__eq__(other)</code></h2>
<pre><code>def __ne__(self, other):
    return not self.__eq__(other)
</code></pre>
<p>never delegates to the other side (and is incorrect if <code>__eq__</code> properly returns <code>NotImplemented</code>). When <code>self.__eq__(other)</code> returns <code>NotImplemented</code> (which is "truthy"), you silently return <code>False</code>, so <code>A() != something_A_knows_nothing_about</code> returns <code>False</code>, when it should have checked if <code>something_A_knows_nothing_about</code> knew how to compare to instances of <code>A</code>, and if it doesn't, it should have returned <code>True</code> (since if neither side knows how to compare to the other, they're considered not equal to one another). If <code>A.__eq__</code> is incorrectly implemented (returning <code>False</code> instead of <code>NotImplemented</code> when it doesn't recognize the other side), then this is "correct" from <code>A</code>'s perspective, returning <code>True</code> (since <code>A</code> doesn't think it's equal, so it's not equal), but it might be wrong from <code>something_A_knows_nothing_about</code>'s perspective, since it never even asked <code>something_A_knows_nothing_about</code>; <code>A() != something_A_knows_nothing_about</code> ends up <code>True</code>, but <code>something_A_knows_nothing_about != A()</code> could <code>False</code>, or any other return value.</p>
<h2>The problem with <code>not self == other</code></h2>
<pre><code>def __ne__(self, other):
    return not self == other
</code></pre>
<p>is more subtle. It's going to be correct for 99% of classes, including all classes for which <code>__ne__</code> is the logical inverse of <code>__eq__</code>. But <code>not self == other</code> breaks both of the rules mentioned above, which means for classes where <code>__ne__</code> <em>isn't</em> the logical inverse of <code>__eq__</code>, the results are once again non-reflexive, because one of the operands is never asked if it can implement <code>__ne__</code> at all, even if the other operand can't. The simplest example is a weirdo class which returns <code>False</code> for <em>all</em> comparisons, so <code>A() == Incomparable()</code> and <code>A() != Incomparable()</code> both return <code>False</code>. With a correct implementation of <code>A.__ne__</code> (one which returns <code>NotImplemented</code> when it doesn't know how to do the comparison), the relationship is reflexive; <code>A() != Incomparable()</code> and <code>Incomparable() != A()</code> agree on the outcome (because in the former case, <code>A.__ne__</code> returns <code>NotImplemented</code>, then <code>Incomparable.__ne__</code> returns <code>False</code>, while in the latter, <code>Incomparable.__ne__</code> returns <code>False</code> directly). But when <code>A.__ne__</code> is implemented as <code>return not self == other</code>, <code>A() != Incomparable()</code> returns <code>True</code> (because <code>A.__eq__</code> returns, not <code>NotImplemented</code>, then <code>Incomparable.__eq__</code> returns <code>False</code>, and <code>A.__ne__</code> inverts that to <code>True</code>), while <code>Incomparable() != A()</code> returns <code>False.</code></p>
<p>You can see an example of this in action <a href="https://tio.run/##tVI7a8MwEN79Ky5kqAOmQ8dABruk4KVTd6PY50RwkRzpQsivd09@gO02ECjVIom773Gf1Nz5ZM1b25akvId0G4GsNewvV0XAFhQRWD6hA208K1OiB1tD2vVVWENR4KUoYo9UJ33npicJS9dgLIP2IzjuOhJIJ01hOeSrM/BpOT83hGc0jFW0qH65K050DT7UXUNuSusclkx3aSc8KhbnMpBmGeBmBt9QWyJ7wwq06OpSh/7DHYRvQtYH4HWFL34Eymh8Ugy10uSXTsPQwRnsdj04ivqAs2cDzv4YcPbfAb//Eq81cv2RcTLQa3N8pL8OqJEnnEVumXpw8zh12HWBvw5p9X6X84U@Yeg2v/ACSB67MKU8Plf4RedGOXUg3D73IoPUhxK657KcIaJcJpnKxpuocdpwnMab8J3yBPKwy3VaWQ2V1aySzTHZvDLBhErbfgM" rel="nofollow noreferrer">here</a>.</p>
<p>Obviously, a class that always returns <code>False</code> for both <code>__eq__</code> and <code>__ne__</code> is a little strange. But as mentioned before, <code>__eq__</code> and <code>__ne__</code> don't even need to return <code>True</code>/<code>False</code>; the SQLAlchemy ORM has classes with comparators that returns a special proxy object for query building, not <code>True</code>/<code>False</code> at all (they're "truthy" if evaluated in a boolean context, but they're never supposed to be evaluated in such a context).</p>
<p>By failing to overload <code>__ne__</code> properly, you <em>will</em> break classes of that sort, as the code:</p>
<pre><code> results = session.query(MyTable).filter(MyTable.fieldname != MyClassWithBadNE())
</code></pre>
<p>will work (assuming SQLAlchemy knows how to insert <code>MyClassWithBadNE</code> into a SQL string at all; this can be done with type adapters without <code>MyClassWithBadNE</code> having to cooperate at all), passing the expected proxy object to <code>filter</code>, while:</p>
<pre><code> results = session.query(MyTable).filter(MyClassWithBadNE() != MyTable.fieldname)
</code></pre>
<p>will end up passing <code>filter</code> a plain <code>False</code>, because <code>self == other</code> returns a proxy object, and <code>not self == other</code> just converts the truthy proxy object to <code>False</code>. Hopefully, <code>filter</code> throws an exception on being handled invalid arguments like <code>False</code>. While I'm sure many will argue that <code>MyTable.fieldname</code> <em>should</em> be consistently on the left hand side of the comparison, the fact remains that there is no programmatic reason to enforce this in the general case, and a correct generic <code>__ne__</code> will work either way, while <code>return not self == other</code> only works in one arrangement.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Short answer: yes (but read the documentation to do it right)</h1>
<p>ShadowRanger's implementation of the <code>__ne__</code> method is the correct one (in the sense that it behaves exactly like the default Python 3 implementation):</p>
<pre><code>def __ne__(self, other):
    result = self.__eq__(other)

    if result is not NotImplemented:
        return not result

    return NotImplemented
</code></pre>
<p>Aaron Hall’s implementation <code>not self == other</code> of the <code>__ne__</code> method is incorrect as it can never return <code>NotImplemented</code> (<code>not NotImplemented</code> is <code>False</code>) and therefore the <code>__ne__</code> method that has priority can never fall back on the <code>__ne__</code> method that does not have priority. <code>not self == other</code> used to be the default Python 3 implementation of the <code>__ne__</code> method but it was a bug and it was corrected in Python 3.4 on January 2015, as ShadowRanger noticed (see <a href="https://bugs.python.org/issue21408" rel="nofollow noreferrer">issue #21408</a>).</p>
<h1>Implementation of the comparison operators</h1>
<p>The <em>Python Language Reference</em> for Python 3 states in its <a href="https://docs.python.org/3.6/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">chapter III Data model</a>:</p>
<blockquote>
<p><code>object.__lt__(self, other)</code><br/>
<code>object.__le__(self, other)</code><br/>
<code>object.__eq__(self, other)</code><br/>
<code>object.__ne__(self, other)</code><br/>
<code>object.__gt__(self, other)</code><br/>
<code>object.__ge__(self, other)</code></p>
<p>These are the so-called “rich comparison” methods. The correspondence
  between operator symbols and method names is as follows: <code>x&lt;y</code> calls
  <code>x.__lt__(y)</code>, <code>x&lt;=y</code> calls <code>x.__le__(y)</code>, <code>x==y</code> calls <code>x.__eq__(y)</code>,
  <code>x!=y</code> calls <code>x.__ne__(y)</code>, <code>x&gt;y</code> calls <code>x.__gt__(y)</code>, and <code>x&gt;=y</code>
  calls <code>x.__ge__(y)</code>.</p>
<p>A rich comparison method may return the singleton <code>NotImplemented</code> if
  it does not implement the operation for a given pair of arguments.</p>
<p>There are no swapped-argument versions of these methods (to be used
  when the left argument does not support the operation but the right
  argument does); rather, <code>__lt__()</code> and <code>__gt__()</code> are each other’s
  reflection, <code>__le__()</code> and <code>__ge__()</code> are each other’s reflection, and
  <code>__eq__()</code> and <code>__ne__()</code> are their own reflection. If the operands
  are of different types, and right operand’s type is a direct or
  indirect subclass of the left operand’s type, the reflected method of
  the right operand has priority, otherwise the left operand’s method
  has priority. Virtual subclassing is not considered.</p>
</blockquote>
<p>Translating this into Python code gives (using <code>operator_eq</code> for <code>==</code>, <code>operator_ne</code> for <code>!=</code>, <code>operator_lt</code> for <code>&lt;</code>, <code>operator_gt</code> for <code>&gt;</code>, <code>operator_le</code> for <code>&lt;=</code> and <code>operator_ge</code> for <code>&gt;=</code>):</p>
<pre><code>def operator_eq(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__eq__(left)

        if result is NotImplemented:
            result = left.__eq__(right)
    else:
        result = left.__eq__(right)

        if result is NotImplemented:
            result = right.__eq__(left)

    if result is NotImplemented:
        result = left is right

    return result


def operator_ne(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__ne__(left)

        if result is NotImplemented:
            result = left.__ne__(right)
    else:
        result = left.__ne__(right)

        if result is NotImplemented:
            result = right.__ne__(left)

    if result is NotImplemented:
        result = left is not right

    return result


def operator_lt(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__gt__(left)

        if result is NotImplemented:
            result = left.__lt__(right)
    else:
        result = left.__lt__(right)

        if result is NotImplemented:
            result = right.__gt__(left)

    if result is NotImplemented:
        raise TypeError(f"'&lt;' not supported between instances of '{type(left).__name__}' and '{type(right).__name__}'")

    return result


def operator_gt(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__lt__(left)

        if result is NotImplemented:
            result = left.__gt__(right)
    else:
        result = left.__gt__(right)

        if result is NotImplemented:
            result = right.__lt__(left)

    if result is NotImplemented:
        raise TypeError(f"'&gt;' not supported between instances of '{type(left).__name__}' and '{type(right).__name__}'")

    return result


def operator_le(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__ge__(left)

        if result is NotImplemented:
            result = left.__le__(right)
    else:
        result = left.__le__(right)

        if result is NotImplemented:
            result = right.__ge__(left)

    if result is NotImplemented:
        raise TypeError(f"'&lt;=' not supported between instances of '{type(left).__name__}' and '{type(right).__name__}'")

    return result


def operator_ge(left, right):
    if type(left) != type(right) and isinstance(right, type(left)):
        result = right.__le__(left)

        if result is NotImplemented:
            result = left.__ge__(right)
    else:
        result = left.__ge__(right)

        if result is NotImplemented:
            result = right.__le__(left)

    if result is NotImplemented:
        raise TypeError(f"'&gt;=' not supported between instances of '{type(left).__name__}' and '{type(right).__name__}'")

    return result
</code></pre>
<h1>Default implementation of the comparison methods</h1>
<p>The documentation adds:</p>
<blockquote>
<p>By default, <code>__ne__()</code> delegates to <code>__eq__()</code> and inverts the result
  unless it is <code>NotImplemented</code>. There are no other implied
  relationships among the comparison operators, for example, the truth
  of <code>(x&lt;y or x==y)</code> does not imply <code>x&lt;=y</code>.</p>
</blockquote>
<p>The default implementation of the comparison methods (<code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__gt__</code>, <code>__le__</code> and <code>__ge__</code>) can thus be given by:</p>
<pre><code>def __eq__(self, other):
    return NotImplemented

def __ne__(self, other):
    result = self.__eq__(other)

    if result is not NotImplemented:
        return not result

    return NotImplemented

def __lt__(self, other):
    return NotImplemented

def __gt__(self, other):
    return NotImplemented

def __le__(self, other):
    return NotImplemented

def __ge__(self, other):
    return NotImplemented
</code></pre>
<p>So this is the correct implementation of the <code>__ne__</code> method. And it does not always return the inverse of the <code>__eq__</code> method because when the <code>__eq__</code> method returns <code>NotImplemented</code>, its inverse <code>not NotImplemented</code> is <code>False</code> (as <code>bool(NotImplemented)</code> is <code>True</code>) instead of the desired <code>NotImplemented</code>.</p>
<h1>Incorrect implementations of <code>__ne__</code></h1>
<p>As Aaron Hall demonstrated above, <code>not self.__eq__(other)</code> is not the default implementation of the <code>__ne__</code> method. <em>But nor is <code>not self == other</code>.</em> The latter is demonstrated below by comparing the behavior of the default implementation with the behavior of the <code>not self == other</code> implementation in two cases:</p>
<ul>
<li>the <code>__eq__</code> method returns <code>NotImplemented</code>;</li>
<li>the <code>__eq__</code> method returns a value different from <code>NotImplemented</code>.</li>
</ul>
<h2>Default implementation</h2>
<p>Let’s see what happens when the <code>A.__ne__</code> method uses the default implementation and the <code>A.__eq__</code> method returns <code>NotImplemented</code>:</p>
<pre><code>class A:
    pass


class B:

    def __ne__(self, other):
        return "B.__ne__"


assert (A() != B()) == "B.__ne__"
</code></pre>
<ol>
<li><code>!=</code> calls <code>A.__ne__</code>.</li>
<li><code>A.__ne__</code> calls <code>A.__eq__</code>.</li>
<li><code>A.__eq__</code> returns <code>NotImplemented</code>.</li>
<li><code>!=</code> calls <code>B.__ne__</code>.</li>
<li><code>B.__ne__</code> returns <code>"B.__ne__"</code>.</li>
</ol>
<p>This shows that when the <code>A.__eq__</code> method returns <code>NotImplemented</code>, the <code>A.__ne__</code> method falls back on the <code>B.__ne__</code> method.</p>
<p>Now let’s see what happens when the <code>A.__ne__</code> method uses the default implementation and the <code>A.__eq__</code> method returns a value different from <code>NotImplemented</code>:</p>
<pre><code>class A:

    def __eq__(self, other):
        return True


class B:

    def __ne__(self, other):
        return "B.__ne__"


assert (A() != B()) is False
</code></pre>
<ol>
<li><code>!=</code> calls <code>A.__ne__</code>.</li>
<li><code>A.__ne__</code> calls <code>A.__eq__</code>.</li>
<li><code>A.__eq__</code> returns <code>True</code>.</li>
<li><code>!=</code> returns <code>not True</code>, that is <code>False</code>.</li>
</ol>
<p>This shows that in this case, the <code>A.__ne__</code> method returns the inverse of the <code>A.__eq__</code> method. Thus the <code>__ne__</code> method behaves like advertised in the documentation.</p>
<p>Overriding the default implementation of the <code>A.__ne__</code> method with the correct implementation given above yields the same results.</p>
<h2><code>not self == other</code> implementation</h2>
<p>Let’s see what happens when overriding the default implementation of the <code>A.__ne__</code> method with the <code>not self == other</code> implementation and the <code>A.__eq__</code> method returns <code>NotImplemented</code>:</p>
<pre><code>class A:

    def __ne__(self, other):
        return not self == other


class B:

    def __ne__(self, other):
        return "B.__ne__"


assert (A() != B()) is True
</code></pre>
<ol>
<li><code>!=</code> calls <code>A.__ne__</code>.</li>
<li><code>A.__ne__</code> calls <code>==</code>.</li>
<li><code>==</code> calls <code>A.__eq__</code>.</li>
<li><code>A.__eq__</code> returns <code>NotImplemented</code>.</li>
<li><code>==</code> calls <code>B.__eq__</code>.</li>
<li><code>B.__eq__</code> returns <code>NotImplemented</code>.</li>
<li><code>==</code> returns <code>A() is B()</code>, that is <code>False</code>.</li>
<li><code>A.__ne__</code> returns <code>not False</code>, that is <code>True</code>.</li>
</ol>
<p>The default implementation of the <code>__ne__</code> method returned <code>"B.__ne__"</code>, not <code>True</code>.</p>
<p>Now let’s see what happens when overriding the default implementation of the <code>A.__ne__</code> method with the <code>not self == other</code> implementation and the <code>A.__eq__</code> method returns a value different from <code>NotImplemented</code>:</p>
<pre><code>class A:

    def __eq__(self, other):
        return True

    def __ne__(self, other):
        return not self == other


class B:

    def __ne__(self, other):
        return "B.__ne__"


assert (A() != B()) is False
</code></pre>
<ol>
<li><code>!=</code> calls <code>A.__ne__</code>.</li>
<li><code>A.__ne__</code> calls <code>==</code>.</li>
<li><code>==</code> calls <code>A.__eq__</code>.</li>
<li><code>A.__eq__</code> returns <code>True</code>.</li>
<li><code>A.__ne__</code> returns <code>not True</code>, that is <code>False</code>.</li>
</ol>
<p>The default implementation of the <code>__ne__</code> method also returned <code>False</code> in this case.</p>
<p><em>Since this implementation fails to replicate the behavior of the default implementation of the <code>__ne__</code> method when the <code>__eq__</code> method returns <code>NotImplemented</code>, it is incorrect.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>If all of <code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__ge__</code>, <code>__le__</code>, and <code>__gt__</code> make sense for the class, then just implement <code>__cmp__</code> instead. Otherwise, do as you're doing, because of the bit Daniel DiPaolo said (while I was testing it instead of looking it up ;) )</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/a/30676267/916568">this</a> is the right answer (down here, by @aaron-hall). The documentation you quoted does <i>not</i> encourage you to implement <code>__ne__</code> using <code>__eq__</code>, only that you implement it.</span>
<span class="comment-copy">@guyarad: Actually, Aaron's answer is still slightly wrong thanks to not properly delegating; instead of treating a <code>NotImplemented</code> return from one side as a cue to delegate to <code>__ne__</code> on the other side, <code>not self == other</code> is (assuming the operand's <code>__eq__</code> doesn't know how to compare the other operand) implicitly delegating to <code>__eq__</code> from the other side, then inverting it. For weird types, e.g. the SQLAlchemy ORM's fields, this <a href="https://stackoverflow.com/a/35781654/364696">causes problems</a>.</span>
<span class="comment-copy">Excellent examples!  Part of the surprise is that the order of the operands <i>doesn't matter at all</i>, unlike some magic methods with their "right-side" reflections.  To re-iterate the part that I missed (and which cost me a lot of time):  The rich comparison method of the <i>subclass</i> is tried first, regardless of whether the code has the superclass or the subclass on the left of the operator.  This is why your <code>a1 != c2</code> returned <code>False</code> --- it didn't run <code>a1.__ne__</code>, but <code>c2.__ne__</code>, which negated the <i>mixin's</i> <code>__eq__</code> method.  Since <code>NotImplemented</code> is truthy, <code>not NotImplemented</code> is <code>False</code>.</span>
<span class="comment-copy">Your recent updates do successfully demonstrate the performance advantage of <code>not (self == other)</code>, but no one is arguing it isn't fast (well, faster than any other option on Py2 anyway). The problem is it's <i>wrong</i> in some cases; Python itself used to do <code>not (self == other)</code>, but changed because <a href="https://bugs.python.org/issue21408" rel="nofollow noreferrer">it was incorrect in the presence of arbitrary subclasses</a>. Fastest to the wrong answer is still <i>wrong</i>.</span>
<span class="comment-copy">The specific example is kind of unimportant really. The problem is that, in your implementation, the behavior of your <code>__ne__</code> delegates to <code>__eq__</code> (of both sides if necessary), but it <i>never</i> falls back to the <code>__ne__</code> of the other side even when both <code>__eq__</code> "give up". The correct <code>__ne__</code> delegates to its <i>own</i> <code>__eq__</code>, but if that returns <code>NotImplemented</code>, it falls back to go to the other side's <code>__ne__</code>, rather than inverting the other side's <code>__eq__</code> (since the other side may not have explicitly opt-ed in to delegating to <code>__eq__</code>, and you shouldn't be making that decision for it).</span>
<span class="comment-copy">@AaronHall: On reexamining this today, I don't <i>think</i> your implementation is problematic for subclasses normally (it would be extremely convoluted to make it break, and the subclass, assumed to have full knowledge of the parent, should be able to avoid it). But I just gave a non-convoluted example in my answer. The non-pathological case is SQLAlchemy's ORM, where neither <code>__eq__</code> nor <code>__ne__</code> returns either <code>True</code> or <code>False</code>, but rather a proxy object (that happens to be "truthy"). Incorrectly implementing <code>__ne__</code> means order matters for the comparison (you only get a proxy in one ordering).</span>
<span class="comment-copy">To be clear, in 99% (or maybe 99.999%) of cases, your solution is fine, and (obviously) faster. But since you don't have control over the cases where it <i>isn't</i> fine, as a library writer whose code may be used by others (read: anything but simple one-off scripts and modules solely for personal use), you have to use the correct implementation to adhere to the general contract for operator overloading and work with whatever other code you might encounter. Luckily, on Py3, none of this matters, since you can omit <code>__ne__</code> entirely. A year from now, Py2 will be dead and we ignore this. :-)</span>
<span class="comment-copy">The <code>__cmp__()</code> special method is no longer supported in Python 3.x so you ought to get used to using the rich comparison operators.</span>
<span class="comment-copy">D: Seems like everything they've taken out is something I liked...</span>
<span class="comment-copy">Or alternatively if you're in Python 2.7 or 3.x, the functools.total_ordering decorator is quite handy as well.</span>
<span class="comment-copy">Thanks for the heads-up. I've come to realize many things along those lines in the last year and a half, though. ;)</span>
