<div class="post-text" itemprop="text">
<p>Which is more pythonic?</p>
<p><strong>While loop:</strong></p>
<pre><code>count = 0
while count &lt; 50:
    print "Some thing"
    count = count + 1
</code></pre>
<p><strong>For loop:</strong></p>
<pre><code>for i in range(50):
    print "Some thing"
</code></pre>
<p>Edit: not duplicate because this has answers to determine which is clearer, vs. how to run a range without 'i' -- even though that ended up being the most elegant</p>
</div>
<div class="post-text" itemprop="text">
<p>Personally:</p>
<pre><code>for _ in range(50):
    print "Some thing"
</code></pre>
<p>if you don't need <code>i</code>. If you use Python &lt; 3 and you want to repeat the loop a lot of times, use <code>xrange</code> as there is no need to generate the whole list beforehand.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are after the side effects that happen within the loop, I'd personally go for the <code>range()</code> approach.</p>
<p>If you care about the result of whatever functions you call within the loop, I'd go for a list comprehension or <code>map</code> approach. Something like this:</p>
<pre><code>def f(n):
    return n * n

results = [f(i) for i in range(50)]
# or using map:
results = map(f, range(50))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The for loop is definitely more pythonic, as it uses Python's higher level built in functionality to convey what you're doing both more clearly and concisely. The overhead of range vs xrange, and assigning an unused <code>i</code> variable, stem from the absence of a statement like Verilog's <code>repeat</code> statement. The main reason to stick to the for range solution is that other ways are more complex. For instance:</p>
<pre><code>from itertools import repeat

for unused in repeat(None, 10):
    del unused   # redundant and inefficient, the name is clear enough
    print "This is run 10 times"
</code></pre>
<p>Using repeat instead of range here is less clear because it's not as well known a function, and more complex because you need to import it. The main style guides if you need a reference are <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">PEP 20 - The Zen of Python</a> and <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP 8 - Style Guide for Python Code</a>. </p>
<p>We also note that the for range version is an explicit example used in both the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow">language reference</a> and <a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements" rel="nofollow">tutorial</a>, although in that case the value is used. It does mean the form is bound to be more familiar than the while expansion of a C-style for loop. </p>
</div>
<div class="post-text" itemprop="text">
<p>How about?</p>
<pre><code>while BoolIter(N, default=True, falseIndex=N-1):
    print 'some thing'
</code></pre>
<p>or in a more ugly way:</p>
<pre><code>for _ in BoolIter(N):
    print 'doing somthing'
</code></pre>
<p>or if you want to catch the last time through:</p>
<pre><code>for lastIteration in BoolIter(N, default=False, trueIndex=N-1):
    if not lastIteration:
        print 'still going'
    else:
        print 'last time'
</code></pre>
<p>where:</p>
<pre><code>class BoolIter(object):

    def __init__(self, n, default=False, falseIndex=None, trueIndex=None, falseIndexes=[], trueIndexes=[], emitObject=False):
        self.n = n
        self.i = None
        self._default = default
        self._falseIndexes=set(falseIndexes)
        self._trueIndexes=set(trueIndexes)
        if falseIndex is not None:
            self._falseIndexes.add(falseIndex)
        if trueIndex is not None:
            self._trueIndexes.add(trueIndex)
        self._emitObject = emitObject


    def __iter__(self):
        return self

    def next(self):
        if self.i is None:
            self.i = 0
        else:
            self.i += 1
        if self.i == self.n:
            raise StopIteration
        if self._emitObject:
            return self
        else:
            return self.__nonzero__()

    def __nonzero__(self):
        i = self.i
        if i in self._trueIndexes:
            return True
        if i in self._falseIndexes:
            return False
        return self._default

    def __bool__(self):
        return self.__nonzero__()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is not a really pythonic way of repeating something. 
However, it is a better way:</p>
<pre><code>map(lambda index:do_something(), xrange(10))
</code></pre>
<p>If you need to pass the index then:</p>
<pre><code>map(lambda index:do_something(index), xrange(10))
</code></pre>
<p>Consider that it returns the results as a collection.
So, if you need to collect the results it can help.</p>
</div>
<span class="comment-copy">Upvoting in order to compensate the down votes: if Lionel asks this question, others might have the same question, and the answers below will be useful.</span>
<span class="comment-copy">Term "Pythonic" is being overused. It's a synonim for "readable" and "easily understandable". In Python, at least.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/818828/is-it-possible-to-implement-a-python-for-range-loop-without-an-iterator-variable">Is it possible to implement a Python for range loop without an iterator variable?</a></span>
<span class="comment-copy">Watch out for _ being mapped to the gettext translation function though.</span>
<span class="comment-copy">+1 for the <code>_</code> variable.  This is what I would have suggested.</span>
<span class="comment-copy">_ is just like any other variable. It's only in the REPL that it has any particular significance. The OP may as well stick with <code>i</code>.</span>
<span class="comment-copy">@vezult I like this as it makes it clear that the variable is not being used in the statement. Is there perhaps a reason that overshadows this to stick with the <code>i</code>?</span>
<span class="comment-copy">I'm a firm believer in adding ponies, espepcially when it sounds appropriate... for pony in range(50): print("neigh") #python 3</span>
<span class="comment-copy">results = (f for i in range(50))</span>
<span class="comment-copy">results = itertools.imap(f, range(50))</span>
<span class="comment-copy">@ralu, only if you don't need repeated or random access into the results though.</span>
<span class="comment-copy">result = tuple(results) and is way faster than list, since slicing on tuple is O(1)</span>
<span class="comment-copy">Would it not be better to use the repeated thing directly, ie: <code>for s in repeat('This is run 10 times', 10): print s</code> ??</span>
<span class="comment-copy">Certainly! But the print in the sample code was only an example of a repeated section of code, for which there may not be a central object.</span>
<span class="comment-copy">Not only is this not really better (function call overhead, lesser known lambda expressions, collecting unused results in a list), 10 is not an iterable.</span>
<span class="comment-copy">Yes, xrange(10) not 10. I said it is better because you do not need to write a function or make a loop. However, as I said there is not a real pythonic way. I changed the code, Thanks.</span>
