<div class="post-text" itemprop="text">
<p>I have got an email multipart message object, and I want to convert the attachment in that email message into python file object. Is this possible? If it is possible, what method or class in Python I should look into to do such task?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't really understand what you mean by "email multipart message object". Do you mean an object belonging to the <a href="http://docs.python.org/library/email.message.html#email.message.Message" rel="noreferrer"><code>email.message.Message</code></a> class?</p>
<p>If that is what you mean, it's straightforward. On a multipart message, the <code>get_payload</code> method returns a list of message parts (each of which is itself a <code>Message</code> object). You can iterate over these parts and examine their properties: for example, the <code>get_content_type</code> method returns the part's MIME type, and the <code>get_filename</code> method returns the part's filename (if any is specified in the message). Then when you've found the correct message part, you can call <code>get_payload(decode=True)</code> to get the decoded contents.</p>
<pre><code>&gt;&gt;&gt; import email
&gt;&gt;&gt; msg = email.message_from_file(open('message.txt'))
&gt;&gt;&gt; len(msg.get_payload())
2
&gt;&gt;&gt; attachment = msg.get_payload()[1]
&gt;&gt;&gt; attachment.get_content_type()
'image/png'
&gt;&gt;&gt; open('attachment.png', 'wb').write(attachment.get_payload(decode=True))
</code></pre>
<p>If you're programmatically extracting attachments from email messages you have received, you might want to take precautions against viruses and trojans. In particular, you probably ought only to extract attachments whose MIME types you know are safe, and you probably want to pick your own filename, or at least sanitize the output of <code>get_filename</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is working solution, messages are form IMAP server</p>
<pre><code>self.imap.select()
typ, data = self.imap.uid('SEARCH', 'ALL')
msgs = data[0].split()
print "Found {0} msgs".format(len(msgs))

for uid in msgs:
    typ, s = self.imap.uid('FETCH', uid, '(RFC822)')
    mail = email.message_from_string(s[0][1])

    print "From: {0}, Subject: {1}, Date: {2}\n".format(mail["From"], mail["Subject"], mail["Date"])

    if mail.is_multipart():
        print 'multipart'
        for part in mail.walk():
            ctype = part.get_content_type()
            if ctype in ['image/jpeg', 'image/png']:
                open(part.get_filename(), 'wb').write(part.get_payload(decode=True))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually using now-suggested <a href="https://docs.python.org/3/library/email.message.html#email.message.EmailMessage" rel="nofollow noreferrer">email.EmailMessage API</a> (don't confuse with old <a href="https://docs.python.org/3/library/email.compat32-message.html" rel="nofollow noreferrer">email.Message API</a>) it is fairly easy to:</p>
<ol>
<li><p>Iterate over all message elements and select only attachments  </p></li>
<li><p>Iterate over just attachments</p></li>
</ol>
<p>Let's assume that you have your message stored as byte content in envelope variable </p>
<p><strong>Solution no.1:</strong></p>
<pre><code>import email
from email.message import EmailMessage

email_message: EmailMessage = email.message_from_bytes(envelope, _class=EmailMessage)

for email_message_part in email_message.walk():
    if email_message.is_attachment():
        # Do something with your attachment
</code></pre>
<p><strong>Solution no.2:</strong> (preferable since you don't have to walk through other parts of your message object)</p>
<pre><code>import email
from email.message import EmailMessage

email_message: EmailMessage = email.message_from_bytes(envelope, _class=EmailMessage)

for email_message_attachment in email_message.iter_attachments():
        # Do something with your attachment
</code></pre>
<p>Couple things to note:</p>
<ol>
<li>We explicitly tell to use new <code>EmailMessage</code> class in our byte read method through <code>_class=EmailMessage</code> parameter</li>
<li>You can read your email message (aka envelope) from sources such as <em>bytes-like object, binary file object or string</em> thanks to built-in methods in <a href="https://docs.python.org/3/library/email.parser.html" rel="nofollow noreferrer">message.Parser API</a> </li>
</ol>
</div>
<span class="comment-copy">What part of the Python library have you read so far?  Have you looked at the pop or imap libraries at all?</span>
<span class="comment-copy">I've only look into email.message.Message and mimetools.Message. Ok I will read into pop and imail and see what I can do with it.</span>
<span class="comment-copy">This works great. Thanks.</span>
<span class="comment-copy">HTML mails often have images in the footers, which are also sent as attachments. You can distinguish these from "real" attachments by looking at the Content-Disposition: inline images start with "inline", while actual attachments start with"attachment". There's no method for getting the content disposition, but you can call part.get('Content-Disposition').startswith('attachment') if you're only interested in actual attachments.</span>
