<div class="post-text" itemprop="text">
<p>I have a model with a FileField. I want to unittest it. django test framework has great ways to manage database and emails. Is there something similar for FileFields?</p>
<p>How can I make sure that the unittests are not going to pollute the real application?</p>
<p>Thanks in advance</p>
<p>PS: My question is almost a duplicate of <a href="https://stackoverflow.com/questions/2266503/django-test-filefield-using-test-fixtures">Django test FileField using test fixtures</a> but it doesn't have an accepted answer. Just want to re-ask if something new on this topic.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are several ways you could tackle this but they're all ugly since unit tests are supposed to be isolated but files are all about durable changes.</p>
<p>My unit tests don't run on a system with production data so it's been easy to simply reset the upload directory after each run with something like <code>git reset --hard</code>. This approach is in some ways the best simply because it involves no code changes and is guaranteed to work as long as you start with good test data. </p>
<p>If you don't actually need to do anything with that file after testing your model's save method, I'd recommend using python's excellent <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer">Mock library</a> to completely fake the <code>File</code> instance (i.e. something like <code>mock_file = Mock(spec=django.core.files.File); mock_file.read.return_value = "fake file contents"</code>) so you can completely avoid changes to your file handling logic. The Mock library has a couple of ways to <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="noreferrer">globally patch</a> Django's <a href="http://docs.djangoproject.com/en/dev/ref/files/file/" rel="noreferrer">File class</a> within a test method which is about as easy as this will get.</p>
<p>If you need to have a real file (i.e. for serving as part of a test, processing with an external script, etc.) you can use something similar to Mirko's example and create a <a href="http://docs.djangoproject.com/en/dev/ref/files/file/" rel="noreferrer">File object</a> after making sure it'll be stored somewhere appropriate - here are three ways to do that:</p>
<ul>
<li>Have your test <code>settings.MEDIA_ROOT</code> point to a temporary directory (see the Python <a href="http://docs.python.org/library/tempfile.html#tempfile.mkdtemp" rel="noreferrer">tempfile</a> module's <code>mkdtemp</code> function). This works fine as long as you have something like a separate <code>STATIC_ROOT</code> which you use for the media files which are part of your source code.</li>
<li>Use a custom <a href="http://docs.djangoproject.com/en/dev/ref/files/storage/" rel="noreferrer">storage manager</a></li>
<li>Set the file path manually on each File instance or have a custom <a href="http://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.FileField.upload_to" rel="noreferrer">upload_to</a> function to point somewhere which your test setup/teardown process purges such as a test subdirectory under <code>MEDIA_ROOT</code>.</li>
</ul>
<p><strong>Edit:</strong> mock object library is new in python version 3.3. For older python versions check <a href="http://www.voidspace.org.uk/python/mock/" rel="noreferrer">Michael Foord's version</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Django provides a great way to do this - use a SimpleUploadedFile.</p>
<pre><code>from django.core.files.uploadedfile import SimpleUploadedFile

my_model.file_field = SimpleUploadedFile('best_file_eva.txt', 'these are the file contents!')
</code></pre>
<p>It's one of django's magical features-that-don't-show-up-in-the-docs :). However it is referred to <a href="https://docs.djangoproject.com/en/dev/ref/forms/api/#binding-uploaded-files-to-a-form" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I normally test filefields in models using doctest</p>
<pre><code>&gt;&gt;&gt; from django.core.files import File
&gt;&gt;&gt; s = SimpleModel()
&gt;&gt;&gt; s.audio_file = File(open("media/testfiles/testaudio.wav"))
&gt;&gt;&gt; s.save()
&gt;&gt;&gt; ...
&gt;&gt;&gt; s.delete()
</code></pre>
<p>If I need to I also test file uploads with test clients. </p>
<p>As for fixtures, I simply copy the files i need in a test folder, after modifying the paths in the fixture.</p>
<p>e.g.</p>
<p>In a fixture containing models with filefiels pointing to a directory named "audio", you replace "audio": "audio/audio.wav" with "audio": "audio/test/audio.wav" .<br/>
Now all you have to do is copy the test folder, with the necessary files, in "audio" in the test setUp and then delete it in tearDown.</p>
<p>Not the cleanest way ever i think, but that's what i do.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to <strong>create an object</strong> that requires FileField and <strong>don't want to use this field</strong> then you can just pass any (existing or not) relative path like this:</p>
<pre><code>self.example_object = models.ExampleModel({'file': "foo.bar"})
self.example_object.save()
</code></pre>
<p>Then it's ready for use.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/2266503/django-test-filefield-using-test-fixtures">Django test FileField using test fixtures</a></span>
<span class="comment-copy">Thanks for this great answer. I finally choose to point to a unit-test MEDIA_ROOT by changing the value of this variable in the setUp of my test case</span>
<span class="comment-copy">mock is now part of the Python standard library, available as unittest.mock in Python 3.3 onward - Gathered from REAME.rst</span>
<span class="comment-copy">@chachan can you suggest an edit? That answer is definitely due for an update</span>
<span class="comment-copy">@ChrisAdams. Done, thanks for suggesting</span>
<span class="comment-copy">I didn't know this. Thanks for your comment. I'll investigate it</span>
<span class="comment-copy">The content <i>must</i> be str() in Python 2.x and bytes() in Python 3.x. You can't put text/unicode in there.</span>
<span class="comment-copy">I know I'm asking this 4 years later but... Is there any way to fake the file size?</span>
<span class="comment-copy">@pta2002 that sounds like a separate question :) and it probably depends how you are using the file size later, so include that when you open your new question</span>
<span class="comment-copy">This doesn't work. The assignment silently fails and the file field is still None.</span>
<span class="comment-copy">How can I do this with an ImageField???</span>
<span class="comment-copy">Do I need to close the file handle manually to free the resources used by it?</span>
