<div class="post-text" itemprop="text">
<p>I'd like to create a random list of integers for testing purposes. The distribution of the numbers is not important. The only thing that is counting is <strong>time</strong>. I know generating random numbers is a time-consuming task, but there must be a better way.</p>
<p>Here's my current solution:</p>
<pre><code>import random
import timeit

# Random lists from [0-999] interval
print [random.randint(0, 1000) for r in xrange(10)] # v1
print [random.choice([i for i in xrange(1000)]) for r in xrange(10)] # v2

# Measurement:
t1 = timeit.Timer('[random.randint(0, 1000) for r in xrange(10000)]', 'import random') # v1
t2 = timeit.Timer('random.sample(range(1000), 10000)', 'import random') # v2

print t1.timeit(1000)/1000
print t2.timeit(1000)/1000
</code></pre>
<p>v2 is faster than v1, but it is not working on such a large scale. It gives the following error:</p>
<blockquote>
<p><strong>ValueError: sample larger than population</strong></p>
</blockquote>
<p>Is there a fast, efficient solution that works at that scale?</p>
<h3>Some results from the answer</h3>
<p>Andrew's: 0.000290962934494</p>
<p>gnibbler's: 0.0058455221653</p>
<p>KennyTM's: 0.00219276118279</p>
<p>NumPy came, saw, and conquered.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not entirely clear what you want, but I would use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html" rel="nofollow noreferrer">numpy.random.randint</a>:</p>
<pre><code>import numpy.random as nprnd
import timeit

t1 = timeit.Timer('[random.randint(0, 1000) for r in xrange(10000)]', 'import random') # v1

### Change v2 so that it picks numbers in (0, 10000) and thus runs...
t2 = timeit.Timer('random.sample(range(10000), 10000)', 'import random') # v2
t3 = timeit.Timer('nprnd.randint(1000, size=10000)', 'import numpy.random as nprnd') # v3

print t1.timeit(1000)/1000
print t2.timeit(1000)/1000
print t3.timeit(1000)/1000
</code></pre>
<p>which gives on my machine:</p>
<pre><code>0.0233682730198
0.00781716918945
0.000147947072983
</code></pre>
<p>Note that randint is <em>very</em> different from random.sample (in order for it to work in your case I had to change the 1,000 to 10,000 as one of the commentators pointed out -- if you really want them from 0 to 1,000 you could divide by 10).</p>
<p>And if you really don't care what distribution you are getting then it is possible that you either don't understand your problem very well, or random numbers -- with apologies if that sounds rude...</p>
</div>
<div class="post-text" itemprop="text">
<p>All the random methods end up calling <code>random.random()</code> so the best way is to call it directly:</p>
<pre><code>[int(1000*random.random()) for i in xrange(10000)]
</code></pre>
<p>For example,</p>
<ul>
<li><code>random.randint</code> calls <code>random.randrange</code>.</li>
<li><code>random.randrange</code> has a bunch of overhead to check the range before returning <code>istart + istep*int(self.random() * n)</code>.</li>
</ul>
<p>NumPy is much faster still of course.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your question about performance is mootâ€”both functions are very fast. The speed of your code will be determined by what you <em>do</em> with the random numbers.</p>
<p>However it's important you understand the difference in <em>behaviour</em> of those two functions. One does random sampling with replacement, the other does random sampling without replacement.</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you should use <code>randrange(0,1000)</code> or <code>randint(0,999)</code>, not <code>randint(0,1000)</code>. The upper limit of <code>randint</code> is inclusive.</p>
<p>For efficiently, <code>randint</code> is simply a wrapper of <code>randrange</code> which calls <code>random</code>, so you should just use <code>random</code>. Also, use <code>xrange</code> as the argument to <code>sample</code>, not <code>range</code>.</p>
<p>You could use</p>
<pre><code>[a for a in sample(xrange(1000),1000) for _ in range(10000/1000)]
</code></pre>
<p>to generate 10,000 numbers in the range using <code>sample</code> 10 times.</p>
<p>(Of course this won't beat NumPy.)</p>
<pre><code>$ python2.7 -m timeit -s 'from random import randrange' '[randrange(1000) for _ in xrange(10000)]'
10 loops, best of 3: 26.1 msec per loop

$ python2.7 -m timeit -s 'from random import sample' '[a%1000 for a in sample(xrange(10000),10000)]'
100 loops, best of 3: 18.4 msec per loop

$ python2.7 -m timeit -s 'from random import random' '[int(1000*random()) for _ in xrange(10000)]' 
100 loops, best of 3: 9.24 msec per loop

$ python2.7 -m timeit -s 'from random import sample' '[a for a in sample(xrange(1000),1000) for _ in range(10000/1000)]'
100 loops, best of 3: 3.79 msec per loop

$ python2.7 -m timeit -s 'from random import shuffle
&gt; def samplefull(x):
&gt;   a = range(x)
&gt;   shuffle(a)
&gt;   return a' '[a for a in samplefull(1000) for _ in xrange(10000/1000)]'
100 loops, best of 3: 3.16 msec per loop

$ python2.7 -m timeit -s 'from numpy.random import randint' 'randint(1000, size=10000)'
1000 loops, best of 3: 363 usec per loop
</code></pre>
<hr/>
<p>But since you don't care about the distribution of numbers, why not just use:</p>
<pre><code>range(1000)*(10000/1000)
</code></pre>
<p>?</p>
</div>
<span class="comment-copy">Of course it doesn't work. <code>random.sample()</code> depletes the population, making the numbers less and less random. Once the entire population is depleted, it's impossible to sample further.</span>
<span class="comment-copy">When you say it's for testing purposes, how long will the testing take?</span>
<span class="comment-copy">For simulations, where time is a requirement (but crypto and security are not), then a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow noreferrer">Linear Congruential Generator (LCG)</a> is often used. I believe a <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="nofollow noreferrer">Mersenne Twister</a> is fast (but slower than LCG), and it provides a uniform distribution, if I recall correctly.</span>
<span class="comment-copy">+1 for numpy, if Stiggo needs this many random numbers it's probably worth installing numpy just for this</span>
<span class="comment-copy">Andrew, you absolutely right about distribution. But this is not a real thing. Just a challange between friends. :D Cheers!</span>
<span class="comment-copy">+1 I was just digging through it all earlier and ended up thinking that <code>randrange</code> eventually led to a call to <code>getrandbits</code>. I missed that you have to instantiate <code>SystemRandom</code> for that to be the behavior. Thanks for making me look more closely.</span>
<span class="comment-copy">Your's beat my version, but Andrew's solution clearly the winner.</span>
<span class="comment-copy">@Stiggo, for sure, the only reason I can think not to use numpy would be if numpy isn't supported on your platform. eg. google app engine</span>
<span class="comment-copy">in Python3, random.randrange(1000) is designed to produce a more uniform distribution than random.random()*1000.  See section 9.6.2 here: <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer">docs.python.org/3/library/random.html</a></span>
<span class="comment-copy">@AlexeyPolonsky, nice pickup. If we are happy to take numbers up to 1023, then <code>[getrandbits(10) for r in range(10000)]</code> is 9 times faster than the list comprehension in my answer</span>
<span class="comment-copy"><code>randrange(1000)</code> takes more than twice as long as <code>1000*int(random())</code> on my computer</span>
<span class="comment-copy">What is the purpose of <code>10000/1000</code>?</span>
