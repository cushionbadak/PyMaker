<div class="post-text" itemprop="text">
<p>I'm looking for a way to debug a python exception "retrospectively". Essentially if my program raises an exception that isn't handled, I want it to save off the program state so I can go back later and debug the problem.</p>
<p>I've taken a look at the pdb docs, and it seems that you can do this, but only if you can interact with the program at the point of the exception. This won't work for me as the program will be run in the background (without a controlling terminal). </p>
<p>My first (doomed!) approach was to put a try/except block at the highest level of my program, and in the except block extract the traceback object from the current exception and write it to disk using pickle. I planned to then write a separate program that would unpickle the object and use pdb.post_mortem to debug the crashed program. But traceback objects aren't pickleable, but I wouldn't expect that to work anyway, as it wouldn't save off the entire program state.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, there isn't any way to do what you're asking.  That said, it sounds like you might be looking for a remote debugger.  There are a couple of options:</p>
<ul>
<li><a href="http://winpdb.org/2010/09/rconsole-remote-python-console/" rel="nofollow">rconsole</a> - This isn't really a debugger, but it allows you to get an interactive prompt inside another process.  This can be useful for debugging purposes.  I haven't tried this, but it looks relatively straightforward.</li>
<li><a href="http://winpdb.org/docs/embedded-debugging/" rel="nofollow">rpdb2's embedded debugger</a> - This lets you start a debugger and then connect to it from another shell.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>What you can do is use twisted.python and write the traceback to a file, it gives you an exact traceback including the exception</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, as far as I know there is no easy solution to this problem. You might want to try this approach: <a href="https://stackoverflow.com/questions/141351/how-do-i-find-what-is-using-memory-in-a-python-process-in-a-production-system#142571">How do I find what is using memory in a Python process in a production system?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>At the moment the exception is caught, before the stack is unwound, the state is available for inspection with the inspect module: <a href="http://docs.python.org/2/library/inspect.html" rel="nofollow">http://docs.python.org/2/library/inspect.html</a></p>
<p>Generically you would use inspect.getinnerframes on your traceback object.  The local variables in each stack frame are available as .f_locals so you can see what they are.</p>
<p>The hard part is serializing all of them correctly: depending on what types you have in the local scope you may or may not be able to pickle them, dump them to JSON, or whatever. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could create an entirely separate execution environment in the top level:</p>
<pre><code>myEnv = {}
myEnv.update(globals)
</code></pre>
<p>Then execute your code within that execution environment.  If an exception occurs you have the traceback (stack) and all the globals, so you can pretty well reconstruct the program state.</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope this helps (it helped me):</p>
<pre><code>import logging, traceback
_logger = logging.getLogger(__name__)

try:
    something_bad()
except Exception as error:
    _logger.exception("Oh no!") # Logs original traceback
    store_exception_somewhere(error)
</code></pre>
<p>Also, <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow">in Python 3 there are a few new options</a> like <code>raise new_exc from original_exc
</code> or <code>raise OtherException(...).with_traceback(tb)</code>.</p>
</div>
<span class="comment-copy">This doesn't solve your problem by any means but instead of wrapping your whole program in a <code>try</code> statement, it might be better to set a handler for uncaught exceptions by assigning it to <a href="http://docs.python.org/library/sys.html#sys.excepthook" rel="nofollow noreferrer"><code>sys.excepthook</code></a>.</span>
<span class="comment-copy">Thanks, I'll look into those.</span>
<span class="comment-copy">there's also the <code>traceback</code> module. But I don't think that's what the OP wants.</span>
<span class="comment-copy">I'm not sure that does what I'm after. I can dump the traceback to file when the exception is caught, but what I'm really after is a way to interactively debug the program after the fact (like you'd debug a core file with gdb).</span>
