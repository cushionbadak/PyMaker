<div class="post-text" itemprop="text">
<p>I'm running into some trouble with deploying Django on the passenger_wsgi module with virtualenv. The Python code in the passenger_wsgi.py file, which should fix my problem is:</p>
<pre><code>import os, sys
INTERP = '/home/login/.virtualenvs/env_name/bin/python'
if sys.executable != INTERP:
    os.execl(INTERP, INTERP, *sys.argv)
</code></pre>
<p>The first three lines I understand, but I only have a veeeery vague idea about the fourth one and that's the one that happens to be giving me an error:</p>
<blockquote>
<p><code>/home/login/.virtualenvs/env_name/bin/python: can't find '__main__.py' in ''</code></p>
</blockquote>
<p>So what is os.execl doing here exactly? And what does that error message mean?</p>
</div>
<div class="post-text" itemprop="text">
<p>maybe you should do it like this:</p>
<pre><code>os.execl(INTERP, *sys.argv) # don't pass again the interpreter path. 
</code></pre>
<p>i think this doc is wrong : <a href="http://wiki.dreamhost.com/Passenger_WSGI" rel="noreferrer">http://wiki.dreamhost.com/Passenger_WSGI</a></p>
<p>about exec:</p>
<p>The exec functions of Unix-like operating systems are a collection of functions that causes the running process to be completely replaced by the program passed as an argument to the function.</p>
<pre><code>os.execl(path, arg0, arg1, ...)
os.execle(path, arg0, arg1, ..., env)
os.execlp(file, arg0, arg1, ...)
os.execlpe(file, arg0, arg1, ..., env)
os.execv(path, args)
os.execve(path, args, env)
os.execvp(file, args)
os.execvpe(file, args, env)
</code></pre>
<p><strong>from :</strong> <a href="http://docs.python.org/library/os.html" rel="noreferrer">http://docs.python.org/library/os.html</a></p>
<p>The “l” and “v” variants of the exec*() functions differ in how command-line arguments are passed. The “l” variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the execl*() functions. The “v” variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the args parameter. In either case, the arguments to the child process should start with the name of the command being run, but this is not enforced.</p>
<p><strong>Edit:</strong></p>
<p>i just did what you were doing in a python shell and i get the same error:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; import sys
&gt;&gt;&gt; os.execl('/home/login/projects/virtual/bin/python', '/home/login/projects/virtual/bin/python', *sys.argv)
/home/login/projects/virtual/bin/python: can't find '__main__.py' in ''
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not my intention to mess up with a question 9 years old, I googled "Python execl example" shortly and bumped into this thread, almost got misled by the answer, so I'm posting in hope of helping other visitors.</p>
<p>I agree with <a href="https://stackoverflow.com/users/479633/mouad">https://stackoverflow.com/users/479633/mouad</a> about the way to reproduce the bug, but not the reason, the error occurs because when a python interpreter is opened interactively, <code>sys.argv</code> will be <code>['']</code>, so an empty string is passed to the execl-invoked python interpreter as the path to the main script (directory), since the main script file __main__.py cannot be found in directory '' (the current work directory), it complains about:</p>
<pre><code>can't find '__main__.py' in ''
</code></pre>
<p>I can not figure out how <a href="https://stackoverflow.com/users/211075/monika-sulik">https://stackoverflow.com/users/211075/monika-sulik</a> managed to run a python script while successfully set the first member of <code>sys.argv</code> to <code>''</code>, it's my pure guess that the code got copy-pasted to the REPL.</p>
<p>As <a href="https://stackoverflow.com/users/845210/bjmc">https://stackoverflow.com/users/845210/bjmc</a> mentioned in <a href="https://stackoverflow.com/questions/4025442/python-os-execl-what-does-it-do-exactly-why-am-i-getting-this-error#comment37742802_4025513">Python: os.execl() - what does it do exactly? Why am I getting this error?</a>, the documentation is correct, it's OK to pass the interpreter path twice, although not required the second time. The signature of the function has its root in the UNIX <code>execve()</code> API (<a href="https://linux.die.net/man/2/execve" rel="nofollow noreferrer">https://linux.die.net/man/2/execve</a>), which says:</p>
<blockquote>
<p><code>argv</code> is an array of argument strings passed to the new program. By
  convention, the first of these strings should contain the filename
  associated with the file being executed.</p>
</blockquote>
<p>There are programs taking advantage of this inconsistency, e.g. busybox.</p>
<pre><code>$ ln -s /bin/busybox cat
$ ./cat /etc/timezone
/UTC
$ python -c "import os; os.execl('./cat', 'cat', '/etc/timezone')"
/UTC
$ python -c "import os; os.execl('./cat', 'ls', '/etc/timezone')"
/etc/timezone
</code></pre>
<p>The inconsistency between the executable path and the <code>argv[0]</code> in <code>main()</code> has made getting the reliable path to the running python executable very hard (if not impossible) in a UNIX-like environment, here is a script to illustrate this:</p>
<pre><code>import os
import sys


if len(sys.argv) &gt;= 2 and sys.argv[1] == 'exec':
    os.execl('/usr/bin/python', 'ls', sys.argv[0])
else:
    print(sys.executable)
    print(sys.version)
    print(sys.argv)
</code></pre>
<p>Run this script</p>
<pre><code>$ python test.py exec
/bin/ls
2.7.13 (default, Nov 24 2017, 17:33:09)
[GCC 6.3.0 20170516]
['test.py']
</code></pre>
<p>and <code>sys.executable</code> has value <code>"/bin/ls"</code>, as the documentation (<a href="https://docs.python.org/3/library/sys.html#sys.executable" rel="nofollow noreferrer">https://docs.python.org/3/library/sys.html#sys.executable</a>) says</p>
<blockquote>
<p>A string giving the absolute path of the executable binary for the
  Python interpreter, <strong>on systems where this makes sense</strong>.</p>
</blockquote>
<p>about <code>sys.executable</code>, if the python developers cannot figure out how to get <code>sys.executable</code> point to the path of the running python executable, it probably does not make sense in a UNIX-like environment. I would be grateful if someone tells me otherwise.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; help(os.execl)


execl(file, *args)
    execl(file, *args)

    Execute the executable file with argument list args, replacing the
    current process.
</code></pre>
<p>This might help with your problem: <a href="http://ubuntuforums.org/showthread.php?t=1493979" rel="nofollow">http://ubuntuforums.org/showthread.php?t=1493979</a></p>
</div>
<span class="comment-copy">Do you really have a directory named <code>&lt;login&gt;</code>?  How did you do that?  That's hard to do.</span>
<span class="comment-copy">Nope, I just didn't want to post my actual path here ;)</span>
<span class="comment-copy">Putting in <code>&lt;login&gt;</code> and <code>&lt;env_name&gt;</code> makes it very hard to experiment with your question.  I don't know what "secrets" you think your protecting, but you should choose names that don't have shell special-characters.</span>
<span class="comment-copy">Ok, edited it to a version without &lt; and &gt;</span>
<span class="comment-copy">Thanks... I read that bit of the docs and didn't quite get it either though. Passing the INTERP argument once gets rid of the error, but not of the problem. Although it did help me to understand what exactly is happening ;-P The problem is that when INTERP is passed just once, the python process does seem to be replaced, but when I print sys.executable in the new process it's still says '/usr/bin/python', which is obviously not what I want.</span>
<span class="comment-copy">Yep, that's how I'm debugging it - in the shell... no errors appear in the error.log (apparently passenger is very difficult to debug because the error logging sucks). And as django isn't working when there are errors in passenger_wsgi.py I don't get any errors sent via e-mail either.</span>
<span class="comment-copy">Right... I've voted your answer up because experimenting with os.execl(INTERP, *sys.argv) is the best lead I have at the moment. The interesting thing is that it seems that when I do that, it doesn't actually change sys.executable to whatever I have in INTERP (which I'm assuming is the point?), but always changes it to '/usr/bin/python'. So even if INTERP = '/usr/bin/python2.7' rather than the path to the virtualenv, running that command makes sys.executable = '/usr/bin/python'</span>
<span class="comment-copy">it's normal the sys.executable will not change , you can try running a python interpreter of a virtual environment and you will see that sys.executable == '/usr/bin/python', that because sys.executable don't give you the interpreter that's being run but give you the system default interpreter.</span>
<span class="comment-copy">Actually no - when I run an interpreter via putting in something like /home/user/.virtualenv/env_name/bin/python2.7 into the command line then when I print sys.executable that's exactly what it says.</span>
<span class="comment-copy">Thanks, but I still don't get it... Why do I have to put in the value of INTERP as both the filename and one of the arguments? And what does "replacing the current process" mean exactly? What about the error message, what does that mean?</span>
<span class="comment-copy">@Monika Sulik : replacing the current process  mean that the exec* command don't kill and create a new process ,they just replace the process from which the command have been called , the process ID doesn't change, but the data, heap and stack of the calling process are replaced by those of the new process.</span>
<span class="comment-copy">@singularity - thanks, that really did clear at least the process thing up for me :)</span>
