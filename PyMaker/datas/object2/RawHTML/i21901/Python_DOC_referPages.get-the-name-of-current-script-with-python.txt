<div class="post-text" itemprop="text">
<p>I'm trying to get the name of the Python script that is currently running.</p>
<p>For example, I have a script called <code>foo.py</code> and I would like to do something like this inside it:</p>
<pre><code>print Scriptname
</code></pre>
<p>and get: <code>foo.py</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>__file__</code>.  If you want to omit the directory part (which might be present), you can use <code>os.path.basename(__file__)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys
print sys.argv[0]
</code></pre>
<p>This will print <code>foo.py</code> for <code>python foo.py</code>, <code>dir/foo.py</code> for <code>python dir/foo.py</code>, etc. It's the first argument to <code>python</code>. (Note that after py2exe it would be <code>foo.exe</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that <code>__file__</code> will give the file where this code resides, which can be imported and different from the main file being interpreted. To get the main file, the special <a href="http://docs.python.org/3/library/__main__.html">__main__</a> module can be used:</p>
<pre><code>import __main__ as main
print(main.__file__)
</code></pre>
<p>Note that <code>__main__.__file__</code> works in Python 2.7 but not in 3.2, so use the import-as syntax as above to make it portable.</p>
</div>
<div class="post-text" itemprop="text">
<p>For completeness' sake, I thought it would be worthwhile summarizing the various possible outcomes and supplying references for the exact behaviour of each:</p>
<ul>
<li><p><code>__file__</code> is the currently executing file, as detailed in the <a href="https://docs.python.org/3/reference/datamodel.html#index-43" rel="noreferrer">official documentation</a>:</p>
<blockquote>
<p><code>__file__</code> is the pathname of the file from which the module was loaded, if it was loaded from a file. The <code>__file__</code> attribute may be missing for certain types of modules, such as <em>C</em> modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.</p>
</blockquote>
<p><a href="https://docs.python.org/3/whatsnew/3.4.html#other-language-changes" rel="noreferrer">From Python3.4</a> onwards, per <a href="https://bugs.python.org/issue18416" rel="noreferrer">issue 18416</a>, <code>__file__</code> is always an absolute path, unless the currently executing file is a script that has been executed directly (not via the interpreter with the <code>-m</code> command line option) using a relative path.</p></li>
<li><p><code>__main__.__file__</code> (requires importing <code>__main__</code>) simply accesses the aforementioned <code>__file__</code> attribute of the <a href="https://docs.python.org/3/library/__main__.html#module-__main__" rel="noreferrer">main module</a>, e.g. of the script that was invoked from the command line.</p></li>
<li><p><code>sys.argv[0]</code> (requires importing <code>sys</code>) is the script name that was invoked from the command line, and might be an absolute path, as detailed in the <a href="https://docs.python.org/3/library/sys.html#sys.argv" rel="noreferrer">official documentation</a>:</p>
<blockquote>
<p><code>argv[0]</code> is the script name (it is operating system dependent whether this is a full pathname or not). If the command was executed using the <code>-c</code> command line option to the interpreter, <code>argv[0]</code> is set to the string <code>'-c'</code>. If no script name was passed to the Python interpreter, <code>argv[0]</code> is the empty string.</p>
</blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/a/4152992/3903832">another answer to this question</a>, <em>Python</em> scripts that were converted into stand-alone executable programs via tools such as <a href="http://www.py2exe.org/" rel="noreferrer"><em>py2exe</em></a> or <a href="http://www.pyinstaller.org/" rel="noreferrer"><em>PyInstaller</em></a> might not display the desired result when using this approach (i.e. <code>sys.argv[0]</code> would hold the name of the executable rather than the name of the main <em>Python</em> file within that executable).</p></li>
</ul>
<hr/>
<p><code>os.path.basename()</code> may be invoked on any of the above in order to extract the actual file name.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Above answers are good . But I found this method more efficient using above results.<br/>
This results in actual script file name not a path.</p>
<pre><code>import sys    
import os    
file_name =  os.path.basename(sys.argv[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>print __file__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first argument in sys will be the current file name so this will work</p>
<pre><code>   import sys
   print sys.argv[0] # will print the file name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that the filename is <code>foo.py</code>, the below snippet</p>
<pre><code>import sys
print sys.argv[0][:-3]
</code></pre>
<p>or</p>
<pre><code>import sys
print sys.argv[0][::-1][3:][::-1]
</code></pre>
<p>will output <code>foo</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For modern Python versions, <code>Path(__file__).name</code> should be more idiomatic. Also, <code>Path(__file__).stem</code> gives you the script name without the <code>.py</code> extension.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're doing an unusual import (e.g., it's an options file), try:</p>
<pre><code>import inspect
print (inspect.getfile(inspect.currentframe()))
</code></pre>
<p>Note that this will return the absolute path to the file.</p>
</div>
<div class="post-text" itemprop="text">
<p>My fast dirty solution:</p>
<pre><code>__file__.split('/')[-1:][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/os.path.html" rel="nofollow noreferrer"><code>os.path.abspath(__file__)</code></a> will give you an absolute path (<code>relpath()</code> available as well).</p>
<p><a href="https://docs.python.org/3/library/sys.html" rel="nofollow noreferrer"><code>sys.argv[-1]</code></a> will give you a relative path.</p>
</div>
<span class="comment-copy">Python 3.2: "<code>Exception NameError: NameError("global name '__file__' is not defined",)</code>"</span>
<span class="comment-copy">@sdaau: <code>__file__</code> is not defined in the interactive interpreter, because it is meaningless there.  It is set by the import implementation, so if you use a non-standard import mechanism it might also be unset.</span>
<span class="comment-copy">At least for Python 2.7, I believe an <code>import os</code> is required for this to work. I'd add this into the answer.</span>
<span class="comment-copy">Actually, <code>import os.path</code>.</span>
<span class="comment-copy">@cdunn2001: <code>import os</code> and <code>import os.path</code> are completely equivalent.</span>
<span class="comment-copy">It won't work for symlinks.</span>
<span class="comment-copy">@DenisMalinovsky: define "won't work". If you call <code>python linkfile.py</code>, where <code>linkfile.py</code> is a symlink to <code>realfile.py</code>, <code>sys.argv[0]</code> will be <code>'linkfile.py'</code>, which may or may not be what you want; it is certainly what I <i>expect</i>. <code>__file__</code> is the same: it will be <code>linkfile.py</code>. If you want to find <code>'realfile.py'</code> from <code>'linkfile.py'</code>, try <code>os.path.realpath('linkfile.py')</code>.</span>
<span class="comment-copy">+1 because it's (a) a little neater and (b) will still work in module (where the <b>file</b> variable would be the module file, not the executed one).</span>
<span class="comment-copy">This answer is nice because it works in IDLE too. As a note, to get just the filename, you can write os.path.basename(sys.argv[0])</span>
<span class="comment-copy">This works in many cases but not when I am using the <code>rPython</code> package from <code>R</code> language. That must be an exceptional case that is just too hard to handle.</span>
<span class="comment-copy">Indeed, the rPython package embeds the python interpreter, which means there isn't a 'main' file like there is when python is running on its own (you'll find the same behaviour anytime python is embedded).  It does import <code>__main__</code> internally, for use in passing variables between <code>R</code> and <code>python</code>, so it would be relatively easy to make it set <code>__main__.__file__</code> before calling anything else, but I'm not even sure what would be an appropriate value in this case.</span>
<span class="comment-copy">Yes, this seems neater to me. Thanks.</span>
<span class="comment-copy">I like to split off the extension too, so I use: os.path.splitext(os.path.basename(sys.argv[0]))[0]</span>
<span class="comment-copy">sys.argv[0][:-3] would do</span>
<span class="comment-copy">@konpsych that's more elegant</span>
<span class="comment-copy">There's big difference between <code>__file__</code> and <code>sys.argv[0]</code>, see <a href="https://stackoverflow.com/questions/5851588/difference-between-file-and-sys-argv0" title="difference between file and sys argv0">stackoverflow.com/questions/5851588/â€¦</a></span>
<span class="comment-copy">NameError: name 'Path' is not defined</span>
<span class="comment-copy">You should <code>from pathlib import Path</code> first.</span>
<span class="comment-copy">Better use <code>os.path</code> to split filenames</span>
