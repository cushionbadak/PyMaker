<div class="post-text" itemprop="text">
<p>I want to write a custom class that behaves like <code>dict</code> - so, I am inheriting from <code>dict</code>.</p>
<p>My question, though, is: Do I need to create a private <code>dict</code> member in my <code>__init__()</code> method?. I don't see the point of this, since I already have the <code>dict</code> behavior if I simply inherit from <code>dict</code>.</p>
<p>Can anyone point out why most of the inheritance snippets look like the one below?</p>
<pre><code>class CustomDictOne(dict):
   def __init__(self):
      self._mydict = {} 

   # other methods follow
</code></pre>
<p>Instead of the simpler...</p>
<pre><code>class CustomDictTwo(dict):
   def __init__(self):
      # initialize my other stuff here ...

   # other methods follow
</code></pre>
<p>Actually, I think I suspect the answer to the question is so that users cannot directly access your dictionary (i.e. they have to use the access methods that you have provided).</p>
<p>However, what about the array access operator <code>[]</code>? How would one implement that? So far, I have not seen an example that shows how to override the <code>[]</code> operator. </p>
<p>So if a <code>[]</code> access function is not provided in the custom class, the inherited base methods will be operating on a different dictionary?</p>
<p>I tried the following snippet to test out my understanding of Python inheritance:</p>
<pre><code>class myDict(dict):
    def __init__(self):
        self._dict = {}

    def add(self, id, val):
        self._dict[id] = val


md = myDict()
md.add('id', 123)
print md[id]
</code></pre>
<p>I got the following error:</p>
<blockquote>
<p>KeyError:  &lt; built-in function id&gt;</p>
</blockquote>
<p>What is wrong with the code above?</p>
<p>How do I correct the class <code>myDict</code> so that I can write code like this?</p>
<pre><code>md = myDict()
md['id'] = 123
</code></pre>
<p><strong>[Edit]</strong></p>
<p>I have edited the code sample above to get rid of the silly error I made before I dashed away from my desk. It was a typo (I should have spotted it from the error message).</p>
</div>
<div class="post-text" itemprop="text">
<p>Check the documentation on <a href="https://docs.python.org/3/reference/datamodel.html?emulating-container-types#emulating-container-types" rel="noreferrer">emulating container types</a>. In your case, the first parameter to <code>add</code> should be <code>self</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Mapping(dict):

    def __setitem__(self, key, item):
        self.__dict__[key] = item

    def __getitem__(self, key):
        return self.__dict__[key]

    def __repr__(self):
        return repr(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def __delitem__(self, key):
        del self.__dict__[key]

    def clear(self):
        return self.__dict__.clear()

    def copy(self):
        return self.__dict__.copy()

    def has_key(self, k):
        return k in self.__dict__

    def update(self, *args, **kwargs):
        return self.__dict__.update(*args, **kwargs)

    def keys(self):
        return self.__dict__.keys()

    def values(self):
        return self.__dict__.values()

    def items(self):
        return self.__dict__.items()

    def pop(self, *args):
        return self.__dict__.pop(*args)

    def __cmp__(self, dict_):
        return self.__cmp__(self.__dict__, dict_)

    def __contains__(self, item):
        return item in self.__dict__

    def __iter__(self):
        return iter(self.__dict__)

    def __unicode__(self):
        return unicode(repr(self.__dict__))


o = Mapping()
o.foo = "bar"
o['lumberjack'] = 'foo'
o.update({'a': 'b'}, c=44)
print 'lumberjack' in o
print o

In [187]: run mapping.py
True
{'a': 'b', 'lumberjack': 'foo', 'foo': 'bar', 'c': 44}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like this</p>
<pre><code>class CustomDictOne(dict):
   def __init__(self,*arg,**kw):
      super(CustomDictOne, self).__init__(*arg, **kw)
</code></pre>
<p>Now you can use the built-in functions, like <code>dict.get()</code> as <code>self.get()</code>.</p>
<p>You do not need  to wrap a hidden <code>self._dict</code>.  Your class already <strong>is</strong> a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of completeness, here is the link to the documentation mentioned by @bj√∂rn-pollex for the latest Python 2.x (2.7.7 as of the time of writing):</p>
<p><a href="https://docs.python.org/2/reference/datamodel.html#emulating-container-types">Emulating Container Types</a></p>
<p>(Sorry for not using the comments function, I'm just not allowed to do so by stackoverflow.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with this chunk of code:</p>
<pre><code>class myDict(dict):
    def __init__(self):
        self._dict = {}

    def add(id, val):
        self._dict[id] = val


md = myDict()
md.add('id', 123)
</code></pre>
<p>...is that your 'add' method (...and any method you want to be a member of a class) needs to have an explicit 'self' declared as its first argument, like:</p>
<pre><code>def add(self, 'id', 23):
</code></pre>
<p>To implement the operator overloading to access items by key, look in the <a href="http://docs.python.org/reference/datamodel.html" rel="nofollow">docs</a> for the magic methods <code>__getitem__</code> and <code>__setitem__</code>.</p>
<p>Note that because Python uses Duck Typing, there may actually be no reason to derive your custom dict class from the language's dict class -- without knowing more about what you're trying to do (e.g, if you need to pass an instance of this class into some code someplace that will break unless <code>isinstance(MyDict(), dict) == True</code>), you may be better off just implementing the API that makes your class sufficiently dict-like and stopping there.</p>
</div>
<span class="comment-copy">If you're going to subclass <code>dict</code>, then you should use the object itself (using <code>super</code>) instead of simply delegating to the instance's <code>__dict__</code> - which essentially means you're creating two dicts for every instance.</span>
<span class="comment-copy">self.__dict__ is <i>not</i> the same as the actual dictionary content. Every python object, regardless of its type, has a <code>_dict__</code> which contains all the object attributes (methods, fields, etc). You do <i>not</i> want to mess around with this unless you want to write code that is modifying itself...</span>
<span class="comment-copy">This. There's no point in inheriting from <code>dict</code> without calling its constructor first.</span>
<span class="comment-copy">Note that your inherited <code>dict</code> actually contains 2 dict-instance: The 1st is the inherited container, and the 2nd is the dict holding the class-attributes - you may avoid that by using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><b>slots</b></a>.</span>
<span class="comment-copy">The <code>__dict__</code> is actually only created when it is first accessed, so as long as users don't attempt to use it, it's fine. <code>__slots__</code> would be nice though.</span>
<span class="comment-copy">Use spaces after commas you savage! ;-)</span>
