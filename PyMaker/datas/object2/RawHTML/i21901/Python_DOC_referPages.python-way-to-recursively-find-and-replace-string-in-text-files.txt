<div class="post-text" itemprop="text">
<p>I want to recursively search through a directory with subdirectories of text files and replace every occurrence of {$replace} within the files with the contents of a multi line string. How can this be achieved with python?</p>
<p><strong>[EDIT]</strong></p>
<p>So far all I have is the recursive code using os.walk to get a list of files that are required to be changed.</p>
<pre><code>import os
import sys
fileList = []
rootdir = "C:\\test"
for root, subFolders, files in os.walk(rootdir):
  if subFolders != ".svn":
    for file in files:
      fileParts = file.split('.')
      if len(fileParts) &gt; 1:
        if fileParts[1] == "php":
          fileList.append(os.path.join(root,file))


print fileList
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check out <a href="http://docs.python.org/library/os.html#os.walk" rel="noreferrer">os.walk</a>:</p>
<pre><code>import os
replacement = """some
multi-line string"""
for dname, dirs, files in os.walk("some_dir"):
    for fname in files:
        fpath = os.path.join(dname, fname)
        with open(fpath) as f:
            s = f.read()
        s = s.replace("{$replace}", replacement)
        with open(fpath, "w") as f:
            f.write(s)
</code></pre>
<p>The above solution has flaws, such as the fact that it opens literally every file it finds, or the fact that each file is read entirely into memory (which would be bad if you had a 1GB text file), but it should be a good starting point.</p>
<p>You also may want to look into the <a href="http://docs.python.org/library/re.html" rel="noreferrer">re module</a> if you want to do a more complex find/replace than looking for a specific string.</p>
</div>
<div class="post-text" itemprop="text">
<p>os.walk is great. However, it looks like you need to filer file types (which I would suggest if you are going to walk some directory). To do this, you should add <code>import fnmatch</code>.</p>
<pre><code>import os, fnmatch
def findReplace(directory, find, replace, filePattern):
    for path, dirs, files in os.walk(os.path.abspath(directory)):
        for filename in fnmatch.filter(files, filePattern):
            filepath = os.path.join(path, filename)
            with open(filepath) as f:
                s = f.read()
            s = s.replace(find, replace)
            with open(filepath, "w") as f:
                f.write(s)
</code></pre>
<p>This allows you to do something like:</p>
<pre><code>findReplace("some_dir", "find this", "replace with this", "*.txt")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For those using <strong>Python 3.5+</strong> you can now use a <a href="https://docs.python.org/3/library/glob.html" rel="noreferrer">glob</a> recursively with the use of <code>**</code> and the <code>recursive</code> flag.</p>
<p>Here's an example replacing <code>hello</code> with <code>world</code> for all <code>.txt</code> files:</p>
<pre><code>for filepath in glob.iglob('./**/*.txt', recursive=True):
    with open(filepath) as file:
        s = file.read()
    s = s.replace('hello', 'world')
    with open(filepath, "w") as file:
        file.write(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To avoid recursing into <code>.svn</code> directories, <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk()</code></a> allows you to change the <code>dirs</code> list inplace. To simplify the text replacement in a file without requiring to read the whole file in memory, you could use <a href="https://docs.python.org/3/library/fileinput.html" rel="nofollow noreferrer"><code>fileinput</code> module</a>. And to filter filenames using a file pattern, you could use <a href="https://docs.python.org/3/library/fnmatch.html#fnmatch.filter" rel="nofollow noreferrer"><code>fnmatch</code> module</a> as <a href="https://stackoverflow.com/a/15629678/4279">suggested by @David Sulpy</a>:</p>
<pre><code>#!/usr/bin/env python
from __future__ import print_function
import fnmatch
import os
from fileinput import FileInput

def find_replace(topdir, file_pattern, text, replacement):
    for dirpath, dirs, files in os.walk(topdir, topdown=True):
        dirs[:] = [d for d in dirs if d != '.svn'] # skip .svn dirs
        files = [os.path.join(dirpath, filename)
                 for filename in fnmatch.filter(files, file_pattern)]
        for line in FileInput(files, inplace=True):
            print(line.replace(text, replacement), end='')

find_replace(r"C:\test", "*.php", '{$replace}', "multiline\nreplacement")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sulpy's answer is good but incomplete. The user would be likely to want to input the parameters through an entry widget, so we might have something more like this (also incomplete, but left as an exercise):</p>
<pre><code>import os, fnmatch
from Tkinter import *
fields = 'Folder', 'Search', 'Replace', 'FilePattern'

def fetch(entvals):
#    print entvals
#    print ents
    entItems = entvals.items()
    for entItem in entItems:
        field = entItem[0]
        text  = entItem[1].get()
        print('%s: "%s"' % (field, text))

def findReplace(entvals):
#    print ents
    directory = entvals.get("Folder").get()
    find = entvals.get("Search").get()
    replace = entvals.get("Replace").get()
    filePattern = entvals.get("FilePattern").get()
    for path, dirs, files in os.walk(os.path.abspath(directory)):
        for filename in fnmatch.filter(files, filePattern):
#            print filename
            filepath = os.path.join(path, filename)
            print filepath  # Can be commented out --  used for confirmation
            with open(filepath) as f:
                s = f.read()
            s = s.replace(find, replace)
            with open(filepath, "w") as f:
                f.write(s)

def makeform(root, fields):
    entvals = {}
    for field in fields:
        row = Frame(root)
        lab = Label(row, width=17, text=field+": ", anchor='w')
        ent = Entry(row)
        row.pack(side=TOP, fill=X, padx=5, pady=5)
        lab.pack(side=LEFT)
        ent.pack(side=RIGHT, expand=YES, fill=X)
        entvals[field] = ent
#        print ent
    return entvals

if __name__ == '__main__':
    root = Tk()
    root.title("Recursive S&amp;R")
    ents = makeform(root, fields)
#    print ents
    root.bind('&lt;Return&gt;', (lambda event, e=ents: fetch(e)))
    b1 = Button(root, text='Show', command=(lambda e=ents: fetch(e)))
    b1.pack(side=LEFT, padx=5, pady=5)
    b2 = Button(root, text='Execute', command=(lambda e=ents: findReplace(e)))
    b2.pack(side=LEFT, padx=5, pady=5)
    b3 = Button(root, text='Quit', command=root.quit)
    b3.pack(side=LEFT, padx=5, pady=5)
    root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's my code (which I think is the same as the above but I'm including it just in case there's something subtly different about it):</p>
<pre><code>import os, fnmatch, sys
def findReplace(directory, find, replace, filePattern):
    for path, dirs, files in os.walk(os.path.abspath(directory)):
        for filename in fnmatch.filter(files, filePattern):         
            filepath = os.path.join(path, filename)
            with open(filepath) as f:
                s = f.read()
            s = s.replace(find, replace)
            with open(filepath, "w") as f:
                f.write(s)
</code></pre>
<p>it runs without error. 
BUT, the file, in <code>z:\test</code> is unchanged.
I've put in print statements, like <code>print("got here")</code> but they don't print out either.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about just using:</p>
<pre><code>clean = ''.join([e for e in text if e != 'string'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Multiple files string change</h3>
<p>import glob</p>
<p>for allfiles in glob.glob('*.txt'):</p>
<pre><code>for line in open(allfiles,'r'):
    change=line.replace("old_string","new_string")
    output=open(allfiles,'w')
    output.write(change)    
</code></pre>
</div>
<span class="comment-copy">If you tell us what you have so far, we will be more likely to help.</span>
<span class="comment-copy">Why do you need to use Python for this?  A combination of <code>find</code> and <code>sed</code> would do the job more elegantly, in my opinion.  <a href="http://developmentality.wordpress.com/2010/09/07/unix-tip-3-introduction-to-find-grep-sed/" rel="nofollow noreferrer">developmentality.wordpress.com/2010/09/07/â€¦</a> Basically, <code>find . -type f -exec sed -i '.bk' 's/search regexp/replacement string/g' {} \;</code> (Haven't tested but I think that's the correct syntax)</span>
<span class="comment-copy">@I82Much - but your solution would require learning sed. If OP already knows basic Python, and is not obsessed learning new tool (prefers mastering existing ones), solving the task in Python makes more sense.</span>
<span class="comment-copy">@I82Much: <code>c:\test</code> might be one reason (Windows). <code>find /c/test -type d -path \*/.svn -prune -o -type f -name \*.php -exec sed -i 's/{\$replace}/multiline\nstring/g' {} +</code>  shell command is close to <a href="http://stackoverflow.com/a/25885751/4279">this Python code</a></span>
<span class="comment-copy">Thanks, I was almost there.</span>
<span class="comment-copy">This is exactly what I was looking for. What a great answer!</span>
<span class="comment-copy">Great method, thanks for sharing</span>
<span class="comment-copy">to avoid loading the whole file in memory, you could use <a href="http://stackoverflow.com/a/25885751/4279"><code>fileinput</code> module</a></span>
<span class="comment-copy">works great! This helped me</span>
<span class="comment-copy">For windows might end up with error <code>'UnicodeDecodeError: 'charmap' codec can't decode byte 0x9d in position 676628: character maps to'</code> This is encoding error. Refer this <a href="https://stackoverflow.com/a/9233174/452708">stackoverflow.com/a/9233174/452708</a></span>
<span class="comment-copy">Please test your code before posting, this will just erase most of the content of the files! Don't try this!</span>
<span class="comment-copy">As @ThierryLathuille said, this answer is wrong and potentially harmful.</span>
