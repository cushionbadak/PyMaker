<div class="post-text" itemprop="text">
<p>I have a Dictionary below:</p>
<pre><code>colors = {
    "blue" : "5",
    "red" : "6",
    "yellow" : "8",
}
</code></pre>
<p>How do I index the first entry in the dictionary?</p>
<p><code>colors[0]</code> will return a <code>KeyError</code> for obvious reasons.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries are unordered in Python versions up to and including Python 3.6.  If you do not care about the order of the entries and want to access the keys or values by index anyway, you can use <code>d.keys()[i]</code> and <code>d.values()[i]</code> or <code>d.items()[i]</code>.  (Note that these methods create a list of all keys, values or items in Python 2.x.  So if you need them more then once, store the list in a variable to improve performance.)</p>
<p>If you do care about the order of the entries, starting with Python 2.7 you can use <a href="http://docs.python.org/library/collections.html#collections.OrderedDict" rel="noreferrer"><code>collections.OrderedDict</code></a>.  Or use a list of pairs</p>
<pre><code>l = [("blue", "5"), ("red", "6"), ("yellow", "8")]
</code></pre>
<p>if you don't need access by key.  (Why are your numbers strings by the way?)</p>
<p>In Python 3.7, normal dictionaries are ordered, so you don't need to use <code>OrderedDict</code> anymore (but you still can – it's basically the same type).  The CPython implementation of Python 3.6 already included that change, but since it's not part of the language specification, you can't rely on it in Python 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>If anybody still looking at this question, the currently accepted answer is now outdated:</p>
<p><a href="https://docs.python.org/3/whatsnew/3.7.html" rel="nofollow noreferrer">Since Python 3.7</a>* the dictionaries are <strong>order-preserving</strong>, that is they now behave exactly as <code>collections.OrderedDict</code>s used to. Unfortunately, there is still no dedicated method to index into <code>keys()</code> / <code>values()</code> of the dictionary, so getting the first key / value in the dictionary can be done as</p>
<pre><code>first_key = list(colors)[0]
first_val = list(colors.values())[0]
</code></pre>
<p>or alternatively (this avoids instantiating the keys view into a list):</p>
<pre><code>def get_first_key(dictionary):
    for key in dictionary:
        return key
    raise IndexError

first_key = get_first_key(colors)
first_val = colors[first_key]
</code></pre>
<p>If you need an <code>n</code>-th key, then similarly</p>
<pre><code>def get_nth_key(dictionary, n=0):
    if n &lt; 0:
        n += len(dictionary)
    for i, key in enumerate(dictionary.keys()):
        if i == n:
            return key
    raise IndexError("dictionary index out of range") 
</code></pre>
<p>(*CPython 3.6 already included ordered dicts, but this was only an implementation detail. The language specification includes ordered dicts from 3.7 onwards.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Addressing an element of dictionary is like sitting on donkey and enjoy the ride.</p>
<p>As rule of Python <strong><em>DICTIONARY is orderless</em></strong></p>
<p>If there is</p>
<pre><code>dic = {1: "a", 2: "aa", 3: "aaa"}
</code></pre>
<p>Now suppose if I go like <code>dic[10] = "b"</code>, then it will not add like this always</p>
<pre><code>dic = {1:"a",2:"aa",3:"aaa",10:"b"}
</code></pre>
<p>It may be like</p>
<pre><code>dic = {1: "a", 2: "aa", 3: "aaa", 10: "b"}
</code></pre>
<p>Or</p>
<pre><code>dic = {1: "a", 2: "aa", 10: "b", 3: "aaa"}
</code></pre>
<p>Or</p>
<pre><code>dic = {1: "a", 10: "b", 2: "aa", 3: "aaa"}
</code></pre>
<p>Or any such combination.</p>
<p>So thumb rule is <strong>DICTIONARY</strong> is <strong>orderless</strong>!</p>
</div>
<div class="post-text" itemprop="text">
<p>actually I found a novel solution that really helped me out,  If you are especially concerned with the index of a certain value in a list or data set, you can just set the value of dictionary to that Index!:</p>
<p>Just watch:</p>
<pre><code>list = ['a', 'b', 'c']
dictionary = {}
counter = 0
for i in list:
   dictionary[i] = counter
   counter += 1

print(dictionary) # dictionary = {'a':0, 'b':1, 'c':2}
</code></pre>
<p>Now through the power of hashmaps you can pull the index your entries in constant time (aka a whole lot faster)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need an ordered dictionary, you can use <a href="http://pypi.python.org/pypi/odict/1.2.1" rel="nofollow">odict</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't, since <code>dict</code> is unordered. you can use <code>.popitem()</code> to get an arbitrary item, but that will remove it from the dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>oh, that's a tough one. What you have here, basically, is two values for each item. Then you are trying to call them with a number as the key. Unfortunately, one of your values is already set as the key!</p>
<p>Try this:</p>
<pre><code>colors = {1: ["blue", "5"], 2: ["red", "6"], 3: ["yellow", "8"]}
</code></pre>
<p>Now you can call the keys by number as if they are indexed like a list. You can also reference the color and number by their position within the list.</p>
<p>For example,</p>
<pre><code>colors[1][0]
// returns 'blue'

colors[3][1]
// returns '8'
</code></pre>
<p>Of course, you will have to come up with another way of keeping track of what location each color is in. Maybe you can have another dictionary that stores each color's key as it's value.</p>
<blockquote>
<blockquote>
<blockquote>
<p>colors_key = {'blue': 1, 'red': 6, 'yllow': 8}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then, you will be able to also look up the colors key if you need to.</p>
<p>colors[colors_key['blue']][0] will return 'blue'</p>
<p>Something like that.</p>
<p>And then, while you're at it, you can make a dict with the number values as keys so that you can always use them to look up your colors, you know, if you need.</p>
<blockquote>
<blockquote>
<blockquote>
<p>values = {5: [1, 'blue'], 6: [2, 'red'], 8: [3, 'yellow']}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then, (colors[colors_key[values[5][1]]][0]) will return 'blue'.</p>
<p>Or you could use a list of lists.</p>
<p>Good luck!</p>
</div>
<span class="comment-copy">What does "first" mean?  Dictionaries have no ordering.</span>
<span class="comment-copy">Dictionaries is now insertion ordered since Python 3.7 Check this out: <a href="https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6" title="are dictionaries ordered in python 3 6">stackoverflow.com/questions/39980323/…</a></span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/52507860/accessing-dictionary-items-by-position-in-python-3-6-efficiently">Accessing dictionary items by position in Python 3.6+ efficiently</a></span>
<span class="comment-copy">In Python 2, use <code>d.iterkeys().next()</code> instead of <code>d.keys()[0]</code> to inspect one of the keys without removing it. If the dictionary is huge, it will make a big difference in terms of performance. The same goes for values and items. In Python 2.7 you can also use <a href="http://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">dict view objects</a></span>
<span class="comment-copy">In Python 3, these calls return a view, rather than an actual list so you should wrap them in a call to list() otherwise you will see: "TypeError: 'dict_values' object does not support indexing". See this S.O. question: <a href="http://stackoverflow.com/questions/17431638/get-typeerror-dict-values-object-does-not-support-indexing-when-using-python" title="get typeerror dict values object does not support indexing when using python">stackoverflow.com/questions/17431638/…</a></span>
<span class="comment-copy">Just a nit of a correction: you can't index items(), at least not in Python 3.</span>
<span class="comment-copy">You can with the workaround stifin provided.</span>
<span class="comment-copy">@hans This answer is outdated for Python 3.7, but not for Python 3.6, since the order-preserving nature of dictionaries is an implementation detail of the CPython implementation of that Python version, not an official part of the language.  I'll update this answer accordingly.</span>
<span class="comment-copy">Could please provide the link to the the corresponding documentation?</span>
<span class="comment-copy">odict sees not to support indexing into keys(), values(), or items().</span>
<span class="comment-copy"><code>next(iter(d.items()))</code> (<code>.iteritems()</code> in Python 2) gives you an arbitrary item as well (the same in my tests, which makes sense since popitem can be implemented using this) but won't remove the item.</span>
