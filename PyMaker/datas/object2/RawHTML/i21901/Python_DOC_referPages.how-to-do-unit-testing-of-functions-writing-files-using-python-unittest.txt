<div class="post-text" itemprop="text">
<p>I have a Python function that writes an output file to disk.</p>
<p>I want to write a unit test for it using Python unittest module.</p>
<p>How should I assert equality of files? I would like to get an error if the file content differs from the expected one + list of differences. As in the output of unix diff command.</p>
<p>Is there any official/recommended way of doing that?</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest thing is to write the output file, then read its contents, read the contents of the gold (expected) file, and compare them with simple string equality.  If they are the same, delete the output file.  If they are different, raise an assertion.</p>
<p>This way, when the tests are done, every failed test will be represented with an output file, and you can use a 3rd-party tool to diff them against the gold files (Beyond Compare is wonderful for this).</p>
<p>If you really want to provide your own diff output, remember that the Python stdlib has the difflib module.  The new unittest support in Python 3.1 includes an <code>assertMultiLineEqual</code> method that uses it to show diffs, similar to this:</p>
<pre><code>    def assertMultiLineEqual(self, first, second, msg=None):
        """Assert that two multi-line strings are equal.

        If they aren't, show a nice diff.

        """
        self.assertTrue(isinstance(first, str),
                'First argument is not a string')
        self.assertTrue(isinstance(second, str),
                'Second argument is not a string')

        if first != second:
            message = ''.join(difflib.ndiff(first.splitlines(True),
                                                second.splitlines(True)))
            if msg:
                message += " : " + msg
            self.fail("Multi-line strings are unequal:\n" + message)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer to have output functions explicitly accept a file <em>handle</em> (or file-like <em>object</em>), rather than accept a file <em>name</em> and opening the file themselves. This way, I can pass a <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="noreferrer"><code>StringIO</code></a> object to the output function in my unit test, then <code>.read()</code> the contents back from that <code>StringIO</code> object (after a <code>.seek(0)</code> call) and compare with my expected output.</p>
<p>For example, we would transition code like this</p>
<pre><code>##File:lamb.py
import sys


def write_lamb(outfile_path):
    with open(outfile_path, 'w') as outfile:
        outfile.write("Mary had a little lamb.\n")


if __name__ == '__main__':
    write_lamb(sys.argv[1])



##File test_lamb.py
import unittest
import tempfile

import lamb


class LambTests(unittest.TestCase):
    def test_lamb_output(self):
        outfile_path = tempfile.mkstemp()[1]
        try:
            lamb.write_lamb(outfile_path)
            contents = open(tempfile_path).read()
        finally:
            # NOTE: To retain the tempfile if the test fails, remove
            # the try-finally clauses
            os.remove(outfile_path)
        self.assertEqual(result, "Mary had a little lamb.\n")
</code></pre>
<p>to code like this</p>
<pre><code>##File:lamb.py
import sys


def write_lamb(outfile):
    outfile.write("Mary had a little lamb.\n")


if __name__ == '__main__':
    with open(sys.argv[1], 'w') as outfile:
        write_lamb(outfile)



##File test_lamb.py
import unittest
from io import StringIO

import lamb


class LambTests(unittest.TestCase):
    def test_lamb_output(self):
        outfile = StringIO()
        # NOTE: Alternatively, for Python 2.6+, you can use
        # tempfile.SpooledTemporaryFile, e.g.,
        #outfile = tempfile.SpooledTemporaryFile(10 ** 9)
        lamb.write_lamb(outfile)
        outfile.seek(0)
        content = outfile.read()
        self.assertEqual(content, "Mary had a little lamb.\n")
</code></pre>
<p>This approach has the added benefit of making your output function more flexible if, for instance, you decide you don't want to write to a file, but some other buffer, since it will accept all file-like objects.</p>
<p>Note that using <code>StringIO</code> assumes the contents of the test output can fit into main memory. For very large output, you can use a <a href="http://docs.python.org/library/tempfile.html" rel="noreferrer">temporary file</a> approach (e.g., <a href="http://docs.python.org/library/tempfile.html#tempfile.SpooledTemporaryFile" rel="noreferrer">tempfile.SpooledTemporaryFile</a>).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import filecmp
</code></pre>
<p>Then</p>
<pre><code>self.assertTrue(filecmp.cmp(path1, path2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could separate the content generation from the file handling. That way, you can test that the content is correct without having to mess around with temporary files and cleaning them up afterward.</p>
<p>If you write a <a href="http://docs.python.org/tutorial/classes.html#generators" rel="nofollow noreferrer">generator method</a> that yields each line of content, then you can have a file handling method that opens a file and calls <a href="http://docs.python.org/library/stdtypes.html#file.writelines" rel="nofollow noreferrer"><code>file.writelines()</code></a> with the sequence of lines. The two methods could even be on the same class: test code would call the generator, and production code would call the file handler.</p>
<p>Here's an example that shows all three ways to test. Usually, you would just pick one, depending on what methods are available on the class to test.</p>
<pre><code>import os
from io import StringIO
from unittest.case import TestCase


class Foo(object):
    def save_content(self, filename):
        with open(filename, 'w') as f:
            self.write_content(f)

    def write_content(self, f):
        f.writelines(self.generate_content())

    def generate_content(self):
        for i in range(3):
            yield u"line {}\n".format(i)


class FooTest(TestCase):
    def test_generate(self):
        expected_lines = ['line 0\n', 'line 1\n', 'line 2\n']
        foo = Foo()

        lines = list(foo.generate_content())

        self.assertEqual(expected_lines, lines)

    def test_write(self):
        expected_text = u"""\
line 0
line 1
line 2
"""
        f = StringIO()
        foo = Foo()

        foo.write_content(f)

        self.assertEqual(expected_text, f.getvalue())

    def test_save(self):
        expected_text = u"""\
line 0
line 1
line 2
"""
        foo = Foo()

        filename = 'foo_test.txt'
        try:
            foo.save_content(filename)

            with open(filename, 'rU') as f:
                text = f.read()
        finally:
            os.remove(filename)

        self.assertEqual(expected_text, text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on suggestions I did the following.</p>
<pre><code>class MyTestCase(unittest.TestCase):
    def assertFilesEqual(self, first, second, msg=None):
        first_f = open(first)
        first_str = first_f.read()
        second_f = open(second)
        second_str = second_f.read()
        first_f.close()
        second_f.close()

        if first_str != second_str:
            first_lines = first_str.splitlines(True)
            second_lines = second_str.splitlines(True)
            delta = difflib.unified_diff(first_lines, second_lines, fromfile=first, tofile=second)
            message = ''.join(delta)

            if msg:
                message += " : " + msg

            self.fail("Multi-line strings are unequal:\n" + message)
</code></pre>
<p>I created a subclass MyTestCase as I have lots of functions that need to read/write files so I really need to have re-usable assert method. Now in my tests, I would subclass MyTestCase instead of unittest.TestCase.</p>
<p>What do you think about it?</p>
</div>
<span class="comment-copy">This is better then writing a file to disk. If you are running tons of unittests, IO to disk causes all kinds of problems, especially trying to clean them up. I had tests writing to disk, the tearDown deleting the written files. Tests would work fine one at a time, then fail when Run All. At least with Visual Studio and PyTools on a Win machine. Also, speed.</span>
<span class="comment-copy">While this is a nice solution to test separate functions, it is still troublesome when testing the actual interface that your program provides (e.g. a CLI tool)..</span>
<span class="comment-copy">You can replace <code>seek()</code> and <code>read()</code> with <code>getvalue()</code>.</span>
<span class="comment-copy">I got error: TypeError: unicode argument expected, got 'str'</span>
<span class="comment-copy">Could you provide example code for that? It sounds interesting.</span>
<span class="comment-copy">I added an example for all three approaches, @buhtz.</span>
<span class="comment-copy">see <a href="http://stackoverflow.com/questions/4617034/python-open-multiple-files-using-with-open" title="python open multiple files using with open">stackoverflow.com/questions/4617034/â€¦</a></span>
