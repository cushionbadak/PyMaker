<div class="post-text" itemprop="text">
<p>I'm writing a class in python and I have an attribute that will take a relatively long time to compute, so <strong>I only want to do it once</strong>.  Also, it will not be needed by every instance of the class, so <strong>I don't want to do it by default</strong> in <code>__init__</code>.  </p>
<p>I'm new to Python, but not to programming.  I can come up with a way to do this pretty easily, but I've found over and over again that the 'Pythonic' way of doing something is often much simpler than what I come up with using my experience in other languages.</p>
<p>Is there a 'right' way to do this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way would be to make the attribute a <a href="http://docs.python.org/library/functions.html#property" rel="noreferrer">property</a> and store the value the first time it is calculated</p>
<pre><code>import time

class Foo(object):
    def __init__(self):
        self._bar = None

    @property
    def bar(self):
        if self._bar is None:
            print "starting long calculation"
            time.sleep(5)
            self._bar = 2*2
            print "finished long caclulation"
        return self._bar

foo=Foo()
print "Accessing foo.bar"
print foo.bar
print "Accessing foo.bar"
print foo.bar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I used to do this how gnibbler suggested, but I eventually got tired of the little housekeeping steps.</p>
<p>So I built my own descriptor:</p>
<pre><code>class cached_property(object):
    """
    Descriptor (non-data) for building an attribute on-demand on first use.
    """
    def __init__(self, factory):
        """
        &lt;factory&gt; is called such: factory(instance) to build the attribute.
        """
        self._attr_name = factory.__name__
        self._factory = factory

    def __get__(self, instance, owner):
        # Build the attribute.
        attr = self._factory(instance)

        # Cache the value; hide ourselves.
        setattr(instance, self._attr_name, attr)

        return attr
</code></pre>
<p>Here's how you'd use it:</p>
<pre><code>class Spam(object):

    @cached_property
    def eggs(self):
        print 'long calculation here'
        return 6*2

s = Spam()
s.eggs      # Calculates the value.
s.eggs      # Uses cached value.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python â‰¥ 3.2</strong></p>
<p>You should use both <a href="https://docs.python.org/3/library/functions.html#property" rel="noreferrer"><code>@property</code></a> and <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noreferrer"><code>@functools.lru_cache</code></a> decorators:</p>
<pre><code>import functools
class MyClass:
    @property
    @functools.lru_cache()
    def foo(self):
        print("long calculation here")
        return 21 * 2
</code></pre>
<p><a href="https://stackoverflow.com/a/16099881/343834">This answer</a> has more detailed examples and also mentions a backport for previous Python versions.</p>
<p><strong>Python &lt; 3.2</strong></p>
<p>The Python wiki has a <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Cached_Properties" rel="noreferrer">cached property decorator</a> (MIT licensed) that can be used like this:</p>
<pre><code>import random
# the class containing the property must be a new-style class
class MyClass(object):
   # create property whose value is cached for ten minutes
   @cached_property(ttl=600)
   def randint(self):
       # will only be evaluated every 10 min. at maximum.
       return random.randint(0, 100)
</code></pre>
<p>Or any implementation mentioned in the others answers that fits your needs.
<br/>Or the above mentioned backport.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class MemoizeTest:

      _cache = {}
      def __init__(self, a):
          if a in MemoizeTest._cache:
              self.a = MemoizeTest._cache[a]
          else:
              self.a = a**5000
              MemoizeTest._cache.update({a:self.a})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try looking into memoization. The way it works is that if you pass in a function the same arguments, it will return the cached result. You can find more information on <a href="http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize" rel="nofollow">implementing it in python here</a>.</p>
<p>Also, depending on how your code is set up (you say that it is not needed by all instances) you could try to use some sort of flyweight pattern, or lazy-loading.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's what I do. This is about as efficient as you can get:</p>
<pre><code>class X:
    @property
    def foo(self):
        r = calculate_something()
        self.foo = r
        return r
</code></pre>
<p>Explanation: Basically, I'm just overloading a property method with the computed value. So after the first time you access the property (for that instance), <code>foo</code> ceases to be a property and becomes an instance attribute. The advantage of this approach is that a cache hit is as cheap as possible because <code>self.__dict__</code> is being used as the cache, and there is no instance overhead if the property is not used.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most simple way of doing this would probably be to just write a method (instead of using an attribute) that wraps around the attribute (getter method). On the first call, this methods calculates, saves and returns the value; later it just returns the saved value.</p>
</div>
<span class="comment-copy">IMO none of these answers is correct. OP wanted a cached <i>class</i> property, eg <code>Foo.something_expensive</code>. All these answers are about cached <i>instance</i> properties, which means <code>something_expensive</code> will be recalculated for every new instance, which is less than optimal in most cases</span>
<span class="comment-copy">In Python3.2+, is there any motivation to use this approach over <code>@property + @functools.lru_cache()</code>? The quasi-private attribute way seems to be reminiscent of Java/setters/getters; in my humble opinion just decorating with lru_cache is more pythonic</span>
<span class="comment-copy">(As in @Maxime's <a href="https://stackoverflow.com/a/19979379/7954504">answer</a>)</span>
<span class="comment-copy">Wonderful! Here's how it works: Instance variables <a href="https://docs.python.org/2/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">take precedence over non-data descriptors</a>. At the first access of the attribute, there is no instance attribute but only the descriptor class attribute and hence the descriptor is executed. However, during its execution the descriptor creates an instance attribute with the cached value. This means that when the attribute is accessed a second time the previously created instance attribute is returned instead of the descriptor being executed.</span>
<span class="comment-copy">There is a <a href="https://pypi.python.org/pypi/cached-property" rel="nofollow noreferrer"><code>cached_property</code> package on PyPI</a>. It includes thread-safe and time-expire versions. (Also, thanks, @Florian, for the explanation.)</span>
<span class="comment-copy">Yay for esoteric corner cases: you can't use a <code>cached_property</code> descriptor when using <code>__slots__</code>. Slots are implemented using data descriptors, and using a <code>cached_property</code> descriptor simply overrides the generated slot descriptor, so the <code>setattr()</code> call won't work as there is no <code>__dict__</code> to set the attribute in and the only descriptor available for this attribute name is the <code>cached_property</code>.. Just putting this here to help others avoid this pitfall.</span>
<span class="comment-copy">lru_cache has also been backported to python 2: <a href="https://pypi.python.org/pypi/functools32/3.2.3" rel="nofollow noreferrer">pypi.python.org/pypi/functools32/3.2.3</a></span>
<span class="comment-copy">-1 <code>lru_cache</code> has a default size of 128, cause the property function to be potentially called twice. If you were to use <code>lru_cache(None)</code> all instances will be kept alive permanently.</span>
<span class="comment-copy">@orlp lru_cache has a default size of 128, for 128 different argument configurations.  This will only be an issue if you are generating more objects than your cache size, as the only changing argument here is self.  If you are generating so many objects, you really shouldn't be using an unbounded cache, as it will force you to keep all objects that have ever called the property in memory indefinitely, which could be a horrendous memory leak.  Regardless, you probably would be better off with a caching method that stores the cache in the object itself, so the cache is cleaned up with it.</span>
