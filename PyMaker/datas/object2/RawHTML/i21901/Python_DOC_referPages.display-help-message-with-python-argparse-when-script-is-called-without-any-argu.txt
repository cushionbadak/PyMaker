<div class="post-text" itemprop="text">
<p>This might be a simple one. Assume I have a program that uses argparse to process command line arguments/options. The following will print the 'help' message:</p>
<pre><code>./myprogram -h
</code></pre>
<p>or:</p>
<pre><code>./myprogram --help
</code></pre>
<p>But, if I run the script without any arguments whatsoever, it doesn't do anything. What I want it to do is to display the usage message when it is called with no arguments. How is that done?</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer comes from Steven Bethard <a href="http://groups.google.com/group/argparse-users/browse_thread/thread/2dacd5fed110bd0c?pli=1" rel="noreferrer">on Google groups</a>. I'm reposting it here to make it easier for people without a Google account to access.</p>
<p>You can override the default behavior of the <code>error</code> method:</p>
<pre><code>import argparse
import sys

class MyParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write('error: %s\n' % message)
        self.print_help()
        sys.exit(2)

parser = MyParser()
parser.add_argument('foo', nargs='+')
args = parser.parse_args()
</code></pre>
<hr/>
<p>Note that the above solution will print the help message whenever the <code>error</code>
method is triggered. For example, <code>test.py --blah</code> will print the help message
too if <code>--blah</code> isn't a valid option.</p>
<p>If you want to print the help message only if no arguments are supplied on the
command line, then perhaps this is still the easiest way:</p>
<pre><code>import argparse
import sys

parser=argparse.ArgumentParser()
parser.add_argument('foo', nargs='+')
if len(sys.argv)==1:
    parser.print_help(sys.stderr)
    sys.exit(1)
args=parser.parse_args()
</code></pre>
<hr/>
<p>Note that <code>parser.print_help()</code> prints to stdout by default. As <a href="https://stackoverflow.com/questions/4042452/display-help-message-with-python-argparse-when-script-is-called-without-any-argu/4042861?noredirect=1#comment84996345_4042861">init_js suggests</a>, use <code>parser.print_help(sys.stderr)</code> to print to stderr.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of writing a class, a try/except can be used instead</p>
<pre><code>try:
    options = parser.parse_args()
except:
    parser.print_help()
    sys.exit(0)
</code></pre>
<p>The upside is that the workflow is clearer and you don't need a stub class. The downside is that the first 'usage' line is printed twice.</p>
<p>This will need at least one mandatory argument. With no mandatory arguments, providing zero args on the commandline is valid.</p>
</div>
<div class="post-text" itemprop="text">
<p>With argparse you could do:</p>
<pre><code>parser.argparse.ArgumentParser()
#parser.add_args here

#sys.argv includes a list of elements starting with the program
if len(sys.argv) &lt; 2:
    parser.print_usage()
    sys.exit(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have arguments that must be specified for the script to run - use the <strong>required</strong> parameter for ArgumentParser as shown below:-</p>
<pre class="lang-py prettyprint-override"><code>parser.add_argument('--foo', required=True)
</code></pre>
<p>parse_args() will report an error if the script is run without any arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you associate default functions for (sub)parsers, as is mentioned under <a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers" rel="noreferrer"><code>add_subparsers</code></a>, you can simply add it as the default action:</p>
<pre class="lang-py prettyprint-override"><code>parser = argparse.ArgumentParser()
parser.set_defaults(func=lambda x: parser.print_usage())
args = parser.parse_args()
args.func(args)
</code></pre>
<p>Add the try-except if you raise exceptions due to missing positional arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>Throwing my version into the pile here:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
args = parser.parse_args()
if not vars(args):
    parser.print_help()
    parser.exit(1)
</code></pre>
<p>You may notice the <code>parser.exit</code> - I mainly do it like that because it saves an import line if that was the only reason for <code>sys</code> in the file... </p>
</div>
<div class="post-text" itemprop="text">
<p>The cleanest solution will be to manually pass default argument if none were given on the command line:</p>
<pre><code>parser.parse_args(args=None if sys.argv[1:] else ['--help'])
</code></pre>
<p>Complete example:</p>
<pre><code>import argparse, sys

parser = argparse.ArgumentParser()
parser.add_argument('--host', default='localhost', help='Host to connect to')
# parse arguments
args = parser.parse_args(args=None if sys.argv[1:] else ['--help'])

# use your args
print("connecting to {}".format(args.host))
</code></pre>
<p>This will print complete help (not short usage) if called w/o arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a pair of one-liners with <code>sys.argv[1:]</code> (a very common Python's idiom to refer the command line arguments, being <code>sys.argv[0]</code> the script's name) that can do the job.</p>
<p>The first one is self-explanatory, clean and pythonic:</p>
<pre><code>args = parser.parse_args(None if sys.argv[1:] else ['-h'])
</code></pre>
<p>The second one is a little hackier. Combining the previously evaluated fact that an empty list is <code>False</code> with the <code>True == 1</code> and <code>False == 0</code> equivalences you get this:</p>
<pre><code>args = parser.parse_args([None, ['-h']][not sys.argv[1:]])
</code></pre>
<p>Maybe too many brackets, but pretty clear if a previous argument selection was made.</p>
<pre><code>_, *av = sys.argv
args = parser.parse_args([None, ['-h']][not av])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>parser.print_help()
parser.exit()
</code></pre>
<hr/>
<p>The <code>parser.exit</code> method also accept a <code>status</code> (returncode), and a <code>message</code> value (include a trailing newline yourself!).</p>
<p>an opinionated example,
:)</p>
<pre><code>#!/usr/bin/env python3

""" Example argparser based python file
"""

import argparse

ARGP = argparse.ArgumentParser(
    description=__doc__,
    formatter_class=argparse.RawTextHelpFormatter,
)
ARGP.add_argument('--example', action='store_true', help='Example Argument')


def main(argp=None):
    if argp is None:
        argp = ARGP.parse_args()  # pragma: no cover

    if 'soemthing_went_wrong' and not argp.example:
        ARGP.print_help()
        ARGP.exit(status=128, message="\nI just don't know what went wrong, maybe missing --example condition?\n")


if __name__ == '__main__':
    main()  # pragma: no cover
</code></pre>
<p>Example calls:</p>
<pre>
$ python3 ~/helloworld.py; echo $?
usage: helloworld.py [-h] [--example]

 Example argparser based python file

optional arguments:
  -h, --help  show this help message and exit
  --example   Example Argument

I just don't know what went wrong, maybe missing --example condition?
128
$ python3 ~/helloworld.py --example; echo $?
0
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Set your positional arguments with nargs, and check if positional args are empty.</p>
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('file', nargs='?')
args = parser.parse_args()
if not args.file:
    parser.print_help()
</code></pre>
<p>Reference <a href="https://docs.python.org/2/library/argparse.html#nargs" rel="nofollow noreferrer">Python nargs</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way to do it, if you need something flexible where you want to display help if specific params are passed, none at all or more than 1 conflicting arg:</p>
<pre><code>import argparse
import sys

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--days', required=False,  help="Check mapped inventory that is x days old", default=None)
    parser.add_argument('-e', '--event', required=False, action="store", dest="event_id",
                        help="Check mapped inventory for a specific event", default=None)
    parser.add_argument('-b', '--broker', required=False, action="store", dest="broker_id",
                        help="Check mapped inventory for a broker", default=None)
    parser.add_argument('-k', '--keyword', required=False, action="store", dest="event_keyword",
                        help="Check mapped inventory for a specific event keyword", default=None)
    parser.add_argument('-p', '--product', required=False, action="store", dest="product_id",
                        help="Check mapped inventory for a specific product", default=None)
    parser.add_argument('-m', '--metadata', required=False, action="store", dest="metadata",
                        help="Check mapped inventory for specific metadata, good for debugging past tix", default=None)
    parser.add_argument('-u', '--update', required=False, action="store_true", dest="make_updates",
                        help="Update the event for a product if there is a difference, default No", default=False)
    args = parser.parse_args()

    days = args.days
    event_id = args.event_id
    broker_id = args.broker_id
    event_keyword = args.event_keyword
    product_id = args.product_id
    metadata = args.metadata
    make_updates = args.make_updates

    no_change_counter = 0
    change_counter = 0

    req_arg = bool(days) + bool(event_id) + bool(broker_id) + bool(product_id) + bool(event_keyword) + bool(metadata)
    if not req_arg:
        print("Need to specify days, broker id, event id, event keyword or past tickets full metadata")
        parser.print_help()
        sys.exit()
    elif req_arg != 1:
        print("More than one option specified. Need to specify only one required option")
        parser.print_help()
        sys.exit()

    # Processing logic here ...
</code></pre>
<p>Cheers!</p>
</div>
<span class="comment-copy">Yeah.. that's what I was wondering about, whether there was a way for argparse to handle this scenario. Thanks!</span>
<span class="comment-copy">In the second solution I use <code>parser.print_usage()</code> in place of <code>parser.print_help()</code> -- the help message includes usage but it's more verbose.</span>
<span class="comment-copy">I would have voted for the second part of the answer, but overriding <code>error()</code> seems a terrible idea to me. It serves a different purpose, it's not designed for printing a friendly usage or help.</span>
<span class="comment-copy">@Peterino - the override is occurring in a child class, so this shouldn't be a problem.  It's explicit.</span>
<span class="comment-copy">@unutbu WONDERFUL! Exactly what I needed. One question, can this be applied to subcommands too? I usually just get ``Namespace(output=None)`. How can I trigger an error easily on ALL subcommands? I'd like to trigger an error there.</span>
<span class="comment-copy">me too, I prefer this to the accepted answer. Adding a class is overkilled for printing help when the arguments are unexpected. Let the excellent module argparse handle error cases for you.</span>
<span class="comment-copy">This code prints help 2 times if <code>-h</code> flag is used, and unnecessary prints help if <code>--version</code> flag is used. To mitigate those problems  you can check error type like this: <code>except SystemExit as err: if err.code == 2: parser.print_help()</code></span>
<span class="comment-copy">This must come <i>before</i> the call to <code>parser.parse_args()</code></span>
<span class="comment-copy">This is the simplest solution and will work with invalid options specified as well.</span>
<span class="comment-copy">Agreed. I think it's always better to leverage the built-in abilities of the argument parser then to write an additional handler of some kind.</span>
<span class="comment-copy">This answer is so underrated. Simple and works very well with sub-parsers.</span>
<span class="comment-copy">parser.exit(1) is nice!  Good addition.</span>
<span class="comment-copy">Unfortunately parser.parse_args() will exit if a positional argument is missing. So this only works when using optional arguments.</span>
<span class="comment-copy">@MarcelWilson, it does indeed - good catch! I'll have a think about how to change it.</span>
<span class="comment-copy"><code>sys.argv[1:]</code> is a very common idiom. I see <code>parser.parse_args(None if sys.argv[1:] else ['-h'])</code> more idiomatic and cleaner.</span>
<span class="comment-copy">@NunoAndré thanks - updated the answer. Feels more pythonic indeed.</span>
