<div class="post-text" itemprop="text">
<p>I'd like to convert a hex triplet to an RGB tuple and then convert a tuple to a hex triplet. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a look-up table with some slicing and shifts — all relatively fast operations — to create a couple of functions that will work unchanged in both Python 2 and 3:</p>
<pre><code>_NUMERALS = '0123456789abcdefABCDEF'
_HEXDEC = {v: int(v, 16) for v in (x+y for x in _NUMERALS for y in _NUMERALS)}
LOWERCASE, UPPERCASE = 'x', 'X'

def rgb(triplet):
    return _HEXDEC[triplet[0:2]], _HEXDEC[triplet[2:4]], _HEXDEC[triplet[4:6]]

def triplet(rgb, lettercase=LOWERCASE):
    return format(rgb[0]&lt;&lt;16 | rgb[1]&lt;&lt;8 | rgb[2], '06'+lettercase)

if __name__ == '__main__':
    print('{}, {}'.format(rgb('aabbcc'), rgb('AABBCC')))
    # -&gt; (170, 187, 204), (170, 187, 204)

    print('{}, {}'.format(triplet((170, 187, 204)),
                          triplet((170, 187, 204), UPPERCASE)))
    # -&gt; aabbcc, AABBCC

    print('{}, {}'.format(rgb('aa0200'), rgb('AA0200')))
    # -&gt; (170, 2, 0), (170, 2, 0)

    print('{}, {}'.format(triplet((170, 2, 0)),
                          triplet((170, 2, 0), UPPERCASE)))
    # -&gt; aa0200, AA0200
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; rgbstr='aabbcc'
&gt;&gt;&gt; struct.unpack('BBB',rgbstr.decode('hex'))
(170, 187, 204)
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; rgb = (50,100,150)
&gt;&gt;&gt; struct.pack('BBB',*rgb).encode('hex')
'326496'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Trying to be <em>pythonic</em>:</p>
<pre><code>&gt;&gt;&gt; rgbstr='aabbcc'
&gt;&gt;&gt; tuple(ord(c) for c in rgbstr.decode('hex'))
(170, 187, 204)
&gt;&gt;&gt; tuple(map(ord, rgbstr.decode('hex'))
(170, 187, 204)
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; rgb=(12,50,100)
&gt;&gt;&gt; "".join(map(chr, rgb)).encode('hex')
'0c3264'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found a simple way:</p>
<pre><code>red, green, blue = bytes.fromhex("aabbcc")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>with <a href="http://matplotlib.org/" rel="noreferrer">matplotlib</a></h2>
<p>matplotlib uses RGB tuples with values between 0 and 1:</p>
<pre><code>from matplotlib.colors import hex2color, rgb2hex

hex_color = '#00ff00'
rgb_color = hex2color(hex_color)
hex_color_again = rgb2hex(rgb_color)
</code></pre>
<p>both <code>rgb_color</code> and <code>hex_color</code> are in a format acceptable by matplotlib.</p>
<h2>with <a href="https://pypi.python.org/pypi/webcolors/1.3" rel="noreferrer">webcolors</a></h2>
<p>html uses RGB tuples with values between 0 and 255.</p>
<p>you can convert between them with the module webcolors, using the functions <code>hex_to_rgb</code>, <code>rgb_to_hex</code></p>
</div>
<div class="post-text" itemprop="text">
<p>A very simplistic approach to convert rgb to hex</p>
<pre><code>&gt;&gt;&gt; rgb = (255, 255, 255)
&gt;&gt;&gt; r, g , b = rgb
&gt;&gt;&gt; hex(r)
'0xff'
&gt;&gt;&gt; hex(r) + hex(g)[2:] + hex(b)[2:]
'0xffffff'
&gt;&gt;&gt;
</code></pre>
<p>A simplistic approach to convert Hex to rgb </p>
<pre><code>&gt;&gt;&gt; h  = '0xffffff'
&gt;&gt;&gt; h1, h2, h3 = h[0:4], '0x' + h[4:6], '0x' + h[6:8]
&gt;&gt;&gt; h1, h2, h3
('0xff', '0xff', '0xff')
&gt;&gt;&gt; r, g , b = int(h1, 16), int(h2, 16), int(h3, 16)
&gt;&gt;&gt; r, g, b
(255, 255, 255)
</code></pre>
<p>Use a module which provides some these facility: <a href="http://pypi.python.org/pypi/webcolors/1.3" rel="noreferrer">webcolors</a></p>
<pre><code>&gt;&gt;&gt; hex_to_rgb('#000080')
(0, 0, 128)
&gt;&gt;&gt; rgb_to_hex((255, 255, 255))
'#ffffff'
</code></pre>
<p>Function doc:</p>
<blockquote>
<p>hex_to_rgb(hex_value)
   Convert a hexadecimal color value to a 3-tuple of integers suitable for use in an rgb() triplet specifying that color.</p>
<p>rgb_to_hex(rgb_triplet) : 
   Convert a 3-tuple of integers, suitable for use in an rgb() color triplet, to a normalized hexadecimal value for that color.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>def hex_to_int_color(v):
    if v[0] == '#':
        v = v[1:]
    assert(len(v) == 6)
    return int(v[:2], 16), int(v[2:4], 16), int(v[4:6], 16)

def int_to_hex_color(v):
    assert(len(v) == 3)
    return '#%02x%02x%02x' % v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>HEX to RGB tuple</p>
<pre><code>&gt;&gt;&gt; tuple(bytes.fromhex('61559a'))
(97, 85, 154)
</code></pre>
<p>RGB tuple to HEX</p>
<pre><code>&gt;&gt;&gt; bytes((97, 85, 154)).hex()
'61559a'
</code></pre>
<p>No imports needed!</p>
<hr/>
<p>What is this magic?!</p>
<blockquote>
<p>Since bytes objects are sequences of integers (akin to a tuple), for a
  bytes object b, b[0] will be an integer, while b[0:1] will be a bytes
  object of length 1</p>
<p>...</p>
<p>The representation of bytes objects uses the literal format (b'...')
  since it is often more useful than e.g. bytes([46, 46, 46]). You can
  always convert a bytes object into a list of integers using list(b).</p>
</blockquote>
<p>Source: <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#bytes-objects</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

def hex_to_int_color(v):
  return tuple(int(i,16) for i in re.match(
    r'^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$', v,
    flags=re.IGNORECASE).groups())

def int_to_hex_color(v):
  return '#%02x%02x%02x' % v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here you go. I use it to convert color to graphviz color format in <code>#RGBA</code> format with <code>prefix=#</code>.</p>
<pre><code>def rgba_hex( color, prefix = '0x' ):
    if len( color ) == 3:
       color = color + (255,)
    hexColor = prefix + ''.join( [ '%02x' % x for x in color ] )
    return hexColor
</code></pre>
<p>USAGE:</p>
<pre><code>In [3]: rgba_hex( (222, 100, 34) )
Out[3]: '0xde6422ff'

In [4]: rgba_hex( (0,255,255) )
Out[4]: '0x00ffffff'

In [5]: rgba_hex( (0,255,255,0) )
Out[5]: '0x00ffff00'
</code></pre>
</div>
<span class="comment-copy">Possible duplicate: <a href="http://stackoverflow.com/questions/2262100/rgb-int-to-rgb-python">stackoverflow.com/questions/2262100/rgb-int-to-rgb-python</a></span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/214359/converting-hex-to-rgb-and-vice-versa#214657" title="converting hex to rgb and vice versa%23214657">stackoverflow.com/questions/214359/…</a></span>
<span class="comment-copy">Try testing with triplet(170, 2, 0).</span>
<span class="comment-copy">@ruralcoder: Good catch. Fixed.</span>
<span class="comment-copy">In python 3.0, replace <code>str.decode('hex')</code> with <code>bytes.fromhex(str)</code> .  For the other direction, use <code>binascii.hexlify</code> to convert back to a string after packing.</span>
<span class="comment-copy">In Python 2.7 <code>str</code> is the name of a built-in type. This is also true in many earlier versions, I just don't recall offhand when it was introduced. Anyway, the point is that giving a variable that name isn't generally a good practice because it hides the type. This is still a good answer, IMHO.</span>
<span class="comment-copy">@martineau - thanks for the comment, I edited my answer.</span>
<span class="comment-copy">Converting this to work in Python 3.x is somewhat tricky -- especially (and surprisingly) the conversion to a hex triplet in the second part.</span>
<span class="comment-copy">If I'm not mistaken, <code>binascii.hexlify</code> yields a bytes object. You'd need to call <code>.decode('utf-8')</code> on that to get a string, right? The total command is <code>binascii.hexlify(struct.pack('BBB', *rgb)).decode('utf-8')</code>. I think <code>'#%02x%02x%02x' % rgb</code> is a lot simpler, and has the benefit of dealing with float values as well as integers.</span>
<span class="comment-copy">+1 for being pythonic</span>
<span class="comment-copy"><code>rgbstr.decode('hex')</code> How it will looks like for python3?</span>
<span class="comment-copy">This is the simplest solution out here, that doesn't even require importing any modules.</span>
<span class="comment-copy"><code>bytearray.fromhex()</code> for python 2.7</span>
<span class="comment-copy">This is not only simpler, it's also faster than using struct. More so if you return tuple instead of list.</span>
<span class="comment-copy">note that the rgb to hex fails if any of the input values are less than 16. e.g., <code>rgb = (0, 255, 0)</code> would result in <code>"#0x0ff0"</code></span>
<span class="comment-copy">v = [1:] ---&gt; v = v[1:]</span>
<span class="comment-copy">def int_to_hex_color(v):   assert(len(v) == 3)   return '#%02x%02x%02x' % v</span>
<span class="comment-copy">Sorry, your int_to_hex_color does not return correct results when some of the colour components have values &lt; 16. int_to_hex_color((30,20,10)) -&gt; '#1e14a'</span>
<span class="comment-copy">fixed. thanks @svenor</span>
