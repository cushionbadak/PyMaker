<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks">What is the most “pythonic” way to iterate over a list in chunks?</a>
<span class="question-originals-answer-count">
                    34 answers
                </span>
</li>
</ul>
</div>
<p>I'm looking for a function that takes an iterable <code>i</code> and a size <code>n</code> and yields tuples of length <code>n</code> that are sequential values from <code>i</code>:</p>
<pre><code>x = [1,2,3,4,5,6,7,8,9,0]
[z for z in TheFunc(x,3)]
</code></pre>
<p>gives</p>
<pre><code>[(1,2,3),(4,5,6),(7,8,9),(0)]
</code></pre>
<p>Does such a function exist in the standard library?</p>
<p>If it exists as part of the standard library, I can't seem to find it and I've run out of terms to search for. I could write my own, but I'd rather not.</p>
</div>
<div class="post-text" itemprop="text">
<p>See the <code>grouper</code> recipe in the <a href="http://docs.python.org/library/itertools.html" rel="nofollow noreferrer">docs for the  <code>itertools</code> package</a> </p>
<pre><code>def grouper(n, iterable, fillvalue=None):
  "grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx"
  args = [iter(iterable)] * n
  return izip_longest(fillvalue=fillvalue, *args)
</code></pre>
<p>(However, this is a duplicate of <a href="https://stackoverflow.com/search?q=python+grouper">quite a few questions</a>.)</p>
</div>
<div class="post-text" itemprop="text">
<p><em>When you want to group an iterator in chunks of <code>n</code> <strong>without padding</strong> the final group with a fill value, use <code>iter(lambda: list(IT.islice(iterable, n)), [])</code></em>:</p>
<pre><code>import itertools as IT

def grouper(n, iterable):
    """
    &gt;&gt;&gt; list(grouper(3, 'ABCDEFG'))
    [['A', 'B', 'C'], ['D', 'E', 'F'], ['G']]
    """
    iterable = iter(iterable)
    return iter(lambda: list(IT.islice(iterable, n)), [])

seq = [1,2,3,4,5,6,7]
print(list(grouper(3, seq)))
</code></pre>
<p>yields</p>
<pre><code>[[1, 2, 3], [4, 5, 6], [7]]
</code></pre>
<p>There is an explanation of how it works in the second half of <a href="https://stackoverflow.com/a/31170795/190597">this answer</a>.</p>
<hr/>
<p><em>When you want to group an iterator in chunks of <code>n</code> <strong>and pad</strong> the final group with a fill value, use the <a href="http://docs.python.org/library/itertools.html#recipes" rel="noreferrer">grouper recipe</a> <code>zip_longest(*[iterator]*n)</code></em>:</p>
<p>For example, in Python2:</p>
<pre><code>&gt;&gt;&gt; list(IT.izip_longest(*[iter(seq)]*3, fillvalue='x'))
[(1, 2, 3), (4, 5, 6), (7, 'x', 'x')]
</code></pre>
<p>In Python3, what was <code>izip_longest</code> is now renamed <code>zip_longest</code>:</p>
<pre><code>&gt;&gt;&gt; list(IT.zip_longest(*[iter(seq)]*3, fillvalue='x'))
[(1, 2, 3), (4, 5, 6), (7, 'x', 'x')]
</code></pre>
<hr/>
<p><em>When you want to group a <strong>sequence</strong> in chunks of <code>n</code> you can use the <code>chunks</code> recipe</em>:</p>
<pre><code>def chunks(seq, n):
    # https://stackoverflow.com/a/312464/190597 (Ned Batchelder)
    """ Yield successive n-sized chunks from seq."""
    for i in xrange(0, len(seq), n):
        yield seq[i:i + n]
</code></pre>
<p>Note that, unlike iterators in general, <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="noreferrer">sequences by definition</a> have a length (i.e. <code>__len__</code> is defined).</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this one? It doesn't have a fill value though.</p>
<pre><code>&gt;&gt;&gt; def partition(itr, n):
...     i = iter(itr)
...     res = None
...     while True:
...             res = list(itertools.islice(i, 0, n))
...             if res == []:
...                     break
...             yield res
...
&gt;&gt;&gt; list(partition([1, 2, 3, 4, 5, 6, 7, 8, 9], 3))
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt;
</code></pre>
<p>It utilizes a copy of the original iterable, which it exhausts for each successive splice. The only other way my tired brain could come up with was generating splice end-points with range.</p>
<p>Maybe I should change <code>list()</code> to <code>tuple()</code> so it better corresponds to your output.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a very common request in Python. Common enough that it made it into the <a href="http://boltons.readthedocs.org/en/latest/" rel="nofollow">boltons</a> unified utility package. First off, <a href="http://boltons.readthedocs.org/en/latest/iterutils.html#boltons.iterutils.chunked" rel="nofollow">there are extensive docs here</a>. Furthermore, <a href="https://github.com/mahmoud/boltons/blob/master/boltons/iterutils.py" rel="nofollow">the module</a> is designed and tested to only rely on the standard library (Python 2 and 3 compatible), meaning you can <a href="https://raw.githubusercontent.com/mahmoud/boltons/master/boltons/iterutils.py" rel="nofollow">just download the file directly into your project</a>.</p>
<pre class="lang-py prettyprint-override"><code># if you downloaded/embedded, try:
# from iterutils import chunked

# with `pip install boltons` use:

from boltons.iterutils import chunked 

print(chunked(range(10), 3))
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
</code></pre>
<p>There's an iterator/generator form for indefinite/long sequences as well:</p>
<pre class="lang-py prettyprint-override"><code>print(list(chunked_iter(range(10), 3, fill=None)))
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, None, None]]
</code></pre>
<p>As you can see, you can also fill the sequence with a value of your choosing, as well. Finally, as the maintainer, I can assure you that, while the code has been downloaded/tested by thousands of developers, if you encounter any issues, you'll get the fastest support possible through the <a href="https://github.com/mahmoud/boltons/issues" rel="nofollow">boltons GitHub Issues page</a>. Hope this (and/or any of the other 150+ boltons recipes) helped!</p>
</div>
<div class="post-text" itemprop="text">
<p>I use the <a href="https://pythonhosted.org/more-itertools/api.html#more_itertools.chunked" rel="nofollow">chunked function from the more_itertools package</a>.</p>
<pre><code>$ pip install more_itertools
$ python
&gt;&gt;&gt; x = [1,2,3,4,5,6,7,8,9,0]
&gt;&gt;&gt; [tuple(z) for z in more_itertools.more.chunked(x, 3)]
[(1, 2, 3), (4, 5, 6), (7, 8, 9), (0,)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a very old quesiton, but I think it is useful to mention the following approach for the general case. Its main merit is that it only needs to iterate over the data once, so it will work with database cursors or other sequences that can only be used once. I also find it more readable.</p>
<pre><code>def chunks(n, iterator):
    out = []
    for elem in iterator:
        out.append(elem)
        if len(out) == n:
            yield out
            out = []
    yield out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this has been answered several times but I'm adding my solution which should improve in both, general applicability to sequences and iterators, readability (no invisible loop exit condition by StopIteration exception) and performance when compared to the grouper recipe. It is most similar to the last answer by Svein.</p>
<pre class="lang-py prettyprint-override"><code>def chunkify(iterable, n):
    iterable = iter(iterable)
    n_rest = n - 1

    for item in iterable:
        rest = itertools.islice(iterable, n_rest)
        yield itertools.chain((item,), rest)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a different solution which makes no use of itertools and, even though it has a couple more lines, it apparently outperforms the given answers when chunks are a lot shorter than the iterable lenght.
However, for big chunks the other answers are much faster.</p>
<pre><code>def batchiter(iterable, batch_size):
    """
    &gt;&gt;&gt; list(batchiter('ABCDEFG', 3))
    [['A', 'B', 'C'], ['D', 'E', 'F'], ['G']]
    """
    next_batch = []
    for element in iterable:
        next_batch.append(element)
        if len(next_batch) == batch_size:
            batch, next_batch = next_batch, []
            yield batch
    if next_batch:
        yield next_batch


In [19]: %timeit [b for b in batchiter(range(1000), 3)]
1000 loops, best of 3: 644 µs per loop

In [20]: %timeit [b for b in grouper(3, range(1000))]
1000 loops, best of 3: 897 µs per loop

In [21]: %timeit [b for b in partition(range(1000), 3)]
1000 loops, best of 3: 890 µs per loop

In [22]: %timeit [b for b in batchiter(range(1000), 333)]
1000 loops, best of 3: 540 µs per loop

In [23]: %timeit [b for b in grouper(333, range(1000))]
10000 loops, best of 3: 81.7 µs per loop

In [24]: %timeit [b for b in partition(range(1000), 333)]
10000 loops, best of 3: 80.1 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>    def grouper(iterable, n):
        while True:
            yield itertools.chain((next(iterable),), itertools.islice(iterable, n-1))
</code></pre>
</div>
<span class="comment-copy">If I knew to search for "grouper" I wouldn't have needed to ask at all. But I didn't know of that term.</span>
<span class="comment-copy">+1. Totally forgot about the handy recipes in the docs.</span>
<span class="comment-copy">I ended up using this, but had to hack in filtering out the fillvalues at a later stage.</span>
<span class="comment-copy">LOL. You've GOT to be kidding me. There is a bug here in the answer, and my edit for it got rejected? My respect for the SO community has just diminished greatly.</span>
<span class="comment-copy">btw, itertools.islice(i, 0, 3) -&gt; itertools.islice(i, 0, n)  Still can't believe the SO community.</span>
<span class="comment-copy">I didn't reject it, someone else did. But you are correct. The 3 is hardcoded negating the purpose of n as a parameter. If you want I can edit it but you won't get any rep then, up to you : )</span>
<span class="comment-copy">Yeah...I've kinda gotten over it by now. Just go ahead and edit it yourself :)</span>
<span class="comment-copy">Your answer would be better if you included a short explanation to go with that code.</span>
