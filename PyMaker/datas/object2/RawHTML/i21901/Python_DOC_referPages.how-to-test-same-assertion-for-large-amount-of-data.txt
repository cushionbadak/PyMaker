<div class="post-text" itemprop="text">
<p>I am using python unittest module to do a number of tests; however,  it is very repetitive.</p>
<p>I have a lot of data that I want to run through the same test over and over, checking if correct. However, I have to define a test for every one.</p>
<p>For instance I want to do something similar to this. I know I could do it using a generator (found it in a previous thread here). But are there alternatives, maybe even using a different testing module?</p>
<p>Any suggestions would be great.</p>
<pre><code>
import unittest

class TestData(unittest.TestCase):
    def testNumbers(self):
        numbers = [0,11,222,33,44,555,6,77,8,9999]
        for i in numbers:
            self.assertEqual(i, 33)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sample code for solution suggested by Bill Gribble could look like this:</p>
<pre><code>import unittest

class DataTestCase(unittest.TestCase):
    def __init__(self, number):
        unittest.TestCase.__init__(self, methodName='testOneNumber')
        self.number = number

    def testOneNumber(self):
        self.assertEqual(self.number, 33)

    def shortDescription(self):
        # We need to distinguish between instances of this test case.
        return 'DataTestCase for number %d' % self.number


def get_test_data_suite():
    numbers = [0,11,222,33,44,555,6,77,8,9999]
    return unittest.TestSuite([DataTestCase(n) for n in numbers])

if __name__ == '__main__':
    testRunner = unittest.TextTestRunner()
    testRunner.run(get_test_data_suite())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may want to consider using the unittest.TestSuite class, which will allow you to dynamically construct a set of unittest.TestCase instances which will get run separately.  Your unittest.TestCase subclass should define just one test method, with the class accepting a construction parameter passing in the value to test against for that particular instance. </p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://ddt.readthedocs.io/" rel="nofollow noreferrer"><code>ddt</code> library</a> was built to solve exactly what you are asking for <code>unittest</code>[*].</p>
<p>For example:</p>
<pre><code>import ddt
import unittest

@ddt.ddt
class EvalTests(unittest.TestCase):

    @ddt.data(
            ('1', 1),
            ('1 == 1',  True),
            ('1 == 2',  False),
            ('1 + 2',   4),  ## This will fail
    )
    def test_eval_expressions(self, case):
        expr, exp_value = case
        self.assertEqual(eval(expr), exp_value)
</code></pre>
<p>And when you run it, you get 4 TestCases instead of just one:</p>
<pre><code>$ python -m unittest  -v  test_eval.py
test_eval_expressions_1___1___1_ (test_eval.EvalTests) ... ok
test_eval_expressions_2___1__1___True_ (test_eval.EvalTests) ... ok
test_eval_expressions_3___1__2___False_ (test_eval.EvalTests) ... ok
test_eval_expressions_4___1_2___4_ (test_eval.EvalTests) ... FAIL

======================================================================
FAIL: test_eval_expressions_4___1_2___4_ (test_eval.EvalTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib/python/lib/site-packages/ddt.py", line 129, in wrapper
    return func(self, *args, **kwargs)
  File "/Work/test_eval.py", line 15, in test_eval_expressions
    self.assertEqual(eval(expr), exp_value)
AssertionError: 3 != 4

----------------------------------------------------------------------
Ran 4 tests in 0.002s

FAILED (failures=1)
</code></pre>
<p>Notice that <em>ddt</em> tries to come up with names for the generated TCs.</p>
<p>Install it with pip:</p>
<pre><code>pip install ddt
</code></pre>
<p>[*] The same solution for the pythonic <code>pytest</code> framework (<code>pytest.mark.parametrize</code>) is integrated into the core tool, and is worth switching to <code>pytest</code> just for this feature alone.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with running assertions in a loop is that, if one of the assertions fails, you don't know which value caused it (in your example, it would fail on <code>0</code>, but you don't know that until you debug). On the other hand, repeating <code>self.assertEqual(i, 33)</code> is an even worse idea, because it introduces code duplication.</p>
<p>What I do in my test is to create a simple, shortly-named internal function inside the test and call it with different arguments. So your function would look like this:</p>
<pre><code>import unittest

class TestData(unittest.TestCase):
    def testNumbers(self):
        def eq(i):
            self.assertEqual(i, 33)
        eq(0)
        eq(11)
        eq(222)
        eq(33)
        eq(44)
        eq(555)
        ... 
</code></pre>
<p>This way, when the assertion fails for <code>0</code>, you immediately see it on the stack trace printed by the <code>unittest</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>In another post I stumbled accross
<a href="http://somethingaboutorange.com/mrl/projects/nose/0.11.2/" rel="nofollow">Nose Tests</a>
It is more suited to data driven testing.</p>
<pre><code>
class Test_data():
    def testNumbers():
        numbers = [0,11,222,33,44,555,6,77,8,9999]
        for i in numbers:
            yield checkNumber, num

def checkNumber(num):
    assert num == 33
</code></pre>
<p>The above code does the exact same thing as my first post. 
No imports are needed, just write a python class.</p>
<p>You execute the tests by typing: </p>
<p><code>nosetests filename</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Spin-off of <a href="https://stackoverflow.com/a/3923268/916568">this</a> answer, which didn't quite work for me. Where I'm not dealing with <em>large</em> amounts of data, I did need to run same tests with different inputs. The following tests are using <code>create_a</code> and <code>create_b</code> methods which I want to customize. </p>
<p>The requirement is to run both tests with the same customization.</p>
<pre class="lang-python prettyprint-override"><code>class Tests(unittest.TestCase):

    def test_a_uses_b(self):
        a = create_a()
        b = create_b()
        a.b = b
        self.assertIs(b.a, a)

    def test_b_uses_a(self):
        a = create_a()
        b = create_b()
        b.a = a
        self.assertIs(a.b, b)
</code></pre>
<p>Instantiating <code>TestSuite</code> and <code>TestCase</code> myself, bypassing the test loader, resulted in an error because it expected a single method, called <code>runTest</code>.</p>
<p>The result was this:</p>
<pre class="lang-python prettyprint-override"><code>class Tests(unittest.TestCase):

    def __init__(self, create_a, create_b):
        super().__init__()
        self.create_b = create_b
        self.create_a = create_a

    def test_a_uses_b(self):
        a = self.create_a()
        b = self.create_b()
        a.b = b
        self.assertIs(b.a, a)

    def test_b_uses_a(self):
        a = self.create_a()
        b = self.create_b()
        b.a = a
        self.assertIs(a.b, b)


class TestPair1(Tests):
    def __init__(self):
        super().__init__(create_a1, create_b1)


class TestPair2(Tests):
    def __init__(self):
        super().__init__(create_a2, create_b2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.4 you can use <code>unittest.TestCase.subTest(msg=None, **params)</code> context manager (<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.subTest" rel="nofollow noreferrer">documentation</a>). This will allow you to achieve what you want by adding just one statement.</p>
<p>Here is you example modified to use <code>subTest()</code></p>
<pre><code>import unittest

class TestData(unittest.TestCase):
    def testNumbers(self):
        numbers = [0, 11, 222, 33, 44, 555, 6, 77, 8, 9999]
        for i in numbers:
            with self.subTest(i=i):  # added statement
                self.assertEqual(i, 33)
</code></pre>
</div>
<span class="comment-copy">What's wrong with this?  It looks great.</span>
<span class="comment-copy">Basically, as soon as the assertion is true, it will stop executing.</span>
<span class="comment-copy">I see what you are doing. Its a good idea. But the first time it hits 33, it will stop executing for the rest of the code.</span>
<span class="comment-copy">If what you're saying is that you have to recreate the test fixture for each number, then you should go ahead with what Bill Gribble suggested and dynamically construct a TestSuite.</span>
