<div class="post-text" itemprop="text">
<p>I am extracting emails from Gmail using the following:</p>
<pre><code>def getMsgs():
 try:
    conn = imaplib.IMAP4_SSL("imap.gmail.com", 993)
  except:
    print 'Failed to connect'
    print 'Is your internet connection working?'
    sys.exit()
  try:
    conn.login(username, password)
  except:
    print 'Failed to login'
    print 'Is the username and password correct?'
    sys.exit()

  conn.select('Inbox')
  # typ, data = conn.search(None, '(UNSEEN SUBJECT "%s")' % subject)
  typ, data = conn.search(None, '(SUBJECT "%s")' % subject)
  for num in data[0].split():
    typ, data = conn.fetch(num, '(RFC822)')
    msg = email.message_from_string(data[0][1])
    yield walkMsg(msg)

def walkMsg(msg):
  for part in msg.walk():
    if part.get_content_type() != "text/plain":
      continue
    return part.get_payload()
</code></pre>
<p>However, some emails I get are nigh impossible for me to extract dates (using regex) from as encoding-related chars such as '=', randomly land in the middle of various text fields. Here's an example where it occurs in a date range I want to extract:</p>
<blockquote>
<p>Name:  KIRSTI   Email: 
  kirsti@blah.blah   Phone #:  + 999
  99995192   Total in party:  4 total, 0
  children   Arrival/Departure:  Oct 9=
  ,
  2010 - Oct 13, 2010 - Oct 13, 2010</p>
</blockquote>
<p>Is there a way to remove these encoding characters?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could/should use the <a href="http://docs.python.org/library/email.parser.html#email.parser.FeedParser" rel="noreferrer"><code>email.parser</code></a> module to decode mail messages, for example (quick and dirty example!):</p>
<pre><code>from email.parser import FeedParser
f = FeedParser()
f.feed("&lt;insert mail message here, including all headers&gt;")
rootMessage = f.close()

# Now you can access the message and its submessages (if it's multipart)
print rootMessage.is_multipart()

# Or check for errors
print rootMessage.defects

# If it's a multipart message, you can get the first submessage and then its payload
# (i.e. content) like so:
rootMessage.get_payload(0).get_payload(decode=True)
</code></pre>
<p>Using the "decode" parameter of <a href="http://docs.python.org/library/email.message.html#email.message.Message.get_payload" rel="noreferrer"><code>Message.get_payload</code></a>, the module automatically decodes the content, depending on its encoding (e.g. quoted printables as in your question).</p>
</div>
<div class="post-text" itemprop="text">
<p>That's known as quoted-printable encoding. You probably want to use something like <code>quopri.decodestring</code> - <a href="http://docs.python.org/library/quopri.html" rel="nofollow">http://docs.python.org/library/quopri.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using Python3.6 or later, you can use the <a href="https://docs.python.org/3/library/email.message.html#email.message.EmailMessage.get_content" rel="nofollow noreferrer"><code>email.message.Message.get_content()</code></a> method to decode the text automatically.  This method supersedes <code>get_payload()</code>, though <code>get_payload()</code> is still available.</p>
<p>Say you have a string <code>s</code> containing this email message (based on the <a href="https://docs.python.org/3.6/library/email.examples.html#email-examples" rel="nofollow noreferrer">examples</a> in the docs):</p>
<pre><code>Subject: Ayons asperges pour le =?utf-8?q?d=C3=A9jeuner?=
From: =?utf-8?q?Pep=C3=A9?= Le Pew &lt;pepe@example.com&gt;
To: Penelope Pussycat &lt;penelope@example.com&gt;,
 Fabrette Pussycat &lt;fabrette@example.com&gt;
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0

    Salut!

    Cela ressemble =C3=A0 un excellent recipie[1] d=C3=A9jeuner.

    [1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718

    --Pep=C3=A9
   =20
</code></pre>
<p>Non-ascii characters in the string have been encoded with the <code>quoted-printable</code> encoding, as specified in the <code>Content-Transfer-Encoding</code> header.</p>
<p>Create an email object:</p>
<pre><code>import email
from email import policy

msg = email.message_from_string(s, policy=policy.default)
</code></pre>
<p>Setting the policy is required here; otherwise <a href="https://docs.python.org/3/library/email.policy.html#email.policy.Compat32" rel="nofollow noreferrer"><code>policy.compat32</code></a> is used, which returns a legacy Message instance that doesn't have the get_content method.  <a href="https://docs.python.org/3/library/email.policy.html#email.policy.default" rel="nofollow noreferrer"><code>policy.default</code></a> will eventually become the default policy, but as of Python3.7 it's still <code>policy.compat32</code>.</p>
<p>The <code>get_content()</code> method handles decoding automatically:</p>
<pre><code>print(msg.get_content())

Salut!

Cela ressemble à un excellent recipie[1] déjeuner.

[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718

--Pepé
</code></pre>
<p>If you have a multipart message, <code>get_content()</code> needs to be called on the individual parts, like this:</p>
<pre><code>for part in message.iter_parts():
    print(part.get_content())
</code></pre>
</div>
<span class="comment-copy">Yeah... I thought it put those where there's a line break to wrap lines. Should be a lib to decode it properly.</span>
<span class="comment-copy">decode=True won't work when the charset is us-ascii.</span>
