<div class="post-text" itemprop="text">
<p>Is there some way in Python to capture <code>KeyboardInterrupt</code> event without putting all the code inside a <code>try</code>-<code>except</code> statement?</p>
<p>I want to cleanly exit without trace if user presses <kbd><strong>Ctrl</strong></kbd>+<kbd><strong>C</strong></kbd>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can install an interrupt handler using the module <a href="https://docs.python.org/3/library/signal.html" rel="nofollow noreferrer">signal</a>, and wait forever using a <a href="https://docs.python.org/3/library/threading.html#threading.Event" rel="nofollow noreferrer">threading.Event</a>:</p>
<pre><code>import signal
import sys
import time
import threading

def signal_handler(signal, frame):
    print('You pressed Ctrl+C!')
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
print('Press Ctrl+C')
forever = threading.Event()
forever.wait()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all you want is to not show the traceback, make your code like this:</p>
<pre><code>## all your app logic here
def main():
   ## whatever your app does.


if __name__ == "__main__":
   try:
      main()
   except KeyboardInterrupt:
      # do nothing here
      pass
</code></pre>
<p>(Yes, I know that this doesn't directly answer the question, but it's not really clear why needing a try/except block is objectionable -- maybe this makes it less annoying to the OP)</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative to setting your own signal handler is to use a context-manager to catch the exception and ignore it:</p>
<pre><code>&gt;&gt;&gt; class CleanExit(object):
...     def __enter__(self):
...             return self
...     def __exit__(self, exc_type, exc_value, exc_tb):
...             if exc_type is KeyboardInterrupt:
...                     return True
...             return exc_type is None
... 
&gt;&gt;&gt; with CleanExit():
...     input()    #just to test it
... 
&gt;&gt;&gt;
</code></pre>
<p>This removes the <code>try</code>-<code>except</code> block while preserving some explicit mention of what is going on.</p>
<p>This also allows you to ignore the interrupt only in some portions of your code without having to set and reset again the signal handlers everytime.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an old question but I came here first and then discovered the <code>atexit</code> module. I do not know about its cross-platform track record or a full list of caveats yet, but so far it is exactly what I was looking for in trying to handle post-<code>KeyboardInterrupt</code> cleanup on Linux. Just wanted to throw in another way of approaching the problem.</p>
<p>I want to do post-exit clean-up in the context of Fabric operations, so wrapping everything in <code>try</code>/<code>except</code> wasn't an option for me either. I feel like <code>atexit</code> may be a good fit in such a situation, where your code is not at the top level of control flow.</p>
<p><code>atexit</code> is very capable and readable out of the box, for example:</p>
<pre><code>import atexit

def goodbye():
    print "You are now leaving the Python sector."

atexit.register(goodbye)
</code></pre>
<p>You can also use it as a decorator (as of 2.6; this example is from the docs):</p>
<pre><code>import atexit

@atexit.register
def goodbye():
    print "You are now leaving the Python sector."
</code></pre>
<p>If you wanted to make it specific to <code>KeyboardInterrupt</code> only, another person's answer to this question is probably better.</p>
<p>But note that the <code>atexit</code> module is only ~70 lines of code and it would not be hard to create a similar version that treats exceptions differently, for example passing the exceptions as arguments to the callback functions. (The limitation of <code>atexit</code> that would warrant a modified version: currently I can't conceive of a way for the exit-callback-functions to know about the exceptions; the <code>atexit</code> handler catches the exception, calls your callback(s), then re-raises that exception. But you could do this differently.)</p>
<p>For more info see:</p>
<ul>
<li><a href="http://docs.python.org/2/library/atexit.html" rel="noreferrer">Official documentation on <code>atexit</code></a></li>
<li>The <a href="http://pymotw.com/2/atexit/" rel="noreferrer">Python Module of the Week post</a>, a good intro</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can prevent printing a stack trace for <code>KeyboardInterrupt</code>, without <code>try: ... except KeyboardInterrupt: pass</code> (the most obvious and propably "best" solution, but you already know it and asked for something else) by replacing <a href="http://docs.python.org/library/sys.html#sys.excepthook" rel="nofollow"><code>sys.excepthook</code></a>. Something like</p>
<pre><code>def custom_excepthook(type, value, traceback):
    if type is KeyboardInterrupt:
        return # do nothing
    else:
        sys.__excepthook__(type, value, traceback)
</code></pre>
</div>
<span class="comment-copy">Note that there are some platform-specific issues with the signal module -- shouldn't affect this poster, but "On Windows, signal() can only be called with SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, or SIGTERM. A ValueError will be raised in any other case."</span>
<span class="comment-copy">Works well with threads, too. I hope you don't ever do <code>while True: continue</code>, though. (In that style, <code>while True: pass</code> would be neater, anyway.) That'd be very wasteful; try something like <code>while True: time.sleep(60 * 60 * 24)</code> (sleeping for a day at a time is an entirely arbitrary figure).</span>
<span class="comment-copy">If you're using Chris Morgan's suggestion of using <code>time</code> (as you should), don't forget to <code>import time</code> :)</span>
<span class="comment-copy">Calling sys.exit(0) triggers a SystemExit exception for me.  You can make it work nicely if you use it in combination with this: <a href="http://stackoverflow.com/a/13723190/353094">stackoverflow.com/a/13723190/353094</a></span>
<span class="comment-copy">You can use signal.pause() instead of sleeping repeatedly</span>
<span class="comment-copy">For some reason, this doesn't always work for me.  <code>signal.signal( signal.SIGINT, lambda s, f : sys.exit(0))</code> always does.</span>
<span class="comment-copy">This doesn't always work with things such as pygtk which use threads. Sometimes ^C will just kill the current thread instead of the entire process, so the exception will only propagate through that thread.</span>
<span class="comment-copy">There's another SO question specifically about Ctrl+C with pygtk: <a href="http://stackoverflow.com/questions/16410852/keyboard-interrupt-with-with-python-gtk" title="keyboard interrupt with with python gtk">stackoverflow.com/questions/16410852/…</a></span>
<span class="comment-copy">nice, this solution does seem a bit more direct in expressing the purpose rather than dealing with signals.</span>
<span class="comment-copy">Using multiprocessing library, I'm not sure on which object I should add those methods .. any clue ?</span>
<span class="comment-copy">@Stéphane What do you mean? When dealing with multiprocessing you will have to deal with the signal in both the parent and child processes, since it might be triggered in both. It really depends on what you are doing and how your software will be used.</span>
<span class="comment-copy">atexit doesnt' work for KeyboardInterrupt (python 3.7)</span>
<span class="comment-copy">I want clean exit without trace if user press ctrl-c</span>
<span class="comment-copy">catched ==&gt; caught</span>
<span class="comment-copy">This is not true at all. The KeyboardInterrupt exception is created during an interrupt handler. The default handler for SIGINT raises the  KeyboardInterrupt so if you didn't want that behavior all you would have to do is provide a different signal handler for SIGINT. Your are correct in that exceptions can only be handled in a try/except however in this case you can keep the exception from ever being raised in the first place.</span>
<span class="comment-copy">Yeah, I learned that about three minutes after posting, when kotlinski's answer rolled in ;)</span>
