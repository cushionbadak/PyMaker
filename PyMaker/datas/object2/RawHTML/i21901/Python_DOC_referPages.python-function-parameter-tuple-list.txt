<div class="post-text" itemprop="text">
<p>My function expects a list or a tuple as a parameter. It doesn't really care which it is, all it does is pass it to another function that accepts either a list or tuple:</p>
<pre><code>def func(arg): # arg is tuple or list
  another_func(x)
  # do other stuff here
</code></pre>
<p>Now I need to modify the function slightly, to process an additional element:</p>
<pre><code>def func(arg): #arg is tuple or list
  another_func(x + ['a'])
  # etc
</code></pre>
<p>Unfortunately this is not going to work: if arg is tuple, I must say <code>x + ('a',)</code>.</p>
<p>Obviously, I can make it work by coercing arg to list. But it isn't neat.</p>
<p>Is there a better way of doing that? I can't force callers to always pass a tuple, of course, since it simply shifts to work to them.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>another_func</code> just wants a iterable you can pass <code>itertools.chain(x,'a')</code> to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about changing the other function to accept a list of params instead ?</p>
<pre><code>def func(arg): # arg is tuple or list
  another_func('a', *x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>how about:</p>
<pre><code>l = ['a']
l.extend(x)
</code></pre>
<p>Edit:
Re-reading question, I think this is more what you want (the use of <code>arg</code> and <code>x</code> was a little confusing):</p>
<pre><code>tuple(arg) + ('a',)
</code></pre>
<p>As others have said, this is probably not the most efficient way, but it is very clear. If your tuples/lists are small, I might use this over less clear solutions as the performance hit will be negligible. If your lists are large, use the more efficient solutions.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def f(*args):
    print args

def a(*args):
    k = list(args)
    k.append('a')
    f(*k)

a(1, 2, 3)
</code></pre>
<p>Output:</p>
<pre><code>(1, 2, 3, 'a')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If an iterable is enough you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a>, but be aware that if function <code>A</code> (the first one called), also iterates over the iterable after calling <code>B</code>, then you might have problems since iterables cannot be rewinded. In this case you should opt for a sequence or use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>iterable.tee</code></a> to make a copy of the iterable:</p>
<pre><code>import itertools as it

def A(iterable):
    iterable, backup = it.tee(iterable)
    res = B(it.chain(iterable, 'a'))
    #do something with res
    for elem in backup:
        #do something with elem

def B(iterable):
   for elem in iterable:
       #do something with elem
</code></pre>
<p>Even though <code>itertools.tee</code> isn't really that efficient if <code>B</code> consumes <em>all</em> or <em>most</em> of the iterable, at that point it's simpler to just convert <code>iterable</code> to a <code>tuple</code> or a <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>My suggestion:</p>
<pre><code>def foo(t):
    bar(list(t) + [other])
</code></pre>
<p>This is not very efficient though, you'd be better off passing around mutable things if you're going to be, well, mutating them.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the type of the iterable passed to the first function to construct what you pass to the second:</p>
<pre><code>from itertools import chain

def func(iterable):
    it = iter(iterable)
    another_func(type(iterable)(chain(it, ('a',))))

def another_func(arg):
    print arg

func((1,2))
# (1, 2, 'a')
func([1,2])
# [1, 2, 'a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have your function accept any iterable.  Then use <code>itertools.chain</code> to add whatever sequence you want to the iterable.</p>
<pre><code>from itertools import chain

def func(iterable):
    another_func(chain(iterable, ('a',)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd say Santiago Lezica's answer of doing</p>
<pre><code>def foo(t):
    bar(list(t) + [other])
</code></pre>
<p>is the best because it is the simplest. (no need to import itertools stuff and use much less readable chain calls). But only use it if you expect t to be small. If t can be large you should use one of the other solutions. </p>
</div>
<span class="comment-copy">If the other function accepts either than I would send it a tuple as it will be faster for you to work with. Then what's not neat about <code>tuple(x) + ('a',)</code>?</span>
<span class="comment-copy">Are tuples faster in the implementation?</span>
<span class="comment-copy">constructing a tuple from string and numeric literals is faster than constructing a list. More importantly, <code>tuple(x)</code> just returns <code>x</code> if it's already a tuple whereas <code>list(x)</code> copies <code>x</code> even if it's already a list. So by using a tuple, you cut most of the work out for half of your input cases.</span>
<span class="comment-copy">+1: good point about tuple vs list.</span>
<span class="comment-copy">+1 I like this but is it fast?</span>
<span class="comment-copy">@max  No copy is made, so it is very fast.  It's probably the most efficient Python solution.</span>
<span class="comment-copy">What about when another_func needs several list arguments that are affected by the same issue, or if it already has an (unrelated) *x parameter?</span>
<span class="comment-copy">+0: good but unsure if other func can be changed</span>
<span class="comment-copy">@max: The answer's the same.  Fix the other function.</span>
<span class="comment-copy">something must be changed in the function's interface</span>
<span class="comment-copy">@max: A tuple with an indefinite number of elements is a design error.  Tuples are usually used for a definite number of elements; the number of elements is usually fixed by the problem domain (x,y) coordinates, (r,g,b) colors, etc.  A "variable-sized" tuple is simply inappropriate.  It should be a list.  Fix the function to work with a list.  Fix the functions.  "variable length" or "indefinite length" tuples are an error.  Don't support them.  Fix them.</span>
<span class="comment-copy"><code>extend</code> returns <code>None</code>, as it mutates the list.</span>
<span class="comment-copy">+1, simple and clean</span>
<span class="comment-copy">@delnan: what do you mean?</span>
<span class="comment-copy">@max I originally had "['a'].extend(x)" which is a largely useless statement, because extend returns None, as delnan pointed out</span>
<span class="comment-copy">hmm <code>f(*(tuple(args)+('a',))</code> is better</span>
<span class="comment-copy">+1 for the clarification about rewinding of iterators. In my case, iterable is enough; I guess for the sequence case I'll just coerce to tuple as suggested by @aaronasterling</span>
<span class="comment-copy">Could you clarify please? Why is this not efficient?</span>
<span class="comment-copy">@max  It's not as efficient because it copies an entire list just to add a single item.</span>
