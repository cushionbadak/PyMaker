<div class="post-text" itemprop="text">
<p>When implementing a class with multiple properties (like in the toy example below), what is the best way to handle hashing?</p>
<p>I guess that the <code>__eq__</code> and <code>__hash__</code> should be consistent, but how to implement a proper hash function that is capable of handling all the properties?</p>
<pre><code>class AClass:
  def __init__(self):
      self.a = None
      self.b = None

  def __eq__(self, other):
      return other and self.a == other.a and self.b == other.b

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
      return hash((self.a, self.b))
</code></pre>
<p>I read on <a href="https://stackoverflow.com/questions/654128/python-hash-functions">this question</a> that tuples are hashable, so I was wondering if something like the example above was sensible. Is it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__hash__</code> should return the same value for objects that are equal. It also shouldn't change over the lifetime of the object; generally you only implement it for immutable objects.</p>
<p>A trivial implementation would be to just <code>return 0</code>. This is always correct, but performs badly.</p>
<p>Your solution, returning the hash of a tuple of properties, is good. But note that you don't need to list all properties that you compare in <code>__eq__</code> in the tuple. If some property usually has the same value for inequal objects, just leave it out. Don't make the hash computation any more expensive than it needs to be.</p>
<p>Edit: I would recommend against using xor to mix hashes in general. When two different properties have the same value, they will have the same hash, and with xor these will cancel eachother out. Tuples use a more complex calculation to mix hashes, see <code>tuplehash</code> in <a href="http://hg.python.org/cpython/file/dcced3bd22fe/Objects/tupleobject.c" rel="noreferrer"><code>tupleobject.c</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's dangerous to write</p>
<pre><code>def __eq__(self, other):
  return other and self.a == other.a and self.b == other.b
</code></pre>
<p>because if your rhs (i.e., <code>other</code>) object evaluates to boolean False, it will never compare as equal to anything!</p>
<p>In addition, you might want to double check if <code>other</code> belongs to the class or subclass of <code>AClass</code>. If it doesn't, you'll either get exception <code>AttributeError</code> or a false positive (if the other class happens to have the same-named attributes with matching values). So I would recommend to rewrite <code>__eq__</code> as:</p>
<pre><code>def __eq__(self, other):
  return isinstance(other, self.__class__) and self.a == other.a and self.b == other.b
</code></pre>
<p>If by any chance you want an unusually flexible comparison, which compares across unrelated classes as long as attributes match by name, you'd still want to at least avoid <code>AttributeError</code> and check that <code>other</code> doesn't have any additional attributes. How you do it depends on the situation (since there's no standard way to find all attributes of an object).</p>
</div>
<div class="post-text" itemprop="text">
<p>Documentation for <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="noreferrer"><code>object.__hash__(self)</code></a></p>
<blockquote>
<p>The only required property is that objects which compare equal have the same hash value; it is advised to somehow mix together (e.g. using exclusive or) the hash values for the components of the object that also play a part in comparison of objects.</p>
</blockquote>
<pre><code>def __hash__(self):
    return hash(self.a) ^ hash(self.b)
</code></pre>
</div>
<span class="comment-copy">Just make sure to use <code>hash()</code> on a tuple with exactly the elements that are compared in <code>__eq__()</code> and friends (exactly as you did) and you're good to go.</span>
<span class="comment-copy">Definite duplicate of <a href="http://stackoverflow.com/questions/2909106/whats-a-correct-and-good-way-to-implement-hash">What's a correct and good way to implement __hash__()?</a></span>
<span class="comment-copy">As you said hash functions usually only make sense for immutable objects. Hence it is possible to calculate the hash-value once in <code>__init__</code>.</span>
<span class="comment-copy">+1 for the <code>return 0</code> hash function - I've always thought that anything else is premature optimisation :-). (I'm only half kidding).</span>
<span class="comment-copy">@Bj√∂rnPollex Rather than doing it in <code>__init__</code>, you can just cache the value in <code>__hash__</code>. That way if <code>__hash__</code> is never called, you didn't waste either time or memory. I assume checking whether the value has been already cached isn't expensive is it? (Not sure if it's best through exception or explicit <code>if</code>).</span>
<span class="comment-copy">It's unfortunate that Python does not make a <code>combine_hashes</code> function available.</span>
<span class="comment-copy">It's not implemented in things like dict or list, the justification being that changing the hash of an object that already belongs to, e.g., a set wreaks havoc on the set's internal data structures.</span>
<span class="comment-copy">Useful info, but unrelated to the primary question about hashing.</span>
<span class="comment-copy">It will work, but it's bad that if you exchange <code>self.a</code> and <code>self.b</code> then you'll get the same hash while it will be the other "object".</span>
<span class="comment-copy">"somehow mix together (e.g. using exclusive or" is a pretty flexible set of requirements.  If it actually matters, then <code>(hash(self.a)&lt;&lt;1) ^ hash(self.b)</code> might be better.  There's no general answer, just a general guideline that has to be modified based on the specific application.</span>
<span class="comment-copy">why not just hash a tuple value? hash((self.a, self.b))</span>
<span class="comment-copy">Note that (fortunately) the suggestion to use xor is no longer present in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">Python 3</a> or <a href="https://docs.python.org/2/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">Python 2</a> docs.</span>
<span class="comment-copy">For those whom are interested, here is the bug that led to removal of XOR recommendation: <a href="https://bugs.python.org/issue28383" rel="nofollow noreferrer">bugs.python.org/issue28383</a></span>
