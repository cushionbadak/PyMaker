<div class="post-text" itemprop="text">
<p>How do I serialize a Python dictionary into a string, and then back to a dictionary? The dictionary will have lists and other dictionaries inside it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on what you're wanting to use it for. If you're just trying to save it, you should use <a href="https://docs.python.org/3/library/pickle.html" rel="noreferrer"><code>pickle</code></a> (or, if youâ€™re using CPython 2.x, <a href="https://docs.python.org/2/library/pickle.html#module-cPickle" rel="noreferrer"><code>cPickle</code></a>, which is faster).</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.dumps({'foo': 'bar'})
b'\x80\x03}q\x00X\x03\x00\x00\x00fooq\x01X\x03\x00\x00\x00barq\x02s.'
&gt;&gt;&gt; pickle.loads(_)
{'foo': 'bar'}
</code></pre>
<p>If you want it to be readable, you could use <a href="https://docs.python.org/3/library/json.html" rel="noreferrer"><code>json</code></a>:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.dumps({'foo': 'bar'})
'{"foo": "bar"}'
&gt;&gt;&gt; json.loads(_)
{'foo': 'bar'}
</code></pre>
<p><code>json</code> is, however, very limited in what it will support, while <code>pickle</code> can be used for arbitrary objects (if it doesn't work automatically, the class can define <code>__getstate__</code> to specify precisely how it should be pickled).</p>
<pre><code>&gt;&gt;&gt; pickle.dumps(object())
b'\x80\x03cbuiltins\nobject\nq\x00)\x81q\x01.'
&gt;&gt;&gt; json.dumps(object())
Traceback (most recent call last):
  ...
TypeError: &lt;object object at 0x7fa0348230c0&gt; is not JSON serializable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use Python's <a href="http://docs.python.org/library/json.html" rel="noreferrer">json</a> module, or <a href="http://pypi.python.org/pypi/simplejson/" rel="noreferrer">simplejson</a> if you don't have python 2.6 or higher.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>If</em> you fully trust the string and don't care about <a href="https://www.owasp.org/index.php/Direct_Dynamic_Code_Evaluation_('Eval_Injection')" rel="noreferrer">python injection attacks</a> then this is very simple solution:</p>
<pre><code>d = { 'method' : "eval", 'safe' : False, 'guarantees' : None }
s = str(d)
d2 = eval(s)
for k in d2:
    print k+"="+d2[k]
</code></pre>
<p>If you're more safety conscious then <a href="https://docs.python.org/2/library/ast.html" rel="noreferrer"><code>ast.literal_eval</code></a> is a better bet.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pickle is great but I think it's worth mentioning <code>literal_eval</code> from the <code>ast</code> module for an even lighter weight solution if you're only serializing basic python types. It's basically a "safe" version of the notorious <code>eval</code> function that only allows evaluation of basic python types as opposed to any valid python code.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d[0] = range(10)
&gt;&gt;&gt; d['1'] = {}
&gt;&gt;&gt; d['1'][0] = range(10)
&gt;&gt;&gt; d['1'][1] = 'hello'
&gt;&gt;&gt; data_string = str(d)
&gt;&gt;&gt; print data_string
{0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], '1': {0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 1: 'hello'}}

&gt;&gt;&gt; from ast import literal_eval
&gt;&gt;&gt; d == literal_eval(data_string)
True
</code></pre>
<p>One benefit is that the serialized data is just python code, so it's very human friendly. Compare it to what you would get with <code>pickle.dumps</code>:</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; print pickle.dumps(d)
(dp0
I0
(lp1
I0
aI1
aI2
aI3
aI4
aI5
aI6
aI7
aI8
aI9
asS'1'
p2
(dp3
I0
(lp4
I0
aI1
aI2
aI3
aI4
aI5
aI6
aI7
aI8
aI9
asI1
S'hello'
p5
ss.
</code></pre>
<p>The downside is that as soon as the the data includes a type that is not supported by <code>literal_ast</code> you'll have to transition to something else like pickling.</p>
</div>
<div class="post-text" itemprop="text">
<p>One thing <code>json</code> cannot do is <code>dict</code> indexed with numerals. The following snippet</p>
<pre><code>import json
dictionary = dict({0:0, 1:5, 2:10})
serialized = json.dumps(dictionary)
unpacked   = json.loads(serialized)
print unpacked[0]
</code></pre>
<p>will throw </p>
<pre><code>KeyError: 0
</code></pre>
<p>Because keys are converted to strings. <code>cPickle</code> preserves the numeric type and the unpacked <code>dict</code> can be used right away.</p>
</div>
<div class="post-text" itemprop="text">
<p>While not strictly serialization, json may be reasonable approach here. That will handled nested dicts and lists, and data as long as your data is "simple": strings, and basic numeric types. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>pyyaml</strong> should also be mentioned here. It is both human readable and can serialize any python object.<br/>
pyyaml is hosted here:<br/>
<a href="https://bitbucket.org/xi/pyyaml" rel="nofollow">https://bitbucket.org/xi/pyyaml</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you are trying to only serialize then pprint may also be a good option. It requires the object to be serialized and a file stream.</p>
<p>Here's some code:</p>
<pre><code>from pprint import pprint
my_dict = {1:'a',2:'b'}
with open('test_results.txt','wb') as f:
    pprint(my_dict,f)
</code></pre>
<p>I am not sure if we can deserialize easily. I was using json to serialize and deserialze earlier which works correctly in most cases.</p>
<pre><code>f.write(json.dumps(my_dict, sort_keys = True, indent = 2, ensure_ascii=True))
</code></pre>
<p>However, in one particular case, there were some errors writing non-unicode data to json.</p>
</div>
<span class="comment-copy">Are you familiar with <code>pickle</code>?</span>
<span class="comment-copy">nope, whats that?</span>
<span class="comment-copy">a module that is part of the Python Standard Library</span>
<span class="comment-copy">I wish I knew what on earth that -1 was for.</span>
<span class="comment-copy">I guess this -1 might be for not mentioning security problems inherent in pickling. See <a href="http://stackoverflow.com/questions/10282175/attacking-pythons-pickle" title="attacking pythons pickle">stackoverflow.com/questions/10282175/attacking-pythons-pickle</a></span>
<span class="comment-copy">It is worth mentioning that the cPickle part of the answer is not relevant for python 3.x. See <a href="https://docs.python.org/3.1/whatsnew/3.0.html#library-changes" rel="nofollow noreferrer">here</a> for the official explanation. In short, the accelerated C version of a package should be the default choice for any python module, and, if not available, the module itself falls back to the python implementation. This encapsulates the implementation from the user.  Quote: <code>In Python 3.0...  Users should always import the standard version, which attempts to import the accelerated version and falls back to the pure Python version.</code></span>
<span class="comment-copy">@Ori: answer updated to target Python 3.</span>
<span class="comment-copy">+1: json is way better than pickle and can be used in the same way: <code>json.dumps(mydict)</code> and <code>json.loads(mystring)</code></span>
<span class="comment-copy">but json can only do strings, numbers, lists, and dictionaries while pickle can do any python type but json is far more portable then pickle for the types it can do</span>
<span class="comment-copy">When you use <code>json.dumps()</code>, take care of some types (<code>False</code>, <code>True</code>, and <code>None</code>) because they  are not compatible with <code>json</code></span>
<span class="comment-copy">honestly this is the method I use all the time. thanks for sharing the safety tip. I use repr instead of str if the dictionary contains custom made objects that can be initialized by the repr string</span>
<span class="comment-copy">You should use <code>ast.literal_eval</code> by default. <code>eval</code> has zero added values and a big security issue.</span>
