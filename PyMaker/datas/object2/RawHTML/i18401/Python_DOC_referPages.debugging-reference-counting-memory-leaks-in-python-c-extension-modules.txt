<div class="post-text" itemprop="text">
<p>I'm trying to determine if there are any reference counting memory leaks in a Python C extension module. Consider this very simple test extension that leaks a <code>date</code> object:</p>
<pre><code>#include &lt;Python.h&gt;
#include &lt;datetime.h&gt;

static PyObject* memleak(PyObject *self, PyObject *args) {
    PyDate_FromDate(2000, 1, 1); /* deliberately create a memory leak */
    Py_RETURN_NONE;
}

static PyMethodDef memleak_methods[] = {
    {"memleak",  memleak, METH_NOARGS, "Leak some memory"},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

PyMODINIT_FUNC initmemleak(void) {
    PyDateTime_IMPORT;
    Py_InitModule("memleak", memleak_methods);
}
</code></pre>
<p>PyDate_FromDate creates a new reference (i.e. internally calls Py_INCREF) and since I never call Py_DECREF, this object will never get garbage collected.</p>
<p>However, when I call this function, the number of objects being tracked by the garbage collector doesn't seem to change before and after the function call:</p>
<pre><code>Python 2.7.3 (default, Apr 10 2013, 05:13:16)
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from memleak import memleak
&gt;&gt;&gt; import gc
&gt;&gt;&gt; gc.disable()
&gt;&gt;&gt; gc.collect()
0
&gt;&gt;&gt; len(gc.get_objects()) # get object count before
3581
&gt;&gt;&gt; memleak()
&gt;&gt;&gt; gc.collect()
0
&gt;&gt;&gt; len(gc.get_objects()) # get object count after
3581
</code></pre>
<p>And I can't seem to find the leaked <code>date</code> object at all in the list of objects returned by <code>gc.get_objects()</code>:</p>
<pre><code>&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; print [obj for obj in gc.get_objects() if isinstance(obj, date)]
[]
</code></pre>
<p>Am I missing something here about how <code>gc.get_objects()</code> works? Is there another way to demonstrate that the memleak() function has a memory leak?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the documentation of the <a href="http://docs.python.org/3.3/library/gc.html" rel="nofollow noreferrer"><code>gc</code></a> module:</p>
<blockquote>
<p>Since the collector <strong>supplements</strong> the reference counting already used
  in Python, you can disable the collector if you are sure your program
  does not create <strong>reference cycles</strong>.</p>
</blockquote>
<p>So the <code>gc</code> module is used <strong>only</strong> to deal with references cycles. In your case there is no cycle, hence the <code>date</code> object isn't returned by the <code>get_objects</code> function.</p>
<p>In fact old versions of python did not have the garbage collector at all, they only used reference-counting. The garbage collector was introduced to avoid creating memory leaks with reference-cycles(since this can be done from the python side pretty easily, and you do not want that a pure-python programs create memory leaks).</p>
<p>To see that kind of memory leak you should call the <code>memleak</code> function in a loop and see that the memory used increases (slowly in your case).</p>
<p>There are also some 3rd party libraries that can be used to profile memory usage, see the <a href="https://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended">Which Python memory profiler is recommended?</a> question on SO.</p>
</div>
<div class="post-text" itemprop="text">
<p>For this type of debugging, you want to use an instance of Python that is compiled with the <code>--with-pydebug</code> option. One of the features enabled by debug mode is tracking the total number of reference counts via a new function in the <code>sys</code> module - <code>gettotalrefcount()</code>.</p>
<p>For more information, see <a href="http://docs.python.org/3/c-api/intro.html#debugging-builds" rel="nofollow">http://docs.python.org/3/c-api/intro.html#debugging-builds</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#include &lt;Python.h&gt;
#include &lt;datetime.h&gt;

static PyObject* memleak(PyObject *self, PyObject *args) {
    PyObject* date=PyDate_FromDate(2000, 1, 1); /* deliberately create a memory leak */
    Py_DECREF(date);
    Py_RETURN_NONE;
}

static PyMethodDef memleak_methods[] = {
    {"memleak",  memleak, METH_NOARGS, "Leak some memory"},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

PyMODINIT_FUNC initmemleak(void) {
    PyDateTime_IMPORT;
    Py_InitModule("memleak", memleak_methods);
}
</code></pre>
<p>Solve your problem Py_DECREF(date);</p>
</div>
<span class="comment-copy">Thanks, that makes sense now. I ended up <a href="http://stackoverflow.com/a/7669482/2113516">using the resource module</a> to measure the growth in memory usage in order to test specific functions for memory leaks.</span>
<span class="comment-copy">The memory leak is intentional. The question is about how to detect memory leaks.</span>
