<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pi
3.141592653589793
&gt;&gt;&gt; math.pi = 3
&gt;&gt;&gt; math.pi
3
&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pi
3
</code></pre>
<p><strong>Initial question: Why can't I get <code>math.pi</code> back?</strong> </p>
<p>I thought <code>import</code> would import all the defined variables and functions to the current scope. And if a variable name already exists in current scope, then it would replace it.  </p>
<p>Yes, it does replace it:</p>
<pre><code>&gt;&gt;&gt; pi = 3
&gt;&gt;&gt; from math import *
&gt;&gt;&gt; pi
3.141592653589793
</code></pre>
<p>Then I thought maybe the <code>math.pi = 3</code> assignment actually changed the property in the <code>math class</code>(or is it <code>math module</code>?), which the <code>import math</code> imported.  </p>
<p>I was right:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pi
3.141592653589793
&gt;&gt;&gt; math.pi = 3
&gt;&gt;&gt; from math import *
&gt;&gt;&gt; pi
3
</code></pre>
<p>So, it seems that:<br/>
If you do <code>import x</code>, then it imports <code>x</code> as a class-like thing. And if you make changes to x.property, the change would <strong>persist in the module so that every time you import it again, it's a modified version.</strong> </p>
<p><strong>Real question</strong>:  </p>
<ol>
<li>Why is <code>import</code> implemented this way? Why not let every <code>import math</code> import a fresh, unmodified copy of <code>math</code>? Why leave the imported <code>math</code> open to change?  </li>
<li>Is there any workaround to get <code>math.pi</code> back after doing <code>math.pi = 3</code> (except <code>math.pi = 3.141592653589793</code>, of course)?  </li>
<li>Originally I thought <code>import math</code> is preferred over <code>from math import *</code>. But this behaviour leaves me worrying someone else might be modifying my imported module if I do it this way...How should I do the <code>import</code>?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>A module may be imported many times. An <code>import</code> statement just loads the reference from <a href="http://docs.python.org/3/library/sys#sys.modules"><code>sys.modules</code></a>. If the <code>import</code> statement also reloaded the module from disk, it would be quite slow. Modifying a module like this is very unusual and is only done under rare, documented circumstances, so thereâ€™s no need to worry.</p>
<p>How to <a href="http://docs.python.org/3/library/imp#imp.reload">reload</a> a module:</p>
<pre><code>&gt;&gt;&gt; import imp
&gt;&gt;&gt; imp.reload(math)
&lt;module 'math' (built-in)&gt;
&gt;&gt;&gt; math.pi
3.141592653589793
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python only creates one copy of any given module. Importing a module repeatedly reuses the original. This is because if modules A and B imported C and D, which imported E and F, etc., C and D would get loaded twice, and E and F would get loaded 4 times, etc. With any but the most trivial of dependency graphs, you'd spend a few minutes loading redundant modules before running out of memory. Also, if A imported B and B imported A, you'd get stuck in a recursive loop and, again, run out of memory without doing anything useful.</p>
<p>The solution: <strong>Don't screw with the contents of other modules.</strong> If you do, that's an interpreter-wide change. There are occasionally situations where you'd want to do this, so Python lets you, but it's usually a bad idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>The import behavior is intended to allow modules to have state. For example, a module that runs initialization code may have all sorts of different behaviors based on what happens at init time (a good example is the os module, which transparently loads different versions of the path submodule depending on what OS you're on).  The usual behavior exists to allow lots of different code to access the module without re-running the initialization over and over. Moreover, modules function sort of like static classes in other languages - they can maintain state and are often used as an alternative to global variables: eg, you might use the locale module to set local culture variables (currency format, etc) -- calling <em>locale.setlocale</em> in one part of your code and <em>local.getlocale</em> in another is a nice alternative to making a global variable. </p>
<p>Your example, of course, points out the weakness. One of the classic python principes is </p>
<blockquote>
<p>We're all adults here</p>
</blockquote>
<p>The language does not provide much of the privacy management features you'd find in, say, Java or C# which let the author lock down the contents of a module or class. You can, if you're feeling malicious (or just suicidal) do exactly the sort of thing done in your example: change pi to equal 3, or turn a function into a variable, or all sorts of other nasty stuff. The language is not designed to make that hard -- it's up to coders to be responsible.</p>
<p>@Josh Lee's answer shows how to use reload, which is the correct way of refreshing a module to it's disk-based state.  The wisdom of using reload depends mostly on how much init code is in the module, and also on the web of other modules which import or are imported by the module in question.</p>
</div>
<span class="comment-copy">You may find Nick Coghlan's <a href="https://ncoghlan_devs-python-notes.readthedocs.org/en/latest/python_concepts/import_traps.html" rel="nofollow noreferrer">Traps for the Unwary</a> a good (related) read.</span>
<span class="comment-copy">@kojiro Thanks for the link!</span>
<span class="comment-copy"><code>imp.reload = lambda x: "Woops"</code></span>
<span class="comment-copy">@Josh <code>reload(imp)</code></span>
<span class="comment-copy">please don't tell people to reload modules. you really shouldn't ever need to</span>
<span class="comment-copy">@jterrace: what about when you're debugging a module which you're changing between runs in ipython?</span>
<span class="comment-copy">@octref: reload() should really only be used in interactive shell when you're modifying the source code of a module while issuing commands. If it's a running program, then you really shouldn't be using reload(). Instead, you should find and remove the offending module, or find a way to control its monkey patching behavior. The problem with reload() is that you can end up with multiple copies of the same variables/classes/methods that all works differently, incompatibly, and this will lead to all sorts of nightmare.</span>
<span class="comment-copy">Ahh I see how it works out... If I do a <code>from math import *</code> it doesn't leave a pointer to the module so that I can't modify the module...thanks!</span>
<span class="comment-copy">I don't understand your concern, octref, from your comments and question it seems that you assume you do the <code>import</code> for other coders to use.</span>
<span class="comment-copy">@justhalf I'm asking this out of my curiosity... And, what else are all those access modifiers in OOP languages made for?</span>
<span class="comment-copy">for Python, the OOP is only <i>by convention</i>. In Python there is no real access modifiers like in Java as some answers have highlighted. You can access every member of any module you imported, like you did. The convention is that the variables that should not be accessed from other module should be prepended with an underscore. So if you see a variable named <code>_vocabulary</code> in a module, that means the original writer doesn't want people to access that variable directly, but Python will still allow you to do that.</span>
<span class="comment-copy">@justhalf: neither is access modifier in Java actually enforced at the bytecode level; even with Java, reflection can be used to muck with private members.</span>
<span class="comment-copy">Well that's one of the reason I like Python over Java. I guess maybe the point of Java's access modifiers lies more in team working on the same projects (so that you force your teammates to follow your API, not messing up with your implementation...)</span>
<span class="comment-copy">absolutely - the whole access thing is designed for people working in the bowels of huge projects or corporations who will never meet or even hear of people using their stuff....</span>
