<div class="post-text" itemprop="text">
<p>I have a function in my C library, say <code>runsim()</code> which takes pointer to <code>struct repdata</code> as one of the arguments, where <code>struct repdata</code> is given by</p>
<pre><code>struct repdata {
    int *var1;
    int *var2;
    int *var3;
    char *var4;
    double *var5;
    double *var6;
    int *var7;
};
</code></pre>
<p>When using C exclusively, I initialize a variable of type <code>struct repdata</code> calling the function,</p>
<pre><code>struct repdata data;
void create_data_container(struct repdata *data, int len_data)
{

    data -&gt; var1 = malloc( sizeof(int) * len_data );
    data -&gt; var2 = malloc( sizeof(int) * len_data );
    data -&gt; var3 = malloc( sizeof(int) * len_data );
    data -&gt; var4 = malloc( sizeof(char) * len_data );
    data -&gt; var5 = malloc( sizeof(double) * len_data);
    data -&gt; var6 = malloc( sizeof(double) * len_data);
    data -&gt; var7 = malloc( sizeof(int) * len_data);
}
</code></pre>
<p>and then fill this struct as simulation proceeds. After I have written the data to a file, I free the memory using the standard</p>
<pre><code>free(data.var1);
free(data.var2);
.
.
.
free(data.var7);
</code></pre>
<p>I want to call the <code>runsim()</code> function from Python using Python Ctypes. For this I need to pass a pointer to a variable (that is equivalent to the type of <code>struct repdata</code>) as one of the <code>runsim()</code> arguments. Suppose that in Python I have defined an equivalent of <code>struct repdata</code> in the following manner.</p>
<pre><code>import ctypes as C

class Repdata(C.Structure):
    _fields_ = [
        ("var1", C.POINTER(C.c_int)),
        ("var2", C.POINTER(C.c_int)),
        ("var3", C.POINTER(C.c_int)),
        ("var4", C.POINTER(C.c_char)),
        ("var5", C.POINTER(C.c_double)),
        ("var6", C.POINTER(C.c_double)),
        ("var7", C.POINTER(C.c_int)),
    ]
</code></pre>
<p>What is the equivalent of <code>create_data_container</code> function shown above on the Python side? I want to initialize an instance of Repdata which can be passed to C code and has sufficient memory for storing the replication data. And, once simulation is completed, how do I free the memory from Python?</p>
<p>I am using Ubuntu Linux 12.04.</p>
<p>Thanks in advance for your help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can allocate buffers using <code>ctypes</code> and assign them to the pointers.  Once the Python ctypes objects have no references they will be freed automatically.  Here's a simple example (with a Windows DLL...don't have a Linux machine handy, but the idea is the same) and a Python wrapper.</p>
<p><a href="http://docs.python.org/3/library/ctypes.html?highlight=create_string_buffer#ctypes.create_string_buffer" rel="noreferrer"><code>create_string_buffer</code></a> allocates a writable buffer that can be passed from Python to C that <code>ctypes</code> will marshal as a <code>char*</code>.</p>
<p>You can also create writable arrays of <code>ctypes</code> types with the syntax:</p>
<pre><code>variable_name = (ctypes_type * length)(initial_values)
</code></pre>
<h3>x.h</h3>
<pre><code>#ifdef DLL_EXPORTS
#define DLL_API __declspec(dllexport)
#else
#define DLL_API __declspec(dllimport)
#endif

struct example {
    char* data;
    int len;          // of data buffer
    double* doubles;
    int count;        // of doubles
};

DLL_API void func(struct example* p);
</code></pre>
<h3>x.c</h3>
<pre><code>#include &lt;stdio.h&gt;
#define DLL_EXPORTS
#include "x.h"

void func(struct example* p)
{
    int i;
    strcpy_s(p-&gt;data,p-&gt;len,"hello, world!");
    for(i = 0; i &lt; p-&gt;count; i++)
        p-&gt;doubles[i] = 1.1 * (i + 1);
}
</code></pre>
<h3>x.py</h3>
<pre><code>import ctypes

class Example(ctypes.Structure):

    _fields_ = [
        ('data',ctypes.POINTER(ctypes.c_char)),
        ('len',ctypes.c_int),
        ('doubles',ctypes.POINTER(ctypes.c_double)),
        ('count',ctypes.c_int)]

    def __init__(self,length,count):
        self.data = ctypes.cast(ctypes.create_string_buffer(length),ctypes.POINTER(ctypes.c_char))
        self.len = length
        self.doubles = (ctypes.c_double * count)()
        self.count = count

    def __repr__(self):
        return 'Example({},[{}])'.format(
            ctypes.string_at(self.data),
            ','.join(str(self.doubles[i]) for i in range(self.count)))

class Dll:

    def __init__(self):
        self.dll = ctypes.CDLL('x')
        self.dll.func.argtypes = [ctypes.POINTER(Example)]
        self.dll.func.restype = None

    def func(self,ex):
        self.dll.func(ctypes.byref(ex))

d = Dll()
e = Example(20,5)
print('before:',e)
d.func(e)
print ('after:',e)
</code></pre>
<h3>Output</h3>
<pre><code>before: Example(b'',[0.0,0.0,0.0,0.0,0.0])
after: Example(b'hello, world!',[1.1,2.2,3.3000000000000003,4.4,5.5])
</code></pre>
</div>
<span class="comment-copy">I may be wrong, but this appears to be different from what I am looking for. In my problem the data is generated in the C code and I want to pass a container to the C code from Python which can be filled with that data. In the answer here the data is being passed from Python to C.</span>
<span class="comment-copy">@Curious2learn, The buffers are allocated but don't have to be initialized on the Python side.  You can fill them out on the C side as well and the data will appear on the Python side.  I'll change the above to demonstrate that instead.</span>
<span class="comment-copy">@MarkTolonen Coming across your answer: could I "inject" <code>create_string_buffer</code> as a <code>malloc</code> replacement into my c-library via <code>CFUNCTYPE(c_void_p, c_size_t)(create_string_buffer)</code>? I'd like to avoid "asking" my c library how much memory it needs all the time...</span>
