<div class="post-text" itemprop="text">
<p>I need to create a program that finds the base and exponent of a single number given that the exponent is less than 7 and greater than 1. I am using python 2.7.</p>
<p>My code is as follows:</p>
<pre><code>def determineRootAndPower(inputInteger):
    pwr = 1
    num = inputInteger
    while (num) &gt; 0 and (0 &lt; pwr &lt; 7):
        inputInteger = inputInteger - 1
        pwr = pwr + 1
        num = num - 1
    if int(num)**int(pwr) == inputInteger:
            print(str(num) + (" to the power of ") + str(pwr) + (" equals ") + str(inputInteger) + ("!"))
    else: 
        print("No base and root combination fit the parameters of this test")
</code></pre>
<p>Can anyone give me any general advice on this issue? Right now I am always receiving the 'else' statement which is not correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, the reason you're always hitting the <code>else</code> is that you're doing the <code>if</code> check after the loop is over. So, instead of checking each value, you're just checking the very last values.</p>
<p>You want to print the "Yes" answer if <em>any</em> value matches, and the "No" only if <em>all</em> values fail. For that, you need to put the <code>if</code> inside the loop, and <code>break</code> as soon as you find the first success (unless you want to print <em>all</em> matches, instead of just the first one), and then the <code>else</code> becomes something you do only if you didn't find any of them.</p>
<p>You can use an <code>else:</code> with a <code>while:</code>, which gets run only if you didn't <code>break</code> anywhere. But many people find that confusing, so it might be simpler to just <code>return</code> instead of <code>break</code> on success, and just always print the failure message if you finish the loop.</p>
<hr/>
<p>Meanwhile, I think what you're hoping to do is handle all <code>num</code> values from <code>inputNumber</code> to <code>0</code>, and, for each one, all <code>pwr</code> values from 1 to 7. To do that, you need a nested loop.</p>
<p>While we're at it, using a <code>for</code> loop is a whole lot easier than using a <code>while</code> loop around a variable that you initialize and <code>+1</code> or <code>-1</code> each time through.</p>
<p>Putting all of that together:</p>
<pre><code>def determineRootAndPower(inputInteger):
    for num in range(inputInteger, 0, -1):
        for pwr in range(1, 7):
            if int(num)**int(pwr) == inputInteger:
                print(str(num) + (" to the power of ") + str(pwr) + (" equals ") + str(inputInteger) + ("!"))
                return
    print("No base and root combination fit the parameters of this test")
</code></pre>
<hr/>
<p>You can simplify this further.</p>
<p>What you really want is all combinations of any <code>num</code> in range, and any <code>pwr</code> in range. You don't care about how the nesting works, you just want all the combinations. In mathematical terms, you want to loop over the cartesian product of the two ranges. The function <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> does exactly that. So:</p>
<pre><code>def determineRootAndPower(inputInteger):
    for num, pwr in itertools.product(range(inputInteger, 0, -1), range(1, 7)):
        if int(num)**int(pwr) == inputInteger:
            print(str(num) + (" to the power of ") + str(pwr) + (" equals ") + str(inputInteger) + ("!"))
            return
    print("No base and root combination fit the parameters of this test")
</code></pre>
<hr/>
<p>As a side note, there are two things that make this code harder to read for no good reason.</p>
<p>First, if you want to print out an expression, it's a lot easier to use <code>format</code> (or <code>%</code>) than to manually convert things to strings and concatenate them together. Formatting lets you see what the output will look like, instead of having to figure it out, and it takes care of the stringifying and related stuff automatically.</p>
<p>Second, adding parentheses where they're not needed makes the code harder to read. The parentheses around your <code>print</code> expression makes your code look like Python 3, but it's actually Python 2. And the parentheses around each string inside the expression are even worse—at first glance, it looks like those are supposed to be inside the quotes. Even the parentheses in your test expression, <code>(num) &gt; 0 and (0 &lt; pwr &lt; 7)</code>, force the reader to pause—normally, parentheses like that are used to override the normal way operators combine together, so you have to think through what would be wrong with the normal <code>num &gt; 0 and 0 &lt; pwr &lt; 7</code> and how the parentheses make it different, only to eventually figure out that it's actually exactly the same.</p>
<p>Anyway, compare these two and see which one is easier to follow:</p>
<pre><code>print "{} to the power of {} equals {}!".format(num, pwr, inputInteger)
print(str(num) + (" to the power of ") + str(pwr) + (" equals ") + str(inputInteger) + ("!"))
</code></pre>
</div>
<span class="comment-copy">Your formatting needs some help - what you have pasted can't possibly run.  Also, you're reducing the input integer by 1 at the same time you're increasing the power by 1.  <code>num = 15</code> while <code>pwr = 1</code>, then <code>num = 14</code> when <code>pwr = 2</code>.  That pattern of sequences isn't guaranteed to find a factor for a given input number.</span>
<span class="comment-copy">As a side note, why are you doing <code>int(num)**int(pwr)</code>? That implies that <code>num</code> and <code>pwr</code> might be something different, like a string, in which case your code will break in plenty of other places…</span>
<span class="comment-copy">As another side note, the excessive parentheses make your code harder to read.</span>
