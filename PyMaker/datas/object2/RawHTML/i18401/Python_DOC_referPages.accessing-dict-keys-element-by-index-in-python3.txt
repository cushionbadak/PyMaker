<div class="post-text" itemprop="text">
<p>I'm trying to access a dict_key's element by its index:</p>
<pre><code>test = {'foo': 'bar', 'hello': 'world'}
keys = test.keys()  # dict_keys object

keys.index(0)
AttributeError: 'dict_keys' object has no attribute 'index'
</code></pre>
<p>I want to get <code>foo</code>.</p>
<p>same with:</p>
<pre><code>keys[0]
TypeError: 'dict_keys' object does not support indexing
</code></pre>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Call <code>list()</code> on the dictionary instead:</p>
<pre><code>keys = list(test)
</code></pre>
<p>In Python 3, the <code>dict.keys()</code> method returns a <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects">dictionary view object</a>, which acts as a set. Iterating over the dictionary directly also yields keys, so turning a dictionary into a list results in a list of all the keys:</p>
<pre><code>&gt;&gt;&gt; test = {'foo': 'bar', 'hello': 'world'}
&gt;&gt;&gt; list(test)
['foo', 'hello']
&gt;&gt;&gt; list(test)[0]
'foo'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not a full answer but perhaps a useful hint. If it is really the first item you want*, then </p>
<pre><code>next(iter(q))
</code></pre>
<p>is much faster than </p>
<pre><code>list(q)[0]
</code></pre>
<p>for large dicts, since the whole thing doesn't have to be stored in memory.</p>
<p>For 10.000.000 items I found it to be almost 40.000 times faster.</p>
<p>*The first item in case of a dict being just a pseudo-random item before <a href="https://www.google.nl/search?client=ubuntu&amp;channel=fs&amp;q=python%20dict%20order%203.5&amp;ie=utf-8&amp;oe=utf-8&amp;gfe_rd=cr&amp;ei=PGlvWNTrIa3c8AeKjpKACw" rel="noreferrer">Python 3.6</a> (after that it's ordered in the standard implementation, although it's not advised to rely on it).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>test = {'foo': 'bar', 'hello': 'world'}
ls = []
for key in test.keys():
    ls.append(key)
print(ls[0])
</code></pre>
<p>Conventional way of appending the keys to a statically defined list and then indexing it for same</p>
</div>
<div class="post-text" itemprop="text">
<p>Another different approach would be use a pandas Series like this:</p>
<pre><code>import pandas as pd
pd.Series(dict).index.values.tolist()
</code></pre>
<p>This might be overkilling and not very fast, but for me is very clear and readable.</p>
</div>
<span class="comment-copy">In py3.x <code>dict.keys()</code> returns a set like view object, not list(so, indexing is not possible). Use <code>keys = list(test)</code></span>
<span class="comment-copy">when i do list(something_dict), the tuple order is random: example: list({'foo': 'bar', 'hello': 'world'}) can returns: list(foo,  hello) or list(hello, foo), why is this random?</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/526125/why-is-python-ordering-my-dictionary-like-so">Dicts don't have any order</a>.(Use <code>collections.OrderedDict</code> if you want ordered keys)</span>
<span class="comment-copy">Interesting discussion on thread safety here reagrding the various approaches to solve this problem:  <a href="http://blog.labix.org/2008/06/27/watch-out-for-listdictkeys-in-python-3" rel="nofollow noreferrer">blog.labix.org/2008/06/27/â€¦</a></span>
<span class="comment-copy"><a href="http://blog.labix.org/2008/06/27/watch-out-for-listdictkeys-in-python-3" rel="nofollow noreferrer">Watch out for list(dict.keys()) in Python 3 - Labix Blog</a> clearly explains what the issue is without providing a solution. This is excellent!</span>
<span class="comment-copy">@BrandonBradley: generally speaking: relying on certain actions being atomic is a bad idea anyway, as Python is so highly dynamic. Your code can easily be passed a <code>dict</code> subclass, for example, where <code>.keys()</code> is handled in Python code (e.g. a thread switch can take place).</span>
<span class="comment-copy">@BrandonBradley: thanks for the link. Only the solution from one of the comments for that blog works for me in Python3: sorted(dict.keys()). In Python2, dict.keys() will return a list of key values.</span>
<span class="comment-copy">@GoodWill: <code>sorted(dict)</code> would do the exact same thing; produce a list of keys in sorted order. <code>list(dict)</code> will give you the list in dictionary order.</span>
<span class="comment-copy">This has always been one of my biggest issues with everything becoming iterators in Py3. It's definitely more efficient, but so many use cases become "unclean" and complicated for no reason. For example, why can't they just support indexing on the iterator, without necessarily having a performance loss?</span>
<span class="comment-copy">It is not wrong, but why not <code>ls = list(test.keys())</code>? I find it more simple.</span>
<span class="comment-copy">Yes, this is more efficient. I wrote this just to show the readability.</span>
