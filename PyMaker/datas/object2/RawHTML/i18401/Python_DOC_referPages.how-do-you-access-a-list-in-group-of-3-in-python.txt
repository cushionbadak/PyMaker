<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks">How do you split a list into evenly sized chunks?</a>
<span class="question-originals-answer-count">
                    57 answers
                </span>
</li>
</ul>
</div>
<pre><code>origCodon = ([orig[i: i + groupSize] for i in range(len(orig) + 1 - groupSize)])
patCodon = ([pat[i: i + groupSize] for i in range(len(pat) + 1 - groupSize)])
print (patCodon)
origCode = []
patCode = []
for p in patCodon:
    for d in dna:
         if d == p:
              x = dna[p]
              print (p)
              patCode.append(x)
</code></pre>
<p>The code above takes two lists and splits them into groups of three, but when I go to check each individual element, it makes a new list of three, moving along one element each time.</p>
<p>i.e. this is one list made:</p>
<pre><code>['AAC', 'ACT', 'CTG', 'TGC', 'GCA', 'CAG', 'AGC', 'GCT', 'CTC', 'TCA']
</code></pre>
<p>But these are the elements it checks:</p>
<pre><code>AAC
ACT
CTG
TGC
GCA
CAG
AGC
GCT
CTC
TCA
</code></pre>
<p>How do I make it so that each group of three is checked and then it moves on to the next?</p>
<p>My list is split into groups of three (becoming items in the list), I want to check each of those items for their corresponding amino acid (in a dictionary), but the  program keeps making new lists, e.g. the user enters AAATTT, then the program checks:</p>
<pre><code>AAA
AAT
ATT
TTT
</code></pre>
<p>rather than just AAA and TTT</p>
</div>
<div class="post-text" itemprop="text">
<p>With a nod to Óscar, who figured out the bulk of the problem, I think the OP is asking about something like this:</p>
<pre><code>codon = 'AACTGCAGCTCA'

list = [codon[i:i+3] for i in range(0, len(codon), 3)]

=&gt; ['AAC', 'TGC', 'AGC', 'TCA']
</code></pre>
<p>The list <code>['AAC', 'ACT', 'CTG', 'TGC', 'GCA', 'CAG', 'AGC', 'GCT', 'CTC', 'TCA']</code> was an unintended result of the OP's code, because each triplet contains the last two characters of the previous one.</p>
<p>Edit:  Also, this chunk of code:</p>
<pre><code>for p in patCodon:
    for d in dna:
        if d == p:
             x = dna[p]
             print (p)
             patCode.append(x)
</code></pre>
<p>should probably be this instead:</p>
<pre><code>for p in patCodon:
    if p in dna:
        x = dna[p]
        print (p)
        patCode.append(p)
</code></pre>
<p>The reason is that checking for membership with <code>in</code> is much faster than looping over the members.</p>
<p>This will only work if <code>dna</code> is a dict.  If <code>dna</code> is a list, the same syntax will work to check whether <code>p</code> is in <code>dna</code>, but <code>x = dna[p]</code> is probably a mistake.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two ways to do this: slices, or a shared iterator.</p>
<p>The other answers show the slice method—which I think you could have gotten correct, if you just knew/remembered the step=3 to <code>range</code>:</p>
<pre><code>[lst[i:i+3] for i in range(0, len(lst), 3)]
</code></pre>
<p>The only major downside of this method is that it only works on a list or other sequence, not a general iterable. In your current code, this doesn't matter, because the thing you want to call it on <em>is</em> a list.</p>
<p>But it's worth knowing the alternative too:</p>
<pre><code>i = iter(list)
zip(i, i, i)
</code></pre>
<p><a href="http://docs.python.org/3/library/functions.html#iter" rel="nofollow"><code>iter</code></a> just asks a sequence or other iterable for a single-pass iterator over its contents.</p>
<p>Then <a href="http://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> just advances them in lockstep, as usual.</p>
<p>Because all three of <code>zip</code>'s arguments are references to the exact same iterator, when it tries to advance one, it advances all of them. (This is why we can't just do <code>zip(iter(i), iter(i), iter(i))</code>—then you'd have three <em>separate</em> iterators.)</p>
<hr/>
<p>But what if you want to group by 2, or 5? Writing separate functions for <code>zip(i, i)</code> and <code>zip(i, i, i, i, i)</code> and so on wouldn't be very nice.</p>
<p>If we had a sequence of <code>n</code> references of the iterator, we could use <code>*args</code> syntax, as described in the tutorial under <a href="http://docs.python.org/3.3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow">Unpacking Argument Lists</a>, to just call <code>zip(*sequence)</code>.</p>
<p>And we can easily get such a sequence by using the <a href="http://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow"><code>*</code> repetition operator</a>: <code>[i]*n</code>. (If you don't understand why that ends up with <code>n</code> references to one iterator, instead of <code>n</code> separate iterators, read the Python FAQ's entry on <a href="http://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list" rel="nofollow">How do I create a multidimensional list?</a>.)</p>
<p>And you can put that all together into a one-liner:</p>
<pre><code>zip(*[iter(lst)]*n)
</code></pre>
<hr/>
<p>If there's a partial group left over, this will drop it, because that's what <code>zip</code> does. So if you'd rather do something different in that case, you can just replace <code>zip</code> with a different function—e.g., to pad the partial group with spaces, just:</p>
<pre><code>itertools.zip_longest(*[iter(lst)]*3, fillvalue=' ')
</code></pre>
<p>The <a href="http://docs.python.org/3/library/itertools.html#recipes" rel="nofollow"><code>itertools</code> recipes</a> in the docs have a function caller <code>grouper</code> which does this for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You mean, like this?</p>
<pre><code>lst = ['AAC', 'ACT', 'CTG', 'TGC', 'GCA', 'CAG', 'AGC', 'GCT', 'CTC', 'TCA']
[lst[i:i+3] for i in range(0, len(lst), 3)]

=&gt; [['AAC', 'ACT', 'CTG'], ['TGC', 'GCA', 'CAG'], ['AGC', 'GCT', 'CTC'], ['TCA']]
</code></pre>
<p>The above will iterate over the original list and create sublists of <em>at most</em> three elements - notice that the last sublist can have 1, 2 or 3 elements.</p>
</div>
<span class="comment-copy">I am quite confused about your goal here.</span>
<span class="comment-copy">What does "check" mean?</span>
<span class="comment-copy">Is <code>dna</code> a dictionary?</span>
<span class="comment-copy">Someone posted a pretty similar questions yesterday.</span>
<span class="comment-copy">@Josay: Someone asks a similar question every few days. I'm not sure this is a dup of those hundreds of questions, but I think it is…</span>
<span class="comment-copy">Where would I look for documentation on the syntax you use in <code>zip(*[iter(lst)]*3)</code> ?  Unclear on what the asterisks do and not sure where to find an explanation.</span>
<span class="comment-copy">@MarkR.Wilkins: Reorganized the answer and added links, in a way that should help you find the explanations.</span>
