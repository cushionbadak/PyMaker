<div class="post-text" itemprop="text">
<p>I thought I understood python's pass-by-reference processing... Why is there a difference between pass-by-reference for lists vs. that for list elements, specially if both are objects as far as I understand it:</p>
<pre><code> dataBloc = [ ['123'] , ['345'] ]

 print dataBloc

 def func( b ):
     print ( 'Row-by-Row Before' , b )
     for row in b:
         row = [ float(x) for x in row ]
     print ( 'Row-by-Row After' , b )

     print ( 'Element-by-Element Before' , b )
     for row in b:
         for i in range(len(row)):
             row[i] = float(row[i])
     print ( 'Element-by-Element After' , b )

     return b

 print func(dataBloc)

 [['123'], ['345']]
 ('Row-by-Row Before', [['123'], ['345']])
 ('Row-by-Row After', [['123'], ['345']])
 ('Element-by-Element Before', [['123'], ['345']])
 ('Element-by-Element After', [[123.0], [345.0]])
 [[123.0], [345.0]]
</code></pre>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, this question has nothing to do with either pass-by-value or pass-by-reference, because you're not doing any passing, you're simply mutating values within a function.</p>
<p>Secondly, there is no such difference. The difference is in your code: you are doing different things. In the first loop, you assign each element in the list to the name 'row'. Then, you <em>reassign</em> the name 'row' to point to something else. The actual value that was previously in 'row' is unchanged, so of course the original list is itself unchanged, since you didn't actually change the contents.</p>
<p>In the second, inside each row you specifically mutate the contents of each element via its index. So, the list is changed.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I thought I understood python's pass-by-reference processing... Why is there a difference between pass-by-reference for lists vs. that for list elements, specially if both are objects as far as I understand it:</p>
</blockquote>
<p>Python is call-by-value, not call-by-reference. See the wikipedia page on <a href="http://en.wikipedia.org/wiki/Evaluation_strategy" rel="nofollow">evaluation strategies</a>.</p>
<p>As @ShashankGupta summarises: "Python is basically considered pass-by-value where all the values are references (since every name in a namespace is just a pointer to some object)." The view that python has some magical other evaluation strategy is the view of small subset of the python community who want python to be magical and unique. Python's way of dealing with objects+call-by-reference isn't even unique, and is present in (at least) Java, Smalltalk, and Ruby.</p>
<p>Also, your code does not show any calling/passing except passing <code>databloc</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no pass-by-reference or pass-by-value in Python (apart from implementation details – I'm talking about language properties). This kind of categorization just does not apply to Python at all. All there is are objects, who have type, identity (the hash) and data (a value).</p>
<p>The only difference between objects is if their data is <em>mutable</em> or <em>immutable</em>. I recommend reading the official documentation about Python's <a href="http://docs.python.org/3/reference/datamodel.html" rel="nofollow">data model</a></p>
</div>
<span class="comment-copy">Take a look here, <a href="http://www.jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/" rel="nofollow noreferrer">jeffknupp.com/blog/2012/11/13/…</a></span>
<span class="comment-copy">That article is wrong...Python is basically considered pass-by-value where all the values are references (since every name in a namespace is just a pointer to some object).</span>
<span class="comment-copy">@ShashankGupta: The article is right. "pass-by-value where all the values are references" is just the Java terminology for the same exact semantics.</span>
<span class="comment-copy">The most interesting thing about the article linked is that it has one of the few comment sections where the top comments are correct, and correct the author.</span>
<span class="comment-copy">Its worth noting that your "row-by-row" version could work if you used indexing to write the rows: <code>for i, row in enumerate(b): b[i] = [float(x) for x in row]</code>. The result will be almost the same as the "element-by-element" version, though it will create new inner lists instead of reusing the old ones.</span>
<span class="comment-copy">You beat me to it!</span>
<span class="comment-copy">There's a function, and a call, so there has to be some level of passing even if how that happens is unclear to me (and others apparently). Clearly my choice of title offended someone. Also, if I rename <code>row</code> in the second loop to something else, the printed data doesn't change. Clearly I'm missing something. I'll go &amp; educate myself.</span>
<span class="comment-copy">But both the mutating and the printing are happening <i>within</i> the function. If you did all that without the call, the question would be the same. And I'm sorry, I don't understand what you mean with your second point: if you renamed all references to 'row' to 'blargh', it would work just the same.</span>
<span class="comment-copy">Got it, thanks.</span>
<span class="comment-copy">No, python references are passed by value.</span>
