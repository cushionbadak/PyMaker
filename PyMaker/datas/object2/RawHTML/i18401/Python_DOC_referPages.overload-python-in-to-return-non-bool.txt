<div class="post-text" itemprop="text">
<p>I'm trying to overload the <code>in</code> operator for a class to return a non-bool object, but it seems to cast anyway. Here is my use case:</p>
<pre><code>class Dataset(object):
  def __init__(self):
    self._filters = []

  def filter(self, f):
    self._filters.append(f)
    return self

class EqualFilter(object):
  def __init__(self, field, val):
    ...

class SubsetFilter(object):
  def __init__(self, field, vals):
    ...

class FilterBuilder(object):
  def __init__(self, field):
    self._field = field

  def __eq__(self, val):
    return EqualFilter(self._field, val)

  def __contains__(self, vals):
    return SubsetFilter(self._field, vals)


veggie = FilterBuilder('veggie')
fruit = FilterBuilder('fruit')
ds = Dataset().filter(veggie == 'carrot').filter(fruit in ['apple', 'orange'])
</code></pre>
<p>At the end of the code, <code>ds</code> contains an <code>EqualFilter</code> for <code>veggie == 'carrot'</code>, and <code>True</code> for <code>fruit in ['apple', 'orange']</code>. Is there any way for ds to end up with a <code>SubsetFilter</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The real problem here is that, as <a href="http://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow">the documentation</a> says:</p>
<blockquote>
<p>For user-defined classes which define the <code>__contains__()</code> method, <code>x in y</code> is true if and only if <code>y.__contains__(x)</code> is true.</p>
</blockquote>
<p>Also see <a href="http://docs.python.org/2/reference/datamodel.html#object.__contains__" rel="nofollow">here</a> and <a href="http://docs.python.org/2/library/operator.html#operator.contains" rel="nofollow">here</a>.</p>
<p>user2357112's answer explains this better than I could. You're calling <code>list.__contains__</code>, not <code>FilterBuilder.__contains__</code>.</p>
<hr/>
<p>But why does it work that way?</p>
<p>Well, how else could it work? </p>
<p>Imagine that <code>3 in [1, 2, 3]</code> called <code>int.__contains__</code>. And so did <code>3 in {1, 2, 3}</code>, and <code>3 in my_custom_sorted_bintree</code>. How could <code>int.__contains__(container)</code> possibly be implemented? Certainly not by iterating over the container. That would mean slow, exhaustive search for looking things up in sets and bintrees, which would defeat the whole point. My bintree class might not even be iterable, and yet may still have a concept of membership.</p>
<p>But what if they call <code>list.__contains__</code>, <code>set.__contains__</code> and <code>CustomSortedBintree.__contains__</code>? Don't they have to know about int, and str, and every other possible thing you could give them? No, not at all. A list just has to know how to compare <code>arg == elem</code> for each of its elements. A set also needs to know how to call <code>hash(arg)</code>. A bintree also has to know how to call <code>arg &lt; elem</code>. But you don't need to know anything about the type of <code>arg</code> to do that.</p>
<hr/>
<p>You probably want to know how to deal with this. There are two and a half common solutions.</p>
<p>1: You can easily create a <code>FilterList</code> class. Then, you just write:</p>
<pre><code>fruit in FilterList('apple', 'orange')
</code></pre>
<p>1.5: Or, with a bit more work, you can build a more general "value holder":</p>
<pre><code>fruit in const(['apple', 'orange'])
</code></pre>
<p>2: Alternatively, you can write a <code>FilterBuilder.in_</code> method. Then you write:</p>
<pre><code>fruit.in_(['apple', 'orange'])
</code></pre>
<p>… or, if you prefer:</p>
<pre><code>fruit.in_('apple', 'orange')
</code></pre>
<p>Most libraries I've seen either provide the second (sqlalchemy), or provide both but use the second in their tutorials (appscript), although "quick-lambda" libraries often go with the generic version of the first.</p>
<p>But you should consider the tradeoffs for your own use case. In general, the first is easier to implement, and more explicit, and has the advantage that subfilters/subqueries can return something that acts as a <code>FilterList</code>; the second is less verbose and arguably easier to read.</p>
<p>If neither one is acceptable, you could consider writing a parser for a Python-like DSL, instead of trying to build a DSL out of actual Python code via expression templates. Or using something like <a href="https://github.com/lihaoyi/macropy" rel="nofollow"><code>MacroPy</code></a> (which I think even has an example similar to what you're looking for—as well as quick-lambda macros that don't need "const" and friends).</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two problems here. First, <code>in</code> always casts the result of <code>__contains__</code> to a <code>bool</code>, so what you're looking for isn't possible. The second problem is that</p>
<pre><code>fruit in ['apple', 'orange']
</code></pre>
<p>calls</p>
<pre><code>['apple', 'orange'].__contains__(fruit)
</code></pre>
<p>There's no way for the left operand of <code>in</code> to override the operator, so that's also going to defeat what you're trying to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>No. <code>list.__contains__</code> <em>always</em> returns a <code>bool</code>, and C types cannot be monkeypatched (nor should you consider doing so, since you will likely break other code).</p>
</div>
<span class="comment-copy">@sharth: Thanks for the fix.</span>
<span class="comment-copy">Adding a print statement to FilterBuilder.__contains__ does cause a print, so I'm fairly certain that FilterBuilder.__contains__ is called and not list.__contains__</span>
<span class="comment-copy">@user108088: Some code path from <code>FilterBuilder.__eq__</code> is probably calling <code>FilterBuilder.__contains__</code>. When I implement a <code>class Printer(object)</code> whose <code>__contains__</code> method has a <code>print</code> in it, <code>4 in Printer()</code> prints, but <code>Printer() in [1,2,3]</code> doesn't print.</span>
<span class="comment-copy">@abarnert: Wrong reply target?</span>
<span class="comment-copy">@user2357112: Sorry, yes.</span>
<span class="comment-copy">By the way, from what I can tell, it's not guaranteed that <code>in</code> will cast the result to a <code>bool</code>. All of the relevant documentation just says that it will be a true value iff <code>__contains__</code> returns a true value. It could do that by returning a bool, but it could also return the value itself. <a href="http://hg.python.org/cpython/file/246095bb2309/Python/ceval.c#l4427" rel="nofollow noreferrer">CPython</a> returns a bool, as you'd expect given <a href="http://docs.python.org/3.3/c-api/sequence.html#PySequence_Contains" rel="nofollow noreferrer"><code>PySequence_Contains</code></a>, and so do at least Jython and PyPy, but still, I think it's implementation-dependent.</span>
