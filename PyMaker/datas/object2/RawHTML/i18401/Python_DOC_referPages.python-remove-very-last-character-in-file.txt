<div class="post-text" itemprop="text">
<p>After looking all over the Internet, I've come to this.</p>
<p>Let's say I have already made a text file that reads:
<code>Hello World</code></p>
<p>Well, I want to remove the very last character (in this case <code>d</code>) from this text file.</p>
<p>So now the text file should look like this: <code>Hello Worl</code></p>
<p>But I have no idea how to do this.</p>
<p>All I want, more or less, is a single backspace function for text files on my HDD.</p>
<p>This needs to work on Linux as that's what I'm using.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/2/library/stdtypes.html#file.seek" rel="noreferrer"><code>file.seek()</code></a> to seek 1 position from the end, then use <a href="http://docs.python.org/2/library/stdtypes.html#file.truncate" rel="noreferrer"><code>file.truncate()</code></a> to remove the remainder of the file:</p>
<pre><code>with open(filename, 'rb+') as filehandle:
    filehandle.seek(-1, os.SEEK_END)
    filehandle.truncate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case you are not reading the file in binary mode, where you have only 'w' permissions, I can suggest the following.</p>
<pre><code>f.seek(f.tell() - 1, os.SEEK_SET)
f.write('')
</code></pre>
<p>In this code above, <code>f.seek()</code> will only accept <code>f.tell()</code> b/c you do not have 'b' access. then you can set the cursor to the starting of the last element. Then you can delete the last element by an empty string.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accepted answer of Martijn is simple and kind of  works, but does not account for text files with:</p>
<ul>
<li><strong>UTF-8 encoding</strong> containing non-English characters (which is the default encoding for text files in Python 3)</li>
<li>one <strong>newline character at the end of the file</strong> (which is the default in Linux editors like <code>vim</code> or <code>gedit</code>)</li>
</ul>
<p>If the text file contains non-English characters, neither of the answers provided so far would work.</p>
<p>What follows is an example, that solves both problems, which also allows removing more than one character from the end of the file:</p>
<pre><code>import os


def truncate_utf8_chars(filename, count, ignore_newlines=True):
    """
    Truncates last `count` characters of a text file encoded in UTF-8.
    :param filename: The path to the text file to read
    :param count: Number of UTF-8 characters to remove from the end of the file
    :param ignore_newlines: Set to true, if the newline character at the end of the file should be ignored
    """
    with open(filename, 'rb+') as f:
        last_char = None

        size = os.fstat(f.fileno()).st_size

        offset = 1
        chars = 0
        while offset &lt;= size:
            f.seek(-offset, os.SEEK_END)
            b = ord(f.read(1))

            if ignore_newlines:
                if b == 0x0D or b == 0x0A:
                    offset += 1
                    continue

            if b &amp; 0b10000000 == 0 or b &amp; 0b11000000 == 0b11000000:
                # This is the first byte of a UTF8 character
                chars += 1
                if chars == count:
                    # When `count` number of characters have been found, move current position back
                    # with one byte (to include the byte just checked) and truncate the file
                    f.seek(-1, os.SEEK_CUR)
                    f.truncate()
                    return
            offset += 1
</code></pre>
<p>How it works:</p>
<ul>
<li>Reads only the last few bytes of a UTF-8 encoded text file in binary mode</li>
<li>Iterates the bytes backwards, looking for the start of a UTF-8 character</li>
<li>Once a character (different from a newline) is found, return that as the last character in the text file</li>
</ul>
<p>Sample text file - <code>bg.txt</code>:</p>
<pre><code>Здравей свят
</code></pre>
<p>How to use:</p>
<pre><code>filename = 'bg.txt'
print('Before truncate:', open(filename).read())
truncate_utf8_chars(filename, 1)
print('After truncate:', open(filename).read())
</code></pre>
<p>Outputs:</p>
<pre><code>Before truncate: Здравей свят
After truncate: Здравей свя
</code></pre>
<p>This works with both UTF-8 and ASCII encoded files.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open(urfile, 'rb+') as f:
    f.seek(0,2)                 # end of file
    size=f.tell()               # the size...
    f.truncate(size-1)          # truncate at that size - how ever many characters
</code></pre>
<p>Be sure to use binary mode on windows since Unix file line ending many return an <a href="http://docs.python.org/2/library/stdtypes.html#file.tell" rel="nofollow">illegal or incorrect</a> character count.</p>
</div>
<div class="post-text" itemprop="text">
<p>here is a dirty way (erase &amp; recreate)...
i don't advice to use this, but, it's possible to do like this ..</p>
<pre><code>x = open("file").read()
os.remove("file")
open("file").write(x[:-1])
</code></pre>
</div>
<span class="comment-copy">I was typing up an ugly <code>read, drop character, write</code> answer when you posted this. So elegant.</span>
<span class="comment-copy">I got the following error <code>NameError: name 'os' is not defined</code></span>
<span class="comment-copy">@beckah you need to import the module. Add <code>import os</code> to your code.</span>
<span class="comment-copy">According to [1] "SEEK_END or 2: seek to the end of the stream; offset must be zero (all other values are unsupported)."  1: <a href="https://docs.python.org/3/library/io.html?highlight=newline#io.TextIOBase.seek" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">@zvyn: You are looking at the wrong documentation. See <a href="https://docs.python.org/3/library/io.html?highlight=newline#io.IOBase.seek" rel="nofollow noreferrer"><code>io.IOBase.seek()</code></a> instead. The file is opened in <i>binary mode</i>, not text mode. In text mode the offsets depend on the encoding of the text which can use variable-length bytes; which is why the <code>TextIOBase.seek()</code> method doesn't support seeking backwards. But in binary mode we seek by bytes instead and negative offsets from the end are perfectly legal.</span>
<span class="comment-copy">seeking relative to the end requires negative indices still. You also forgot to close the <code>open()</code> call.</span>
<span class="comment-copy">@MartijnPieters: Yes -- I was double checking it worked before I edited it! Thanks.</span>
