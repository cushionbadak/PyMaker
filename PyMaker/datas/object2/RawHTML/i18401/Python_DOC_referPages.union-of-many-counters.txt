<div class="post-text" itemprop="text">
<p>What's the best way (in terms of readability and efficiency) of finding the union of a list of <a href="http://docs.python.org/3/library/collections.html#counter-objects" rel="nofollow">Counters</a>?</p>
<p>For example, my list might look like this:</p>
<pre><code>counters = [Counter({'a': 6, 'b': 3, 'c': 1}),
            Counter({'a': 2, 'b': 5}),
            Counter({'a': 4, 'b': 4}),
            ...]
</code></pre>
<p>I want to calculate the union, i.e. <code>counters[0] | counters[1] | counters[2] | ...</code>.</p>
<p>One way of doing it would be this:</p>
<pre><code>def counter_union(iterable):
    return functools.reduce(operator.or_, iterable, Counter())
</code></pre>
<p>Is there a better approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>Goodness, when did Python programmers become afraid of easy loops?  LOL.</p>
<pre><code>result = Counter()
for c in counters:
    result |= c
</code></pre>
<p>There really aren't prizes in real life for squashing things into as few characters as theoretically possible.  Well, ya, there are in Perl, but not in Python ;-)</p>
<p>Later:  pursuant to user2357112's comment, starting with Python 3.3 the code above will do "in place" unions into <code>result</code>.  That is, <code>result</code> is truly reused, possibly growing larger on each iteration.</p>
<p>In any spelling of</p>
<pre><code>counters[0] | counters[1] | counters[2] | ...
</code></pre>
<p>instead, the entire partial result so far keeps getting thrown away when the next partial result is computed.  That may - or may not - be a lot slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think a loop is much more readable:</p>
<pre><code>def counter_union(iterable):
    union = Counter()
    for counter in counters:
        union |= counter
    return union
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>user2357112 and Tim's comments made me realize that if you are going to use <code>reduce</code>, you should at least use <code>operator.ior</code>, not <code>operator.or_</code>.  In Python 3.3+, this will avoid creating a new counter for every iteration.</p>
<pre><code>def counter_union(iterable):
    return functools.reduce(operator.ior, iterable, Counter())
</code></pre>
</div>
<span class="comment-copy">I think your approach is perfectly fine.</span>
<span class="comment-copy">You might want a solution using <code>|=</code> if you have a lot of Counters.</span>
<span class="comment-copy">@arshajii: Well, I was thinking that it'd be in-place, avoiding a potentially-quadratic amount of time spent making copies, but it doesn't look like Counter actually implements in-place versions of any operators.</span>
<span class="comment-copy">That depends on the Python version:  inplace multiset methods were implemented for Counters starting in Python 3.3.</span>
<span class="comment-copy">You're not by chance the creator of timsort, are you?</span>
<span class="comment-copy">Yes, but it wasn't by chance ;-)</span>
<span class="comment-copy">hahah <code>there are in Perl</code> ...</span>
