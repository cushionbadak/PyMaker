<div class="post-text" itemprop="text">
<p>is there a simple way to take a pandas/df table:</p>
<pre><code>field_1 field_2 field_3 field_4
cat     15,263  2.52    00:03:00
dog     1,652   3.71    00:03:47
test     312    3.27    00:03:41
book     300    3.46    00:02:40
</code></pre>
<p>And convert it to XML along the lines of:</p>
<pre><code>&lt;item&gt;
  &lt;field name="field_1"&gt;cat&lt;/field&gt;
  &lt;field name="field_2"&gt;15263&lt;/field&gt;
  &lt;field name="filed_3"&gt;2.52&lt;/field&gt;

...

&lt;item&gt;
      &lt;field name="field_1"&gt;dog&lt;/field&gt;

and so on...
</code></pre>
<p>Thanks in advance for any help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a function that creates the <code>item</code> node from a row in your DataFrame:</p>
<pre><code>def func(row):
    xml = ['&lt;item&gt;']
    for field in row.index:
        xml.append('  &lt;field name="{0}"&gt;{1}&lt;/field&gt;'.format(field, row[field]))
    xml.append('&lt;/item&gt;')
    return '\n'.join(xml)
</code></pre>
<p>And then apply the function along the <code>axis=1</code>.</p>
<pre><code>&gt;&gt;&gt; print '\n'.join(df.apply(func, axis=1))
&lt;item&gt;
  &lt;field name="field_1"&gt;cat&lt;/field&gt;
  &lt;field name="field_2"&gt;15,263&lt;/field&gt;
  &lt;field name="field_3"&gt;2.52&lt;/field&gt;
  &lt;field name="field_4"&gt;00:03:00&lt;/field&gt;
&lt;/item&gt;
&lt;item&gt;
  &lt;field name="field_1"&gt;dog&lt;/field&gt;
  &lt;field name="field_2"&gt;1,652&lt;/field&gt;
  &lt;field name="field_3"&gt;3.71&lt;/field&gt;
  &lt;field name="field_4"&gt;00:03:47&lt;/field&gt;
&lt;/item&gt;
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To expand on Viktor's excellent answer (and tweaking it slightly to work with duplicate columns), you could set this up as a <code>to_xml</code> DataFrame method:</p>
<pre><code>def to_xml(df, filename=None, mode='w'):
    def row_to_xml(row):
        xml = ['&lt;item&gt;']
        for i, col_name in enumerate(row.index):
            xml.append('  &lt;field name="{0}"&gt;{1}&lt;/field&gt;'.format(col_name, row.iloc[i]))
        xml.append('&lt;/item&gt;')
        return '\n'.join(xml)
    res = '\n'.join(df.apply(row_to_xml, axis=1))

    if filename is None:
        return res
    with open(filename, mode) as f:
        f.write(res)

pd.DataFrame.to_xml = to_xml
</code></pre>
<p>Then you can print the xml:</p>
<pre><code>In [21]: print df.to_xml()
&lt;item&gt;
  &lt;field name="field_1"&gt;cat&lt;/field&gt;
  &lt;field name="field_2"&gt;15,263&lt;/field&gt;
  &lt;field name="field_3"&gt;2.52&lt;/field&gt;
  &lt;field name="field_4"&gt;00:03:00&lt;/field&gt;
&lt;/item&gt;
&lt;item&gt;
...
</code></pre>
<p>or save it to a file:</p>
<pre><code>In [22]: df.to_xml('foo.xml')
</code></pre>
<p><em>Obviously this example should be tweaked to fit your xml standard.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/xml.etree.elementtree.html" rel="noreferrer">xml.etree.ElementTree</a> package to generate a read-friendly format in a very few lines of code.</p>
<pre><code>root = etree.Element('data');

for i,row in dframe.iterrows():
    item = etree.SubElement(root, 'item', attrib=row.to_dict());

etree.dump(root);
</code></pre>
<p>This will create a XML Tree (under root), where each row will will be of type <code>item</code>, and have attributes for all columns. You can create a more nested tree with columns as well by creating a subelement for each field.</p>
<p>Then you can also read the xml file back in Python using the ElementTree package:</p>
<pre><code>xml.etree.ElementTree.parse('xml_file.xml');
</code></pre>
</div>
<span class="comment-copy">hmmm seems to_xml is a strange omission, there is to_html, to_json etc. Perhaps this would make a good enhancement request.</span>
<span class="comment-copy">is XML standardized enough to do this?</span>
<span class="comment-copy">@Jeff Probably not, I think Viktor's recipe can probably be tweaked to a user's specific needs.</span>
<span class="comment-copy">This is a very neat solution.</span>
<span class="comment-copy">Problem with this is that if you have characters in the InnerText that are special characters, it wont escape them.  There are a multitude of XML standards to follow here.  If you have very well known data, no punctuation, then this will work.  Otherwise if you data has some text like 'shoe lace count &gt; 2', this will throw off any XML reader.  A good XML library will encode that to 'shoe lace count &amp;gt; 2'.</span>
<span class="comment-copy">worth opening an issue to support to/read_xml</span>
