<div class="post-text" itemprop="text">
<p>I'm trying to a create dictionary from a nested list.  However, I'm running into an issue with appending values to my dictionary because they are strings. Is there a creative solution to this? Perhaps splitting up my strings into another list? </p>
<pre><code>my_list = [('key1', 'topic1', 'content1'), ('key2', 'topic1', 'content2'), ('key3', 'topic2', 'content3')]

my_dict = {}
for list in my_list:
    for val in list:
        if list[1] in my_dict:
            my_dict[list[1]].append(list[2])
        else:
            my_dict[i[1]] = i[2] 
</code></pre>
<p>I'm trying to return:</p>
<pre><code>[{'topic1': 'content1', 'content2'}, {'topic2': 'content3'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_list = [('key1', 'topic1', 'content1'), ('key2', 'topic1', 'content2'), ('key3', 'topic2', 'content3')]

result={}
for t in my_list:
    result.setdefault(t[1],[]).append(t[2])

print result    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The value of each dictionary entry needs to be another collection.  A list or a set depending on expected behavior with duplicates.</p>
<pre><code>    my_dict = {}
    for list in my_list:
        if list[1] in my_dict:
            my_dict[list[1]].append(list[2])
        else:
            my_dict[list[1]]= [ list[2]  ]
</code></pre>
<p>This is the closest to you current code.  An slightly improved version is:</p>
<pre><code>    my_dict = {}
    for triplet in my_list:
        if triplet[1] in my_dict:
            my_dict[triplet[1]].append(triplet[2])
        else:
            my_dict[triplet[1]]= [ triplet[2]  ]
</code></pre>
<p>Given that <code>list</code> is already used by the language, and that <code>my_list</code> elements are not lists but tuples (triplets in your particular case).  For the same reason, you can also write:</p>
<pre><code>    my_dict = {}
    for _, my_key, my_value in my_list:
        if my_key in my_dict:
            my_dict[my_key].append(my_value)
        else:
            my_dict[my_key]= [ my_value  ]
</code></pre>
<p>Finally, you can use a <code>defaultdict</code> (a dictionary that automatically initializes the value corresponding to a key when it is referenced for the first time).</p>
<pre><code>    my_dict = collections.defaultdict(list)
    for _, my_key, my_value in my_list:
        my_dict[my_key].append(my_value)
</code></pre>
<p>If you are going to use the dictionary later to check for the presence/absence of keys, your have to keep in mind that for a <code>defaultdict</code> all keys are always present (created when they are queried).  The best solution in this case is to copy the <code>defaultdict</code> to a regular one with:</p>
<pre><code>    my_regulardict= dict( my_defaultdict )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a case for <a href="http://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a>:</p>
<pre><code>import collections

my_list = [('key1', 'topic1', 'content1'), ('key2', 'topic1', 'content2'), ('key3', 'topic2', 'content3')]

my_dict = collections.defaultdict(list)

for _, key, value in my_list:
    my_dict[key].append(value)

print(my_dict)
</code></pre>
<p>Gives us:</p>
<pre><code>defaultdict(&lt;class 'list'&gt;, {'topic2': ['content3'], 'topic1': ['content1', 'content2']})
</code></pre>
<p>The <code>defaultdict</code> creates the list for the values if it doesn't exist, meaning we can do this really easily by just looping over the list and appending the values to the key. It acts exactly as a normal dictionary in every other way, but if you <em>need</em> a normal dict, you can just use <code>dict()</code> on it.</p>
</div>
<span class="comment-copy">So the first values in the tuples are just flat-out ignored? And there will always be three values per-tuple?</span>
<span class="comment-copy">Don't use list as a variable name. It's a built-in type.</span>
<span class="comment-copy">Also, where are you expecting that <code>i</code> (in the <code>i[1]</code> and <code>i[2]</code>) to come from in that code?</span>
<span class="comment-copy">This is no what the OP wants, but strangely it was accepted as the answer. The original question is looking for a list of dictionaries.</span>
<span class="comment-copy">@BurhanKhalid: You are right, but the example data structure is not a valid Python data structure either...</span>
<span class="comment-copy">+1. But it's worth noting that if you use <code>defaultdict</code>, every attempt to look up a nonexistent key later will return <code>[]</code> instead of raising a <code>KeyError</code>. Of course that might actually be what the OP wants… but I wouldn't just assume that. You can use <code>setdefault</code> instead, or just do <code>my_dict = dict(my_dict)</code> at the end, if this is a problem.</span>
<span class="comment-copy">@abarnert  Iteration on a <code>defaultdict</code> doesn't trigger creation of new defaults.  That's the usual way of accessing elements after "load", and also the reason why <code>dict(my_dict)</code> in your comment works.  Good warning to the OP by all means.  +1 to your clarification/warning</span>
<span class="comment-copy">I don't know that iteration is "the usual way"; the whole point of having a dictionary is that you can look things up by key. If you're never going to do that, it doesn't matter whether you have a dict or a defaultdict, or for that matter just a list of tuples/<code>ItemsView</code>/iterator…</span>
<span class="comment-copy">@abarnert  I understand your point, but for some reason when I use a dictionary the expectation is that keys <b>are</b> present and, if not, they are created (with a default value or otherwise).  When absent keys are a definite possibility, then the underlying structure is usually a set.  Perhaps it's just coincidence, a matter of style, or application domain.  I'm going to add a few lines about this to my answer.</span>
<span class="comment-copy">Yes, there are definitely good uses for both <code>defaultdict</code>, just as there are good uses for and a regular <code>dict</code> (and, for that matter, for anything you can iterate over like <code>items</code>). I was just pointing out that the choice of solution is more about how you're going to use the dictionary later than anything else, so it's worth thinking about. And I think your answer (especially with your comments) covers that very nicely.</span>
