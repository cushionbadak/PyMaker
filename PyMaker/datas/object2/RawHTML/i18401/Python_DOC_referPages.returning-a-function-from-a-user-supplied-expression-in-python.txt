<div class="post-text" itemprop="text">
<p>So I'm working on writing a program that will need to take an expression as user input, and evaluate that expression as values change over in-program time.  There will be many of these expressions. There will be a "play" function to have time move forward, so I'd like to keep things fast(ish) which usually means "find something somebody else wrote", but I'm certainly not against writing my own stuff.</p>
<p>I'm expecting things like this as input</p>
<pre><code>input&gt; sin(currentTime()*360) - (plant.height*5 + root.depth**2)
</code></pre>
<p>I've looked into tokenizing, and building ast's and such, but I'm apparently missing that last step where I get a function that can be evaluated over and over as multiple inputs change.</p>
<p>Any shove in the right general direction will be most helpful.  Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind the input format being Python, there's an <a href="http://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast</a> module that could do the parsing for you. The literal_eval helper safely executes the AST or source code string. <a href="https://stackoverflow.com/questions/13849960/how-can-i-dynamically-execute-function-in-current-scope-and-add-it-as-property-o">This question</a> has some stuff on manipulating scopes with functions, if it helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've done something like this to apply arbitrary filtering rules against events to see if actions needed to be taken in response. The event and relevant context would be passed as arguments to a function compiled from an arbitrary expression wrapped in a lambda.</p>
<pre><code># API consists of the variables:
# - plant
# - root
# - currentTime
# math.* and random.* are imported

exprs = """\
sin(currentTime()*360) - (plant.height*5 + root.depth**2)
cos(currentTime()*180) - (plant.height*3 + root.depth**(1.5 + random()*0.5))""".splitlines()

# function to 'compile' expression into an executable function
def makeFunction(expr):
    # define args that are supported in the expression
    api = "plant,root"
    return eval("lambda %s : %s" % (api, expr))

# compile given expressions into functions
fns = [makeFunction(e) for e in exprs]
</code></pre>
<p>Here is a mock wrapper to show how this might look within your larger program:</p>
<pre><code>from math import *
from random import *

# mock up simple classes and vars to simulate larger program
def simpleClass(clsname, **kwargs):
    classDefn = "class %s:\n  %s=%s" % (clsname, ','.join(kwargs.keys()), 
                                        ','.join(map(str,kwargs.values())))
    print classDefn
    exec(classDefn, globals())

def mockProgramVars():
    # define some simple classes for API variables
    simpleClass("Plant", height=0, stem=0)
    simpleClass("Root", depth=0, thickness=0, radius=0)
    return Plant(), Root()

plant, root = mockProgramVars()


# loop through time, evaluating functions as plant and root grow
for T in range(0,10):
    # note, local vars become implicit part of API for functions
    def currentTime():
        return T

    # define explicit args
    args = (plant, root)

    # invoke compiled functions
    print T, ":", 
    for i,fn in enumerate(fns, start=1):
        print fn(*args),
    print

    # have plant grow a bit before next time
    plant.height += 0.1
    root.depth += 0.2
</code></pre>
<p>prints:</p>
<pre><code>class Plant:
  stem,height=0,0
class Root:
  depth,radius,thickness=0,0,0
0 : 0.0 1.0
1 : 0.418915723414 -0.948727984564
2 : -1.70407169644 -1.12048780375
3 : -2.5102191366 -0.418297794419
4 : -1.72700555043 -2.69830945686
5 : -3.36779764724 -2.4337532978
6 : -5.42800370907 -2.38542932493
7 : -5.03162665152 -4.90632786047
8 : -5.81504769652 -4.46741225807
9 : -8.59104601264 -5.02132453755
</code></pre>
<p>Of course, all the standard warning about using eval apply.</p>
</div>
<span class="comment-copy">I'd hate to suggest <code>eval</code>, but I'm afraid that's the easiest way to do what you need.</span>
<span class="comment-copy">The last step is to make the terms in your expression evaluate to something. For example, use the <code>operator</code> module to implement operations.</span>
<span class="comment-copy">Are <code>plant</code> and <code>root</code> just arbitrary variables in the local namespace, or is there a set of known variable names that are available for input?</span>
<span class="comment-copy">@Paul They're just arbitrary names of user created class instances.  There can be any number of them with any name.</span>
<span class="comment-copy">Sounds like the OP has already looked in to the <code>ast</code> module.</span>
<span class="comment-copy">I thought they meant ast in general, not the specific python ast. Even so, they should be able to re-evaluate it as needed</span>
<span class="comment-copy"><code>literal_eval</code> won't help here; the expected inputs are much more powerful than <code>literal_eval</code> is built to handle.</span>
<span class="comment-copy">What about <code>compile</code> - if it's a function, couldn't it just be called again whenever the inputs change?</span>
<span class="comment-copy">Ah HA!  <code>compile(inputStr,'','single')</code> was exactly what I was looking for.  Hooray for one obvious way to do it! Too bad I'm not Dutch.</span>
