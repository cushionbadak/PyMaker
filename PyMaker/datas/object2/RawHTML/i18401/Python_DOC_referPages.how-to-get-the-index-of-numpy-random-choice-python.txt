<div class="post-text" itemprop="text">
<p>Is it possible to modify the numpy.random.choice function in order to make it return the index of the chosen element? 
Basically, I want to create a list and select elements randomly without replacement</p>
<pre><code>import numpy as np
&gt;&gt;&gt; a = [1,4,1,3,3,2,1,4]
&gt;&gt;&gt; np.random.choice(a)
&gt;&gt;&gt; 4
&gt;&gt;&gt; a
&gt;&gt;&gt; [1,4,1,3,3,2,1,4]
</code></pre>
<p><code>a.remove(np.random.choice(a))</code> will remove the first element of the list with that value it encounters (<code>a[1]</code> in the example above), which may not be the chosen element (eg, <code>a[7]</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way to find out the <em>index</em> of a randomly selected element:</p>
<pre><code>import random # plain random module, not numpy's
random.choice(list(enumerate(a)))[0]
=&gt; 4      # just an example, index is 4
</code></pre>
<p>Or you could retrieve the element <em>and</em> the index in a single step:</p>
<pre><code>random.choice(list(enumerate(a)))
=&gt; (1, 4) # just an example, index is 1 and element is 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>numpy.random.choice(a, size=however_many, replace=False)
</code></pre>
<p>If you want a sample without replacement, just ask numpy to make you one. Don't loop and draw items repeatedly. That'll produce bloated code and horrible performance.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; a = numpy.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; numpy.random.choice(a, size=5, replace=False)
array([7, 5, 8, 6, 2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Regarding your first question, you can work the other way  around, randomly choose from the index of the array <code>a</code> and then fetch the value.</p>
<pre><code>&gt;&gt;&gt; a = [1,4,1,3,3,2,1,4]
&gt;&gt;&gt; a = np.array(a)
&gt;&gt;&gt; random.choice(arange(a.size))
6
&gt;&gt;&gt; a[6]
</code></pre>
<p>But if you just need random sample without replacement, <code>replace=False</code> will do. Can't remember when it was firstly added to <code>random.choice</code>, might be 1.7.0. So if you are running very old <code>numpy</code> it may not work. Keep in mind the default is <code>replace=True</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit in left field compared with the other answers, but I thought it might help what it sounds like you're trying to do in a slightly larger sense. You can generate a random sample without replacement by shuffling the indices of the elements in the source array :</p>
<pre><code>source = np.random.randint(0, 100, size=100) # generate a set to sample from
idx = np.arange(len(source))
np.random.shuffle(idx)
subsample = source[idx[:10]]
</code></pre>
<p>This will create a sample (here, of size 10) by drawing elements from the source set (here, of size 100) without replacement.</p>
<p>You can interact with the non-selected elements by using the remaining index values, i.e.:</p>
<pre><code>notsampled = source[idx[10:]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on your comment:</p>
<blockquote>
<p>The sample is already <code>a</code>. I want to work directly with <code>a</code> so that I can control how many elements are still left and perform other operations with <code>a</code>. â€“ HappyPy</p>
</blockquote>
<p>it sounds to me like you're interested in working with <code>a</code> after <code>n</code> randomly selected elements are removed.  Instead, why not work with <code>N = len(a) - n</code> randomly selected elements from <code>a</code>?  Since you want them to still be in the original order, you can select from indices like in @CTZhu's answer, but then sort them and grab from the original list:</p>
<pre><code>import numpy as np
n = 3 #number to 'remove'
a = np.array([1,4,1,3,3,2,1,4])
i = np.random.choice(np.arange(a.size), a.size-n, replace=False)
i.sort()
a[i]
#array([1, 4, 1, 3, 1])
</code></pre>
<p>So now you can save that as <code>a</code> again:</p>
<pre><code>a = a[i]
</code></pre>
<p>and work with <code>a</code> with <code>n</code> elements removed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using <code>choice</code>, you can also simply <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer"><code>random.shuffle</code></a> your array, i.e.</p>
<pre><code>random.shuffle(a)  # will shuffle a in-place
</code></pre>
</div>
<span class="comment-copy">It may not be the chosen element, but it seems like two cases are indistinguishable.</span>
<span class="comment-copy"><code>enumerate</code> would probably work</span>
<span class="comment-copy">@Rob: Not really. After I create the list it's important that it remains in the same order, whichever element I remove.</span>
<span class="comment-copy">... there should be a function np.random.argchoice(...)</span>
<span class="comment-copy">This is not working for me. It gives me a "ValueError: a must be 1-dimensional"</span>
<span class="comment-copy">Then <code>a</code> is not a Pyhton list as shown in the question...</span>
<span class="comment-copy">I copy/pasted the your code and the list above, and I still get the same error. Is it working with you?</span>
<span class="comment-copy"><code>list(enumerate(a))</code> produces a list of tuples, which is considered a 2D array-like object. This won't work.</span>
<span class="comment-copy">Strong warning, this is going to have terrible performance, which is one of the primary reasons people use numpy in the first place. You're iterating over an entire array. It would be cheaper to just generate a random integer between 0 and the length of the list rather than this.</span>
<span class="comment-copy">I don't understand how would this work. What's "a" in this case? Could you provide an example please?</span>
<span class="comment-copy">@HappyPy: <code>a</code> is exactly the same thing it is in your code; it's the array-like object we want a sample from. <code>size</code> is the number of elements we want in the sample, and <code>replace=False</code> asks for a sample without replacement. The result will be a 1D array of shape <code>(however_many,)</code> containing the sample you wanted.</span>
<span class="comment-copy">The sample is already "a". I want to work directly with "a" so that I can control how many elements are still left and perform other operations with "a".</span>
<span class="comment-copy">@HappyPy: That sounds like you're using numpy all wrong. If <code>a</code> is already a random sample, but you want to draw elements from <code>a</code> without replacement, you're essentially drawing another random sample from <code>a</code>. If you <i>really, really</i> want to successively remove elements from <code>a</code>, numpy is unlikely to help you.</span>
<span class="comment-copy">No need to make a list and choose from it in this case, just do <code>np.random.randint(0,a.size)</code>, unless I suppose many mutually exclusive choices are needed.</span>
<span class="comment-copy">@askwchan, right! What was I thinking. <code>np.random.randint(0,a.size, size=size_you_want)</code> will be enough.</span>
<span class="comment-copy">@CT Zhu: I get a AttributeError: 'list' object has no attribute 'size'</span>
<span class="comment-copy">Oh, <code>a</code> is a list, not a <code>array</code>. Put convert it to <code>array</code> first. I forgot to copy 1 line.</span>
<span class="comment-copy">@askwchan, oh, no. Your method will always become sampling with replacement. HappyPy really needs that <code>replace=False</code>, so a once a element is sampled it will not sampled again.</span>
