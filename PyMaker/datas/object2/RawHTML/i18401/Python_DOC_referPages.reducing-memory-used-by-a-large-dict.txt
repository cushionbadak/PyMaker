<div class="post-text" itemprop="text">
<p>I need to create an in memory object that has keys that are a 9 digit integer and a boolean value associated with each key.  I've been using a dict as in the simplified example below:</p>
<pre><code>#!/usr/bin/python
from __future__ import print_function
import sys

myDict = {}
for n in range(56000):
        myDict[n] = True

print('Count:',len(myDict),' Size:', sys.getsizeof(myDict))
</code></pre>
<p>I need to be able to look up and retrieve the boolean value associated with each key.  The problem is the size of the dict.  Using Python 2.7 on a 64 bit Linux system and the above example, the size of the dict is 3.1 megabytes according to sys.getsizeof(). (about 56 bytes per entry to store 9 digits plus a boolean value)</p>
<p>I need to store the boolean state of (approx) 55.000 entries in the dict.  Each dict key is a 9 digit integer.  I've tried using the integer and str(theInteger) as keys with no change in the size of the dict.</p>
<p>Is there some other sort of data structure or methodology I should be using to conserve memory with such a large data set?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look up your boolean with an integer key, and the range of keys starts with 0 and is continuous, there's really no reason <em>not</em> to use a list:</p>
<pre><code>my_list = []
for n in range(56000):
        my_list[n] = True
</code></pre>
<p>or better:</p>
<pre><code>my_list = [True for n in range(5600])
</code></pre>
<p>If that is not enough, try the <code>array</code> module and use one byte per bool:</p>
<pre><code>import array
my_array = array.array("b", (True for n in range(56000)))
</code></pre>
<p>And if that is not good enough, try the <a href="https://pypi.python.org/pypi/bitarray/" rel="noreferrer" title="pypu/bitarray">bitarray module on PyPi</a>.</p>
<p>Another idea is to use a <code>set</code>: Say you have many more <code>False</code> than <code>True</code>, simply have a set:</p>
<pre><code>my_true_numbers = {0, 2323, 23452} # just the True ones
</code></pre>
<p>and check with</p>
<pre><code>value = number in my_true_numbers
</code></pre>
<p>If you have more <code>True</code> than <code>False</code>, do it the other way round.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer of <a href="https://stackoverflow.com/questions/10264874/python-reducing-memory-usage-of-dictionary">Python: Reducing memory usage of dictionary</a> has the conclusion that there it not much you can do and i agree with it. The overall memory overhead of a dictionary is small but the number of key-value pairs of your example raises the memory footprint.</p>
<p>There might one think possible: If the keys are always linear you could create a list of booleans directly or better use <a href="https://pypi.python.org/pypi/bitarray/" rel="nofollow noreferrer">bitarray</a>. The keys would then be implicit. But if this is only in your example the case you can't do much. </p>
</div>
<div class="post-text" itemprop="text">
<p>Why not using a gigantic bitfield ?
You code your data on two bits since you need at least three values : true, false and not_init/UB. The overall memory used would be <code>55.000*2 bits = 110 000 bits =  13 kBytes</code>.</p>
<p><img alt="A badly drawn diagram" src="https://i.stack.imgur.com/44NMX.png"/></p>
<p>The set flag is here to ensure that the value has been correctly set by the user (not necessary), and the second bit contains the value.</p>
<p>Using <code>64 bit unsigned integers</code>, you will only need <code>203</code> of them to store the whole array.</p>
<p>Then you can access it using bit index : let's say you want to access the value at index <code>123</code>. you will need to access bit <code>#246</code> ans <code>#247</code> (one for the set bool and the other one for the value).</p>
<p>Since <code>246</code> and <code>247</code> are inferior to <code>2**64</code>, they are stored on the <code>first uint</code>. To access them : </p>
<pre><code>return (( (1&lt;&lt;246) &amp; array[0] ) &gt;&gt; 246 )
</code></pre>
<p>To access any bit : </p>
<pre><code>return (( (1&lt;&lt;n) &amp; array[ n/(2**64) ] ) &gt;&gt; n)
</code></pre>
<p>( not tested the bit accessor)</p>
<p>Set a bit :</p>
<pre><code>array[ n/(2**64) ] = array[ n/(2**64) ] | (1&lt;&lt;n)
</code></pre>
<p>Bitwise operations are tricky (arithmetic shifting vs logical one ) and not easily debuggable, but they can be extremely powerful.</p>
</div>
<div class="post-text" itemprop="text">
<p>If "key not found" is not an important state for you (i.e. you are OK with treating keys not in the array as <code>False</code>), you may use a <code>set</code> instead to store just the elements mapping to <code>True</code>. This requires about 30% less space because each entry consists of just two 64-bit quantities (hash and key) instead of three quantities (hash, key, value).</p>
<p>Keep in mind that <code>sys.getsizeof(dict)</code> only tells you the size of the <code>dict</code> itself, not the objects contained within. Creating 56000 <code>int</code>s as the keys will also carry its own cost: 24 bytes per integer (type pointer, refcount, value). That will amount to 1.3MB just by itself, in addition to the memory taken by the dictionary.</p>
<p>To really save space, you could use a NumPy <em>compressed sparse row</em> matrix:</p>
<pre><code>from scipy.sparse import lil_matrix # linked-list matrix, used to construct the csr matrix
vals = lil_matrix((1,1000000000), dtype='int8'))
# We will use 0 = no such key, 1 = True, 2 = False
for n in myIndices:
    vals[n] = 1
vals = vals.tocsr()
</code></pre>
<p>The memory usage of <code>vals</code> is very small: 56KB for the data, 224KB for the indices, and less than 1KB for other structures. The total size is thus less than <strong>281KB</strong> (10x smaller than the dict), with no extra allocated integers. Looking elements up and changing non-zero elements is very fast (binary search in a sorted array), but inserting a new nonzero value or zeroing an existing nonzero value are expensive operations.</p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on what exactly your needs are, you could use a list to store your values.  This will only uses around 16% of the space a dictionary uses, but certain operations such as lookup and insertion will be (possibly a lot) slower.</p>
<pre><code>values = list(range(56000))
</code></pre>
<p>If you use the <a href="http://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code></a> module and store your values in a sorted list, your lookups will still be slower than with a dict, but much faster than the naïve <code>x in my_list</code> check.</p>
<p>The list must always be kept in sorted order.  To check whether a value is in your list, you can use this function:</p>
<pre><code>def is_in_list(values, x):
    i = bisect_left(values, x)
    return i != len(values) and values[i] == x
</code></pre>
<p>Works like this:</p>
<pre><code>&gt;&gt;&gt; is_in_list([2, 4, 14, 15], 4)
True
&gt;&gt;&gt; is_in_list([2, 4, 14, 15], 1)
False
&gt;&gt;&gt; is_in_list([2, 4, 14, 15], 13)
False
</code></pre>
<p>This method will reduce memory usage significantly, but – <a href="http://wiki.python.org/moin/TimeComplexity" rel="nofollow">compared to a dict or set</a> – lookup takes O(log n) time instead of O(1) and insertion takes O(n) instead of O(1).</p>
</div>
<span class="comment-copy">Are you truly interested in the tristate (<code>True</code>, <code>False</code>, no key in dict), or just the boolean value? In the latter case, a <code>set</code> for just the <code>True</code> values is more appropriate.</span>
<span class="comment-copy">the set idea is a good one, depending on the distribution (is there more True than False or the opposite) a value in the set can mean both True or False. whichever is best.</span>
<span class="comment-copy">Thanks to Christian and others who contributed.  I'll try Christian's set method.  Looks quite promising.</span>
<span class="comment-copy">To make a list of 56000 <code>True</code> use <code>[ True ] * 56000</code>. Notice however that the same reference is repeated 56000 times, but because <code>True</code> is immutable, it does not matter.</span>
<span class="comment-copy">Thanks for the suggestions.  Unfortunately the keys aren't linear.  The problem is that even though there are only 56,000 entries, each entry key is some integer from 100,000,000 through 800,000,000 so I think my list or bitarray would need to be 800,000,000 elements long to directly access the boolean in a non-keyed object.</span>
<span class="comment-copy">One more bit of evidence that leads me to believe that there is more to dict memory allocation than meets the eye.  If my dict is using around 12,000 bytes, then when the next single entry is added, the size of the dict jumps to around 48,000 bytes.  It then stays at 48,000 for a while and suddenly jumps to 192,000 bytes, etc etc, increasing by 4x the previous size each time it extends.</span>
<span class="comment-copy">Probably some kind of opimization to prevent memory allocation with every new entry. Most list... implementations do this.</span>
<span class="comment-copy">Christian Schramm idea with the sets seems worth a try. In the worst case you need two sets. One for true and one for false but you don't need to store the boolean value.</span>
<span class="comment-copy">@tea2code: that's going to be too expensive. A <code>set</code> saves only 30% space compared to a dictionary; having two sets will require more space than a single dictionary (because of <code>set</code> overallocation).</span>
