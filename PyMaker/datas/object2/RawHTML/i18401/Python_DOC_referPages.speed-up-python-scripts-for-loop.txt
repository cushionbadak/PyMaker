<div class="post-text" itemprop="text">
<p>Assuming you got something like this (copied from <a href="https://stackoverflow.com/questions/7541056/pinging-an-ip-range-with-scapy">here</a>):</p>
<pre><code>#!/usr/bin/python
from scapy.all import *

TIMEOUT = 2
conf.verb = 0
for ip in range(0, 256):
    packet = IP(dst="192.168.0." + str(ip), ttl=20)/ICMP()
    reply = sr1(packet, timeout=TIMEOUT)
    if not (reply is None):
         print reply.src, "is online"
    else:
         print "Timeout waiting for %s" % packet[IP].src
</code></pre>
<p>There is no need to wait for each ping to finish before trying the next host. Could I put the loop interior each time into the background along the lines of the <code>&amp;</code> in:</p>
<pre><code>for ip in 192.168.0.{0..255}; do 
ping -c 1 $ip &amp;
done
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first thing you should do is change your range to <code>range(0, 256)</code> so that it is inclusive of 0-255.</p>
<p>Second, you're looking at Python's threading, which can be somewhat similar to Bash process daemonization at an abstract level.</p>
<p>Import multiprocessing and create a pool:</p>
<pre><code>from multiprocessing.pool import ThreadPool
pool = ThreadPool(20)  # However many you wish to run in parallel
</code></pre>
<p>So take the ping lookup, which is everything inside of the for loop, and make it a function.</p>
<pre><code>def ping(ip):
    packet = IP(dst="192.168.0." + str(ip), ttl=20)/ICMP()
    reply = sr1(packet, timeout=TIMEOUT)
    if not (reply is None):
         print reply.src, "is online"
    else:
         print "Timeout waiting for %s" % packet[IP].src
</code></pre>
<p>Then in your for loop, </p>
<pre><code>for ip in range(0, 256):
    pool.apply_async(ping, (ip,))

pool.close()
pool.join()
</code></pre>
<p><code>pool.join()</code> is what waits for all of your threads to return.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>threading</code> or <code>multiprocessing</code> module to run aynchronous/non-blocking IO calls.</p>
<p>Read about hte difference on SO:</p>
<p><a href="https://stackoverflow.com/questions/1226584/multiprocess-or-threading-in-python">multiprocess or threading in python?</a></p>
</div>
<span class="comment-copy">Beside the point, but are you aware that <code>range(0,255)</code> ends at  <code>254</code>?</span>
<span class="comment-copy">thanks for the typo correction</span>
<span class="comment-copy">You could use the <a href="http://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" rel="nofollow noreferrer"><code>concurrent.futures</code></a> module to do pings concurrently.</span>
<span class="comment-copy">You should use some asynchronous library, or select.   Also, <code>reply is not None</code> looks better than <code>not (reply is None)</code>. ;)</span>
<span class="comment-copy">You can actually provide a range of IP addresses to capy, and it will send out accordingly, you can then evaluate the results of sr separately, which would work a lot faster as there should be less I/O blocks.</span>
