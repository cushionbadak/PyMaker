<div class="post-text" itemprop="text">
<p>As you may have noticed before, CPython sometimes stores a single copy of identical immutable objects.</p>
<p>e.g.</p>
<pre><code>&gt;&gt;&gt; a = "hello"
&gt;&gt;&gt; b = "hello"
&gt;&gt;&gt; a is b
True

&gt;&gt;&gt; a, b = 7734, 7734
&gt;&gt;&gt; a is b
True
</code></pre>
<p>It appears that the hashing for what I assume is heap is performed after type inferencing</p>
<pre><code>&gt;&gt;&gt; a, b = 7734, 07734
&gt;&gt;&gt; a is b
False

&gt;&gt;&gt; a, b = 7734, 017066
&gt;&gt;&gt; a is b
True
</code></pre>
<p>Is there any way to introspect the interpreter and print out this supposed heap of immutable objects?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, interned objects are maintained in a range of locations, no one method exists to list them all.</p>
<ul>
<li>Strings can be interned, as you discovered, and you can intern strings yourself by using the <a href="http://docs.python.org/2/library/functions.html#intern"><code>intern()</code> function</a>.</li>
<li>Small integers between -5 and 256 are interned.</li>
<li>Tuples are reused; the empty tuple (<code>()</code>) is a singleton, and 2000 each of tuple sizes 1 through to 20 are kept cached for recycling. (<em>Just</em> the tuple objects, not the contents).</li>
<li><code>None</code> is a singleton, as are <code>Ellipsis</code>, <code>NotImplemented</code>, <code>True</code> and <code>False</code>.</li>
<li>As of Python 3.3, instance <code>__dict__</code> dictionaries can <a href="http://www.python.org/dev/peps/pep-0412/">share keys</a> to save on memory.</li>
<li>The compiler can mark immutable (and in certain circumstances, mutable) sourcecode literals as constants, store them as such with the bytecode and re-use them each time the bytecode is run. This applies to strings, numbers, tuples, lists (if used with an <code>in</code> statement) and <a href="http://docs.python.org/3/whatsnew/3.2.html#optimizations">as of Python 3.2</a> sets (again, when used with <code>in</code>).</li>
</ul>
<p>There may be more I haven't discovered yet.</p>
<p>These optimizations all help to avoid too much heap churn. And apart from <code>None</code>, <code>Ellipsis</code>, <code>NotImplemented</code>, <code>True</code> and <code>False</code> being a singletons they are all CPython-specific optimisations, they are not part of the Python language definition itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a little more complicated than you make it out to be. For instance, in your examples with large integers, the same object is <em>not</em> reused when the uses aren't part of the same expression.</p>
<pre><code>&gt;&gt;&gt; a = 7734
&gt;&gt;&gt; b = 7734
&gt;&gt;&gt; a is b
False
</code></pre>
<p>On the other hand, as your first example shows, this does work with strings...but not all strings.</p>
<pre><code>&gt;&gt;&gt; a = "this string includes spaces"
&gt;&gt;&gt; b = "this string includes spaces"
&gt;&gt;&gt; a is b
False
</code></pre>
<p>The following objects are actually interned by default: small integers, the empty tuple, and strings that look like Python identifiers. What you're seeing with large integers and other immutable objects is an optimization due to the fact that they're being used in the same expression.</p>
</div>
<span class="comment-copy">Be careful with your second example: <code>07734</code> isn't <code>7734</code> because <code>07734 == 4060</code>.</span>
<span class="comment-copy">ah, I forgot about octal shorthand...</span>
<span class="comment-copy">What's wrong with using <code>locals()</code>? Or perhaps <code>list(set(locals().values()))</code>, which would print something like <code>[None, &lt;module '__builtin__' (built-in)&gt;, 7734, '__main__']</code> in your case</span>
<span class="comment-copy">Why do you want to know what objects are interned?</span>
<span class="comment-copy">I'm writing embedded Python and want to visually see where heap bloat is coming from.</span>
<span class="comment-copy">Hello. What do you mean by that: <code>Just the tuple objects, not the contents</code> , please ?</span>
<span class="comment-copy">@eyquem: When a tuple is to be created, the C code will pick one from the heap and re-assign the contents. Tuples are immutable in Python only, C code can still assign new content. So when the tuple <code>(1, 2)</code>  is no longer used, <i>just</i> the <code>(null, null)</code> object, without references to any other Python objects (so null pointers for each slot), is cached.</span>
<span class="comment-copy">Thank you. Didn't know all that. I wonder from where you've learned it. I upvote</span>
