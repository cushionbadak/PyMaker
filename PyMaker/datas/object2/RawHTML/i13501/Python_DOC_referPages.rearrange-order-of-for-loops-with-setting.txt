<div class="post-text" itemprop="text">
<p>I'm working with arrays having the following kind of structure/entries (for a masters project in quantum info games);
The 1st column entries <code>{0,1}</code>, 2nd col <code>{0,1}</code>, 3rd col <code>{0,2**(d-1)}</code> , last col <code>{0,d-1}</code>.
As follows for <code>d=3</code>:</p>
<pre><code>G = 
[[0 0 0 0]
 [0 0 0 1]
 [0 0 0 2]
 [0 0 1 0]
 [0 0 1 1]
 [0 0 1 2]
 [0 0 2 0]
 [0 0 2 1]
 [0 0 2 2]
 [0 0 3 0]
 [0 0 3 1]
 [0 0 3 2]
 [0 1 0 0]
 [0 1 0 1]
 [0 1 0 2]
 [0 1 1 0]
 [0 1 1 1]
 [0 1 1 2]
 [0 1 2 0]
 [0 1 2 1]
 [0 1 2 2]
 [0 1 3 0]
 [0 1 3 1]
 [0 1 3 2]
 [1 0 0 0]
 [1 0 0 1]
 [1 0 0 2]
 [1 0 1 0]
 [1 0 1 1]
 [1 0 1 2]
 [1 0 2 0]
 [1 0 2 1]
 [1 0 2 2]
 [1 0 3 0]
 [1 0 3 1]
 [1 0 3 2]
 [1 1 0 0]
 [1 1 0 1]
 [1 1 0 2]
 [1 1 1 0]
 [1 1 1 1]
 [1 1 1 2]
 [1 1 2 0]
 [1 1 2 1]
 [1 1 2 2]
 [1 1 3 0]
 [1 1 3 1]
 [1 1 3 2]]
</code></pre>
<p>I'm using the following function to build this array:</p>
<pre><code>def games(d = 3):
    res = np.empty(0).astype(int)
    for a in range(2):
        for b in range(2):
            for x in range(2**(d-1)):
                for y in range(d):
                    res = np.append(res,[a,b,x,y],axis=0)
    res = np.reshape(res,(-1,4))    
    return res
</code></pre>
<p>Now what I'd like to be able to do, is easily choose in which order the entries in the columns start counting. (Above its from the right column to the left.)</p>
<p>For instance, say Id like the 1st column to begin counting, then the 3rd column, then the 4th column and at last the 2nd one. I can get this by permuting the <code>for-loops</code> in the function:</p>
<pre><code>def games(d = 3):
    res = np.empty(0).astype(int)

    for b in range(2):
        for y in range(d):        
            for x in range(2**(d-1)):
                for a in range(2):
                    res = np.append(res,[a,b,x,y],axis=0)
    res = np.reshape(res,(-1,4))    
    return res
</code></pre>
<p>Which gives:</p>
<pre><code>G=
[[0 0 0 0]
 [1 0 0 0]
 [0 0 1 0]
 [1 0 1 0]
 [0 0 2 0]
 [1 0 2 0]
 [0 0 3 0]
 [1 0 3 0]
 [0 0 0 1]
 [1 0 0 1]
 [0 0 1 1]
 [1 0 1 1]
 [0 0 2 1]
 [1 0 2 1]
 [0 0 3 1]
 [1 0 3 1]
 [0 0 0 2]
 [1 0 0 2]
 [0 0 1 2]
 [1 0 1 2]
 [0 0 2 2]
 [1 0 2 2]
 [0 0 3 2]
 [1 0 3 2]
 [0 1 0 0]
 [1 1 0 0]
 [0 1 1 0]
 [1 1 1 0]
 [0 1 2 0]
 [1 1 2 0]
 [0 1 3 0]
 [1 1 3 0]
 [0 1 0 1]
 [1 1 0 1]
 [0 1 1 1]
 [1 1 1 1]
 [0 1 2 1]
 [1 1 2 1]
 [0 1 3 1]
 [1 1 3 1]
 [0 1 0 2]
 [1 1 0 2]
 [0 1 1 2]
 [1 1 1 2]
 [0 1 2 2]
 [1 1 2 2]
 [0 1 3 2]
 [1 1 3 2]]
</code></pre>
<p>Permuting the order of the for-loops in the function works, but I'd have to write 24 different cases to cover all permutations. Anyone have an idea what would be, in general, a nicer <code>solution/approach</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The thing you're calculating is called the "Cartesian product" and by <s>chance</s> popular demand the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">itertools module</a> from the standard library has a function to construct it without all the explicit loops. By permuting the order of the arguments given to <code>itertools.product</code>, the column count-order is determined. The only thing left to do is rearranging the columns back to the desired order, but this is easily accomplished with Numpy.</p>
<pre><code>import itertools

def make_games(d=3, perm=[3,2,1,0]):
    entries = [range(2),
               range(2),
               range(2**(d-1)),
               range(d)]
    # Python3 compatibility
    entries = [list(entry) for entry in entries]

    # Cartesian product with columns count-order by `perm`
    permuted_entries = [entries[px] for px in perm[::-1]]
    games_list = list(itertools.product(*permuted_entries))

    # Move the columns around to the original ordering
    sorter = np.argsort(perm[::-1])
    games = np.take(games_list, sorter, axis=1)

    return games
</code></pre>
<p>The output given as example can now be obtained by calling <code>make_games(3, [0, 2, 3, 1])</code>. Also, all possible permutations are now easily obtained by looping over <code>itertools.permutations(range(4))</code>.</p>
<hr/>
<p>As a bonus, here's a way to make this operation perform a lot faster with just Numpy (for larger <code>d</code>):</p>
<pre><code>def make_games_np(d=3, perm=[3,2,1,0]):
    entries = [range(2),
               range(2),
               range(2**(d-1)),
               range(d)]
    # Python3 compatability
    entries = [list(entry) for entry in entries]

    n = len(entries)
    entries_grid = np.array(np.meshgrid(*entries, indexing='ij'))
    entries_grid = np.rollaxis(entries_grid, 0, n+1)

    order = list(perm)[::-1] + [n]
    games = entries_grid.transpose(*order).reshape(-1, n)

    return games
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Each column of <code>G</code> is made from 4 dimensions that extend to <code>2</code>, <code>2</code>, <code>4</code> and <code>3</code> units respectively. These <code>4</code> dimensions could be permuted in 24 ways. To form each column of <code>G</code>, one can use any <code>4</code> of those <code>24</code> permuted dimensions in <code>permutations(24,4)</code> = <code>10626</code> ways.</p>
<p>Thus, if I got all of this correctly, you would have <code>10626</code> such <code>G</code> versions. So, to be memory-efficient, it would make sense to use a loop to run through those <code>10626</code> ways. Here's the implementation to fulfil all of the talk -</p>
<pre><code>import itertools

# Create meshes with upto 2,2,4,3 numbers as is the case across G columns
D0,D1,D2,D3 = np.meshgrid(np.arange(2),np.arange(2),np.arange(4),np.arange(3))

# All possible dimension arrangements with 4 dimensions for each of D0,D1,D2,D3
dims = np.asarray(list(itertools.permutations(range(4))))

# All possible arrangements considering the dimension arrangements
dims_row_idx = np.asarray(list(itertools.combinations(range(dims.shape[0]),4)))

# Use dims_row_idx to select rows of dims and subsequently 
# permute dimensions of D0,D1,D2,D3 and stack them as columns
for d in dims_row_idx:
    c0 = D0.transpose(dims[d[0]]).ravel()
    c1 = D1.transpose(dims[d[1]]).ravel()
    c2 = D2.transpose(dims[d[2]]).ravel()
    c3 = D3.transpose(dims[d[3]]).ravel()
    out = np.column_stack((c0,c1,c2,c3))
    # print(out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import numpy as np
import itertools

def games(d=3):
    res_list=[]
    a=list(itertools.permutations([2,2,2**(d-1),d],4))
    for index in range(len(a)):
        res=np.empty(0).astype(int)
        for i in range(a[index][0]):
            for j in range(a[index][1]):
                for p in range(a[index][2]):
                    for q in range(a[index][3]):
                        res=np.append(res,[i,j,p,q],axis=0)
        res=np.reshape(res,(-1,4))
        res_list.append(res)
    return res_list
</code></pre>
<p>I think there is an inconsistency probelm in your question. I think you mean 3rd col {0,2**(d-1)-1} instead of {0,2**(d-1)}.</p>
</div>
<span class="comment-copy">Shouldn't that be 24 permutations?</span>
<span class="comment-copy">You are right, thank you, any ideas about the programming?</span>
<span class="comment-copy">Well, it looks like you would have <code>10626</code> such ways to do it.</span>
<span class="comment-copy">Thank you very much, this is great!</span>
<span class="comment-copy">It looks like you are only permuting the order of the columns, its hard to tell with the complicated looking array you are using, please have another look at my original question.</span>
<span class="comment-copy">@balletpiraat See if the edited answer makes sense and work for you?</span>
