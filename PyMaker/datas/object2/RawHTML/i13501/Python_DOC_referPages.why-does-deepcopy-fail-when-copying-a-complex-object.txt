<div class="post-text" itemprop="text">
<p>How can I replicate a complex object so that I can add new members to it?  When I try to use deepcopy, it fails with "<code>TypeError: cannot serialize</code> ..."</p>
<p>The original problem is that I want to add some member variables to an existing object but can't because doing so results in "<code>AttributeError: Object is fixed</code>"</p>
<p>So the idea is create a full copy of the original object in a new class with the added members.</p>
<pre><code>orig_obj = SomeSqlObject.get_root() # contents unclear, complex

class orig_expanded():
    def __init__(self, replicable_object):
        self.__dict__ = copy.deepcopy(replicable_object.__dict__)

        self.added_member1 = None
        self.added_list    = []

expanded_thing = orig_expanded(orig_obj)
</code></pre>
<p>But I get:</p>
<pre><code>TypeError: cannot serialize '_io.TextIOWrapper' object
</code></pre>
<p>Followup answer to comment, "What is SomeSqlObject?"
Perhaps my name is wrong... actual name obfuscated for the company. It is a method that returns an object that represents the base of a tree (of some kind)  That tree is defined </p>
<pre><code>class SomeSqlObject(ParentRegisterSet):
    """
    Implements the functionality of the Device "root" Register Set.

    """
    def __init__(self, db, v1, dg, ui):
        self.__db__ = db
        self.__dg__ = dg
        self.__ui__ = ui
        SomeSqlObject.__init__(self, v1, None)

        # note:  this class is now locked
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>copy.deepcopy</code>'s behavior for classes that don't provide direct support (by defining <code>__deepcopy__</code>) is to <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow"><code>pickle</code></a> then <code>unpickle</code> the object to ensure a new instance is created. <code>io.TextIOWrapper</code> (which is a wrapper than converts binary file-like objects to text file-like objects) can't be serialized (because it assumes it may have external/run time state, e.g. a file descriptor that has a specific position in a file that may not be available when it's later deserialized).</p>
<p>The error comes because the object you're copying contains <code>io.TextIOWrapper</code>, and the serialization fails.</p>
<p>If the shared state is okay, you might limit yourself to a shallow copy, or use a composition based wrapper (based on <a href="https://stackoverflow.com/questions/16237659/python-how-to-implement-getattr"><code>__getattr__</code></a>) to access the underlying object through the wrapper object semi-seamlessly (aside from those pesky <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">special methods</a>), or you might try to individually deepcopy the values from the dictionary and just ignore the ones you can't copy, e.g.:</p>
<pre><code>for attr, value in vars(replicable_object).items():
    try:
        setattr(self, attr, copy.deepcopy(value))
    except Exception:
        pass
        # Alternatively, copy reference when copy impossible:
        #setattr(self, attr, value)
</code></pre>
<p>and just hope that the stuff you can't copy isn't too important.</p>
</div>
<div class="post-text" itemprop="text">
<p>My guess is what you really want is a <strong>proxy</strong> class, one example from google:
<a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Fronting.html" rel="nofollow">http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Fronting.html</a></p>
<p>You will initialize your proxy class from the object to wrap; attributes that the proxy class knows are handled locally; attributes that the proxy class doesn't know about are passed through to the wrapped object. </p>
<p>(normally, you'd subclass if you're creating these objects yourself... sounds like that is not an option here...)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>TypeError: cannot serialize '_io.TextIOWrapper' object
</code></pre>
<p>This exception means that somewhere, somehow your object is linked to a file object, a socket or something like that.</p>
<p><code>TextIOWrapper</code> is the class that wraps file descriptors and lets you read/write unicode strings.</p>
<p>And, as you can see, <code>TextIOWrapper</code> cannot be copied.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ok Found The answer.</p>
<p>The original error seen when trying to do a <code>setattr()</code> was <code>AttributeError: Object is fixed.</code>  That was an error from code in the original SomeSqlObject for a custom <code>__setatter__()</code> that was looking checking for bit <code>_attr_lock</code> and preventing adding members to the object.  Once I de-asserted this lock, I was able to add members easily.</p>
<p>The original problem is that I have a number of class members (call them id's) of the form <code>id0</code>, <code>id1</code>, <code>id3</code>, <code>id2</code>, etc.  Each of them is a complex object also.  But, the better way from the code-user's point of view is to use a list-type member <code>id[#]</code> to access them.  So, I needed to add on a list-type member <code>id[]</code> and make sure each successive element points to the same objects as pointed to by <code>id0</code>, <code>id1</code>,  ie. <code>id[0]</code>, <code>id[1]</code>, etc.</p>
<p>So, my final code to take a complex object and add a list-type member, is. </p>
<pre><code># Below we ADD ON to the existing SqlObject with a list-type member
# and populate the list with proper pointers to each register/register-
# set. This is PFM!

id_name_re = "\W*id\D*(\d+)"

# SqlObject has a feature to block adding attributes.... This will override
self.regs._attr_lock = None

# add a list-type placeholder in the SqlObj for a id array
setattr(self.regs, 'id', [])

# now get a list of all SqlObject  members called id&lt;#&gt; like:
#  ['id13', 'id12', 'id11', 'id10', 'id9', 'id8', 'id14 ...
id_list = [id_member  for id_member in self.regs.__dict__ if re.match(id_name_re, id_member)]

# Sort the list since we need to place them in the new id[] list
# sequentially
id_list = sorted(id_list, key=h.natural_sort_key)

# now go through the list and create a new list element and populate
# it with the SqlObject  goofy-name which is not in a list-type format
for id_member in id_list:
    offset = int(re.match(id_name_re, id_member).group(1))

    # this is NEEDED!. It causes the SqlObject  to rescan and keep
    # everything updated ('_' is kinda like /dev/null)
    _ = eval("self.regs.id%d" % (offset))

    self.regs.id.append(self.regs.__dict__[id_member].__getitem__.__self__)
</code></pre>
</div>
<span class="comment-copy">what does <code>SomeSqlObject.get_root()</code> return?</span>
<span class="comment-copy">My name may be misleading... trying to obfuscate company code... however, here is the class structure for what I call SomeSqlObject:class SomeSqlObject(ParentRegisterSet):     """     Implements the functionality of the Device "root" Register Set.      """     def <b>init__(self, db, v1, dg, ui):         self.__db</b> = db         self.__dg__ = dg         self.__ui__ = ui         SomeSqlObject.__init__(self, v1, None)          # note:  this class is now locked</span>
<span class="comment-copy">Alright that's a fail... perhaps I have to answer this with a different method....</span>
<span class="comment-copy">Trying to copy a file object  in python3 is not going to work,  what does <code>SomeSqlObject.get_root()</code> actually return?</span>
<span class="comment-copy">Yeah... Everything is important in there, including the I/O finctionality which creates the _io.TextIOWrapper error.  Thanks for the assist.  Found the answers above.</span>
<span class="comment-copy">YES... Looks like exactly what I needed... Then I would not have had to go look at my original object and find that the <b>setattr</b> method used a blocking mechanism that I had to override.  I WISH had seen this earlier. ... I'll implement it this way in the future.  THANKS.</span>
