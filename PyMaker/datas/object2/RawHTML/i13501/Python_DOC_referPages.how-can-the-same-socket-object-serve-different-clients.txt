<div class="post-text" itemprop="text">
<p>As is mentioned in the documentation: <a href="https://docs.python.org/3/library/socket.html#socket.socket.accept" rel="nofollow noreferrer">Python socket.accept()</a></p>
<blockquote>
<p>Accept a connection. The socket must be bound to an address and
  listening for connections. The return value is a pair (conn, address)
  where conn is a new socket object usable to send and receive data on
  the connection, and address is the address bound to the socket on the
  other end of the connection.</p>
<p>The newly created socket is non-inheritable.</p>
<p>Changed in version 3.4: The socket is now non-inheritable.</p>
</blockquote>
<p>The server code is</p>
<pre><code>&gt;&gt;&gt; from socket import *
&gt;&gt;&gt; sock = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; sock.bind(("localhost", 20000))
&gt;&gt;&gt; sock.getsockname()
('127.0.0.1', 20000)
&gt;&gt;&gt; sock.listen(1)
&gt;&gt;&gt; while True: 
...     conn, address = sock.accept()
...     print("Address of client : {0}".format(address))
...     print("Address of socket : {0}".format(conn.getsockname()))
... 
Address of client : ('127.0.0.1', 47165)
Address of socket : ('127.0.0.1', 20000)
Address of client : ('127.0.0.1', 47166)
Address of socket : ('127.0.0.1', 20000)
</code></pre>
<p>The client code is</p>
<pre><code>&gt;&gt;&gt; from socket import *
&gt;&gt;&gt; sclient1 = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; sclient2 = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; sclient1.connect(("localhost", 20000))
&gt;&gt;&gt; sclient2.connect(("localhost", 20000))
</code></pre>
<p>The address of the new <code>socket</code> object that is returned, is always the same as the original <code>socket</code> which was actually accepting connections.</p>
<p>I always thought that the server would create a new <code>socket</code> object with a different random port, but as can be seen above, even for multiple clients, the address and port of new <code>conn</code> object is still the same. How is then the server able to handle multiple clients?</p>
<hr/>
<h3>Edit</h3>
<p>I know the above code is blocking. If I use multiple threads to handle different client connections, I'll have to do send the new socket object, and client address to my thread function. Therefore, multiple threads are then handling multiple clients using the same server address and port.</p>
<p><em>Threaded server</em></p>
<pre><code>&gt;&gt;&gt; from socket import *    
&gt;&gt;&gt; import threading
&gt;&gt;&gt; def handler(conn, address):
...     print("Address of client : {0}".format(address))
...     print("Address of socket : {0}".format(conn.getsockname()))
... 
&gt;&gt;&gt; sock = socket(AF_INET, SOCK_STREAM)
&gt;&gt;&gt; sock.bind(("localhost", 20000))
&gt;&gt;&gt; sock.listen(1)
&gt;&gt;&gt; while 1:
...     conn, address = sock.accept()
...     t = threading.Thread(target=handler, args=[conn, address])
...     t.start()
... 
Address of client : ('127.0.0.1', 47169)
Address of socket : ('127.0.0.1', 20000)
Address of client : ('127.0.0.1', 47170)
Address of socket : ('127.0.0.1', 20000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I always thought that the server would create a new socket object with a different random port</p>
</blockquote>
<p>That would require telling the client which <em>new</em> port to use for the connection. Nicely enough, it is not necessary, see below. It would also mean, you could not have more than 65535 open connections to a single host address, which probably would break quite a bit for some systems.</p>
<blockquote>
<p>How is then the server able to handle multiple clients?</p>
</blockquote>
<p>The tuple <code>(server_addr, server_port, client_addr, client_port)</code> is unique after a client connects. When a packet comes in, the network stack searches for open connections matching this tuple and redirects incoming packets to the relevant socket (/file descriptor).</p>
<p>The <em>server socket</em> (which you perform <code>accept()</code> on), is <em>unconnected</em> (it is <em><code>listen()</code>ing</em>), but <em>bound</em>. This means it doesn't have a peer on the other side (no client address), but it does have a local address (server side).</p>
<p><code>accept()</code> returns a new socket. This one is <em>bound</em> and <em>connected</em>. Bound is the same as above: it has a local address and port. That address is the same as for the server socket, however the new socket's state is also <em>connected</em>. This means that there is a known peer (with an address) on the other side that we can communicate with. We also have that peer's address (the <em>peer address</em>) and port (<em>peer port</em>). This information is enough to uniquely identify the connection.</p>
<p>The client socket only accepts data that matches all four of <code>(server_addr, server_port, client_addr, client_port)</code>.</p>
</div>
<span class="comment-copy">Let me re-phrase this: You were under the impression, that, if you listen to e.g. port <code>10000</code> and clients connect, each client connection gets a random server port to identify the connection?</span>
<span class="comment-copy">@dhke Yes I did!</span>
<span class="comment-copy">You're confusing sockets and ports. One server-side <i>port</i> is all that's required, but the server needs a <i>socket</i> per connection.</span>
<span class="comment-copy">One more doubt. How is the server able to listen as well as serve clients on the same socket? Whenever a request comes, does the operating system always go for a unconnected but bound socket which will be different from the ones which are connected and bound?</span>
<span class="comment-copy">@KartikAnand Be careful with terminology. A <i>socket</i> is essentially the handle the operating system gives you to interact with the network stack. You cannot have a socket that is both listening and connected. However, if a <i>connection establishment request</i> (e.g. TCP <code>SYN</code>) packet comes in that matches an established connection it is handled by the existing connection (and thus usually silently ignored). You simply cannot create a connection with the same address quadruple when you already have one.</span>
<span class="comment-copy">Thanks for the information. Can you point me towards a specific resource where these nitty gritty details are covered. I couldn't find them using Google!</span>
<span class="comment-copy">You probably won't find good results when you search generally for <i>socket</i> because sockets cover a wide range of protocols, even connectionless ones. Try searching for a concrete protocol. For example, there is an answer <a href="http://stackoverflow.com/questions/6825036/what-will-happen-if-i-send-a-syn-packet-to-the-server-when-there-has-already-bee">here</a> for what happens when you get a <code>SYN</code> on an established TCP connection.</span>
