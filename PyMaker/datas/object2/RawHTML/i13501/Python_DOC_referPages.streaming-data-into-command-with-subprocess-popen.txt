<div class="post-text" itemprop="text">
<p>I frequently need to sort a collection of files that contain headers. Because sorting depends on the contents of the header, this use case is more complicated that similar questions (e.g., <a href="https://stackoverflow.com/questions/14562423/">Is there a way to ignore header lines in a UNIX sort?</a>).</p>
<p>I was hoping to use Python to read files, output the header of the first file, then pipe the tails into sort. I've tried this as a proof of concept:</p>
<pre><code>#!/usr/bin/env python

import io
import subprocess
import sys

header_printed = False

sorter = subprocess.Popen(['sort'], stdin=subprocess.PIPE)

for f in sys.argv[1:]:
    fd = io.open(f,'r')
    line = fd.readline()
    if not header_printed:
        print(line)
        header_printed = True
    sorter.communicate(line)
</code></pre>
<p>When called as <code>header-sort fileA fileB</code>, with fileA and fileB containing lines like</p>
<pre><code>c   float   int
Y   0.557946     413
F   0.501935     852
F   0.768102     709
</code></pre>
<p>I get:</p>
<pre><code># sort file 1
Traceback (most recent call last):
  File "./archive/bin/pipetest", line 17, in &lt;module&gt;
    sorter.communicate(line)
  File "/usr/lib/python2.7/subprocess.py", line 785, in communicate
    self.stdin.write(input)
ValueError: I/O operation on closed file
</code></pre>
<p>The problem is communicate takes a string and the pipe is closed after writing. This means that the content must be read fully into memory. communicate doesn't take a generator (I tried).</p>
<p>An even simpler demonstration of this is:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; p = subprocess.Popen(['tr', 'a-z', 'A-Z'], stdin=subprocess.PIPE)
&gt;&gt;&gt; p.communicate('hello')
HELLO(None, None)
&gt;&gt;&gt; p.communicate('world')
Traceback (most recent call last):
  File "&lt;ipython-input-14-d6873fd0f66a&gt;", line 1, in &lt;module&gt;
    p.communicate('world')
  File "/usr/lib/python2.7/subprocess.py", line 785, in communicate
    self.stdin.write(input)
ValueError: I/O operation on closed file
</code></pre>
<p>So, the question is, what's the right way (with Popen or otherwise) to stream data into a pipe in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just write to the pipe directly:</p>
<pre><code>#!/usr/bin/env python2
import fileinput
import subprocess

process = subprocess.Popen(['sort'], stdin=subprocess.PIPE)
with process.stdin as pipe, fileinput.FileInput() as file:
    for line in file:
        if file.isfirstline(): # print header
            print line,
        else: # pipe tails
            pipe.write(line)
process.wait()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For your specific case, if you only passed <code>subprocess.PIPE</code> for a single standard handle (in your case, <code>stdin</code>), then in your example, you can safely call <code>sorter.stdin.write(line)</code> over and over. When you're finished writing output, call <code>sorter.stdin.close()</code> so <code>sort</code> knows the input is finished, and it can perform the actual sort and output work (<code>sorter.communicate()</code> with no argument would probably work too; otherwise, after closing <code>stdin</code> you'd probably want to call <code>sorter.wait()</code> to let it finish).</p>
<p>If you need to deal with more than one piped standard handle, the right way is either <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>threading</code></a> with a dedicated thread for each pipe that must be handled beyond the first (relatively simple in concept, but heavyweight and introduces all the headaches of threading), or using the <a href="https://docs.python.org/3/library/select.html" rel="nofollow"><code>select</code></a> module (or in Python 3.4+, the <a href="https://docs.python.org/3/library/selectors.html" rel="nofollow"><code>selectors</code></a> module), which is quite tricky to get right, but can (under some circumstances) be more efficient. Lastly, there is <a href="https://docs.python.org/3/library/tempfile.html" rel="nofollow">creating temporary files for output</a>, so you can write directly to the process's <code>stdin</code> while the process writes to a file (and therefore won't block); you can then read the file at your leisure (note that the subprocess won't necessarily have flushed it's own output buffers until it exits, so the output may not arrive promptly in response to your input until further inputs and outputs have filled and flushed the buffer).</p>
<p><code>subprocess.Popen</code>'s <code>.communicate()</code> method uses either threads or <code>select</code> module primitives itself (depending on OS support; the implementation is under the <a href="https://hg.python.org/cpython/file/default/Lib/subprocess.py" rel="nofollow">various <code>_communicate</code> methods here</a>) whenever you pass <code>subprocess.PIPE</code> for more than one of the standard handles; it's how you have to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use writing/reading from <code>stdin</code> and <code>stdout</code>, however depending on your subprocess, you need a "flushing mechanism" for the subprocess to process your input. The below code works for the first part, but since it closes <code>stdin</code>, it also kills the subprocess. If you change it with <code>flush()</code> or if you can add some trailing characters to push your subprocess, then you can use it. Else, I would recommend to take a look at <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow">Multithreading in Python</a>, especially <code>pipes</code>.</p>
<pre><code>p=subprocess.Popen(['tr','a-z','A-Z'],stdin=subprocess.PIPE,stdout=subprocess.PIPE)
p.stdin.write("hello\n")
p.stdin.close()
p.stdout.readline()
'HELLO\n'
</code></pre>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/14465154/4279">Sorting text file by using Python</a></span>
<span class="comment-copy">I started down a similar path (yours is much more elegant), but I then I saw this admonishment in the docs: "Warning Use communicate() rather than .stdin.write, .stdout.read or .stderr.read to avoid deadlocks due to any of the other OS pipe buffers filling up and blocking the child process." I understand the deadlock potential when a script is writing to a subprocess' stdin and reading from its stdout, but I don't understand the deadlock potential when the script and the subprocess are both streaming to stdout (as in your answer). Comments?</span>
<span class="comment-copy">@Reece: it doesn't apply here. The rule to avoid the deadlock in the general case is simple: never use PIPE unless you consume the corresponding pipe.</span>
<span class="comment-copy">That was my interpretation too. I appreciate the follow-up.</span>
<span class="comment-copy">I used this answer as the basis for tool that provides multi-file sort for files with headers. Headers are defined by # of lines, prefix, or regexp. Output headers are deduped. Custom sort options are permissible. Data also accepted from stdin.  It's here: <a href="https://bitbucket.org/reece/reece-base/src/a711b1ecc8a31c24c16ad8b759525c95becb0dd9/bin/header-sort?at=default&amp;fileviewer=file-view-default" rel="nofollow noreferrer">bitbucket.org/reece/reece-base/src/â€¦</a></span>
<span class="comment-copy">Upshot of chat for closure: We agreed that it's typically preferable to externalize a pipe when possible, but that the pipe above would indeed sort headers into the output. -30-</span>
<span class="comment-copy">there is a single pipe (subprocess' stdin). Why do you need multiple threads here?</span>
<span class="comment-copy">Yeah, my mistake. I assumed this was one of those "I'm trying to do what <code>communicate</code> does without using <code>communicate</code>" cases, and over answered. I've edited to explain how it works for the specific case with only a single <code>PIPE</code>-ed standard handle.</span>
<span class="comment-copy">It's really not safe with either <code>flush</code> or <code>close</code>; if you send enough data to the subprocess that its own output pipe fills, it will block. If you fill its input pipe, you block. And because it's waiting for you to read, and you're waiting for it to read, you deadlock, and never reach the <code>readline</code>. Also, if you <code>flush</code> instead of <code>close</code>, the subprocess may be block buffering its own output, so the <code>readline</code> could block forever (and you'd never return from the <code>readline</code> to send more data than might cause it to flush its buffer).</span>
