<div class="post-text" itemprop="text">
<p>I'm just going to post what I have so far and try to describe the problem.</p>
<p>The script bellow tracks a transform object with custom attributes. It creates an interface to easily <code>__get__</code> and <code>__set__</code> to a maya node's attributes. This makes it easy to save attribute values into a scene that can load with the scene in the future. In the script I was using OpenMaya to track a dagObject, but simplified to try to work through the problem first. If you want to use this code, look into MDagPath and MSelectionList.</p>
<p>Now..
<code>Attributes()</code> need to be declared outside of <code>__init__</code> to work correctly.
<code>Attributes()</code> as they are now, require a Transform() at creation.
If I create a <code>Transform()</code> outside of an <code>__init__</code> in the <code>Clip()</code>, the resulting <code>Transform()</code> instance will reference whatever latest <code>Transform()</code> was created by this method (image)</p>
<p>Can't post image without reputation, so descriptively:
three clips called _new_anim_, _new_anim_1, _new_anim_2.
When script bellow runs, the output from the list is all _new_anim_2, which is the last transform that was initialized.</p>
<p><code>__init__</code> happens <em>after</em> the Attributes are created.
I need to pass a <code>__init__</code> <code>Transform</code> instance to an already initialized Attribute instance.</p>
<p>How?</p>
<p>Saying <code>clip.transform = correctTransform</code> doesn't seem to replace the reference to <code>correctTransfrom</code>. I need a way to pass a class instance to a class variables that are initialized outside of the <code>__init__</code>.</p>
<pre><code>import maya.cmds as cmds

class Attribute(object):
    def __init__(self,transform,attr,*args):
        self.transform = transform
        self.attr = attr
        self.string = "string" in args
    def __set__(self, instance, value):
        if self.string:
            cmds.setAttr(self.transform.path()+"."+self.attr,value,dt="string")
        else:
            cmds.setAttr(self.transform.path()+"."+self.attr,value)
    def __get__(self, instance, owner):
        if self.string:
            return     cmds.getAttr(self.transform.path()+"."+self.attr,dt="string")
        return cmds.getAttr(self.transform.path()+"."+self.attr)

class Transform(object):
    def __init__(self):
        self.parent = ""
        self.name = ""
    def setObject(self,transform):
        self.parent = cmds.listRelatives(transform,p=1)[0]
        self.name = cmds.ls(transform,sn=1)[0]
    def path(self):
        return self.parent+"|"+self.name
    def getName(self):
        return cmds.ls(self.path(),sn=1)[0]
    def rename(self,value):
        self.name = cmds.ls(cmds.rename(self.path(),value),sn=1)[0]

class Clip(object):
    transform = Transform()
    start = Attribute(transform,"STA")
    end = Attribute(transform,"END")
    loop = Attribute(transform,"Loop")
    relative = Attribute(transform,"RelativeToStart")
    speedState = Attribute(transform,"SpeedState")
    speed = Attribute(transform,"SpeedVal")

    def __init__(self,transform):
        self.transform.setObject(transform)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I am understanding your question correctly, it looks like you want the <code>transform</code> variable in your <code>Clip</code> class to be a instance-specific value, but you're having problems because it needs to be accessed by the <code>Attribute</code> descriptors you're also adding to <code>Clip</code>, which need to be declared as class variables.</p>
<p>I think the solution to this is to have the <code>Attribute</code> class's <code>__get__</code> and <code>__set__</code> methods look for <code>transform</code> on the <code>instance</code> they are passed in, rather than on <code>self</code>.</p>
<p>Try this:</p>
<pre><code>class Attribute(object):
    def __init__(self,attr,*args): # no transform parameter or instance variable
        self.attr = attr
        self.string = "string" in args
    def __set__(self, instance, value): # look up transform on instance, rather than self
        if self.string:
            cmds.setAttr(instance.transform.path()+"."+self.attr,value,dt="string")
        else:
            cmds.setAttr(instance.transform.path()+"."+self.attr,value)
    def __get__(self, instance, owner): # here too
        if self.string:
            return     cmds.getAttr(instance.transform.path()+"."+self.attr,dt="string")
        return cmds.getAttr(instance.transform.path()+"."+self.attr)

# Transform can stay the same, though you could merge set_object into __init__

class Clip(object):
    # no more transform class variable
    start = Attribute("STA") # no more transform argument passed to the Attributes
    end = Attribute("END")
    loop = Attribute("Loop")
    relative = Attribute("RelativeToStart")
    speedState = Attribute("SpeedState")
    speed = Attribute("SpeedVal")

    def __init__(self,transform):
        self.transform = Transform() # create transform as an instance variable
        self.transform.setObject(transform)
</code></pre>
</div>
<span class="comment-copy">Oooooh my goodness. Thank you!!! That worked. Minor tweaking, but yay!!!</span>
<span class="comment-copy">You might want to <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">read up on descriptors</a> if you're going to be writing them yourself.</span>
<span class="comment-copy">I was basing all of this off of a method I've been using for maya guis at techartsurvival.blogspot.com. They work beautifully, and use a very similar method. However, that technique didn't need to pass information like this method was trying to do. I'd been scouring for info on the subject. Just didn't know how to pass the transform. I completely glossed over that Instance is the source the call is passed from.</span>
<span class="comment-copy">There's an even simpler version of the same trick at <a href="http://techartsurvival.blogspot.com/2014/03/descriptors-and-pythonic-may-properties.html" rel="nofollow noreferrer">techartsurvival.blogspot.com/2014/03/â€¦</a>.</span>
