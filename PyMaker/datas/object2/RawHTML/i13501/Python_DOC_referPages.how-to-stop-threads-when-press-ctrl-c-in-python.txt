<div class="post-text" itemprop="text">
<p>What I'm trying to do here is use a keyboard interrupt to exit all ongoing threads in the program. This is a pared down version of my code where the thread is created:</p>
<pre><code>for i in taskDictionary:
    try:
        sleep(60)
        thread = Thread(target = mainModule.executeThread)
        thread.start()
    except KeyboardInterrupt:
        thread.__stop()
</code></pre>
<p>The program itself is far more complicated, accounting for tons of different variables that affect the threads and even having the option to launch in a sequential mode, where tasks are not threaded, but instead launched one-by-one so there might be some problems with this small variation I just conjured up.
I have done this in ways that produced 50/50 results. The interrupts would work but the threads would never cleanly exit. Sometimes they would keep going but halt the execution of future threads, some times they would exit with a massive error regarding the interrupt, other times the interrupts would do nothing at all. Last time I ran this the program stopped any future threads from executing but did not stop the current thread.
Is there any way to exit the threads without going into the module the thread is actually executing in?</p>
</div>
<div class="post-text" itemprop="text">
<p>A similar question is "How do you kill a thread?"</p>
<p>You create an exit handler in your thread that is controlled by a lock or event object from the threading module. You then simply remove the lock or signal the event object. This informs the thread it should stop processing and exit gracefully. After signaling the thread in your main program, the only thing left to do is to use the <code>thread.join()</code> method in <code>main</code> which will wait for the thread to shut down.</p>
<p>A short example:</p>
<pre><code>import threading
import time

def timed_output(name, delay, run_event):
    while run_event.is_set():
        time.sleep(delay)
        print name,": New Message!"


def main():
    run_event = threading.Event()
    run_event.set()
    d1 = 1
    t1 = threading.Thread(target = timed_output, args = ("bob",d1,run_event))

    d2 = 2
    t2 = threading.Thread(target = timed_output, args = ("paul",d2,run_event))

    t1.start()
    time.sleep(.5)
    t2.start()

    try:
        while 1:
            time.sleep(.1)
    except KeyboardInterrupt:
        print "attempting to close threads. Max wait =",max(d1,d2)
        run_event.clear()
        t1.join()
        t2.join()
        print "threads successfully closed"

if __name__ == '__main__':
    main()
</code></pre>
<p>If you REALLY need the functionality of <em>killing</em> a thread, use multiprocessing. It allows you to send SIGTERMs to individual "processes" (it's also very similar to the threading module). Generally speaking, threading is for when you are IO-bound, and multiprocessing is for when you are truly processor-bound.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of options that don't require using locks or other signals between threads. One is setting the threads as <a href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" rel="nofollow noreferrer">daemons</a>, which will be killed off automatically when the main thread exits. The other is using <a href="https://stackoverflow.com/a/7752174/10826955">processes</a> instead, which have a terminate method you can call from the main process, if you needed to kill them and keep the main program running.</p>
<p>Both of these are especially useful if you have threads blocking on input. While using a timeout and periodically checking the signal would work in most cases without too much overhead, using daemons or processes eliminates the need for any busy loops or significant added complexity.</p>
<p>See the answers to <a href="https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread">this question</a> for more details on these solutions and discussion on the problem of killing threads.</p>
</div>
<span class="comment-copy">With a thread's cooperation, you can kill it any way you want. Without a thread's cooperation, there is no safe way to do it and all roads lead to pain.</span>
<span class="comment-copy">Brilliant answer! Not exactly what I was looking for but extensive enough that I was able to adapt the logic into what I needed! Thanks for that!</span>
<span class="comment-copy">I'm using a thread because I don't want an infinite while True loop. This wastes all of your CPU's time... pretty much literally. I've done something like this and without a sleep it cranks CPU% up to 100% for <b>seconds</b> at a time and with a small sleep, this only helps a little. Is there any way to do this <b>without</b> a while True?</span>
<span class="comment-copy">@Dylan The infinite loop was only meant to offer a pithy working example. Normally one would be completing some primary task in the main loop. Still, even <code>time.sleep(.001)</code> should reduce cpu load significantly. At <code>time.sleep(.010)</code> my python thread runs with less than 1% CPU. Threads should be used for IO bound processes, or resources which need to be checked periodically. The main loop should execute your primary code, and if it needs a resource, can likely afford to sleep for 50ms to wait. If processing is truly time sensitive, you can always utilize <code>lock</code> protocols to sleep and wake.</span>
<span class="comment-copy">What if the thread is blocked waiting on I/O. Does Event somehow wake it up.</span>
