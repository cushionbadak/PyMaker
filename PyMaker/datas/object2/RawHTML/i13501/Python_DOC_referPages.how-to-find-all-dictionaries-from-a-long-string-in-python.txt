<div class="post-text" itemprop="text">
<p>I am trying to retrieve all JSON like dictionaries from a long string. 
For example, </p>
<pre><code>{"uri": "something"} is referencing {"link": "www.aurl.com"}
</code></pre>
<p>I want to get <code>{"uri": "something"}</code> and <code>{"link": "www.aurl.com"}</code> as result. Is there a way to do this through regex in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably the "nicest" way to do this is to let a real JSON decoder do the work, not using horrible regexes. Find all open braces as "possible object start points", then try to parse them with <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder" rel="nofollow"><code>JSONDecoder</code></a>'s <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder.raw_decode" rel="nofollow"><code>raw_decode</code></a> method (which returns the object parsed and number of characters consumed on success making it possible to skip successfully parsed objects efficiently). For example:</p>
<pre><code>import json

def get_all_json(teststr):
    decoder = json.JSONDecoder()
    # Find first possible JSON object start point
    sliceat = teststr.find('{')
    while sliceat != -1:
        # Slice off the non-object prefix
        teststr = teststr[sliceat:]
        try:
            # See if we can parse it as a JSON object
            obj, consumed = decoder.raw_decode(teststr)
        except Exception:
            # If we couldn't, find the next open brace to try again
            sliceat = teststr.find('{', 1)
        else:
            # If we could, yield the parsed object and skip the text it was parsed from
            yield obj
            sliceat = consumed
</code></pre>
<p>This is a generator function, so you can either iterate the objects one by one e.g. <code>for obj in get_all_json(mystr):</code> or if you need them all at once for indexing, iterating multiple times or the like, <code>all_objs = list(get_all_json(mystr))</code>.</p>
</div>
<span class="comment-copy"><code>re.findall(r'\{[^}]*\}', s)</code></span>
<span class="comment-copy">@AvinashRaj: The flaw with that approach is that it can't handle nested objects. If the string was <code>{"uri": {"domain": "example.com", "protocol": "https"}, "foo": "bar"} is referencing {"link": "www.aurl.com"}</code>, your first capture would omit the <code>, "foo": "bar"}</code>, leaving you unparseable partial JSON as a result.</span>
<span class="comment-copy">Depending on your data, you may need to adjust the decoder configuration. For example, strict JSON forbids control characters, e.g. tabs, line feeds, etc., in strings, but sometimes real JSON has them. Passing <code>strict=False</code> to the <code>JSONDecoder</code> constructor will allow strings of that form to be parsed. Much more powerful customizations are also available, see <a href="https://docs.python.org/3/library/json.html#json.JSONDecoder" rel="nofollow noreferrer">the <code>JSONDecoder</code> docs</a>.</span>
<span class="comment-copy">If you just want the strings, rather than the decoded dictionaries, you can change <code>yield obj</code> to <code>yield teststr[:consumed]</code>. While this makes the <code>obj</code> generation a "waste", it's still much better to have a real JSON parser doing the work, rather than rolling your own, invariably bad replacement with regular expressions.</span>
<span class="comment-copy">Thank you ShadowRanger for the detail explanation. However the string I am parsing is known not to have any nested JSON. I will try Avinash's approach first, but will definitely keep your solution in mind. :)</span>
<span class="comment-copy">Please don't. Reinventing parsers unnecessarily is a cause of serious pain; <a href="https://cstheory.stackexchange.com/questions/3987/is-json-a-regular-language">JSON is not a regular language</a>; even though Python's regex dialect can handle more than a true regex engine, it's still nigh impossible to get it 100% correct. <a href="https://stackoverflow.com/a/1732454/364696">Like HTML, JSON cannot be parsed with regular expressions</a>. Example failure: <code>{"uri": "http://example.com/?res_id={3F2504E0-4F89-41D3-9A0C-0305E82C3301}"}</code> will fail even w/o nested JSON objects because the string itself has a close brace.</span>
