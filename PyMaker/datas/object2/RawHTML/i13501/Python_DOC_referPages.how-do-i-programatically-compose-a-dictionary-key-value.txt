<div class="post-text" itemprop="text">
<p>Given:</p>
<pre><code>dict_top = "trialdata[0]"
top_keys = ['offset', 'latitude', 'longitude']
</code></pre>
<p>The result I want is:
    trialdata[0]['offset'] # which will operate as a dictionary lookup when called</p>
<p>My code:</p>
<pre><code>call_key_line = "".join([dict_top, "[\'", top_keys[0], "\']"])
print(call_key_line)
print(trialdata[0]['offset'])
</code></pre>
<p>returns:</p>
<pre><code>trialdata[0]['offset']
-6
</code></pre>
<p>-6 is the right value, but how do I code call_key_line so it acts as a dictionary look up?  Right now printing call_key_line just prints out a string.  I suspect that's because the 0 in call_key_line is a string, not an integer.  But if I try to change it with </p>
<pre><code>call_key_line[10] = 0
</code></pre>
<p>I get TypeError: 'str' object does not support item assignment  </p>
<p>Is there any way to compose the dictionary lookup within the program (rather than hard coding)?  I have several keys and dicts and I want to loop through them and collect their values.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer is not to generate code as strings.</p>
<p>Abstract the operations you want to perform and encapsulate them in functions.  For example, to get the "offset":</p>
<pre><code>def get_offset(d):
    return d['offset']
</code></pre>
<p>Then you can call this with each of your dictionaries:</p>
<pre><code>print( get_offset( trialdata[0] ) )

for d in trialdata:
    print( get_offset(d) )
</code></pre>
<p>Or if you want to do the same operation on each key:</p>
<pre><code>top_keys = ['offset', 'latitude', 'longitutde']
def print_values(d):
    for key in top_keys:
        print( d[key] )

def change_all_values(d):
    for key in top_keys:
        d[key] = "Hello World"

for d in trialdata:
    print_values(d)
    change_all_values(d)
</code></pre>
<p>You may want to consider using <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow">classes</a> instead of dictionaries so you can encapsulate the operations you will perform on each.</p>
<pre><code>class MyData:
    def __init__(self, offset, lat, long):
        self.offset = offset
        self.latitude = lat
        self.longitutde = long

    def print_offset(self):
        print( self.offset )

    def change_offset(self, val):
        self.offset = val

    def __str__(self):
        return "offset: %s, coordinates: (%d, %d)" % (
                    self.offset, self.latitude, self.longitutde)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>based on your pastbin comment:</p>
<pre><code>for dict_x in [dict_top, dict_daily, dict_current]:
    for i in data_list:
        for k in top_keys:
            if k in dict_x:
                continue
            else:
                dict_x[k] = -9999
</code></pre>
<p>What are you doing with <code>i</code>?  It seems extraneous.  </p>
<p>Is it possible one of <code>dict_top</code>, <code>dict_daily</code>, or <code>dict_current</code> is a string and not a dictionary?  It looks like they may be all strings?  Have you tried removing the quotes surrounding their definitions?</p>
<p>Line 47 is also suspicious (may be copy-paste error):</p>
<pre><code>dict_dailthis_dicy = "data_list[i]['daily']['data'][0]"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks again to all who commented.  The answer I found was the .get() method.  I was directed to it via a Reddit forum (<a href="https://www.reddit.com/r/learnpython/comments/3l2sgq/how_do_i_programatically_compose_a_dictionary_key/" rel="nofollow">https://www.reddit.com/r/learnpython/comments/3l2sgq/how_do_i_programatically_compose_a_dictionary_key/</a>)</p>
<p>I was going down the path that I needed to retrieve the value from the dict and then examine the result, and insert a replacement value if I didn't find that particular key. </p>
<p>Using dict.get(key, default_value) accomplishes exactly what I was trying to do - insert a default value when a given key is not found.</p>
</div>
<span class="comment-copy">I'm not sure what you're asking. Can you add the full code you're trying to run? Including where you create these dictionaries.</span>
<span class="comment-copy">What?! Why are you messing with strings?</span>
<span class="comment-copy">You mean you want the string <code>trialdata[0]['offset']</code> to be converted to a dictionary lookup? Why not just use <code>trialdata[0][top_keys[0]]</code>?</span>
<span class="comment-copy">Better still: what is the actual underlying problem you are trying to solve here? Why do you think you need to evaluate a Python expression from a string?</span>
<span class="comment-copy">You are allowed to use a string variable as a dictionary index, such as  my_dict = {} ... my_dict[string_variable] = my_value</span>
<span class="comment-copy"><a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">Eval really is dangerous</a></span>
<span class="comment-copy"><code>.get()</code> does <i>not</i> insert a value. It will return to you the default you provided when the key is not present but does not modify the dictionary to make it be present. It may be that is all you really needed and you don't actually need to insert the value. As ebyrob's answer shows, you can test for the present of a key using the <code>in</code> operator and then assign a value when it is not present.</span>
<span class="comment-copy">@dsh  Thanks for that point.  It turns out I just need a default in the csv I'm building - not in the original data.  So .get(key, default_value) works perfectly for me.</span>
