<div class="post-text" itemprop="text">
<p>I have got one problem with Python. I'm trying to repeat a for loop more than once. I have a condition inside the loop, and if the condition is true, the loop should start again. I need the solution only with one for loop. For example:</p>
<pre><code>for i in range (10):
    if i==4:
        i=0
    print(i) 
</code></pre>
<p>Unfortunately this doesn't work.</p>
<p>The output should be: <code>0 1 2 3 0 1 2 3 0 1 2 3...</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Writing to the loop's variable (<code>i</code>) inside the loop is always not a good idea (that includes all languages I'm familiar with).</p>
<p>Try using a while loop instead:</p>
<pre><code>i = 0
while i &lt; 10:
    i += 1
    if i == 4:
        i = 0
</code></pre>
<p>The same logic can be implemented with:</p>
<pre><code>while True:
    for i in range(4):
        print(i)
</code></pre>
<p>Or using the modulo operator which is common when cycling:</p>
<pre><code>i = 0
while True:
    print(i % 4)
    i += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a version using <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a>:</p>
<pre><code>from itertools import cycle

for i in cycle(range(4)):
    # put your logic that `break`s the cycle here
    print(i) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Converting the through away variable <code>i</code> to 0 at the bottom level of the loop doesn't mean that in next iteration your variable shall be 0, because in each iteration python reassigned it automatically.</p>
<p>As a more pythonic way for such tasks you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a></p>
<pre><code>&gt;&gt;&gt; def range_printer(r,N): # r is the length of your range and N is the number of sequence printing 
...     a=cycle(range(r))
...     for i in range(N*r):
...         print next(a)
... 
&gt;&gt;&gt; range_printer(4,3)
0
1
2
3
0
1
2
3
0
1
2
3
</code></pre>
<p>Or you can use <code>yield</code> to return a generator :</p>
<pre><code>&gt;&gt;&gt; def range_printer(r,N):
...     a=cycle(range(r))
...     for i in range(N*r):
...         yield next(a)
... 
&gt;&gt;&gt; list(range_printer(4,3))
[0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">OP, what you are trying to do sounds like a bad idea in general. Structured programming doesn't usually work well with <code>goto</code>, <code>continue</code> and <code>break</code>, much less randomly fiddling with the loop index. There is a <a href="https://en.wikipedia.org/wiki/Considered_harmful" rel="nofollow noreferrer">famous historic paper</a> on the subject. Also, consider <code>print [x % 4 for x in range(10)]</code>for a more pythonic way :)</span>
<span class="comment-copy">@TobiaTesan What's wrong with <code>continue</code> and <code>break</code>?</span>
<span class="comment-copy">@mkrieger1 maybe <code>filter</code> and <code>next</code> are better abstractions.</span>
<span class="comment-copy">@mkrieger1: there is <i>a lot</i> of literature about it, from the EWD paper to <a href="http://homepages.tig.com.au/~ijoyner/Ian_Joyner/Structured_Programming.html" rel="nofollow noreferrer">this one</a>. TL;DR the main contention point is that early exit generally undermines structured programming which is at its cleanest with exactly 1 entry and 1 exit point. Of course there are times when a <code>break</code> here and there is actually a good idea, but I suspect it's better that <b>OP stays away from them for the time being</b>.</span>
<span class="comment-copy">I have tried it with while,but TLE,so there'll be problem with my algorithm maybe</span>
<span class="comment-copy">no modules imported...nice</span>
<span class="comment-copy">Still itertools.cycle is probably what OP wants / should use.</span>
<span class="comment-copy">And you cant really change i variable as it is dynamically yielded by range.</span>
<span class="comment-copy">Why people always say you can't change (rebind) i?? Of course you can. Set i to 8 before printing, and you'll see 8 printed. The only thing is that range yields the next value independently of what i is set to.</span>
<span class="comment-copy">@Veky Indeed but that's another scenario, pls check the edit! and thanks for attention!</span>
