<div class="post-text" itemprop="text">
<p>I've been switching from Matlab to NumPy/Scipy, and I think NumPy is great in many aspects.</p>
<p>But one thing that I don't feel comfortable is that I cannot find a  data structure similar to <code>struct</code> in C/C++.</p>
<p>For example, I may want to do the following thing:</p>
<pre><code>struct Parameters{
  double frame_size_sec;
  double frame_step_sec;
}
</code></pre>
<p>One simplest way is using a dictionary as follows. </p>
<pre><code>  parameters = {"frame_size_sec" : 0.0, "frame_step_sec", 0.0}
</code></pre>
<p>But in case of a dictionary, unlike struct, any keys may be added. I'd like to restrict keys.</p>
<p>The other option might be using a class as follows. But it also has the same type of problems.</p>
<pre><code>class Parameters:
  frame_size_sec = 0.0
  frame_step_sec = 0.0
</code></pre>
<p>From a thread, I saw that there is a data structure called named tuple, which looks great, but the biggest problem with it is that fields are immutable. So it is still different from what I want.</p>
<p>In sum, what would be the best way to use a struct-like object in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need actual memory layout guarantees, user-defined classes can restrict their set of instance members to a fixed list using <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__" rel="nofollow"><code>__slots__</code></a>. So for example:</p>
<pre><code>class Parameters:  # On Python 2, class Parameters(object):, as __slots__ only applies to new-style classes
    __slots__ = 'frame_size_sec', 'frame_step_sec'
    def __init__(self, frame_size_sec=0., frame_step_sec=0.):
        self.frame_size_sec = float(frame_size_sec)
        self.frame_step_sec = float(frame_step_sec)
</code></pre>
<p>gets you a class where on initialization, it's guaranteed to assign two <code>float</code> members, and no one can add new instance attributes (accidentally or on purpose) to any instance of the class.</p>
<p>Please read the caveats at the <code>__slots__</code> documentation; in inheritance cases for instance, if a superclass doesn't define <code>__slots__</code>, then the subclass will still have <code>__dict__</code> and therefore can have arbitrary attributes defined on it.</p>
<p>If you need memory layout guarantees and stricter (C) types for variables, you'll want to look at <a href="https://docs.python.org/3/library/ctypes.html#structures-and-unions" rel="nofollow">ctypes Structures</a>, but from what you're saying, it sounds like you're just trying to enforce a fixed, limited set of attributes, not specific types or memory layouts.</p>
</div>
<div class="post-text" itemprop="text">
<p>While taking the risk of not being very Pythonic, you can create an immutable dictionary by subclassing the <code>dict</code> class and overwriting some of its methods:</p>
<pre><code>def not_supported(*args, **kwargs):
        raise NotImplementedError('ImmutableDict is immutable')


class ImmutableDict(dict):
    __delitem__ = not_supported
    __setattr__ = not_supported
    update = not_supported
    clear = not_supported
    pop = not_supported
    popitem = not_supported

    def __getattr__(self, item):
        return self[item]

    def __setitem__(self, key, value):
        if key in self.keys():
            dict.__setitem__(self, key, value)
        else:
            raise NotImplementedError('ImmutableDict is immutable')
</code></pre>
<p>Some usage examples:</p>
<pre><code>my_dict = ImmutableDict(a=1, b=2)
print my_dict['a']
&gt;&gt; 1
my_dict['a'] = 3 # will work, can modify existing key
my_dict['c'] = 1 # will raise an exception, can't add a new key
print my_dict.a # also works because we overwrote __getattr__ method
&gt;&gt; 3
</code></pre>
</div>
<span class="comment-copy">FYI, using <code>__slots__</code> does have some advantages. CPU-wise, it's basically irrelevant, but it reduces the per-instance memory cost significantly. On Python 3.4 (64 bit), for a 2 variable instance, the overhead of the object structure plus the structure for its <code>__dict__</code> is 152 bytes, vs. 56 bytes for the object structure (and no <code>__dict__</code>) if it's defined with <code>__slots__</code>. The difference on Python 2 is even more extreme (because Python 2 lacks shared-key dictionaries; the base object structure in both cases uses 64 bytes, but the <code>__dict__</code> required w/o <code>__slots__</code> takes it up to 344 bytes).</span>
<span class="comment-copy">That doesn't have a class wide limitation on the set of fields, it just limits you to defining the fields at instantiation time (and the OP explicitly said he didn't want immutable fields).</span>
<span class="comment-copy">@ShadowRanger I've edited my answer to allow modifying existing keys but not allowing to add new keys, which is exactly what the OP wants.</span>
<span class="comment-copy">Might want to have <code>__setattr__ = __setitem__</code> so <code>my_dict.a = 3</code> works without exposing the "it's really a dictionary, not an object" thing too obviously.</span>
