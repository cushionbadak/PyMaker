<div class="post-text" itemprop="text">
<p>I want to mock one of the model's methods in my tests. This is my model with the method I want to mock</p>
<pre><code>class Customer(models.Model):
    # Fields ...

    def save(self, *args, **kwargs):

        update_collector = self.id is None

        super(Customer, self).save(*args, **kwargs)

        if update_collector:
            self.send_to_address_book()

    def send_to_address_book(self):  # This is the method I want mocked
        email = self.user.email
        first_name = self.user.first_name
        last_name = self.user.last_name
        print("This is not being mocked")

        investigate_customer.apply_async(
            args=[first_name, last_name, email]
        )
</code></pre>
<p>Then, I want all the tests that inherit from <code>CustomerTestCase</code> to mock <code>send_to_address_book</code></p>
<pre><code>class CustomerTestCase(object):
    @mock.patch('accounts.models.Customer.send_to_address_book')
    def create_user_and_customer(self, name, mock_method):
        mock_method.return_value = None
        if not name:
            name = 'test'
        email = name + '@test.si'
        user = User.objects.create_user(name, email)
        customer = Customer.objects.create(user=user)
        return user, customer
</code></pre>
<p>However, when I run the following tests, <code>send_to_address_book</code> is not mocked.</p>
<pre><code>class CustomerQueriesTest(CustomerTestCase, TestCase):
    def setUp(self):
        G(Language, code='en', name='English')
        self.user, self.customer = self.create_user_and_customer()

    def test_queries_running(self):
        profile = self.user.profile
        resp = self.user.profile.queries_running()
        self.assertEqual(resp, 0)
        G(Package)  # using Django dynamic fixtures to create a new Package
</code></pre>
<p>What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>So, I found what was the issue.</p>
<p>Partly, it was the problem of default settings of <a href="https://github.com/paulocheque/django-dynamic-fixture" rel="nofollow">DDF</a> - if a model field is blank/null it will still fill it by default. So when a <code>Package</code> was created with DDF, it also created a <code>Customer</code> because of a FK.</p>
<p>The second part of the problem was, that <code>Package</code> is in a different module than <code>Customer</code> so <code>@mock.patch('accounts.models.Customer.send_to_address_book')</code> did nothing (see <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">Python docs</a> for more details). I had to add a second patch, which took care of when a <code>Customer</code> was created through <code>Package</code>: </p>
<pre><code>@mock.patch('billing.models.Customer.send_to_address_book')
</code></pre>
</div>
<span class="comment-copy">Perhaps this give you a hint: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#where-to-patch</a></span>
