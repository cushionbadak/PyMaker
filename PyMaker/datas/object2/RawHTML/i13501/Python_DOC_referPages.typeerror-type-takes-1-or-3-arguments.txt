<div class="post-text" itemprop="text">
<p>I have a TypeClass to make Class:</p>
<pre><code>class MyMetaClass(type):

    def __new__(cls, *args, **kwargs):
        print('call __new__ from MyMetaClass.')
        return type(cls.__name__, *args, **kwargs)
</code></pre>
<p>but when use it :</p>
<pre><code>Foo= MyMetaClass('Foo', (), {'name':'pd'})
</code></pre>
<p>raise Error :</p>
<pre><code>TypeError: type() takes 1 or 3 arguments
</code></pre>
<p>if Change it like :</p>
<pre><code>class MyMetaClass(type):
    def __new__(cls, *args, **kwargs):
        print('call __new__ from MyMetaClass.')
        return type(cls.__name__, (), {})
</code></pre>
<p>it will works okey ! 
where is problem ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__new__</code> method is passed <em>3</em> positional arguments in <code>args</code>; the class name, the baseclasses and the class body. The <code>cls</code> argument is bound to the <em>metaclass</em>, so <code>MyMetaClass</code> here.</p>
<p>You are adding another name to that sequence; drop the name, or remove the first argument from <code>args</code>:</p>
<pre><code>class MyMetaClass(type):
    def __new__(cls, *args, **kwargs):
        print('call __new__ from MyMetaClass.')
        return type(*args, **kwargs)
</code></pre>
<p>or</p>
<pre><code>class MyMetaClass(type):
    def __new__(cls, *args, **kwargs):
        print('call __new__ from MyMetaClass.')
        return type(cls.__name__, *args[1:], **kwargs)
</code></pre>
<p>The <code>cls</code> argument is the <em>metaclass object</em> however, so unless you want all your classes to be called <code>MyMetaClass</code> I'd stick with the first option.</p>
<p>See the <a href="https://docs.python.org/2/reference/datamodel.html#customizing-class-creation" rel="nofollow"><em>Customizing class creation</em> section</a> of the Python data model:</p>
<blockquote>
<p>These steps will have to be performed in the metaclass’s <code>__new__()</code> method – <code>type.__new__()</code> can then be called from this method to create a class with different properties. This example adds a new element to the class dictionary before creating the class:</p>
<pre><code>class metacls(type):
    def __new__(mcs, name, bases, dict):
        dict['foo'] = 'metacls was here'
        return type.__new__(mcs, name, bases, dict)
</code></pre>
</blockquote>
<p>and the <a href="https://docs.python.org/2/reference/datamodel.html#object.__new__" rel="nofollow"><code>object.__new__</code> documentation</a>:</p>
<blockquote>
<p><code>__new__()</code> is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument. The remaining arguments are those passed to the object constructor expression (the call to the class).</p>
</blockquote>
<p>where <em>class of which an instance was requested</em> is your metaclass (producing a class object).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class MyMetaClass(type):
...     def __new__(cls, *args, **kwargs):
...         print('call __new__ from MyMetaClass.')
...         return type(*args, **kwargs)
... 
&gt;&gt;&gt; class Foo(object):
...     __metaclass__ = MyMetaClass
... 
call __new__ from MyMetaClass.
&gt;&gt;&gt; Foo
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; class MyMetaClass(type):
...     def __new__(cls, *args, **kwargs):
...         print('call __new__ from MyMetaClass.')
...         return type(cls.__name__, *args[1:], **kwargs)
... 
&gt;&gt;&gt; class Foo(object):
...     __metaclass__ = MyMetaClass
... 
call __new__ from MyMetaClass.
&gt;&gt;&gt; Foo
&lt;class '__main__.MyMetaClass'&gt;
&gt;&gt;&gt; # Note the  ^^^^^^^^^^^^ class.__name__ attribute here
...
</code></pre>
</div>
<span class="comment-copy">is it beacuse <b>new</b> is a classmethod ?</span>
<span class="comment-copy">@ZeroDays: <code>__new__</code> is a <code>staticmethod</code>, actually, with <code>cls</code> being passed in explicitly by Python. See the <a href="https://docs.python.org/2/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>object.__new__</code> documentation</a>. When you create the (meta) class Python automatically wraps it in a <code>staticmethod</code> object.</span>
<span class="comment-copy">but in your exmp  Foo is Class <b>main</b>.MyMetaClass !!! but if use type -&gt; &gt;&gt;&gt; Foo=type('Foo', (), {}) &gt;&gt;&gt; Foo &lt;class '<b>main</b>.Foo'&gt; name here is Foo not type ! why ?</span>
<span class="comment-copy">@ZeroDays: I explained that; because your code passes in <code>cls.__name__</code> instead of <code>args[0]</code> as the name argument to <code>type()</code>.</span>
<span class="comment-copy">@ZeroDays: I used Python 2 notation for specifying the Metaclass. In Python 3, it is part of the first line: <code>class Foo(object, metaclass=MyMetaClass): pass</code>. See the <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer">Python 3 documentation</a>.</span>
