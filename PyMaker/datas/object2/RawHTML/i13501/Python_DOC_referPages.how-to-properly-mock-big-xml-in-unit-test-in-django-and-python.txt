<div class="post-text" itemprop="text">
<p>I want to unit test a method in my XML parser. The method takes an XML element, parses it into Django model object and returns this object.</p>
<p>I have already written unit tests for parsers, but they required a small bits of XML and I could just paste these bits in string, like:</p>
<pre><code>xml = ElementTree.fromstring('&lt;xml&gt;&lt;item&gt;content&lt;/item&gt;&lt;/xml&gt;')
</code></pre>
<p>But now I have to pass an XML entity that seems too big for storing it in unit test file itself.</p>
<p>I was thinking to save it to file and then load from it, but I can't fugure out where to put the file and do not break Django conventions about app structure.</p>
<p>Is there a "Django" or "pythonic" way to mock this XML?</p>
</div>
<div class="post-text" itemprop="text">
<p>I usually create a fixtures folder (which you can configure within your Django settings file).
This is usually used for json fixtures, but it is perfectly ok to add XML files there as well.
You can load and read those XML files through the <code>setUp</code> method that unittest provides (<a href="https://docs.python.org/3/library/unittest.html#module-unittest" rel="nofollow">https://docs.python.org/3/library/unittest.html#module-unittest</a>).
Then just use it as you would within your project.
A quick example:</p>
<pre><code>import os
from django.test import TestCase
from django.conf import settings
import xml.etree.ElementTree as ET

# Configure your XML_FILE_DIR inside your settings, this can be the
# same dir as the FIXTURE_DIR that Django uses for testing.
XML_FILE_DIR = getattr(settings, 'XML_FILE_DIR')


class MyExampleTestCase(TestCase):

    def setUp(self):
        """
        Load the xml files and pass them to the parser.
        """
        test_file = os.path.join(XML_FILE_DIR, 'my-test.xml')
        if os.path.isfile(test_file):
            # Through this now you can reffer to the parser through
            # self.parser.
            self.parser = ET.parse(test_file)
            # And of course assign the root as well.
            self.root = self.parser.getroot()
</code></pre>
</div>
<span class="comment-copy">Thanks for sharing your approach. I thought about fixtures dir, but I assumed that Django will try to automatically load them to database every time when running <code>migrate</code>. But now I see in docs that this behavior is deprecated since 1.7 (and doesn't work if application is using migrations) <a href="https://docs.djangoproject.com/en/1.8/howto/initial-data/#automatically-loading-initial-data-fixtures" rel="nofollow noreferrer">docs.djangoproject.com/en/1.8/howto/initial-data/â€¦</a></span>
