<div class="post-text" itemprop="text">
<p>I am using Python to implement the following equation:</p>
<blockquote>
<p>S[n+1] = (k * S[n]) MOD m The values of the variables are: S[0] = 1111
  k = 16807 m = 2147483647 I have calculate 10000 values (so S[0] to
  S[9999]).</p>
</blockquote>
<p>I am using lists to calculate and append the values.
This is what I am doing:</p>
<pre><code># Respective values of k, m and Seed value S[0] in sList
k = 16807
m = 2147483647
sList = [1111]

# Populating the list/array for 10000 iterations
while len(sList) &lt; 10000:
   Sn = (k * sList[-1]) % m
   sList.append(Sn)
print (sList)
</code></pre>
<p>While the code works perfectly for smaller values of k and m, I am getting incorrect results S[2] onwards.
I manually calculated S[2]=1417880224, however my code is generating S[2] = 297389177.</p>
<p>Is this happening because the numbers I am trying to append in the list is going beyond a certain range? Do I need to type cast to a different data type (like double)?
Where am I going wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's do it by hand using your definitions with a <a href="https://docs.python.org/3/tutorial/introduction.html#using-python-as-a-calculator" rel="nofollow">calculator</a>:</p>
<pre><code>&gt;&gt;&gt; 1111
1111
&gt;&gt;&gt; (16807 * 1111) % 2147483647
18672577
&gt;&gt;&gt; (16807 * 18672577) % 2147483647
297389177
</code></pre>
<p>These are the same results your code produces.</p>
<p>So, it seems like either your hand calculations or the recursive formula you are providing is wrong.</p>
</div>
<span class="comment-copy">Thanks a ton! I was indeed using a buggy calculator :(</span>
