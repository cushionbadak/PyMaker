<div class="post-text" itemprop="text">
<p>I try to embed a Python script into my C++ program. After reading some things about embedding and extending I understand how to open my own python script and how to pass some integers to it. But now I'm at a point a do not understand how to resolve my problem. I have to do both, calling Python functions from C++ and calling C++ functions from my embedded Python script. But I do not know where I have to start. I know I have to compile a .so file to expose my C++ functions to Python but this is nothing I can do, because I have to embed my Python file and control it by using C++ code (I have to extend a large software with a script language, to make some logic easy to edit).</p>
<p>So, is there any way to do both things? Calling Python functions from C++ and calling C++ functions from Python?</p>
<p>This is my C++ code</p>
<pre><code>#include &lt;Python.h&gt;
#include &lt;boost/python.hpp&gt;
using namespace boost::python;


// &lt;----------I want to use this struct in my python file---------
struct World
{
    void set(std::string msg) { this-&gt;msg = msg; }
    std::string greet() { return msg; }
    std::string msg;
};


// Exposing the function like its explained in the boost.python manual
// but this needs to be compiled to a .so to be read from the multiply.py
BOOST_PYTHON_MODULE(hello)
{
    class_&lt;World&gt;("World")
        .def("greet", &amp;World::greet)
        .def("set", &amp;World::set)
    ;
}
// &lt;---------------------------------------------------------------


int
main(int argc, char *argv[]) // in the main function is only code for embedding the python file, its not relevant to this question
{
    setenv("PYTHONPATH",".",1);
    PyObject *pName, *pModule, *pDict, *pFunc;
    PyObject *pArgs, *pValue;
    int i;

    if (argc &lt; 3) {
        fprintf(stderr,"Usage: call pythonfile funcname [args]\n");
        return 1;
    }

    Py_Initialize();
    pName = PyString_FromString(argv[1]);
    /* Error checking of pName left out */

    pModule = PyImport_Import(pName);
    Py_DECREF(pName);

    if (pModule != NULL) {
        pFunc = PyObject_GetAttrString(pModule, argv[2]);
        /* pFunc is a new reference */

        if (pFunc &amp;&amp; PyCallable_Check(pFunc)) {
            pArgs = PyTuple_New(argc - 3);
            for (i = 0; i &lt; argc - 3; ++i) {
                pValue = PyInt_FromLong(atoi(argv[i + 3]));
                if (!pValue) {
                    Py_DECREF(pArgs);
                    Py_DECREF(pModule);
                    fprintf(stderr, "Cannot convert argument\n");
                    return 1;
                }
                /* pValue reference stolen here: */
                PyTuple_SetItem(pArgs, i, pValue);
            }
            pValue = PyObject_CallObject(pFunc, pArgs);
            Py_DECREF(pArgs);
            if (pValue != NULL) {
                printf("Result of call: %ld\n", PyInt_AsLong(pValue));
                Py_DECREF(pValue);
            }
            else {
                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                PyErr_Print();
                fprintf(stderr,"Call failed\n");
                return 1;
            }
        }
        else {
            if (PyErr_Occurred())
                PyErr_Print();
            fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
        }
        Py_XDECREF(pFunc);
        Py_DECREF(pModule);
    }
    else {
        PyErr_Print();
        fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
        return 1;
    }
    Py_Finalize();
    return 0;
}
</code></pre>
<p>and this is my Python file</p>
<pre><code>import hello_ext #importing the C++ file works only if its compiled as a .so
planet = hello.World() #this class should be exposed to python
planet.set('foo')

def multiply(a,b):
    planet.greet()
    print "Will compute", a, "times", b
    c = 0
    for i in range(0, a):
        c = c + b
    return c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In short, Python extensions that are statically linked with embedded Python need to have their module initializer function explicitly added to the initialization table before the interpreter is initialized.</p>
<pre class="lang-cpp prettyprint-override"><code>PyImport_AppendInittab("hello", &amp;inithello);
Py_Initialize();
</code></pre>
<hr/>
<p>Boost.Python uses the <a href="http://www.boost.org/doc/libs/1_59_0/libs/python/doc/v2/module.html#BOOST_PYTHON_MODULE-spec" rel="noreferrer"><code>BOOST_PYTHON_MODULE</code></a> macro to define a Python module initializer.  The resulting function is not the module importer.  This difference is similar to that of creating a <code>example.py</code> module and calling <code>import example</code>.</p>
<p>When importing a module, Python will first check if the module is a built-in module.  If the module is not there, then Python will then search the <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="noreferrer">module search path</a> trying to find a python file or library based on the module name.  If a library is found, then Python expects the library to provide a function that will initialize the module.  Once found, the import will create an empty module in the modules table, then initialize it.  For statically linked modules, such as <code>hello</code> in the original code, the module search path will not be helpful, as there is no library for it to find.</p>
<p>For embedding, the <a href="https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function" rel="noreferrer">module table and initialization function</a> documentation states that for static modules, the module initializer function will not be automatically called unless there is an entry in the initialization table.  For Python 2 and Python 3, one can accomplish this by calling  <a href="https://docs.python.org/3/c-api/import.html#c.PyImport_AppendInittab" rel="noreferrer"><code>PyImport_AppendInittab()</code></a> before <a href="https://docs.python.org/3/c-api/init.html#c.Py_Initialize" rel="noreferrer"><code>Py_Initialize()</code></a>:</p>
<pre class="lang-cpp prettyprint-override"><code>BOOST_PYTHON_MODULE(hello)
{
  // ...
}

PyImport_AppendInittab("hello", &amp;inithello);
Py_Initialize();
// ...
boost::python::object hello = boost::python::import("hello");
</code></pre>
<p>Also note that the Python's C API for embedding changed naming conventions for module initialization functions between Python 2 and 3, so for <code>BOOST_PYTHON_MODULE(hello)</code>, one may need to use <code>&amp;inithello</code> for Python 2 and <code>&amp;PyInit_hello</code> for Python 3.</p>
<hr/>
<p>Here is  a complete example <a href="http://coliru.stacked-crooked.com/a/ff54ee8e667acc8e" rel="noreferrer">demonstrating</a> having an embedded Python import a <code>demo</code> user module, that will then import a statically linked <code>hello</code> module.  It also invokes a function in the user module <code>demo.multiply</code>, that will then invoke a method exposed through the statically linked module.</p>
<pre class="lang-cpp prettyprint-override"><code>#include &lt;cstdlib&gt;  // setenv, atoi
#include &lt;iostream&gt; // cerr, cout, endl
#include &lt;boost/python.hpp&gt;

struct World
{
  void set(std::string msg) { this-&gt;msg = msg; }
  std::string greet()       { return msg;      }
  std::string msg;
};

/// Staticly linking a Python extension for embedded Python.
BOOST_PYTHON_MODULE(hello)
{
  namespace python = boost::python;
  python::class_&lt;World&gt;("World")
    .def("greet", &amp;World::greet)
    .def("set", &amp;World::set)
    ;
}

int main(int argc, char *argv[])
{
  if (argc &lt; 3)
  {
    std::cerr &lt;&lt; "Usage: call pythonfile funcname [args]" &lt;&lt; std::endl;
    return 1;
  }
  char* module_name   = argv[1];
  char* function_name = argv[2];

  // Explicitly add initializers for staticly linked modules.
  PyImport_AppendInittab("hello", &amp;inithello);

  // Initialize Python.
  setenv("PYTHONPATH", ".", 1);
  Py_Initialize();

  namespace python = boost::python;
  try
  {
    // Convert remaining args into a Python list of integers.
    python::list args;
    for (int i=3; i &lt; argc; ++i)
    {
      args.append(std::atoi(argv[i]));
    }

    // Import the user requested module.
    // &gt;&gt;&gt; import module
    python::object module = python::import(module_name);

    // Invoke the user requested function with the provided arguments.
    // &gt;&gt;&gt; result = module.fn(*args)
    python::object result = module.attr(function_name)(*python::tuple(args));

    // Print the result.
    std::cout &lt;&lt; python::extract&lt;int&gt;(result)() &lt;&lt; std::endl;
  }
  catch (const python::error_already_set&amp;)
  {
    PyErr_Print();
    return 1;
  }

  // Do not call Py_Finalize() with Boost.Python.
}
</code></pre>
<p>Contents of <code>demo.py</code>:</p>
<pre class="lang-python prettyprint-override"><code>import hello
planet = hello.World()
planet.set('foo')

def multiply(a,b):
    print planet.greet()
    print "Will compute", a, "times", b
    c = 0
    for i in range(0, a):
        c = c + b
    return c
</code></pre>
<p>Usage:</p>
<pre class="lang-none prettyprint-override"><code>$ ./a.out demo multiply 21 2
foo
Will compute 21 times 2
42
</code></pre>
<p>In the above code, I opted to use Boost.Python instead of the Python/C API, with the C++ comments annotated with the equivalent Python code.  I find it to be much more succinct and far less error prone.  If a Python error occurs, Boost.Python will throw an exception and all reference counting will be handled appropriately.</p>
<p>Also, when using Boost.Python, do not invoke <a href="http://docs.python.org/2/c-api/init.html#Py_Finalize" rel="noreferrer"><code>Py_Finalize()</code></a>.  Per the <a href="http://www.boost.org/doc/libs/1_59_0/libs/python/doc/tutorial/doc/html/python/embedding.html" rel="noreferrer">Embedding - Getting started</a> section:</p>
<blockquote>
<p>Note that at this time you must not call <code>Py_Finalize()</code> to stop the interpreter. This may be fixed in a future version of boost.python.</p>
</blockquote>
</div>
<span class="comment-copy">If its not clear, I look for something like the <code>lua_register(lua_State* L, string name, function func)</code> for python.</span>
