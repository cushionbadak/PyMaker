<div class="post-text" itemprop="text">
<p>I'm experimenting with the regex RE module in Python 2.7. Documentation states that in the re.sub() function the count parameter is optional. If it's missing or set to 0, all matches will be substituted. But that's not quite the case. Notice in particular the difference in handling when 're.I' or 're.M' are present but group parameter missing:</p>
<pre><code>Python 2.7.9 (default, Mar  1 2015, 12:57:24) 
[GCC 4.9.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import re
&gt;&gt;&gt; a = "The brown fox over the little doggy which moved."
&gt;&gt;&gt; b = re.sub(r'o\w','au',a)
&gt;&gt;&gt; print b
The braun fau auer the little daugy which maued.
&gt;&gt;&gt; b = re.sub(r'o\w','au',a,2)
&gt;&gt;&gt; print b
The braun fau over the little doggy which moved.
&gt;&gt;&gt; b = re.sub(r'o\w','au',a,re.I)
&gt;&gt;&gt; print b
The braun fau over the little doggy which moved.
&gt;&gt;&gt; b = re.sub(r'o\w','au',a,flags=re.I)
&gt;&gt;&gt; print b
The braun fau auer the little daugy which maued.
&gt;&gt;&gt; b = re.sub(r'o\w','au',a,re.M)
&gt;&gt;&gt; print b
The braun fau auer the little daugy which maued.
</code></pre>
<p>Is this expected behaviour in Python generally? If so, doesn't that mean that the code is unreliable?</p>
</div>
<div class="post-text" itemprop="text">
<p>Note the declaration of <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a>:</p>
<pre><code>re.sub(pattern, repl, string, count=0, flags=0)
</code></pre>
<p>The first optional parameter is <code>count</code>, then <code>flag</code>. Both <code>re.M</code> and <code>re.I</code> are integers (with values <code>8</code> and <code>2</code>, respectively), so if you call <code>re.sub(r'o\w','au',a,re.I)</code> then the <code>re.I</code> is interpreted as <code>count=2</code>, <em>not</em> as a <code>flag</code>.</p>
<p>Since those are just integers, and evaluated as such before they are passed to the function, there is no way for the Python interpreter to distinguish them from "regular" integers. To the interpreter, <code>re.sub(r'o\w','au',a,re.I)</code> is indistinguishable from <code>re.sub(r'o\w','au',a,2)</code>.</p>
<p>If you do <code>re.sub(r'o\w','au',a,flags=re.I)</code>, on the other hand, then you are explicitly passing it as the <code>flag</code> parameter, leaving <code>count</code> with the default.</p>
</div>
<span class="comment-copy">What exactly is the problem? Why unreliable?</span>
<span class="comment-copy">Where's the inconsistency here? You're passing, say, <code>re.I</code> as the <code>count</code> parameter, and <code>re.I</code> is an integer equal to 2, so you get two substitutions. <code>re.M</code> is 8, so you get 8 substitutions.</span>
<span class="comment-copy">So re.I or re.M are read as count parameter? And that's expected behaviour? Hmm... OK, I've learned something new. Thanks!</span>
<span class="comment-copy">Thank you Tobias. I thought the interpreter would be 'intelligent' enough to parse 're.I' as a flag. But it does the reverse, parsing it as a number first and then deciding which parameter it is by its position. I'll be frank here, I see this as quite disappointing. It means that parameters that can supposedly be missing are not really missing if other params are of the same type and not explicitly declared. Oh well, I'll learn to live with it.</span>
<span class="comment-copy">Not only if they are of the same type. Remember that Python is dynamically typed, so even if the flag was of a different type, it would still be in place of the count parameter. Of course, in this case the developer of the function could manually check the type and decide what parameter to use it for, but using integers as flags has other benefits, e.g. you can <i>or</i> them together, e.g. <code>re.M | re.I</code> will activate both modes.</span>
