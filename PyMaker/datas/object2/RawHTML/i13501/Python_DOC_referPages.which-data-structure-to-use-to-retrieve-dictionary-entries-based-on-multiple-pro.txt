<div class="post-text" itemprop="text">
<p>I am wondering what the most efficient data structure would be to represent the following: Essentially I would like to create a dictionary to represent lexical entries with specific grammatical properties. Each set of properties consists of attribute-value pairs.</p>
<p><strong>Example:</strong></p>
<pre><code>dictionary = [
    {'lexeme:'goes', 'person':'3', 'number':'sg', 'tense':'present'}, 
    {'lexeme':'go', 'person':'3', 'number':'pl', 'tense':'present'}, 
    {'lexeme':'went', 'person':'3', 'number':'sg', 'tense':'past'},
    ... 
]
</code></pre>
<p>I now want to be able to retrieve all dictionary entries with a given set of properties, e.g. all dictionary entries with <code>person = 3</code> or <code>tense = past</code> or <code>person = 3 AND tense = past</code>.</p>
<p>What is a suitable and effective way to do this in Python?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Storing a list of dictionaries seems like overkill for the data you have described. If each dictionary has the same structure as you have described, then there is no need to use a dictionary because you don't gain any advantages to hashing the data. I think you could accomplish your needs with a single dictionary.</p>
<pre><code>dictionary = {
    'goes':['3','sg','present'],
    'go':['3','pl','present'],
    'went':['3','sg','past'],
    ...
}
</code></pre>
<p>By using a single dictionary you can search for individual words within your dictionary.</p>
<p>If you want to return all the dictionaries of a certain value, you will still have to iterate through the dictionary with a for loop and an if then statement.</p>
<pre><code>tmp_list = []
for word in dictionary:
    if dictionary[word][0] == '3' ^ dictionary[word][2] == 'past':
        tmp_list.append(word)
</code></pre>
<p>The ^ operator is python's built in and/or operator.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension to get the relevant entries:</p>
<pre><code>[entry for entry in dictionary if entry['person'] == '3' and entry['tense'] == 'past']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you considered <a href="http://pandas.pydata.org/pandas-docs/stable/" rel="nofollow">pandas</a><code>DataFrame</code>. It is designed to efficiently store and manipulate tabular data.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not a python guy, It might be very easy to do with python syntax. Here is my attempt to the problem.</p>
<p>From a Data-Structure perspective, you can create a <code>structure</code> to represent each entry in the dictionary.</p>
<pre><code>class Entry {
  String lexeme;
  Integer person;
  String number;
  String tense;
}
</code></pre>
<p>Now to perform the quick queries on the <code>data-structure</code>, you can create HashMap of respective <code>Entry</code> attributes.</p>
<p><strong>For Example:</strong> Create maps for <code>&lt;person, Entry&gt;</code> and <code>&lt;tense, Entry&gt;</code>, that will provide you <code>Entry</code> object in O(1) complexity. The value part will be a list of all the <code>Entry</code> objects and you can keep them in sorted order to performing intersection (<code>AND</code> operation) in liner time. </p>
</div>
<div class="post-text" itemprop="text">
<h3>itemgetter approach</h3>
<p>The pandas solution is a nice one.  If you want a pure python - standard library solution, one option is to use <code>operator.itemgetter</code> (<a href="https://docs.python.org/3/library/operator.html" rel="nofollow">https://docs.python.org/3/library/operator.html</a>).  You pass <code>itemgetter</code> a list of your dictionary keys that you care about and it returns a function that will fetch those keys from the dictionary (works for lists with numeric indices also).</p>
<pre><code>from operator import itemgetter
my_list = [
    {'lexeme':'goes', 'person':'3', 'number':'sg', 'tense':'present'}, 
    {'lexeme':'go', 'person':'3', 'number':'pl', 'tense':'present'}, 
    {'lexeme':'went', 'person':'3', 'number':'sg', 'tense':'past'}]

getter = itemgetter('person', 'tense')
my_values = ('3', 'past')
matches = [row for row in my_list if getter(row) == my_values]

print(matches)
[{'person': '3', 'tense': 'past', 'lexeme': 'went', 'number': 'sg'}]
</code></pre>
<p>This allows you to deal with an arbitrary number of keys to match.  For instance, you could specify a few sets of things to match:</p>
<pre><code>match_keys = (
    'person',            # must not be a tuple if it's a single item
                         # itemgetter will return a single value and not a tuple
    ('person', 'tense')
)
match_values = (
    '3',
    ('3', 'past')
)

matches = []
for mk, mv in zip(match_keys, match_values):
    getter = itemgetter(*mk) if isinstance(mk, tuple) else itemgetter(mk)
    matches.extend(
        [row for row in dictionary if getter(row) == mv]
    )
</code></pre>
<p>This approach will return duplicates.  Ideally you could make the matches object a <code>set</code> rather than a <code>list</code> and update it in the loop.  Unfortunately a <code>dict</code> cannot be added to a <code>set</code>, so that won't work directly.</p>
<h3>attrgetter approach</h3>
<p>Finally, if you have a list of class instances where the fields you care about are attributes of the objects, you could use the <code>operator.attrgetter</code> method in a similar approach as described above.  You could then use a <code>set</code> to weed out duplicates.</p>
</div>
<span class="comment-copy">You may do this effectively only using indices (yeah, like in databases). The simplest form of index is dictionary (hashmap), where the key is your search item(s) and the value is what you are seeking or its position. But this complications you may need for a really big set of data, consider using usual dict or list comprehension if its not the case. "Premature optimization...", you know..</span>
<span class="comment-copy">The implementation is simple enough but for each operation, you need to traverse the full dictionary, which is O(n) operation.</span>
<span class="comment-copy"><code>^</code> is actually the bitwise exclusive-OR operator. You <i>can</i> apply it to boolean values, though. If <code>a</code> and <code>b</code> are booleans (i.e <code>True</code> / <code>False</code>), then <code>a^b</code> is True if  (<code>a</code> is True and <code>b</code> is False) OR (<code>a</code> is False and <code>b</code> is True). So it's equivalent in that situation to <code>a != b</code> or <code>a is not b</code>.</span>
<span class="comment-copy">Agreed, on both accounts. There are ways to store this data in a more flexible manner. In fact any relational database would give more than enough flexibility to do so. I was just providing a built in python way to do it. It seems that's what was asked in the original question.</span>
<span class="comment-copy">Thanks for the answer ... my example is faulty in that not all dictionary entries do indeed share the same attributes. Sorry ... this was misleading.</span>
