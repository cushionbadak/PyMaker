<div class="post-text" itemprop="text">
<p>I want to do something like the following example (found <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow">here</a>)</p>
<pre><code>&gt;&gt;&gt; with patch.object(ProductionClass, 'method', return_value=None) as mock_method:
...     thing = ProductionClass()
...     thing.method(1, 2, 3)
</code></pre>
<p>However this is patching the method called <code>method</code> on <code>ProductionClass</code>.  I want to patch a generic function within a context.  Ideally something looking like...</p>
<pre><code>with path.something(my_fn, return_value=my_return) as mock_function:
    do_some_other_fn()
</code></pre>
<p><code>my_fn</code> is called deep within <code>do_some_other_fn</code> and therefore is difficult to mock out directly.  This seems like it should be straight forward but I can't find the right syntax</p>
<p><strong>EDIT</strong>  In the module that <code>do_some_other_fn</code> lives I import <code>my_fn</code> like followings</p>
<pre><code>from my_module import my_fn
</code></pre>
<p>So I need a way to be able to tell mock to patch that from outside the module.  Is this possible?</p>
<p><strong>EDIT 2</strong> I think this makes it more clear what I am looking for</p>
<p>This works but is not ideal:</p>
<pre><code>import my_module
with patch('my_module.fn', return_value='hello') as patch_context:
    x = my_module.fn()
    # x now contains 'hello'
</code></pre>
<p>However I would much rather have it work like this (or something similar)</p>
<pre><code>from my_module import fn
with patch('my_module.fn', return_value='hello') as patch_context:
    x = fn()
    # x contains real result from real call to fn()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your attempt to patch with <code>from my_module import fn</code> does not work because the import statement creates a local symbol <code>fn</code> which points to whatever value <code>fn</code> has in <code>my_module</code> <em>at the time of import</em>. You later patch <code>my_module.fn</code> but it does not matter because you already have a local copy of <code>fn</code>.</p>
<p>If the file that contains the <code>patch</code> call is the main module (the file that <code>python</code> initially loaded), you should be able to do it by patching <code>__main__.fn</code>:</p>
<pre><code>from my_module import fn
with patch('__main__.fn', return_value='hello') as patch_context:
    x = fn()
</code></pre>
<p>If the file that contains the <code>patch</code> call is loaded as a module from the main module then <code>__main__</code> won't work and you need to pass the absolute module name of the module that contains your <code>patch</code> call to <code>patch</code> rather than <code>__main__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can see function like module object's static method. To patch a function  <code>func</code> in module <code>mymodule</code> you can use </p>
<pre><code>patch("mymodule.func", return_value=my_return)
</code></pre>
<p>You should take care of <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow">Where to patch</a> and if the function is in the same module where you have the test should use <code>"__main__.func"</code> as patch argument.</p>
<p><code>patch</code> like <code>patch.object</code> can be useed as decorator, context or by <code>start()</code> and <code>stop()</code> method.</p>
<p>Now when in a module you import a function from an other module like:</p>
<pre><code>from mymodule import func as foo
</code></pre>
<p>You create a new reference to <code>func</code> in the new module called <code>foo</code>. <em>Every 
time in this module you call <code>foo</code> you will use the reference to <code>mymodule.func</code> that you load when you imported it: if you whould like change this behavior you should patch <code>foo</code> in the new module.</em></p>
<p>To make it more clear I build an example where you have <code>mymodule</code> that contain <code>func</code>, <code>module_a</code> that include <code>mymodule</code> and use <code>mymodule.func</code>, <code>module_b</code> that use <code>from mymodule import func as foo</code> and use bot <code>foo</code> and <code>mymodule.func</code></p>
<p><code>mymodule.py</code></p>
<pre><code>def func():
    return "orig"
</code></pre>
<p><code>module_a.py</code></p>
<pre><code>import mymodule

def a():
    return mymodule.func()
</code></pre>
<p><code>module_b.py</code></p>
<pre><code>from mymodule import func as foo
import mymodule

def b_foo():
    return foo()

def b():
    return mymodule.func()
</code></pre>
<p><code>test.py</code></p>
<pre><code>import unittest
from unittest.mock import *
import mymodule
import module_a
import module_b

class Test(unittest.TestCase):
    def test_direct(self):
        self.assertEqual(mymodule.func(), "orig")
        with patch("mymodule.func", return_value="patched"):
            self.assertEqual(mymodule.func(), "patched")

    def test_module_a(self):
        self.assertEqual(module_a.a(), "orig")
        with patch("mymodule.func", return_value="patched"):
            self.assertEqual(module_a.a(), "patched")

    def test_module_b(self):
        self.assertEqual(module_b.b(), "orig")
        with patch("mymodule.func", return_value="patched"):
            self.assertEqual(module_b.b(), "patched")
            self.assertEqual(module_b.b_foo(), "orig")
        with patch("module_b.foo", return_value="patched"):
            self.assertEqual(module_b.b(), "orig")
            self.assertEqual(module_b.b_foo(), "patched")    


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>In other words what really rules on choosing where to patch is how the function is referenced where <strong>you want use the patched version</strong>.</p>
</div>
<span class="comment-copy">Question about this answer.  If use <code>patch('mymodule.func'....)</code> but deep within my code I import with <code>from mymodule import func</code> then call <code>func()</code>, will it still be patch appropriately?</span>
<span class="comment-copy">Just did some tests and it doesn't look like it works well that way.  If I do <code>mymodule.func</code> the patch works fine, but I can't use <code>from mymodule import func</code>.  I've updated the question to make this more clear</span>
<span class="comment-copy">@sedavidw as I pointed out clearly in my answer you should take a look to <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#where-to-patch</a> .</span>
