<div class="post-text" itemprop="text">
<p>In this example, I am trying to <strong>assign</strong> new <code>__eq__</code>, <code>__lt__</code> and <code>__gt__</code> methods and invoke them by comparing the object to the literal <code>3</code>. Why is <code>bar(...)</code> never called?</p>
<pre><code>class Foo:
    def __init__(self):
        self.__eq__ = self.bar
        self.__lt__ = self.bar
        self.__gt__ = self.bar

    def bar(self, other):
        print("bar called.")

a = Foo()
a == 3
a &lt; 3
a &gt; 3
</code></pre>
<p>In <a href="https://stackoverflow.com/a/19176343/489345">this answer</a> I found the hint <code>you can't assign new __eq__ to the object</code>. I can't find any official source for this statement though. </p>
<p>Any hints and help is appreciated!</p>
<p><em>Edit: I am aware that there is the option of defining <code>__eq__</code> in the object itself, but this questions is specifically about assigning it after instance creation.</em></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow">Special Method Lookup</a>:</p>
<blockquote>
<p>implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary.</p>
</blockquote>
<p>If the goal is to use <code>bar</code> for comparisons, assign it at the class level, not per instance (which will also save memory by not bloating the per instance attribute dictionary):</p>
<pre><code>class Foo:
    def bar(...):
        ...
    __eq__ = __lt__ = __gt__ = bar
</code></pre>
</div>
<span class="comment-copy">I am not sure why I am being downvoted, I don't think it's such a trivial question. But thank you for your answer!</span>
<span class="comment-copy">I suspect because this sort of question gets asked a lot (I basically copied my answer from a comment I made on a similar question about <code>__call__</code>). I didn't downvote, but people often downvote what they view as redundant questions.</span>
<span class="comment-copy">Obviously I tried searching, but I didn't find any information on it on SO. But true, I didn't think of trying to assign <code>__call__</code>, maybe I could have found more info.</span>
<span class="comment-copy">If you need to be able to override per instance, then define some other method (e.g. <code>_realeq</code>) and define <code>__eq__</code> (at class level) to call it. You can then assign instances their own <code>_realeq</code> which, not being a special method, will be called as you expect.</span>
<span class="comment-copy">I was researching for <a href="http://stackoverflow.com/questions/32501397/object-that-raises-exception-when-used-in-any-way">this question</a> when I stumbled about this problem. I tried replacing all the methods listed by <code>dir(...)</code> on an instance, but apparently the underscore methods failed.</span>
