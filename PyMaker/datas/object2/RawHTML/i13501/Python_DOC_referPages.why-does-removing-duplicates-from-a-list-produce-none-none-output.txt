<div class="post-text" itemprop="text">
<p>I am new to Python and I'm not able to understand why I am getting the results with <strong>None</strong> values.</p>
<pre><code>#Remove duplicate items from a list
def remove_duplicates(list):
    unique_list = []
    return [unique_list.append(item) for item in list if item not in unique_list]
print remove_duplicates([1,1,2,2]) -&gt; result [None, None]
</code></pre>
<p>When I print the result it shows the following: [None, None]</p>
<p>PS: I've seen other solutions and also aware of the list(set(list)) but I am trying to understand why the above result with integers gives [None, None] output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Although using a <a href="https://docs.python.org/3.5/tutorial/datastructures.html#sets" rel="nofollow">set is the proper way</a>, the problem with your code, as the comments indicated, is that you are not actually returning <code>unique_list</code> from your function, you are returning the result of the list comprehension.</p>
<pre><code>def remove_duplicates(my_list):
    unique_list = []
    do = [unique_list.append(item) for item in my_list if item not in unique_list]
    return unique_list  # Actually return the list!

print remove_duplicates([1,1,2,2]) -&gt; result [1, 2]
</code></pre>
<p>Here I simply made a throwaway variable <code>do</code> that is useless, it just "runs" the comprehension. Understand?</p>
<p>That comprehension is storing a value each time you call <code>unique_list.append(item)</code> ... and that value is the result of the <code>append</code> method, which is <code>None</code>! So <code>do</code> equals <code>[None, None]</code>.</p>
<p>However, your <code>unique_list</code> <em>is</em> in fact being populated correctly, so we can return that and now your function works as expected.</p>
<p>Of course, this is not a normal use for a list comprehension and really weird.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that the method <code>list.append</code> returns None. You can test this easily with the following code:</p>
<pre><code>myList=[1, 2, 3]
print myList.append(4)
</code></pre>
<p>So, a solution for you would issue would be</p>
<pre><code>def remove_duplicates(myList):
    alreadyIncluded = []
    return [item for item in myList if item not in alreadyIncluded and not alreadyIncluded.append(item)]
print remove_duplicates([1,1,2,2]) 
</code></pre>
<p>The idea is that you will begin with an empty list of aldeady included elements and you will loop over all the elements in list, including them in the <code>alreadyIncluded</code> list. The <code>not</code> is necessary because the <code>append</code> will return <code>None</code> and <code>not None</code> is <code>True</code>, so the if will not be affected by the inclusion.</p>
<p>You were including a list of the result of the appends (always <code>None</code>), but what you need is a list of the elements that passed the <code>if</code> test.</p>
<p>I hope it helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the other answers have explained, the reason you're getting a list of <code>None</code> values is because <code>list.append</code> returns <code>None</code>, and you're calling it in a list comprehension. That means you're building a list full of <code>None</code> values along side your list of unique values.</p>
<p>I would like to suggest that you ditch the list comprehension. Because you need to access outside state (the list of unique values seen so far), a comprehension can't easily do what you want. A regular <code>for</code> loop is much more appropriate:</p>
<pre><code>def remove_duplicates(lst):
    unique_list = []
    for item in lst:
        if item not in unique_list:
            unique_list.append(item)
    return unique_list
</code></pre>
<p>A more Pythonic approach however would be to use a <code>set</code> to handle the unique items, and to make your function a generator:</p>
<pre><code>def remove_duplicates(lst):
    uniques = set()
    for item in lst:
        if item not in unique_list:
            yield item
            uniques.add(item)
</code></pre>
<p>The <code>itertools.ifilterfase</code> function from the standard library can help improve this even further, as shown in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">recipe in the docs</a> (you'll have to scroll down a little to find the specific recipe):</p>
<pre><code>def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element
</code></pre>
</div>
<span class="comment-copy">Wouldn't it be easier to do: <code>return list(set(list))</code> ?</span>
<span class="comment-copy">because your statement returns a list with the return values of <code>unique_list.append(item)</code> which is <code>None</code></span>
<span class="comment-copy">BTW, do <i>not</i> use <code>list</code> as a variable name, it is a <a href="https://docs.python.org/2/library/functions.html#list" rel="nofollow noreferrer">builtin function</a>!</span>
<span class="comment-copy"><b>Thank you</b> for all your answers</span>
<span class="comment-copy">Is there a reason you're using an assignment to the unused variable <code>do</code> ?</span>
<span class="comment-copy">The goal being to make it clear that the variable is useless and not the desired output. I wanted to imply that the statement was being "executed" but the result isn't being used.</span>
<span class="comment-copy">I'm not sure if I should upvote this answer for the good catch that he wasn't returning <code>unique_list</code> or to downvote because of the poor mistake you've done with <code>do</code> (which is really unnecessary, the comprehension will run without an assignment as well).</span>
<span class="comment-copy">Well, the question was "why is the function return [None, None]", so ... hard to say. ;) I'll add a link to sets documentation.</span>
<span class="comment-copy">You could just write <code>_ = [â€¦]</code> if you really wanted to put a variable there.</span>
<span class="comment-copy"><b>Thank you</b> rLinden for the explanation.</span>
<span class="comment-copy"><b>Thank you</b> BlckKnght for the different solutions.</span>
