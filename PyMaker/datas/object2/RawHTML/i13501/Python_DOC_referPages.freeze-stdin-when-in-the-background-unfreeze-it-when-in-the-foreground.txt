<div class="post-text" itemprop="text">
<p>I am trying to run a sript in the background:</p>
<pre><code>nohup script.py &gt; out 2&gt; err &lt; /dev/null &amp;
</code></pre>
<p>The script (<code>Python 3.4</code>) does at some point:</p>
<pre><code>answer = input('? ')
</code></pre>
<p>(it has a menu running in one of the threads)</p>
<p>And the nohup call is crashing with:</p>
<pre><code>EOFError: EOF when reading a line
</code></pre>
<p>Because of the <code>/dev/null</code> redirection of <code>stdin</code> I imagine. If I run it without <code>stdin</code> redirection:</p>
<pre><code>nohup script.py &gt; out 2&gt; err &amp;
</code></pre>
<p>It crashes with:</p>
<pre><code>OSError: [Errno 9] Bad file descriptor
</code></pre>
<p>If I run it with:</p>
<pre><code>script.py &gt; out 2&gt; err
</code></pre>
<p>It works, but blocks my terminal (it is in the foreground)</p>
<p>If I run it with:</p>
<pre><code>script.py &gt; out 2&gt; err &amp;
</code></pre>
<p>It runs in the background alright, but it gets stopped as soon as the <code>input</code> call is reached.</p>
<p>What I would like is:</p>
<ul>
<li>be able to redirect <code>stdout</code> and <code>stderr</code> to the filesystem</li>
<li>be able to put the script in the background</li>
<li>be able to move if to the foreground and interact with the menu normally (so <code>stdin</code> must be enabled somehow). <code>stdout</code> and <code>stderr</code> would still be redirected to the filesystem, but <code>stdin</code> would behave normally.</li>
<li>the script must run fine in the background and in the foreground (of course, the menu is not working in the background, because <code>stdin</code> is "frozen")</li>
</ul>
<p>Basically, what I would like is that when it is in the background, <code>stdin</code> is kind of "frozen", and whenever it comes to the foreground it works again normally.</p>
<p>Is this possible? The solution does not need to involve <code>nohup</code></p>
</div>
<div class="post-text" itemprop="text">
<p>What you want (and how <code>input</code> works and fails on <code>EOF</code> under python) with an interactive menu means that you cannot safely pass a file as <code>stdin</code> when invoking your program.  This means your only option is to invoke this like so:</p>
<pre><code>$ script.py &gt; out 2&gt; err &amp;
</code></pre>
<p>As a demonstration, this is my script:</p>
<pre><code>from time import sleep
import sys

c = 0
while True:
    sleep(0.001)
    c += 1
    if c % 1000 == 0:
        print(c, flush=True)
    if c % 2000 == 0:
        print(c, file=sys.stderr, flush=True)
    if c % 10000 == 0:
        answer = input('? ')
        print('The answer is %s' % answer, flush=True)
</code></pre>
<p>Essentially, every second it will write to <code>stdout</code>, every two seconds it will write to <code>stderr</code>, and lastly, every ten seconds it will wait for input.  If I were to run this and wait a bit over a seconds (to allow disk flush), and chain this together, like so:</p>
<pre><code>$ python script.py &gt; out 2&gt; err &amp; sleep 2.5; cat out err
[1] 32123
1000
2000
2000
$ 
</code></pre>
<p>Wait at least 10 seconds and try <code>cat out err</code> again:</p>
<pre><code>$ cat out err
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
? 2000
4000
6000
8000
10000

[1]+  Stopped                 python script.py &gt; out 2&gt; err
$ 
</code></pre>
<p>Note that the prompt generated by <code>input</code> is also written to stdout, and the program effectively continued running up to where it is expecting <code>stdin</code> to give it data.  You simply have to bring the process back into foreground by <code>%</code>, and start feeding it the required data, then suspend with <code>^Z</code>  (<kbd>Ctrl</kbd><kbd>Z</kbd>) and keep it running again in the background with <code>%&amp;</code>.  Example:</p>
<pre><code>$ %
python script.py &gt; out 2&gt; err
Test input
^Z
[1]+  Stopped                 python script.py &gt; out 2&gt; err
$ %&amp;
[1]+ python script.py &gt; out 2&gt; err &amp;
$
</code></pre>
<p>Now <code>cat out</code> again, after waiting another ten seconds:</p>
<pre><code>$ cat out
1000
...
10000
? The answer is Test input
11000
...
20000
? 
[1]+  Stopped                 python script.py &gt; out 2&gt; err
$
</code></pre>
<p>This is essentially a basic crash course in how standard processes typically functions in both foreground and background, and things just simply work as intended if the code handles the standard IO correctly.</p>
<p>Lastly, you can't really have it both ways.  If the application expects stdin and none is provided, then the clear option is failure.  If one is provided however but application got sent to background and kept running, it will be <code>Stopped</code> as it expects further input.  If this stopped behaviour is unwanted, the application is at fault, there is nothing can be done but to change the application to not result in an error when <code>EOF</code> is encountered when executed with <code>/dev/null</code> as its <code>stdin</code>.  If you want to keep <code>stdin</code> as is, with the application being able to somehow keep running when it is in the background you cannot use the <code>input</code> function as it will block when <code>stdin</code> is empty (resulting in process being stopped).</p>
<hr/>
<p>Now that you have clarified via the comment below that your "interactive prompt" is running in a thread, and since usage of <code>input</code> directly reads from <code>stdin</code> and you seem unwilling to modify your program (you asking for general case) but expects a utility to do this for you, the simple solution is to execute this within a <a href="https://tmux.github.io/" rel="nofollow noreferrer"><code>tmux</code></a> or <a href="https://www.gnu.org/software/screen/" rel="nofollow noreferrer"><code>screen</code></a> session as they fully implement a pseudo tty that is independent from whichever console that started (so you can disconnect and send the session to the background, or start other virtual sessions, see manual pages) which will provide stdio that the program expects.</p>
<p>Finally, if you actually want your application to support this natively, you cannot simply use <code>input</code> as is, but you should check whether <code>input</code> can safely be called (i.e. perhaps making use of <a href="https://docs.python.org/3/library/select.html" rel="nofollow noreferrer"><code>select</code></a>), or by checking whether the process is currently in the foreground or background (An example you could start working from is <a href="https://stackoverflow.com/questions/24861351/how-to-detect-if-python-script-is-being-run-as-a-background-process/24862213#24862213">How to detect if python script is being run as a background process</a>, although you might want to check using <code>sys.stdin</code>, maybe.) to determine if <code>input</code> can be safely called (however if user suspends the task as input comes it would still hang as <code>input</code> waits), or use unix sockets for communication.</p>
</div>
<span class="comment-copy">What exactly should it do while stdin is frozen except stop and wait for stdin to become available?</span>
<span class="comment-copy">@user2313067: What I expect is that the <code>input</code> call waits until <code>stdin</code> is "unfrozen", and then reads from it. I would like to avoid the the program to be stopped just because there is no active stdin, it should just wait until stdin is active to continue reading from it. To say it another way: a "frozen" <code>stdin</code> should behave exactly the same as an <code>stdin</code> without data coming in. I do not know if this is possible - if there are primitives (at the kernel level?) to support this, but this is what I looking for. Maybe it is not possible at all ...</span>
<span class="comment-copy">@metatoaster: yes, handling <code>EOF</code> would solve the problem, but that means modifying the script. I can do that because I have the source code (and it is python, so you nearly always have the source code), but this is not practical in the general case: maybe there is no source code, maybe there are 2 million input calls all around the code. I would like to find a non-invasive solution.</span>
<span class="comment-copy">Either the application utilize <code>stdin</code> correctly as per expectation or it is simply incorrect. This is literally the foundation of all unix binaries. Also you still have not define what "run fine in the background" means, however by definition so far it correctly stopped as it expects further input. Also, the expectation is that <code>stdin</code> cannot simply be an <code>EOF</code>, so either fix that or your problem cannot be solved.  General cases do not mean anything in this context because a broken binary is still a broken binary.</span>
<span class="comment-copy">@metatoaster: It is not broken: the program just sees EOF and crashes, which is ok. What I want is a mechanism to avoid the program to <i>see</i> EOF. I want to be able to unplug the running program from the terminal, without having an EOF being sent. I want the program to keep a functioning stdin which is not connected to anything for a while, until it is brought back to the terminal's foreground. Not "connected for a while" means here that no input data will be generated, not that the <code>stdin</code> has been terminated.</span>
<span class="comment-copy">Thanks for the effort, but this is not exactly what I need. Basically, my interactive menu is running in its own thread. I want that thread to wait for input <i>indefinitely</i> whenever the process is in the background, without crashing, and when it is brought to the foreground it should continue accepting input normally from stdin. But, when it is in the background (and thus, no stdin is available), it should not crash with "EOFError: EOF when reading a line". It should just wait for the input to come, as if the user were not yet inputing anything.</span>
<span class="comment-copy">The other threads, which are not interactive, should keep running normally, which is not the case right now because the interactive thread crashes the whole process.</span>
<span class="comment-copy">For your sample program, it would suffice if the <code>input</code> call would block the program, but <i>not</i> by stopping the process, but just by waiting for input, as any <code>input</code> call does ... <b>even whenever there is no stdin attached</b>. The <code>input</code> call should continue reading from <code>stdin</code> when it is re-attached (by bringing the process to the foreground)</span>
<span class="comment-copy">Ideally there would be a wrapper utility (let's call it <code>savestdin</code>), similar in concept to what <code>nohup</code> does, but with another purpose, namely keeping an <code>stdin</code> alive even for processes in the background, which can be re-attached to the terminal on demand. I would call my program like this then: <code>savestdin python script.py &gt; out 2&gt; err &amp;</code>, and whenever the job is put to the foreground again, the terminal would be re-connected to the process <code>stdin</code>. I am not aware of any such utiliy.</span>
<span class="comment-copy">If you had mentioned the usage of thread in your question it would have been a lot more clear on what your actual problem is.  Anyway, what you want is simply not possible with how your application as written as I had explained, you can't expect <code>input</code> to work with <code>stdin</code> "disconnected" (it will either see EOF and raise exception, or hang all threads indefinitely as you saw).  Try spawning background processes instead of threads.</span>
