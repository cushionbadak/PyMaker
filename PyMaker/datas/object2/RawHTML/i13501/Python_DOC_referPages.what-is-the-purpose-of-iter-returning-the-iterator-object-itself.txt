<div class="post-text" itemprop="text">
<p>I don't understand exactly why the <code>__iter__</code> special method just returns the object it's called on (if it's called on an iterator).  Is it essentially just a flag indicating that the object is an iterator?</p>
<p>EDIT: Actually, I discovered that "This is required to allow both containers and iterators to be used with the <code>for</code> and <code>in</code> statements."  <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__" rel="nofollow">https://docs.python.org/3/library/stdtypes.html#iterator.<strong>iter</strong></a></p>
<p>Alright, here's how I understand it: When writing a <code>for</code> loop, you're allowed to specify either an iterable or an iterator to loop over.  But Python ultimately needs an iterator for the loop, so it calls the <code>__iter__</code> method on whatever it's given.  If it's been given an iterable, the <code>__iter__</code> method will produce an iterator, and if it's been given an iterator, the <code>__iter__</code> method will likewise produce an iterator (the original object given).</p>
</div>
<div class="post-text" itemprop="text">
<p>When you loop over something using <code>for x in something</code>, then the loop actually calls <code>iter(something)</code> first, so it has something to work with. In general, the for loop is approximately equivalent to something like this:</p>
<pre><code>something_iterator = iter(something)
while True:
   try:
       x = next(something_iterator)

       # loop body

   except StopIteration:
       break
</code></pre>
<p>So as you already figured out yourself, in order to be able to loop over an iterator, i.e. when <code>something</code> is already an iterator, iterators should always return themselves when calling <code>iter()</code> on them. So this basically makes sure that iterators are also iterable.</p>
</div>
<div class="post-text" itemprop="text">
<p>This depends what object you call iter on. If an object is already an iterator, then there is no operation required to convert it to an iterator, because it already is one. But if the object is not an <em>iterator</em>, but is <em>iterable</em>, then an iterator is constructed from the object.</p>
<p>A good example of this is the list object:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; iter(x) == x
False
&gt;&gt;&gt; iter(x)
&lt;list_iterator object at 0x7fccadc5feb8&gt;
&gt;&gt;&gt; x
[1, 2, 3]
</code></pre>
<p>Lists are iterable, but they are not themselves iterators. The result of <code>list.__iter__</code> is not the original list.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>Python</code> when ever you try to use <code>loops</code>, or try to iterate over any object like below..</p>
<p>Lets try to understand for <code>list</code> object..</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3] # Defined list l
</code></pre>
<p>If we iterate over the above list..</p>
<pre><code>&gt;&gt;&gt; for i in l:
...     print i
... 
1
2
3
</code></pre>
<p>When you try to do this <code>iteration</code> over <code>list l</code>, Python <code>for</code> loop checks for <code>l.__iter__()</code> which intern return an iterator object.</p>
<pre><code>&gt;&gt;&gt; for i in l.__iter__():
...     print i
... 
1
2
3
</code></pre>
<p>To understand this more, lets customize the <code>list</code> and create anew list class..</p>
<pre><code>&gt;&gt;&gt; class ListOverride(list):
...     def __iter__(self):
...         raise TypeError('Not iterable')
... 
</code></pre>
<p>Here I've created <code>ListOverride</code> class which intern <code>inherited</code> from <code>list</code> and overrided <code>list.__iter__</code> method to raise <code>TypeError</code>.</p>
<pre><code>&gt;&gt;&gt; ll = ListOverride([1, 2, 3])
&gt;&gt;&gt; ll
[1, 2, 3]
</code></pre>
<p>And i've created anew list using <code>ListOverride</code> class, and since it's list object it should iterate in the same way as <code>list</code> does.</p>
<pre><code>&gt;&gt;&gt; for i in ll:
...     print i
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 3, in __iter__
TypeError: Not iterable
</code></pre>
<p>If we try to <code>iterate</code> over <code>ListOverride</code> object <code>ll</code>, we'll endup getting <code>NotIterable</code> exception..</p>
</div>
<span class="comment-copy">It only returns the same object <i>if</i> that object is an iterator.  If the object is an <i>iterable</i>, then <code>__iter__</code> can return some other object that will be the iterator.  See <a href="http://stackoverflow.com/questions/9884132/what-exactly-are-pythons-iterator-iterable-and-iteration-protocols">this question</a>.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">doc</a></span>
<span class="comment-copy">But if it's an iterator, I still don't get why you'd have it return itself.</span>
<span class="comment-copy">You need to return an iterator, something you can pass to <code>next</code> to get the next object. If the instance implements <code>__next__</code>, you can return the instance itself.</span>
<span class="comment-copy">Is your question then "why are iterators iterable"?</span>
<span class="comment-copy">I assume you meant <code>except StopIteration</code> rather than <code>catch StopIteration</code>.</span>
<span class="comment-copy">@Waylan Whoops, sorry, too many different languages. Thanks</span>
