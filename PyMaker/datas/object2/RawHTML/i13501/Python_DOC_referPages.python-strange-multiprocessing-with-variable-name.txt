<div class="post-text" itemprop="text">
<p>a simple example:</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-
import multiprocessing

class Klass(object):
    def __init__(self):
        print "Constructor ... %s" % multiprocessing.current_process().name

    def __del__(self):
        print "... Destructor %s" % multiprocessing.current_process().name


if __name__ == '__main__':
    kls = Klass()
</code></pre>
<p>run with error when do <code>current_process</code> in <code>__del__</code>:</p>
<pre><code>Constructor ... MainProcess
Exception AttributeError: "'NoneType' object has no attribute 'current_process'" in &lt;bound method Klass.__del__ of &lt;__main__.Klass object at 0x7f5c34e52090&gt;&gt; ignored
</code></pre>
<p>if I change a variable name:</p>
<pre><code>als = Klass()
</code></pre>
<p>it get the right result:</p>
<pre><code>Constructor ... MainProcess
... Destructor MainProcess
</code></pre>
<p>and I tried many variable name, some ok, some error.</p>
<p>Why different instance name, will cause multiprocessing module be None in <code>__del__</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The code raises </p>
<pre><code>AttributeError: "'NoneType' object has no attribute 'current_process'"
</code></pre>
<p>if the global variable <code>multiprocessing</code> is deleted before <code>kls</code> gets deleted.
In general, the order in which objects are deleted is not predictable. However, <a href="https://docs.python.org/3/reference/datamodel.html#object.__del__" rel="nofollow noreferrer">per the docs</a>:</p>
<blockquote>
<p>Starting with version 1.5, Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the <code>__del__()</code> method is called.</p>
</blockquote>
<p>Therefore, if you name the instance <code>_kls</code> (with an underscore), then you can be assured that its <code>__del__</code> will be called before <code>multiprocessing</code> is deleted:</p>
<pre><code>import multiprocessing 

class Klass(object):
    def __init__(self):
        print "Constructor ... %s" % multiprocessing.current_process().name

    def __del__(self):
        print "... Destructor %s" % multiprocessing.current_process().name


if __name__ == '__main__':
    _kls = Klass()
</code></pre>
<p>yields</p>
<pre><code>Constructor ... MainProcess
... Destructor MainProcess
</code></pre>
<hr/>
<p><a href="https://stackoverflow.com/q/14986568/190597">Other methods</a> of ensuring a <code>del</code> method is called before the module is deleted include </p>
<ul>
<li>using <code>atexit</code></li>
<li>using a context manager</li>
<li>saving a reference to the module as an attribute of <code>Klass</code>. </li>
</ul>
</div>
<span class="comment-copy">I see the same result... that's very weird!</span>
<span class="comment-copy">Same here. Produces the same weird results. So I guess you spotted a bug in <code>multiprocessing</code>.</span>
<span class="comment-copy">@jonrsharpe  see unutbu 's answer</span>
<span class="comment-copy">@Sait see unutbu 's answer</span>
<span class="comment-copy">very thanks! I should be more attention to the <i>warning</i> section of python document.</span>
