<div class="post-text" itemprop="text">
<p>Right now, I'm doing this:</p>
<pre><code>class EdgesGenerator(abc.Sequence):

    def __init__(self, link, size):
        self.link = link
        self.size = size

    def __getitem__(self, cluster_index):
        try:
            index = cluster_index.__index__()
        except AttributeError:
            raise TypeError from None
        if 0 &lt;= index &lt; self.size:
            return Edge(self.link, index)
        raise IndexError

    def __len__(self):
        return self.size
</code></pre>
<p>Is this the prototypical <code>__getitem__</code> <em>for a sequence</em>?  How should it be written?</p>
</div>
<div class="post-text" itemprop="text">
<p>As correctly given in the comments by <a href="https://stackoverflow.com/users/12892/cristian-ciupitu">@Cristian</a>, the only standard pattern I know of is from <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">documentation -</a></p>
<blockquote>
<p><strong>object.__getitem__(self, key)</strong></p>
<p>Called to implement evaluation of <code>self[key]</code>. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the <code>__getitem__()</code> method. If key is of an inappropriate type, TypeError may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.</p>
</blockquote>
<p>But there is another issue I see with your implementation , For each valid call to <code>__getitem__()</code> , that is for something like <code>object[index]</code> . You are creating a new Edge object everytime.</p>
<p>So everytime you call <code>object[index]</code> , you would receive a new <code>Edge</code> object (though the contents of that edge object may be identical) , but the object itself would be new.</p>
<p>So things like - <code>object[index] is object[index]</code> would most probably fail (would result False) .</p>
<p>Unless this is something you intended , you should try caching the Edge objects (and returning from cache if found) . I would suggest using a dictionary to cache the objects (since you seem to be creating objects on the fly , only when accessed) , though you can also use a list, you would just need to initialize the list to have size as <code>self.size</code> .</p>
</div>
<span class="comment-copy">What do you mean by "prototypical"? How you should write it depends on hat you want it to do; there is no single way to write a <code>__getitem__</code> method.</span>
<span class="comment-copy">@kindall: I think that for a sequence, there should be a standard pattern to be followed.  For example, raising IndexError for out of bounds and TypeError for non-integer arguments is consistent with <code>list</code>.  Am I missing other kinds of consistency?  It would be weird for <code>__getitem__</code> on a sequence to raise <code>AttributeError</code>, wouldn't it?</span>
<span class="comment-copy">See the documentation for <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>object.__getitem__</code></a></span>
<span class="comment-copy">@CristianCiupitu: Ahaâ€¦ not sure why I didn't check that first!  So I'm okay then?</span>
<span class="comment-copy">Also, what version of python are you using?</span>
<span class="comment-copy">Yeah, that's right.  I don't think object identity needs to be the same for multiple calls.  It's just for building UI handles and so I don't want to create and cache all possible Edge objects.  I want them created on the fly.  Otherwise, I wouldn't need this abstract object.</span>
<span class="comment-copy">Yea,  but I was saying you can cache the objects that got created on the fly.</span>
<span class="comment-copy">Yeah, but that can't save more than a constant fraction of the memory taken up by the Edge objects since for every object prevented from being allocated there would be some other object pointing at it.</span>
<span class="comment-copy">In case you change your mind about caching, you can use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a></span>
<span class="comment-copy">The cache could use a <a href="https://docs.python.org/3/library/weakref.html" rel="nofollow noreferrer"><code>weakref</code></a> <code>WeakValueDictionary</code> to map indexes to <code>Edge</code> objects. <code>object[index] is object[index]</code> would hold. But as soon as there are no reference to a given <code>Edge</code>, it would be GCed.</span>
