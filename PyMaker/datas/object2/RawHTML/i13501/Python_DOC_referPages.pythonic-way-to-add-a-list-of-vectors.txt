<div class="post-text" itemprop="text">
<p>I am trying to create a method (sum) that takes a variable number of vectors and adds them in. For educational purposes, I have written my own <code>Vector</code> class, and the underlying data is stored in an instance variable named data.</p>
<p>My code for the <code>@classmethod</code> sum works (for each of the vectors passed in, loop through each element in the data variable and add it to a result list), but it seems non-Pythonic, and wondering if there is a better way?</p>
<pre><code>class Vector(object):
    def __init__(self, data):
        self.data = data

    @classmethod
    def sum(cls, *args):
        result = [0 for _ in range(len(args[0].data))]
        for v in args:
            if len(v.data) != len(result): raise
            for i, element in enumerate(v.data):
                result[i] += element

        return cls(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest"><strong><code>itertools.izip_longest</code></strong></a> may come very handy in your situation:</p>
<pre><code>a = [1, 2, 3, 4]
b = [1, 2, 3, 4, 5, 6]
c = [1, 2]

lists = (a, b, c)

result = [sum(el) for el in itertools.izip_longest(*lists, fillvalue=0)]
</code></pre>
<p>And here you got what you wanted:</p>
<pre><code>&gt;&gt;&gt; result
[3, 6, 6, 8, 5, 6]
</code></pre>
<p>What it does is simply zips up your lists together, by filling empty value with <code>0</code>. e.g. <code>izip_longest(a, b)</code> would be <code>[(1, 1), (2, 2), (3, 0), (4, 0)]</code>. Then just sums up all the values in each tuple element of the intermediate list.</p>
<p>So here you go step by step:</p>
<pre><code>&gt;&gt;&gt; lists
([1, 2, 3, 4], [1, 2, 3, 4, 5, 6], [1, 2])
&gt;&gt;&gt; list(itertools.izip_longest(*lists, fillvalue=0))
[(1, 1, 1), (2, 2, 2), (3, 3, 0), (4, 4, 0), (0, 5, 0), (0, 6, 0)]
</code></pre>
<p>So if you run a list comprehension, summing up all sub-elements, you get your result.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another thing that you could do (and that might be more "pythonic") would be to implement the <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types"><code>__add__</code> magic method</a>, so you can use <code>+</code> and <code>sum</code> directly on vectors.</p>
<pre><code>class Vector(object):
    def __init__(self, data):
        self.data = data

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector([s + o for s, o in zip(self.data, other.data)])
        if isinstance(other, int):
            return Vector([s + other for s in self.data])
        raise TypeError("can not add %s to vector" % other)

    def __radd__(self, other):
        return self.__add__(other)

    def __repr__(self):
        return "Vector(%r)" % self.data
</code></pre>
<p>Here, I also implemented addition of <code>Vector</code> and <code>int</code>, adding the number on each of the Vector's data elements, and the "reverse addition" <code>__radd__</code>, to make <code>sum</code> work properly.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; v1 = Vector([1,2,3])
&gt;&gt;&gt; v2 = Vector([4,5,6])
&gt;&gt;&gt; v3 = Vector([7,8,9])
&gt;&gt;&gt; v1 + v2 + v3
Vector([12, 15, 18])
&gt;&gt;&gt; sum([v1,v2,v3])
Vector([12, 15, 18])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>args = [[1,   2,  3],
        [10, 20, 30],
        [7,   3, 15]]

result = [sum(data) for data in zip(*args)]
# [18, 25, 48]
</code></pre>
<p>Is this what you want?</p>
</div>
<span class="comment-copy"><a href="http://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">Why a class method?</span>
<span class="comment-copy">I was thinking that sum should return a new vector, and thus used a class method.</span>
<span class="comment-copy">Thank you and this works!</span>
<span class="comment-copy">Thank you for this, and I didn't consider this approach and learned something new!</span>
