<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/pickle.html#pickle-python-object-serialization" rel="nofollow">pickle module documentation</a> says right at the beginning:</p>
<blockquote>
<p><strong>Warning</strong>: 
  The pickle module is not intended to be secure against erroneous or
  maliciously constructed data. Never unpickle data received from an
  untrusted or unauthenticated source.</p>
</blockquote>
<p>However, further down under <a href="https://docs.python.org/3/library/pickle.html#restricting-globals" rel="nofollow">restricting globals</a> it seems to describe a way to make unpickling data safe using a whitelist of allowed objects.</p>
<p>Does this mean that I can safely unpickle untrusted data if I use a <code>RestrictedUnpickler</code> that allows only some "elementary" types, or are there additional security issues that are not addressed by this method? If there are, is there another way to make unpickling safe (obviously at the cost of not being able to unpickle every stream)?</p>
<p>With "elementary types" I mean precisely the following:</p>
<ul>
<li><code>bool</code></li>
<li><code>str</code>, <code>bytes</code>, <code>bytearray</code></li>
<li><code>int</code>, <code>float</code>, <code>complex</code></li>
<li><code>tuple</code>, <code>list</code>, <code>dict</code>, <code>set</code> and <code>frozenset</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I'd go so far as saying that there is no safe way to use pickle to handle untrusted data. </p>
<p>Even with restricted globals, the dynamic nature of Python is such that a determined hacker still has a chance of finding a way back to the <code>__builtins__</code> mapping and from there to the Crown Jewels. </p>
<p>See <a href="http://nedbatchelder.com/blog/201302/finding_python_3_builtins.html" rel="nofollow">Ned Batchelder's blog posts on circumventing restrictions on <code>eval()</code></a> that apply in equal measure to <code>pickle</code>.</p>
<p>Remember that <code>pickle</code> is still a stack language and you cannot foresee all possible objects produced from allowing arbitrary calls even to a limited set of globals. The pickle documentation also doesn't mention the <code>EXT*</code> opcodes that allow calling <code>copyreg</code>-installed extensions; you'll have to account for anything installed in that registry too here. All it takes is one vector allowing a object call to be turned into a <code>getattr</code> equivalent for your defences to crumble.</p>
<p>At <em>the very least</em> use a cryptographic signature to your data so you can validate the integrity. You'll limit the risks, but if an attacker ever managed to steal your signing secrets (keys) then they could again slip you a hacked pickle. </p>
<p>I would instead use an an existing innocuous format like JSON and add type annotations; e.g. store data in dictionaries with a type key and convert when loading the data. </p>
</div>
<div class="post-text" itemprop="text">
<p>This idea has been discussed also on the mailing list <a href="https://mail.python.org/pipermail//python-ideas/" rel="nofollow">python-ideas</a> when addressing the problem of adding a safe <code>pickle</code> alternative in the standard library. For example <a href="https://mail.python.org/pipermail//python-ideas/2013-February/019539.html" rel="nofollow">here</a>:</p>
<blockquote>
<p>To make it safer I would have a restricted unpickler as the default (for load/loads) and force people to override it if they want to loosen restrictions. To be really explicit, I would make load/loads only work with built-in types.</p>
</blockquote>
<p>And also <a href="https://mail.python.org/pipermail//python-ideas/2013-February/019524.html" rel="nofollow">here</a>:</p>
<blockquote>
<p>I've always wanted a version of pickle.loads() that takes a list of classes that are allowed to be instantiated.</p>
<blockquote>
<p>Is the following enough for you: <a href="http://docs.python.org/3.4/library/pickle.html#restricting-globals" rel="nofollow">http://docs.python.org/3.4/library/pickle.html#restricting-globals</a> ?</p>
<blockquote>
<p>Indeed, it is. Thanks for pointing it out! I've never gotten past the module interface part of the docs. Maybe the warning at the top of the page could also mention that there are ways to mitigate the safety concerns, and point to #restricting-globals?</p>
<blockquote>
<p>Yes, that would be a good idea :-)</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>So I don't know why the documentation has not been changed but according to me, using a <code>RestrictedUnpickler</code> to restrict the types that can be unpickled is a safe solution. Of course there could exist bugs in the library that compromise the system, but there could be a bug also in OpenSSL that show random memory data to everyone who asks.</p>
</div>
<span class="comment-copy">Is it important for your task to achieve something that <code>json</code> doesn't, e.g. forbidding the serialisation of <code>bool</code> types?</span>
<span class="comment-copy">@Brian yes, the data already exists. Switching the format in the future is an option, but I'd still need to unpickle the data frist to do the conversion.</span>
<span class="comment-copy">Oh... <a href="http://dilbert.com/2014-08-12/" rel="nofollow noreferrer">bummer</a> :(</span>
<span class="comment-copy">In order to get from some (whitelisted) object to <code>__builtins__</code> using Ned's procedure, you need some way to retrieve object attributes (e.g. <code>getattr(obj, '__class__')</code> or <code>obj.__class__</code>). I don't think this is possible with the pickle protocol. You can retrieve globals ('<code>GLOBAL</code> opcode), call/instantiate them with arbitrary arguments (<code>REDUCE</code>, <code>INST</code>, <code>OBJ</code>, <code>NEWOBJ</code>, <code>NEWOBJ_EX</code>) and <i>set</i> their attributes (<code>BUILD</code>), but you cannot retrieve attributes. Am I missing something?</span>
<span class="comment-copy">I've never seen my blog post connected to pickle before, but would like to know if it could be.  Pickle uses a stack-based execution machine, but it is not Python bytecode, so the possibilities are different.</span>
<span class="comment-copy">@NedBatchelder: sure, but that doesn't mean I'd trust pickle even with a limited set of globals. All it it takes is one seemingly innocuous <code>__new__</code> method returning an attribute instead of a new instance when passed certain arguments. <b>I just would not trust near-arbitrary calling power</b>.</span>
<span class="comment-copy">@Nikratio: I am not currently aware of an attack vector <i>but I cannot discount one either</i>. That should scare anyone; between the <code>copyreg</code> extensions that might be installed on an arbitrary system plus the ability to call <code>__new__</code> (which may or may not return an actual instance) the <i>possibility</i> still exists for an attacker to find a callable that produces a <code>getattr()</code> equivalent. Perhaps not now but in a future Python version. That's a <i>huge</i> risk in my eyes.</span>
<span class="comment-copy">I like the OpenSSL reference</span>
<span class="comment-copy">Also, many objects offer <i>indirect</i> access to globals, allowing an attacker to <b>still</b> get to load arbitrary objects. Restricting access to globals is <b>not enough</b>. I'd still recommend against using pickle when dealing with untrusted data.</span>
<span class="comment-copy">See <a href="http://nedbatchelder.com/blog/201302/finding_python_3_builtins.html" rel="nofollow noreferrer">nedbatchelder.com/blog/201302/finding_python_3_builtins.html</a> and related blog posts about circumventing <code>eval()</code> restrictions; those apply to unpickling just as much.</span>
