<div class="post-text" itemprop="text">
<p>I am working on software for a robot, which is normally run on the Raspberry Pi. Let's consider the imports of two files:</p>
<p><code>motor.py</code> (runs the motors):</p>
<pre><code>from RPi import GPIO as gpio
</code></pre>
<p>and <code>client.py</code> (communicates with the server and relays commands to the motors):</p>
<pre><code>from rpi.motor import Motor
</code></pre>
<p>Both files are in a directory called <code>rpi</code>, which contains a <code>__init__.py</code> and a <code>__main__.py</code>. The <code>RPi</code> package cannot be installed on non-RPi devices. However, I still want to test the functionality of <code>client.py</code>.</p>
<pre><code>import unittest
from unittest import mock
# Location A


class TestClient(unittest.TestCase):
    # Location B
    setUp(self):
         # Location C
         pass
</code></pre>
<p>Originally, I tried <code>from rpi.client import Client</code> at LocA, but that failed because it tried to import Motor, and then import GPIO from RPi, which doesn't exist. I also tried <code>mock.patch("rpi.client.Motor")</code> at LocB (including adding <code>mock_motor</code> after <code>self</code>, and imported <code>Client</code> at LocC, but that failed as well. I tried mocking <code>RPi</code> at LocA, too, but it didn't work either.</p>
<p>How do you mock out a library that is not installed on your system?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="noreferrer"><code>patch.dict()</code></a> to patch <code>sys.modules</code> and mock <code>RPi</code> module as showed in pointed documentation.</p>
<p>Use follow code at the top of your test module:</p>
<pre><code>&gt;&gt;&gt; from mock import MagicMock, patch
&gt;&gt;&gt; mymodule = MagicMock()
&gt;&gt;&gt; patch.dict("sys.modules", RPi=mymodule).start()
&gt;&gt;&gt; from RPi import GPIO as gpio
&gt;&gt;&gt; gpio
&lt;MagicMock name='mock.GPIO' id='139664555819920'&gt;
&gt;&gt;&gt; import os
&gt;&gt;&gt; os
&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt;
</code></pre>
<p>In Python3 you have same behavior. </p>
<hr/>
<p>In your specific case use <code>patch.dict</code> is little bit overkill; maybe you aren't interested in patch context and original state recover. So you can simplify it by set <code>sys.modules["RPi"]</code> directly:</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; mymodule = MagicMock()
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules["RPi"] = mymodule
&gt;&gt;&gt; from RPi import GPIO as gpio
&gt;&gt;&gt; gpio
&lt;MagicMock name='mock.GPIO' id='140511459454648'&gt;
&gt;&gt;&gt; import os
&gt;&gt;&gt; os
&lt;module 'os' from '/usr/lib/python3.4/os.py'&gt;
</code></pre>
</div>
<span class="comment-copy">I've verified that is a correct solution. To make the answer better I would expand on sys.modules.</span>
<span class="comment-copy">As you can read at <a href="https://docs.python.org/3/library/unittest.mock.html#patch-dict" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#patch-dict</a> <code>patch.dict()</code> default behavior preserve original dictionary and just inject new values. Anyway I integrated my answer with some other notes to make it more clear.</span>
