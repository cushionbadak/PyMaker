<div class="post-text" itemprop="text">
<p>In python, I have the line:</p>
<pre><code>check_output(['babel', 'www/scripts6/lib/data.js', '&gt;', 'www/scripts/lib/data.js'])
</code></pre>
<p>It gives me the error:</p>
<pre><code>subprocess.CalledProcessError: Command '['babel', 'www/scripts6/lib/data.js', '&gt;', 'www/scripts/lib/data.js']' returned non-zero exit status 2
</code></pre>
<p>I'm stumped.  The command works fine in the shell.  Why is python complaining?</p>
<p>EDIT:  using</p>
<pre><code>print(check_output(['babel', './www/scripts6/lib/data.js', '&gt;', './www/scripts/lib/data.js'], shell=True))
</code></pre>
<p>instead yields the output</p>
<pre><code>b'"use strict";\n\n'
</code></pre>
<p>in the terminal.  This suggests that babel is now working but babel is taking in NOTHING as its input and OUTPUTTING to the terminal.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should pass the shell command as a single string to <code>check_output</code>. The <a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="nofollow">documentation</a> about this function actually gives an example that does just that. In your case, it would look like this:</p>
<pre><code>check_output('path/to/babel ./www/scripts6/lib/data.js &gt; '
             './www/scripts/lib/data.js', shell=True)
</code></pre>
<p>The <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow">documentation</a> on Popen states: </p>
<blockquote>
<p>On POSIX with <code>shell=True</code>, the shell defaults to <code>/bin/sh</code>. If <code>args</code> is a string, the string specifies the command to execute through the shell. This means that the string must be formatted exactly as it would be when typed at the shell prompt. This includes, for example, quoting or backslash escaping filenames with spaces in them. If <code>args</code> is a sequence, the first item specifies the command string, and any additional items will be treated as additional arguments to the shell itself. That is to say, Popen does the equivalent of:</p>
<pre><code>Popen(['/bin/sh', '-c', args[0], args[1], ...])
</code></pre>
</blockquote>
<p><code>check_output</code> with <code>shell=True</code> interprets its arguments in the same way as described above.</p>
<p>If you are using the shell only for redirection, I would suggest to instead do this:</p>
<pre><code>check_output(['path/to/babel', './www/scripts6/lib/data.js', 
              '--out-file', './www/scripts/lib/data.js'])
</code></pre>
<p>This will save the output in the file you want without having to spawn a shell.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suspect that you need to enter the full path to <code>babel</code> instead of just <code>babel</code>, but you can try the following and see if it makes a difference:</p>
<pre><code>check_output(['babel', 'www/scripts6/lib/data.js', '&gt;', 'www/scripts/lib/data.js'], shell=True)
</code></pre>
<p><strong>EDIT:</strong> In reference to your edit, instead of using <code>check_output</code>, let's use <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen" rel="nofollow"><code>subprocess.Popen()</code></a>:</p>
<pre><code>import shlex
from subprocess import Popen

with open('./www/scripts/lib/data.js', 'w') as outfile:
    command = "babel ./www/scripts6/lib/data.js"
    command_args = shlex.split(command)
    process = Popen(command_args, stdout=outfile, shell=True)
    output, err = process.communicate()
    if err:
        print err
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As already explained, you would need to use shell=True, passing a single string to make your code work, a simpler solution would be to use <code>check_call</code>, passing a file object to stdout:</p>
<pre><code>from subprocess import check_call

with open('./www/scripts/lib/data.js',"w") as f:    
    check_call(['babel', './www/scripts6/lib/data.js'],stdout=f)
</code></pre>
<p>If you are just worried about redirecting the output then I don't see the need for <code>check_output</code> or any other means of storing any output, you might want to wrap the code in a try/except though and catch any non zero exit status. You can also set the <code>cwd</code>:</p>
<pre><code>from subprocess import check_call, CalledProcessError

def babel_sub(cmds, out_f, cwd="."):
    with open(out_f, "w") as f:
        try:
            check_call(cmds, stdout=f, cwd=cwd)
        except CalledProcessError as e:
            print(e)
</code></pre>
</div>
<span class="comment-copy">What you have typed is two strings, not a single string.  Here: <code>'path/to/babel ./www/scripts6/lib/data.js &gt; '              './www/scripts/lib/data.js'</code></span>
<span class="comment-copy">@mareoraft In Python two strings that are in sequence without any intervening operator are concatenated to a single string automatically by the interpreter. <code>'a' 'b'</code> is completely equivalent to <code>'ab'</code>. (See <a href="https://docs.python.org/2/reference/lexical_analysis.html#string-literal-concatenation" rel="nofollow noreferrer">here</a>.)</span>
<span class="comment-copy">The second solution you offer only works with the full path of babel.  This may be a portability issue if one of my devs has their babel stored elsewhere.</span>
<span class="comment-copy">Is there something bad about spawning another shell?  Will the spawned shell close after running the command?</span>
<span class="comment-copy">Spawning a shell for redirection when the command you are using allows storing output into a file is a waste of resources. Probably not going to make a huge difference in general but as a matter of principle I don't spawn shells unless I have to. Regarding your previous comment about needing the full path, that's incorrect. <code>check_output</code>, just like its siblings (<code>Popen</code>, etc.) honors the <code>PATH</code> environment variable. If a developer has set his <code>PATH</code> so that <code>babel</code> is readily findable then <code>check_output</code> (in either version in my answer) does not need the full path.</span>
<span class="comment-copy">We're one step closer.  Now there is just an input-output issue.  Please see my edits. Thanks!</span>
<span class="comment-copy">That fixes the OUTPUT issue, but not the INPUT issue.  Even when using the full path via <code>command_args = shlex.split("babel" + " " + "/Users/Matthew/programming/prove-math/" + in_path)</code>, I get the same babel output that I would get for a blank file input.</span>
