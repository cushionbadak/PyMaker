<div class="post-text" itemprop="text">
<p>The code here works for me. But I am new to Python and want to know and learn if there is a more elegant or pythonic way to do that job.</p>
<p>There is a list of two-element-tuples. I want to join equal list elements and store the count of equal elements as a third tuple-element (the first in front of the other two-tuple elements).</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

org = [ ( 12, 4 ),
        (  8, 4 ),
        ( 12, 8 ),
        ( 12, 8 ) ]

# should result in
# [ ( 1, 12, 4 ),
#   ( 1,  8, 4 ),
#   ( 2, 12, 8 ) ]


def count_element(count_in, e):
    """
        How often does 'e' appear in 'count_in'.
    """
    count = 0
    for x in count_in:
        if x == e:
            count += 1
    return count


def has_element(look_in, e):
    """
        'look_in' is a three-element tuple
        'e' is a two-element tuple
    """ 
    for x, y, z in look_in:
        if y == e[0] and z == e[1]:
            return True
    return False


def main():
    result = []

    for i in org:
        if has_element(result, i):
            continue
        c = count_element(org, i)
        resi = (c, i[0], i[1])
        result += [resi]

    print(org)
    print(result)


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to the other answers, but for any tuple dimension:</p>
<pre><code>org = [(12, 4), (8, 4), (12, 8), (12, 8), (4, 3, 2, 1)]

from collections import Counter
[(count,) + item for item, count in Counter(org).items()]
# [(2, 12, 8), (1, 12, 4), (1, 4, 3, 2, 1), (1, 8, 4)]
</code></pre>
<p><code>Counter</code> is definitely very useful (and idiomatic) for this, but it's good to remember that it's easy to construct a similar structure with a plain <code>dict</code>:</p>
<pre><code>counter = dict()
for item in org:
    if item not in counter:
        counter[item] = 1
    else:
        counter[item] += 1 
    # Alternatively, just: counter[item] = counter.get(item, 0) + 1      
</code></pre>
<p>Its properties are ideal for this task. If you're not familiar with <code>dict</code>s, more amazement is awaiting you. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a combination of a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow">Counter</a> and a list comprehension, we can do this fairly quickly. It will result in a new tuple though, since a tuple is immutable. </p>
<pre><code>from collections import Counter

org = [ ( 12, 4 ),
        (  8, 4 ),
        ( 12, 8 ),
        ( 12, 8 ) ] 
counts = Counter(org)
org_counts = [(counts[o], o[0], o[1]) for o in set(org)]
</code></pre>
<p>The <code>org_count</code> variable looks like this at the end of the script:</p>
<pre><code>[(2, 12, 8), (1, 12, 4), (1, 8, 4)]
</code></pre>
<p>It's important to note that the <code>Counter</code> is a dictionary subclass, thus unordered. That means you final list can be in a different order than the original <code>org</code> variable. I made the assumption that this was alright, because duplicates would be compressed into a single entry, thus messing up the order.</p>
<p>In the list comprehension, I utilize the unique <code>set</code> of <code>org</code> to prevent duplicate entries.</p>
<pre><code>for o in set(org)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An easier way to do what you are doing would be to use <code>collections.Counter</code> and list comprehension -</p>
<pre><code>import collections
def main()
    result = [(v,) + k for k,v in collections.Counter(org).items()]
    print(org)
    print(result)
</code></pre>
<p>Please note, this would not preserve the order from the original list.</p>
<p>Demo -</p>
<pre><code>&gt;&gt;&gt; org = [ ( 12, 4 ),
...         (  8, 4 ),
...         ( 12, 8 ),
...         ( 12, 8 ) ]
&gt;&gt;&gt;
&gt;&gt;&gt; result = [(v,) + k for k,v in collections.Counter(org).items()]
&gt;&gt;&gt; result
[(2, 12, 8), (1, 12, 4), (1, 8, 4)]
</code></pre>
<hr/>
<p>If you want to preserve the order, I would suggest you use a set to record the elements that are already seen and use <code>collections.Counter()</code> for counting. Example -</p>
<pre><code>import collections
def main():
    result = []
    seen = set()
    counts = collections.Counter(org)
    for x in org:
        if x not in seen:
            result.append((counts[x],) + x)
            seen.add(x)
</code></pre>
<p>Demo -</p>
<pre><code>&gt;&gt;&gt; org
[(12, 4), (8, 4), (12, 8), (12, 8)]
&gt;&gt;&gt;
&gt;&gt;&gt; result = []
&gt;&gt;&gt; seen = set()
&gt;&gt;&gt; counts = collections.Counter(org)
&gt;&gt;&gt; for x in org:
...     if x not in seen:
...         result.append((counts[x],) + x)
...         seen.add(x)
...
&gt;&gt;&gt; result
[(1, 12, 4), (1, 8, 4), (2, 12, 8)]
</code></pre>
<hr/>
<p>Also, just a suggestion , a better way to do the following -</p>
<pre><code>def has_element(look_in, e):
    """
        'look_in' is a three-element tuple
        'e' is a two-element tuple
    """ 
    for x, y, z in look_in:
        if y == e[0] and z == e[1]:
            return True
    return False
</code></pre>
<p>Is to use <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow"><code>any()</code></a> , Example -</p>
<pre><code>def has_element(look_in, e):
    """
        'look_in' is a three-element tuple
        'e' is a two-element tuple
    """ 
    return any(y == e[0] and z == e[1] for _, y, z in look_in)
</code></pre>
</div>
<span class="comment-copy">Can you explain the diff between code on codereview and code on stackoverflow? My code here is just a minimalistic example to describe my algorithmic problem. It is not productive code that needed to be reviewed.</span>
<span class="comment-copy">Is <code>(12, 4)</code> the same as <code>(4, 12)</code> for your desired result?</span>
<span class="comment-copy">No it is different.</span>
<span class="comment-copy">Wow. This is magic.</span>
<span class="comment-copy">No need for the set - just do <code>for o in counts</code>, or even <code>for o, count in counts.items()</code>.</span>
<span class="comment-copy">I will remember <code>any()</code> for my future work. But what is the advantage here? Your code is harder to read for humans.</span>
<span class="comment-copy">What is harder? The second one? The second one has the benefit of preserving the order.</span>
<span class="comment-copy">The first one is exactly the same as others, so I do not see how that is harder.</span>
<span class="comment-copy">The use of any(). You compress my four lines into one. That make it hard to read and understand.</span>
<span class="comment-copy">yea the same functionally as your four lines , but I don't see it being any harder to read , what is hard for you in that? It's not that long line.</span>
