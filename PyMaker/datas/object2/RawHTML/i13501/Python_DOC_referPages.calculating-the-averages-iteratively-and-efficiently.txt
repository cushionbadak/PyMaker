<div class="post-text" itemprop="text">
<p>I have a long list of integers:</p>
<pre><code>my_list = [10,13,42,23,12,45,33,59,12]
</code></pre>
<p>I want to calculate the averages of first <code>i</code> numbers, for all <code>i</code> in <code>0&lt;i&lt;n</code>.</p>
<p>I can basically do:</p>
<pre><code>averages = [ sum(my_list[0:i]) * (1.0/i) for i in range(1,len(my_list)) ]
</code></pre>
<p>which gives me the correct results, but I think there should be a faster way of doing this since I can use the previous sums in the following calculations.</p>
<p>I guess there should be a faster solution with <code>numpy</code>, maybe?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about using <code>numpy.cumsum</code></p>
<pre><code>In [13]: import numpy as np

In [14]: my_list = [10,13,42,23,12,45,33,59,12]

In [15]: np.cumsum(my_list) / np.arange(1, len(my_list)+1, dtype=np.float)
Out[15]: 
array([ 10.        ,  11.5       ,  21.66666667,  22.        ,
        20.        ,  24.16666667,  25.42857143,  29.625     ,  27.66666667])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply create a generator function that would also allow lazy evaluation or generation of the list in one go by casting the result into a <code>list</code>, and use the <code>enumerate</code> generator to generate the count of the current element over time.</p>
<pre><code>&gt;&gt;&gt; def average_series(items):
...     sum = 0
...     for i, item in enumerate(items, 1):
...         sum += item
...         yield float(sum) / i
... 
&gt;&gt;&gt; list(average_series([10,13,42,23,12,45,33,59,12]))
[10.0, 11.5, 21.666666666666668, ..., 27.666666666666668]
</code></pre>
<p>You don't always have to rely on numpy for simple things like this.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.2 or higher, see <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow">itertools.accumulate</a> (and <code>itertools.islice</code> if you're trying to get a running average for a subset of the inputs). For example, in your case (getting the running average for <code>n - 1</code> values in the input):</p>
<pre><code>import itertools
my_list = [10,13,42,23,12,45,33,59,12]
sums = itertools.islice(itertools.accumulate(my_list), len(my_list) - 1)
# If you didn't intend to omit the final value, it's just:
# sums = itertools.accumulate(my_list)
averages = [accum / i for i, accum in enumerate(sums, start=1)]
</code></pre>
</div>
<span class="comment-copy"><code>numpy</code> is always welcome.</span>
<span class="comment-copy">Note: In your particular case, where the list is already in memory, you could just slice <code>my_list</code> directly instead of using <code>islice</code>, e.g.  <code>sums = itertools.accumulate(my_list[:-1])</code>, but you'd want <code>islice</code> if the input was coming from a generator of some sort where direct slicing won't work.</span>
<span class="comment-copy">I'm not sure you need to slice at all, I get the impression that the OP wants the whole list (and just made an error in the question) but will wait for the OP to confirm.</span>
<span class="comment-copy">Possible. The example explicitly omits the last value, and for all 0&lt;i&lt;n would imply that omission is intentional. Hard to tell.</span>
