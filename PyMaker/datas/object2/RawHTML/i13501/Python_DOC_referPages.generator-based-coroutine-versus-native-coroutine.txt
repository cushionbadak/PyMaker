<div class="post-text" itemprop="text">
<p>I just read <a href="https://www.python.org/dev/peps/pep-0492/" rel="nofollow">PEP0492</a> talking about the new approach on coroutines but the PEP failed to make me understand the difference between generator-based coroutines and native ones. Can someone tell me the difference (maybe with examples)?</p>
<p>For what I understood they uses different words (yield/yield from and await/async/yield). I understand that at the end of a native coroutine a yield is expected, but this also stands true for generator-based ones.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no <em>functional</em> difference. "Native coroutines" using the <code>async</code> and <code>await</code> keywords are just syntactic sugar for what was previously implemented in "generator-based coroutines."</p>
<p>The use of <code>async</code> and <code>await</code> is recommended in the <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow">3.5 docs</a> <strong>if there is no need to support older Python versions</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To expand on what Mike S wrote: native coroutines in CPython share most of the same code as generators, so there's little functional difference. However, I think that PEP-492 rises above the threshold of just "syntactic sugar". Generators and native coroutines have separate purposes, so the new syntax clarifies an author's intent and can do things the old syntax cannot. Here are some examples:</p>
<ul>
<li>Generators are iterable, and native coroutines are not.</li>
<li>Native coroutines also permit new syntaxes like async context managers and async iterators.</li>
<li>Coroutines have useful debugging messages, e.g. a warning if you never <code>await</code> a coroutine object.</li>
</ul>
<p>The new syntax also nicely mirrors the <code>asyncio</code> library and resembles keywords used in other languages.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, conventionally the way to write coroutines involved callbacks. Even though callbacks might be convenient initially, but in my opinion, they lead to highly complicated and complex code, which is not pythonic to say the least. Besides, <code>yield</code> (especially <code>yield from</code> since python 3.3), has made implementing coroutines a lot easier and pythonic.</p>
<p>With generators, you can easily divide your code into initial part and callbacks.</p>
<pre><code>@asyncio.coroutine
def print_sum(x, y):
    result = yield from compute(x, y)

    #write callback code
    print("%s + %s = %s" % (x, y, result))
</code></pre>
</div>
<span class="comment-copy">The difference is the syntax; it is syntactic sugar to make it clearer and cleaner.</span>
<span class="comment-copy">So, apart from the syntax, they are identical? Sound too strange... it wouldn't be approved in a PEP.</span>
<span class="comment-copy">Decorators are syntactic sugar too, you could just use <code>func = decorator(func)</code> <i>after</i> the function declaration. Context managers are syntactic sugar for <code>try:...except:...finally:</code>. Python is all about readability and clarity of purpose, this fits right in with those goals.</span>
<span class="comment-copy">Putting it in that way, it seems more legit. Make an answer and I'll accept it</span>
<span class="comment-copy">[<a href="https://docs.python.org/3/reference/expressions.html#yield-expressions" rel="nofollow noreferrer">docs.python.org/3/reference/expressions.html#yield-expressions</a>) is, and always has been, an expression <code>await</code> cannot be used in any places <code>yield from</code> can't. In fact, the difference is the exact opposite: <code>yield from</code> can be used in places <code>await</code> can'tâ€”namely, non-<code>async</code> functions (and that restriction occasionally helps catch errors).</span>
<span class="comment-copy">Thanks @abarnert. You are definitely right. I have removed that incorrect statement from my answer.</span>
<span class="comment-copy">Ok, but this doesn't answer to the question "how native coroutines and generator-based coroutines are different?"</span>
<span class="comment-copy">They are not... just different ways to implement same thing</span>
