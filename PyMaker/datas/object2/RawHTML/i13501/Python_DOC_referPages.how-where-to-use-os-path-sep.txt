<div class="post-text" itemprop="text">
<p><code>os.path.sep</code> is the character used by the operating system to separate pathname components.</p>
<p>But when <code>os.path.sep</code> is used in <code>os.path.join()</code>, why does it truncate the path?</p>
<p>Example:</p>
<p>Instead of <code>'home/python'</code>, <code>os.path.join</code> returns <code>'/python'</code>:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.join('home', os.path.sep, 'python')
'/python'
</code></pre>
<p>I know that <a href="https://docs.python.org/2/library/os.path.html#os.path.join" rel="nofollow"><code>os.path.join()</code></a> inserts the directory separator implicitly. </p>
<p>Where is <code>os.path.sep</code> useful? Why does it truncate the path?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Where os.path.sep is usefull? </p>
</blockquote>
<p>I suspect that it exists mainly because a variable like this is required in the module anyway (to avoid hardcoding), and if it's there, it might as well be documented. Its documentation says that it is <a href="https://docs.python.org/2/library/os.html#os.sep" rel="noreferrer">"occasionally useful"</a>.</p>
<blockquote>
<p>Why it truncates the path?</p>
</blockquote>
<p>From the <a href="https://docs.python.org/2/library/os.path.html#os.path.join" rel="noreferrer">docs for <code>os.path.join()</code></a>:</p>
<blockquote>
<p>If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</p>
</blockquote>
<p>and <code>/</code> is an absolute path on *nix systems.</p>
</div>
<div class="post-text" itemprop="text">
<p>Drop <code>os.path.sep</code> from the <code>os.path.join()</code> call. <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow"><code>os.path.join()</code></a> uses <code>os.path.sep</code> internally.</p>
<p>On your system, <code>os.path.sep == '/'</code> that is interpreted as a root directory (absolute path) and therefore <code>os.path.join('home', '/', 'python')</code> is equivalent to <code>os.path.join('/', 'python') == '/python'</code>. <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow">From the docs</a>:</p>
<blockquote>
<p>If a component is an absolute path, all previous components are thrown
  away and joining continues from the absolute path component.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As correctly given in the docstring of <code>os.path.join</code> -</p>
<blockquote>
<p>Join two or more pathname components, inserting '/' as needed. <strong>If any component is an absolute path, all previous path components will be discarded.</strong></p>
</blockquote>
<p>Same is given in the <a href="https://docs.python.org/2/library/os.path.html#os.path.join" rel="nofollow">docs</a> as well -</p>
<blockquote>
<p><strong>os.path.join(path, *paths)</strong></p>
<p>Join one or more path components intelligently. The return value is the concatenation of path and any members of *paths with exactly one directory separator (os.sep) following each non-empty part except the last, meaning that the result will only end in a separator if the last part is empty. <strong>If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</strong></p>
</blockquote>
<p>When you give <code>os.path.sep</code> alone, it is considered as an absolute path to the root directory - <code>/</code> .</p>
<p>Please note , this is for unix/linux based os.path , which internally is <code>posixpath</code> . Though the same behavior is seen in windows <code>os.path.join()</code> .</p>
<p>Example -</p>
<pre><code>&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.join.__doc__
"Join two or more pathname components, inserting '/' as needed.\n    If any component is an absolute path, all previous path components\n    will be discarded."
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the snippet of code that is run if you are on a <code>POSIX</code> machine:</p>
<p><strong><a href="https://github.com/python/cpython/blob/master/Lib/posixpath.py#L67" rel="nofollow">posixpath.py</a></strong></p>
<pre><code># Join pathnames.
# Ignore the previous parts if a part is absolute.
# Insert a '/' unless the first part is empty or already ends in '/'.

def join(a, *p):
    """Join two or more pathname components, inserting '/' as needed.
    If any component is an absolute path, all previous path components
    will be discarded.  An empty last part will result in a path that
    ends with a separator."""
    sep = _get_sep(a)
    path = a
    try:
        if not p:
            path[:0] + sep  #23780: Ensure compatible data type even if p is null.
        for b in p:
            if b.startswith(sep):
                path = b
            elif not path or path.endswith(sep):
                path += b
            else:
                path += sep + b
    except (TypeError, AttributeError, BytesWarning):
        genericpath._check_arg_types('join', a, *p)
        raise
    return path
</code></pre>
<p>Specifically, the lines:</p>
<pre><code>        if b.startswith(sep):
            path = b
</code></pre>
<p>And, since <code>os.path.sep</code> definitely starts with this character, whenever we encounter it we throw out the portion of the variable <code>path</code> that has already been constructed and start over with the next element in <code>p</code>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But when os.path.sep is used in os.path.join() , why it truncates the path?</p>
</blockquote>
<p>Quoting directly from the documentation of <a href="https://docs.python.org/2/library/os.path.html#os.path.join" rel="nofollow">os.path.join</a></p>
<blockquote>
<p>If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</p>
</blockquote>
<p>So when you do:</p>
<pre><code>os.path.join('home', os.path.sep, 'python')
</code></pre>
<p><code>os.path.sep</code> returns <code>'/'</code> which is an absolute path, and so <code>'home'</code> is thrown away and you get only <code>'/python'</code> as the output.</p>
<p>This can is also clear from the example:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.join('home','/python','kivy')
'/python/kivy'
</code></pre>
<blockquote>
<p>Where os.path.sep is usefull?</p>
</blockquote>
<p><code>os.path.sep</code> or <code>os.sep</code> returns the character used by the operating system to separate pathname components.
But again quoting from the <a href="https://docs.python.org/2/library/os.html#os.sep" rel="nofollow">docs</a>:</p>
<blockquote>
<p>Note that knowing this is not sufficient to be able to parse or concatenate pathnames — use os.path.split() and os.path.join() — but it is occasionally useful.</p>
</blockquote>
</div>
