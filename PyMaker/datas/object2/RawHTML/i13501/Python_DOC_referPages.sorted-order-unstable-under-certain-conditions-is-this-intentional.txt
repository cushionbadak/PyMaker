<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/835092/python-dictionary-are-keys-and-values-always-the-same-order">Python dictionary: are keys() and values() always the same order?</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p><code>sorted()</code> <a href="https://docs.python.org/3.4/library/functions.html?highlight=sorted#sorted" rel="nofollow noreferrer">documentation</a> (emphasis mine):</p>
<blockquote>
<p>The built-in sorted() function is guaranteed to be stable. A sort is
  stable if it <strong>guarantees not to change the relative order of elements</strong>
<strong>that compare equal</strong> [...]</p>
</blockquote>
<p>In the code below, keys <code>8</code> and <code>16</code> have the same value, that is they would compare equal by the <code>key=lambda x: d[x]</code>:</p>
<pre><code>d = {8: 0, 16: 0, 'a': 1}    

for i in range(200):    
    print(sorted(d, key=lambda x: d[x]))

# Prints always the same 
# [8, 16, 'a']
# [8, 16, 'a']
# [8, 16, 'a']
# ......
</code></pre>
<p>Now lets try a small modification to the dictionary: </p>
<p><strong>Example 1:</strong> </p>
<pre><code>for i in range(10):

    if i == 5:

        del d[8]
        del d[16]

        d.update({16: 0})
        d.update({8: 0})

    print(sorted(d, key=lambda x: d[x]))

# Prints: 
# [8, 16, 'a']
# [8, 16, 'a']
# [8, 16, 'a']
# [8, 16, 'a']
# [8, 16, 'a'] 
# [16, 8, 'a']    &lt;----- it changed the order
# [16, 8, 'a']
# [16, 8, 'a']
# [16, 8, 'a']
# [16, 8, 'a']
</code></pre>
<p>id(d) remains the same. Also the contents remain the same. What changes is the order of key insertion.</p>
<p>Note:<br/>
Those keys were chosen so that they cause <a href="https://stackoverflow.com/a/12165239/4230591">hash collisions</a>:</p>
<blockquote>
<p>whether 8 occupies a location or 16 is determined by which one
  arrived at the party first</p>
</blockquote>
<hr/>
<p><strong>Example 2:</strong> </p>
<pre><code>d = {8: 0, 16: 0, 'a': 1}
c = {16: 0, 8: 0, 'a': 1}

print(sorted(d, key=lambda x: d[x]))
print(sorted(c, key=lambda x: d[x]))
</code></pre>
<p>I know that <code>d</code> and <code>c</code> are different objects here:</p>
<pre><code>id(d)  # 140067442777736
id(c)  # 140067442811016
</code></pre>
<p>But I would expect that <code>sorted()</code> treats objects that are <code>d == c</code> the exact same way.</p>
<hr/>
<p><strong>Example 3:</strong> 
A different example would be the following: </p>
<pre><code>d = {'a': 0, 'b': 0, 'c': 0, 'd': 1}

print(sorted(d, key=lambda x: d[x]))
</code></pre>
<p>Running this on multiple different runs (<em>not</em> with a <code>for</code> loop) would give a different order each time. </p>
<p>Note: That's assuming you use <a href="https://docs.python.org/3.4/using/cmdline.html?highlight=pythonhashseed#cmdoption-R" rel="nofollow noreferrer">Python 3.3 or higher</a> and your <code>PYTHONHASHSEED=random</code></p>
<hr/>
<p><strong>Question:</strong><br/>
The order is not stable: </p>
<ul>
<li>for the same object that gets its order
modified (example 1).</li>
<li>for 2 objects that compare equal (example 2).</li>
<li>for different runs of the exact same code (example 3).</li>
</ul>
<p>Is the order instability mentioned above a bug or am I missing something? Do I misunderstand the documentation by expecting all 3 examples to have a stable order?</p>
<p>Edit: 
This is not a duplicate. <strong>There is no answer in the duplicate that answers whether or not this behavior of <code>sorted()</code> is intentional or not.</strong>
I know why sorted behaves the way it does (I even caused that behavior intentionally). What I don't know is whether the documentation is missing something and whether I drew the wrong conclusions when reading it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not a bug, you missed something. You manipulated the dictionary changing the <em>order of iteration</em>, and it is that order that is kept stable by <code>sorted()</code>. Or put differently, <code>sorted()</code> keeps the <em>input order</em> stable, and <em>you</em> changed that input order by altering the dictionary.</p>
<p>Note that <code>sorted()</code> doesn't 'see' a dictionary here. It is passed a <em>sequence of keys</em>, just as if you used <code>list()</code> on the dictionary first. In this case, both <code>8</code> and <code>16</code> hash to the same hash-table slot. Which one is listed first depends on the order of insertions:</p>
<pre><code>&gt;&gt;&gt; d1 = {}
&gt;&gt;&gt; d1[8] = None
&gt;&gt;&gt; d1[16] = None
&gt;&gt;&gt; d1
{8: None, 16: None}
&gt;&gt;&gt; list(d1)
[8, 16]
&gt;&gt;&gt; d2 = {}
&gt;&gt;&gt; d2[16] = None
&gt;&gt;&gt; d2[8] = None
&gt;&gt;&gt; d2
{16: None, 8: None}
&gt;&gt;&gt; list(d2)
[16, 8]
</code></pre>
<p>Calling <code>list()</code> on the two dictionaries shows that the keys are listed in a different order. <code>sorted()</code> just <em>maintained</em> that order as it iterates over the dictionary, since they both are otherwise sorted in the same location, by value. This is exactly what the documentation tells you would happen.</p>
<p>Note that <em>dictionary equality</em> has no role to play here, at all. That's not what the <em>compare equal</em> part of the documentation is referring to. That only refers to the <em>elements <strong>in</strong> the sequence</em>; if the elements are equal (or in this case, if the <code>key(element)</code> values are equal), then those elements retain their relative order.</p>
<p>So to focus on possible things you missed here:</p>
<ul>
<li><p>The signature of the method is <code>sorted(iterable[, key][, reverse])</code>; the key word there is <em><code>iterable</code></em>. The first line of the documentation:</p>
<blockquote>
<p>Return a new sorted list <strong>from the items</strong> in <em>iterable</em>.</p>
</blockquote>
<p>Emphasis mine; it is the items from the iterable that are sorted. The Python glossary <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow">defines <code>iterable</code></a> as:</p>
<blockquote>
<p>An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as <code>list</code>, <code>str</code>, and <code>tuple</code>) and some non-sequence types like <code>dict</code>, file objects, and objects of any classes you define with an <code>__iter__()</code> or <code>__getitem__()</code> method. [...] When an iterable object is passed as an argument to the built-in function <code>iter()</code>, it returns an iterator for the object. This iterator is good for one pass over the set of values.</p>
</blockquote>
<p>Anything that takes an iterable basically will call <code>iter()</code> on it to loop over the sequence produced.</p></li>
<li><p>Dictionaries happen to be iterable, and iterating gives you the keys. See the <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow">mapping types documentation</a>:</p>
<blockquote>
<p><strong><code>iter(d)</code></strong><br/>
  Return an iterator over the keys of the dictionary. This is a shortcut for <code>iter(d.keys())</code>.</p>
</blockquote>
<p>The <code>dict.keys()</code> documentation then points to the <a href="https://docs.python.org/3/library/stdtypes.html#dict-views" rel="nofollow">dictionary views section</a>, which states:</p>
<blockquote>
<p><strong><code>iter(dictview)</code></strong><br/>
  Return an iterator over the keys, values or items (represented as tuples of (key, value)) in the dictionary.</p>
<p><strong>Keys and values are iterated over in an arbitrary order</strong> which is non-random, varies across Python implementations, <strong>and depends on the dictionaryâ€™s history of insertions and deletions</strong>. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond. This allows the creation of (value, key) pairs using <code>zip()</code>: <code>pairs = zip(d.values(), d.keys())</code>. Another way to create the same list is <code>pairs = [(v, k) for (k, v) in d.items()]</code>.</p>
</blockquote>
<p>Again, emphasis mine. So <code>sorted()</code> iterates, taking the items to sort. Dictionaries, when iterated, produce keys whose order is <strong>not</strong> stable.</p></li>
<li><p>Finally, the section you quoted, never contradicts this:</p>
<blockquote>
<p>The built-in <code>sorted()</code> function is guaranteed to be stable. A sort is stable if it guarantees not to change <strong>the relative order of elements that compare equal</strong>.</p>
</blockquote>
<p>So the elements <strong>in the sequence iterated</strong> do not change order. Nowhere does this state that dictionaries cannot <strong>produce a different order</strong> when iterated however.</p>
<p>In other words, it doesn't matter if <em>iterable_a == iterable_b</em> here, it is not about iterable equality, only <em>element equality</em> matters to the sort order stability. If the iteration order differs, <em>that order</em> is kept stable.</p></li>
</ul>
</div>
<span class="comment-copy">What makes you think sorted is at fault here? The order of the keys changed. <code>sorted()</code> maintains the relative order you give to it. Giving it <code>[16, 8]</code> is different from giving it <code>[8, 16]</code>.</span>
<span class="comment-copy">@MartijnPieters Its documentation made me think that on different runs, it would give the same result. Which it doesn't. Yes, <code>[16,8] != [8,16]</code>. <b>However</b> <code>{16,8} == {8,16}</code>.</span>
<span class="comment-copy">So? Just because the dictionaries are equal doesn't mean that sorted can see that or cares. It is given a sequence of keys, in a given order. You changed that order.</span>
<span class="comment-copy">but you are not sorting based on <code>16</code> or <code>8</code> at all . You are sorting based on its corresponding values from dictionary. If the values are same sorted would use the element that came first. Try out something like - <code>sorted([3,4,5,1,2],key=lambda x:1)</code> , would you really expect sorted to change the order?</span>
<span class="comment-copy">its not <code>sorted()</code> that is changing the order, <code>sorted()</code> is getting the changed order from dictionary itself.</span>
