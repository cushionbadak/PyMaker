<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10438894/python-subscript-a-module">Python: subscript a module</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>So it's quite a simple question. how do I add <code>__getitem__</code> to a Python module. I mostly just want it as an ease of use, however it's confusing why it wouldn't let me 'just set it'. Below is a simple example of <code>__getitem__</code> semi-working, however I wish for the <code>other['test']</code> to work.</p>
<p>Here's the full output:</p>
<pre><code>hello
hello
Traceback (most recent call last):
  File "main.py", line 4, in &lt;module&gt;
    print other['test']
TypeError: 'module' object has no attribute '__getitem__'
</code></pre>
<p>main.py</p>
<pre><code>import other
print other.get('test')
print other.__getitem__('test')
print other['test']
</code></pre>
<p>other.py</p>
<pre><code>test = 'hello'

def __getitem__(name):
    return globals()[name]

get = __getitem__
</code></pre>
<p>I've tried to set <code>__getitem__</code> using <code>globals()</code> aswell, <code>globals()['__getitem__'] = __getitem__</code>. It didn't work. And I tried to set it in <code>main.py</code>. So I'm confused as to why it's so adamant in not allowing me to use <code>other['test']</code>.</p>
<p>If it's impossible, then a short reason would be good.</p>
</div>
<div class="post-text" itemprop="text">
<p>Special methods are <a href="https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-new-style-classes" rel="nofollow">looked up on the <em>type</em></a>, not on an instance. Python looks for <code>type(other).__getitem__()</code> and that isn't available. You'd have to add the <code>__getitem__</code> method to the <code>module</code> type; you can't in Python.</p>
<p>You'd have to replace the whole <code>module</code> instance in <code>sys.modules</code> with an instance of your own class to achieve what you want:</p>
<pre><code>class MyModule(object):
    def __init__(self, namespace):
        self.__dict__.update(namespace)
    def __getitem__(name):
        return self.__dict__[name]

import other
import sys
sys.modules[other.__name__] = MyModule(other.__dict__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This limitation doesn't just apply for modules, it applies for anything such that the type is not <code>object</code> or some subclass of <code>object</code>, or something with a metaclass that never bottoms out with <code>object</code> in the <code>mro</code>.</p>
<p>For example, you can also see this happening with type <code>type</code>:</p>
<pre><code>In [32]: class Foo(type):
   ....:     pass
   ....: 

In [33]: type(Foo)
Out[33]: type

In [34]: Foo.__getitem__ = lambda x, y: x.__dict__.get(y)

In [35]: Foo.foo = "hello"

In [36]: Foo['foo']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-38-e354ca231ddc&gt; in &lt;module&gt;()
----&gt; 1 Foo['foo']

TypeError: 'type' object has no attribute '__getitem__'

In [37]: Foo.__dict__.get('foo')
Out[37]: 'hello'
</code></pre>
<p>The reason is that at the C-API level, both <a href="https://docs.python.org/2/c-api/module.html" rel="nofollow"><code>module</code></a> and <a href="https://docs.python.org/3/c-api/type.html#c.PyType_Type" rel="nofollow"><code>type</code></a> are particular instances of <a href="https://docs.python.org/2/c-api/typeobj.html" rel="nofollow"><code>PyTypeObject</code></a> which don't implement the required protocol for inducing the same search mechanism that the <code>PyTypeObject</code> <a href="https://docs.python.org/2/c-api/object.html" rel="nofollow">implementation of <code>object</code></a> and friends does implement.</p>
<p>To change this aspect of the language itself, rather than hacking a replacement of <code>sys.modules</code>, you would need to change the C source definitions for <code>PyModule_Type</code> and <code>PyType_Type</code> such that there were C functions created for <code>__getitem__</code> and added to the appropriate location in the C-API big <code>PyTypeObject</code> <a href="https://docs.python.org/2/extending/newtypes.html#the-basics" rel="nofollow">struct-o-magic-functions</a> (a lot of which is expanded by the macro <code>PyObject_HEAD</code>) instead of <code>0</code> (which is the sentinel for does not exist), and recompile Python itself with these modified implementations of <code>module</code> and <code>type</code>.</p>
</div>
<span class="comment-copy">@райтфолд: I'm editing too; I'll make the correction. :-)</span>
