<div class="post-text" itemprop="text">
<p>I've got this C program:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;

int main() {
    for (int i=0;; i++) {
        printf("%i\n",i);
        Sleep(100);
    }
    return 0;
}
</code></pre>
<p>And I have a Python script that tries to capture its output and do something with it:</p>
<pre><code>from subprocess import Popen, PIPE

p = Popen("a.exe", stdout=PIPE, shell=True)
print p.stdout.readline()
</code></pre>
<p>... and it hangs on the last line without printing anything on a screen.</p>
<p>I've tried to solve this problem using the Python shell and found this:</p>
<pre><code>&gt;&gt;&gt; from test import *
&gt;&gt;&gt; p.stdout.flush()
&gt;&gt;&gt; p.stdout.readline()
'0\r\n'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
^CKeyboardInterrupt
</code></pre>
<p>It can actually read the output but only when I send KeyboardInterrupt. <code>p.stdout.read(1)</code> behaves the same way.</p>
<p>So, what's a working, correct way to do what I want?</p>
<p><strong>Edit:</strong> <br/>
Ok, looks like it is impossible on Windows, see comments to first answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>The output is being buffered so you need to use<code>iter(p.stdout.readline,"")</code></p>
<pre><code>p = Popen("a.exe", stdout=PIPE)

for line in iter(p.stdout.readline,""):
     print line
</code></pre>
<p>Try flushing stdout from c if <code>sys.stdout.flush()</code> if  is not working, as far as I know lines are block buffered when writing to a pipe:</p>
<pre><code>int main() {
    for (int i=0;; i++) {
        printf("%i\n",i);
        Sleep(100);
        fflush(stdout);

    }
    return 0;
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rough example of something I did a long time ago.</p>
<pre><code>process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
while process.poll() is None:
    txt = process.stdout.read().decode("utf-8")
    result += txt
</code></pre>
<p>You can make your own StringIO which handles file io operations like read and write.</p>
<p><a href="https://docs.python.org/3/library/io.html" rel="nofollow">https://docs.python.org/3/library/io.html</a></p>
<p>I have not tested the code below!</p>
<pre><code>import io
buffer = io.StringIO()
p = Popen(["a.exe"], stdout=buffer)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Run python in <a href="https://docs.python.org/2/using/cmdline.html#cmdoption-u" rel="nofollow">unbuffered mode</a>:</p>
<pre><code>python -u myprogram.py 
</code></pre>
</div>
<span class="comment-copy">p.stdout.readline doesnt work. This does'nt work either.</span>
<span class="comment-copy">Just saw the sleep command, that is causing the issue, try flushing stdout</span>
<span class="comment-copy">fflush(stdout) works but I cant do this.  Originally "a.exe" is a server and i havent access to its source code.  sys.stdout.flush() doesnt  work</span>
<span class="comment-copy">is there a <code>stdbuf</code> command on windows or a way to run the command redirecting stdout to stderr just to check?</span>
<span class="comment-copy">I dont know. After quick googling i'd say no. But i found this: <a href="http://stackoverflow.com/questions/3385427/disable-buffering-on-redirected-stdout-pipe-win32-api-c">Disable Buffering on Redirected Stdout Pipe win32 api c</a> and seems like it cant be done on Windows..</span>
<span class="comment-copy">The problem is not with reading output. As I understood program buffers its output and you cant get any data until the buffer is full or the program is finished. Is there any way to force program to output data? p.stdout.flush() does nt work for some reason</span>
<span class="comment-copy">I need to run program in unbuffered mode, not my script</span>
<span class="comment-copy">Are you sure? Have you tried running the C program by itself?</span>
<span class="comment-copy">What should I get? It runs and it puts output into the console without any surprises.</span>
<span class="comment-copy">Maybe I'm misunderstanding your first comment. Since the C program prints to the console without an issue, it's not being buffered. Therefore, I suspect Python is buffering output, hence the <code>python -u</code>.</span>
