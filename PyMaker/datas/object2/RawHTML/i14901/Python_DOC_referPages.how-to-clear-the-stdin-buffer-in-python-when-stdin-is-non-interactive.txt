<div class="post-text" itemprop="text">
<p>How do I read everything there is from the stdin buffer in python without blocking? None of the stack overflow solutions I found work as my stdin is non-interactive.</p>
<h1>I tried:</h1>
<h2>tcflush</h2>
<p><code>tcflush(sys.stdin, TCIOFLUSH)</code> which does not work on non-interactive stdin.</p>
<h2>select</h2>
<pre><code>while select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
  sys.stdin.read(1)
</code></pre>
<p>and</p>
<pre><code>while len(select.select([sys.stdin.fileno()], [], [], 0.0)[0])&gt;0:
  os.read(sys.stdin.fileno(), 4096)
</code></pre>
<p>Which do not work because the condition in the <code>while</code> head is always <code>False</code>.</p>
<p>Any other ideas?</p>
<h1>Edit</h1>
<p>To be more precise:</p>
<p>My code should</p>
<ul>
<li>do nothing if the input buffer is empty</li>
<li>empty the buffer if there is something in it</li>
</ul>
<p>So it should <em>never</em> block.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using a zero seconds timeout in your <code>select()</code> call, which effectively makes select into a one-shot poll operation that does <strong>not</strong> wait until data is available.</p>
<pre><code>while len(select.select([sys.stdin.fileno()], [], [], 0.0)[0])&gt;0:
                                                       ^
                                                       |
                                                This means don't wait
</code></pre>
<p>Try instead:</p>
<pre><code>while len(select.select([sys.stdin.fileno()], [], [], None)[0]) &gt; 0:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for your suggestions so far. Apparently this was, after all, one of those strange concurrency problems.</p>
<p>When I set a timeout in the <code>select</code> call, it works. So it seems that the buffer really has not been filled at the moment I call the <code>select</code>.</p>
<p>Does not work (same as in the question):</p>
<pre><code>while select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
  sys.stdin.read(1)
</code></pre>
<p>Does work:</p>
<pre><code>while select.select([sys.stdin], [], [], 0.01) == ([sys.stdin], [], []):
  sys.stdin.read(1)
</code></pre>
<p>As the things I want to read are line-based, I can read a whole line at a time with <code>input</code> instead of reading single characters with <code>read</code> though, and then the slowdown of the timeout in the while loop will not be noticeable. (There will be max. 5-10 lines in the buffer).</p>
<p>I am not totally satisfied with this solution as it involves waiting for an arbitrary amount of time (will <code>0.01</code> always be enough?). But on the other hand I can't think of a better solution right now as I can't influence the code writing to "my stdin".</p>
</div>
<span class="comment-copy">What do you mean by 'do not work'?  If select says there is nothing to be read, how to you know that there is something to be read?</span>
<span class="comment-copy">@TerryJanReedy because if I put a <code>input()</code> after the <code>while</code> statement, it does not block. The <code>input()</code> also does not block if put before the <code>while</code> statement so I am pretty sure there is something in the buffer.</span>
<span class="comment-copy">Are you trying this in Windows? The <code>select</code> functionality in Windows is provided by WinSock, and thus only works on sockets. See the <a href="https://docs.python.org/3/library/select.html" rel="nofollow noreferrer">documentation</a>.</span>
<span class="comment-copy">Not blocking is the whole point ;-) See the clarification I just added.</span>
<span class="comment-copy">But then that's because there isn't any data to read. What is <code>stdin</code> connected to?</span>
