<div class="post-text" itemprop="text">
<p>I recently discovered the <code>try</code>statement (I'm pretty new) and I know about <code>except</code>, but I have some questions:</p>
<p>1) How do I use <code>finally</code>?</p>
<p>2) Can you have multiple <code>except</code>s with different errors? </p>
<p>Could you give me some examples of this? </p>
</div>
<div class="post-text" itemprop="text">
<p>Answer is yes to everything you ask.</p>
<pre><code>try:
    raise ArithmeticError
except ValueError:
    print("caught valueerror")
except RuntimeError:
    print("caught runtimeerror")
finally:
    print("I'll do this everytime")
</code></pre>
<p>Output: </p>
<pre><code>I'll do this everytime

Traceback (most recent call last):
  File "&lt;pyshell#13&gt;", line 2, in &lt;module&gt;
    raise ArithmeticError
ArithmeticError
</code></pre>
<p>That's it in short. To get full explanations you best see a tutorial, there's easily million of them online. Some general rules I like to hold to when doing this is:</p>
<ul>
<li>surround the shortest snippet of code you can with the try block. This helps isolate <strong>exactly</strong> where the error originated.</li>
<li>keep your excepts as specific as possible. Try not to catch a generic except as I shown bellow. It's useful sometimes, but so rarely so you should probably try to never do it.</li>
<li>finally is always executed. Finally <strong>always</strong> happens, if an error occurred, if it didn't, if you caught it or if you didn't, finally will always execute. Use it to create a clean exit for your code. Close all open files here, save all data structures you might have and tie all loose ends. </li>
</ul>
<p>We already saw how finally behaves when you encounter an error you don't have an except for above, here's an example when you raise an error that you have an except for: </p>
<pre><code>try:
    raise ValueError
except ValueError:
    print("caught valueerror")
except RuntimeError:
    print("caught runtimeerror")
finally:
    print("I'll do this everytime")

caught valueerror
I'll do this everytime
</code></pre>
<p>Finally will happen even if you don't encounter an error:</p>
<pre><code>try:
    pass
except ValueError:
    print("caught valueerror")
finally:
    print("I'll do this everytime")

I'll do this everytime
</code></pre>
<p>There's a couple of ways you can catch any error (try to avoid this, always):</p>
<pre><code>try:
    raise ArithmeticError
except BaseException as e:
    print("caught unknown error: ", e)
finally:
    print("I'll do this everytime")

('caught unknown error: ', ArithmeticError())
I'll do this everytime
</code></pre>
<p>or you could do</p>
<pre><code>import sys
try:
    raise ArithmeticError
except:
    print("caught unknown error: ", sys.exc_info()[0])
finally:
    print("I'll do this everytime")

('caught unknown error: ', &lt;type 'exceptions.ArithmeticError'&gt;)
I'll do this everytime
</code></pre>
<p>Additionally try except blocks can have an else statement.</p>
<p>Imagine, for a second, a situation where you would want to run some additional code appart from the <code>raise</code> statement. Imagine that code could throw an error too. To put that code inside the same try block would then break my 1st point and that's not how we should do things! To get around that with what I showed so far would look something like:</p>
<pre><code>executed = True
try:
    [do something]
except ValueError:
    executed = False
    print("caught valueerror")
finally:
    print("I'll do this everytime")
    if executed:
        [do something more]
</code></pre>
<p>I believe you'll agree that it's ugly and less readable than what python normally strives for. That's why there's an added else statement you can have in your try except block.</p>
<p>else statement <strong>must</strong> follow all excepts and will only ever execute if there was no error raised. To be really technical, it will only execute "if it flows off the try statement". That means that there must be no returns, breaks, continues and such statements that cause a "jump". else also makes your code neater and more powerful, however I've rarely used it or seen it been used:</p>
<pre><code>try:
    [do something]
    pass
except ValueError:
    print("caught valueerror")
except RuntimeError:
    print("caught runtimeerror")
else:
    [do something more but only if there were no exceptions so far]
    print("I found no errors and executed else statement")
    raise ArithmeticError
finally:
    print("I'll do this everytime")

I found no errors and executed else statement
I'll do this everytime

Traceback (most recent call last):
  File "&lt;pyshell#41&gt;", line 7, in &lt;module&gt;
    raise ArithmeticError
ArithmeticError
</code></pre>
</div>
<span class="comment-copy">check the official docs: <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/errors.html</a> the explanations are very good</span>
<span class="comment-copy">Since the next question is likely to be "how about <code>else</code>?", perhaps you should add an example of how <code>else</code> works here.</span>
<span class="comment-copy">@SethMMorton Added, I guess it was silly to pay attention to generic error catching and not have else. Thanks.</span>
<span class="comment-copy"><code>else</code> is useful to execute code before a <code>finally</code> that wasn't trapped in an <code>except</code>. Otherwise, I agree that it's use is mostly for clarity, although I use it often for that reason.</span>
