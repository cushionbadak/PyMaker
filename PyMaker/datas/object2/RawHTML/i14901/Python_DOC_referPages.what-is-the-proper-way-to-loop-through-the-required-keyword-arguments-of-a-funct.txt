<div class="post-text" itemprop="text">
<p>I'm looking to strip the white-space from each of the arguments in a function that takes a bunch of required strings.  And I don't want to use <code>**kwargs</code> which defeats the purpose of the required arguments.</p>
<pre><code>def func(a, b, c):
    for argument, argument_value in sorted(list(locals().items())):
        print(argument, ':', argument_value)
        argument_value = ' '.join(argument_value.split())
        print(argument, ':', argument_value)

    print('a is now:', a)

func(a='   a test 1  ', b='   b test 2 ', c='c test    3')
</code></pre>
<p>Output</p>
<pre><code>a :    a test 1  
a : a test 1
b :    b test 2 
b : b test 2
c : c test    3
c : c test 3
a is now:    a test 1  
</code></pre>
<p>Desired output for the original 'a' argument:</p>
<pre><code>a is now : a test 1  
</code></pre>
<p>Being a newb, I cobbled this together and <strong><em>then</em></strong> read the <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow">python documentation</a> which clearly states.</p>
<blockquote>
<p><strong>locals()</strong><br/>
  Update and return a dictionary representing the current local symbol table. Free variables are returned by locals() when it is
  called in function blocks, but not in class blocks.</p>
<p><em>Note</em><br/>
  The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the
  interpreter.</p>
</blockquote>
<p>What is the right way to do what I'm attempting here?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="http://thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow">decorator</a> to do that kind of task.</p>
<p>The idea is to mask the real function behind a decorator that will take generic arguments, do modifications "on them" (actually create new variables containing the modifications) and pass the modified arguments to the real function.</p>
<pre class="lang-py prettyprint-override"><code>def strip_blanks(f):
    def decorated_func(*args, **kwargs):
        # Strip blanks from non-keyword arguments
        new_args = [ " ".join(arg.split()) for arg in args]
        # Strip blanks from keyword arguments
        new_kwargs = { key:" ".join(arg.split()) for key,arg in kwargs.items()}
        # Pass the modified arguments to the decorated function
        # And forward its result in case needed
        return f(*new_args, **new_kwargs)
    return decorated_func

@strip_blanks
def func(a, b, c):
    for i in a, b, c:
        print(i)
</code></pre>
<p>Then you'd get</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; func(a = "  foo  bar", b = "baz  boz", c = "biz buz  ")
foo bar
baz boz
biz buz
&gt;&gt;&gt; func("  foo  bar", "baz  boz", "biz buz  ")
foo bar
baz boz
biz buz
&gt;&gt;&gt; func(a = "  foo  bar", b = "baz  boz", c = "biz buz  ", d = " ha ha")
Traceback (most recent call last):
  File "&lt;pyshell#40&gt;", line 1, in &lt;module&gt;
    func(a = "  foo  bar", b = "baz  boz", c = "biz buz  ", d = " ha ha")
  File "&lt;pyshell#35&gt;", line 5, in decorated_func
    f(*new_args, **new_kwargs)
TypeError: func() got an unexpected keyword argument 'd'
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would start by changing your definition to <code>def func(**kwargs)</code>.  This takes whatever keyword arguments you provide and adds them to a dictionary.  For example:</p>
<pre><code>def func(**kwargs):
    for key in kwargs:
        print key, kwargs[key]

&gt;&gt;&gt; func(a='hello', b='goodbye')
a hello
b goodbye
&gt;&gt;&gt; func()
&gt;&gt;&gt;
</code></pre>
<p>As you can see, it works with no arguments as well (nothing to print).  From there, have a look at the string method <code>strip</code>.</p>
<p>EDIT:</p>
<p>You're giving some pretty arbitrary restrictions.  So, what you want is:</p>
<ul>
<li><p>...a specific number of arguments with specific names.</p></li>
<li><p>...to loop over the arguments.</p></li>
<li><p>...perform some work on each one.</p></li>
</ul>
<p>The fastest way to do what you want is with <code>locals()</code> I think.  I'm guessing what you're balking at is the bit about the contents of the dictionary not being modified.  This isn't a concern here, as you're looping over a list of tuples representing the keys and values from the locals dictionary.  When you do <code>for argument, argument_value in ____</code> you are unpacking the tuples and assigning one value to each of those names.  When you then do <code>argument_value = 'blahblah'</code> you are assigning a new string to <code>argument_value</code>.  Strings are immutable, so you can't change the value "in placed".  You aren't changing the value in the dictionary, as you haven't assigned anything to the dictionary's key. </p>
</div>
<span class="comment-copy">I guess you don't want to use <code>**kwargs</code>?</span>
<span class="comment-copy">Yes.  That is correct.</span>
<span class="comment-copy">Maybe here ?: <a href="https://stackoverflow.com/questions/582056/getting-list-of-parameter-names-inside-python-function" title="getting list of parameter names inside python function">stackoverflow.com/questions/582056/â€¦</a></span>
<span class="comment-copy">Nope.  That just gets the argument names and values.  The key here is I want to act on each value.</span>
<span class="comment-copy">I do not get it, there is nothing more needed to act on an argument than getting its name and current value... If you mean that you want to <i>set</i> the argument from inside the function you are going in the wrong direction, that won't happen... However, if your arguments are references (i.e. objects, lists, dicts, ...) actions you take on them will affect the original object (i.e. if you get a list as an argument value and add an item to the list, it will be added to the original list, because you manipulate a reference).</span>
<span class="comment-copy">Awesome!  This is exactly the kind of answer I was looking for.  I learned a lot reading through the posted tutorial as well.  Thanks @Cilyan</span>
<span class="comment-copy">@GollyJer you're very welcome. It took me some time to understand what you needed, and then... (Aziz) light! :)</span>
<span class="comment-copy">But I want the function to define it's arguments by name.</span>
<span class="comment-copy">I've made an edit to my answer, but your question is a bit confusing to me as well with such arbitrary requirements.</span>
