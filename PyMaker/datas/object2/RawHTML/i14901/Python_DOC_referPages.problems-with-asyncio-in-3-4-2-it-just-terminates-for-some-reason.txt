<div class="post-text" itemprop="text">
<p>A newbie at python and spending many hours reading docs and other code I cannot seem to get the new <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow"><code>asyncio</code></a> module in Python 3.
It keeps on terminating without a stack trace to give me a clue and should run forever but does not.</p>
<p>The fundamental process concept I am trying to emulate is the following:</p>
<p><em>read from port:</em>
open port -&gt; read data (variable length) -&gt; place on queue1</p>
<p><em>then process data:</em>
get data from queue1 -&gt; condition applies -&gt; outcome put on queue2</p>
<p><em>then write to port:</em>
get data from queue2 and write to port</p>
<p>loop around from top forever</p>
<p>Note: The data on the in port is sporadic, variable length and several blocks may arrive out of 'sequence' thus I use <code>asyncio</code>. I understand <code>asyncio</code> will allow the case of a block arrives, then another prior to my app responding - i.e. the call <code>get_io_from_port()</code> facilitates multiple executions of the co-routine. This is why I have use the queues to ensure non-blocking of the <code>process_queue()</code></p>
<p>My toy example code so far:</p>
<pre><code>import queue
import asyncio

@asyncio.coroutine
def process_queue(q1, q2):
    tmp = q1.Get()
    if tmp == 'ABCDEF':
        q2.put('12345')
    elif tmp == 'GHIJKL':
        q2.put =('67890')
    else:
        print('There is a data error')

@asyncio.coroutine
def put_io_to_port(writer, q2):

    if not q2.empty():
        try:
                writer.write(q2.get())

        except IOError as e:
            print('OUT Port issue: ', e)

@asyncio.coroutine
def get_io_from_port(reader, q1):

    try:
        data_i = yield from reader.read(1200)
        q1.put(data_i)

    except IOError as e:
        print('IN Port issue: ', e)

def main():

    q1 = queue()
    q2 = queue()

    loop = asyncio.get_event_loop()     # main loop declaration
    reader, writer = yield from asyncio.open_connection('192.168.1.103', 5555)
                # high-level call open streams - read and write

    print('Start')
    tasks = [
        asyncio.async(get_io_from_port(reader,q1)),
        asyncio.async(process_queue(q1, q2)),
        asyncio.async(put_io_to_port(writer, q2)),]  # do these tasks - in this order

    loop.run_forever(tasks)     # loop through on main loop forever
    loop.close()

if __name__ == '__main__':
    main()
</code></pre>
<p>Also, as an aside - how does one debug this code - ie tracing? What techniques could be suggested? I am using Eclipse and PyDev but to no avail.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've made several mistakes here. First, you're treating <code>main</code> like its a normal function, but you've placed a <code>yield from</code> call in there, which will automatically convert it into a generator. That means when you do</p>
<pre><code>if __name__ == "__main__":
    main()
</code></pre>
<p><code>main</code> is not actually executed; the call to <code>main()</code> just creates a generator object that's immediately thrown away (because you're not assigning it to a variable). This is why you're having a hard time debugging - none of the code inside <code>main</code> is even executing. You should convert <code>main</code> to be a coroutine and call it using <code>loop.run_until_complete</code> instead.</p>
<p>Next, you're trying to use the <code>queue</code> module, which is not designed for use in a single-threaded asynchronous program. As soon as you call <code>queue.get()</code>, it's going to block your main thread, which means your <code>asyncio</code> event loop will be blocked, which means your whole program will be deadlocked. You should use the coroutine-safe <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue" rel="nofollow"><code>asyncio.Queue</code></a> instead.</p>
<p>You also have a race condition in <code>put_io_to_port</code>. You're only trying to consume from <code>q2</code> if it isn't empty, but its possible that <code>put_io_to_port</code> could execute before <code>process_queue</code> has a chance to run and populate the <code>queue</code>. It looks like you would be fine if you just removed the <code>if not q2.empty()</code> check from <code>put_io_to_port</code> altogether.</p>
<p>Finally, you're adding your coroutines to the event loop using <code>asyncio.async</code>, which is fine. But you have a comment that says <code># do these tasks, in this order</code>, but that's not how the program will behave with <code>asyncio.async</code>. It just adds all the coroutines to the event loop, and they'll all run in parallel. If you really want them to run sequentially, you should just do:</p>
<pre><code>yield from get_io_from_port(reader,q1)
yield from process_queue(q1, q2)
yield from put_io_to_port(writer, q2)
</code></pre>
<p>But that's really not necessary here. You can run all of them at the same time and get the correct behavior; if one coroutine executes ahead of the other, it will just wait until the coroutine it depends on passes it the data it needs, and then resume execution.</p>
<p>You also have a few typos in there (<code>q1.Get()</code>, <code>q2.put =(...)</code>, etc).</p>
<p>So, put all those fixes together and you get this:</p>
<pre><code>import queue
import asyncio

@asyncio.coroutine
def process_queue(q1, q2):
    while True:
        tmp = yield from q1.get()
        if tmp == 'ABCDEF':
            yield from q2.put('12345')
        elif tmp == 'GHIJKL':
            yield from q2.put('67890')
        else:
            print('There is a data error')

@asyncio.coroutine
def put_io_to_port(writer, q2):
    while True:
        try:
            data = yield from q2.get()
            writer.write(data)
        except IOError as e:
            print('OUT Port issue: ', e)

@asyncio.coroutine
def get_io_from_port(reader, q1):
    while True:
        try:
            data_i = yield from reader.read(1200)
            yield from q1.put(data_i)
        except IOError as e:
            print('IN Port issue: ', e)

@asyncio.coroutine
def main():
    q1 = asyncio.Queue()
    q2 = asyncio.Queue()

    reader, writer = yield from asyncio.open_connection('192.168.1.103', 5555)
                # high-level call open streams - read and write

    print('Start')
    tasks = [
        asyncio.async(get_io_from_port(reader,q1)),
        asyncio.async(process_queue(q1, q2)),
        asyncio.async(put_io_to_port(writer, q2)),]


if __name__ == '__main__':
    loop = asyncio.get_event_loop()     # main loop declaration
    loop.run_until_complete(main())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import queue
import asyncio

@asyncio.coroutine
def process_queue(q1, q2):
    while True:
        tmp = yield from q1.get()
        if tmp == 'ABCDEF':
            yield from q2.put('12345')
        elif tmp == 'GHIJKL':
            yield from q2.put('67890')
        else:
            print('There is a data error')

@asyncio.coroutine
def put_io_to_port(writer, q2):
    while True:
        try:
            data = yield from q2.get()
            writer.write(data)
        except IOError as e:
            print('OUT Port issue: ', e)

@asyncio.coroutine
def get_io_from_port(reader, q1):
    while True:
        try:
            data_i = yield from reader.read(1200)
            yield from q1.put(data_i)
        except IOError as e:
            print('IN Port issue: ', e)

@asyncio.coroutine
def main():
    q1 = asyncio.Queue()
    q2 = asyncio.Queue()

    reader, writer = yield from asyncio.open_connection('192.168.1.103', 5555)
                # high-level call open streams - read and write

    print('Start')

    asyncio.async(get_io_from_port(reader,q1))  # changed items so not
    asyncio.async(process_queue(q1, q2))        # in task list otherwise
    asyncio.async(put_io_to_port(writer, q2))   # they are not visible


if __name__ == '__main__':
    loop = asyncio.get_event_loop()     # main loop declaration
    loop.run_until_complete(main())
</code></pre>
<p>Find comments inline with code to understand the problem.</p>
</div>
<span class="comment-copy">I removed the rasks = [....] as I would assume the tasks would not be executed.      From what I see the reader, writer = yield from asyncio.open_connection('192.168.1.103', 5555) function is part of the main() loop and it is OK to do so. I definitely misunderstood this.   Thx for the clarity on the queues - there are many examples on web that are actually wrong! I will give this a try now. Appreciated.</span>
<span class="comment-copy">@devOpenID Are you talking about your original example? In your  code, the call to <code>asyncio.open_connection</code> is being made outside of the event loop context, in a normal (non-coroutine) function. Putting a <code>yield</code> or <code>yield from</code> in a normal function/method turns it into a generator, so the body of <code>main</code> never runs actually when you call <code>main()</code>. That's why you don't see <code>'Start'</code> get printed when you run your example code.</span>
<span class="comment-copy">@devOpenID Oh, I also missed that you want each coroutine to be an infinite loop. I've updated the example code to do that. You just need to add a <code>while True:</code> loop to each one.</span>
<span class="comment-copy">Oooops I was not clear enough. As you said, in my code. Look like I have more homework on getting to grips here. Thx</span>
<span class="comment-copy">If I understand your text answer correctly, the comment <code># do these tasks ...</code> should be removed from the code.</span>
<span class="comment-copy">You should add this as an edit to your initial question, not as a new answer.</span>
