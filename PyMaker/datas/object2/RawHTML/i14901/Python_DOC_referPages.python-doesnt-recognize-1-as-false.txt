<div class="post-text" itemprop="text">
<p>I recently wrote a Python program that used:</p>
<pre><code>if s.find('something'): 
</code></pre>
<p>or</p>
<pre><code>if s.find('something')==True:
</code></pre>
<p>but nothing worked correctly until I used:</p>
<pre><code>if s.find('something') &gt;0
</code></pre>
<p>That's the only way I could get an accurate True decision in my program.</p>
<p>It seems -1 result wasn't recognized as False. Successful finds weren't recognized as True either. So looking for -1 (False) or a positive number &gt;0 (True) was the only thing that worked for me.</p>
<p>What was I doing wrong? This can't be the way Python works, can it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are interpreting the return value of <a href="https://docs.python.org/3/library/stdtypes.html#str.find" rel="nofollow"><code>find</code></a> incorrectly. The documentation states:</p>
<blockquote>
<p><strong><code>str.find(sub[, start[, end]])</code></strong></p>
<p>Return the lowest index in the string where substring <code>sub</code> is found, such that <code>sub</code> is contained in the slice <code>s[start:end]</code>. Optional arguments start and end are interpreted as in slice notation. Return <code>-1</code> if <code>sub</code> is not found.</p>
</blockquote>
<p>Of all numbers, Python considers only <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow">0 to be false; -1 is true</a>. As <code>find</code> returns the index of the beginning of the match, and 0 is a valid index to a string, -1 is returned when no match was found.</p>
<p>Thus your code should rather* be:</p>
<pre><code>if s.find('something') != -1: 
</code></pre>
<p>or </p>
<pre><code>if s.find('something') &gt;= 0:
</code></pre>
<p>Though they're not the most Pythonic either, if you just want to see if <code>s</code> contains <code>'something'</code> - see below.</p>
<hr/>
<p>Now, about your second example: the <code>bool</code> constant <code>False</code> compares equal to <code>0</code>:</p>
<pre><code>&gt;&gt;&gt; 0 == False
True
</code></pre>
<p>and <code>bool</code> constant <code>True</code> only equal to number <code>1</code>:</p>
<pre><code>&gt;&gt;&gt; 1 == True
True
&gt;&gt;&gt; 2 == True
False
</code></pre>
<p>Thus the expression <code>s.find('something') == True</code> would be totally equivalent with <code>s.find('something') == 1</code>; and the whole expression would evaluate to <code>True</code> only if the <code>s</code> would be of form <code>xsomethingxxxx</code>, with a match for <code>something</code> starting at the 2nd character (index 1).</p>
<hr/>
<p>The documentation for <code>str.find</code> continues with the following note:</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>find()</code> method <strong>should be used only if you need to know the position of <code>sub</code>.</strong> To check if <code>sub</code> is a substring or not, use the <code>in</code> operator:</p>
<pre><code>&gt;&gt;&gt; 'Py' in 'Python'
True
</code></pre>
</blockquote>
<p>Thus the form that is the most Pythonic for the problem in your question is</p>
<pre><code>if 'something' in s:
</code></pre>
<hr/>
<p>As suggested by @myaut, if you <em>need</em> the position of <code>'something'</code> within <code>s</code> and expect it to contain the value, you should use <a href="https://docs.python.org/3/library/stdtypes.html#str.index" rel="nofollow"><code>str.index</code></a> instead, which will throw an exception if the <code>substring</code> was not found within the string.</p>
<pre><code> try:
     position = s.index('something')
     print("'something' found at", position)
 except ValueError:
     print(s, "does not contain the substring 'something'")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python thinks <code>0</code> is <code>False</code>, not <code>-1</code>.</p>
<p>As you can see in the <a href="https://docs.python.org/2.4/lib/truth.html" rel="nofollow">Python documentation</a>, Python tries hard to have many different kinds of <code>False</code> values:</p>
<ul>
<li><code>False</code></li>
<li><code>None</code></li>
<li><code>0</code> of any numeric type: <code>0</code>, <code>0L</code>, <code>0.0</code>, <code>0j</code>.</li>
<li>any empty sequence: <code>''</code>, <code>()</code>, <code>[]</code>.</li>
<li>any empty mapping: <code>{}</code>.</li>
</ul>
<p>Your intuitive notion that <code>-1</code> should be <code>False</code> in Python makes some sense, but that is just not how Python was designed. Zeros and empties are falsey in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only want to check wether a string is contained in another, use:</p>
<pre><code>if 'something' in s:
    print 'something in %s' % s
else:
    print 'bad luck'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The quickest way to verify what is the bool value of it;</p>
<pre><code>bool(-1)
True

bool(0)
False

bool('')
False
</code></pre>
<p>and so on, </p>
</div>
<div class="post-text" itemprop="text">
<p><code>-1</code> as an error code came from C, but that leads to spaghetti code of checking return values.</p>
<p>Python has more reliable way to report an error: <a href="https://docs.python.org/3.4/tutorial/errors.html" rel="nofollow">raise an Exception</a>. I.e. <code>str.index</code> does that:</p>
<pre><code>&gt;&gt;&gt; 'abcde'.find('cd')
2
&gt;&gt;&gt; 'abcde'.index('cd')
2
&gt;&gt;&gt; 'abcde'.find('zx')
-1
&gt;&gt;&gt; 'abcde'.index('zx')
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: substring not found
</code></pre>
<p>And of course to check if string contains substring you should use <code>in</code> operator:</p>
<pre><code>&gt;&gt;&gt; 'ab' in 'abcde'
True
&gt;&gt;&gt; 'zx' in 'abcde'
False
</code></pre>
<p>Speaking of <code>if</code> statements you should note that comparing to boolean is a bad idea (check for example <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP-8</a>). </p>
<p>Every type in Python defines its own rules which values are considered "True": <a href="https://docs.python.org/3.4/library/stdtypes.html#truth-value-testing" rel="nofollow">Truth value testing</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You are not doing something wrong.</p>
<p>In python <code>bool</code> inherit from <code>int</code>. <code>False</code> is <code>0</code> and <code>True</code> is <code>1</code>. You can try <code>int(True)</code> and <code>int(False)</code>. If you try <code>bool(0)</code> you will get <code>False</code>, but if you write <code>bool(-1)</code> or <code>bool(1)</code> you always will get <code>True</code>. If you use <code>find</code> you will get <code>-1</code> so you need to use <code>&gt;= 0</code>. You can find <code>'something'</code> inside <code>'something else'</code>.</p>
<p>You can write <code>if 'something' in s:</code>. I think that find is deprecated.</p>
</div>
<span class="comment-copy"><code>find</code> returns the index that the substring was found at. Since 0 is a valid index, it can't be used as a 'not found' code, so it returns -1 instead. The only falsey number in Python is 0. If you just want to check for containment, use <code>"something" in s</code> instead, which returns a boolean.</span>
<span class="comment-copy">Thanks very much - I understand now.</span>
<span class="comment-copy">So the problem is not how python performs boolean evaluation of numeric values, but the way the OP was interpreting the return value from <code>str.find</code> , right?</span>
<span class="comment-copy">@heltonbiker, right.  BTW Antti, I'm pretty sure that you mean "should NOT be used", please edit accordingly...</span>
<span class="comment-copy">Do not compare booleans with <code>==</code> or at least do <code>bool(1) == True</code> (see PEP-8). You miss <code>__bool__</code> operator that actually decides which values are <code>True</code> and which are <code>False</code>.</span>
<span class="comment-copy">@myaut I am very well aware of that.</span>
<span class="comment-copy">@AnttiHaapala: Even if you aware, it may confuse OP like that confused me ;)</span>
