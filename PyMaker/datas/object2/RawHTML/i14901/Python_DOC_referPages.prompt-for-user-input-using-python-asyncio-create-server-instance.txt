<div class="post-text" itemprop="text">
<p>I'm learning about python 3 asyncio library, and I've run into a small issue. I'm trying to adapt the EchoServer example from the python docs to prompt for user input rather than just echo what the client sends. </p>
<p>I thought it would be as easy as just adding a call to input(), but of course input() will block until there is user input which causes the problems.</p>
<p>Ideally I would like to continue receiving data from the client even when the server has nothing to "say". Somewhat like a chat client where each connection is chatting with the server. I'd like to be able to switch to-and-from each individual connection and send input as needed from stdin. Almost like a P2P chat client.</p>
<p>Consider the following modified EchoServer code:</p>
<pre><code>import asyncio

class EchoServerClientProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        peername = transport.get_extra_info('peername')
        print('Connection from {}'.format(peername))
        self.transport = transport

    def data_received(self, data):
        message = data.decode()
        print('Data received: {!r}'.format(message))

        reply = input()
        print('Send: {!r}'.format(reply))
        self.transport.write(reply.encode())

        #print('Close the client socket')
        #self.transport.close()

loop = asyncio.get_event_loop()
# Each client connection will create a new protocol instance
coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)
server = loop.run_until_complete(coro)

# Serve requests until CTRL+c is pressed
print('Serving on {}'.format(server.sockets[0].getsockname()))
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

# Close the server
server.close()
loop.run_until_complete(server.wait_closed())
loop.close()
</code></pre>
<p>How would I go about getting input form stdin on the server side and specify which connection to send it to while still received inputs from the connected clients?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.add_reader" rel="noreferrer"><code>loop.add_reader</code></a> schedule a callback to run when data is available on <code>sys.stdin</code>, and then use an <a href="https://docs.python.org/3/library/asyncio-queue.html#queue" rel="noreferrer"><code>asyncio.Queue</code></a> to pass the stdin data received to your <code>data_received</code> method:</p>
<pre><code>import sys
import asyncio


def got_stdin_data(q):
    asyncio.async(q.put(sys.stdin.readline()))

class EchoServerClientProtocol(asyncio.Protocol):
   def connection_made(self, transport):
       peername = transport.get_extra_info('peername')
       print('Connection from {}'.format(peername))
       self.transport = transport

   def data_received(self, data):
       message = data.decode()
       print('Data received: {!r}'.format(message))
       fut = asyncio.async(q.get())
       fut.add_done_callback(self.write_reply)

   def write_reply(self, fut):
       reply = fut.result()
       print('Send: {!r}'.format(reply))
       self.transport.write(reply.encode())

       #print('Close the client socket')
       #self.transport.close()

q = asyncio.Queue()
loop = asyncio.get_event_loop()
loop.add_reader(sys.stdin, got_stdin_data, q)
# Each client connection will create a new protocol instance
coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)
server = loop.run_until_complete(coro)

# Serve requests until CTRL+c is pressed
print('Serving on {}'.format(server.sockets[0].getsockname()))
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

# Close the server
server.close()
loop.run_until_complete(server.wait_closed())
loop.close()
</code></pre>
<p>The only tricky bit is how we call the <code>Queue.put</code>/<code>Queue.get</code> methods; both of them are coroutines, which can't be called using <code>yield from</code> in the callback or the <code>Protocol</code> instance methods. Instead, we just schedule them with the event loop using <code>asyncio.async</code>, and then use the <code>add_done_callback</code> method to handle the reply we retrieve from the <code>get()</code> call.</p>
</div>
<span class="comment-copy">I suspected that I needed to use a queue like this, but wasn't sure how to implement. Thank you for the great response! It works nicely.</span>
