<div class="post-text" itemprop="text">
<p>I have working code that takes a directory of csv files and hashes one column of each line, then aggregates all files together.  The issue is the output only displays the first hash value, not re-running the hash for each line.  Here is the code:</p>
<pre><code> import glob
 import hashlib

 files = glob.glob( '*.csv' )
 output="combined.csv"

 with open(output, 'w' ) as result:
     for thefile in files:
        f = open(thefile)
        m = f.readlines()
        for line in m[1:]:
            fields = line.split()       
            hash_object = hashlib.md5(b'(fields[2])')
            newline = fields[0],fields[1],hash_object.hexdigest(),fields[3]
            joined_line = ','.join(newline)
            result.write(joined_line+ '\n')
  f.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are creating a hash of a <em>fixed bytestring</em> <code>b'(fields[2])'</code>. That value has no relationship to your CSV data, even though it uses the same characters as are used in your row variable name.</p>
<p>You need to pass in bytes <em>from your actual row</em>:</p>
<pre><code>hash_object = hashlib.md5(fields[2].encode('utf8'))
</code></pre>
<p>I am assuming your <code>fields[2]</code> column is a string, so you'd need to encoding it first to get bytes. The UTF-8 encoding can handle all codepoints that could possibly be contained in a string.</p>
<p>You also appear to be re-inventing the CSV reading and writing wheel; you probably should use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow"><code>csv</code> module</a> instead:</p>
<pre><code> import csv

 # ...

 with open(output, 'w', newline='') as result:
     writer = csv.writer(result)

     for thefile in files:
        with open(thefile, newline='') as f:
            reader = csv.reader(f)
            next(reader, None)  # skip first row
            for fields in reader:
                hash_object = hashlib.md5(fields[2].encode('utf8'))
                newrow = fields[:2] + [hash_object.hexdigest()] + fields[3:]
                writer.writerow(newrow)
</code></pre>
</div>
<span class="comment-copy">why this: <code>hash_object = hashlib.md5(b'(fields[2])')</code>, this should be sth like: <code>hash_object = hashlib.md5(fields[2])</code>, but comverted to binary format, else you just has the constant string 'fields[2]'</span>
