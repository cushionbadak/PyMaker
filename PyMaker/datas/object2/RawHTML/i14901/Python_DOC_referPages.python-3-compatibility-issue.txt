<div class="post-text" itemprop="text">
<p><strong>Description of problem</strong></p>
<p>I have to migrate some code to Python 3. The compilation terminated with success. But I have a problem on the runtime: </p>
<pre><code>static PyObject* Parser_read(PyObject * const self, PyObject * unused0, PyObject * unused1) {
    //Retrieve bytes from the underlying data stream.
    //In this case, an iterator
    PyObject * const i = PyIter_Next(self-&gt;readIterator);

    //If the iterator returns NULL, then no more data is available.
    if(i == NULL)
    {
        Py_RETURN_NONE;
    }

    //Treat the returned object as just bytes
    PyObject * const bytes = PyObject_Bytes(i);

    Py_DECREF(i);

    if( not bytes )
    {
        //fprintf(stderr, "try to read %s\n", PyObject_Str(bytes));
        PyErr_SetString(PyExc_ValueError, "iterable must return bytes like objects");
        return NULL;

    }

    ....
}
</code></pre>
<p>In my python code, I have something like that:</p>
<pre><code>for data in Parser(open("file.txt")):
   ...
</code></pre>
<p>The code works well on Python 2. But on Python 3, I got:</p>
<pre><code>ValueError: iterable must return bytes like objects
</code></pre>
<p><strong>Update</strong></p>
<p>The solution of @casevh works well in all test cases except one: when I wrap the stream:</p>
<pre><code>def wrapper(stream):
    for data in stream:
        for i in data:
            yield i

for data in Parser(wrapper(open("file.txt", "rb"))):
    ...
</code></pre>
<p>and I got:
<strong>ValueError: iterable must return bytes like objects</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>One option is to open the file in binary mode:</p>
<pre><code>open("file.txt", "rb")
</code></pre>
<p>That should create an iterator that returns a sequence of bytes.</p>
<p>Python 3 strings are assumed to be Unicode and without proper encoding/decoding, they shouldn't be interpreted as a sequence of bytes. If you are reading plain ASCII text, and not a binary data stream, you could also convert from Unicode to ASCII. See <code>PyUnicode_AsASCIIString()</code> and related functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>As noted by @casevh, in Python you need to decide whether your data is binary <strong>or</strong> text. The fact that you are iterating lines makes me think that the latter is the case.</p>
<hr/>
<pre><code>def wrapper(stream):
    for data in stream:
        for i in data:
            yield i
</code></pre>
<p>works in Python 2, because iterating a <code>str</code> will yield 1-character strings; in Python 3, iterating over a <code>bytes</code> object will <strong>yield individual bytes that are integers in range 0 - 255</strong>. You can get the the code work identically in Python 2 and 3 (and identically to the Python 2 behaviour of the code above) by using range and slicing 1 byte/character at a time:</p>
<pre><code>def wrapper(stream):
    for data in stream:
        for i in range(len(data)):
            yield data[i:i + 1]
</code></pre>
<hr/>
<p>P.S. You also have a mistake in your C extension code: <code>Parser_read</code> takes 3 arguments, 2 of which are named <code>unused_x</code>. Only a method annotated with <a href="https://docs.python.org/3/c-api/structures.html#METH_KEYWORDS" rel="nofollow"><code>METH_KEYWORDS</code></a> takes 3 arguments (<code>PyCFunctionWithKeywords</code>); all others, including <code>METH_NOARGS</code> must be functions taking 2 arguments (<code>PyCFunction</code>).</p>
</div>
<span class="comment-copy">thanks, It works. But, In some test, I have a wrapper to the stream. so I do something like that: for i in open("someFile", "rb"): for j in i: yield j And I got the same error</span>
<span class="comment-copy">Does your wrapper return <code>str</code> or <code>bytes</code>? If your data is ASCII text, you may want to use the second option, i.e. convert Unicode to ASCII.</span>
<span class="comment-copy">Sorry, it was a typo error in the wrapper code and it's fixed now!</span>
