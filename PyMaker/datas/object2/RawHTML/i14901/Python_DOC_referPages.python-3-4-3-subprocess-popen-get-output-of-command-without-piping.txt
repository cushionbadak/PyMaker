<div class="post-text" itemprop="text">
<p>I am trying to assign the output of a command to a variable without the command thinking that it is being piped. The reason for this is that the command in question gives unformatted text as output if it is being piped, but it gives color formatted text if it is being run from the terminal. I need to get this color formatted text.</p>
<p>So far I've tried a few things. I've tried Popen like so:</p>
<pre><code>output = subprocess.Popen(command, stdout=subprocess.PIPE)
output = output.communicate()[0]
output = output.decode()
print(output)
</code></pre>
<p>This will let me print the output, but it gives me the unformatted output that I get when the command is piped. That makes sense, as I'm piping it here in the Python code. But I am curious if there is a way to assign the output of this command, directly to a variable, without the command running the piped version of itself.</p>
<p>I have also tried the following version that relies on check_output instead:</p>
<pre><code>output = subprocess.check_output(command)
output = output.decode()
print(output)
</code></pre>
<p>And again I get the same unformatted output that the command returns when the command is piped.</p>
<p>Is there a way to get the formatted output, the output the command would normally give from the terminal, when it is not being piped?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://pexpect.readthedocs.org/en/latest/install.html">pexpect</a>:</p>
<p>2.py:</p>
<pre><code>import sys

if sys.stdout.isatty():
    print('hello')
else:
    print('goodbye')
</code></pre>
<p>subprocess:</p>
<pre><code>import subprocess

p = subprocess.Popen(
    ['python3.4', '2.py'],
    stdout=subprocess.PIPE
)

print(p.stdout.read())

--output:--
goodbye
</code></pre>
<p>pexpect:</p>
<pre><code>import pexpect

child = pexpect.spawn('python3.4 2.py')

child.expect(pexpect.EOF)
print(child.before)  #Print all the output before the expectation.

--output:--
hello
</code></pre>
<p>Here it is with <code>grep --colour=auto</code>:</p>
<pre><code>import subprocess

p = subprocess.Popen(
    ['grep', '--colour=auto', 'hello', 'data.txt'],
    stdout=subprocess.PIPE
)

print(p.stdout.read())

import pexpect

child = pexpect.spawn('grep --colour=auto hello data.txt')
child.expect(pexpect.EOF)
print(child.before)

--output:--
b'hello world\n'
b'\x1b[01;31mhello\x1b[00m world\r\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can use the <a href="https://docs.python.org/3/library/pty.html" rel="nofollow">pty module</a>. </p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; p = subprocess.Popen(["ls", "--color=auto"], stdout=subprocess.PIPE)
&gt;&gt;&gt; p.communicate()[0]
# Output does not appear in colour
</code></pre>
<p>With <code>pty</code>:</p>
<pre><code>import subprocess
import pty
import os

master, slave = pty.openpty()
p = subprocess.Popen(["ls", "--color=auto"], stdout=slave)
p.communicate()
print(os.read(master, 100)) # Print 100 bytes
# Prints with colour formatting info
</code></pre>
<p>Note from the docs:</p>
<blockquote>
<p>Because pseudo-terminal handling is highly platform dependent, there
  is code to do it only for Linux. (The Linux code is supposed to work
  on other platforms, but hasnâ€™t been tested yet.)</p>
</blockquote>
<p>A less than beautiful way of reading the whole output to the end in one go:</p>
<pre><code>def num_bytes_readable(fd):
    import array
    import fcntl
    import termios
    buf = array.array('i', [0])
    if fcntl.ioctl(fd, termios.FIONREAD, buf, 1) == -1:
        raise Exception("We really should have had data")
    return buf[0]

print(os.read(master, num_bytes_readable(master)))
</code></pre>
<p>Edit: nicer way of getting the content at once thanks to @Antti Haapala:</p>
<pre><code>os.close(slave)
f = os.fdopen(master)
print(f.read())
</code></pre>
<p>Edit: people are right to point out that this will deadlock if the process generates a large output, so @Antti Haapala's answer is better.</p>
</div>
<div class="post-text" itemprop="text">
<p>A working polyglot example (works the same for Python 2 and Python 3), using <code>pty</code>.</p>
<pre><code>import subprocess
import pty
import os
import sys

master, slave = pty.openpty()
# direct stderr also to the pty!
process = subprocess.Popen(
    ['ls', '-al', '--color=auto'],
    stdout=slave,
    stderr=subprocess.STDOUT
)

# close the slave descriptor! otherwise we will
# hang forever waiting for input
os.close(slave)

def reader(fd):
    try:
        while True:
            buffer = os.read(fd, 1024)
            if not buffer:
                return

            yield buffer

    # Unfortunately with a pty, an 
    # IOError will be thrown at EOF
    # On Python 2, OSError will be thrown instead.
    except (IOError, OSError) as e:
        pass

# read chunks (yields bytes)
for i in reader(master):
    # and write them to stdout file descriptor
    os.write(1, b'&lt;chunk&gt;' + i + b'&lt;/chunk&gt;')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Many programs automatically turn off colour printing codes when they detect they are not connected directly to a terminal. Many programs will have a flag so you can force colour output. You could add this flag to your process call. For example:</p>
<pre><code>grep "search term" inputfile.txt 
# prints colour to the terminal in most OSes

grep "search term" inputfile.txt | less
# output goes to less rather than terminal, so colour is turned off 

grep "search term" inputfile.txt --color | less
# forces colour output even when not connected to terminal 
</code></pre>
<p>Be warned though. The actual colour output is done by the terminal. The terminal interprets special character espace codes and changes the text colour and background color accordingly. Without the terminal to interpret the colour codes you will just see the text in black with these escape codes interspersed throughout. </p>
</div>
<span class="comment-copy">I think the "coloring" is a function of the shell/tty. The colors are not part of the output of command. So you won't be able to retrieve anything else but this unformatted output.</span>
<span class="comment-copy">Hi EddyG, sometimes that's true, but you can send color formatting code to the terminal yourself. That's the case in this instance. I double checked the C source of the command itself and it does indeed send the color formatting code. So it's not just the tty.</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/25923901/4279">Last unbuffered line can't be read</a></span>
<span class="comment-copy">upvote. As far as I can tell, it is the only answer with a code example that actually works.</span>
<span class="comment-copy">you could use <a href="http://pexpect.readthedocs.org/en/latest/api/pexpect.html?highlight=runu#pexpect.runu" rel="nofollow noreferrer"><code>pexpect.runu()</code></a> if all you need is to get output as a string.</span>
<span class="comment-copy">@J.F. Sebastian, Nice. I just read the docs.  Would have saved some fumbling with that EOF constant.</span>
<span class="comment-copy">for subprocess-based code, you could use check_output with universal_newlines=True</span>
<span class="comment-copy">I was successful in my aims with this code. Thank you 7stud, and everyone else, for your valuable feedback, especially J. F. Sebastian and Antti Haapala. I have another issue now that is specific to pexpect.spawn, but I wil make another thread. This should work so long as my collaborator doesn't made the additional pexpect dependency. Thanks!</span>
<span class="comment-copy">You could use <code>os.fdopen</code> to open the master descriptor as a python file</span>
<span class="comment-copy">yes, <code>pty</code> may hoodwink the command into thinking that it is run interactively in a terminal (though if the program provides <code>--color</code> option such as <code>ls</code>; you could just pipe the output) 1. you should mention that <code>pty</code> is for Linux (it may also work on other *nices). You don't need to call <code>p.communicate()</code> if you use <code>stdout=slave</code> -- <code>p.wait()</code> is enough. You should probably read from <code>master</code> while the command is still running otherwise the program may hang forever after it fills up the corresponding output buffers, <a href="http://stackoverflow.com/a/20509641/4279">code example</a> &lt;- <code>pexpect</code></span>
<span class="comment-copy">Closing <code>slave</code> file descriptor before reading the output from <code>master</code> may lead to an I/O error (it shouldn't but it does). I had to <a href="http://stackoverflow.com/questions/12419198/python-subprocess-readlines-hangs/12471855#12471855">put <code>os.close(slave_fd)</code> after the <code>while 1</code> that reads the output to make the code work</a>. Also, <code>f.read()</code> might hang forever -- try it (I'm not completly sure it was long time ago).</span>
<span class="comment-copy">Hmm interesting. I was playing around with the <code>os.fdopen</code> suggestion but the <code>read</code> call hanged if I didn't close the slave first. It seems to work fine.. do you know what would make it fail?</span>
<span class="comment-copy">it is because the master never meets "EOF" while the slave is held open.</span>
<span class="comment-copy">1. it shouldn't work on Python 3, try <code>os.write(1, b'a')</code> instead. 2. On Linux if you close <code>slave</code> before the data is read, an exception may be raised. 3. Use <code>EnvironmentError</code> to catch both <code>IOError</code>, <code>OSError</code> (they are all the same on Python 3).</span>
<span class="comment-copy">fixed the 1; as for 2, the exception handling is there to catch the exception; and 3, I put them explicitly in the tuple so that one understands that the error is not specifically IOError <b>or</b> OSError.</span>
<span class="comment-copy">do you assert that the exception is <i>always</i> raised and all data is always read (assuming no other errors)? I don't understand the point in writing <code>(IOError, OSError)</code> instead of <code>EnvironmentError</code>.</span>
<span class="comment-copy">Fixed for the case of getting EOF as an empty string (for me the EOF always results in EIO).</span>
<span class="comment-copy">Python 2 raises OSError on EOF here. OSError is IOError (literally) on Python 3. What is the point of using both <code>(IOError, OSError)</code>? You should probably <a href="http://stackoverflow.com/a/12471855/4279">reraise non-EIO errors here</a>.</span>
<span class="comment-copy">Thanks Dunes, this is on the right track, but it is not quite enough. The app for this command in this case has a configuration file. Users can set the color to never, auto, or always. So I can't force the color myself, I have to try to just get the exact output that the un-piped command would give. If I force the color, then I'll override the users configuration if they happen to have never.</span>
<span class="comment-copy">@nullified: if you want to emulate <code>script</code> command, you could try <a href="http://stackoverflow.com/a/25945031/4279"><code>pty.spawn()</code> or <code>pexpect</code></a></span>
