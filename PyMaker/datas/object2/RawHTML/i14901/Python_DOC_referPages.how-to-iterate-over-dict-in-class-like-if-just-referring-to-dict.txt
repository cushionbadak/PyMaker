<div class="post-text" itemprop="text">
<p>In a defined object some values are kept in a <code>dict</code>, and I want to iterate over the contents in that <code>dict</code> as when referring to a plain <code>dict</code>, thus with directly access using <code>[]</code>, and loop using e.g. <code>.items()</code>.  Code structure is: </p>
<pre><code>class Klass:

    def __init__(self, values):
        self.values = values
        self.more = None

    def __getitem__(self, name):
        return self.values[name]

    def __iter__(self):
        pass  # TBD[How to make this ?]

d = {'alfa': 1, 'bravo': 2, 'charlie': 3}

k = Klass(d)

for key in k:
    print(key)  # Expected to print keys from self.values 

for (key, value) in k.items():
    print(key, value)  # Expected to print key and value from self.values 

for key in k.keys():
    print(key)  # Expected to print key from self.values 

for value in k.values():
    print(value)  # Expected to print value from self.values 
</code></pre>
<p>How to write the <code>__iter__</code> and, other required methods, so this kind of access is possible through an instance of Klass?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to implement the <code>.keys()</code>, <code>.values()</code> and <code>.items()</code> methods yourself; together with <code>__iter__</code> they can all delegate the actual work to the <code>self.values()</code> dictionary:</p>
<pre><code>class Klass:
    def __init__(self, values):
        self._values = values
        self.more = None

    def __getitem__(self, name):
        return self._values[name]

    def __iter__(self):
        return iter(self._values)

    def keys(self):
        return self._values.keys()

    def items(self):
        return self._values.items()

    def values(self):
        return self._values.values()
</code></pre>
<p>I renamed the attribute to avoid masking the <code>.values()</code> method.</p>
<p>The easiest way to delegate <code>__iter__</code> to iteration over the dictionary (by key) is to use the <a href="https://docs.python.org/3/library/functions.html#iter" rel="noreferrer"><code>iter()</code> function</a> to get an iterator for the dictionary object.</p>
<p>To be explicit: <code>__iter__</code> plays no role in how <code>.keys()</code>, <code>.values()</code> and <code>.items()</code> are handled; the latter are <em>just more methods</em>.</p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>    class Klass(dict):
        def __init__(self, *arg, **kw):
            super(Klass, self).__init__(*arg, **kw)
            self.choosebettername = super(Klass, self).keys()

        def __iter__(self):
            return iter(self.choosebettername)

        def keys(self):
            return self.choosebettername

        def itervalues(self):
            return (self[key] for key in self)


    d = {'alfa': 1, 'bravo': 2, 'charlie': 3}

    k = Klass(d)

    for key in k:
        print(key)  # Expected to print keys from self.values 

    for (key, value) in k.items():
        print(key, value)  # Expected to print key and value from self.values 

    for key in k.keys():
        print(key)  # Expected to print key from self.values 

    print(k.values())

    for value in k.values():
        print(value)  # Expected to print value from self.values 
</code></pre>
</div>
<span class="comment-copy"><code>for item in self.values: yield item</code>?</span>
<span class="comment-copy">The intention with OOP is to hide specific implementation, so direct reference to instance attribute <code>.values</code> should be avoided..</span>
<span class="comment-copy">@EquipDev: <b>within the implementation</b> you are still going to have to rely on your own state. <code>Torxed</code> was proposing a implementation for <code>__iter__</code>, making it a generator function. Not needed here, not with <code>iter()</code>, however.</span>
<span class="comment-copy">@MartijnPieters: Now I see; yes that adheres to OOP principles.  Thanks for pointing that out.</span>
<span class="comment-copy">Thanks for the help, and for renaming <code>values</code> to <code>_values</code>; it was a bad choice of name when having to implement the <code>values</code> method.</span>
<span class="comment-copy">There's no need to implement <code>.keys()</code> etc.  Just subclass from <code>collections.abc.Mapping</code>.</span>
<span class="comment-copy">@Kevin: yup, that's the next step. The fact that <code>collections.abc.Mapping</code> then implements those methods doesn't diminishes the fact that those methods need to be implemented.</span>
