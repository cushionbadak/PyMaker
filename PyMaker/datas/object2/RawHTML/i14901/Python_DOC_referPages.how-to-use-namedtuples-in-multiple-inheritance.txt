<div class="post-text" itemprop="text">
<p>Is it possible to create a class that inherits from multiple instances of <a href="https://docs.python.org/3/library/collections.html?highlight=namedtuple#collections.namedtuple" rel="nofollow"><code>namedtuple</code></a>, or create something to the same effect (having an immutable type that combines the fields of the base types)? I haven't found a way to do so. </p>
<p>This example illustrates the problem:</p>
<pre><code>&gt;&gt;&gt; class Test(namedtuple('One', 'foo'), namedtuple('Two', 'bar')):
&gt;&gt;&gt;    pass

&gt;&gt;&gt; t = Test(1, 2)
TypeError: __new__() takes 2 positional arguments but 3 were given

&gt;&gt;&gt; t = Test(1)
&gt;&gt;&gt; t.foo
1
&gt;&gt;&gt; t.bar
1
</code></pre>
<p>The problem seems to be that <code>namedtuple</code> does not use <code>super</code> to initialize its base class, as can be seen when creating one:</p>
<pre><code>&gt;&gt;&gt; namedtuple('Test', ('field'), verbose=True)
[...]    
class Test(tuple):
[...]
    def __new__(_cls, field,):
        'Create new instance of Test(field,)'
        return _tuple.__new__(_cls, (field,))
</code></pre>
<p>Even if I considered writing my own version of <code>namedtuple</code> to fix this, it is not obvious how to do that. If there are multiple instances of <code>namedtuple</code> in the MRO of a class they'd have to share a single instance of the base class <code>tuple</code>. To do that, they'd have to coordinate on which <code>namedtuple</code> uses which range of indices in the base tuple.</p>
<p>Is there any simpler way to achieve multiple inheritance with a <code>namedtuple</code> or something similar? Has anyone already implemented that somewhere?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a decorator or metaclass to combined the parent named tuple fields into a new named tuple and add it to the class <code>__bases__</code>:</p>
<pre><code>from collections import namedtuple

def merge_fields(cls):
    name = cls.__name__
    bases = cls.__bases__

    fields = []
    for c in bases:
        if not hasattr(c, '_fields'):
            continue
        fields.extend(f for f in c._fields if f not in fields)

    if len(fields) == 0:
        return cls

    combined_tuple = namedtuple('%sCombinedNamedTuple' % name, fields)
    return type(name, (combined_tuple,) + bases, dict(cls.__dict__))


class SomeParent(namedtuple('Two', 'bar')):

    def some_parent_meth(self):
        return 'method from SomeParent'


class SomeOtherParent(object):

    def __init__(self, *args, **kw):
        print 'called from SomeOtherParent.__init__ with', args, kw

    def some_other_parent_meth(self):
        return 'method from SomeOtherParent'


@merge_fields
class Test(namedtuple('One', 'foo'), SomeParent, SomeOtherParent):

    def some_method(self):
        return 'do something with %s' % (self,)


print Test.__bases__
# (
#   &lt;class '__main__.TestCombinedNamedTuple'&gt;, &lt;class '__main__.One'&gt;, 
#   &lt;class '__main__.SomeParent'&gt;, &lt;class '__main__.SomeOtherParent'&gt;
# )
t = Test(1, 2)  # called from SomeOtherParent.__init__ with (1, 2) {} 
print t  # Test(foo=1, bar=2)
print t.some_method()  # do something with Test(foo=1, bar=2)
print t.some_parent_meth()  # method from SomeParent
print t.some_other_parent_meth()  # method from SomeOtherParent
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code adopts a similar approach to Francis Colas', although it's somewhat longer :) </p>
<p>It's a factory function that takes any number of parent namedtuples, and creates a new namedtuple that has all the fields in the parents, in order, skipping any duplicate field names.</p>
<pre><code>from collections import namedtuple

def combined_namedtuple(typename, *parents):
    #Gather fields, in order, from parents, skipping dupes
    fields = []
    for t in parents:
        for f in t._fields:
            if f not in fields:
                fields.append(f)
    return namedtuple(typename, fields)

nt1 = namedtuple('One', ['foo', 'qux'])
nt2 = namedtuple('Two', ['bar', 'baz'])    

Combo = combined_namedtuple('Combo', nt1, nt2)    
ct = Combo(1, 2, 3, 4)
print ct
</code></pre>
<p><strong>output</strong></p>
<pre><code>Combo(foo=1, qux=2, bar=3, baz=4)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, if you just want a namedtuple with both the fields, it's easy to just recreate it:</p>
<pre><code>One = namedtuple('One', 'foo')
Two = namedtuple('Two', 'bar')
Test = namedtuple('Test', One._fields+Two._fields)
</code></pre>
</div>
<span class="comment-copy">How would you propose to resolve the ambiguity if the super classes contained a different number of fields or different field names?</span>
<span class="comment-copy">I don't understand the question. I'd expect everything to behave the same as it would with regular mutable classes, except that it would be immutable. The sub-class would have all the fields of all the base classes. Thus, the example above would be equivalent to <code>namedtuple(Test, ('foo', 'bar'))</code>.</span>
<span class="comment-copy">The issue is that since you don't define <code>Test.__init__</code>, only the <code>__init__</code> of the <i>first</i> base class is called, and that function only takes one (additional) argument.</span>
<span class="comment-copy">This looks promising. I'll have to look into it!</span>
<span class="comment-copy">@Bj√∂rnPollex Updated after reading some of your comment.</span>
<span class="comment-copy">That works for the example I have given, but the real situation is slightly more complicated. In my real use case I have a class that inherits directly and indirectly from <code>namedtuple</code>. Apparently I have oversimplified my example.</span>
<span class="comment-copy">Ok, can you rewrite a less minimal example? Because I don't know if composition wouldn't be a better approach in this case.</span>
