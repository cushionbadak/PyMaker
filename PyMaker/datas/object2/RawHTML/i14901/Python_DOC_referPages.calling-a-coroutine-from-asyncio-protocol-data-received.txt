<div class="post-text" itemprop="text">
<p>This is similar to <a href="https://stackoverflow.com/questions/20746619/calling-coroutines-in-asyncio-protocol-data-received">Calling coroutines in asyncio.Protocol.data_received</a> but I think it warrants a new question.</p>
<p>I have a simple server set up like this</p>
<pre><code>loop.create_unix_server(lambda: protocol, path=serverSocket)
</code></pre>
<p>It works fine, if I do this</p>
<pre><code> def data_received(self, data):
    data = b'data reply'
    self.send(data)
</code></pre>
<p>my client gets the reply. But I can't get it to work with any sort of <code>asyncio</code> call. I tried all of the following and none of them worked.</p>
<pre><code>@asyncio.coroutine
def go(self):
    yield from asyncio.sleep(1, result = b'data reply')

def data_received(self, data):
    print('Data Received', flush=True)

    task = asyncio.get_event_loop().create_task(self.go())
    data = yield from asyncio.wait_for(task,10)
    self.send(data)
</code></pre>
<p>that one hung and printed nothing (if I decorated <code>data_received</code> with <code>@asyncio.coroutine</code> I get that that is not yielded from) OK, I get that using yield in <code>data_received</code> isn't right.</p>
<p>If I try a new event loop, as below, that hangs in <code>run_until_complete</code></p>
<pre><code>    loop = asyncio.new_event_loop()
    task = loop.create_task(self.go())
    loop.run_until_complete(task)
    data = task.result()
    self.send(data)
</code></pre>
<p>If I use a <code>Future</code>, that also hangs in <code>run_until_complete</code></p>
<pre><code>@asyncio.coroutine
def go(self, future):
    yield from asyncio.sleep(1)
    future.set_result(b'data reply')

def data_received(self, data):
    print('Data Received', flush=True)

    loop = asyncio.new_event_loop()
    future = asyncio.Future(loop=loop)
    asyncio.async(self.go(future))
    loop.run_until_complete(future)
    data = future.result()
    self.send(data)
</code></pre>
<p>The following gets close, but it returns immediately and the result is of type <code>asyncio.coroutines.CoroWrapper</code>, implying that the <code>wait_for</code> line returned immediately with the unfinished task?</p>
<pre><code>@asyncio.coroutine
def go(self):
    return(yield from asyncio.sleep(3, result = b'data reply'))

@asyncio.coroutine
def go2(self):
    task = asyncio.get_event_loop().create_task(self.go())
    res = yield from asyncio.wait_for(task, 10)
    return result

def data_received(self, data):
    print('Data Received', flush=True)

    data = self.go2()
    self.send(data)
</code></pre>
<p>I'm a bit stuck really, and would appreciate some pointers about what to look at.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to add your coroutine to the event loop, and then use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future.add_done_callback"><code>Future.add_done_callback</code></a> to handle the result when the coroutine completes:</p>
<pre><code>@asyncio.coroutine
def go(self):
    return(yield from asyncio.sleep(3, result = b'data reply'))

def data_received(self, data):
    print('Data Received', flush=True)

    task = asyncio.async(self.go()) # or asyncio.get_event_loop().create_task()
    task.add_done_callback(self.handle_go_result)

def handle_go_result(self, task):
    data = task.result()
    self.send(data)
</code></pre>
<p>Calling a coroutine directly in <code>data_received</code> just simply isn't allowed, since the caller isn't going to try to <code>yield from</code> it, and creating/running a new event loop inside of <code>data_received</code> will always end up blocking the main event loop until the inner event loop finishes its work.</p>
<p>You just want to schedule some work with your main event loop (<code>asyncio.async</code>/<code>loop.create_task()</code>), and schedule a callback to run when the work is done (<code>add_done_callback</code>).</p>
</div>
<span class="comment-copy">Hi, thanks for that reply - that does work in my code. I'm just integrating it in to my non-trivial code (that has a calling stack etc) I had thought about using callbacks, but I thought that yielding/tasks/futures were the more recent approach, and had the benefit of not worrying about your calling stack or how to get data into your callback. Do you know why the inner loop wouldn't finish its work? Or why the future approach wouldn't work with the main loop?</span>
<span class="comment-copy">Oh, I guess the inner loop is waiting on the blocked outer one to do some IO etc.</span>
<span class="comment-copy">@Dave <code>asyncio</code> definitely prefers a coroutine-style approach for higher-level usage, but low-level features like Protocols still use the callback style. If you want to use coroutines instead, the <a href="https://docs.python.org/3/library/asyncio-protocol.html#coroutines-and-protocols" rel="nofollow noreferrer">docs recommend</a> using stream objects instead of protocols.</span>
<span class="comment-copy">OK, that makes sense. Many thanks for your help</span>
