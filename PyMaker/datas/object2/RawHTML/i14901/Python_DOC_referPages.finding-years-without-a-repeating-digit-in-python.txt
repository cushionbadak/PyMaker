<div class="post-text" itemprop="text">
<p>I'm trying to find the 5 most recent years without repeating digits, and I keep getting the error <code>'int' object has no attribute '__getitem__'</code> </p>
<p>This is my code and I so far -I can't figure out what's wrong with it. Any explanation as to how to fix it is appreciated.</p>
<pre><code>def find_year():
    start = 2015
    years = []
    while len(years) &lt; 5:
        if start[0] == start[1]:
            return False
        elif start[0] == start[2]:
            return False
        elif start[0] == start[3]:
            return False
        elif start[1] == start[2]:
            return False
        elif start[1] == start[3]:
            return False
        elif start[2] == start[3]:
            return False
        else:
            years.append(start)
            start -= 1
     else:
          print years

 find_year()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are assuming that you can index (<code>[]</code>) an integer to get a digit out of it but that's not something you can do with integers in Python. What you <em>can</em> do is convert an integer into a string, and then you can index the string to get characters out of it:</p>
<pre><code>&gt;&gt;&gt; year = 2015
&gt;&gt;&gt; year_as_string = str(year)
&gt;&gt;&gt; year_as_string[0]
'2'
</code></pre>
<p>The reason the error message mentions an attribute <code>__getitem__</code> is because <code>year[0]</code> basically expands to <code>year.__getitem__(0)</code>. <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow">Info on <code>__getitem__</code></a>.</p>
<p>Also I'd advise tackling this in smaller segments. Rather than trying to solve the whole problem at once, start by writing a function that takes <em>one</em> year and will return <code>True</code> if it doesn't have any repeating digits and <code>False</code> otherwise. Then when you've got that working you can write another function calling the first function in a loop to get the five results you need.</p>
<p>There are a couple of nice ways to solve the complete problem:</p>
<p>List comprehension:</p>
<pre><code>&gt;&gt;&gt; [y for y in range(2015, 0, -1) if len(set(str(y))) == 4][0:5]
[2015, 2014, 2013, 1987, 1986]
</code></pre>
<p>Iterator:</p>
<pre><code>from itertools import islice
&gt;&gt;&gt; list(islice(filter(lambda y: len(set(str(y))) == 4, range(2015, 0, -1)), 5))
[2015, 2014, 2013, 1987, 1986]
</code></pre>
<p>The list comprehension is simpler but does a lot more work (it will try all the years in the range, only to throw out all but the first five); the iterator version is not as straightforward but (in Python 3) only does as much work as it needs to.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a one-liner with a list comprehension:</p>
<pre><code>[year for year in range(2015, 1915, -1) if len(set(str(year)))==4] [0:5]

[2015, 2014, 2013, 1987, 1986]
</code></pre>
<p>You can test for no repeated digit with <code>len(set(str(year)))==4</code>.
And <code>range(2015, 1915, -1)</code> bounds the number of years we need to test.
Then we just slice the result with [0:5] to take the first five such years (in decreasing order from 2015).</p>
</div>
<div class="post-text" itemprop="text">
<p>This may work, try it:</p>
<pre><code>    &gt;&gt; from collections import Counter

    &gt;&gt; year = 2015
    &gt;&gt; list = map(int, str(year))
    &gt;&gt; counts = Counter(list)
    &gt;&gt; counts
      Counter({0: 1, 1: 1, 2: 1, 5: 1})
    &gt;&gt;Counter(list).values()
     [1,1,1,1]
</code></pre>
<p>The last method will count the occurrence of each digits in the year. This should be more efficient.
Now if you want to know if there is a repeated digit, use this <a href="https://stackoverflow.com/a/7281797/553029">post</a></p>
<pre><code>&gt;&gt; import bisect

&gt;&gt; bisect.bisect(Counter(list).values(), 1)
4
</code></pre>
<p>Any value under 4 means there is a digit that has more than one occurrence.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you can't access the digits of an integer using <code>[]</code> indexing notation. An easy way to do that to convert it into a sequence of digits, and an easy way to check for duplicates is by converting that sequence into a <code>set</code> and checking whether the length of the set is the same a the number of digits, it won't be if there are any duplicates â€” see this <a href="https://stackoverflow.com/a/11249874/355230">answer</a> to another related question.</p>
<p>The code below does this looking both at prior and future years from the starting year. It also checks the starting year, but it's not clear from your question if it should do this or not.</p>
<pre><code>def has_dup_digits(year):
    """ Check if integer year has any repeated digits.
    """
    digits = str(year)
    return len(digits) != len(set(digits))

def find_years(start_year):
    """ Find the 5 years closest to the starting year without repeated digits.
    """
    years = []
    if not has_dup_digits(start_year): # check start year
        years.append(start_year)
    delta = 1
    while len(years) &lt; 5:
        if not has_dup_digits(start_year+delta):
            years.append(start_year+delta)
        if len(years) &gt;= 5:
            break
        if not has_dup_digits(start_year-delta):
            years.append(start_year-delta)
        delta += 1

    print(sorted(years))

find_years(2015)  # --&gt; [2013, 2014, 2015, 2016, 2017]
</code></pre>
</div>
<span class="comment-copy">When you have a collection of N items and want to test they're all different, then instead of making N(N-1)/2 unnecessary equality tests, just assign them to a set/dict/tuple/list and test its length is == N. dict/set is your friend, it has O(1) lookup time, as opposed to O(n) for list/tuple or O(log2 N) for binary-tree.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/11194110/int-object-has-no-attribute-getitem">'int' object has no attribute '__getitem__'</a></span>
<span class="comment-copy">This correctly diagnoses the issue with the OP's code.</span>
<span class="comment-copy">I suspect the desired output is actually: <code>[2015, 2014, 2013, 1987, 1986]</code>...</span>
<span class="comment-copy">Doh, it needed len( <b>set</b> (str(year)))==4 . Thanks</span>
<span class="comment-copy">Umm... <code>collections.Counter</code> seems overkill here - just run the digits through a <code>set</code> and check it's the same length as the input. <code>year = 2015; str_year = str(year); if len(str_year) == len(set(str_year)) # no repeated digits</code></span>
