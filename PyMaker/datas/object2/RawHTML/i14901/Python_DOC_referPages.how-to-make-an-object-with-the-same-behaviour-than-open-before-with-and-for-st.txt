<div class="post-text" itemprop="text">
<p>I would like to create a class in Python that receive a filename, and return an object that can be handled by a context manager and iterable by a for-loop.</p>
<p>Basicly, the file will be parsed line by line (iterable). The class will split each line into a defined pattern and will return at each step of iteration a tuple of values.</p>
<p>I know that I need to implement <code>__iter__</code>, <code>__next__</code> methods to make it iterable but I do not clearly understand how to proceed. The file is one of my class attribute, and I want the iterator to yield parsed line at each iteration.</p>
<p>I also know that I need to implement <code>__enter__</code> and <code>__exit__</code> methods, but this also is a little bit fuzzy to me.</p>
<pre><code>class myfile:
    def __init__(self,file,**kwargs):
        self._file = open(file,'r')

    def __del__(self):
        self._file.close()

    def __enter__(self):
        # Not sure what am I supposed to return here

    def __exit__(self):
        self._file.close()

    def __iter__(self):
        # What iterator must be returned

    def __next__(self):
        return parseLine(x)

    def parseLine(self,line):
        #Stuff:
        return *values
</code></pre>
<p>I am not looking for an out-of-the box code, rather I would like to understand what each of those magic methods exactly needs to properly works in order to get the desired behaviour.</p>
<p><strong>Update:</strong></p>
<p>I finally resolved to do it in the following way:</p>
<pre><code>class myfile:
    def __init__(self,file,**kwargs):
        self._file = open(file,'r')

    def __del__(self):
        self._file.close()

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self._file.close()

    def __iter__(self):
        for fline in self._file:
            yield self.parseLine(fline)

    def parseLine(self,line):
        # Stuff
        return *values
</code></pre>
<p>It seems to have the behaviour I am looking for. It works when I perform:</p>
<pre><code>with myfile(r'x.txt') as pf:
    for i in pf:
        print(i)
</code></pre>
<p>Is this a good way to achieve it? Is it pythonic enough?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just return <code>self</code> in both cases.</p>
<p>Your class is itself the iterator (since you are providing a <code>__next__</code> method), and if you don't have a special value for <code>__enter__</code> to return you generally just return <code>self</code>.</p>
<p>In fact, that's exactly what a file object does for both cases:</p>
<pre><code>&gt;&gt;&gt; fobj = open('/dev/null')
&gt;&gt;&gt; fobj.__enter__() is fobj
True
&gt;&gt;&gt; fobj.__iter__() is fobj
True
</code></pre>
<p>For <code>__iter__</code> you'd return a different object if you wanted to support independent iteration over the object; that new object would then return <code>self</code> for <code>__iter__</code> and provide the <code>__next__</code> method rather than this class.</p>
<p>For <code>__enter__</code> you'd return whatever was convenient for the user to bind to in a <code>with</code> statement. For example, some database connection objects return a new cursor object, so that you can do:</p>
<pre><code>with conn as cursor:
    # handle a transaction, using the already produced cursor
</code></pre>
<p>Note that your updated version returns a <em>generator</em> from <code>__iter__</code>, which is a <em>new</em> iterator each time you call <code>iter(myfile('...'))</code>. These iterators are not really independent as <code>iter(fileobj)</code> will always return the file object itself, so iterating over one generator will affect the other generators as the file position advances.</p>
<p>Moreover, since file objects are their own iterator, you can use the <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow"><code>next()</code> function</a> directly on a file object, but you cannot do the same on your object.</p>
<p>A better solution is to stick to returning <code>self</code> and make your <code>__next__</code> method do the parsing:</p>
<pre><code>def __iter__(self):
    return self

def __next__(self):
    return self.parseLine(next(self._file))
</code></pre>
</div>
<span class="comment-copy">Thanks for answering, could you check out if the update I have made is correct</span>
<span class="comment-copy">@jlandercy: kind-of; your <code>__iter__</code> now returns a new generator (a type of iterator) each time it is called; this means you now can create separate iterators for the file object. In this case that's okay, as the file object itself still will only return <code>self</code>, and the independent iterators are not really independent.</span>
<span class="comment-copy">@jlandercy: that is probably fine; but you could also use <code>def __next__(self): return self.parseLine(next(self._file))</code> instead of creating a generator.</span>
<span class="comment-copy">@jlandercy: the downside of your approach is that <code>next(yourobject)</code> won't work, while <code>next(fileobj)</code> <i>does</i> work.</span>
