<div class="post-text" itemprop="text">
<p>I want to create an <code>Attribute</code> class so I can do stuff like:</p>
<pre><code>class Creature:
    def __init__(self, health=100, armor=0):
        self.health = Attribute(health)
        self.armor = Attribute(armor)
</code></pre>
<p>Now when I do</p>
<pre><code>c1 = Creature()
c1.health += 10
</code></pre>
<p>It actually doesn't change the real value, but it keeps <code>health</code>'s <em>base</em> value at 100, while giving it an adjustment of +10.</p>
<p>Here's what I tried, but it works using <code>healt.get()</code> and <code>health.set()</code> which is not wanted:</p>
<pre><code>class Attribute:
    def __init__(self, base=0, adjustments=None):
        self._base = base
        self._adjustments = adjustments or []

    def set(self, value):
        difference = value - self._base
        if difference:
            self._adjustments.append(difference)

    def get(self):
        return self._base + sum(self._adjustments)

c1 = Creature(50)
c1.health.set(60)  # Adds +10 adjustment
</code></pre>
<p>But I  want to be able to do this:</p>
<pre><code>c1 = Creature(50)
c1.health = 60
# Or just:
c1.health += 10
</code></pre>
<p>Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Below are four approaches that might meet your needs.</p>
<hr/>
<h2>Descriptors</h2>
<p><a href="https://docs.python.org/2/reference/datamodel.html#implementing-descriptors" rel="nofollow">Descriptors</a> allow you to provide direct attribute access while hiding the underlying implementation.</p>
<pre><code>class AttributeDescriptor(object):
    def __init__(self):
        self.initialized = False
        self.base = 0
        self.adjustments = []

    def compute(self):
        return self.base + sum(self.adjustments)

    def __set__(self, inst, value):
        if not self.initialized:
            self.base = value
            self.initialized = True
            print("Attribute initialized to %s" % value)
        else:
            # Calculate delta
            delta = (value - self.compute())
            self.adjustments.append(delta)
            print("Adjustment added: %s" % delta)

    def __get__(self, inst, owner):
        return self.compute()

class Creature(object):
    health = AttributeDescriptor()
    armor  = AttributeDescriptor()

    def __init__(self, health=100, armor=0):
        self.health = health
        self.armor  = armor


c1 = Creature(50)
c1.health = 60      # Adds a +10 adjustment
print c1.health     # 60
c1.health += 10     # Add a +10 adjustment
print c1.health     # 70
#print c1.health.adjustments     # This won't work ('int' object has no attribute 'adjustments')
</code></pre>
<p>Output:</p>
<pre>
Attribute initialized to 50
Attribute initialized to 0
Adjustment added: 10
60
Adjustment added: 10
70
</pre>
<p>The problem with this approach is that you have no easy way to access the internals of the descriptor.  So in this case, you can't ever inspect the <code>adjustments</code> list.  You can, however, directly assign <code>c1.health = X</code> to it as if it were a normal attribute.</p>
<p><strong>Note:</strong> As noted by Veedrac in the comments, these attributes are defined at the class level and <em>will be shared between all instances</em> of the <code>Creature</code> class.  For this reason alone it's not a solution whatsoever, but it wasn't a great solution in any case.</p>
<h2>Normal Tracker Objects</h2>
<p>You can use a class that implements the "<a href="http://legacy.python.org/dev/peps/pep-0203/" rel="nofollow">augmented assignment</a>" magic methods <code>__iadd__()</code> and <code>__isub__()</code></p>
<pre><code>class AttributeObject(object):
    def __init__(self, base):
        self.base = base
        self.adjustments = []
        print("Attribute initialized to %s" % base)

    def __compute(self):
        return self.base + sum(self.adjustments)

    def __int__(self):
        return self.__compute()

    def __iadd__(self, delta):
        print("Adjustment added: %s" % delta)
        self.adjustments.append(delta)
        return self

    def __isub__(self, delta):
        print("Adjustment added: %s" % -delta)
        self.adjustments.append(-delta)
        return self

class Creature(object):
    def __init__(self, health=100, armor=0):
        self.health = AttributeObject(health)
        self.armor =  AttributeObject(armor)


c1 = Creature(50)
#c1.health = 60         # Can't do this, because it will override the AttributeObject
print int(c1.health)    # 60
c1.health += 10         # Add a +10 adjustment
print int(c1.health)    # 70
print c1.health.adjustments  # [10]
</code></pre>
<p>Output:</p>
<pre>
Attribute initialized to 50
Attribute initialized to 0
50
Adjustment added: 10
60
[10]
</pre>
<p>The problem with this approach is that you can't directly assign to the attribute without overriding it.  In other words, <code>c1.health = X</code> will override the value of the <code>health</code> attribute to be equal to X -- you lose whatever was there previously.</p>
<p>But with this approach, you <em>can</em> access the <code>adjustments</code> list:  <code>print c1.health.adjustments</code></p>
<p>Note that <code>c1.health</code> is an instance of <code>AdjustmentTracker</code>, not a numeric type like you may expect (try <code>print c1.health</code>).  You have a number of ways to access/extract the numeric value, in the example I use the <code>int(c1.health)</code> type conversion (possible since I implemented <code>__int__</code>).</p>
<h2>Descriptor + Tracker Object</h2>
<p>Using a combination of the two above methods, you can use all of the syntax you listed.</p>
<pre><code>class AttributeDescriptor(object):
    def __init__(self, attr):
        self.attr = attr

    def __set__(self, inst, value):
        getattr(inst, self.attr).update(value)

    def __get__(self, inst, owner):
        return getattr(inst, self.attr).compute()


class AdjustmentTracker(object):
    def __init__(self, base):
        print("Attribute initialized to %s" % base)
        self.base = base
        self.adjustments = []

    def compute(self):
        return self.base + sum(self.adjustments)

    def update(self, value):
        delta = (value - self.compute())
        print("Adjustment added: %s" % delta)
        self.adjustments.append(delta)


class Creature(object):
    health = AttributeDescriptor('_health')
    armor  = AttributeDescriptor('_armor')

    def __init__(self, health=100, armor=0):
        self._health = AdjustmentTracker(health)
        self._armor =  AdjustmentTracker(armor)


c1 = Creature(50)
c1.health = 60      # Adds a +10 adjustment
print c1.health     # 60
c1.health += 10     # Add a +10 adjustment
print c1.health     # 70
print c1._health.adjustments     # [10, 10]
</code></pre>
<p>Output:</p>
<pre>
Attribute initialized to 50
Attribute initialized to 0
Adjustment added: 10
60
Adjustment added: 10
70
[10, 10]
</pre>
<p>Here, the descriptors aren't keeping track of the base and adjustment list themselves, rather you're using them as a proxy to interface with <code>AdjustmentTracker</code> obejcts.  With this you can do both direct assignment (e.g. <code>c1.health = 60</code>) <em>and</em> access the underlying initial base / adjustments (e.g. <code>c1._health.adjustments</code>).</p>
<h2>Properties + Tracker Objects</h2>
<p>Just as in the previous example, we use <code>AdjustmentTracker</code> objects to hold the state of the attributes.  But in this example, instead of using an explicit descriptors, you can use <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow">properties</a> to shield the attribute.</p>
<pre><code>class AdjustmentTracker(object):
    def __init__(self, base):
        print("Attribute initialized to %s" % base)
        self.base = base
        self.adjustments = []

    def compute(self):
        return self.base + sum(self.adjustments)

    def update(self, value):
        delta = (value - self.compute())
        print("Adjustment added: %s" % delta)
        self.adjustments.append(delta)


class Creature(object):
    @property
    def health(self):         return self._health.compute()
    @health.setter
    def health(self, value):  self._health.update(value)

    @property
    def armor(self):          return self._armor.compute()
    @armor.setter
    def armor(self, value):   self._armor.update(value)

    def __init__(self, health=100, armor=0):
        self._health = AdjustmentTracker(health)
        self._armor =  AdjustmentTracker(armor)


c1 = Creature(50)
c1.health = 60      # Adds a +10 adjustment
print c1.health     # 60
c1.health += 10     # Add a +10 adjustment
print c1.health     # 70
print c1._health.adjustments     # [10, 10]
</code></pre>
<p>Output:</p>
<pre>
Attribute initialized to 50
Attribute initialized to 0
Adjustment added: 10
60
Adjustment added: 10
70
[10, 10]
</pre>
<p>This example is basically the same as the previous one, just less lines of code since it makes use of properties, and functions exactly the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check out properties
<a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow">https://docs.python.org/3/library/functions.html#property</a></p>
<p>In the example below a property is being used as a decorator.</p>
<pre><code>class Creature:
    def __init__(self, health):
        self._base_health = health
        self._modifications = []
    @property
    def health(self):
        return self._base_health + sum(self._modifications)
    @health.setter
    def health(self, value):
        self._modifications.append(value - self._base_health - sum(self._modifications))
</code></pre>
<p>Every time the health attribute is retrieved the getter function (the function marked with the <code>property</code> decorator) is called. Similarly when the health attribute is set the setter function (the function marked with the <code>health.setter</code> decorator) is called.</p>
<pre><code>c1 = Creature(50)
c1.health = 60
c1.health += 10
print(c1.health)
c1.health = 40
print(c1.health)
</code></pre>
<p>outputs</p>
<pre><code>70
40
</code></pre>
</div>
<span class="comment-copy">I think you want a combinations of <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow noreferrer">properties</a> and <code>__iadd__()</code></span>
<span class="comment-copy">@Alex's answer is right and the simplest one. But if you have to use classes for property, you can use Meta classes. That's how Django models work. eg <code>country = models.TextField(max_length=5, default='US').</code> You can see you can add additional meta information and abstract out the usual validations into another classes. You can now use the property like a normal property: <code>obj.country = 'ENG'.</code> When I am back to work, I will post sample code on how to do that.</span>
<span class="comment-copy">This is very likely a bad idea. Pretending to be an integer but acting like something else entirely is extremely confusing.</span>
<span class="comment-copy">The first example stores the value at class-level, so all <code>Creature</code>s share the same health and armor.</span>
<span class="comment-copy">@Veedrac, you're right -- let me see if I can fix this.</span>
<span class="comment-copy">@Veedrac, I "fixed" it -- what an ugly solution.</span>
<span class="comment-copy">I'm pretty sure that'll memory leak.</span>
<span class="comment-copy">It shouldn't keep <code>Creature</code> elements alive since it's just a hash, but it will never free information about collected instances.  I rolled back the edit and noted your concern.  If I can figure out a nice way to handle this I'll edit it in.</span>
