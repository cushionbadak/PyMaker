<div class="post-text" itemprop="text">
<p>I recently had following code in mind and wondered what was wrong with it. Previously I used the .get method of dictionaries with success, but now i wanted to pass arguments too and this is where i noticed a somewhat weird behavior:</p>
<pre><code>def string_encoder(nmstr):
    return nmstr.encode('UTF-8')

def int_adder(nr_int):
    return int(nr_int) + int(nr_int)

def selector(fun, val):
    return {'str_en': string_encoder(val), 
            'nr_add': int_adder(val)}.get(fun, string_encoder(val))
selector('str_en', 'Test') -&gt; ValueError
selector('str_en', 1) -&gt; AttributeError
</code></pre>
<p>The above code will never run.
To inspect the issue i supplied a small piece of code:</p>
<pre><code>def p1(pstr):
    print('p1: ', pstr)
    return pstr

def p2(pstr):
    print('p2: ', pstr)
    return pstr

def selector_2(fun, val):
    return {'p1': p1(val), 
            'p2': p2(val)}.get(fun, p2(val))
selector_2('p1', 'Test')
Out[]: p1:  Test
       p2:  Test
       p2:  Test
       'Test'
</code></pre>
<p>I would expect the following .get('p1', 'test') to output 'p1: test' test. 
But as it appears to me, every argument is evaluated, even if it is not selected. So my question is: Why is every argument evaluated with the .get method, or how can this behavior be explained? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>dict</code> creation is eager, as is argument evaluation. So before <code>get</code> even runs, you've called <code>string_encoder</code> twice, and <code>int_adder</code> once (and since the behaviors are largely orthogonal, you'll get an error for anything but a numeric <code>str</code> like <code>"123"</code>).</p>
<p>You need to avoid calling the function until you know which one to call (and ideally, only call that function once).</p>
<p>The simplest solution is to have the <code>dict</code> and <code>get</code> call contain the functions themselves, rather than the result of calling them; you'll end up with whichever function wins, and you can then call that function. For example:</p>
<pre><code>def selector(fun, val):
    # Removed (val) from all mentions of functions
    return {'str_en': string_encoder, 
            'nr_add': int_adder}.get(fun, string_encoder)(val) # &lt;- But used it to call resulting function
</code></pre>
<p>Given <code>string_encoder</code> is your default, you could remove <code>'str_en'</code> handling entirely to simplify to:</p>
<pre><code>    return {'nr_add': int_adder}.get(fun, string_encoder)(val)
</code></pre>
<p>which leads to the realization that you're not really getting anything out of the <code>dict</code>. <code>dict</code>s have cheap lookup, but you're rebuilding the <code>dict</code> every call, so you didn't save a thing. Given that you really only have two behaviors:</p>
<ol>
<li>Call <code>int_adder</code> if <code>fun</code> is <code>'nr_add'</code></li>
<li>Otherwise, call <code>string_encoder</code></li>
</ol>
<p>the correct solution is just an <code>if</code> check which is <em>more</em> efficient, and easier to read:</p>
<pre><code>def selector(fun, val):
    if fun == 'nr_add':
        return int_adder(val)
    return string_encoder(val)

    # Or if you love one-liners:
    return int_adder(val) if fun == 'nr_add' else string_encoder(val)
</code></pre>
<p>If your real code has a lot of entries in the <code>dict</code>, not just two, one of which is unnecessary, then you <em>can</em> use a <code>dict</code> for performance, but build it once at global scope and reference it in the function so you're not rebuilding it every call (which loses all performance benefits of <code>dict</code>), e.g.:</p>
<pre><code># Built only once at global scope
_selector_lookup_table = {
    'str_en': string_encoder, 
    'nr_add': int_adder,
    'foo': some_other_func,
    ...
    'baz': yet_another_func,
    }

def selector(fun, val):
    # Reused in function for each call
    return _selector_lookup_table.get(fun, default_func)(val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid evaluation of functions and only <em>chooses</em> the function, do this instead for your second block (the syntax will also work for your first block):</p>
<pre><code>def selector_2(fun, val):
    return {'p1': p1, 
            'p2': p2}.get(fun)(val)
</code></pre>
</div>
<span class="comment-copy">That's how <i>all</i> functions work. Arguments are always evaluated before being passed to the function. <code>get</code> is not special in that respect.</span>
<span class="comment-copy">yes, now i somehow see the somehow dumb question. as the dict value is a function call which will always be called by the get function...duh</span>
<span class="comment-copy">"If your real code has a lot of entries in the dict, not just two, one of which is unnecessary, then you can use a dict for performance" -&gt; yes this is my application scenario. As I wanted to make a "select" like operator. Thank you for hinting at the performance issue which arises by always creating a dictionary by calling the selector function.</span>
