<div class="post-text" itemprop="text">
<p>With four dictionaries <code>grandpa</code>, <code>dad</code>, <code>son_1</code> and <code>son_2</code>:</p>
<pre><code>grandpa = {'name': 'grandpa', 'parents': []}
dad = {'name': 'dad', 'parents': ['grandpa']}
son_1 = {'name': 'son_1', 'parents': ['dad']}
son_2 = {'name': 'son_2', 'parents': ['dad']}
relatives = [son_1, grandpa, dad, son_2]
</code></pre>
<p>I want to write a function that sorts all these relatives in a "reverse" order.
So instead of <code>parents</code> there would be <code>children</code> list used. The oldest <code>grandpa</code> would be on the top level of <code>result</code> dictionary, the <code>dad</code> would be below with its <code>children</code> list storing the <code>son_1</code> and <code>son_2</code>:</p>
<pre><code>def sortRelatives(relatives):
    # returns a resulted dictionary:
    # logic


result = sortRelatives(relatives)
print result 
</code></pre>
<p>Which would print:</p>
<pre><code>result = {'name': 'grandpa', 
            'children': [
                        {'name': 'dad', 
                        'children': [{'name': 'son_1', 'children': [] },
                                     {'name': 'son_2', 'children': [] }] }
                        ]

        }
</code></pre>
<p>How to make <code>sortRelatives</code> function perform a such sorting?</p>
</div>
<div class="post-text" itemprop="text">
<p>What I think is a viable yet simple solution is to first build a children dictionary that will map person names to their children. Then we can use that new data structure to build the output: </p>
<pre class="lang-py prettyprint-override"><code>from collections import defaultdict

def children(relatives):
    children = defaultdict(list)
    for person in relatives:
        for parent in person['parents']:
            children[parent].append(person)
    return children
</code></pre>
<p>Another tool we can use is a function that would find the root of our genealogy: </p>
<pre class="lang-py prettyprint-override"><code>def genealogy_root(relatives):
    for person in relatives:
        if not person['parents']:
            return person
    raise TypeError("This doesn't look like a valid genealogy.")
</code></pre>
<p>That will help us locating the person that has no parent, and will therefore be the root of our genealogy-tree. Now that we have all the necessary tools we just need to build the output:</p>
<pre class="lang-py prettyprint-override"><code>def build_genealogy(relatives):
    relatives_children = children(relatives)

    def sub_genealogy(current_person):
        name = current_person['name']
        return dict(
            name=name,
            children=[sub_genealogy(child) for child in relatives_children[name]] 
        )

    root = genealogy_root(relatives)
    return sub_genealogy(root)

result = build_genealogy(relatives)
print(result)
</code></pre>
<p>Which outputs:</p>
<pre><code>{
  'name': 'grandpa', 'children': [
     {'name': 'dad', 'children': [
         {'name': 'son_1', 'children': []}, 
         {'name': 'son_2', 'children': []}
     ]}
  ]
}
</code></pre>
<p>Note that as I said in the comments, this is only working because there are no name duplicates. If several persons share the same name, you will have to have a better data-structure as input. For example, you may want to have something like:</p>
<pre class="lang-py prettyprint-override"><code>grandpa = {'name': 'grandpa', 'parents': []}
dad = {'name': 'dad', 'parents': [grandpa]}
son_1 = {'name': 'son_1', 'parents': [dad]}
son_2 = {'name': 'son_2', 'parents': [dad]}
relatives = [grandpa, dad, son_1, son_2]
</code></pre>
</div>
<span class="comment-copy"><code>The oldest grandpa would be on the top level of result dictionary</code> What is the field you're sorting on? For example, age is not included in your dictionary.</span>
<span class="comment-copy">@ScottSkiles The one with empty <code>'parents'</code> I presume</span>
<span class="comment-copy">I this example names are unique and there is only one parent. Is this a reasonable assumption to make or is your actual data very different from what you shared here?</span>
<span class="comment-copy">I think the question needs significant clarification... (I did not downvote, however)</span>
<span class="comment-copy">This is not called sorting. It's a kind of lookup or mapping. I don't understand why it needs to be recursive? Where does that requirement come from? Is it homework?</span>
