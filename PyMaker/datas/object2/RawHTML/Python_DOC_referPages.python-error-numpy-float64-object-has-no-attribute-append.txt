<div class="post-text" itemprop="text">
<p>I am trying to run a simulation in which I do the following:</p>
<ol>
<li>Take 2000 random samples from a uniform distribution between 0 and 1</li>
<li>Calculate the difference, du, between any sample and the one chosen before it</li>
<li>Use that difference to calculate r=EXP(-a*du)</li>
<li>Compare another random sample z to the calculated value of r</li>
<li>Create a list of the random samples for which r&gt;z, and discard all others</li>
<li>Repeat this process until 2000 samples have been "accepted"</li>
</ol>
<p>Here is what I have thus far. When I run this code, I receive the error message "'numpy.float64' object has no attribute 'append'". Any ideas on how to fix this issue?</p>
<pre><code>import numpy as np                                                          
import matplotlib.pyplot as plt                                             
import math                                                                 

NP=np.random.uniform(0,1,size=(2000,))                                      
a=np.linspace(0.1,2,num=20)                                                 

for i in range(len(a)):                                                     
    dr = []                                                                 
    du = []                                                                 
    for j in range(1999):                                                   
        du=N[j+1]-N[j]                                                      
        r=math.exp(-a[i]*du)                                                
        z=np.random.uniform(0,1)                                            
        if r&gt;z:                                                             
            du.append(N[j+1])                                               
            dr.append(r)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are using the same variable name, <code>du</code>, for two distinct concepts (the container for all the valid <code>du</code> values, and each individual <code>du</code> value per iteration).</p>
<p>Change your code to <code>du_values = []</code> and <code>du_values.append(N[j + 1])</code> and it should work.</p>
<p>As an aside, there appears to be a typo in your code - you define the original array as <code>NP</code>, but later refer to it as <code>N</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that since you did not provide any code, the code I am going to show you is not <em>FOR</em> you but code I have used and <em>SOUNDS</em> like you could easily adopt to to your needs.</p>
<pre><code> # this will simulate 1000 different combinations of my portfolio
    for x in range(1000):
        weights = np.random.random(len(tickers))
        weights /= np.sum(weights)
        portfolio_returns.append(np.sum(weights * log_returns.mean()) * 250)
        portfolio_volatilities.append(np.sqrt(np.dot(weights.T, np.dot(log_returns.cov() * 250, weights))))
</code></pre>
<p>What this code is doing is short is 1000x it is creating random numbers and weights for my data points, and then appending the result.The code won't be uniform as it is random, but if you really wanted uniform you could simply step through the increments. However I don't think you want uniform, but rather a large enough sample size to not have it be thrown off by outliers.</p>
<p>A way to compare the results would be something like this.</p>
<pre><code>simple_return = (mydata / mydata.shift(1)) - 1
</code></pre>
<p>Comparing random samples should be pretty straightforard, so if you do need help follow up. And with numpy arrays you can also filter/remove items based on criteria.  </p>
<p>Sorry if these do not answer exactly what you are wanting, but it should get you headed in the right direction.</p>
</div>
<span class="comment-copy">Do you need to store all of the du's in your code? Right now you're overwriting du to be a number instead of keeping it as a list</span>
<span class="comment-copy">I don't need to store them, no. I just want to print a list of every random sample from N which produces a value of du that satisfies r&gt;z</span>
<span class="comment-copy">Please provide your code as text in your post, rather than an image.</span>
<span class="comment-copy">@MarcusLim I fixed it. Sorry about that - I'm pretty new to this</span>
<span class="comment-copy">Welcome to Stackoverflow.com! While there is a reasonable question in your post, it certainly has nothing to do with the whole simulation thing. Please cut your script hard to prepare <a href="https://stackoverflow.com/help/mcve">a minimal example</a>.</span>
<span class="comment-copy">Yes, this solved my problem. Thank you for the help!</span>
<span class="comment-copy">@MattieEckerstrom please accept my answer if it helped; thanks!</span>
