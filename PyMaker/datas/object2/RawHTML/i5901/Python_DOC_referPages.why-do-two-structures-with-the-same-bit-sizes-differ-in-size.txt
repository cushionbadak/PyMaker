<div class="post-text" itemprop="text">
<p>I've got two structure that should be identical in size and content:</p>
<pre><code>from ctypes import *

class struct_1(Structure):
    _fields_ = (
        ('field1', c_int16),
        ('field2', c_int16)
    )

class struct_2(Structure):
    # having _pack_ doesn't appear to do anything as it yields the same result
    _pack_ = 1 
    _fields_ = (
        ('field1', c_int64, 16),
        ('field2', c_int64, 16)
    )
</code></pre>
<p>however <code>sizeof(struct_1)</code> is <code>4</code> and <code>sizeof(struct_2)</code> is <code>8</code>.  When I convert instances of each structure to a bytes array like so:</p>
<pre><code>p1 = struct_1()
p2 = struct_2()

p1.field1 = 3
p2.field1 = 3

p1.field2 = -3
p2.field2 = -3

print(string_at(addressof(p1), sizeof(struct_1)))
print(string_at(addressof(p2), sizeof(struct_2)))
</code></pre>
<p>I get the following output:</p>
<pre><code>b'\x03\x00\xfd\xff'
b'\x03\x00\xfd\xff\x00\x00\x00\x00'
</code></pre>
<p>Which shows to me that the structure is properly storing the data, but incorrectly setting the size of the structure.  Furthermore, if I add another field after it:</p>
<pre><code>class struct_1(Structure):
    _fields_ = (
        ('field1', c_int16),
        ('field2', c_int16),
        ('field3', c_int16)
    )

class struct_2(Structure):
    _pack_ = 1
    _fields_ = (
        ('field1', c_int64, 16),
        ('field2', c_int64, 16),
        ('field3', c_int16)
    )
</code></pre>
<p>and I set the values to those, I get a "padding" in between:</p>
<pre><code>b'\x03\x00\xfd\xff\xff\x00'
b'\x03\x00\xfd\xff\x00\x00\x00\x00\xff\x00'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>struct_1</code> has two 16 bit fields which equal 4 bytes. (2 * 16 / 8)</p>
<p><code>struct_2</code> is putting 2 16 bit fields into a 64 bit field, no matter what you do 64 bits is 8 bytes.</p>
<p><code>Pack</code>ing only helps when you are adding small fields near each other by default compilers will align the fields to start at 16, 32 or 64 bit alignments, but it will not make a <code>int64</code> smaller.</p>
</div>
<div class="post-text" itemprop="text">
<p>When dealing with the <code>ctypes</code> module, everything is going to be byte aligned (8 bits).  To account for the possibility of fields with non-byte aligned bit lengths, <code>ctypes</code> automatically allocates the space with the size of the field selected and then places the sub-fields into the newly byte aligned allocated space.  For example, given the following <code>ctypes</code> Structure:</p>
<pre><code>from ctypes import *

class simple_pkt(Structure):
    _fields_ = (
        ('A', c_int8, 4),
        ('B', c_int8, 4),
        ('C', c_int8)
    )
</code></pre>
<p>The end packet produced in memory will be:</p>
<pre><code>+---------------------------------------------------------------+
|                         bit locations                         |
+-------------------------------+-------------------------------+
|               Byte 0          |               Byte 1          |
+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| A | A | A | A | B | B | B | B | C | C | C | C | C | C | C | C |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</code></pre>
<p>This is nice and lined up as expected.  Now, let's look at , if you have two sub-fields whose bit lengths added up aren't byte aligned:</p>
<pre><code>class simple_pkt(Structure):
    _fields_ = (
        ('A', c_int8, 2),
        ('B', c_int8, 4),
        ('C', c_int8)
    )
</code></pre>
<p>You'll get empty or spare bits:</p>
<pre><code>+---------------------------------------------------------------+
|                         bit locations                         |
+-------------------------------+-------------------------------+
|             Byte 0            |             Byte 1            |
+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| A | A | B | B | B | B |   |   | C | C | C | C | C | C | C | C |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</code></pre>
<p>Notice that there is a gap between <code>B</code> and <code>C</code>.  This is the case for all of the <code>c_&lt;int&gt;</code> data types within the <code>ctypes</code> module.  As far as I know, there is no way around this.  </p>
</div>
<span class="comment-copy">Seems likely to be because of something called structure field <b>alignment</b>. See <a href="https://docs.python.org/3/library/ctypes.html#structure-union-alignment-and-byte-order" rel="nofollow noreferrer">Structure/union alignment and byte order</a> in the <code>ctypes</code> module's documentation.</span>
<span class="comment-copy">That was the reasoning of putting <code>_pack_=1</code> into the second structure, to force it to align with a single byte.</span>
<span class="comment-copy">Why do you expect a structure with two <code>c_int16</code> fields to be the same size as one with two <code>c_int64</code> ones in it? Also,it seems you're expecting <code>16</code> in the definition for the two fields in the second structure to give the 64-bit fields a 16-bit widthâ€”how is that supposed to work?</span>
<span class="comment-copy">I would expect the ability to define a structure with an odd bit length.  For example say I have a structure that has 3 fields (one that is only 1 bit in length, 1 that is 3 bits in length and finally a 3rd that is 12 bits in length).  I want to be able to define a structure like that.  It's possible is c.  I was hoping it'd be possible in Python using <code>ctypes</code>.</span>
<span class="comment-copy">It seems to indeed be because of the offset/alignment. If you print the fields of the struct (e.g. <code>print(struct_1.field1)</code>), you can see that <code>field2</code> on the two structs have differing <code>ofs</code> values: <code>struct_1.field2:  ofs=2:0, struct_2.field2:  ofs=0:16</code></span>
