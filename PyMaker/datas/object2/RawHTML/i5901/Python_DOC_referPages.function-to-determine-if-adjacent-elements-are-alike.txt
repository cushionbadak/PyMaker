<div class="post-text" itemprop="text">
<p>I've been stuck on this for a while and I keep running into problems, I'm trying to create a function that returns true if at least one pair of adjacent elements in a list are equal.</p>
<p>Test cases:</p>
<p>[1, 2, 3] -&gt; False</p>
<p>[1, 2, 2, 3] -&gt; True</p>
<p>[2, 6, 3, 6] -&gt; False</p>
<p>['a', 'b', 'c', 'd', 'd'] -&gt; True</p>
<pre><code>def equal_adjacent_elements(l):
    for x in range(len(l)):
        if l[x] == l[x+1] or l[x] == l[x-1]:
            return True
        else:
            return False
</code></pre>
<p>The problems I run into are assertion errors and I believe it's because of my loop. Once I find a pair that is equal the returned value won't stay the same because my loops will evaluate the next values in the list. So I just need to find at least one pair, I don't know how I would do that though.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> the list with itself offest by <code>1</code> and use <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a> to short-cut the find-one pattern:</p>
<pre><code>def equal_adjacent_elements(l):
    return any(x == y for x, y in zip(l, l[1:]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I made few changes. It should work now.</p>
<pre><code>def equal_adjacent_elements(l):
    for x in range(len(l)-1):
        if l[x] == l[x+1]:
            return True
    return False
</code></pre>
<p>or, shorter one using <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a>,</p>
<pre><code>def equal_adjacent_elements(l)
    return any( l[x] == l[x+1] for x in range(len(l)-1) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two problems here:</p>
<ol>
<li>the indices can run into overflow here;</li>
<li>you immediately return <code>False</code> from the moment there are two consecutive elements that are not equal, you should return <code>False</code> after the <code>for</code> loop.</li>
</ol>
<p>The index problem here is that <code>x</code> ranges from <code>0</code> to (excluding) <code>len(l)</code>. So that means <code>x-1</code> ranges from <code>-1</code> (which is the last element of the list) to <code>len(l)-1</code> and <code>x+1</code> from <code>1</code> to <code>len(l)</code> (including). But the list is not that long, so you get an index out of the list bounds, which is an error.</p>
<p>A more Pythonic approach however is to use a <code>zip(..)</code> over the list <code>l</code>, and the "<em>tail</em>" of the list (the list omitting the first element). So <code>zip(l, l[1:])</code>.</p>
<p>We can iterate over every pair <code>x,y</code> of <code>l</code> and <code>l[1:]</code>. In case <code>x == y</code>, then we have such element and return <code>True</code>.</p>
<p>In case we fail to find such pair, we eventually return `False.</p>
<p>So a correct implementation is:</p>
<pre><code>def equal_adjacent_elements(l):
    for x,y in zip(l, l[1:]):
        if x == y:
            return True
    return False</code></pre>
<p>Python however has a builtin <code>any</code>, that will return <code>True</code> from the moment the iterable we give it contains at least one <code>True</code>; and <code>False</code> if no element has truthiness <code>True</code>.</p>
<p>So we can convert the above code to something using the <code>any</code> builtin:</p>
<pre><code>def equal_adjacent_elements(l):
    return any(x == y for x,y in zip(l, l[1:]))</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm kinda new to python but anyways hoped this is easy enough</p>
<pre><code>def equal_adjacent_elements(l):
    try:
        for i in range(0, len(l)):
            if l[i] == l[i+1]:
                return True
    except IndexError:
        return False
</code></pre>
</div>
<span class="comment-copy">Is there a wrap around here? Or not?</span>
<span class="comment-copy">as for me you shouldn't do <code>else: return False</code> but use <code>return False</code> after <code>for</code> loop.</span>
