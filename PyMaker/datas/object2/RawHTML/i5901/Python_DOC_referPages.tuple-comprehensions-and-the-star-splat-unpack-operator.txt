<div class="post-text" itemprop="text">
<p>I just read the question <a href="https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python">Why is there no tuple comprehension in Python?
</a></p>
<p>In the <a href="https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python#comment66240747_16940351">comments of the accepted answer</a>, it is stated that there are no true "tuple comprehensions". Instead, our current option is to use a generator expression and pass the resulting generator object to the tuple constructor:</p>
<pre><code>tuple(thing for thing in things)
</code></pre>
<p>Alternatively, we can create a list using a list comprehension and then pass the list to the tuple constructor:</p>
<pre><code>tuple([thing for thing in things])
</code></pre>
<p>Lastly and to the contrary of the accepted answer, <a href="https://stackoverflow.com/a/47476344/6292000">a more recent answer</a> stated that tuple comprehensions are indeed a thing (since Python 3.5) using the following syntax:</p>
<pre><code>*(thing for thing in things),
</code></pre>
<ul>
<li><p>To me, it seems like the second example is also one where a generator object is created first. Is this correct? </p></li>
<li><p>Is there any difference between these expressions in terms of what goes on behind the scenes? In terms of performance? I assume the first and third could have latency issues while the second could have memory issues (as is discussed in the linked comments). </p></li>
<li>Comparing the first one and the last, which one is more pythonic?</li>
</ul>
<p><strong>Update:</strong></p>
<p>As expected, the list comprehension is indeed much faster. I don't understand why the first one is faster than the third one however. Any thoughts?</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit

&gt;&gt;&gt; a = 'tuple(i for i in range(10000))'
&gt;&gt;&gt; b = 'tuple([i for i in range(10000)])'
&gt;&gt;&gt; c = '*(i for i in range(10000)),'

&gt;&gt;&gt; print('A:', timeit(a, number=1000000))
&gt;&gt;&gt; print('B:', timeit(b, number=1000000))
&gt;&gt;&gt; print('C:', timeit(c, number=1000000))

A: 438.98362647295824
B: 271.7554752581845
C: 455.59842588083677
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>To me, it seems like the second example is also one where a generator
  object is created first. Is this correct?</p>
</blockquote>
<p>Yes, you're correct, checkout the CPython bytecode:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis("*(thing for thing in thing),")
  1           0 LOAD_CONST               0 (&lt;code object &lt;genexpr&gt; at 0x7f56e9347ed0, file "&lt;dis&gt;", line 1&gt;)
              2 LOAD_CONST               1 ('&lt;genexpr&gt;')
              4 MAKE_FUNCTION            0
              6 LOAD_NAME                0 (thing)
              8 GET_ITER
             10 CALL_FUNCTION            1
             12 BUILD_TUPLE_UNPACK       1
             14 POP_TOP
             16 LOAD_CONST               2 (None)
             18 RETURN_VALUE
</code></pre>
<blockquote>
<p>Is there any difference between these expressions in terms of what
  goes on behind the scenes? In terms of performance? I assume the first
  and third could have latency issues while the second could have memory
  issues (as is discussed in the linked comments).</p>
</blockquote>
<p>My timings suggest the first 1 is slightly faster, presumably because the unpacking is more expensive via <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_TUPLE_UNPACK" rel="nofollow noreferrer"><code>BUILD_TUPLE_UNPACK</code></a> than the <code>tuple()</code> call:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; def f1(): tuple(thing for thing in range(100000))
... 
&gt;&gt;&gt; def f2(): *(thing for thing in range(100000)),
... 
&gt;&gt;&gt; timeit(lambda: f1(), number=100)
0.5535585517063737
&gt;&gt;&gt; timeit(lambda: f2(), number=100)
0.6043887557461858
</code></pre>
<blockquote>
<p>Comparing the first one and the last, which one is more pythonic?</p>
</blockquote>
<p>The first one seems far more readable to me, and also will work across different Python versions.</p>
</div>
<span class="comment-copy">You ask about performance.  Test them.  Try <code>%timeit</code> in ipython.  Find out which is better on your specific machine.</span>
<span class="comment-copy">The <code>x for y in z</code> in the list comprehension may look like a generator, but it isn't. The inner workings are different. E.g.  a <code>StopIteration</code> raised in the <code>x</code> part will stop a generator but will bubble out of the list comprehension.</span>
<span class="comment-copy">I'd say neither is very pythonic, because tuples are generally used to represent a statically known, possibly heterogeneous set of items (which you can e.g. destructure over), with some semantic meaning associated with each position. Lists are more suited to indeterminate, homogeneous multitudes where operations like iterating makes sense. That's just my opinion though.</span>
<span class="comment-copy">While the last can technically be used, it is the slowest out of the options and having to paste in a stray comma just to have the interpreter be able to understand it needs to unpack a tuple is in my humble view not very "pythonic".</span>
<span class="comment-copy">Done! I updated the question @JohnZwinck . Also @schwobaseggl, I'm not sure if I understand, I've used <code>x for x in y</code> and not <code>x for y in z</code>. With regards to the other points raised here, I agree with you all.</span>
