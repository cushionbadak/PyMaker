<div class="post-text" itemprop="text">
<p>I am working on a small project where I have to use method overloading for <strong>mul</strong> method. But that <strong>mul</strong> method has a different arguments. </p>
<blockquote>
<p>Method can take 2 argument 1st is self and 2nd is either Instance or integer.
  So when Method take 2nd argument as Instance it gives me an error. 
  Here is my code</p>
</blockquote>
<pre><code>import math
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __mul__(self,v1):
        x = self.x * v1.x
        y = self.y * v1.y
        return Vector(x,y)

    def __mul__(self,n):
        x = self.x*n
        y = self.y*n 
        return Vector(x,y)


v1 = getVector()
v2 = getVector()
v3 = v1 * v2 

v4 = 1
v5 = getVector()
v6 = v4 * v5
</code></pre>
<p>So when I am trying to run the program I am getting error that </p>
<pre><code>File "Al.py", line 102, in &lt;module&gt;
    main()
  File "Al.py", line 88, in main
    mul()
  File "Al.py", line 47, in mul
    v3 = v1 * v2
  File "Al.py", line 21, in __mul__
    x = self.x*n
</code></pre>
<p>Can someone help me to understand this? How can I call the overloaded method without making any changes to my method signature? </p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in the comments, Python does not support method overloading. Instead, you have to examine the argument(s) in the body of the function to determine how to proceed.</p>
<p>Note that you generally do not examine the <em>type</em> of the argument(s), but rather their <em>behavior</em>. For example,</p>
<pre><code>def __mul__(self, other):
    try:
        try:
            x = self.x * other.x
            y = self.y * other.y
        except AttributeError:
            x = self.x * other
            y = self.y * other
    except Exception:
        return NotImplemented

    return Vector(x, y)

__rmul__ = __mul__   # Allows 4 * v, not just v * 4
</code></pre>
<p>The second argument of <code>__mul__</code> doesn't have to be just an number or a <code>Vector</code>; it can be anything that is similar enough to either for the attempted multiplications to succeed.</p>
<p>On any other error involving the multiplication, return <code>NotImplemented</code> so that <code>type(other).__rmul__</code> can be tried.</p>
<p>If you really need to differentiate between arguments of different types, use <code>isinstance</code>:</p>
<pre><code>def __mul__(self, other):
    if isinstance(other, int):
        x = self.x * other
        y = self.y * other
    elif isinstance(other, Vector):
        x = self.x * other.x
        y = self.y * other.y
    else:
        return NotImplemented

    return Vector(x, y)
</code></pre>
</div>
<span class="comment-copy">Python doesn't support overloading. Instead write one method in which you check parameter type and process parameter accordingly.</span>
<span class="comment-copy">Which Python version do you use? Remove the wrong tag.</span>
<span class="comment-copy">It does not related to version.</span>
<span class="comment-copy">Python can have only one function by a given name in a given namespace. By redefining <code>__mul__</code>, you wiped out the first version.</span>
<span class="comment-copy">Unlike, say, C++, Python does <i>not</i> consider the number of arguments nor their type to be part of a method's signature, only it's name. To fake overloading, the <code>__mul__()</code> method would need to explicitly check the number and type of arguments it was passed to determine what to do.</span>
<span class="comment-copy">In the first sentence, do you mean method overloading/overloading in general, rather than operator overloading? I have seen operator overloading refer to simply custom dunder methods such as <code>__mul__</code></span>
<span class="comment-copy">I did mean method overloading; thanks for point that out.</span>
<span class="comment-copy">Good clear explanation. Might be worth noting that <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance()</code></a> can check multiple candidate types in one call by passing a tuple of them as the second argument: i.e. <code>isinstance(other, (int, float))</code>.</span>
