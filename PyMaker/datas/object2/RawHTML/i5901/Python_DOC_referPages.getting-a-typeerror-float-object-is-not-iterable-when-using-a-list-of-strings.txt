<div class="post-text" itemprop="text">
<p>Im trying to get the closest match between two lists of strings (<code>listA</code> and <code>listB</code>) to create a <code>listC</code>.</p>
<p>The purpose for that is because I have to clean a dataframe that has one column of strings which each string represent a fruit which some entries has spelling mistakes that I need to fix.</p>
<p>The actual column that I want to fix is called test:</p>
<pre><code>print(test)
</code></pre>
<p>Output:
    </p>
<pre><code>0             lychee
1         strawberry
2          nectarine
3             lychee
4             lychee
5             banana
6          raspberry
7            loga!!n
....
37497          grape
37498          apple
37499      rockmelon
Name: fruit_ate, Length: 37500, dtype: object
</code></pre>
<p>Then I converted the test column into a list called <code>newTest</code> and I created a list of fruits with the correct names:</p>
<pre><code>newTest = list(test)

fruits = ['lychee',
      'strawberry',
      'nectarine',
      'banana',
      'raspberry',
      'kiwi',
      'apple',
      'durian',
      'pear',
      'logan',
      'jackfruit',
      'grape',
      'peach',
      'watermelon',
      'rockmelon',
      'orange']
</code></pre>
<p>I created a for loop that goes through <code>newList</code> and get each element and returns me the closest match in fruits list. However, as I thought it would be easier to try to fix a small list first than just after my code works I could use it to fix the <code>newTest</code> list.</p>
<p>So I created these <code>listA</code> and <code>listB</code>.
I copied some of these values of test column into the <code>listB</code>, and I created <code>listA</code> with values of the list fruits.</p>
<p>The way I managed to do that was:</p>
<pre><code>listA = ['apple', 'banana', 'coco', 'grape', 'pear']
listB = ['ba88tana', 'peeaar', 'apple', 'ggra))pe']
listC = []

for i in listB:
    listC.append(diff.get_close_matches(i, fruits, n=1, cutoff=0.5))

output: [['banana'], ['pear'], ['apple'], ['grape']]
</code></pre>
<p>When I run this it works fine, but if I apply the same algorithm to my <code>newTest</code> list and fruits list it doesn't work, it says:  <code>TypeError: 'float' object is not iterable</code>.</p>
<p>If someone knows how to fix it or another way that I could do this it would be very helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Without seeing the entire code I would guess that newTest is a float when you are using it with your data?</p>
<p>Or that the line:</p>
<pre><code>listC.append(diff.get_close_matches(i, fruits, n=1, cutoff=0.5))
</code></pre>
<p>The function diff may be recieving a float instead of a string, for example</p>
<pre><code>diff.get_close_matches(32, text, n=1, cutoff=.5)
</code></pre>
<p>Instead of:</p>
<pre><code>diff.get_close_matches('32', text, n=1, cutoff=.5)
</code></pre>
<p>This may be the case if your data is floats and not strings.</p>
<pre><code>for i in newTest:
    diff.get_close_matches(str(i), text, n=1, cutoff=.5)
</code></pre>
<p>Posting relevant parts of the actual test would aid in diagnosis.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Dependencies</h1>
<pre><code>pip install editdistance
</code></pre>
<h1>code (closest.py)</h1>
<pre><code>import editdistance
listA = ['apple', 'banana', 'coco', 'grape', 'pear']
listB = ['ba88tana', 'peeaar', 'apple', 'ggra))pe']
listC = []

for i in listB:
    res = None
    distance = len(i)+1
    for j in listA:
        diff = editdistance.eval(i, j)
        if diff &lt; distance:
            distance = diff
            res = j
    listC.append(res)

print listC
</code></pre>
</div>
<span class="comment-copy">What is the value of <code>newTest</code>?</span>
<span class="comment-copy">oh, it was supposed to be listB, I forgot to change that. Sorry :/</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">Catch the error</a> and inspect the data in the except suite.</span>
<span class="comment-copy">I added more details to clarify what I am trying to do. The cutoff argument is just how close the match needs to be, so I don't think this is the problem. Specially because I took it of to check and it gave me the same error :/</span>
<span class="comment-copy">hope this helps</span>
<span class="comment-copy">I tried to install editdistance and run this chunk but didn't work as well. It says : ModuleNotFoundError: No module named 'editdistance'</span>
<span class="comment-copy">python2.x <code>pip install editdistance</code> for python3 <code>pip3 install editdistance</code></span>
