<div class="post-text" itemprop="text">
<p>Sometimes you need to dynamically import Python objects, for example with <code>importlib</code>:</p>
<pre><code>import importlib
importlib.import_module(name='my.module.path')
</code></pre>
<p>I would like to know if there is a standard way to check if the string fed to <code>importlib.import_module</code> is <strong>valid</strong>, i.e. could specify the location of a Python object.</p>
<p>If I had to implement a validation method myself, I would try to match the string against a regular expression like <code>([a-zA-Z_][a-zA-Z0-9_]\.?)+</code> (names starting with letters or underscore, composed of letters, underscores and numbers, and separated by dots).</p>
<p>Is there a method in standard or third libraries to check this? If not, is there a PEP describing valid Python paths? If not, is my regex sufficient?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>import</code> statement requires that names are <em>valid Python identifiers</em>. From the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer"><code>import</code> statement documentation</a>:</p>
<blockquote>
<pre><code>import_stmt     ::=  "import" module ["as" name] ( "," module ["as" name] )*
                     | "from" relative_module "import" identifier ["as" name]
                     ( "," identifier ["as" name] )*
                     | "from" relative_module "import" "(" identifier ["as" name]
                     ( "," identifier ["as" name] )* [","] ")"
                     | "from" module "import" "*"
module          ::=  (identifier ".")* identifier
relative_module ::=  "."* module | "."+
name            ::=  identifier
</code></pre>
</blockquote>
<p>Identifiers are basically anything that starts with a letter or underscore, followed by 0 or more letters, underscores or digits. The definition of letters and digits is broad, see the <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="nofollow noreferrer"><em>Identifiers and keywords</em> section</a>; basically the NFKC normalised forms of specific Unicode character classes are all included.</p>
<p>However, note that by using <code>importlib()</code>, <strong>anything goes</strong>. You can import modules that do not have valid Python identifier names, because the whole process is highly flexible. If you want to import a module that only consists of digits, then <em>that is still possible</em>, just not with the <code>import</code> statement.</p>
<p>As such, there is no cut and dry answer to this question. In principle, any string is valid.</p>
</div>
<span class="comment-copy">As long as it follows dot notation and English alphabet lowercase/uppercase it is good</span>
<span class="comment-copy">What do you mean by valid, that it doesn't throw an format error when passed to <code>importlib.import_module()</code>???</span>
<span class="comment-copy">Define 'valid'? E.g. following the rules for module names (so valid Python identifiers), or referring to an actual importable object?</span>
<span class="comment-copy">And you can't validate dotted names like this without actually <i>doing the import</i>, because plenty of modules set such names dynamically. For example, <code>os.path</code> is dynamically set when you import <code>os</code>, it is really either the <code>ntpath</code> or the <code>posixpath</code> module!</span>
<span class="comment-copy">By valid, I mean that the object <b>could</b> be imported if it exists. I don't need to know if it <b>actually</b> exists.</span>
<span class="comment-copy">Thanks for the note about <code>importlib</code>.</span>
