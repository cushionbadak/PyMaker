<div class="post-text" itemprop="text">
<p>Four references to a class are produced when a class is created which that never had a <code>__classcell__</code> passed in the namespace argument of <code>type.__new__</code>, aka a class with no functions that ever need the opcode <code>LOAD_NAME - __class__</code>. I can account for one, but since I can barely read C I can only speculate about the other 3. Most obviously, the first is the reference in the <code>__dict__</code> of the module the class was defined in. Another I think one is in a cache in <code>typeobject.c</code>. After a while if the reference count of a class drops below 4 it is destroyed, which is a good thing for classes defined in in function since there's no way to delete it after the function has been executed. 
Also there is perhaps a reference in whatever <code>type.mro</code> uses to generate mros. </p>
<p>Finally, I'm guessing the last is somewhere zero argument <code>super</code> can access, and that is the real info I'm after: why does a function created outside a class definition not work with zero argument <code>super</code>, even when it has <code>'__class__'</code> in its <code>__code__.co_names</code> and a cell with the class in its <code>__closure__</code>? A <code>RuntimeError: super(): __class__ cell not found</code> is still produced.</p>
<p>Classes that had a <code>__classcell__</code> (I say <em>had</em> because I believe that name is eventually deleted) have 5 references upon creation, one more than not. Seeing as the cell containing the class object in the <code>__closure__</code> of all functions that mention zero argument <code>super()</code> or <code>__class__</code> are identical I think it's a good bet that the additional reference is used by the <code>types.FunctionType.__closure__</code> descriptor to produce the <code>tuple</code> containing the cells.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's take a look with <a href="https://docs.python.org/3/library/gc.html#gc.get_referrers" rel="nofollow noreferrer"><code>gc.get_referrers</code></a>:</p>
<pre><code>&gt;&gt;&gt; import gc
&gt;&gt;&gt; import pprint
&gt;&gt;&gt; class Foo: pass
... 
&gt;&gt;&gt; pprint.pprint(gc.get_referrers(Foo))
[&lt;attribute '__dict__' of 'Foo' objects&gt;,
 &lt;attribute '__weakref__' of 'Foo' objects&gt;,
 (&lt;class '__main__.Foo'&gt;, &lt;class 'object'&gt;),
 {'Foo': &lt;class '__main__.Foo'&gt;,
  '__annotations__': {},
  '__builtins__': &lt;module 'builtins' (built-in)&gt;,
  '__cached__': None,
  '__doc__': None,
  '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x7ff284402da0&gt;,
  '__name__': '__main__',
  '__package__': None,
  '__spec__': None,
  'gc': &lt;module 'gc' (built-in)&gt;,
  'pprint': &lt;module 'pprint' from '/usr/local/lib/python3.6/pprint.py'&gt;}]
</code></pre>
<p>We can see in this list that the 3 references you were missing are from the <code>__dict__</code> and <code>__weakref__</code> <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptors</a> and the class's <a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow noreferrer"><code>__mro__</code></a>. (It might not be obvious that the third entry is the <code>__mro__</code>, but we can confirm:)</p>
<pre><code>&gt;&gt;&gt; gc.get_referrers(Foo)[2] is Foo.__mro__
True
</code></pre>
<p>The <code>__dict__</code> and <code>__weakref__</code> descriptors manage access to the <code>__dict__</code> and <code>__weakref__</code> attributes of <code>Foo</code> instances, and they need a reference to <code>Foo</code> for type checking, to make sure they're only used on <code>Foo</code> instances.</p>
<p>The <code>__mro__</code> is the sequence of classes Python searches to resolve class attributes of <code>Foo</code>, and to resolve instance attributes of <code>Foo</code> which are managed by a data descriptor or which don't have an entry in the instance <code>__dict__</code>.</p>
</div>
<span class="comment-copy">It sounds like you asked this question as part of an attempt to debug some <code>super</code>-related issue. If you can produce an MCVE where the externally-defined function actually has a <code>__class__</code> closure variable pointing to the class and <code>super</code> can't find it, you may want to ask a question specifically about that.</span>
