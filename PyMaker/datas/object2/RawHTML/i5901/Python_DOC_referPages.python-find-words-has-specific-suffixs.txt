<div class="post-text" itemprop="text">
<p>I am dealing with Chinese NLP Problem.
I find to find word has specific suffixs.
 For example, I have two list!</p>
<p><code>suffixs = ['aaa','bbb','cc'.....]</code></p>
<p><code>words_list = ['oneaaa','twobbb','three','four']</code></p>
<pre><code>for w in words_list:
    if w has suffix in suffixs:
          func(s,w)
</code></pre>
<p>I know I can use re package, but re just can deal with less than 100 suffixs,but I have 1000+ suffixs.
I try to use</p>
<pre><code>for w in words_list:
    for s in suffixs:
         #suffixs sorted by lenth
         if s is_suffix_of(w):
               func(s,w)
               break
</code></pre>
<p>But it is too slow.<br/>
The func(s,w) could split the word <em>w</em> to no_suffix word and suffix.<br/>
For example 'oneaaa' to ['one','aaa']ï¼Œbut the func bases on some condition and more complex.So <em>any</em> doesn't work here.<br/>
So I want to know whether a better way to deal with it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just wan to see which words have "back-fixes" (the correct term is suffix, BTW), you can just use <a href="https://docs.python.org/3/library/stdtypes.html#str.endswith" rel="nofollow noreferrer"><code>str.endswith</code></a> in combination with <code>any</code></p>
<pre><code>for w in words_list:
    if any(w.endswith(b) for b in back_fixs):
          print(w)
</code></pre>
<p>Or pass all the suffixes to <code>endswith</code>, but for that they have to be in a <code>tuple</code>, not <code>list</code>:</p>
<pre><code>back_fixs = tuple(back_fixs)
for w in words_list:
    if w.endswith(back_fixs):
          print(w)
</code></pre>
<p>If you also need to know <em>which</em> suffix matches, you can get the <code>next</code>, or <code>None</code> if non match:              </p>
<pre><code>for w in words_list:
    b = next((b for b in back_fixs if w.endswith(b)), None)
    if b:
          print(w, b)
</code></pre>
<p>Or shorter using <code>filter</code>: <code>b = next(filter(w.endswith, back_fixs), None)</code></p>
<p>Or without default, using <code>try/except</code>:</p>
<pre><code>for w in words_list:
    try:
        print(w, next(filter(w.endswith, back_fixs)))
    except StopIteration:
        pass
</code></pre>
</div>
<span class="comment-copy">What's your <code>func</code>, Why you call it with different params?</span>
<span class="comment-copy">it's worth to elaborate whether <code>func(b,w)</code> should be called if ANY of "back_fixes" was found in the word OR it should be called for all potential matches</span>
<span class="comment-copy">@FrankAK thank for your attention,I edit my question.</span>
<span class="comment-copy">@RomanPerekhrest when the b is the back_fixs of w , trigger the func, and the match rule is heuristic, when the longer back_fix in w, break the infer loop.</span>
<span class="comment-copy">If you say "back-fix", do you mean "suffix"?</span>
<span class="comment-copy">+1 for the <code>endswith(&lt;tuple&gt;)</code> syntax, I had no idea! I wonder if the performance is acceptable with a thousand suffixes, but only the OP can say.</span>
<span class="comment-copy">Thank you. I tried to use <b>next</b>  and <b>endswith</b> but it was also slow .I deal with news with about thousands words .One article cost 7 seconds.</span>
<span class="comment-copy">@Cauchyzhou If the suffixes has a certain maximum length, say 3 characters, it might be faster to put all the suffixes into a <code>set</code> and then test for the last 1, 2, or 3 characters of each word whether those are in the set.</span>
<span class="comment-copy">I am sorry, I find the reason why is slow. The func's condition judgement is slow.Anyhow, thank you. <b>endswit</b>h is a better solution.</span>
