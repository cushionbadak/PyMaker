<div class="post-text" itemprop="text">
<p>So, I have a few tasks for creating class in python:</p>
<ul>
<li>Can someone give me review of my code.</li>
<li>I need to use Magic Methods to complete tasks.</li>
</ul>
<p>Here is my tasks:</p>
<p>1) The class must be initialized in the full path.</p>
<p>such as</p>
<pre><code>obj = File('/tmp/file.txt')
</code></pre>
<p>2) The class must support the write method.</p>
<p>3) Objects of type File must support adding.</p>
<p>4) Objects of type File must support the iteration protocol, and iterates through the lines of the file.</p>
<pre><code>for line in File('/tmp/file.txt'):
</code></pre>
<p>And here I have a problem, as a result I heve an infinite loop.</p>
<p>5) When outputting a file using the print function, it should print its full path, passed at initialization.</p>
<p>Here is my code:</p>
<pre><code>import os

class File:

def __init__(self, file_path, content = None):
    self.file_path = file_path
    self.content = content
    try:
        with open(file_path) as file_to:
            self.content = file_to.read()
    except FileNotFoundError:
        print("File or directory does not exist!\nEnter existing directory")


def write(self, line):
    self.line = line
    with open(self.file_path, 'a+') as file_to:
        file_to.write(self.line)

def __add__(self, obj):
        with open('result.txt', 'a+') as new_file:
            new_file.write(self.content + obj.content)

def __iter__(self):
    return self

def __next__(self):
    self.stop = 0
    with open(self.file_path) as f:
        data = f.readlines()
    if self.stop &gt; len(data):
        raise StopIteration

    self.stop += 1

    return data 

def __str__(self):
    return f"{self.file_path}"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>And here I have a problem, as a result I have an infinite loop.</p>
</blockquote>
<p>You're re-opening the file and reading it all over every time the next method is called by the <em>for</em> on the <code>File</code> instance. The successive <code>next</code> calls will not end as <code>__next__</code> keeps returning the same data.</p>
<p>You can instead return an iterator on the file content directly from <code>__iter__</code>:</p>
<pre><code>class File:

    def __init__(self, file_path):
        self.file_path = file_path
        try:
            with open(file_path) as file_to:
                self.content = file_to.readlines()
        except FileNotFoundError:
            print("File or directory does not exist!\nEnter existing directory")
            raise

    def __iter__(self):
        return iter(self.content)
</code></pre>
<p>To make the class instance an iterator, i.e. implement the iterator protocol, you can return self in <code>__iter__</code>, and return lines of the file in <code>__next__</code>:</p>
<pre><code>class File:

     def __init__(self, file_path):
        ...
        self._index = 0 

    def __iter__(self):
        return self

    def __next__(self):
        try:
           return self.content[self._index]
        except IndexError:
           raise StopIteration
        self._index += 1
</code></pre>
</div>
<span class="comment-copy">General code review of working code belongs on <a href="http://codereview.stackexchange.com">the Code Review sister site</a>. For the known problems you need help fixing, please provide the necessary parts of a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> (including code that exercises the class and the expected inputs and outputs).</span>
<span class="comment-copy">This solution assumes it's intended to be an iterable, but not an iterator (all built-in file-like objects are iterators, with <code>seek</code>ing required to reset their position).</span>
<span class="comment-copy">@ShadowRanger That's not what I read from the OP: <i>Objects of type File must support the iteration protocol, and iterates through the lines of the file.</i> And BTW, there is no explicit requirement to support seeking and all the fancy stuff file iterators provide.They want to support the iterator protocol, and there they have it.</span>
<span class="comment-copy">I don't know what the OP wants. The wording you quoted is too vague to determine intent. Python has a concept of <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">"iterator protocol"</a> (if that was the intent, you'd want an iterator), it has no "iteration protocol". No, they don't need to provide <code>seek</code>, but if it's supposed to be an iterator, then having it be an iterable that hands out independent iterators on each <code>__iter__</code> call will make it incorrect (two threads iterating the file will each iterate it independently, rather than splitting the lines).</span>
<span class="comment-copy">@ShadowRanger I take it they meant "iterator protocol". Updated.</span>
