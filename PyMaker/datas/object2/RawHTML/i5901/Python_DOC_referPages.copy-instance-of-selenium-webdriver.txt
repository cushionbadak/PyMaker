<div class="post-text" itemprop="text">
<p>I'm currently using Python (3.6.3) Selenium to access a website and scrape data from it.
The website contains a section such as the following:</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Each <code>&lt;li&gt;&lt;/li&gt;</code> is a link that I want to press on, then collect the data on that website.</p>
<p>My solution is to load the main page, 
then copy its session, clicking on one link,
then copying the session again and click on the next link.</p>
<pre><code>browser = webdriver.PhantomJS("phantomjs")
browser2 = browser
</code></pre>
<p>Thats what I want to do, but when I do that, <code>browser2</code> points to <code>browser</code>, so whenever I change <code>browser2</code>, <code>browser</code> changes.</p>
<p>I want to make <code>browser2</code> a copy of <code>browser</code>, so that I can just reset <code>browser2</code> whenever I want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are assigning browser to broswer2, browser2 is essentially a reference to browser object hence broswer2 and browser both points to the same object. What you can do to solve this issue is use a Python's standard copy module</p>
<pre><code>import copy

broswer2 = copy.copy(browser)
</code></pre>
<p>Now both object can be modified independently </p>
<p>From copy docs:</p>
<blockquote>
<p>Assignment statements in Python do not copy objects, they create
  bindings between a target and an object. For collections that are
  mutable or contain mutable items, a copy is sometimes needed so one
  can change one copy without changing the other. This module provides
  generic shallow and deep copy operations</p>
</blockquote>
<p>Read more about copy module <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">here in docs</a></p>
</div>
<span class="comment-copy">I'm not entirely sure about the issue here, but I guess you wish to navigate all the links, you don't need a new instantiation of webdriver for that, without going into parallelism you could simple go to the first links, use browser.back() for instance and select a new one, etc rinse and repeat.</span>
<span class="comment-copy">This is exactly what I needed, thanks!</span>
<span class="comment-copy">Great Answer !!!</span>
