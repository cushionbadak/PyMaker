<div class="post-text" itemprop="text">
<p>Note: although my particular use is Flask related, I think the question is more general. </p>
<p>I am building a Flask web application meant to be customized by the user. For example, the user is expected to provide a concrete subclass of a DatabaseInterface and may add to the list of certain ModelObjects that the application knows how to handle. </p>
<p>What is the best way to expose the various hooks to users, and indicate required and optional status?  'Best' here primarily means most 'pythonic', or "easiest for python users to grasp", but other criteria like not causing headaches down the road are certainly worth mentioning. </p>
<p>Some approaches I've considered:</p>
<ul>
<li><p>Rely solely on documentation</p></li>
<li><p>Create a template file with documented overrides, much like default config files for many servers. E.g. </p>
<pre><code>app = mycode.get_app()
##Add your list of extra foo classes here
#app.extra_foos = []
</code></pre></li>
<li><p>Create a UserOverrides class with an attr/method for each of the hooks; possibly split into RequiredOverrides and OptionalOverrides </p></li>
<li>Create an empty class with unimplemented methods that the user must subclass into a concrete instance</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>One method is by using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">abstract base classes (abc module)</a>. For example, you can define an ABC with abstract methods that <em>must</em> be overridden by child classes like this:</p>
<pre><code>from abc import ABC


class MyClass(ABC):  # inherit from ABC

   def __init__(self):
      pass

    @abstractmethod
    def some_method(self, args):
        # must be overridden by child class
        pass
</code></pre>
<p>You would then implement a child class like:</p>
<pre><code>class MyChild(MyClass):
    # uses parent's __init__ by default
    def some_method(self, args):
        # overrides the abstract method
</code></pre>
<p>You can specify what everything needs to do in the overridden methods with documentation. There are also decorators for abstract properties, class methods, and static methods. Attempting to instantiate an ABC that does not have all of its abstract methods/properties overridden will result in an error.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://softwareengineering.stackexchange.com/questions/260343/why-is-inheritance-generally-viewed-as-a-bad-thing-by-oop-proponents">Inheritance</a>. <a href="https://softwareengineering.stackexchange.com/questions/134097/why-should-i-prefer-composition-over-inheritance">Is</a>. <a href="https://simpleprogrammer.com/2010/01/15/inheritance-is-inherently-evil/" rel="nofollow noreferrer">Bad</a>.</p>
<p>This is especially true in Python, which gives you a nice precedent to avoid the issue. Consider the following code:</p>
<pre><code>len({1,2,3}) # set with length 3
len([1,2,3]) # list with length 3
len((1,2,3)) # tuple with length 3
</code></pre>
<p>Which is cool and all for the built-in data structures, but what if you want to make your own data structure and have it work with Python's <code>len</code>? Simple:</p>
<pre><code>class Duple(object):
    def __init__(self, fst, snd):
        super(Duple, self).__init__()
        self.fst = fst
        self.snd = snd

    def __len__():
        return 2
</code></pre>
<p>A <code>Duple</code> is a two-element (only) data structure (calling it with more or fewer arguments raises) and now works with <code>len</code>:</p>
<pre><code>len(Duple(1,2)) # 2
</code></pre>
<p>Which is exactly how you should do this:</p>
<pre><code>def foo(arg):
    return arg.__foo__()
</code></pre>
<p>Any class that wants to work with your <code>foo</code> function just implements the <code>__foo__</code> magic method, which is how <code>len</code> works under the hood.</p>
</div>
<span class="comment-copy">Inheritance is a crappy extension mechanism. Use functions that call a magic method on their arguments and have extension classes implement the appropriate dunder methods.</span>
<span class="comment-copy">@JaredSmith I'm afraid most of that was Greek to me.  Care to expand that into an answer since the only current answer suggests the opposite?</span>
<span class="comment-copy">Done. Check out my answer below.</span>
<span class="comment-copy">Possibly a bit off-topic, but I've always wondered: what does ABC add compared to just defining your abstract methods in the base class to raise <code>NotImplementedError</code>?</span>
<span class="comment-copy">2 questions: (1) isn't defining new double-underscore methods considered a no-no?</span>
<span class="comment-copy">(2) I am probably missing something, but this seems to only partially answer my question.  Rather than telling my users "Subclass this ABC and pass your concrete instance", I say "pass an object that implements these methods."  But especially if some methods are allowed default values, having an overloadable base class seems like less work than creating objects from scratch. And it doesn't answer the question "how do I best communicate what methods are overloadable?"</span>
<span class="comment-copy">@thegreatemu First: compared to what? Inheritance? When there's a zillion and five articles about the evils of inheritance all over the internet? Second: see the answer to the first, rethink your design. Inheritance is inherently <i>fragile</i>. You may be able to get away with it in your case (in which case the other answer is <i>fine</i>) but Python gives you other tools. Or to turn your question around: why do you think Guido implemented <code>len</code> that way rather than having it simply be a method on those objects?</span>
<span class="comment-copy">well PEP 8 specifically says "<code>__double_leading_and_trailing_underscore__</code>: "magic" objects or attributes that live in user-controlled namespaces. E.g.` __init__<code>, </code>__import__` or <code>__file__</code>. Never invent such names; only use them as documented."  <a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" rel="nofollow noreferrer">python.org/dev/peps/pep-0008/#naming-conventions</a></span>
<span class="comment-copy">@thegreatemu <a href="https://stackoverflow.com/a/19328146/3757232">this answer</a> to a related-but-not-duplicate question may shed some light. As for PEP 8, fine, don't use double underscores. But the same principle applies: use duck typing, not inheritance.</span>
