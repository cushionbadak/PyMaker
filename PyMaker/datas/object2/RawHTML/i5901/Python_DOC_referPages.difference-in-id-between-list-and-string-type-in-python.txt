<div class="post-text" itemprop="text">
<p>Two Python strings with the same characters, a == b,
may share memory, id(a) == id(b),
or may be in memory twice, id(a) != id(b).
Try</p>
<pre><code>ab = "ab"
print id( ab ), id( "a"+"b" )
</code></pre>
<p>Here Python recognizes that the newly created "a"+"b" is the same
as the "ab" already in memory -- not bad.</p>
<p>Now consider an N-long list of state names
    [ "Arizona", "Alaska", "Alaska", "California" ... ]
(N ~ 500000 in my case).<br/>
I see 50 different id() s ⇒ each string "Arizona" ... is stored only once, fine.<br/>
BUT write the list to disk and read it back in again: 
the "same" list now has N different id() s, way more memory, see below.</p>
<p>How come -- can anyone explain Python string memory allocation ?</p>
<pre><code>""" when does Python allocate new memory for identical strings ?
    ab = "ab"
    print id( ab ), id( "a"+"b" )  # same !
    list of N names from 50 states: 50 ids, mem ~ 4N + 50S, each string once
    but list &gt; file &gt; mem again: N ids, mem ~ N * (4 + S)
"""

from __future__ import division
from collections import defaultdict
from copy import copy
import cPickle
import random
import sys

states = dict(
AL = "Alabama",
AK = "Alaska",
AZ = "Arizona",
AR = "Arkansas",
CA = "California",
CO = "Colorado",
CT = "Connecticut",
DE = "Delaware",
FL = "Florida",
GA = "Georgia",
)

def nid(alist):
    """ nr distinct ids """
    return "%d ids  %d pickle len" % (
        len( set( map( id, alist ))),
        len( cPickle.dumps( alist, 0 )))  # rough est ?
# cf http://stackoverflow.com/questions/2117255/python-deep-getsizeof-list-with-contents

N = 10000
exec( "\n".join( sys.argv[1:] ))  # var=val ...
random.seed(1)

    # big list of random names of states --
names = []
for j in xrange(N):
    name = copy( random.choice( states.values() ))
    names.append(name)
print "%d strings in mem:  %s" % (N, nid(names) )  # 10 ids, even with copy()

    # list to a file, back again -- each string is allocated anew
joinsplit = "\n".join(names).split()  # same as &gt; file &gt; mem again
assert joinsplit == names
print "%d strings from a file:  %s" % (N, nid(joinsplit) )

# 10000 strings in mem:  10 ids  42149 pickle len  
# 10000 strings from a file:  10000 ids  188080 pickle len
# Python 2.6.4 mac ppc
</code></pre>
<p>Added 25jan:<br/>
There are two kinds of strings in Python memory (or any program's):</p>
<ul>
<li>Ustrings, in a Ucache of unique strings: these save memory, and make a == b fast if both are in Ucache</li>
<li>Ostrings, the others, which may be stored any number of times.</li>
</ul>
<p><code>intern(astring)</code> puts astring in the Ucache (Alex +1);
other than that we know nothing at all about how Python moves Ostrings to the Ucache --
how did "a"+"b" get in, after "ab" ?
("Strings from files" is meaningless -- there's no way of knowing.)<br/>
In short, Ucaches (there may be several) remain murky.</p>
<p>A historical footnote:
<a href="http://en.wikipedia.org/wiki/SPITBOL_compiler" rel="noreferrer">SPITBOL</a>
uniquified all strings ca. 1970.</p>
</div>
<div class="post-text" itemprop="text">
<p>Each <em>implementation</em> of the Python language is free to make its own tradeoffs in allocating immutable objects (such as strings) -- either making a new one, or finding an existing equal one and using one more reference to it, are just fine from the language's point of view. In practice, of course, real-world implementation strike reasonable compromise: one more reference to a suitable existing object when locating such an object is cheap and easy, just make a new object if the task of locating a suitable existing one (which may or may not exist) looks like it could potentially take a long time searching.</p>
<p>So, for example, multiple occurrences of the same string literal within a single function will (in all implementations I know of) use the "new reference to same object" strategy, because when building that function's constants-pool it's pretty fast and easy to avoid duplicates; but doing so across <em>separate</em> functions could potentially be a very time-consuming task, so real-world implementations either don't do it at all, or only do it in some heuristically identified subset of cases where one can hope for a reasonable tradeoff of compilation time (slowed down by searching for identical existing constants) vs memory consumption (increased if new copies of constants keep being made).</p>
<p>I don't know of any implementation of Python (or for that matter other languages with constant strings, such as Java) that takes the trouble of identifying possible duplicates (to reuse a single object via multiple references) when reading data from a file -- it just doesn't seem to be a promising tradeoff (and here you'd be paying <em>runtime</em>, not <em>compile</em> time, so the tradeoff is even less attractive).  Of course, if you know (thanks to application level considerations) that such immutable objects are large and quite prone to many duplications, you can implement your own "constants-pool" strategy quite easily (<a href="http://docs.python.org/library/functions.html?highlight=intern#intern" rel="noreferrer">intern</a> can help you do it for strings, but it's not hard to roll your own for, e.g., tuples with immutable items, huge long integers, and so forth).</p>
</div>
<div class="post-text" itemprop="text">
<p>I strongly suspect that Python is behaving like many other languages here - recognising string constants <em>within your source code</em> and using a common table for those, but <em>not</em> applying the same rules when creating strings dynamically. This makes sense as there will only be a finite set of strings within your source code (although Python lets you evaluate code dynamically, of course) whereas it's much more likely that you'll be creating huge numbers of strings in the course of your program.</p>
<p>This process is generally called <em>interning</em> - and indeed by the looks of <a href="http://pyref.infogami.com/intern" rel="noreferrer">this page</a> it's called interning in Python, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>A side note: it is very important to know the lifetime of objects in Python. Note the following session:</p>
<pre><code>Python 2.6.4 (r264:75706, Dec 26 2009, 01:03:10) 
[GCC 4.3.4] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a="a"
&gt;&gt;&gt; b="b"
&gt;&gt;&gt; print id(a+b), id(b+a)
134898720 134898720
&gt;&gt;&gt; print (a+b) is (b+a)
False
</code></pre>
<p>Your thinking that by printing the IDs of two <em>separate</em> expressions and noting “they are equal ergo the two expressions must be equal/equivalent/the same” is <strong>faulty</strong>. A single line of output does not necessarily imply all of its contents were created and/or co-existed at the same single moment in time.</p>
<p>If you want to know if two objects are the same object, ask Python directly (using the <code>is</code> operator).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>x = 42
y = 42
x == y #True
x is y #True
</code></pre>
<blockquote>
<p>In this interaction, X and Y should be
  == (same value), but not is (same object) because we ran two different
  literal expressions. Because <strong>small
  integers and strings are cached and
  reused</strong>, though, is tells us they
  reference the same single object.</p>
<p>In fact, if you really want to look
  under the hood, you can always ask
  Python how many references there are
  to an object using the <strong>getrefcount</strong>
  function in the standard sys module
  returns the object’s reference count.
  This behavior reflects one of the many
  ways Python optimizes its model for
  execution speed.</p>
</blockquote>
<p><a href="http://oreilly.com/catalog/9781565924642" rel="nofollow noreferrer">Learning Python</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I found a good article to explain the <code>intern</code> behavior of CPython:
<a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">http://guilload.com/python-string-interning/</a></p>
<p>In short:</p>
<ol>
<li>String object in CPython has a flag to indicate that if it's in <code>intern</code>.</li>
<li>Interning string by storing them in a normal dictionary with keys and values are string's pointers. This accepts <code>string</code> class only.</li>
<li>Interning help Python to reduce memory consumption because objects can refer to the same memory address, and speed up comparison speed because it only has to compare the string's pointers.</li>
<li>Python does the <code>intern</code> in the compile process, which means only literal strings (or string can be computed at compile time, like 'hello' + 'world')</li>
<li>For your question: Only strings with length 0 or length 1 or contains ASCII letters only(a-z, A-Z, 0-9) are interned</li>
<li><code>Intern</code> works in Python due to strings are immutable, otherwise does not make sense.</li>
</ol>
<p>This is a really good article, I strongly suggest visiting his site and check for other ones, worth our time.</p>
</div>
<span class="comment-copy">Is there anything of value within my answer that you don't think is covered in yours? If not, I'll delete my answer. If there is, do you want to edit it into yours and <i>then</i> I'll delete my answer?</span>
<span class="comment-copy">+1 for mentioning <code>intern</code>. I had completely forgotten that this function existed. Using <code>joinsplit = [intern(n) for n in "\n".join(names).split()]</code> did the job and lowered memory usage from 4,374,528 to 3,190,783 on my MacBook.</span>
<span class="comment-copy">Lua always has only one instance of any particular string.  It's a very neat system: a bit of overhead on string creation (very small in practice) makes all comparisons for string equality an O(1) pointer comparison.</span>
<span class="comment-copy">@max, you make a factory function that uses a hash table (for speed) to hold immutables (strings, tuples, whatever) and returns a reference to the existing one if any, the newly inserted one if previously absent.</span>
<span class="comment-copy">@max For Python 3, <code>intern</code> is in the <code>sys</code> module: <a href="https://docs.python.org/3/library/sys.html" rel="nofollow noreferrer">docs.python.org/3/library/sys.html</a>. In general, to roll your own, you can establish a data structure that holds objects of the types you like (e.g. a dictionary) and do the same sort of thing that intern does: establish a storage/lookup method which returns keys from the dictionary as references.</span>
<span class="comment-copy">Any idea then why id("ab") == id("a"+"b") ? Would you agree that we just don't know how Python runs Ucaches ?</span>
<span class="comment-copy">For completeness: the expression <code>"a"+"b"</code> is statically turned into the expression <code>"ab"</code>, which is then found to be the same string as the other one.  It all happens at compile-time.</span>
<span class="comment-copy">A bit of explanation as to what's going on here: the <code>print id(a+b), id(b+a)</code> line first concatenates "a" and "b" into a newly-allocated string "ab", then passes that to <code>id</code>, then deallocates it since it's no longer needed. Then "ba" is allocated in the same way, and ends up being allocated at the same location in memory (CPython has a habit of doing this).  "ba" is then passed to <code>id</code>, which returns the same result. With the next line, however, both "ab" and "ba" are kept around to be passed to the <code>is</code> operator, so they are necessarily allocated at different positions.</span>
