<div class="post-text" itemprop="text">
<p>I'm fairly new to Python, so maybe my whole concept of how this should Work is wrong:</p>
<p>I'm building a RFID Reader for time managing purposes. E.g. User logs in with RFID chip -&gt; Timer Starts counting and updating a Google  spreadsheet every Minute. The updating part works fine, but takes a little while. But I want to Check for RFID Logins all the time. Somewhere  I read that Event driven Programming is what I'm looking for.</p>
<p>Currently I'm doing everything in a while true loop, which feels like a hack itself. Can i somehow just execute my code when the RFID reader sends a signal? And then time my update to run every minute or so parallel? I'd like to know whats best practice here.</p>
</div>
<div class="post-text" itemprop="text">
<p>Parallel and Event Driven are basically orthogonal, although it is generally "easy" to parallelize events. I'll first cover the event driven and then the parallelisation, although you may only want to use the later.</p>
<p>The "normal" controlflow in python is iterative.
That means you define the instructions the code should do and then the pc executes these step for step.
There are different ways to organize your code (functional, event driven, object oriented, although I don't want to say that these are absolute categories where you can only do X or Y). Event driven normally means you define events and how to handle them.
There is nothing you could program with event driven which you couldn't program iterativly and vice versa.</p>
<p>Python mainly got support for asyncronuos stuff with version 3.4 when the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer">asyncio</a> library was introduced. 
With 3.5 you also got syntactic sugar <code>await</code> and <code>async</code>. Because you are on 2.7 this is not available for you.
There is a backport from asyncio named <a href="https://github.com/vstinner/trollius" rel="nofollow noreferrer">trollius</a> but this is overkill if you only have a "low amount of events". Also it's not hard to "roll your own basic event loop" (of course asyncio and trollius do much more, but if we are not going to use these features, why bother?).</p>
<p>The basic workflow is waiting for events and then handling them as they occur:</p>
<pre><code>events = []

while waiting_for_events:
    if events:
        event = events.pop()
        handle_event(event)
</code></pre>
<p>You somehow need to know how to differentiate between events and how to handle them.
For a "full featured event loop" you would probably use different classes with inheritance, but lets just use a name for each event.
Also we probably need some kind of <code>data</code> like which RFID we encountered.</p>
<pre><code>from collections import namedtuple
Event = namedtuple("Event", ["name", "data"])
</code></pre>
<p>Then we simply need to map events to how to handle them:</p>
<pre><code>def handle_rfid(data):
    ...

def handle_timer(data):
    ...

event_handler_mapping = {"rfid": handle_rfid, "timer": handle_timer}

def handle_event(event):
    event_handler_mapping[event.name](event.data)
</code></pre>
<p>We still need to generate events, so lets rewrite the eventloop to get events:</p>
<pre><code>timer = 0
current_time = time.perf_counter()

while waiting_for_events:

    rfid = get_rfids()
    if rfid:
        events.append(Event("rfid", rfid))

    if timer &gt; 1:
        events.append(Event("timer", timer))
        timer = 0
    else:
        timer += time.perf_counter() - current_time
        current_time = time.perf_counter()

    if events:
        event = events.pop()
        handle_event(event)
</code></pre>
<p>And now we are "event driven". The nice thing is that we can easily extend this to more events.
The bad thing is that it still does the same thing you probably already have, but it's more complicated.
Also if the event handling needs a lot of time (which seems to be the case with updating the spreadsheet) the other events will not
be generated and handled. This is were parallelism comes into play. </p>
<p>Parallelism basically means we can use multiple cores.
Here we actually only need "concurrency" which means two things can happen at once. 
This is "easier" than true parallelism, we can just switch between different things but still do all the things sequentially. 
In python this basically boils down to multiprocessing (parallelism) and threads ("only" concurrency) (in other programming languages threads actually do parallelism, but in python this is for reasons I don't want to go into not the case). 
The problem with concurrency is always syncronisation. If things can happen at the same time, bad things can happen
if two threads try to change the same variable. In general as long as you only use thread-safe functions to access variables shared between threads, you are safe.</p>
<p>In python threads are created by the <a href="https://docs.python.org/2/library/threading.html#thread-objects" rel="nofollow noreferrer">threading</a> module.
I personally find it hard to understand if you don't already know threads from somewhere else, but the gist is the following:
To run a function in a thread use <code>threading.Thread(target=function)</code> and then <code>thread.start()</code>.
You could use it the following:</p>
<pre><code>def run_in_thread(f, *args, **kwargs):
    thread = Thread(target=f, args=args, kwargs=kwargs)
    thread.start()

def _update_spreadsheet(data):
    # logic here

# when using the event driven approach from above
def handle_timer(data):
    run_in_thread(_update_spreadsheet(data))
</code></pre>
<p>Note that if you access variables from within <code>_update_spreadsheet</code> you need to be carefule to only use thread safe function.
It is "best" to use as little inter-thread communication as possible.
A <a href="https://docs.python.org/2/library/queue.html#module-Queue" rel="nofollow noreferrer">queue</a> is often a good choice.</p>
<p>You can use parallelism/concurrency without the event driven organisation.
Because we already divided the code into event handlers we can call long running event handlers in a seperate thread.</p>
<p>If we have lots of events and event handlers running everything in threads is a bad idea (because thread switching has an overhead).
Thus asyncio (and probably all other event loops) implement some kind of "wait until atleast one event can be handled".
This is most interesting for internet input and output, because these need "a long time".
Often something like <a href="https://docs.python.org/2/library/select.html" rel="nofollow noreferrer">select</a> is used. 
Other events (timers, read from disk, wait for some hardware events, ...) need other mechanisms for "wake me up when something happens". Integrating all of these is one of the features asyncio offer for you.</p>
</div>
<span class="comment-copy">How do you read the RFID information, is that an filedescriptor which can only be read when there is information?</span>
<span class="comment-copy"><a href="https://tutorials-raspberrypi.de/raspberry-pi-rfid-rc522-tueroeffner-nfc/" rel="nofollow noreferrer">tutorials-raspberrypi.de/â€¦</a> this is the module I'm using, sorry its in german. The whole project is done on a raspberry pi</span>
<span class="comment-copy">On which python version are you?</span>
<span class="comment-copy">its python 2.7. ich found some information about the multiprocessing module or the multitasking library by Ran Aroussi, i have a feeling this is what i'm looking for. Unfortunately, i don't really understand the basics of these libraries</span>
<span class="comment-copy">Wow, thank you so much for the detailed Answer! I'm currently at work and will check it out later this week, but it cleared up a lot of questions for me.</span>
