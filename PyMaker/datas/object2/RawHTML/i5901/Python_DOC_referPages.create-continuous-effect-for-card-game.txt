<div class="post-text" itemprop="text">
<p>I was trying to figure out the code of some cards of the popular game Hearthstone and reproducing it with Python. I said Hearthstone, but this can apply basically to every card game, like Magic the Gathering etc...
Lets say I have a creature on the field:</p>
<pre><code>class Creature:
    def __init__(self,manacost,atk,health):
        self.manacost = manacost
        self.atk = atk
        self.health = health

creature = Creature(2,3,2)
field = []
field.append(creature)
</code></pre>
<p>Now, this creature has a continuous effect like "Spells in your hand cost 1 less". That means that WHILE the card is on the field my spells will cost 1 less, and they will return to their original cost as soon the card leaves the field.
Then I wrote:</p>
<pre><code>class Spell:
    def __init__(self,manacost):
        self.manacost = manacost

s1 = Spell(1)
s2 = Spell(2)
s3 = Spell(3)

hand = [s1,s2,s3]

while creature in field == True:
    for spell in hand:
        if spell.manacost &gt;=1:
            spell.manacost -= 1
</code></pre>
<p>At first I expected to end up with all my spells having <code>manacost</code> equal to <code>0</code>.
Instead nothing happened.
Typing </p>
<pre><code>[x.manacost for x in hand]
</code></pre>
<p>I get <code>[1,2,3]</code>, which are the exact same <code>manacost</code>s I set for the spells in the beginning. How can I do?</p>

EDITED POST ANSWERS

<p>In the end here is my code fixed (i had to post it here and not in answers cause i didn't have enough characters in the reply slot.</p>
<pre><code>class Creature:
    def __init__(self,manacost,atk,health):
        self.manacost = manacost
        self.atk = atk
        self.health = health
    def continuous_effect(self):
        global spellcostdifference
        spellcostdifference += 1
    def continuous_effect_cancel(self):
        global spellcostdifference
        spellcostdifference -= 1

class Spell:
    def __init__(self,manacost):
        self.manacost = manacost
    def current_manacost(self):
        global spellcostdifference
        return self.manacost - spellcostdifference if spellcostdifference &lt;= self.manacost else 0

spellcostdifference = 0
creature = Creature(2,3,2)
s1 = Spell(1)
s2 = Spell(2)
s3 = Spell(3)
hand = [s1,s2,s3]

creature.continuous_effect() ## this means the creature is on the field
creature.continuous_effect_cancel() ## this means the creature left the field or got its effect negated
</code></pre>
<p>Thanks a lot for your help guys =)</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does look deceivingly similar to English/pseudocode, but in this case, the meanings differ. As you tagged the question, the construct <code>while &lt;condition&gt;: &lt;looping code&gt;</code> is a loop, which means that when the program reaches this point, it will keep running the wrapped code as long as the condition is true.</p>
<p>In this case, your code would have been an infinite loop if not for a problem with <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">operator precedence</a>. What you wrote was interpreted as:</p>
<pre class="lang-python prettyprint-override"><code>while creature in (field == True):
    for spell in hand:
        if spell.manacost &gt;=1:
            spell.manacost -= 1
</code></pre>
<p>which will never run, instead of</p>
<pre class="lang-python prettyprint-override"><code>while (creature in field) == True:
    for spell in hand:
        if spell.manacost &gt;=1:
            spell.manacost -= 1
</code></pre>
<p>or equivalently</p>
<pre class="lang-python prettyprint-override"><code>while creature in field:
    for spell in hand:
        if spell.manacost &gt;=1:
            spell.manacost -= 1
</code></pre>
<p>which are both infinite loops that will keep running forever.</p>
<hr/>
<p>What you want is instead a <em>function</em> that calculates the current mana cost, based on the original mana cost and current modifiers, like Atto suggested.</p>
<p>One way to do it would be as a new method in the <code>Spell</code> class, like this:</p>
<pre class="lang-python prettyprint-override"><code>class Spell:
    def current_manacost(self, field, creature):
        if creature in field:
            return self.manacost - 1
        else:
            return self.manacost

    def __init__(self,manacost):
        self.manacost = manacost

print([x.current_manacost(field, creature) for x in hand])
</code></pre>
<p><a href="https://tio.run/##jVDLasQwDLz7K3SMwQ0kvhV66if0uIRgEpmYuk6wvLD9@lSOm4TdHrY6CD1mhGaW7zTNQa/r4A0RvEc06RrxVQDHiBb63gWX@r4i9FZ9mWCGmZIy6VNNaHyaZMHmyJB6h8Ab7OU9gKm843w/Ltd4Uwohht9feLS/VbVKq1YK69CPPL90pazNsmAYq50imb3p@VjQ@1PMcI0RQ@r3x4oo2G4oONinImePKbhQgOc2R0RehgfpL9AcIPSEzyniieH/cVlQw@0muWqkoPbo2DLSR6fZnsmEzUBqFLWKdCeEWKILqbrc6j82PRoEdo5wy47kO51c1x8" rel="nofollow noreferrer" title="Python 3 â€“ Try It Online">Try it online!</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You don't want a while loop, this will constantly lower all of the mana costs to 0. You probably want a completely different variable holding the buffs/debuffs.</p>
<p>For example:</p>
<pre><code>spell_manacost_modifier = 0

class Spell:
    def __init__(self,manacost):
        self.manacost = manacost

def calculate_cost(spell):
    final_cost = spell.manacost + spell_manacost_modifier
    return final_cost if final_cost &gt;=0 else 0

s1 = Spell(1)
s2 = Spell(2)
s3 = Spell(3)

hand = [s1,s2,s3]

# this specific if statement should be run when the turn starts, after of course setting spell_manacost_modifier to 0
if creature in field:
    spell_manacost_modifier -= 1

for spell in hand:
    print(calculate_cost(spell))
</code></pre>
<p>Hope this helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>Expressions that evaluate to a boolean do not need to compared to True, or False.</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; 1 in a == True
False
</code></pre>
<p><code>a == True</code> is being evaluated before <code>1 in a</code>. Reference <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">6.16 Operator Precedence</a>.</p>
<pre><code>&gt;&gt;&gt; 1 in a
True
&gt;&gt;&gt; a == True
False

&gt;&gt;&gt; (1 in a) == True
True
&gt;&gt;&gt;
</code></pre>
<p>Change:</p>
<pre><code>while creature in field == True
</code></pre>
<p>to</p>
<pre><code>while creature in field:
</code></pre>
</div>
<span class="comment-copy">The for loop without the while statement works - <code>creature in field == True</code> must be evaluating as False. Print something just before the for loop - did it print?</span>
<span class="comment-copy">For statements the evaluate to a boolean, you do not need to compare to True, or False.  <code>while creature in field == True</code> --&gt; <code>while creature in field:</code>.</span>
<span class="comment-copy">The <code>while creature in field == True:</code> looks like it could cause an infinite loop. There's nothing in the code within it that changes the contents of <code>field</code>, so the condition will either be <code>True</code> and stay that way forever, or the entire thing will be skipped if it's <code>False</code> initially.</span>
<span class="comment-copy">Thank you so much for your time and accuracy explaining everything. I really appreciate. I was able to fix my code, i edited my original post for characters lack reasons. Again, thanks a lot</span>
<span class="comment-copy">Thanks for the fast and helpful response man, it was indeed the right solution, you can check my original post to see how i changed my code.</span>
<span class="comment-copy">Yes, but that change will not make the code work. Instead, it will become an infinite loop that does nothing.</span>
<span class="comment-copy">@Hjulle - OP stated <code>I expected to end up with all my spells having manacost equal to 0</code>.</span>
<span class="comment-copy">@Hjulle - maybe the example is a simplification and at some point the actual code's execution the creature gets eaten.</span>
<span class="comment-copy">Ok, yes, the loop does set the mana costs equal to 0, but after that, it keeps looping infinitely, so there's no way to verify it.</span>
