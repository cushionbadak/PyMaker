<div class="post-text" itemprop="text">
<p>Having looked at this question:</p>
<p><a href="https://stackoverflow.com/questions/47360621/ctypes-how-do-i-define-an-array-of-a-structure-as-a-field-of-another-structure">ctypes: How do I define an array of a structure as a field of another structure?</a></p>
<p>now I'm trying to implement my version of the solution, but the output of <code>len_a</code> in <code>struct Arr</code> is different from how is it set in C. My question is: what is the proper way to set <code>Parse.arr</code> as an array of <code>Arr</code> objects in python (which is originally allocated/set in C)? There is  something obviously incorrect on the line <code>self.arr = cast(byref(self.parse.arr),POINTER(Arr*n)).contents</code> in <strong>pylink.py</strong>.</p>
<p><strong>clink.c</strong></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define SIZE 10

struct Arr {
    int len_a;
};

struct Parse {
    struct Arr* arr;
    int len_arr;
};

struct Parse* C_new_domain(void) {
    int i = 0;
    struct Parse* parse = malloc(sizeof(struct Parse));   
    parse-&gt;arr = malloc(SIZE*sizeof(struct Arr));
    for (i=0 ; i&lt;SIZE ; i++) {
        parse-&gt;arr[i].len_a = i;
    }
    parse-&gt;len_arr = SIZE;
    return parse;
}

void C_end_program(struct Parse* parse) {
    free(parse-&gt;arr);
    free(parse);
    return;
}
</code></pre>
<p><strong>pylink.py</strong></p>
<pre><code>import sys
from ctypes import *
_lib = cdll.LoadLibrary('./libclink.so')

class Arr(Structure):
    def __init__(self, obj, name=""):
        self.obj = obj
    _fields_ = [("len_a", c_int)]


class Parse(Structure):
    def __init__(self, obj, name=""):
        self.obj = obj
    _fields_ = [("arr", POINTER(Arr)),
                ("len_arr", c_int)]

class Domain(object):
    domain = POINTER(Parse)
    parse = None
    arr = None
    _lib.C_new_domain.argtype = None
    _lib.C_new_domain.restype = POINTER(Parse)
    _lib.C_end_program.argtype = POINTER(Parse)
    def __init__(self):
        self.domain = _lib.C_new_domain()
        self.parse = self.domain.contents
        n = self.parse.len_arr
        self.arr = cast(byref(self.parse.arr),POINTER(Arr*n)).contents
    def end(self):
        _lib.C_end_program(self.domain)

if __name__ == '__main__':
    domain = Domain()
    for count, array in enumerate(domain.arr):
        print "[Hoping this is %d] --&gt; array[%d].len_a is %d"%(count, count, array.len_a)
    domain.end()
</code></pre>
<p><strong>Output</strong></p>
<pre class="lang-none prettyprint-override"><code>[Hoping this is 0] --&gt; array[0].len_a is 25023216
[Hoping this is 1] --&gt; array[1].len_a is 0
[Hoping this is 2] --&gt; array[2].len_a is 10
[Hoping this is 3] --&gt; array[3].len_a is 32512
[Hoping this is 4] --&gt; array[4].len_a is 14962
[Hoping this is 5] --&gt; array[5].len_a is 0
[Hoping this is 6] --&gt; array[6].len_a is 33
[Hoping this is 7] --&gt; array[7].len_a is 0
[Hoping this is 8] --&gt; array[8].len_a is 10
[Hoping this is 9] --&gt; array[9].len_a is 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This was solved by replacing this line in <strong>pylink.py</strong></p>
<pre><code>self.arr = cast(byref(self.parse.arr), POINTER(Arr*n)).contents
</code></pre>
<p>with</p>
<pre><code>self.arr = cast(self.parse.arr, POINTER(Arr*n)).contents
</code></pre>
<p>The attribute <code>arr</code> is declared as a <code>POINTER(Arr)</code>, so function <code>byref</code> is not valid here. An important distinction between my implementation the one linked in the question is how the structure arrays are declared. Mine is a pointer, whereas the other uses a zero-sized array. For more info see: <a href="https://docs.python.org/3/library/ctypes.html#ctypes.byref" rel="nofollow noreferrer">https://docs.python.org/3/library/ctypes.html#ctypes.byref</a></p>
</div>
