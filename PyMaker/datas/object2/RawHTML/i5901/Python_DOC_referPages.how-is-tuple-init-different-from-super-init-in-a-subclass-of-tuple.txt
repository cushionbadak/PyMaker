<div class="post-text" itemprop="text">
<p>Please see the following code:</p>
<pre><code>#! /usr/bin/env python3

class MyTupleT(tuple):
    def __init__(self, contents):
        tuple.__init__(contents)
        self.len = len(contents)

class MyTupleS(tuple):
    def __init__(self, contents):
        super().__init__(contents)
        self.len = len(contents)

t = MyTupleT([0, 1, 2])
print(t.len, t)

s = MyTupleS([0, 1, 2])
print(s.len, s)
</code></pre>
<p>The output is:</p>
<pre><code>3 (0, 1, 2)
Traceback (most recent call last):
File "tuple_init.py", line 16, in &lt;module&gt;
    s = MyTupleS([0, 1, 2])
File "tuple_init.py", line 10, in __init__
    super().__init__(contents)
TypeError: object.__init__() takes no parameters
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">The docs say</a>  that <code>super()</code> will:</p>
<blockquote>
<p>Return a proxy object that delegates method calls to a parent or sibling class of type</p>
</blockquote>
<p>IIUC here <code>super()</code> is the same as <code>super(MyTupleS, self)</code>. Now the docs further say that</p>
<blockquote>
<p>The search order is same as that used by <code>getattr()</code> except that the type itself is skipped. The <code>__mro__</code> attribute of the type lists the method resolution search order used by both <code>getattr()</code> and <code>super()</code>.</p>
</blockquote>
<p>Ohkay but then:</p>
<pre><code>$ MyTupleS.__mro__
(__main__.MyTupleS, tuple, object)
</code></pre>
<p>So the <code>super()</code> line should first look within <code>tuple</code> to find <code>__init__</code> and tuple's <code>__init__</code> can certainly take one parameter (other than <code>self</code> of course) and is what is being called by the explicit <code>tuple.__init__</code> line. So why doesn't the <code>super().__init__</code> call work identical to that? Why is it trying to invoke <code>object.__init__</code> and failing?</p>
<p>IIUC one should only need to explicitly specify the superclass when one is worried that the inheritance hierarchy can change in a "dynamic execution environment" (phrase from the docs) and wants the method of a particular superclass to be called. But this error effectively makes it mandatory for the superclass to be specified. Why?</p>
<p>NOTE: This is different from <a href="https://stackoverflow.com/q/27566391/">another similarly titled question</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you call <code>tuple.__init__</code> it returns <code>object.__init__</code> because <code>tuple</code> has no custom <code>__init__</code> method and only inherits it from <code>object</code>. The first argument for <code>object.__init__</code> is <code>self</code> and what <code>object.__init__</code> does is nothing. So when you pass in <code>contents</code> it's interpreted as <code>self</code> and doesn't throw an Exception. However it probably doesn't do what you think it does because <code>tuple.__new__</code> is responsible for setting up a new tuple instance.</p>
<p>If you use <code>super().__init__</code> it also resolves to <code>object.__init__</code> but it already binds the current "self" as first argument. So when you pass <code>contents</code> to this function it's interpreted as additional argument which doesn't exist for <code>object.__init__</code> and therefore throws that Error.</p>
</div>
<span class="comment-copy">Not sure what's wrong with the question to get a downvote?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/10165405/#comment13041331_10165405" title="%23comment13041331_10165405">stackoverflow.com/questions/10165405/#comment13041331_10165405</a> says <code>super()</code> and <code>__init__</code> don't go well together which is surprising because IIUC often one would want to call <code>super()</code> from <code>__init__</code>!</span>
<span class="comment-copy">The first version only <i>appears</i> to work because you've called <code>tuple.__init__()</code> without passing <code>self</code> (well, actually, you've passed the list <code>[0, 1, 2]</code> as <code>self</code>).</span>
<span class="comment-copy">Oh yes when instance methods are called by a class name, we should manually pass <code>self</code>. Thanks for reminding that!</span>
<span class="comment-copy">Downvoting legitimate questions which are receiving legitimate answers discourages non-experts like me from asking on SO for fear of downvote itself! üôÅ</span>
<span class="comment-copy">Hi thanks for this but why should <code>tuple.__init__</code> resolve to <code>object.__init__</code> when tuple has its own <code>__init__</code>?</span>
<span class="comment-copy">@jamadagni It doesn't have a "custom" <code>__init__</code> it just inherits it from <code>object</code>. That was what I meant. :)</span>
<span class="comment-copy">Then something is wrong with PyCharm 2017.1.1 showing me <code>def __init__(self, seq=()): # known special case of tuple.__init__</code> under <code>class tuple(object):</code> of <code>builtins.py</code>. üôÅ Is that only an artificial Py file and really it's all inside the C implementation?</span>
<span class="comment-copy">@jamadagni I only looked at the <a href="https://github.com/python/cpython/blob/master/Objects/tupleobject.c#L840" rel="nofollow noreferrer">source code for tuple and that doesn't define an <code>__init__</code></a>. That means it inherits it from <code>object</code>. But it does have a <code>__new__</code> method (a few lines later, it's called <code>tp_new</code>).</span>
<span class="comment-copy">but then how does the <code>MyTupleT</code> store <code>contents</code> if the call to <code>tuple.__init__</code> isn't doing the lifting? Is it because <code>tuple.__new__</code> is implicitly called with <code>contents</code>?</span>
