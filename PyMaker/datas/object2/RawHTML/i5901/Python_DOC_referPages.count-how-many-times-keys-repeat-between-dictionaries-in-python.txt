<div class="post-text" itemprop="text">
<p>How do I check to see how many times the keys in one <code>dict1</code> exist in <code>dict2</code>. If the keys of <code>dict1</code> exist in <code>dict2</code> a variable, <code>val</code>, with an initial value of <code>4</code> should be subtracted based on how many times the keys are found. </p>
<p>For example <code>dict1</code> looks like this </p>
<pre><code>print dict1
{(2, 0): 3, (3, 1): 0, (1, 1): 2, (2, 2): 1} 
</code></pre>
<p>and <code>dict2</code> looks like this </p>
<pre><code>print `dict2`
{(2, 0): 323, (3, 1): 32, (10, 10): 21, (20, 2): 100} 
</code></pre>
<p>Since there are two repeat keys between the dicts,<code>val</code> should be equal to <code>2</code>.</p>
<p>if <code>dict2</code> looks identical to <code>dict1</code>, then <code>val</code> should be <code>0</code>. </p>
<p>Also, <code>dict1</code> will always be the same size, but <code>dict2</code> can get quite large, so a fast lookup method would be ideal. Lastly, the values of dicts here don't really mean anything. </p>
</div>
<div class="post-text" itemprop="text">
<p>Using set intersection:</p>
<pre><code>d1 = {(2, 0): 3, (3, 1): 0, (1, 1): 2, (2, 2): 1} 
d2 = {(2, 0): 323, (3, 1): 32, (10, 10): 21, (20, 2): 100} 

sd1 = set(d1.keys())
sd2 = set(d2.keys())
len(sd1.intersection(sd2))
</code></pre>
<p>Edit:
Because key views are already set-like, so you can do <code>d1.keys() &amp; d2.keys()</code> directly. Note that <code>.keys()</code> is a very cheap call because it simply provides an alternative interface to the existing dict structure (Credits to @PM2RING in the comments).</p>
</div>
<div class="post-text" itemprop="text">
<p>Since dict_keys are <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer">already set-like</a>, you can simply use</p>
<pre><code>len(dict1.keys() &amp; dict2.keys())
</code></pre>
<p>That is for Python 3. In Python 2, the equivalent view object is <a href="https://docs.python.org/2.7/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer"><code>dict.viewkeys()</code></a>, which you'd use similarly. </p>
<pre><code>len(dict1.viewkeys() &amp; dict2.viewkeys())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make sets out of the list of keys in each dict.
Find the intersection and union of those sets.
<code>union - intersection</code> gives you the set of differences.
If that's 0, then you return 0;
otherwise, return the size of the intersection.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will work in Python 2 and 3: <code>len(set(dict1).intersection(dict2))</code> </p>
<pre><code>In [1]: dict1 = {(2, 0): 3, (3, 1): 0, (1, 1): 2, (2, 2): 1}

In [2]: dict2 = {(2, 0): 323, (3, 1): 32, (10, 10): 21, (20, 2): 100}

In [3]: len(set(dict1).intersection(dict2))
Out[3]: 2
</code></pre>
</div>
<span class="comment-copy"><code>len([k for k in dict1 if k in dict2])</code></span>
<span class="comment-copy">@alfasin Why build a list just to get its length? <code>sum(1 for k in dict1 if k in dict2)</code> is more efficient. However, for this task set intersection is faster.</span>
<span class="comment-copy">@PM2Ring ha, good point :)</span>
<span class="comment-copy">key views are already set-like, so you can do <code>d1.keys() &amp; d2.keys() </code></span>
<span class="comment-copy">Note that <code>.keys()</code> is a very cheap call because it just provides an alternative interface to the existing dict structure.</span>
