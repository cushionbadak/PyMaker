<div class="post-text" itemprop="text">
<p>Function call will always yield some overhead. But why the code below shows that non-function call is slower.</p>
<h2>Code:</h2>
<pre><code>import time

def s():
    for i in range(1000000000):
        1 + 1

t = time.time()
s()
print("Function call: " + str(time.time() - t))

t = time.time()
for i in range(1000000000):
    1 + 1
print("Non function call: " + str(time.time() - t))
</code></pre>
<h2>Output:</h2>
<pre><code>Function call: 38.39736223220825
Non function call: 60.33238506317139
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might be thinking that since the loop only does <code>1 + 1</code>, there shouldn't be much difference. <strong>But</strong>, there's a 'hidden' <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">assignment</a> here that's commonly forgotten: to the loop variable <code>i</code> in your <code>for</code> loop. This is the cause of the slowdown.</p>
<p>In functions, this is done with <a href="https://docs.python.org/3/library/dis.html#opcode-STORE_FAST" rel="nofollow noreferrer"><code>STORE_FAST</code></a>. In the top level, it's done with <a href="https://docs.python.org/3/library/dis.html#opcode-STORE_NAME" rel="nofollow noreferrer"><code>STORE_NAME</code></a>. The first is faster than the other and, in a loop that runs <code>1000000000</code> times, this difference is shown quite clearly.</p>
<p>Remember that the function invocation only <em>happens once</em>. So its overhead doesn't really contribute in this specific scenario.</p>
<p>Besides that, all other steps happen once and are pretty much the same. A range is created and its iterator grabbed and the constant <code>2</code> is loaded for every iteration.</p>
<hr/>
<p>You can always use the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a> to examine the CPython bytecode that is produced for each of these, as @Moses indicated in a comment. For the function <code>s</code>, you have:</p>
<pre><code>dis.dis(s)
#       snipped for brevity
        &gt;&gt;   10 FOR_ITER                 8 (to 20)
             12 STORE_FAST               0 (i)

  3          14 LOAD_CONST               3 (2)
             16 POP_TOP
             18 JUMP_ABSOLUTE           10
</code></pre>
<p>While for the top-level version of the loop:</p>
<pre><code>dis('for i in range(1000000000): 1+1')
#       snipped for brevity
        &gt;&gt;   10 FOR_ITER                 8 (to 20)
             12 STORE_NAME               1 (i)
             14 LOAD_CONST               3 (2)
             16 POP_TOP
             18 JUMP_ABSOLUTE           10
</code></pre>
<p>The main difference between these is in the storing of the iteration value <code>i</code>. In functions, it's simply more efficient.</p>
<hr/>
<p>To address @Reblochon Masque (now deleted) answer that seems to show no discrepancy between these two when timed with <code>timeit</code> in IPython cells.</p>
<p><code>timeit</code> times things by creating a little-function (<a href="https://github.com/python/cpython/blob/3.6/Lib/timeit.py#L70" rel="nofollow noreferrer">named <code>inner</code></a>) that stores the statements you pass and executes them for a given number of executions. You can see this if you create a <code>Timer</code> object and peek at its <code>src</code> attribute (this isn't documented so don't expect it to always be there :-):</p>
<pre><code>from timeit import Timer

t = Timer('for i in range(10000): 1 + 1')
print(t.src)
</code></pre>
<p>This contains the little function that is essentially timed. The previous <code>print</code> call prints:</p>
<pre><code>def inner(_it, _timer):
    pass
    _t0 = _timer()
    for _i in _it:
        for i in range(10000): 1 + 1
    _t1 = _timer()
    return _t1 - _t0
</code></pre>
<p>So, in effect, by using <code>timeit</code> you have altered the way the look-up for <code>i</code> is performed, since it is inside a function it's also done with <code>STORE_FAST</code>. Easy pitfall! </p>
<p><sup><sup>(and if you don't believe me, see <code>dis.dis(compile(t.src, '', 'exec').co_consts[0])</code>)</sup></sup></p>
</div>
<span class="comment-copy">related: <a href="https://stackoverflow.com/q/12590058/4279">Python - performance with global variables vs local</a></span>
<span class="comment-copy">can you add some reference to your answer?</span>
<span class="comment-copy">@AmitTripathi <code>dis.dis(s)</code> and <code>dis.dis('for i in range(1000000000): 1 + 1')</code> is all you need, in Python 3.</span>
