<div class="post-text" itemprop="text">
<p>Given a string (e.g.,  <em>ja<strong>ghi</strong>uu<strong>abc</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>There's a nice example in the <a href="https://docs.python.org/2.6/library/itertools.html#examples" rel="nofollow noreferrer">Python 2.6 <code>itertools</code> docs</a> that shows how to find consecutive sequences. To quote:</p>
<blockquote>
<p>Find runs of consecutive numbers using <code>groupby</code>.  The key to the
  solution is differencing with a range so that consecutive numbers all
  appear in same group.</p>
</blockquote>
<p>For some strange reason, that example is not in the later versions of the docs. That code works for sequences of numbers, the code below shows how to adapt it to work on letters.</p>
<pre><code>from itertools import groupby

s = 'jaghiuuabc'

def keyfunc(t):
    ''' Subtract the character's index in the string 
        from its Unicode codepoint number. 
    ''' 
    i, c = t
    return ord(c) - i

a = []
for k, g in groupby(enumerate(s), key=keyfunc):
    # Extract the chars from the (index, char) tuples in the group
    seq = [t[1] for t in g]
    if len(seq) &gt; 1:
        a.append(''.join(seq))

print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['ghi', 'abc']
</code></pre>
<hr/>
<h3>How it works</h3>
<p>The heart of this code is </p>
<pre><code>groupby(enumerate(s), key=keyfunc)
</code></pre>
<p><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate(s)</code></a> generates tuples containing the index number and character for each character in <code>s</code>. For example:</p>
<pre><code>s = 'ABCEF'
for t in enumerate(s):
    print(t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>(0, 'A')
(1, 'B')
(2, 'C')
(3, 'E')
(4, 'F')
</code></pre>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> takes items from a sequence or iterator and gathers adjacent equal items together into groups. By default, it simply compares the values of the items to see if they're equal. But you can also give it a key function. When you do that, it passes each item to the key function and uses the result returned by that key function for its equality test.</p>
<p>Here's a simple example. First, we define a function <code>div_by_10</code> that divides a number by 10, using integer division. This basically gets rid of the last digit in the number.</p>
<pre><code>def div_by_10(n):
    return n // 10

a = [2, 5, 10, 13, 17, 21, 22, 29, 33, 35]
b = [div_by_10(u) for u in a]
print(a)
print(b)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[2, 5, 10, 13, 17, 21, 22, 29, 33, 35]
[0, 0, 1, 1, 1, 2, 2, 2, 3, 3]
</code></pre>
<p>So if we use <code>div_by_10</code> as the key function to <code>groupby</code> it will ignore the last digit in each number and thus it will group adjacent numbers together if they only differ in the last digit.</p>
<pre><code>from itertools import groupby

def div_by_10(n):
    return n // 10

a = [2, 5, 10, 13, 17, 21, 22, 29, 33, 35]
print(a)
for key, group in groupby(a, key=div_by_10):
    print(key, list(group))        
</code></pre>
<p><strong>output</strong></p>
<pre><code>[2, 5, 10, 13, 17, 21, 22, 29, 33, 35]
0 [2, 5]
1 [10, 13, 17]
2 [21, 22, 29]
3 [33, 35]
</code></pre>
<p>My <code>keyfunc</code> receives a (index_number, character) tuple and subtracts that index_number from the character's code number and returns the result. Let's see what that does with my earlier example of <code>'ABCEF'</code>:</p>
<pre><code>def keyfunc(t):
    i, c = t
    return ord(c) - i

for t in enumerate('ABCEF'):
    print(t, keyfunc(t))
</code></pre>
<p><strong>output</strong></p>
<pre><code>(0, 'A') 65
(1, 'B') 65
(2, 'C') 65
(3, 'E') 66
(4, 'F') 66
</code></pre>
<p>The code number for 'A' is 65, the code number for 'B' is 66, the code number for 'C' is 67, etc. So when we subtract the index from the code number for each of 'A', 'B', and 'C' we get 65. But we skipped over 'D' so when we do the subtractions for 'E' and 'F' we get 66. And that's how <code>groupby</code> can put 'A', 'B', &amp; 'C' in one group and 'E' &amp; 'F' in the next group.</p>
<p>This can be tricky stuff. Don't expect to understand it all completely straight away. But if you do some experiments yourself I'm sure it will gradually sink in. ;)</p>
<hr/>
<p>Just for fun, here's the unreadable multiply-nested list comprehension version of that code. ;)</p>
<pre><code>print([z for _, g in groupby(enumerate(s),lambda t:ord(t[1])-t[0])for z in[''.join([*zip(*g)][1])]if len(z)&gt;1])
</code></pre>
<hr/>
<p>Here's another version which was inspired by <a href="https://stackoverflow.com/a/47493914/4014959">Amit Tripathi's answer</a>. This one doesn't use any imports because it does the grouping manually. <code>prev</code> contains the codepoint number of the previous character. We initialize <code>prev</code> to -2 so that the first time the <code>if i != prev + 1</code> test is performed it's guaranteed to be true because the smallest possible value of <code>ord(ch)</code> is zero, so a new empty list will be added to <code>groups</code>.</p>
<pre><code>s = 'jaghiuuabcxyzq'

prev, groups = -2, []
for ch in s:
    i = ord(ch)
    if i != prev + 1:
        groups.append([])
    groups[-1].append(ch)
    prev = i

print(groups)
a = [''.join(u) for u in groups if len(u) &gt; 1]
print(a)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[['j'], ['a'], ['g', 'h', 'i'], ['u'], ['u'], ['a', 'b', 'c'], ['x', 'y', 'z'], ['q']]
['ghi', 'abc', 'xyz']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be done easily with pure Python</p>
<p>Python 3(should work with Python 2 also) implementation. A simple 8 liner</p>
<pre><code>s = 'jaghiuuabc'

prev, counter, dct = None, 0, dict()
for i in s:
    if prev is not None:
        if not chr(ord(prev) + 1) == i:
            counter += 1
    prev = i
    dct.setdefault(counter, []).append(prev)

[''.join(dct[d]) for d in dct if len(dct[d]) &gt; 1]

Out[51]: ['ghi', 'abc']
</code></pre>
<p><code>ord</code> converts char to equivalent ASCII number</p>
<p><code>chr</code> converts a number to equivalent ASCII char</p>
<p><code>setdefault</code> set default value as list if a key doesn't exists</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What about some recursion without any external module ?</p>
</blockquote>
<pre><code>a='jaghiuuabc'


import string
alpha = list(string.ascii_lowercase)
def trech(string_1,chr_list,new_string):
    final_list=[]
    if not string_1:
        return 0
    else:

        for chunk in range(0,len(string_1),chr_list):
            for sub_chunk in range(2,len(string_1)+1):
                if string_1[chunk:chunk + sub_chunk] in ["".join(alpha[i:i + sub_chunk]) for i in range(0, len(alpha), 1)]:
                    final_list.append(string_1[chunk:chunk + sub_chunk])

    if final_list:
        print(final_list)

    return trech(string_1[1:],chr_list-1,new_string)

print(trech(a,len(a),alpha))
</code></pre>
<p>output:</p>
<pre><code>['gh', 'ghi']
['hi']
['ab', 'abc']
['bc']
0
</code></pre>
</div>
<span class="comment-copy">Do you mean that you want to find a part of the string where the letters are all next to each other in the alphabet?</span>
<span class="comment-copy">I think what OP wants is just to remove non-alphabetic characters from a string</span>
<span class="comment-copy">Do you mean you want the output for that data to be <code>'ghiabc'</code>? Or maybe <code>['ghi', 'abc']</code>?</span>
<span class="comment-copy">a list. Thank you!</span>
<span class="comment-copy">not getting what keyfunc do?</span>
<span class="comment-copy">@JoydeepRoychowdhury I'll add some more explanation to my answer. I admit it might not be easy to understand my code if you aren't familiar with <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>; you also need to know what <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> does. There are some good <code>groupby</code> examples <a href="https://stackoverflow.com/questions/41411492/what-is-itertools-groupby-used-for">here</a>.</span>
<span class="comment-copy">@JoydeepRoychowdhury Please see my updated answer. I hope it makes it a little easier to understand what's going on.</span>
<span class="comment-copy">now i know what enumerate and groupby does thanks once again</span>
<span class="comment-copy">hi - @PM 2Ring, can you please suggest me similar type of question?</span>
<span class="comment-copy">Not bad. :) I often use <code>dct.setdefault(key,  []).append(value)</code> myself, but we don't really need a <code>dict</code> here because the keys are guaranteed to be in order, so we can just use a list. And by a slight change in the logic we can reduce the number of <code>if</code> tests to 1. Please see the end of my answer for a variation of your code.</span>
