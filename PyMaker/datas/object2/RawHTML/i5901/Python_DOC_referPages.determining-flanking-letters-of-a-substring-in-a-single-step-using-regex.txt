<div class="post-text" itemprop="text">
<p>I'm trying to cut up a list of letters using <code>cutters</code> where the corresponding position of the letter in <code>cutters</code> cuts at <code>cutspots</code> in such a way that 'K' (<code>cutspots</code> 1), cuts after a letter when read left-to-right, and 'S' (<code>cutspots</code> 0) cuts before a letter.</p>
<p>I currently need to use a list comprehension inside another list comprehension to confirm this, but I'd like to lower this to a single list comprehension while returning the location of the word that is found to be successfully cut by this pattern in <code>beginning</code> and <code>end</code>.</p>
<p>Is there a more clever way to go about doing this?</p>
<pre><code>import re

letterlist = 'GIURELABGIRUGHAWUWORDHGUOIHRUANOTHERKHVUHREIAVHRELGBEIUVIREUVBKWORDSGOREGK'

cutters = ['K', 'S']
cutspots = [1, 0]

wordlist = 'WORD'

end = [[m.start() for m in re.finditer(wordlist, letterlist) if letterlist[m.start()+len(wordlist)-abs(0-cutspots[position])] is cutters[position]] for position in range(len(cutters))]

beginning = [[m.start() for m in re.finditer(wordlist, letterlist) if letterlist[m.start()-cutspots[position]] is cutters[position]] for position in range(len(cutters))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Code</h2>
<p><a href="https://regex101.com/r/50muEG/1" rel="nofollow noreferrer">See regex in use here</a></p>
<pre><code>(?&lt;=K)(?=WORDS)
</code></pre>
<h3>Usage</h3>
<p><a href="https://ideone.com/dKfT8W" rel="nofollow noreferrer">See code in use here</a></p>
<pre><code>import re

p = re.compile(r"(?&lt;=K)(?=WORDS)")
s = "GIURELABGIRUGHAWUWORDHGUOIHRUANOTHERKHVUHREIAVHRELGBEIUVIREUVBKWORDSGOREGK"

for m in re.finditer(p,s):
    print m.span()
</code></pre>
<h3>Usage 2</h3>
<p>This version allows you to change the regex with variables.</p>
<pre><code>import re

c = ["K", "S"]
w = "WORD"
p = re.compile(r"(?&lt;=" + re.escape(c[0]) + r")(?=" + re.escape(w) + re.escape(c[1]) + r")")
s = "GIURELABGIRUGHAWUWORDHGUOIHRUANOTHERKHVUHREIAVHRELGBEIUVIREUVBKWORDSGOREGK"

for m in re.finditer(p,s):
    print m.span()
</code></pre>
<hr/>
<h2>Explanation</h2>
<ul>
<li><code>(?&lt;=K)</code> Positive lookbehind ensuring what precedes is <code>K</code> literally</li>
<li><code>(?=WORDS)</code> Positive lookahead ensuring what follows is <code>WORD</code> and <code>S</code> (<code>WORDS</code>) literally</li>
</ul>
<p>Python has the method <a href="https://docs.python.org/3/library/re.html#re.match.span" rel="nofollow noreferrer"><code>.span()</code></a> that returns the position of the regex match.</p>
</div>
<span class="comment-copy">please include a clear expected input and output</span>
<span class="comment-copy">So this currently has the expected input and output, but I'd like to have the same output with less code if possible. The current output is the location of the first letter of the substring location where the cut is successful.</span>
<span class="comment-copy">So this is pretty close but I want it to find 'WORD' after a 'K' and before an 'S'. I wasn't aware of that tool, thanks for sharing. How might I put the "before S" part in there?</span>
<span class="comment-copy">@NameyMcNamo this has <code>S</code> after the word. You would simply construct the regex by using <code>re.escape()</code> on the cutters input.</span>
<span class="comment-copy">So for my actual code I would need it to be more flexible, I iterate through different letters that can cut either before or after depending on the letter. I'd have a harder time concatenating a letter at the end if it cut before a letter. I currently use the cutspots to differentiate between the two.</span>
<span class="comment-copy">@NameyMcNamo see my edit (usage 2)</span>
<span class="comment-copy">Excellent, thank you very much :)</span>
