<div class="post-text" itemprop="text">
<p>In Python 3, I should be able to use <code>super()</code> in a class method as a substitute for the parent class:</p>
<pre><code>class demodict(OrderedDict):

    def __setitem__(self, key, val):
        print(key)
        super().__setitem__(self, key, val)
</code></pre>
<p>The above behaves as expected when I instantiate a <code>demodict()</code> and add values to it. But if I use it as the data type for a <code>ConfigParser</code> object, something goes wrong:</p>
<pre><code>&gt;&gt;&gt; Config = configparser.ConfigParser(dict_type=demodict)
Traceback (most recent call last):
  File "&lt;pyshell#15&gt;", line 1, in &lt;module&gt;
    conf = configparser.ConfigParser(dict_type=demodict)
  File ".../anaconda/lib/python3.4/configparser.py", line 588, in __init__
    self._proxies[default_section] = SectionProxy(self, default_section)
  File "&lt;pyshell#14&gt;", line 5, in __setitem__
    super().__setitem__(self, key, val)
  File ".../anaconda/lib/python3.4/collections/__init__.py", line 67, in __setitem__
    if key not in self:
TypeError: unhashable type: 'demodict'
</code></pre>
<p>If I replace <code>OrderedDict</code> with plain <code>dict</code> as the parent class, the error gets even weirder:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;pyshell#9&gt;", line 1, in &lt;module&gt;
    conf = configparser.ConfigParser(dict_type=demodict)
  File ".../anaconda/lib/python3.4/configparser.py", line 588, in __init__
    self._proxies[default_section] = SectionProxy(self, default_section)
  File "&lt;pyshell#7&gt;", line 6, in __setitem__
    super().__setitem__(self, key, val)
TypeError:  expected 2 arguments, got 3
</code></pre>
<p>If instead of <code>super()</code> I write <code>OrderedDict</code> or <code>dict</code> explicitly, I can use <code>demodict</code> as the <code>dict_type</code> with no problems. Can someone explain what is going on? (Since there is an easy work-around, I'm more curious about the cause than about the solution...)</p>
</div>
<div class="post-text" itemprop="text">
<p>Method attribute access on a <code>super()</code> proxy object, like ordinary method binding, just passes the object implicitly as the first positional argument.  </p>
<p>Change this:</p>
<pre><code>super().__setitem__(self, key, val)
</code></pre>
<p>To this:</p>
<pre><code>super().__setitem__(key, val)
</code></pre>
<p>Note that <a href="https://stackoverflow.com/q/39478747/674039"><strong><code>OrderedDict</code> doesn't use cooperative inheritance</strong></a>, i.e. it just calls <code>dict.__setitem__</code> directly.  Ideally, every object in the inheritance chain should be using <code>super</code>.  Please proceed with caution if you plan to use <code>OrderedDict</code> with a multiple-inheritance structure.  </p>
</div>
<span class="comment-copy"><code>super().__setitem__</code> passes <code>self</code> as the first argument automatically. It works if you just do <code>super().__setitem__(key, val)</code>.</span>
<span class="comment-copy">Indeed! That solved the problem. Duh, but also, how strange. I should have read the docs on <code>super()</code> more carefully. Would you write it up as an answer with an explanation?</span>
<span class="comment-copy">I can spare the points, but I'm curious why someone thinks this is a bad question.</span>
<span class="comment-copy">@alexis  You answered your own question with "<i>I should have read the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">docs on super()</a> more carefully.</i>"  RTFM questions seems to get downvoted these days...</span>
<span class="comment-copy">I was not the down-voter, so this is just a guess as to why (I think the question is fine and will be good for future users with possibly a change in title): the error message "expected 2 arguments, got 3" in the context of class methods is usually indicative of some error with <code>self</code>; perhaps the down-voter felt there was not enough research in the question.</span>
<span class="comment-copy">"Note that it is not the self that is passed, as vaultah's comment says, but a proxy object" - what are you talking about?</span>
<span class="comment-copy">I mean <code>self</code> will be a <code>demodict</code> instance, and <code>super()</code> will be a <code>super</code> instance.</span>
<span class="comment-copy"><code>super()</code> will be a <code>super</code> instance, but the <code>super()</code> object isn't what'll be passed into the superclass <code>__setitem__</code> method as <code>self</code>.</span>
<span class="comment-copy">I don't know how to explain it.  The fact that the proxy object is the guy responsible for keeping track of the position in the mro, not the instance itself.  If you have a better way, please edit it into my question directly.</span>
