<div class="post-text" itemprop="text">
<p>I was learning the itertools through python docs:</p>
<p><a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html</a></p>
<p>And at the very end there are recipes that use itertools commands to do simple things, one of them, the consume(), I don't understand it at all:</p>
<pre><code>from itertools import *
def consume(iterator, n):
    """"Advance the iterator n-steps ahead. If n is none, consume 
        entirely."""
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>first of all, this function claims argument to be an iterator, but I found that an iterable will do as well. I think there is a difference between iterable and iterator, right? Because <code>islice()</code> needs no iterator, an iterable could be used</p>
<p>Secondly, When I tried it:</p>
<pre><code>aa = iter([1,2,3,4,5])
print(consume(aa, 2))
</code></pre>
<p>it give me <code>None</code>, because <code>islice(iterator, n, n)</code> will always be <code>None</code> no matter what, as (n, n) has no range to be sliced.</p>
<p>And of course if <code>n</code> is <code>None</code>, then I will definitely get <code>None</code>
So it seems like no matter what I do here, I get <code>None</code> as the output anyway, what is the purpose of this function at all?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>consume</code> is not supposed to return anything useful.  Like the docs says, its purpose is to advance the existing iterator.  If you look at <code>aa</code> after your example, you will see it has been advanced:</p>
<pre><code>&gt;&gt;&gt; aa = iter([1,2,3,4,5])
... print(consume(aa, 2))
None
&gt;&gt;&gt; next(aa)
3
</code></pre>
<p>Because the use of <code>consume</code> is in its side effect, you can use it on an a "re-iterable" object, but doing so will be useless.  What happens is that <code>islice</code> will create an iterator over the object, and advance that iterator, but that won't affect subsequent iteration over the iterable, because a new iterator will be created:</p>
<pre><code># consuming an iterator
aa = iter([1,2,3,4,5])
consume(aa, 2)
print(list(aa))
# [3, 4, 5]

# "consuming" an iterable
aa = [1,2,3,4,5]
consume(aa, 2)
print(list(aa))
# [1, 2, 3, 4, 5]
</code></pre>
<p>In the latter case, all you consumed was a temporary iterator that was created inside <code>consume</code> itself but not returned, so it had no observable effect.</p>
<p>(I use the term "re-iterable" to refer to iterable objects which generate a "fresh" iterator over some stable base data each time <code>iter</code> is called.  Lists, for instance, are re-iterables.  Every re-iterable object is iterable, but you can write an iterable object which is not re-iterable.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterating through a list is kind of pointless unless you do something with its elements, but advancing through an iterator can execute code; for example, you might be iterating through the values returned by a function with side effects. <code>consume()</code> walks through several elements and throws them away. The general idea (if you don't consume everything) is that it works like <code>seek()</code> in a file handle: When you try to get something out of the iterator afterwards, you will be at a different position.</p>
</div>
<span class="comment-copy"><i>"but I found that an iterable will do as well"</i> - Why does that surprise you? It's <i>meant</i> to be used with an iterator, but an iterable doesn't break it either. <i>"islice(iterator, n, n) will always be None"</i> - It will be an empty iterator, that is different from <code>None</code>. <i>"it give me None"</i> - Because the function doesn't return <i>anything</i>. <i>"what is the purpose of this function at all?"</i> - Read the docstring.</span>
<span class="comment-copy">If it always returns <code>None</code>, that strongly suggests it's not being used for its return value, right? Think about the side effects.</span>
<span class="comment-copy">ah!! Got it!! That is what it means! They really should have put an example there so beginners like me can understand...</span>
<span class="comment-copy">Thanks for the additional information. This is the first time I saw a function that is used for its side effect. Very educating, and enlightening.</span>
<span class="comment-copy">@Code_Control_jxie0755 I doubt this is the first function you've seen used for it's side effect. <code>print</code> is a function that is used for it's side-effect, and of course, many list-methods do just that, e.g. <code>.append</code>. Note, both <code>.append</code> and <code>print</code> return <code>None</code></span>
<span class="comment-copy">I guess that is why the function calls for an iterator now, because when I use the next() on aa after consuming the first 2 elements, it needs to be an iterator other than an iterable.</span>
