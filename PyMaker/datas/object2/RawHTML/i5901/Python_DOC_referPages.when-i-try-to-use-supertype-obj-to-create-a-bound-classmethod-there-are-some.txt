<div class="post-text" itemprop="text">
<p>I typed code like this</p>
<pre><code>class A:
    @classmethod
    def m1(cls):
        pass

class B(A):
    @classmethod
    def m1(cls):
        print(super(B, B).m1)
</code></pre>
<p>Then I called B.m1 and the result was</p>
<pre><code>&lt;bound method A.m1 of &lt;class '__main__.B'&gt;&gt;
</code></pre>
<p>According to the documentation of <code>super</code>, if the second argument is used, <code>super</code> will return a bound object, and the code show it works.</p>
<p>I know that method <code>__new__</code> is also a classmethod, so I type a test code like this</p>
<pre><code>class A(object):
    def __new__(cls):
        print(super(A, A).__new__)
</code></pre>
<p>I had thought that it would be same as the former one. But the result confuses me:</p>
<pre><code>&lt;built-in method __new__ of type object at 0x103e33cf0&gt;
</code></pre>
<p>Then I turned to method <code>__init__</code> like this:</p>
<pre><code>class A(object):
    def __init__(self):
        print(super(A, self).__init__)
</code></pre>
<p>The result was</p>
<pre><code>&lt;method-wrapper '__init__' of A object at 0x104f59da0&gt;
</code></pre>
<p>which is different from a bound object of an instance.</p>
<pre><code>class A:
    def m1(self):
        pass

class B(A):
    def m1(self):
        print(super(B, self).m1)
</code></pre>
<p>The result is</p>
<pre><code>&lt;bound method A.m1 of &lt;__main__.B object at 0x104f59da0&gt;&gt;
</code></pre>
<p>So I wonder that why the result is different between built-in object and custom-defined object?</p>
</div>
<div class="post-text" itemprop="text">
<p>Naming. Nothing more. You are dealing with methods (descriptors) defined in C code versus methods defined in Python code. </p>
<p>There is no <em>functional</em> difference, there is really no need to worry about what amounts to implementation differences.</p>
</div>
<span class="comment-copy">Note: <code>__new__</code> is a <b>static method</b>, not a class method. See the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">reference documentation</a>: <i><code>__new__()</code> is a static method (special-cased so you need not declare it as such)</i></span>
<span class="comment-copy">I found that if I try to use super(B, B).m1() without passing cls to m1, it works, but if I try to use super(A, A).__new__(), it doesn't work and I must use super(A,A).__new__(A) or just super().__new__(A).</span>
<span class="comment-copy">@user9010294: <code>__new__</code> is <i>treated</i> as a class method but is not actually bound as such. It is instead a static method and you need to pass in the class manually.</span>
<span class="comment-copy">I get it. Thank you for help</span>
