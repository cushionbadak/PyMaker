<div class="post-text" itemprop="text">
<p>I can't pass a dict of dict between processes with multiprocessing in Python2.7</p>
<pre><code>from multiprocessing import Process, Manager

class TestProcess(Process):
    def __init__(self, d, w):
        super(TestProcess, self).__init__()
        self.daemon = True
        self.d = d
        self.w = w

    def run(self):
        self.d['a'][self.w] = self.w


class Test(object):
    def __init__(self):
        manager = Manager()
        self.d = manager.dict()
        self.d['a'] = {}

        p = TestProcess(d=self.d, w=1)
        p.start()
        p.join()

        p = TestProcess(d=self.d, w=2)
        p.start()
        p.join()

    def show(self):
        print(self.d)

if __name__ == '__main__':

    t=Test()
    t.show()
</code></pre>
<p>Expecting result: {'a': {1:1, 2:2}}, but got {'a': {}} instead</p>
</div>
<div class="post-text" itemprop="text">
<p>Make the nested dictionary a proxy object too:</p>
<pre><code>manager = Manager()
self.d = manager.dict()
self.d['a'] = manager.dict() 
</code></pre>
<p>or retrieve <code>self.d['a']</code>, mutate that object, and set it back:</p>
<pre><code>a = self.d['a']
a[self.w] = self.w
self.d['a'] = a
</code></pre>
<p><code>self.d</code> is not a regular dictionary; it wraps a dict to track mutations to the object itself, but your <em>value</em>, associated with the key <code>'a'</code> is not such an object, so mutations to that object are not detected, and the changes are not communicated with the parent process.</p>
<p>If you were to use <code>self.d['a'][self.w] = self.w</code>, then <code>self.d['a'] = self.d['a']</code> the latter would <em>retrieve the still empty dictionary from the parent process</em> and set <code>self.d['a']</code> back to that empty object; you <em>have</em> to create a local reference to the remote mutable nested dictionary first to ensure you correctly tell the parent process to correctly set it.</p>
<p>From the <a href="https://docs.python.org/3/library/multiprocessing.html#proxy-objects" rel="nofollow noreferrer"><em>Proxy Objects</em> section</a> of the documentation:</p>
<blockquote>
<p>If standard (non-proxy) list or dict objects are contained in a referent, modifications to those mutable values will not be propagated through the manager because the proxy has no way of knowing when the values contained within are modified. However, storing a value in a container proxy (which triggers a <code>__setitem__</code> on the proxy object) does propagate through the manager and so to effectively modify such an item, one could re-assign the modified value to the container proxy:</p>
<pre><code># create a list proxy and append a mutable object (a dictionary)
lproxy = manager.list()
lproxy.append({})
# now mutate the dictionary
d = lproxy[0]
d['a'] = 1
d['b'] = 2
# at this point, the changes to d are not yet synced, but by
# updating the dictionary, the proxy is notified of the change
lproxy[0] = d
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Using self.d['a'] = self.d['a'] in the run method doesn't change anything. But using a nested dict self.d['a']=manager.dict(), and in the run d = self.d['a']         d[self.w] = self.w         self.d['a'] = d make the trick.</span>
<span class="comment-copy">@LionelRoubeyrie: you need to do the assignment <i>after</i> mutating <code>self.d['a'][self.w]</code>.</span>
<span class="comment-copy">Yes I did at the end of the run</span>
<span class="comment-copy">@LionelRoubeyrie: figured out the sequence of events and updated. <code>self.d['a'] = self.d['a']</code> first retrieves the still empty dictionary from the parent process; I didn't quite realise to what extend <code>dict.__getitem__</code> is proxied <i>too</i>.</span>
