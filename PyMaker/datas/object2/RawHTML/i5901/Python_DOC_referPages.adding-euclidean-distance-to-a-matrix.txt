<div class="post-text" itemprop="text">
<p>I explain what I have to develop.</p>
<p>Let's say I have to perform a function that is responsible for receiving two matrices, which have the same number of columns but can differ in the number of rows.</p>
<p>In summary, we will have two matrices of vectors with the same dimension but different number N of elements.</p>
<p>I have to calculate the Euclidean distance between each of the vectors that make up my two matrices, and then store it in another matrix that will contain the Euclidean distance between all my vectors.</p>
<p>This is the code I have developed:</p>
<pre><code>def compute_distances(x, y):
    # Dimension:
    N, d = x.shape
    M, d_ = y.shape

    # The dimension should be the same
    if d != d_:
        print "Dimensiones de x e y no coinciden, no puedo calcular las distancias..."
        return None

    # Calculate distance with loops:
    D = np.zeros((N, M))
    i = 0
    j = 0
    for v1 in x:
       for v2 in y:
            if(j != M):
                D[i,j] = math.sqrt(sum([(xi-yi)**2 for xi,yi in zip(v1,v2)]))
            #print "[",i,",",j,"]"
                j = j + 1
            else:
                j = 0
       i = i + 1;

    print D
</code></pre>
<p>In this method I am receiving the two matrices to later create a matrix that will have the Euclidean distances between the vectors of my matrices <code>x</code> and <code>y</code>.</p>
<p>The problem is the following, I do not know how, to each one of the calculated Euclidean distance values ​​I have to assign the correct position of the new matrix <code>D</code> that I have generated.</p>
<p>My main function has the following structure:</p>
<pre><code>n = 1000
m = 700
d = 10

x = np.random.randn(n, d)
y = np.random.randn(m, d)

print "x shape =", x.shape
print "y shape =", y.shape

D_bucle = da.compute_distances(x, y)
D_cdist = cdist(x, y)

print np.max(np.abs(D_cdist - D_bucle))
</code></pre>
<p><code>B_cdist</code> calculates the Euclidean distance using efficient methods.
It has to have the same result as <code>D_bucle</code> that calculates the same as the other but with non efficient code, but I'm not getting what the result should be.</p>
<p>I think it's when I create my Euclidean matrix <code>D</code> that is not doing it correctly, then the calculations are incorrect.</p>
<p>Updated!!!
I just updated my solution, my problem is that firstly I didnt know how to asign to the D Matrix  my correct euclidean vector result for each pair of vectors, 
Now I khow how to asign it but now my problem is that only the first line from D Matrix is having a correct result in comparison with cdist function</p>
</div>
<div class="post-text" itemprop="text">
<p>not fully understanding what you're asking, but I do see one problem which may explain your results:</p>
<pre><code>for v1 in x:
  for v2 in y:
    D = math.sqrt(sum([(xi-yi)**2 for xi,yi in zip(v1,v2)]))
</code></pre>
<p>You are overwriting the value of D each of the NxM times you go through this loop.  When you're done D only contains the distance of the last compare.  You might need something like D[i,j] = math.sqrt(...</p>
</div>
<span class="comment-copy">Slight off-topic, but I suggest you use <a href="https://docs.python.org/3/library/math.html#math.hypot" rel="nofollow noreferrer"><code>math.hypot()</code></a> to compute the distance values.</span>
<span class="comment-copy">You are calculating <code>n</code> x <code>m</code> distances?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/q/27948363/2823755">Numpy Broadcast to perform euclidean distance vectorized</a></span>
<span class="comment-copy"><code>might need something like D[i,j] </code> instead of <b>might</b> and <b>something like</b>, can you supply a solution/fix for that deficiency?</span>
<span class="comment-copy">yes, guilty as charged.  I was vague because I'm not familiar with numpy which provides the matrix in this case</span>
<span class="comment-copy">This is my solution, but I think it's not doing it properly, because comparing cdist function and my euclidean function just only the first line of both results are correctly.                                                                              i = 0     j = 0     for v1 in x:         for v2 in y:             if(j != M):                 D[i,j] = math.sqrt(sum([(xi-yi)**2 for xi,yi in zip(v1,v2)]))                 #print "[",i,",",j,"]"                 j = j + 1             else:                 j = 0         i = i + 1;</span>
<span class="comment-copy">I just updated my solution</span>
<span class="comment-copy">I tried this myself with numpy and your updated solution seems to produce a valid matrix.  can you confirm?</span>
