<div class="post-text" itemprop="text">
<p>is it possible to implement a python key for sorting depending on multiple list elements?</p>
<p>For example:</p>
<pre><code>list = [1, 2, 3, 4]
</code></pre>
<p>And I want to sort the list depending on the difference between two elements, so that the delta is maximized between them.</p>
<p>Expected result:</p>
<pre><code>list = [1, 4, 2, 3] # delta = 4-1 + 4-2 + 3-2 = 6
</code></pre>
<p>Other result would also be possible, but 1 is before 4 in the origin array so 1 should be taken first:</p>
<pre><code>list = [4, 1, 3, 2] # delta = 4-1 + 3-1 + 3-2 = 6
</code></pre>
<p>I want to use python <code>sorted</code> like:</p>
<pre><code>sorted(list, key=lambda e1, e2: abs(e1-e2))  
</code></pre>
<p>Is there any possibility to do it this way? Maybe there is another library which could be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since (as you showed  us) there could be multiple different results - it means that this sorting/order is not deterministic and hence you can't apply a key function to it.</p>
<p>That said, it's easy to implement the sorting by yourself:</p>
<pre><code>def my_sort(col):
    res = []
    while col:
        _max = max(col)
        col.remove(_max)
        res.append(_max)

        if col:
            _min = min(col)
            col.remove(_min)
            res.append(_min)

    return res


print(my_sort([1,2,3,4]))  # [4, 1, 3, 2]
</code></pre>
<p>This solution runs in <code>O(n^2)</code> but it can be improved by sorting <code>col</code> in the beginning and then instead of looking for <code>max</code> and <code>min</code> we can extract the items in the beginning and the end of the list. By doing that we'll reduce the time complexity to <code>O(n log(n))</code></p>
<p><strong>EDIT</strong> </p>
<p>Per your comment below: if the index plays a role, again, it's not a "real" sorting :) that said, this solution can be engineered to keep the smaller index first and etc:</p>
<pre><code>def my_sort(col):
    res = []
    while col:
        _max = max(col)
        max_index = col.index(_max)
        col.remove(_max)

        if col:
            _min = min(col)
            min_index = col.index(_min)
            col.remove(_min)
            if max_index &lt; min_index:
                res.extend([_max, _min])
            else:
                res.extend([_min, _max])
            continue
        res.append((_max))

    return res

print(my_sort([1,2,3,4])) # [1, 4, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This solution is quite brute force; however, it is still a possibility:</p>
<pre><code>from itertools import permutations
list = [1, 2, 3, 4]
final_list = ((i, sum(abs(i[b]-i[b+1]) for b in range(len(i)-1))) for i in permutations(list, len(list)))
final_lists = max(final_list, key=lambda x:x[-1])
</code></pre>
<p>Output:</p>
<pre><code>((2, 4, 1, 3), 7)
</code></pre>
<p>Note that the output is in the form: <code>(list, total_sum))</code></p>
</div>
<span class="comment-copy">Suggest you read the <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer"><b>Sorting HOW TO</b></a>.</span>
<span class="comment-copy">First off, never use <code>list</code> as a variable name, it shadows the built-in</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/q/12375831/1639625">Algorithm to separate items of the same type</a></span>
<span class="comment-copy">@ᴬᴶᵁᴾᴾᴬᴸ jep you are right, thanks for the advice. - here it was just for an example purpose.</span>
<span class="comment-copy">the problem with this function is, that it does not take the index into account. so the exact output should be <code>[1, 4, 2, 3]</code> because <code>1</code> was before <code>4</code> in the origin list.</span>
<span class="comment-copy">@KevinWallis see "edit" section</span>
<span class="comment-copy">Thanks for the update!</span>
<span class="comment-copy">I'd suggest making <code>final_list</code> a generator: <code>final_list = (...)</code> this way it at least does not have O(n!) <i>memory</i> consumption. (Also, I'd put the calculation of the key into the <code>key</code> function itself.)</span>
<span class="comment-copy">@tobias_k good idea. Please see my recent edit.</span>
<span class="comment-copy">okay, as far as I understand it is not possible by using a simple key function. Maybe I thought using the <code>functools.cmp_to_key</code> have you ever tried this?</span>
<span class="comment-copy">This solution is valid but the "brute force" part makes it run in a time complexity of <code>O(n!)</code>...</span>
