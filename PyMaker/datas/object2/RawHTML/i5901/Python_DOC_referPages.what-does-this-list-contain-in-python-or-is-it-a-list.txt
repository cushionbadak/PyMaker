<div class="post-text" itemprop="text">
<p>I know that lists in Python are surrounded by square brackets <code>[]</code>.</p>
<p>I had an output that looked something like the following:</p>
<pre><code>[(451,165,76,-77,[98,42])]
</code></pre>
<p>Is this a list of a tuple? How can we access the items?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just give it a try in a terminal, it's all self-explanatory:</p>
<pre><code>&gt;&gt;&gt; x = [(451,165,76,-77,[98,42])]
&gt;&gt;&gt; type(x)
&lt;type 'list'&gt;
&gt;&gt;&gt; x[0]
(451, 165, 76, -77, [98, 42])
&gt;&gt;&gt; x[0][1]
165
&gt;&gt;&gt; x[0][4]
[98, 42]
&gt;&gt;&gt; type(x[0][4])
&lt;type 'list'&gt;
&gt;&gt;&gt; x[0][4][1]
42
</code></pre>
<p>Anyway, just because the output looks like a list, it doesn't need to be a list. It can be a more complex data structure (an object of some user-defined class) that specifies how to be printed by overloading <code>__str__()</code> or <code>__repr__()</code> (see <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>str</strong></a> for details)</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a <code>list</code> containing a <code>tuple</code> which has the first four elements as  <code>integers</code> and the last <code>element</code> as a <code>list</code> of <code>2</code> <code>integers</code>.</p>
<p>You can access all the values by <code>indexing</code> correctly. Here are some examples:</p>
<pre><code>&gt;&gt;&gt; l = [(451,165,76,-77,[98,42])]
&gt;&gt;&gt; l[0]
(451, 165, 76, -77, [98, 42])
&gt;&gt;&gt; l[0][0]
451
&gt;&gt;&gt; l[0][1]
165
&gt;&gt;&gt; l[0][3]
-77
&gt;&gt;&gt; l[0][4]
[98, 42]
&gt;&gt;&gt; l[0][4][0]
98
&gt;&gt;&gt; l[0][4][1]
42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, that is a list of a tuple.</p>
<pre><code>a = [(451,165,76,-77,[98,42])]
type(a)     #&gt; list
type(a[0])  #&gt; tuple
</code></pre>
<p>You would access the first item of the tuple like this:</p>
<pre><code>a[0][0]     #&gt; 451
</code></pre>
<p>And the last item of the tuple is a list:</p>
<pre><code>a[0][4]     #&gt; [98, 42]
</code></pre>
<p>And to access the elements of that list, you just add another layer of brackets:</p>
<pre><code>a[0][4][0]  #&gt; 98
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a list that contains one tuple, that himself contains 5 elements, of which one of them is a table.</p>
<p>To access:</p>
<pre><code>a=[(451,165,76,-77,[98,42])]

a[0][0][2]   
</code></pre>
<p>will return 76</p>
<pre><code>a[0][0][4][0]   
</code></pre>
<p>will return 98</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it's a list containing <strong>one</strong> element. And -as you mentioned correctly- this element is a tuple. A tuple is used in this case, because its last element is a list as well (tuples are suitable to store heterogenous data).</p>
</div>
<div class="post-text" itemprop="text">
<p>While the straight forward Python description is a list with a tuple that contains integers and list, the display is also consistent with a <code>numpy</code> structured array.</p>
<p>Define a compound dtype:</p>
<pre><code>In [596]: dt = np.dtype('i,i,i,i,(2)i')
In [597]: dt
Out[597]: dtype([('f0', '&lt;i4'), ('f1', '&lt;i4'), ('f2', '&lt;i4'), ('f3', '&lt;i4'), ('f4', '&lt;i4', (2,))])
</code></pre>
<p>Make an array with this list input.  Data for a compound dtype (structured array) is in the form of a list of tuples.  Each tuple represents the data of a record or element of the array:</p>
<pre><code>In [598]: arr = np.array([(451,165,76,-77,[98,42])], dtype=dt)
In [599]: arr
Out[599]: 
array([(451, 165, 76, -77, [98, 42])],
      dtype=[('f0', '&lt;i4'), ('f1', '&lt;i4'), ('f2', '&lt;i4'), ('f3', '&lt;i4'), ('f4', '&lt;i4', (2,))])
</code></pre>
<p>Print of this array looks just like the question:</p>
<pre><code>In [600]: print(arr)
[(451, 165, 76, -77, [98, 42])]
</code></pre>
<p>This is a 1 element array with 5 fields.  The last field has shape (2,), in effect a 2 element array.</p>
<pre><code>In [601]: arr['f4']
Out[601]: array([[98, 42]], dtype=int32)
In [602]: _.shape
Out[602]: (1, 2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So I wrote a type inspector awhile back that has served me well, because as asked we can only guess as to the type of the data when it's output as a string. For all we know it could be an object of type <code>Person</code> or <code>Frombulate</code> who chooses to <code>str()</code> as given.</p>
<pre><code>def type_diver(obj, prefix="", index = ""):
    print "%s'%s': %s%s" % (prefix, obj, type(obj), " - Accessible via " + index if index else "")
    if not isinstance(obj, str):
        try:
            for ind, elem in enumerate(obj):
                type_diver(elem, " " * len(prefix) + "|---", index + "[%s]" % ind)
        except TypeError:
            pass  # Don't call recursively on non-iterable objects
</code></pre>
<p>Which, for a basic python object gives, on your input:</p>
<pre><code>'[(451, 165, 76, -77, [98, 42])]': &lt;type 'list'&gt;
|---'(451, 165, 76, -77, [98, 42])': &lt;type 'tuple'&gt; - Accessible via [0]
    |---'451': &lt;type 'int'&gt; - Accessible via [0][0]
    |---'165': &lt;type 'int'&gt; - Accessible via [0][1]
    |---'76': &lt;type 'int'&gt; - Accessible via [0][2]
    |---'-77': &lt;type 'int'&gt; - Accessible via [0][3]
    |---'[98, 42]': &lt;type 'list'&gt; - Accessible via [0][4]
        |---'98': &lt;type 'int'&gt; - Accessible via [0][4][0]
        |---'42': &lt;type 'int'&gt; - Accessible via [0][4][1]
</code></pre>
<p>But I could write a custom class which <code>str()</code> output looks like that. The only way to know is to ask.</p>
<p>If your data is as <a href="https://stackoverflow.com/a/47539537/3579910">hpaulj suggested</a> [a numpy array], you might see something like:</p>
<pre><code>'[(451, 165, 76, -77, [98, 42])]': &lt;type 'numpy.ndarray'&gt;
|---'(451, 165, 76, -77, [98, 42])': &lt;type 'numpy.void'&gt; - Accessible via [0]
    |---'451': &lt;type 'numpy.int32'&gt; - Accessible via [0][0]
    |---'165': &lt;type 'numpy.int32'&gt; - Accessible via [0][1]
    |---'76': &lt;type 'numpy.int32'&gt; - Accessible via [0][2]
    |---'-77': &lt;type 'numpy.int32'&gt; - Accessible via [0][3]
    |---'[98 42]': &lt;type 'numpy.ndarray'&gt; - Accessible via [0][4]
        |---'98': &lt;type 'numpy.int32'&gt; - Accessible via [0][4][0]
        |---'42': &lt;type 'numpy.int32'&gt; - Accessible via [0][4][1]
</code></pre>
<p>Given everyone will have a different object they are interested in typing, this is a more general solution. It does, however, only investigate iterable objects.</p>
</div>
<span class="comment-copy">Where exactly does the output come from? You have selected the <code>numpy</code> tag, that's why I'm curious if it's that simple.</span>
<span class="comment-copy">Why is this tagged with <code>numpy</code> and <code>arrays</code>?</span>
<span class="comment-copy">This is the sort of situation I in which I would use the type inspector in my answer: we can only guess as to the type of the data when it's output as a string. I suspect you are correct in your guess, however, as the op tagged <code>numpy</code>.</span>
<span class="comment-copy">Fails for <code>obj = [None]; obj[0] = obj; type_diver(obj)</code> :P</span>
<span class="comment-copy">Add as much error handling as you desire. It serves it's purpose well.</span>
