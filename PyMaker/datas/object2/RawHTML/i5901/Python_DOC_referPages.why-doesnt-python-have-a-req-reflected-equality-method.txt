<div class="post-text" itemprop="text">
<p>I have a little helper class:</p>
<pre><code>class AnyOf(object):
    def __init__(self, *args):
        self.elements = args
    def __eq__(self, other):
        return other in self.elements
</code></pre>
<p>This lets me do sweet magic like:</p>
<pre><code>&gt;&gt;&gt; arr = np.array([1,2,3,4,5])
&gt;&gt;&gt; arr == AnyOf(2,3)
np.array([False, True, True, False, False])
</code></pre>
<p>without having to use a list comprehension (as in <code>np.array(x in (2,3) for x in arr</code>).</p>
<p>(I maintain a UI that lets (trusted) users type in arbitrary code, and <code>a == AnyOf(1,2,3)</code> is a lot more palatable than a list comprehension to the non-technically savvy user.)</p>
<p>However!</p>
<p>This only works one way! For example, if I were to do <code>AnyOf(2,3) == arr</code> then my <code>AnyOf</code> class's <code>__eq__</code> method never gets called: instead, the NumPy array's <code>__eq__</code> method gets called, which internally (I would presume) calls the <code>__eq__</code> method of all its elements.</p>
<p>This lead me to wonder: why does Python not allow a right-sided equivalent to <code>__eq__</code>? (Roughly equivalent to methods like <code>__radd__</code>, <code>__rmul__</code>, et cetera.)</p>
</div>
<div class="post-text" itemprop="text">
<p>An <code>__req__</code> is not a good idea in the language, because if class <code>Left</code> defines <code>__eq__</code> and class <code>Right</code> defines <code>__req__</code>, then Python is obliged to make a consistent decision about who gets called first in <code>Left() == Right()</code>.  They can't both win.</p>
<p>However, the Python datamodel does allow a way for you to do what you want here.  From both sides you can control this comparison, but you'll need to define <code>AnyOf</code> correctly.  <strong>If you want <code>AnyOf</code> to control the __eq__ from the right hand side, you must define it to be a subclass of <code>np.ndarray</code>.</strong> </p>
<blockquote>
<p>if I were to do <code>AnyOf(2,3) == arr</code> then my <code>AnyOf</code> class's <code>__eq__</code> method never gets called</p>
</blockquote>
<p>No, you have a fundamental misunderstanding here.  The left hand side <em>always</em> gets first try at the equality comparison, unless the right hand side is a subclass of the type of the left hand side.  </p>
<pre><code>arr == AnyOf(2,3)
</code></pre>
<p>In the case above, your custom <code>__eq__</code> <em>is</em> being called, because the numpy array calls it!  So <code>np.ndarray</code> wins, and it decides to check once per element.  It literally could do anything else, including not calling your <code>AnyOf.__eq__</code> at all.  </p>
<pre><code>AnyOf(2,3) == arr
</code></pre>
<p>In the case above, your class does get the first try at the comparison, and it fails because of the way you used <code>in</code> (checking if an array is in a tuple).  </p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3.6/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">documentation</a> about the <code>__rxx__</code> methods like <code>__radd__</code> states:</p>
<blockquote>
<p>These functions are only called if the left operand does not support the
  corresponding operation and the operands are of different types.</p>
</blockquote>
<p>While classes don't have <code>__add__</code> or <code>__sub__</code> methods per default, they <strong>do</strong> have <code>__eq__</code>:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     pass
&gt;&gt;&gt; '__eq__' in dir(A)
True
</code></pre>
<p>This means <code>__req__</code> would never be called unless you explicitly remove <code>__eq__</code> from the other class. </p>
<p>You can solve your specific problem with <code>np.in1d</code>:</p>
<pre><code>&gt;&gt;&gt; np.in1d(arr, [2, 3])
array([False,  True,  True, False, False], dtype=bool)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the documentation on the <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer">data model</a>:</p>
<blockquote>
<p>There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the
  right argument does); rather, <code>__lt__()</code> and <code>__gt__()</code> are each other’s
  reflection, <code>__le__()</code> and <code>__ge__()</code> are each other’s reflection, and
  <strong><code>__eq__()</code></strong> and <code>__ne__()</code> are their own reflection. If the operands are of different types, and right operand’s type is a direct or indirect
  subclass of the left operand’s type, the reflected method of the right
  operand has priority, otherwise the left operand’s method has
  priority. Virtual subclassing is not considered.</p>
</blockquote>
<p>As stated in the comments above, what you want works, and <code>__eq__</code> is essentially the sames as a potential <code>__req__</code>: it is called on the right hand side of <code>==</code> if the object on the left hand side returns <code>NotImplemented</code>:</p>
<pre><code>In [1]: class A:
   ...:     def __eq__(self, other):
   ...:         return NotImplemented
   ...:     

In [2]: class B:
   ...:     def __eq__(self, other): 
   ...:         print("B comparing")
   ...:         return True
   ...:     

In [3]: B() == A()
B comparing
Out[3]: True

In [4]: A() == B()
B comparing
Out[4]: True

In [5]: A() == A()
Out[5]: False
</code></pre>
<p>As it comes, it even work with other, ordinary, objects: </p>
<pre><code>In [10]: 5 == B()
B comparing
Out[10]: True
</code></pre>
<p>However, some objects may yield a TypeError on <code>__eq__</code> instead of returning <code>NotImplemented</code> or <code>False</code>, and that makes this not reliable for all kinds of objects.</p>
<p>What happens in your case, is an incorrect use of the operator <code>in</code>  with arrays and tuples inside your own <code>__eq__</code> method. (Thanks @wim to have spotted this in another answer here).</p>
</div>
<span class="comment-copy">"Why does Python not have X?" isn't likely to be a very productive question. If you want Python to have X, the productive way to make that happen is to follow <a href="https://www.python.org/dev/peps/pep-0001/#start-with-an-idea-for-python" rel="nofollow noreferrer">the process in PEP-1</a> to actually propose the idea and get feedback from the people who have a say on what gets added to the language. Otherwise, "Is there a way to get the useful effect of X in Python?" is much more likely to actually have an immediately useful result (wrt. generating light rather than heat).</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/3588776/how-is-eq-handled-in-python-and-in-what-order" title="how is eq handled in python and in what order">stackoverflow.com/questions/3588776/…</a></span>
<span class="comment-copy">Actually I can't recognize an urgent need for a class in the example above. Why not use a simple function, which returns a list?</span>
<span class="comment-copy">Note that if you have somewhat large arrays this "magic" is going to be much slower than something like <code>np.in1d</code>.</span>
<span class="comment-copy">Normally, <code>__eq__</code> should return <code>NotImplemented</code> rather than <code>False</code>, unless it is absolutely certain that values are different.</span>
<span class="comment-copy">Regarding "An <code>__req__</code> is not a good idea in the language" and the argument that follows, I don't think that holds, as from the same argument, methods like <code>__radd__</code> would also not be a good idea. However, I do see now that, due to how which model is selected (<code>Left.__eq__</code> or <code>Right.__req__</code>) it would actually make it so that <code>__req__</code> would fulfill the exact same function as <code>__eq__</code>, making the right-hand method superfluous!</span>
<span class="comment-copy">+1  that's a big "if" though - some standard types will just raise exception instead of returning <code>NotImplemented</code>, so you can't rely on this.</span>
<span class="comment-copy">I'm just not sure it works with <code>np.array</code> that way. But if it doesn't it's a bug in <code>np.array</code>, not something missing from the language.</span>
<span class="comment-copy">I did not say one can rely on it.</span>
