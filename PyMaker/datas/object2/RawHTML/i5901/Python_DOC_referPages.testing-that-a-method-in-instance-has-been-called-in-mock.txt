<div class="post-text" itemprop="text">
<p>I have this sort of setup where I'm testing a class which is using another class, and I want to mock the latter so I'm only testing the first class itself.</p>
<p><code>nuclear_reactor.py</code>:</p>
<pre><code>class NuclearReactor():
    def __init__(self):
        print "initializing the nuclear reactor"

    def start(self):
        print "starting the nuclear reactor"
</code></pre>
<p><code>nuclear_manager.py</code>:</p>
<pre><code>from nuclear_reactor import NuclearReactor

class NuclearManager():
    def __init__(self):
        print "manager creating the nuclear reactor"
        self.reactor = NuclearReactor()

    def start(self):
        print "manager starting the nuclear reactor"
        self.reactor.start()
</code></pre>
<p><code>test_nuclear_manager.py</code>:</p>
<pre><code>from mock import Mock
import nuclear_manager
from nuclear_manager import NuclearManager

def test():
    mock_reactor = nuclear_manager.NuclearReactor = Mock()
    nuke = NuclearManager()
    nuke.start()
    nuke.start()
    print mock_reactor.mock_calls
    print mock_reactor.start.call_count

test()
</code></pre>
<p>What I'd like to test is that <code>NuclearReactor.start</code> is called,
but when I run this I get:</p>
<pre><code>manager creating the nuclear reactor
manager starting the nuclear reactor
manager starting the nuclear reactor
[call(), call().start(), call().start()]
0
</code></pre>
<p>Which I totally understand since <code>start</code> is an attribute of the instance and not of the class, and I could parse the <code>mock_calls</code>, but isn't there a better way to check that the call of an instantiated mocked class is made?</p>
<p>I could use dependency injection in <code>NuclearManager</code> to pass a mock <code>NuclearReactor</code>, but I'm thinking there would be an alternative way using just mock.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are indeed testing if <code>start</code> has been called <em>directly on the class</em>, which your code does not. You can test the method on the instance directly; remember that an instance is produced by calling the class:</p>
<pre><code>print mock_reactor.return_value.calls
print mock_reactor.return_value.start.call_count
</code></pre>
<p>The <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value" rel="noreferrer"><code>Mock.return_value</code> attribute</a> is the result of the call to the mocked class, so the instance.</p>
<p>You can also just <em>call</em> the mock. Mocks by default always return the exact same object when called, a new mock representing that return value:</p>
<pre><code>print mock_reactor().calls
print mock_reactor().start.call_count
</code></pre>
<p>The result of calling a mock instance, and the mock instance <code>return_value</code> attribute, are one and the same.</p>
<p>You were already on the right path by printing out the calls to the <code>NuclearReactor</code> mock, you just missed the detail that <code>start()</code> was invoked on the <em>called</em> mock, so <code>call().start()</code>, not <code>start()</code> was recorded.</p>
<p>You may want to use <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="noreferrer"><code>mock.patch()</code></a> to handle the patching, rather than by direct assignment; this makes sure that the patch is <em>removed</em> again so that other tests can make their own decisions on what is mocked:</p>
<pre><code>import mock
from nuclear_manager import NuclearManager

@mock.patch('nuclear_manager.NuclearReactor')
def test(mock_reactor):
    nuke = NuclearManager()
    nuke.start()
    nuke.start()

    instance = mock_reactor.return_value
    assert instance.start.call_count == 2
    instance.assert_called()
</code></pre>
<p>I used it as a decorator here; when the <code>test()</code> function is called, the mock is put in place, and when the function exits, it is removed again. You can also use <code>patch()</code> as a context manager to limit the scope of the patch even more finely.</p>
<p>Also, for unit testing like this, do use the <a href="https://docs.python.org/3/library/unittest.html" rel="noreferrer"><code>unittest</code> library</a>:</p>
<pre><code>import mock
import unittest
import nuclear_manager

class NuclearManagerTests(unittest.TestCase):
    @mock.patch('nuclear_manager.NuclearReactor')
    def test_start(self, mock_reactor):
        nuke = NuclearManager()
        nuke.start()
        nuke.start()

        instance = mock_reactor.return_value
        self.assertEqual(instance.start.call_count, 2)
        instance.assert_called()

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>This lets you fit your tests into a larger test suite, enable and disable tests, and integrate with other testing tools.</p>
</div>
<div class="post-text" itemprop="text">
<p>The way I use mocks is like this: (Code is Python 3)</p>
<pre><code>from unittest.mock import MagicMock

class NuclearManager():
    def __init__(self, reactor):
        print("manager creating the nuclear reactor")
        self.reactor = reactor

    def start(self):
        print("manager starting the nuclear reactor")
        self.reactor.start()


def test():
    mock_reactor = MagicMock()
    nuke = NuclearManager(mock_reactor)
    nuke.start()
    nuke.start()

    # These two prints would actually be asserts of some sort
    print(mock_reactor.mock_calls)
    print(mock_reactor.start.call_count)

test()
</code></pre>
<p>Output:</p>
<pre><code>manager creating the nuclear reactor
manager starting the nuclear reactor
manager starting the nuclear reactor
[call.start(), call.start()]
2
</code></pre>
</div>
<span class="comment-copy">Why do you expect <code>.start()</code> to be called once when you call the manager twice?</span>
<span class="comment-copy">Yes, you should inject an instance into <code>NuclearManager</code> because your code now makes the manager set its <code>reactor</code> instance to a default value. Only the highest level parts of a program should have defaults.</span>
<span class="comment-copy">@quamrana: whether or not the OP should use dependency injection is an entirely separate discussion. Not all code under test will be suitable for dependency injection.</span>
<span class="comment-copy">Not that I use <code>patch</code> myself, but its good to know that <code>@patch()</code> will restore the scope later.</span>
<span class="comment-copy">Thanks a lot Marijn, makes sense. Just a note that I'm using <code>pytest</code> so no need for the <code>unittest</code> extra baggage. The <code>assert</code> is all I need.</span>
<span class="comment-copy">The OP has a hypothetical situation. Not all code requires injection, you can trivially still reach the instance, because that's a <b>call</b> to the class.</span>
