<div class="post-text" itemprop="text">
<p>I'm trying to read the log file in Linux <code>/var/log/messages</code> for a line having special pattern of strings which I have given below. From this line pattern I'm looking at the e-mail address for the user, like <code>rajeshm@noi-rajeshm.fox.com</code> and using the <code>str.partition()</code> method I'm separating it into two parts as a list index, and taking the first one further getting that split into a list for the ease of taking last index value, which is the user ID and that's working fine.</p>
<p>Saying that I'm able to get the list of users and total count but I need to count the occurrence of each user and print the <code>user_name: Count</code>, so the key and value.</p>
<blockquote>
<p>Nov 28 09:00:08 foxopt210 rshd[6157]: pam_rhosts(rsh:auth): allowed
  access to rajeshm@noi-rajeshm.fox.com as rajeshm</p>
</blockquote>
<pre><code>#!/usr/bin/python3
f= open("/var/log/messages")
count = 0
for line in f:
  if "allowed access"  in line:
    count+=1
    user_id = line.partition('@')[0]
    user_id = user_id.split()[-1]
    print(user_id)
f.close()
print("--------------------")
print("Total Count :" ,count)
</code></pre>
<p>The current code is working as below:</p>
<pre><code>bash-4.1$ ./log.py | tail
navit
akaul
akaul
pankaja
vishalm
vishalm
rajeshm
rajeshm
--------------------
Total Count : 790
</code></pre>
<p>While googling around I get the idea of using dictionary for this
purpose and it's working as expected:</p>
<pre><code>#!/usr/bin/python3
from collections import Counter
f= open("/var/log/messages")
count = 0
dictionary = {}
for line in f:
  if "allowed access"  in line:
    user_id = line.partition('@')[0]
    user_count = user_id.split()[-1]
    if user_count in dictionary:
        dictionary[user_count] += 1
    else:
       dictionary[user_count] = 1
for user_count, occurences in dictionary.items():
    print(user_count, ':', occurences)
</code></pre>
<p>And my output is as desired:</p>
<pre><code>bash-4.1$ ./log2.py
rajeshm : 5
navit : 780
akaul : 2
pankaja : 1
vishalm : 2
</code></pre>
<p>I'm just looking if there is a better way around for this exercise.</p>
</div>
<div class="post-text" itemprop="text">
<p>When counting things, it's easier to use the <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter()</code> class</a>. I'd encapsulate parsing the lines into a generator here:</p>
<pre><code>def users_accessed(fileobj):
    for line in fileobj:
        if 'allowed access' in line:
            yield line.partition('@')[0].rsplit(None, 1)[-1]
</code></pre>
<p>and pass this to the <code>Counter()</code> object:</p>
<pre><code>from collections import Counter

with open("/var/log/messages") as f:
    access_counts = Counter(users_accessed(f))

for userid, count in access_counts.most_common():
    print(userid, count, sep=':')
</code></pre>
<p>This uses the <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>Counter.most_common()</code> method</a> to provide sorted output (most common to least).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try with the regular expression and can do this:</p>
<pre><code>import re
pattern=r'(?&lt;=as\s)\w.+'
occurrence={}

with open("/var/log/messages") as f:
    for line in f:
        search=re.search(pattern,line).group()

        if  search not in occurrence:
            occurrence[search]=1
        else:
            occurrence[search]=occurrence.get(search)+1

print(occurrence)
</code></pre>
<blockquote>
<p>Just for fun one line logic:</p>
</blockquote>
<pre><code>import re
pattern=r'(?&lt;=as\s)\w.+'
new={}
[new.__setitem__(re.search(pattern, line).group(), 1) if re.search(pattern, line).group() not in new  else new.__setitem__(re.search(pattern, line).group(), new.get(re.search(pattern, line).group()) + 1) for line in open('legend.txt','r')]

print(new)
</code></pre>
</div>
<span class="comment-copy"><code>dictionary = collections.Counter(line.partition('@')[0].rsplit(None, 1)[-1] for line in f if 'allowed access' in line)</code>, then <code>for user_count, count in dictionary.most_common(): print(user_count, count, sep=':')</code>.</span>
<span class="comment-copy">@MartijnPieters, thnx for your inputs.. i'll try this.</span>
<span class="comment-copy">thnx aagain.. this is nice one, will try and revert you on the results.</span>
<span class="comment-copy">@Martin .. this is working fine, thnx.. can you please explain the <code>(None, 1)</code> and yeild Keywords .</span>
<span class="comment-copy">@Karn: <code>str.rsplit(None)</code>  is the same as <code>str.rsplit()</code>; splitting on aribtary whitespace. <code>str.rsplit()</code> takes a second argument that limits the number of splits, so <code>str.rsplit(None, 1)</code> splits just <i>once</i> on whitespace, counting from the right. By splitting just once you keep it more efficient, there is no point in splitting further as you ignore the rest of the results.</span>
<span class="comment-copy">@Karn: <code>yield</code> makes something a generator function, see <a href="//stackoverflow.com/q/231767">What does the "yield" keyword do?</a></span>
<span class="comment-copy">Ayodhyankit Paul  .. Thx for your code, i'll give it a try ..</span>
