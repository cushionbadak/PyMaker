<div class="post-text" itemprop="text">
<p>For a list such as:</p>
<pre><code>list1 = [1, 2, 3, 4]
</code></pre>
<p>What is the best way to iterate through the integers so that I get the return:</p>
<pre><code>[1, (1,2), (1,2,3), (1,2,3,4), 2, (2, 3), (2,3,4) 3, (3,4), 4]
</code></pre>
<p>aka getting every combination without rearranging the numbers.</p>
<p>I tried an idea such as</p>
<pre><code>def practice(list1):
    list2 = []
    for i in list1:
        for j in list1:
            list2.append((i, j))
    return list2
</code></pre>
<p>which returns </p>
<pre><code>[(1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (3, 2), (3, 3), (3, 4), (4, 1), (4, 2), (4, 3), (4, 4)]
</code></pre>
<p>but not quite what I want. </p>
<p>Sorry if this is simple, still new to/picking up the syntax and functions of this language!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a generator like this to produce all possible contiguous slices of the list and then make the case distinction for singletons:</p>
<pre><code>def practice(list1):
    for i in range(len(list1)):  # start index of slice
        for j in range(i, len(list1)):  # end index [-1]
            # differentiate singleton cases
            yield list1[i] if i==j else tuple(list1[i:j+1])

list(practice([1,2,3,4]))
# [1, (1, 2), (1, 2, 3), (1, 2, 3, 4), 2, (2, 3), (2, 3, 4), 3, (3, 4), 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively, you can use <code>itertools</code> to get the <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer">combinations (with replacement)</a> for the bounds and then return a generator of those. Also, I'd suggest not returning a mixed list, but wrapping the single numbers into one-elemented tuples.</p>
<pre><code>import itertools
def practice(lst):
    return (tuple(lst[i:j+1]) 
            for i, j in itertools.combinations_with_replacement(range(len(lst)), 2))

print(list(practice([1, 2, 3, 4])))
# [(1,), (1, 2), (1, 2, 3), (1, 2, 3, 4), (2,), (2, 3), (2, 3, 4), (3,), (3, 4), (4,)]
</code></pre>
<p>Or shorter (thanks to <a href="https://stackoverflow.com/questions/47555372/specific-iteration-method-on-list/47555790?noredirect=1#comment82069533_47555790">@schwobaseggl</a>), using just <code>combinations</code> without replacement but a slightly different <code>range</code>. Not sure which of the two is clearer.</p>
<pre><code>def practice(lst):
    return (tuple(lst[i:j])  # &lt;-- no +1 here      +1 here --v
            for i, j in itertools.combinations(range(len(lst)+1), 2))
</code></pre>
<p>(If this is some sort of programming assignment, this might not be the expected output, but it will likely be much easier to handle in practice.)</p>
</div>
<span class="comment-copy">Do you really want to get a <i>mixed list</i> of integers and tuples?</span>
<span class="comment-copy">it would be superb if using <code>itertools.islice</code> to avoid extra lists</span>
<span class="comment-copy">@DanielSanchez True, but overkill for the illustration of this simple logic ;)</span>
<span class="comment-copy">It could be shorter (and maybe cleaner) using <code>combinations</code> without replacement, <code>range(len(lst)+1)</code> and <code>lst[i:j]</code> ;-)</span>
<span class="comment-copy">@schwobaseggl Thank, I added this, but to be frank, I still prefer the original version. While <code>combinations</code> may be shorter in code, <code>combinations_with_replacement</code> directly communicates that <code>(1,)</code> should be in the result.</span>
<span class="comment-copy">Well, of course that's a matter of taste. Yet the <code>(1,)</code> you mention will always be produced by the slice <code>[0:1]</code>, that is two <b>different</b> indices which, in turn, is directly implied by no replacement... :D many ways to skin the cat</span>
