<div class="post-text" itemprop="text">
<p>so I'm working with this code which should return the combined version of two matrices from a text file (w/o importing any kind of module). </p>
<pre><code>def concatenate(filename): 
    with open(filename, 'r') as myfile:
        data=myfile.read().split()
        a=data[0].split()
        b=data[1].split()
    a=eval(a[0])
    b=eval(b[0])
    row_a=len(a)
    row_b=len(b)
    col_a=len(a[0])
    col_b=len(b[0])
    if row_a==row_b:
        concatenated=[a+b for a,b in zip(*eval(open(filename)))]        
        return concatenated
    if col_a==col_b:
        concatenated=[a+b for a, b in zip(*eval(open(filename)))]
        return concatenated
    else:
        print ("Error")
</code></pre>
<p>The text file might contain something like:</p>
<p>[[1,2],[3,4]] [[5,6,7],[8,9,10]]</p>
<p>And output:</p>
<p>[[1,2,5,6,7],[3,4,8,9,10]]</p>
<p>I keep on getting this type error: TypeError: eval() arg 1 must be a string, bytes or code object</p>
<p>How do I fix this? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I keep on getting this type error: TypeError: eval() arg 1 must be a string, bytes or code object</p>
</blockquote>
<p>Well that's documented indeed.</p>
<blockquote>
<p>How do I fix this?</p>
</blockquote>
<p>Quite simply: don't pass a <code>file</code> object to a function that expect a string, bytes or code object. </p>
<p>BUT actually the <em>real</em> solution is : <strong>don't</strong> use <code>eval()</code> at all - it's a huge security hole. At least use <code>ast.literal_eval()</code>:</p>
<pre><code>&gt;&gt;&gt; ast.literal_eval("[[1,2],[3,4]]")
[[1, 2], [3, 4]]
&gt;&gt;&gt; ast.literal_eval("[[5,6,7],[8,9,10]]")
[[5, 6, 7], [8, 9, 10]]
</code></pre>
<p>Also you don't need to reopen your file (and forget to close it), you already get the content in <code>data</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way to do it using <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval()</code></a> which is much safer than running the dangerous <code>eval</code> on arbitrary file input:</p>
<pre><code>from ast import literal_eval

def concatenate(filename): 
    with open(filename, 'r') as myfile:
        data = myfile.read().split()
        result = literal_eval(data[0])
        b = literal_eval(data[1])
        if len(result) != len(b):
            print('Matrices of unequal length')
            return None    # or raise an exception

        for i, l in enumerate(result):
            l.extend(b[i])
        return result
</code></pre>
<p>For your data:</p>
<pre><code>&gt;&gt;&gt; concatenate('data')
[[1, 2, 5, 6, 7], [3, 4, 8, 9, 10]]
</code></pre>
</div>
<span class="comment-copy">Thank you, is there a way to fix this without importing a module?</span>
<span class="comment-copy">You can use <code>eval()</code> but you really need to be certain that there can not be any malicious code passed to it. It would be unnecessarily risky to do that just to avoid an import.</span>
