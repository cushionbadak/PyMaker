<div class="post-text" itemprop="text">
<p>The built-in function <code>len()</code> (<a href="https://docs.python.org/3/library/functions.html#len" rel="noreferrer">https://docs.python.org/3/library/functions.html#len</a>) returns "<em>the length (the number of items) of an object</em>", but this is not implemented for <code>queue.Queue</code> (<a href="https://docs.python.org/3/library/queue.html" rel="noreferrer">https://docs.python.org/3/library/queue.html</a>).
Instead, <code>queue.Queue</code> has a <code>qsize()</code> method which returns the approximate size of a queue, when it clearly has a length; you can specify the maximum length of a <code>Queue</code> in the constructor. The similar <code>collections.deque</code> does work with <code>len</code>.</p>
<p>What are the reasons for not using the common <code>len()</code> for <code>queue.Queue</code>? Or: What would be the problems if <code>qsize</code> were instead named <code>__len__</code> to enable the <code>len()</code> function?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>len()</code> isn't implemented for <code>queue.Queue</code> because it would be an "attractive nuisance":  something that only an expert should even consider using, but a "friendly name" would encourage non-experts to use it.</p>
<p>Unlike most sequence types (like <code>list</code> and <code>deque</code>), a <code>queue.Queue</code> is specifically <em>intended</em> to be used in multi-threaded contexts (and similarly for the <code>multiprocessing</code> module's queue type).  While the number of items in a <code>Queue</code> certainly has a definite value at any particular time, it's impossible for user code to find out what that value is:  between the time a call to <code>.qsize()</code> returns and your code can <em>look</em> at the returned value, any number of other threads (or processes, in the <code>multiprocessing</code> case) may have made any number of changes to the queue's contents.</p>
<p>So the only true thing that can be said about the value returned by <code>.qsize()</code> is that the <code>Queue</code> <em>had</em> that many values in it at <em>some</em> time in the past.  By the time you can use the returned value, it may have arbitrarily more (or fewer) values in it.</p>
<p>Of course that's not so if you're only running one thread - but then there's no need to pay for the implementation complexity of a <code>Queue</code> (use a <code>list</code> or a <code>deque</code> instead).</p>
</div>
<span class="comment-copy">Maybe because people expect <code>len</code> to return an accurate value, not an approximate one. And that it should be fast. To implement an accurate  <code>__len__</code> the Queue would have to be temporarily locked to prevent additions &amp; removals, which would impact performance.</span>
<span class="comment-copy">so why are <code>empty()</code> and <code>full()</code> implemented for a queue?</span>
<span class="comment-copy">They wouldn't implement <code>empty()</code> and <code>full()</code> if I had written them ;-)  In the early days, the various optional <code>timeout=</code> arguments didn't exist, and <code>full()</code> and <code>empty()</code> were used in loops as <i>probabilistic</i> gimmicks to make a decent guess at whether <code>.put()</code> or <code>.get()</code> were "likely to" succeed.  Code using them (like code using <code>qsize()</code>) is as often as not prone to timing bugs.</span>
