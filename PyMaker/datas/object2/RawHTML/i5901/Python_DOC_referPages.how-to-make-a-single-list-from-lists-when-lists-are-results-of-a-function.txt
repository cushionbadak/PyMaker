<div class="post-text" itemprop="text">
<p>I have json file like:</p>
<pre><code>{
    "level0name":{
      "level1name":[
        {
            "notkey":null,
            "key":"Some text 626 dollars."
        },
        {
            "notkey":null,
            "key":"Some text 3213 dollars."
        }
      ]
    }
}
</code></pre>
<p>and python code that parse json with regex </p>
<pre><code>import json
import re
path = 'name.json'
def parser():
    with open(path, 'r') as jfile:
        data = json.loads(jfile.read())
        for i in data["level0name"]["level1name"]:
            try:
                all_messages = (i['key'])
                a = re.findall(u'[0-9]{1,}\sdollars.', all_messages)
                for i in a:
                    print(i)
            except KeyError:
                continue   
parser()
</code></pre>
<p>Result of function gives me many lists like, and can't merge it.</p>
<pre><code>[625 dollars]
[3213 dollars]
[121 dollars]
[692 dollars]
</code></pre>
<p>How can i get single list? Maybe I doing something wrong while parsing? 
Just need a single comma-separated list. Like:</p>
<pre><code>[625, 3213, 121, 692]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can slightly change your regex so you include a positive lookahead along with a list: </p>
<pre><code>import json
import re
path = 'name.json'
def parser():
   with open(path, 'r') as jfile:
      data = json.loads(jfile.read())
      final_list = [] #for collecting the data
      for i in data["level0name"]["level1name"]:
         try:
             all_messages = (i['key'])
             a = re.findall(u'[0-9]{1,}(?=\sdollars\.)', all_messages)
             if a:
                final_list.append(int(a[0])) #append to final_list
         except KeyError:
            continue   
parser()
</code></pre>
<p>Or, you can read the file and apply regex:</p>
<pre><code>import re
final_data = map(int, re.findall('\d+(?=\sdollars\.)', open('path.json').read()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a slightly longer JSON input file:</p>
<pre class="lang-json prettyprint-override"><code>{
    "level0name":{
      "level1name":[
        {
            "notkey":null,
            "key":"Some text 626 dollars."
        },
        {
            "notkey":null,
            "key":"Some text 3213 dollars."
        },
        {
            "notkey":null,
            "key":"Some text 121 dollars."
        },
        {
            "notkey":null,
            "key":"Some text 692 dollars."
        }
      ]
    }
}
</code></pre>
<p>Along with this code:</p>
<pre><code>import json
import re

path = 'name.json'

def parser():
    results = []
    with open(path, 'r') as jfile:
        data = json.loads(jfile.read())
        for i in data["level0name"]["level1name"]:
            try:
                match = re.search(r'([0-9]{1,})\sdollars.', i['key'])
                if match:
                    results.append(match.group(1))
            except KeyError:
                continue

    return results

print(parser())  # -&gt; ['626', '3213', '121', '692']
</code></pre>
<p>Seems to do what you want. Note how a pair of parentheses were added to the regex pattern to indicate the portion (aka group) of the pattern has characters of interest. These are <em>capturing</em> parentheses as opposed to non-capturing parentheses, <code>(&gt;:...)</code>, in the <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">documentation</a>â€”in other words regular parentheses are the kind that do capturing.</p>
</div>
<span class="comment-copy">thanks, first one return many lists too, but like: [625][625, 3213][625, 3213, 121][625, 3213, 121, 692]. Second solutions is really good! thanks)</span>
