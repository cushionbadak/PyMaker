<div class="post-text" itemprop="text">
<p>I'm experimenting with GPIO access from Python on an embedded system (ARM core), which is running linux built with Buildroot (kernel 4.1.15).  </p>
<p>I want my code to BLOCK waiting for a pin change on GPIO2 (i.e. I don't want to poll the pin by calling "read" repeatedly). I'm trying to do this using "epoll" in edge-triggered mode: </p>
<p>See <a href="https://docs.python.org/3/library/select.html#epoll-objects" rel="nofollow noreferrer">Python docs for epoll</a>. <strong>select.EPOLLET</strong> flag is used to get edge triggering for epoll. See also <a href="https://linux.die.net/man/4/epoll" rel="nofollow noreferrer">Linux docs for epoll</a>.</p>
<p>For simplicity, I've already set up my GPIO pin from the console, using sysfs:</p>
<pre><code># cat /sys/class/gpio/gpio2/direction 
in
# cat /sys/class/gpio/gpio2/edge
rising
</code></pre>
<p>Here's my Python code:</p>
<pre><code>#!/usr/bin/env python
# coding=utf8

from time import sleep
import select
import sys

if __name__ == '__main__':

    try:
        pinIn = open("/sys/class/gpio/gpio2/value", "r")
    except IOError:
        print("Error setting up GPIO pin")
        sys.exit()

    myPoll = select.epoll()
    myPoll.register(pinIn.fileno(), select.EPOLLPRI | select.EPOLLET)

    while(1):

        events = myPoll.poll(4)
        print("EPoll result: %s" % (str(events),))

        for fd, event_type in events:
            print("FD: %d; Events: %d" % (fd, event_type))
            if event_type &amp; select.EPOLLIN:
                print("-EPOLLIN!")
            if event_type &amp; select.EPOLLPRI:
                print("-EPOLLPRI!")
            if event_type &amp; select.EPOLLERR:
                print("-EPOLLERR!")

        value = pinIn.read(1)
        pinIn.seek(0)
        print("--&gt; %s" % (str(value),))
        sleep(1)
</code></pre>
<p>For testing, I am feeding the input pin with a square wave from a signal generator at about 2 seconds per cycle, so I can see when the pin changes.  </p>
<p>When I run this on my embedded system, I get this: </p>
<pre><code># python3 /usr/sbin/test-gpio-python.py 
EPoll result: [(3, 10)]
FD: 3; Events: 10
-EPOLLPRI!
-EPOLLERR!
--&gt; 0
</code></pre>
<p>The code sleeps on the 1 seconds sleep, then on the next iteration, the poll() immediately returns and doesn't block. It should block since my input is only operating at one rising edge per 2 seconds. </p>
<p><strong>Why isn't "poll()" blocking?</strong></p>
<p>==== EDIT: ====</p>
<p>Originally, the code caused a weird error when I tried to use "select.EPOLLET":</p>
<pre><code>OverflowError: can't convert negative value to unsigned int
</code></pre>
<p>However, I discovered that I had accidentally used <strong>myPoll = select.poll()</strong> instead of <strong>epoll()</strong>. Code now fixed. </p>
</div>
<div class="post-text" itemprop="text">
<p>I decided to check the interrupt information by looking at <strong>/proc/interrupts</strong>.</p>
<p>Here it is, only a couple of seconds after setting <strong>edge</strong> to "rising" for the GPIO pin:</p>
<pre><code># cat /proc/interrupts 
...
 33:        421  gpio-mxc   2 Edge      gpiolib
...
</code></pre>
<p>Hmm, 421 interrupts have occurred already!</p>
<p>Two seconds later: </p>
<pre><code># cat /proc/interrupts 
...
 33:        852  gpio-mxc   2 Edge      gpiolib
...
</code></pre>
<p>That could explain it. Interrupts are piling up at ~400 per second, definitely faster than I am processing them in Python. </p>
<p>Further investigation with a scope showed that the signal generator was only putting out about 1.6 V, and it looks like noise was triggering the input circuit on the device. </p>
<p>When I switched to the correct signal generator output and got a clean signal on the GPIO pin, I started getting the expected number of interrupts, and the python code worked correctly (i.e. poll() blocked correctly between rising edges on the input).</p>
</div>
<span class="comment-copy">I would recommend to consider use of <i>libgpiod</i> (in case you can use new kernel): <a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/" rel="nofollow noreferrer">git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git</a>.</span>
<span class="comment-copy">@0andriy Good info, thanks... I didn't know the sysfs interface is going to be deprecated! We are using kernel 4.1.15 at the moment though.</span>
<span class="comment-copy">I'm still getting the "EPOLLERR" flag set along with "EPOLLPRI" in the event I get back when the poll() returns. However, it sounds like this might be normal behaviour... See: <a href="https://groups.google.com/forum/#!topic/quick2wire-users/ka-V_85ePtE" rel="nofollow noreferrer">groups.google.com/forum/#!topic/quick2wire-users/ka-V_85ePtE</a></span>
