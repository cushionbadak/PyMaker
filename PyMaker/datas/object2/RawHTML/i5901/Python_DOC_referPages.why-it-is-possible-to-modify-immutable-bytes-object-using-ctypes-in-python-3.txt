<div class="post-text" itemprop="text">
<p>bytes object is <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow noreferrer">immutable</a>. It doesn't support item assignment:</p>
<pre><code>&gt;&gt;&gt; bar = b"bar"
&gt;&gt;&gt; bar[0] = b"#"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'bytes' object does not support item assignment
</code></pre>
<p>str object is also immutable:</p>
<pre><code>&gt;&gt;&gt; bar = "bar"
&gt;&gt;&gt; bar[0] = "#"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</code></pre>
<p>It is possible to modify bytes object with ctypes while it is not possible to do the same with str object. Could you explain why? Please have a look at the following examples.</p>
<p><strong>c code</strong></p>
<pre><code>char* foo(char *bar) {
    bar[0] = '#';
    return bar;
}
</code></pre>
<p><strong>c code compilation</strong></p>
<pre><code>gcc -shared -o clib.so -fPIC clib.c
</code></pre>
<h1>bytes attempt</h1>
<p><strong>python code</strong></p>
<pre><code>import ctypes

clib = ctypes.CDLL('./clib.so')

bar = b"bar"
print("Before:", bar, id(bar))

clib.foo(bar)
print("After: ", bar, id(bar))
</code></pre>
<p><strong>python code output</strong></p>
<pre><code>Before: b'bar' 140451244811328
After:  b'#ar' 140451244811328
</code></pre>
<h1>str attempt</h1>
<p>str object is also immutable in Python 3 but unlike bytes object it's not possible to modify it with ctypes.</p>
<p><strong>python code</strong></p>
<pre><code>import ctypes

clib = ctypes.CDLL('./clib.so')

bar = "bar"
print("Before:", bar, id(bar))

clib.foo(bar)
print("After: ", bar, id(bar))
</code></pre>
<p><strong>python code output</strong></p>
<pre><code>Before: bar 140385853714080
After:  bar 140385853714080
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str</code> in Python 3 is abstracted as Unicode and can be stored as 1-, 2-, or 4-byte per character strings depending on the highest Unicode character used in the string.  To pass the string to a C function it must be converted to a specific representation.  <code>ctypes</code> in this case is passing the converted temporary buffer to C and not the original.  <code>ctypes</code> can crash and corrupt Python if you prototype functions incorrectly or send immutable objects to functions that mutate the contents and it is up to the user to be careful in these cases.</p>
<p>In the <code>bytes</code> case <code>ctypes</code> passes along a pointer to its internal buffer of the bytes, but doesn't expect it to be modified.  Consider:</p>
<pre><code>a = b'123'
b = b'123'
</code></pre>
<p>Since <code>bytes</code> are immutable, Python is free to store the same reference in both <code>a</code> and <code>b</code>.  If you pass <code>b</code> to a <code>ctypes</code>-wrapped function and it modifies it, it could corrupt <code>a</code> as well.</p>
<p>Straight from the <a href="https://docs.python.org/3/library/ctypes.html#fundamental-data-types" rel="nofollow noreferrer">ctypes documentation</a>:</p>
<blockquote>
<p>You should be careful, however, not to pass [immutable objects] to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a <code>create_string_buffer()</code> function which creates these in various ways....</p>
</blockquote>
</div>
<span class="comment-copy">You're going behind the scenes, so basically anything is possible.</span>
<span class="comment-copy">Ok, I could accept that but why it is not possible to do the same with str object?</span>
<span class="comment-copy">Can you show the code for your string attempt?</span>
<span class="comment-copy">It is present below "str attempt" header - I've modified my question a little to make it easier to read.</span>
