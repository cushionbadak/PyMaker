<div class="post-text" itemprop="text">
<p>I'm totally new to Python and I'm trying to write a class, which will store only two attributes, one of which is intended to be a number and another a datetime object. Though I'd also like, while storing <code>date</code> as a datetime, to initialize and output it using a string like "dd.mm.yyyy". So I go: </p>
<pre><code>class MyClass:
    number = None
    date = None

    def __init__(self, params):
        self.number = params["number"]
        self.date = params["date"]

    @property
    def date(self):
        return datetime.datetime.strftime(self.date, '%d.%m.%Y')

    @date.setter
    def date(self, value):
        self.date = datetime.datetime.strptime(value, '%d.%m.%Y')

    def get_vars(self):
        return vars(self)
</code></pre>
<p>But at runtime <code>@property</code> points at <code>self.date</code> and says: <code>Expected type 'datetime', got 'str' instead</code>. How can it ever get a string, when it's meant to be converted to date while setting. Why is this happening? Confused.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; MyClass({'number': 42, 'date': '28.12.2017'})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 8, in __init__
  File "&lt;string&gt;", line 16, in date
  File "&lt;string&gt;", line 16, in date
TypeError: strptime() argument 1 must be str, not datetime.datetime
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't use <code>date</code> for both the <code>property</code> object and an instance attribute. Only the property is available (because it is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>data descriptor</em></a>), and <code>self.date</code> references that property object. The expression <code>self.date = params['date']</code> is passing the <code>param['date']</code> value to the setter, it is not setting an instance attribute.</p>
<p>Because <code>param['date']</code> is evidently a <code>datetime</code> object in your case, that means that in the setter <code>datetime.datetime.strptime(&lt;datetime instance&gt;, '%d.%m.%Y')</code> is called, which fails. Even if that succeeded, you'd then try to assign that result back to <code>self.date</code>, which would call the setter again, ad infinitum. And it is a <code>datetime</code> instance either because you passed in a <code>datetime</code> value originally, <em>or</em> you passed in a string, and the first <code>.strptime()</code> call succeeded and now <code>self.date</code> is being assigned that <code>datetime</code> instance that was just created.</p>
<p>Rename the instance attribute; giving it a leading single underscore is usually the most helpful naming scheme here:</p>
<pre><code>class MyClass:
    _number = None
    _date = None

    def __init__(self, params):
        self._number = params["number"]
        self._date = params["date"]

    @property
    def date(self):
        return self._date.strftime('%d.%m.%Y')

    @date.setter
    def date(self, value):
        self._date = datetime.datetime.strptime(value, '%d.%m.%Y')

    def get_vars(self):
        return vars(self)
</code></pre>
<p>I also changed <code>datetime.datetime.strftime(self._date, '%d.%m.%Y')</code> (a call to an unbound method) to a method call on <code>self._date</code>.</p>
</div>
<span class="comment-copy">Please do include the <i>full traceback</i> and the code that creates your <code>MyClass</code> instance. I can work out <i>in this specific, limited case</i> exactly what must have happened, but a traceback makes it easier for future visitors to see if they have the same problem.</span>
<span class="comment-copy">Now it works and what is more important, I now understand why) Thousand thanks)</span>
<span class="comment-copy">can I ask you one more question? Seems like vars() doesn't use @property when returning the dict with attributes. Is there a way to make it use getters in order to obtain the <code>data</code> value in correct  format?</span>
<span class="comment-copy">@Dankevich: no, <code>vars()</code> returns the instance attribute dictionary. You'd have to find all attributes on the class (<code>dir(ype(self))</code>), test each attribute to see if it is a property, then access the property on the instance, to list those.</span>
<span class="comment-copy">@Dankevich: see <a href="//stackoverflow.com/q/1215408">How to list all class properties</a></span>
<span class="comment-copy">it's close, but not exactly what I need here. I'd like to have a dictionary a "key": "value" pairs for all attributes, while this hint only gives me attribute names</span>
