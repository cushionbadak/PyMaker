<div class="post-text" itemprop="text">
<p>I have a simple test bench implemented in python.</p>
<p>The test runner exposes a set of functions to the test.
This may be considered as a domain specific language for writing tests.
Most test cases form simple sequences of calls to these functions, sometimes involving control flow statements, but nothing more complicated than that.</p>
<p>Now a few test cases have become too complex and would benefit from being refactored using functions.
This is where I run into problems.
From within the functions I cannot access local symbols defined inside the test case. I can also not access the functions exposed by the runner (log and verify).</p>
<pre><code>''' Testing variable scopes in exec()'''

PRG_1 = '''
a = 42
log('Testing a = ' + str(a))
verify(a, 42)
'''

PRG_2 = '''
a = 42
def f():
    c = a  # Error 'a' not defined
    log(c) # Error 'log' not defined

f()
'''

class TestRunner():
    def __init__(self, prg):
        self.prg = prg

    def log(self, msg):
        print(msg)

    def verify(self, a, b):
        print('PASSED' if a == b else 'FAILED')

    def run(self):
        # Bring methods into local scope to avoid having 'self.' in DSL
        log = self.log
        verify = self.verify

        # Execute test
        exec(self.prg)

r = TestRunner(PRG_1)
r.run()

r = TestRunner(PRG_2)
r.run()
</code></pre>
<p>Any idea on how I can get this to work?
Maybe there is a different (and better way) to accomplish this, that I as a C++ developer do not see.</p>
<pre><code>$ python3 test.py
Testing a = 42
PASSED
Traceback (most recent call last):
  File "test.py", line 42, in &lt;module&gt;
    r.run()
  File "test.py", line 35, in run
    exec(self.prg)
  File "&lt;string&gt;", line 7, in &lt;module&gt;
  File "&lt;string&gt;", line 4, in f
NameError: name 'a' is not defined
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you do:</p>
<pre><code>def run(self):
    exec(self.prg, {'log': self.log, 'verify': self.verify})
</code></pre>
<p>Produces:</p>
<pre><code>42
</code></pre>
<p>Generally a good idea to avoid dynamic code execution like this anyway!</p>
</div>
<span class="comment-copy">You can pass locals and globals to <code>exec</code>, see the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">documentation</a></span>
<span class="comment-copy">I tried <code>exec(self.prg, globals=globals(), locals=locals())</code> but got <code>TypeError: exec() takes no keyword arguments</code>. Then tried using positional arguments instead, but to no help.</span>
<span class="comment-copy">Thank you. This may solve my problems. I added <code>log</code> and <code>verify</code> to <code>scope</code>. Not <code>a</code> as that is a test case local variable. Now my small example works. I did not use the wrapper function, but for some reason <code>a</code> is found anyway.</span>
<span class="comment-copy">I understand the potential security issues of dynamic code execution, but in this case all persons writing test cases are trusted and might as well modify the actual test bench if they wanted to execute malicious code. Any other reasons to avoid dynamic execution?</span>
<span class="comment-copy">Security was the reason I had in mind.  Beyond that I guess things like code readability, IDE integration, syntax highlighting come to mind.</span>
<span class="comment-copy">Ok. We store the test cases in files and not in string literals so we get the coloring. But it not very nice to get syntactic errors as &lt;string&gt;:57 instead of a filename. Also debugging is limited to printf-debugging.</span>
<span class="comment-copy">Simplified my answer, works perfectly well in Python 2, I was just being an idiot.</span>
