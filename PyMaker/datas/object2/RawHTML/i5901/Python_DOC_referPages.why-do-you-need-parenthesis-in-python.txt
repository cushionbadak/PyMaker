<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/31294125/why-python-need-parentheses-in-function-call">Why python need parentheses in function call? [closed]</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>This question is just an attempt at understanding something; I know what to do, just want to know what is the difference between:</p>
<p><code>datetime.datetime.now().date</code></p>
<p>and </p>
<p><code>datetime.datetime.now().date()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Parentheses denote that you actually want to <em>call</em> the method, rather than <em>mention</em> it for later use. On a line of its own, the latter doesn't appear to make sense, but in larger expressions, it allows <em>delaying</em> the function call:</p>
<pre><code># access the "date" method, but don't call it yet
fn = datetime.datetime.now().date
... do other things ...
# *now* call date()
print(fn())
</code></pre>
<p>The callable object stored in <code>fn</code> is a <em>bound method</em>, and it refers to a concrete object. In Python there is no fundamental difference between a method call and a function call: accessing a method by name creates a bound method object, which is then called as any other function. As far as Python is concerned, omitting the parentheses simply means that you are not (yet) interested in calling it.</p>
<p>This is useful when you have a function that accepts a callable. For example, imagine calling into an event processor that allows you to provide a custom callable for processing events. Normally the events are dispatched through GUI, but you want to (temporarily) want to collect the events in a list you've just created. This would be a use case for a bound method:</p>
<pre><code># library function that we cannot change
def do_processing(dispatchfn):
    for event in something_that_generates_events():
        ... internal bookkeeping
        # dispatch the event
        dispatchfn(event)

# our code to log the events
log = []
do_processing(log.append)
# ... inspect the events list, e.g.:
for event in log:
    print event
</code></pre>
<p>In this case, an alternative to using a bound method would be to use a <code>lambda</code>:</p>
<pre><code>do_processing(lambda event: log.append(event))
</code></pre>
<p>But a <code>lambda</code> has subtly different semantics and performance. Using a bound method can actually <em>improve</em> performance in very tight loops. A popular optimization in Python is to transform a tight loop:</p>
<pre><code>todo = deque()
while todo:
    next_item = todo.popleft()
    ...
</code></pre>
<p>into:</p>
<pre><code>todo = deque()
todo_popleft = todo.popleft
while todo:
    next_item = todo_popleft()
    ...
</code></pre>
<p>If the <code>while</code> loop does <em>really</em> little, this transformation can actually improve performance because it eliminates the cost of one dict lookup and of creation of the bound method. This is not something that should be done routinely, but it is a recognized usage of uncalled bound methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>The parenthesis <em>calls</em> a function.</p>
<pre><code>datetime.datetime.now().date
</code></pre>
<p><em>Works</em>, in that it's valid syntax, but what that gives you is the method itself, not the result of calling the method.</p>
<p>You can see this in a REPL:</p>
<pre><code>&gt;&gt;&gt; datetime.datetime.now().date
&lt;built-in method date of datetime.datetime object at 0x7fbb8ea17620&gt;
</code></pre>
<p>and:</p>
<pre><code>&gt;&gt;&gt; date_method = datetime.datetime.now().date
&gt;&gt;&gt; actual_date = date_method()
&gt;&gt;&gt; actual_date
datetime.date(2017, 11, 30)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The parenthesis represents a call to a <a href="https://docs.python.org/2.4/lib/typesmethods.html" rel="nofollow noreferrer">method</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>date</code> is a method of <code>datetime</code>. Whenever you want the date you need to <strong>invoke</strong> (or call) that method - and the way to do it is with parenthesis. When you don't use parenthesis what you access is the function itself as an object. </p>
</div>
<span class="comment-copy">Relevant part of the Python tutorial  (Which you should go through): <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">docs.python.org/3/tutorial/controlflow.html#defining-functions</a></span>
<span class="comment-copy">Functions are first-class objects; the former expression is a reference to the function; the later is an actual call to the same function.</span>
<span class="comment-copy">@Stack It does not return a string representation; it's a reference to the function itself (on which the REPL calls <code>repr</code> to <i>get</i> a string representation to display).</span>
<span class="comment-copy">I'm wondering why this somehow got a better reception than the 2015 duplicate <a href="https://stackoverflow.com/questions/31294125/why-python-need-parentheses-in-function-call">Why python need parentheses in function call?</a></span>
<span class="comment-copy">Makes sense, thanks:) Just a follow up question, which situation would you used it in?</span>
<span class="comment-copy">@Unknown I've added some examples.</span>
