<div class="post-text" itemprop="text">
<p>I'm trying to understand the performance of list comprehensions in Python, and the trade-offs of using them versus for loops to create lists. One of the known performance costs of using a for loop to append elements to a list is that at each iteration it is O(k) (where k is the length of the list) because the append needs to get to the end of the list to add an additional element.</p>
<p>How does this work for list comprehensions? At each iteration does it need to get to the end of the new list to append a new element?</p>
<pre><code># For loop:
# O(n*k) (k=number of elements currently in list) time complexity:
new_list = []
for i in range(n): # O(n)
  new_list.append(i) # O(k) 

# List comprehension:
new_list = [i for i in range(n)] # Is this O(n)? 
</code></pre>
<p>I've searched the Python documentation, Stack Overflow, and other websites and couldn't find any information about this. There are many resources for more higher level information about list comprehensions but nothing specific like this. </p>
<p>If you can't provide an answer can you please direct me to, or show me how to look at the actual underlying Python list comprehension code so I can do this on my own?</p>
</div>
<div class="post-text" itemprop="text">
<p>Appending to a list is <em>amortized</em> <code>O(1)</code> and not <code>O(k)</code>; lists are implemented as variable-length arrays, not as linked-lists. The complexity applies both for <code>for</code> loops with <code>my_list.append</code> calls and list-comprehensions (which, spoiler alert, <em>also</em> append). </p>
<p>So in both cases. The complexity is <code>O(N)</code>.</p>
<p>List-comprehensions generally perform better because they are <em>specialized to do one thing:</em> <strong>create lists</strong>. The byte-code produced for them is specific to that. (See the <a href="https://docs.python.org/3/library/dis.html#opcode-LIST_APPEND" rel="nofollow noreferrer"><code>LIST_APPEND</code></a> bytecode)</p>
<p>Also note that list-comprehensions, like for-loops, don't necessarily append at each iteration. Using <code>if</code> clauses to filter out elements of the iterable you're looping through is commonly used.  </p>
<hr/>
<p>If you'd like to see how list-comprehensions are implemented in CPython, you can take a look at the bytecode produced for them and scan through <code>ceval.c</code> for the actions performed for each.  </p>
<p>The byte-code can be seen with <code>dis</code> after we compile a list-comprehension expression:</p>
<pre><code>dis(compile('[i for i in range(10)]', '', 'exec').co_consts[0])
  1           0 BUILD_LIST               0
              2 LOAD_FAST                0 (.0)
        &gt;&gt;    4 FOR_ITER                 8 (to 14)
              6 STORE_FAST               1 (i)
              8 LOAD_FAST                1 (i)
             10 LIST_APPEND              2
             12 JUMP_ABSOLUTE            4
        &gt;&gt;   14 RETURN_VALUE
</code></pre>
<p>Then, <a href="https://github.com/python/cpython/blob/eea3cc1ef0dec0af193eedb4c1164263fbdfd8cc/Python/ceval.c#L1055" rel="nofollow noreferrer">scan through the cases in <code>ceval.c</code></a> or look at their documentation in the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a>. </p>
</div>
<span class="comment-copy"><a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">Appending to a list is <code>O(1)</code></a></span>
<span class="comment-copy"><code>new_list.append(i)</code> is not <code>O(k)</code>. Inserting may be. but they're optimized to use <code>append</code></span>
<span class="comment-copy">Check the <a href="https://github.com/python/cpython" rel="nofollow noreferrer">cython</a> source code? For performance you could use <code>% timeit</code> magic operator.</span>
<span class="comment-copy">"List comprehensions run a bit faster than equivalent for-loops (unless you're just going to throw away the result)." from: <a href="https://wiki.python.org/moin/PythonSpeed" rel="nofollow noreferrer">wiki.python.org/moin/PythonSpeed</a></span>
<span class="comment-copy">Might be worth mentioning that you can also have nested for-loops in a list-comprehension for completeness, but great answer!</span>
