<div class="post-text" itemprop="text">
<p>Propose <code>s = [1, 2, 3, 4]</code></p>
<p>If you <code>zip(s, s[1:])</code> which returns <code>[(1, 2), (2, 3), (3, 4)]</code>. 
Is it possible to rewrite <code>zip(s, s[1:])</code> to return <code>[(1, 2), (2, 3), (3, 4), (4, 1)]</code>? </p>
<p>Or for generality sake, is it possible to zip a list with itself for the last touple to be <code>(list[-1], list[0])</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can use <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> for handy iterators to accomplish this rather elegantly:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle, islice
&gt;&gt;&gt; s = [1, 2, 3, 4]
&gt;&gt;&gt; list(zip(s, islice(cycle(s), 1, None)))
[(1, 2), (2, 3), (3, 4), (4, 1)]
</code></pre>
<p>Note, <code>itertools.cycle</code> works like this:</p>
<blockquote>
<p><code>cycle('ABCD') --&gt; A B C D A B C D ...</code></p>
</blockquote>
<p>It is an infinite iterator, so be careful. <code>zip</code> here stops at the shortest, so it works fine.</p>
<p>Also, <code>itertools.islice</code>:</p>
<blockquote>
<p><code>islice('ABCDEFG', 2, None) --&gt; C D E F G</code></p>
</blockquote>
<p>Which works just like <code>slice</code> or sequence slicing, i.e. <code>my_list[1:] == my_list[1:None] == my_list[slice(1, None)]</code> except it works on <em>any iterable</em>, not just sequences.</p>
<p>Anyway, note this approach is generalizable:</p>
<pre><code>&gt;&gt;&gt; list(zip(s, islice(cycle(s), 2, None)))
[(1, 3), (2, 4), (3, 1), (4, 2)]
&gt;&gt;&gt; list(zip(s, islice(cycle(s), 3, None)))
[(1, 4), (2, 1), (3, 2), (4, 3)]
&gt;&gt;&gt; list(zip(s, islice(cycle(s), 4, None)))
[(1, 1), (2, 2), (3, 3), (4, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools as it


iterable = [1, 2, 3, 4]

c = it.cycle(iterable)
next(c)

list(zip(iterable, c))
# [(1, 2), (2, 3), (3, 4), (4, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = [1, 2, 3, 4]

&gt;&gt;&gt; zip(s, s[1:] + s[:1])
[(1, 2), (2, 3), (3, 4), (4, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>a pure python cyclic <code>zip</code> answer can be made with a parameterized slice indexing, adding the slices</p>
<pre><code>s = [1, 2, 3, 4]

n = 2

list(zip(s[n::] + s[0:n], s[n+1::] + s[0:n+1]))
Out[100]: [(3, 4), (4, 1), (1, 2), (2, 3)]

n = 0

list(zip(s[n::] + s[0:n], s[n+1::] + s[0:n+1]))
Out[101]: [(1, 2), (2, 3), (3, 4), (4, 1)]
</code></pre>
</div>
<span class="comment-copy">You mean <code>[s[0]]</code>.</span>
<span class="comment-copy">@Piinthesky or <code>s[0:1]</code></span>
<span class="comment-copy">@juanpa.arrivillaga Looks indeed more consistent and is therefore better.</span>
