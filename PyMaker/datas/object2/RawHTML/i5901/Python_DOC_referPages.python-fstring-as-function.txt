<div class="post-text" itemprop="text">
<p>I'd like to use Python f-string for its syntactical simplicity, compared to string.Template() or other approach. However, in my application, the string is loaded from file, and the values of the variable can only be provided later.</p>
<p>If there a way to invoke fstring functionality separate from the string definition? Hopefully code below will better explain what I hope to achieve.</p>
<pre><code>a = 5
s1 = f'a is {a}' # prints 'a is 5'

a = 5
s2 = 'a is {a}'
func(s2) # what should be func equivalent to fstring
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>str.format()</code>.</p>
<p>Preferably, be explicit about passing arguments to it. But as a stopgap measure, you can use <code>locals()</code> to pass a dict of local (function-defined) variables to the formatting function:</p>
<pre><code>foo = 'bar'
print('Foo is actually {foo}'.format(**locals()))
</code></pre>
<p>You can of course copy <code>globals()</code> to a local dict, and merge <code>locals()</code> to it, and use it to more closely emulate the f-string approach.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can format it this way. pass in a dictionary of possible values for a and map it to your string. </p>
<pre><code>dictionary = {
  'a':[5,10,15]
}

def func(d):
  for i in range(3):
      print('a is {{a[{0}]}}'.format(i).format_map(d))

func(dictionary)
</code></pre>
<p>print:</p>
<pre><code>a is 5
a is 10
a is 15
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's what you were looking for:</p>
<p><code>pip install fstring</code></p>
<pre><code>from fstring import fstring

x = 1

y = 2.0

plus_result = "3.0"

print fstring("{x}+{y}={plus_result}")

# Prints: 1+2.0=3.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here you go:</p>
<pre><code>In [58]: from functools import partial

In [59]: def func(var_name, a):
    ...:     return var_name + f' is {a}'
    ...:

In [60]: f = partial(func, 'a')

In [61]: f(5)
Out[61]: 'a is 5'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3.1/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> like this:</p>
<pre><code>def f(string):
    frame = inspect.currentframe()
    g = frame.f_back.f_globals
    l = frame.f_back.f_locals
    try:
        repl = lambda m: str(eval(m.group(1), g, l))
        return re.sub(r'{(.+?)}', repl, string)
    finally:
        del frame
</code></pre>
<p>The function runs a regex replace that replaces all bracketed strings after running them through <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">eval</a>. Using <a href="https://docs.python.org/3/library/inspect.html#inspect.currentframe" rel="nofollow noreferrer">inspect.currentframe()</a> we get the outside (caller's) scope.</p>
<pre><code>&gt;&gt;&gt; a = 5
&gt;&gt;&gt; s2 = 'a is {a}'
&gt;&gt;&gt; print f(s2)
a is 5
</code></pre>
<blockquote>
<p><strong>Note:</strong> This can easily be extended to handle format flags like !r.</p>
</blockquote>
</div>
<span class="comment-copy">Alternate, <code>'foo is {foo}'.format_map(locals())</code></span>
<span class="comment-copy">This isn't equivalent, though may answer this user's question - <code>f'1+2 is {1=2}'</code> returns `'1+2 is 3'. See the answer relating to the string module below.</span>
<span class="comment-copy">@SteveHarris: Indeed, not equivalent! You likely don't want to evaluate expressions in strings loaded from a file when all you want is to pretty-print them. Evaluating untrusted input is a security hole.</span>
<span class="comment-copy">That's exactly what I was looking for when I found this question. The original equation was specifically about fstrings.</span>
<span class="comment-copy">Why was this downvoted? Use of 'eval'? It does most of what python 3 f-strings do but with delayed evaluation, as requested by OP.</span>
