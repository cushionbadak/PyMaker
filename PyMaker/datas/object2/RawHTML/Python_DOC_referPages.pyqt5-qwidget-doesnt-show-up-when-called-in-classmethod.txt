<div class="post-text" itemprop="text">
<p>I want to call a <code>QWidget()</code> within a <code>@classmethod</code> to obtain the parameters for the class from a Qt form:</p>
<pre><code>from PyQt5.QtWidgets import QWidget, QApplication
import sys


class FormDialog(QWidget):

    def __init__(self):
        QWidget.__init__(self)
        super(FormDialog, self).__init__()

        print("FormDialog called")


class Files(object):

    def __init__(self):
        pass

    @classmethod
    def from_gui(cls):
        form = FormDialog()
        form.show()

        return cls()


if __name__ == '__main__':

    app = QApplication(sys.argv)
    obj = Files.from_gui()  # "FormDialog called" appears, but window doesn't show up

    form = FormDialog()  # "FormDialog called" appears
    form.show()  # Window appears

    sys.exit(app.exec_())
</code></pre>
<p>If I call the <code>FormDialog()</code> within the <code>@classmethod</code>, the window doesn't show up. If I call it outside of the <code>@classmethod</code>, everything works like intended. Why?</p>
</div>
<div class="post-text" itemprop="text">
<p>Put this method in the FormDialog class to see what is really happen</p>
<pre><code>def __del__(self):
    print('Deleting the form')
</code></pre>
<p>The formDialog is destroyed when the from_gui method return.</p>
<p>You can solve it with :</p>
<ol>
<li><p>returning the form outside the from_gui, so it can live out of from_gui scope</p></li>
<li><p>Make FormDialog inherit QDialog instead of QWidget and use exec instead of show, this way the dialog shows and blocks, next instruction will be executed after the dialog is destroyed</p></li>
</ol>
</div>
