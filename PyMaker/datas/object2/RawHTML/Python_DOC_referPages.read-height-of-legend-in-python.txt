<div class="post-text" itemprop="text">
<p>I have some plots with a lot of information and lines, so sometimes I tend to put the legend outside the plot itself <code>using bbox_to_anchor</code>. I also prefer to have a title of the plot, but this will positionally coincide with the legend in that case. The following example below is just an illustration of the problem. </p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

t = np.arange(0.0, 2.0, 0.01)
s = 1 + np.sin(2 * np.pi * t)
r = 1 + np.sin(4 * np.pi * t)
q = 1 + np.sin(6 * np.pi * t)

fig, ax = plt.subplots()
ax.plot(t, s, label='S')
ax.plot(t, r, label='R')
ax.plot(t, q, label='Q')
leg = ax.legend(loc=3, ncol=3, bbox_to_anchor=(.0, 1.02, 1., .102), borderaxespad=0., mode='expand')
ax.set_title('SIMPLE PLOT', y=1.1)
plt.show()
</code></pre>
<p>To avoid this, I set some kind of y-value (e.g. <code>y=1.1</code>). I would like to automate this process because I keep updating the same plot with new data, so the legend grows in size, and I need to adjust the position of the title accordingly. </p>
<ul>
<li>Is there a way to automate this process? </li>
<li>Is there a function in Python that is able to read the height of the legend so that this can be used to adjust the title position?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The height of the legend is determined at draw time. You can get it after having drawn the figure via <code>legend.get_window_extent()</code>. The resulting bounding box is in units of pixels. In order to find the offset of the title, you will need to subtract the upper limit of the legend from the upper limit of the axes. So you need to get the axes position in pixels as well. </p>
<p>The title can be offset either in figure coordinates (<code>y=1.1</code>) or points (<code>pad=20</code>). I would suggest to use points here, to make it independent of the size of the axes. So you can calculate the difference in upper positions, convert from pixels to points (i.e. <code>distance [pixels] * ppi / dpi</code>) and add some constant offset in points (because usually you would not want the title to sit exactly on the border of the legend). Then use that number as <code>pad</code>.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt


fig, ax = plt.subplots(constrained_layout=True)

ax.plot([1,2,3], np.random.rand(3,5), label='Label')

leg = ax.legend(loc="lower center", ncol=3, bbox_to_anchor=(.0, 1.02, 1., 1.02),
                borderaxespad=0, mode='expand')

fig.canvas.draw()
leg_box = leg.get_window_extent()
ax_box = ax.get_position().transformed(fig.transFigure)
pad = (leg_box.y1 - ax_box.y1)*72./fig.dpi + 6
ax.set_title('SIMPLE PLOT', pad=pad)

plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/YNGAV.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/YNGAV.png"/></a></p>
<p>Note that here I also used <code>constrained_layout</code> to have the title not cropped by the figure boundaries. </p>
</div>
<span class="comment-copy">Thank you, @ImportanceOfBeingErnest -- this was actually what I had in mind!</span>
