<div class="post-text" itemprop="text">
<p>I do understand how <code>setattr()</code> works in python, but my question is when i try to dynamically set an attribute and give it an unbound function as a value, so the attribute is a callable, the attribute ends up taking the name of the unbound function when i call <code>attr.__name__</code> instead of the name of the attribute. </p>
<p>Here's an example:</p>
<p>I have a <code>Filter</code> class:</p>
<pre><code>class Filter:
    def __init__(self, column=['poi_id', 'tp.event'], access=['con', 'don']):
        self.column = column
        self.access = access
        self.accessor_column = dict(zip(self.access, self.column))
        self.set_conditions()

    def condition(self, name):
        # i want to be able to get the name of the dynamically set 
        # function and check `self.accessor_column` for a value, but when
        # i do `setattr(self, 'accessor', self.condition)`, the function 
        # name is always set to `condition` rather than `accessor`
        return name

    def set_conditions(self):
        mapping = list(zip(self.column, self.access))
        for i in mapping:
            poi_column = i[0]
            accessor = i[1]
            setattr(self, accessor, self.condition)

</code></pre>
<p>In the class above, the <code>set_conditions</code> function dynamically set attributes (<code>con</code> and <code>don</code>) of the Filter class and assigns them a callable, but they retain the initial name of the function.</p>
<p>When i run this:</p>
<pre><code>&gt;&gt;&gt; f = Filter()
&gt;&gt;&gt; print(f.con('linux'))
&gt;&gt;&gt; print(f.con.__name__)
</code></pre>
<p>Expected: </p>
<ul>
<li>linux</li>
<li>con (which should be the name of the dynamically set attribute)</li>
</ul>
<p>I get:</p>
<ul>
<li>linux</li>
<li>condition (name of the value (unbound <code>self.condition</code>) of the attribute)</li>
</ul>
<p>But i expect <code>f.con.__name__</code> to return the name of the attribute (<code>con</code>) and not the name of the unbound function (<code>condition</code>) assigned to it.</p>
<p>Can someone please explain to me why this behaviour is such and how can i go around it? </p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>function.__name__</code> is the name under which the function has been initially defined, it has nothing to do with the name under which it is accessed. Actually, the whole point of <code>function.__name__</code> is to correctly identify the function whatever name is used to access it. You definitly want to <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">read this for more on what Python's "names" are</a>.</p>
<p>One of the possible solutions here is replace the static definition of <code>condition</code> with a closure:</p>
<pre><code>class Filter(object):
    def __init__(self, column=['poi_id', 'tp.event'], access=['con', 'don']):
        self.column = column
        self.access = access
        self.accessor_column = dict(zip(self.access, self.column))
        self.set_conditions()

    def set_conditions(self):
        mapping = list(zip(self.column, self.access))
        for column_name, accessor_name in mapping:
            def accessor(name):
                print("in {}.accessor '{}' for column '{}'".format(self, accessor_name, column_name))
                return name

            # this is now technically useless but helps with inspection
            accessor.__name__ = accessor_name
            setattr(self, accessor_name, accessor)
</code></pre>
<p>As a side note (totally unrelated but I thought you may want to know this), using mutable objects as function arguments defaults is <a href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments" rel="nofollow noreferrer">one of the most infamous Python gotchas</a> and may yield totally unexpected results, ie:</p>
<pre><code>&gt;&gt;&gt; f1 = Filter()
&gt;&gt;&gt; f2 = Filter()
&gt;&gt;&gt; f1.column
['poi_id', 'tp.event']
&gt;&gt;&gt; f2.column
['poi_id', 'tp.event']
&gt;&gt;&gt; f2.column.append("WTF")
&gt;&gt;&gt; f1.column
['poi_id', 'tp.event', 'WTF']
</code></pre>
<p>EDIT: </p>
<blockquote>
<p>thank you for your answer, but it doesn't touch my issue here. My problem is not how functions are named or defined, my problem it that when i use setattr() and i set an attribute and i give it a function as it's value, i can access the value and perform what the value does, but since it's a function, why doesn't it return it's name as the function name</p>
</blockquote>
<p>Because as I already explained above, the function's <code>__name__</code> attribute and the name of the <code>Filter</code> instance attribute(s) refering to this function are totally unrelated, and the function knows absolutely <strong>nothing</strong> about the names of variables or attributes that reference it, as explained in the reference article I linked to.</p>
<p>Actually the fact that the object you're passing to <code>setattr</code> is a function is totally irrelevant, from the object's POV it's just a name and an object, period. And actually the fact you're binding this object (function or just <em>whatever</em> object) to an instance attribute (whether directly or using <code>setattr()</code>, it works just the same) instead of a plain variable is also totally irrelevant - none of those operation will have any impact on the object that is bound (except for increasing it's ref counter but that's a CPython implementation detail - other implementations may implement garbage collection diffently). </p>
</div>
<div class="post-text" itemprop="text">
<p>May I suggest you this :</p>
<pre><code>from types import SimpleNamespace

class Filter:
    def __init__(self, column=['poi_id', 'tp.event'], access=['con', 'don']):
        self.column = column
        self.access = access
        self.accessor_column = dict(zip(self.access, self.column))
        self.set_conditions()

    def set_conditions(self):
        for i in self.access:
            setattr(self, i, SimpleNamespace(name=i, func=lambda name: name))

f = Filter()
print(f.con.func('linux'))
&gt;&gt;&gt; linux
print(f.con.name)
&gt;&gt;&gt; con
</code></pre>
<p>[edited after bruno desthuilliers's comment.]</p>
</div>
<span class="comment-copy">See also <a href="https://stackoverflow.com/questions/40661758/name-of-a-python-function-in-a-stack-trace/40663943#40663943" title="name of a python function in a stack trace">stackoverflow.com/questions/40661758/â€¦</a></span>
<span class="comment-copy">Hi Bruno, thank you for your answer, but it doesn't touch my issue here. My problem is not how functions are named or defined, my problem it that when i use <code>setattr()</code> and i set an attribute and i give it a function as it's value, i can access the value and perform what the value does, but since it's a function, why doesn't it return it's name as the function name, i'd look into <code>setattr</code>.   Also concerning using mutable objects as function args, i don't plan on updating/changing (appending) to these arguments, so i saw no harm here.  Thank you so much again.</span>
<span class="comment-copy">@EmmanuelEvbuomwan cf my edited answer - TL;DR : I <b>did</b> answer your question already.</span>
<span class="comment-copy">I just read your edit, it's quite very clear now, thanks.</span>
<span class="comment-copy">You're welcome ;-)</span>
<span class="comment-copy">Python has no pointer. <code>f.con</code> is actually an expression that evaluates as <code>getattr(f, "con")</code>, which in turn will evaluate to <code>f.__dict__["con"]</code>, which is a reference to the <code>method</code> instance created when evaluating <code>self.condition</code>, which method holds references to <code>f</code>, <code>Filter</code> and <code>Filter.__dict__["condition"]</code>.</span>
