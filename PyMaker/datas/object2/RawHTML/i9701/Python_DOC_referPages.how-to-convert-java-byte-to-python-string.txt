<div class="post-text" itemprop="text">
<p>I know that java and python handle bytes differently so I am a little bit confused about how to convert byte[] to python string
I have this byte[] in java  </p>
<pre><code>{ 118, -86, -46, -63, 100, -69, -30, -102, -82, -44, -40, 92, 0, 98, 36, -94 }
</code></pre>
<p>I want to convert it to python string
 here is how i did  it</p>
<pre><code>b=[118, -86, -46, -63, 100, -69, -30, -102, -82, -44, -40, 92, 0, 98, 36, -94]
str=""
for i in b:
    str=str+chr(abs(i))
</code></pre>
<p>But I am not really sure if this is the correct way to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Java <code>byte</code> type is a <em>signed integer</em>; the value ranges between -128 and 127. Python's <code>chr</code> expects a value between 0 and 255 instead. From the <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="nofollow noreferrer"><em>Primitive Data Types</em> section</a> of the Java tutorial:</p>
<blockquote>
<p><strong>byte</strong>: The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive). </p>
</blockquote>
<p>You need to convert from 2s compliment to an unsigned integer:</p>
<pre><code>def twoscomplement_to_unsigned(i):
    return i % 256

result = ''.join([chr(twoscomplement_to_unsigned(i)) for i in b])
</code></pre>
<p>However, if this is Python 3, you really want to use the <code>bytes</code> type:</p>
<pre><code>result = bytes(map(twoscomplement_to_unsigned, b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>String concatenation is highly inefficient.</p>
<p>I'd recommend to do that in a generator comprehension passed to <code>str.join</code> using an empty separator:</p>
<pre><code>s = "".join([chr(abs(x)) for x in b])
</code></pre>
<p>edit: the <code>abs</code> bit is weird. It does what's requested, but nothing useful since <code>byte</code> is signed. So you'd need two's complement as in Martijn answer that fixes the next OP problem: data validity :)</p>
<p>It would be okay if you had some list of ASCII values in a table (and dropping <code>abs</code> allows us to use <code>map</code>, it's so rare to be able to use it let's not deprive us from doing so :)</p>
<pre><code>items = [65, 66, 67, 68]
print("".join(map(chr,items)))
</code></pre>
<p>result:</p>
<pre><code>"ABCD"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're using Python 3, bytes can already be initialized from a list. You'll need to convert the signed integers to unsigned bytes first.</p>
<pre><code>items = [118, -86, -46, -63, 100, -69, -30, -102, -82, -44, -40, 92, 0, 98, 36, -94]
data = bytes(b % 256 for b in items)
print(data)  # b'v\xaa\xd2\xc1d\xbb\xe2\x9a\xae\xd4\xd8\\\x00b$\xa2'
</code></pre>
<p>If the bytes represent text, decode it afterwards. In your example, they do not represent text encoded to UTF-8, so this would fail.</p>
<pre><code>data = data.decode('utf8')
print(data)
</code></pre>
</div>
<span class="comment-copy"><code>byte</code> is a datatype in java that does not correspond to python bytestrings. While you can get a result from this, it is likely meaningless.</span>
<span class="comment-copy">If those bytes are stored in 2-complement, then you are destroying information by using abs()</span>
<span class="comment-copy">See "<a href="https://stackoverflow.com/questions/961632">Converting integer to string in Python?</a>" for the minimal case of converting a single Python <code>int</code> to a <code>str</code>.</span>
<span class="comment-copy">You were done converting it to Python when you typed <code>b=[118, ...]</code>. Your real question is probably more like "How do I convert a Python list to a string?", or maybe "How do I convert many Python integers to a string?". The first is probably either <code>str(b)</code> or <code>repr(b)</code>; the second is something like <code>' '.join(str(x) for x in b)</code>.  See also the docs for <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>str.join</code></a>.</span>
<span class="comment-copy">can also implement as <code>i % 256</code> (in python)</span>
<span class="comment-copy">@AnthonySottile: much better idea, thanks.</span>
<span class="comment-copy">Martijn I noticed that you use a list inside the parenthesis when joining. So it's really faster than directly passing the gencomp to <code>join</code> right?</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre: see <a href="//stackoverflow.com/a/9061024">List comprehension without [ ] in Python</a>; for <i><code>str.join()</code></i> it is faster to pass in a list.</span>
<span class="comment-copy">I already stumbled on it, hence my question. So long for "less signs and more letters". A lot of people would advise to remove them, but <code>join</code> creates the list anyway, only slower. BTW it must be the same performance issue with <code>"".join(map(chr,items))</code> then? this <code>map</code> function is really really useless nowadays.</span>
<span class="comment-copy">Would it be possibly more efficient to do <code>map(lambda x: chr(abs(x)), b)</code>?</span>
<span class="comment-copy">I think it's equivalent. But as you say, passing absolute value of a negative byte is not recommended.</span>
<span class="comment-copy">You can't just use <code>abs()</code> on those byte values...</span>
<span class="comment-copy">@MartijnPieters yes, it does nothing useful.</span>
<span class="comment-copy">I got the joke! sorry I just copied the OP flawed code. fixed</span>
