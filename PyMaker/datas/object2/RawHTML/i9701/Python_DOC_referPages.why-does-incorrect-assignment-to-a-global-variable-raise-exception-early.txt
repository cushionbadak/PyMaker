<div class="post-text" itemprop="text">
<pre><code>a = 10
def f():
  print(1)
  print(a) # UnboundLocalError raised here
  a = 20
f()
</code></pre>
<p>This code of course raises <code>UnboundLocalError: local variable 'a' referenced before assignment</code>. But why is this exception raised at the <code>print(a)</code> line?</p>
<p>If the interpreter executed code line by line (like I thought it did), it wouldn't know anything was wrong when <code>print(a)</code> was reached; it would just think that <code>a</code> referred to the global variable.</p>
<p>So it appears the interpreter reads the entire function in advance to figure out whether <code>a</code> is used for assignment. Is this documented anywhere? Is there any other occasion where the interpreter looks ahead (apart from checking for syntax errors)?</p>
<p>To clarify, the exception itself is perfectly clear: global variables can be read without <code>global</code> declaration, but not written (this design prevents bugs due to unintentionally modifying global variables; those bugs are especially hard to debug because they lead to errors that occur far from the location of the erroneous code). I'm just curious why the exception is raised early.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/faq/programming.html?highlight=unboundlocalerror#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">Python's documentation</a>, the interpreter will first notice an assignment for a variable named <code>a</code> in the scope of <code>f()</code> (no matter the position of the assignment in the function) and then as a consequence only recognize the variable <code>a</code> as a local variable in this scope. This behavior effectively <a href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="nofollow noreferrer"><em>shadows</em></a> the global variable <code>a</code>.</p>
<p>The exception is then raised "early", because the interpreter which executes the code "line by line", will encounter the print statement referencing a local variable, which is not yet bound at this point (remember, Python is looking for a <code>local</code> variable here).</p>
<p>As you mentioned in your question, one has to use the <code>global</code> keyword to explicitly tell the compiler that the assignment in this scope is done to the global variable the correct code would be:</p>
<pre><code>a = 10
def f():
  global a
  print(1)
  print(a) # Prints 10 as expected
  a = 20
f()
</code></pre>
<p>As <a href="https://stackoverflow.com/users/691859/2rs2ts">@2rs2ts</a> said in a now-deleted answer, this is easily explained by the fact that "Python is not merely interpreted, it is compiled into a bytecode and not just interpreted line by line".</p>
</div>
<div class="post-text" itemprop="text">
<p>In the <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="noreferrer">Resolution of Names</a> section of the Python Reference Manual this is stated:</p>
<blockquote>
<p>[..] If the current scope is a function scope, and the <em>name refers to a local variable that has not yet been bound to a value</em> at the point where the name is used, an <code>UnboundLocalError</code> exception is raised [..]</p>
</blockquote>
<p>that's the official word on when <code>UnboundLocalError</code> occurs. If you take a look at the bytecode CPython generates for your function <code>f</code> with <a href="https://docs.python.org/3.6/library/dis.html" rel="noreferrer"><code>dis</code></a> you can see it trying to load the name from a local scope when its value hasn't even been set yet:</p>
<pre><code>&gt;&gt;&gt; dis.dis(f)
  3           0 LOAD_GLOBAL              0 (print)
              3 LOAD_CONST               1 (1)
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 POP_TOP

  4          10 LOAD_GLOBAL              0 (print)
             13 LOAD_FAST                0 (a)      # &lt;-- this command
             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             19 POP_TOP

  5          20 LOAD_CONST               2 (20)
             23 STORE_FAST               0 (a)
             26 LOAD_CONST               0 (None)
             29 RETURN_VALUE
</code></pre>
<p>As you can see, the name <code>'a'</code> is loaded onto the stack by means of the <a href="https://docs.python.org/3.6/library/dis.html#opcode-LOAD_FAST" rel="noreferrer"><code>LOAD_FAST</code></a> command:</p>
<pre><code>             13 LOAD_FAST                0 (a)
</code></pre>
<p>This is the command that is used to grab <em>local</em> variables in a function (named <code>FAST</code> due to it being quite faster than loading from the global scope with <code>LOAD_GLOBAL</code>). </p>
<p>This really has nothing to do with the global name <code>a</code> that has been defined previously. It has to do with the fact that CPython will assume you're playing nice and generate a <code>LOAD_FAST</code> for references to <code>'a'</code> since <code>'a'</code> is being <em>assigned to</em> (i.e made a local name) inside the function body.</p>
<p>For a function with a single name access and no corresponding assignment, CPython does not generate a <code>LOAD_FAST</code> and instead goes and looks at the global scope with <code>LOAD_GLOBAL</code>:</p>
<pre><code>&gt;&gt;&gt; def g():
...    print(b)
&gt;&gt;&gt; dis.dis(g)
  2           0 LOAD_GLOBAL              0 (print)
              3 LOAD_GLOBAL              1 (b)
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 POP_TOP
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE
</code></pre>
<blockquote>
<p><sub>So it appears the interpreter reads the entire function in advance to figure out whether <code>a</code> is used for assignment. Is this documented anywhere? Is there any other occasion where the interpreter looks ahead (apart from checking for syntax errors)?</sub></p>
</blockquote>
<p>In the Compound Statements section of the reference manual the following is stated for function definitions:</p>
<blockquote>
<p>A function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function).</p>
</blockquote>
<p>Specifically, it binds the name <code>f</code> to a function object that holds the compiled code, <code>f.__code__</code>, that <code>dis</code> prettifies for us. </p>
</div>
<span class="comment-copy">I think you'll find that python cannot access global variables from inside functions by default. You will have to explicitly declare that you mean to use a global. (btw Don't Use Global Variables).</span>
<span class="comment-copy">@quamrana untrue. If you remove the assignment to the local <code>a</code> the code prints <code>10</code>.</span>
<span class="comment-copy">For what it's worth, this isn't specific to python 3, just tested in python 2 and the same thing happens.</span>
<span class="comment-copy">I think you'll find that python cannot (<b>edit</b>) &lt;strike&gt;access&lt;/strike&gt; <i>write to</i> global variables from inside functions by default. You will have to explicitly declare that you mean to use a global. (btw Don't Use Global Variables).</span>
<span class="comment-copy">There are many similar/duplicates like <a href="http://stackoverflow.com/a/17097379/4230591">this</a> but since this Q doesn't have redundant code, i think it shouldn't be closed.</span>
<span class="comment-copy">Does the fact that the script is compiled into bytecode first rather than interpreted line by line has any other (slightly) unexpected consequences?</span>
<span class="comment-copy">Not that I'm aware of off the top of my head, but I'm probably wrong. Something I know is that python is not optimized much by the compiler because the language is very dynamic (no static types, methods can be replaced on the fly, etc) so it makes it very difficult. Generally speaking, the code is compiled to bytecode only to remove the parsing time at each function call (the runtime just looks up the bytecodes in a big lookup table, instead of parsing everything again). cc @max</span>
<span class="comment-copy">@max: Compilation and interpretation are completely and utterly irrelevant to your question. You are asking about <i>Semantics</i>, i.e. the Python Language Specification. The Python Language Specification says that all variables assigned in a function are local unless declared <code>global</code>. Period. Compilation and interpretation are question of <i>Pragmatics</i>, i.e. any particular Python implementation. But any particular Python implementation, regardless of whether it is compiled or interpreted must abide by the Python Language Specification. Otherwise it wouldn't <i>be</i> a "Python implementation", it …</span>
<span class="comment-copy">… would be an implementation of a completely different language that kinda-sorta resembles Python. Even if there weren't any Python implementations <i>at all</i>, if Python only existed on paper (or even only in Guido van Rossum's head), the behavior would still be the same one you are seeing, because the Python Language Specification says that the behavior you <i>are</i> seeing is the one you <i>should</i> be seeing. Don't confuse the programming language "Python" with the implementation "CPython". E.g.: the behavior you are seeing is part of "Python" and thus identical in <i>all</i> implementations (Pyston, …</span>
<span class="comment-copy">… PyPy, IronPython, Jython, CPython, Pynie, …), whereas reference counting and deterministic finalization, the GIL, the C extension API are party of "CPython" and don't necessarily exist in other implementations.</span>
