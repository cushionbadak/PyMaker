<div class="post-text" itemprop="text">
<p>I wrote a function to validate Json objects in Python. Here is the code snippet:</p>
<pre><code>def is_json(myjson):
    """
    Check whether a string is a json object.
    :param myjson: the string to check
    :return: True/False
    """
    try:
        json_object = json.loads(myjson)
    except ValueError, e:
        return False
    return True
</code></pre>
<p>However, I happened to find that it allows digit string. For instance, </p>
<pre><code>is_json("123") # return True
is_json("-123") # return True
is_json("0123") # return False
is_json(" 123") # return True
</code></pre>
<p>From my understanding, number should not be part of Json data. And I also confirmed it with some other <a href="https://jsonformatter.curiousconcept.com/" rel="nofollow noreferrer">Json formatter tool</a>. If it is true, why would <code>json.loads</code> permit digits strings?  </p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like Python's <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer"><code>json</code></a> module supports JSON specified by RFC 7159:</p>
<blockquote>
<p>JSON (JavaScript Object Notation), specified by RFC 7159 (which obsoletes RFC 4627)</p>
</blockquote>
<p>Playing around with the validator you linked, "123" is invalid in 4627, but valid in 7159.</p>
<p>Comparing the two RFCs, it looks like the definition of what comprises valid JSON text became more broad. In 4627:</p>
<blockquote>
<p><code>JSON-text = object / array</code></p>
</blockquote>
<p>And in 7159:</p>
<blockquote>
<p><code>JSON-text = ws value ws</code></p>
</blockquote>
<p>(ws meaning "optional whitespace")</p>
<p>So originally you could only have an object or an array, but now you can have a value, which is "an object, array, number, or string, or one of the [...] names: false null true".</p>
<p>The <code>json</code> module documentation discusses the difference further:</p>
<blockquote>
<p>The old version of JSON specified by the obsolete RFC 4627 required that the top-level value of a JSON text must be either a JSON object or array (Python dict or list), and could not be a JSON null, boolean, number, or string value. RFC 7159 removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer.</p>
</blockquote>
</div>
<span class="comment-copy">whicg python version?</span>
<span class="comment-copy">@ItayMoav-Malimovka Python 2.7.12</span>
<span class="comment-copy">@Kevin yes python appears to use RFC 7159  hence this is correct. <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer">docs.python.org/3/library/json.html</a></span>
<span class="comment-copy">@Kevin, I think you are right. "The JSON format is specified by RFC 7159 and by ECMA-404." quoted from <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer">docs.python.org/2/library/json.html</a></span>
<span class="comment-copy"><code>is_json(" 123") # return False</code> I ran your code, and this returns True (as it should)</span>
<span class="comment-copy">What if I want my function adhere to RFC 4627 cos I want to exclude numbers in the validator function?</span>
<span class="comment-copy">@this-vidor, whoops, I thought a "value" was synonymous with "a valid standalone JSON document" but really it's <code>JSON-text</code>. Edited.</span>
<span class="comment-copy">@Theresa, it doesn't look like there's any easy way to make a strict RFC 4627-compliant parser using just the builtin modules. In principle you could write your own parser (perhaps using Lex/Yacc/Flex/Bison), but that's a very "batteries not included" approach (and I'm not even sure how those tools integrate with Python, if at all).</span>
<span class="comment-copy">Re: Not easy to comply strictly to RFC 4627 - Maybe I'm reading the RFC wrong, but it seems to me you could simply check whether the result (i.e. <code>json_object</code> in OP's example) was a Python <code>dict</code> or <code>list</code> (JSON object or array), and if not, then reject. Also, RFC 4627 has the following passage: <i>A JSON parser MUST accept all texts that conform to the JSON grammar. A JSON parser MAY accept non-JSON forms or extensions.</i> Thus, a parser that complies with RFC 7159 is, by that provision in RFC 4627, also a parser that complies with RFC 4627 (with extensions), isn't it?</span>
<span class="comment-copy">@njzk2: Yes, if the OP's code was accurate, Python's <code>json</code> module would not have been RFC7159-compliant. Fortunately, the OP's code was incorrect. <code>import json; assert json.loads(" 123") == 123</code> works fine for me in Python 2.7.10.</span>
