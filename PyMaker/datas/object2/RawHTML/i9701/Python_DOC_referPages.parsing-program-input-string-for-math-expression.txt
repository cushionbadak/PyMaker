<div class="post-text" itemprop="text">
<p>I'm trying to program a <code>worlfram alpha</code> like math expression solver. 
My current obstacle is figuring out which opening and closing brackets are corresponding. </p>
<p>For example, how would I figure out which brackets in <code>((1 * 3) / (4 / 2))</code> are matching. The program will solve each of these sections individually, and when doing so replacing the section in the original with the answer. </p>
<p>So, for example, the first section the program would try to solve in <code>((1 * 3) / (4 / 2))</code> would be <code>(1 * 3)</code>, so it would replace that section with the product, 3, and <code>((1 * 3) / (4 / 2))</code> would now be <code>(3 / (4 / 2))</code>. </p>
<p>My current code, if helpful is here - <a href="http://pastebin.com/Xpayzbff" rel="nofollow noreferrer">http://pastebin.com/Xpayzbff</a>, the function that is handling the paring is <code>parse()</code>. </p>
<p>Thanks! </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not gonna write code for you, because that would defeat the point, but what you probably want is the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" rel="nofollow noreferrer">Shunting-yard algorithm</a>. It converts from infix (how humans normally represent series of operations, with the operator <em>in</em> the operands) into postfix(which is easy for a computer to evaluate, with the operator <em>after</em> the operands).</p>
<p>Here is someone who did it for boolean login in python: <a href="https://msoulier.wordpress.com/2009/08/01/dijkstras-shunting-yard-algorithm-in-python/" rel="nofollow noreferrer">https://msoulier.wordpress.com/2009/08/01/dijkstras-shunting-yard-algorithm-in-python/</a></p>
<p>You could also try parsing the statement directly into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="nofollow noreferrer">AST</a>, which you could then manipulate.</p>
<p>Also make sure to check out the <a href="https://docs.python.org/3/library/tokenize.html" rel="nofollow noreferrer">tokenizer module</a> for python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Treat an expression between brackets as a list of symbols which can also contain another list. So <code>"((1 * 3) / (4 / 2))"</code> is represented by <code>[['1', '*', '3'], '/', ['4', '/' '2']]</code>. Call a list of symbols a ‘node’.</p>
<p>As you iterate the string, maintain a stack, which keeps track of the ‘bracket pair’ (or node) that you’re in. Append symbols to the last node in the stack (<code>current_node</code>). At each <code>'('</code>, add a new node to the node you’re in, <em>and</em> to the stack. At each <code>')'</code>, pop the stack, so that you’re in the parent node, and further symbols will be appended there.</p>
<p>Then you can recursively evaluate each node, inside first, until you have a final value.</p>
<p>Reverse engineer this code.</p>
<pre><code>def parse(expr):
    stack = [[]]
    for i in expr:
        current_node = stack[-1]
        if i == '(':
            new_node = []
            current_node.append(new_node)
            stack.append(new_node)
        elif i == ')':
            stack.pop()
        elif not i.isspace():
            current_node.append(i)

    return stack[0]

print(parse('(1 * 3) / (4 / 2)')) # [['1', '*', '3'], '/', ['4', '/', '2']]
</code></pre>
<hr/>
<p>Check out this question:
<a href="https://stackoverflow.com/questions/1651487/python-parsing-bracketed-blocks">Python parsing bracketed blocks</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" rel="nofollow noreferrer">Shunting-Yard</a> algorithm. However, a complete implementation of the algorithm is pretty involved. Here is simpler, somewhat naive version that could give you a basic understanding <a href="https://gist.github.com/tiabas/339f5c06f541c176a02c02cc3113d6f7" rel="nofollow noreferrer">https://gist.github.com/tiabas/339f5c06f541c176a02c02cc3113d6f7</a> </p>
<pre><code># Simple Shunting-Yard solution
#
# Given a math expression, parse and evaluate
# the expression
#
# E.g '2+1' =&gt; 3, 8/2*4+1 =&gt; 17, 2+(1*2) = 4, ((2+4)/2*7) =&gt; 21
# 
def parse_math_expression(exp):
    PRECENDENCE = {
        ')': 3,
        '(': 3,
        '*': 1,
        '/': 1,
        '+': 0,
        '-': 0,
    }
    output = []
    operators = []
    for ch in exp:
        # Handle nested expressions
        if ch == ')':
            opr = operators.pop(0)
            while opr != '(':
                output.append(opr)
                opr = operators.pop(0)
        elif ch.isdigit():
            output.append(ch)
        else:
            # Handle operator prescendence
            top_op = None
            if len(operators) and operators[0]:
                top_op = operators[0]
            # Check if top operator has greater prcendencethan current char
            if top_op in ['*', '/'] and PRECENDENCE[top_op] &gt; PRECENDENCE[ch]:
                output.append(top_op)
                operators.pop(0)
            # Push operator onto queues
            operators.insert(0, ch)
    # Handle any leftover operators
    while len(operators):
        output.append(operators.pop(0))
    return output

test1 = "(2+1)"
assert parse_math_expression(test1) == ['2', '1', '+']
test2 = "((2+4)/(2*7))"
assert parse_math_expression(test2) == ['2', '4', '+', '2', '7', '*', '/']
test3 = "(3*2)+(4/2)"
assert parse_math_expression(test3) == ['3', '2', '*','4', '2', '/','+']

def eval_parsed_expression(exp):
    OPRS = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: a / b
    }
    tmp = []
    while len(exp) &gt; 1:
        k = exp.pop(0)
        while not k in ['*', '-', '+', '/']:
            tmp.insert(0, k)
            k = exp.pop(0)
        o = k
        b = tmp.pop(0)
        a = tmp.pop(0)
        r = OPRS[o](int(a), int(b))
        exp.insert(0, r)
    return exp[0]

test4 = ['2', '1', '+'] # (2+1*2)
assert eval_parsed_expression(test4) == 3
test5 = ['2', '1', '2', '*', '+'] # (2+1*2)
assert eval_parsed_expression(test5) == 4
test6 = ['3', '2', '*','4', '2', '/','+'] # (3*2)+(4/2)
assert eval_parsed_expression(test6) == 8
</code></pre>
</div>
<span class="comment-copy">As I say <a href="http://stackoverflow.com/users/2617068/tigerhawkt3?tab=profile">in my profile</a>, calculators are not the best choice for a beginner coding project. You might consider programming something like a card game or board game instead.</span>
<span class="comment-copy">To implement an infix expression evaluator (not a solver, because solver is something else), you need to understand and use recursion.</span>
<span class="comment-copy">@TigerhawkT3 or at least a single operation one with three separate args</span>
<span class="comment-copy">Please do not use PasteBin. Make your questions self contained, and a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of what you wish to accomplish</span>
<span class="comment-copy">@DYZ Didn't realize  pastebin was poor choice, but in the code I have so far I do use recursion, but the way it selects a section doesn't work for all expressions</span>
