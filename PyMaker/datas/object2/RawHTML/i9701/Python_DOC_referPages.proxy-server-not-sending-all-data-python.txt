<div class="post-text" itemprop="text">
<p>I'm creating a HTTP proxy in python but I'm having trouble in the fact that my proxy will only accept the webservers response and will completely ignore the browsers next request and the transfer of data just stops. Here's the code:</p>
<pre class="lang-py prettyprint-override"><code>import socket

s = socket.socket()
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

bhost = '192.168.1.115'
port = 8080
s.bind((bhost, port))
s.listen(5)

def server(sock, data, host):
    p = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    p.connect((host, 80))
    p.send(data)
    rdata = p.recv(1024)
    print(rdata)
    sock.send(rdata)


    while True:
        sock, addr = s.accept()
        data = sock.recv(1024)
        host = data.splitlines()[1][6:]
        server(sock, data, host)`
</code></pre>
<p>Sorry about the code this is just a trial version and help will be much appreciated as I am only 14 and have much to learn :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately I don't really see how your code should work, so I'm putting here my thoughts of how should a simple HTTP proxy look like.
So what should a basic proxy server do:</p>
<ol>
<li>Accept connection from a client and receive an HTTP request.</li>
<li>Parse the request and extract its destination.</li>
<li>Forward requests and responses.</li>
<li>(optionally) Support <code>Connection: keep-alive</code>.</li>
</ol>
<p>Let's go step by step and write some very simplified code.</p>
<p><strong>How does proxy accepts a client.</strong> A socket should be created and moved to passive mode:</p>
<pre><code>import socket, select
sock = socket.socket()
sock.bind((your_ip, port))
sock.listen()
while True:
   client_sock = sock.accept()
   do_stuff(client_sock)
</code></pre>
<p>Once the TCP connection is established, <strong>it's time receive a request</strong>. Let's assume we're going to get something like this:</p>
<pre><code>GET /?a=1&amp;b=2 HTTP/1.1 
Host: localhost    
User-Agent: my browser details
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    
Accept-Language: en-gb,en;q=0.5    
Accept-Encoding: gzip, deflate    
Connection: keep-alive
</code></pre>
<p>In TCP, message borders aren't preserved, so we should wait until we get at least first two lines (for GET request) in order to know what to do later:</p>
<pre><code>def do_stuff(sock):
    data = receive_two_lines(sock)
    remote_host = parse_request(data)
</code></pre>
<p>After we have got the remote hostname, it's time to forward the requests and responses:</p>
<pre><code>def do_stuff(client_sock):
    data = receive_two_lines(client_sock)
    remote_host = parse_request(data)
    remote_ip = socket.getaddrinfo(remote_host)  # see the docs for exact use

    webserver = socket.socket()
    webserver.connect((remote_ip, 80))

    webserver.sendall(data)
    while it_makes_sense():
        client_ready = select.select([client_sock], [], [])[0]
        web_ready = select.select([webserver], [], [])[0]

        if client_ready:
            webserver.sendall(client_sock.recv(1024))
        if web_ready:
            client_sock.sendall(webserver.recv(1024))
</code></pre>
<p>Please note <a href="https://docs.python.org/3/library/select.html" rel="nofollow noreferrer"><code>select</code></a> - this is how we know if a remote peer has sent us data. I haven't run and tested this code and there are thing left to do:</p>
<ol>
<li>Chances are, you will get several GET requests in a single <code>client_sock.recv(1024)</code> call, because again, message borders aren't preserved in TCP. Probably, look additional get requests each time you receive data.</li>
<li>Request may differ for POST, HEAD, PUT, DELETE and other types of requests. Parse them accordingly.</li>
<li>Browsers and servers usually utilise one TCP connection by setting <code>Connection: keep-alive</code> option in the headers, but they also may decide to drop it. Be ready to detect disconnects and sockets closed by a remote peer (for simplicity sake, this is called <code>while it_makes_sense()</code> in the code).</li>
<li><code>bind</code>, <code>listen</code>, <code>accept</code>, <code>recv</code>, <code>send</code>, <code>sendall</code>, <code>getaddrinfo</code>, <code>select</code> - all these functions can throw exceptions. It's better to catch them and act accordingly. </li>
<li>The code currently server one client at a time.</li>
</ol>
</div>
<span class="comment-copy">The format of this is strange because your accepting connections inside <code>server()</code> and you call <code>server()</code> again. Is that intentional?</span>
<span class="comment-copy">Thanks Vovanrock2002 That has really helped me :-)</span>
<span class="comment-copy">i was planning on my code to; while it was running to accept a connection and recive the HTTP request then pares it to find the host then give it to the server function which will connect to the host and send the HTTP request from the browser and recive the responce and send it to the browser, and for all of this to just be a constant loop.</span>
