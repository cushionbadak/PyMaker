<div class="post-text" itemprop="text">
<p>I would like to make bool binary operations using the magic methods for these operators. For example, I can get <code>a &lt; b</code> as <code>getattr(a, '__lt__')(b)</code> or <code>a == b</code> as <code>getattr(a, '__eq__')(b)</code>. </p>
<p>Can I get <code>a in b</code> and <code>a is b</code> in such a way? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>in</code> is <code>__contains__</code> and <code>is</code> does not have a dunder method. I strongly suggest you use the functions in the <a href="https://docs.python.org/2/library/operator.html" rel="nofollow noreferrer"><code>operator</code> module</a>:</p>
<pre><code>a &lt; b  =&gt; operator.lt(a, b)
a == b =&gt; operator.eq(a, b)
a in b =&gt; operator.contains(a, b)
a is b =&gt; operator.is_(a, b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For <code>in</code>, the correct dunder method is <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__</code></a>.</p>
<p>There is no method for <code>is</code>, because this is equivalent to <code>id(a) == id(b)</code>. It compares the actual object ID used under the hood by Python, so is used to compare object identity, not object contents.  Overwriting it within a class would break Python's object model, so it is not allowed.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__contains__</code> is correct for <code>in</code>, with fall-back options if <code>__contains__</code> isn't defined being <code>__iter__</code> and <code>__getitem__</code>. </p>
<p>I am not really sure why you'd need to use <code>getattr</code> for <code>is</code> though; <code>is</code> is "defined" for <em>every</em> object in Python. There's no need to go through <code>operator._is</code> or (trying and failing) through <code>getattr</code>. </p>
<p><em><a href="https://docs.python.org/3.6/library/stdtypes.html#comparisons" rel="nofollow noreferrer">See the documentation on built-in types</a></em>:</p>
<blockquote>
<p>The behavior of the <code>is</code> and <code>is not</code> operators <em>cannot be customized</em>; also <em>they can be applied to any two objects</em> and never raise an exception.</p>
</blockquote>
<p><sup>(Emphasis mine)</sup></p>
<p>According to the snippets you provided, which just grab a function and call it using <code>getattr(a, "function")(b)</code>, you already have the names of the objects you need to evaluate, just use <code>is</code> immediately; it is always available. </p>
</div>
<span class="comment-copy">Why would the <code>operator</code> module be preferable to the usual way?</span>
<span class="comment-copy">It wouldn't be but if you need function versions of the operators the operator module is preferable to accessing dunder methods or writing your own wrappers.</span>
<span class="comment-copy">I read <code>getattr(a, '__lt__')(b)</code> as asking for the function version of <code>a &lt; b</code> which is <code>operator.lt(a, b)</code>. You can pass around <code>operator.lt</code>. I saw no attempt at definition of a class in which you would define the dunder methods.</span>
<span class="comment-copy">I agree with you now. Your answer definitely provides a superior alternative to using <code>getattr</code>.</span>
<span class="comment-copy">If you want <code>operator.is_</code> with the first argument already filled in, like <code>getattr(a, '__lt__')</code> already has <code>a</code> as its first argument) you can use <code>functools.partial</code>. <code>partial(operator.is_, a)</code> is a function that only takes one argument.</span>
