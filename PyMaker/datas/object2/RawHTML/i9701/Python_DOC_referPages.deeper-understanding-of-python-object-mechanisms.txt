<div class="post-text" itemprop="text">
<p>I would like to better understand Python 3.x data model. But I do not find complete and precise explanation of Python Object behaviours.</p>
<p>I am looking for references, it would be great if every case that I show below could be linked to a Python API reference or PEP or anything else valuable. Thank you further for your wise advises...</p>
<p>Let say we have some complex Python structure for testing purposes:</p>
<pre><code>d1 = {
    'id': 5432
   ,'name': 'jlandercy'
   ,'pets': {
        'andy': {
            'type': 'cat'
           ,'age': 3.5
        }
       ,'ray': {
            'type': 'dog'
           ,'age': 6.5
        }
    }
   ,'type': str
   ,'complex': (5432, 6.5, 'cat', str)
   ,'list': ['milk', 'chocolate', 'butter']
}
</code></pre>
<p><strong>1) Immutable atomic objects are singletons</strong></p>
<p>Whatever the way I create a new integer:</p>
<pre><code>n1 = 5432
n2 = int(5432)
n3 = copy.copy(n1)
n4 = copy.deepcopy(n1)
</code></pre>
<p>No new copy of this number is created, instead it points towards the same object as <code>d1['id']</code>. More concisely</p>
<pre><code> d1['id'] is n1
 ...
</code></pre>
<p>They all do have the same <code>id</code>, I cannot create a new instance of <code>int</code> with value 5432, therefore it is a <em>singleton</em>.</p>
<p><strong>2) Immutable and Iterable objects might be singletons...</strong></p>
<p>Previous observation also works for <code>str</code>, which are <em>immutable</em> and <em>iterable</em>. All following variables:</p>
<pre><code>s1 = 'jlandercy'
s2 = str('jlandercy')
s3 = copy.copy(s1)
s4 = copy.deepcopy(s1)
</code></pre>
<p>Point towards the copy initially created <code>d1['name']</code>. String are also <em>singletons</em>.</p>
<p><strong>...but not exactly...</strong></p>
<p>Tuple are also <em>immutable</em> and <em>iterable</em>, but they do not behave like string. It is know that the magic empty tuple is a <em>singleton</em>:</p>
<pre><code>() is ()
</code></pre>
<p>But other tuples are not.</p>
<pre><code>t1 = (5432, 6.5, 'cat', str)
</code></pre>
<p><strong>...instead they hash equally</strong></p>
<p>They do not have the same <code>id</code>:</p>
<pre><code>id(d1['complex']) != id(t1)
</code></pre>
<p>But all items within those two structures are atomic, so they point towards same instances. The important point is, both structures <code>hash</code> the same way:</p>
<pre><code>hash(d1['complex']) == hash(t1)
</code></pre>
<p>So they can be used as dictionary keys. This is even true for nested tuples:</p>
<pre><code>t2 = (1, (2, 3))
t3 = (1, (2, 3))
</code></pre>
<p>They do have the same <code>hash</code>.</p>
<p><strong>3) Passing dictionary by double dereferencing works as shallow copy of it</strong></p>
<p>Lets define the following function:</p>
<pre><code>def f1(**kwargs):
    kwargs['id'] = 1111
    kwargs['pets']['andy'] = None
</code></pre>
<p>Which will receive our trial dictionary by double dereferencing (<code>**</code> operator) first degree members will be copied, but deepest will be passed by reference.</p>
<p>Output of this simple program, illustrates it:</p>
<pre><code>print(d1)
f1(**d1)
print(d1)
</code></pre>
<p>It returns:</p>
<pre><code>{'complex': (5432, 6.5, 'cat', &lt;class 'str'&gt;),
 'id': 5432,
 'list': ['milk', 'chocolate', 'butter'],
 'name': 'jlandercy',
 'pets': {'andy': {'age': 3.5, 'type': 'cat'},
          'ray': {'age': 6.5, 'type': 'dog'}},
 'type': &lt;class 'str'&gt;}

{'complex': (5432, 6.5, 'cat', &lt;class 'str'&gt;),
 'id': 5432,
 'list': ['milk', 'chocolate', 'butter'],
 'name': 'jlandercy',
 'pets': {'andy': None, 'ray': {'age': 6.5, 'type': 'dog'}},
 'type': &lt;class 'str'&gt;}
</code></pre>
<p>The dictionary <code>d1</code> has been modified by function <code>f1</code>, but not completely. Member <code>id</code>'is kept back because we worked on a copy, but member <code>pets</code> is also a dictionary and the shallow copy did not copy it, then it has been modified.</p>
<p>This behaviour is similar to <code>copy.copy</code> behaviour for <code>dict</code> object. Where we need <code>copy.deepcopy</code> to have a recursive and complete copy of object.</p>
<p>My requests are:</p>
<ul>
<li><p>Are my observations correctly interpreted?</p>
<ol>
<li><p>Immutable atomic objects are singletons</p></li>
<li><p>Immutable and Iterable objects might be singletons but not exactly instead they hash equally</p></li>
<li><p>Passing dictionary by double dereferencing works as shallow copy of it</p></li>
</ol></li>
<li>Are those behaviours well documented somewhere?</li>
<li>For each case states correct properties &amp; behaviours.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Immutable atomic objects are singletons</p>
</blockquote>
<p>Nope, some are and some aren't, this is a detail of the CPython implementation. </p>
<ul>
<li><p>Integers in the range <code>(-6, 256]</code> are cached and when a new request for these is made the already existing objects are returned. Numbers outside that range are subject to constant folding where the interpreter re-uses constants during compilation as a slight optimization. <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer">This is documented</a> in the section on creating new <code>PyLong</code> objects.</p>
<p>Also, see the following for a discussion on these:  </p>
<ul>
<li><a href="https://stackoverflow.com/questions/34147515/is-operator-behaves-unexpectedly-with-non-cached-integers">'is' operator behaves unexpectedly with non-cached integers</a></li>
<li><a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers/34964030#34964030">"is" operator behaves unexpectedly with integers</a></li>
</ul></li>
<li><p>Strings literals are subject to interning during the compilation to bytecode as do ints. The rules for governing this are not as simplistic as for ints, though: Strings under a certain size composed of certain characters are only considered. I am not aware of any section in the docs specifying this, you could take a look at the behavior by reading <a href="http://guilload.com/python-string-interning/" rel="nofollow noreferrer">here</a>.</p></li>
<li><p>Floats, for example, which could be considered "atomic" (even though in Python that term doesn't have the meaning you think) there are no singletons:</p>
<pre><code>i = 1.0
j = 1.0
i is j # False
</code></pre>
<p>they are still of course subject to constant folding. As you can see by reading: <a href="https://stackoverflow.com/questions/38834770/is-operator-behaves-unexpectedly-with-floats/38835101#38835101">'is' operator behaves unexpectedly with floats</a></p></li>
</ul>
<blockquote>
<p>Immutable and Iterable objects might be singletons but not exactly instead they hash equally</p>
</blockquote>
<p>Empty immutables collections are signletons; this is again an implementation detail that can't be found in the Python Reference but truly only discovered if you look at the source.</p>
<p>See here for a look at the implementation: <a href="https://stackoverflow.com/questions/38328857/why-does-is-return-true-when-is-and-is-return-false">Why does '() is ()' return True when '[] is []' and '{} is {}' return False?</a></p>
<blockquote>
<p>Passing dictionary by double dereferencing works as shallow copy of it.</p>
</blockquote>
<p>Yes. Though the term isn't double dereferencing, it is unpacking.</p>
<blockquote>
<p>Are those behaviours well documented somewhere?</p>
</blockquote>
<p>Those that are considered an implementation detail needn't be documented in the way you'd find documentation for the <code>max</code> function for example. These are specific things that might easily change if the decision is made so.</p>
</div>
<span class="comment-copy">Your answer is quite complete, I will wait a little if any other pop up. Thank you anyway.</span>
<span class="comment-copy">That makes sence @jlandercy, give it as much time as you think is best :-)</span>
<span class="comment-copy">could you add info to hash in [2], do immutable and iterable (in stdlib only) hash always the same way? For example must have I to use named_tuple or tuple of "atomic types" is enough? Thanks</span>
