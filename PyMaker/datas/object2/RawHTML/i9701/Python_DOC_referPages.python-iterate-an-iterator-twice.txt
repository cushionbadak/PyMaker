<div class="post-text" itemprop="text">
<p><em>Edit: There is a <a href="https://stackoverflow.com/questions/3266180">similar question here</a> that deals with iterator resetting. The accepted answer below however addresses the actual issue of nested iterators, and handles an easy to miss issue, whereby the nested iterator doesn't reset.</em></p>
<p>Is there any way to iterate over an iterator twice in python?</p>
<p>In the example code below I can see that the second iteration is operating on the same object as the first, and thus yields a weird result. Contrast this with the C# below that yields the result I'm after.</p>
<p>Is there any way to do what I want. I was wondering if I could make a copy of the iterator or "retrieve" the function it came from, but maybe there's a simpler way. (I know I could just call <code>MyIter()</code> twice in the toy example below, but that's useless if I don't know where the iterator came from and isn't what I'm after!).</p>
<pre><code>def MyIter():
  yield 1;
  yield 2;
  yield 3;
  yield 4;

def PrintCombos(x):
  for a in x:
      for b in x:
          print(a,"-",b);

PrintCombos(MyIter());
</code></pre>
<p>gives</p>
<pre><code>1 - 2
1 - 3
1 - 4
</code></pre>
<p>Contrast with:</p>
<pre><code>static IEnumerable MyIter()
{
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
}

static void PrintCombos(IEnumerable x)
{
    foreach (var a in x)
        foreach (var b in x)
            Console.WriteLine(a + "-" + b);
}

public static void Main(String[] args)
{
    PrintCombos(MyIter());
}
</code></pre>
<p>Which gives:</p>
<pre><code>1-1
1-2
1-3
1-4
2-1
2-2
. . .
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>itertools.tee</code> to create multiple copies of the generator</p>
<pre><code>from itertools import tee

def MyIter():
    yield 1
    yield 2
    yield 3
    yield 4

def PrintCombos(x):
    it1, it2 = tee(x, 2)
    for a in it1:
        it2, it3 = tee(it2, 2)
        for b in it3:
        print("{0}-{1}".format(a, b))

PrintCombos(MyIter())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer">itertools.tee</a> creates independent iterators from a single iterable. However, once new iterables are creates, the original iterable should not be used anymore.</p>
<pre><code>import itertools
def MyIter():
    yield 1;
    yield 2;
    yield 3;
    yield 4;

def PrintCombos(x):
    xx = []
    xx.append(itertools.tee(x))
    n = 0
    for a in xx[0][0]:
        xx.append(itertools.tee(xx[n][1]))
        for b in xx[n+1][0]:
            print('%s - %s' % (a,b));
        n += 1

PrintCombos(MyIter());
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I find using list comprehension for this type of problem is most effective at getting your desired result. </p>
<pre><code>x = [1,2,3,4]
y = [1,2,3,4]

spam = [[s,t] for s in x for t in y]

for x in spam:
    print('%s - %s' %(x[0], x[1]))
</code></pre>
<p>output:</p>
<pre><code>1 - 1
1 - 2
1 - 3
1 - 4
2 - 1
2 - 2
2 - 3
2 - 4
3 - 1
3 - 2
3 - 3
3 - 4
4 - 1
4 - 2
4 - 3
4 - 4
</code></pre>
</div>
<span class="comment-copy">You can iterate over iterators unlimited amount of times in python. However if you are refering to generators (which you are by the looks of code given) there is no way of doing that multiple times on generator itself. You can however save generator results in memory and iterate over that. In the example given by you you'd do that by calling <code>PrintCombos(list(MyIter()))</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> might be what you're looking for.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/3266180/can-iterators-be-reset-in-python">Can iterators be reset in Python?</a></span>
