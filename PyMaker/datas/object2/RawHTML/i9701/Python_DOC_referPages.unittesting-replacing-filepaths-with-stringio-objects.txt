<div class="post-text" itemprop="text">
<p>I am trying to unittest parsing functions which take a filepath and return some of the file contents. I would like to be able to pass these functions strings of data for testing purposes.</p>
<p>I understand that I can pas csv.reader() either StringIO or a file_handle (e.g. csv.reader(StringIO("my,data") or csv.reader(open(file))), but I can't see a way that I can pass a StringIO object in place of a <em>filepath</em> since open(StringIO("my, data")) fails. Equally I want to have the file open/close logic in these parsing methods rather than in the main bulk of my code as that would clutter my main code and also mean I have to re-write all the file IO interfaces!</p>
<p>It seems my choices are:</p>
<ol>
<li>Rewrite all the existing code so that it passes file handles to the parsing functions - this is a real pain!</li>
<li>Use mock.patch() to replace the open() method - this should work, but seems more complex than this task should require!</li>
<li>Do something which I haven't yet thought of, but am convinced must exist!</li>
</ol>
<p><pre>
    import csv
    def parse_file(input):
        with open(input, 'r') as f:
            reader = csv.reader(f)
            output = []
            for row in reader:
                #Do something complicated
                output.append(row)
            return output</pre></p>
<code>import unittest  
class TestImport(unittest.TestCase):
    def test_read_string(self):
        string_input = u"a,b\nc,d\n"
        output = read_file(string_input)
        self.assertEqual([['a', 'b'], ['c', 'd']], output)
    def test_read_file(self):
        filename = "sample_data.csv"
        output = read_file(filename)
        self.assertEqual([['a', 'b'],['c', 'd']], output)
</code></div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/3/library/tempfile.html" rel="nofollow noreferrer">temporary files</a>. </p>
<p>If you really prefer not to use the hard disk, you can use StringIO to replace your files, and redefine the builtin <code>open</code> function, like so:</p>
<pre><code>import StringIO
import csv

#this function is all you need to make your code work with StringIO objects
def replaceOpen():
    #the next line redefines the open function
    oldopen, __builtins__.open = __builtins__.open, lambda *args, **kwargs: args[0] if isinstance(args[0], StringIO.StringIO) else oldopen(*args, **kwargs)

    #these methods below have to be added to the StringIO class
    #in order for the with statement to work
    StringIO.StringIO.__enter__ = lambda self: self
    StringIO.StringIO.__exit__ = lambda self, a, b, c: None

replaceOpen()

#after the re-definition of open, it still works with normal paths
with open(__file__, 'rb') as f:
    print f.read(16)

#and it also works with StringIO objects
sio = StringIO.StringIO('1,2\n3,4')
with open(sio, 'rb') as f:
    reader = csv.reader(f)
    output = []
    for row in reader:
        output.append(row)
    print output
</code></pre>
<p>This outputs:</p>
<pre><code>import StringIO
[['1', '2'], ['3', '4']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to change the interface to accept open file objects like <code>StringIO</code>, look at the <a href="https://pypi.python.org/pypi/testfixtures" rel="nofollow noreferrer">testfixtures module</a>. I have used it to manage files and directories for unit tests, although I usually prefer to pass in <code>StringIO</code> objects.</p>
<p>If you don't like that, then patching <code>open()</code> sounds like a reasonable strategy. I haven't tried it, myself.</p>
</div>
<div class="post-text" itemprop="text">
<p>For others looking for this in future I was able to use Mock to do this quite effectively.</p>
<pre><code>---- module: import_data.py -----

import csv

def read_file(input):
    with open(input, 'r') as f:
        reader = csv.reader(f)
        output = []
        for row in reader:
            #Do something complicated
            output.append(row)
        return output

---- Unittests ----

import unittest
from io import StringIO
from mock import patch
from import_data import read_file

class TestImport(unittest.TestCase):

    @patch('import_data.open')
    def test_read_string(self, mock_file):
        mock_file.return_value = StringIO(u"a,b\nc,d")
        output = read_file(None)
        self.assertEqual([['a', 'b'], ['c', 'd']], output)


    def test_read_file(self):
        filename = "sample_data.csv"
        output = read_file(filename)
        self.assertEqual([['a', 'b', 'c'],['d', 'e', 'f']], output)
</code></pre>
</div>
<span class="comment-copy">why not just write the test cases to the hard disk and pass paths to them?</span>
<span class="comment-copy">This is how the code currently works - I'm trying to avoid this because: <b>A</b> I don't want to have to keep track of lots of really small text files <b>B</b> The parsing has lots of config options - it's easily for me to manipulate the strings in code to simulate these, but to this with file would require dozens which makes my build look "messy"</span>
<span class="comment-copy">Thanks for the pointers - I've got this working using mock now :)</span>
