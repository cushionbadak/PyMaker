<div class="post-text" itemprop="text">
<p>To create a dictionary from a table file, where some columns have special characters, as "|" but I need to eliminate all the text after the last "|".</p>
<p>For example:</p>
<pre><code>A     this_is|my_A|best|result|      20
B     this_is|my_B|best|result|mess  40
C     this_is|my_C|best|result|me..  32
</code></pre>
<p>I wrote this to create the dictionary:</p>
<pre><code>for line in file:
        query = line.strip().split('\t')[0]
        data =  line.strip().split('\t')[1:2]
        subject = line.strip().split('\t')[1]
        if query not in best_hit:
                best_hit[subject] = data
</code></pre>
<p>Resulting in a mess dictionary like this:</p>
<pre><code>d = {'A': 'this_is|my_A|best|result|, 20' ,'B': 'this_is|my_B|best|result|mess  40', 'C':'this_is|my_C|best|result|me..  32' }
</code></pre>
<p>My intention is to eliminate the "mess" and "me.." text before to include it in the dictionary because I need this value to compare with other list without these texts.</p>
<pre><code>A     this_is|my_A|best|result|      20
B     this_is|my_B|best|result|      40
C     this_is|my_C|best|result|      32
</code></pre>
<p>My own solution:</p>
<pre><code>old_result = line.strip().split('\t')[1]
new_result = old_result.split('|')
subject = new_result[0]+'|'+new_result[1]+'|'+new_result[2]+'|'+new_result[3]+'|
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Split might be not performance-wise but the algorithm is simpler this way.</p>
<pre><code>source = """

A   this_is|my_A|best|result|   20
B   this_is|my_B|best|result|mess   40
C   this_is|my_C|best|result|me..   32

"""

source = source.strip()
source = source.split('\n')

result = {}

for i in xrange(len(source)):
    asplit = source[i].split('\t')
    bsplit = asplit[1].split('|')
    bsplit[-1] = ''
    asplit[1] = '|'.join(bsplit)

    if not asplit[0] in result:
        result[asplit[0]] = asplit[1] + '\t' + asplit[2]

print result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given that you already read in the dictionary, this should do it if I understood you correctly:</p>
<pre><code>def get_last_num(s):
  i = len(s)-1
  for ch in reversed(s):
    if ch not in ['1','2','3','4','5','6','7','8','9','0']:
      return s [i:]
    i -= 1

d = {'A': 'this_is|my_A|best|result|, 20' , \
     'B': 'this_is|my_B|best|result|mess  40', \
     'C': 'this_is|my_C|best|result|me..  32' }

for key in d:
  last_bar = d [key].rfind('|')
  d [key] = d [key][:last_bar] + get_last_num(d [key])

print(d)
</code></pre>
<p>(This prints out):</p>
<pre><code>{'A': 'this_is|my_A|best|result 20', 'C': 'this_is|my_C|best|result 32', 'B': 'this_is|my_B|best|result 40'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for how to turn this <code>'this_is|my_B|best|result|mess  40'</code> 
into <code>this_is|my_b|best|result 40</code></p>
<p>Say s is your string ,</p>
<pre><code>last_delimiter_index =len(s)- s[::-1].index('|')
s = s[:last_delimiter_index-1] +" "+ s.split()[1]
</code></pre>
<p>What this does is it gets the last index of a delimiter, in your case a '|' and constructs a new one similar to the one you want / <code>s[::-1]</code> is reversing the string, if it seems unfamiliar</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>results = (
    'A  this_is|my_A|best|result|   20\n'
    'B  this_is|my_B|best|result|mess   40\n'
    'C  this_is|my_C|best|result|me..   32'
)
keepCols = 4 ## number of cols you want keep
mydict = {}

for line in results.split('\n'):
    splited = line.split('\t')
    data = ''

    for x, col in enumerate(splited[1].split('|')):
        if x + 1 == keepCols:
            break
        data += col + '|'

    mydict[splited[0]] = data + ', ' + splited[2]

print(mydict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can eliminate while you are reading the file or when you have the dictionary. In my solution I will clean the dictionary:</p>
<pre><code>import re #To use regular expresion
#Your example Dict
d = {'A': 'this_is|my_A|best|result|, 20' ,'B': 'this_is|my_B|best|result|mess  40', 'C':'this_is|my_C|best|result|me..  32' }
for k,v in d.items():
    text = v.split("|")[-1]
    text_clean = re.sub('\\D', '', text)
    v_result = "|".join(v.split("|")[:-1])+"|"+text_clean
    d[k] = v_result
</code></pre>
<p>Result:</p>
<pre><code>print(d)
{'A': 'this_is|my_A|best|result|20', 'C': 'this_is|my_C|best|result|32', 'B': 'this_is|my_B|best|result|40'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An efficient way to find the last pipe character in your tab-delimited data is to split each stripped line on tabs and then use the <code>str.rfind</code> method. </p>
<pre><code>src = '''\
A\tthis_is|my_A|best|result|\t20
B\tthis_is|my_B|best|result|mess\t40
C\tthis_is|my_C|best|result|me..\t32
'''.splitlines()

result = {}
for line in src:
    key, text, num = line.strip().split('\t')
    result[key] = text[:text.rfind('|')] + '|\t' + num

# display contents of `result`, with the keys in alphabetical order
for k in sorted(result.keys()):
    print(k, result[k])
</code></pre>
<p><strong>output</strong></p>
<pre><code>A this_is|my_A|best|result|     20
B this_is|my_B|best|result|     40
C this_is|my_C|best|result|     32
</code></pre>
<p>If <code>.rfind</code> doesn't find a pipe char in <code>text</code> it will return -1, so my code will simply append a pipe if <code>text</code> doesn't contain one.</p>
</div>
<span class="comment-copy">There's not much point in posting multi-line Python code in comments since it's almost unreadable. But for single lines of code you should escape them by enclosing them in backticks, like `some code`</span>
<span class="comment-copy">+1 for rfind. Do you know of any std lib ways to find all occurences while we're at learning new methods?</span>
<span class="comment-copy">@themistoklik Depending on exactly what you're trying to do that's probably best done using a regex function, eg <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re.finditer</code></a> which returns regex <code>Match</code> objects so you get each matching string pattern as well as its location in the original string.</span>
