<div class="post-text" itemprop="text">
<p>I have a large <code>numpy</code> array already allocated of a given size. For example</p>
<pre><code>my_array = numpy.empty(10000, numpy.float)
</code></pre>
<p>The values for the array can be generated by (mock example) </p>
<pre><code>k * val ** 2 for val in range(0, 10000)
</code></pre>
<p>This step of setting the values of the array is done many times. For example, <code>for k in range(0,1000)</code>. I don't want to do any other allocation than the one done by the <code>numpy.empty()</code> at the beginning.</p>
<p>I have considered,</p>
<pre><code>my_array = numpy.array([k*val**2 for val in range(0,10000)])
</code></pre>
<p>but this looks like there is going to be at least the allocation of the list <code>[k * val ** 2 for val in range(0, 10000)]</code>. Is that right?</p>
<p>I saw also <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow noreferrer">numpy.fromiter</a>, but this seem to be for constructing the array.</p>
<pre><code>my_array = numpy.fromiter((k*val**2 for val in range(0,10000)), numpy.float, 10000)
</code></pre>
<p>Is it true that there is one further allocation here?</p>
<hr/>
<p>To see if <code>numpy.fromiter</code> allocates an array I tried the following</p>
<pre><code>import numpy as np

iterable1 = (x*x for x in range(5))
iterable2 = (x*x + 1.0 for x in range(5))
my_array = np.fromiter(iterable1, np.float)
print(my_array)
print(hex(id(my_array)))

my_array = np.fromiter(iterable2, np.float)
print(my_array)
print(hex(id(my_array)))
</code></pre>
<p>In the output I the two addresses printed are different. Doesn't this mean that <code>np.fromiter</code> allocated a new array which got then assigned to <code>my_array</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>First make sure you understand what the variable assignment does:</p>
<pre><code> my_array = numpy.empty(10000, numpy.float)
 my_array = numpy.fromiter(...)
</code></pre>
<p>the second assignment replaces the first.  The object that the <code>my_array</code> originally referenced is free and gets garbage collected.  That's just basic Python variable handling.  To hang on to the original array (a mutable object), you have to change its values, </p>
<pre><code>my_array[:] = &lt;new values&gt;
</code></pre>
<p>But the process that generates <code>&lt;new values&gt;</code> will, more than likely, create a temporary buffer (or two or three).  Those values are then copied to the target.  Even <code>x += 1</code> does a buffered calculation.  There are few in-place numpy operations.</p>
<p>Generally trying to second guess numpy's memory allocation doesn't work.  Efficiency can only be measured by time tests, not by guessing  what is happening under the covers.</p>
<p>Don't bother with 'pre-allocation' unless you need to fill it iteratively:</p>
<pre><code>In [284]: my_array = np.empty(10, int)
In [285]: for i in range(my_array.shape[0]):
     ...:     my_array[i] = 2*i+3
In [286]: my_array
Out[286]: array([ 3,  5,  7,  9, 11, 13, 15, 17, 19, 21])
</code></pre>
<p>Which is a horrible way of creating an array compared to:</p>
<pre><code>In [288]: np.arange(10)*2+3
Out[288]: array([ 3,  5,  7,  9, 11, 13, 15, 17, 19, 21])
</code></pre>
<p>the <code>fromiter</code> approach is prettier but not faster.</p>
<pre><code>In [290]: np.fromiter((i*2+3 for i in range(10)),int)
Out[290]: array([ 3,  5,  7,  9, 11, 13, 15, 17, 19, 21])
</code></pre>
<p>Some timings:</p>
<pre><code>In [292]: timeit np.fromiter((i*2+3 for i in range(10000)),int)
100 loops, best of 3: 4.76 ms per loop
# giving a count drops the time to 4.28 ms

In [293]: timeit np.arange(10000)*2+3
The slowest run took 8.73 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 3: 47.4 Âµs per loop

In [294]: %%timeit 
     ...: my_array=np.empty(10000,int)
     ...: for i in range(my_array.shape[0]):
     ...:     my_array[i] = 2*i+3
     ...:     
100 loops, best of 3: 4.72 ms per loop

In [303]: timeit np.array([i*2+3 for i in range(10000)],int)
100 loops, best of 3: 4.48 ms per loop
</code></pre>
<p><code>fromiter</code> takes just as long as an explicit loop, while the pure numpy solution is orders of magnitude faster.  Timewise there is little difference between <code>np.array</code> with a list comprehension and <code>fromiter</code> with the generator.</p>
<p>Creating the array from a pre-existing list takes about 1/3 the time.</p>
<pre><code>In [311]: %%timeit alist=[i*2+3 for i in range(10000)]
     ...: x=np.array(alist, int)
     ...: 
1000 loops, best of 3: 1.63 ms per loop
</code></pre>
<p>Assigning a list to an existing <code>empty</code> array isn't faster.</p>
<pre><code>In [315]: %%timeit alist=[i*2+3 for i in range(10000)]
     ...: arr = np.empty(10000,int)
     ...: arr[:] = alist
1000 loops, best of 3: 1.65 ms per loop
In [316]: %%timeit alist=[i*2+3 for i in range(10000)]; arr=np.empty(10000,int)
     ...: arr[:] = alist
1000 loops, best of 3: 1.63 ms per loop
</code></pre>
<p>There are some <code>numpy</code> functions that take an <code>out</code> parameter.  You may save some time by reusing an array that way.  <code>np.cross</code> is one function that takes advantage of this (the code is Python and readable).</p>
<p>Another 'vectorized' way of creating values from a scalar function:</p>
<pre><code>In [310]: %%timeit f=np.frompyfunc(lambda i: i*2+3,1,1)
     ...: f(range(10000))
     ...: 
100 loops, best of 3: 8.31 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given the explanation in the comments, it seems that the problem is the following:</p>
<ul>
<li>A large array needs to be updated frequently, and as efficiently as possible;</li>
<li>Source of the updates are not only other numpy arrays, but arbitrary Python objects (which can generate on-the-fly).</li>
</ul>
<p>The second item is the problem: as long as your values come from Python, putting them into a numpy array will <em>never</em> be really efficient. This is because you have to loop over each value in interpreted code.</p>
<blockquote>
<p>I was expecting to find the expression <code>for ind, elem in enumerate(iterable): my_array[ind] = elem</code> already packaged in a built in function. Do you know if the Python interpreter compiles that expression as a whole?</p>
</blockquote>
<p>CPython's virtual machine is very different from the C++ model; specifically, the compiler cannot inline the expression or interpret it as a whole in a way to make it significantly more efficient. Even if it supported a byte-code instruction that did this one specific thing in C, it would still need to call the generator's <code>next</code> method that produces each value as heap-allocated Python object after executing Python byte-code. In either case, interpreted code is involved for every iteration, and you really want to avoid that.</p>
<p>The efficient way to approach your problem is to design it from the ground up to never leave numpy. As others explained in the comment, the cost of allocation (if done efficiently, by numpy) is miniscule compared to the cost of actually working with data piece by piece in Python.  I would design it as follows:</p>
<ul>
<li>Convert as much code to natively work with numpy arrays, from the ground up; make returning a numpy array part of your interface and don't worry about allocation costs. Do as many loops as possible within numpy itself, so they are done in native code. Never iterate through all values of large arrays in Python.</li>
<li>Where it is not possible to use numpy, use <code>numpy.fromiter</code> to convert the iterator to the numpy array as early as possible.</li>
<li>Use either <code>my_array[:] = new_array[:]</code> or <code>my_array = new_array</code> to introduce the new values into the array. (The former will take microscopically more time, but it makes more sense when <code>my_array</code> is shared in many places in the data model.)</li>
<li><strong>Benchmark</strong> operations you are interested in. Don't assume that "copying is slow" - it might turn out that operations that would in C++ be "slow" turn out orders of magnitude faster than the Python rendition of operations that would be efficient in C++.</li>
</ul>
<p>If after doing the above some operation is not supported by numpy, and the measurements show it to be critically inefficient, you can use the <a href="https://docs.python.org/3/extending/index.html" rel="nofollow noreferrer">Python/C API</a> to create an extension module that performs the computation efficiently and returns the result as a numpy array created in C.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow noreferrer"><code>np.fromiter</code></a> doesn't do any further allocation. It just creates an array from an iterable. That's the whole essence of that function. It also accepts a <code>count</code> argument which allows <code>fromiter</code> to pre-allocate the output array, instead of resizing it on demand.</p>
<p>Also, you don't need to use <code>np.empty</code> if you want to change all of the items at once.</p>
<p>After all, if you are constructing your new array by doing some mathematical operations on a range of numbers you can simply do the operations on a Numpy array as well.</p>
<p>Here is an example:</p>
<pre><code>In [4]: a = np.arange(10)

In [6]: a**2 + 10
Out[6]: array([10, 11, 14, 19, 26, 35, 46, 59, 74, 91])
</code></pre>
</div>
<span class="comment-copy"><code>np.fromiter</code> doesn't do any further allocation. That's the whole essence of that function. Also, you don't need to use <code>np.empty</code> if you want to change all of the items at once.</span>
<span class="comment-copy">@Kasramvd Are you sure about that? I just don't know. The documentation of the <code>fromiter</code> says that it creates an array. I assumed that it creates a numpy array and then that array gets moved by the operator = to the <code>my_array</code>. But if you know for a fact that no new allocation is done I will believe you.</span>
<span class="comment-copy">If you must support an arbitrary iterator <i>and</i> don't want any temporary allocation, it will be hard to avoid the simplest <code>for ind, elem in enumerate(iterable): my_array[ind] = elem</code>.</span>
<span class="comment-copy">@onekeystrokeatatime Yes, that's exactly what this function does. It creates an array from an iterable and assigns it to the target variable. If you are looking for a way to get rid of this, check out my answer.</span>
<span class="comment-copy">"I don't want to do any other allocation than the one done by the numpy.empty() at the beginning." - you're coming at this from a C++ perspective, where array allocation is expensive and must be avoided. This is Python. Array allocation is nothing compared to the expenses of JIT-less bytecode interpretation, dynamic dispatch, and individually-allocated 24-byte <code>int</code> objects.</span>
<span class="comment-copy"><code>np.fromiter</code> does a new allocation, it allocates the array it returns. The OP has made it clear that he wants to set the elements of the same array (allocated once at the start) many times, with contents each time coming from an iterator.</span>
<span class="comment-copy">@user4815162342 By allocation I meant it just creates the new array from the iterator and not caching the items in memory and converting them to a numpy array. It's gets an iterable and converts it to a numpy array.</span>
<span class="comment-copy">I am not sure that what you are suggesting is accurate. I tried this code <code>import numpy as np  iterable1 = (x*x for x in range(5)) iterable2 = (x*x + 1.0 for x in range(5)) my_array = np.fromiter(iterable1, np.float) print(my_array) print(hex(id(my_array)))  my_array = np.fromiter(iterable2, np.float) print(my_array) print(hex(id(my_array)))</code> and it looks like the address of <code>my_array</code> changed.</span>
<span class="comment-copy">Opps. Python in a comment looses the alignment.</span>
<span class="comment-copy">@onekeystrokeatatime As I said the <code>formiter()</code> directly creates a numpy array from an iterable, if you don't want this you should do the operations directly on your array.</span>
