<div class="post-text" itemprop="text">
<p>I need a lot of small objects in my applications. They must be immutable and return a new instance when I set a new attribute.</p>
<p>I found a lot of ways to disable the <code>obj.prop = newValue</code> behavior, now I need this:</p>
<pre><code>newObj = obj.setTitle(title)
newObj = obj.setDirection(x, y)
newObj = obj.incrementCount()
newObj = obj.swap()
</code></pre>
<p>Currently I do this:</p>
<pre><code>class Info(object):
    __slots__ = ['_x', '_y', ...]

    def setDirection(self, x, y):
        newObj = copy.copy(self)  # shallow copy is OK
        newObj._x = x
        newObj._y = y
        return newObj

    def swap(self):
        newObj = copy.copy(self)
        #  methods can do different things
        newObj._x, newObj._y = self._y, self._x
        return newObj
</code></pre>
<p>Is this good in terms of perfomance? Are there any faster ways to return a clone of the object with some attributes changed?</p>
<p>I use <code>__slots__</code>. My object has predefined properties. I have no generic <code>.set(prop, value)</code> methods</p>
<p>(Python 3.5+ is welcome)</p>
</div>
<div class="post-text" itemprop="text">
<p>To gain true immutability, I would rather subclass <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> and use the method <code>_replace()</code>:</p>
<pre><code>import collections as co

# this will create a class with five attributes
class Info(co.namedtuple('BaseInfo', 'x y a b c')):
    __slots__ = ()

    def setDirection(self, x, y):
        return self._replace(x=x, y=y)

    def swap(self):
        return self._replace(x=self.y, y=self.x)
</code></pre>
<p>I've benchmarked the performance of the <code>swap()</code> method in both classes, and the class derived from <code>namedtuple</code> is about 3-4 times faster in python 3. Here's the benchmark code:</p>
<pre><code>import copy
import collections as co

class Info(object):
    __slots__ = ['x', 'y', 'a', 'b', 'c']

    def swap(self):
        newObj = copy.copy(self)
        newObj.x, newObj.y = self.y, self.x
        return newObj

    # for the sake of convenience
    def __init__(self, x, y, a, b, c):
        self.x = x
        self.y = y

class TupleInfo(co.namedtuple('BaseInfo', 'x y a b c')):
    __slots__ = ()

    def swap(self):
        return self._replace(x=self.y, y=self.x)

if __name__ == "__main__":
    from timeit import timeit

    i1 = Info(1, 2, 0, 0, 0)
    i2 = TupleInfo(1, 2, 0, 0, 0)

    print("Built from scratch")
    print(timeit("z = i1.swap()", "from __main__ import i1", number=100000))

    print("Derived from namedtuple")
    print(timeit("z = i2.swap()", "from __main__ import i2", number=100000))
</code></pre>
<p>Results:</p>
<pre><code>Built from scratch
1.8578372709998803
Derived from namedtuple
0.520611657999325
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get a significant performance boost by defining a custom copy method for your objects:</p>
<pre><code>class Info(object):
    __slots__ = ['x', 'y', 'z']

    def swap(self):
        newObj = self.copy()
        newObj.x, newObj.y = self.y, self.x
        return newObj

    def copy(self):
        clone = type(self)()
        for slot in self.__slots__:
            if hasattr(self, slot):
                setattr(clone, slot, getattr(self, slot))
        return clone
</code></pre>
<p>Test:</p>
<pre><code>i = Info()
i.x = i.y = 4

def fn1(i=i, copy=copy.copy): return copy(i)
def fn2(i=i): return i.copy()

print('copy.copy')
print(timeit('fn1()', 'from __main__ import fn1', number=100000))
print('custom copy')
print(timeit('fn2()', 'from __main__ import fn2', number=100000))
</code></pre>
<p>Results:</p>
<pre><code>copy.copy
1.5658336669985147
custom copy
0.4359149369993247
</code></pre>
</div>
<span class="comment-copy">Why do you need your objects to be immutable? In OOP, objects are supposed to be mutable. If you want immutability, classes and objects are not the data structure you are looking for. You could probably do some metaclass hacks to make it work, but you would not be <i>guaranteed</i> immutability or get any of the benefits of immutable datatypes.</span>
<span class="comment-copy">There are some interesting projects that introduces persistent/immutable/functional data structures to python. You could check out how it's done in for instance "pyrsistent": <a href="https://github.com/tobgu/pyrsistent" rel="nofollow noreferrer">github.com/tobgu/pyrsistent</a></span>
