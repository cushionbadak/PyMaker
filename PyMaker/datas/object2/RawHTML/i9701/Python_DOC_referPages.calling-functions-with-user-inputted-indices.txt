<div class="post-text" itemprop="text">
<p>I am attempting to call functions in python 2.7 by presenting a list and asking the user to choose the index of the item in the list. I am confused on two points:</p>
<ol>
<li><p>How can the the user inputted index correspond to the function which is defined in the initial list? I understand how to choose items in a list, but don't understand how to call a function. </p></li>
<li><p>Where should I put this block of code? In the main function?</p></li>
</ol>
<p>Here is my code: Thank you </p>
<pre><code>''' neoPixel setups'''
import time
from neopixel import *

# LED configuration.
LED_COUNT = 16  # Number of LED pixels.
LED_PIN = 12  # GPIO pin connected to the pixels (must support PWM!).
LED_FREQ_HZ = 800000  # LED signal frequency in hertz (usually 800khz)
LED_DMA = 5  # DMA channel to use for generating signal (try 5)
LED_BRIGHTNESS = 255  # Set to 0 for darkest and 255 for brightest
LED_INVERT = False  # True to invert the signal (when using NPN transistor level shift)


def colorWipe(strip, color, wait_ms=50):
    """Wipe color across display a pixel at a time."""
    for i in range(strip.numPixels()):
        strip.setPixelColor(i, color)
        strip.show()
        time.sleep(wait_ms / 1000.0)


def theaterChaseRainbow(strip, wait_ms=50):
    """Rainbow movie theater light style chaser animation."""
    for j in range(256):
        for q in range(3):
            for i in range(0, strip.numPixels(), 3):
                strip.setPixelColor(i + q, wheel((i + j) % 255))
            strip.show()
            time.sleep(wait_ms / 1000.0)
            for i in range(0, strip.numPixels(), 3):
                strip.setPixelColor(i + q, 0)


if __name__ == '_main_':
    # create neopixel object with appropriate configuration
    strip = Adafruit_NeoPixel(LED_COUNT, LED_PIN, LED_FREQ_HZ, LED_DMA, LED_INVERT, LED_BRIGHTNESS)
    # initialize the library (must be called before other function)
    strip.begin()

    print 'Press Ctrl-C to quit'

''' user input block '''
lighting_modes = 'rainbow', 'colorWipe'

for i, item in enumerate(lighting_modes):
    print i, item

user_input = input("Please enter index of the lighting modes listed above")

if user_input == 0:
    colorWipe(strip, Color(255, 0, 0))  # red
    colorWipe(strip, Color(0, 255, 0))  # blue
    colorWipe(strip, Color(0, 0, 255))  # green
elif user_input == 1:
    theaterChase(strip, Color(127, 127, 127))
    theaterChase(strip, Color(127, 0, 0))
    theaterChase(strip, Color(0, 0, 127))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def f():
    print('foo')

&gt;&gt;&gt; def g():
    print('bar')
</code></pre>
<p>Put the functions in a list</p>
<pre><code>&gt;&gt;&gt; funcs = [f, g]
</code></pre>
<p>Index the list with the user's input and assign the result to a name.</p>
<pre><code>&gt;&gt;&gt; which = int(input('which .. '))
which .. 1
&gt;&gt;&gt; func = funcs[which]
</code></pre>
<p>Call it</p>
<pre><code>&gt;&gt;&gt; func()
bar
</code></pre>
<hr/>
<pre><code>def fff(arg1, arg2):
    print('f', arg1, arg2)

def ggg(arg1, arg2):
    print('g', arg1, arg2)
</code></pre>
<p>To call different functions multiple times with predetermined arguments based on a user's choice - you need to associate the user's choice with the functions and the functions with the arguments they will be called with.  This could be done with a dictionary</p>
<pre><code>{choice : [function, [(args), (args), (args)]], ...}

func_f = [fff, [('strip', 'blue'), ('strip', 'green'), ('strip', 'red')]]
func_g = [ggg, [('strip', 'grey'), ('strip', 'dk_red'), ('strip', 'dk_blue')]]

p = {'0': func_f, '1': func_g}
</code></pre>
<p>Then you could construct an option <em>menu</em> with</p>
<pre><code>options = '\n'.join('{} - {}'.format(k, v[0].__name__) for k,v in p.items())
which = input('Which?\n' + options + '\n')
</code></pre>
<p>Then you would select and call the function like this. Notice the <code>*args</code>, the asterisk <em>unpacks</em> multiple items in a list or tuple.</p>
<pre><code>func, calls = p[which]
for args in calls:
    func(*args)

&gt;&gt;&gt; 
Which?
1 - ggg
0 - fff
1
g strip grey
g strip dk_red
g strip dk_blue
&gt;&gt;&gt;
</code></pre>
<p>If you construct the dictionary with too many or too few function arguments it will throw a TypeError exception when calling the function.  If the user submits an <em>invalid</em> option, you'll get a KeyError exception. <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">Handling Exceptions</a>.</p>
<hr/>
<p>This seems a little convoluted compared to the simple conditionals you used in your example but if you have a lot of functions this might be better and this lets you construct/modify the dictionary at runtime with different argument values.</p>
<pre><code>f_calls = operator.itemgetter(1)
f_calls(func_f).append(('strip', 'hazel'))
f_calls (func_g)[0] = ('strip', 'maroon')

pprint(p)

&gt;&gt;&gt;
{'0': [&lt;function fff at 0x000000000312C048&gt;,
       [('strip', 'blue'),
        ('strip', 'green'),
        ('strip', 'red'),
        ('strip', 'hazel')]],
 '1': [&lt;function ggg at 0x0000000003165268&gt;,
       [('strip', 'maroon'),
        ('strip', 'dk_red'),
        ('strip', 'dk_blue')]]}
&gt;&gt;&gt;
</code></pre>
<p>This isn't very generic and it seems that it could be encapsulated in a class.  I bet this is a pretty common thing and if you search around someone has come up with something a bit more refined.</p>
<hr/>
<p>A possible refinement would be to use <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">collections.namedtuple</a> to make it a bit more readable.</p>
<pre><code>Task = collections.namedtuple('Task', ['func', 'calls'])
task_f = Task(fff, [('strip', 'blue'), ('strip', 'green'), ('strip', 'red')])
task_g = Task(ggg, [('strip', 'grey'), ('strip', 'dk_red'), ('strip', 'dk_blue')])

p = {'0': task_f, '1': task_g}
options = '\n'.join('{} - {}'.format(item, task.func.__name__) for item,task in p.items())

which = input('Which?\n' + options + '\n')

task = p[which]
for args in task.calls:
    task.func(*args)


task_f.calls.append(('strip', 'candycane'))
task_g.calls.remove(('strip', 'grey'))
</code></pre>
</div>
<span class="comment-copy"><code>input</code> returns a string, try <code>if user_input == '0'</code> and <code>if user_input == '1'</code></span>
<span class="comment-copy">right thanks, I could also cast it, but how would this correspond to the function calls?</span>
<span class="comment-copy">I'm note sure what you are asking. Do you want to select a function from a list by its index and call it?</span>
<span class="comment-copy">yes this exactly what I want to do. The function names are in a list and I wish to call them by their corresponding index value. This is why I used enumerate.</span>
<span class="comment-copy">Thank you. This seems to work; however, I wonder how this would work if the function had arguments, or if you wanted to call the same function multiple times with different arguments (like in my code above). My goal is once the index is entered by the user, this will meet a condition which enables a sequence of functions. (also, would this block of code go in the main statement, or before the declaration of functions?) Thank you again, I very much appreciate the help.</span>
<span class="comment-copy">@ErikSvenBroberg, using conditional statements like your example seems easiest and straightforward. Why do you want to do it differently?</span>
<span class="comment-copy">thank you for this in depth answer. I had thought about using dictionaries and this works well. I agree that 'if statements' are the simplest solution; however, I was interested to see how the solution you presented could be achieved. Thank you very much as I have learned much from your contributions.</span>
