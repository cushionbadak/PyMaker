<div class="post-text" itemprop="text">
<p>How can I convert the below nested dictionary values to a single string ?</p>
<pre><code>data = {'people': {'first': {'fname': 'P1', 'lname': 'L1'}, 'second': { 'fname': 'P2', 'lname': 'L2'}}}
</code></pre>
<p>Output should be <code>P1 L1, P2 L2</code></p>
<p>Here is my current code: </p>
<pre><code>print ', '.join("%s %s" % (data['people'][person].get('fname'), data['people'][person].get('lname')) for person in data['people'])
</code></pre>
<p>Is this a efficient way for a larger set to items in people dict ? If not how to improve this  ?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make your expression a bit short by only looping over just values and using named field in <a href="https://docs.python.org/2/library/string.html#format-string-syntax" rel="nofollow noreferrer">format string</a>(Emphasis is to keep it more readable):</p>
<pre><code>&gt;&gt;&gt; print ', '.join("{fname} {lname}".format(**p) for p in data['people'].values())
P2 L2, P1 L1
</code></pre>
<p>In Python 3.2+ this can also be done using <a href="https://docs.python.org/3/library/stdtypes.html#str.format_map" rel="nofollow noreferrer"><code>str.format_map</code></a>:</p>
<pre><code>&gt;&gt;&gt; print (', '.join("{fname} {lname}".format_map(p) for p in data['people'].values()))
P1 L1, P2 L2
</code></pre>
<hr/>
<p>If the keys <code>fname</code> or <code>lname</code> might be missing from the dicts then you could do something like this:</p>
<pre><code>def get_values(dct, keys):
    return (dct.get(k) for k in keys)
...
&gt;&gt;&gt; keys = ('fname', 'lname')
&gt;&gt;&gt; print ', '.join("{} {}".format(*get_values(p, keys)) for p in data['people'].values())
P2 L2, P1 L1
</code></pre>
<hr/>
<ul>
<li>If number of values are huge then replace <code>values()</code> with <code>itervalues()</code>. In Python 3 use <code>values()</code> only.</li>
<li>Dicts don't have any specified order, so you cannot expect the output to be <code>P1 L1, P2</code> L2 here.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your data structure is recursive so you'll need a recursive function to obtain them</p>
<pre><code>def get_values(data):
    values = []
    for k, v in data.items():
        if isinstance(v, dict):
            values.extend(get_values(v))
        else:
            values.append(v)
    return values
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>result = list()
for person in data["people"]:
    for val in data["people"][person].values():
        result.append(val)
    result.append(", ")
result.pop()
print(' '.join(result))
</code></pre>
<p>or</p>
<pre><code>result = list()
for person in data["people"]:
    result.append(data["people"][person]["fname"])
    result.append(data["people"][person]["lname"])
    result.append(", ")
result.pop()
print(' '.join(result))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>one = data['people']['second'].values()
two = data['people']['first'].values()

three = one + two
three.reverse()


for each in three:
  print each,
</code></pre>
<p>I hope this what you are looking for.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = {'people': {'first': {'fname': 'P1', 'lname': 'L1'}, 'second': { 'fname': 'P2', 'lname': 'L2'}}}


def myprint(d):
  for k, v in d.iteritems():
    if isinstance(v, dict):
      myprint(v)
    else:
      print "{0} : {1}".format(k, v)

myprint(data)
</code></pre>
</div>
<span class="comment-copy">Not a generic solution.</span>
<span class="comment-copy">@helloV If OP's current code is working for them then it don't see why we need a generic solution here.</span>
<span class="comment-copy">added sorted, <code>print ', '.join("{fname} {lname}".format(**p) for p in sorted(data['people'].values()))</code> will give <code>P1 L1, P2 L2</code></span>
<span class="comment-copy">@Skycc Without a well-defined sorting rule, sorting dicts this was is bad and unfortunately it works in Python 2. Thankfully Python 3 fixed it. OP can always sort the dicts based on the values explicitly, but I won't recommend using <code>sorted(data['people'].values())</code>.</span>
<span class="comment-copy">@Ashwini Chaudhary , i see, i did try with python 2 though. :)</span>
<span class="comment-copy">I think OP wants only the values of the nested dict. But, he can tweak your solution to get the answer he needs</span>
<span class="comment-copy">Need my output like this P1 L1, P2 L2. Don't need to print it separately.</span>
