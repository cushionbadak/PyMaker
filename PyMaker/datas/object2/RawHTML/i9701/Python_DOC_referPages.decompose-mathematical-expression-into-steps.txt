<div class="post-text" itemprop="text">
<p>I would like to know if there is a way to print each step considering python follows PEMDAS <sup>1</sup>. Can I make it print each step it does in solving this problem without building my own library?</p>
<pre><code>print_steps('(3+7-2)*4/(3+32)')
</code></pre>
<p><sup><sup>1</sup> Parentheses, Exponents, Multiplication and Division, and Addition and Subtraction</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>The "library" can be pretty lightweight:</p>
<pre><code>class verbose_number:
    def __init__(self, value): self.value = value
    def operate(self, operator, other):
        other = getattr(other, 'value', other)
        result = eval('self.value %s other' % operator)
        print('%r %s %r = %r' % (self.value, operator, other, result))
        return self.__class__(result)
    def __add__(self, other): return self.operate('+', other)
    def __sub__(self, other): return self.operate('-', other)
    def __mul__(self, other): return self.operate('*', other)
    def __div__(self, other): return self.operate('/', other)
    def __floordiv__(self, other): return self.operate('//', other)
    def __truediv__(self, other): return self.operate('/', other)
    def __pow__(self, other): return self.operate('**', other)
    def __mod__(self, other): return self.operate('%', other)
    def __neg__(self): return self.__class__(-self.value)
    def __pos__(self): return self.__class__(+self.value)
    def __repr__(self): return repr(self.value)
    def __int__(self): return int(self.value)
    def __float__(self): return float(self.value)
</code></pre>
<p>Now any arithmetic computation that involves a <code>verbose_number</code> instance gets printed and returns another <code>verbose_number</code>, so the calculation is printed step by step:</p>
<pre><code>&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; (verbose_number(3)+7-2)*4/(3+32)
3 + 7 = 10
10 - 2 = 8
8 * 4 = 32
3 + 32 = 35
32 / 35 = 0.9142857142857143
</code></pre>
<p>Note that this relied on the fact that I made the <em>first</em> number in the expression a <code>verbose_number</code>.  A refinement on the approach is to write a handy routine for parsing string expressions: </p>
<pre><code>import re
def print_steps(expression):
    return eval(re.sub(r'([0-9\.]+([eE]-?[0-9]+)?)', r'verbose_number(\1)', expression))
</code></pre>
<p>This works by turning <em>every</em> numeric literal in the string into a <code>verbose_number</code> constructor call, thereby ensuring that <em>all</em> steps will be verbose no matter where Python's parser starts in the expression.  Here's how it can be used to evaluate your example:</p>
<pre><code>&gt;&gt;&gt; print_steps('(3+7-2)*4/(3+32)')
3 + 7 = 10
10 - 2 = 8
8 * 4 = 32
3 + 32 = 35
32 / 35 = 0.9142857142857143
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse</code></a> and <a href="https://docs.python.org/3/library/ast.html#ast.dump" rel="nofollow noreferrer"><code>ast.dump</code></a> to get a grasp of it.</p>
<pre><code>import ast
ast.dump(ast.parse('(3+7-2)*4/(3+32)', mode='eval'))
</code></pre>
<p>If formatted nicely, the output can look like this:</p>
<pre><code>Expression(
  body=BinOp(
    left=BinOp(
      left=BinOp(
        left=BinOp(
          left=Num(n=3),
          op=Add(),
          right=Num(n=7)
        ),
        op=Sub(),
        right=Num(n=2)
      ),
      op=Mult(),
      right=Num(n=4)
    ),
    op=Div(),
    right=BinOp(
      left=Num(n=3),
      op=Add(),
      right=Num(n=32)
    )
  )
)
</code></pre>
<p>Inspired by jez's <a href="https://stackoverflow.com/a/40939926/12892">answer</a> I came up with the following solution to transform the dump into some linear steps:</p>
<pre><code>import operator
Expression = lambda body: body
Num = lambda n: n
USub = lambda : ('-', operator.neg)
Add = lambda : ('+', operator.add)
Sub = lambda : ('-', operator.sub)
Mult = lambda : ('*', operator.mul)
Div = lambda : ('/', operator.truediv)
FloorDiv = lambda : ('//', operator.floordiv)

def UnaryOp(op, operand):
    print(op[0], operand)
    result = op[1](operand)
    print(' =', result)
    return result

def BinOp(left, op, right):
    result = op[1](left, right)
    print(left, op[0], right, '=', result)
    return result

eval(ast.dump(ast.parse('(3+7-2)*4/(3+32)', mode='eval')))
</code></pre>
<p>It prints:</p>
<pre><code>3 + 7 = 10
10 - 2 = 8
8 * 4 = 32
3 + 32 = 35
32 / 35 = 0.9142857142857143
</code></pre>
<p><a href="https://github.com/titusjan/astviewer" rel="nofollow noreferrer">astviewer</a> can give you a graphical represention of the tree. For example <code>astviewer.main.view(source_code='(3+7-2)*4/(3+32)', mode='eval')</code> gives you:
<a href="https://i.stack.imgur.com/f471m.png" rel="nofollow noreferrer"><img alt="astviewer for 3+7-2)*4/(3+32)" src="https://i.stack.imgur.com/f471m.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Nope. Not even <a href="https://docs.python.org/3/library/dis.html#dis.dis" rel="nofollow noreferrer"><code>dis.dis</code></a> will show you individual steps since it all gets simplified out to a single constant before being compiled to bytecode.</p>
<pre><code>&gt;&gt;&gt; def f():
...     return (3+7-2)*4/(3+32)
...
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_CONST              10 (0.9142857142857143)
              3 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">This code is a type error.</span>
