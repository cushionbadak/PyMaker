<div class="post-text" itemprop="text">
<p>I am trying to figure out difference between <code>@staticmethod</code> and <code>@classmethod</code>. The latter is passed a <code>cls</code> instance.</p>
<p>When I tried to call the <code>@classmethod</code>, it is giving me an error. </p>
<p>How should I call a <code>@classmethod</code> (<code>to_c()</code> and <code>to_f()</code>) decorated method in REPL?</p>
<p>Here is the REPL calls</p>
<pre><code>&gt;&gt;&gt; from temperature_converter import *
&gt;&gt;&gt; c = TemperatureConverter(41)
&gt;&gt;&gt; TemperatureConverter.to_f()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\Repos\Python\module-3\temperature_converter.py", line 21, in to_f
    return cls.c_to_f(cls.temperature)
  File "C:\Repos\Python\module-3\temperature_converter.py", line 25, in c_to_f
    return celsius * 9 / 5 + 32
TypeError: unsupported operand type(s) for *: 'property' and 'int'
</code></pre>
<p>Here is the class, <code>TemperatureConverter</code></p>
<pre><code>class TemperatureConverter:
    _temperature = 0

    @property
    def temperature(self):
        return self._temperature

    @temperature.setter
    def temperature(self, value):
        self._temperature = value

    def __init__(self, temperature):
        self.temperature = temperature

    @classmethod
    def to_c(cls):
        return cls.f_to_c(cls.temperature)

    @classmethod
    def to_f(cls):
        return cls.c_to_f(cls.temperature)

    @staticmethod
    def c_to_f(celsius):
        return celsius * 9 / 5 + 32

    @staticmethod
    def f_to_c(fahrenheit):
        return (fahrenheit - 32) * 5/9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Problem</strong>: You trying to access the <code>temperature</code> property from the class and expecting the same result as an instance, in this case an <code>int</code> value of <code>41</code>.  However, attributes are called differently in instances and classes. Compare the <code>__get__</code> method for each:  </p>
<p><strong>Description</strong></p>
<pre><code># Reassignments for illustration
C = TemperatureConverter                                   # class  
i = c                                                      # instance 
attr = "temperature"                                       # attribute    

# Call via Instance binding, `c.temperature`
C.__dict__[attr].__get__(i, C)                     
# 41

# Call via Class binding, `C.temperature`
C.__dict__[attr].__get__(None, C)                      
# &lt;property at 0x4ab9458&gt;
</code></pre>
<p>Here is more <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer">information</a> on the signature of the <code>__get__</code>  method and a <a href="https://stackoverflow.com/a/3681323/4531270">SO post</a> on how descriptors work.  In this case, the signature is could be seen as <code>C.__get__(self, inst, cls)</code>.  In short, when getting from a property, <strong>unlike an instance calls, calls from a class passes <code>None</code> for the instance argument</strong>.</p>
<p>As shown above, the property object is returned if bound to the class:   </p>
<pre><code>C.temperature
# &lt;property at 0x4ab9458&gt;
</code></pre>
<p>Can we still "get" the value from the property object?  Let us call <code>__get__</code> on the property object:</p>
<pre><code>C.temperature.__get__(i, C)
# 41
</code></pre>
<p>The latter shows it is possible to get the property value while bound to a class.  While it may be tempting to implement the <code>__get__</code> method on <code>cls.temperature</code> inside your class method, <em>you still need to pass in an instance</em> (e.g. <code>i</code>) to access the value of the property.  Instances are not accessible in a class method.  Therefore, we see why the property object is returned in your code, which is trying to multiply with an <code>int</code> and raises the error you observe. </p>
<p>This is one explanation for your problem, in particular describing why you cannot access your property value <code>cls.temperature</code> within a class method.</p>
</div>
<span class="comment-copy">What you're trying to do makes no sense. <code>cls.temperature</code> refers to the descriptor object itself, not to an instance that has a value. Neither class methods nor static methods can possibly access any instance value.</span>
<span class="comment-copy">Why do you want <code>to_c</code> and <code>to_f</code> to be classmethods? The temperature they're likely want to be converting (if you don't change their definition to give them an argument) is the <code>_temperature</code> instance attribute, since the class attribute of that name will always be <code>0</code>. There's really no need for the class attribute, even as a default value, since very instance gets a value assigned by the constructor (via the property).</span>
<span class="comment-copy">Ah, for some reason I thought an <code>instance</code> of a class object was being passed to <code>to_c(cls)</code> via <code>cls</code>. I was wrong... Thanks, @pylang for the enlightment</span>
