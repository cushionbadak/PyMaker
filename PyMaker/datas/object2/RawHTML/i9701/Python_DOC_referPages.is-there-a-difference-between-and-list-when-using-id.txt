<div class="post-text" itemprop="text">
<p>Can somebody explain the following?</p>
<p>Why is the id the same, but the lists are different?</p>
<pre><code>&gt;&gt;&gt; [] is []
False
&gt;&gt;&gt; id([]) == id([])
True
</code></pre>
<p>Is there difference in list creation?</p>
<pre><code>&gt;&gt;&gt; id(list()) == id(list())
False
&gt;&gt;&gt; id([]) == id([])
True
</code></pre>
<p>Why is this happening? I get two different lists. Why not only one, or three or more?</p>
<pre><code>&gt;&gt;&gt; [].__repr__
&lt;method-wrapper '__repr__' of list object at 0x7fd2be868128&gt;
&gt;&gt;&gt; [].__repr__
&lt;method-wrapper '__repr__' of list object at 0x7fd2be868170&gt;
&gt;&gt;&gt; [].__repr__
&lt;method-wrapper '__repr__' of list object at 0x7fd2be868128&gt;
&gt;&gt;&gt; [].__repr__
&lt;method-wrapper '__repr__' of list object at 0x7fd2be868170&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You used <code>id()</code> wrong. <code>id([])</code> takes the memory id of an object that is <em>discarded immediately</em>. After all, nothing is referencing it anymore once <code>id()</code> is done with it. So the next time you use <code>id([])</code> Python sees an opportunity to re-use the memory and lo and behold, those addresses are indeed the same. </p>
<p>However, this is an implementation detail, one you can't rely on, and it won't always be able to reuse the memory address.</p>
<p>Note that <code>id()</code> values are only unique <em>for the lifetime of the object</em>, see the <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer">documentation</a>:</p>
<blockquote>
<p>This is an integer which is guaranteed to be unique and constant for this object during its lifetime. <strong>Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</strong></p>
</blockquote>
<p>(Bold emphasis mine).</p>
<p>That <code>id(list())</code> can't re-use the memory location is probably due to the extra heap mutations caused by pushing the current frame on the stack to call a function, then popping it again when the <code>list()</code> call returns.</p>
<p>Both <code>[]</code> and <code>list()</code> produce a <strong>new</strong> empty list object; but you need to first create references to those separate lists (here <code>a</code> and <code>b</code>):</p>
<pre><code>&gt;&gt;&gt; a, b = [], []
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; id(a) == id(b)
False
&gt;&gt;&gt; a, b = list(), list()
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; id(a) == id(b)
False
</code></pre>
<p>The same happens when you used <code>[].__repr__</code>. The Python interactive interpreter has a special global name, <code>_</code>, that you can use to reference the last result produced:</p>
<pre><code>&gt;&gt;&gt; [].__repr__
&lt;method-wrapper '__repr__' of list object at 0x10e011608&gt;
&gt;&gt;&gt; _
&lt;method-wrapper '__repr__' of list object at 0x10e011608&gt;
</code></pre>
<p>That creates an extra reference, so the <code>__repr__</code> method, and by extension, the empty list you created for it, <em>are still considered active</em>. The memory location is not freed and not available for the next list you create.</p>
<p>But executing <code>[].__repr__</code> again, Python now binds <code>_</code> to that new method object. Suddenly the previous <code>__repr__</code> method is no longer referenced by anything and can be freed, and so is the list object. </p>
<p>The third time you execute <code>[].__repr__</code> the first memory location is available again for reuse, so Python does just that:</p>
<pre><code>&gt;&gt;&gt; [].__repr__  # create a new method
&lt;method-wrapper '__repr__' of list object at 0x10e00cb08&gt;
&gt;&gt;&gt; _            # now _ points to the new method
&lt;method-wrapper '__repr__' of list object at 0x10e00cb08&gt;
&gt;&gt;&gt; [].__repr__  # so the old address can be reused
&lt;method-wrapper '__repr__' of list object at 0x10e011608&gt;
</code></pre>
<p>You never create more than two lists; the previous one (still referenced by <code>_</code>) and the current one. If you wanted to see more memory locations, use variables to add another reference.</p>
</div>
