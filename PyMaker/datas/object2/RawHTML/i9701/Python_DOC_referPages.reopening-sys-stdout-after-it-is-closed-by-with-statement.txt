<div class="post-text" itemprop="text">
<p>I'm having trouble with a printing information that is input from a yaml file using PyYAML. I'm trying to reduce line-count, without affecting functionality. In some runs the output has to be appended to a file, in others to stdout.</p>
<p>At first I used this multiple times in my function <em>processData</em>:</p>
<pre><code>    if logName:
        fp = open(logName, 'a')
    else:
        fp = sys.stdout
    print(........, file=fp)
    print(........, file=fp)
    if logName:
        fp.close()
</code></pre>
<p>That worked, but has the disadvantages of not using the <em>with</em> statement when something goes wrong.</p>
<p>The actual problem is not the complex print statements, but that I </p>
<p>1) don't want to duplicate code when printing to file or to sys.stdout<br/>
2) want to use the <em>with</em> statement so that files get closed if there are print errors<br/>
3) there are several such blocks, I don't want to call a different function for each of them, and so preventing code duplication</p>
<p>Then what I tried is:</p>
<pre><code>def processData(yamlData, logName=None):
    ......
    with open(logName, 'a') if logName else sys.stdout as fp:
        print(........, file=fp)
        print(........, file=fp)
    .....
    with open(logName, 'a') if logName else sys.stdout as fp:
        print(........, file=fp)
        print(........, file=fp)
</code></pre>
<p>If there is not a logName, this errors to "ValueError: I/O operation on closed file". Any suggestions on how to get this to work without the original duplication? Can I reopen sys.stdout?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can "wrap" <code>sys.stdout</code> in a class to prevent it from being closed in the first place.   </p>
<p>The <code>with</code> statement calls <code>__enter__</code> and <code>__exit__</code> on instances of that class at the beginning and end resp., so just make sure the <code>__exit__</code> doesn't do anything:</p>
<pre><code>class StdOut:
    def __enter__(self):
        return sys.stdout

    def __exit__(self, typ, val, trace):
        pass

stdout = StdOut()
</code></pre>
<p>and then use <code>stdout</code> instead of <code>sys.stdout</code></p>
</div>
<div class="post-text" itemprop="text">
<h1>Literal question - reopening stdout</h1>
<p>At the lowest C level, <em>stdout</em> is a well-known <a href="https://en.wikipedia.org/wiki/File_descriptor" rel="nofollow noreferrer">file descriptor</a> (an integer pointing to an entry in the runtime- or system-managed descriptor table), initialized in a process upon its creation. <a href="https://stackoverflow.com/questions/9084099/re-opening-stdout-and-stdin-file-descriptors-after-closing-them">It cannot be reopened (with standard C means) once it's closed and must be duplicated beforehand if you still need it.</a></p>
<p>A disposable copy of <code>sys.stdout</code> can be created like this:</p>
<pre><code>stdout_copy=os.fdopen(os.dup(sys.stdout.fileno()),sys.stdout.mode)
</code></pre>
<p><sub>(In Python 3, <a href="https://docs.python.org/3/library/os.html?highlight=fdopen#os.fdopen" rel="nofollow noreferrer"><code>os.fdopen()</code></a> has been merged into <code>open()</code> and is an alias to it.)</sub></p>
<p>You may need to use <code>sys.__stdout__</code> instead if <code>sys.stdout</code> has been replaced.</p>
<h1>The other question - wrapping functionality into <code>with</code> logic</h1>
<p>First of all, consider the standard way to log - namely, the <a href="https://docs.python.org/3/library/logging.html?highlight=logging#module-logging" rel="nofollow noreferrer"><code>logging</code></a> module - to avoid reinventing the square wheel. Opening and closing the file on demand can very well be implemented with its machinery, and it's not even needed in the vast majority of cases.</p>
<p>Now, the only way to cut on the repetitive parts of the code is to wrap the repeating part into a subroutine (or a code block that processes a list with elements describing what it should do each iteration, but it can only be used once). There are three conceptual parts here, regardless of syntax (it can be <code>try</code>/<code>finally</code> just as well as <code>with</code>):</p>
<ul>
<li>the wrapping construct

<ul>
<li>incl. exception handling</li>
</ul></li>
<li>the opening+closing code</li>
<li>the wrapped code</li>
</ul>
<hr/>
<ul>
<li><p>Wrapping just "the opening+closing code" is the easiest, <a href="https://stackoverflow.com/a/40826961/648265">the other answer</a> is one possible way, but it leaves the repeating <code>with</code> and <code>print(........, file=fp)</code> parts.</p></li>
<li><p>Wrapping the entire construct is harder since you'll have to pass a code chunk to your would-be subroutine, and Python intentionally omits anonymous code blocks - you'd have to <code>def</code> and then immediately use it which is rather awkward.</p>
<ul>
<li>a decorator or passing your code as a callback are two possibilities.</li>
<li>If your code can be reduced to a pattern (like a set of messages), you can pass just that pattern instead and have the subroutine process it.</li>
</ul></li>
</ul>
</div>
<span class="comment-copy">Instead of printing you can use a logger. It's a best practice.</span>
<span class="comment-copy">Thanks I'll look into that. Some many useful packages, so little time...</span>
<span class="comment-copy">@Brad Look no further! Enter <i>Python</i>, the first language and standard library where <i>"there should be one, and preferably,</i> only <i>one obvious way to do it"!</i> If there's some functionality in the standard library, you can bet they thought hard to make it cover <i>every</i> typical use case.</span>
<span class="comment-copy">(OT) btw, was that a Duke Nukem reference? ;)</span>
