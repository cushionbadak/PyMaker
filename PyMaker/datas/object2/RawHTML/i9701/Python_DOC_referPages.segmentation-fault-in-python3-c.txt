<div class="post-text" itemprop="text">
<p>I get message <code>Program received signal SIGSEGV, Segmentation fault</code> when I'm working with my code. My program calls C module with defined struct.</p>
<p>Definition of struct</p>
<pre><code>typedef struct {
    char* str;
    int order;
    int list[10][10];
} Graph;
</code></pre>
<p>Definitions of module</p>
<pre><code>static PyMethodDef GraphMethods[] = {
{ "fromString",(PyCFunction)Graph__fromString,METH_VARARGS,"desc" },
{ "order",(PyCFunction)Graph_order,METH_NOARGS,"desc" },
{ NULL }
} ;


static PyTypeObject GraphType = {
PyVarObject_HEAD_INIT( NULL,0 ) // inicjalizacja
"GL.Graph", // nazwa
sizeof( Graph ), // rozmiar
0, //
(destructor)Graph__del__, // destruktor
0,0,0,0,0,0,0,0,0,0, //
(reprfunc)Graph__str__, // obiekt -&gt; napis
0,0,0, //
Py_TPFLAGS_DEFAULT, //
"desc.", // opis
0,0,0,0,0,0, //
GraphMethods, // metody
0,0,0,0,0,0,0, //
(initproc)Graph__init__, // inicjalizator
0, //
(newfunc)Graph__new__ // konstruktor
} ;
</code></pre>
<p>Simply, my object gets initialised by function <code>fromString</code> - when I'm using constructor like this:</p>
<pre><code>import GL

g = GL.Graph("A?")
g.order()
</code></pre>
<p>(init function)</p>
<pre><code>static int Graph__init__(Graph *self, PyObject *args ) {
    Graph__fromString(self, args);
    printf("ORDER: %d\n", self-&gt;order);
    return 0;
}
</code></pre>
<p>Program throws error on <code>g.order()</code>.</p>
<pre><code>static  PyObject * Graph_order( Graph *self ) {
    int result = self-&gt;order;
    return  Py_BuildValue("i", result);
}


PyObject * Graph__fromString(Graph * self, PyObject *args) {
    char * text;
    // Check if user passed the argument
    if (PyArg_ParseTuple(args, "s", &amp;text)) {
        self-&gt;str = text;
        int i, k;
        int n = strlen(text);

        /* magic goes here, but im sure this is working */
}
Py_RETURN_NONE;
}
</code></pre>
<p>What am I doing wrong? This code worked in plain C, when I moved it to Python, it crashes on every method called after constructor...</p>
</div>
<div class="post-text" itemprop="text">
<p>Your struct is missing the <code>PyObject_HEAD</code> macro:</p>
<pre><code>typedef struct {
    PyObject_HEAD
    char* str;
    int order;
    int list[10][10];
} Graph;
</code></pre>
<p>After expansion this eventually (among other things) also hold a pointer to the type, the fact that you're missing this probably causes this whole thing to blow up.</p>
</div>
<span class="comment-copy">I'm pretty sure it is required that you <code>Graph</code> struct contain the <code>PyObject_HEAD</code> macro.</span>
<span class="comment-copy">Oh, and it seems that it is working now, when I added <code>PyObject_HEAD</code> to <code>str</code> field. Thanks, but... Can you explain, why it is working now?</span>
<span class="comment-copy">And I have a question - does field marked by this macro have to be unique? Field <code>str</code> is debugging variable for me, but when I add this macro to another, it does not work. I would like to make <code>list</code> annotated by this macro?</span>
<span class="comment-copy">I'm not sure I'm understanding your question, what do you mean unique?</span>
<span class="comment-copy">I am asking if I can use this macro on any field in struct or this field should be unique for every graph?</span>
<span class="comment-copy">This macro isn't applied on a field of the struct @deem. It <i>adds a field</i> to the struct (specifically an <code>PyObject ob_base;</code> field if <code>PyObject_HEAD</code> is used and <code>PyVarObject ob_base</code> if <code>PyObject_VAR_HEAD</code> is used).</span>
<span class="comment-copy">Take a look on the <a href="https://docs.python.org/3/extending/extending.html" rel="nofollow noreferrer">docs on extending Python</a>, it has most of this information</span>
