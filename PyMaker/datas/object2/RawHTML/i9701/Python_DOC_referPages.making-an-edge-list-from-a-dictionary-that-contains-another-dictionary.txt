<div class="post-text" itemprop="text">
<p>I have a dictionary that looks like:</p>
<pre><code>{
  a: {a, b, c},
  b: {a, b, c},
  ...
 }
</code></pre>
<p>Essentially, a dictionary with keys and values, and the values itself are in another dictionary.</p>
<p>How would I made the keys and values into an edge list</p>
<p>I want each edge to be like:</p>
<pre><code>(a, a), (a, b), (a, c), (b, a), (b, b), (b, c)
</code></pre>
<p>For every key in the dictionary, the edges it's connected to are its values in the dictionary.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a, b, c = ('a', 'b', 'c')
main = {a: {a, b, c}, b: {a, b, c}}

output = []

# loop through the keys of the dictionary
for key in main:
    # iterate through set
    for i in main[key]:
        output.append((key, i))

print(output)
&gt;&gt;&gt; [('a', 'a'), ('a', 'c'), ('a', 'b'), ('b', 'a'), ('b', 'c'), ('b', 'b')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Considering you have a dictionary and the value for each key is a set you can try this:</p>
<pre><code>a = 'a'
b = 'b'
c = 'c'


x = {
  a: {a, b, c},
  b: {a, b, c},
 }

for key in x:
    for value in x[key]:
        print("(" + key + ", " + value + ")", end=" ")
</code></pre>
<p>However, the order that you require could not be exactly the same since dictionaries and sets are not sorted data structures. If <strong>order matters</strong>, you can use the following code:</p>
<pre><code>a, b, c = 'a', 'b', 'c'

x = {
    a: {a, b, c},
    b: {a, b, c},
 }

y = []

for key in sorted(x):
    for value in sorted(x[key]):
        y.append((key, value))

print(y)
</code></pre>
<p>I really hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>While it is not clear to me the exact edge cases you are looking for, as an alternative to @double_j's result, you can perform an <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> on the keys and values.</p>
<pre><code>import itertools as it

list(it.product(main.keys(), set.union(*main.values())))
# [('a', 'a'), ('a', 'c'), ('a', 'b'), ('b', 'a'), ('b', 'c'), ('b', 'b')]
</code></pre>
<p>This approach finds the <a href="https://en.wikipedia.org/wiki/Cartesian_product" rel="nofollow noreferrer">Cartesian product</a> of two iterables: 1) the keys and 2) a set of unique values in the <code>main</code> dictionary.</p>
</div>
<span class="comment-copy">a, b, and c are numbers or what data type?</span>
<span class="comment-copy">they are strings</span>
<span class="comment-copy">you know that in your main <code>{a, b, c}</code> is a set?</span>
<span class="comment-copy">The example you have features <code>set</code> as values of your keys. Is this correct?</span>
<span class="comment-copy">the list comprehension also worked @roganjosh</span>
<span class="comment-copy">this worked, I believe, thanks!</span>
<span class="comment-copy">Instead of <code>value</code>, you should write <code>key</code> since that is what you are actually iterating in <code>main</code>.</span>
<span class="comment-copy">@pylang Tku, fixed this</span>
