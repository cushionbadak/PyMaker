<div class="post-text" itemprop="text">
<p>I need the settings in the parent to contain the functions from the child.  (Every child of this parent will use that settings, but the way the functions are defined will change)</p>
<p>Is this possible? Currently it appears to read in the undefined functions from the parent class (and thus breaks)</p>
<pre><code>class Mine(object):
    __metaclass__ = ABCMeta
    @abstractmethod
    def _get_stuff(self):
        raise NotImplementedError()

    @abstractmethod
    def _set_stuff(self, value):
        raise NotImplementedError()

    settings = property(_get_stuff, _set_stuff)

    def do_stuff_with_settings(self):
        return settings

class Child(Mine):
    def _get_stuff(self):
        return {"a": 2}
    def _set_stuff(self):
        pass
    def do_stuff(self):
        self.a = do_stuff_with_settings.a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">docs</a></p>
<blockquote>
<p>a metaclass derived from ABCMeta cannot be instantiated unless all of
  its abstract methods and properties are overridden.</p>
</blockquote>
<p>I changed how you created the base class to <code>class Mine(metaclass=ABCMeta):
</code> and received the error</p>
<pre><code>Traceback (most recent call last):
  File "g.py", line 24, in &lt;module&gt;
    Child().settings
TypeError: Can't instantiate abstract class Child with abstract methods settings
</code></pre>
<p>So that makes the problem more explicit. To fix the problem, just have the child classes create their own <code>settings</code> property. Now they are bound to the concrete methods instead of the abstract methods.</p>
<pre><code>from abc import ABCMeta,abstractmethod

class Mine(object):
    __metaclass__ = ABCMeta
    @abstractmethod
    def _get_stuff(self):
        raise NotImplementedError()

    @abstractmethod
    def _set_stuff(self, value):
        raise NotImplementedError()

    settings = property(_get_stuff, _set_stuff)

    def do_stuff_with_settings(self):
        return settings

class Child(Mine):
    def _get_stuff(self):
        return 1
    def _set_stuff(self):
        pass
    settings = property(_get_stuff, _set_stuff)

Child().settings
</code></pre>
<p><strong>UPDATE</strong></p>
<p>This isn't just an ABC issue. You have this problem with any subclass that overrides a property method. Here, I try to override a getter but find that I still get the parent's view:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __init__(self, val):
...         self._val = val
...     def _get_val(self):
...         return self._val
...     def _set_val(self, val):
...         self._val = val
...     val = property(_get_val, _set_val)
... 
&gt;&gt;&gt; class Bar(Foo):
...     def _get_val(self):
...         return self._val + 2
... 
&gt;&gt;&gt; print('want 3, got', Bar(1).val)
want 3, got 1
</code></pre>
<p><strong>UPDATE 2</strong></p>
<p>The problem is that <code>property</code> binds the class method when it is defined. If you don't mind implementing intermediate functions, then you can let them resolve the target method at runtime after the child has overriden them. Here, <code>_get_stuff</code> calls <code>_get_stuff_impl</code> at runtime and you get the child version.</p>
<pre><code>from abc import ABCMeta,abstractmethod

class Mine(metaclass=ABCMeta):
    def _get_stuff(self):
        return self._get_stuff_impl()

    @abstractmethod
    def _get_stuff_impl(self):
        raise NotImplementedError()

    def _set_stuff(self, value):
        return self._set_stuff_impl(value)

    @abstractmethod
    def _set_stuff_impl(self, value):
        raise NotImplementedError()

    settings = property(_get_stuff, _set_stuff)

    def do_stuff_with_settings(self):
        return settings

class Child(Mine):
    def _get_stuff_impl(self):
        return 1
    def _set_stuff_impl(self):
        pass
#    settings = property(_get_stuff, _set_stuff)

Child().settings
</code></pre>
</div>
<span class="comment-copy">What problem are you trying to get around by doing things this way?</span>
<span class="comment-copy">There are a number of functions that are generic (the same for every child) that use that settings.  I would prefer not to have those functions referencing a variable that doesn't exist in the parent  (though python wouldn't complain).</span>
<span class="comment-copy">could <code>do_stuff_with_settings</code> <code>return property(self._get_stuff, self._set_stuff)</code></span>
<span class="comment-copy">there's a bunch of functions that <code>do_stuff_with_settings</code> and they all access parameters contained in settings and _get_stuff is retrieving a dictionary of values from another dictionary</span>
<span class="comment-copy">so the only solution is code duplication?</span>
<span class="comment-copy">@north.mister - if you want to use properties, then yes, that is the only way. The parent <code>settings = property(_get_stuff, _set_stuff)</code> binds to the parent methods. It isn't really an abstractmethod thing either. You'd have the same problem with any subclass overriding the property implementation functions.</span>
<span class="comment-copy">@north.mister - you can game the system, though... I've provided an example update.</span>
