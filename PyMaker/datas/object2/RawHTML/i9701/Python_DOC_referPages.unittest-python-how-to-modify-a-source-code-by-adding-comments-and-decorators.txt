<div class="post-text" itemprop="text">
<p>During a test phase, I would like to modify a part of my source code. For instance, I don't need to plot, so the code responsible for plotting can be commented. Is there a proper tool in unittest module to do so? </p>
<p>Another question is regarding the decorator @patch. Is there a way I can put them into source code in runtime during testing?</p>
</div>
<div class="post-text" itemprop="text">
<p>As Ohad the Lad already said, mocks are at your help.</p>
<p>There are several ways how to mock a function, but in general, you will decorate your test-functions - not the function to mock!</p>
<p>In your case the code could look as follows:</p>
<pre><code># your_file.py
from ... import ... as plt #depends on the class you use

class MyPlotter(object):

    def draw_calling_method(self):
        ....
        plt.draw()
        ...
        return something


# test.py
import mock
from unittest import TestCase

from your_file import MyPlotter
from ... import ... as plt # same import as in the your_file.py


class TestMyPlotter(TestCase):

    @mock.patch.object(plt, 'draw')
    def test_draw_calling_method_returns_something(self, draw):
        plotter = MyPlotter()
        plotter_return = plotter.draw_calling_method()
        self.assertEqual(plotter_return, something)
</code></pre>
<p>This will replace all calls to the <code>plt.draw()</code> with MagicMocks and hinder the draw-execution. If all of your test-methods need to mock the draw-call, the mock decorator could also be applied to the class instead. You only have to make sure then, that all your test-methods accept the mock as second argument (as the <code>test_draw_calling_mehtod_returns_something</code> does). Further you could mock any return values the draw() function may have by setting <code>draw.return_value = ...</code> in the test-method. <strong>Attention:</strong> This has to happen prior to the call of the function which calls the mock, otherwise the return-values will not be applied.</p>
<p>For more information on mocking refer to the docs <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">python-docs</a>. They are quite comprehensive.</p>
<p>One last thing; As Jonathon Reinhart already mentioned, if you feel it difficult to write your tests it may be good to refactor your code before. This will not only make it more testable, but more readable as well! </p>
</div>
<div class="post-text" itemprop="text">
<p>Try working with mock,</p>
<p>As it sounds it mocks your code and can be manipulated thru the test.</p>
<p>You may mock an method returned val or an object instance etc etc.</p>
<p><a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python" rel="nofollow noreferrer">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a></p>
</div>
<span class="comment-copy">Er, no, this is not how unit testing works. And patch belongs in the test code, not in the code under test.</span>
<span class="comment-copy">It sounds like you need to refactoring your code and break it into smaller pieces.</span>
<span class="comment-copy">so all my plotting has to be a separate function?</span>
<span class="comment-copy">so I have to copy/dublicate my sources in order to add @patch?</span>
<span class="comment-copy">That's what I needed, thank you</span>
<span class="comment-copy">Glad I could help :-) Took me quite some time to figure mocks out myself, so I am happy to share.</span>
<span class="comment-copy">how to mock plt.draw() to make it disappeared?</span>
