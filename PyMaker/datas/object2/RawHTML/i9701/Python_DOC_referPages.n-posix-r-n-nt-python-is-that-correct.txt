<div class="post-text" itemprop="text">
<p>I'm writing a python(2.7) script that writes a file and has to run on linux, windows and maybe osx.
Unfortunately for compatibility problems I have to use carriage return and line feed in windows style.
Is that ok if I assume:</p>
<pre><code>str = someFunc.returnA_longText()
with open('file','w') as f:
    if os.name == 'posix':
        f.write(str.replace('\n','\r\n'))
    elif os.name == 'nt'
        f.write(str)    
</code></pre>
<p>Do I have to considerate an else?
os.name has other alternatives ('posix', 'nt', 'os2', 'ce', 'java', 'riscos'). Should I use platform module instead?</p>
<p><strong>Update 1:</strong><br/>
1. The goal is to use '\r\n' in any OS.<br/>
2. I'm receiving the str from</p>
<pre><code>str = etree.tostring(root, pretty_print=True, 
                     xml_declaration=True, encoding='UTF-8')
</code></pre>
<p>I'm not reading a file.<br/>
3. My fault, I should probably check the os.linesep instead?  </p>
<p><strong>Solution recap:</strong> </p>
<pre><code>with io.open('file', mode='w', newline='\r\n', encoding='utf8') as f:
    f.write(etree.tostring(root, pretty_print=True,
                           xml_declaration=True, encoding='UTF-8').decode('utf-8'))
</code></pre>
<p>thanks to @Martijn Pieters</p>
</div>
<div class="post-text" itemprop="text">
<p>Python file objects can handle this <em>for you</em>. By default, writing to a text-mode file translates <code>\n</code> line endings to the platform-local, but you can override this behaviour.</p>
<p>See the <code>newline</code> option in the <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>open()</code> function documentation</a>:</p>
<blockquote>
<p><em>newline</em> controls how universal newlines mode works (it only applies to text mode). It can be <code>None</code>, <code>''</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\r\n'</code>. It works as follows:</p>
<ul>
<li>When reading input from the stream, if <em>newline</em> is <code>None</code>, universal newlines mode is enabled. Lines in the input can end in <code>'\n'</code>, <code>'\r'</code>, or <code>'\r\n'</code>, and these are translated into <code>'\n'</code> before being returned to the caller. If it is <code>''</code>, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li>
<li>When writing output to the stream, if <em>newline</em> is <code>None</code>, any <code>'\n'</code> characters written are translated to the system default line separator, <code>os.linesep</code>. If newline is <code>''</code> or <code>'\n'</code>, no translation takes place. If <em>newline</em> is any of the other legal values, any <code>'\n'</code> characters written are translated to the given string.</li>
</ul>
</blockquote>
<p>(the above applies to Python 3, Python 2 has <a href="https://docs.python.org/2/library/functions.html#open" rel="nofollow noreferrer">similar behaviour</a>, with <a href="https://docs.python.org/2/library/io.html#io.open" rel="nofollow noreferrer"><code>io.open()</code></a> giving you the Python 3 I/O options if needed).</p>
<p>Set the <code>newline</code> option if you need to force what line-endings are written:</p>
<pre><code>with open('file', 'w', newline='\r\n') as f:
</code></pre>
<p>In Python 2, you'd have to open the file in binary mode:</p>
<pre><code>with open('file', 'wb') as f:
    # write `\r\n` line separators, no translation takes place
</code></pre>
<p>or use <code>io.open()</code> and write Unicode text:</p>
<pre><code>import io

with io.open('file', 'w', newline='\r\n', encoding='utf8') as f:
     f.write(str.decode('utf8'))
</code></pre>
<p>(but pick appropriate encodings; it is always a good idea to explicitly specify the codec even in Python 3).</p>
<p>You can always use the <a href="https://docs.python.org/3/library/os.html#os.linesep" rel="nofollow noreferrer"><code>os.linesep</code> constant</a> if your program needs to know the appropriate line separator for the current platform.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/454725/python-get-proper-line-ending">Python get proper line ending</a></span>
<span class="comment-copy">The OP does not want to use the platform-local line endings.  They want to use DOS line endings on all platforms, so I think the first sentence misses the point.</span>
<span class="comment-copy">@SvenMarnach: their <i>code</i> suggests otherwise. They are switching based on <code>os.name</code>.</span>
<span class="comment-copy">I don't think so.  On Windows, they just write the string as it is, which results in <code>\r\n</code> line endings.  On POSIX, they replace <code>\n</code> by <code>\r\n</code>, which also results in <code>\r\n</code> line endings.  The question text is also quite clear.</span>
<span class="comment-copy">@faber: then you are using Python 2. Use <code>import io</code> and <code>io.open()</code> (and write Unicode text). The alternative is to open the file in <i>binary</i> mode, so no line translation takes place.</span>
<span class="comment-copy">@faber: see the update to my answer, you need to write unicode when using <code>io.open()</code>.</span>
