<div class="post-text" itemprop="text">
<p>I have a class that is implemented in cython containing c-pointers which I'm trying to use together with python's multiprocessing module. The class takes a DLL-file to return an instance of the class.</p>
<p>The problem I have is that while the instances preserve their data type, they seem to be empty, i.e. I can access all their class functions but they've lost all their instance values I set before they entered. The code containing special_class is very big so I'm not able to include it.</p>
<pre><code>import time
import multiprocessing as mp
from special_module import special_class

def run_task(tasks,nr):
    obj = tasks[nr]['data']
    print obj.get_name()



if __name__ == "__main__":

    m1 = special_class("a.dll")
    m2 = special_class("b.dll")


    tasks = dict()

    tasks[1] = {'data': m1}
    tasks[2] = {'data': m2}


    process1 = mp.Process(target = run_task, name = 'process1', args = (tasks, 1))
    process2 = mp.Process(target = run_task, name = 'process2', args = (tasks, 2))

    process1.start()

    time.sleep(0.2)

    process2.start()

    process1.join()
    process2.join()
</code></pre>
<p>Above script gives me the output</p>
<pre><code>None
None
</code></pre>
<p>The correct output should be in the style of</p>
<pre><code>name.a
name.b
</code></pre>
<p>If I create the instances inside the function run_task it will work fine, but I'm looking for a way to make it work by creating the instances in the main process. Is this possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>The multiprocessing library works by pickling objects and then piping the data to other spawned processes. The issue is that your <code>special_class</code> is unpicklable.</p>
<blockquote>
<p>If I create the instances inside the function run_task it will work fine</p>
</blockquote>
<p>This works because then the object does not need to be pickled, which works around the issue.</p>
<hr/>
<p>You need to make your <code>special_class</code> picklable. This can be done in various ways. They are all documented here: <a href="https://docs.python.org/3/library/pickle.html#pickle-inst" rel="nofollow noreferrer">https://docs.python.org/3/library/pickle.html#pickle-inst</a></p>
<p>Basically, there are 3 mechanisms:</p>
<ul>
<li>Use a custom pickler</li>
<li>Implement a <code>__reduce__</code> method on <code>special_class</code></li>
<li>Implement <code>__getstate__</code> and <code>__setstate__</code> methods on <code>special_class</code> (if your class instances have states)</li>
</ul>
<p>I have a feeling that you have a reference to an external object in your <code>special_class</code>. In that case, refer to: <a href="https://docs.python.org/3/library/pickle.html#persistence-of-external-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/pickle.html#persistence-of-external-objects</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe multiprocessing.Process pickles all its arguments. So you need to tell Python how to pickle special_class. You just need to implement method special_class.__reduce__ so that the data can be pickled properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems as if you are making <code>m1</code> and <code>m2</code> both the full <code>special_class</code> <em>module</em>. If you are trying to make them a certain <em>class</em>, either do:</p>
<pre><code>from special_class import *
</code></pre>
<p>(which I recommend) or </p>
<pre><code>m1 = special_class.special_class("a.dll")
m2 = special_class.special_class("b.dll")
</code></pre>
<p>The <code>None</code> is probably appearing because the methods you input <code>m1</code> and <code>m2</code> into also accept the module, for some reason. I would suggest trying <code>from special_class import *</code> and work it out.</p>
</div>
<span class="comment-copy">Try <a href="https://docs.python.org/3/library/copyreg.html" rel="nofollow noreferrer">using a custom pickler</a>.</span>
<span class="comment-copy">Every windows(OS) <code>class access</code> required a registered point on Python. You access a DLL but how to set all <code>data access</code> procedure. Need using <code>pythoncom.CoInitialize()</code>. <a href="http://stackoverflow.com/questions/26764978/using-win32com-with-multithreading">check this</a></span>
<span class="comment-copy">Umm... <code>import special_class</code> followed by <code>m1 = special_class("a.dll")</code> isn't legal; you can't call a module. I assume it's slightly different in the real code, but either way, the Cython class definition is important here; you can't omit it.</span>
<span class="comment-copy">No, the <code>None</code> appears because it's not able to pickle the object. If I dont use the multiprocessing module I dont get this problem.</span>
