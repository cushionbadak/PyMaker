<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1207406/how-to-remove-items-from-a-list-while-iterating">How to remove items from a list while iterating?</a>
<span class="question-originals-answer-count">
                    23 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/21581824/correct-code-to-remove-the-vowels-from-a-string-in-python">Correct code to remove the vowels from a string in Python</a>
<span class="question-originals-answer-count">
                    13 answers
                </span>
</li>
</ul>
</div>
<p>I just started to learn Python in codacademy. I was trying to do anti-vowel function, but found the following problem with 'u'.</p>
<pre><code>def anti_vowel(text):
    a = []
    for i in text:
        a.append(i)
    for item in a:
        if item in "aeiouAEIOU":
            a.remove(item)
    print ''.join(a)

print anti_vowel("Hey You!")
print anti_vowel("Hey look Words!")
print anti_vowel("aeiouAEIOU")
</code></pre>
<p>It printed</p>
<pre><code>"Hy Yu!"
"Hy lk Words!"
"eoAIU"
</code></pre>
<p>Instead of</p>
<pre><code>"Hy Y!"
"Hy lk Wrds!"
""
</code></pre>
<p>Somehow, some vowels was not removed es expected.</p>
<p>I found many alternatives for the function. 
However, please help me identify the mistake of the current code.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no need to use remove, and there's no need to iterate twice. Rather, as you iterate, check whether the item is a vowel and only append if it is not.</p>
<pre><code>def anti_vowel(text):
    a = []
    for i in text:
        if i not in "aeiouAEIOU":
            a.append(i)
    print ''.join(a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you look very closely at the remaining vowels, you can see that all those vowels remain that immediately follow one another. In your last example, a (removed) e (stays) i (removed) o (stays) and so on.</p>
<p>This is because you are iterating over a list and at the same time you are modifying it.</p>
<p>To solve the problem, you should make a copy of the list. Then you can iterate over the original one while modifying the copy.</p>
</div>
<div class="post-text" itemprop="text">
<p>Removing items while iterating is not a good idea.</p>
<p>Do it in one line with a generator comprehension passed to <code>str.join</code></p>
<pre><code>def anti_vowel(text):
    return ''.join(item for item in text if item not in "aeiouAEIOU")
</code></pre>
<p>or maybe more performant using a <code>set</code> for faster letter lookup (not sure converting to lowercase would speed this up since it creates a new string for that)</p>
<pre><code>s=set("aeiouAEIOU")
def anti_vowel(text):
    return ''.join(item for item in text if item not in s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Like others have already stated, you are modifying your list while iterating through it. I did want to suggest a python built-in option for this task, though for 3.x &gt; <a href="https://docs.python.org/2/library/stdtypes.html#str.translate" rel="nofollow noreferrer">Python &gt; 2.6</a>:</p>
<p><code>print "Hey You!".translate(None, "aeiouAEIOU")</code></p>
<p>In <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer">Python 3.x</a> you'll need to take account for the standard Unicode string and translate it first:</p>
<pre><code>translation = dict.fromkeys(map(ord, "aeiouAEIOU"), None)
print("Hey You!".translate(translation))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def anti_vowel(text):
    a = []

    for i in text:
        a.append(i)

    b = a[:]
    for item in a:
        if item in "aeiouAEIOU":
            b.remove(item)
    print (''.join(b))

print (anti_vowel("Hey You!"))
print (anti_vowel("Hey look Words!"))
print (anti_vowel("aeiouAEIOU"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not try recursively like this? </p>
<pre><code>def anti_vowel(s):
    if not s:
        return s
    elif s[0] in "aeiouAEIOU":
        return anti_vowel(s[1:])
    return s[0] + anti_vowel(s[1:])

print (anti_vowel("Hey You!"))
print (anti_vowel("Hey look Words!"))
print (anti_vowel("aeiouAEIOU"))
</code></pre>
<p>Output:</p>
<pre><code>Hy Y!
Hy lk Wrds!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you are removing item from list while traversing so thats creating a problem.
Moreover there is no need to traverse the so many times.</p>
<p>you could use:</p>
<pre><code>def anti_vowel(text):
    a = []
    for i in text:
        if i not in "aeiouAEIOU":
            a.append(i)
    print ''.join(a)
</code></pre>
<p>or I would say instead of using list use string like this : </p>
<pre><code>def anti_vowel(text):
    a = ""
    for item in text:
        if item not in "aeiouAEIOU":
            a+=item
    print a
</code></pre>
<p>Edited: </p>
<p>using <code>''.join(list)</code> is faster than using string cancatenation as pointed out by @jean in the comment section.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also join the result of a list comprehension, like:</p>
<pre><code>def anti_vowel(text):
    return "".join([char for char in text if char not in "aeiouAEIOU"])
</code></pre>
<p>Be sure to let your functions return their results if you want the function to do more than just printing to the terminal (for example if you want to use the returned value somehow). There's no need to print the results of a function that prints its result and returns <code>None</code> (which is the case if there are no <code>return</code> statements inside).</p>
<p>The <code>[char for char in text ...]</code> part of the list comprehension is simply a for loop over the characters in the string named <code>text</code>. The <code>[... if char not in "aeiouAEIOU"]</code> excludes the characters who are present in the <code>"aeiouAEIOU"</code> string. Finally, <code>"".join([ ... ])</code> merges the non-excluded characters together to form a string which by the <code>return</code> statement is returned.</p>
</div>
<span class="comment-copy">Don't remove items from a list while iterating over the list, that's what's causing your weird bug. Rather make a new list from scratch that is missing the items.</span>
<span class="comment-copy">Also see the explanation and linked questions at <a href="http://sopython.com/canon/95/removing-items-from-a-list-while-iterating-over-the-list" rel="nofollow noreferrer">Removing items from a list while iterating over the list</a></span>
<span class="comment-copy">If you are just learning Python now you should be learning Python 3. Python 2 will no longer be supported after 2020.</span>
<span class="comment-copy">While this is an excellent solution, but give OP a break - he just started learning Python. Anyway, take my +1.</span>
<span class="comment-copy">thanks. Note that the recommended solution to avoid removing items on the current list is always list/generator comprehension. Maybe learning listcomps from the start is easier than learning them afterwards :)</span>
<span class="comment-copy">Doing <code>if item.lower() not in s</code> would definitely be slower due to the time needed to create the new string. Using a set here may give a marginal speed benefit, especially if there are lots of strings to process, but searching a 10 char string is pretty fast. And if you were only searching 5 chars, using a set would almost certainly be slower, and that's not counting the time needed to build the set (OTOH, you could use a set literal to build the set at compile time, which is a little faster than converting a string).</span>
<span class="comment-copy">I was thinking about <code>for item in text.lower()</code> instead.</span>
<span class="comment-copy">But <code>''.join(item for item in text.lower() if item not in s)</code> doesn't preserve the case, which is probably not acceptable.</span>
<span class="comment-copy">I edited the answer to cover Python 3 as well.</span>
<span class="comment-copy">performance is not at its best with string concatenation.</span>
<span class="comment-copy">Thanks for the knowledge! But it's not noticeable with small strings like these.</span>
<span class="comment-copy">of course not, but better avoid bad habits, because that's how people create software that work with a small data set and are unusable when the dataset grows bigger. Ex: If I pass "War and Peace" contents as string to this algorithm it will crawl.</span>
<span class="comment-copy">I see.Do you know what I can do to improve it? like without changing much of the function.</span>
<span class="comment-copy">I think you could use an helper function to handle data as lists and join afterwards. Still not optimal because of list concatenation which wouldn't be done in-place, but better.</span>
<span class="comment-copy">at least the OP used <code>str.join()</code> to avoid string concatenation which bears catastrophic performance..</span>
<span class="comment-copy">thanks for telling me that. I didn't know that. I'll add a note at the end of my answer.</span>
<span class="comment-copy">and you also have to fix indentation of your snippets.</span>
<span class="comment-copy">done. thanks for pointing that out.</span>
