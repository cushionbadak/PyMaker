<div class="post-text" itemprop="text">
<p>I'm trying to duplicate and then modify a class programmatically but I'm running into problems with python 3's magic super for example the following </p>
<pre><code>class Base():
    def __init__(self):
        print("Base init")

class Orginal(Base):
    def __init__(self):
        super().__init__()
        print("Orginal init")

Modified = type(Orginal.__name__, Orginal.__bases__, dict(Orginal.__dict__))
Modified.f = lambda self: print("f")

m = Modified()
</code></pre>
<p>raises </p>
<p>TypeError: super(type, obj): obj must be an instance or subtype of type</p>
<p>So I'm wondering, is there someway I can help super() find the right __class__ cell in a class created through type()? </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note</strong>: <em>I corrected the spelling of <code>Original</code> in this answer</em></p>
<hr/>
<p>It appears that the problem is that when your <code>Modified</code> object is being instantiated and <code>super</code> is called, its being called like:  <code>super(Original, self)</code> since those are the default arguments for <code>super</code>.  Since <code>Original</code> is not a superclass of <code>Modified</code> (check <code>isinstance(m, Original)</code>), python is not allowing you to call <code>super</code> in that way.</p>
<p>The following code does something similar to yours but better illustrates the problem.</p>
<pre><code>class Base():
    def __init__(self):
        print("Base init")

class Original(Base):
    def __init__(self):
        super().__init__()
        print("Orginal init")

class Modified(Base):
    def __init__(self):
        super(Original, self).__init__()  # illegal 

Modified.__name__ == Original.__name__

m = Modified()  # raises same Exception that your your code does
</code></pre>
<p>Adding <code>Original</code> to the <code>bases</code> of <code>Modified</code> will make it work:</p>
<pre><code>Modified = type(Original.__name__, (Original,) + Original.__bases__, dict(Original.__dict__))
</code></pre>
<hr/>
<p><strong>Edit</strong>:</p>
<p>Per the comments, the above suggestion can be simplified since all the methods contained within <code>Original</code> will be included in <code>Modified</code> without needing to pass the <code>dict</code> in the <code>type</code> call:</p>
<pre><code>Modified = type(Original.__name__, (Original,), {})
</code></pre>
<p><s>and going one step further, if you don't want <code>Modified</code> to be a subclass of <code>Original</code>, you could simply make <code>Modified</code> a copy of <code>Original</code> and then add attributes the same as you do in your example:</s></p>
<pre><code>from copy import deepcopy
Modified = deepcopy(Original)
Modified.f = lambda self: print("f")

m = Modified()
</code></pre>
<p></p></div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">the documentation</a>,</p>
<blockquote>
<p>Also note that, aside from the zero argument form, super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. <strong>The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined,</strong> as well as accessing the current instance for ordinary methods.</p>
</blockquote>
<p>So, the <code>super()</code> in the code is equivalent to <code>super(Orginal, self).__init__()</code>, and it's determined in compile time.</p>
</div>
<span class="comment-copy">I think your class should be named "Original".</span>
<span class="comment-copy">FYI, If <code>Original</code> is in bases, no need to add <code>Original.__bases__</code> and <code>dict(Original.__dict__)</code>: <code>Modified = type(Original.__name__, (Original,), {})</code> should be enough.</span>
<span class="comment-copy">Using deepcopy is good idea, it is exactly what I needed- except it doesn't seem to actually work. If I overwrite any of Original's attributes Modified's also are changed!</span>
<span class="comment-copy">It actually adds a <code>__class__</code> cell containing the class, wich you could manipulate from within that function. But Daniel Bunting already knows that, judging from the last part of his question. He is asking how to set the cell's value.</span>
