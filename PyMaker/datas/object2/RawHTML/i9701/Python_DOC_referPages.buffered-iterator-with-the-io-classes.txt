<div class="post-text" itemprop="text">
<p>When writing to a file in a setting like the following, where <code>production.iterlines()</code> generates many lines of text:</p>
<pre><code>with open('output.txt', 'w', encoding='UTF-8') as f:
    for line in production.iterlines():
        f.write(line)
</code></pre>
<p>then – if I understand correctly – the following happens:
The TextIOWrapper object <code>f</code> accepts line by line, encodes it, and, whenever a certain limit is reached (eg. 4096 bytes in the buffer), writes a chunk of bytes to disk. So the actual disk-writing operations are not at the same pace as the lines yielded, but typically less frequent (unless the lines are very long).</p>
<p>Now I would like to have an <em>iterator</em> over these chunks, eg. for sending them over a network. It could be used like this:</p>
<pre><code>for chunk in BufferedIterator(production.iterlines()):
    # do something with the chunk
</code></pre>
<p>So this hypothetical BufferedIterator object assembles strings from its argument into chunks of reasonable size and yields them to its caller as encoded bytes.</p>
<p>I feel like this should be possible with a clever combination of the classes in the <code>io</code> module – I just can't get my head around how to use them. Something like StringIO, but with some kind of queue behaviour, with interleaved write and read calls.</p>
<p>But maybe I'm wrong and they aren't designed for this kind of task. (After all, it's not that hard to piece together an iterator that encodes and concatenates strings until a fixed chunk size is reached.) Answers are encouraged to give me a better understanding of the <em>usage</em> of the <code>io</code> classes. I am very fond of the official documentation usually, but the one on the <code>io</code> module just leaves me behind hopelessly.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to use <em>any</em> <code>io</code> classes here. You are not really performing I/O, only buffering (which is not unique to I/O). Trying to re-use the <code>BufferIOBase</code> interface is sub-optimal here, since your input is an iterable, and so is your output; neither is a file-like object and no <code>.read()</code> is available for a <code>BufferedReader()</code> to fill the buffer from.</p>
<p>You can implement the class yourself; I used the <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque()</code> type</a> to keep this as efficient as possible:</p>
<pre><code>from collections import deque

class BufferedIterator:
    """Turns an iterable of str lines into chunks of a fixed size"""
    def __init__(self, it, buffer=2**12):
        self._it = iter(it)
        self._buffersize = buffer
        self._lengths, self._lines = deque(), deque()

    def __iter__(self):
        return self

    def __next__(self):
        if self._it is None:
            raise StopIteration

        # collect enough lines to fill the buffer
        bsize = self._buffersize
        while sum(self._lengths) &lt; bsize:
            line = next(self._it, None)
            if line is None:
                # out of data, build the chunk from the remainder
                # clear the iterable to flag that we are done
                self._it = None
                if not self._lines:
                    # edgecase, never had any lines to begin with
                    raise StopIteration
                break
            self._lines.append(line)
            self._lengths.append(len(line))

        # build a chunk from the buffered lines
        chunklength = 0
        chunk = []
        while self._lines and chunklength &lt; bsize:
            length, linechunk = self._lengths.popleft(), self._lines.popleft()
            needed = bsize - chunklength
            if length &gt; needed:
                # only need a substring
                self._lengths.appendleft(length - needed)
                self._lines.appendleft(linechunk[needed:])
                length, linechunk = needed, linechunk[:needed]
            chunklength += length
            chunk.append(linechunk)
        return ''.join(chunk)

    next = __next__  # Python 2
</code></pre>
<p>By using two <code>deque</code> objects, one for the lengths, and one for the lines themselves, we avoid having to call <code>len()</code> too often. Getting the length of a string is cheap enough, but pushing and popping the current stack frame to retrieve it each time is costly enough to want to avoid this.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; for chunk in BufferedIterator(['The quick brown fox ', 'jumps over ', 'the lazy dog'], 16):
...     print(repr(chunk))
...
'The quick brown '
'fox jumps over t'
'he lazy dog'
&gt;&gt;&gt; import random, string
&gt;&gt;&gt; def random_lines(number=100, minlength=60, maxlength=80):
...     for _ in range(number):
...         yield ''.join([random.choice(string.printable) for _ in range(random.randrange(minlength, maxlength))])
...
&gt;&gt;&gt; for chunk in BufferedIterator(random_lines(200)):
...     print(len(chunk))
...
4096
4096
4096
1710
&gt;&gt;&gt; for chunk in BufferedIterator(random_lines(2000, 2, 20)):
...     print(len(chunk))
...
4096
4096
4096
4096
4096
428
&gt;&gt;&gt; for chunk in BufferedIterator(random_lines(3, 5000, 6000)):
...     print(len(chunk))
...
4096
4096
4096
3960
</code></pre>
</div>
<span class="comment-copy">Thanks, Martijn. I'm a bit disappointed that the whole buffering logic needs to be rebuilt... I mean, there's StringIO, which doesn't do any IO either, it just simulates it, offering the consumer-side interface. So I figured that there might be a simulator for the other side, too.</span>
<span class="comment-copy"><code>StringIO</code> requires the whole string to be available as one big chunk, which an iterable doesn't provide. Buffering is used in many different contexts; you just don't have an I/O context here.</span>
<span class="comment-copy">Besides, you don't need to build anything, I just did it for you ;-)</span>
<span class="comment-copy">Sure, thanks :). But is calling <code>len()</code> often really an issue? I'd rather try to avoid the unconditioned slice on <code>line</code> in the second while loop, as it's will be the whole line in most cases.</span>
<span class="comment-copy">Oh, you already changed that last thing :-). I'll come back when you're happy with the code!</span>
