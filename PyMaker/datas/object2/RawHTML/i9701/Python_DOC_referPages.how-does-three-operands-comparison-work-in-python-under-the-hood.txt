<div class="post-text" itemprop="text">
<p>Can you please explain what does the syntactic parse tree look like for a chained comparison?</p>
<p>As far as I understand in most of languages it constructs nodes based on operator associativity so in <code>a &lt; b &lt; c</code> there will be a boolean value either as a left- or right-hand operand.</p>
<p>But in Python such expression is almost equivalent to <code>a &lt; b and b &lt; c</code> (with <code>b</code> only evaluated once). </p>
<p>What is a generative grammar rule for such a transformation? Basically, what does a Python interpreter do to construct a parse tree in such case?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow noreferrer">comparison grammar</a> is not that interesting here, it simply lets you append multiple comparators to an operator:</p>
<pre><code>comparison    ::=  or_expr ( comp_operator or_expr )*
comp_operator ::=  "&lt;" | "&gt;" | "==" | "&gt;=" | "&lt;=" | "!="
                   | "is" ["not"] | ["not"] "in"
</code></pre>
<p>So lets ask the Python parser directly, by using the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer"><code>ast</code> module</a> (which simply asks the Python compiler itself to only return the Abstract Syntax Tree):</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.dump(ast.parse('a &gt; b &gt; c', mode='eval'))
"Expression(body=Compare(left=Name(id='a', ctx=Load()), ops=[Gt(), Gt()], comparators=[Name(id='b', ctx=Load()), Name(id='c', ctx=Load())]))"
</code></pre>
<p>So there is just a <em>single</em> <code>Compare</code> node, with multiple operators and comparators:</p>
<pre><code>Compare(
    left=Name(id='a'),
    ops=[Gt(), Gt()],
    comparators=[Name(id='b'), Name(id='c')])
</code></pre>
<p>(I omitted the <code>Expression</code> and <code>ctx</code> parts).</p>
<p>This lets the interpreter evaluate comparators as needed (e.g. if <code>a &lt; b</code> is false, the remaining comparators don't have to be considered).</p>
<p>The resulting bytecode uses conditional jumps to skip remaining comparisons:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('a &gt; b &gt; c', '', 'eval'))
  1           0 LOAD_NAME                0 (a)
              2 LOAD_NAME                1 (b)
              4 DUP_TOP
              6 ROT_THREE
              8 COMPARE_OP               4 (&gt;)
             10 JUMP_IF_FALSE_OR_POP    18
             12 LOAD_NAME                2 (c)
             14 COMPARE_OP               4 (&gt;)
             16 RETURN_VALUE
        &gt;&gt;   18 ROT_TWO
             20 POP_TOP
             22 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">The grammar rule is simply <code>comparison: expr (comp_op expr)*</code>.</span>
<span class="comment-copy">"such expression is almost equivalent to <code>a &lt; b and b &lt; c</code>". <code>a &lt; b &lt; c</code> is exactly equivalent to <code>a &lt; b and b &lt; c</code> except that the <code>b</code> expression is guaranteed to be evaluated once (at most).</span>
<span class="comment-copy">@PM2Ring yes, that's why i wrote "almost" they are equivalent if there're no side effects in computing b</span>
<span class="comment-copy">Understood. I just added my comment for the benefit of other readers.</span>
