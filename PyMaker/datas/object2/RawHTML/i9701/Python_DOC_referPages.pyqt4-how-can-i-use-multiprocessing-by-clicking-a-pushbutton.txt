<div class="post-text" itemprop="text">
<p>I have been trying to run a command using multiprocess since the GUI freezes when using a while loop. I need to call the function inside of pyqt4 class. Or a better way to handle multiprocess will Qthread help me? I have search many tutorials, but I cannot figure out how I can do this.</p>
<p>I tried it like this, which works fine. The problem is I cannot get the input of QeditText passed to the function if there is a way I can then it will work for what I want to do.</p>
<pre><code>import sys
import multiprocessing
import time
from PyQt4 import QtCore, QtGui
from form import Ui_Dialog


def worker():
    t = MyDialog()
    name = multiprocessing.current_process().name
    print name, 'Starting',  t.self.ui.rtmpIN.toPlainText()
    time.sleep(2)
    print name, 'Exiting'

class MyDialog(QtGui.QDialog):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        self.ui = Ui_Dialog()
        self.ui.setupUi(self)
        self.ui.startButton.clicked.connect(self.start)
        self.ui.stopButton.clicked.connect(self.stop)
        self.ui.comboBox.addItem("player 1")
        self.ui.comboBox.addItem("player 2")
        self.ui.comboBox.addItem("player 3")
        #self.ui.comboBox.currentIndexChanged.connect(self.selectionchange)

    def selectionchange(self,i):
        print self.ui.comboBox.currentText()

    def start(self):
        worker_2 = multiprocessing.Process(target=worker)  # use default name
        worker_2.start()
        print "in:  ", self.ui.rtmpIN.toPlainText()
        print "out: ", self.ui.outPUT.toPlainText()
        print str(self.ui.comboBox.currentText())

        if self.ui.quialityBox.isChecked():
            q = "Streaming started" + "\n" + "quality: " + self.ui.Setquality.toPlainText() + "\n" + "player: " + str(self.ui.comboBox.currentText())
            self.ui.theLog.append(q)
            #print self.ui.Setquality.toPlainText()
        else:
            p = "Streaming" + "\n" + "player: " + str(self.ui.comboBox.currentText()) + "\n"
            self.ui.theLog.append(p)

    def stop(self):
        print 'stop pressed.'
        self.close()




if __name__ == "__main__":
        app = QtGui.QApplication(sys.argv)
        myapp = MyDialog()
        myapp.show()
        sys.exit(app.exec_())
</code></pre>
<p>I need to be able to get the data from this, inside the worker function, is there a way?</p>
<pre><code>print "in:  ", self.ui.rtmpIN.toPlainText()
print "out: ", self.ui.outPUT.toPlainText()
</code></pre>
<p>edit: forgot the form.py here it is
<a href="http://pastebin.com/HksuSjkt" rel="nofollow noreferrer">http://pastebin.com/HksuSjkt</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is my Solution:</p>
<pre><code>from PyQt4.QtCore import QThread

class Worker(QThread):
    def __init__(self, parent=None):
        super(Worker, self).__init__(parent)
        self.textin = ""
        self.textout = ""
        self.okay = True

    def setTextIn(self, text):
        self.textin = text

    def setTextOut(self, text):
        self.textout = text

    def run(self):
        while self.okay:
            print('IN:' + self.textin)
            print('OUT:' + self.textout)
            time.sleep(2)

    def stop(self):
        self.okay = False


class MyDialog(QtGui.QDialog):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        self.worker = Worker(self)
        self.ui = Ui_Dialog()
        self.ui.setupUi(self)
        self.ui.rtmpIN.textChanged.connect(self.changeText)
        self.ui.outPUT.textChanged.connect(self.changeText)
        self.ui.startButton.clicked.connect(self.start)
        self.ui.stopButton.clicked.connect(self.stop)
        self.ui.comboBox.addItem("player 1")
        self.ui.comboBox.addItem("player 2")
        self.ui.comboBox.addItem("player 3")

    def selectionchange(self,i):
        print(self.ui.comboBox.currentText())

    def start(self):
        self.worker.start()
        print("in:  "+self.ui.rtmpIN.toPlainText())
        print("out: "+self.ui.outPUT.toPlainText())
        print(self.ui.comboBox.currentText())

        if self.ui.quialityBox.isChecked():
            q = "Streaming started" + "\n" + "quality: " + self.ui.Setquality.toPlainText() + "\n" + "player: " + str(self.ui.comboBox.currentText())
            self.ui.theLog.append(q)
        else:
            p = "Streaming" + "\n" + "player: " + str(self.ui.comboBox.currentText()) + "\n"
            self.ui.theLog.append(p)

    def changeText(self):
        self.worker.setTextIn(self.ui.rtmpIN.toPlainText())
        self.worker.setTextOut(self.ui.outPUT.toPlainText())

    def stop(self):
        self.worker.stop()
        self.worker.quit()
        self.worker.wait()
        print('stop pressed.')
        self.close()

    def closeEvent(self, event):
        self.worker.stop()
        self.worker.quit()
        self.worker.wait()
        QtGui.QDialog.closeEvent(self, event)


if __name__ == "__main__":
        app = QtGui.QApplication(sys.argv)
        myapp = MyDialog()
        myapp.show()
        sys.exit(app.exec_())
</code></pre>
<p>Output:</p>
<p><a href="https://i.stack.imgur.com/nTI0h.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/nTI0h.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Im not an expert on PyQt but I assume you keep an entry widget in your <code>form.py</code> eyllanesc mentioned and I can see you imported.</p>
<p>One of the reasons you use special variables to contain string and such from UIs, is that the class it resides in is occupying a designated memory space (good when it comes to scopes and such).</p>
<p>When it comes to multiPROCESSING the memory spaces is no longer shared and you cannot reach this variable any longer. If you however use multiTHREADING, it is a new thread, but in the same process, which means it can access the Qt string you want.</p>
<p>The syntax is for this purpose the same</p>
<pre><code>import threading

def foo(): pass

t = threading.Thread(target=foo,
                     args=[])

t.daemon = True

t.start()
</code></pre>
<p>Learn more about threads <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">here</a></p>
</div>
<span class="comment-copy">please add form.py</span>
<span class="comment-copy">@eyllaneschere is the form <a href="http://pastebin.com/HksuSjkt" rel="nofollow noreferrer">pastebin.com/HksuSjkt</a></span>
<span class="comment-copy">@Sligthz I am created Qthread process <a href="https://github.com/CodeHuntersLab/CuriElements/blob/master/CuriElements/soundthread.py" rel="nofollow noreferrer">github.com/CodeHuntersLab/CuriElements/blob/master/CuriElements/â€¦</a></span>
<span class="comment-copy">@Sligthz try with my solution</span>
<span class="comment-copy">i get aan error NameError: name 'QThread' is not defined  nvm, i added from PyQt4.QtCore import QThread  but now when i click stop p i get another error     super().closeEvent(event) TypeError: super() takes at least 1 argument (0 given)</span>
<span class="comment-copy">@Slightz update my solution</span>
<span class="comment-copy">@Slightz complete code: <a href="http://pastebin.com/jQ2vFc4t" rel="nofollow noreferrer">pastebin.com/jQ2vFc4t</a></span>
<span class="comment-copy">I am using python 2.7 if that helps, I still get the same error  TypeError: super() takes at least 1 argument (0 given) from what I read, super() requires an argument in Python 2.7 whereas Python 3 it does not when I click stop i get the error..</span>
<span class="comment-copy">@Slightz change to QtGui.QDialog.closeEvent(self, event)</span>
<span class="comment-copy">Yes, i tried threading module, but will I go about killing that thread? For instance, the app is to restream using FFmpeg I connect to ssh using paramiko, and execute the command. Thus, sometimes the stream is bad, and I need to stop and edit. If I close the GUI every time, I will have to set up the rtmp info over again, so I want to disconnect when I click stop and re-connect</span>
