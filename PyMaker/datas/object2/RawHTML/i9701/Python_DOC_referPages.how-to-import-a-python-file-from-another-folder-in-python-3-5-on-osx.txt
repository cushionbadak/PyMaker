<div class="post-text" itemprop="text">
<p>I use Python 3.5 and my project structure is like this: </p>
<pre><code>Project/
    App/
        myApp.py
    Libraries/
        myLibA.py
        myLibB.py
</code></pre>
<p>I want to import <code>myLibA.py</code> in <code>myApp.py</code></p>
<p>If I simply write <code>from Libraries import myLibA</code> I end up with this error : </p>
<blockquote>
<p>ImportError: No module named Libraries.</p>
</blockquote>
<p>I found the Q/A <a href="https://stackoverflow.com/questions/4383571/importing-files-from-different-folder-in-python">Importing files from different folder in Python</a>, from which I adapted my own solution, adding this at the beginning of <code>myApp.py</code> in order to add my <code>Project</code> folder to the Python Path :</p>
<pre><code>import sys
sys.path.insert(0, sys.path[0] + "..")
</code></pre>
<p>This worked well on Windows, but when I run <code>myApp.py</code> from the same project on OSX (10.9) I see the same error message, my module is not found. </p>
<p>To reproduce my issue it's very simple. Just fill the Python files like this : </p>
<p><strong>myApp.py</strong> : </p>
<pre><code>import sys
sys.path.insert(0, sys.path[0] + "..")

from Libraries import myLibA

if __name__ == '__main__':
    myLibA.print_hello()
</code></pre>
<p><strong>myLibA.py</strong> : </p>
<pre><code>def print_hello():
    print("Hello")
</code></pre>
<p>I don't understand why the Python Path method doesn't work here. Anyway, I'm looking for a solution that keeps the Python file compatible with Windows and that is contained in the sources (in the Python files). I've seen a few console hooks but I'm not satisfied with that because I want to be able to clone the project on any OSX/Windows PC with Python 3.5, and just run myApp.py. I'm looking for a solution that doesn't involve any library not natively present in Python 3.5. </p>
<p>Is there another way to achieve this ? </p>
<p>(If not, is it because it is somehow not <em>pythonic</em> to organize a project like this? As a C developer I might have the wrong approach)</p>
</div>
<div class="post-text" itemprop="text">
<p>Add <code>__init__.py</code> to your <code>Libraries</code> directory.  That file can be empty, and it  magically turns the <code>Libraries</code> directory into a <a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer"><em>package</em></a>.  Now:</p>
<pre><code>import sys
import os.path
libdir = os.path.dirname(__file__)
sys.path.append(os.path.split(libdir)[0])   

from Libraries import myLibA

if __name__ == '__main__':
    myLibA.print_hello()
</code></pre>
<p>The <code>__file__</code> special variable gives the filename of the current script.  <code>os.path.dirname()</code> gives the directory it resides in, and <code>os.path.split(libdir)[0]</code> gives its parent directory.  This should work wherever the script is called from.</p>
<p>I am using <code>append</code> rather than <code>insert</code>.  It is generally advised that user directories are searched last, and also <code>append</code> is more efficient than <code>insert</code> in the C Python implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should have <code>__init__.py</code> inside every folder that you want to import.
Also a common project structure for a python project is this:</p>
<pre><code>Project/ 
Libraries/         &lt;-- this will contain app specific code (Libraries)
    __init__.py
    myLibA.py
    myLibB.py
main.py
</code></pre>
<p>Where main.py will contain the entry code of you app, just like C's main(), for example</p>
<pre><code>from Libraries import myLibA

if __name__ == '__main__':
    myLibA.print_hello()
</code></pre>
<p>No need to tinker with sys.path in runtime.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/72852/how-to-do-relative-imports-in-python">This Question</a> is somewhat similar. My favourite answer suggests a project structure like this in your case:</p>
<pre><code>Project/
    myApp.py
    Libraries/
        __init__.py
        myLibA.py
        myLibB.py
</code></pre>
<p>With the library code in <code>myLibA.py</code> unchanged the app code and import would look like this:</p>
<pre><code>from Libraries import myLibA

if __name__ == "__main__":
    myLibA.print_hello()
</code></pre>
<p><strong>Edit 1:</strong></p>
<p>When the requested folder structure is necessary, this change to the  <code>myApp.py</code> file:</p>
<pre><code>import sys
import os
sys.path.append(os.path.abspath(".."))
</code></pre>
<p>works too.</p>
</div>
<span class="comment-copy">Does <code>Libraries</code> has an <code>__init__.py</code> in it?  If not then an empty one will do:  <code>touch __init__.py</code>.  Second:  don't use relative path names (..), you are asking for trouble, use absolute path names, or use environment variables (like <code>os.environ['HOME']</code>).</span>
<span class="comment-copy">@cdarke they don't, I thought it was a Python 2 thing. The problem with an absolute path is that I don't know in advance at which location the project will be cloned.</span>
<span class="comment-copy">You also will not know the current directory of the process running <code>python</code> either.   Should it be relative to the directory that your script resides in, for example?  As a C programmer, you wouldn't do a <code>#include('../fred.h')</code> would you?</span>
<span class="comment-copy">@cdarke That's right I assumed the current process directory would be the one containing myApp.py. As a C programmer I'd just include "fred.h" and tell the linker to look for the files in all the project folders.</span>
<span class="comment-copy">Thank you, this works fine both on Windows and OSX. I was sure that the <b>init</b>.py file was only required in Python 2, and that Python 3 wasn't using it. Was I wrong about this ?</span>
<span class="comment-copy">Generally <code>__init__.py</code> is used on both.  At 3.3 <i>Namespace Packages</i> were introduced, but those are for splitting a package across directories. I have not seen them used much and I don't think that is appropriate in your case.  See <a href="https://www.python.org/dev/peps/pep-0420/" rel="nofollow noreferrer">python.org/dev/peps/pep-0420</a>.  The point about <code>__init__.py</code> is that it can contain initialisation code for the <i>package</i>, including defining functions.</span>
<span class="comment-copy">Thank you for this explanation :-)</span>
<span class="comment-copy">Thank you, that's the correct solution, though someone posted it a few seconds before you ;) Just correct me if I'm wrong, but if I don't modify that Path at runtime I have the risk that someone who clones the project on a location that is not in the Path will have an import error as long has he doesn't add the project location to the path, is that right ?</span>
<span class="comment-copy">With the above structure you won't have any issues, there is no need to add anything to path. Just run <code>python /path/to/Project/main.py</code>. The "path" we refer to in python is the path where python looks for packages (folders with __init__py inside), and  the folder of the main.py ("Project" in this case) is already in the python path.</span>
<span class="comment-copy">Oh that's right thanks. But my files will not be at the same level than Libraries. I think that's why I need to modify the path.</span>
<span class="comment-copy">if you insist to put them in an "app" directory, then go ahead, modify the path but I dont think it 's worth it. But instead of adding '..' in the path, search google for getting the folder of a file in python</span>
<span class="comment-copy">The thing is that I oversimplified my current Project structure for asking this question, but I actually have a high amount of myApp.py files, all with a main function, etc. I put them in a subfolder to keep the Project folder as clean as possible.</span>
<span class="comment-copy">Thanks for the answer. I think it would work, but I want to put myApp.py in a subfolder. I simplified my usecase a lot for asking the question, but actually I have plenty of files such as myApp1.py, myApp2.py, etc, so I prefer to put them all in a subfolder.</span>
