<div class="post-text" itemprop="text">
<p>Started learning python after lots of ruby experience. With that context in mind:</p>
<p>I have a csv file that looks something like this:</p>
<h2>city_names.csv</h2>
<pre><code>"abidjan","addis_ababa","adelaide","ahmedabad"
</code></pre>
<p>With the following python script I'd like to read this into a list:</p>
<h2>city_names_reader.py</h2>
<pre><code>import csv

city_name_file = r"./city_names.csv"

with open(city_name_file, 'rb') as file:
  reader = csv.reader(file)
  city_name_list = list(reader)

print city_name_list
</code></pre>
<p>The result surprised me:
    <code>[['abidjan', 'addis_ababa', 'adelaide', 'ahmedabad']]</code></p>
<p>Any idea why I'm getting a nested list rather than a 4-element list? I must be overlooking something self-evident.</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">CSV</a> file represents a table of data. A table contains both columns and rows, like a spreadsheet. Each line in a CSV file is one row in the table. One row contains multiple columns, separated by <code>,</code></p>
<p>When you read a CSV file you get a list of rows. Each row is a list of columns.</p>
<p>If your file have only one row you can easily just read that row from the list:</p>
<pre><code>city_name_list = city_name_list[0]
</code></pre>
<p>Usually each column represent some kind of data (think "column of email addresses"). Each row then represent a different object (think "one object per row, each row can have one email address"). You add more objects to the table by adding more rows.</p>
<p>It is not common with wide tables. Wide tables are those that grow by adding more columns instead of rows. In your case you have only one kind of data: <em>city names</em>. So you should have one column ("name"), with one row per <em>city</em>. To get city names from your file you could then read the first element from each row:</p>
<pre><code>city_name_list = [row[0] for row in city_name_list]
</code></pre>
<p>In both cases you can flatten the list by using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">itertools.chain</a>:</p>
<pre><code>city_name_list = itertools.chain(city_name_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others suggest, your file is not an idiomatic CSV file. You can simply do:</p>
<pre><code>with open(city_name_file, "rb") as fp:
    city_names_list = fp.read().split(",")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on comments, here is a possible solution:</p>
<pre><code>import csv

city_name_file = r"./city_names.csv"
city_name_list = []

with open(city_name_file, 'rb') as file:
  reader = csv.reader(file)
  for item in reader:
    city_name_list += item

print city_name_list
</code></pre>
</div>
<span class="comment-copy">try:     city_name_list = [row for row in reader]</span>
<span class="comment-copy">Each line of the file is a list of values. Your list() call creates a list of lists, one for each line.</span>
<span class="comment-copy">That works for me, yes, but is this the most idiomatic way to go about things? In other words, if I know that my csv file will just be one comma-separated list, is there a way I can read it in without creating the unnecessary nested structure in the first place?</span>
<span class="comment-copy">Depends on your definition of "idiomatic". This is an idiomatic way of working with CSV files. But your file is not an idiomatic CSV (edited my answer to clarify that) so perhaps you shouldn't use a CSV parser in the first place!</span>
<span class="comment-copy">@pgblu: You can use <code>next(reader)</code>, but do take a look at Emil's edited post.</span>
<span class="comment-copy">Re: not using a CSV parser, what would I use instead? I just want to take a file with a comma-separated list and read it into a list for further processing. I did not realize that the 'normative' CSV is akin to a table. Makes me think the term 'CSV' is a misnomer, but that's a separate topic.</span>
