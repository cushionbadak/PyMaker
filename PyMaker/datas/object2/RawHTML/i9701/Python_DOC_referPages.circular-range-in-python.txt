<div class="post-text" itemprop="text">
<p>How can I implement a circular range <strong>object</strong> in Python?</p>
<p>e.g. </p>
<p>Let S is a circular space modulo 2^3 (range [0, 2^3)).
I want to generate a range object like this:</p>
<pre><code>crange(3, 7, 2 ** 3) =&gt; a range object [3, 4, 5, 6]
crange(7, 3, 2 ** 3) =&gt; a range object [7, 0, 1, 2]
</code></pre>
<p>I tryed this:</p>
<pre><code>def crange(start, stop, modulo):
    if start &gt; stop:
        return range(start, modulo) or range(stop)
    else:
        return range(start, stop)
</code></pre>
<p>But I can't input bigint to crange e.g. <code>crange(8, 2, 2 ** 160)</code>.</p>
<pre><code>OverflowError: Python int too large to convert to C ssize_t
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>def crange(start, stop, modulo):
    result = []
    index = start
    while index != stop:
        result.append(index)
        index = (index + 1) % modulo
    return result
</code></pre>
<p>If you know that your list can be too long, you can use a generator instead that generates the necessage sequence:</p>
<pre><code>def crange(start, stop, modulo):
    index = start
    while index != stop:
        yield index
        index = (index + 1) % modulo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid the use of range and the storage of a huge list in memory by creating your own generator:</p>
<pre><code>def crange(start, end, modulo):
    if start &gt; end:
        while start &lt; modulo:
            yield start
            start += 1
        start = 0

    while start &lt; end:
        yield start
        start += 1

print list(crange(3, 7, 2 ** 3))
print list(crange(7, 3, 2 ** 3))
print next(crange(8, 2, 2 ** 160))
</code></pre>
<p>This code outputs:</p>
<pre><code>[3, 4, 5, 6]
[7, 0, 1, 2]
8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thank you very much, everyone.</p>
<p>I implemented <code>crange</code> which I want (in reference to @Ni and @J.F.Sebastian).</p>
<pre><code>import math


class crange:
    def __init__(self, start, stop, step=None, modulo=None):
        if step == 0:
            raise ValueError('crange() arg 3 must not be zero')

        if step is None and modulo is None:
            self.start = 0
            self.stop = start
            self.step = 1
            self.modulo = stop
        else:
            self.start = start
            self.stop = stop
            if modulo is None:
                self.step = 1
                self.modulo = step
            else:
                self.step = step
                self.modulo = modulo

    def __iter__(self):
        n = self.start
        if n &gt; self.stop:
            while n &lt; self.modulo:
                yield n
                n += 1
            n = 0
        while n &lt; self.stop:
            yield n
            n += 1

    def __contains__(self, n):
        if self.start &gt;= self.stop:
            return self.start &lt;= n &lt; self.modulo or 0 &lt;= n &lt; self.stop
        else:
            return self.start &lt;= n &lt; self.stop
</code></pre>
<p>I got the following output:</p>
<pre><code>&gt;&gt;&gt; print(list(crange(start=7, stop=3, modulo=2 ** 4)))
[7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2]
&gt;&gt;&gt; print(3 in crange(start=7, stop=3, modulo=2 ** 4))
False
&gt;&gt;&gt; print(7 in crange(start=7, stop=3, modulo=2 ** 4))
True
&gt;&gt;&gt; print(list(crange(start=3, stop=7, modulo=2 ** 4)))
[3, 4, 5, 6]
&gt;&gt;&gt; print(3 in crange(start=3, stop=7, modulo=2 ** 4))
True
&gt;&gt;&gt; print(7 in crange(start=3, stop=7, modulo=2 ** 4))
False
</code></pre>
</div>
<span class="comment-copy">What have you tried already? post it so we can help. SO is not a code writing service</span>
<span class="comment-copy">What result do you want for <code>crange(0, 8)</code> in the example you give?</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/1482480/4279"><code>xrange(2**100)</code> -&gt; OverflowError: long int too large to convert to int</a>. In particular, <a href="https://github.com/zed/lrange/" rel="nofollow noreferrer"><code>lrange()</code></a></span>
<span class="comment-copy">Interestingly, your code is raising <code>OverflowError</code> because evaluating the truthiness of a large <code>range</code> apparently raises <code>OverflowError</code> (even though the range itself is representable). That's arguably a bug. I've opened <a href="http://bugs.python.org/issue28876" rel="nofollow noreferrer">bugs.python.org/issue28876</a></span>
<span class="comment-copy">@sira: it is related but it is a different issue (lrange() won't help unless it will define <code>__bool__</code> methodâ€”it is easy but it will break the compatibility with the range() from Python 3). No range() object would generate <code>7, 0, 1, 2</code>. The specific error is due to <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer">bool(range())</a> being implemented as len(range()) and due to the implementation history len() is limited to C ssize_t size. Here's what <a href="http://bugs.python.org/msg70525" rel="nofollow noreferrer">Guido said about it in 2008</a></span>
<span class="comment-copy"><code>crange(2, 2 ** 100, 2 ** 160)</code> take up so much memory. How can I fix it?</span>
<span class="comment-copy">It doesn't. The generator doesn't store anything in memory except for the local variables.</span>
<span class="comment-copy">I understood. Thank you.</span>
