<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2612802/how-to-clone-or-copy-a-list">How to clone or copy a list?</a>
<span class="question-originals-answer-count">
                    20 answers
                </span>
</li>
</ul>
</div>
<p>Help! I have a big problem using Python. 
  We know in Python if <code>A=[1,2,3]</code> and if <code>B=A</code>, <code>B[1]=10</code>, then <code>A=[1,10,3]</code>.
  To fix this, we can <code>import copy</code> and <code>B =copy.copy(A)</code> or <code>B=A[:]</code>.
  In both cases, doing <code>B[1]=10</code> won't change <code>A</code>.</p>
<p>Now I extend <code>A</code> as a dictionary, and <code>A[1]=[1,2,3]</code>. Doing</p>
<pre><code>  A = {1:[1,2,3]}
  A[2] = A[1][:]
  for j in range(len(A[1])):
      A[2].append(4)
  print (A[2])
  print (A[1])
</code></pre>
<p>the result shows</p>
<pre><code>  [1, 2, 3, 4, 4, 4]
  [1, 2, 3]
</code></pre>
<p>It only changes <code>A[2]</code>, not <code>A[1]</code>. So it is good.
   But If I do <code>A[1] = [[1],[2],[3]]</code>, and</p>
<pre><code>  A = {1:[[1],[2],[3]]}
  A[2] = A[1][:]
  for j in range(len(A[1])):
      A[2][j].append(4)    
  print (A[2])
  print (A[1])
</code></pre>
<p>which instead gives me</p>
<pre><code>  [[1, 4], [2, 4], [3, 4]]
  [[1, 4], [2, 4], [3, 4]]
</code></pre>
<p>not</p>
<pre><code>  [[1, 4], [2, 4], [3, 4]]
  [[1], [2], [3]]
</code></pre>
<p>where <code>A[1]</code> was changed. Anyone can help me figure this out? I even use <code>A[2] = copy.copy(A[1])</code> still doesn't work. Thank you very much for the solution!!!!</p>
</div>
<div class="post-text" itemprop="text">
<p>The explantation for this behavior is that you're only copying at the first level. When you set up your dictionary as</p>
<pre><code>&gt;&gt;&gt; A = {1:[[1],[2],[3]]}
&gt;&gt;&gt; A[2] = A[1][:]
</code></pre>
<p>then <code>A[2]</code> is an independent copy of <code>A[1]</code> <em>only at the first level</em> (<code>id</code> gives the memory address of an object):</p>
<pre><code>&gt;&gt;&gt; id(A[1])
4347137160
&gt;&gt;&gt; id(A[2])
4347154056
</code></pre>
<p>However, respective elements of <code>A[1]</code> and <code>A[2]</code> are still references to the same object:</p>
<pre><code>&gt;&gt;&gt; id(A[1][0])
4346993992
&gt;&gt;&gt; id(A[2][0])
4346993992
</code></pre>
<p>As pointed out in other comments, you would have to make a deepcopy to also copy at the second level:</p>
<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; A[2] = copy.deepcopy(A[1])
&gt;&gt;&gt; id(A[1][0])
4346993992
&gt;&gt;&gt; id(A[2][0])
4349177096
</code></pre>
</div>
<span class="comment-copy">Have you tried <code>copy.deepcopy()</code>?</span>
<span class="comment-copy">use <a href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="nofollow noreferrer">docs.python.org/3/library/copy.html#copy.deepcopy</a></span>
<span class="comment-copy">@Graham, thanks! yes <code>copy.deepcopy()</code> works!</span>
<span class="comment-copy">what about if I have <code>A ={1:[[[1],[2],[3]],[4]]}</code> (three levels)? should <code>copy.deepcopy()</code> still  work? In this case, always using <code>copy.deepcopy()</code> is a safe way?</span>
<span class="comment-copy">yes, <code>deepcopy</code> works recursively to an arbitrary number of levels</span>
<span class="comment-copy">great! this is super-important to me! a ton of thanks!</span>
