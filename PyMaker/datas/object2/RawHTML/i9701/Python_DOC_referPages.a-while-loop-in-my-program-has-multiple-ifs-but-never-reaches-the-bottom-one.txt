<div class="post-text" itemprop="text">
<p>I am in the middle of a really difficult to grasp assignment for school. I've been trying for a few days and I think I'm finally almost done, but... I'm stuck again and don't know why. </p>
<p>I am supposed to let the user fill in a number invoer (Dutch)/input. That number is supposed to be smaller than, or equal to 50. This number determines how many more inputs the user can do - these new inputs are test cases.
Each test case should be a number larger than 0, but equal to, or lower than 100. It is not required to go very deep into handling bad input, so I only use some basic handling for that.</p>
<p>Then what needs to be tested for each test case, is what the smallest number is that is divisible by the test case, but the sum of the separate digits of that smallest number should equal your test case itself. So in the example they state: input = 1, (which means 1 test case, but they dont state that), input 2 = 10 (which means your only test case is the number 10, but they dont state that). What it sends out is the number 190 (this is because 190/10 = 19, so it's a correct outcome, but 1+9+0 = 10 as well, so it passes the second test, but again, they dont state that. I had to figure this all out myself, which is why the assigment takes me so long... the question itself is in Dutch and barely gives you any information at all).</p>
<p>So what my program DOES test, if I input number 25 as test case for example, that 25/25 = 1, so valid and 2+5 = 7. However, after calculating this number 7, it never seems to check the second condition. The sum of the digits needs to be 25, not 7. The program gets thrown in an infinite loop now and I don't see what is wrong.</p>
<p>I will post my code below. I apologize for the variable names and printed text, as they are in Dutch. I hope I explained the meaning of all this clearly enough.</p>
<pre><code>import sys

invoer = int(input('Vul het aantal testgevallen in: '))
if invoer &lt;= 50:
    invoer = invoer
else:
    print('Het getal moet groter kleiner dan of gelijk aan 50 zijn!!')
    sys.exit()

t = 0
testgevallen = []

while t &lt; invoer:

    invoer2 = int(input('Vul een testgeval in groter dan 0 en kleiner of gelijk aan 100: '))
    if 0 &lt; invoer2 &lt;= 100:
        print('Testgeval ', t + 1, 'is: ', invoer2)
        testgevallen.append(invoer2)
        t += 1
        print('Array is ', testgevallen)
    else:
        print('Het getal moet groter zijn dan 0 en kleiner of gelijk aan 100!!')
        sys.exit()
t = 0

while t &lt; invoer:
    print('Opgegeven nummer ', t + 1, ' is ', testgevallen[t])
    vermenigvuldiging = 1

    doorgaan = True

    while doorgaan == True:
        getal = testgevallen[t] * vermenigvuldiging

        if testgevallen[t] % getal == 0:
            print(getal, ' - Dit getal is deelbaar door ', testgevallen[t])

            som = sum(map(int, str(getal)))
            print(som)

            if som == testgevallen[t]:
                print('Output moet zijn: ', som)
                doorgaan = False

            else:
                doorgaan = True

        else:
            doorgaan = True
            vermenigvuldiging += 1

    t += 1
    doorgaan = doorgaan
</code></pre>
<p>I hope you guys can help me. Thanks a lot for you time in advance, I know it's quite the wall of text.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are multiple issues at hand:</p>
<p>In your inner loop in the second test's (if the sum of digits matches) else branch you've forgot to increment <code>vermenigvuldiging</code>, so when it "finds" the first <code>getal</code> that satisfies the modulo condition, it will loop forever.</p>
<p>Handling of <code>getal</code> in the modulo test is also broken and will only match when <code>vermenigvuldiging</code> is 1, otherwise <code>testgevallen[t] % getal</code> will always equal <code>testgevallen[t]</code>, since <code>getal</code> is larger. This will also result in an infinite loop. In fact the whole</p>
<pre><code>getal = testgevallen[t] * vermenigvuldiging
</code></pre>
<p>seems like it is meant to iterate through numbers divisible by <code>testgevallen[t]</code> quickly in ascending order. This makes the whole modulo test redundant.</p>
<p>A working solution for at least the input <em>10</em> could be for example:</p>
<pre><code>for tv in testgevallen:
    print('Opgegeven nummer ', t + 1, ' is ', tv)
    vermenigvuldiging = 1

    while True:
        getal = tv * vermenigvuldiging
        # I've no idea what this says, but probably something along the lines
        # of "is divisible by" and can be removed. Do print `getal` though
        # when `som` is a match.
        print(getal, ' - Dit getal is deelbaar door ', tv)
        som = sum(map(int, str(getal)))
        print(som)

        if som == tv:
            print('Output moet zijn: ', som)
            break

        # This is going to take a loooooong time for tv == 100    
        vermenigvuldiging += 1
</code></pre>
<p>Note that I've removed using an index variable to iterate through the values of the list. Just iterate through it directly. You could also "enhance" your solution further using <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a>, in which case you'd replace the while-loop with something like:</p>
<pre><code>for vermenigvuldiging in count(1):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>while doorgaan == True:
getal = testgevallen[t] * vermenigvuldiging

if testgevallen[t] % getal == 0:
    print(getal, ' - Dit getal is deelbaar door ', testgevallen[t])

    som = sum(map(int, str(getal)))
    print(som)

    if som == testgevallen[t]:
        print('Output moet zijn: ', som)
        doorgaan = False

    else:
        doorgaan = True

else:
    doorgaan = True
    vermenigvuldiging += 1
</code></pre>
<p>In this while loop <code>t</code> is never modified, so <code>som == testgevallen[t]</code> will be constant, causing an infinite loop. </p>
</div>
<div class="post-text" itemprop="text">
<p>First, you should look up the usage of sys.exit() on the <a href="https://docs.python.org/2/library/sys.html" rel="nofollow noreferrer">docs here</a>. This command will exit the program when called, so if it is called at the end of the first while loop, the second while loop won't ever get run. The command you should use to break out of a while loop is break as used below</p>
<pre><code>while t &lt; invoer:

invoer2 = int(input('Vul een testgeval in groter dan 0 en kleiner of gelijk aan 100: '))
if 0 &lt; invoer2 &lt;= 100:
    print('Testgeval ', t + 1, 'is: ', invoer2)
    testgevallen.append(invoer2)
    t += 1
    print('Array is ', testgevallen)
else:
    print('Het getal moet groter zijn dan 0 en kleiner of gelijk aan 100!!')
    break.
</code></pre>
<p>I suspect that the second while loop never gets run because you are using sys.exit() instead of just breaking from the loop. Also, in the second while loop, you need to alter your t variable or else <code>Output moet zijn: ', som</code> will constantly be printed and stuck in this loop.</p>
</div>
<span class="comment-copy">Please specify the problem clearly. Use numbers if required.  Then, provide some example input and expected output combination! It helps!</span>
<span class="comment-copy">I think that you forgot to increment t below &lt; "if som == testgevallen[t]:print('Output moet zijn: ', som)  doorgaan = False &gt;</span>
<span class="comment-copy">A more pythonic way of doing the first  <code>while t &lt; invoer:</code> would be <code>for t in range(invoer):</code>   The second <code>while t &lt; invoer</code> should be something like; <code>for vallen in testgevallen:</code>.  This would eliminate the need for <code>t</code>, and the indexing errors you seem to have.</span>
<span class="comment-copy">The <code>while doorgaan == True:</code> is also clumsy.  You could exit the loop by replacing <code>doorgaan = False</code> with <code>break</code>, which makes it unclear why you would need <code>doorgan</code> at all.</span>
<span class="comment-copy">@ Ehsan, I'm pretty sure I did. @Petruz &amp; @ CAB, thanks. I'm new to Pyhton. Only know a bit of Java (and HTML/CSS/JavaScript).</span>
<span class="comment-copy">Thanks a ton! I was able to figure it out thanks to you! And yes, I do some unneccesary prints from time to time, just for myself to confirm stuff while I test. I always remove it after finishing up.</span>
<span class="comment-copy">Nicholas shows the main thing. But I'd add that as a matter of good practice, you don't need to read in all the values and save them in a list. You never need them all at once, so you can just read one, process it, and then read the next one into the same variable. Since you limit it to 50 numbers it's not a problem, but when you do bigger data, it will be.</span>
<span class="comment-copy">I'd wager <code>t</code> is not meant to be incremented in the inner loop, but <code>vermenigvuldiging</code> is, if it does not match both the requirements, which it is not in the second else-block.</span>
<span class="comment-copy">I thought of that, but without <code>t</code> changing, you would never get a chance to increment <code>vermenigvuldiging</code>, unless <code>testgevallen[t] % getal == 0</code> is initially <code>False</code></span>
<span class="comment-copy">I'm starting to think that the <code>testgevallen[t] % getal == 0</code> is also broken: it can only be satisfied when <code>vermenigvuldiging</code> is <i>1</i>, or the number to test is 0, which it cannot be. Otherwise <code>getal</code> will be larger than the number to test and the modulo will always result in the number to test as well. The idea behind <code>getal = testgevallen[t] * vermenigvuldiging</code> is perhaps to quickly iterate numbers divisible by the number to test, but then the modulo is just unnecessary entirely.</span>
<span class="comment-copy">Removing the modulo entirely, incrementing <code>vermenigvuldiging</code> if <code>som</code> does not match quickly finds that the smallest (not 100% sure on this) number for 25 to meet the requirements is 4975. It also works for 10, finding the 190 from the question description.</span>
<span class="comment-copy">It was my goal to exit the program when the input numbers defy what the rules of what can be thrown into the program. Very basic handling, like I explained. But thanks for trying to help :D</span>
