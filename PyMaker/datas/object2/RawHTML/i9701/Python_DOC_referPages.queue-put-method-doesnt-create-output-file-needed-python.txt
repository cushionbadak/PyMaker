<div class="post-text" itemprop="text">
<p>I am writing a simple caesar cipher program in python using threads and queues. Even though my program is able to run, it doesn't create the necessary output file. Would appreciate any help, thanks! </p>
<p>I am guessing the anomaly starts where I use the queues to store ciphered strings, here:</p>
<pre><code>for i in range(0,len(data),l):
    while not q1.full:
        q1.put(data[index:index+l])
        index+=l
    while not q2.empty:
        output_file.write(q2.get())
</code></pre>
<p>Here is the whole code:</p>
<pre><code>import threading
import sys
import Queue
import string

#argumanlarin alinmasi
if len(sys.argv)!=4:
    print("Duzgun giriniz: '&lt;filename&gt;.py s n l'")
    sys.exit(0)
else:
    s=int(sys.argv[1])
    n=int(sys.argv[2])
    l=int(sys.argv[3])

#Global
index = 0

#kuyruk deklarasyonu
q1 = Queue.Queue(n)
q2 = Queue.Queue(2000)

lock = threading.Lock()

#Threadler
threads=[]

#dosyayi okuyarak stringe cevirme
myfile=open('metin.txt','r')
data=myfile.read()

#Thread tanimlamasi
class WorkingThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)

    def run(self):
        lock.acquire()
        q2.put(self.caesar(q1.get(), s))
        lock.release()

    def caesar(self, plaintext, shift):
        alphabet = string.ascii_lowercase
        shifted_alphabet = alphabet[shift:] + alphabet[:shift]
        table = string.maketrans(alphabet, shifted_alphabet)
        return plaintext.translate(table)

for i in range(0,n):
    current_thread = WorkingThread()
    current_thread.start()
    threads.append(current_thread)

output_file=open("crypted"+ "_"+ str(s)+"_"+str(n)+"_"+str(l)+".txt", "w")

for i in range(0,len(data),l):
    while not q1.full:
        q1.put(data[index:index+l])
        index+=l
    while not q2.empty:
        output_file.write(q2.get())

for i in range(0,n):
    threads[i].join()

output_file.close()
myfile.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>while not q1.full</code> can never be <code>True</code>, as <code>full</code> is a method, and as such will always be <code>True</code> in a boolean context, therefore <code>not q1.full</code> will always be <code>False</code>, you need to <em>call</em> the method: <code>q1.full()</code>. Same for <code>q2.full</code>.</p>
<p>Also, you should'n try to detect wheather the queue is full in this case. If it ever would be not full, then you would continut to add data until it was and then ignore the rest, or your <code>index</code> can increase beyond the size of <code>data</code> and you would continue to add 0-length data chunks.</p>
<p>You should use a separate thread for writing to <code>q1</code> and for reading from <code>q2</code>, then you can just let <code>q1</code> block on <code>put()</code>.</p>
<p>Also, you're using the same lock in your worker threads to basically serialize all computations, which defeats the purpose of threading. The problem you're dealing with is CPU bound, for which multithreading isn't going to give you any speedup in python. Have a look at the <code>multiprocessing</code> module. Using <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map" rel="nofollow noreferrer"><code>multiprocessing.Pool.map()</code></a> (or some other of the map-methods) the whole program could be simplified dramatically and give you a speed up through mutliprocessig at the same time.</p>
</div>
<span class="comment-copy">Thank you for pointing out my mistake. I've removed the part where I tried to detect whether the queue was full.   In your third sentence, I didn't quite get how I should implement what you just said. (By the way my program is still not functioning as I want it to after deleting the detecting conditions). Should I open two threads; Writethread &amp; Readthread?  I will try writing the code with multiprocessing as well, thanks for the recommendation.</span>
<span class="comment-copy">You only need one additional thread, e.g. for writing to the queue and keep reading in the main thread (or the other way round). Also, when you use such a consumer-producer pattern the order in which the results are returned is not the same as the order in which the jobs were enqueued, but for this kind of problem you need to preserve the order. <code>Pool.map()</code> doesn't have that problem as it keeps the order.</span>
