<div class="post-text" itemprop="text">
<p>Alright, lets suppose I have a class called Tab and that class has a method that takes in keys and values of dictionaries and and makes it into a huge dictionary.</p>
<pre><code>class Tab():

def __init__(self):
    if not 'table' in dir(self):
        self._table = {}        

def add_table(self, key, value):    
    self._table[key] = value
</code></pre>
<p>Now if i were to have a function and a dictionary</p>
<pre><code>dic = {'A': ['A', 'B','C'], 'B':['D', 'E','F']}
def read_table():
    table = Tab()
    for key in dic:
        table.add_table(key, dic[key])
    return table
test = read_table()
</code></pre>
<p>And if I were to run this it would run fine, but if I did this,</p>
<pre><code>new_test = test['A']
</code></pre>
<p>It would crash. I know I can fix this by converting the object back into a dictionary, but i need the type to be the Tab class(the one i defined earlier).</p>
<p>How can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>To make a <code>Tab</code> instance behave like a dictionary, you can override <code>__getitem__(self, item)</code>, <code>__setitem__(self, key, value)</code> and <code>__repr__(self)</code> methods within <code>Tab</code> class:</p>
<pre><code>class Tab():

    def __init__(self):
        if not 'table' in dir(self):
            self._table = {}

    def add_table(self, key, value):
        self._table[key] = value

    def __getitem__(self, item):
        return self._table[item]

    def __setitem__(self, key, value):
        self._table[key] = value

    def __repr__(self):
        return self._table.__repr__()

dic = {'A': ['A', 'B','C'], 'B':['D', 'E','F']}
...
# read_table() function declaration (omitted)
...
test = read_table()
new_test = test['A']       # accessing dict element
test['C'] = ['G','H','I']  # setting a new dict element

print(new_test)
print(test)       # printing Tab instance as a dict
print(type(test))
</code></pre>
<p>The output(sequentially):</p>
<pre><code>['A', 'B', 'C']
{'B': ['D', 'E', 'F'], 'A': ['A', 'B', 'C'], 'C': ['G', 'H', 'I']}
&lt;class '__main__.Tab'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why you overcomplicate things? Why not inherit <code>dict</code> object, and using <code>update</code> method.</p>
<p>Or even better to inherit <a href="https://docs.python.org/3/library/collections.html#userdict-objects" rel="nofollow noreferrer"><code>UserDict</code></a> from <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer"><code>collections</code></a> module.</p>
<pre><code>from collections import UserDict

class Tab(UserDict):
    pass

dic = {'A': ['A', 'B','C'], 'B':['D', 'E','F']}

def read_table(dic):
    table = Tab()
    table.update(dic)
    return table

read_table(dic).data['A']
</code></pre>
<p>And it's better to pass obj in <code>read_table</code> function.</p>
</div>
<span class="comment-copy">what do you mean <code>crash</code> ? Do you get error message ? Always show full error message (Traceback) in question.</span>
<span class="comment-copy">see <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><b>getitem</b></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__setitem__" rel="nofollow noreferrer"><b>setitem</b></a></span>
