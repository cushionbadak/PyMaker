<div class="post-text" itemprop="text">
<p>I have a dictionary with lists and want to create a function that can find lists by using "substring". So that if the list's name is "Things to do on Monday" you only have to type "Monday" to find the list. </p>
<p>Here is what I have so far.</p>
<p>A dictionary.</p>
<pre><code>list_dict = {}
list_dict["Things to do on Monday"] = ['clean', 'workout', 'buy food']
list_dict["Grocery list"] = ['oranges', 'apples', 'milk']
list_dict["Monday outfit"] = ['jeans', 't-shirt', 'shoes']
</code></pre>
<p>A function.</p>
<pre><code>def substring_function(substring):
    for key in list_dict.keys():
        if substring in key:
            return list_dict[key]
</code></pre>
<p>Then, I do for example:</p>
<pre><code>print(substring_function("Monday"))
</code></pre>
<p>The problem is that as you can see I have the word "Monday" in two lists, and I can't figure out how to make it return BOTH lists. </p>
<p>I guess there is something wrong with my for-loop.</p>
<p>Can anyone help me out? Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make the function a generator by replacing the <code>return</code> statement with a <code>yield</code> statement instead:</p>
<pre><code>def substring_function(substring):
    for key in list_dict.keys():
        if substring in key:
            yield list_dict[key]
</code></pre>
<p>so that <code>list(substring_function("Monday"))</code> will return a list of matches.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need add every ocurrency in one var and return after the loop finish</p>
<pre><code>def substring_function(substring):
    rs = list()
    for key in list_dict.keys():
        if substring in key:
            rs.append(list_dict[key])
    return rs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try link this.</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d["Things to do on Monday"] = ['clean', 'workout', 'buy food']
&gt;&gt;&gt; d["Grocery list"] = ['oranges', 'apples', 'milk']
&gt;&gt;&gt; d["Monday outfit"] = ['jeans', 't-shirt', 'shoes']
&gt;&gt;&gt; 
&gt;&gt;&gt; d
{'Things to do on Monday': ['clean', 'workout', 'buy food'], 'Monday outfit': ['jeans', 't-shirt', 'shoes'], 'Grocery list': ['oranges', 'apples', 'milk']}
&gt;&gt;&gt; 

&gt;&gt;&gt; def substring_function(substring, list_dict):
...     final_list = []
...     for key in list_dict:
...         if substring in key:
...             final_list.append(list_dict[key])
...     return final_list
... 
&gt;&gt;&gt; substring_function("Monday", d)
[['clean', 'workout', 'buy food'], ['jeans', 't-shirt', 'shoes']]
&gt;&gt;&gt; 
</code></pre>
<p>Further, you can pass the returned object to any function as follows (by destructing it using * ).</p>
<pre><code>&gt;&gt;&gt; def print_items(*args):
...     for arg in args:
...         print(arg)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; print_items(*substring_function("Monday", d))
['clean', 'workout', 'buy food']
['jeans', 't-shirt', 'shoes']
&gt;&gt;&gt; 
&gt;&gt;&gt; # OR 
... 
&gt;&gt;&gt; items = substring_function("Monday", d)
&gt;&gt;&gt; print_items( *items )
['clean', 'workout', 'buy food']
['jeans', 't-shirt', 'shoes']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about just looking for the 'monday' key(or the key you want to search for):</p>
<pre><code>for key in d.keys():
    if 'monday' in key.lower():
        print(key, d[key])
#Output:
Things to do on Monday ['clean', 'workout', 'buy food']
Monday outfit ['jeans', 't-shirt', 'shoes']
</code></pre>
<p>and if you want both lists in one:</p>
<pre><code>def substring(key_to_look_for):
    test = []
    for key in d.keys():
        if key_to_look_for in key.lower():
            test.append(d[key])
    return test

print(substring('monday'))
#Output:
[['clean', 'workout', 'buy food'], ['jeans', 't-shirt', 'shoes']]
</code></pre>
<p>With list comprehensions:</p>
<pre><code>def substring(key_to_look_for):
    l = [d[key] for key in d.keys() if key_to_look_for in key.lower()]
    return l
print(substring('monday'))
#Output:
[['clean', 'workout', 'buy food'], ['jeans', 't-shirt', 'shoes']]
</code></pre>
<p>List comprehension with lambdas:</p>
<pre><code>def substring(key_to_look_for):
    l = [d[i] for i in list(filter(lambda x: key_to_look_for in x.lower(), d.keys()))]
    return l
substring('monday')
#Output:
[['clean', 'workout', 'buy food'], ['jeans', 't-shirt', 'shoes']]
</code></pre>
</div>
<span class="comment-copy">Simple fix would be to return a list of all results that contain Monday from the function rather than the first one you see</span>
<span class="comment-copy">I prefer this yield version of the answer - uses less memory, takes fewer lines and is particularly more readable when the logic is more complex (say requires control flow). Some like to prefix the name of such function with <code>iter_</code>. For example <code>dict.keys</code> vs <code>dict.iterkeys</code>. Also dict dot iter items|values</span>
<span class="comment-copy">I tried it but it when I run the program, it just says "&lt;generator object substring_function at...&gt;". Can I actually make it print the list instead?</span>
<span class="comment-copy">@JonasGraffman Yes, you would have to pass the returning generator to the <code>list</code> constructor, as I pointed out in the answer.</span>
