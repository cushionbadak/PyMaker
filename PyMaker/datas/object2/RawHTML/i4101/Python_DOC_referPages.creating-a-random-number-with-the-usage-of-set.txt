<div class="post-text" itemprop="text">
<p>Considering the fact that set is an unordered data structure, I began to wonder if it is possible to create a truly "random" number with the usage of it (or with the usage of a dictionary).</p>
<p>Lets consider such an input number represented as a string:</p>
<pre><code>input = "0123456789"
</code></pre>
<p>And then we convert the string into a set:</p>
<pre><code>input_set = set(input)
</code></pre>
<p>After printing the result of this operation multiple times, we have following example outputs:</p>
<blockquote>
<p>{'9', '3', '4', '6', '0', '7', '1', '8', '5', '2'}</p>
<p>{'3', '4', '2', '1', '5', '7', '0', '8', '6', '9'}</p>
</blockquote>
<p>Now we can convert the elements of the set into a string with the usage of:</p>
<pre><code>output = ''.join(set_input)
</code></pre>
<p>And the result of this operation for the sets above would be:</p>
<blockquote>
<p>9346071852</p>
<p>3421570869</p>
</blockquote>
<p>Would generation of a random number in a following way be considered a good practice?</p>
<p>And most of all, do I understand correctly that it would be a "pseudorandom" number, because we could reproduce the result with the usage of some seed value or key?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, this is not good practice.</p>
<p>The order is determined by the random hash seed, and this seed is <strong>fixed for the current Python interpreter</strong>. You would not be able to produce more than one 'random' order per interpreter. The hash seed is also a <em>implementation detail</em>, there to prevent a class of denial of service attacks. Different Python implementations (including future releases produced by Python.org) are free to come up with a different implementation of sets that doesn't use a hash seed. See the <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-r" rel="nofollow noreferrer"><code>-R</code> switch documentation</a> for more details.</p>
<p>The seed is also aimed at producing good hashing performance, not cryptographic security. The ordering of values in a set is also determined by the insertion order of the elements; it is a combination of the hash for each value and any clashes when translating the hash into the (limited) choices of slots available in a hash table that determines the ordering of the elements. If you were to repeat your experiments, you'd almost certainly see a bias towards certain numbers appearing in certain positions.</p>
<p>Stick to the <a href="https://docs.python.org/3/library/secrets.html" rel="nofollow noreferrer"><code>secrets</code> module</a> to produce cryptographically secure random numbers.</p>
<p>For non-secure operations, just use the <code>random</code> module; using <code>random.shuffle()</code> on your digits would already give a far better distribution of the numbers, statistically speaking.</p>
</div>
<span class="comment-copy"><code>set</code> is not random at <i>all</i>; it's <i>arbitrary</i>. The language makes no guarantees about any property of the output. An implementation would be free to sort the elements if it so chose.</span>
<span class="comment-copy">@chepner so why does it denerate a different output on every run?</span>
<span class="comment-copy">Just because it is different doesn't mean it is random. Plus, it's different in the interpreter <i>you</i> are using; that doesn't mean <i>every</i> interpreter has to do so.</span>
<span class="comment-copy">@GalAbra: <a href="//stackoverflow.com/q/15479928">Why is the order in dictionaries and sets arbitrary?</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/31598562/ensuring-random-order-for-iteration-over-set-python">Ensuring random order for iteration over Set Python</a></span>
