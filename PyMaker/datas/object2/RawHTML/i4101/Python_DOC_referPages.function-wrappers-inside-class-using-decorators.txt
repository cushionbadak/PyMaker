<div class="post-text" itemprop="text">
<p>I have a class which interacts with a database and so there are repetitive actions (establish session, commit, close session) before and after each member method of the class.</p>
<p>As follows:</p>
<pre><code>class UserDatabaseManager(object):

    DEFAULT_DB_PATH = 'test.db'

    def __init__(self, dbpath=DEFAULT_DB_PATH):
        dbpath = 'sqlite:///' + dbpath
        self.engine = create_engine(dbpath, echo=True)

    def add_user(self, username, password):
        Session = sessionmaker(bind=self.engine)
        session = Session()
        # &lt;============================== To be wrapped
        user = User(username, password)
        session.add(user)
        # ==============================&gt;
        session.commit()
        session.close()

    def delete_user(self, user):
        Session = sessionmaker(bind=self.engine)
        session = Session()
        # &lt;============================== To be wrapped
        # Delete user here
        # ==============================&gt;
        session.commit()
        session.close()
</code></pre>
<p>What is an idiomatic way to abstract out the repeated session calls with a function wrapper?</p>
<p>I would prefer to do this with decorators by declaring a private <code>_Decorators</code> class inside <code>UserDatabaseManager</code> and implementing the wrapper function inside there, but then such class won't be able to access the <code>self.engine</code> instance attribute of the outer class.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple (and in my opinion, the most idiomatic) way of doing this is to wrap the setup/teardown boilerplate code in a <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer">context manager</a> using <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer"><code>contextlib.contextmanager</code></a>. You then simply use a <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code></a> statement in the functions that do the work (rather than trying to wrap that function itself). </p>
<p>For example:</p>
<pre><code>from contextlib import contextmanager

class UserDatabaseManager(object):

    DEFAULT_DB_PATH = 'test.db'

    def __init__(self, dbpath=DEFAULT_DB_PATH):
        dbpath = 'sqlite:///' + dbpath
        self.engine = create_engine(dbpath, echo=True)

    @contextmanager
    def session(self):
        try:
            Session = sessionmaker(bind=self.engine)
            session = Session()
            yield session
            session.commit()
        except:
            session.rollback()
        finally:
            session.close()

    def add_user(self, username, password):
        with self.session() as session:
            user = User(username, password)
            session.add(user)

    def delete_user(self, user):
        with self.session() as session:
            session.delete(user)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a simple function outside the class to wrap each method:</p>
<pre><code>def create_session(**kwargs):
   def outer(f):
     def wrapper(cls, *args):
       Session = sessionmaker(bind=getattr(cls, 'engine'))
       session = Session()
       getattr(session, kwargs.get('action', 'add'))(f(cls, *args))
       session.commit()
       session.close()
     return wrapper
   return outer

class UserDatabaseManager(object):
  DEFAULT_DB_PATH = 'test.db'
  def __init__(self, dbpath=DEFAULT_DB_PATH):
    dbpath = 'sqlite:///' + dbpath
    self.engine = create_engine(dbpath, echo=True)
  @create_session(action = 'add')
  def add_user(self, username, password):
    return User(username, password)

  @create_session(action = 'delete')
  def delete_user(self, user):
     return User(username, password)
</code></pre>
<p>Generally, setup and tear-down operations like the above are best put in a contextmanager:</p>
<pre><code>class UserDatabaseManager(object):
  DEFAULT_DB_PATH = 'test.db'
  def __init__(self, dbpath=DEFAULT_DB_PATH):
     dbpath = 'sqlite:///' + dbpath
     self.engine = create_engine(dbpath, echo=True)

class UserAction(UserDatabaseManager):
  def __init__(self, path):
    UserDatabaseManager.__init__(self, path)
  def __enter__(self):
    self.session = sessionmaker(bind=self.engine)()
    return self.session
  def __exit__(self, *args):
     self.session.commit()
     self.session.close()

with UserAction('/the/path') as action:
   action.add(User(username, password))

with UserAction('/the/path') as action:
   action.remove(User(username, password))
</code></pre>
</div>
<span class="comment-copy">@Luke I actually upvoted both your answers as they work, but it's hard to tell which approach is better at the moment and both are quite similar. I've been meaning to see how either approach scales with my project for a few more days before casting my verdict. But thanks so much for replying to my question!</span>
<span class="comment-copy">I accepted this answer as it's cleaner, but I have to give it to Ajax1234's answer for actually accomplishing the same purpose with decorators and with more gory details around the dunder methods, this was a close call.</span>
<span class="comment-copy">Wouldn't it be a bad thing to commit a session where some statements were valid but then an exception was raised?</span>
<span class="comment-copy">@Rainy can you elaborate? with <code>__enter__</code> and <code>__exit__</code>, any exceptions raised in the setup or the body of the <code>with</code> statement will crash the current program.</span>
<span class="comment-copy">Sorry for taking long to respond; my point is that an exception raised in body of <code>with</code> will cause <code>__exit__</code> to be run and will commit session. (tested on Python3.x). The user most likely doesn't want that, he would either want to commit explicitly at some point or to avoid committing at all if there was an error.</span>
