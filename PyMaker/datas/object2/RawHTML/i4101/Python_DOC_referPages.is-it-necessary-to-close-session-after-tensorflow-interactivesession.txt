<div class="post-text" itemprop="text">
<p>I have a question about <code>InteractiveSession</code> in Tensorflow</p>
<p>I know <code>tf.InteractiveSession()</code> is just convenient syntactic
sugar for keeping a default session open and basically work the same like below:</p>
<pre><code>with tf.Session() as sess:
    # Do something
</code></pre>
<p>However, I have seen some examples online, they did't call <code>close()</code> at the end of the code after using <code>InteractiveSession</code>.</p>
<p><strong>Question</strong>:<br/>
1. Would it caused any problem without closing the session like session leak? <br/>
2. How the GC work for the InteractiveSession if we don't close it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>tf.InteractiveSession</code> is just convenient syntactic sugar for keeping a <strong>default</strong> session open.</p>
<p>The Session implementation has <a href="https://github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/client/session.py#L678-L686" rel="nofollow noreferrer">a comment</a></p>
<blockquote>
<p>Calling this method frees all resources associated with the session.</p>
</blockquote>
<p>A quick test</p>
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/env python
# -*- coding: utf-8 -*-


import argparse
import tensorflow as tf
import numpy as np


def open_interactive_session():
    A = tf.Variable(np.random.randn(16, 255, 255, 3).astype(np.float32))
    sess = tf.InteractiveSession()
    sess.run(tf.global_variables_initializer())


def open_and_close_interactive_session():
    A = tf.Variable(np.random.randn(16, 255, 255, 3).astype(np.float32))
    sess = tf.InteractiveSession()
    sess.run(tf.global_variables_initializer())
    sess.close()


def open_and_close_session():
    A = tf.Variable(np.random.randn(16, 255, 255, 3).astype(np.float32))
    with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--num', help='repeat', type=int, default=5)
    parser.add_argument('type', choices=['interactive', 'interactive_close', 'normal'])
    args = parser.parse_args()

    sess_func = open_and_close_session

    if args.type == 'interactive':
        sess_func = open_interactive_session
    elif args.type == 'interactive_close':
        sess_func = open_and_close_interactive_session

    for _ in range(args.num):
        sess_func()
    with tf.Session() as sess:
        print("bytes used=", sess.run(tf.contrib.memory_stats.BytesInUse()))
</code></pre>
<p>gives</p>
<pre><code>"""
python example_session2.py interactive
('bytes used=', 405776640)
python example_session2.py interactive_close
('bytes used=', 7680)
python example_session2.py
('bytes used=', 7680)
"""
</code></pre>
<p>This provokes a session-leak, when not closing the session.<strike>Note, even when closing the session, there is currently bug in TensorFlow which keep 1280 bytes per session see <a href="https://stackoverflow.com/q/49735217/7443104">Tensorflow leaks 1280 bytes with each session opened and closed?</a>.</strike> (This has been fixed now).</p>
<p>Further, there is some logic in the <a href="https://github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/client/session.py#L698-L715" rel="nofollow noreferrer"><code>__del__</code></a> trying to start the GC.</p>
<p>Interestingly, I never saw the warning </p>
<blockquote>
<p>An interactive session is already active. This can cause out-of-memory errors in some cases. You must explicitly call <code>InteractiveSession.close()</code> to release resources held by the other session(s)</p>
</blockquote>
<p>which seems to be <a href="https://github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/client/session.py#L1709-L1714" rel="nofollow noreferrer">implemented</a>. It guess the only raison d'Ãªtre of the InteractiveSession is its usage in Jupyter Notebookfiles or inactive shells in combination with <code>.eval()</code>. But I advised against using eval (see <a href="https://stackoverflow.com/q/50177766/7443104">Official ZeroOut gradient example error: AttributeError: 'list' object has no attribute 'eval'</a>)</p>
<blockquote>
<p>However, I have seen some examples online, they did't call close() at the end of the code after using InteractiveSession.</p>
</blockquote>
<p>And I am not surprised by that. Guess how many code snippets are the without a <code>free</code> or <code>delete</code> after some malloc. Bless the OS that it frees up the memory.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer">with</a> uses a context manager which already handles the entry and exit from its block of code. So no, you don't need to call <code>close()</code>.</span>
<span class="comment-copy">He is talking about not closing after <code>tf.InteractiveSession()</code></span>
<span class="comment-copy">Your example and explanation above are amazing!! One more question, (a little bit off topic from this question), would it free the memory after stopping the kernel in Jupyter notebook even if without closing the session?</span>
<span class="comment-copy">Honestly, I don't know it exactly but I bet yes. According the jupyter documentation "Note that the RAM is not released until the kernel is shut-down." it is very likely. There is no reason to keep the Python process and TensorFlow session alive. So the OS once more will probably pick up the pieces and clear the memory.</span>
