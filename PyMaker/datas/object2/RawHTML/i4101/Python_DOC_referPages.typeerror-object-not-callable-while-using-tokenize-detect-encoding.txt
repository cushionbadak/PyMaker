<div class="post-text" itemprop="text">
<p>I'm reading a bunch of txt.gz files but they have different encoding (at least UTF-8 and cp1252, they are old dirty files). I try to detect the encoding of <code>fIn</code> before reading it in text-mode but I get the error: <code>TypeError: 'GzipFile' object is not callable</code></p>
<p>The corresponding code:</p>
<pre><code>   # detect encoding
   with gzip.open(fIn,'rb') as file:
        fInEncoding = tokenize.detect_encoding(file) #this doesn't works
        print(fInEncoding)

    for line in gzip.open(fIn,'rt', encoding=fInEncoding[0], errors="surrogateescape"):
        if line.find("From ") == 0:
            if lineNum != 0:
                out.write("\n")
            lineNum +=1
            line = line.replace(" at ", "@")
        out.write(line)
</code></pre>
<p>Traceback</p>
<pre><code>$ ./mailmanToMBox.py list-cryptography.metzdowd.com
 ('Converting ', '2015-May.txt.gz', ' to mbox format')
 Traceback (most recent call last):
  File "./mailmanToMBox.py", line 65, in &lt;module&gt;
    main()
  File "./mailmanToMBox.py", line 27, in main
    if not makeMBox(inFile,outFile):
  File "./mailmanToMBox.py", line 48, in makeMBox
    fInEncoding = tokenize.detect_encoding(file.readline()) #this doesn't works                                                         
  File "/Users/simon/anaconda3/lib/python3.6/tokenize.py", line 423, in detect_encoding                                                 
    first = read_or_stop()
  File "/Users/simon/anaconda3/lib/python3.6/tokenize.py", line 381, in read_or_stop                                                    
    return readline()
 TypeError: 'bytes' object is not callable
</code></pre>
<p>EDIT
I tried to use the following code:</p>
<pre><code># detect encoding
readsource =  gzip.open(fIn,'rb').__next__
fInEncoding = tokenize.detect_encoding(readsource)
print(fInEncoding)
</code></pre>
<p>I have no error but it always return utf-8 even when it isn't. My text editor (sublime) detect correctly the cp1252 encoding.</p>
</div>
<div class="post-text" itemprop="text">
<p>As the documentation of <code>detect_encoding()</code> <a href="https://docs.python.org/3/library/tokenize.html#tokenize.detect_encoding" rel="nofollow noreferrer">says</a>, it's input parameter has to be a callable that provides lines of input. That's why you get a <code>TypeError: 'GzipFile' object is not callable</code>.</p>
<pre><code>import tokenize

with open(fIn, 'rb') as f:
    codec = tokenize.detect_encoding(f.readline)[0]
</code></pre>
<p>... <code>codec</code> will be "utf-8" or something like that.</p>
</div>
<span class="comment-copy">traceback please?</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre traceback added.</span>
<span class="comment-copy">But why file.readlines() is not callable? I understood that I have to give a callable object, didn't understood how. (I'm new to python)</span>
<span class="comment-copy">The <code>detect_encoding()</code>-function will call the function you pass in to get lines of text from the input. It may call it multiple times if it needs more lines to detect the encoding. If you pass <code>detect_encoding(f.readlines())</code>, the result of <code>f.readlines()</code> gets passed in (which is the whole file, as a list of lines), which is not what <code>detect_encoding</code> needs. It's argument is "give me something I can call without any further arguments that gets me more text if I need any". Updated the answer.</span>
<span class="comment-copy">your solution works but I have the same problem that with the solution I add when I edited my answer a bit before using    <code>readsource =  gzip.open(fIn,'rb').__next__</code> <code>fInCodec = tokenize.detect_encoding(readsource)[0]</code> It always return UTF-8 even when their is char that are not UTF-8. But I guess it's another problem.</span>
<span class="comment-copy">This is a limitation of <code>tokenize.detect_encoding()</code>, which is designed to detect the encoding of python-source-files. Specifically, it only looks at the first two lines and only looks for the BOM (which is not always present) and the python-specific encoding-cookie (which is never present for general text files). For non-python-files, a library like <a href="https://pypi.org/project/chardet/" rel="nofollow noreferrer">chardet</a> is probably better. Also see <a href="https://stackoverflow.com/questions/436220/determine-the-encoding-of-text-in-python">here</a></span>
