<div class="post-text" itemprop="text">
<p>Newbie alert- but have spent a few hours now on this and just cant figure it out - i have this list :</p>
<pre><code>players = [{'name': 'John', 'points': '27', 'Played': '6'},
{'name': 'Emil', 'points': '43', 'Played' : '13'},
{'name': 'Susan', 'points': '11', 'Played': '2'},
{'name': 'Peter', 'points': '4', 'Played': '3'}]
</code></pre>
<p>What i would like to do was to be able to say :</p>
<pre><code>players["John"]["score"]=newScore
players["john"]["Played"] = players["john"]["Played"]+1
</code></pre>
<p>This list represents like a list of objects, where the name is the primary key and then theres parameters for each object.</p>
<p>But ofcourse that doesnt work, im able to touch elements by, ex doing :</p>
<pre><code>print (players[0]["score"])
</code></pre>
<p>and this would then print Johns score alright, but with this way i would need to go through all players[x] to first compare if the name is the same, and then i can access it, it just doesnt seems so python to me.</p>
<p>How would you go about this in a pythonic way ? </p>
</div>
<div class="post-text" itemprop="text">
<p>You could wrap your current data with a class that could provide the specialized update methods you specified, without changing the entire structure of your original data to begin with:</p>
<pre><code>class Row:
   def __init__(self, row):
      self.row = row
   def __setitem__(self, _t, _val):
      self.row[_t] = str(_val)
   def __getitem__(self, _stat):
      return int(self.row[_stat])
   def __repr__(self):
      return '{}({})'.format(self.__class__.__name__, str(self.row))

class Players:
   def __init__(self, data={}):
      self.data = {i['name']:Row(i) for i in data}
   def __getitem__(self, name):
      return self.data[name]
   def __setitem__(self, _name, _data):
      self.data[_name] = Row(_data)
   def __repr__(self):
      return '{}({})'.format(self.__class__.__name__, str(self.data))

players = [{'points': '27', 'name': 'John', 'Played': '6'}, {'points': '43', 'name': 'Emil', 'Played': '13'}, {'points': '11', 'name': 'Susan', 'Played': '2'}, {'points': '4', 'name': 'Peter', 'Played': '3'}]
d = Players(players)
d['John']['points'] = 30
d["John"]["Played"] = d["John"]["Played"]+1
print(d['John'])
d['Bob'] = {'points': '2', 'Played': '5'}
</code></pre>
<p>Output:</p>
<pre><code>Row({'points': '30', 'name': 'John', 'Played': '7'})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Change your data structure, if <code>Name</code> is a key then simply:</p>
<pre><code>players_dict = {d['Name']: d for d in players}
</code></pre>
<p>would allow you to do:</p>
<pre><code>players_dict["John"]["score"] = new_score
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need to access those dicts by player name, it is better that you adapt the format of your data to this need.</p>
<p>E.g.:</p>
<pre><code>playersDict = {o['name']: o for o in players}
</code></pre>
<p>Now you can youse <code>playersDict</code> as in your example:</p>
<pre><code>&gt;&gt;&gt; playersDict['John']['Played']
'6'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, a list of dictionaries is inefficient and not a recommended solution to hold structured data of this kind.</p>
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> from the standard library, but I prefer 3rd party library <code>pandas</code>, which accepts a list of dictionaries directly:</p>
<pre><code>import pandas as pd

players = [{'name': 'John', 'points': '27', 'Played': '6'},
           {'name': 'Emil', 'points': '43', 'Played' : '13'},
           {'name': 'Susan', 'points': '11', 'Played': '2'},
           {'name': 'Peter', 'points': '4', 'Played': '3'}]

df = pd.DataFrame(players)

print(df)

  Played   name points
0      6   John     27
1     13   Emil     43
2      2  Susan     11
3      3  Peter      4
</code></pre>
<p>You can then perform manipulations using the <code>pandas</code> API:</p>
<pre><code># Add a new column and specify value for a given name
df['Score'] = 0
df.loc[df['name'] == 'John', 'Score'] = 1

# Add 1 to John played
df.loc[df['name'] == 'John', 'Played'] += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can make new structure data for that.
e.g.</p>
<pre><code>&gt;&gt;&gt; new_data_struct_players = {}

&gt;&gt;&gt; for player in players:
...    new_data_struct_players[player['name']] = {
...        'points': int(player['points']),  # make it number (int)
...        'Played': int(player['points'])   # make it number too
...    }

&gt;&gt;&gt; print(new_data_struct_players['John'])
{'points': '27', 'Played': 27}

print(new_data_struct_players['John']['points'])
27
</code></pre>
</div>
<span class="comment-copy">@PM2Ring Ah, my mistake.  Please see my recent edit. Now it merely iterates once, when an instance of <code>Player</code> is created.</span>
<span class="comment-copy">@MTdrip Please see my recent edit. I added a <code>__setitem__</code> method in <code>Player</code> to enable creation of new players.</span>
<span class="comment-copy">@MTdrip What Ajax said. But unfortunately it won't update the original <code>players</code> list, so when a new player is added to <code>d</code> it gets out of sync with <code>players</code>. Of course, there are ways around that, but things are starting to get complicated...</span>
<span class="comment-copy">@MTdrip The underlying structure is still a dictionary stored as an attribute of the class; however, the class itself provides slightly different functionality by allowing you to apply the inverted methods of data lookup originally mentioned by utilizing builtin <code>__getitem__</code>/<code>__setitem__</code> methods.</span>
<span class="comment-copy">@MTdrip That is correct.</span>
<span class="comment-copy">my god :) if you knew the amount of hours and ugly code i tried to get around this - this programming language is so beautiful. Do have an additional question for dictionaries and lists but better post it as a new question</span>
<span class="comment-copy">why is the dictionary inefficient ? what i probably end out with in the end in this learning project, is that i would need a structure that would be a dictionary structure like i described here, but on the player, i would then attached an additonal list or dictionary, which would contain all games played by the player ( the games that adds up to the score) which could be many - would something like this be where i should look into the panda ?</span>
<span class="comment-copy">It's ok to suggest Pandas when it's appropriate for a question that isn't tagged Pandas, but please bear in mind that not everyone want to use or install Pandas.</span>
<span class="comment-copy">@MTdrip, A list of dictionaries is inefficient because it requires many levels of passing; first pass each list, then pass each dictionary; then check if key-value pair already exists, etc. If you aren't permitted to use <code>pandas</code>, please do look at the other solutions here. What I would say is there are <i>much better</i> data structures to use for learning purposes than a list of dictionaries; look up named tuples, for example.</span>
<span class="comment-copy">@jpp thanks i will try to get around as much as possible as its learning phase and i dont rule out panda if it makes things easier for me and in the end faster, but probably will try to stick with as much standard as possible to start with as its still a new world to me but am absolutely hooked on this language</span>
<span class="comment-copy">Oh, I wouldn't downvote an answer merely because it uses Pandas, or some other 3rd party library, that the OP didn't tag. Unless, of course, the solution were worse than a plain Python solution. ;)</span>
<span class="comment-copy">think i follow the idea here and its nice that it can act as integer - but i would like to update on the fly, im reading in lines from a text file, and when i meet "John-Lines" in the file i would like to update his stats, and if "John" isnt already in the list i want to add him. Am not sure but the above seems to be that i have to run through the datastructure every time in that case ? or would i be able to only run it if i add a previously unknown player to the dict ?</span>
