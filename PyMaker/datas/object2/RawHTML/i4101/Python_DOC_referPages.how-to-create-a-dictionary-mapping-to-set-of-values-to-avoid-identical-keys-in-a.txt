<div class="post-text" itemprop="text">
<p>I have the following dictionary that maps a word to the frequency with which that word appears in a text:</p>
<pre><code>{'loves' : 3, 'coding' : 3} 
</code></pre>
<p>words 'loves' and 'coding' both appeared 3 times in the text and thus have the same value. Now we know that if we want to swap keys and values in this dictionary, it will return this:</p>
<p>either </p>
<pre><code>{3:'loves'} 
</code></pre>
<p>or this </p>
<pre><code>{3:'coding'} 
</code></pre>
<p>because identical keys are not allowed in a dictionary</p>
<p>Now my question is how do I swap the keys and features in the dictionary while avoiding duplicate keys as follows:</p>
<pre><code>{3: {'loves', 'coding'}} 
</code></pre>
<p>This is my failed attempt:</p>
<pre><code>def func(text, words): 

d = dict()

for word in text.split():
    if word in words:

        if word in d:
            d[word] += 1 

        elif word not in d:
            d[word] = 1

# return d


newDict = dict()

for key in d:
    newKey = d[key]
    newDict[newKey] = set()


    newDict[newKey].add(key)


return newDict 
</code></pre>
<h1>Edit :</h1>
<p>Thanks for all your valuable answers. I also got mine to work by fixing the following bug: a comment is added next to the buggy line  </p>
<pre><code># swapping keys and values in a dictionary:
newDict = dict()

def func(text, words):

    d = dict()

    for word in text.split():
       if word in words:

          if word in d:
              d[word] += 1 

          elif word not in d:
             d[word] = 1

# return d


newDict = dict()

for key in d:

    if d[key] not in newDict:
        newDict[d[key]] = set({key})  # This was my bug. Initially I had 
                                      # newDict[d[key]] = set()

    elif d[key] in newDict:
        newDict[d[key]].add(key)



return newDict 
</code></pre>
<p>Now if I run it on the following input:</p>
<pre><code>func('Ahmed loves loves coding coding is rewarding', {'loves', 'coding', 'I'})
</code></pre>
<p>I get this which is exactly what I wanted:</p>
<pre><code>{2: {'coding', 'loves'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, </p>
<blockquote>
<p>words 'loves' and 'coding' both appeared 3 times in the text and thus have the same key.</p>
</blockquote>
<p>they actually have the same <em>value</em>, not the same key (maybe you mistyped it?).</p>
<p>But you can just do a simple <code>for</code>-loop followed by a simple logic where you check first if the value exist in your new <code>dict</code>; it it does, append to their value; if it doesn't, create a new entry.</p>
<pre><code>d = {'loves' : 3, 'coding' : 3} 
new_dict = {}

for key, value in d.items():
    if new_dict.get(value, None):
        new_dict[value].add(key)
    else:
        new_dict[value] = {key}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As in @RafaelC's answer, only using sets:</p>
<pre><code>d = {'loves' : 3, 'coding' : 3} 
new_dict = {}
for key, value in d.items():
    if value not in new_dict:
        new_dict[value].add(key)
    else:
        new_dict[value] = {key}
</code></pre>
</div>
<span class="comment-copy">My answer uses <code>set</code> :}. I had edited it right after I posted</span>
<span class="comment-copy">You could use <a href="https://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> as a alternative.</span>
