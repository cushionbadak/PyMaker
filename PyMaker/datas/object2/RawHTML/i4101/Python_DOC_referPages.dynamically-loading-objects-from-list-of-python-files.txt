<div class="post-text" itemprop="text">
<p>I'm wondering if I have some python scripts in a folder that will have common functionality like method names but different functionality can by dynamically imported. These python scripts will be in a single folder but I don't know how many their will be. I'd like to have a script look in the folder, get a list of the scripts and create objects for each of them.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're describing is what's usually called a <em>plugin system</em>.</p>
<p>For Python 3.4 and later, there's <a href="https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly" rel="nofollow noreferrer">a standard recipe for importing a source file</a>.</p>
<p>The only things left to do are (a) enumerating all the source files in a specified directory, and (b) calling some factory/register/whatever function on each module after you've loaded it.</p>
<p>So:</p>
<pre><code>def load_module(path):
    name = os.path.split(path)[-1]
    spec = importlib.util.spec_from_file_location(name, path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

plugins = []
for fname in os.listdir(PLUGIN_DIR):
    if not fname.startswith('.') and fname.endswith('.py'):
        try:
            module = load_module(os.path.join(PLUGIN_DIR, fname)
            plugins.append(module.plugin_factory())
</code></pre>
<p>The <code>plugin_factory</code> is just a function or class that "creates an object" for each module. You can call it whatever you want. Often, either every plugin provides a class that's a subclass of (or duck-types as) some type that you defined, or provides a function that returns an instance of some class that you defined. But in really simple cases, you can just use the module itself as the plugin object. In that case, of course, the last line just becomes <code>plugins.append(module)</code>.</p>
<p>And obviously, if you want to access the plugins by name rather than just iterating over them (and they don't have some <code>name</code> attribute), you'll want to store them in a dict rather than a list.</p>
<p>And of course you can add them to <code>sys.modules</code>, as in the recipe in the docs, but usually you don't need that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose we have three files in current dir.</p>
<p>a.py:</p>
<pre><code>def f():
    pass
</code></pre>
<p>b.py:</p>
<pre><code>def g():
    pass
</code></pre>
<p>c.py:</p>
<pre><code>def h():
    pass
</code></pre>
<p>And the following main.py script which scans current directory for python files, and imports them as needed:</p>
<pre><code>import os

modules = {}
for f in os.listdir('.'):
    if os.path.isfile(f) and f.endswith('.py') and f != 'main.py':
        modname = f[:-3] # remove '.py' extension
        modules[modname] = __import__(modname)

# now the various functions are available via:
modules['a'].f()
modules['b'].g()
modules['c'].h()
</code></pre>
<p>In Python &gt;=3.4 you can use the <code>importlib</code> module, and avoid <code>__import__</code>, whose use is discouraged in the python docs:</p>
<pre><code>import os
import importlib

modules = {}
for f in os.listdir('.'):
    if os.path.isfile(f) and f.endswith('.py') and f != 'main.py':
        modname = f[:-3] # remove '.py' extension
        spec = importlib.util.spec_from_file_location(modname, f)
        modules[modname] = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(modules[modname])

modules['a'].f()
modules['b'].g()
modules['c'].h()
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/932069/building-a-minimal-plugin-architecture-in-python">Building a minimal plugin architecture in Python</a></span>
<span class="comment-copy">You really shouldn't be using <code>__import__</code>, <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow noreferrer">as its own docs say</a>. (Technically, you also shouldn't assume that <code>f[:-3]</code> matches the name of the module, but unless you've installed some funky import hooks, that's not going to bit you.)</span>
<span class="comment-copy">The ironic thing is that <code>__import__</code> used in this way is portable between py2 and py3, while <code>imp</code>/<code>importlib</code> breaks with the version change.</span>
