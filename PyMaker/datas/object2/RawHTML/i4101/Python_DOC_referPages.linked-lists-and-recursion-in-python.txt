<div class="post-text" itemprop="text">
<p>I am newbie in programming and starting out in Python. My question is regarding linked  lists, I wrote a class for the linked list, what I need to do is to have a function with an input as a reference pointing towards the head of the list. 'linked_list.head' as I understand, with linked_list being the name of the list in question. Specifically using recursion, I am trying to find the length of the list as the output of this function. Here's my code, I don't quite understand how I could move to the next node and return the number of nodes with recursion in this case. </p>
<pre><code>import re
def special_match(strg, search=re.compile(r'[^A-Za-z.]').search):
    return not bool(search(strg))

class node:
    def __init__(self, data, next):
        self.data = data
        self.next = next

    def get_data(self):
        return self.data

    def set_data(self,value):
        self.data = value

    def get_next_node(self):
        return self.next

    def set_next_node(self,val):
        self.next = val

class linked_list:

    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def add_first(self,e):
        newest = node(e,None)
        newest.next = self.head
        self.head = newest
        self.size = self.size+1
        if self.size == 1:
            self.tail = newest

    def add_last(self,e):
        newest = node(e,None)
        if self.size &gt; 0:
            self.tail.next = newest
        else:
            self.head = newest
        self.tail = newest
        self.size = self.size+1

    def remove_first(self):
        if self.size == 0:
            print('The linked list is empty')
        elif self.size == 1:
            answer = self.head.data
            self.head = None
            self.tail = None
            self.size -= 1
            return answer
        else:
            answer = self.head.data
            self.head = self.head.next
            self.size = self.size - 1
            return answer

    def remove_last(self):
        if self.size == 0:
            print('The linked list is empty')
        elif self.size == 1:
            answer = self.tail.data
            self.head = None
            self.tail = None
            self.size -= 1
            return answer
        else:
            temp  = self.head
            while(temp.next is not None):
                temp = temp.next
            temp.next = None


    def node_number(self,reference):
        reference = str(reference)
        count = 0
        temp = self.head
        if special_match(reference) == True:
            count =+ 1
            temp = temp.next
            return self.node_number  
        else:
            print('You have made wrong input')

    def printe(self):
        curr = self.head
        while curr:
            print(curr.data)
            curr = curr.get_next_node()
        if self.size == 0:
            print('The list is empty')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Recursion is a functional heritage and so using it with functional style will yield the best results. In your program, you have implemented a linked list using imperative style <a href="https://en.wikipedia.org/wiki/Immutable_object" rel="nofollow noreferrer">mutable</a> nodes- that is, the values of <code>data</code> and <code>next</code> can change over time. While this might feel like an intuitive approach, I'd like to focus on an <em>immutable</em> implementation that frees us from crippling state complexity. In this answer, we will implement <em>all</em> linked list functions using recursive forms expressed with functional styles.</p>
<p>We start with simple <code>node</code> and <code>linked_list</code> classes. This time we skip creating <code>get_*</code> and <code>set_*</code> functions as you have done. There's other ways to do this kind of thing in Python as we'll see in a minute</p>
<pre><code>class node:
  def __init__ (self, left, right):
    self.left = left
    self.right = right


class linked_list:
  def __init__ (self, node = None):
    self.node = node
</code></pre>
<p>Next we define primitive <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a> for our list: <code>is_empty</code>, <code>head</code>, and <code>tail</code></p>
<pre><code>class linked_list:
  def __init__ (self, node = None):
    self.node = node

  @property
  def is_empty (self):
    return self.node is None

  @property
  def head (self):
    if self.is_empty:
      raise Exception ("cannot get head of an empty list")
    else:
      return self.node.left

  @property
  def tail (self):
    if self.is_empty:
      raise Exception ("cannot get tail of an empty list")
    else:
      return self.node.right
</code></pre>
<p>Now the use of a <code>node</code> is completely abstracted, and we can write higher level list behaviors by using our new properties</p>
<pre><code>class linked_list:
  ... 

  def length (self):
    if self.is_empty:
      return 0
    else:
      return 1 + self.tail.length ()
</code></pre>
<p>Above, we see it's very easy to talk about our list thru use of its properties. Before we go further, let's see how we can construct lists and visualize them using <code>print</code>. For object-to-string conversion, we use <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__</code></a></p>
<pre><code>class linked_list:
  ... 

  def add_first (self, x):
    return linked_list (node (x, self))

  def __str__ (self):
    if self.is_empty:
      return "None"
    else:
      return str (self.head) + " -&gt; " + str (self.tail)

ls = linked_list().add_first(3).add_first(2).add_first(1)
print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None

print (ls.length ())
# 3
</code></pre>
<p>Remember, because we've built an immutable linked list, <code>add_first</code> does <em>not</em> change the list it was called upon</p>
<pre><code>ls = linked_list().add_first(3).add_first(2).add_first(1)
print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None

print (ls.add_first (0))
# 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None

print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None
</code></pre>
<p>Before we move on, let's make it easier to construct our linked lists. We add a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer">static</a> <code>build</code> function which allows us to construct a list of a varying number of inputs</p>
<pre><code>class linked_list:
  ...

  @staticmethod
  def build (x = None, *rest):
    if x is None:
      return linked_list ()
    else:
      return linked_list (node (x, linked_list.build (*rest)))

print (linked_list.build (1,2,3))
# 1 -&gt; 2 -&gt; 3 -&gt; None
</code></pre>
<p>Now, let's look at your <code>remove_first</code> and <code>remove_last</code> functions now</p>
<pre><code>class linked_list:
  ...

  def remove_first (self):
    if self.is_empty:
      raise Exception ("cannot remove first element of an empty list")
    else:
      return self.tail

  def remove_last (self):
    if self.is_empty:
      raise Exception ("cannot remove last element of an empty list")
    elif self.tail.is_empty:
      return self.tail
    else:
      return linked_list (node (self.head, self.tail.remove_last ()))

ls = linked_list.build (1,2,3)
print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None

print (ls.remove_first ())
# 2 -&gt; 3 -&gt; None

print (ls.remove_last ())
# 1 -&gt; 2 -&gt; None

print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None
</code></pre>
<p>And <code>node_number</code></p>
<pre><code>class linked_list:
  ...

  def node_number (self, index = 0):
    if self.is_empty:
      raise Exception ("index out of bounds")
    elif index is 0:
      return self.head
    else:
      return self.tail.node_number (index - 1)

ls = linked_list.build ("a", "b", "c")

print (ls.node_number (0))
# "a"

print (ls.node_number (1))
# "b"

print (ls.node_number (10))
# Exception: index out of bounds
</code></pre>
<p>And a <code>add_last</code> freebie</p>
<pre><code>class linked_list:
  ...

  def add_last (self, x):
    if self.is_empty:
      return self.add_first (x)
    else:
      return linked_list (node (self.head, self.tail.add_last (x)))

ls = linked_list.build (1, 2, 3)
print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None

print (ls.add_last (4))
# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; None

print (ls)
# 1 -&gt; 2 -&gt; 3 -&gt; None
</code></pre>
<p>Full program demonstration at <a href="https://repl.it/repls/HollowQuerulousScript" rel="nofollow noreferrer">repl.it</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I'd set it up where the length function is actually part of the <code>Node</code> class rather than the <code>Linked_List</code> class.  The <code>Linked_List</code> class would have a <code>length</code> function too, but all it would do is to call the <code>length</code> function of the <code>head</code> node of the list.</p>
<p>Then, each node would just return the <code>length</code> of it's <code>next</code> instance plus 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>The recursion should have a base case where the code checks if the <code>next</code> attribute is <code>None</code>. If so, the function returns the current count. If not, the counter is incremented and the function <code>length</code> is called as a method of the <code>next</code> attribute, to be able to continue the progression of the recursion along the links, which can be written as:</p>
<pre><code>|val1|pointer| -&gt; |val2|pointer| -&gt; |val3|pointer| -&gt; |val4|pointer| -&gt; |val5|None|
</code></pre>
<p>First, below is a simpler linked list class construct for demonstration:</p>
<pre><code>class Node:
   def __init__(self, val=None):
      self.head = val
      self.next = None 
   def length(self, count = 0):
      if self.next is None:
         return count + 1 if self.next is None and self.head else count
      return self.next.length(count + 1)
   def insert(self, v):
      if self.head is None:
         self.head = v
      else:
         if self.next is None:
           self.next = Node(v)
         else:
           self.next.insert(v)
   @classmethod
   def regular_transform(cls, node, nodes = []):
      '''for easier visulization'''
      return nodes+[node.head] if not node.next else cls.regular_transform(node.next, nodes+[node.head])

n = Node()
for i in [56, 232, 424, 2, 11]:
  n.insert(i)
print(Node.regular_transform(n))
print(n.length())
</code></pre>
<p>Output:</p>
<pre><code>[56, 232, 424, 2, 11]
5
</code></pre>
</div>
<span class="comment-copy">Give the guy a break. He's a newbie and he's simply asking a question (a quite trivial one, but it's specific to his use case.</span>
<span class="comment-copy">Rather than checking the truth of the current node, you could check for the existence of the next. So if node.next != None, step to the next node.</span>
<span class="comment-copy">There are plenty of existing resources on how to compute the length of a linked list. The purpose of Stack Overflow isn't to rewrite those resources every time someone asks.</span>
<span class="comment-copy">@user2357112 SO also doesn't encourage posting links to google in the comments. If you find something off site that answers the question post a link in an answer along with a short summary of the relevant bits. If another question on SO has already asked this question then mark as duplicate. Posting a comment telling OP to google it doesn't help OP or anyone else who finds this question later looking for help. SO is here for you to help others. Not to be the "homework" police.</span>
<span class="comment-copy">@user2357112 You suggested googling the title of the question + the words "length algorithm". I just don't see how that is helpful for anyone. Even if it does turn up useful results, pick one, summarize it in an answer and post the link. That way everyone benefits.</span>
<span class="comment-copy">Thanks for the comprehensive answer, as I understand this is doubly linked list? I appreciate the effort it was extremely helpful</span>
<span class="comment-copy">If it was a doubly-linked list, each node would be able to get the next <i>and</i> the previous node. This is only a singly-linked list as each node <i>only</i> has a link to the next node.</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">Partly because the length function <a href="https://ideone.com/N4iY8p" rel="nofollow noreferrer">doesn't handle false elements</a>, and partly because this is doing too much of the questioner's homework for them.</span>
<span class="comment-copy">(The insertion routine doesn't handle false elements correctly either, for that matter.)</span>
<span class="comment-copy">@user2357112 False elements are out of scope of the example, which is to demonstrate a recursive length-finding method but I did add a more robust check. However, there is no way to prove that the OP's code is homework. Just because it is an elementary CS construct does not mean that he did not write the code himself, or garner it from an online resource for study.</span>
