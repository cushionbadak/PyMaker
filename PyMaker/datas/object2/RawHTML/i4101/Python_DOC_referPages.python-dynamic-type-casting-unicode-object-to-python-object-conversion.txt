<div class="post-text" itemprop="text">
<p>This is a problem I am facing for a data pipeline project.
I have 2 data sources. One contains all the user data, the other contains meta data of what all columns we have to process from the user data to output.</p>
<p>So python is good with dynamic type casting, like if I say</p>
<pre><code>a = float
b = "25.123"
c = a(b)
print(c)
&gt;&gt; 25.123
</code></pre>
<p>This is what I want to do, I want to dynamically type cast values in order to process them correctly. The type is retrieved from the meta-data data source.
The problem is when I do a django model query on the meta-data, I get unicode objects.</p>
<pre><code>a = model.objects.filter(id = 'id') # get the type variable from the meta-data
a = a[0]['type']
print(a)
&gt;&gt; u'float'
a("123.123")
&gt;&gt; TypeError: 'unicode' object is not callable
</code></pre>
<p>How do I convert this u'float' to float ?
Does this approach have any better alternatives ?
I checked out <a href="https://stackoverflow.com/a/28756526/8872639">this</a>, but it does not work</p>
<p>Open to all suggestions</p>
</div>
<div class="post-text" itemprop="text">
<p>In your first example where <code>a = float</code>, <code>a</code> is a built in function, but in your second example, <code>a = u"float"</code>, <code>a</code> is an unicode string. If you want complete "dynamicness" of the built in type to convert to without the need of creating a mapping, you can do this:</p>
<pre><code># for Python 2
a = u"float"
b = "123.123"
import __builtin__
print getattr(__builtin__, a.decode())(b) 
# 123.123

# for Python 3+
a = u"float"
b = "123.123"
import builtins
print(getattr(builtins, a)(b))
# 123.123
</code></pre>
<hr/>
<p>I would advise you <strong><em>not</em></strong> to use <code>eval()</code> (as suggested by <a href="https://stackoverflow.com/a/50148630/6622817">another answer</a>) because it could lead to major security risks. This is why I used the <a href="https://docs.python.org/2/library/__builtin__.html#module-builtins" rel="nofollow noreferrer"><code>__builtin__</code></a>/<a href="https://docs.python.org/3/library/builtins.html#module-builtins" rel="nofollow noreferrer"><code>builtins</code></a> module and <code>getattr()</code> to retrieve the <code>float(...)</code> function. </p>
<hr/>
<p>You may also create a mapping (ie. a <code>dict</code>), to map the unicode string to its corresponding function (suggested by this <a href="https://stackoverflow.com/questions/50148545/python-dynamic-type-casting-unicode-object-to-python-object-conversion#comment87315250_50148545">comment</a>):</p>
<pre><code># both Python 2 and 3
a = u"float"
b = "123.123"
mapping = {u"float": float, u"int": int, u"str": str, u"list": list}
print(mapping[a](b))
# 123.123
</code></pre>
<p>Using a mapping is the safest way to go, but it limits your "dynamicness" to only the types listed in the mapping. </p>
</div>
<div class="post-text" itemprop="text">
<p>You may use the <code>eval()</code> function to evaluate the code, but you need to be careful with that function! Otherwise, you might have a look at that <a href="https://stackoverflow.com/questions/1176136/convert-string-to-python-class-object">post</a>. Another solution is to pre-define allowed types and gather them inside a dictionary mapping <code>typeName</code> with <code>typeConstructor</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>astype</code> from the numpy library:</p>
<pre><code>import numpy as np
np.array(('213.123')).astype(a)
</code></pre>
<p>admittedly, this needs to go via an array, because <code>astype()</code> works on numpy-arrays - but it can compute a string as type.</p>
</div>
<span class="comment-copy">I would create an explicit mapping from strings to types.</span>
<span class="comment-copy">how do we do this with date or datetime objects ? suppose a = u"date", getattr will not work there right</span>
<span class="comment-copy">understood, so instead of using <b>builtin</b>, you use datetime</span>
<span class="comment-copy">better to have a predefined dict mapped, eval() may lead to problems in the future</span>
<span class="comment-copy">Yes, that's why I emphasize the fact that it is needed to be careful. Many security flaws may appear, so I actually won't recommend <code>eval()</code> but that was the first that came to my mind.</span>
