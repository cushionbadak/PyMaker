<div class="post-text" itemprop="text">
<p>I am trying to map a string of characters (A, T, C, G) into a 64 bit integer where each letter is represented as two bits using this mapping:</p>
<pre><code>mapping = {'A': 0b00, 'C': 0b01, 'G': 0b10, 'T': 0b11} 
</code></pre>
<p>The "sequence" string will not be longer than 28 characters, and I intend for the integer to be zero-padded at the beginning to make it 64 bits. Currently, I use the below function, but it is incredibly slow. I then convert the output using by calling: </p>
<pre><code>int(result, 2)
</code></pre>
<p>This currently works, but I'd like to make this function incredibly fast. I don't know C++ well so it's hard for me to port to that. I am trying Cython now but I am unfamiliar with that as well. Any help making this more efficient in Python (or even C++ or Cython equivalent) would be greatly appreciated. </p>
<p>Below is my code, again which I call int() on afterwards.</p>
<pre><code>def seq_to_binary(seq):
    values = [mapping[c] for c in seq]
    BITWIDTH = 2
    return "".join(map(lambda x: bin(x)[2:].zfill(BITWIDTH), values)).encode();
</code></pre>
<p>At typical sequence input would be something like: 'TGTGAGAAGCACCATAAAAGGCGTTGTG'</p>
</div>
<div class="post-text" itemprop="text">
<p>You are interpreting a string of 4 different 'digits' as a number, so a <em>base 4 notation</em>. If you had a string of actual digits, in the range 0-3, you could have <code>int()</code> produce an integer really fast.</p>
<pre><code>def seq_to_int(seq, _m=str.maketrans('ACGT', '0123')):
    return int(seq.translate(_m), 4)
</code></pre>
<p>The above function uses <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate()</code></a> to replace each of the 4 characters with a matching digit (I used the static <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow noreferrer"><code>str.maketrans()</code> function</a> to create the translation table). The resulting string of digits is then interpreted as an integer number in base 4.</p>
<p>Note that this produces an integer object, not binary string of zero and one characters:</p>
<pre><code>&gt;&gt;&gt; seq_to_int('TGTGAGAAGCACCATAAAAGGCGTTGTG')
67026852874722286
&gt;&gt;&gt; format(seq_to_int('TGTGAGAAGCACCATAAAAGGCGTTGTG'), '016x')
'00ee20914c029bee'
&gt;&gt;&gt; format(seq_to_int('TGTGAGAAGCACCATAAAAGGCGTTGTG'), '064b')
'0000000011101110001000001001000101001100000000101001101111101110'
</code></pre>
<p>No padding is needed here; as long as your input sequence is 32 letters or less, the resulting integer will fit in an unsigned 8-byte integer representation. In the above output examples, I used the <code>format()</code> string to format that integer value as a hexadecimal and binary string, respectively, and zero-padded those representations to the correct number of digits for a 64-bit number.</p>
<p>To measure if this is faster, lets take 1 million randomly produced test strings (each 28 characters long):</p>
<pre><code>&gt;&gt;&gt; from random import choice
&gt;&gt;&gt; testvalues = [''.join([choice('ATCG') for _ in range(28)]) for _ in range(10 ** 6)]
</code></pre>
<p>The above function can produce 1 million conversions in under 3/4 of a second on my Macbook Pro with 2.9 GHz Intel Core i7, on Python 3.6.5:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; timeit('seq_to_int(next(tviter))', 'from __main__ import testvalues, seq_to_int; tviter=iter(testvalues)')
0.7316284350017668
</code></pre>
<p>So that's 0.73 microseconds per call.</p>
<p>(previously, I advocated a pre-computation version, but after experimentation I struck on the base-4 idea).</p>
<p>To compare this to the other methods posted here so far, some need to be adjusted to produce integers too, and be wrapped into functions:</p>
<pre><code>def seq_to_int_alexhall_a(seq, mapping={'A': b'00', 'C': b'01', 'G': b'10', 'T': b'11'}):
    return int(b''.join(map(mapping.__getitem__, seq)), 2)

def seq_to_int_alexhall_b(seq, mapping={'A': b'00', 'C': b'01', 'G': b'10', 'T': b'11'}):
    return int(b''.join([mapping[c] for c in seq]), 2)

def seq_to_int_jonathan_may(seq, mapping={'A': 0b00, 'C': 0b01, 'G': 0b10, 'T': 0b11}):
    result = 0
    for char in seq:
        result = result &lt;&lt; 2
        result = result | mapping[char]
    return result
</code></pre>
<p>And then we can compare these:</p>
<pre><code>&gt;&gt;&gt; testfunctions = {
...     'Alex Hall (A)': seq_to_int_alexhall_a,
...     'Alex Hall (B)': seq_to_int_alexhall_b,
...     'Jonathan May': seq_to_int_jonathan_may,
...     # base_decode as defined in https://stackoverflow.com/a/50239330
...     'martineau': base_decode,
...     'Martijn Pieters': seq_to_int,
... }
&gt;&gt;&gt; setup = """\
... from __main__ import testvalues, {} as testfunction
... tviter = iter(testvalues)
... """
&gt;&gt;&gt; for name, f in testfunctions.items():
...     res = timeit('testfunction(next(tviter))', setup.format(f.__name__))
...     print(f'{name:&gt;15}: {res:8.5f}')
...
  Alex Hall (A):  2.17879
  Alex Hall (B):  2.40771
   Jonathan May:  3.30303
      martineau: 16.60615
Martijn Pieters:  0.73452
</code></pre>
<p>The base-4 approach I propose easily wins this comparison.</p>
</div>
<div class="post-text" itemprop="text">
<p>My clumsy straight forward try in Cython, which is twice as fast as the best solution (@MartijnPieters's) so far:</p>
<pre><code>%%cython

ctypedef unsigned long long ull

cdef ull to_int(unsigned char *data, int n):
    cdef ull res=0
    cdef int i
    cdef unsigned char ch
    for i in range(n):
        res&lt;&lt;=2
        ch=data[i]
        if ch==67: #C
            res+=1
        if ch==71: #G
            res+=2
        if ch==84: #T
            res+=3
    return res

cpdef str_to_int_ead(str as_str):
    s=as_str.encode('ascii')
    return to_int(s, len(s))
</code></pre>
<p>Compared to current @MartijnPieters's solution, it is twice as fast on my machine:</p>
<pre><code>&gt;&gt;&gt; [str_to_int_ead(x) for x in testvalues] == [seq_to_int(x) for x in testvalues]
True

&gt;&gt;&gt; tviter=iter(testvalues)
&gt;&gt;&gt; %timeit -n1000000 -r1 seq_to_int(next(tviter))
795 ns ± 0 ns per loop (mean ± std. dev. of 1 run, 1000000 loops each)

&gt;&gt;&gt; tviter=iter(testvalues)
&gt;&gt;&gt; %timeit -n1000000 -r1 str_to_int_ead(next(tviter))
363 ns ± 0 ns per loop (mean ± std. dev. of 1 run, 1000000 loops each)
</code></pre>
<p>That makes 0.795 seconds vs 0.363 seconds for the whole run (so it can be compared with timings measured by @MartijnPieters).</p>
<p>One coould ask, how many overhead can be saved, if the conversion unicode &lt;-&gt; ascii were not needed?</p>
<pre><code>%%cython
....
cpdef bytes_to_int_ead(bytes as_bytes):
    return to_int(as_bytes, len(as_bytes))


&gt;&gt;&gt; testbytes=[bytes(x.encode('ascii')) for x in testvalues]
&gt;&gt;&gt; tviter=iter(testbytes)
&gt;&gt;&gt; %timeit -n1000000 -r1 bytes_to_int_ead(next(tviter))
327 ns ± 0 ns per loop (mean ± std. dev. of 1 run, 1000000 loops each)
</code></pre>
<p>Only 10% faster - this is somewhat surprising...</p>
<p>However, we should not forget we also measuring the overhead of "nexting" an iterator, without we get:</p>
<pre><code>&gt;&gt;&gt; v=testvalues[0]
&gt;&gt;&gt; %timeit str_to_int_ead(v)
&gt;&gt;&gt; 139 ns ± 0.628 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)


&gt;&gt;&gt; v=testbytes[0]
&gt;&gt;&gt; %timeit bytes_to_int_ead(v)
97.2 ns ± 1.03 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>Now there is actually about 40% speed-up now!</p>
<p>Another interesting conclusion: There are also about 250ns (or 70%) overhead when tested with iterators. Without this overhead, cython beats @MartijnPieters's 140ns vs 550ns, i.e. by almost by factor 4.</p>
<hr/>
<p>Listing function the cython have been compared to (current state of @MartijnPieters's  answer):</p>
<pre><code>def seq_to_int(seq, _m=str.maketrans('ACGT', '0123')):
    return int(seq.translate(_m), 4)
</code></pre>
<p>test data:</p>
<pre><code>from random import choice
testvalues = [''.join([choice('ATCG') for _ in range(28)]) for _ in range(10 ** 6)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>seq = 'TGTGAGAAGCACCATAAAAGGCGTTGTG'

mapping = {'A': b'00', 'C': b'01', 'G': b'10', 'T': b'11'}

result = b''.join(map(mapping.__getitem__, seq)).zfill(64)

print(result)
</code></pre>
<p>Here is some timing code to compare options:</p>
<pre><code>import timeit

setup = """
seq = 'TGTGAGAAGCACCATAAAAGGCGTTGTG'

mapping = {'A': b'00', 'C': b'01', 'G': b'10', 'T': b'11'}
"""

for stmt in [
    "b''.join(map(mapping.__getitem__, seq)).zfill(64)",
    "b''.join([mapping[c] for c in seq]).zfill(64)",
]:
    print(stmt)
    print(timeit.timeit(stmt, setup, number=10000000))
</code></pre>
<p>I find that the two options are roughly the same, but your results may vary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the bit shift operator and addition. You've got the right idea with using a dictionary to hold character codes:</p>
<p><code>mapping = {'A': 0b00, 'C': 0b01, 'G': 0b10, 'T': 0b11}</code></p>
<p>Produce a 28 character string (kind of redundant to call it this, string will do) for this example:</p>
<p><code>chars = 'TGTGAGAAGCACCATAAAAGGCGTTGTG'</code></p>
<p>Define a result and set it to zero:</p>
<p><code>result = 0</code></p>
<p>Strings in Python are actually just an array of characters, and you can iterate through the string as you would any array. We'll use this, along with a nested series of bit operations to do what you require:</p>
<pre><code>for char in chars:
  result = result &lt;&lt; 2
  result = result | mapping[char]
</code></pre>
<p>This will produce bits of length <code>2*len(chars)</code> which in this case is 56. To get the extra </p>
<p>To add an extra 8 bits of leading zeros, the integer representation of this is actually a QWORD (64 bits) and will automatically fill the 8 Most Significant Bits with zeros.</p>
<pre><code>print(result)
&gt;&gt; 67026852874722286
</code></pre>
<p>If you wanted to get really fancy, you could use <code>ctypes</code> to speed up your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to think about this problem is to realize that the essence of what it's doing is a conversion from a base 4 number to a base 10. This can be done a number of ways, but one I like is the actually very generic accepted answer to the question <a href="https://stackoverflow.com/questions/1119722/base-62-conversion">Base 62 conversion</a>.</p>
<p>Below is a modified version of it the does a base 4 conversion by default:</p>
<pre><code>def base_decode(astring, alphabet="ACGT"):
    """Decode a Base X encoded astring into the number

    Arguments:
    - `astring`: The encoded astring
    - `alphabet`: The alphabet to use for encoding
    """
    base = len(alphabet)
    strlen = len(astring)
    num = 0
    for idx, char in enumerate(astring):
        power = (strlen - (idx + 1))
        num += alphabet.index(char) * (base ** power)

    return num

seq = 'TGTGAGAAGCACCATAAAAGGCGTTGTG'
print('seq_to_binary:', seq_to_binary(seq))
print('base_decode:', format(base_decode(seq), 'b'))
</code></pre>
<p>Note that this actually returns an integer of whatever bit length is needed (integers are variable length in Python) to store the number given as a character string packed in to binary integer value. The added call to <code>format()</code> turns that value into a binary string so it can be printed and compared to the result of calling your <code>seq_to_binary()</code> function which returns a string, <strong>not</strong> a 64-bit integer mentioned in the title.</p>
</div>
<span class="comment-copy">Base-4 conversion can be done much, much faster though; <code>int()</code> can do this is C for us, all that is needed is a string translation from letters to digits.</span>
<span class="comment-copy">@Martijn: Realizing and pointing out that this was simply a base-4 conversion problem was the primary point of my answer, not the particular implementation of it presented—which I picked because it was handy, easy to understand, and easily adapted to do base-4 conversions. Mapping the characters of the string to "normal" digits and using the <code>int()</code> built-in is very clever and a faster implementation. Congratulations.</span>
