<div class="post-text" itemprop="text">
<p>I have code that works but I'm wondering if there is a more pythonic way to do this.  I have a dictionary and I want to see if:</p>
<ul>
<li>a key exists</li>
<li>that value isn't None (NULL from SQL in this case)</li>
<li>that value isn't simply quote quote (blank?)</li>
<li>that value doesn't solely consist of spaces</li>
</ul>
<p>So in my code the keys of "a", "b", and "c" would succeed, which is correct.</p>
<pre><code>import re

mydict = {
"a":"alpha",
"b":0,
"c":False,
"d":None,
"e":"",
"g":"   ",
}

#a,b,c should succeed
for k in mydict.keys():
    if k in mydict and mydict[k] is not None and not re.search("^\s*$", str(mydict[k])):
        print(k)
    else:
        print("I am incomplete and sad")
</code></pre>
<p>What I have above works, but that seems like an awfully long set of conditions.  Maybe this simply is the right solution but I'm wondering if there is a more pythonic "exists and has stuff" or better way to do this?</p>
<p><strong>UPDATE</strong>
Thank you all for wonderful answers and thoughtful comments.  With some of the points and tips, I've updated the question a little bit as there some conditions I didn't have which should also succeed.  I have also changed the example to a loop (just easier to test right?).</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to fetch the value and store it in a variable, then use object "truthyness" to go further on with the value</p>
<pre><code>v = mydict.get("a")
if v and v.strip():
</code></pre>
<ul>
<li>if <code>"a"</code> is not in the dict, <code>get</code> returns <code>None</code> and fails the first condition</li>
<li>if <code>"a"</code> is in the dict but yields <code>None</code> or empty string, test fails, if <code>"a"</code> yields a blank string, <code>strip()</code> returns falsy string and it fails too.</li>
</ul>
<p>let's test this:</p>
<pre><code>for k in "abcde":
    v = mydict.get(k)
    if v and v.strip():
        print(k,"I am here and have stuff")
    else:
        print(k,"I am incomplete and sad")
</code></pre>
<p>results:</p>
<pre><code>a I am here and have stuff
b I am incomplete and sad    # key isn't in dict
c I am incomplete and sad    # c is None
d I am incomplete and sad    # d is empty string
e I am incomplete and sad    # e is only blanks
</code></pre>
<p>if your values can contain <code>False</code>, <code>0</code> or other "falsy" non-strings, you'll have to test for string, in that case replace:</p>
<pre><code>if v and v.strip():
</code></pre>
<p>by</p>
<pre><code>if v is not None and (not isinstance(v,str) or v.strip()):
</code></pre>
<p>so condition matches if not <code>None</code> and either not a string (everything matches) or if a string, the string isn't blank.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension with <code>str.strip</code> to account for whitespace in strings.</p>
<p>Using <code>if v</code> is natural in Python to cover False-like objects, e.g. <code>None</code>, <code>False</code>, 0, etc. So note this only works <em>if 0 is not an acceptable value</em>.</p>
<pre><code>res = [k for k, v in mydict.items() if (v.strip() if isinstance(v, str) else v)]

['a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">get</a> method for checking if a key exists is more efficient that iterating through the keys. It checks to see if the key exists without iteration using an <code>O(1)</code> complexity as apposed to <code>O(n)</code>. My preferred method would look something like this:</p>
<pre><code>if mydict.get("a") is not None and str(mydict.get("a")).replace(" ", "") != '':
    # Do some work
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I have 2 suggestions to offer you, especially if your main issue is the length of the conditions.</p>
<p>The first one is for the check if the key is in the dict. You don't need to use <code>"a" in mydict.keys()</code> you can just use <code>"a" in mydict</code>.</p>
<p>The second suggestion to make the condition smaller is to break down into smaller conditions stored as booleans, and check these in your final condition:</p>
<pre><code>import re

mydict = {
"a":"alpha",
"c":None,
"d":"",
"e":"   ",
}

inKeys = True if "a" in mydict else False
isNotNone = True if mydict["a"] is not None else False
isValidKey = True if not re.search("^\s*$", mydict["a"]) else False

if inKeys and isNotNone and isValidKey:
    print("I am here and have stuff")
else:
    print("I am incomplete and sad")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>it check exactly for <code>NoneType</code> not only <code>None</code></p>
<pre><code>from types import NoneType # dont forget to import this

mydict = {
"a":"alpha",
"b":0,
"c":False,
"d":None,
"e":"",
"g":"   ",
}

#a,b,c should succeed
for k in mydict:
    if type(mydict[k]) != NoneType:
        if type(mydict[k]) != str or type(mydict[k]) == str and mydict[k].strip():
            print(k)
        else:
            print("I am incomplete and sad")
    else:
        print("I am incomplete and sad")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>cond</code> is a generator function responsible for generating conditions to apply in a short-circuiting manner using the <code>all</code> function. Given <code>d = cond()</code>, <code>next(d)</code> will check if a exists in the dict, and so on until there is no condition to apply, in that case <code>all(d)</code> will evaluate to <code>True</code>.</p>
<pre><code>mydict = {
  "a":"alpha",
  "c":None,
  "d":"",
  "e":"   ",
}

def cond ():
  yield 'a' in mydict
  yield mydict ['a']
  yield mydict ['a'].strip ()

if all (cond ()):
    print("I am here and have stuff")
else:
    print("I am incomplete and sad")
</code></pre>
</div>
<span class="comment-copy">How about <code>if mydict.get("a", "").strip():</code>?  <code>None</code> and <code>""</code> are both falsey.</span>
<span class="comment-copy">@0x5453 That fails if <code>mydict['a'] is None</code>, as <code>None</code> doesn't have a <code>strip</code> method.</span>
<span class="comment-copy">@BradSolomon just one, no need to do a loop</span>
<span class="comment-copy">Just a small note - you can just do <code>"a" in mydict</code> without having to call <code>mydict.keys()</code></span>
<span class="comment-copy">Note that this is a use case covered by <a href="https://www.python.org/dev/peps/pep-0505/" rel="nofollow noreferrer">PEP-505</a>, although it is currently deferred, so it is not of immediate use.</span>
<span class="comment-copy">I tried with the <code>if isinstance(v,str) and v.strip():</code> but it doesn't seems to catch the new 'b' and 'c' as having stuff.</span>
<span class="comment-copy">you updated your question in the meanwhile.</span>
<span class="comment-copy">ah yes, sorry about that.</span>
<span class="comment-copy">no sweat. Added the last test that should do what you want.</span>
<span class="comment-copy">Good call on the 0.  I can't guarantee that the value won't be 0</span>
<span class="comment-copy">You could add an additional clause: <code>res = [k for k, v in mydict.items() if (v == 0) or (v.strip() if isinstance(v, str) else v)]</code>. But now you're getting to the stage where an explicit function is better than a one-liner.</span>
<span class="comment-copy">I like that "a" in mydict, that's a good tip.</span>
<span class="comment-copy">this works ok from a functional programming perspective but is arguably not very pythonic and wouldn't handle the case where mydict['a'] is None</span>
<span class="comment-copy">@avigil definitely, it would not handle even the case of <code>'a' not in mydict</code>.</span>
<span class="comment-copy">Please add some explanation to your code.</span>
