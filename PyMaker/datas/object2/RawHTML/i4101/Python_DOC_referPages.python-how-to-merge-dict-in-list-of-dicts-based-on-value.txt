<div class="post-text" itemprop="text">
<p>I have a list of dicts, where each dict consists of 3 keys: name, url, and location.<br/>
Only value of 'name' can be the same throughout the dicts, and both 'url' and 'location' are always different value throughout the list.</p>
<p><strong>Example:</strong></p>
<pre><code>[
{"name":"A1", "url":"B1", "location":"C1"}, 
{"name":"A1", "url":"B2", "location":"C2"}, 
{"name":"A2", "url":"B3", "location":"C3"},
{"name":"A2", "url":"B4", "location":"C4"}, ...
]  
</code></pre>
<p>Then I want to make them grouping based on the value in 'name' as follows.</p>
<p><strong>Expected:</strong></p>
<pre><code>[
{"name":"A1", "url":"B1, B2", "location":"C1, C2"},
{"name":"A2", "url":"B3, B4", "location":"C3, C4"},
]
</code></pre>
<p>(actual list consists of &gt;2,000 dicts)</p>
<p>I'd be very glad to get solved this situation.<br/>
Any advice / answers will be greatly appreciated.</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>where <code>res</code> is:</p>
<pre><code>[{'location': 'C1', 'name': 'A1', 'url': 'B1'},
 {'location': 'C2', 'name': 'A1', 'url': 'B2'},
 {'location': 'C3', 'name': 'A2', 'url': 'B3'},
 {'location': 'C4', 'name': 'A2', 'url': 'B4'}]
</code></pre>
<p>You can work with the data using a <code>defaultdict</code> and unpacking the result into a list comprehension:</p>
<pre><code>from collections import defaultdict

result = defaultdict(lambda: defaultdict(list))

for items in res:
     result[items['name']]['location'].append(items['location'])
     result[items['name']]['url'].append(items['url'])

final = [
    {'name': name, **{inner_names: ' '.join(inner_values) for inner_names, inner_values in values.items()}}
    for name, values in result.items()
]
</code></pre>
<p>And <code>final</code> is:</p>
<pre><code>In [57]: final
Out[57]:
[{'location': 'C1 C2', 'name': 'A1', 'url': 'B1 B2'},
 {'location': 'C3 C4', 'name': 'A2', 'url': 'B3 B4'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your dataset is relatively small then I guess Time complexity is not a big deal here so you could consider following code.</p>
<pre><code>from collections import defaultdict
given_data = [
    {"name":"A1", "url":"B1", "location":"C1"}, 
    {"name":"A1", "url":"B2", "location":"C2"}, 
    {"name":"A2", "url":"B3", "location":"C3"},
    {"name":"A2", "url":"B4", "location":"C4"},
] 
D = defaultdict(list)
for item in given_data:
    D[item['name']].append(item)
result = []
for x in D:
    urls = ""
    locations = ""
    for pp in D[x]:
        urls += pp['url']+" "
        locations += pp['location']+" "
    result.append({'name': x, 'url': urls.strip(), 'location': locations.strip()})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With auxiliary grouping dict (for Python &gt; 3.5):</p>
<pre><code>data = [
    {"name":"A1", "url":"B1", "location":"C1"}, 
    {"name":"A1", "url":"B2", "location":"C2"}, 
    {"name":"A2", "url":"B3", "location":"C3"},
    {"name":"A2", "url":"B4", "location":"C4"}
]

groups = {}
for d in data:
    if d['name'] not in groups:
        groups[d['name']] = {'url': d['url'], 'location': d['location']}
    else:
        groups[d['name']]['url'] += ', ' + d['url']
        groups[d['name']]['location'] += ', ' + d['location']
result = [{**{'name': k}, **v} for k, v in groups.items()]

print(result)
</code></pre>
<p>The output:</p>
<pre><code>[{'name': 'A1', 'url': 'B1, B2', 'location': 'C1, C2'}, {'name': 'A2', 'url': 'B3, B4', 'location': 'C3, C4'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using @Yaroslav Surzhikov comment, here is a solution using itertools.groupby</p>
<pre><code>from itertools import groupby

dicts = [
    {"name":"A1", "url":"B1", "location":"C1"},
    {"name":"A1", "url":"B2", "location":"C2"},
    {"name":"A2", "url":"B3", "location":"C3"},
    {"name":"A2", "url":"B4", "location":"C4"},
]

def merge(dicts):
    new_list = []
    for key, group in groupby(dicts, lambda x: x['name']):
        new_item = {}
        new_item['name'] = key
        new_item['url'] = []
        new_item['location'] = []
        for item in group:
            new_item['url'].extend([item.get('url', '')])
            new_item['location'].extend([item.get('location', '')])
        new_item['url'] = ', '.join(new_item.get('url', ''))
        new_item['location'] = ', '.join(new_item.get('location', ''))
        new_list.append(new_item)
    return new_list

print(merge(dicts))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like this? Small deviation: I preferred to store <strong>urls</strong> and <strong>locations</strong> in a <em>list</em> inside <strong><em>resDict</em></strong>, not in appended <em>str</em>.</p>
<pre><code>myDict = [
{"name":"A1", "url":"B1", "location":"C1"}, 
{"name":"A1", "url":"B2", "location":"C2"}, 
{"name":"A2", "url":"B3", "location":"C3"},
{"name":"A2", "url":"B4", "location":"C4"}
]

resDict = []

def getKeys(d):
    arr = []
    for row in d:
        arr.append(row["name"])
    ret = list(set(arr))
    return ret

def filteredDict(d, k):
    arr = []
    for row in d:
        if row["name"] == k:
            arr.append(row)
    return arr

def compressedDictRow(rowArr):
    urls = []
    locations = []
    name = rowArr[0]['name']

    for row in rowArr:
       urls.append(row['url'])
       locations.append(row['location'])
    return {"name":name,"urls":urls, "locations":locations}

keys = getKeys(myDict)

for key in keys:
    rowArr = filteredDict(myDict,key)
    row = compressedDictRow(rowArr)
    resDict.append(row)
print(resDict)
</code></pre>
<p>Outputs (in one line):</p>
<pre><code>[
    {'name': 'A2', 'urls': ['B3', 'B4'], 'locations': ['C3', 'C4']}, 
    {'name': 'A1', 'urls': ['B1', 'B2'], 'locations': ['C1', 'C2']}
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a variant (<strong>it's hard to even read it</strong>, feels like scratching the right side of my head using my left hand, but at this point, I don't know how to make it shorter) that uses:</p>
<ul>
<li><a href="https://docs.python.org/3/library/itertools.html#module-itertools" rel="nofollow noreferrer">[Python]: itertools - Functions creating iterators for efficient looping</a>
<ul>
<li><code>groupby</code></li>
<li><code>accumulate</code></li>
</ul></li>
<li>Comprehensions (<code>list</code> and <code>dict</code>)</li>
</ul>
<blockquote>
<pre><code>&gt;&gt;&gt; pprint.pprint(initial_list)
[{'location': 'C1', 'name': 'A1', 'url': 'B1'},
 {'location': 'C2', 'name': 'A1', 'url': 'B2'},
 {'location': 'C3', 'name': 'A2', 'url': 'B3'},
 {'location': 'C4', 'name': 'A2', 'url': 'B4'}]
&gt;&gt;&gt;
&gt;&gt;&gt; NAME_KEY = "name"
&gt;&gt;&gt;
&gt;&gt;&gt; final_list = [list(itertools.accumulate(group_list, func=lambda x, y: {key: x[key] if key == NAME_KEY else " ".join([x[key], y[key]]) for key in x}))[-1] \
...     for group_list in [list(group[1]) for group in itertools.groupby(sorted(initial_list, key=lambda x: x[NAME_KEY]), key=lambda x: x[NAME_KEY])]]
&gt;&gt;&gt;
&gt;&gt;&gt; pprint.pprint(final_list)
[{'location': 'C1 C2', 'name': 'A1', 'url': 'B1 B2'},
 {'location': 'C3 C4', 'name': 'A2', 'url': 'B3 B4'}]
</code></pre>
</blockquote>
<p><strong>Rationale</strong> (from <em>outer</em> to <em>inner</em>):</p>
<ul>
<li>Group the dictionaries in the initial list based on their value corresponding to the <em>name</em> key (<code>itertools.groupby</code>)

<ul>
<li>An auxiliary operation for this to work properly is to sort the list on the same value prior to grouping (<code>sorted</code>)</li>
</ul></li>
<li>For each such group of dictionaries, perform their "<em>sum</em>" (<code>itertools.accumulate</code>)

<ul>
<li><code>func</code> argument "<em>sum</em>s" 2 dictionaries, based on the keys:

<ul>
<li>If the key is <em>name</em>, just take the value from the 1<sup>st</sup> dictionary (it's the same for both dictionaries, anyway)</li>
<li>Otherwise just add the 2 values (strings) with a space in between</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Considerations</strong>:</p>
<ul>
<li>The dictionaries have to stay <em>homogeneous</em> (all must have the same structure (keys))</li>
<li>Only the <em>name</em> key is hardcoded (but, if you decide to add other keys which are not strings, you'll have to adjust <code>func</code> too)</li>
<li>It could be split for readability</li>
<li>Not sure about the <code>lambda</code>s (performance wise)</li>
</ul>
</div>
<span class="comment-copy">this could help <a href="https://stackoverflow.com/questions/50051890/combine-or-merge-dictionaries-based-on-more-than-one-key-or-multi-keys" title="combine or merge dictionaries based on more than one key or multi keys">stackoverflow.com/questions/50051890/â€¦</a></span>
<span class="comment-copy">itertools.groupby - that's all</span>
