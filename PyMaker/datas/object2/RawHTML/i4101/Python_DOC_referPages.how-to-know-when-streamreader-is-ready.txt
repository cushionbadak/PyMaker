<div class="post-text" itemprop="text">
<p>I'm using <code>asyncio</code> to make TCP connections:</p>
<pre><code>reader, writer = await asyncio.open_connection(addr)
</code></pre>
<p>I need to keep connections alive. For this, I'm storing a pair of <code>(reader, writer)</code> for future communications. However, I don't know when <code>reader</code> has data to read. What can I do with it? Is there a way to make a handler, when the reader is ready?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>However, I don't know when <code>reader</code> has data to read. What can I do with it?</p>
</blockquote>
<p>The obvious way to know when a reader stream has data to read is to <code>await</code> it:</p>
<pre><code>data = await reader.read(1024)
</code></pre>
<p>This will either return the data right away, or <em>suspend</em> the current coroutine, allowing other coroutines to make progress, and only resuming this one when the reader has some data to read. Instead of storing the reader/writer for future communication, you can write a coroutine that <em>does</em> the communication, and store the <a href="https://docs.python.org/3/library/asyncio-task.html#task" rel="nofollow noreferrer">task</a> that drives it:</p>
<pre><code>async def communicate():
    reader, writer = await asyncio.open_connection(addr)
    # an echo server
    while True:
        line = await reader.readline()
        if not line:
            break
        writer.write(line)
        await writer.drain()  # backpressure, see https://tinyurl.com./hqylfay

task = loop.create_task(communicate())
# the task can itself be awaited, canceled, etc.
</code></pre>
<p>The idea behind the asyncio <a href="https://docs.python.org/3/library/asyncio-stream.html" rel="nofollow noreferrer">stream API</a> is to write such sequential-looking code, leaving it to asyncio to handle polling of file descriptors and scheduling of tasks. You can use combinators like <a href="https://docs.python.org/3/library/asyncio-task.html?highlight=gather#asyncio.gather" rel="nofollow noreferrer"><code>asyncio.gather</code></a> and <a href="https://docs.python.org/3/library/asyncio-task.html?highlight=gather#asyncio.wait" rel="nofollow noreferrer"><code>asyncio.wait</code></a> to run thousands of such lightweight coroutines in parallel.</p>
<blockquote>
<p>Is there a way to make a handler, when the reader is ready?</p>
</blockquote>
<p>If you need a callback-based API, you should probably use the lower-level <a href="https://docs.python.org/3/library/asyncio-protocol.html" rel="nofollow noreferrer">transports and protocols</a> instead. However, if you are already working with streams, but still occasionally need an ordinary callback, you can get it by obtaining a <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future" rel="nofollow noreferrer"><code>Future</code></a>:</p>
<pre><code>future = asyncio.ensure_future(reader.read(1024))
future.add_done_callback(your_callback)
</code></pre>
<p>Future has the role equivalent to a coroutine handler. Once <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.read" rel="nofollow noreferrer"><code>read</code></a> would no longer block, the done-callback will be invoked by the event loop with a single argument, the future. The future will have finished, and its <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future.result" rel="nofollow noreferrer"><code>result()</code></a> method can be used to retrieve the received data or an exception.</p>
<p>(The above applies to any coroutine or future-compatible object in asyncio, not just to <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader" rel="nofollow noreferrer"><code>StreamReader</code></a> methods.)</p>
</div>
