<div class="post-text" itemprop="text">
<p>Consider this simple folder structure: </p>
<pre><code>root
  Package1
    x.py
    y.py
  Package2
    z.py
  Examples
    main.py
</code></pre>
<p>Now our requirements are:</p>
<ul>
<li>x.py needs to import y.py </li>
<li>z.py needs to import y.py </li>
<li>main.py needs to import y.py and z.py</li>
</ul>
<p>Below is what works:</p>
<p><strong>x.py</strong></p>
<pre><code>import y

def x():
  y()
</code></pre>
<p><strong>y.py</strong></p>
<pre><code>def y():
  pass
</code></pre>
<p><strong>z.py</strong></p>
<pre><code>import package1.y as y

def z():
  y.y()
</code></pre>
<p><strong>main.py</strong></p>
<pre><code>import sys
from os import path
sys.path.append(  path.dirname(  path.dirname( path.abspath(__file__) ) ) )

import package1.y as y
import package2.z as z

y.y()
z.z()
</code></pre>
<p><strong>Questions:</strong></p>
<ol>
<li>Is this the best and recommended way to setup imports in Python 3?</li>
<li>I really don't like changing <code>sys.path</code> in <code>main</code> because it strongly binds assumptions about package locations <em>inside</em> code file. Is there any way around that?</li>
<li>I also really don't like superfluous <code>as y</code> part in <code>import package1.y as y</code>. Is there any way around that?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>As always, there are two separate steps:</p>
<ol>
<li>You write the code against the <em>abstract</em> namespace of packages, which contains <code>package1</code> and <code>package2</code> (and <code>sys</code>, <code>os</code>, <em>etc.</em>), but not “Examples” which is not a package (because <code>main.py</code> is not a module).</li>
<li>You set <code>sys.path</code> appropriately <em>before</em> any of your code ever runs.  If it's your own (uninstalled) code, there are <a href="https://stackoverflow.com/q/16196268/8586227">places you can put it</a>, or you can write an easy shell script wrapper to set <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" rel="nofollow noreferrer"><code>PYTHONPATH</code></a> for your <code>python</code> process.</li>
</ol>
<p>So the answers to your questions are</p>
<ol>
<li>In <code>x.py</code> you write <code>from . import y</code>.  (Python 2 supports this and 3 requires it.)</li>
<li>How you set <code>sys.path</code> depends on your packaging/environment system.  The traditional way is to set the <code>PYTHONPATH</code> environment variable for the <code>python</code> process, but there are other ways involving things like the <code>site</code> module.</li>
<li><code>from package1 import y</code> is the usual way to name things only once.</li>
</ol>
</div>
<span class="comment-copy">Just to make sure I understand, <code>root</code> is not a package. You have two independent packages called <code>Package1</code> and <code>Package2</code>. The <code>sys.path</code> option is bad because it means I can't clone different copies of this package for development. I think the best option is to create <code>setup.py</code> files for each package and make them installable. Now someone could install, install into a virtualenv, or set their own path outside of any tests to where ever they happen to be using them. Make it easy for end users who just want to install.</span>
<span class="comment-copy">...but also easy for developers with a little extra knowledge to use them.</span>
<span class="comment-copy"><code>x.py</code> could do <code>import .y</code> but <code>z.py</code> is in an entirely separate package. it needs the full <code>Package1.y</code>.</span>
<span class="comment-copy">Yes, root is not package. Question is how source code should look on disk during the development?</span>
<span class="comment-copy">Good question! Its common for each to have their own source repository  and not have any hardcoded relationship to each other. Users would <code>pip install</code> them and developers would either either <code>pip install --editable</code> or <code>pip install --develop</code> them. Even if they are in the same repository of other reasons, they are still separate python entities. (This is all my humble opinion of course)</span>
<span class="comment-copy">NB for step 2: "install your package" is a valid way of setting up <code>sys.path</code> :)</span>
<span class="comment-copy">@Josh: Sure, if your environment supports “installation”; lots of people use virtual environments and so forth, but some of us have to put packages in non-default locations and use external configuration like <a href="https://en.m.wikipedia.org/wiki/Environment_Modules_(software)" rel="nofollow noreferrer">Environment Modules</a>.  It’s useful to understand the basic mechanisms in any event.</span>
<span class="comment-copy">There shouldn't be any need to install package (user can if they wish, but best practice should not require it). This is especially important if you are in development mode and may be you just want you package to be copied in private folder with your own version without effecting system level package.</span>
<span class="comment-copy">In x.y, why should one write <code>from . import y</code> instead of just <code>import y</code>. Former is verbose and is not actually required by Python 3.</span>
<span class="comment-copy">@ShitalShah: If <code>x</code> and <code>y</code> are in a package, it’s certainly required.  If you have the directory <code>Package1</code> (rather than its parent) on <code>sys.path</code>, then there is no package, but that’s not what you seem to want.</span>
