<div class="post-text" itemprop="text">
<pre><code>from binascii import unhexlify
import time
import struct

var = 'FF'
bytes = unhexlify(var)

start_time = time.time()
for i in range(10000):
  temp = struct.unpack('B', bytes)[0]
print("- %s milli sec -" % ((time.time() - start_time)*1000))


start_time = time.time()
for i in range(10000):
  temp = int.from_bytes(bytes, byteorder='big')
print("- %s milli sec -" % ((time.time() - start_time)*1000))


start_time = time.time()
for i in range(10000):
  temp = bytes[0]
print("- %s milli sec -" % ((time.time() - start_time)*1000))
</code></pre>
<p><strong>output</strong></p>
<pre><code>- 5.327939987182617 milli sec -
- 12.086629867553711 milli sec -
- 1.882314682006836 milli sec -
</code></pre>
<p>Obviously, the 3rd one is a lot faster than others.</p>
<p>Is there any technical reasoning for this. Also, can someone tell me the pros and cons of these approaches? If there is any other better way to achieve this, please explain it as an answer.</p>
<p>program available here: <a href="https://repl.it/repls/AcceptableCompatiblePrograms" rel="nofollow noreferrer">https://repl.it/repls/AcceptableCompatiblePrograms</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The first problem is that you're not benchmarking properly (you should be using <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a>, because it takes care of all the things you didn't think of), and, even more importantly, you're benchmarking the wrong thing.</p>
<p>Using <code>%timeit</code> in IPython on my laptop, here are the times for the three parts of your process:</p>
<ul>
<li><code>b = unhexlify(var)</code>: 209ns</li>
<li><code>b[0]</code>: 16.0ns</li>
<li><code>temp = b0</code>: 50.2ns</li>
</ul>
<p>So, you're focusing on the fastest part of the process.</p>
<p>Meanwhile, once you've decided to use <code>unhexlify</code> to get a <code>bytes</code> object, of course the fastest way to get the first byte out of that is <code>b[0]</code>. How could anything possibly be any faster than that?</p>
<p>But if you take a step back:</p>
<ul>
<li><code>int(var, 16)</code>: 233ns</li>
</ul>
<p>This is nearly as fast as <code>unhexlify(var)[0]</code>—within 4%, and a difference in the single-digit nanos. Which may not even be consistently repeatable across systems, Python versions, or input values. But, even if it were, it's hard to imagine an application where this 8ns makes a difference where you couldn't get a much bigger speedup by stepping back and doing something at a higher level. Sure, it's not <em>impossible</em> this could come up, by immediately jumping to how to micro-optimize this operation is almost always going to be a mistake.</p>
<p>Even more importantly, <code>unhexlify(var)[0]</code> only works for single-byte values. Try it with, say, <code>FF22</code> and you're going to get 255 instead of 65314. The other options—including <code>int</code>—will give you the right answer.</p>
<p>And of course using <code>struct</code> and <code>int.from_bytes</code> give you more flexibility—you can read bytes in either endianness, or specify the exact size you expect (or read exactly that many bytes out of an input buffer without consuming the whole buffer).</p>
<p>So, the right answer is to use the one that does what you actually want in the most obvious way. Something that's faster but wrong is not helpful, and even something that's faster but not obviously right often isn't helpful.</p>
<p>And this means that if what you're actually trying to do is (contrary to what you implied in your question) iterate or index a <code>bytes</code> as integers from 0 to 255, the right thing to do is <code>for by in b:</code> or <code>b[0]</code>. Not because it's fastest (although it is), but because it directly does exactly what you want to do—it's the One Obvious Way To Do It.</p>
</div>
<span class="comment-copy">Why <i>woudn't</i> the last one be fastest? There's no attribute lookup or call overhead, it's just indexing the array.</span>
<span class="comment-copy">You really shouldn't be using <code>time.time</code> to benchmark things; that's what <code>timeit</code> is for.</span>
<span class="comment-copy">You also shouldn't be doing this if you're trying to convert anything larger than FF to integer. For example, how would you convert 'CAFEBABE'? You should instead use <code>int(var, 16)</code> if you're dealing with hex numbers.</span>
<span class="comment-copy">Anyway, notice that the <code>unhexlify</code> part takes more time than accessing the bytes—e.g., on my laptop, it's 209ns to <code>unhexlify</code> a single byte, and then only 16ns to access the first element of it. So you may be focusing on the wrong thing in the first place. (Also, is a 16ns operation something you need to worry about optimizing here? If you're doing it billions of times, you may want to step back and find a higher-level way of doing whatever you're actually doing.)</span>
<span class="comment-copy">By comparison, <code>int(var, 16)</code> takes 233ns, which is only 8ns more than <code>unhexlify(var)[0]</code>. Even if that 4% performance cost in the single-digit-nanos range is consistent, is that worth the added brittleness?</span>
<span class="comment-copy">I am reading a byte stream. So int(var, 16) is not useful in my case. because var should be hex string</span>
<span class="comment-copy">@LokeshCherukuri <code>int(var, 16)</code> works on a hex string. Have you tried it?</span>
<span class="comment-copy">yes, it works on hex string. but i am dealing with bytes</span>
<span class="comment-copy">If you already have bytes, and you want to interpret them as bytes, then you don't want, or need, to do anything. Anything you add will just slow things down and make things more confusing, so why d it? If, on the other hand, you want to interpret them as X-byte big-endian integers, then you want to use <code>int.from_bytes</code>. Or, if you want to interpret them as C structs full of shorts and long, use <code>struct.unpack_from</code>. And so on. The point is the same: write the thing that does what you actually want in the most obvious way.</span>
