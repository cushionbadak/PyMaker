<div class="post-text" itemprop="text">
<p>I have read about cutting stock problem, but this is a bit different. Please can you direct me to some resources. There is bin packing,cutting stock ... </p>
<p>We have orders in different variants, and a maximum sized machine to produce it.</p>
<p>Variants would be, X,S,XL,L and ordered quantities, 100,40,40,80</p>
<p>X &gt; 100</p>
<p>S &gt; 40</p>
<p>XL &gt; 40</p>
<p>L &gt; 80</p>
<p>Say, machine width is 6</p>
<p>This means, we can put 6 different variants together and produce it.</p>
<p>We can put 2 X,1 S,1 XL,2 L , this means if we produce it 50 times , output is :</p>
<p>X &gt; 100 (0 waste)</p>
<p>S &gt; 50 (10 waste)</p>
<p>XL &gt; 50 (10 waste)</p>
<p>L &gt; 100 (20 waste)</p>
<p>Total of 40 waste in 300 produced.</p>
<hr/>
<p>Another aproach to reduce waste would be creating 2 different variation.
We can put 4 X,2 S and produce it 25 times, with 10 waste
and make another setup and put 2 XL,4 L and produce it 20 times with no waste.
With total 10 waste we handled this production in 2 setups.</p>
<p>Since setup has a price, we would prefer first setup, or depending on quantities, we may choose the second one.</p>
<p>I have read about cutting stock and it looks similar to this one, <strong>but ability to divide quantities between different setups</strong>, this has more potential to optimize and therefore more complex.</p>
<p>I have thought about it, and couldn't come with a reliable solution, If this problem has any place in literature, could you at least tell me the keywords so I can search for it?</p>
<p>thanks.</p>
<p>Note : I know basic mathematics and good python programming language.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest solving this with an A* search for the fastest and lowest cost way to get to 0 left to do.</p>
<p>The possibly new to you data structure is a priority queue, which you can get with <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">https://docs.python.org/3/library/heapq.html</a>, a dictionary of visited nodes, and just a little bit of logic.  The trick is that you put possible partial solutions in at will, and they will come out in order of lowest cost, and then farthest done.</p>
<p>Here is untested code for the main piece of logic.</p>
<pre><code># There should be 84
configs = generate_list_of_machine_configurations(variants)
# Our priority queue
upcoming = [(0, sum(quantities), quantities, None]
seen = set()
while (len(upcoming)):
    (waste, _, quantities, path) = heapq.heappop(upcoming)
    if tuple(quantities) not in seen:
        if all_zeros(quantities):
            return path # ANSWER IS FOUND HERE

        seen.add(tuple(quantities))
        for config in configs:
            for count in range(max(quantities)):
               (new_quantities, wasted) = apply(quantities, config, count)
               new_path = [(config, count), path]
               if all_zeros(new_quantities):
                   heapq.heappush(upcoming, (
                       waste + wasted, 0, new_quantities, new_path))
               else:
                   heapq.heappush(upcoming, (
                       waste + wasted + cost_of_config_switch,
                       sum(new_quantities), new_quantities, new_path))
</code></pre>
</div>
<span class="comment-copy">Interesting, but it sounds tricky. And too broad in its current state for SO, where our focus is more on specific coding problems. You may be able to get help for this on the <a href="https://softwareengineering.stackexchange.com/">Software Engineering</a> site, but please read their Help before posting a question there.</span>
<span class="comment-copy">It doesn't seem to be too broad to me.  All you need to do is specify how many waste is stopping and reconfiguring the machine, and it is exactly specified.  What configuration or set of configurations minimizes the waste?</span>
<span class="comment-copy">Actual best in this case is X, S, XL, L, L produce 40 times, then X, X, X, X, X, X produce 10 times.  Zero waste!</span>
<span class="comment-copy">What are you trying to minize? waste or cost? Because If you do first all X, then all S, then all XL, then all L you have 4 setups with 30 waste max between all</span>
<span class="comment-copy">@juvian Cost.  Waste has cost, and so does reconfiguring.</span>
<span class="comment-copy">Thanks for the suggestion, heap queue will be my interest, but this can be a tool to solve the question. My problem is that there are seemingly endless possibilities and I need a way to decrease it and find a solution.</span>
<span class="comment-copy">@durdenk The problem is np-complete.  The approach that I gave is pseudopolynomial time.  In practice it is likely fairly efficient.</span>
