<div class="post-text" itemprop="text">
<p>Is it possible to put a return statement in a list comprehension? </p>
<pre><code>[foo.remove(i) for i in bar]
return ''.join(foo) 
</code></pre>
<p>My guess is no since the code after the return statement isn't executed. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/simple_stmts.html#grammar-token-return_stmt" rel="nofollow noreferrer"><code>return</code></a> is a statement.</p>
<p><a href="https://docs.python.org/3/reference/expressions.html#grammar-token-comprehension" rel="nofollow noreferrer">List comprehensions</a> cannot contain statements, only expressions.</p>
<p>In fact, that's true for <em>all</em> expressions in Python: they can only contain other expressions.</p>
<p>So, no, you can't put a <code>return</code> inside a list comprehension.</p>
<p>If you really need to mutate <code>foo</code> in-place, what you're trying to do is much better written as a <code>for</code> statement (which, being a compound statement, can of course contain other statements):</p>
<pre><code>for i in bar: foo.remove(i)
return ''.join(foo)
</code></pre>
<p>While comprehensions <em>are</em> faster than <code>for</code> statements for building a list, that's mainly because they can use a specially-optimized version of <code>list.append</code>. If you don't actually <em>want</em> the resulting list, they're <em>slower</em>, because even a really fast <code>list.append</code> is still a lot slower than not building a list at all.</p>
<p>And, more importantly, using comprehensions just for side effects isn't just inefficient, it makes your code less idiomatic, and harder to understand.</p>
<p>Anyway, if you really need to optimize this code, you probably <em>shouldn't</em> be mutating <code>foo</code> in-place. Every time you call <code>foo.remove(i)</code>, that takes linear work to find the first occurrence of <code>i</code> and then shift the whole rest of the list up. So, if <code>bar</code> is roughly the same size as <code>foo</code>, this takes quadratic work. But you can just copy the list, filtering as you go, in linear time:</p>
<pre><code>barset = set(bar)
return ''.join([x for x in foo if x not in barset])
</code></pre>
<p>(I'm assuming here you don't have any duplicate values in <code>foo</code> and <code>bar</code>—if you do, I'd be willing to bet <code>remove</code> wasn't actually doing what you want. But, if so, you do need something a bit more complicated here.)</p>
</div>
<span class="comment-copy">List comprehensions are meant to produce <i>lists</i>.  Don't use them for this.</span>
<span class="comment-copy">What is the problem you are trying to solve? It sounds like an <a href="https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem">XY problem</a>. That is to say an issue with your proposed solution, rather your actual problem. If we can understand why you want to do this, we may be able to suggest another way to do it.</span>
<span class="comment-copy">You can't put <i>any</i> statement inside a comprehension, only expressions (and only a specific subset of them).</span>
<span class="comment-copy">@PhillipsKruman list comprehensions are great when your desired result is a list.  Here there is no point in creating a list of <code>None</code> (which is what <code>foo.remove(i)</code> returns.  You don't even store the result.</span>
<span class="comment-copy">@PhillipsKruman List comprehensions are more efficient than for loops <i>if you're using them to build a list</i>, mainly because they have a special optimization in the way they append to that list. If you're using them purely for side effects, they're generally <i>less</i> efficient, because even a fast append is still slower than not appending at all.</span>
<span class="comment-copy">Well, they can contain expression statements :)</span>
<span class="comment-copy">@juanpa.arrivillaga Sure, without context an expression statement in the code is indistinguishable from an expression (or I think a splat-expression in current versions?) in the code, but they are different node types in the grammar (and the actual parser), and in context the grammar can never produce an expression statement node inside a comprehension.</span>
<span class="comment-copy">@juanpa.arrivillaga Of course looked at another way, <i>semantically</i> they certainly do contain statements, and even a return statement, because of the way their behavior is defined (and implemented by the CPython compiler)… :)</span>
<span class="comment-copy">That was meant more as a quip, but your response lead me to this good question: <a href="https://stackoverflow.com/questions/32429034/what-is-an-expr-in-python-ast?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" title="what is an expr in python ast">stackoverflow.com/questions/32429034/…</a></span>
<span class="comment-copy">@juanpa.arrivillaga Yeah, I know you weren't serious… but meanwhile, after reading: <a href="https://docs.python.org/3/library/ast.html#abstract-grammar" rel="nofollow noreferrer">The Abstract Grammar section</a> says an <code>Expr</code> contains an <code>expr</code>, but the <a href="https://docs.python.org/3/reference/simple_stmts.html" rel="nofollow noreferrer">Simple Statements reference</a> says an <code>expression_stmt</code> contains a <code>starred_expression</code>. It looks the reference is right in that you can <i>parse</i> <code>*(1,2,3)</code> as an expression—but the <code>ast</code> module is right in that a post-processing step raises a special <code>SyntaxError: can't use starred expression here</code></span>
