<div class="post-text" itemprop="text">
<p>I apologize for the seemingly confusing title, hope the code will help clarify the question.</p>
<p>I have a python data structure that looks like this:</p>
<pre class="lang-py prettyprint-override"><code>people = [
  {
    'id': 1,
    'name': 'Ada',
    'age': 55
  },
  {
    'id': 2,
    'name': 'Bart',
    'age': 46
  },
  {
    'id': 3,
    'name': 'Chloe',
    'age': 37
  },
  {
    'id': 4,
    'name': 'Dylan',
    'age': 28
  }
]
</code></pre>
<p>I want to achieve the following:</p>
<pre class="lang-none prettyprint-override"><code>1, Ada, 55
2, Bart, 46
3, Chloe, 37
4, Dylan, 28
</code></pre>
<p>Without having to address each dictionary key like <code>person['key']</code> but rather by just <code>key</code>; something like this:</p>
<pre class="lang-py prettyprint-override"><code># BOGUS CODE, WON'T WORK
for (id, name, age) in people:
  print('{}, {}, {}'.format(id, name, age))
</code></pre>
<p>(which curiously prints <code>name, id, age</code>)
Thanks in advance!</p>
<p>PS: Bonus question! Is there a specific name for list/arrays of homogeneous dictionaries/objects (also outside of Python)? <em>List of homogenous dictionaries</em> seems quite a mouthful.</p>
</div>
<div class="post-text" itemprop="text">
<p>You an use <code>operator.itemgetter()</code> and <code>map()</code>.</p>
<pre><code>In [31]: from operator import itemgetter

In [32]: list(map(itemgetter('id', 'name', 'age'), people))
Out[32]: [(1, 'Ada', 55), (2, 'Bart', 46), (3, 'Chloe', 37), (4, 'Dylan', 28)]
</code></pre>
<p>But note that if you want all the values from all the keys you could simply use <code>dict.values()</code> in a list comprehension to get all the respective values. </p>
<pre><code>In [33]: [d.values() for d in people]
Out[33]: 
[dict_values([1, 'Ada', 55]),
 dict_values([2, 'Bart', 46]),
 dict_values([3, 'Chloe', 37]),
 dict_values([4, 'Dylan', 28])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just d:</p>
<pre><code>for person in people:
    person_id, name, age = person['id'], person['name'], person['age']
    print(person_id, name, age)
</code></pre>
<p>In Python 3.6 you could also do (provided that values are defined exactly in the same order you shown us in the original question):</p>
<pre><code>for person in people:
    person_id, name, age = person.values()
    print(person_id, name, age)
</code></pre>
<p>However, this relies on the fact that the dictionary is defined <strong>exactly</strong> as it is in your example. If the order of the values changes, the code will break, as values will get mixed as well.</p>
<p><em>Hint</em>: I deliberately named my variable <code>person_id</code> instead of <code>id</code>, because It's an anti-pattern to shadow built-in variables and/or functions, and it happens that <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">there's a built-in called id</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for find in people:
    print('{0}, {1}, {2}'.format(find["id"], find["name"], find["age"]))
</code></pre>
<p>that will work</p>
</div>
<div class="post-text" itemprop="text">
<p>You could build a small class with an <code>__iter__</code> method:</p>
<pre><code>class Group:
  def __init__(self, d):
     self.__dict__ = d

class People:
   def __init__(self, data):
     self.data = data
   def __iter__(self):
     for i in self.data:
       d = Group(i)
       yield d.id, d.name, d.age

people = [{'age': 55, 'id': 1, 'name': 'Ada'}, {'age': 46, 'id': 2, 'name': 'Bart'}, {'age': 37, 'id': 3, 'name': 'Chloe'}, {'age': 28, 'id': 4, 'name': 'Dylan'}]
for a, b, c in People(people):
   print('{} {} {}'.format(a, b, c))
</code></pre>
<p>Output:</p>
<pre><code>1 Ada 55
2 Bart 46
3 Chloe 37
4 Dylan 28
</code></pre>
</div>
<span class="comment-copy"><code>print('{0}, {1}, {2}'.format(id, name, age))</code> ?</span>
<span class="comment-copy">@Mika72, This won't work, notice that OP is iterating over a list of dictionaries.</span>
<span class="comment-copy"><code>for dict_ in people: print("{id}, {name}, {age}".format(**dict_))</code></span>
<span class="comment-copy">You're right. I assumed that this is the exact order as it is in the OP. I edited the answer to reflect this information in a better way.</span>
<span class="comment-copy">dicts being ordered is still an implementation detail in python 3.6. You shouldn't rely on that until 3.7.</span>
<span class="comment-copy">While I am indeed familiar with the conventional method, I'd like to achieve the same result &lt;&lt; <i>Without having to address each dictionary key like <code>person['key']</code> but rather by just <code>key</code></i> &gt;&gt;</span>
