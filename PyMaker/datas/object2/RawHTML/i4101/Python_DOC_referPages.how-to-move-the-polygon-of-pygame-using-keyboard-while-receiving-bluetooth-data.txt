<div class="post-text" itemprop="text">
<p>I wanna move polygon of pygame using keyboard while receiving bluetooth data from smartphone. when bluetooth signal is received, the polygon appears on the screen, but cannot move using keyboard. I set only moving upward. How can I move one......</p>
<pre><code>import pygame, sys
from pygame.locals import *
pygame.init()
import RPi.GPIO as GPIO
import numpy as np
import bluetooth
DISPLAYSURF = pygame.display.set_mode((500,400), 0, 32)
pygame.display.set_caption('Drawing')
BLACK = (0,0,0)
WHITE = (255,255,255)
GREEN = (0,255,0)
DISPLAYSURF.fill(WHITE)
pygame.display.update()
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
port = 1
server_socket.bind(("", port))
server_socket.listen(1)
client_socket, address = server_socket.accept()
print ("Accepted connection from ", address)
def get_data():
    data = client_socket.recv(1024)
return data

p = np.array([[146,0],[291,106],[236,277],[56,277],[0,106]])
</code></pre>
<p>the coordinates of a polygon</p>
<pre><code>    while True:
    pygame.display.update()
    for event in pygame.event.get():
        if event.type == QUIT:

            pygame.quit()
            sys.exit()



    data = get_data()
    if data == '0':

        DISPLAYSURF.fill(WHITE)
        pygame.draw.polygon(DISPLAYSURF, GREEN, ((p[0][0],p[0][1]),(p[1][0],p[1][1]),(p[2][0],p[2][1]),(p[3][0],p[3][1]),(p[4][0],p[4][1])))

        if event.type == KEYDOWN:
            if event.key == K_UP:
                p[0][1]-=2
                p[1][1]-=2
                p[2][1]-=2
                p[3][1]-=2
                p[4][1]-=2   
        if event.type == KEYUP:
            p=p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem seems to be that <code>client_socket.recv(1024)</code> is blocking Python.</p>
<p>When you are using pygame, you usually control the main loop yourself, that is, you call <code>pygame.display.update()</code> every couple of milliseconds. The simplest solution probably to first set the socket into <a href="https://docs.python.org/3/library/socket.html#socket.socket.setblocking" rel="nofollow noreferrer">non-blocking mode</a> and do polling.</p>
<p>E.g. you call <code>msg = client_socket.recv(1024)</code> during every iteration of the main loop, and process <code>msg</code> if not empty.</p>
<p>Depending on the socket implementation (I don't know the specifics of <code>BluetoothSocket</code>) you may have to deal with partial message and message boundaries. That is, you may need to collect more data and add them together until you have a full message, and use something like .split('\n') to separate a completed message(s) from the partial next message. Just print what you get and figure it out from there.</p>
<p>There are other options than polling (threads, async event main loop) but they come with their own drawbacks (synchronization and race conditions, callbacks and framework complexity).</p>
</div>
