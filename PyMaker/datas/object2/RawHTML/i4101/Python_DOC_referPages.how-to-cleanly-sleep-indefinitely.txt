<div class="post-text" itemprop="text">
<p>A few threads are started in my code and I need at the end of the script to sleep indefinitely, without this sleep being a major hit on the performance<sup>1</sup>. </p>
<p>One possibility can be to loop indefinitely with a short sleep:</p>
<pre><code>while True:
    time.sleep(1)
</code></pre>
<p>or sleep for a long time</p>
<pre><code>time.sleep(4000000)
</code></pre>
<p>or </p>
<pre><code>import signal
signal.pause()
</code></pre>
<p>But:</p>
<ul>
<li><p>I did not manage to find the largest time sleep would accept (<code>sys.maxint</code> is too large)</p></li>
<li><p><code>signal.pause()</code> is implemented in Unix only</p></li>
<li><p>and the first "sleep loop" does not look clean to me (why 1 second and not 10, or 0.1?)</p></li>
</ul>
<p><strong>Is there a clean, pythonic way to sleep indefinitely?</strong></p>
<hr/>
<p><sup>1</sup> I do not control the threads directly, otherwise I would have gone for <a href="https://docs.python.org/3/library/threading.html#threading.Thread.join" rel="nofollow noreferrer"><code>threading.Thread.join()</code></a> as the threads themselves will not end.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/threading.html#threading.enumerate" rel="nofollow noreferrer"><code>threading.enumerate</code></a> gives you the list of all running threads including the main one, so you could do this:</p>
<pre><code>main_thread = threading.main_thread()
while True:
    L = threading.enumerate()
    L.remove(main_thread)  # or avoid it in the for loop
    for t in L:
        t.join()
</code></pre>
<p>The <code>while True</code> is needed in case your library creates new threads while you wait for the current ones to finish.</p>
<p>Assuming that no threads are created while <code>enumerate</code> is running, you can check if <code>L</code> has only one element (the main thread) and if so, break the loop. This combined with <a href="https://stackoverflow.com/users/5827215/tadhg-mcdonald-jensen">Tadhg McDonald-Jensen</a>'s <a href="https://stackoverflow.com/questions/50216918/how-to-cleanly-sleep-indefinitely/50218501#comment87488444_50218501">suggestion</a> of using <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a> with a sentinel, results in:</p>
<pre><code>main_thread = threading.main_thread()
main_threads = [main_thread, ]  # WARN: can't have more than one thread here
for threads in iter(threading.enumerate, main_threads):
    for t in threads:
        if t == main_thread:
            continue
        t.join()
</code></pre>
<p><code>enumerate</code> returns a list in undefined order, so if you have more than one "main" thread, order starts to matter. A solution would be to use <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer">sets</a>, i.e. <code>main_threads = {main_thread, }</code> and <code>iter(lambda : set(threading.enumerate()), main_threads)</code>.</p>
<p>If you prefer the <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a> approach of asking for forgiveness instead of permission and all your threads are started when you reach the end of your script, you can also do this:</p>
<pre><code>for thread in threading.enumerate():
    try:
        thread.join()
    except RuntimeError:
        # trying to join the main thread, which would create a deadlock (see https://docs.python.org/3/library/threading.html#threading.Thread.join for details)
        pass
</code></pre>
</div>
<span class="comment-copy">why? you want a job scheduler perhaps?</span>
<span class="comment-copy">How about you <code>join()</code> the threads or the thread pool?</span>
<span class="comment-copy">"cleanly sleep" looks like an oxymoron...</span>
<span class="comment-copy">There's nothing wrong with sleeping for a long time in an infinite loop. Every N seconds, the scheduler will wake your thread, loop around to the next sleep and then move on. No harm done; very quick. Your MQTT library probably has a method to do this for you. The Eclipse Paho MQTT Python docs show <code>client.loop_forever()</code> as an example.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/threading.html#threading.enumerate" rel="nofollow noreferrer"><code>threading.enumerate</code></a> gives you the list of all running threads including the main one, so you could wait (<code>join</code>) them.</span>
<span class="comment-copy">you may want to rewrite it slightly to have <code>while L</code> instead of <code>while True</code> so when there are no more threads you can let the thing stop.  you can also do <code>for L in iter(threading.enumerate, []):</code> which basically reads "keep calling <code>threading.enumerate()</code> and keep running this loop with the result until it gives an empty list"</span>
<span class="comment-copy">@TadhgMcDonald-Jensen, I've expanded my answer based on your suggestion. Thanks for the idea.</span>
<span class="comment-copy">That makes more sense than checking for empty list and I really like the way you used it, although I do need to point out that if you wanted to have more than one "main thread" I'm not sure you can guarantee the order they appear in the list so I'm not sure it would directly scale to multiple main threads.  Either way very good solution.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen: good catch! I've added a fix.</span>
