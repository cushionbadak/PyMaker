<div class="post-text" itemprop="text">
<p>I have a list of tuples that can be understood as key-value pairs, where a key can appear several times, possibly with different values, for example</p>
<pre><code>[(2,8),(5,10),(2,5),(3,4),(5,50)]
</code></pre>
<p>I now want to get a list of tuples with the highest value for each key, i.e.</p>
<pre><code>[(2,8),(3,4),(5,50)]
</code></pre>
<p>The order of the keys is irrelevant.</p>
<p>How do I do that in an efficient way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Sort them and then cast to a dictionary and take the items again from it:</p>
<pre><code>l = [(2,8),(5,10),(2,5),(3,4),(5,50)]
list(dict(sorted(l)).items()) #python3, if python2 list cast is not needed
[(2, 8), (3, 4), (5, 50)]
</code></pre>
<p>The idea is that the key-value pairs will get updated in ascending order when transforming to a dictionary filtering the lowest values for each key, then you just have to take it as tuples.</p>
</div>
<div class="post-text" itemprop="text">
<p>At its core, this problem is essentially about grouping the tuples based on their first element and then keeping only the maximum of each group.</p>
<p>Grouping can be done easily with a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>. A detailed explanation of grouping with defaultdicts can be found in my answer <a href="https://stackoverflow.com/questions/50086452/a-recipe-to-group-aggregate-data/50086453#50086453">here</a>. In your case, we group the tuples by their first element and then use the <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow noreferrer"><code>max</code></a> function to find the tuple with the largest number.</p>
<pre><code>import collections

tuples = [(2,8),(5,10),(2,5),(3,4),(5,50)]

groupdict = collections.defaultdict(list)
for tup in tuples:
    group = tup[0]
    groupdict[group].append(tup)

result = [max(group) for group in groupdict.values()]
# result: [(2, 8), (5, 50), (3, 4)]
</code></pre>
<p>In your particular case, we can optimize the code a little bit by storing only the maximum 2nd element in the dict, rather than storing a list of all tuples and finding the maximum at the end:</p>
<pre><code>tuples = [(2,8),(5,10),(2,5),(3,4),(5,50)]

groupdict = {}
for tup in tuples:
    group, value = tup

    if group in groupdict:
        groupdict[group] = max(groupdict[group], value)
    else:
        groupdict[group] = value

result = [(group, value) for group, value in groupdict.items()]
</code></pre>
<p>This keeps the memory footprint to a minimum, but only works for tuples with exactly 2 elements.</p>
<hr/>
<p>This has a number of advantages over <a href="https://stackoverflow.com/a/50251705/1222951">Netwave's solution</a>:</p>
<ul>
<li>It's more readable. Anyone who sees a defaultdict being instantiated knows that it'll be used to group data, and the use of the <code>max</code> function makes it easy to understand which tuples are kept. Netwave's one-liner is clever, but clever solutions are rarely easy to read.</li>
<li>Since the data doesn't have to be sorted, this runs in linear O(n) time instead of O(n log n).</li>
</ul>
</div>
<span class="comment-copy">Use an intermediate dict.</span>
<span class="comment-copy">Just to be clear for myself, sorting a list beforehand and then casting it to a dict applies some kind of ordering ? Is it definite that every time this will give the same result ?</span>
<span class="comment-copy">@BcK Constructing a dictionary from an iterable (like a list) inserts the items one after another, overwriting existing keys. If the iterable is sorted, only the maximum value for each key survives.</span>
<span class="comment-copy">@BcK, it will give the same result in python3 because if i recall properly dictionaries assure to have the same ordering over keys, but not in python2. let me check about this.</span>
<span class="comment-copy">The output of <code>items()</code> is probably not guaranteed to be the same each time. Otherwise there would be no need for <code>OrderedDict</code> to exist.</span>
<span class="comment-copy">@BcK, from python3.6 they maintain insertion order, <a href="https://docs.python.org/3.6/whatsnew/3.6.html#new-dict-implementation" rel="nofollow noreferrer">docs.python.org/3.6/whatsnew/3.6.html#new-dict-implementation</a>. So they will be always ordered.</span>
<span class="comment-copy">Alternatively, you could keep running maximums in the dict instead of collecting all values and computing the maxes at the end.</span>
<span class="comment-copy">Also, keeping tuples instead of just values in the groups requires that the keys support <code>key &lt; key</code>. That works for int keys, but for non-comparable keys, it'd require adjustment.</span>
<span class="comment-copy">@user2357112 Each solution has its own disadvantages, but I added a version with a running maximum. It's certainly worth showing, even if it only works with 2-tuples.</span>
