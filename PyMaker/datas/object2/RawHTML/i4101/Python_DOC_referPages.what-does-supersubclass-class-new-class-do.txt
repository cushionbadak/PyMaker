<div class="post-text" itemprop="text">
<p>In the following <code>Python</code> implementation of the <a href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow noreferrer">Singleton pattern</a>:</p>
<pre><code>class Singleton(object):
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance
</code></pre>
<p>What does the line <code>cls.instance = super(Singleton, cls).__new__(cls)</code> do?  </p>
<p>Among other things in this line that I don't understand is the <code>super</code> usage. I saw usage of <code>super</code> with <code>(subclass, instance)</code>, but here we pass it <code>(subclass, class)</code>. So is it going to have <code>(Singleton class, Singleton class)</code> as arguments?</p>
<p><a href="https://repl.it/repls/AffectionateAdoredFtpclient" rel="nofollow noreferrer">Live example</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The second argument to <code>super()</code> is used for two purposes:</p>
<ul>
<li><p>To supply an ordered list of classes to search through; the order is the Method Resolution Order (MRO), and searching for attributes on <code>super()</code> starts at the class following the one named as the first argument to <code>super()</code></p></li>
<li><p>To bind any descriptors (like methods) to.</p></li>
</ul>
<p>So <code>super(clsobject, second_argument)</code> will look for a <code>__mro__</code> list, then search for <code>clsobject</code>, then continue searching the remainder of the list for the attribute you wanted. It then uses the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a> to bind the object to <code>second_argument</code>.</p>
<p>The <code>__new__</code> method only makes sense on a class, because it creates a new instance; there is no instance yet when that method is called; it is the factory that is supposed to produce the instance for that class.</p>
<p>So you can't pass in an instance as the second argument. You can only pass in a class, and <code>super()</code> can handle that. For instances, <code>super()</code> looks at <code>type(instance).__mro__</code>, but for classes, <code>classobject.__mro__</code> is used instead. So passing in <code>cls</code> is perfectly fine here.</p>
<p><code>__new__</code> is also a <em>static method</em>, meaning that it ignores the binding process. No automatic passing in of the first argument, the class, takes place. You need to do this manually, hence the <code>...__new__(cls)</code> call.</p>
<p>So in this specific instance, the line:</p>
<pre><code>cls.instance = super(Singleton, cls).__new__(cls)
</code></pre>
<p>will search for <code>Singleton</code> in <code>cls.__mro__</code>, find the next object with a <code>__new__</code> attribute, and then try to bind that <code>__new__</code> attribute to <code>cls</code>. If you didn't use multiple inheritance, that is going to be <code>object.__new__</code>. The <code>__new__</code> method is static, so no binding takes place, so you are given <code>object.__new__</code>, which is then called with <code>cls</code> as the first argument. This produces an instance of the <code>Singleton</code> class (or a subclass thereof), which is then assigned to the attribute <code>instance</code> on the class object.</p>
</div>
<span class="comment-copy"><code>cls</code> <b>is the instance</b> in this case.</span>
<span class="comment-copy">In Python 3, is it safe to do <code>cls.instance = super().__new__(cls)</code> here?</span>
<span class="comment-copy">@PM2Ring: yes, because <code>super()</code> then finds the <code>__class__</code> closure (set to <code>Singleton</code>) and the <i>first</i> argument to the method, here <code>cls</code> (this is always the first name in the code object local names).</span>
