<div class="post-text" itemprop="text">
<p>I'm just starting to use Asyncio and I'm trying to use it to parse a website.</p>
<p>I'm trying to parse 6 sections (<code>self.signals</code>) of the site, each section has N number of pages with tables on them, so essentially I'm trying to async the loop that calls what section, and async the pages in each section. This is what I have so far.</p>
<pre><code>class FinViz():
    def __init__(self):
        self.url = 'https://finviz.com/screener.ashx?v=160&amp;s='

        self.signals = {
            'Earnings_Before' : 'n_earningsbefore',
            'Earnings_After' : 'n_earningsafter',
            'Most_Active' : 'ta_mostactive',
            'Top_Gainers' : 'ta_topgainers',
            'Most_Volatile' : 'ta_mostvolatile',
            'News' : 'n_majornews',
            'Upgrade' : 'n_upgrades',
            'Unusual_Volume' : 'ta_unusualvolume' 
        }

        self.ticks = []

    def _parseTable(self, data):
        i, signal = data
        url = self.signals[signal] if i == 0 else self.signals[signal] + '&amp;r={}'.format(str(i * 20 + 1))
        soup = BeautifulSoup(urlopen(self.url + url, timeout = 3).read(), 'html5lib')
        table = soup.find('div', {'id' : 'screener-content'}).find('table', 
            {'width' : '100%', 'cellspacing': '1', 'cellpadding' : '3', 'border' : '0', 'bgcolor' : '#d3d3d3'})
        for row in table.findAll('tr'):
            col = row.findAll('td')[1]
            if col.find('a'):
                self.ticks.append(col.find('a').text)


    async def parseSignal(self, signal):
        try:
            soup = BeautifulSoup(urlopen(self.url + self.signals[signal], timeout = 3).read(), 'html5lib')

            tot = int(soup.find('td', {'class' : 'count-text'}).text.split()[1])

            with concurrent.futures.ThreadPoolExecutor(max_workers = 20) as executor:
                loop = asyncio.get_event_loop()
                futures = []
                for i in range(tot // 20 + (tot % 20 &gt; 0)):
                    futures.append(loop.run_in_executor(executor, self._parseTable, (i, signal)))


                for response in await asyncio.gather(*futures):
                    pass    
        except URLError:
            pass


    async def getAll(self):
        with concurrent.futures.ThreadPoolExecutor(max_workers = 20) as executor:
            loop = asyncio.get_event_loop()
            futures = []
            for signal in self.signals:
                futures.append(await loop.run_in_executor(executor, self.parseSignal, signal))

            for response in await asyncio.gather(*futures):
                pass
        print(self.ticks)

if __name__ == '__main__':

    x = FinViz()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(x.getAll())
</code></pre>
<p>This does do the job successfully, but it somehow does it slower than if I were to do the parsing without <code>asyncio</code>. </p>
<p>Any tips for an asynchronous noob?</p>
<p>Edit: Added full code</p>
</div>
<div class="post-text" itemprop="text">
<p>Remember python has a GIL, so threaded code will not help performance.  To potentially speed things up use a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer">ProcessPoolExecutor</a> however note you'll incur the following overhead:</p>
<ol>
<li>pickle/unpickling data to sub-process worker</li>
<li>pickle/unpickling result sent back to main process</li>
</ol>
<p>You can avoid 1. if you run on a fork safe environment and store the data in a global variable.</p>
<p>You can also do stuff like share a memory mapped file...also sharing raw strings/bytes is the fastest.</p>
</div>
