<div class="post-text" itemprop="text">
<p><em>Firstly I'm aware that there have been multiple questions already asked regarding this particular error but I can't find any that address the precise context in which it's occurring for me. I've also tried the solutions provided for other similar errors and it hasn't made any difference.</em> </p>
<p>I'm using the python module <code>pickle</code> to save an object to file and the reload it using the following code:</p>
<pre><code>with open('test_file.pkl', 'wb') as a: 
    pickle.dump(object1, a, pickle.HIGHEST_PROTOCOL)
</code></pre>
<p>This doesn't throw any error but then when I try and open the file using the following code:</p>
<pre><code>with open('test_file.pkl', 'rb') as a:
    object2 = pickle.load(a)
</code></pre>
<p>I get this error:</p>
<pre><code>---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)
&lt;ipython-input-3-8c5a70d147f7&gt; in &lt;module&gt;()
      1 with open('2test_bolfi_results.pkl', 'rb') as a:
----&gt; 2     results = pickle.load(a)
      3

~/.local/lib/python3.5/site-packages/elfi/methods/results.py in __getattr__(self, item)
     95     def __getattr__(self, item):
     96         """Allow more convenient access to items under self.meta."""
---&gt; 97         if item in self.meta.keys():
     98             return self.meta[item]
     99         else:

... last 1 frames repeated, from the frame below ...

~/.local/lib/python3.5/site-packages/elfi/methods/results.py in __getattr__(self, item)
     95     def __getattr__(self, item):
     96         """Allow more convenient access to items under self.meta."""
---&gt; 97         if item in self.meta.keys():
     98             return self.meta[item]
     99         else:

RecursionError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<p>I'm aware other people have seen this same error (<a href="https://stackoverflow.com/questions/2134706/hitting-maximum-recursion-depth-using-pickle-cpickle">Hitting Maximum Recursion Depth Using Pickle / cPickle</a>) when doing <code>pickle.dump</code> and I've tried increasing the maximum recursion depth by doing <code>sys.setrecursionlimit()</code> but this doesn't work, I either get the same error as above or I increase it further and python crashes with the message: <code>Segmentation fault (core dumped)</code>.</p>
<p>I suspect that the root of the problem is actually when I save the object with <code>pickle.load()</code> but I don't really know how to diagnose it. </p>
<p>Any suggestions? </p>
<p>(I'm running python3 on a windows 10 machine)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a fairly minimal class derived from <a href="https://docs.python.org/3/library/collections.html#collections.UserDict" rel="nofollow noreferrer"><code>collections.UserDict</code></a> which performs the same trick that your problem object does. It's a dictionary which allows you to access its items either via normal dict syntax, or as attributes. I've thrown in a few <code>print</code> calls so we can see when the main methods get called.</p>
<pre><code>import collections

class AttrDict(collections.UserDict):
    ''' A dictionary that can be accessed via attributes '''
    def __setattr__(self, key, value):
        print('SA', key, value)
        if key == 'data':
            super().__setattr__('data', value)
        else:
            self.data[key] = value

    def __getattr__(self, key):
        print('GA', key)
        if key in self.data:
            return self.data[key]
        else: 
            print('NOKEY')
            raise AttributeError

    def __delattr__(self, key):
        del self.data[key]

# test

keys = 'zero', 'one', 'two', 'three'
data = {k: i for i, k in enumerate(keys)}
d = AttrDict(data)
print(d)
print(d.zero, d.one, d.two, d['three'])
</code></pre>
<p><strong>output</strong></p>
<pre><code>SA data {}
{'zero': 0, 'one': 1, 'two': 2, 'three': 3}
GA zero
GA one
GA two
0 1 2 3
</code></pre>
<hr/>
<p>So far, so good. But if we try to pickle our <code>d</code> instance, we get <code>RecursionError</code> because of that <code>__getattr__</code> which does the magic conversion of attribute access to key lookup. We can overcome that by providing the class with <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer"><code>__getstate__</code></a> and <code>__setstate__</code> methods.</p>
<pre><code>import pickle
import collections

class AttrDict(collections.UserDict):
    ''' A dictionary that can be accessed via attributes '''
    def __setattr__(self, key, value):
        print('SA', key, value)
        if key == 'data':
            super().__setattr__('data', value)
        else:
            self.data[key] = value

    def __getattr__(self, key):
        print('GA', key)
        if key in self.data:
            return self.data[key]
        else: 
            print('NOKEY')
            raise AttributeError

    def __delattr__(self, key):
        del self.data[key]

    def __getstate__(self):
        print('GS')
        return self.data

    def __setstate__(self, state):
        print('SS')
        self.data = state

# tests

keys = 'zero', 'one', 'two', 'three'
data = {k: i for i, k in enumerate(keys)}
d = AttrDict(data)
print(d)
print(d.zero, d.one, d.two, d['three'])

print('Pickling')
s = pickle.dumps(d, pickle.HIGHEST_PROTOCOL)
print(s)

print('Unpickling')
obj = pickle.loads(s)
print(obj)
</code></pre>
<p><strong>output</strong></p>
<pre><code>SA data {}
{'zero': 0, 'one': 1, 'two': 2, 'three': 3}
GA zero
GA one
GA two
0 1 2 3
Pickling
GS
b'\x80\x04\x95D\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x08AttrDict\x94\x93\x94)\x81\x94}\x94(\x8c\x04zero\x94K\x00\x8c\x03one\x94K\x01\x8c\x03two\x94K\x02\x8c\x05three\x94K\x03ub.'
Unpickling
SS
SA data {'zero': 0, 'one': 1, 'two': 2, 'three': 3}
{'zero': 0, 'one': 1, 'two': 2, 'three': 3}
</code></pre>
<p>But what can we do to repair an existing class with this behaviour? Fortunately, Python allows us to easily add new methods to an existing class, even one that we obtain via importing.</p>
<pre><code>import pickle
import collections

class AttrDict(collections.UserDict):
    ''' A dictionary that can be accessed via attributes '''
    def __setattr__(self, key, value):
        print('SA', key, value)
        if key == 'data':
            super().__setattr__('data', value)
        else:
            self.data[key] = value

    def __getattr__(self, key):
        print('GA', key)
        if key in self.data:
            return self.data[key]
        else: 
            print('NOKEY')
            raise AttributeError

    def __delattr__(self, key):
        del self.data[key]

# Patch the existing AttrDict class with __getstate__ &amp; __setstate__ methods

def getstate(self):
    print('GS')
    return self.data

def setstate(self, state):
    print('SS')
    self.data = state

AttrDict.__getstate__ = getstate
AttrDict.__setstate__ = setstate

# tests

keys = 'zero', 'one', 'two', 'three'
data = {k: i for i, k in enumerate(keys)}
d = AttrDict(data)
print(d)
print(d.zero, d.one, d.two, d['three'])

print('Pickling')
s = pickle.dumps(d, pickle.HIGHEST_PROTOCOL)
print(s)

print('Unpickling')
obj = pickle.loads(s)
print(obj)
</code></pre>
<p>This code produces the same output as the previous version, so I won't repeat it here.</p>
<p>Hopefully, this gives you enough info to repair your faulty object. My <code>__getstate__</code> &amp; <code>__setstate__</code> methods <em>only</em> save and restore the stuff in the <code>.data</code> dictionary. To properly pickle your object, we may need to be a bit more drastic. For example, we may need to save and restore the instance's <code>.__dict__</code> attribute, rather than just the <code>.data</code> attribute, which corresponds to the <code>.meta</code> attribute in your problem object.</p>
</div>
<span class="comment-copy">Would be helpful if you post the object's structure or class. Could you try to verify if <code>object2 = pickle.loads(pickle.dumps(object1))</code> raises the same exception?</span>
<span class="comment-copy">I take it the object that you're trying to pickle is not of a class that you wrote, it's something from a 3rd party library (elfi ?). It looks like the culprit is that funky <code>__getattr__</code> method. I can reproduce that error with a fairly minimal class I wrote which subclasses <code>collections.UserDict</code>, but I'm not yet sure what's the best way to get around the problem. I guess you can't modify the offending class.</span>
<span class="comment-copy">Yeah it's the output produced by elfi (engine for likelihood free inference) which is produced when fitting a mathematical model with bayesian-optimisation for likelihood free inference (bolfi)</span>
<span class="comment-copy">Thanks for your answer it was really helpful. Because my object was slightly different from the dummy one you created I couldn't do exactly the same thing that you did but I'd never have figured it out without using your answer as a template. I'm going to post another answer below showing exactly what I did (also sorry for the late reply)</span>
<span class="comment-copy">Actually, ignore that last comment. I don't think I do need to include another answer, saving and restoring the <code>.meta</code> and <code>.__dict__</code> objects was sufficient. Thanks</span>
