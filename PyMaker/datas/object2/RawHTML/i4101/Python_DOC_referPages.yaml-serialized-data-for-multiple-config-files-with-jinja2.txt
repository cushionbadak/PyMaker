<div class="post-text" itemprop="text">
<p>I've already been able to load data from a YAML document into a configuration file.</p>
<p>YAML:</p>
<pre><code>id: 1
x: key1
y: key2
</code></pre>
<p>Python script:</p>
<pre><code>#Import necessary functions from Jinja2 module
from jinja2 import Environment, FileSystemLoader

#Import YAML module
import yaml

import sys

ALLOWED_ARGS = set(['template', 'data'])

def print_usage():
    print('Wrong arguments: Usage: configplate.py --template=&lt;template.jinja&gt; --data=&lt;data.yaml&gt;')

def load_args(args):
    out = {}
    for arg in args:
        if arg == __file__: #ignore the filename argument
            continue
        args_splited = arg.split('=')
        out[args_splited[0].lstrip('-')] = args_splited[1]
    if set(out.keys()) != set(ALLOWED_ARGS):
        print_usage()
        raise ValueError('Required argument not present.')
    return out

def make(template, data):
    #Load data from YAML into Python dictionary
    config_data = yaml.load(open(data))

    #Load Jinja2 templates
    env = Environment(loader = FileSystemLoader('.'), trim_blocks=True, lstrip_blocks=True)
    template = env.get_template(template)

    #Render the template with data and print the output
    return template.render(config_data)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print_usage()
    else:
        args = load_args(sys.argv)
        res = make(args['template'], args['data'])
        print(res)
</code></pre>
<p>Config file:</p>
<pre><code>&lt;add name="Cloud" connectionString="{{ x }}" /&gt;
</code></pre>
<p>The issue I'm facing now is that I can't load the same YAML to multiple config files. I have a second config file that I would like to fill at the same time.</p>
<p>Config file 2:</p>
<pre><code>&lt;add name="Cloud" connectionString="{{ y }}" /&gt;
</code></pre>
<p>How can I add this in the same python script? I also do not need to set the config files on the console, I can simply put their path into the script.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you want to process multiple templates, you need to make your <code>load_args</code> capable of handling multiple <code>--template=</code> arguments/options. 
I adapted your <code>load_args</code> to return a dict with values that are lists, but the check on number of arguments allowed (multiple templates, single YAML file) is crude. </p>
<p>For processing your commandline you should look at the standard <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">arparse</a> module, where you can indicate per  argument/option that it can occur multiple times. </p>
<p>Since you are going to reuse the data from YAML, load it only once, outside of the call <code>make()</code>. <strong>There is no excuse for not using</strong> <code>safe_load()</code> <strong>instead of the documented unsafe</strong> <code>load()</code>.</p>
<p>With:</p>
<pre><code>#Import necessary functions from Jinja2 module
from jinja2 import Environment, FileSystemLoader

#Import YAML module
import yaml

import sys

ALLOWED_ARGS = set(['template', 'data'])

def print_usage():
    print('Wrong arguments: Usage: configplate.py --template=&lt;template.jinja&gt; --data=&lt;data.yaml&gt;')

def load_args(args):
    out = {}
    for arg in args:
        if arg == __file__: #ignore the filename argument
            continue
        args_split = arg.split('=', 1)
        out.setdefault(args_split[0].lstrip('-'), []).append(args_split[1])
    if (set(out.keys()) != set(ALLOWED_ARGS)) or len(out['data']) != 1:
        print_usage()
        raise ValueError('Required argument not present.')
    return out

def make(template, data):
    #Load Jinja2 templates
    env = Environment(loader = FileSystemLoader('.'), trim_blocks=True, lstrip_blocks=True)
    template = env.get_template(template)

    #Render the template with data and print the output
    return template.render(data)

sys.argv=[
    __file__,
    '--template=config1.jinja',
    '--template=config2.jinja',
    '--data=data.yaml'
]

if __name__ == '__main__':
    if len(sys.argv) &lt; 4:
        print_usage()
    else:
        args = load_args(sys.argv)
        # Load data from YAML into Python dictionary **once** and **safely**
        config_data = yaml.safe_load(open(args['data'][0]))
        for template_file in args['template']:
            res = make(template_file, config_data)
            print(res)
</code></pre>
<p>And the appropriate files you get:</p>
<pre><code>&lt;add name="Cloud" connectionString="key1" /&gt;
&lt;add name="Cloud" connectionString="key2" /&gt;
</code></pre>
<hr/>
<p>When you import <code>argparse</code> you can drop <code>AllOWED_ARGS</code>, <code>print_usage</code> and <code>load_args</code>, and do then do the following:</p>
<pre><code>if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--template', action='append', nargs='+', required=True)
    parser.add_argument('--data', required=True)
    args = parser.parse_args()

    # Load data from YAML into Python dictionary **once** and **safely**
    config_data = yaml.safe_load(open(args.data))
    for template_file in args.template:
        res = make(template_file, config_data)
        print(res)
</code></pre>
<hr/>
<p>(BTW look up the conjugation of <code>to split</code>, there is no such thing as "splited" (or "splitted"), i.e. something "has been split", )</p>
</div>
<span class="comment-copy">Thanks @Anthon!</span>
