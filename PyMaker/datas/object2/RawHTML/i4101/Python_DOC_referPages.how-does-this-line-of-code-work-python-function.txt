<div class="post-text" itemprop="text">
<pre><code>def superindex(string, word):
    return [i for i, ltr in enumerate(string) if ltr == word]
</code></pre>
<p>I'm a beginner with Python and I would like to know how this look works.</p>
<ol>
<li>How does it create a list?</li>
<li>What does <code>i for i</code> do?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>It returns the indices where the letter <code>word</code> matches a character in the <code>string</code> variable.</p>
<p><code>for i, ltr in enumerate(string)</code> is a for loop over the letters in <code>string</code>, because you're using enumerate you also get an index <code>i</code> as well. However adding the if condition on the end means you only return <code>i</code> when the letter <code>ltr</code> equals the letter <code>word</code></p>
<p>So this</p>
<pre><code>string = "yuppers"
word = "p"
print(superindex(string, word))
</code></pre>
<p>will return this</p>
<p><code>[2,3]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Would be much easier for you to under stand if it was written like this :</p>
<pre><code>lst = []
for i, ltr in enumerate(string):
    if (ltr == word):
        lst.append(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easy way to understand single-line for loop is using more basic things:</p>
<pre><code>&gt;&gt;&gt; l = ["a", "b", "c"]
&gt;&gt;&gt; [ltr for ltr in l]
['a', 'b', 'c']
</code></pre>
<p>For your first question, using square brackets creates a list and it appends the <code>ltr</code> value to the list by iterating over the list <code>l</code>.</p>
<p>The <code>enumerate</code> is a built-in function which allows having a counter while looping over an iterable object. Here, <code>i</code> iterates over indexes of the list while <code>ltr</code> iterates over the elements of the list <code>l</code>. Here is another example:</p>
<pre><code>&gt;&gt;&gt; [i for i, ltr in  enumerate(l)]
[0, 1, 2]
&gt;&gt;&gt; [ltr for i, ltr in  enumerate(l)]
['a', 'b', 'c']
</code></pre>
<p>Additioanlly, you have a condition at the end:</p>
<pre><code>&gt;&gt;&gt;[ltr for i, ltr in  enumerate(l) if i&gt;0]
['b', 'c']
</code></pre>
<p>Here, it only takes the elements of the list <code>l</code> with indexes greater than <code>0</code>.</p>
<p>I hope, this helps understanding the concepts :)</p>
</div>
<div class="post-text" itemprop="text">
<p>This function is creating a list of the <code>ltr</code> indexes of an iterable variable <code>string</code>, that match the object <code>word</code></p>
<p>This function can be written in a simpler way:</p>
<pre><code>    def superindex(string, word):
        l = list()
        for i, ltr in enumerate(string):
            if ltr == word: # check if ltr is equal to the variable word
                l.append(i) # append the index i of the matching ltr in the string
        return l
</code></pre>
<p><code>enumerate</code><br/></p>
<ul>
<li>The enumerate function allows us to loop over something and have an automatic counter</li>
<li>Here each 'ltr' in the variable 'string' is assigned a number 'i' (starting from zero)
<p></p></li>
</ul>
<p><code>[i for i...</code><br/></p>
<ul>
<li>In the original version of the function, the <code>for</code> loop is written as a pythonic list comprehension. This allows us to loop over an iterable and create a list in one line of code (e.g. <code>[i for i in string]</code>). There are many cases where this form of a list is more efficient (see <a href="https://stackoverflow.com/questions/22108488/are-list-comprehensions-and-functional-functions-faster-than-for-loops">Are list-comprehensions and functional functions faster than "for loops"?</a>)
<p></p></li>
</ul>
<p>This function will work on letters:<br/>
<code>superindex('foo', 'o')</code><br/>
returns <code>[1,2]</code></p>
<p>and also lists of words:<br/>
<code>superindex(['foo', 'bar'], 'bar')</code><br/>
returns <code>[1]</code></p>
<p>Note: Although the variables suggest this is applicable to string and words, a more appropriate naming might be (<code>list_of_strings</code> and <code>word</code>) or (<code>string</code> and <code>letter</code>). If a more general case was sought maybe (<code>iterable</code> and <code>template</code>)...</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs.python.org/3.6/tutorial/â€¦</a></span>
<span class="comment-copy">It's called a list comprehension</span>
<span class="comment-copy">Please see the <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs</a>!</span>
<span class="comment-copy">Paranthesis around  condition in <code>if</code> are unnecessary.</span>
<span class="comment-copy">@theausome Code styling thing, just easier for me to read.</span>
