<div class="post-text" itemprop="text">
<p>Given the following example:</p>
<pre><code>class A:
    def f(self, x):
        return 2*x 
</code></pre>
<p>I would like to write another method which uses <code>f</code> above but adds a constant, i.e.</p>
<pre><code>class A:
        def f(self, x):
            return 2*x
        def g(self, x):
            return self.f(x) + 10
</code></pre>
<p>This would be one way. However, this smells very much like decorating! What would be the proper pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write a simple function outside the class:</p>
<pre><code>def add_val(f):
  def wrapper(cls, _x):
    return f(cls, _x) + 10
  return wrapper


class A:
  @add_val
  def f(self, x):
    return 2*x 
print(A().f(20))
</code></pre>
<p>Output:</p>
<pre><code>50
</code></pre>
<p>Edit: you can utilize <code>functools.wraps</code> with a <code>classmethod</code> in Python3. The wrapped function <code>f</code> will return <code>x*2</code> and the decorator <code>g</code> will add <code>10</code> to the returned result of the function passed to it. However, to be able to save the original functionality of <code>f</code>, you can utilize the <code>__wrapped__</code> attribute:</p>
<pre><code>import functools
def g(f):
  @functools.wraps(f)
  def wrapper(cls, _x):
    return f(cls, _x)+10
  return wrapper

class A:
   @classmethod
   @g
   def f(cls, x):
     return x*2

f_1 = functools.partial(A.f.__wrapped__, A)
print(A.f(4))
print(f_1(4))
</code></pre>
<p>Output:</p>
<pre><code>18
8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending answer of @Ajax1234, you may try to:
 - parametrize your decorator,
 - call your decorator explicitly (without <code>@</code>).</p>
<pre><code>def add_val(_value):
  def decorator(f):
    def wrapper(cls, _x):
      return f(cls, _x) + _value
    return wrapper

  return decorator

class A:
  def f(self, x):
    return 2*x 

  g = add_val(10)(f)
</code></pre>
<p>[EDIT]</p>
<p>You may also improve the decorator with <code>functools.wraps()</code> (which is a decorator itself). All you need to do is to change your wrapper declaration:</p>
<pre><code>@functools.wraps(f)
def wrapper(cls, _x):
  return f(cls, _x) + _value
</code></pre>
</div>
<span class="comment-copy">I think the way you wrote it is Pythonic enough imho</span>
<span class="comment-copy">That's very different from decorating. A decorator changes what a function does, so in the end you have 1 function. But you want to have 2 functions.</span>
<span class="comment-copy">@Aran-Fey I politely disagree. IMHO, decorating is at the end nothing else than composition of functions. Which is exactly what I do above, IMHO.</span>
<span class="comment-copy">It may be composition, but it still results in exactly 1 function and not 2.</span>
<span class="comment-copy">If I had a decorator like <code>add10</code>, I probably wouldn't use decorator syntax to define the function. Instead, I'd just write <code>g = add10(f)</code></span>
<span class="comment-copy">So your <code>f</code> is the OP's <code>g</code>, and the OP's <code>f</code> disappeared into nirvana? I don't think this is what the OP wants. Also, you should really use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">functools.wraps</a> when you write decorators.</span>
<span class="comment-copy">thanks for your answer. However, I would like to have a class method for both results, i.e. 2*x and 2*x + 10. Is this possible?</span>
<span class="comment-copy">@Aran-Fey No, <code>f</code> is the same. The decorator is adding additional functionality to <code>f</code> by providing the same operation as <code>g</code>.</span>
<span class="comment-copy">@math I am not sure I entirely understand, but it seems to me that you are trying to decorate <code>f</code> by applying the operation in <code>g</code> (adding <code>10</code> to the returned result of <code>f</code> ) yet still retaining the unwrapped function <code>f</code>. Please see my recent edit, as I added another possibility.</span>
<span class="comment-copy">If you're going to teach someone how to use decorators, <i>please</i> use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a>.</span>
<span class="comment-copy">@Aran-Fey I thought it is optional. Is it to comply with some Python standard or just for convenience?</span>
<span class="comment-copy">It does some nice things like copy the wrapped function's name and docstring. It also makes it possible to access the wrapped function through the <code>__wrapped__</code> attribute. <code>wraps</code> is what makes the difference between a function that returns another function, and a good, proper decorator.</span>
<span class="comment-copy">@Aran-Fey I agree it is convenient (and I do use it in my code), but according to <a href="https://docs.python.org/3.6/glossary.html#term-decorator" rel="nofollow noreferrer">Python docs</a> decorator is exactly <i>"a function that returns another function"</i>.</span>
