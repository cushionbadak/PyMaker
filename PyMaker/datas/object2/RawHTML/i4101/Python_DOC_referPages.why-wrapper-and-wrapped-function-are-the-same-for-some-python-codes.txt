<div class="post-text" itemprop="text">
<p>I was reading Ian Goodfellow's GAN source code in Github (link <a href="https://github.com/goodfeli/adversarial/blob/master/deconv.py" rel="nofollow noreferrer">https://github.com/goodfeli/adversarial/blob/master/deconv.py</a>). In particular, at line 40/41, the code is:</p>
<pre><code>@functools.wraps(Model.get_lr_scalers)
def get_lr_scalers(self):
</code></pre>
<p>It's a rather unfamiliar way of using <code>wraps</code>, and it seems the goal is to replace the <code>get_lr_scalers</code> with a user defined function. But in that case, we don't really need a wrapper for that, right? I don't really know the purpose of <code>wraps</code> in this case.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>wraps</code></a> copies a number of attributes from another function onto this function—by default, <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> and <code>__doc__</code>.</p>
<p>The most obviously useful one to copy over is the <code>__doc__</code>. Consider this simpler example:<sup>1</sup></p>
<pre><code>class Base:
    def spam(self, breakfast):
        """spam(self, breakfast) -&gt; breakfast with added spam

        &lt;29 lines of detailed information here&gt;
        """

class Child:
    @functools.wraps(Base.spam)
    def spam(self, breakfast):
        newbreakfast = breakfast.copy()
        newbreakfast.meats['spam'] + 30
        return newbreakfast
</code></pre>
<p>Now if someone wants to use <code>help(mychild.spam)</code>, they'll get the 29 lines of useful information. (Or, if they autocomplete <code>mychild.spam</code> in PyCharm, it'll pop up the overlay with the documentation, etc.) All without me having to manually copy and paste it. And, even better, if <code>Base</code> came from some framework that I didn't write, and my user upgrades from 1.2.3 to 1.2.4 of that framework, and there's a better docstring, they'll see that better docstring.</p>
<hr/>
<p>In the most common case, <code>Child</code> would be a subclass of <code>Base</code>, and <code>spam</code> would be an override.<sup>2</sup> But that isn't actually required—<code>wraps</code> doesn't care whether you're subtyping via inheritance, or duck typing by just implementing an implicit protocol; it's equally useful for both cases. As long as <code>Child</code> is intended to implement the <code>spam</code> protocol from <code>Base</code>, it makes sense for <code>Child.spam</code> to have the same docstring (and maybe other metadata attributes).</p>
<hr/>
<p>Others attributes probably aren't quite as useful as docstrings. For example, if you're using type annotations, their benefit in reading the code is probably at least as high as their benefit in being able to run Mypy for static type checking, so just copying them over dynamically from another method often isn't all that useful. And <code>__module__</code> and <code>__qualname__</code> are primarily used for reflection/inspection, and are more likely to be misleading than helpful in this case (although you could probably come up with an example of a framework where you'd want people to read the code in <code>Base</code> instead of the code in <code>Child</code>, that isn't true for the default obvious example). But, unless they're actively harmful, the readability cost of using <code>@functools.wraps(Base.spam, assigned=('__doc__',))</code> instead of just the defaults may not be worth it.</p>
<hr/>
<p><sub>1. If you're using Python 2, change these classes to inherit from <code>object</code>; otherwise they'll be old-style classes, which just complicates things in an irrelevant way. If Python 3, there are no old-style classes, so this issue can't even arise.</sub></p>
<p><sub>2. Or maybe a "virtual subclass" of an ABC, declared via a <code>register</code> call, or via a subclass hook.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>The purpose of <code>@wraps</code> is to copy meta information of one function to another function. This is usually done when replacing the original function by wrapping it, which is often done by decorators.</p>
<p>But in general case, here is what it does in an example:</p>
<pre><code>def f1():
    """Function named f1. Prints 'f1'."""
    print('f1')

@functools.wraps(f1)
def f2():
    print('f2')
</code></pre>
<p>Now, you can test what happened:</p>
<pre><code>&gt;&gt;&gt; f1
&lt;function f1 at 0x006AD8E8&gt;
&gt;&gt;&gt; f2
&lt;function f1 at 0x006AD978&gt;
&gt;&gt;&gt; f1()
f1
&gt;&gt;&gt; f2()
f2
&gt;&gt;&gt; f1.__doc__
"Function named f1. Prints 'f1'."
&gt;&gt;&gt; f2.__doc__
"Function named f1. Prints 'f1'."
</code></pre>
<p>When you call <code>f2</code>, it is obvious that it is actually <code>f2</code>, but when you inspect it, it behaves like <code>f1</code> - it has the same doc string and the same name.</p>
<p>What is that good for? For this:</p>
<pre><code>f1 = f2
</code></pre>
<p>Now the original f1 is replaced with a new functionality, but it still looks like <code>f1</code> from the outside.</p>
<p>It is usually done in a decorator:</p>
<pre><code>def replace(func):
    @functools.wraps(func)
    def replacement():
        print('replacement')
    return replacement

@replace
def f1():
    """Function named f1. Prints 'f1'."""
    print('f1')
</code></pre>
<p>And it behaves like this:</p>
<pre><code>&gt;&gt;&gt; f1()
replacement
&gt;&gt;&gt; f1
&lt;function f1 at 0x006AD930&gt;
&gt;&gt;&gt; f1.__name__
'f1'
&gt;&gt;&gt; f1.__doc__
"Function named f1. Prints 'f1'."
</code></pre>
</div>
<span class="comment-copy">Thanks for the explanation! It really clarified my confusion!</span>
<span class="comment-copy">A question, when you named <code>base</code> class and <code>child</code> class,  are you implying some kind of relationship/inheritance between the two class? Or the two can be completely irrelevant class, and the conclusion still holds?</span>
<span class="comment-copy">@fnosdy In my example, I’m using a subclass and a method override—but the same thing applies to two functions that are completely unrelated (or, rather, that are only related in some way that can’t be directly expressed in Python), it just isn’t quite as easy to come up with an obvious example. But consider a class that duck types as a Spam, and wants to use the docstring from Spam.eggs for its eggs method—wraps will do that (and probably more clearly than writing <code>eggs.__doc__ = Spam.eggs.__doc__</code>).</span>
<span class="comment-copy">@fnosdy Do you think the answer needs to make that clearer, or add more examples?</span>
<span class="comment-copy">I think the base and child definition is a bit confusing to me. I thought the two classes were related, maybe base(object) and child(object) will clear the confusion?</span>
