<div class="post-text" itemprop="text">
<p>I have a GraphQL API built with Flask and Graphene packages, running on <strong>Python 3.5.4</strong>. One of the GraphQL mutation is taking some time to execute (2 to 5 minutes) and I don't want the end user to wait for its execution to complete. I would like the mutation method to be executed in the background and instantly return a message to the user .</p>
<p>I have looked into <strong>asyncio</strong> package but for some reason the execution still appears at the forefront and my script is waiting. Would you have any idea what I'm doing wrong? The script is quite long so I've put a summary below with the key elements related to asyncio.</p>
<p><strong>File mutation_migration_plan.py</strong></p>
<pre><code>from migration_script import Migration, main
import asyncio
[...]

class executeMigrationPlan(graphene.Mutation):
    """Mutation to execute a migration plan."""
    [...]

    @staticmethod
    def mutate(root, info, input):
    [...]
        # Execute migration asynchronously
        print('Execute migration asynchronously')
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main(migration_plan))
        print('Migration plan execution has started. You will receive an e-mail when it is terminated.')

        ok = True
        message = 'Migration plan execution has started. You will receive an e-mail when it is terminated.'
        return executeMigrationPlan(ok=ok, message=message)
</code></pre>
<p><strong>File migration_script.py</strong></p>
<pre><code>class Migration():
    """Class to execute migration of Plan, Step, Object."""

    @staticmethod
    async def migrate(migration_plan, migration_step=None, migration_object=None):
        [...]

async def main(migration_plan, migration_step=None, migration_object=None):
    asyncio.ensure_future(Migration.migrate(migration_plan, migration_step, migration_object))
</code></pre>
<p>Basically I'm expecting to see the <code>print('Migration plan execution has started. You will receive an e-mail when it is terminated.')</code> almost instantly in my console window while the method <code>loop.run_until_complete(main(migration_plan))</code> but right now it's not the case and the print appears only at the end of the execution.</p>
<p><strong>[UPDATE]</strong></p>
<p>Following the answer of @Vincent below, I have updated the first file <strong>File mutation_migration_plan.py</strong> to use <strong>ThreadPoolExecutor</strong> and removed everything related to asyncio from both files.</p>
<p><strong>File mutation_migration_plan.py</strong></p>
<pre><code>from migration_script import Migration
from concurrent.futures import ThreadPoolExecutor
[...]

class executeMigrationPlan(graphene.Mutation):
    """Mutation to execute a migration plan."""
    [...]

    @staticmethod
    def mutate(root, info, input):
        [...]
        # Execute migration asynchronously
        print('Execute migration asynchronously')
        executor = ThreadPoolExecutor(max_workers=1)
        future = executor.submit(Migration.migrate, migration_plan)
        # print(future.result())
        print('Migration plan execution has started. You will receive an e-mail when it is terminated.')

        ok = True
        message = 'Migration plan execution has started. You will receive an e-mail when it is terminated.'
        return executeMigrationPlan(ok=ok, message=message)
</code></pre>
<p>My script runs fine when I add the <code>print(future.result())</code> line but it does not execute in background (makes sense since I'm trying to print the results). However, when I comment out the print, my method <code>Migration.migrate</code> does not seem to execute properly (I know it because I'm not seeing the results in my database). Any idea why?</p>
<p><strong>[UPDATE BIS]</strong></p>
<p><strong>File mutation_migration_plan.py</strong></p>
<p>I have been able to execute my method asynchronously using <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="nofollow noreferrer">ProcessPoolExecutor</a> and removing all references to asyncio on both files. See the following code:</p>
<p><strong>File mutation_migration_plan.py</strong></p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
[...]

class executeMigrationPlan(graphene.Mutation):
    """Mutation to execute a migration plan."""
    [...]

    @staticmethod
    def mutate(root, info, input):
        [...]
        # Execute migration asynchronously
        print('Execute migration asynchronously')
        executor = ProcessPoolExecutor()
        executor.submit(Migration.migrate, migration_plan.id)
        print('Migration plan execution has started. You will receive an e-mail when it is terminated.')

        ok = True
        message = 'Migration plan execution has started. You will receive an e-mail when it is terminated.'
        return executeMigrationPlan(ok=ok, message=message)
</code></pre>
<p>It's working but although the process executes in the backend, my Falsk app takes a very longtime to send the http response and the response is sometimes empty.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a common misconception, but you can't plug asyncio into an existing application and expect it to work. In asyncio, every blocking call must use the <code>await</code> syntax in the context of a coroutine. That's the only way it can achieve single-threaded concurrency. This means you would have to use <a href="https://aiohttp.readthedocs.io/en/stable/" rel="nofollow noreferrer">aiohttp</a> instead of flask, along with a library like <a href="https://github.com/graphql-python/aiohttp-graphql" rel="nofollow noreferrer">aiohttp-graphql</a>.</p>
<p>This would require a major rewrite of your application. If you don't want to go through that, there are other solutions that integrate well with flask. You could use <a href="http://flask.pocoo.org/docs/1.0/patterns/celery/" rel="nofollow noreferrer">celery</a> as pointed by @dirn, or one of the executors provided by <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">concurrent.futures</a>.</p>
</div>
<span class="comment-copy"><code>run_until_complete</code> is blocking. Youâ€™d be better off using something like Celery.</span>
<span class="comment-copy">@dirn thanks for the tip. Apparently Celery requires to install some message queue system like RabbitMQ or Redis. I'd like to avoid that. Would you know a way to do it with <code>ThreadPoolExecutor</code> by any chance?</span>
<span class="comment-copy">Threads would be another way that you could do this, so <code>ThreadPoolExecutor</code> should work.</span>
<span class="comment-copy">Thanks Vincent, I'll look into these packages.</span>
<span class="comment-copy">I'm able to trigger my method with the following lines of code <code>executor = ThreadPoolExecutor(max_workers=1)</code> and <code>future = executor.submit(Migration.migrate, migration_plan)</code> but then it's failing and I can't see the error message. I'm guessing because it's lacking some context info in the new thread. Do you know how I could catch the error?</span>
<span class="comment-copy">@Alexis.Rolland You can use <code>future.result()</code> to re-raise the exception in <code>future.exception()</code> (keep in mind that those methods will block if the job hasn't finished).</span>
<span class="comment-copy">It seems my method is properly executing (not async though) when I add <code>print(future.result())</code> or <code>print(future.exception())</code> (which is None), but as soon as I remove the print. It seems it does not execute.</span>
<span class="comment-copy">@Alexis.Rolland I would move the executor at class level (to make it global to your application) and wrap the job in a function that prints when it starts and when it finishes, possibly with an exception.</span>
