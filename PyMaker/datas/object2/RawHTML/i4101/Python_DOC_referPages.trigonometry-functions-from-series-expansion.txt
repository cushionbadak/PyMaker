<div class="post-text" itemprop="text">
<p>I am trying to write functions which emulate <code>math.sin</code> and <code>math.tan</code> but, instead of using the <code>math</code> library, performing the calculation using a series expansion.</p>
<p>The formulae are from Mathematics SE, <a href="https://math.stackexchange.com/questions/455870/how-would-you-calculate-the-tangent-without-a-calculator">How would you calculate the Tangent without a calculator?</a>:</p>
<blockquote>
<p>sin(x) = x − x^3/3! + x^5/5! −... </p>
<p>tan(x) = sin(x) / √(1 − sin(x)^2)</p>
</blockquote>
<p>This is my attempt, but I could not figure out how to perform the sign flipping <code>+</code> / <code>-</code> / <code>+</code> / ... part of the series expansion for <code>sin</code>:</p>
<pre><code>from math import factorial

res = 0
for i in [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]:
    res += 1**i/factorial(i)

print(res)  # 1.1752011936438016
</code></pre>
<p>The result is not correct because I have not applied a <code>+</code> / <code>-</code> switch. I could add an <code>if</code> / <code>else</code> clause but this seems messy. Is  there a better way?</p>
<p><em>Note</em>: This question is an embellished version of a <a href="https://stackoverflow.com/questions/50223025/how-to-write-my-own-implementation-of-tanx-in-python-where-x-is-the-radians">now deleted question</a> that was posted yesterday by @Lana.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid recalculating x**n and the factorial at each step by calculating the next term of the sum using the previous one:</p>
<pre><code>def sin2(x, n=20):
    curr =  x
    res = curr 
    for i in range(2, n, 2):
        curr *= - x**2/(i*(i+1))
        res += curr
    return res
</code></pre>
<p>Compared to jpp's version, it's about twice as fast:</p>
<pre><code>from math import factorial

def sin(x, n=20):
    return sum(x**j/factorial(j)*(1 if i%2==0 else -1)
               for i, j in enumerate(range(1, n, 2)))


%timeit sin(0.7)
# 100000 loops, best of 3: 8.52 µs per loop
%timeit sin2(0.7)
# 100000 loops, best of 3: 4.54 µs per loop
</code></pre>
<p>And it can get a bit faster if we calculate <code>- x**2</code> once and for all:</p>
<pre><code>def sin3(x, n=20):
    curr =  x
    res = 0
    minus_x_squared = - x**2
    for i in range(2, n, 2):
        res += curr
        curr *= minus_x_squared/(i*(i+1))
    return res

%timeit sin2(0.7)
# 100000 loops, best of 3: 4.6 µs per loop

%timeit sin3(0.7)
# 100000 loops, best of 3: 3.54 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are close. Below is one way using <code>sum</code> with <code>enumerate</code> for your series expansion.</p>
<p><code>enumerate</code> works by taking each value of an iterable and attaching an index, i.e. 0 for the first item, 1 for the second item, etc. Then we only need to test whether the index is even or odd and use a <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator" rel="nofollow noreferrer">ternary statement</a>.</p>
<p>In addition, you can use <code>range</code> instead of listing the odd numbers required in your expansion.</p>
<pre><code>from math import factorial

def sin(x, n=20):
    return sum(x**j/factorial(j)*(1 if i%2==0 else -1)
               for i, j in enumerate(range(1, n, 2)))

def tan(x):
    return sin(x) / (1-(sin(x))**2)**0.5

print(tan(1.2))  # 2.572151622126318
</code></pre>
<p>You can avoid the need for a ternary statement and <code>enumerate</code> altogether:</p>
<pre><code>def sin(x, n=20):
    return sum((-1)**i * x**(2*i+1) / factorial(2*i+1) for i in range(n))
</code></pre>
<p>If you write out the first few terms by hand, the equivalence will become clear.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>The sign of the <code>tan</code> function is only correct for 1st and 4th quadrants. This is consistent with the formulae you have provided. You can perform a trivial transformation to the input to account for this.</li>
<li>You can improve accuracy by increasing parameter <code>n</code>.</li>
<li>You can also calculate factorial without a library, but I'll leave that as an exercise.</li>
</ul>
</div>
<span class="comment-copy">@jezrael, Sure! Here you go.. <a href="https://meta.stackoverflow.com/questions/367892/what-to-do-when-a-high-reputation-user-answers-a-lot-of-duplicates" title="what to do when a high reputation user answers a lot of duplicates">meta.stackoverflow.com/questions/367892/…</a></span>
<span class="comment-copy">That is definitely much better! +1</span>
<span class="comment-copy">Ah, I was editing the same thing in mine :). But yes, definitely deserves +1.</span>
<span class="comment-copy">or you can just use <code>-1**(i%2)</code> instead of ternary. Because <i>-1^0 -&gt; 1</i> and <i>-1^1 -&gt; -1</i></span>
<span class="comment-copy">@Ev.Kounis wouldn't that make the output "technically" complex?</span>
<span class="comment-copy">Can also group adjacent pairs of terms with opposite sign to avoid the if-statement, e.g. <code>x - x^3/3!</code>, <code>x^5/5! - x^7/7!</code> ... <code>x^(2i - 1) / (2i - 1)! * (1 - x^2 / (2i * (2i + 1)))</code></span>
<span class="comment-copy">@meowgoesthedog Why would it? It is not <code>sqrt(-1)</code> we are doing, we are raising -1 to an integer power. The grouping idea is really nice too!</span>
<span class="comment-copy">@meowgoesthedog <code>type(-1**0)</code> returns <code>&lt;class 'int'&gt;</code>. So does <code>type(-1**1)</code></span>
