<div class="post-text" itemprop="text">
<p>I have a tuple that looks like:<br/>
<code>t=(('a','b'),('a','c','d','e'),('c','d','e'))</code></p>
<p>I need to rearrange it so I have a new tuple that will look like:<br/>
<code>t2=(('a','b'),('a','c'),('c','d'),('d','e'),('c','d'),('d','e'))</code></p>
<p>Basically the new tuple takes pairs (of 2) from each element of the old tuple. But I am not sure how to get started. Thanks for your help. </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this out :</p>
<pre><code> tuple([(t[i][j],t[i][j+1]) for i in range(len(t)) for j in range(len(t[i])-1)])
#[('a', 'b'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('c', 'd'), ('d', 'e')]
</code></pre>
<p>You can also try another way. If the problem is reduced to do this for one tuple alone :</p>
<pre><code>def pairs(my_tuple):
    return [(my_tuple[i],my_tuple[i+1]) for i in range(len(my_tuple)-1)]
</code></pre>
<p>Then this can be mapped for all the tuples </p>
<pre><code>tuple(sum(list(map(pairs,t)),[]))
#(('a', 'b'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('c', 'd'), ('d', 'e'))
</code></pre>
<p>Explanation :</p>
<pre><code>map(pairs,t)       : maps the function pairs for every element in tuple t
list(map(pairs,t)) : output of the above
                      But as a nested list 
                      [[[('a', 'b')], [('a', 'c'), ('c', 'd'), ('d', 'e')],...]
sum(list(...),[])   : Flattens out this nested list for the desired output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a generator expression with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to pair and convert to a <code>tuple</code> at the end:</p>
<pre><code>&gt;&gt;&gt; t = (('a','b'),('a','c','d','e'),('c','d','e'))
&gt;&gt;&gt; tuple((x) for tupl in t for x in zip(tupl, tupl[1:]))
(('a', 'b'), ('a', 'c'), ('c', 'd'), ('d', 'e'), ('c', 'd'), ('d', 'e'))                                               
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's what I came up with really quick</p>
<pre><code>def transform(t):
    out = []
    for tup in t:
        for i in range(0, len(tup) - 1):
            out.append((tup[i], tup[i+1]))
    return tuple(out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this easy to understand code:</p>
<pre><code>t = (('a','b'),('a','c','d','e'),('c','d','e'))
t2 = []
for i in t:
    for j in range(len(i)-1):
           t2.append((i[j], i[j+1]))
t2 = tuple(t2)
</code></pre>
<p>Obviously it isn't very optimized like other answers but for an easy understanding it will  be perfect.</p>
<p>That is something equivalent to:</p>
<pre><code>t2 = tuple((i[j], i[j+1]) for i in t for j in range(len(i)-1))
</code></pre>
<p>That is a generator expression, something quite similar to list comprehension (it use brackets instead of square brackets) and they basically do similar things, or at least in basic codes like this one. I still don't understand very well their differences but the generators are one-time fasters while the list comprehension are slower but reusable...</p>
<p>Nevermind: the generator means:</p>
<pre><code>t2 = tuple(...) # Make with the result array a tuple, otherwise it will be a list.
for i in t # Iterate over each item of t, they will by called i.
for i in t for j in range(len(i)) # Iterate over each item of t --called--&gt; i and then iterate over the range(len(i)) --called--&gt; j. 
(i[j], i[j+1]) for i in t for j in range(len(i)) # The same as before but each time we get a new j (each time the second loop iterate) do --&gt; (i[j], i[j+1])
</code></pre>
<p>I know, make two generator/list expression/comprehension on the same line is strange. I always look at <a href="https://stackoverflow.com/a/39870492">an answer like this one</a> to remember how to do that.</p>
<p>My old answer was:</p>
<pre><code>t = (('a','b'),('a','c','d','e'),('c','d','e'))
t2 = []
for i in t:
    for j in range(len(i)):
        if j &lt; len(i) - 1:
           t2.append((i[j], i[j+1]))
t2 = tuple(t2)
</code></pre>
<p>But I notice that adding a <code>-1</code> to the <code>len()</code> of the loop I can avoid that line, because I won't never get an out of index error.</p>
</div>
<span class="comment-copy">okay, great. Problem has been given. Where's the code?</span>
<span class="comment-copy">sorry I really don't know how to get started with code for this problem.</span>
<span class="comment-copy">Thanks! it worked out nicely!</span>
<span class="comment-copy">@CWeeks Made some new additions too :)</span>
<span class="comment-copy">@SruthiV <code>tuple(sum(list(map(pairs,t)),[]))</code> is not a very efficient way to flatten this: <code>tuple(y for x in map(pairs, t) for y in x)</code> would do the same without creating lots of intermediate lists.</span>
<span class="comment-copy">There is no need to use a list comprehension instead of just a generator expression in this case.</span>
<span class="comment-copy">@Vin√≠ciusAguiar nice! Thanks for the point.</span>
<span class="comment-copy">Very minor: you also don't need to unpack and then pack <code>x, y</code> - <code>x for tupl in t for x in zip(...)</code> would be sufficient.</span>
<span class="comment-copy">thanks for posting the answer!</span>
<span class="comment-copy">@AChampion that's even shorter now. Thanks for your comment.</span>
<span class="comment-copy">thanks for making the point for easy understanding!</span>
<span class="comment-copy">You are welcome! I will also add a bit better way but I will try to explain it</span>
<span class="comment-copy">You are missing your <code>for i in t:</code> loop in your initial explanation and old answer.</span>
<span class="comment-copy">@AChampion, ohh, silly of mine, I'm sorry.</span>
