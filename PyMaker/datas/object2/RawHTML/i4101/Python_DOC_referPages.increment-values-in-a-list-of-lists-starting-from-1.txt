<div class="post-text" itemprop="text">
<p>I have a list of lists e.g <code>[[0, 0], [4, 0], [2, 0], [5, 3], [0, 1]]</code></p>
<p>My desired output is <code>[[0, 0], [1, 0], [2, 0], [3, 4], [0, 5]]</code></p>
<p>That is, I wish to modify the list such that if the value is not zero, I set it to the count, which starts at 1 and increments by 1 for each non-zero value. If it's 0, I keep it as 0. </p>
<p>How do I go about this? I started by indexing using <code>enumerate</code> but it's harder than I thought.</p>
<p>Here is what I have done: <code>w</code> generates the initial list. This is not my full code because it is too long to post.</p>
<pre><code>w = [[i if i != l else 0 for i in x] for x in c]
print(w)
inc = 1
lx = []
gg = []
for i in w:
   if i[0] or i[1] !=0:
      g = w.index(i)
      gg.append(g)
      lx.append(i)
for x in gg:
   for i, v in enumerate(w):
       if x==i:
          if
          print(x, i, v)
</code></pre>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>This would also work, probably more pythonic and shorter, using a list-comprehension:</p>
<pre><code>from itertools import count

lst = [[0, 0], [4, 0], [2, 0], [5, 3], [0, 1]]
counter = count(1)

lst = [[next(counter) if x != 0 else 0 for x in sublst] for sublst in lst]
# [[0, 0], [1, 0], [2, 0], [3, 4], [0, 5]]
</code></pre>
<p>Learn more about how <code>itertools.count</code> works <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer">here</a>, meanwhile here is a small snippet for a better understanding:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; c = itertools.count(1)
&gt;&gt;&gt; next(c)
1
&gt;&gt;&gt; next(c)
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're over-complicating this. If either elem is 0, you don't need to touch it. If it's something else, increment the count and stick it in the right place.</p>
<pre><code>nums = [[0, 0], [4, 0], [2, 0], [5, 3], [0, 1]]
count = 0
for i,(a,b) in enumerate(nums):
  if a != 0:
    count += 1
    nums[i][0] = count
  if b != 0:
    count += 1
    nums[i][1] = count

print nums
</code></pre>
<p>Output:</p>
<pre><code>[[0, 0], [1, 0], [2, 0], [3, 4], [0, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your sublists are two element you can get rid of enumerate</p>
<pre><code>from itertools import count
counter = count(1)
lst = [[0, 0], [4, 0], [2, 0], [5, 3], [0, 1]]
for pair in lst:
    pair[0] = next(counter) if pair[0] else 0
    pair[1] = next(counter) if pair[1] else 0
print(lst)
</code></pre>
<p>For longer or variable sublists you may use either enumerate, map or list comprehension</p>
<pre><code>from itertools import count
counter = count(1)
lst = [[0, 0], [4, 0], [2, 0], [5, 3], [0, 1], [0, 1, 3, 3, 3], [3]]
for sublist in lst:
    sublist[:] = map(lambda x: (next(counter) if x else 0), sublist)
    # slice assignment is 'in-place' assignment



from itertools import count
counter = count(1)
lst = [[0, 0], [4, 0], [2, 0], [5, 3], [0, 1], [0, 1, 3, 3, 3], [3]]
for sublist in lst:
    for i, element in enumerate(sublist):
        sublist[i] = next(counter) if element else 0 
</code></pre>
</div>
<span class="comment-copy">are sublists always pairs or do you need handle arbitrary lists</span>
<span class="comment-copy">hmm sounds interesting. It will be worth knowing how you extend to arbitrary list of lists that are not pairs. Do you mind?</span>
<span class="comment-copy">@Starter See my answer. It works for arbitrary list of lists too.</span>
<span class="comment-copy">@Starter updated answer, though comperhension are often faster than map which is a relic of functional programming in Python. Google code style recommends against nested comprehensions. Not sure what is their stance on double map or mixing them with comprehensions.</span>
<span class="comment-copy">I upvoted yet think you need add assignment, the question was how to change the list</span>
<span class="comment-copy">@Serge Sure. I've made the changes now. Thanks for the note!</span>
<span class="comment-copy">Enumerate does help. Am trying to learn how it works. If you do not mind a little explanation of what you did will help. I understood perfectly what @pushkin did</span>
<span class="comment-copy">In most of cases enumerate is replacement for traditional from to loop. Python do no t have it for areason. Better just loop over elements, unless you can have resort to enumerate.</span>
<span class="comment-copy">ok, enumerate is great, just was extraneous in your code (for short sublists)</span>
