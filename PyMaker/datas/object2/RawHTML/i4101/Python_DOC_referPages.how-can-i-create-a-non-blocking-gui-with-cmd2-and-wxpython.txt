<div class="post-text" itemprop="text">
<h3>How can I create non-blocking <code>wxPython</code> GUI windows from a <code>cmd2</code> interpreter command even though both the interpreter and <code>wx.App</code> must be run on the main thread?</h3>
<hr/>
<p>I am creating a command-line interpreter in Python 3.x using the <code>cmd2</code> module. One command in my interpreter will allow me to create a "non-blocking" <code>wxPython</code> GUI window with a countdown timer that runs in a separate thread. It needs to run separately from the main interpreter thread because otherwise it will prevent entering additional commands while the timer runs.</p>
<p>When I try to use the <code>wxTimer</code> object to allow my GUI to update its progress bar and check the remaining time, I get the following error:</p>
<pre><code>wx._core.wxAssertionError: C++ assertion "wxThread::IsMain()" failed at ..\..\src\common\timerimpl.cpp(60) in wxTimerImpl::Start(): timer can only be started from the main thread
</code></pre>
<p>Any attempt to start the timer breaks the code. For example, the following simple code does not work:</p>
<pre><code>import wx
import threading
import cmd2

class TimerFrame(wx.Frame):
    def __init__(self, time):
        super().__init__(None, title=str(time), size=(300, 300))
        self.InitUI()

    def InitUI(self):
        self.timer = wx.Timer(self, 1)
        self.timer.Start(100)
        self.Bind(wx.EVT_TIMER, self.OnTimer, id=1)
        self.Show()

    def OnTimer(self, event):
        print("Updating")

class Interpreter(cmd2.Cmd):
    def __init__(self):
        super().__init__()
        self.app = wx.App()

    def do_timer(self, _):
        threading.Thread(target=self.createTimer, args=(self.app,)).start()

    def createTimer(self, app):
        TimerFrame("Window Title")
        app.MainLoop()

if __name__ == "__main__":
    Interpreter().cmdloop()
</code></pre>
<p>Note that commenting out the line containing <code>timer.Start(100)</code> allows windows to be created in separate threads successfully, but they lack the necessary <code>Timer</code> functionality.</p>
<hr/>
<p>Other things I have tried that do not work:</p>
<ul>
<li>Creating the <code>wx.App</code> in the new thread instead of passing it (results in the same error but for the <code>MainLoop</code> rather than <code>Timer</code>)</li>
<li>Creating the <code>wx.App</code> in the main thread and running its <code>MainLoop</code> there (blocks the command line from accepting further commands)</li>
<li>Running the interpreter command loop in a separate thread (complains that the <code>cmdloop</code> must be run from the main thread)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The docs have a section on <a href="https://cmd2.readthedocs.io/en/latest/integrating.html#integrating-cmd2-with-event-loops" rel="nofollow noreferrer">Integrating cmd2 with event loops</a>:</p>
<blockquote>
<p>Many Python concurrency libraries involve or require an event loop which they are in control of such as <code>asyncio</code>, <code>gevent</code>, <code>Twisted</code>, etc.</p>
</blockquote>
<p>While this is specifically talking about networking-focused event loops, it's actually the same issue with GUI event loops like wx's.</p>
<p>The tl;dr is that instead of calling <code>cmdloop()</code>, blocking the entire main thread until the interpreter exits, you just call <code>preloop()</code>, and then you repeatedly call <code>onecmd()</code> (or <code>onecmd_plus_hooks()</code> or <code>runcmd_plus_hooks()</code>, as appropriate) from a <code>wx</code> callback.</p>
<p>In other words, you drive the <code>cmd2</code> event loop from the <code>wx</code> one, so the <code>wx</code> loop can just take over the thread.</p>
<hr/>
<p><code>wx</code> also has a way of driving its event loop manually. See <a href="https://wxpython.org/Phoenix/docs/html/wx.EventLoopBase.html" rel="nofollow noreferrer"><code>wx.EventLoopBase</code></a> and related classes. (There's probably some good example code out there similar to the code in the <code>cmd2</code> docs, but you'd have to search for it.) The idea is pretty much the same: instead of running the <code>wx</code> loop and blocking the thread forever, you manually create a <code>wx.EventLoop</code> and <code>wx.EventLoopActivator</code>, and then you repeatedly call <code>while loop.Pending(): loop.Dispatch()</code> (and probably <code>app.ProcessIdle()</code>) from the <code>cmd2</code> event loop.</p>
<p>In other words, you drive the <code>wx</code> event loop from the <code>cmd2</code> one, so the <code>cmd2</code> loop can just take over the thread.</p>
<hr/>
<p>If neither of those work for you, you can probably use <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> instead of <code>threading</code>. That way, both event loops are running in the main thread—but one of them is just running in the main thread of a child process.</p>
<p>That can be a problem for GUI apps, so putting <code>wx</code> in the child process may not work (or, worse, may work on some platforms/setups but not others, or may work but mysteriously fail every so often…), but <code>cmd2</code> presumably only needs to see stdin/stdout/tty, so it probably will work.</p>
</div>
<span class="comment-copy">As for why it dies, the timer uses the timer signal and python restricts signals to the main thread.</span>
<span class="comment-copy">I ended up using <code>multiprocessing</code> for running the fairly simple Timer GUI in a child process (mostly to avoid large code refactoring). I have tested on Windows and OS X, and the performance is consistent. Thanks for the speedy and comprehensive response!</span>
<span class="comment-copy">@jstrieb My main worry was OS X (the application-vs.-process distinction, GUI APIs that hide communication with a window server, sandboxing stuff, etc.); if it works for you there, you should be fine.</span>
