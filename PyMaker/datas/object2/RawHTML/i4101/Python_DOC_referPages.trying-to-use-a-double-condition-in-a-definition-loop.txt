<div class="post-text" itemprop="text">
<p>Using the definition below for an array defined as being (a*b) in dimension where a and b are equal, let's say 20 for example. So a=b=20. A 20*20 matrix/array.</p>
<pre><code>import numpy as np
from numpy.linalg import inv
from scipy.stats import gmean

for n in range(20,21,1):

    X=np.random.uniform(-0.3,0.3,(n))
    Y=np.random.uniform(-0.3,0.3,(n))

    a,b=np.ogrid[-1:n-1:1,-1:n-1:1]

    def f(n, x, y):
        D=np.array(np.exp(1j*(5*np.pi/6)*np.abs((a+x)-(b+y))))
        D[diag,diag]=1-1j/np.sqrt(3)
        #this diag line is just to choose the diagonal elements specifically as they never change.
        return D

    Ddiff = np.abs(np.dstack(inv([f(n, x, y) for x,y in zip(X,Y)])))
    D2diff = gmean(Ddiff,axis=-1)
</code></pre>
<p>What I think this code is producing, is that for each time the function is called, it takes the first element of X and Y and uses through the whole iteration. So in this example n=20, so when I call the function it will produce an a*b array which is 20*20. I'd like that each element of X to match with a as it changes. i.e the first element of a and first element of X called at the same time, then when the second element of a is called the second element of X is called etc. Same with b and Y. this should produce a single 20*20 array when the function is called once where all values in X and Y are used. </p>
<p>Then I'd like to automate the code to call the function 500 times. Each time the function is called I need X and Y to generate new values. This way each time an array is produced, it will be different and I can use <code>np.dstack</code> to stack them and <code>gmean</code> to take a geometric average along the third axis (where the arrays are stacked).</p>
<p>The code so far produces a 20*20*20 array before using <code>gmean</code> so that's why i think it's using one element in the arrays X and Y each time the function runs. If it works as I hope it should produce a 20*20*500 array.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your intent correctly, you can achieve this with the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code> builtin</a>. </p>
<pre><code>Ddiff = np.dstack([f(n, x, y) for (x, y) in zip(X, Y)])
</code></pre>
<p>This should make one 20-long iterable from your 20-long <code>X</code> and your 20-long <code>Y</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I have since figured I was making life difficult for myself.</p>
<pre><code>import numpy as np
from numpy.linalg import inv
from scipy.stats import gmean

for n in range(20,21,1):

 X=np.random.uniform(-0.3,0.3,(n))
 Y=np.random.uniform(-0.3,0.3,(n))

 a,b=np.ogrid[-1:n-1:1,-1:n-1:1]

 def f(n, x, y):
     D=np.array(np.exp(1j*(5*np.pi/6)*np.abs((a+x)-(b+y))))
     D[diag,diag]=1-1j/np.sqrt(3)
     #this diag line is just to choose the diagonal elements specifically as they never change.
     return D

 Ddiff = np.abs(np.dstack(inv([f(n, x, y) for x,y in zip(X,Y)])))
 D2diff = gmean(Ddiff,axis=-1)
</code></pre>
<p>I've moved the <code>X</code> and <code>Y</code> arrays inside the function so each time it's called, a new <code>X</code> and <code>Y</code> are called too. I also specified the element to call just using <code>a</code> and <code>b</code> seeing as they are integers anyway. Then I just use a dummy index to call the function 500 times.</p>
<pre><code>def f(n):
    X=np.random.uniform(-0.3,0.3,(n))
    Y=np.random.uniform(-0.3,0.3,(n))
    D=np.array(np.exp(1j*(5*np.pi/6)*np.abs((a+X[a])-(b+Y[b]))))
    D[diag,diag]=1-1j/np.sqrt(3)
    return D

Ddiff = np.abs( np.dstack( inv(
                                [f(n) for _ in range(500)]
                              )
                         )
              )
D2diff = gmean(Ddiff,axis=-1)
</code></pre>
</div>
<span class="comment-copy">Can you rearrange the code snippets to be one runnable block? We call that a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">For your understanding: The line <code>Ddiff = np.dstack([f(n, x, y) for x in X and y in Y])</code> is interpreted as <code>Ddiff = np.dstack([f(n, x, y) for x in (X and (y in Y))])</code> so the interpreter tries to get a boolean value for the <code>X</code> before the <code>and</code>.  Reducing an np-array to a single boolean value isn't  possible, and that's what the error messages tries to convey.</span>
<span class="comment-copy">I don't understand what you mean with "generate 20 different values of x and y".  Can you write some pseudo-code which explains to us what you mean?</span>
<span class="comment-copy">@Alfe For clarity when the code calls the definition, it needs to generate a 20*1 array <code>X</code> (where each value is random between -0.3,0.3) and a 20*1 array <code>Y</code> (where each value is random and between -0.3,0.3 also) and each time the function is repeated, a new array <code>X</code> is created with 20 new values and the same for <code>Y</code>. For example, having <code>X=np.random.uniform(-0.3,0.3,(20))</code> inside the function. My trouble is I can't then get the code to call the function 500 times, only as many times as the arrays <code>X</code> and <code>Y</code> have values. I'll rewrite the question now to provide one runnable block.</span>
<span class="comment-copy">I'm not sure if this is what OP wants.  Where's the "repeat the function 500 times" part in this answer?</span>
<span class="comment-copy">Granted, the 500 didn't show up in the code of the question, either.</span>
<span class="comment-copy">Yup, Q needs improvement.</span>
