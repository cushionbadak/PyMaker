<div class="post-text" itemprop="text">
<p>What i would like to do is to initialize an array which has 5 elements set to 0 and then copy the other array to the first one, something like this:</p>
<pre><code>a = [0, 0, 0, 0, 0]
b = [1, 2, 3]
print a | b
[1, 2, 3, 0, 0]
</code></pre>
<p>Is there any pythonic way in doing so except:</p>
<pre><code>for i, x in enumerate(b):
    a[i] = x
</code></pre>
<p><strong>Edit:</strong></p>
<p>I forgot to mention that buffer <code>a</code> will always be filled with plain zeroes at the beginning and condition <code>len(b) &lt; len(a)</code> is always <code>true</code>, also in each case buffer <code>a</code> will always start getting overwritten from index <code>0</code>.</p>
<p>Ill explain why i need this kind of behaviour in the first place, basicly I have a raw 256-byte UDP frame. Buffer <code>a</code> corresponds to bytes 16-31 in the frame. Depending on some conditions, those bytes will either be overwritten or be set at 0, length of <code>b</code> is always 12.</p>
<pre><code>def foo(b=12*[0]):
    a = 16*[0]
    return a[:12] = b[:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a[:len(b)] = b[:]
&gt;&gt;&gt; a
[1, 2, 3, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works in Python 2:</p>
<pre><code>import itertools
a = [0, 0, 0, 0, 0]
b = [1, 2, 3]
g = (l | r for (l, r) in itertools.izip_longest(a, b, fillvalue=0))
print list(g)
</code></pre>
<p>And this in Python 3:</p>
<pre><code>import itertools
a = [0, 0, 0, 0, 0]
b = [1, 2, 3]
g = (l | r for (l, r) in itertools.zip_longest(a, b, fillvalue=0))
print(list(g))
</code></pre>
<p>I created a generator <code>g</code> but if you know in advance you want all values of it already, then it's okay to have a list comprehension right away instead.</p>
<p>This is the doc for <code>zip_longest</code>: <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.zip_longest</a></p>
<p>Directly with the list comprehension (py3):</p>
<pre><code>import itertools
a = [0, 0, 0, 0, 0]
b = [1, 2, 3]
g = [l | r for (l, r) in itertools.zip_longest(a, b, fillvalue=0)]
print(g)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why waste time defining <code>a</code> in the first place? You can simply append the correct number of <code>0</code>s to <code>b</code> instead:</p>
<pre><code>&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a = b + [0] * (5 - len(b))
&gt;&gt;&gt; a
[1, 2, 3, 0, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Something like this (Note: XOR operator is <code>^</code> ?</p>
<pre><code>import itertools

a = [0, 0, 0, 0, 0]
b = [1, 2, 3]

def safeXOR(arr1, arr2):
    return list((x ^ y for (x, y) in itertools.zip_longest(arr1, arr2, fillvalue=0)))

print(safeXOR(a,b))
</code></pre>
</div>
<span class="comment-copy">What output do you expect for <code>a = [0, 1, 0, 0, 0]</code>?</span>
<span class="comment-copy">Hope 'edit' section clarifes a little bit :)</span>
<span class="comment-copy">I don't think that works. What if <code>a = [0, 1, 0, 0, 0]</code> ? Your output would also be <code>[1, 2, 3, 0, 0]</code>. But <code>[1, 1, 3, 0, 0]</code> would probably be the correct answer. At least that is how I understand the question.</span>
<span class="comment-copy">@miindlek: The question has conflicting criteria. I decided to fulfill the "copy the other array to the first one" criterion based on the second snippet.</span>
<span class="comment-copy">why not make <code>g</code> a listcomp?</span>
<span class="comment-copy">@e.s. You were faster than my edit :-). I explained in here the reason. I'll edit again to make it more obvious.</span>
<span class="comment-copy">And I realized that my answer is about the title of the question, whereas @Ignacio Vazquez-Abrams 's answer is closer the the actual needs.</span>
<span class="comment-copy">@SamuelGIFFARD Maybe the title of the question should be edited so it matches the OP's actual question. Otherwise it will mislead future readers.</span>
