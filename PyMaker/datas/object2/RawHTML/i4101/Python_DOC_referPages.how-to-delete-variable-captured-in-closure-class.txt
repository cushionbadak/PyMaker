<div class="post-text" itemprop="text">
<p>See the following two functions, the first one returns a function closure, the second one a "class closure". <code>objects</code> is used to track the created objects. In both cases an instance of <code>MyObject</code> is captured in the closure.</p>
<pre><code>import weakref

class MyObject(object):
    pass

def leak1():
    obj = MyObject()
    objects[id(obj)] = weakref.ref(obj)

    def inner():
        return obj

    return inner

def leak2():
    obj = MyObject()
    objects[id(obj)] = weakref.ref(obj)

    class Inner(object):

        __slots__ = () # edit

        def __call__(self):
            return obj

        #def __del__(self):
        #   nonlocal obj
        #   del obj

    return Inner()

def print_all_objects(s):
    for id, ref in objects.items():
        print(s, id, ref())

for leak in (leak1, leak2):
    print(leak.__name__)
    objects = {}
    a = leak()
    print_all_objects(1)
    del a
    print_all_objects(2)
</code></pre>
<p>If you run this, you get the following output:</p>
<pre><code>leak1
(1, 54150256L, &lt;__main__.MyObject object at 0x00000000033A4470&gt;)
(2, 54150256L, None)
leak2
(1, 54150256L, &lt;__main__.MyObject object at 0x00000000033A4470&gt;)
(2, 54150256L, &lt;__main__.MyObject object at 0x00000000033A4470&gt;)
</code></pre>
<p>That means in the first case <code>obj</code> is deleted after the function closure is deleted (which is what I expected).
In the second case however <code>obj</code> is never deleted. This can be fixed in Python 3 by using <code>nonlocal</code> and <code>__del__</code>, but not in Python 2.7 as <code>nonlocal</code> does not exist.</p>
<p>So my question: Why is the captured variable not deleted in the case of the class; and: how can I delete it in Python 2.7 without using some weird tracking mechanism using <code>weakref</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't have to do anything.</p>
<p>CPython uses a combination of reference counting and a garbage collector to dispose of unneeded objects. In the first case, deleting the closure with <code>del a</code> reduces the refcount of the leaked object to 0 and it is immediately disposed. In the second case, there is a reference cycle between the <code>Inner</code> class, its <code>__call__</code> method, and <code>obj</code>. This reference cycle prevents the refcount from dropping to 0, so the closure isn't <em>immediately</em> deleted. But once the garbage collector starts its next collection cycle, the closure <em>will</em> be disposed of.</p>
<p>If you want to delete the closure immediately, you can manually trigger the garbage collection with <a href="https://docs.python.org/3/library/gc.html#gc.collect" rel="nofollow noreferrer"><code>gc.collect()</code></a>:</p>
<pre><code>import gc

for leak in (leak1, leak2):
    print(leak.__name__)
    objects = {}
    a = leak()
    print_all_objects(1)
    del a
    gc.collect()  # &lt;- add this
    print_all_objects(2)
</code></pre>
<p>Output:</p>
<pre><code>leak1
1 140591616726800 &lt;__main__.MyObject object at 0x7fde095f9710&gt;
2 140591616726800 None
leak2
1 140591619339880 &lt;__main__.MyObject object at 0x7fde09877668&gt;
2 140591619339880 None
</code></pre>
</div>
<span class="comment-copy">The standard trick is to set <code>obj_wrap = [obj]</code> outside, then you can use <code>return obj_wrap[0]</code> and <code>obj_wrap[0] = None</code> inside to modify the outer variable.</span>
<span class="comment-copy">I accepted your answer, however I am still not clear why there is a ref circle. Why does <code>obj</code> hold any references, and why does it not do so in case of a normal function?</span>
<span class="comment-copy">@C.Yduqoli The reference cycle is actually just the <code>Inner</code> class holding a reference to itself through its <code>__dict__</code>. I don't know <i>why</i> the <code>__dict__</code> has a reference to the class, but that's how it is. So since the class is kept alive by this reference cycle, it also keeps the <code>__call__</code> method alive, which in turn keeps <code>obj</code> alive.</span>
<span class="comment-copy">If I use <code>__slots__</code> to make the <code>__dict__</code> go away, the circle is still there...</span>
<span class="comment-copy">@C.Yduqoli I can't reproduce that.</span>
<span class="comment-copy">@C.Yduqoli I'm not sure, but I <i>think</i> the class is referencing itself in its <a href="https://docs.python.org/3/glossary.html#term-method-resolution-order" rel="nofollow noreferrer">MRO</a>: Printing <code>Inner.__mro__</code> gives you <code>(&lt;class '__main__.leak2.&lt;locals&gt;.Inner'&gt;, &lt;class 'object'&gt;)</code>. If that's not a weak reference (or dynamically generated), then you won't be able to write a class that <i>doesn't</i> have a reference cycle.</span>
