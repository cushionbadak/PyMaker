<div class="post-text" itemprop="text">
<p>I got a huge list of object: (about 500k elts).</p>
<pre><code>class Signal:
    def __init__(self, fq, t0, tf):
        self.fq = fq
        self.t0 = t0
        self.tf = tf

    def __eq__(self, s):
        """ == comparison method."""
        return self.fq == s.fq

    def __ne__(self, s):
        """ != comparison method."""
        return not self.__eq__(self, s)

t0, tf = 0, 200
signals = [[S(f1, t0, tf), S(f2, t0, tf), S(f3, t0, tf), S(f4, t0, tf), S(f5, t0, tf), S(f6, t0, tf)] 
            for f1 in frequencies for f2 in frequencies for f3 in frequencies for f4 in frequencies
            for f5 in frequencies for f6 in frequencies]
</code></pre>
<p>My program maps the list and generates <code>.pkl</code> files with a specific name for each element of the list.</p>
<pre><code>def file_namer(signals):
    frequencies = tuple([s.fq for s in signals])
    return "F{}.pkl".format(frequencies)
</code></pre>
<p>Some of the elements from the list were already computed, OR, a permutation of this element was computed, thus I would like to delete them before mapping.</p>
<pre><code>import itertools
import os

folder = "folder_of_the_pkl"
files = os.listdir(folder)

def is_computed(files, s):
    possibilities = list()
    for elt in itertools.permutations(s):
        possibilities.append(file_namer(s))

    if any([name in files for name in possibilities]):
        return True
    else:
        return False

s_to_remove = list()
for s in signals:
    if is_computed(files, s):
        s_to_remove.append(s)

for elt in s_to_remove:
    signals.remove(elt)
</code></pre>
<p>That is what I come up with. It is fairly not efficient, and I'd be glad to see your proposition to improve this!</p>
<p>Thanks!</p>
<p>N.B: This is a fairly simplified version of my program. The objects are far heavier (10+ parameters).</p>
</div>
<div class="post-text" itemprop="text">
<p>First, if you have so many of your objects you may want to consider <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">slots</a>, <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a>s, <a href="https://pandas.pydata.org/pandas-docs/stable/dsintro.html" rel="nofollow noreferrer">pandas dataframes</a> or <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ndarray.html" rel="nofollow noreferrer">numpy ndarray</a>s. This would reduce the cost of each item considerably, removing per-object dictionaries or even per-row object metadata. </p>
<p>Second, removing items from an array is a costly operation involving moving all the items following it. This applies to Python's lists when using del or remove; even worse with the latter, it has to find the item first, so you're reading the whole array and rewriting part of it for every item you remove. At that point it's better to build a copy containing the items you keep instead. Another option is to replace the irrelevant items with placeholders such as None, an operation that doesn't require moving other entries. </p>
<p>Third, it is frequently more efficient to not build your collections at all. Consider: </p>
<pre><code>def is_computed(files, s):
    possibilities = list()
    for elt in itertools.permutations(s):
        possibilities.append(file_namer(s))

    if any([name in files for name in possibilities]):
        return True
    else:
        return False
</code></pre>
<p>In this code, you construct a (likely large) list named possibilities, grow it by consuming a permutations iterator in a for loop and calling file_namer for each item (not even passing that item!), then build another list of whether each possibility was already in files, and finally apply any() to that list for a result. That's at least two passes over the entire collection of possibilities for an answer that might have only needed to inspect one. I'm not sure the first loop even needs to exist, and the <a href="https://docs.python.org/3/reference/expressions.html#list-displays" rel="nofollow noreferrer">list comprehension</a> should certainly be a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> to allow the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer">any</a> function to shortcut. So, assuming there are no side effects hidden in file_namer etc, we could simplify the entire function to:</p>
<pre><code>def is_computed(files, s):
    return file_namer(s) in files
</code></pre>
<p>But if file_namer(s) should really be file_namer(elt), as I would expect, it should be:</p>
<pre><code>def is_computed(files, s):
    return any(file_namer(elt) in files
               for elt in itertools.permutations(s))
</code></pre>
<p>Another concern, since we're looking at repeated <code>in</code> tests for <code>files</code>, is that we should probably make sure that's a <code>set</code>, <code>dict</code> or other type with quick <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer">membership tests</a>. This would be the point where Dan D's suggestion of sorting instead of repeatedly generating permutations applies. For instance, you could have an index of the lowest-valued (sorted) permutation to the actual object stored in a dictionary. If for some reason you can't make the keys hashable, you might be able to use <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer">binary searches</a> if they're sortable. </p>
<p>That's what came to mind at the moment. I haven't read thoroughly. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest that you don't remove from the list. Build another:</p>
<pre><code>signals_ = list()
for s in signals:
    if not is_computed(files, s):
        signals_.append(s)

signals = signals_
</code></pre>
<p>Then I would look at your <code>is_computed</code> function and see if one can avoid building the list of possibilities:</p>
<pre><code>def is_computed(files, s):
    for elt in itertools.permutations(s):
        name = file_namer(s)
        if name in files:
           return True

    return False
</code></pre>
<p>The test: <code>name in files</code> would be faster if <code>files</code> is a <code>set</code>.</p>
<p>Better still:</p>
<p>Parse each of the filenames such as this one:</p>
<pre><code>&gt;&gt;&gt; "F{}.pkl".format((1,2,3))
'F(1, 2, 3).pkl'
</code></pre>
<p>Back into the tuple:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval('F(1, 2, 3).pkl'[1:].split('.')[0])
(1, 2, 3)
</code></pre>
<p>Then you can <em>avoid the permutations call</em> by sorting <code>(1,2,3)</code> and <code>(2,3,1)</code>: </p>
<pre><code>&gt;&gt;&gt; sorted((1,2,3)) == sorted((2,3,1))
True
</code></pre>
<p>Into the same order and then comparing the sorted versions. </p>
<p>So to extend this to a <code>is_computed</code> replacement, files is turned from <code>['F(1, 2, 3).pkl']</code> into <code>{(1, 2, 3):'F(1, 2, 3).pkl'}</code> then <code>is_computed</code> becomes:</p>
<pre><code>files = { tuple(sorted(ast.literal_eval(name[1:].split('.')[0]))): name 
          for name in files }

def is_computed(files, signal):
    name = tuple(sorted(s.fq for s in signal))
    return name in files
</code></pre>
</div>
<span class="comment-copy">Thanks for both of your answers really helpfull. Aside from the proposition of sorting the permutation which I can't implement for several reasons, the rest seems great and promising! I'll test it soon, thanks for all the enlightment !</span>
