<div class="post-text" itemprop="text">
<p><code>func</code> can refer it itself if <code>func</code> is a global function.</p>
<pre><code>def func(y):
    result = func.x + y
    # `func.x` does not raise an errors
    return result   
func.x = 5  

func(100)
</code></pre>
<p>However, it seems that a class method cannot refer to itself:</p>
<pre><code>class K:        
    def mthd(self, y):
        return mthd.x + y
    mthd.x = 5

K.mthd() # raises an exception
</code></pre>
<p>The exception raised is a <code>NameError</code>:</p>
<pre><code>[Drive Letter]:\[path]
Traceback (most recent call last):
  File "[Path]/[filename].py", line 35, in &lt;module&gt;
    K.mthd()
  File "[Path]/[filename].py", line 40, in mthd
    return mthd.x + y
NameError: name 'mthd' is not defined

Process finished with exit code 1
</code></pre>
<p>Why is this?</p>
<p>Is it because <code>"func"</code> is in <code>globals</code> whereas <code>"mthd"</code> is in <code>K.__dict__</code>?</p>
<p>functions can refer to variables outside of themselves, such as:</p>
<pre><code>x = 3
def f():
    print(x)
</code></pre>
<p>Is the error caused because <code>K.mthd</code> has access to the names <code>locals</code> and <code>globals</code>, but not <code>K.__dict__</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>func</code> is a global name, <code>mthd</code> is not. Methods are an attribute on the <em>class object</em>, which <em>is</em> available as a global:</p>
<pre><code>K.mthd.x
</code></pre>
<p>In the <code>class</code> body (suite) itself, <code>mthd</code> is a local name; at the end of the <code>class</code> statement all locals are taken to form the class body; once the class is created, the local names are no longer available.</p>
<p>From the <a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer"><em>Class definitions</em> section of the Python reference documentation</a>:</p>
<blockquote>
<p>The class’s suite is then executed in a new execution frame <em>[...]</em>, using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved. A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.</p>
</blockquote>
<p>So in your code, the line <code>mthd.x = 5</code> is analogous to accessing locals in a function body. Just like <code>result</code> is not available outside of the <code>func()</code> function scope, <code>mthd</code> is not available outside of the namespace available during class creation.</p>
<p>The <code>class</code> suite can otherwise refer to globals just fine, as can methods:</p>
<pre><code>&gt;&gt;&gt; x = 42
&gt;&gt;&gt; class Demo:
...     print('Class body, globals are available, like x =', x)
...     def method(self):
...         print('Method body, globals are available, like x =', x)
...
Class body, globals are available, like x = 42
&gt;&gt;&gt; Demo().method()
Method body, globals are available, like x = 42
</code></pre>
</div>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/707380/in-python-how-can-i-access-static-class-variables-within-class-methods">How can I access “static” class variables within class methods</a></span>
