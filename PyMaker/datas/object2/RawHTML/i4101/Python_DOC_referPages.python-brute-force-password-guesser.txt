<div class="post-text" itemprop="text">
<p>I am doing a task in class about a password guesser. I stumbled into a lot of problems trying to solve this task, my first approach was to use for loops (code below), but I realized that the amount of 'for loops' is equal to the length of the string.</p>
<pre><code>a_z = 'abcdefghijklmnopqrstuvwxyz'
pasw = 'dog'
tests = 0
guess = ''
azlen = len(a_z)

for i in range(azlen):
    for j in range(azlen):
        for k in range(azlen):
            guess = a_z[i] + a_z[j] + a_z[k]
            tests += 1
            if guess == pasw:
                print('Got "{}" after {} tests'.format(guess, str(tests)))
                break

input()
</code></pre>
<p>The program above is very concrete. It only works if there are exactly 3 characters entered. I read that you could use a package called intertools, however, I really want to find another way of doing this. I thought about using recursion but don't even know where to start.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use <code>itertools</code> you can certainly do this with recursion, which will work with passwords of any (reasonable) lengthâ€”it's not wired to three characters.  Basically, each recursive call will attempt to append a new character from your alphabet to your running value of guess. The base case is when the guess attains the same length as value you're seeking, in which case you check for a match. If a match is found, return an indication that you have succeeded (I used <code>return True</code>) so you can short circuit any further searching.  Otherwise, return a failure indication (<code>return False</code>). The use of a <code>global</code> counter makes it a bit uglier, but produces the same results you reported.</p>
<pre><code>ALPHABET = 'abcdefghijklmnopqrstuvwxyz'

def brute_force_guesser(passwd, guess = ''):
    global _bfg_counter
    if len(guess) == 0:
        _bfg_counter = 0
    if len(guess) == len(passwd):
        _bfg_counter += 1
        if guess == passwd:
            print('Got "{}" after {} tests'.format(guess, str(_bfg_counter)))
            return True
        return False
    else:
        for c in ALPHABET:
            if brute_force_guesser(passwd, guess + c):
                return True
        return False

brute_force_guesser('dog')    # =&gt; Got "dog" after 2399 tests
brute_force_guesser('doggy')  # =&gt; Got "doggy" after 1621229 tests
</code></pre>
<p>One way to avoid the global counter is by using multiple return values:</p>
<pre><code>ALPHABET = 'abcdefghijklmnopqrstuvwxyz'

def brute_force_guesser(target, guess = '', counter = 0):
    if len(guess) == len(target):
        counter += 1
        if guess == target:
            print('Got "{}" after {} tests'.format(guess, str(counter)))
            return True, counter
        return False, counter
    else:
        for c in ALPHABET:
            target_found, counter = brute_force_guesser(target, guess + c, counter)
            if target_found:
                return True, counter
        return False, counter

brute_force_guesser('dog')    # =&gt; Got "dog" after 2399 tests
brute_force_guesser('doggy')  # =&gt; Got "doggy" after 1621229 tests
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import string
import itertools

for possible_password in itertools.permutations(string.ascii_letters, 3): 
    print(possible_password)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, Thanks everyone I figured it out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my full answer, sorry if it's not neat, I'm still new to coding in general. The credit goes to @JohnColeman for the great idea of using bases. </p>
<pre><code>import math
global guess

pasw = str(input('Input password: '))
chars = 'abcdefghijklmnopqrstuvwxyz' #only limeted myself to lowercase for simplllicity.
base = len(chars)+1

def cracker(pasw):
    guess = ''
    tests = 1
    c = 0
    m = 0

    while True:
        y = tests
        while True:
            c = y % base
            m = math.floor((y - c) / base)
            y = m
            guess = chars[(c - 1)] + guess
            print(guess)
            if m == 0:
                break

        if guess == pasw:
            print('Got "{}" after {} tests'.format(guess, str(tests)))
            break
        else:
            tests += 1
            guess = ''


cracker(pasw)
input()
</code></pre>
</div>
<span class="comment-copy">Why use indices at all? You can use things like <code>for c in a_z:</code> directly rather than the cumbersome two step process <code>for i in len(a_z):</code> followed by <code>a_z[i]</code> in the body of the loop. For your more general question, recursion is natural, but you could also use simple iteration. If you have a list of all passwords of a given length, can you modify it to get all passwords of that length + 1? This will run into memory problems sooner or later, but your code isn't practical to begin with.</span>
<span class="comment-copy">Thanks for the advice, really appreciate it, @John Coleman. Yeah, I am still new to python. I know about the memory problems. So do you know of a way to implement recursion?</span>
<span class="comment-copy">For recursion: write a function something like <code>passwords(n)</code> which gives a list or preferably a generator of all passwords of length <code>n</code>. What is the basis case? In the non-basis case, how would you use <code>passwords(n-1)</code> to generate the passwords of length <code>n</code>?</span>
<span class="comment-copy">A radically different but surprisingly easy approach: just count from <code>0</code> to <code>26^N-1</code> in base 26 -- using <code>a,b,...,z</code> as the "digits". You learned to count in elementary school -- just extend that knowledge to a different digit set.</span>
<span class="comment-copy">Okay, I kind of understand. I am struggling with the generation part. I was thinking about using an array <code>guess = ['a', 'a', 'a']</code> with the amount of elements equal to the length of the input. Then I thought to change <code>guess[-1]</code> to the next letter thus cycling through aab, aac, etc. but to change <code>guess[-2]</code> and then go back to <code>guess[-1]</code> to go from aaz to aba is where I get confused.</span>
<span class="comment-copy">That Is a really good way of thinking about it @pjs. I apologize for the late reply, however, I did find a solution but there is a simple error that I can not find.</span>
<span class="comment-copy">Thanks for the help man. But is there any other way, like not using intertools or something?</span>
<span class="comment-copy">Why don't you want to use <code>itertools</code>? It's built-in</span>
<span class="comment-copy">I know that its much easier and faster, our teacher asked us to come up with an alternative way of doing it and this is the closest I got so far.</span>
<span class="comment-copy">You can take a look directly at the python documentation for <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">itertools.permutations</a>. It contains an example of a function which produces similar results. I wouldn't use it in any homework without citing it though.</span>
<span class="comment-copy">Yea, I hope your teacher tell you it's only for learning purpose, because first rule of the developer is: Use libraries, especially built-in ones</span>
