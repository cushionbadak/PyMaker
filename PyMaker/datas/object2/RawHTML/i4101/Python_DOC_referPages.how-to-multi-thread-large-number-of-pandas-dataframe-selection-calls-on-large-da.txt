<div class="post-text" itemprop="text">
<p>df is a dataframe containing 12 millions+ lines unsorted.
Each row has a GROUP ID.</p>
<p>The end goal is to randomly select 1 row per unique GROUP ID, thus populating a new column named SELECTED where 1 means selected 0 means the opposite</p>
<p>There may be 5000+ unique GROUP IDs.
Seeking better and faster solution than the following, Potentially multi-threaded solution?</p>
<pre><code>for sec in df['GROUP'].unique():
    sz = df.loc[df.GROUP == sec, ['SELECTED']].size
    sel = [0]*sz
    sel[random.randint(0,sz-1)] = 1
    df.loc[df.GROUP == sec, ['SELECTED']] = sel
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try a vectorized version, which will probably speed things up if you have many classes.</p>
<pre><code>import pandas as pd

# get fake data
df = pd.DataFrame(pd.np.random.rand(10))
df['GROUP'] = df[0].astype(str).str[2]

# mark one element of each group as selected
df['selected'] = df.index.isin(    # Is current index in a selected list?
        df.groupby('GROUP')        # Get a GroupBy object.
        .apply(pd.Series.sample)   # Select one row from each group.
        .index.levels[1]           # Access index - in this case (group, old_id) pair; select the old_id out of the two.
        ).astype(pd.np.int) # Convert to ints.
</code></pre>
<p>Note that this may fail if duplicate indices are present.</p>
</div>
<div class="post-text" itemprop="text">
<p>I do not know panda's dataframe, but if you simply set selected where it is needed to be one and later assume that not having the attribute means not selected you could avoid updating all elements.</p>
<p>You may also do something like this :</p>
<pre><code>selected = []
for sec in df['GROUP'].unique():
    selected.append(random.choice(sec))
</code></pre>
<p>or with list comprehensions</p>
<pre><code>selected = [random.choice(sec) for sec in  df['GROUP'].unique()]
</code></pre>
<p>maybe this can speed it up because you will not need to allow new memory and udpate all elements from your dataframe.</p>
<p>If you really want multithreading have a look at concurrent.futures <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">https://docs.python.org/3/library/concurrent.futures.html</a></p>
</div>
<span class="comment-copy">Thank you. It seems to work and much faster compared to the old method. Could you do a bit stepwise explanation of this 1 liner.</span>
<span class="comment-copy">I added some comments. The idea is to construct a series of sampled IDs, and then check if each of the original IDs is in the series.</span>
<span class="comment-copy">Thank you, again. Your comments are very helpful.</span>
