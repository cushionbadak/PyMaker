<div class="post-text" itemprop="text">
<p>I am trying to make a network proxy which will forward packets to another IP. I can sniff a packet, unpack it, and view, print, and manipulate its contents. But when I want to pack the bytes to forward it to some other IP, it gives this error:</p>
<blockquote>
<p>struct.error: required argument is not an integer</p>
</blockquote>
<p>The error is raised on this line of code:</p>
<pre><code>ip_header = struct.pack('!BBHHHBBH4s4s' ,version_IHL, TOS, totalLength, ID,flags, TTL,protocolNR, checksum,sourceAddress,destinationAddress)
</code></pre>
<p>Here is the code. Bold stuff in code are comments in my code.</p>
<pre><code>import socket
import sys
import struct
import re
import logging
import struct
from scapy.all import *
import Functions
logging.basicConfig(filename='example.log',level=logging.DEBUG)

hold = "192.168.0.125"

print ("\n\t\t\t**************************")
print ("\t\t\t*****SettingUp Server*****")
print ("\t\t\t**************************\n\n")
print("\t*****Implementing DHKE")
print ("\t*****Generating server public &amp; private keypairs now . . .")
(e,n), private = Functions.generate_keypair(7, 11)
print ("*****Public Key: {} , {} ", e,n)
print ("*****Private key: {} ", private)
public = (e,n)
ip = '192.168.0.125'
port = 5001

# the public network interface
#HOST = socket.gethostbyname(socket.gethostname())
#..............................................................................................
# create a raw socket and bind it to the public interface
s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)
s.bind(('192.168.0.117',5001))

# Include IP headers
s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)

logging.basicConfig(format='%(asctime)s %(message)s')
logging.warning('format=%(asctime)s %(message)s')

# receive all packages
s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)

#..............................................................................................
data = Functions.recievedata(s)
logging.info('**Packet Recieved')
print("Packet Recieved")

#function_data = tuple(struct.unpack(data))
unpacked_data = struct.unpack('!BBHHHBBH4s4s',data[:20])
listunpacked = list(unpacked_data)
logging.info('--&gt; Unpacking packet')
version_IHL = unpacked_data[0]
version = version_IHL &gt;&gt;4
IHL = version_IHL &amp; 0xF
TOS = unpacked_data[1]
totalLength = unpacked_data[2]
ID = unpacked_data[3]
flags = unpacked_data[4]
fragmentOffset =  unpacked_data[4] &amp;  0x1FFF
TTL = unpacked_data[5]
protocolNR = unpacked_data[6]
checksum = unpacked_data[7]
sourceAddress = socket.inet_ntoa(unpacked_data[8])
destinationAddress = socket.inet_ntoa(unpacked_data[9])



#..............................................................................................
print("An IP packet with the size %i is captured.", (totalLength))
print("Raw data: "+ str(data))
print("\nParsed data")
print("Version:\t\t"+ str(version))
print("Header length:\t\t"+ str(IHL*4)+'bytes')
print("Type of service:\t\t" + str(Functions.getTOS(TOS)))
print("Length:\t\t\t"+str(totalLength))
print("ID:\t\t\t"+str(hex(ID)) + ' {' + str(ID) + '}')
print("Flags:\t\t\t" + Functions.getFlags(flags))
print("Fragment offset:\t" + str(fragmentOffset))
print( "TTL:\t\t\t"+str(TTL))
print("Protocol:\t\t" + Functions.getProtocol(protocolNR))
print("Checksum:\t\t" + str(checksum))
print("Source:\t\t\t" + sourceAddress)
print("Destination:\t\t" + destinationAddress)
print("Payload:\n"+str(data[20:]))
# receive a package
#print(s.recvfrom(65565))
#IP = input("Enter IP address to send: ")
#port = int(input("Port: "))

#..............................................................................................
print("\tOld Destination: "+ destinationAddress)

listunpacked[9] = hold
unpacked_data = tuple(listunpacked)
print("\n\t\tNew Address is: "+ unpacked_data[9])
print()
#s.inet_aton(unpacked_data[9]) = hold

#unpacked_data = tuple(listunpacked)
#unpacked_data = bytes(unpacked_data)
#destinationAddress = socket.inet_ntoa(unpacked_data[9])
#..............................................................................................
# tcp header fields
tcp_source = 80  # source port
tcp_dest = 5001  # destination port
tcp_seq = 454
tcp_ack_seq = 0
tcp_doff = 5  # 4 bit field, size of tcp header, 5 * 4 = 20 bytes
# tcp flags
tcp_fin = 0
tcp_syn = 1
tcp_rst = 0
tcp_psh = 0
tcp_ack = 0
tcp_urg = 0
tcp_window = socket.htons(5840)  # maximum allowed window size
tcp_check = 0
tcp_urg_ptr = 0
tcp_offset_res = (tcp_doff &lt;&lt; 4) + 0
tcp_flags = tcp_fin + (tcp_syn &lt;&lt; 1) + (tcp_rst &lt;&lt; 2) + (tcp_psh &lt;&lt; 3) + (tcp_ack &lt;&lt; 4) + (tcp_urg &lt;&lt; 5)

# the ! in the pack format string means network order
tcp_header = tuple(struct.pack('!HHLLBBHHH', tcp_source, tcp_dest, tcp_seq, tcp_ack_seq, tcp_offset_res, tcp_flags, tcp_window,tcp_check, tcp_urg_ptr))
#p =(data+tcp_header)

#hold = bytes(hold,"utf-8")
#hold  = socket.inet_aton ( hold )
#checksum = bytes(checksum,"utf-8")
#destinationAddress = c_int(listunpacked[9])
checksum = bytes(str(checksum),"utf-8")
#ip_header = struct.pack('!BBHHHBBH4s4s' , version_IHL, TOS, totalLength, ID,flags, TTL,protocolNR, checksum,sourceAddress,destinationAddress)
#tcp_header = struct.pack('!HHLLBBH' , tcp_source, tcp_dest, tcp_seq, tcp_ack_seq, tcp_offset_res, tcp_flags,  tcp_window) + struct.pack('H' , tcp_check) + struct.pack('!H' , tcp_urg_ptr)

#packet = ip_header + tcp_header + str(data[20:])
message = "How are  you"
#data = bytes(unpacked_data,"utf-8") + tcp_header + message
ip_header = struct.pack('!BBHHHBBH4s4s' ,version_IHL, TOS, totalLength, ID,flags, TTL,protocolNR, checksum,sourceAddress,destinationAddress)
data = bytes(unpacked_data) + data[20:]
s.sendto(data, ("192.168.0.125" , 5001))
print("Packet sent")
# disabled promiscuous mode
s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>ip_header = struct.pack('!BBHHHBBH4s4s' ,version_IHL, TOS, totalLength, ID,flags, TTL,protocolNR, checksum,sourceAddress,destinationAddress)
</code></pre>
<p>Both the <code>B</code> and <code>H</code> formats require integer arguments (or non-integer objects that implement the <code>__index__</code> method) (see <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow noreferrer">Format Characters</a>).</p>
<p>The <code>checksum</code> argument is now of type <code>bytes</code> because you set it here before packing:  </p>
<pre><code>checksum = bytes(str(checksum),"utf-8")
</code></pre>
<p>And <code>bytes</code> objects do not implement the <code>__index__</code> method.<br/>
You can check this using <code>dir(checksum)</code>.</p>
<p>That's why you're getting the <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow noreferrer"><code>struct.error</code> exception</a>. </p>
<blockquote>
<p>When packing a value x using one of the integer formats ('b', 'B',
  'h', 'H', 'i', 'I', 'l', 'L', 'q', 'Q'), if x is outside the valid
  range for that format then struct.error is raised.</p>
</blockquote>
<p>Either:</p>
<ul>
<li>Use a different variable for the <code>bytes(str(checksum),"utf-8")</code> output</li>
<li>Pass an int type object for the checksum value</li>
</ul>
</div>
