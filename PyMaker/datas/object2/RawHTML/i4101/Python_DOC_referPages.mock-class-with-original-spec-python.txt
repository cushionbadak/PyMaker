<div class="post-text" itemprop="text">
<p>I am trying to mock a class in Python using the <a href="http://www.voidspace.org.uk/python/mock/getting-started.html" rel="nofollow noreferrer">Mock package</a>, specifically, using the <a href="http://www.voidspace.org.uk/python/mock/patch.html#where-to-patch" rel="nofollow noreferrer">patch decorator</a> in the test class.</p>
<pre><code>from unittest import TestCase
from unittest.mock import Mock, patch

@patch("mypackage.subpackage.mymodule", autospec=True)
class MyClassTest(TestCase):
    def setUp(self):
        [...]

    def test_with_boundary_creates_job_flow_task(self):
        returned_value = self.some_class.return_something_from_my_module()

        self.assertIsInstance(returned_value, expected_value_class)
</code></pre>
<p>I would like my mock to have the <em>original behavior</em> of the class being mocked, i.e. unless I specifically mock an attribute/method, it should behave as in the provided class (with its logic &amp; return value). </p>
<p>Thus, when testing a not mocked method but existing method in the original class, test should run successfully rather than failing with following (specific) error:</p>
<pre><code>AssertionError: &lt;class 'unittest.mock.MagicMock'&gt; is not an instance of &lt;class 'airflow.contrib.operators.emr_create_job_flow_operator.EmrCreateJobFlowOperator'&gt;
</code></pre>
<p>Any ideas about how to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The reason for this error, is because a module is mocked, not class</strong></p>
<pre><code>AssertionError: &lt;class 'unittest.mock.MagicMock'&gt; is not an instance of 
&lt;class ...EmrCreateJobFlowOperator'&gt;
</code></pre>
<p>Change</p>
<pre><code>@patch("mypackage.subpackage.mymodule"
</code></pre>
<p>To</p>
<pre><code>@patch("mypackage.subpackage.mymodule.SomeClass"
</code></pre>
<blockquote>
<p>I would like my mock to have the original behavior of the class being mocked,</p>
</blockquote>
<p>I am afraid it is other way around, This will create an instance of <code>App</code> with all methods and attributes mocked, it is only useful when you want to mock the class esp the <code>__init__</code> to use one method(or two)</p>
<pre><code>mock_app = MagicMock(name='App', spec=App)
mock_app.method_one.return_value = whatever
</code></pre>
<blockquote>
<p>I specifically mock an attribute/method, <code>method_one</code>, while <code>app</code> will have everything real except <code>method_one</code></p>
</blockquote>
<pre><code>mock_app = MagicMock(name='App', 'method_one', spec=App)
mock_app.method_one.return_value = 'mocked value'
app = App()
</code></pre>
<p>In short, your patch will be</p>
<pre><code>  from airflow.contrib.operators.emr_create_job_flow_operator import EmrCreateJobFlowOperator
  @patch.object(EmrCreateJobFlowOperator, 'the_method')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I mock it like this:</p>
<pre><code>from mypackage.subpackage.mymodule import MyClass

class MyClassTest(TestCase):
    def setUp(self):
        [...]

    @patch.object(MyClass, 'method_to_mock', autospec=True)
    def test_with_boundary_creates_job_flow_task(self, mock_method):
        mock_method.return_value = expected_value_class() # Can use a stub
        returned_value = self.some_class.return_something_from_my_module()

        self.assertIsInstance(returned_value, expected_value_class)
</code></pre>
</div>
<span class="comment-copy">This is the first scenario described in the docs: <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#quick-guide</a></span>
<span class="comment-copy">Could you specify where you see that's described, If I am not mistaken, @blamblam looks for the exact same behaviour, not a mocked behaviour, or the simply existance of attributes/methods in mock</span>
<span class="comment-copy">It looks like <code>@patch("mypackage.subpackage.mymodule", autospec=True)</code> will mock out an entire module, not just a single class. If you want your class to have the original behaviour unless you specifically mock an attribute or method, why are you mocking the whole class and not just those specific attributes or methods?</span>
<span class="comment-copy">Also as an aside, I cannot recommend <a href="https://docs.pytest.org/en/latest/" rel="nofollow noreferrer">pytest</a> highly enough as a much better unit testing framework than the built-in unittest, and it can be used as a direct replacement (e.g. it will run existing unittest style tests).</span>
<span class="comment-copy">@TomDalton sorry for our mistake (we are newbies in python). Change mymodule for myclass, we are only trying to mock a class.  We want to do that because we have some tests which requires the original instance without change and others that require a mocked function, and we don't want to have 2 instances (some_class and some_class_with_mocks). We note your recommendation about pytest. Thanks!</span>
