<div class="post-text" itemprop="text">
<p>From my understanding of the intersection function, it finds complete overlap between elements in a list. For example:</p>
<pre><code>tup_1 = [(1,2,3),(4,5,6)]
tup_2 = [(4,5,6)]
ol_tup = set(tup_1).intersection(tup_2)
print ol_tup
</code></pre>
<p>would yield:</p>
<pre><code>set([(4, 5, 6)])
</code></pre>
<p>However, suppose my list of tuples are set up as this:</p>
<pre><code>tup_1 = [(1,2,3),(4,5,5)]
tup_2 = [(4,5,6)]
</code></pre>
<p>Where there's an overlap in 2 elements of the 2nd tuple in tup_1 and 1st tuple in tup_2. If I want to python to return these 2 tuples: (4,5,5) and (4,5,6), is there an easier way than this nested for loop (below)?</p>
<pre><code>for single_tuple_1 in tup_1:
    for single_tuple_2 in tup_2:
        if single_tuple_1[0] == single_tuple_2[0] and single_tuple_1[1] == single_tuple_2[1]:
            print single_tuple_1,single_tuple_2
</code></pre>
<p>EDIT: </p>
<p>For this case, suppose order matters and suppose the tuples contain 5 elements:</p>
<pre><code>tup_1 = [(1,2,3,4,5),(4,5,6,7,8),(11,12,13,14,15)]
tup_2 = [(1,2,3,4,8),(4,5,1,7,8),(11,12,13,14,-5)]
</code></pre>
<p>And I would like to find the tuples that intersect with each other in their respective first 4 elements. So the result should be:</p>
<pre><code>[(1,2,3,4,5),(1,2,3,4,8),(11,12,13,14,15),(11,12,13,14,-5)]
</code></pre>
<p>How would the code change to accommodate this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to return all the pairs of "overlapping" tuples there's no way around comparing all the pairs, i.e. a quadratic algorithm. But you could make the code a bit more elegant using a list comprehension, <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> for the combinations and <code>zip</code> and <code>sum</code> for the comparison:</p>
<pre><code>&gt;&gt;&gt; tup_1 = [(1,2,3),(4,5,5),(7,8,9)]

&gt;&gt;&gt; tup_2 = [(4,5,6),(0,5,5),(9,8,7)]

&gt;&gt;&gt; [(a, b) for (a, b) in itertools.product(tup_1, tup_2)
...         if sum(1 for ai, bi in zip(a, b) if ai == bi) &gt;= 2]
[((4, 5, 5), (4, 5, 6)), ((4, 5, 5), (0, 5, 5))]
</code></pre>
<p>Note: This checks whether two tuples have the same element in at least two positions, i.e. order matters. If order should not matter, you can convert <code>a</code> and <code>b</code> to <code>set</code> instead and check the size of their intersection, but that might fail for repeated numbers, i.e. the intersection of <code>(1,1,2)</code> and <code>(1,1,3)</code> would just be <code>1</code> instead of <code>2</code>.</p>
<p>If you only want to match the first two, or first two and last two elements, you can compare slices of the tuples in an accordant disjunction:</p>
<pre><code>&gt;&gt;&gt; [(a, b) for (a, b) in itertools.product(tup_1, tup_2)
...         if a[:2] == b[:2]]
[((4, 5, 5), (4, 5, 6))]

&gt;&gt;&gt; [(a, b) for (a, b) in itertools.product(tup_1, tup_2)
...         if a[:2] == b[:2] or a[-2:] == b[-2:]]
[((4, 5, 5), (4, 5, 6)), ((4, 5, 5), (0, 5, 5))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is one way using a list comprehension. The logic as written checks for an overlap of at least 2 elements.</p>
<p>Note that if there is <em>no</em> overlap you will be left with the one element of <code>tup_2</code>, but that can be trivially identified.</p>
<pre><code>from itertools import chain

tup_1 = [(1,2,3),(4,5,5)]
tup_2 = [(4,5,6)]

y = sorted(tup_2[0])
res = [i for i in chain(tup_1, tup_2) if
       sum(i==j for i, j in zip(sorted(i), y)) &gt; 1]

print res

[(4, 5, 5), (4, 5, 6)]
</code></pre>
</div>
<span class="comment-copy">Does <code>tup_2</code>  always contain a single tuple?</span>
<span class="comment-copy">What if the element overlaps with two others? Would you print two pairs? In this case, I think there's no faster way than quadratic, i.e. comparing each pair.</span>
<span class="comment-copy">Also, does position of elements within the tuple matter?</span>
<span class="comment-copy">Do you always want to check for exactly two in common? What if there's more than that?</span>
<span class="comment-copy">Did one of the solutions below help? Feel free to accept one if it did (green tick on left), or ask for clarification.</span>
<span class="comment-copy">If I only wanted to match the first 2 elements of each tuple or last 2 each tuple, would I have to add the index brackets in a/b,ai/bi, or neither of those variables?</span>
<span class="comment-copy">@superasiantomtom95 To <code>a</code> and <code>b</code>, see my update</span>
<span class="comment-copy">@Chris_Rands, Agreed - thanks</span>
<span class="comment-copy">Note that using <code>set</code> might fail if the tuples have repeated elements.</span>
