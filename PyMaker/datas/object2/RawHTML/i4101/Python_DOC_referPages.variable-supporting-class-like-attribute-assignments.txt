<div class="post-text" itemprop="text">
<p>I was wondering if there was some kind of python variable (which isn't a custom made class) which would support the following code :</p>
<pre><code>a = some_creation_procedure
a.variable_a = 1
a.variable_b = 2
a.variable_c = 3
print ("{}, {}, {}".format(a.variable_a, a.variable_b, a.variable_c))
</code></pre>
<p>output - </p>
<pre><code>[1, 2, 3]
</code></pre>
<p>I could probably create a custom class and support this with "get_attribute" function, but I was wondering if there was a built-in support for this.</p>
<p><strong>Motivation:</strong></p>
<p>I want to debug a certain function within a class (Which requires a lot of operations / variables for initliazing), so I want to create a sub-class instance which has variables corresponding to that specific function (and send it as self for that specific function).</p>
<p>for example :</p>
<pre><code>class some_class():
    def __init__(var1, var2, var3, var4 , ....):
        do_a()
        do_b()
        and so on...

    def minimal_func(self):
        print (self.var1)

    my_variable.var1 = "a"
    some_class.minimal_func(my_variable)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way is a class without anything inside it:</p>
<pre><code>class Namespace: pass

a = Namespace()
a.variable_a = 1
a.variable_b = 2
a.variable_c = 3
print ("{}, {}, {}".format(a.variable_a, a.variable_b, a.variable_c))
</code></pre>
<p>prints:</p>
<pre><code>1, 2, 3
</code></pre>
<p>as @James said in the comments:</p>
<blockquote>
<p>Instances of class objects can have attributes assigned to them on the fly. There are ways to restrict attribute assignment as well, but by default, you can just assign anything</p>
</blockquote>
<p>As @Aran-Frey pointed out, you can also use the <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">types.SimpleNamespace</a> class instead of of the above empty class:</p>
<pre><code>import types
a = types.SimpleNamespace()
</code></pre>
<p>This also allows you to add attributes in the constructor:</p>
<pre><code>import types

a = types.SimpleNamespace(
    variable_a=1,
    variable_b=2,
    variable_c=3)
</code></pre>
<p>Also it has a nice <code>__repr__</code> function:</p>
<pre><code>print(a)
</code></pre>
<p>prints:</p>
<pre><code>namespace(variable_a=1, variable_b=2, variable_c=3)
</code></pre>
</div>
<span class="comment-copy">If your class has so many unused attributes, it might be a sign that your class hierarchy isn't right. Maybe consider splitting it into multiple smaller classes?</span>
<span class="comment-copy">@Aran-Fey He just says for this function unused.</span>
<span class="comment-copy">@Aran-Fey Actually the minimal function uses only one variable for breaking up a bigger function. My class is pretty well though of hierarchy wise.</span>
<span class="comment-copy">Seems like this exactly what I need, could you expand a bit on what you did there?</span>
<span class="comment-copy">Instances of class objects can have attributes assigned to them on the fly.  There are ways to restrict attribute assignment as well, but by default, you can just assign</span>
<span class="comment-copy">There's also <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer"><code>types.SimpleNamespace</code></a> in case you don't want to roll your own. It offers some advantages like keyword arguments in the constructor: <code>a = SimpleNamespace(a=1, b=2)</code> and a nice <code>repr</code>.</span>
<span class="comment-copy">@Rohi This is really no different to how you attach an attribute to an instance in (for example) the class's <code>__init__</code> method, except that inside a method you normally refer to the instance via <code>self</code>, but it's really the same thing. <code>self</code> isn't some kind of magic syntax, it's just a name that's used by convention.</span>
<span class="comment-copy">@Rohi If you don't want to create a class, I edited another alternative into the answer</span>
