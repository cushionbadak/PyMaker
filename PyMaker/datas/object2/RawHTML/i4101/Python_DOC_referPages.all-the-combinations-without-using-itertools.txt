<div class="post-text" itemprop="text">
<p>I want to know how to write an algorithm that gives me all the possible combinations of a list of numbers <em>with</em> repetition &amp; <em>without</em> using itertools in Python.</p>
<p>For example: all possible combinations of the list <code>[1,2]</code>:</p>
<pre><code>[[1,1],[1,2],[2,2],[2,1]]
</code></pre>
<p>All possible combinations of the list <code>[1,2,3]</code>. The algorithm will then give me 27 (3<sup>3</sup>) different lists in a list.</p>
<p>This was my code:</p>
<pre><code>def all_possibilities(list):
    result = [list]

    for i in list:
        new_list1 = list[:]

        for k in range(len(list)):
            new_list2 = list[:]
            new_list1[k] = i
            new_list2[k] = i
            if new_list1 != list:
                result.append(new_list1)
            if new_list2 != list:
                result.append(new_list2)

    for u in result:
        for y in result:
            if u == y and (u is y) == False:
                result.remove(y)

    return (len(result),result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write your own <code>product</code> method which finds out the <code>cartesian product</code> of multiple lists.</p>
<pre><code>def cartesian_product(*lists):
  result = [[]]
  for list in lists:
    result = [x + [y] for x in result for y in list]
  return result  
l = [1, 2, 3]
lst = [l for i in l]
x = cartesian_product(*lst)
for tuple in x:
   print(tuple)
</code></pre>
<p>Output</p>
<pre><code>(1, 1)
(1, 2)
(2, 1)
(2, 2)   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here this actually does the combinations with replacement. You can adjust the size of the combinations. I made it return a tuple because tuples are immutable and tuple operations are faster than list operations. you can however easily make it return a list of list if you want. Cheers</p>
<pre><code>def seq_slicer(container, step=10):
    """(container)-&gt;container
    Returns slices of container in chunks of step.
    Great selecting chunks of a sequence in predetrmined slices efficiently.

    In the event where step is greater than the length of the sequence to be sliced,
    the slice taken will be the length of the sequence.

    &gt;&gt;&gt; [i for i in seq_slicer(range(40), 10)]
    [range(0, 10), range(10, 20), range(20, 30), range(30, 40)]

    &gt;&gt;&gt; [i for i in seq_slicer(range(41), 10)]
    [range(0, 10), range(10, 20), range(20, 30), range(30, 40), range(40, 41)]

    &gt;&gt;&gt; [c for c in seq_slicer("abcdefghijklm", 3)]
    ['abc', 'def', 'ghi', 'jkl', 'm']

    &gt;&gt;&gt; [c for c in seq_slicer(list("abcdefghijklm"), 3)]
    [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ['m']]

    Author: Xero
    License: Apache V2
    """
    i = 0
    span = len(container)
    while i &lt; span:
        yield container[i:i+step]
        i += step

def combinations_with_replacement(seq, num):
    """(sequence type, integer)-&gt;list
    return every possible combination of num elements from seq in lexicographic order
    &gt;&gt;&gt; combinations_with_replacement([1, 2], 2)
    ((1, 1), (1, 2), (2, 1), (2, 2))


    Author: Xero
    License: Apache V2
    """
    lst = []
    _seq = tuple(seq)
    slices = [c for c in seq_slicer(_seq, num-1)]
    for elem in seq:
        for combo in [(elem,) + body for body in slices]:
            lst.append(combo)
    return tuple(lst)
</code></pre>
</div>
<span class="comment-copy">what specific problem are you having with the implementation?</span>
<span class="comment-copy">If you are looking for pure python equivalent of <code>itertools.permutations</code> you can check the implementation of this method is <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">docs</a></span>
<span class="comment-copy">The concept you will need to learn is recursion.</span>
<span class="comment-copy">I know the concept of recursion but I've tried writing it multiple times and I never get ALL the possible solutions.</span>
<span class="comment-copy">show us what you've tried and show us how it fails.</span>
<span class="comment-copy">"WITHOUT using itertools" was in the question</span>
<span class="comment-copy">@MihaiAlexandru-Ionut can you explain what happens on line 4 please? Thanks in advance</span>
<span class="comment-copy">@PaulvanTieghem, basically it created a list [[1],[2],[3]] then <code>[[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]</code> and so on.</span>
<span class="comment-copy">Thanks a lot for your help!</span>
<span class="comment-copy">@PaulvanTieghem, your'e welcome. Please mark the answer as accepted and upvote if it works for you and you find it useful</span>
<span class="comment-copy">@XeroSmith, upvote for your answer. I know the feeling when write a long and correct answer and nobody upvotes it in order to recognize the effort and time invested into answering the question.</span>
<span class="comment-copy">@MihaiAlexandru-Ionut thanks mate</span>
