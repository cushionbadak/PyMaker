<div class="post-text" itemprop="text">
<p>How can I keep the main process from continuing until a spawned process has begun its execution?</p>
<p>Suppose I had the following simple example:</p>
<pre><code>import multiprocessing as mp

def foo():
    print ("In 'foo'")
    while True:
        pass

def bar():
    print ("In 'bar'")
    count = 0
    while count &lt; 5001:
        count += 1

def main():
    print ("In 'main'")
    p = mp.Process(target = foo, args = ())
    p.start()
    # stop here until 'foo()' prints
    bar()

if __name__ == '__main__':
    main()
</code></pre>
<p>As I understand it, when a <code>Process.start()</code> occurs, the process has to "reimport" everything from <code>__main__</code>, and because of this, in my program there is a delay from when <code>foo()</code> would begin, yet <code>__main__</code> continues while the new process is starting up.</p>
<p>The only working method I have is using a <code>multiprocessing.Pipe()</code>:</p>
<pre><code>import multiprocessing as mp

def foo(s):
    print ("In 'foo'")
    s.close()
    while True:
        pass

def bar():
    print ("In 'bar'")
    count = 0
    while count &lt; 5001:
        count += 1

def main():
    print ("In 'main'")
    r, s = mp.Pipe()
    p = mp.Process(target = foo, args = (s,))
    p.start()
    while not s.closed:
        pass
    bar()

if __name__ == '__main__':
    main()
</code></pre>
<p>But this seems clunky since I dont even use the <code>Pipe()</code> for what it is meant for. Another method I thought would work was to use a <code>multiprocessing.Lock()</code>, but because of the "reimport" delay, the target method does acquire the lock before <code>bar()</code> is executed on <code>__main__</code>.</p>
<p>Is there a better way to handle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Event" rel="nofollow noreferrer">Event</a>. You can make you main process wait for the event to be set before continuing. And your child process will set the event when it start in your target function.</p>
<pre><code>import multiprocessing as mp
import time


def foo(process_started):
    print ("In 'foo'")
    time.sleep(5)  # Sleep to show that the main process is waiting for the event
    process_started.set()
    while True:
        pass

def bar():
    print ("In 'bar'")
    count = 0
    while count &lt; 5001:
        count += 1

def main():
    print ("In 'main'")
    process_started = mp.Event()
    p = mp.Process(target = foo, args = (process_started,))
    p.start()
    process_started.wait()  # Wait for the Event to be set
    bar()

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">This doesn't work for me. I don't know, it should work.</span>
<span class="comment-copy">On a non-forking system like windows, the child process would create a new <code>process_started</code>. Setting it would not be seen in the parent. It should be created in <code>main</code> and passed to the child.</span>
<span class="comment-copy">@tdelaney Yep, that's it. Now it works. That should be added to the answer.</span>
<span class="comment-copy">@tdelaney Sorry I only tested in linux system. Didn't know that event in windows behaved differently. I thought that Event object created with the multiprocessing module are shared between process.</span>
<span class="comment-copy">As mentioned, the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer"><code>spawn</code></a> method is defaulted on Windows which creates an entirely new interpreter process. Further documentation is <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow noreferrer">here</a> on the execution of <code>spawn</code>.</span>
