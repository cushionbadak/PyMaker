<div class="post-text" itemprop="text">
<p>I've found this statement in one of the answers to <a href="https://stackoverflow.com/questions/2465921/how-to-copy-a-dictionary-and-only-edit-the-copy">this question</a>. </p>
<p>What does it mean? I would have no problem if the statement were "Python never implicitly copies dictionary objects".  I believe tuples, lists, sets etc are  considered  "object" in python but the problem with dictionary as described in the question doesn't arise with them. </p>
</div>
<div class="post-text" itemprop="text">
<p>The statement in the linked answer is broader than it should be. Implicit copies are rare in Python, and in the cases where they happen, it is arguable whether <em>Python</em> is performing the implicit copy, but they happen.</p>
<p>What is definitely true is that the default rules of name assignment do not involve a copy. By default,</p>
<pre><code>a = b
</code></pre>
<p>will not copy the object being assigned to <code>a</code>. This default can be overridden by a custom local namespace object, which can happen when using <code>exec</code> or a metaclass with a <code>__prepare__</code> method, but doing so is extremely rare.</p>
<p>As for cases where implicit copies do happen, the first that comes to mind is that the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> standard library module performs implicit copies all over the place, which is one of the reasons that <code>multiprocessing</code> causes a lot of confusion. Assignments other than name assignment may also involve copies; <code>a.b = c</code>, <code>a[b] = c</code>, and <code>a[b:c] = d</code> may all involve copies, depending on what <code>a</code> is. <code>a[b:c] = d</code> is particularly likely to involve copying <code>d</code>'s data, although it will usually not involve producing an object that is a copy of <code>d</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>python has a lot of difficult types. they are divide on two groups:<br/>
1) not change - integer, string, tuple<br/>
2) change - list, dictionary<br/>
for example:<br/>
- not change</p>
<pre><code>x = 10
</code></pre>
<p>for this 'x' python create new object like 'Int' with link in memory 0x0001f0a</p>
<pre><code>x += 1 # x = x + 1
</code></pre>
<p>python create new link in memory like 0x1003c00
- change</p>
<pre><code>x = [1, 2, 'spam']
</code></pre>
<p>for this 'x' python create new object like 'Int' with link in memory 0x0001f0a</p>
<pre><code>y = x
</code></pre>
<p>python copy link from 'x' to 'y' </p>
</div>
<span class="comment-copy">The answer states <code>x = y</code> never creates a copy of <code>y</code>. Anything mutable will be affected, lists and sets for instance.</span>
<span class="comment-copy">Yes, the statement is accurate. When doing an assignment, Python never implicitly assigns a copy of the right-hand side to the left. You must do this explicitly.</span>
<span class="comment-copy">Yes, it is accurate, assignment <b>never</b> copies, and works <i>exactly</i> the same for <code>list</code>, <code>set</code>, <code>tuple</code>, and <code>dict</code> objects (and all other objects). The difference between mutable types and immutable types is that <i>you cannot mutate immutable types</i>, therefore, you won't see a practical difference. But using the <code>id</code> function, you'll see that the behavior is the same. Also, this is important, <b>everything</b> in Python is an object.\</span>
<span class="comment-copy">read this: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">Actually, not only do lists have this problem, but novices seem to get bitten far more often with lists than with any other type. Dicts and numpy arrays are probably tied for a distant 2nd place. Notice that <a href="https://docs.python.org/3/faq/programming.html#why-did-changing-list-y-also-change-list-x" rel="nofollow noreferrer">the official Python FAQ question</a> and <a href="https://stackoverflow.com/questions/2612802/">our canonical question</a> are both all about lists, and barely mention dicts as another example of a mutable type.</span>
<span class="comment-copy">You could also point out that <code>+=</code> and friends can "make an implicit copy" (e.g., <code>tup += ()</code>). Of course what's actually happening is the <code>__iadd__</code> or <code>__add__</code> method making a copy, followed by assignment not making a copy—but people coming from C++ are sometimes mislead by this behavior.</span>
<span class="comment-copy">Technically, in most (all?) cases but local variables, Python hands off the responsibility of assignment to a <code>__setitem__</code>, <code>__setattr__</code>, <code>__set__</code>, or <code>set_contents</code> method on some object. So it's not really that Python never copies, but that dict, list, slots-wrapper, property, and cell don't copy, and neither do any method inherited from <code>object</code>; beyond that, it's entirely up to whatever methods you (or a third-party, or even the stdlib, a la multiprocessing) want to do in those methods. (I don't think that would clarify things for most people even if you explained it better than me…)</span>
