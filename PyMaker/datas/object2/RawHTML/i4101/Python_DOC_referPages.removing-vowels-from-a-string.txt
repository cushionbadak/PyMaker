<div class="post-text" itemprop="text">
<p>I'm suppose remove all the vowels from the any string that would be entered. I'm trying to make the code as simple as possible.</p>
<p>Thank you for the help.</p>
<pre><code>def anti_vowel(text):
    for i in text:
       i.strip(['i','o','a','u','e'])
       return i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two problems:</p>
<ol>
<li><code>strip</code> is the wrong method; it only removes from the beginning and end of a string. Use <code>.replace(something, '')</code>.</li>
<li>Strings are immutable; a method cannot <em>modify</em> a string. <code>strip</code> <em>returns</em> the modified string.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>So you call strip on each character.... and then what? You don't update the string, because strings are immutable and <code>i.strip</code> is not an inplace operation. </p>
<p>A naive improvement over your solution would filtering characters out inside a list comprehension and then doing a <code>join</code> on the result:</p>
<pre><code>vowels = {'i','o','a','u','e'}
def anti_vowel(text):
    return ''.join([c for c in text if c not in vowels])
</code></pre>
<p>A small note: if your string contains mixed case, you may want to either</p>
<ol>
<li>Lowercase <code>text</code>, or</li>
<li>Augment <code>vowels</code> to contain uppercase vowels: <code>vowels = set('aeiouAEIOU')</code>, or</li>
<li><p>Use <code>str.casefold</code> (as per @Adam Smith's comment)—augmenting <code>vowels</code> is no longer needed in that case: </p>
<pre><code>return ''.join([c for c in text if c.casefold() not in vowels])
</code></pre></li>
</ol>
<hr/>
<p>You can get <em>even</em> better with <code>str.translate</code> (this works on python-3.x):</p>
<pre><code>mapping = str.maketrans(dict.fromkeys(vowels, '')) # create a global mapping once
def anti_vowel(text):
    return text.translate(mapping))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code worked too! The dude who wrote the anwser deleted their post. Shame it worked really well. </p>
<pre><code>liz = ("Totally not going to hitting the big bong at the event")
import re

def anti_vowel(text):
    print re.sub('[aeiou]', '', text)

anti_vowel(liz)

output: 
Ttlly nt gng t httng th bg bng t th vnt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.strip</code> is not an in-place operation and takes a string as an argument. Therefore, your code will not work as desired.</p>
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#bytearray" rel="nofollow noreferrer"><code>bytearray</code></a> to efficiently remove certain characters from your string. You may see an order of magnitude better performance for larger strings.</p>
<p>Character removal can be performed with <code>bytearray.translate</code> directly, without the need to use <code>str.maketrans</code>.</p>
<pre><code>def anti_vowel_bytes(s):
    b = bytearray()
    b.extend(s.encode())
    b = b.translate(None, b'aeiou')
    return b.decode('utf-8') 

def anti_vowel_str(s, mapping):
    return s.translate(mapping)

vowels = set('aeiou')
mapping = str.maketrans(dict.fromkeys(vowels, ''))

test = 'alpha beta gamma delta epsilon zeta eta'*100000
res1 = anti_vowel_bytes(test)
res2 = anti_vowel_str(test, mapping)

assert res1 == res2

%timeit anti_vowel_bytes(test)            # 20 ms
%timeit anti_vowel_str(test, mapping)     # 398 ms
</code></pre>
</div>
<span class="comment-copy"><a href="https://codereview.stackexchange.com/questions/151716/remove-all-vowels-from-a-string-except-an-initial-character">Relevant question from code review.</a></span>
<span class="comment-copy">Very true, although #1 isn't relevant here, since the OP's code is calling  <code>.strip</code> on  single chars.</span>
<span class="comment-copy">That works too! Thanks dude!</span>
<span class="comment-copy">@STNDR Just FYI, you can only accept a single answer... when you accept one and then accept another, the first is automatically unmarked :-)</span>
<span class="comment-copy">Lol, I was surprised that mine was accepted over cᴏʟᴅsᴘᴇᴇᴅ's. You should probably consider accepting that one again.</span>
<span class="comment-copy">Don't need the <code>[]</code> in the join.</span>
<span class="comment-copy">@StephenRauch But it's faster <i>with</i> it... let me find you the link. EDIT: here: <a href="https://stackoverflow.com/a/9061024/4909087">stackoverflow.com/a/9061024/4909087</a></span>
<span class="comment-copy">for mixed case -- <code>...if c.casefold() not in vowels])</code> is probably best, rather than <code>[c for c in text.casefold() ...</code> since then you don't lose the original case</span>
<span class="comment-copy">I'd probably create the translation table as a global, rather than rebuilding it in each <code>anti_vowel</code> call.</span>
<span class="comment-copy">@StephenRauch Here's what core dev Raymond Hettinger has to say about <code>.join</code> on a gen exp vs list comp: <a href="https://stackoverflow.com/a/9061024/4014959">stackoverflow.com/a/9061024/4014959</a></span>
<span class="comment-copy">The deleted answer contains some incorrect information. But yes, they could've just edited that out. That regex code works, but I suspect that using the built-in <code>str.translate</code> is faster.</span>
<span class="comment-copy">Feel free to do a timeit test, but I can guarantee this regex replacement is the slowest, followed by your loopy replace. The fastest and second fastest by far is translate and the list comp.</span>
<span class="comment-copy">Slightly unfair as of now, because both vowel and mapping's definitions can be moved outside, otherwise they're timed as part of the timeit at each iteration. Otherwise this is a nice find.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ, Fair point; updated the benchmarking. Yep, it's amazing the new things you can learn from the official docs.</span>
