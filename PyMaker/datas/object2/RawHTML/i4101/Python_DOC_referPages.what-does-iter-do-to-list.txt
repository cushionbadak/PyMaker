<div class="post-text" itemprop="text">
<p>I have this code:</p>
<pre><code>a = ['animal', 'dog', 'car', 'bmw', 'color', 'blue']
a_iter = iter(a)

print(a)
print(a_iter)

print(dict(zip(a,a)))
print(dict(zip(a_iter,a_iter)))
</code></pre>
<p>and output is:</p>
<pre><code>['animal', 'dog', 'car', 'bmw', 'color', 'blue']
&lt;list_iterator object at 0x7f2d98b756d8&gt;
{'dog': 'dog', 'car': 'car', 'animal': 'animal', 'color': 'color', 'blue': 'blue', 'bmw': 'bmw'}
{'car': 'bmw', 'color': 'blue', 'animal': 'dog'}
</code></pre>
<p>I do not understad, why the zip works differently with <code>a_iter</code> than <code>a</code>. What does <code>iter()</code> do, list is iterable, so why use <code>iter()</code>? Could anybody explain me this with some nice example? I googled about it but I still do not understand it.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter(l)</code></a> returns an iterator object for <code>l</code>. Together with <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next(i)</code></a> it can be used for iterating the elements of <code>l</code>.</p>
<p>The code:</p>
<pre><code>for x in l: print(x)
</code></pre>
<p>is equivalent to this code explicitly using the iterator:</p>
<pre><code>i = iter(l)
while True:
    try:
        x = next(i)
        print(x)
    except StopIteration:
        break
</code></pre>
<p>Note that an iterator can also be traversed with a for loop:</p>
<pre><code>i = iter(l)
for x in i:
    print(x)
</code></pre>
<hr/>
<p><code>zip(a,b)</code> consumes one element from <code>a</code>, <code>b</code> at a time.</p>
<p>When the argument of zip is a sequence, it will create its own iterator for it.</p>
<p>When the argument is an iterator, it will just consume elements from it.</p>
<p>When it is <strong>the same</strong> iterator in both arguments, each iteration of zip will consume one element of the iterator for the first argument, and one element for the second argument.</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3,4]
&gt;&gt;&gt; b = [10,20,30,40]

&gt;&gt;&gt; list(zip(a, b)) # zip two lists
[(1, 10), (2, 20), (3, 30), (4, 40)]

&gt;&gt;&gt; list(zip(a, a)) # zip a list with itself
[(1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; i1 = iter(a)
&gt;&gt;&gt; i2 = iter(a)
&gt;&gt;&gt; list(zip(i1, i2)) # same as above, but with iterators
[(1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; i = iter(a)
&gt;&gt;&gt; list(zip(i, i)) # same as above, but with the same iterator
[(1, 2), (3, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>iter()</code> does nothing to a list; the <code>list</code> object has an <code>__iter__</code> method that <code>iter()</code> uses to produce an iterator object. That object has a reference to the original list and an index; every time you ask for the next value in the iterator, the value at the current index is retrieved and returned, and the index is incremented.</p>
<p>You can use the <code>next()</code> function to get the next value from an iterator:</p>
<pre><code>&gt;&gt;&gt; a = ['animal', 'dog', 'car', 'bmw', 'color', 'blue']
&gt;&gt;&gt; a_iter = iter(a)
&gt;&gt;&gt; next(a_iter)  # get the next value
'animal'
&gt;&gt;&gt; next(a_iter)  # get the next value
'dog'
</code></pre>
<p>Notice how calling <code>next()</code> again gives you a new value. You can do so until the iterator is done:</p>
<pre><code>&gt;&gt;&gt; three_more = next(a_iter), next(a_iter), next(a_iter)
&gt;&gt;&gt; next(a_iter)  # last one
'blue'
&gt;&gt;&gt; next(a_iter)  # nothing left
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>List iterator objects keep hold of the original list object; changing the list object will reflect in the iterator values produced on <code>next()</code>:</p>
<pre><code>&gt;&gt;&gt; b = ['foo', 'bar']
&gt;&gt;&gt; b_iter = iter(b)
&gt;&gt;&gt; next(b_iter)
'foo'
&gt;&gt;&gt; b[1] = 'spam'
&gt;&gt;&gt; b
['foo', 'spam']
&gt;&gt;&gt; next(b_iter)
'spam'
</code></pre>
<p><code>zip()</code> asks for the next value in each of its arguments, which are assumed to be <em>iterables</em>; <code>zip()</code> calls <code>iter()</code> on them all. For iterator objects such as <code>a_iter</code>, <code>iter(a_iter)</code> returns the iterator itself (it's already an iterator, after all):</p>
<pre><code>&gt;&gt;&gt; iter(a_iter)
&lt;list_iterator object at 0x10e7b6a20&gt;
&gt;&gt;&gt; iter(a_iter) is a_iter
True
</code></pre>
<p>Since <code>a_iter</code> will yield values from the original list, in order, that means that you get paired-up elements in a dictionary, because <code>zip()</code> has <em>two references to the same object</em>; you effectively creating <code>(next(a_iter), next(a_iter))</code> as the iterator step values for <code>zip()</code>. If you pass in two references to <code>a</code>, on the other hand, <code>zip()</code> will call <code>iter()</code> <em>twice</em>, creating <em>two separate iterator objects</em>, and each have their own index to track.</p>
<p>Let's look at that in detail. Note that <code>zip()</code> <em>also</em> produces an iterator object, so we can verify that calling <code>next()</code> on <code>zip()</code> in turn causes <code>a_iter</code> to step forward twice:</p>
<pre><code>&gt;&gt;&gt; a_iter = iter(a)
&gt;&gt;&gt; a_iter_zip = zip(a_iter, a_iter)
&gt;&gt;&gt; a_iter_zip   # a zip object is an iterator too
&lt;zip object at 0x10e7ba8c8&gt;
&gt;&gt;&gt; next(a_iter_zip)  # get next value of a_iter, together with the next value of a_iter
('animal', 'dog')
&gt;&gt;&gt; next(a_iter)  # the a-list iterator was advanced, so now we get 'car'
'car'
&gt;&gt;&gt; next(a_iter_zip)  # now a_iter is at bmw, so we get bmw and color
('bmw', 'color')
</code></pre>
<p>Iterators are independent objects, they each have their own index:</p>
<pre><code>&gt;&gt;&gt; a_iter1 = iter(a)
&gt;&gt;&gt; a_iter2 = iter(a)   # different iterator from a_iter1
&gt;&gt;&gt; next(a_iter1), next(a_iter1)  # what zip() does
('animal', 'dog')
&gt;&gt;&gt; next(a_iter2), next(a_iter2)  # iter2 is independent
('animal', 'dog')
</code></pre>
<p>So when you use <code>zip(a, a)</code>, what really happens is that <code>zip()</code> calls <code>iter(a)</code> two times, creating two new iterators, and both are used to create the output:</p>
<pre><code>&gt;&gt;&gt; a_iter1 = iter(a)
&gt;&gt;&gt; a_iter2 = iter(a)
&gt;&gt;&gt; a_iter_1_and_2_zip = zip(a_iter1, a_iter2)
&gt;&gt;&gt; next(a_iter_1_and_2_zip)  # values from a_iter1 and a_iter2
('animal', 'animal')
&gt;&gt;&gt; next(a_iter_1_and_2_zip)  # moving in lockstep
('dog', 'dog')
&gt;&gt;&gt; next(a_iter1)   # moving one of these two one step along, to 'car'
'car'
&gt;&gt;&gt; next(a_iter_1_and_2_zip)   # so a_iter1 is one step ahead!
('bmw', 'car')
&gt;&gt;&gt; next(a_iter1)   # another extra step
'color'
&gt;&gt;&gt; next(a_iter_1_and_2_zip)   # so a_iter1 is two steps ahead!
('blue', 'bmw')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>iter() function return a instance of iterator on which we can iterate for getting all the value one by one.It is memory efficient function because it stores only current element value.</p>
</div>
<span class="comment-copy">iterators are a special type of objects, they are made to e iterate over, so they are fast and are not saved in memory, they are mainly use in <code>for</code> cycles for speed, you can always transform an iterator to a list by <code>list() </code>.</span>
<span class="comment-copy">Thank you for great explanation!</span>
