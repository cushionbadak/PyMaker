<div class="post-text" itemprop="text">
<p>I have a array contains file names like below:</p>
<pre><code>['001_1.png', '001_2.png', '001_3.png', '002_1.png','002_2.png', '003_1.png', '003_2.png', '003_3.png', '003_4.png', ....]
</code></pre>
<p>I want to quickly group these files into multiple arrays like this:</p>
<pre><code>[['001_1.png', '001_2.png', '001_3.png'], ['002_1.png', '002_2.png'], ['003_1.png', '003_2.png', '003_3.png', '003_4.png'], ...]
</code></pre>
<p>Could anyone tell me how to do it in few lines in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like that should work:</p>
<pre><code>import itertools


mylist = [...]
[list(v) for k,v in itertools.groupby(mylist, key=lambda x: x[:3])]
</code></pre>
<p>If input list isn't sorted, than use something like that:</p>
<pre><code>import itertools


mylist = [...]
keyfunc = lambda x:x[:3]
mylist = sorted(mylist, key=keyfunc)
[list(v) for k,v in itertools.groupby(mylist, key=keyfunc)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your data is already sorted by the file name, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>files = ['001_1.png', '001_2.png', '001_3.png', '002_1.png','002_2.png',
        '003_1.png', '003_2.png', '003_3.png']

import itertools

keyfunc = lambda filename: filename[:3]

# this creates an iterator that yields `(group, filenames)` tuples,
# but `filenames` is another iterator
grouper = itertools.groupby(files, keyfunc)

# to get the result as a nested list, we iterate over the grouper to
# discard the groups and turn the `filenames` iterators into lists
result = [list(files) for _, files in grouper]

print(list(result))
# [['001_1.png', '001_2.png', '001_3.png'],
#  ['002_1.png', '002_2.png'],
#  ['003_1.png', '003_2.png', '003_3.png']]
</code></pre>
<hr/>
<p>Otherwise, you can base your code on <a href="https://stackoverflow.com/questions/50086452/a-recipe-to-group-aggregate-data/50086453#50086453">this recipe</a>, which is more efficient than sorting the list and then using <code>groupby</code>.</p>
<ul>
<li><p><strong>Input:</strong> Your input is a flat list, so use a regular ol' loop to iterate over it:</p>
<pre><code>for filename in files:
</code></pre></li>
<li><p><strong>Group identifier:</strong> The files are grouped by the first 3 letters:</p>
<pre><code>group = filename[:3]
</code></pre></li>
<li><p><strong>Output:</strong> The output should be a nested list rather than a dict, which can be done with</p>
<pre><code>result = list(groupdict.values())
</code></pre></li>
</ul>
<p>Putting it together:</p>
<pre><code>files = ['001_1.png', '001_2.png', '001_3.png', '002_1.png','002_2.png',
        '003_1.png', '003_2.png', '003_3.png']

import collections

groupdict = collections.defaultdict(list)
for filename in files:
    group = filename[:3]
    groupdict[group].append(filename)

result = list(groupdict.values())

print(result)
# [['001_1.png', '001_2.png', '001_3.png'],
#  ['002_1.png', '002_2.png'],
#  ['003_1.png', '003_2.png', '003_3.png']]
</code></pre>
<p>Read <a href="https://stackoverflow.com/questions/50086452/a-recipe-to-group-aggregate-data/50086453#50086453">the recipe answer</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it using a <code>dictionary</code>.</p>
<pre><code>list = ['001_1.png', '001_2.png', '003_3.png', '002_1.png', '002_2.png', '003_1.png', '003_2.png', '003_3.png', '003_4.png']

dict = {}
for item in list:
  if item[:3] not in dict:
    dict[item[:3]] = []
  dict[item[:3]].append(item)
</code></pre>
<p>Then you have to sort the dictionary by key value.</p>
<pre><code>dict = {k:v for k,v in sorted(dict.items())}
</code></pre>
<p>The last step is to use a <code>list</code> comprehension in order to achieve your requirement.</p>
<pre><code>list = [v for k,v in dict.items()]
print(list)
</code></pre>
<p>Output</p>
<pre><code>[['001_1.png', '001_2.png'], ['002_1.png', '002_2.png'], ['003_3.png', '003_1.png', '003_2.png', '003_3.png', '003_4.png']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a simple iteration and dictionary.</p>
<p><strong>Ex:</strong></p>
<pre><code>l = ['001_1.png', ' 001_2.png', ' 003_3.png', ' 002_1.png', ' 002_2.png', ' 003_1.png', ' 003_2.png', ' 003_3.png', ' 003_4.png']
r = {}
for i in l:
    v = i.split("_")[0][-1]
    if v not in r:
        r[v] = []
    r[v].append(i)
print(r.values())
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[['001_1.png', ' 001_2.png'], [' 003_3.png', ' 003_1.png', ' 003_2.png', ' 003_3.png', ' 003_4.png'], [' 002_1.png', ' 002_2.png']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your list is ordered like this here is a short script for this task.</p>
<pre><code>myList = []
for i in a:
    if i[:-4].endswith('1'):
        myList.append([i])
    else:
        myList[-1].append(i)

# [['001_1.png', '001_2.png', '003_3.png'], ['002_1.png', '002_2.png'], ...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#IYN

mini_list = []
p = ['001_1.png', '001_2.png', '001_3.png', '002_1.png','002_2.png', '003_1.png', '003_2.png', '003_3.png', '003_4.png']
new_p = []

for index, element in enumerate(p):
    if index == len(p)-1:
        mini_list.append(element)
        new_p.append(mini_list)
        break

    if element[0:3]==p[index+1][0:3]:
        mini_list.append(element)

    else:
        mini_list.append(element)
        new_p.append(mini_list)
        mini_list = []

print (new_p)
</code></pre>
<p>The code above will cut the initial list into sub lists and append them as individual lists into a resulting, larger list.
Note: not a few lines, but you can convert this to a function.</p>
<pre><code>def list_cutter(ls):
    mini_list = []
    new_list = []

    for index, element in enumerate(ls):
        if index == len(ls)-1:
            mini_list.append(element)
            new_list.append(mini_list)
            break

        if element[0:3]==ls[index+1][0:3]:
            mini_list.append(element)

        else:
            mini_list.append(element)
            new_list.append(mini_list)
            mini_list = []

    return new_list
</code></pre>
</div>
<span class="comment-copy">In your desired output, should the third element be 001_3.png?</span>
<span class="comment-copy">Is it always like this, I mean ordered ?</span>
<span class="comment-copy">The third one should be 001_3.png, right?</span>
<span class="comment-copy">Beatiful answer and upvote. I know the feeling when write a long and correct answer and nobody upvote it in order to recognize the invested time and effort into answering it.</span>
<span class="comment-copy">@MihaiAlexandru-Ionut Thanks :) I couldn't stand the low text/code ratio in this thread, so I decided to do something about it. Your answer was the only one that had a significant amount of explanation.</span>
