<div class="post-text" itemprop="text">
<p>The typing module allows assigning complex type signatures to <a href="https://docs.python.org/3/library/typing.html#type-aliases" rel="nofollow noreferrer">aliases</a>, which can then be used interchangeably with the actual type. This seems to have the problem that it confuses type aliases with actual classes, i.e. in a definition like this</p>
<pre><code>def foo(obj: MyComplexObject):
    ...
</code></pre>
<p>there is no way to tell if <code>MyComplexObject</code> is implemented as a class somewhere or is just a type alias. This seems to be an unfortunate source of confusion to me, especially when the alias is (re)used far from its original definition. Is that generally accepted or is there a convention to somehow distinguish type aliases from actual classes?</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe type aliases and regular types are indistinguishable by design: type aliases are meant to be exact stand-ins for whatever type they're aliasing.</p>
<p>So, to use your example, it doesn't necessarily matter if <code>MyComplexObject</code> is an actual class or a type alias: they both behave equivalently at runtime and static typecheck time.</p>
<p>And because the type checker can give you immediate feedback on whether or not you're using <code>obj</code> in a type-safe way, there are minimal opportunities to get confused: either you'll use the <code>obj</code> parameter correctly or you'll get immediate feedback otherwise. (And similarly, IDEs such as Pycharm that understand PEP 484 semantics will also understand type aliases and will correctly auto-complete/flag mistakes.)</p>
<p>It's also worth noting that in the case where you specifically alias other classes, the alias and the original class are literally indistinguishable at runtime: they're both variables that refer to the same underlying type object. (So arguably, there's nothing to actually be confused about: both the alias and the original type are the "same thing".)</p>
<p>Consequently, there's been very little incentive to find a naming convention for distinguishing between types and type aliases -- it doesn't really end up being an issue in practice.</p>
<hr/>
<p>That said, there <em>are</em> some implicit conventions for when to <em>use</em> type aliases. For example, people usually don't alias classes directly: type aliases, as Ethan said, are mainly meant to be used to help simplify larger compound types that are repeated in multiple places.</p>
<p>This means that type aliases are mainly used when you would otherwise have a bunch of really ugly type signatures. It then becomes a "tradeoff" sort of thing: the reader does need to spend time looking up the definition of an alias and cache it in their head, but once they do, reading the rest of the code ought to be much more pleasant.</p>
<p>So if you still find type aliases potentially confusing and prefer to avoid using them unless necessary, that's perfectly fine: that's what pretty much everybody else does anyways. The only difference comes down to when you cross that tipping point from "unnecessary" to "necessary".</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no official convention for distinguishing the two.</p>
<p>Type aliases are very similar to typedefs in other languages. However, by convention type aliases are used for complex combinations of types, such as <code>Message = Union[str, MyClass1, MyClass2, OtherClass]</code>, where writing out the full union multiple times would be cumbersome. So a single name annotation should either be: a type, or some combination of types that are aliased. You must go to the definition of that name to tell them apart.</p>
</div>
<span class="comment-copy">Hm, that's a really unpleasant situation. I'm almost inclined to consider Hungarian notation-like alias declarations (<code>MyComplexObject_t</code>) just slightly less annoying than constantly having to wonder if I ever defined a particular class or not.</span>
<span class="comment-copy">Type aliases, like all abstractions, only work if done correctly. They hide a complicated thing into a simpler thing. Fundamentally you are trying to break an abstraction barrier, and probably shouldn't be. Instead, give semantically meaningful names to your aliases, and let those dictate understanding the type.</span>
