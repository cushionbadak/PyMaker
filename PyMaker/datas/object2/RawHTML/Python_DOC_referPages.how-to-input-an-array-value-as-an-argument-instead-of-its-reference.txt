<div class="post-text" itemprop="text">
<p>I have a minor issue with python. I found a way to bypass it but still, it bugs me...
Take the following code, where I tried to rewrite the issue to its simplest form :</p>
<pre><code>"WE DEFINE A SIMPLE OBJET" 
class Object():
    def __init__(self,argument):
        self.table = argument

"We define an array that will be used as the argument for the 'Object' instances" 
tab = [0,0]

"We instanciate 2 'Object' using the 'tab' array as an argument" 
Obj1=Object(tab)
Obj2=Object(tab)

"We change the first value of the first Object's table to 1" 
Obj1.table[0] = 1

"RESULTS (we are expecting the first Object's tab to be [1,0] and the second to be [0,0] but we get [1,0] for both)" 
print(Obj1.table) 
print(Obj2.table)
</code></pre>
<p>Out : </p>
<blockquote>
<p>&gt;&gt;[1,0]</p>
<p>&gt;&gt;[1,0]</p>
</blockquote>
<p>It seems that instead of creating the object <strong>self.table</strong> variable with the '<strong>tab</strong>' value, the <strong>self.table</strong> is linked to the <strong>tab</strong> variable by its reference. As a result, when we try to modify the <strong>self.table</strong> variable in one of the two objects, it is modified in all the other instances as well. Is it normal? Is there something wrong with my code?</p>
<p>For information, I fixed the issue by changing the 4th line to : </p>
<pre><code>self.table = [argument[x] for x in range(len(argument))]
</code></pre>
<p>Thank you!! :)</p>
<p>PS : I don't know if there is any link but this other behavior is also bugging me. Maybe the root cause is the same : </p>
<p>in : </p>
<pre><code>a = [[0,0]]*2
a[0][0] = 1
print(a)
</code></pre>
<p>out : </p>
<blockquote>
<p>&gt;&gt; [[1, 0], [1, 0]]</p>
</blockquote>
<p>This in an unexpected result, whereas,</p>
<p>in : </p>
<pre><code>a = [[0,0] for x in range(2)]
a[0][0] = 1
print(a)
</code></pre>
<p>out : </p>
<blockquote>
<p>&gt;&gt; [[1, 0], [0, 0]]</p>
</blockquote>
<p>gives an expected result.. :p</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python documentation:</p>
<blockquote>
<p>Assignment statements in Python do not copy objects, they create
  bindings between a target and an object. For collections that are
  mutable or contain mutable items, a copy is sometimes needed so one
  can change one copy without changing the other.</p>
</blockquote>
<p>For copying objects there is a special module that could get the job done.
<a href="https://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">Python <strong>copy</strong> module</a></p>
</div>
<div class="post-text" itemprop="text">
<p>When you make an assignment, such as what you are in this example, you're not creating a new object, but rather a reference to the original. An alternative is to deepcopy as per <a href="https://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">https://docs.python.org/2/library/copy.html</a>, however IMO this is quite hacky. </p>
<p>How I avoid issues with this is by trying to make my programs as immutable as possible, meaning I do not want to reassign the variables or change existing variables. Rather, you try to preserve the objects state and create new objects based on the contents of others. </p>
</div>
<span class="comment-copy">Python doesn't work the way you're hoping for. It's not based around value types and copying as a core operation, the way C++ is. If you want to be an effective Python programmer, you're going to need to get used to writing code that works with the language semantics instead of trying to make it work like another language.</span>
<span class="comment-copy">For a good explanation of how variables and objects interact in Python, see <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">Wow thank you for the article!! I wasn't understanding much of how python variables were working. It really helped! :) It should be the official answer, it explains everything.</span>
<span class="comment-copy"><code>copy</code> isn't that useful. When you know you need a shallow copy, you usually know the type of the input well enough that you can just do something like <code>thing[:]</code> or <code>dict(thing)</code> or whatever is appropriate for the input type. When you need something deeper, <code>copy.deepcopy</code> is really slow, unreliable, and often <i>too</i> deep.</span>
