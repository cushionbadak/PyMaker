<div class="post-text" itemprop="text">
<p>Currently I have this structure which I have successfully parsed from text file:</p>
<pre><code>Chain={'damn':[{'you':0.2}, {'it':0.4}, {'fool!':0.4}]}
</code></pre>
<p>And now I'm struggling to build output text based on states (current keys in Chain). Why? Because my probabilities of words are in float format, and I don't know how to convert them to percentage. My first thought was something like this:</p>
<pre><code>def buildText(self, Chain):
    self.state = outText = choice(list(Chain.keys()))
    for i in range(self.iterations):
        step = uniform(0,1)
        self.getState(Chain)
        outText = outText + ' ' + self.state + ' '
    return outText

def getState(self, Chain):
    step = uniform(0,1.1)
    print('Current step is: ', step, ' And state is: ', self.state)
    for d in Chain[self.state]:
        for key in d:
            if d[key] &lt; step:
                print('New state--', key)
                self.state = key
                return
            else:
                continue
</code></pre>
<p>But this function generates repeating texts because, as I mentioned, I don't know how to properly code random function based on my probability format. Any suggestions will be greatly appreciated!
Full code at <a href="https://github.com/Tehtehteh/MarkovChain" rel="nofollow">Github Link</a></p>
</div>
<div class="post-text" itemprop="text">
<h1>Python &gt;= 3.6</h1>
<p><code>random</code> now includes <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a> which will take weights</p>
<pre><code>import random, collections

# convert Chain to a sensible format instead of a list of single element dictionaries
accumulator = {}
for dic in chain['damn']:
    accumulator.update(dic)
values = list(d.keys())
weights = list(d.values())

# Get one value
print(random.choices(values, weights=weights)[0])

# Test distribution
print(collections.Counter(random.choices(values, weights=weights)[0] for i in range(100)))

# prints Counter({'fool!': 41, 'it': 39, 'you': 20})    
</code></pre>
<h1>Python &lt;3.6</h1>
<p><a href="https://docs.python.org/3.5/library/random.html#examples-and-recipes" rel="nofollow noreferrer">See the recipe in the Python docs for creating cumulative distributions</a> (this is what people were describing in the comments)</p>
</div>
<div class="post-text" itemprop="text">
<p>The trick here if that the values form relative probabilities of occurence of their key. You must take as step value a <code>random.uniform(0, tot)</code> where tot is the sum of the probabilities (here it is 1.). Then you compare it with first probability. If it is less, you choose this one, else you substract the probability from the step value and iterate with next probability. If you want to be super safe, you can make the last possibility a catch all to be immune to rounding errors (search for <em>broken floating point arithmetics</em> on SO...)</p>
<p>Code could be:</p>
<pre><code>def buildText(self, Chain):
    self.state = outText = choice(list(Chain.keys()))
    for i in range(self.iterations):
        self.getState(Chain)
        outText = outText + ' ' + self.state + ' '
    return outText
def getState(self, Chain):
    states = Chain[self.state]
    if len(states) == 1:                # beware of corner case: one single option
        k = list(states[0].keys())[0]
        self.state = k
        return
    tot = sum(list(d.values())[0] for d in states)
    step = uniform(0, tot)
    # print(step, '/', tot)                  # uncomment to control what happens
    for s in states[:-1]:                    # test up to last item in list
        k, v = list(s.items())[0]
        if step &lt;= v:                        # less we choose this one
            self.state = k
            return
        step -= v                            # else decrease the step
    self.state = list(states[-1].keys())[0]  # last option is a "catch all"
</code></pre>
</div>
<span class="comment-copy">Since they are already in a float you can just think of them as the % value. <code>0.2 can be thought of as 20%</code>, <code>0.4 can be thought of as 40%</code>. Just generate a random float (between 0 and 1) or number (0 to 100) and just compare what you have and print it out? For the random number please take a look here: <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer">docs.python.org/3/library/random.html</a></span>
<span class="comment-copy">Yup. But what if I have rolled, for example, 0.7. 0.7 is bigger than any probability, therefore my state won't change (what happens now).</span>
<span class="comment-copy">20% + 40% + 40% = 100% right? So stack 20% to be 1-20, the next value of 40% to be 21-60 and the next value of 40% to be 61-100 which means your 70 would be the last 40%.</span>
<span class="comment-copy">Should I then make additional random table for each word ? Sounds really complex to me</span>
<span class="comment-copy">waiting for the answer</span>
