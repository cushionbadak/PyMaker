<div class="post-text" itemprop="text">
<p>There is list named L.
Which contains others list: L=[A,B,C,...N]
I want to for-loop, where B is no equal A (see #2)
Something like: for B is not A in L:</p>
<pre><code>for A in L: #1
    for B in L: #2
</code></pre>
<p>How can I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just access the rest of the list by index:</p>
<pre><code>for i in xrange(len(L)-1):
    for j in xrange(i+1, len(L)):
        #L[i] != L[j] always, and will check just one list against the others once
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use an <code>if</code> statement to filter out the cases you don't want:</p>
<pre><code>for A in L:
    for B in L:
        if A == B:
            continue # skip
        # do stuff ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Better solution using <code>itertools</code>, either <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow">with <code>permutations</code></a> or <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow">with <code>combinations</code></a>:</p>
<pre><code>import itertools

# If it's okay to see L[1], L[2], and later L[2], L[1], that is, order sensitive,
# matching your original question's specification of only avoiding pairing with self:
for A, B in itertools.permutations(L, 2):
    ...

# If you only want to see L[x] paired with L[y] where y &gt; x,
# equivalent to results of Daniel Sanchez's answer:
for A, B in itertools.combinations(L, 2):
    ...
</code></pre>
<p>Either one of these is significantly faster than using nested loops that require indexing (and bonus, requires only one level of indentation, reducing "arrow patterns" in your code).</p>
<p>If the body of the loop was <code>print(A, B, sep=',', end=' ')</code> and <code>L = [1, 2, 3]</code>, the output of the <code>permutations</code> loop would be:</p>
<pre><code>1,2 1,3 2,1 2,3 3,1 3,2
</code></pre>
<p>For <code>combinations</code>, you'd get:</p>
<pre><code>1,2 1,3 2,3
</code></pre>
<p>so choose whichever matches your desired behavior.</p>
<p>An additional benefit of using the <code>itertools</code> functions is that they'll work just fine when <code>L</code> is a non-sequence collection (e.g. a <code>set</code>), or when it's an iterator that can only be traversed once (they'll cache the values internally so they can produce them more than once). Other solutions require explicit conversion to <code>list</code>/<code>tuple</code> or the like to handle the "<code>L</code> is a one-use iterator" case.</p>
</div>
<span class="comment-copy"><code>xrange</code> doesn't exist in Python 3. Use <code>range</code>.</span>
<span class="comment-copy">This will prevent <code>L[1]</code> from pairing with <code>L[0]</code> (in that order). The OP <i>seems</i> to want to allow <code>L[0], L[1]</code> as a pair <i>and</i> <code>L[1], L[0]</code> as a pair since the original loop would produce both, and they only wanted to omit <code>L[x], L[x]</code> pairings...</span>
<span class="comment-copy">That requires an explicit comparison performed <code>len(L) ** 2</code> times. And assumes your <code>list</code> contains homogeneous (or at least comparable) types. And that equal (but not identity equal) pairings should be rejected (which is not clear), which means weird stuff <code>L = [1, True]</code> will produce no outputs at all, while <code>L = [float('nan')]</code> will produce an output pairing it with itself. If it can be done in other ways (e.g. <code>itertools</code> methods, or failing that, index comparisons, which avoid issues with equality, and edge cases of identity caused by caching), it's better to avoid this "test per loop".</span>
