<div class="post-text" itemprop="text">
<p>I'm trying to use recursion to return the dot product of two lists, and I'm trying to account for the situation in which I get two lists of different length: I return 0. However, when I try to check for that condition, I get the error: unsupported operand type(s) for &amp;: 'list' and 'list'. Why can't I use the '&amp;' operand for two lists in Python?</p>
<pre><code>def dot(L, K):
    if L+K == []:
        return 0
    elif L == [] &amp; K != []:
        return 0
    elif K == [] &amp; L != []:
        return 0 
    else:
        return L[-1] * K[-1] + dot(L[:-1], K[:-1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would probably do something like this:</p>
<pre><code>def dot(L, K):
    if L + K == [] or len(L) != len(K): # this only needs to be checked once
        return 0
    return dot_recurse(L, K)

 def dot_recurse(L, K):
     if len(L) &gt; 0:
         return L[-1] * K[-1] + dot_recurse(L[:-1], K[:-1])
     else:
         return 0;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dot(L, K):
    if len(L)!=len(K):  # return 0 before the first recursion
        return 0
    elif not L:  # test if L is [] - previous test implies K is [] so no need to retest
        return 0
    else:
        return L[-1] * K[-1] + dot(L[:-1], K[:-1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is a bit more complicated than it really needs to be. It is not possible to take the dot product of two vectors which are not the same size. There are a couple of ways to deal with receiving vectors of different sizes.</p>
<p>1) Lop off the remaining unused numbers from the larger vector. Below is a modified version of your function. I changed it to only require one check for if either of the vectors is empty (there is no need to check this in multiple ways), and also changed it to start from the beginning of the vectors instead of the end. Was there a particular reason you started from the end?</p>
<pre><code>def dot(L, K):
    if(L == [] or K == []):
        return 0
    else:
        return L[0] + K[0] + dot(L[1:], K[1:])
</code></pre>
<p>While this option works, it does not give the user any indication that they made a mistake in attempting to dot product two different sized vectors.</p>
<p>2) Give the user an error upon receiving two different sized vectors.</p>
<pre><code>def dot(L, K):
    if(len(L) != len(K)):
        print('Vector sizes do not match, please pass two same-sized vectors')
        return 0 #not sure exactly how you are wanting to do error handling here.
    elif(L == [] or K == []):
        return 0
    else:
        return L[0] + K[0] + dot(L[1:], K[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you check out python's <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">Operator Precedence</a> you will see that <code>&amp;</code> has lower precedence than <code>==</code> and <code>and</code></p>
<p>This means you are doing the following:</p>
<pre class="lang-py prettyprint-override"><code>if (L == ([] &amp; K)) != []:
    ...
</code></pre>
<p>As suggested by Tuan333 you should be using <code>and</code>.</p>
<pre class="lang-py prettyprint-override"><code>def dot(L, K):
    if L+K == []:
        return 0
    elif L == [] and K != []:
        return 0
    elif K == [] and L != []:
        return 0 
    else:
        return L[-1] * K[-1] + dot(L[:-1], K[:-1])
</code></pre>
<p>However if you wanted to use <code>&amp;</code> (which is the <strong>Binary AND</strong>, and isn't the same thing) you could just use <code>()</code> to force precedence</p>
<pre class="lang-py prettyprint-override"><code>def dot(L, K):
    if L+K == []:
        return 0
    elif (L == []) &amp; (K != []):
        return 0
    elif (K == []) &amp; (L != []):
        return 0 
    else:
        return L[-1] * K[-1] + dot(L[:-1], K[:-1])
</code></pre>
<hr/>
<p>If you're curious why <code>&amp;</code> is likely not what you want read on:</p>
<ul>
<li><code>AND</code> takes two values, converts them to Booleans (<code>True</code> or <code>False</code>) and check that both are <code>True</code></li>
<li><strong>Binary AND</strong> (<code>&amp;</code>) takes two values, converts them to a Number-like value, then performs an operation on their bits</li>
</ul>
<hr/>
<p>Here is how I would implement this function</p>
<pre class="lang-py prettyprint-override"><code>def dot(L, K):
    if len(L) != len(K):
        # Ensure the lists are the same length
        raise ValueError('Can not perform dot product on two differently sized lists')
    elif len(L) + len(K) == 0:
        # See if we've reached the base case
        return 0
    else:
        # Recurse doing dot product
        return L[-1] * K[-1] + dot(L[:-1], K[:-1])


print(dot([6, 2, 6], [5, 1]))
</code></pre>
</div>
<span class="comment-copy">use <code>and</code> instead of <code>&amp;</code>. The former is a logical and while the later is a bit wise operator</span>
<span class="comment-copy">It doesn't return 0 though. Any idea why?</span>
<span class="comment-copy">what is your input? I replaced the <code>&amp;</code> by the <code>and</code> and it does return <code>0</code> when doing <code>dot([],[1,2])</code> or <code>dot([1,2],[])</code></span>
<span class="comment-copy"><code>dot([6,2,6],[5,1]) = 6*1 + dot([6,2],[5]) = 6*1 + 2*5 + dot([6],[]) = 16</code> if you want to check to see if two lists have different length and return 0, maybe at the beginning, try <code>if not( len(L) == len(K)): return 0</code> (the <code>return 0</code> should be on new line). As far as your recursion function goes, it will try to multiply the last elements, then add that number to whatever the recurssion part returns, that's why you don't have 0.</span>
<span class="comment-copy">the last recurse will return a 0, which will just be added to the total of all the previous calls.  If you want it to bail, you will need to provide a length comparison as before anything else.</span>
<span class="comment-copy">you have no stopping condition anymore in your recursion</span>
<span class="comment-copy">@Tuan333 kindly added one.</span>
<span class="comment-copy">@miah welcome. I would solve this problem with this same code too.</span>
