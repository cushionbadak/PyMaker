<div class="post-text" itemprop="text">
<p>How can I check if any of my list of URLs match the given <code>url</code>? I need URLs to match only if all GET parameter names (not their values) and the path are the same. For example, I have this list:</p>
<pre><code>links = [
  "http://example.com/page.php?param1=111&amp;param2=222",
  "http://example.com/page2.php?param1=111&amp;param2=222",
  "http://example.com/page2.php?param1=111&amp;param2=222&amp;someParameterN=NumberN"
  ]

url = "http://example.com/page2.php?param1=NOT111&amp;param2=NOT222"
</code></pre>
<p>This example is <code>True</code> because <code>url</code> matches <code>links[1]</code>. But how to match it in the most efficient way? I don't know what <code>url</code> will looks like.</p>
</div>
<div class="post-text" itemprop="text">
<p>You ideally want to use python's urlparse library.
Parse your url like so:</p>
<pre><code>import urlparse
url = "http://example.com/page2.php?param1=NOT111&amp;param2=NOT222"
parsed_url = urlparse.urlparse(url)
urlparse.parse_qs(parsed_url.query).keys()
</code></pre>
<p>Then you create a datastructure which looks something like this:</p>
<pre><code>seen_pages = set() # Stores all pages you've already seen.
</code></pre>
<p>And then all your pages to it like so:</p>
<pre><code>for page in list_of_pages:
    parsed_url = urlparse.urlparse(page)
    current_page = (parsed_url.path, frozenset(urlparse.parse_qs(parsed_url.query).keys())
    seen_pages.add(current_page)
</code></pre>
<p>This stores all your pages in the form: <code>tuple(link, set(param1,param2))</code> in a set.</p>
<p>To look up if you've already visited the page, with those exact parameters, simply create the <code>current_page</code> structure again and look it up in the set.
Look up and addition to a set is an <code>O(1)</code> operation, that is, it is as fast as you can get.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's standard library comes with a package for parsing urls: <a href="https://docs.python.org/3/library/urllib.parse.html" rel="nofollow"><code>urllib.parse</code></a>.  Don't try to write your own regexes for this... <em>especially</em> if you haven't considered all the weird things that are legal parts of a URL.</p>
<p>I suggest something like below.  <code>is_url_in_list</code> is the question you want answered.  It calls <code>url_file_and_params</code> to break the URl into the file path and a set of query parameters.  <code>url_file_and_params</code> calls <code>url_params_from_quoted_query</code> to build the set of parameter names.</p>
<pre class="lang-python3 prettyprint-override"><code>#!/usr/bin/env python3

from urllib.parse import parse_qs
from urllib.parse import urlsplit


def url_params_from_quoted_query(query_string):
    # An empty query string would make parse_qs raise a ValueError.
    if '' == query_string:
        return set()
    params_and_values = parse_qs(
      query_string,
      keep_blank_values=True,
      strict_parsing=True,
      )
    params = set(params_and_values)
    return params


def url_file_and_params(url):
    parts = urlsplit(url)
    url_file = parts[2]
    quoted_query = parts[3]
    url_params = url_params_from_quoted_query(quoted_query)
    return url_file, url_params


def is_url_in_list(url_target, url_list):
    target_file, target_params = url_file_and_params(url_target)
    for url in url_list:
        url_file, url_params = url_file_and_params(url)
        if url_file == target_file and url_params == target_params:
            return True
    return False


def main():
    links = [
      "http://example.com/page.php?param1=111&amp;param2=222",
      "http://example.com/page2.php?param1=111&amp;param2=222",
      "http://example.com/page2.php?param1=&amp;param2=222",
      "http://example.com/page2.php",
      "http://example.com/page2.php?param1=111&amp;param2=222&amp;someParameterN=NumberN"
      ]

    url = "http://example.com/page2.php?param1=NOT111&amp;param2=NOT222"
    print(is_url_in_list(url, links))
    return


if "__main__" == __name__:
    main()
</code></pre>
<p>One assumption this code makes is that your URLs are already UTF-8 strings with correctly percent-encoded query strings.  If not, you might need to use <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote" rel="nofollow"><code>quote</code></a> or <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote_from_bytes" rel="nofollow"><code>quote_from_bytes</code></a> before feeding them to <code>is_url_in_list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think <a href="http://www.tutorialspoint.com/python/string_split.htm" rel="nofollow">split</a> is your friend )</p>
<p>First compare <code>links[i].split('?')[0]</code> with <code>url.split('?')[0]</code></p>
<p>Then if true - split your vars with <code>'&amp;'</code>. </p>
<p>I think there exists more optimal way, i'm only a newbee, but this way will works.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think that <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlparse" rel="nofollow"><code>urllib.parse.urlparse()</code></a> (if you are using Python 3) will help you, or <code>urlparse.urlparse()</code> for Python 2.</p>
<p>This function will break the URL up into its various components. Then you can compare all components, or a subset of them as you require. Example (Python 3)</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import urlparse
&gt;&gt;&gt; urlparse('http://example.com/page.php?param1=111&amp;param2=222')
ParseResult(scheme='http', netloc='example.com', path='/page.php', params='', query='param1=111&amp;param2=222', fragment='')


&gt;&gt;&gt; url1 = urlparse('http://example.com/page.php?param1=111&amp;param2=222')
&gt;&gt;&gt; url2 = urlparse('http://example.com/page.php?param1=111&amp;param2=222')
&gt;&gt;&gt; url1 == url2
True

&gt;&gt;&gt; url3 = urlparse('http://example.com/page2.php?param2=222&amp;param1=111')
&gt;&gt;&gt; url1 == url3
False
&gt;&gt;&gt; url1.query == url3.query    # same GET params but in different order
False
</code></pre>
<p>The last example shows that the order of parameters in the query string affects the comparison. You can account for that by using <code>urllib.parse.parse_qs()</code>:</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import parse_qs
&gt;&gt;&gt; parse_qs(url1.query)
{'param2': ['222'], 'param1': ['111']}
&gt;&gt;&gt; parse_qs(url1.query) == parse_qs(url3.query)
True
</code></pre>
<p>You can use the <code>.path</code> attribute of the <code>ParseResult</code> to compare "pages".</p>
<p>As I said, I think that will help you, however, I don't fully understand exactly what you are trying to do.</p>
</div>
<span class="comment-copy">Nice touch making the data hashable (I'd forgotten about <code>frozenset</code>).  You could create a <code>namedtuple</code> named something like <code>ComparableURL</code> with <code>path</code> and <code>params</code> fields, and store them in your <code>seen_pages</code> set... pretty-printing and .fieldname access for free.</span>
<span class="comment-copy">@KevinJ.Chase You're right, I could've used a named tuple, but I felt the length and additional overhead of an extra class would've detracted from the brevity of the answer. That's probably how I'd do it in actual shipping code though.</span>
<span class="comment-copy">Thank you =) But can you show an example how to look it up? Because I am trying to make exactly this action. And is it possible to look up in SET()?</span>
<span class="comment-copy">@passwd it is possible to look up in the set. I'll add an example of the lookup.</span>
<span class="comment-copy">Yes, this can work, but Python comes with the <a href="https://docs.python.org/3/library/urllib.parse.html" rel="nofollow noreferrer"><code>urllib.parse</code></a>, which does exactly this kind of work for you.  For example, it would also handle splitting the query parameters from their values (one more split, on <code>=</code>), and building a <code>dict</code> out of them.</span>
<span class="comment-copy">One time investment that has paid me back many times over was reading all the one-line descriptions of the <a href="https://docs.python.org/3/library/" rel="nofollow noreferrer">Python standard library's packages</a> and reading all the <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">Python builtins</a>...  It gave me a good idea what had already been done for me, so I could re-invent... well, less than I used to.</span>
<span class="comment-copy">You are right, there are a lot of information. I think man who try to answer takes more score of points to his knowledge base, so I'm trying to state my map of knowledge.</span>
<span class="comment-copy">This tests all parts of the URL, but passwd only wanted to match a few of them... the file path, and the query parameters (but not their values).  I agree that <code>urllib.parse</code> is the way to go, though.</span>
