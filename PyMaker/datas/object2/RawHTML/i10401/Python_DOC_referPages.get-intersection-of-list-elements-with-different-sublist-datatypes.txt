<div class="post-text" itemprop="text">
<p>I have two lists, which contains list elements, e.g:</p>
<pre><code>list1 = [['placeholder1', {'data': 'data1'}], ['placeholder2', {'data': 'data2'}], ['placeholder2', {'data': 'data1'}]]
list2 = [['placeholder2', {'data': 'data2'}], ['placeholder3', {'data': 'data5'}]]

intersection_result = [['placeholder2', {'data': 'data2'}]]
</code></pre>
<p>The structure of the sub-list elements is just an example. It can also happen that all the sub-list elements contains strings <code>['asdf', 'qwert']</code> or a mixture of string and numbers <code>['sdfs', 232]</code>. However, the sub-list structure is always the same (in both lists).</p>
<p>How can I get the intersection of lists elements which are identical in both lists?</p>
</div>
<div class="post-text" itemprop="text">
<p>If my understanding is correct, you can get the intersection by checking and selecting <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow"><code>any()</code></a> of the elements in the smallest list which are equal to ones in the larger one.</p>
<p>With a comprehension, this would look like this:</p>
<pre><code>intersection_res = [l for l in min(list2, list1, key=len) if any(l == l2 for l2 in max(list1, list2, key=len))]
</code></pre>
<p>This uses, <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow"><code>min</code></a> and <a href="https://docs.python.org/3/library/functions.html#max" rel="nofollow"><code>max</code></a> with a key assigned to <a href="https://docs.python.org/3/library/functions.html#len" rel="nofollow"><code>len</code></a> to always select from the smaller list and check against the larger one.</p>
<p>This yields:</p>
<pre><code>print(intersection_res)
[['placeholder2', {'data': 'data2'}]]
</code></pre>
<p>This comprehension can be trimmed down if you pre-assign the min-max lists or, of course, if you are always certain which list is larger than the other:</p>
<pre><code>sm, la = list1, list2 if len(list1) &lt; len(list2) else list2, list1
intersection_res = [l for l in sm if any(l == l2 for l2 in la)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution, which would be <strong>independent of the structure of your data</strong>.
You can generate <a href="https://stackoverflow.com/questions/16735786/how-to-generate-unique-equal-hash-for-equal-dictionaries">signature hashes</a> (using json or pformat) for your data, and find common hashes in both list1 and list2.</p>
<p><strong>Demo</strong> : <a href="http://ideone.com/5i9cs8" rel="nofollow noreferrer">http://ideone.com/5i9cs8</a> </p>
<pre><code>import json

list1 = [['placeholder1', {'data': 'data1'}], ['placeholder2', {'data': 'data2'}], ['placeholder2', {'data': 'data1'}]]
list2 = [['placeholder2', {'data': 'data2'}], ['placeholder3', {'data': 'data5'}]]
sig1 = { hash(json.dumps(x, sort_keys=True)):x for x in list1 }
sig2 = { hash(json.dumps(x, sort_keys=True)):x for x in list2 }
result = {x:sig1[x] for x in sig1 if x in sig2}
print(result)
#prints {-7754841686355067234: ['placeholder2', {'data': 'data2'}]}
</code></pre>
<ul>
<li>If your dictionaries have data which does not support json serialization e.g. datetime, pformat will work well, or you can use cPickle, <code>str</code> will also work for simple cases. You can make the choice based on your dataset and efficiency required.</li>
</ul>
</div>
<span class="comment-copy">Are hashes are guaranteed to be unique?</span>
<span class="comment-copy">@PadraicCunningham For most practical cases, yes. The <code>hash</code> part can be removed as well, and json.dumps with sort_keys will be unique string key too.</span>
