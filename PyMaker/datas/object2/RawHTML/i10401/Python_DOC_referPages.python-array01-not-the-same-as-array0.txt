<div class="post-text" itemprop="text">
<p>I'm using Python to split a string of 2 bytes <code>b'\x01\x00'</code>. The string of bytes is stored in a variable called <code>flags</code>.</p>
<p>Why when I say <code>flags[0]</code> do I get <code>b'\x00'</code> but when I say <code>flags[0:1]</code> I get the expected answer of <code>b'\x01'</code>.</p>
<p>Should both of these operations not be exactly the same?</p>
<p>What I did:</p>
<pre><code>&gt;&gt;&gt; flags = b'\x01\x00'
&gt;&gt;&gt; flags[0:1]
b'\x01'
&gt;&gt;&gt; bytes(flags[0])
b'\x00'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>bytes</code> is a sequence type containing <em>integers</em> (each in the range 0 - 255) so indexing to a specific index gives you an integer.</p>
<p>And just like slicing a list produces a new list object for the slice, so does slicing a <code>bytes</code> object produce a new <code>bytes</code> instance. And the representation of a <code>bytes</code> instance tries to show you a <code>b'...'</code> literal syntax with the integers represented as either printable ASCII characters or an applicable escape sequence when the byte isn't printable. All this is great for developing but may hide the fact that bytes are really a sequence of integers.</p>
<p>However, you will still get the <em>same piece of information</em>; <code>flags[0:1]</code> is a one-byte long <code>bytes</code> value with the <code>\x01</code> byte in it, and <code>flags[0]</code> will give you the integer <code>1</code>:</p>
<pre><code>&gt;&gt;&gt; flags = b'\x01\x00'
&gt;&gt;&gt; flags[0]
1
&gt;&gt;&gt; flags[0:1]
b'\x01'
</code></pre>
<p>What you <strong>really</strong> did was not use <code>flags[0]</code>, you used <code>bytes(flags[0])</code> instead. Passing in a single integer to the <code>bytes()</code> type creates a new <code>bytes</code> object of the specified length, pre-filled with <code>\x00</code> bytes:</p>
<pre><code>&gt;&gt;&gt; flags[0]
1
&gt;&gt;&gt; bytes(1)
b'\x00'
</code></pre>
<p>Since <code>flags[0]</code> produces the integer 1, you told <code>bytes()</code> to return a new bytes value of length 1, filled with <code>\x00</code> bytes.</p>
<p>From the <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code> documentation</a>:</p>
<blockquote>
<p>Bytes objects are immutable sequences of single bytes.</p>
<p>[...]</p>
<p>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that <code>0 &lt;= x &lt; 256</code>.</p>
<p>[...]</p>
<p>In addition to the literal forms, bytes objects can be created in a number of other ways:</p>
<ul>
<li><strong>A zero-filled bytes object of a specified length: <code>bytes(10)</code></strong></li>
</ul>
</blockquote>
<p>Bold emphasis mine.</p>
<p>If you wanted to create a new <code>bytes</code> object with that one byte in it, you'll need to put the integer value in a list first:</p>
<pre><code>&gt;&gt;&gt; bytes([flags[0]])
b'\x01'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you should get the same thing. In both cases <code>b'\x01'</code>. <code>flags</code> is probably not what you think it is.</p>
<pre><code>&gt;&gt;&gt; flags = b'\x01\x00'
&gt;&gt;&gt; flags[0]
'\x01'
&gt;&gt;&gt; flags[0:1]
'\x01'
</code></pre>
</div>
<span class="comment-copy">No, slicing is not the same thing as indexing.</span>
<span class="comment-copy">I thought, array[0:1] was the same as array[0] because it's inclusive of the 0th index and exclusive of the 1st index.</span>
<span class="comment-copy">When you say <code>flags[0]</code> you'd get <code>1</code>, not <code>b'\x00'</code>.</span>
<span class="comment-copy">Sorry again! You're correct, I was printing bytes(flags[0])</span>
<span class="comment-copy">@Francis: <code>bytes(flags[0])</code> is extra confusing, because <code>flags[0]</code> returns <code>1</code>, and the <code>bytes</code> constructor interprets <code>int</code> arguments as "create a zeroed out <code>bytes</code> object of that length", so <code>bytes(flags[0])</code> is equivalent to <code>bytes(1)</code>, which constructs <code>b'\x00'</code>.</span>
<span class="comment-copy">This only applies to Python 2, which will treat <code>flags</code> as a <code>str</code>. Python 3 behaves differently, treating <code>flags</code> as an instance of <code>bytes</code>.</span>
<span class="comment-copy">The OP is on Python 3 (otherwise they would have a <code>repr</code> with a <code>b</code> prefix), so no, not the same thing at all.</span>
