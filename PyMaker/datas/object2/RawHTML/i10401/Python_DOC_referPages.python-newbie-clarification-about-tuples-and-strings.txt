<div class="post-text" itemprop="text">
<p>I just learned that I can check if a substring is inside a string using:</p>
<blockquote>
<p>substring in string</p>
</blockquote>
<p>It looks to me that a string is just a special kind of tuple where its elements are chars. So I wonder if there's a straightforward way to search a slice of a tuple inside a tuple. The elements in the tuple can be of any type.</p>
<blockquote>
<p>tupleslice in tuple</p>
</blockquote>
<p>Now my related second question:</p>
<pre><code>&gt;&gt;&gt; tu = 12 ,23, 34,56
&gt;&gt;&gt; tu[:2] in tu
False
</code></pre>
<p>I gather that I get False because (12, 23) is not an element of tu. But then, why substring in string works?. Is there syntactic sugar hidden behind scenes?.</p>
</div>
<div class="post-text" itemprop="text">
<p>A string is not just a special kind of tuple. They have many similar properties, in particular, both are iterators, but they are distinct types and each defines the behavior of the <code>in</code> operator differently. See the docs on this here: <a href="https://docs.python.org/3/reference/expressions.html#in" rel="nofollow">https://docs.python.org/3/reference/expressions.html#in</a></p>
<p>To solve your problem of finding whether one tuple is a sub-sequence of another tuple, writing an algorithm like in your answer would be the way to go. Try something like this:</p>
<pre><code>def contains(inner, outer):
  inner_len = len(inner)
  for i, _ in enumerate(outer):
    outer_substring = outer[i:i+inner_len]
    if outer_substring == inner:
      return True
  return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>string</code> is not a type of <code>tuple</code>. Infact both belongs to different class. How <code>in</code> statement will be evaluated is based on the <code>__contains__()</code> magic function defined within there respective class.</p>
<p>Read <a href="https://stackoverflow.com/questions/14766767/how-do-you-set-up-the-contains-method-in-python">How do you set up the contains method in python</a>, may be you will find it useful. To know about magic functions in Python, read: <a href="http://www.rafekettler.com/magicmethods.html" rel="nofollow noreferrer">A Guide to Python's Magic Methods</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is how I accomplished to do my first request, however, it's not straightforward nor pythonic. I had to iterate the Java way. I wasn't able to make it using "for" loops.</p>
<pre><code>def tupleInside(tupleSlice):
    i, j = 0, 0
    while j &lt; len(tu):
        t = tu[j]
        ts = tupleSlice[i]
        print(t, ts, i, j)
        if ts == t:
            i += 1
            if i == len(tupleSlice):
                return True
        else:
            j -= i
            i = 0
        j += 1
    return False

tu = tuple('abcdefghaabedc')
print(tupleInside(tuple(input('Tuple slice: '))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try just playing around with tuples and splices. In this case its pretty easy because your splice is essentially indexing. </p>
<pre><code>&gt;&gt;&gt; tu = 12 ,23, 34,56  
&gt;&gt;&gt; tu
(12, 23, 34, 56) #a tuple of ints
&gt;&gt;&gt; tu[:1] # a tuple with an int in it
(12,) 
&gt;&gt;&gt; tu[:1] in tu #checks for a tuple against int. no match.
False 
&gt;&gt;&gt; tu[0] in tu #checks for int against ints. matched!
True
&gt;&gt;&gt; #you can see as we iterate through the values...
&gt;&gt;&gt; for i in tu:
         print(""+str(tu[:1])+" == " + str(i))

(12,) == 12
(12,) == 23
(12,) == 34
(12,) == 56
</code></pre>
<p>Splicing is returning a list of tuples, but you need to index further to compare <code>in</code> by values and not containers. Spliced strings return values, strings and the <code>in</code> operator can compare to values, but splicing tuples returns tuples, which are containers. </p>
</div>
<div class="post-text" itemprop="text">
<p>Just adding to Cameron Lee's answer so that it accepts <code>inner</code> containing a single integer.</p>
<pre><code>def contains(inner, outer):
    try:
        inner_len = len(inner)
        for i, _ in enumerate(outer):
            outer_substring = outer[i:i+inner_len]
            if outer_substring == inner:
                return True
        return False
    except TypeError:
        return inner in outer

contains(4, (3,1,2,4,5))  # returns True
contains((4), (3,1,2,4,5))  # returns True
</code></pre>
</div>
<span class="comment-copy">Well, strings are not tuples.</span>
<span class="comment-copy">"a string is just a special kind of tuple" This isn't true in any straightforward sense. The string class doesn't inherit from the tuple class.</span>
<span class="comment-copy">OK, String is not inherited from Tuple. I thought otherwise. What about searching for a tupleslice in a tuple?. How can be done?.</span>
<span class="comment-copy">Uau!. Talk about some real real python coding!. Thanks. This is a way more compact code and easier to understand. One little question: Is the underscore a usual way to name dummy variables or is it just you?.</span>
<span class="comment-copy">I guess the only downside is a little overhead for executing enumerate(), but I'm OK with this in order to improve code maintenability. Many times you can make the code faster but if it's at expense of readability it might not be a good idea.</span>
<span class="comment-copy">Yes, the underscore is a common way to denote that a variable is unused.</span>
<span class="comment-copy">I definitely focused on readability in this code over speed. I wanted to show that you can use higher-level building blocks to write an algorithm like this. Regarding speed, you're right that it shouldn't always be prioritised over readability. Also, it's hard to tell how fast code is just by reading it, so you really need to benchmark. In particular, I wouldn't expect enumerate to provide any kind of significant overhead. My understanding is that in Python, even just accessing variables has some overhead. So the fact that this is simpler than your algorithm might make it faster too.</span>
