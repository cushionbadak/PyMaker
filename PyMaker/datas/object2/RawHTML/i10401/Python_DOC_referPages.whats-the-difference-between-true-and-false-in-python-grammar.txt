<div class="post-text" itemprop="text">
<p>I'm reading <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">the python language specification</a> and found there's a <code>None</code>,
<code>True</code>, and <code>False</code> token. I can understand the difference between <code>None</code> and
<code>False</code> since <code>None</code> is not a boolan. But, about <code>True</code> and <code>False</code>, why not
just <code>BOOLEAN</code> there? Is there any case where <code>True</code> and <code>False</code>
behave differently? Or is there any semantical difference?</p>
<p>Note that I'm asking about the difference in grammar not the boolean value which
is obviously different.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a formalization of the fact that <code>True</code> and <code>False</code> are special names in python3: you can't assign to them.  </p>
<p>The reason that they aren't BOOLEAN is simply that boolean isn't a <a href="https://docs.python.org/3/library/token.html" rel="nofollow">valid token</a> for the parser.  </p>
<p><em>Note:</em> You will find this detail missing in the python2 grammar, where you <em>can</em> actually assign to the names True and False (...if you want to watch the world burn).  </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>atom: ('(' [yield_expr|testlist_comp] ')' |
       '[' [testlist_comp] ']' |
       '{' [dictorsetmaker] '}' |
       NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
</code></pre>
<p><code>NAME</code>, <code>NUMBER</code>, and <code>STRING</code> are tokens representing three classes of tokens. Each of them represents an unlimited set of possible tokens. There are many number literals that can be classified as <code>NUMBER</code>, many string literals that can be <code>STRING</code>s, etc.</p>
<p>There are only two boolean literals, <code>True</code> and <code>False</code>. The tokenizer could have been written to classify them both as <code>BOOLEAN</code>. Could have, but wasn't. They're only referred to once in the entire grammar, so writing <code>'True' | 'False'</code> is no big deal.</p>
</div>
<div class="post-text" itemprop="text">
<p>Presumably from the reference to which you linked you are referring to the grammatical production</p>
<pre><code>atom: ('(' [yield_expr|testlist_comp] ')' |
       '[' [testlist_comp] ']' |
       '{' [dictorsetmaker] '}' |
       NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
</code></pre>
<p>This simply gives the strings <code>None</code>, <code>True</code>, and <code>False</code> the same status as certain other language elements. While it would have been possible to create a definition of a Boolean atom which could either be <code>True</code> or <code>False</code> and use that in the grammar, what purpose would that have served?</p>
<p>In point of fact, even in 2.7 you can try to delete the <code>True</code> and <code>False</code> definitions from the <code>__builtins__</code> namespace:</p>
<pre><code>&gt;&gt;&gt; del __builtins__.True
&gt;&gt;&gt; del __builtins__.False

Traceback (most recent call last):
  File "/Users/sholden/.virtualenvs/jlab/lib/python2.7/encodings/utf_8.py", line 16, in decode
    return codecs.utf_8_decode(input, errors, True)
NameError: global name 'True' is not defined
</code></pre>
<p>Interestingly, if you delete <code>False</code> first there is no complaint about the deletion of <code>True</code> :-)</p>
<p>However, this makes even quite standard Python make no sense at all:</p>
<pre><code>&gt;&gt;&gt; 1 == 1

Traceback (most recent call last):
  File "/Users/sholden/.virtualenvs/jlab/lib/python2.7/encodings/utf_8.py", line 16, in decode
    return codecs.utf_8_decode(input, errors, True)
NameError: global name 'True' is not defined
</code></pre>
<p>This underlines that Python was produced as "a programming language for consenting adults." Ultimately it gives you enough rope to hang yourself if you are determined to do that.</p>
</div>
<span class="comment-copy">All the 21st century is based on the difference between True and False.</span>
<span class="comment-copy">I don't understand the question. <code>True</code> and <code>False</code> are distinct tokens, so they're both in the grammar. Are you asking why there isn't a <code>boolean: 'True' | 'False'</code> production?</span>
<span class="comment-copy"><code>True</code> and <code>False</code> are Python constants, therefore considered an <code>atom</code>. Not sure what else you are looking for</span>
<span class="comment-copy"><code>boolean: ('True' | 'False')</code>, would just add another indirection. Why is that <i>better</i> in your interpretation?</span>
<span class="comment-copy">So there no difference then? I'm writing a python interpreter now for learning purpose. That's why I need to now if there's any difference.</span>
<span class="comment-copy">And then you can <code>del</code> them to restore sense!</span>
<span class="comment-copy">@holdenweb - And then you can try <code>del</code>ing them again, but it'll tell you that they're not defined, even though you can still use them and see that they're what they should be.</span>
<span class="comment-copy">I want to watch the world burn XD</span>
<span class="comment-copy">You'll need 2.7 for that, @MasBagol! @ArtOfWarfare - just goes to show you can't always believe what the interpreter tells you! Once upon a time (extra points: which release?) you could delete them from the built-in namespace, which caused even greater consternation!</span>
<span class="comment-copy">To really watch the world burn, try <code>del __builtins__.True</code>.  :-)</span>
