<div class="post-text" itemprop="text">
<p>I have some group data like below a, b, c and so on. What I want to do is to calculate all possible combinations from the data. It's ok if the count of input data is always same. But in my case, I want to assume that the count of input data is from 0 to N, I mean a, b, c, d, e ...</p>
<p>I think I have to use recurrent loop. But I'm not sure to use recurrent loop to resolve this problem.</p>
<p><strong>Input</strong></p>
<pre><code>a = ["x", "y"]
b = ["q", "w", "c"]
c = ["i", "o", "p"]
...
</code></pre>
<p><strong>Ouput</strong></p>
<p>The expected output is all combinations with each value's all combinations.</p>
<pre><code>[{a:[], b:["q"], c:["i", "o"]}, {a:["x"], b:[], c:["o"]}, ...]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I am understanding what you're looking for, you can use <a href="https://docs.python.org/2.7/library/itertools.html#itertools.product" rel="nofollow"><em>itertools.product()</em></a> over the <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow">powersets</a> of the inputs (there is a recipe for <a href="https://docs.python.org/2.7/library/itertools.html#recipes" rel="nofollow"><em>powerset()</em></a> in the docs).  The <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><em>map()</em></a> function can be used to apply <em>powerset</em> to each of the inputs.</p>
<pre><code>from itertools import product, combinations, chain
from pprint import pprint

def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

names = ['a', 'b', 'c']
a = ["x", "y"]
b = ["q", "w", "c"]
c = ["i", "o", "p"]

result = []
for values in product(*map(powerset, [a, b, c])):
    result.append(dict(zip(names, values)))
pprint(result)
</code></pre>
<p><strong>Here is how it works:</strong></p>
<p>First, it builds the powersets:</p>
<pre><code>&gt;&gt;&gt; list(powerset(["x", "y"]))
[(), ('x',), ('y',), ('x', 'y')]
&gt;&gt;&gt; 
&gt;&gt;&gt; list(powerset(["x", "y"]))
[(), ('x',), ('y',), ('x', 'y')]
&gt;&gt;&gt; list(powerset(["q", "w", "c"]))
[(), ('q',), ('w',), ('c',), ('q', 'w'), ('q', 'c'),
 ('w', 'c'), ('q', 'w', 'c')]
&gt;&gt;&gt; list(powerset(["i", "o", "p"]))
[(), ('i',), ('o',), ('p',), ('i', 'o'), ('i', 'p'), 
 ('o', 'p'), ('i', 'o', 'p')]
</code></pre>
<p>Next <a href="https://docs.python.org/2.7/library/itertools.html#itertools.product" rel="nofollow"><em>product()</em></a> pulls one element from each powerset:</p>
<pre><code>&gt;&gt;&gt; for values in product(*map(powerset, [a, b, c])):
        print(values)

((), (), ())
((), (), ('i',))
((), (), ('o',))
((), (), ('p',))
((), (), ('i', 'o'))
((), (), ('i', 'p'))
((), (), ('o', 'p'))
((), (), ('i', 'o', 'p'))
((), ('q',), ())
((), ('q',), ('i',))
((), ('q',), ('o',))
((), ('q',), ('p',))
((), ('q',), ('i', 'o'))
((), ('q',), ('i', 'p'))
((), ('q',), ('o', 'p'))
((), ('q',), ('i', 'o', 'p'))
</code></pre>
<p>Lastly, we <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><em>zip()</em></a> together the above results with the variable <em>names</em> to make a <a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow"><em>dict()</em></a>:</p>
<pre><code># What zip does
&gt;&gt;&gt; list(zip(['a', 'b', 'c'], ((), ('q',), ('i', 'o', 'p'))))
[('a', ()), ('b', ('q',)), ('c', ('i', 'o', 'p'))]

# What dict does with the zip:
&gt;&gt;&gt; dict(zip(['a', 'b', 'c'], ((), ('q',), ('i', 'o', 'p'))))
{'b': ('q',), 'c': ('i', 'o', 'p'), 'a': ()}
</code></pre>
</div>
<span class="comment-copy">Your output is not so clear. Please, provide more examples.</span>
<span class="comment-copy">Amazing your are! It takes a little time to understand your code. But I confirmed your code is working correctly in my IPython. Thank you.</span>
