<div class="post-text" itemprop="text">
<p>How do I write an equivalent of the code below using map and filter?</p>
<pre><code>res = []
for x in range(5):
    if x % 2 == 0:
        for y in range(5):
            if y % 2 == 1:  
                res.append((x, y))
</code></pre>
<p>This is the expected result:</p>
<pre><code>[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
</code></pre>
<p>Here's the code I wrote, but it doesn't seem to work:</p>
<pre><code>list( map(( lambda x,y: (x,y)), filter((lambda x: x%2 == 0), range(5)), filter((lambda y: y%2 != 0), range(5))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write it as (in Python 2.x):</p>
<pre><code>xs = filter(lambda x: x % 2 == 0, range(5))
ys = filter(lambda y: y % 2 == 1, range(5))
res = [(x, y) for x in xs for y in ys]
</code></pre>
<p>This also uses a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehension</a>.</p>
<p>In Python 3.x:</p>
<pre><code>xs = list(filter(lambda x: x % 2 == 0, range(5)))
ys = list(filter(lambda y: y % 2 == 1, range(5)))
res = [(x, y) for x in xs for y in ys]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't even need map and filter, you could do the whole thing in a list comprehension</p>
<pre><code>[(x,y) for x in range(5) for y in range(5) if not x%2 and y%2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative, you can make use of the fact that odd or even numbers can be captured by using the 3rd <code>step</code> argument of <code>range</code>:</p>
<pre><code>&gt;&gt;&gt; sorted((x,y) for y in range(1,5,2) for x in range(0,5,2))
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>product</code></a> method from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a>, which produces cartesian product of input iterables.</p>
<pre><code>x_arr = [x for x in range(5) if x % 2 == 0]
y_arr = [y for y in range(5) if x % 2 == 1]
from itertools import product
final_arr = product(x_arr, y_arr)
</code></pre>
<p>Output would be <code>[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]</code></p>
</div>
<span class="comment-copy">Comparing your own two approaches, mind that <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">readability counts</a>.</span>
<span class="comment-copy">Thanks. I'll keep that in mind. I just wanted to understand map and filter better. :)</span>
<span class="comment-copy">This gives <code>[(0, 1), (0, 3)]</code> in 3.X. The filter objects need to be wrapped in list(). It worked when I did this. Thanks a lot for your answer!  <code>xs = list(filter(lambda x: x % 2 == 0, range(5))) ys = list(filter(lambda y: y % 2 == 1, range(5))) res = [(x, y) for x in xs for y in ys]</code></span>
<span class="comment-copy">@Taiwosam: thanks for your comment. I have updated the answer to make it clear for others.</span>
