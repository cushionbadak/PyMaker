<div class="post-text" itemprop="text">
<p>I have a function which merges two sorted lists (a, b) into one sorted (c). If given lists have different lengths I need to insert the rest of the longest into the list c. But the way I did it - it gives the result with brackets inside the list c (for instance if a = [1,3,5] and b = [2,4,6] then the function returns [1,2,3,4,5,[6]]. How can I get rid of those brackets?</p>
<p>here`s my code</p>
<pre><code>def merge(a,b):
c = []
i = j = 0
while i &lt; len(a) and j &lt; len(b):
    if a[i] &lt; b[j]:
        c.append(a[i])
        i = i + 1
    elif b[j] &lt; a[i]:
        c.append(b[j])
        j = j + 1
    elif a[i] == b[j]:
        c.append(a[i])
        c.append(b[j])
        i = i + 1
        j = j + 1
if i &lt; len(a):
    c.append(a[i:])
if j &lt; len(b):
    c.append(b[j:])
return c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you would have to add each value individually like this:</p>
<pre><code>if i &lt; len(a):
    for k in a[i:]:
        c.append(k)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow"><code>.extend()</code></a> in your last lines:</p>
<pre><code>if i &lt; len(a):
    c.extend(a[i:])
if j &lt; len(b):
    c.extend(b[j:])
</code></pre>
<p>because <code>a[i:]</code> and <code>b[j:]</code> are going to be lists</p>
<p>But I don't understand why you won't you use existing methods to your end result:</p>
<pre><code>a = [1, 3, 5]
b = [2, 4, 6]

c = a + b

c.sort()

print(c)
</code></pre>
<p>Won't that workÂ ?</p>
</div>
<span class="comment-copy">Look up the <code>.extend()</code> method of lists.</span>
<span class="comment-copy">Side-note: If this isn't for a class, don't reinvent the wheel. Python already includes the batteries for this: <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow noreferrer"><code>heapq.merge</code> takes an arbitrary number of already sorted iterables, and returns a generator that produces the merged values in sorted order</a>. Wrapping in <code>list</code> gets the exact results seen here, so replacing <code>merge(a, b)</code> with <code>list(heapq.merge(a, b))</code> is equivalent (and likely faster, especially as the number of iterables to merge increases).</span>
<span class="comment-copy">Repeated <code>append</code>ing is wasteful; this is why <code>extend</code> exists.</span>
<span class="comment-copy">In theory, concatenating and sorting is inefficient, since the theoretical sorting algorithms can't make use of the existing order. In practice, Python's TimSort hybrid sorting algorithm is designed to handle this scenario quite well (it exploits existing ordering in the inputs), so yes, it's usually fine to just concatenate and sort "from scratch". I suspect the OP is writing this for a class though. If they weren't either concatenation and sorting or <code>heapq.merge</code> would be the way to go (latter is usually slightly slower on average, but can stream inputs and outputs to reduce memory costs).</span>
