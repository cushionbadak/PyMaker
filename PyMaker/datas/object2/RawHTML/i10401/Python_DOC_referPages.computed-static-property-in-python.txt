<div class="post-text" itemprop="text">
<p>Is it possible to have a static property on a class that would be computed as a one off. The idea would be to be able to do it like so:</p>
<pre><code>class Foo:
    static_prop = Foo.one_off_static_method()

    @staticmethod
    def one_off_static_method():
        return 'bar'
</code></pre>
<p>I thought of using <code>__new__</code> as well.</p>
<pre><code>Class Foo:
    def __new__(cls):
         cls.static_prop = ... do everything here
</code></pre>
<p>Not sure the implications of that though.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want it computed at class definition time, see <a href="https://stackoverflow.com/a/39498950/674039">chepner's answer</a> - although I would recommend just to use a module level function instead.</p>
<p>If you want it lazily evaluated, then you might be interested in a <a href="https://pypi.python.org/pypi/cached-property/" rel="nofollow noreferrer"><code>cached_property</code></a>.  </p>
<pre><code>&gt;&gt;&gt; from random import random
&gt;&gt;&gt; from cached_property import cached_property
&gt;&gt;&gt; class Foo(object):
...     @cached_property
...     def one_off_thing(self):
...         print('computing...')
...         return random()
...     
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.one_off_thing
computing...
0.5804382038855782
&gt;&gt;&gt; foo.one_off_thing
0.5804382038855782
</code></pre>
<p><em>Note:</em> it seems every man and his dog has an implementation of memo decorators in Python, this is one of many.  If you're on Python 3, consider <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">functools.lru_cache</a> because it's in the core libraries.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Here you go, I made a small descriptor for you :-)</p>
<p>Upon accessing the attribute, it will be computed and cached.</p>
<pre><code>class CachedStaticProperty:
    """Works like @property and @staticmethod combined"""

    def __init__(self, func):
        self.func = func

    def __get__(self, inst, owner):
        result = self.func()
        setattr(owner, self.func.__name__, result)
        return result
</code></pre>
<p>The way it works is rather simple:</p>
<ol>
<li>Upon using the decorator syntax, I save the function internally.</li>
<li>Upon access, I call the function and set the value as the class value with the same name as the original function.</li>
</ol>
<p>That's all there is to it. Simple and efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>Until the class is actually created, <code>one_off_static_method</code> is just a regular function. It needs to be defined before you attempt to call it, since you want to call it while the <code>class</code> statement is being executed. Once you are done with it, you can simply delete it.</p>
<pre><code>class Foo:
    def _one_off_static_method():
        return 'bar'

    static_prop = _one_off_static_method()
    del _one_off_static_method
</code></pre>
</div>
<span class="comment-copy">Do you want this lazily evaluated (and is it actually something sufficiently expensive and sufficiently likely to never be used that lazy evaluation makes sense)?</span>
<span class="comment-copy">Did you try making a staticmethod a property?</span>
<span class="comment-copy">Do you want it computed at first-use or at class definition time?</span>
<span class="comment-copy">This is what I use: <a href="http://stackoverflow.com/a/6849299/107660">stackoverflow.com/a/6849299/107660</a></span>
<span class="comment-copy">@user2357112 It is expensive, a file gets opened read and a data structure is created.</span>
<span class="comment-copy">This would be computed once per instance though right?</span>
<span class="comment-copy">Yes, once per instance.</span>
<span class="comment-copy">Nice find with <code>functools.lru_cache</code>.</span>
<span class="comment-copy">This is cool. Still not static though ;)</span>
<span class="comment-copy">@mkohram Whoops, here you go :-) It's even smaller :P</span>
<span class="comment-copy">@mkohram Added a small explanation.</span>
