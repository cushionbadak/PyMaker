<div class="post-text" itemprop="text">
<p>I made a quick program that sends a file using sockets in python.</p>
<p>Server:</p>
<pre><code>import socket, threading

#Create a socket object.
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Bind the socket.
sock.bind( ("", 5050) )

#Start listening.
sock.listen()

#Accept client.
client, addr = sock.accept()


#Open a new file jpg file.
file = open("out.jpg", "wb")


#Receive all the bytes and write them into the file.
while True:

    received = client.recv(5)

    #Stop receiving.
    if received == b'':
        file.close()
        break

    #Write bytes into the file.
    file.write( received )
</code></pre>
<p>Client:</p>
<pre><code>import socket, threading

#Create a socket object.
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#Connect to the server.
sock.connect(("192.168.1.3", 5050))


#Open a file for read.
file = open("cpp.jpg", "rb")

#Read first 5 bytes.
read = file.read(5)

#Keep sending bytes until reaching EOF.
while read != b'':

    #Send bytes.
    sock.send(read)

    #Read next five bytes from the file.
    read = file.read(1024)


sock.close()
file.close()
</code></pre>
<p>From experience a learn that send can send an amount of bytes that your network
speed is capble of sending them. If you give for example: sock.send(20 gb) you are going to lose bytes because most network connections can't send 20 gb at
once. You must send them part by part.</p>
<p>So my question is: How can i know the maximum amount of bytes that socket.send()
can send over the internet? How can i improve my program to send the file as quick as possible depending on my internet speed?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>send</code> makes no guarantees that all the data is sent (it's not directly tied to network speed; there are multiple reasons it could send less than requested), just that it lets you know how much was sent. You could explicitly write loops to <code>send</code> until it's all really sent, per <a href="https://stackoverflow.com/a/39603386/364696">Dunno's answer</a>.</p>
<p>Or you could just use <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendall" rel="nofollow noreferrer"><code>sendall</code></a> and avoid the hassle. <code>sendall</code> is basically the wrapper described in <a href="https://stackoverflow.com/a/39603386/364696">the other answer</a>, but Python does all the heavy lifting for you.</p>
<p>If you don't care about slurping the whole file into memory, you could use this to replace your whole loop structure with just:</p>
<pre><code>sock.sendall(file.read())
</code></pre>
<p>If you're on modern Python (3.5 or higher) on a UNIX-like OS, you could optimize a bit to avoid even reading the file data into Python using <a href="https://docs.python.org/3/library/socket.html#socket.socket.sendfile" rel="nofollow noreferrer"><code>socket.sendfile</code></a> (which should only lead to partial <code>send</code> on error):</p>
<pre><code>sock.sendfile(file)
</code></pre>
<p>If the Python doesn't support <code>os.sendfile</code> on your OS, this is just a effectively a loop that <code>read</code>s and <code>send</code>s repeatedly, but on a system that supports it, this directly copies from file to socket in the kernel, without even handling file data in Python (which can improve throughput speeds significantly by reducing system calls and eliminating some memory copies entirely).</p>
</div>
<div class="post-text" itemprop="text">
<p>Just send those bytes in a loop until all were sent, here's an <a href="https://docs.python.org/2/howto/sockets.html#using-a-socket" rel="nofollow">example from the docs</a></p>
<pre><code>def mysend(self, msg):
    totalsent = 0
    while totalsent &lt; MSGLEN:
        sent = self.sock.send(msg[totalsent:])
        if sent == 0:
            raise RuntimeError("socket connection broken")
        totalsent = totalsent + sent
</code></pre>
<p>In your case, <code>MSGLEN</code> would be 1024, and since you're not using a class, you don't need the self argument</p>
</div>
<div class="post-text" itemprop="text">
<p>There are input/output buffers at all steps along the way between your source and destination.   Once a buffer fills, nothing else will be accepted on to it until space has been made available.</p>
<p>As your application attempts to send data, it will fill up a buffer in the operating system that is cleared as the operating system is able to offload that data to the network device driver (which also has a buffer).   </p>
<p>The network device driver interfaces with the actual network and understands how to know when it can send data and how receipt will be confirmed by the other side (if at all).   As data is sent, that buffer is emptied, allowing the OS to push more data from its buffer.   That, in turn, frees up room for your application to push more of its data to the OS.</p>
<p>There are a bunch of other things that factor into this process (timeouts, max hops are two I can think off offhand), but the general process is that you have to buffer the data at each step until it can be sent to the next step.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>From experience a learn that send can send an amount of bytes that
  your network speed is capble of sending them.</p>
</blockquote>
<p>Since you are using a TCP Socket (i.e. SOCK_STREAM), speed-of-transmission issues are handled for you automatically.  That is, once some bytes have been copied from your buffer (and into the socket's internal send-buffer) by the send() call, the TCP layer will make sure they make it to the receiving program, no matter how long it takes (well, within reason, anyway; the TCP layer will eventually give up on resending packets if it can't make any progress at all over the course of multiple minutes).</p>
<blockquote>
<p>If you give for example: sock.send(20 gb) you are going to lose bytes
  because most network connections can't send 20 gb at once. You must
  send them part by part.</p>
</blockquote>
<p>This is incorrect; you are not going to "lose bytes", as the TCP layer will automatically resend any lost packets when necessary.  What might happen, however, is that send() might decide not to accept all of the bytes that you offered it.  That's why it is absolutely necessary to check the return value of send() to see how many bytes send() actually accepted responsibility for -- you <em>cannot</em> simply assume that send() will always accept all the bytes you offered to it.</p>
<blockquote>
<p>So my question is: How can i know the maximum amount of bytes that
  socket.send() can send over the internet?</p>
</blockquote>
<p>You can't.  Instead, you have to look at the value returned by send() to know how many bytes send() has copied out of your buffer.  That way, on your next call to send() you'll know what data to pass in (i.e. starting with the next byte after the last one that was sent in the previous call)</p>
<blockquote>
<p>How can i improve my program to send the file as quick as possible
  depending on my internet speed?</p>
</blockquote>
<p>Offer send() as many bytes as you can at once; that will give it the most flexibility to optimize what it's doing behind the scenes.  Other than that, just call send() in a loop, using the return value of each send() call to determine what bytes to pass to send() the next time (e.g. if the first call returns 5, you know that send() read the first 5 bytes out of your buffer and will make sure they get to their destination, so your next call to send() should pass in a buffer starting at the 6th byte of your data stream... and so on).  (Or if you don't want to deal with that logic yourself, you can call sendall() like @ShadowRanger suggested; sendall() is just a wrapper containing a loop around send() that does that logic for you.  The only disadvantage is that e.g. if you call sendall() on 20 gigabytes of data, it might be several hours before the sendall() call returns!  Whether or not that would pose a problem for you depends on what else your program might want to accomplish, if anything, while sending the data).</p>
<p>That's really all there is to it for TCP.</p>
<p>If you were sending data using a UDP socket, on the other hand, things would be very different; in the UDP case, packets can simply be dropped, and it's up to the programmer to manage speed-of-transmission issues, packet resends, etc, explicitely.  But with TCP all that is handled for you by the OS.</p>
</div>
<div class="post-text" itemprop="text">
<p>@Jeremy Friesner</p>
<p>So I can do something like that:</p>
<pre><code>file = open(filename, "rb")

read = file.read(1024**3) #Read 1 gb.

totalsend = 0

#Send Loop
while totalsend &lt; filesize:

    #Try to send all the bytes.
    send = sock.send(read)
    totalsend += send

    #If failed, then seek into the file the position
    #where the next read will also read the missing bytes.
    if send &lt; 1024**3:
        file.seek(totalsend)

    read = file.read(1024**3) #Read 1 gb.
</code></pre>
<p>Is this correct?</p>
<p>Also, from this example i undestood one more think. The data you can send in every loop, can't be bigger in size than your memory. Because you are bringing bytes from the disk on the memory. So theoretically even if your network speed is infinity, you can't send all the bytes at once if the file is bigger than your memory.</p>
</div>
<span class="comment-copy">But i can't understand, how is this going to send all the bytes at the maximum speed of your internet connection?</span>
<span class="comment-copy">Send returns the amount of bytes that have been send successfully? Which means that if i try to send all the bytes at once the first time, the second time i will know how many bytes i can send through the socket?</span>
<span class="comment-copy">@babaliaris sockets are managed by the operating system. They are a layer of abstraction so that you don't have to worry about lower-layer things like the speed of connection. The duty of sending data in an optimal way lies on the OS. And yes, send returns the amount of bytes sent.</span>
<span class="comment-copy">So if i do this: sock.send( file.read() ) #Send all the data at once. What will happen? Especially if the file is very big.</span>
<span class="comment-copy">Normally an API will tell you how much it sent (to the OS buffer) and you're responsible for trying to send the rest later.   Looks like someone else gave you an easy python-specific way to automatically take care of that.  There is normally a <code>select</code> call that lets you be notified when the OS buffer has room for more data so you don't waste time trying to send more data when you cannot make any progress.</span>
<span class="comment-copy">Thank you, your answer is the best! I posted an alternative program with the knowledge you gave me, and i'd be glad if you can check it.</span>
<span class="comment-copy">Also when i run this code i got a MemoryError exception. Then i changed the read buffer from 1gb to 1024 bytes and there is no problem.</span>
