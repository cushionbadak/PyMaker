<div class="post-text" itemprop="text">
<p>How can I check and remove duplicate values from items in a dictionary?
I have a large data set so I'm looking for an efficient method. The following is an example of values in a dictionary that contains a duplicate:</p>
<pre><code>'word': [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]
</code></pre>
<p>needs to become </p>
<pre><code>'word': [('769817', [6]), ('769819', [4, 10])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This problem essentially boils down to removing duplicates from a list of <strong>unhashable</strong> types, for which converting to a set does not possible.</p>
<p>One possible method is to check for membership in the current value while building up a new list value.</p>
<pre><code>d = {'word': [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]}
for k, v in d.items():
    new_list = []
    for item in v:
        if item not in new_list:
            new_list.append(item)
    d[k] = new_list
</code></pre>
<p><em>Alternatively</em>, use <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow"><code>groupby()</code></a> for a more concise answer, although <strong>potentially</strong> slower (<em>the list must be sorted first, if it is, then it is faster than doing a membership check</em>).</p>
<pre><code>import itertools

d = {'word': [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]}
for k, v in d.items():
    v.sort()
    d[k] = [item for item, _ in itertools.groupby(v)]
</code></pre>
<p><strong>Output</strong> -&gt; <code>{'word': [('769817', [6]), ('769819', [4, 10])]}</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You have a list, not a dictionary.  Python dictionaries may have only one value for each key.  Try</p>
<pre><code>my_dict = dict([('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])])
</code></pre>
<p>result:</p>
<pre><code>{'769817': [6], '769819': [4, 10]}
</code></pre>
<p>a Python dictionary.  For more information <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow">https://docs.python.org/3/tutorial/datastructures.html#dictionaries</a></p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:
I am just focusing on the list part:</p>
<pre><code>&gt;&gt;&gt; s = [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]
&gt;&gt;&gt; [(x,y) for x,y in {key: value for (key, value) in s}.items()]
[('769817', [6]), ('769819', [4, 10])]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strikethrough applied to original question before edits, left for posterity:
<s>You're not using a <code>dict</code> at all, just a <code>list</code> of two-<code>tuple</code>s, where the second element in each <code>tuple</code> is itself a <code>list</code>. If you actually want a <code>dict</code>, </s></p>
<pre><code>dict([('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])])
</code></pre>
<p>will convert it, and uniquify by key (so you'd end up with <code>{'769817': [6], '769819': [4, 10]}</code>, though it loses order, and doesn't pay attention to whether the values (the sub-<code>list</code>s) are unique or not (it just keeps the last pairing for a given key).</p></div>
<div class="post-text" itemprop="text">
<pre><code>your_list = [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]
new = []
for x in your_list:
    if x not in new: new.append(x)

print(new)    
&gt;&gt;&gt;[('769817', [6]), ('769819', [4, 10])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can uniqify the items based on the hash they generate. Hash could be anything, a sorted <code>json.dumps</code>, or <code>cPickle.dumps</code>.
This one liner can uniqify your dict as required.</p>
<pre><code>&gt;&gt;&gt; d =  {'word': [('769817', [6]), ('769819', [4, 10]), ('769819', [4, 10])]}
&gt;&gt;&gt; import json
&gt;&gt;&gt; { k: { json.dumps(x,sort_keys = True):x for x in v}.values() for k,v in d.iteritems()}
{'word': [('769817', [6]), ('769819', [4, 10])]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about that?</p>
<pre class="lang-py prettyprint-override"><code>    def remove_duplicates(d: dict):
        unique_values = set(d.values())
        o = {}
        for k, v in d.items():
           if v in unique_values:
                o[k] = v
                unique_values.remove(v)
        return o
</code></pre>
</div>
<span class="comment-copy">There is no python dictionary in your question, just integers and strings and lists and tuples. What do you mean by "dictionary"?</span>
<span class="comment-copy">the examples are the values of an item in a dictionary i have to show what it contains</span>
<span class="comment-copy">This is a duplicate of <a href="http://stackoverflow.com/questions/2931672/what-is-the-cleanest-way-to-do-a-sort-plus-uniq-on-a-python-list" title="what is the cleanest way to do a sort plus uniq on a python list">stackoverflow.com/questions/2931672/â€¦</a></span>
<span class="comment-copy">once again, i am not using just a lists!!!</span>
<span class="comment-copy">thanks this works !</span>
<span class="comment-copy">Added another approach, I would explore bench-marking the two approaches to see what works better with your dataset.</span>
<span class="comment-copy">@mrdomoboto: Why <code>list()</code> wrapping genexpr? <code>[item for item, _ in itertools.groupby(v)]</code> is going to be faster/more succinct than a genexpr that just gets passed to <code>list</code> constructor anyway. Also, <code>groupby</code> is only slower if <code>list</code> is unsorted; if it's already sorted, as in the example, no sorting needed, so it's actually faster than any other solution in theory (<code>O(n)</code> with no meaningful constant factors). It could be optimized further if needed to push all work to C layer by changing comprehension to <code>list(map(operator.itemgetter(0), itertools.groupby(v)))</code> (<code>list()</code> wrapping is Py3 only).</span>
<span class="comment-copy">You are correct, the <code>list()</code> wrapper does add another order of magnitude cost to that line. I've updated my answer. Yes, <code>groupby()</code> is far faster if the list is already sorted, which is why I added the note.</span>
<span class="comment-copy">This does not return a list.</span>
<span class="comment-copy">i do have multiple items as value</span>
<span class="comment-copy">That list comprehension could simplify to just: <code>dict(s).items()</code> (<code>list(dict(s).items())</code> on Py3). No need to turn everything into a comprehension when the data is already what the constructors expect. It also only uniqifies by the first element in the <code>tuple</code>, not the second, and does not preserve order, which may not match requirements. It's efficient if that's acceptable though.</span>
<span class="comment-copy">thats very thoughtful and much more efficient.</span>
<span class="comment-copy">i am using a dictionary. i have multiple tuples for 1 key</span>
<span class="comment-copy">@Brutalized: Your original question didn't make that clear. In any event, the last two options are more optimized versions of the current accepted answer (if the data is already ordered, the non-sorting <code>groupby</code> is <code>O(n)</code>, if it needs sorting, it's <code>O(n log n)</code>, both of which are a major improvement on <code>O(n^2)</code> of the loop with <code>list</code> contain checking on every iteration).</span>
<span class="comment-copy">That is a terrible misuse of list comprehensions. Don't use a <code>list</code> comprehension for side-effects. They're a functional construct, and functional code is side-effect free; using them for side-effects is wasteful (creates a garbage <code>list</code> of <code>None</code>s that just gets thrown away after) and confusing. Just use a plain <code>for</code> loop for those cases. Also, never name a variable <code>list</code>; shadowing built-ins is terrible practice.</span>
<span class="comment-copy">@ShadowRanger I fixed it.</span>
<span class="comment-copy">You did, but the new code has its own issues in the general case (no issues for the two-<code>tuple</code> case admittedly), since falsy values will be mistaken for duplicates by that test (a <code>list</code> like <code>[1, None, 0, 2]</code>, which has no duplicates, would still get reduced to <code>[1, 2]</code> because <code>None</code> and <code>0</code> look like duplicates to this logic). You could just do <code>if x not in new: new.append(x)</code> and avoid the <code>to_append</code> temporary and the risk of confusing falsy values for duplicate values.</span>
<span class="comment-copy">@ShadowRanger thx, Fixed.</span>
<span class="comment-copy">Down-vote removed. :-)</span>
