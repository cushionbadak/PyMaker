<div class="post-text" itemprop="text">
<p>I am reading lines from a file one at a time and before i store each, i wanna modify them according to the following simple rule:</p>
<ul>
<li>if the last character is not any of, e.g., <code>{'a', 'b', 'c'}</code> store the line.</li>
<li>if that is not the case, remove the character (pop-like) and check again.</li>
</ul>
<p>What i currently have (felt like the obvious thing to do) is this:</p>
<pre><code>bad_chars = {'a', 'b', 'c'}


def remove_end_del(line_string, chars_to_remove):
    while any(line_string[-1] == x for x in chars_to_remove):
        line_string = line_string[:-1]
    return line_string

example_line = 'jkhasdkjashdasjkd|abbbabbababcbccc'
modified_line = remove_end_del(example_line, bad_chars)
print(modified_line)  # prints -&gt; jkhasdkjashdasjkd|
</code></pre>
<p>Which of course works, but the string slicing\reconstruction seems a bit too excessive to my untrained eyes. So i was wondering a couple of things:</p>
<ol>
<li>is there a better way to do this? like a <code>pop</code> type of function for strings?</li>
<li>how is <code>rstrip()</code> or <code>strip()</code> in general implemented? is it also with a <strong>while</strong>?</li>
<li>would it be worthwhile making <code>rstrip()</code> recursive for this example?</li>
<li>Finally, how much better is the following:</li>
</ol>
<hr/>
<pre><code>def remove_end_del_2(line_string, chars_to_remove):
    i = 1
    while line_string[-i] in chars_to_remove:
        i += 1
    return line_string[:-i+1]
</code></pre>
<p>Any comment on any of the points made above would be appreciated ☺.</p>
<p><strong>Note: the separator ("|") is only there for visualization.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Another nearly fast approach to <code>re.sub</code> albeit more intuitive (<em>it sounds like the <code>pop</code> you're asking for</em>) is <a href="https://docs.python.org/2/library/itertools.html#itertools.dropwhile" rel="nofollow"><code>itertools.dropwhile</code></a>:</p>
<blockquote>
<p>Make an iterator that drops elements from the iterable as long as the
  predicate is true;</p>
</blockquote>
<pre><code>&gt;&gt;&gt; ''.join(dropwhile(lambda x: x in bad_chars, example_line[::-1]))[::-1]
'jkhasdkjashdasjkd|'
</code></pre>
<p>However, it appears <code>rstrip</code> was made and more suited for a task as this.</p>
<hr/>
<p>Some timings:</p>
<pre><code>In [4]: example_line = 'jkhasdkjashdasjkd|abbbabbababcbccc'

In [5]: bad_chars = {'a', 'b', 'c'}
</code></pre>
<hr/>
<pre><code>In [6]: %%timeit
   ...: re.sub(r'[%s]+$' % ''.join(bad_chars), '', example_line)
   ...:
100000 loops, best of 3: 5.24 µs per loop
</code></pre>
<hr/>
<pre><code>In [7]: %%timeit
   ...: ''.join(dropwhile(lambda x: x in bad_chars, example_line[::-1]))[::-1]
   ...:
100000 loops, best of 3: 5.72 µs per loop
</code></pre>
<hr/>
<pre><code>In [10]: %%timeit
   ....: remove_end_del(example_line, bad_chars)
   ....:
10000 loops, best of 3: 24.1 µs per loop
</code></pre>
<hr/>
<pre><code>In [11]: %%timeit
   ....: example_line.rstrip('abc')
   ....:
1000000 loops, best of 3: 579 ns per loop
</code></pre>
<hr/>
<pre><code>In [14]: %%timeit
   ....: remove_end_del_2(example_line, bad_chars)
   ....:
100000 loops, best of 3: 4.22 µs per loop
</code></pre>
<p><strong><code>rstrip</code> wins!</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Slicing creates lots of unnecessary temporary copies of string. Recursion would be even worse - copies would still be made, and on top of it function call overhead would be intruduced. Both approaches are not that great.</p>
<p>You may find an <code>rstrip</code> implementation in <a href="https://github.com/python/cpython/blob/master/Objects/bytesobject.c#L2030" rel="nofollow">CPython source code</a>. An iterative approach (similar to your last code snippet) is used there.</p>
<pre><code>Py_LOCAL_INLINE(PyObject *)
do_xstrip(PyBytesObject *self, int striptype, PyObject *sepobj)
{
    Py_buffer vsep;
    char *s = PyBytes_AS_STRING(self);
    Py_ssize_t len = PyBytes_GET_SIZE(self);
    char *sep;
    Py_ssize_t seplen;
    Py_ssize_t i, j;

    if (PyObject_GetBuffer(sepobj, &amp;vsep, PyBUF_SIMPLE) != 0)
        return NULL;
    sep = vsep.buf;
    seplen = vsep.len;

    i = 0;
    if (striptype != RIGHTSTRIP) {
        while (i &lt; len &amp;&amp; memchr(sep, Py_CHARMASK(s[i]), seplen)) {
            i++;
        }
    }

    j = len;
    if (striptype != LEFTSTRIP) {
        do {
            j--;
        } while (j &gt;= i &amp;&amp; memchr(sep, Py_CHARMASK(s[j]), seplen));
        j++;
    }

    PyBuffer_Release(&amp;vsep);

    if (i == 0 &amp;&amp; j == len &amp;&amp; PyBytes_CheckExact(self)) {
        Py_INCREF(self);
        return (PyObject*)self;
    }
    else
        return PyBytes_FromStringAndSize(s+i, j-i);
}
</code></pre>
<p>So to sum up, your intuition to use index-based parsing is correct. Main advantage is that no temporary strings are created and copying things in memory is significantly reduced.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not the direct answer to the question, but one alternative option would be to use <em>regular expressions</em> to remove the bad characters at the end of the string:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt;
&gt;&gt;&gt; example_line = 'jkhasdkjashdasjkd|abbbabbababcbccc'
&gt;&gt;&gt; bad_chars = {'a', 'b', 'c'}
&gt;&gt;&gt;
&gt;&gt;&gt; re.sub(r'[%s]+$' % ''.join(bad_chars), '', example_line)
'jkhasdkjashdasjkd|'
</code></pre>
<p>The regular expression here is dynamically constructed from the set of "bad" characters. It would (or "could", since sets have no order) be <code>[abc]+$</code> in this case:</p>
<ul>
<li><code>[abc]</code> defines a "character class" - any of "a", "b" or "c" would be matched</li>
<li><code>+</code> means 1 or more   </li>
<li><code>$</code> defines the end of the string</li>
</ul>
<p>(Note that, if "bad" characters can contain a character that may have a special meaning in the character class (like, for example, <code>[</code> or <code>]</code>), it should be escaped with <a href="https://docs.python.org/2/library/re.html#re.escape" rel="nofollow noreferrer"><code>re.escape()</code></a>).</p>
<p><sup>The last statement though may prove that <a href="https://softwareengineering.stackexchange.com/questions/223634/what-is-meant-by-now-you-have-two-problems">old saying</a> about having more problems than initially.</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>I understand what you mean by <em>excessive</em>, but I think in general, it looks good. The alternative would be to work with indices, which is not very readable. (I also happen to think that regexes are not very readable either...)</p>
<p>You could, however, use a <code>memoryview</code> if you have a <code>bytes</code> object which may or may not be relevant:
<a href="https://docs.python.org/3/library/stdtypes.html#memoryview" rel="nofollow">https://docs.python.org/3/library/stdtypes.html#memoryview</a></p>
<p><strong>1. <code>pop</code> function for strings</strong></p>
<p>No there are no <code>.pop</code> method for <code>str</code>. You'd have to use <code>list(line_string).pop()</code>, where <code>list(s)</code> creates a list with each character of the string as an element.</p>
<p><strong>2. <code>(r)strip</code> implementation</strong></p>
<p>This is probably implemented with a while, yes.
It should be all C code though.</p>
<p><strong>3. recursive <code>rstrip</code></strong></p>
<p>First of all, why would you need to make it <em>recursive</em>?
Second, I think that (recursiveness) would make the mental load unnecessarily high -- so, no.</p>
<p><strong>4. Finally, how much better is the following:</strong></p>
<p>Measure it! Surely it would be faster.</p>
</div>
<span class="comment-copy">I think this is the most Pythonic solution, i.e. using <code>dropwhile</code>.</span>
<span class="comment-copy">can you please put <code>remove_end_del_2</code> &amp; <code>example_line.rstrip('abc')</code> in the mix too?</span>
<span class="comment-copy">Actually, I changed my mind when I think about it. <code>.rstrip()</code> is, of course! :-)</span>
<span class="comment-copy">Since you are using itertools, consider using <code>reversed()</code> which is lazy, while <code>[::-1]</code> is not.</span>
<span class="comment-copy">@ŁukaszRogalski The string is a small one, the iterator will add extra overhead</span>
<span class="comment-copy">thanks a lot for the input, but <i>regex</i> is my Achilles heel, so do you mind explaining how this looks at the end of the string only?</span>
<span class="comment-copy">@Ev.Kounis sure, will do. Also, checking how this compares with your existing solutions in terms of speed.</span>
<span class="comment-copy">So the <code>$</code> makes all the difference. Is <code>sub</code> what imposes "sequentiality" (upon finding one that is not in the set stop)?</span>
<span class="comment-copy">@Ev.Kounis yeah, <code>$</code> is the key. I would go with the <code>dropwhile</code> as well, more pythonic and less things to worry about.</span>
<span class="comment-copy">you would have to make it recursive because if you do <code>'something_useful|abbbabbababcbccc'.rstrip(b)</code> on this one, you would get nothing removed because you should have gone for <code>c</code> first. So order matters. Do you see where i am going?</span>
<span class="comment-copy">@Ev.Kounis No, since afaik <code>rstrip()</code> takes an iterable of chars as argument.</span>
<span class="comment-copy">You are right. i was confused. You can actually pass a string like <code>'abc'</code> and it will process every character individually</span>
