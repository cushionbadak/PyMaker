<div class="post-text" itemprop="text">
<p>From one of our client's requirement, I have to develop an application which should be able to process huge CSV files. File size could be in the range of 10 MB - 2GB in size.</p>
<p>Depending on size, module decides whether to read the file using <code>Multiprocessing pool</code> or by using normal <code>CSV reader</code>. 
But from observation, <code>multi processing</code> taking longer time than normal <code>CSV reading</code> when tested both the modes for a file with size of 100 MB. </p>
<p>Is this correct behaviour? OR Am I doing something wrong?</p>
<p>Here is my code:</p>
<pre><code>def set_file_processing_mode(self, fpath):
   """ """
   fsize = self.get_file_size(fpath)
   if fsize &gt; FILE_SIZE_200MB:
      self.read_in_async_mode = True
   else:
      self.read_in_async_mode = False

def read_line_by_line(self, filepath):
    """Reads CSV line by line"""
    with open(filepath, 'rb') as csvin:
        csvin = csv.reader(csvin, delimiter=',')
        for row in iter(csvin):
          yield row

def read_huge_file(self, filepath):
    """Read file in chunks"""
    pool = mp.Pool(1)
    for chunk_number in range(self.chunks): #self.chunks = 20
        proc = pool.apply_async(read_chunk_by_chunk, 
                        args=[filepath, self.chunks, chunk_number])
        reader = proc.get()
        yield reader
    pool.close()
    pool.join()

def iterate_chunks(self, filepath):
    """Read huge file rows"""
    for chunklist in self.read_huge_file(filepath):
        for row in chunklist:
            yield row
@timeit #-- custom decorator
def read_csv_rows(self, filepath):
    """Read CSV rows and pass it to processing"""
    if self.read_in_async_mode:
        print("Reading in async mode")
        for row in self.iterate_chunks(filepath):
            self.process(row)
    else:
        print("Reading in sync mode")
        for row in self.read_line_by_line(filepath):
            self.process(row)

def process(self, formatted_row):
    """Just prints the line"""
    self.log(formatted_row)

def read_chunk_by_chunk(filename, number_of_blocks, block):
  '''
  A generator that splits a file into blocks and iterates
  over the lines of one of the blocks.
  '''
  results = []
  assert 0 &lt;= block and block &lt; number_of_blocks
  assert 0 &lt; number_of_blocks
  with open(filename) as fp :
    fp.seek(0,2)
    file_size = fp.tell()
    ini = file_size * block / number_of_blocks
    end = file_size * (1 + block) / number_of_blocks
    if ini &lt;= 0:
        fp.seek(0)
    else:
        fp.seek(ini-1)
        fp.readline()
    while fp.tell() &lt; end:
        results.append(fp.readline())
  return results

if __name__ == '__main__':
    classobj.read_csv_rows(sys.argv[1])    
</code></pre>
<p>Here is a test: </p>
<pre><code>$ python csv_utils.py "input.csv"
Reading in async mode
FINISHED  IN 3.75 sec
$ python csv_utils.py "input.csv"
Reading in sync mode
FINISHED  IN 0.96 sec
</code></pre>
<p>Question is : </p>
<p>Why Async mode is taking longer?</p>
<p><strong>NOTE:</strong>  Removed unnecessary functions/lines to avoid complexity in the code </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is this correct behaviour? </p>
</blockquote>
<p>Yes - it may not be what you expect, but it is consistent with the way you implemented it and how <code>multiprocessing</code> works. </p>
<blockquote>
<p>Why Async mode is taking longer?</p>
</blockquote>
<p>The way your example works is perhaps best illustrated by a parable - bear with me please: </p>
<p>Let's say you ask your friend to engage in an experiment. You want him to go through a book and mark each page with a pen, as fast as he can. There are two rounds with a distinct setup, and you are going to time each round and then compare which one was faster:</p>
<ol>
<li><p>open the book on the first page, mark it, then flip the page and mark the following pages as they come up. Pure sequential processing.</p></li>
<li><p>process the book in chunks. For this he should run through the book's pages chunk by chunk. That is he should first make a list of page numbers
as starting points, say 1, 10, 20, 30, 40, etc. Then for each chunk, he should close the book, open it on the page for the starting point, process all pages before the next starting point comes up, close the book, then start all over again for the next chunk.</p></li>
</ol>
<p>Which of these approaches will be faster? </p>
<blockquote>
<p>Am I doing something wrong?</p>
</blockquote>
<p>You decide both approaches take too long. What you really want to do is ask <em>multiple</em> people (processes) to do the marking <em>in parallel</em>. Now with a book (as with a file) that's difficult because, well, only one person (process) can access the book (file) at any one point. Still it can be done if the order of processing doesn't matter and it is the marking itself - not the accessing - that should run in parallel. So the new approach is like this:</p>
<ol>
<li>cut the pages out of the book and sort them into say 10 stacks</li>
<li>ask ten people to mark one stack each</li>
</ol>
<p>This approach will most certainly speed up the whole process. Perhaps surprisingly though the speed up will be less than a factor of 10 because step 1 takes some time, and only one person can do it. That's called <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" rel="nofollow noreferrer">Amdahl's law</a> [wikipedia]:</p>
<p><a href="https://i.stack.imgur.com/800RH.gif" rel="nofollow noreferrer"><img alt="$$ S_\text{latency}(s) = \frac{1}{(1 - p) + \frac{p}{s}}" src="https://i.stack.imgur.com/800RH.gif"/></a></p>
<p>Essentially what it means is that the (theoretical) speed-up of any process can only be as fast as the parallel processing part <em>p</em> is reduced in speed in relation to the part's sequential processing time (<em>p/s</em>). </p>
<p>Intuitively, the speed-up can only come from the part of the task that is processed in parallel, all the sequential parts are not affected and take the same amount of time, whether <em>p</em> is processed in parallel or not. </p>
<p>That said, in our example, obviously the speed-up can only come from step 2 (marking pages in parallel by multiple people), as step 1 (tearing up the book) is clearly sequential.</p>
<blockquote>
<p>develop an application which should be able to process huge CSV files</p>
</blockquote>
<p>Here's how to approach this:</p>
<ol>
<li>determine what part of the <em>processing</em> can be done in parallel, i.e. process each chunk sepearately and out of sequence </li>
<li>read the file sequentially, splitting it up into chunks as you go</li>
<li>use multiprocessing to run <em>multiple</em> processing steps <em>in parallel</em></li>
</ol>
<p>Something like this:</p>
<pre><code>def process(rows):
    # do all the processing
    ...
    return result

if __name__ == '__main__':
    pool = mp.Pool(N) # N &gt; 1
    chunks = get_chunks(...)
    for rows in chunks:
       result += pool.apply_async(process, rows)
    pool.close()
    pool.join() 
</code></pre>
<p>I'm not defining <code>get_chunks</code> here because there are several documented approaches to doing this e.g. <a href="https://gist.github.com/miku/820490" rel="nofollow noreferrer">here</a> or <a href="https://stackoverflow.com/a/32743290/890242">here</a>.</p>
<p><strong>Conclusion</strong></p>
<p>Depending on the kind of processing required for each file, it may well be that the sequential approach to processing any one file is the fastest possible approach, simply because the processing parts don't gain much from being done in parallel. You may still end up processing it chunk by chunk due to e.g. memory constraints. If that is the case, you probably don't need multiprocessing.</p>
<p>If you have <em>multiple files</em> that can be processed in parallel, 
multiprocessing is a very good approach. It works the same way as shown above, where the chunks are not rows but filenames.</p>
</div>
<span class="comment-copy">Multi <b>processing</b> has the overhead of handling the processes and communication. You're also always calling <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.AsyncResult.get" rel="nofollow noreferrer"><code>AsyncResult.get()</code></a> right away after applying your <code>read_chunk_by_chunk()</code>, which then has to wait for the chunk to finish reading, so you're effectively still serial, but with the additional overhead. The std csv reader on the other hand is passed a (possibly) buffered file, so IO is not actually that big of a problem probably.</span>
<span class="comment-copy">what processing do you need to do with the file?</span>
<span class="comment-copy">Instead of having multiple producers (async readers), try multiple consumers, aka multiprocess the <code>self.process()</code>, if need be.</span>
<span class="comment-copy">@miraculixx: I have to compare the CSV row with db, if record exists update it else create a new entry in the table.</span>
<span class="comment-copy">In that case your best course of action will probably be to upload the CSV data to a temporary table in the DB directly and perform a single "upsert" query. How to upload the data depends on what DB you're using.</span>
<span class="comment-copy">Perfect, Superb explained. So I should split the file and for each file need to be processed in multiprocessing pool.  Thank you</span>
