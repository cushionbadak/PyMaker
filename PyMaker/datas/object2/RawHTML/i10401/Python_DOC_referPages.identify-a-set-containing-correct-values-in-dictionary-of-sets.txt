<div class="post-text" itemprop="text">
<p>I have a dictionary of sets, and two values to test. I need to identify the set containing both values (there's only one correct set) and return the key of that set. I thought I could get away with a one-liner like that below, but no success this far. </p>
<pre><code>d = {"set1": {"A", "B", "C"}, "set2": {"D", "E", "F"}, "set3":{"A", "D", "C"}}
value1 = "A"
value2 = "B"

def do_values_belong_in_same_set(value1, value2):
    if all(x in v for k, v in d.items() for x in [value1, value2]) is True:
        return True, k
    else:
        return False
</code></pre>
<p>The desired output here would be: True, "set1"</p>
<p>The "v for k, v in d.items()" part doesn't do the trick. Nor does simpler "x in d.values()" What would work? Or will I just need to construct a proper for-loop for this? Thanks for your help!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; value1 = "A"
&gt;&gt;&gt; value2 = "B"
&gt;&gt;&gt; d = {"set1": {"A", "B", "C"}, "set2": {"D", "E", "F"}, "set3":{"A", "D", "C"}}
&gt;&gt;&gt; [k for k, v in d.items() if value1 in v and value2 in v]
['set1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#set.issubset" rel="nofollow"><code>set.issubset</code></a> (which uses the <code>&lt;=</code> operator) by combining your needle characters into a set.</p>
<pre><code>d = {"set1": {"A", "B", "C"}, "set2": {"D", "E", "F"}, "set3":{"A", "D", "C"}}
value1 = "A"
value2 = "B"

needle_set = set([value1, value2])
result = next(k for k,v in d.items() if needle_set.issubset(v))
# or needle_set &lt;= v, or v &gt;= needle_set, or
# v.issuperset(needle_set), all are the same condition
</code></pre>
<p>You could roll it into a function with your requested output like:</p>
<pre><code>def do_values_belong_in_same_set(source_d, *values):
    # I use the variadic argument `value` here so you can check any number of values
    # and include the source dict by name as best practice
    needle_set = set(values)
    result = next(k for k,v in source_d.items() if needle_set &lt;= v)
    if result:
        return True, result
    else:
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could slightly change the logic in your function to achieve this:</p>
<pre><code>def do_values_belong_in_same_set(value1, value2):
    r = next((k for k, v in d.items() if all(i in v for i in {value1, value2})), False)
    if r: 
        return True, r
    else: 
        return r
</code></pre>
<p>Calling <code>next</code> on the generator will return the first <code>k</code> (set name) if one exists and a default value of <code>False</code> is assigned if the value is not present. Then you return accordingly. </p>
<p>This yields the following results for different runs:</p>
<pre><code>do_values_belong_in_same_set(value1, value2)
(True, 'set1')

do_values_belong_in_same_set(value1, 'F')
False

do_values_belong_in_same_set(value1, 'E')
False

do_values_belong_in_same_set('F', 'E')
(True, 'set2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can filter the sets for which the set composed of value1 and value2 is a subset:</p>
<pre><code>def do_values_belong_in_same_set(value1, value2):
    sets = [key for key, s in d.items() if {value1, value2} &lt;= s]
    if sets:
        return True, sets[0]
    else:
        return False
</code></pre>
</div>
<span class="comment-copy">Returning a tuple in once case and just  boolean in another is a bad idea, why not just return False or the key?</span>
<span class="comment-copy">(or at least <code>(True, keyname)</code> or <code>(False, None)</code>, though I'm unsure why you'd even want to do that)</span>
<span class="comment-copy">You could also  another set, <code>if v.issuperset...</code> and just pass the values</span>
<span class="comment-copy">it doesn't look as if the dictionary is defined inside the function but it is not passed as an argument as well. So, how?</span>
<span class="comment-copy">OP apperently grabs the dictionary reference from the global scope, if he wants a parameter for a dictionary he could pass it as a required arg. He doesn't so I didn't assume it was needed.</span>
<span class="comment-copy">The function is a closure inside the module. If you haven't assigned an identifier to the local namespace of the function, Python will keep resolving out until it either finds it or can't go any further (in the latter case raising a <code>NameError</code>)</span>
<span class="comment-copy">@AdamSmith I am aware of that but i think OP just forgot and this too has to be addressed.</span>
<span class="comment-copy">He did make it a required arg and I like his solution more than mine and that's why I upvoted, I'll be keeping mine for another reference on how to do this.</span>
<span class="comment-copy">This does not produce the requested output</span>
<span class="comment-copy">Fixed it to produce the requested output.</span>
<span class="comment-copy">Please, always give some explanation, not only the plain code</span>
