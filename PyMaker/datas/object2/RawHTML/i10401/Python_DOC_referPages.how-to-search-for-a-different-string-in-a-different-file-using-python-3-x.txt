<div class="post-text" itemprop="text">
<p>I am trying to search a large group of text files (160K) for a specific string that changes for each file. I have a text file that has every file in the directory with the string value I want to search. Basically I want to use python to create a new text file that gives the file name, the string, and a 1 if the string is present and a 0 if it is not.</p>
<p>The approach I am using so far is to create a dictionary from a text file. From there I am stuck. Here is what I figure in pseudo-code:</p>
<pre><code>**assign dictionary**
d = {}
with open('file.txt') as f:
  d = dict(x.rstrip().split(None, 1) for x in f)

**loop through directory**
for filename in os.listdir(os.getcwd()):

***here is where I get lost***
match file name to dictionary
look for string
write filename, string, 1 if found
write filename, string, 0 if not found
</code></pre>
<p>Thank you. It needs to be somewhat efficient since its a large amount of text to go through. </p>
<p>Here is what I ended up with</p>
<pre><code>d = {}
with open('ibes.txt') as f:
  d = dict(x.rstrip().split(None, 1) for x in f)

import os

for filename in os.listdir(os.getcwd()):
    string = d.get(filename, "!@#$%^&amp;*")
    if string in open(filename, 'r').read():
        with open("ibes_in.txt", 'a') as out:
            out.write("{} {} {}\n".format(filename, string, 1))
    else: 
        with open("ibes_in.txt", 'a') as out:
            out.write("{} {} {}\n".format(filename, string, 0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I understand your question, the dictionary relates file names to strings</p>
<pre><code>d = {
 "file1.txt": "widget",
 "file2.txt": "sprocket", #etc
}
</code></pre>
<p>If each file is not too large you can read each file into memory: </p>
<pre><code>for filename in os.listdir(os.getcwd()):
    string = d[filename]
    if string in open(filename, 'r').read():
        print(filename, string, "1")
    else: 
        print(filename, string, "0")
</code></pre>
<p>This example uses print, but you could write to a file instead. Open the output file before the loop <code>outfile = open("outfile.txt", 'w')</code> and instead of printing use </p>
<pre><code>outfile.write("{} {} {}\n".format(filename, string, 1))
</code></pre>
<p>On the other hand, if each file is too large to fit easily into memory, you could use a <code>mmap</code> as described in <a href="https://stackoverflow.com/questions/4940032/search-for-string-in-txt-file-python">Search for string in txt file Python</a></p>
</div>
<span class="comment-copy">I ran this and got this error: string = dict[filename] TypeError: 'type' object is not subscriptable</span>
<span class="comment-copy">thats because one should never use dict for the name of a dict.</span>
<span class="comment-copy">Ok fixed that, I had to change the line for missing keys and I copy and pasted the dict. I redid that using d.get(filename, "!@#$%^&amp;*") the random string is just silly way to mark the missing keys. I also had to add a () to the read from if string in open(filename, 'r').read to get it to run.</span>
<span class="comment-copy">An <code>mmap</code> solution is by far the best if: 1) The files are smaller than a GB or so <i>or</i> you're using a 64 bit build of Python (in which case file size doesn't matter) and 2) The files are large, and the search string is often found early in the file. If #2 is false, <code>mmap</code> won't hurt, but it won't help much either. If #2 is true, then you might short-circuit quite a lot of I/O. On Py3, you might also benefit from <a href="https://docs.python.org/3/library/os.html#os.posix_fadvise" rel="nofollow noreferrer">using <code>os.posix_fadvise</code></a> on the file object's <code>fileno()</code> (passing appropriate <code>WILLNEED</code>, <code>SEQUENTIAL</code> or <code>NOREUSE</code>).</span>
