<div class="post-text" itemprop="text">
<pre><code>import itertools
a = [[2, 3], [3, 4]]
b = [[5, 6], [7, 8], [9, 10]]
c = [[11, 12], [13, 14]]
d = [[15, 16], [17, 18]]
e = [[12,16],[13,17],[14,18],[15,19]]

q=[]
q=list(itertools.combinations((a, b, b,c, c, d,e),7)
print q
</code></pre>
<p>How would I go about using the combination function from itertools properly to use list a one time, b 2 times without replacement, c 2 times without replacement, and d and e one time each?</p>
<pre><code>[[[2, 3],[5, 6],[7, 8],[11, 12],[13, 14],[15, 16],[12,16]], 
[[2, 3],[5, 6],[7, 8],[11, 12],[13, 14],[15, 16],[13,17]],
[[2, 3],[5, 6],[7, 8],[11, 12],[13, 14],[15, 16],[14,18]],
[[2, 3],[5, 6],[7, 8],[11, 12],[13, 14],[15, 16],[15,19]], 
[[2, 3],[5, 6],[7, 8],[11, 12],[13, 14],[15, 16],[12,16]],...
[[3, 4],[7, 8],[9, 10],[11, 12], [13, 14],[17, 18],[15,19]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like you are looking for a combination of <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>combinations</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a>: Use <code>combinations</code> to get the possible combinations without replacement for the repeated lists, then use <code>product</code> to combine all those combinations. You can put the lists and counts in two lists, <code>zip</code> those lists, and use a generator expression to get all the combinations.</p>
<pre><code>from itertools import product, combinations, chain
lists = [a,b,c,d,e]
counts = [1,2,2,1,1]
combs = product(*(combinations(l, c) for l, c in zip(lists, counts)))
</code></pre>
<p>For this example, the <code>combs</code> generator has 48 elements, among others:</p>
<pre><code>[(([2, 3],), ([5, 6], [7, 8]), ([11, 12], [13, 14]), ([15, 16],), ([12, 16],)),
 ...
 (([2, 3],), ([5, 6], [7, 8]), ([11, 12], [13, 14]), ([17, 18],), ([15, 19],)),
 (([2, 3],), ([5, 6], [9, 10]),([11, 12], [13, 14]), ([15, 16],), ([12, 16],)),
 ...
 (([3, 4],), ([5, 6], [7, 8]), ([11, 12], [13, 14]), ([15, 16],), ([12, 16],)),
 ...
 (([3, 4],), ([5, 6], [7, 8]), ([11, 12], [13, 14]), ([17, 18],), ([15, 19],)),
 ...
 (([3, 4],), ([7, 8], [9, 10]),([11, 12], [13, 14]), ([17, 18],), ([15, 19],))]
</code></pre>
<p>If you want <a href="https://stackoverflow.com/q/952914/1639625">flattened lists</a>, just <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain</code></a> them:</p>
<pre><code>&gt;&gt;&gt; combs = (list(chain(*p)) for p in product(*(combinations(l, c) for l, c in zip(lists, counts))))
&gt;&gt;&gt; list(combs)
[[[2, 3], [5, 6], [7, 8], [11, 12], [13, 14], [15, 16], [12, 16]],
 ...
 [[3, 4], [7, 8], [9, 10], [11, 12], [13, 14], [17, 18], [15, 19]]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What your are trying to achieve is the <code>Cartesian product of input iterables</code> and not the combinations of the item present in the list. Hence you have to use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a> instead.</p>
<p>In case repetition is allowed among the lists which used more than once, answer is simple:  </p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; b = [3,4]
&gt;&gt;&gt; [i for i in itertools.product(a, b, b)]
[(1, 3, 3), (1, 3, 4), (1, 4, 3), (1, 4, 4), (2, 3, 3), (2, 3, 4), (2, 4, 3), (2, 4, 4)]
</code></pre>
<p>But in case <code>repetition is not allowed</code> within the same lists, it will become little nasty and you need to combine the above answer with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>combinations()</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>chain()</code></a> (same as mentioned by <a href="https://stackoverflow.com/users/1639625/tobias-k">tobias_k</a>). This code will give the list of all <code>combinations</code>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, product, combinations
&gt;&gt;&gt; lists, counts = [a, b], [1, 2]  # to track that a is to be used once, and b twice
&gt;&gt;&gt; list(list(chain(*p)) for p in product(*(combinations(l, c) for l, c in zip(lists, counts))))
[[1, 3, 4], [2, 3, 4]]
</code></pre>
<p>However, in case you need permutations instead of combinations, you have to update the above code with <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>permutations()</code></a>:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, product, permutations
&gt;&gt;&gt; list(list(chain(*p)) for p in product(*(permutations(l, c) for l, c in zip(lists, counts))))
[[1, 3, 4], [1, 4, 3], [2, 3, 4], [2, 4, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated given clarification of expected output</strong>:</p>
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">You want <code>itertools.product</code></a>:</p>
<pre><code>itertools.product(a, b, b, c, c, c, c, d, e)
</code></pre>
<p>Which will pick one element from each of its arguments on each iteration, cycling the rightmost element the fastest, leftmost slowest.</p>
<p>You can use extended argument unpacking to express the repetition of certain arguments a little more obviously in Python 3:</p>
<pre><code>itertools.product(a, *[b]*2, *[c]*4, d, e)
</code></pre>
<p>Or use <a href="https://stackoverflow.com/a/39520252/364696">tobias_k's solution</a> for more general repetition of sequences (that will also work on Py2).</p>
</div>
<span class="comment-copy">Are the two draws from <code>b</code> with or without replacement?</span>
<span class="comment-copy">I'm not sure I understand what you want here (can you give the first few example outputs or something to be sure?), but if you wrap <code>itertools.combinations</code> in <code>list</code> for a decent number of inputs, you're almost guaranteed to blow your memory. The number of outputs grows at roughly <code>O(n!)</code> (factorial growth); you're usually expected to iterate the combinations one by one, not store them all at once.</span>
<span class="comment-copy">Without replacement,</span>
<span class="comment-copy">Could you show us the expected output?</span>
<span class="comment-copy">thank you this is awesome</span>
<span class="comment-copy">Not entirely clear from the question, but I think then the last line in the expected output should contain <code>[13, 14], [11, 12]</code> instead of <code>[11, 12], [13, 14]</code>.</span>
<span class="comment-copy">@tobias_k On looking at his sample output, I believe he needs cartesian product of the lists. Updated the answer with simple example. And I agree with you, the input params OP provided are too huge and gives no clear insight of his intention. Simpler example would be helpful</span>
<span class="comment-copy">order doesnt matter</span>
<span class="comment-copy">@WilliamBernard : In that case it is @ tobias_k answer you should be marked as accepted. As I have mentioned this after he answered</span>
<span class="comment-copy">@WilliamBernard: It was not cleared from the sample you provided in the question. So, I mentioned all the possible solutions :P</span>
<span class="comment-copy">But this will not draw one from a, two from b, etc., but just 9 from all together.</span>
<span class="comment-copy">@tobias_k: I answered before the OP clarified the precise usage. Will fix.</span>
