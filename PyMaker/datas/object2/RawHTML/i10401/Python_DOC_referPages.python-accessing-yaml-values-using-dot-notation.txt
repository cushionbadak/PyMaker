<div class="post-text" itemprop="text">
<p>I'm using a YAML configuration file. So this is the code to load my config in Python:</p>
<pre><code>import os
import yaml
with open('./config.yml') as file:
    config = yaml.safe_load(file)
</code></pre>
<p>This code actually creates a dictionary. Now the problem is that in order to access the values I need to use tons of brackets.</p>
<p>YAML:</p>
<pre><code>mysql:
    user:
        pass: secret
</code></pre>
<p>Python:</p>
<pre><code>import os
import yaml
with open('./config.yml') as file:
    config = yaml.safe_load(file)
print(config['mysql']['user']['pass']) # &lt;--
</code></pre>
<p>I'd prefer something like that (dot notation):</p>
<pre><code>config('mysql.user.pass')
</code></pre>
<p>So, my idea is to utilize the PyStache render() interface.</p>
<pre><code>import os
import yaml
with open('./config.yml') as file:
    config = yaml.safe_load(file)

import pystache
def get_config_value( yml_path, config ):
    return pystache.render('{{' + yml_path + '}}', config)

get_config_value('mysql.user.pass', config)
</code></pre>
<p>Would that be a "good" solution? If not, what would be a better alternative?</p>
<p><strong>Additional question [Solved]</strong></p>
<p>I've decided to use Ilja Everilä's solution. But now I've got an additional question: How would you create a wrapper Config class around DotConf?</p>
<p>The following code doesn't work but I hope you get the idea what I'm trying to do:</p>
<pre><code>class Config( DotDict ):
    def __init__( self ):
        with open('./config.yml') as file:
            DotDict.__init__(yaml.safe_load(file))

config = Config()
print(config.django.admin.user)
</code></pre>
<p>Error: </p>
<pre><code>AttributeError: 'super' object has no attribute '__getattr__'
</code></pre>
<p><strong>Solution</strong></p>
<p>You just need to pass <code>self</code> to the constructor of the super class.</p>
<pre><code>DotDict.__init__(self, yaml.safe_load(file))
</code></pre>
<p><strong>Even better soltution (Ilja Everilä)</strong></p>
<pre><code>super().__init__(yaml.safe_load(file))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>The Simple</h1>
<p>You could use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noreferrer"><code>reduce</code></a> to extract the value from the config:</p>
<pre><code>In [41]: config = {'asdf': {'asdf': {'qwer': 1}}}

In [42]: from functools import reduce
    ...: 
    ...: def get_config_value(key, cfg):
    ...:     return reduce(lambda c, k: c[k], key.split('.'), cfg)
    ...: 

In [43]: get_config_value('asdf.asdf.qwer', config)
Out[43]: 1
</code></pre>
<p>This solution is easy to maintain and has very few new edge cases, if your YAML uses a very limited subset of the language.</p>
<h1>The Correct</h1>
<p>Use a proper YAML parser and tools, such as in <a href="https://stackoverflow.com/a/39485868/2681632">this answer</a>.</p>
<hr/>
<h1>The Convoluted</h1>
<p>On a lighter note (not to be taken too seriously), you could create a wrapper that allows using attribute access:</p>
<pre><code>In [47]: class DotConfig:
    ...:     
    ...:     def __init__(self, cfg):
    ...:         self._cfg = cfg
    ...:     def __getattr__(self, k):
    ...:         v = self._cfg[k]
    ...:         if isinstance(v, dict):
    ...:             return DotConfig(v)
    ...:         return v
    ...:     

In [48]: DotConfig(config).asdf.asdf.qwer
Out[48]: 1
</code></pre>
<p>Do note that this fails for keywords, such as "as", "pass", "if" and the like.</p>
<p>Finally, you could get really crazy (read: probably not a good idea) and customize <code>dict</code> to handle dotted string and tuple keys as a special case, with attribute access to items thrown in the mix (with its limitations):</p>
<pre><code>In [58]: class DotDict(dict):
    ...:     
    ...:     # update, __setitem__ etc. omitted, but required if
    ...:     # one tries to set items using dot notation. Essentially
    ...:     # this is a read-only view.
    ...:
    ...:     def __getattr__(self, k):
    ...:         try:
    ...:             v = self[k]
    ...:         except KeyError:
    ...:             return super().__getattr__(k)
    ...:         if isinstance(v, dict):
    ...:             return DotDict(v)
    ...:         return v
    ...:
    ...:     def __getitem__(self, k):
    ...:         if isinstance(k, str) and '.' in k:
    ...:             k = k.split('.')
    ...:         if isinstance(k, (list, tuple)):
    ...:             return reduce(lambda d, kk: d[kk], k, self)
    ...:         return super().__getitem__(k)
    ...:
    ...:     def get(self, k, default=None):
    ...:         if isinstance(k, str) and '.' in k:
    ...:             try:
    ...:                 return self[k]
    ...:             except KeyError:
    ...:                 return default
    ...:         return super().get(k, default=default)
    ...:     

In [59]: dotconf = DotDict(config)

In [60]: dotconf['asdf.asdf.qwer']
Out[60]: 1

In [61]: dotconf['asdf', 'asdf', 'qwer']
Out[61]: 1

In [62]: dotconf.asdf.asdf.qwer
Out[62]: 1

In [63]: dotconf.get('asdf.asdf.qwer')
Out[63]: 1

In [64]: dotconf.get('asdf.asdf.asdf')

In [65]: dotconf.get('asdf.asdf.asdf', 'Nope')
Out[65]: 'Nope'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On the one hand your example takes the right approach by using <code>get_config_value('mysql.user.pass', config)</code> instead of solving the dotted access with attributes. I am not sure
if you realised that on purpose you were not trying to do the more intuitive:</p>
<pre><code>print(config.mysql.user.pass)
</code></pre>
<p>which you can't get to work, even when overloading <code>__getattr__</code>, as <code>pass</code> is a Python language element.</p>
<p>However your example describes only a very restricted subset of YAML files as it doesn't involve any sequence collections, nor any complex keys.</p>
<p>If you want to cover more than the tiny subset you can e.g. extend the powerful round-trip capable objects of <code>ruamel.yaml</code>:¹</p>
<pre><code>def mapping_string_access(self, s, delimiter=None, key_delim=None):
    def p(v):
        try:
            v = int(v)
        except:
            pass
        return v
       # possible extend for primitives like float, datetime, booleans, etc.

    if delimiter is None:
        delimiter = '.'
    if key_delim is None:
        key_delim = ','
    try:
        key, rest = s.split(delimiter, 1)
    except ValueError:
        key, rest = s, None
    if key_delim in key:
        key = tuple((p(key) for key in key.split(key_delim)))
    else:
        key = p(key)
    if rest is None:
        return self[key]
    return self[key].string_access(rest, delimiter, key_delim)

ruamel.yaml.comments.CommentedMap.string_access = mapping_string_access


def sequence_string_access(self, s, delimiter=None, key_delim=None):
    if delimiter is None:
        delimiter = '.'
    try:
        key, rest = s.split(delimiter, 1)
    except ValueError:
        key, rest = s, None
    key = int(key)
    if rest is None:
        return self[key]
    return self[key].string_access(rest, delimiter, key_delim)

ruamel.yaml.comments.CommentedSeq.string_access = sequence_string_access
</code></pre>
<p>Once that is set up you are can run the following:</p>
<pre><code>yaml_str = """\
mysql:
    user:
        pass: secret
    list: [a: 1, b: 2, c: 3]
    [2016, 9, 14]: some date
    42: some answer
"""

config = ruamel.yaml.round_trip_load(yaml_str)

def get_config_value(path, data, **kw):
    return data.string_access(path, **kw)

print(get_config_value('mysql.user.pass', config))
print(get_config_value('mysql:user:pass', config, delimiter=":"))
print(get_config_value('mysql.list.1.b', config))
print(get_config_value('mysql.2016,9,14', config))
print(config.string_access('mysql.42'))
</code></pre>
<p>giving:</p>
<pre><code>secret
secret
2
some date
some answer
</code></pre>
<p>showing that with a bit more forethought and very little extra work you can have flexible dotted access to many to a vast range of YAML files, and not just those consisting of recursive mappings with string scalars as keys.</p>
<ol>
<li>As shown you can directly call <code>config.string_access(</code>mysql.user.pass<code>)</code> instead of defining and using <code>get_config_value()</code></li>
<li>this works with strings and integers as mapping keys, but can be easily extended to support other key types (boolean, date, date-time).</li>
</ol>
<hr/>
<p>¹ <sub>This was done using <a href="https://pypi.python.org/pypi/ruamel.yaml" rel="nofollow noreferrer">ruamel.yaml</a> a YAML 1.2 parser, of which I am the author.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>I had the same problem a while ago and built this getter:</p>
<pre><code> def get(self, key):
    """Tries to find the configuration value for a given key.
    :param str key: Key in dot-notation (e.g. 'foo.lol').
    :return: The configuration value. None if no value was found.
    """
    try:
        return self.__lookup(self.config, key)
    except KeyError:
        return None

def __lookup(self, dct, key):
    """Checks dct recursive to find the value for key.
    Is used by get() interanlly.
    :param dict dct: The configuration dict.
    :param str key: The key we are looking for.
    :return: The configuration value.
    :raise KeyError: If the given key is not in the configuration dict.
    """
    if '.' in key:
        key, node = key.split('.', 1)
        return self.__lookup(dct[key], node)
    else:
        return dct[key]
</code></pre>
<p>The getter looks-up a config value from <code>self.config</code> in a recursive manner (by using <code>__lookup</code>).
If you have trouble adjusting this for your case, feel free to ask for further help.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's quite old question, but I came here hunting for the answer, but looking for more simpler solution. Finally, came up with my own solution using <code>easydict</code> library; installed using <code>pip install easydict</code></p>
<pre class="lang-py prettyprint-override"><code>  def yaml_load(fileName):
    import yaml
    from easydict import EasyDict as edict
    fc = None
    with open(fileName, 'r') as f:
      fc = edict(yaml.load(f))
      ## or use safe_load
      ## fc = edict(yaml.safe_load(f))

    return fc
</code></pre>
<p>Now, simply call <code>yaml_load</code> with the valid <code>yaml filename</code>:</p>
<pre class="lang-py prettyprint-override"><code>config = yaml_load('./config.yml')

## assuming: config["mysql"]["user"]["pass"] is a valid key in config.yml
print("{}".format(config.mysql.user.pass))
</code></pre>
</div>
<span class="comment-copy">Using a template engine for this is a truly awful hack. Please don't do this in any real application!</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/11049117/how-to-load-a-pyyaml-file-and-access-it-using-attributes-instead-of-using-the-di" title="how to load a pyyaml file and access it using attributes instead of using the di">stackoverflow.com/questions/11049117/…</a> seems related, or even a duplicate</span>
<span class="comment-copy">Sorry, but this is even more bloated than the bracket notation...</span>
<span class="comment-copy">YMMV, I'd call having a template library as a dependency for config access bloat.</span>
<span class="comment-copy">This solution is <b>much</b> cleaner than abusing a template engine for this.</span>
<span class="comment-copy">@Lugaxx: Remember that you can wrap your config object once using <code>DotDict</code> (<code>config = DotDict(config)</code>) and then it's simply <code>config.asdf.asdf.qwer</code> everywhere else in your code. It won't get any shorter than that.</span>
<span class="comment-copy">You're using the "old" style of calling super class methods. Replace <code>DotDict.__init__(yaml.safe_load(file))</code> with <code>super().__init__(yaml.safe_load(file)</code>. In your original you were calling <code>DotDict.__init__</code> with the loaded configuration as <code>self</code>. Explicitly calling some super classes method can be useful, but perhaps not in this situation.</span>
