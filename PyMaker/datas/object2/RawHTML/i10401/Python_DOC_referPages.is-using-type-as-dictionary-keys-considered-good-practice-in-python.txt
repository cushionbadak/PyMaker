<div class="post-text" itemprop="text">
<p>I have a lookup table like this:</p>
<pre><code>lookup = {
  "&lt;class 'Minority.mixin'&gt;": report_minority,
  "&lt;class 'Majority.mixin'&gt;": report_majority,
}

def report(o):
  h = lookup[str(type(o))]
  h()
</code></pre>
<p>It looks awkward to me as the <code>key</code> is precariously linked to how <code>type()</code> returns and represents a <code>class</code> in <code>string</code>. If one day Python changes its way to represents <code>class</code> types in <code>string</code>, all the codes like this are broken. So I want to have some advice from pros, is such type of keys considered good or bad? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The question would more be <em>why are you doing this in the first place</em>? What advantage do <em>you</em> think using strings has?</p>
<p>Class objects are hashable, so you can use <code>Minority.mixin</code> and <code>Majority.mixin</code> <em>directly</em> as keys. And when you do so, you ensure that the key is <em>always</em> the exact same object provided your classes are globals in their respective modules, making them singletons your program. Moreover, there is no chance of accidental confusion when you later on refactor your code to rename modules and you end up with a <em>different</em> type with that exact <code>repr()</code> output.</p>
<p>So unless you have a specific usecase where you <em>can't</em> use the class directly, you should not be using the string representations.</p>
<p>(And even if you were to generate classes with a factory function, using a baseclass and <code>isinstance</code> checks or extracting a base class from the MRO would probably be preferable).</p>
<p>So, for your usecase, stick to:</p>
<pre><code>lookup = {
    Minority.mixin: report_minority,
    Majority.mixin: report_majority,
}

def report(o):
    h = lookup[type(o)])
    h()
</code></pre>
<p>Next, if you ensure that <code>report_minority</code> and <code>report_majority</code> are <em>functions</em> (and not methods, for example), you can use <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow"><code>functools.singledispatch()</code></a> and dispense with your mapping altogether:</p>
<pre><code>from functools import singledispatch

@singledispatch
def report(o):
    raise ValueError('Unhandled type {}'.format(type(o)))

@report.register(Minority.mixin)
def report_minority(o):
    # handle a Minority instance

@report.register(Majority.mixin)
def report_majority(o):
    # handle a Majority instance
</code></pre>
<p>Note that this won't work with methods, as methods have to take multiple arguments for dispatch to work, as they always take <code>self</code>.</p>
<p>Single-dispatch handles <em>subclasses</em> much better, unlike your <code>str</code>-based mapping or even the direct class mapping.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just remove the <code>str</code> from the lookup and from the dictionary. So</p>
<pre><code>lookup = {
   Minority.mixin : report_minority,
   Majority.mixin : report_majority,
}

def report(o):
    h = lookup[type(o)]
    h()
</code></pre>
<p>This fixes your immediate concern and is fairly reasonable code.  However, it seems like dispatching on the type is exactly what OO is for.  So why not make those varying report functions methods on the <code>o</code> object derived from its type?  Then you could just write:</p>
<pre><code>o.report()
</code></pre>
<p>and the correct variant would be obtained from the class.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at that script, I don't think it's perfect but it works and I think it's more elegant than your solution :</p>
<pre><code>#!/usr/bin/env python3

class Person:
    pass

def display_person():
    print("Person !")

class Car:
    pass

def display_car():
    print("Car !")

lookup = {
    Person: display_person,
    Car: display_car
}


def report(o):
    lookup[o.__class__]()


report(Person())
report(Car())
</code></pre>
<p>Edit : modification for Python3</p>
</div>
<span class="comment-copy">It doesn't matter how long I've been writing in Python, I still learn something from every one of your answers Martijn.</span>
<span class="comment-copy">I feel so luck got Martijn to answer my question. Really like his(or maybe her? We never met) hand-holding style, helps a lot!</span>
<span class="comment-copy">@ Martijn Pietersâ™¦ Could you please explain a bit on the word "singletons" in your second paragraph? Does it refer to the singleton pattern? It doesn't seem to me there is such a pattern exist in my example, does it? Thanks.</span>
<span class="comment-copy">@JinghuiNiu: there should only ever be <i>one</i> copy of a given class in Python memory; class objects are singletons if declared at the module level.</span>
<span class="comment-copy">@JinghuiNiu: if you used a factory function (<code>def createclass():</code>, <code>class Foo: pass</code>, <code>return Foo</code>) you can create multiple class objects, and they'd each be unique and not compare equal (<code>createclass() == createclass()</code> produces <code>False</code>), so in that case the dictionary lookup would fail.</span>
<span class="comment-copy">Thanks also for your pointing out that polymorphism direction. Unfortunately my implementation involves a variety of immutable Python classes, and also involves writing into a database, so subclassing those classes and add a distinct report() seem less elegant than this dispatching route. But I wasn't so sure until reading posts here.</span>
<span class="comment-copy">@ Dorian Could you please elaborate on a little why this solution is more elegant? Is looping really necessary? I don't know but I personally feel that looping is more complicated than a simple dictionary lookup??</span>
<span class="comment-copy">@ Dorian Also performance wise, an iteration is much more expensive than a hash lookup, isn't it?</span>
<span class="comment-copy">I think it's more elegant because <code>isistance</code> is a better way to test the type of an object than use <code>type</code>. But you're right, I don't like the loop too, it may be more expensive, if you dict contains only 2 elements, it's not a big deal, but it could be if you dict is bigger.</span>
<span class="comment-copy">@JinghuiNiu I found a better solution to remove the loop, I didn't know the <code>__class__</code> attribute but I think it's perfect to resolve that issue.</span>
