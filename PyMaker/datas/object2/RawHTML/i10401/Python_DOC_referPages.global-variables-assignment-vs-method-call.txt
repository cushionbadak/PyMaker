<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6329499/in-python-why-is-list-automatically-global">In Python, why is list[] automatically global?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>To avoid accidentally modifying a global variable, python requires an explicit <code>global</code> statement before assigning to a global variable. However, modifying a global variable by calling its method can be done without any extra statement:</p>
<pre><code>x = [1, 2]
y = [1, 2]
def f():
  global x
  x = x + [3] # won't affect global variable without global statement
  y.append(3) # will affect global variable without global statement
</code></pre>
<p>This seemed slightly inconsistent. Is this design choice made because it's considered less dangerous / less of a bad practice to modify global mutable objects through a method call, compared to replacing them with an entire new object? If so, why?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>In Python, <strong>variables that are only referenced inside a function are
  implicitly global</strong>. <strong>If a variable is assigned a value</strong> anywhere
  within the function’s body, <strong>it’s assumed to be a local unless
  explicitly declared as global</strong>.</p>
</blockquote>
<p>In your case <code>y</code> is referenced inside of the function, thus implicitly global. On the other hand, <code>x</code> is assigned a value, thus it must be local unless explicitly declared otherwise.</p>
<p>And the documentation goes further to answer your questions:</p>
<blockquote>
<p>Though a bit surprising at first, a moment’s consideration explains
  this. On one hand, <strong>requiring global for assigned variables provides a
  bar against unintended side-effects.</strong> On the other hand, <strong>if global was
  required for all global references, you’d be using global all the
  time.</strong> You’d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>It's not really about mutability at the value level, which is how you're looking at it; it's about mutability of variable references, i.e. what a named item (a variable) is pointing at.</p>
<pre class="lang-python prettyprint-override"><code>x = [1, 2]
print(id(x)) # 57226944
y = [1, 2]
print(id(y)) # 57262728
def f():
  global x
  x = x + [3]
  print(id(x)) # 57306648 - CHANGED
  y.append(3)
  print(id(y)) # 57262728 - UNCHANGED

f()
</code></pre>
<p>Note that the name 'x' is now pointing at a new thing (a newly-created list), whereas the .append operation on y has not changed what the name 'y' is pointing at.</p>
</div>
<div class="post-text" itemprop="text">
<p>In one sentence:</p>
<p>"without declaring it explicitly, python will not let you change the <code>reference</code> of a global variable".</p>
<p>Now let's explain what you have just read, assignment of object to a variable is actually making a <code>reference</code>, which is a memory address to where the object lays in the memory.</p>
<p>When we write:</p>
<pre><code>x = [1, 2]
</code></pre>
<p>What actually happens that somewhere in the memory the list object is allocated with all its function references and members and other shit. This address is what actually kept in <code>x</code>.</p>
<p>We may use the function <code>id(object)</code> to notice the change:</p>
<pre><code>x = [1, 2]
def foo():
 print id(x)    # an address like 50075016
 y = [1, 2, 3]
 print id(y)    # another address like 50075272 
 x = y          # won't work without declaring 'global x' 
                # because we try to change the address stored in x
                # from 50075016 to 50075272.
 x.append(3)    # works
 print id(x)    # same address 50075016
</code></pre>
</div>
<span class="comment-copy">This helped. <a href="http://stackoverflow.com/questions/6329499/in-python-why-is-list-automatically-global" title="in python why is list automatically global">stackoverflow.com/questions/6329499/…</a></span>
<span class="comment-copy">Ah so it's not that changing <code>y</code> in my question is safe, it's just that it's too hard for python interpreter to cleanly distinguish it from the relatively safe cases of accessing components of imported modules?</span>
<span class="comment-copy">I don't think it's only hard for the Python interpreter, but for any interpreter. Essentially there is no difference beyond the one we create in our own minds. <code>Global</code> is also fundamental to avoid name collisions, otherwise we'd have to create different names for every function we'd write.</span>
<span class="comment-copy">This makes sense.</span>
<span class="comment-copy">Of course, but I guess my question was why it's less of a risk to modify the object compared to changing which object the variable points to.</span>
