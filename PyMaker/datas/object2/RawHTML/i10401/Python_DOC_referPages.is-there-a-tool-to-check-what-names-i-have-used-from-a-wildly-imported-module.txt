<div class="post-text" itemprop="text">
<p>I've been using python to do computations for my research. In an effort to clean up my terrible code, I've been reading <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" rel="nofollow">Code Like a Pythonista: Idiomatic Python</a> by David Goodger. </p>
<p>In this article, Goodger advises against "wild-card" imports of the form</p>
<pre><code>from module import *
</code></pre>
<p>My code uses a lot of these. I'd like to clean my code up, but I'm not sure how. I'm curious if there is a way to check what names from <code>module</code> I have used in my code. This way I could either explicitly import these names or replace the names with <code>module.name</code>. Is there a tool designed to accomplish such a task?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a tool like <code>pyflakes</code> (which you should use anyway) to note which names in your code become undefined after you replace <code>from module import *</code> with <code>import module</code>. Once you've positively identified every instance of a name imported from <code>module</code>, you can assess whether to</p>
<ol>
<li>Always use <code>import module</code> and <code>module.x</code> for <code>x</code> imported from <code>module</code>.</li>
<li>Use <code>import module as m</code> and <code>m.x</code> if the module name is long.</li>
<li>Selectively import some names from <code>module</code> into the module namespace with <code>from module import x, y, z</code></li>
</ol>
<p>The above three are not mutually exclusive; as an extreme example, you can use all three in the same module:</p>
<pre><code>import really.long.module.name
import really.long.module.name as rlmn
from really.long.module.name import obvious_name

really.long.module.name.foo()  # full module name
rlmn.bar()                     # module alias
obvious_name()                 # imported name
</code></pre>
<p>all in the same code. (I don't <em>recommend</em> using all three in the same module. Stick with either the full module name <em>or</em> the alias throughout a single module, but there is no harm importing common, obvious names directly and using the fully qualified name for more obscure module attributes.)</p>
</div>
<div class="post-text" itemprop="text">
<h2>Overview</h2>
<p>One approach is to:</p>
<ul>
<li>Manually (or even automatically) identify each of the modules you've imported from using the <code>*</code> approach, </li>
<li>Import them in a separate file,</li>
<li>And then do a search-and-replace if they appear in <code>sys.modules[&lt;module&gt;].__dict__</code>, which <a href="https://docs.python.org/3/reference/import.html#loaders" rel="nofollow">keeps track</a> of which objects from a Python module have been loaded.</li>
</ul>
<p>See for yourself <code>sys.modules</code> in action:</p>
<pre><code>from numpy import *
import sys

sys.modules['numpy'].__dict__.keys()  # will display everything you just imported from `numpy`
&gt;&gt;&gt; ['disp', 'union1d', 'all', 'issubsctype', 'savez', 'atleast_2d', 'restoredot', 'ptp', 'PackageLoader', 'ix_', 'mirr', 'blackman', 'FLOATING_POINT_SUPPORT', 'division', 'busdaycalendar', 'pkgload', 'void', 'ubyte', 'moveaxis', 'ERR_RAISE', 'void0', 'tri', 'diag_indices', 'array_equal', 'fmod', 'True_', 'indices', 'loads', 'round', 'set_numeric_ops', 'pmt', 'nanstd', '_mat', 'cosh', 'object0', 'argpartition', 'FPE_OVERFLOW', 'index_exp', 'append', 'compat', 'nanargmax', 'hstack', 'typename', 'diag', 'rollaxis', 'ERR_WARN', 'polyfit', 'version', 'memmap', 'nan_to_num', 'complex64', 'fmax', 'spacing', 'sinh', '__git_revision__', 'unicode_', 'sinc', 'trunc', 'vstack', 'ERR_PRINT', 'asscalar', 'copysign', 'less_equal', 'BUFSIZE', 'object_', 'divide', 'csingle', 'dtype', 'unsignedinteger', 'fastCopyAndTranspose', 'bitwise_and', 'uintc', 'select', 'deg2rad', 'nditer', 'eye', 'kron', 'newbuffer', 'negative', 'busday_offset', 'mintypecode', 'MAXDIMS', 'sort', 'einsum', 'uint0', 'zeros_like', 'int_asbuffer', 'uint8', 'chararray', 'linspace', 'resize', 'uint64', 'ma', 'true_divide', 'Inf', 'finfo', 'triu_indices', 'complex256', 'add_newdoc', 'seterrcall', 'logical_or', 'minimum', 'WRAP', 'tan', 'absolute', 'MAY_SHARE_EXACT', 'numarray', 'array_repr', 'get_array_wrap', 'polymul', 'tile', 'array_str', 'setdiff1d', 'sin', 'longlong', 'product', 'int16', 'str_', 'mat', 'fv', 'max', 'asanyarray', 'uint', 'npv', 'logaddexp', 'flatnonzero', 'amin', 'correlate', 'fromstring', 'left_shift', 'searchsorted', 'int64', 'may_share_memory', 'dsplit', 'intersect1d', 'can_cast', 'ppmt', 'show_config', 'cumsum', 'roots', 'outer', 'CLIP', 'fix', 'busday_count', 'timedelta64', 'degrees', 'choose', 'FPE_INVALID', 'recfromcsv', 'fill_diagonal', 'empty_like', 'logaddexp2', 'greater', 'histogram2d', 'polyint', 'arctan2', 'datetime64', 'complexfloating', 'ndindex', 'ctypeslib', 'PZERO', 'isfortran', 'asfarray', 'nanmedian', 'radians', 'fliplr', 'alen', 'recarray', 'modf', 'mean', 'square', 'ogrid', 'MAY_SHARE_BOUNDS', 'nanargmin', 'r_', 'diag_indices_from', 'hanning', 's_', 'allclose', 'extract', 'float16', 'ulonglong', 'matrix', 'asarray', 'poly1d', 'promote_types', 'rec', 'datetime_as_string', 'uint32', 'math', 'log2', '__builtins__', 'cumproduct', 'diagonal', 'atleast_1d', 'meshgrid', 'column_stack', 'put', 'byte', 'remainder', 'row_stack', 'expm1', 'nper', 'ndfromtxt', 'matmul', 'place', 'DataSource', 'newaxis', 'arccos', 'signedinteger', 'ndim', 'rint', 'number', 'rank', 'little_endian', 'ldexp', 'lookfor', 'array', 'vsplit', 'common_type', 'size', 'logical_xor', 'geterrcall', 'sometrue', 'exp2', 'bool8', 'msort', 'alltrue', 'zeros', 'False_', '__NUMPY_SETUP__', 'nansum', 'bool_', 'inexact', 'nanpercentile', 'broadcast', 'copyto', 'short', 'arctanh', 'typecodes', 'rot90', 'savetxt', 'sign', 'int_', 'std', 'not_equal', 'fromfunction', 'tril_indices_from', '__config__', 'double', 'require', 'rate', 'typeNA', 'str', 'getbuffer', 'abs', 'clip', 'savez_compressed', 'frompyfunc', 'triu_indices_from', 'conjugate', 'alterdot', 'asfortranarray', 'binary_repr', 'angle', 'lib', 'min', 'unwrap', 'apply_over_axes', 'ERR_LOG', 'right_shift', 'take', 'broadcast_to', 'byte_bounds', 'trace', 'warnings', 'any', 'shares_memory', 'compress', 'histogramdd', 'issubclass_', 'multiply', 'mask_indices', 'amax', 'logical_not', 'average', 'partition', 'nbytes', 'exp', 'sum', 'dot', 'int0', 'nanprod', 'longfloat', 'random', 'setxor1d', 'copy', 'FPE_UNDERFLOW', 'frexp', 'errstate', 'nanmin', 'swapaxes', 'SHIFT_OVERFLOW', 'infty', 'fft', 'ModuleDeprecationWarning', 'digitize', '__file__', 'NZERO', 'ceil', 'ones', 'add_newdoc_ufunc', '_NoValue', 'deprecate', 'median', 'geterr', 'convolve', 'isreal', 'where', 'isfinite', 'SHIFT_UNDERFLOW', 'MachAr', 'argmax', 'testing', 'deprecate_with_doc', 'full', 'polyder', 'rad2deg', 'isnan', '__all__', 'irr', 'sctypeDict', 'NINF', 'min_scalar_type', 'count_nonzero', 'sort_complex', 'nested_iters', 'concatenate', 'vdot', 'bincount', 'transpose', 'array2string', 'corrcoef', 'fromregex', 'vectorize', 'set_printoptions', 'isrealobj', 'trim_zeros', 'unravel_index', 'cos', 'float64', 'log1p', 'ushort', 'equal', 'cumprod', 'float_', 'vander', 'geterrobj', 'load', 'fromiter', 'poly', 'bitwise_or', 'polynomial', 'diff', 'iterable', 'array_split', 'get_include', 'pv', 'tensordot', 'piecewise', 'invert', 'UFUNC_PYVALS_NAME', 'SHIFT_INVALID', 'c_', 'flexible', 'pi', '__doc__', 'empty', 'VisibleDeprecationWarning', 'find_common_type', 'isposinf', 'arcsin', 'sctypeNA', 'imag', 'sctype2char', 'singlecomplex', 'SHIFT_DIVIDEBYZERO', 'matrixlib', 'apply_along_axis', 'reciprocal', 'tanh', 'dstack', 'cov', 'cast', 'logspace', 'packbits', 'issctype', 'mgrid', 'longdouble', 'signbit', 'conj', 'asmatrix', 'inf', 'flatiter', 'bitwise_xor', 'fabs', 'generic', 'reshape', 'NaN', 'cross', 'sqrt', '__package__', 'longcomplex', 'complex', 'pad', 'split', 'floor_divide', '__version__', 'format_parser', 'nextafter', 'polyval', 'flipud', 'i0', 'iscomplexobj', 'sys', 'mafromtxt', 'bartlett', 'polydiv', 'stack', 'identity', 'safe_eval', 'greater_equal', 'Tester', 'trapz', 'PINF', 'object', 'recfromtxt', 'oldnumeric', 'add_newdocs', 'RankWarning', 'ascontiguousarray', 'less', 'putmask', 'UFUNC_BUFSIZE_DEFAULT', 'unicode', 'half', 'NAN', 'absolute_import', 'typeDict', '__path__', 'shape', 'setbufsize', 'cfloat', 'RAISE', 'isscalar', 'character', 'bench', 'source', 'add', 'uint16', 'cbrt', 'bool', 'ufunc', 'save', 'ravel', 'float32', 'real', 'int32', 'tril_indices', 'around', 'lexsort', 'complex_', 'ComplexWarning', 'unicode0', 'ipmt', '_import_tools', 'atleast_3d', 'isneginf', 'integer', 'unique', 'mod', 'insert', 'bitwise_not', 'getbufsize', 'array_equiv', 'arange', 'asarray_chkfinite', 'in1d', 'interp', 'hypot', 'logical_and', 'get_printoptions', 'diagflat', 'float128', 'nonzero', 'kaiser', 'ERR_IGNORE', 'polysub', 'fromfile', 'prod', 'nanmax', 'core', 'who', 'seterrobj', 'power', 'bytes_', 'percentile', 'FPE_DIVIDEBYZERO', '__name__', 'subtract', 'print_function', 'nanmean', 'frombuffer', 'iscomplex', 'add_docstring', 'argsort', 'fmin', 'ones_like', 'is_busday', 'arcsinh', 'intc', 'float', 'ndenumerate', 'intp', 'unpackbits', 'Infinity', 'log', 'cdouble', 'complex128', 'long', 'round_', 'broadcast_arrays', 'inner', 'var', 'sctypes', 'log10', 'uintp', 'linalg', 'histogram', 'issubdtype', 'maximum_sctype', 'squeeze', 'int8', 'info', 'seterr', 'argmin', 'genfromtxt', 'maximum', 'record', 'obj2sctype', 'clongdouble', 'euler_gamma', 'arccosh', 'delete', 'tril', 'int', 'ediff1d', 'char', 'single', 'loadtxt', 'hsplit', 'ScalarType', 'triu', 'floating', 'expand_dims', 'floor', 'polyadd', 'nan', 'TooHardError', 'emath', 'arctan', 'bmat', 'isclose', 'ERR_DEFAULT', 'test', 'roll', 'string0', 'compare_chararrays', 'iinfo', 'real_if_close', 'repeat', 'nanvar', 'hamming', 'ALLOW_THREADS', 'ravel_multi_index', 'string_', 'isinf', 'ndarray', 'e', 'ERR_CALL', 'datetime_data', 'clongfloat', 'full_like', 'result_type', 'gradient', 'base_repr', 'argwhere', 'set_string_function']
</code></pre>
<p>You can either manually check if a function name you're not sure of appears here using <code>if &lt;function_name&gt; in sys.modules[&lt;module&gt;].__dict__</code>, or you can write a neat automated script that goes through each entry in <code>sys.modules[&lt;module&gt;]</code>.</p>
<p>I would favour the latter for anything too sophisticated, and the former for diagnostic purposes.</p>
<h2>Rough Implementation of Automatic Tool</h2>
<p>A very, very, very quick-and-dirty example of how to write such an automated script:</p>
<pre><code>import re
import sys

with open('file_I_want_to_change.py', 'r+') as f:
    file_contents = f.read()  # get the entire file as a string
    search_string = r"from ([a-zA-Z]+) import *"  # regex to find all loaded module names
    module_names = re.findall(search_string, file_contents)
    map(__import__, module_names)  # import ALL of these modules names at once

    for module in module_names:
        for function_name in sys.modules[module].__dict__:
            # do a very quick-and-dirty replace-all
            file_contents = file_contents.replace(function_name, "{0}.{1}".format(module, function_name)) 
    f.seek(0)  # move to start of file
    f.write(file_contents)
</code></pre>
<p>This is not very robust, and you shouldn't use it as-is! You may find yourself overwriting names <em>not</em> from the module but that are defined anyway. </p>
<p>It's probably best to allow some form of user interaction to confirm you want to apply a change for each function name found. But it gets the gist across.</p>
<p>This has been tested with the following simple example file:</p>
<pre><code>from numpy import *
array([1])
</code></pre>
<p>becomes </p>
<pre><code>from numpy import *
numpy.array([1])
</code></pre>
<p><strong>EDIT:</strong> I have since created a much more robust and useful command line utility <a href="https://github.com/AkshatM/wildcard_import_fixer" rel="nofollow">here</a></p>
</div>
<span class="comment-copy">The difficulty you are facing -- knowing which functions come from which modules -- is one of the very reasons why you shouldn't use wildcard imports. It's a bummer of a lesson to have to learn first hand.</span>
<span class="comment-copy">I wrote you a tool to do exactly this with one single script. See my answer.</span>
<span class="comment-copy">Perhaps change "module" to "ReallyLongModuleName" and "x" to "obvious_name"?</span>
<span class="comment-copy">Pyflakes actually prints out when an object potentially is from a star import if you use one: <code>Foo may be undefined, or defined from star imports: module_i_star_imported</code></span>
<span class="comment-copy">This utility looks cool. Looking forward to checking it out.</span>
