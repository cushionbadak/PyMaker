<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/15889131/how-to-find-the-cumulative-sum-of-numbers-in-a-list">How to find the cumulative sum of numbers in a list?</a>
<span class="question-originals-answer-count">
                    18 answers
                </span>
</li>
</ul>
</div>
<p>I have an old list and I want to sum up every single element to a new list:</p>
<pre><code>    lst_old = [1, 2, 3, 4, 5]
    lst_new = [1, 3, 6, 10, 15]
</code></pre>
<p>Is there an elegant way to implement that in Python 3 with short and fast code? Apart from <code>sum()</code> which only prints last element I couldn't find a proper solution for my problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.accumulate</code>, eg:</p>
<pre><code>from itertools import accumulate

lst_old = [1, 2, 3, 4, 5]
lst_new = list(accumulate(lst_old))
# [1, 3, 6, 10, 15]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>itertools.accumulate as mentioned by Jon Clements is the best way to do. However, in case you want an explicit way to do it, here goes:</p>
<pre><code>lst_old = [1, 2, 3, 4, 5]
sum = 0
lst_new = []
for item in lst_old:
    sum += item
    lst_new.append(sum)
</code></pre>
<p>Main advantage of this is, you can wrap it in a function and if there is any transform or validation need to be performed, can be added.</p>
<p>For example, lets say you want to stop the function keep going after a limit, the following will help:</p>
<pre><code>def accumulate_items(lst_old, limit=0):
    sum = 0
    output_list = []
    for item in lst_old:
        sum += item
        output_list.append(sum)
        if limit and sum &gt; limit:
            break
    return output_list
</code></pre>
<p>The flexibility will be limitless if there is any transformation or operation need to be done here. Have a pre-condition that need to be set? Go ahead. Have a post-condition that need to be tested? Go ahead. Pretty huge list and wanted a generator based solution just like the itertools.accumulate? Go ahead. Need to add a validation or exception handling? Go ahead.</p>
<p>However, no transformation and simply accumulate? The previous answer is the best. Using sum with list indices is pretty slow as the order of complexity sky rockets.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can take the sum of a slice of a list using listname[start:end], with both start and end as optional arguments (defaulting to the beginning and end of the list):</p>
<pre><code>lst_old = [1, 2, 3, 4, 5]
lst_new = []

for i, num in enumerate(lst_old):
    index = i+1
    var = sum(lst_old[:index])
    print(var)
    lst_new.append(var)
</code></pre>
</div>
<span class="comment-copy">Whose doc is there: <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.accumulate</a></span>
<span class="comment-copy">An answer from Jon does the same. Also you can pass the starting value to enumerate instead of incrementing manually. However, I did not down vote :)</span>
