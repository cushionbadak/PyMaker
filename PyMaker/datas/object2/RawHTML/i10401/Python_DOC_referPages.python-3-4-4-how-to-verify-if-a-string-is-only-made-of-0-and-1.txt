<div class="post-text" itemprop="text">
<p>I'm doing a binary to decimal converter in python 3.4.4 and it's pretty much finished except for the fact that I would like to check that the binary number entered by the user is indeed a binary number (check if the string is only made of o and 1) but I'm unsure what to do.</p>
<p>here's the program:</p>
<pre><code>binary=input("Enter a binary number") 
bit=len(binary)
result=0
power=0
while bit&gt;0:
    result=result+int(binary[bit-1])*2**power
    bit=bit-1
    power=power+1
print(binary, " in decimal is equal to ", result, sep="")
</code></pre>
<p>hopefully someone can help me &lt;3</p>
</div>
<div class="post-text" itemprop="text">
<p>Follow the <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP approach</a>, try to convert it to decimal via <a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow"><code>int()</code></a> and handle the <code>ValueError</code>:</p>
<pre><code>try:
    int(binary, 2)
    is_binary = True
except ValueError:
    is_binary = False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you <em>must</em> avoid using <code>int(binary, 2)</code> and handle the exception, you could use the <a href="https://docs.python.org/2/library/functions.html#any" rel="nofollow"><code>all()</code> function</a> with a <a href="https://docs.python.org/2/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a>:</p>
<pre><code>all(c in '01' for c in binary)
</code></pre>
<p><code>all()</code> with a generator expression will bail out early and return <code>False</code> when a non-binary digit is found.</p>
<p>If you are already looping over all characters <em>anyway</em> you could just raise an exception in your loop:</p>
<pre><code>binary=input("Enter a binary number") 
bit=len(binary)
result=0
power=0
try:
    while bit&gt;0:
        if binary[bit-1] not in '01':
            raise ValueError('Not a binary string: %s' % binary)
        result=result+int(binary[bit-1])*2**power
        bit=bit-1
        power=power+1
except ValueError:
    print('%s is not a binary string')
else:
    print(binary, " in decimal is equal to ", result, sep="")
</code></pre>
<p>Rather than use an index, your code could just loop over the reverse of the string, using numbers generated by <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a> as the power:</p>
<pre><code>binary = input("Enter a binary number") 
result = 0
try:
    for power, bit in enumerate(reversed(binary)):
        if bit not in '01':
            raise ValueError('Not a binary string: %s' % binary)
        result += int(bit) * 2 ** power
except ValueError:
    print('%s is not a binary string')
else:
    print(binary, " in decimal is equal to ", result, sep="")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>all()</code></p>
<pre><code> all(x in '10' for x in binary_string) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe <code>all(x in "01" for x in binary)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following is for 2.7.9, just look for a 3.4.4 parallel:</p>
<pre><code>import re

binary = raw_input("enter binary number")
if re.match("^[01]*$", binary):
    print "ok"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could check if the sum of  occurrences of '0' and '1' is equal to the length of the string.</p>
<pre><code> binary.count('0') + binary.count('1') == len(binary)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suppose checking the input string for correctness is best done with regular expressions. The code that would help you is the following:</p>
<pre><code>import re

binary = input("Enter a binary number") 
len_bin = len(binary)
result = 0
if re.search("^[0-1]+$", binary) is not None:
    for position in range(len_bin):
        result += int(binary[position]) * 2 ** (len_bin - position - 1)

    print(binary + " in decimal is equal to " + str(result))
else:
    print("The input is not a binary number")
</code></pre>
<p>The regular expression determines whether the binary number only contains zeros and ones. Also, I took the opportunity to shorten the code a bit, using <code>result += ...</code>, which is equal to <code>result = result + ...</code>.</p>
</div>
<span class="comment-copy">thank you all for helping, it works (some of the solutions looked too complex and i didn't use them, should have precised i wasn't really an expert xD)</span>
<span class="comment-copy">At which point they may as well add <code>return</code> and be done with it.</span>
<span class="comment-copy">A downvote without an explanation seems a little cowardly to me and it certainly doesn't help the one who posted the answer. What's more, this solution appears to also work.</span>
<span class="comment-copy">@MattCremeens: it may work, but is rather inefficient; <code>str.count()</code> traverses the string in full, so this does two full scans. <i>All</i> other solutions presented here bail out early; i.e. they'll report failure the moment the first invalid character is detected while scanning.</span>
<span class="comment-copy">Then whoever downvoted should have stated as such so that the poster can learn from it. Downvoting without explanation does nothing more than lower the self-esteem and confidence of the one who posted. And, honestly, it's tough for me to understand downvoting a post that works, even if it is less efficient than the other posts. I could see upvoting all posts other than this one, maybe. But his code has the benefit of being easy to understand as often less-efficient code can be. That is worth at least something.</span>
<span class="comment-copy">my answer was made with the assumption that the asker is a student doing a homework or a beginner, who can not use or don't understand what is an exception, regular expression, etc. So I offer a simply and intuitive  solution.</span>
