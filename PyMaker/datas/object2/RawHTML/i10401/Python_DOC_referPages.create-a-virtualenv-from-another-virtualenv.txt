<div class="post-text" itemprop="text">
<p>Can we create a <a href="https://virtualenv.pypa.io/en/stable/" rel="noreferrer">virtualenv</a> from an existing virtualenv in order to inherit the installed libraries?</p>
<p>In detail:</p>
<p>I first create a "reference" virtualenv, and add libraries (with versions fixed):</p>
<pre><code>virtualenv ref
source ref/bin/activate
pip install -U pip==8.1.1     # &lt;- I want to fix the version number
pip install -U wheel==0.29.0  # &lt;- I want to fix the version number
</code></pre>
<p>Then:</p>
<pre><code>virtualenv -p ref/bin/python myapp
source myapp/bin/activate
pip list
</code></pre>
<p>I get:</p>
<pre><code>pip (1.4.1)
setuptools (0.9.8)
wsgiref (0.1.2)
</code></pre>
<p>How to get my installed libraries?</p>
<p><strong>Similar question</strong></p>
<p>I saw a similar question: <a href="https://stackoverflow.com/questions/10538675/can-a-virtualenv-inherit-from-another">Can a virtualenv inherit from another?</a>.</p>
<p>But I want a isolated virtualenv which didn't use the referenced virtualenv, except for libraries installation. So, adding the specified directories to the Python path for the currently-active virtualenv, is not the solution.</p>
<p><strong>Why doing that?</strong></p>
<p>Well, we have an integration server which builds the applications (for releases and continuous integration) and we want to keep the control on libraries versions and make the build faster.</p>
<p><strong>Create a relocatable virtualenv</strong></p>
<p>I think I could use a <a href="https://virtualenv.pypa.io/en/stable/userguide/#making-environments-relocatable" rel="noreferrer">relocatable virtualenv</a>, that way:</p>
<ol>
<li>create the <strong>ref</strong> virtualenv</li>
<li>make it relocatable: ``virtualenv --relocatable ref```</li>
</ol>
<p>For "myapp":</p>
<ul>
<li>copy <strong>ref</strong> to <strong>myapp</strong></li>
</ul>
<p>What do you think of this solution? Is it reliable for a distribuable release?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can solve your problem by <a href="https://docs.python.org/3/library/site.html" rel="noreferrer">using .pth files</a>. Basically you do this:</p>
<pre><code>virtualenv -p ref/bin/python myapp
realpath ref/lib/python3.6/site-packages &gt; myapp/lib/python3.6/site-packages/base_venv.pth
</code></pre>
<p>After doing this and activating <code>myapp</code>, if you run <code>pip list</code> you should see all the packages from <code>ref</code> as well. Note that any packages installed in <code>myapp</code> would hide the respective package from <code>ref</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>when you install the second virtualenv you have to add <code>--system-site-packages</code> flag.</p>
<pre><code>virtualenv -p ref/bin/python myapp --system-site-packages
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may <code>freeze</code> list of packages from one env:</p>
<pre><code>(ref) user@host:~/dir$ pip freeze &gt; ref-packages.txt
</code></pre>
<p>Then install them:</p>
<pre><code>(use) user@host:~/dir$ pip install -r ref-packages.txt
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>pip</code> version <code>1.4.1</code> was bundle with an old version of <code>virtualenv</code>. For example the one shipped with Ubuntu 14.04. You should remove that from your system and install the most recent version of <code>virtualenv</code>.</p>
<pre><code>pip install virtualenv
</code></pre>
<p>This might require root permissions (<code>sudo</code>).</p>
<p>Then upgrade <code>pip</code> inside the virtual env <code>pip install -U pip</code> or recrete the env.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your problem can be solved differently. With use of <code>PYTHONPATH</code>. First we create <code>ref</code> virtaulenv and install all needed packages here</p>
<pre><code>$ virtualenv ref
$ source ref/bin/activate
$ pip install pep8
$ pip list
&gt; pep8 (1.7.0)
&gt; pip (8.1.2)
&gt; setuptools (26.1.1)
&gt; wheel (0.29.0)
</code></pre>
<p>Then we create second virtaulenv <code>use</code>.</p>
<pre><code>$ virtualenv use
$ source use/bin/activate
$ pip list
&gt; pip (8.1.2)
&gt; setuptools (26.1.1)
&gt; wheel (0.29.0)
</code></pre>
<p>And now we can set our <code>PYTHONPATH</code> in this env to include ref's directories</p>
<pre><code>$ export PYTHONPATH=PYTHONPATH:/home/path_to/ref/lib/python2.7/site-packages:/home/path_to/ref/local/lib/python2.7/site-packages
$ pip list
&gt; pep8 (1.7.0)
&gt; pip (8.1.2)
&gt; setuptools (26.1.1)
&gt; wheel (0.29.0)
</code></pre>
<p>As you see this way you just reference installed packages in ref's environment. Also note that we add this folders at the end so they will have lower priority. </p>
<p><strong>NOTE</strong>: this are not all folders that exists in <code>PYTHONPATH</code>. I included this 2 because they are main ones. But if you will have some problems you can add other ones too, just lookup needed paths with this method
<a href="https://stackoverflow.com/questions/18486469/how-to-print-contents-of-pythonpath#18486534">how to print contents of PYTHONPATH</a></p>
</div>
<span class="comment-copy">Create a second virtualenv and then <code>pip install -r &lt;(/path/to/other/pip freeze)</code>?</span>
<span class="comment-copy">You're right, I can install the requirements again. But if we can only copy the libraries, it can go faster.</span>
<span class="comment-copy">What do you think of the "Create a relocatable virtualenv" solution?</span>
<span class="comment-copy">Works with environments created using the built-in <code>venv</code> module, too. Thanks for the tip!</span>
<span class="comment-copy">The <code>--system-site-packages</code> installs the libraries of the system Python, not the ones of the referenced virtualenv.</span>
<span class="comment-copy">but the "system" should be your virtualenv</span>
<span class="comment-copy">I tested and in my case is working</span>
<span class="comment-copy">I’ve done this test too but it fails. I’ll retry that on my build server. I hope <code>virtualenv</code> is not too old…</span>
<span class="comment-copy">Tested doesn't work for me either. pip version 8.1.2</span>
<span class="comment-copy">No, I don’t want to re-install the libraries, just copy existing ones (if possible).</span>
<span class="comment-copy">So, what's the difference between "re-install" and "just copy"? I this case pip won't download them, just unpack the same libraries to an other directory.</span>
<span class="comment-copy">Well, libraries with binaries (like lxml) run some build during installation…</span>
