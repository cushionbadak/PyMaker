<div class="post-text" itemprop="text">
<p>I have a list of integers as follows:</p>
<pre><code>my_list = [2,2,2,2,3,4,2,2,4,4,3]
</code></pre>
<p>What I want is to have this as a list os strings, indexed and 'compressed', that is, with each element indicated by its position in the list and with each successive duplicate element indicated as a range, like this:</p>
<pre><code>my_new_list = ['0-3,2', '4,3', '5,4', '6-7,2', '8-9,4', '10,3']
</code></pre>
<p>EDIT: The expected output should indicate that list elements 0 to 3 have the number 2, element 3, the number 3, element 5, the number 4, elements 6 and 7, the number 2, elements 8 and 9, number 4, and element 10, number 3. </p>
<p>EDIT 2: The output list need not (indeed cannot) be a list of integers, but a list of strings instead.</p>
<p>I could find many examples of finding (and deleting) duplicated elements from lists, but nothing along the lines of what I need.</p>
<p>Could someone point out a relevant example or suggest an algorithm for solving this?</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Like most problems involving cascading consecutive duplicates, you can still use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">groupby()</a> for this. Just group indices by the value at each index.</p>
<pre><code>values = [2,2,2,2,3,4,2,2,4,4,3]
result = []

for key, group in itertools.groupby(range(len(values)), values.__getitem__):
    indices = list(group)

    if len(indices) &gt; 1:
        result.append('{}-{},{}'.format(indices[0], indices[-1], key))
    else:
        result.append('{},{}'.format(indices[0], key))

print(result)
</code></pre>
<p>Output:</p>
<pre><code>['0-3,2', '4,3', '5,4', '6-7,2', '8-9,4', '10,3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a lazy version that works on any sequence, and yields slices. Thus it's generic and memory efficient.</p>
<pre><code>def compress(seq):
    start_index = 0
    previous = None
    n = 0
    for i, x in enumerate(seq):
        if previous and x != previous:
            yield previous, slice(start_index, i)
            start_index = i

        previous = x
        n += 1
    if previous:
        yield previous, slice(start_index, n)
</code></pre>
<p>Usage :</p>
<pre><code>assert list(compress([2, 2, 2, 2, 3, 4, 2, 2, 4, 4, 3])) == [
    (2, slice(0, 4)),
    (3, slice(4, 5)),
    (4, slice(5, 6)),
    (2, slice(6, 8)),
    (4, slice(8, 10)),
    (3, slice(10, 11)),
]
</code></pre>
<p>Why slices? Because it's convenient (can be used as-is for indexing) and the semantics (upper bound not included) are more "standard". Changing that to tuples or string with upper bound is easy btw.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use enumerate with a generator function</p>
<pre><code>def seq(l):
    it = iter(l)
    # get first element and set the start index to 0.
    start, prev = 0, next(it)
    # use enumerate to track the rest of the indexes
    for ind, ele in enumerate(it, 1):
        # if last seen element is not the same the sequence is over
        # if start i == ind - 1 the sequence had just a single element.
        if prev != ele:
            yield ("{}-{}, {}".format(start, ind - 1, prev)) \
                if start != ind - 1 else ("{}, {}".format(start, prev))

            start = ind
        prev = ele
    yield ("{}-{}, {}".format(start-1, ind-1, prev)) \
        if start != ind  else ("{}, {}".format(start, prev))
</code></pre>
<p>Output:</p>
<pre><code>In [3]: my_list = [2, 2, 2, 2, 3, 4, 2, 2, 4, 4, 3]

In [4]: list(seq(my_list))
Out[4]: ['0-3, 2', '4, 3', '5, 4', '6-7, 2', '8-9, 4', '10, 3']
</code></pre>
<p>I was going to use  <em>groupby</em> but will be faster.</p>
<pre><code>In [11]: timeit list(seq(my_list))
100000 loops, best of 3: 4.38 µs per loop

In [12]: timeit itools()

100000 loops, best of 3: 9.23 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Construct the list with number of consecutive occurences with the item. Then iterate the list and get the list with the range of index of each item.</p>
<pre><code>from itertools import groupby

new_list = []

for k, g in groupby([2,2,2,2,3,4,2,2,4,4,3]):
   sum_each = 0
   for i in g:
      sum_each += 1
   ##Construct the list with number of consecutive occurences with the item like this `[(4, 2), (1, 3), (1, 4), (2, 2), (2, 4), (1, 3)]`
   new_list.append((sum_each, k))

x = 0
for (n, item) in enumerate(new_list):
   if item[0] &gt; 1:
      new_list[n] = str(x) + '-' + str(x+item[0]-1) + ',' + str(item[1])
   else:
      new_list[n] = str(x) + ',' + str(item[1])
   x += item[0]

print new_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First off, your requested results are not valid python.  I'm going to assume that the following format would work for you:</p>
<pre><code>my_new_list = [ ((0,3),2), ((4,4),3), ((5,5),4), ((6,7),2), ((8,9),4), ((10,10),3) ]
</code></pre>
<p>Given that, you can first transform <code>my_list</code> into a list of <code>((index,index),value)</code> tuples, then use <code>reduce</code> to gather that into ranges:</p>
<pre><code>my_new_list = reduce(
        lambda new_list,item:
            new_list[:-1] + [((new_list[-1][0][0],item[0][1]),item[1])]
                if len(new_list) &gt; 0 and new_list[-1][1] == item[1]
            else new_list + [item]
        , [((index,index),value) for (index,value) in enumerate(my_list)]
        , []
)
</code></pre>
<p>This does the following:</p>
<ol>
<li><p>transform the list into <code>((index,index),value)</code> tuples:</p>
<pre><code>[((index,index),value) for (index,value) in enumerate(my_list)]
</code></pre></li>
<li><p>use <code>reduce</code> to merge adjacent items with the same value:  If the list being built has at least 1 item and the last item in the list has the same value as the item being processed, reduce it to the list minus the last item, plus a new item consisting of the first index from the last list item plus the second index of the current item and the value of the current item.  If the list being built is empty or the last item in the list is not the same value as the item being processed, just add the current item to the list.</p></li>
</ol>
<p><em>Edited to use <code>new_list</code> instead of <code>list</code> as my lambda parameter; using <code>list</code> as a parameter or variable name is bad form</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a generator-based solution similar to Padraic's.  However it avoids <code>enumerate()</code>-based index tracking and thus is probably faster for huge lists.  I didn't worry about your desired output formatting, either.</p>
<pre><code>def compress_list(ilist):
    """Compresses a list of integers"""
    left, right = 0, 0
    length = len(ilist)
    while right &lt; length:
        if ilist[left] == ilist[right]:
            right += 1
            continue
        yield (ilist[left], (left, right-1))
        left = right
    # at the end of the list, yield the last item
    yield (ilist[left], (left, right-1))
</code></pre>
<p>It would be used like this:</p>
<pre><code>my_list = [2,2,2,2,3,4,2,2,4,4,3]
my_compressed_list = [i for i in compress_list(my_list)]
my_compressed_list
</code></pre>
<p>Resulting in output of:</p>
<pre><code>[(2, (0, 3)),
 (3, (4, 4)),
 (4, (5, 5)),
 (2, (6, 7)),
 (4, (8, 9)),
 (3, (10, 10))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some good answers here, and thought I would offer an alternative. We iterate through the list of numbers and keep an updating <code>current</code> value, associated with a list of indicies for that value <code>current_indicies</code>. We then look-ahead one element to see if the consecutive number <strong>differs</strong> from <code>current</code>, if it does we go ahead and add it as a '<em>compressed number</em>'. </p>
<pre><code>def compress_numbers(l):
    result = []
    current = None
    current_indicies = None
    for i, item in enumerate(l):
        if current != item:
            current = item
            current_indicies = [i]
        elif current == item:
            current_indicies.append(i)
        try:
            if l[i+1] != current:
                result.append(format_entry(current_indicies, current))
        except:
            result.append(format_entry(current_indicies, current))
    return result

# Helper method to format entry in the list.
def format_entry(indicies, value):
    i_range = None
    if len(indicies) &gt; 1:
        i_range = '{}-{}'.format(indicies[0], indicies[-1])
    else:
        i_range = indicies[0]
    return '{},{}'.format(i_range, value)
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>&gt;&gt;&gt; print compress_numbers([2, 2, 2, 2, 3, 4, 2, 2, 4, 4, 3])
['0-3,2', '4,3', '5,4', '6-7,2', '8-9,4', '10,3']
</code></pre>
</div>
<span class="comment-copy">You expected output makes no sense, please elaborate</span>
<span class="comment-copy">Thanks, I have edited the question for elaborating it better.</span>
<span class="comment-copy">Your value for <code>my_new_list</code> is not a python value. Could the ranges be in string format? And I assume that you are doing a RLE (Run Length Encoding)?</span>
<span class="comment-copy">Rory Daulton, the output list can (indeed, should, because of the ranges) be in string format. This is a sort of RLE, sure.</span>
<span class="comment-copy">While your goal is now clear (except for the fact that the type is unclear -- it's usually a bad sign when your desired output gives a SyntaxError), it's not clear what problem you encountered when you went to implement this.</span>
<span class="comment-copy">I accept this solution as it seems more clear to me and also because it has the advantage of being generic, that is, the original list could be like values = ['a','a','a','a','b','c','a','a','c','c','b'] and it would work fine as well. I will have to check how it behaves with large lists.</span>
<span class="comment-copy">@maurobio, what do you mean by generic, how would <code>['a','a','a','a','b','c','a','a','c','c','b']</code> fail with any other answer?</span>
<span class="comment-copy">Sorry, Padraic, mine was a misplaced comment. I was under the impression that at least one of the solutions would work only with a list of integers, but all work with lists of any type.</span>
<span class="comment-copy">@maurobio There are many ways to accomplish this. I believe the least intrusive alteration would be to change the line <code>indices = list(group)</code> to <code>indices = [index + 1 for index in group]</code></span>
<span class="comment-copy">@friendly dog, I had deleted my comment because I found a solution for my own question, although different and less elegant than yours, as follows: if len(indices) &gt; 1:         result.append('{}-{},{}'.format(indices[0]+1, indices[-1]+1, key))     else:         result.append('{},{}'.format(indices[0]+1, key))</span>
<span class="comment-copy">Padraic, this solution results in a duplicate range at the end of the output list: ['0-3, 2', '4, 3', '5, 4', '6-7, 2', '8-9, 4', '10-10, 3']</span>
<span class="comment-copy">I didn't know about reduce.</span>
