<div class="post-text" itemprop="text">
<pre><code>def make_accumulator(init):
    def accumulate(part): 
        init = init + part 
        return init
    return accumulate

A = make_accumulator(1)
print A(2)
</code></pre>
<p>gives me:-</p>
<pre><code>Traceback (most recent call last):
  File "make-accumulator.py", line 8, in &lt;module&gt;
    print A(2)
  File "make-accumulator.py", line 3, in accumulate
    init = init + part 
UnboundLocalError: local variable 'init' referenced before assignment
</code></pre>
<p>Why is init not visible inside accumulate? </p>
</div>
<div class="post-text" itemprop="text">
<p>That's because during parsing the inner function when Python sees the assignment <code>init = init + part</code> it thinks <code>init</code> is a local variable and it will only look for it in local scope when the function is actually invoked.</p>
<p>To fix it add <code>init</code> as an argument to <code>accumulate</code> with default value of <code>init</code>:</p>
<pre><code>def make_accumulator(init):
    def accumulate(part, init=init): 
        init = init + part 
        return init
    return accumulate
</code></pre>
<hr/>
<p>Read: <a href="https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow">Why am I getting an UnboundLocalError when the variable has a value?</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def make_accumulator(init):
...     def accumulate(part): 
...         return init + part
...     return accumulate
... 
&gt;&gt;&gt; make_accumulator(1)
&lt;function accumulate at 0x7fe3ec398938&gt;
&gt;&gt;&gt; A(2)
3
</code></pre>
<p>Since you declare <code>init</code> inside accumulate, Python interprets it as local and therefore referenced before assignment. (Note that I removed the <code>init =</code> part). </p>
<p>I am definitely not an expert about this, but got the hint from these posts : <a href="https://stackoverflow.com/questions/9264763/unboundlocalerror-in-python">Here</a> and <a href="https://stackoverflow.com/questions/4831680/function-inside-function">Here</a>.</p>
<p>I guess someone could explain it better...</p>
</div>
<span class="comment-copy">where did you initialised init... when interpreter wants to do init=init+part, it should know init initialised before..</span>
<span class="comment-copy">use a constructor to set the init value... ` def make_accumulator(self,init): def   __init__(self,init): self.init=init`</span>
<span class="comment-copy">@lokesh1729 They are passing its value to <code>make_accumulator</code>, it's a closure variable. If they only do <code>return init + part</code> it will work fine.</span>
