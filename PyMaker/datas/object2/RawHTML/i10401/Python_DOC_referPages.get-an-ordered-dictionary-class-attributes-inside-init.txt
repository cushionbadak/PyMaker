<div class="post-text" itemprop="text">
<p>I have the following class:</p>
<pre><code>class NewName:
    def __init__(self):
        self.Name = None
        self.DecomposedAlias = OrderedDict([("Prefix", None),
                                            ("Measurement", None),
                                            ("Direction", None),
                                            ("Item", None),
                                            ("Location", None),
                                            ("Descriptor", None),
                                            ("Frame", None),
                                            ("RTorigin", None)])
        self.Meaning = ""
        self.SIUnit = OrderedDict([("ScaleFactor", None),
                                   ("Offset", None),
                                   ("A", None),
                                   ("cd", None),
                                   ("K", None),
                                   ("kg", None),
                                   ("m", None),
                                   ("mol", None),
                                   ("rad", None),
                                   ("s", None)])
        self.NormalDisplayUnit = OrderedDict([("ScaleFactor", None),
                                              ("Offset", None),
                                              ("A", None),
                                              ("cd", None),
                                              ("K", None),
                                              ("kg", None),
                                              ("m", None),
                                              ("mol", None),
                                              ("rad", None),
                                              ("s", None)])
        self.OrientationConvention = ""
        self.ContactPerson = ""
        self.Note = ""
        self.SubType = None
        self.RefersTo = []
</code></pre>
<p>If I instantiate a new object of this class I can obtain a dictionary like this:</p>
<pre><code>mynewname = NewName()
mynewdict = mynewname.__dict__
</code></pre>
<p>What if I want <code>mynewdict</code> to be ordered in the same way the attributes of <code>NewName</code> were instantiated in its <code>__init__</code>?</p>
<p>Doing some research I found <a href="https://stackoverflow.com/questions/4459531/how-to-read-class-attributes-in-the-same-order-as-declared">this</a>, but in my case I would just obtain <code>['__init__']</code>. Is there a way to point to the attributes inside the <code>__init__</code>?</p>
<p>For completeness sake I should mention that I am using Python 3.4.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't do that, because the <code>__init__</code> attribute called after that the instance has been created (by <code>__new__()</code>) so if you even override the <code>__new__()</code> and use a <code>__prepare__</code> method <a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer">using a metaclass</a>, you can just get an ordered sequence (dict or etc.) of other methods and attributes which are not defined within <code>__init__</code> method.</p>
<p>Also based on <a href="https://mail.python.org/pipermail/python-list/2012-January/618121.html" rel="nofollow noreferrer">this mail</a>:</p>
<blockquote>
<p>It's just not possible to have something different than a dict as a type's <code>__dict__</code>. It's a deliberate limitation and required optimization.</p>
</blockquote>
<p>But this doesn't mean that you can't get a list of ordered attributes of your class. Since every attribute sets by <code>__setattr__</code> method you can simply preserve your attributes in an ordered dict by overriding the <code>__setattr__</code> method:</p>
<pre><code>from collections import OrderedDict

class NewName:
    ordered_attrs = OrderedDict()
    def __setattr__(self, name, val):
        object.__setattr__(self, name, val)
        # Use setattr(self, name, val) if you don't want to preserve the attributes in instances `__dict__`
        NewName.ordered_attrs[name] = val

    def __init__(self):
        # your __init__ body

mynewname = NewName()
print(list(NewName.ordered_attrs))
</code></pre>
<p>Output:</p>
<pre><code>['Name', 'DecomposedAlias', 'Meaning', 'SIUnit', 'NormalDisplayUnit', 'OrientationConvention', 'ContactPerson', 'Note', 'SubType', 'RefersTo']

# Output of mynewname.__dict__
{'Note': '', 'Meaning': '', 'RefersTo': [], 'SIUnit': OrderedDict([('ScaleFactor', None), ('Offset', None), ('A', None), ('cd', None), ('K', None), ('kg', None), ('m', None), ('mol', None), ('rad', None), ('s', None)]), 'DecomposedAlias': OrderedDict([('Prefix', None), ('Measurement', None), ('Direction', None), ('Item', None), ('Location', None), ('Descriptor', None), ('Frame', None), ('RTorigin', None)]), 'SubType': None, 'Name': None, 'ContactPerson': '', 'NormalDisplayUnit': OrderedDict([('ScaleFactor', None), ('Offset', None), ('A', None), ('cd', None), ('K', None), ('kg', None), ('m', None), ('mol', None), ('rad', None), ('s', None)]), 'OrientationConvention': ''}
</code></pre>
<p>Also regarding the setting the attributes, based on <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>If <code>__setattr__()</code> wants to assign to an instance attribute, it should call the base class method with the same name, for example, <code>object.__setattr__(self, name, value)</code>.</p>
</blockquote>
</div>
<span class="comment-copy">thanks, now I can retrieve the ordered dictionary. However after your suggested modification of the class, if I ask <code>mynewdict = mynewname.__dict__</code> it returns an empty dictionary. Do you know why is that?</span>
<span class="comment-copy">@Francesco In that case, if you want to have the attributes in instance's <code>__dict__</code>  you should use <code>object.__setattr__(self, name, val)</code>  in order to set the attributes.</span>
<span class="comment-copy">thanks for the edit. However I am not really an expert of python and I am afraid I have not understood what you mean. In my class I added a function like: <code>@staticmethod def ordered_dict():       return ordered_attrs</code> so to retrieve the ordered dictionary with <code>mynewdict = mynewname.ordered_dict()</code>. How should I use <code>object.__setattr__(self, name, val)</code> to get an unordered dictionary, as I obtained with <code>mynewdict = mynewname.__dict__</code>? In other words, after the proposed modification to the class, can I still get in some way an unordered dictionary?</span>
<span class="comment-copy">@Francesco You don't need to use  <code>object.__setattr__(self, name, val)</code> to get an unordered dictionary. After the modification you can get the unordered-dictionary with <code>mynewname.__dict__</code>.</span>
<span class="comment-copy">The problem is that now with <code>mynewdict = mynewname.__dict__</code> I obtain an empty dictionary and I am not understanding why.</span>
