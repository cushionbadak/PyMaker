<div class="post-text" itemprop="text">
<p>I need to test some python 3 code, and I got stuck testing function with few input()'s.</p>
<p>Example:</p>
<pre><code>def two_answers():
    if input("Input 'go' to proceed") != "go":
        return two_answers()
    else:
        while input("Input 'bananas' to proceed") != "bananas":
            print("What?!")
    print("You've just gone bananas!")
</code></pre>
<p>For functions with one input i use:</p>
<pre><code>def test_some_function(self):
    codefile.input = lambda x: 'u'
    codefile.some_function() . . . .
</code></pre>
<p>And then:</p>
<pre><code>def teardown_method(self, method):
    codefile.input = input
</code></pre>
<p>To revert inputs back.</p>
<p>But here it won't work. Help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<pre><code>class SimulatedInput:

    def __init__(self,*args):
        self.args = iter(args) 

    def __call__(self,x):
        try:
            return next(self.args)
        except StopIteration:
            raise Exception("No more input")
</code></pre>
<p>Then you could use it like you did before:</p>
<pre><code>def test_some_function(self):
    codefile.input = SimulatedInput("u","v")
    codefile.some_function() . . . .
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want is to simulate the user inputs.</p>
<p>You have to use a <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><strong>unittest.mock</strong></a> and patch the <code>input</code> function.</p>
<p>See the <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow">Quick Guide</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would wrap the input in to a function.</p>
<pre><code>def input_wrap(prompt):
  return input(prompt)
</code></pre>
<p>Then you can inject it.</p>
<pre><code>def two_answers(input_func):
  if input_func('...') != 'go':
    return two_answers(input_func)
  ...
</code></pre>
<p>Now when you want to test it you can inject a fake or a mock:</p>
<pre><code>def test_two_answers(self):
  fake_input = mock.MagicMock()
  fake_input.side_effect = ['go', 'foo', 'bananas']
  two_answers(fake_input) # no assertion for needed since there's no return value
</code></pre>
<p>Later in the code that executes two_answers you call it like this:</p>
<pre><code>two_answers(input_wrap)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A minimalistic example with no dependencies. Play with it to extend it as you wish:</p>
<pre><code>import sys
import io

def two_answers():
    if input("Input 'go' to proceed") != "go":
        return two_answers()
    else:
        while input("Input 'bananas' to proceed") != "bananas":
            print("What?!")
    print("You've just gone bananas!")

def wrapper():
    lines = ["go", "bananas"]
    def fake_input(*args, **kwargs):
        return lines.pop(0)
    global input
    real_input = input
    input = fake_input
    two_answers()
    input = real_input


wrapper()
</code></pre>
</div>
