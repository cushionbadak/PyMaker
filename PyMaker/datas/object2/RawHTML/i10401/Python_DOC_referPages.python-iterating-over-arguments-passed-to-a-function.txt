<div class="post-text" itemprop="text">
<p>Suppose I have the following example:</p>
<pre><code>class foo:
   ...
   def bar(self, w, x, y, z, ...):
      self.w = w
      self.x = x
      self.y = y
      self.z = z
      ...
</code></pre>
<p>I wish to reduce the n-number of attribute assignment lines in <code>bar()</code> to one assignment line set using a <code>setattr()</code> cycle through the arguments. Is there a good way to cycle through said arguments for this purpose?</p>
<p>I wish to retain the defined parameter names so as to limit the number of parameters passed to the function as well as the order in which they are passed. I also understand that <a href="https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators-in-python/1594484#1594484">functions can be handled like objects</a>; so is it possible to obtain a list of the defined parameters as an attribute of the function and iterate through that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>locals()</code> and you can get all the arguments (and any other local variables):</p>
<pre><code>class foo:
    def bar(self, w, x, y, z):
        argdict = {arg: locals()[arg] for arg in ('w', 'x', 'y', 'z')}
        for key, value in argdict.iteritems():
            setattr(self, key, value)
        ...
</code></pre>
<p>Might be possible to do it more efficiently, and you could inline argdict if you prefer less lines to readability or find it more readable that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>So you don't have to actually name the arguments explicitly use:</p>
<pre><code>class foo:
    def __init__(self, w, x, y, z):
        args = locals()# gets a dictionary of all local parameters
        for argName in args:
            if argName!='self':
                setattr(self, argName, args[argName])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow"><code>__setattr__</code></a> attribute only assigns one attribute at a time, if you want to assign multiple attribute, you can use <code>**kwargs</code> in your function header and for limiting the number of arguments you can simply check the length of <code>kwargs</code> within your function. and call the <code>__setattr__</code> for each each of the arguments one by one. One good reason for this recipe is that basically assigning attribute to an object without considering anything is not a correct and desirable job, due to a lot of reasons. Thus you have to assign each attribute one at a time by considering all the required conditions.</p>
<p>You can also do this manually by updating the instance dictionary but you should handle the exceptions too. </p>
<pre><code>In [80]: class foo:                      
    def bar(self, **kwargs):
        if len(kwargs) != 4:
            raise Exception("Please enter 4 keyword argument")
        for k, v in kwargs.items():
            foo.__setattr__(self, k, v)
   ....:             

In [81]: f = foo()

In [82]: f.bar(w=1, x=2, y=3, z=4)

In [83]: f.w
Out[83]: 1

In [84]: f.bar(w=1, x=2, y=3, z=4, r=5)
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
&lt;ipython-input-84-758f669d08e0&gt; in &lt;module&gt;()
----&gt; 1 f.bar(w=1, x=2, y=3, z=4, r=5)

&lt;ipython-input-80-9e46a6a78787&gt; in bar(self, **kwargs)
      2     def bar(self, **kwargs):
      3         if len(kwargs) != 4:
----&gt; 4             raise Exception("Please enter 4 keyword argument")
      5         for k, v in kwargs.items():
      6             foo.__setattr__(self, k, v)

Exception: Please enter 4 keyword argument
</code></pre>
<p>By using <code>__setatter__</code> it will take care of the exception automatically:</p>
<pre><code>In [70]: f.bar(1, 2)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-70-07d1f3c9e27f&gt; in &lt;module&gt;()
----&gt; 1 f.bar(1, 2)

&lt;ipython-input-65-1049e26120c1&gt; in bar(self, *args)
      2     def bar(self, *args):
      3         for item in args:
----&gt; 4             foo.__setattr__(self, item, item)
      5 

TypeError: attribute name must be string, not 'int'
</code></pre>
</div>
<span class="comment-copy">The information you're looking for would be defined in the <a href="https://docs.python.org/2/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">Python Language Reference - Data Model - Objects, values and types</a> reference (<a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="nofollow noreferrer">version 3 reference</a>).  It does not appear that the parameter list is defined as part of a function object.</span>
<span class="comment-copy">Just found this after I posted the question. <a href="http://stackoverflow.com/questions/582056/getting-list-of-parameter-names-inside-python-function">Getting List of Parameter Names inside Python Function</a> This might answer my question. Feel free to mark this question as a duplicate.</span>
<span class="comment-copy">@JEarls The parameter list is not defined, but at the top of the function or method, <code>locals()</code> will contain only the parameters (including <code>self</code> if it's a method).</span>
<span class="comment-copy">So <code>locals()</code>, in this case would return a dictionary of the arguments passed to function <code>bar()</code> with the values keyed to the names? Is <code>locals()</code> operating only in the scale of function <code>bar()</code>?</span>
<span class="comment-copy">Yes. More specifically, <code>locals()</code> returns all local variables - if you inserted the line <code>q = 73</code> before calling <code>locals()</code>, the dict would include that pair. The dict does include <code>self</code>, That's why I copied it to a new dict instead of using it directly - it allows limiting to only the intended variables, even if you later need to move it down, and also means you don't try to set <code>self.self = self</code> which would be unhelpful at best.</span>
<span class="comment-copy">Alright. So if I called <code>argdict = locals()</code> at the very beginning of function <code>bar()</code> it would only contain the elements passed to bar as arguments? That's what I'm looking for.</span>
<span class="comment-copy">Almost. It would still include <code>self</code> if <code>bar()</code> is a method rather than a function (as in your example), though - <code>self</code> is still an argument, just not one you pass explicitly. You could more efficiently pare it down by <code>argdict = dict(locals()); del argdict['self']</code>. Can't directly do <code>argdict = locals()</code> if you want to remove something from <code>argdict</code> without actually removing it entirely.</span>
<span class="comment-copy">It's not a proper way to hard code the name of arguments in function.</span>
<span class="comment-copy">This doesn't enforce the specific parameter names and quantity as requested.</span>
<span class="comment-copy">@DavidHeyman I don't see such thing in question. Can you elaborate more?</span>
<span class="comment-copy">First line of last paragraph as I write this: "I wish to retain the defined parameter names so as to limit the number of parameters passed to the function as well as the order in which they are passed"</span>
<span class="comment-copy">Doing it with <code>**kwargs</code> keeps names but still doesn't enforce quantity, and loses enforcement of order.</span>
<span class="comment-copy">@Kasramvd "I wish to retain the defined parameter names so as to limit the number of parameters passed to the function as well as the order in which they are passed." So, if I use *args, then function can take any quantity of arguments and assign them as attributes. I want to be able to strictly enforce a certain number of attributes (in this example, 4 attributes) to be assigned to <code>self</code>. And I want them to be labeled by the names provided. I suppose that **kwargs might solve the labeling problem, but not the quantity problem.</span>
