<div class="post-text" itemprop="text">
<p>I'm trying to find way to parse string that can contain variable, function, list, or dict written in python syntax separated with ",". Whitespace should be usable anywhere, so split with "," when its not inside (), [] or {}.</p>
<p>Example string: <code>"variable, function1(1,3), function2([1,3],2), ['list_item_1','list_item_2'],{'dict_key_1': "dict_item_1"}"</code></p>
<p>Another example string: <code>"variable,function1(1, 3) , function2( [1,3],2), ['list_item_1','list_item_2'],{'dict_key_1': "dict_item_1"}"</code></p>
<p>Example output <code>["variable", "function1(1,3)", "function2([1,3],2)", "['list_item_1','list_item_2']", "{'dict_key_1': "dict_item_1"}"]</code></p>
<p>edit:
Reason for the code is to parse string an then run it with <code>exec("var = &amp;s" % list[x])</code>. (yes i know this might not be recommended way to do stuff)</p>
</div>
<div class="post-text" itemprop="text">
<p>Regular expressions aren't very good for parsing the complexity of arbitrary code. What exactly are you trying to accomplish? You can (unsafely) use <code>eval</code> to just evaluate the string as code. Or if you're trying to understand it without <code>eval</code>ing it, you can use <a href="https://docs.python.org/3/library/ast.html" rel="nofollow">the <code>ast</code></a> or <a href="https://docs.python.org/3/library/dis.html" rel="nofollow"><code>dis</code> modules</a> for various forms of inspection.</p>
</div>
<div class="post-text" itemprop="text">
<p>I guess the main problem here is that the arrays and dicts also have commas in them, so just using <code>str.split(",")</code> wouldn't work. One way of doing it is to parse the string one character at a time, and keep track of whether all brackets are closed. If they are, we can append the current result to an array when we come across a comma. Here's my attempt:</p>
<pre><code>s = "variable, function1(1,3),function2([1,3],2),['list_item_1','list_item_2'],{'dict_key_1': 'dict_item_1'}"

tokens = []
current = ""
open_brackets = 0

for char in s:
    current += char

    if char in "({[":
        open_brackets += 1
    elif char in ")}]":
        open_brackets -= 1
    elif (char == ",") and (open_brackets == 0):
        tokens.append(current[:-1].strip())
        current = ""

tokens.append(current)

for t in tokens:
    print(t)

"""
    variable
    function1(1,3)
    function2([1,3],2)
    ['list_item_1','list_item_2']
    {'dict_key_1': 'dict_item_1'}
"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried using split?</p>
<pre><code>&gt;&gt;&gt; teststring = "variable, function1(1,3), function2([1,3],2), ['list_item_1','list_item_2'],{'dict_key_1': 'dict_item_1'}"
&gt;&gt;&gt; teststring.split(", ")
['variable', 'function1(1,3)', 'function2([1,3],2)', "['list_item_1','list_item_2'],{'dict_key_1': 'dict_item_1'}"]
</code></pre>
</div>
<span class="comment-copy">Reason for the code is to parse string into list and then run it with exec(var = list[x]).</span>
<span class="comment-copy">@SacredCoconut: Is there a reason not to bulk parse it all at once?</span>
<span class="comment-copy">Sorry i don't know what you mean by bulk parse.</span>
<span class="comment-copy">@SacredCoconut: As in, why not just do <code>allvals = eval(thestring)</code>, then index the resulting <code>tuple</code> for the results?</span>
<span class="comment-copy">Oh that might work, i have most likely misunderstood how eval works</span>
<span class="comment-copy">I was thinking of the same idea using a <code>list</code> as a stack of brackets, but the <code>open_brackets</code> counter works the same and is simpler.</span>
<span class="comment-copy">Yeah i just thought that regex/python would have had way of doing it instead of writing algorithm my self. I will have to do that then i suppose.</span>
<span class="comment-copy">Oh yeah i forgot to mention it might or might not have whitespace after ",". For example "['variable', function1(1, 3)'"  would not work.</span>
