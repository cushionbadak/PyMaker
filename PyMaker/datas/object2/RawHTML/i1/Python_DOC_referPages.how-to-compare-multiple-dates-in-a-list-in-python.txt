<div class="post-text" itemprop="text">
<p>I am wondering how am I able to compare dates in a list. I would like to extract the "earliest" date. 
(I did a for loop as I had to replace some characters with '-')</p>
<pre><code>comment_list = comment_container.findAll("div", {"class" : "comment-date"})
D =[]

  for commentDate in comment_list:
    year, month, day = map(int, commentDate.split('-'))
    date_object = datetime(year, month, day)
    date_object = datetime.strptime(commentDate, '%Y-%m-%d').strftime('%Y-%m-%d')   
    D.append(date_object)

print(D)
</code></pre>
<p>Output:</p>
<pre><code>['2018-06-26', '2018-04-01', '2018-07-19', '2018-04-23', '2018-08-25', '2018-06-08', '2018-06-14', '2018-07-08', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15']
</code></pre>
<p>I want to extract the earliest date:</p>
<p>Eg.  </p>
<blockquote>
<p>'2018-04-01'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Just use the min function:</p>
<pre><code>A = ['2018-06-26', '2018-04-01', '2018-07-19', '2018-04-23', '2018-08-25', '2018-06-08', '2018-06-14', '2018-07-08', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15']
print(min(A))
</code></pre>
<p>produces </p>
<pre><code>2018-04-01
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>comment_list = comment_container.findAll("div", {"class" : "comment-date"})
D =[]

  for commentDate in comment_list:
    year, month, day = map(int, commentDate.split('-'))
    date_object = datetime(year, month, day)  
    D.append(date_object)

print(min(D))
</code></pre>
<p>You should keep the dates as datetime objects and then use the <code>min()</code> builtin function to determine the earliest date </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from datetime import datetime 

D = ['2018-06-26', '2018-04-01', '2018-07-19', '2018-04-23', '2018-08-25', '2018-06-08',
 '2018-06-14', '2018-07-08', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15', '2019-03-15']
D.sort()
print(D[0])
</code></pre>
<p>or this if you dont want change D</p>
<pre><code>T = D[:]
T.sort()
print(T[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As suggested by Siong you can use <code>min(D)</code>. You can achieve the same like this:</p>
<pre><code>comment_list = comment_container.findAll("div", {"class" : "comment-date"})
D = [datetime.strptime(commentDate, '%Y-%m-%d') for commentDate in comment_list]

print(min(D))
</code></pre>
<p>Working with <code>datetime.datetime</code> objects is usually preferable since the comparisons you make are not based on the formatting of the string. You can always convert to string later on:</p>
<pre><code>min_date_str = min(D).strftime('%Y-%m-%d')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are sure that all dates are correctly padded with zeros (i.e. <code>01</code> for January not <code>1</code> and so on) then simple <code>min</code> or <code>max</code> will be enough. However I want to note that <code>tuple</code>s of <code>int</code>s might be also sorted which might be of use if you encounter mixed padded and not padded dates, consider for example:  </p>
<pre><code>d = ['2018-7-1','2018-08-01']
print(min(d)) #prints 2018-08-01 i.e. later date
print(min(d,key=lambda x:tuple(int(i) for i in x.split('-')))) #prints 2018-7-1
</code></pre>
<p>This solution assumes data are not broken, i.e. all elements produced by <code>.split('-')</code> might be turned into <code>int</code>s.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from dateutil.parser import parse

d = ['2018-7-1','2018-08-01']

date_mapping = dict((parse(x), x) for x in d)
earliest_date = date_mapping[min(date_mapping)]
print(earliest_date)

&gt;&gt;&gt;&gt; '2018-7-1'
</code></pre>
</div>
<span class="comment-copy">I’m typing this on my phone so can’t test it, but should be something like 'D.sort()[0]' to sort and get first element. Or even easier, just use max or min</span>
<span class="comment-copy">Your loop seems totally pointless, by the way. You extract the integer parts from the string, then build a new date, then ignore that and build another new date that you immediately turn back into the same string it was parsed from.</span>
<span class="comment-copy">If the dates are strings in <code>YYYY-MM-DD</code> format, just <code>min(comment_list)</code> should do the trick.</span>
