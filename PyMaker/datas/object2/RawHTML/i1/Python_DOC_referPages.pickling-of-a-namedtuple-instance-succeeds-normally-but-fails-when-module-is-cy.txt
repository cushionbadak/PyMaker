<div class="post-text" itemprop="text">
<p>I have a namedtuple type defined inside a module consisting of two classes, foo and bar, defined in the module's only file, <code>mod.py</code>.  I am able to create instances of both foo and bar without issue and pickle them.  I am now trying to Cythonize it so that I can distribute the module as bytecode.  </p>
<p>The module file structure looks like:</p>
<pre><code>./mod.pyx
./setup.py
./demo.py
</code></pre>
<p>The content of `mod.pyx' is:</p>
<pre><code>import collections

foo = collections.namedtuple('foo', 'A B')

class bar:

    def __init__(self,A,B):
        self.A = A
        self.B = B
</code></pre>
<p>The content of <code>setup.py</code> is:</p>
<pre><code>from distutils.core import setup
from distutils.extension import Extension
from Cython.Build import cythonize

setup( 
      ext_modules= cythonize([Extension('mod', ['mod.pyx'])])
)
</code></pre>
<p>I cythonize it using the command <code>python setup.py build_ext --inplace</code>, which creates the compiled module file:</p>
<pre><code>./mod.cp37-win_amd64.pyd
</code></pre>
<p>Running the following <code>demo.py</code>:</p>
<pre><code>import mod, pickle
ham = mod.foo(1,2)
spam = mod.bar(1,2)

print(pickle.dumps(spam))
print(pickle.dumps(ham))
</code></pre>
<p>Successfully pickles <code>spam</code>, the instance of class <code>bar</code>, but fails on <code>ham</code>, the instance of namedtuple <code>foo</code>, with the error message:</p>
<pre><code>PicklingError: Can't pickle &lt;class 'importlib._bootstrap.foo'&gt;: attribute lookup foo on importlib._bootstrap failed
</code></pre>
<p>This is all done in Python 3.7, if it matters.  It seems like Pickle can no longer find the class definition of <code>mod.foo</code>, even though Python is able to create an instance without issue.  I know namedtuple has some weird behavior with respect to naming of the class it returns, and I admit I am a relative novice at packaging Cython modules.</p>
<p>A bit of googling turned up a few known issues with namedtuples and Cython, so I'm wondering if this might be part of a known issue, or if I am just packaging my module incorrectly.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order for <code>pickle</code> to work, the attribute <code>__module__</code> of the <code>foo</code>-type must be set and should be <code>mod</code>. </p>
<p><code>namedtuple</code> uses <a href="https://github.com/python/cpython/blob/master/Lib/collections/__init__.py#L464-L475" rel="nofollow noreferrer">a trick/heuristic</a> (i.e lookup  in <code>sys._getframe(1).f_globals</code>) to get this information:</p>
<pre><code>def namedtuple(typename, field_names, *, rename=False, defaults=None, module=None):
    ...
    # For pickling to work, the __module__ variable needs to be set to the frame
    # where the named tuple is created.  Bypass this step in environments where
    # sys._getframe is not defined (Jython for example) or sys._getframe is not
    # defined for arguments greater than 0 (IronPython), or where the user has
    # specified a particular module.
    if module is None:
        try:
            module = _sys._getframe(1).f_globals.get('__name__', '__main__')
        except (AttributeError, ValueError):
            pass
    if module is not None:
        result.__module__ = module
    ...
</code></pre>
<p>The problem with the Cython- or C-extensions is that, this heuristic will not work and <code>_sys._getframe(1).f_globals.get('__name__', '__main__')</code> will yield <code>importlib._bootstrap</code> and not <code>mod</code>.</p>
<p>To fix that you need to pass right <code>module</code>-name to <code>namedtuple</code>-factory (as pointed out in the code-comments), i.e.:</p>
<pre><code>foo = collections.namedtuple('foo', 'A B', module='mod')
</code></pre>
<p>or to keep it more generic:</p>
<pre><code>foo = collections.namedtuple('foo', 'A B', module=__name__)
</code></pre>
<p>Now, after importing, <code>foo.__module__</code> is <code>mod</code> as expected by <code>pickle</code> and <code>ham</code> can be pickled.</p>
<hr/>
<p>By the way, pickling of <code>bar</code> functions, because Cython explicitly sets the right <code>__module__</code> attribute (i.e. <code>mod</code>), while constructing the class.</p>
</div>
