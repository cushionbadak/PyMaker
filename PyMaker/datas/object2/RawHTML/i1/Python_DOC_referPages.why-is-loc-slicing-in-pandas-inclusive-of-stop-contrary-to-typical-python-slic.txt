<div class="post-text" itemprop="text">
<p>I am slicing a pandas dataframe and I seem to be getting unexpected slices using <code>.loc</code>, at least as compared to numpy and ordinary python slicing. See the example below.</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; a = pd.DataFrame([[0,1,2],[3,4,5],[4,5,6],[9,10,11],[34,2,1]])
&gt;&gt;&gt; a
    0   1   2
0   0   1   2
1   3   4   5
2   4   5   6
3   9  10  11
4  34   2   1
&gt;&gt;&gt; a.loc[1:3, :]
   0   1   2
1  3   4   5
2  4   5   6
3  9  10  11
&gt;&gt;&gt; a.values[1:3, :]
array([[3, 4, 5],
       [4, 5, 6]])
</code></pre>
<p>Interestingly, this only happens with <code>.loc</code>, not <code>.iloc</code>.</p>
<pre><code>&gt;&gt;&gt; a.iloc[1:3, :]
   0  1  2
1  3  4  5
2  4  5  6
</code></pre>
<p>Thus, <code>.loc</code> appears to be inclusive of the terminating index, but numpy and <code>.iloc</code> are not. </p>
<p>By the comments, it seems this is not a bug and we are well warned. But why is it the case?</p>
</div>
<div class="post-text" itemprop="text">
<p>Remember <code>.loc</code> is <strong>primarily</strong> label based indexing. The decision to include the stop endpoint becomes far more obvious when working with a non-RangeIndex:</p>
<pre><code>df = pd.DataFrame([1,2,3,4], index=list('achz'))
#   0
#a  1
#c  2
#h  3
#z  4
</code></pre>
<p>If I want to select all rows between <code>'a'</code> and <code>'h'</code> (inclusive) I only know about <code>'a'</code> and <code>'h'</code>. In order to be consistent with other python slicing, you'd need to also know what index follows <code>'h'</code>, which in this case is <code>'z'</code>  but could have been anything. </p>
</div>
<div class="post-text" itemprop="text">
<p>Additionally to the point in the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html" rel="nofollow noreferrer">docs</a>, <code>pandas</code> slice indexing using <code>.loc</code> is <strong>not cell index</strong> based. It is in fact <strong>value based indexing</strong> (in the pandas docs it is called "label based", but for numerical data I prefer the term "value based"), whereas with <code>.iloc</code> it is traditional numpy-style cell indexing.</p>
<p>Furthermore, value based indexing is right-inclusive, whereas cell indexing is not. Just try the following:</p>
<pre><code>a = pd.DataFrame([[0,1,2],[3,4,5],[4,5,6],[9,10,11],[34,2,1]])
a.index = [0, 1, 2, 3.1, 4]  # add a float index

# value based slicing: the following will output all value up to the slice value
a.loc[1:3.1]
# Out:
# 0    1   2
# 1.0  3   4   5
# 2.0  4   5   6
# 3.1  9  10  11

# index based slicing: will raise an error, since only integers are allowed
a.iloc[1:3.1]
# Out: TypeError: cannot do slice indexing on &lt;class 'pandas.core.indexes.numeric.Float64Index'&gt; with these indexers [3.2] of &lt;class 'float'&gt;
</code></pre>
<p>To give an explicit answer to your question why it is right-inclusive:<br/>
When using values/labels as indices, it is, at least in my opinion, intuitive, that the last index is included. This is as far as I know a design decision of how the implemented function is meant to work.</p>
</div>
<span class="comment-copy">I assume that value-based indexing was chosen to be right-inclusive because it allows the user to pass a list/iterable of valid indices when making a selection. That's how I often use it.</span>
<span class="comment-copy">@SNygard Yes, I guess so. Imho for value based indexing right-inclusive is the most "familiar" behavior.</span>
<span class="comment-copy">Agreed. Value-based indexing allows users to <code>a.loc[[0,2]]</code> and also perform slicing.</span>
