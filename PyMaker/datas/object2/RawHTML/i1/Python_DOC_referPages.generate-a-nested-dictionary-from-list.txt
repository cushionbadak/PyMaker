<div class="post-text" itemprop="text">
<p>I want to populate a nested dictionary in python3 but I'm at a loss as to how to do this cleanly. I want to have an update function that works in the following way:</p>
<pre><code>#pseudo code for the update given One and Two:
One = ('W/X/Y/Z.py', 1, 8)
Two = ('A/B/C/D.py', 12, 42)

#blank initialization
Dict = dict()

#structure gets created based on the path in Two
def updateDict(One, Two):
    tuple = (1, 8, 12, 42)
    try:
        Dict["A"]["B"]["C"]["D.py"]['W/X/Y/Z.py'].append(tuple)
    except:
        Dict["A"]["B"]["C"]["D.py"]['W/X/Y/Z.py'] = [tuple]
#where:
#Dict["A"] is now a dict, 
#Dict["A"]["B"] is now a dict, 
#Dict["A"]["B"]["C"] is now a dict and 
#Dict["A"]["B"]["C"]["D.py"] is now a dict
#Dict["A"]["B"]["C"]["D.py"]["W/X/Y/Z.py"] is now a list of tuples with four values

</code></pre>
<pre><code>Iteratively given
One = ('W/X/Y/Z.py', 1, 8)
Two = ('A/B/C/D.py', 12, 42)

One = ('W/X/Y/Z.py', 50, 60)
Two = ('A/B/C/D.py', 90, 100)

One = ('W/X/Y/NOTZ.py', 3, 14)
Two = ('A/B/C/D.py', 15, 22)

One = ('W/X/Y/Z.py', 14, 62)
Two = ('A/B/C/NOTD.py', 13, 56)
</code></pre>
<pre><code>#Would produce the following structure:
Dict = 
{"A":   {
        "B":    {
                "C":    {
                        "D.py": {
                                "W/X/Y/Z.py" : [(1,8,12,42), (50,60,90,100)],
                                "W/X/Y/NOTZ.py" : [(3,14,15,22)]
                        },
                        "NOTD.py": {
                                "W/X/Y/Z.py" : [(14,62,13,56)]
                        }
                }
        }
}}
</code></pre>
<pre><code>This can be made using the following commands:
Dict = dict()
Dict["A"] = dict()
Dict["A"]["B"] = dict()
Dict["A"]["B"]["C"] = dict()
Dict["A"]["B"]["C"]["D.py"] = dict()
Dict["A"]["B"]["C"]["D.py"]["W/X/Y/Z.py"] = [(1,8,12,42), (50,60,90,100)]
Dict["A"]["B"]["C"]["D.py"]["W/X/Y/NOTZ.py"] = [(3,14,15,22)]
Dict["A"]["B"]["C"]["NOTD.py"] = dict()
Dict["A"]["B"]["C"]["NOTD.py"]["W/X/Y/Z.py"] = [(14,62,13,56)]
</code></pre>
<p>so Dict["A"]["B"]["C"] would return a dictionary:</p>
<pre><code>dict(
    "D.py": {
        "W/X/Y/Z.py" : [(1,8,12,42), (50,60,90,100)],
        "W/X/Y/NOTZ.py" : [(3,14,15,22)]
     },
    "NOTD.py": {
        "W/X/Y/Z.py" : [(14,62,13,56)]
    }
)

</code></pre>
<p>and Dict["A"]["B"]["C"]["D.py"] would return a dictionary:</p>
<pre><code>dict(
    "W/X/Y/Z.py" : [(1,8,12,42), (50,60,90,100)],
    "W/X/Y/NOTZ.py" : [(3,14,15,22)]
)
</code></pre>
<p>and Dict["A"]["B"]["C"]["D.py"]["W/X/Y/Z.py"] would return a list of tuples:</p>
<pre><code>[(1,8,12,42), (50,60,90,100)]
</code></pre>
<p>So all the nested values are dictionaries but all of the leaves are lists of tuples.</p>
<p>The paths in the strings in One and Two can both be arbitrary length and values before ending in a filename (so you could get W/X/Y/Z.py or W/X/AA.py or Q/R/S/T/U/V.py).</p>
<p>Any packages that might aid in this would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's one version of <code>updateDict()</code> that does what you want (note: Py3). It uses a pointer <code>d</code> into the arbitrary depth dictionary and then just appends the tuple to that pointer:</p>
<pre><code>Dict = dict()

def updateDict(One, Two):
    k, *v1 = One
    path, *v2 = Two
    d = Dict
    for p in path.split('/'):
        d = d.setdefault(p, {})
    d.setdefault(k, []).append(tuple(v1+v2))

In []:
One = ('W/X/Y/Z.py', 1, 8)
Two = ('A/B/C/D.py', 12, 42)
updateDict(One, Two)
Dict

Out[]:
{'A': {'B': {'C': {'D.py': {'W/X/Y/Z.py': [(1, 8, 12, 42)]}}}}}

In []:
One = ('W/X/Y/Z.py', 50, 60)
Two = ('A/B/C/D.py', 90, 100)
updateDict(One, Two)
Dict

Out[]:
{'A': {'B': {'C': {'D.py': {'W/X/Y/Z.py': [(1, 8, 12, 42), (50, 60, 90, 100)]}}}}}
</code></pre>
<p>Etc...</p>
</div>
<div class="post-text" itemprop="text">
<p>It's hard to understand what your are doing. But let me try to describe what do you need to do.</p>
<pre><code>Dict = {}
Dict.setdefault('A', {})
Dict['A'].setdefault('B', {})
Dict['A']['B'].setdefault('C', {})
Dict['A']['B']['C'].setdefault('D.py', {})
Dict['A']['B']['C']['D.py'].setdefault('W/X/Y/Z.py', set())
Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'].add(???)
</code></pre>
<p>Another point you need to know, set can't add a list. You can only add a number, or a tuple —— which is immutable. So the last step you should do below:</p>
<pre><code>Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'] = Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'].union([1, 8, 12, 42]).union([50, 60, 90, 100])
# {1, 8, 12, 42, 50, 60, 90, 100}
# or
Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'].add((1, 8, 12, 42))
Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'].add((50, 60, 90, 100))
# {(1, 8, 12, 42), (50, 60, 90, 100)}
</code></pre>
<hr/>
<p>OK, I see you have edited the last step. So it's easier now.</p>
<pre><code>Dict = {}
Dict.setdefault('A', {})
Dict['A'].setdefault('B', {})
Dict['A']['B'].setdefault('C', {})
Dict['A']['B']['C'].setdefault('D.py', {})
Dict['A']['B']['C']['D.py'].setdefault('W/X/Y/Z.py', [])
Dict['A']['B']['C']['D.py']['W/X/Y/Z.py'].append(tuple)
</code></pre>
</div>
<span class="comment-copy">I cant tell what you are asking ... but im guessing you want <code>dict.setdefault</code></span>
<span class="comment-copy">I guess my question is how can I generate these arbitrary depth dictionary accessors based on a list input.  How could I turn [A, B, C, D] into Dict[A][B][C][D] without hardcoding?</span>
<span class="comment-copy">@MichaelHackman I think you need <code>'A/B/C/D.py'.split('/')</code> then do a for loop or a recursion.</span>
