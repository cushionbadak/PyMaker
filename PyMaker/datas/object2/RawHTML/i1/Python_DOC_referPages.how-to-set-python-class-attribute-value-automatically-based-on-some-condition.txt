<div class="post-text" itemprop="text">
<p>I have a class which has multiple attributes that are related, for example:</p>
<pre><code>class SomeClassï¼š
    def __init__(self, n=0):
        self.list = range(n)
        self.listsquare = [ x**2 for x in self.list ]
</code></pre>
<p>If I make an object normally that would no problem, with</p>
<pre><code>a = SomeClass(10)
</code></pre>
<p>I will get 2 lists, <code>a.list</code> and <code>a.listsquare</code>.</p>
<p>Now if I want to make a empty object first, and assign one attribute to it, I want the other attributes to be automatically updated, for example if I do</p>
<pre><code>b = SomeClass()
b.list = range(5,10)
</code></pre>
<p>I want <code>b.listsquare</code> to be automatically updated, and also the other way around (assign <code>b.listsquare</code> and auto update <code>b.list</code>). Is this possible? Is <em>Class</em> the right choice for this?</p>
<hr/>
<p>Thanks to you all, but I'm completely overwhelmed by all the different answers. Can anyone give a complete solution so I can learn write my own?</p>
<p>I would like to achieve a class <code>Foo</code> with 3 attributes <code>length</code>, <code>list</code> and <code>listsquare</code> such that:</p>
<ol>
<li>If I do <code>a = Foo(3)</code>, I get <code>a.length = 3</code>, <code>a.list = [0, 1, 2]</code>, <code>a.listsquare = [0, 1, 4]</code>.</li>
<li>If I do <code>b = Foo().list = [5, 6]</code>, I get <code>b.length = 2</code>, <code>b.listsquare = [25, 36]</code>.</li>
<li>If I do <code>c = Foo().listsquare = [4, 9]</code>, I get <code>c.length = 2</code>, <code>c.list = [2, 3]</code>.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>if updating one property due to an update on another property is what you're looking for (instead of recomputing the value of the downstream property on access) use property setters:</p>
<pre><code>class SomeClass(object):
    def __init__(self, n):
        self.list = range(0, n)

    @property
    def list(self):
        return self._list
    @list.setter
    def list(self, val):
        self._list = val
        self._listsquare = [x**2 for x in self._list ]

    @property
    def listsquare(self):
        return self._listsquare
    @listsquare.setter
    def listsquare(self, val):
        self.list = [int(pow(x, 0.5)) for x in val]

&gt;&gt;&gt; c = SomeClass(5)
&gt;&gt;&gt; c.listsquare
[0, 1, 4, 9, 16]
&gt;&gt;&gt; c.list
[0, 1, 2, 3, 4]
&gt;&gt;&gt; c.list = range(0,6)
&gt;&gt;&gt; c.list
[0, 1, 2, 3, 4, 5]
&gt;&gt;&gt; c.listsquare
[0, 1, 4, 9, 16, 25]
&gt;&gt;&gt; c.listsquare = [x**2 for x in range(0,10)]
&gt;&gt;&gt; c.list
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Absolutely. But use a <a href="http://archive.org/details/SeanKellyRecoveryfromAddiction" rel="noreferrer"><strong>property</strong></a> instead.</p>
<pre><code>class SomeClass(object):
  def __init__(self, n=5):
    self.mylist = range(n)

  @property
  def listsquare(self):
    return [ x**2 for x in self.mylist ]

a = SomeClass()
a.mylist = [4, 5, 8]
print a.listsquare
</code></pre>
<p>Caching of the property value is left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also just use setter methods, like this:</p>
<pre><code>class SomeClass:
    def __init__(self, n=5):
        self.set_list(range(n))

    def set_list(self, n):
        self.list = n
        self.listsquare = [ x**2 for x in self.list ]

b = SomeClass()
b.set_list(range(5,10))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ignacio's @property solution is great but it recalculates the list every time you reference listsquare - that could get expensive. Mathew's solution is great, but now you have function calls. You can combine these with the 'property' function. Here I define a getter and a setter for my_list (I just couldn't call it 'list'!) that generates listsquare:</p>
<pre><code>class SomeClass(object):

    def __init__(self, n=5):
        self.my_list = range(n)

    def get_my_list(self):
        return self._my_list

    def set_my_list(self, val):
        self._my_list = val
        # generate listsquare when my_list is updated
        self.my_listsquare = [x**2 for x in self._my_list]

    # now my_list can be used as a variable
    my_list = property(get_my_list, set_my_list, None, 'this list is squared')

x = SomeClass(3)
print x.my_list, x.my_listsquare
x.my_list = range(10)
print x.my_list, x.my_listsquare
</code></pre>
<p>This outputs:</p>
<pre><code>[0, 1, 2] [0, 1, 4]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
</div>
<span class="comment-copy">The code you have given us doesn't work. classes are defined by 'class' not 'def' and are initialized via the 'def __init__(self, ...)' method. You have defined a function with 1 required param called 'self' and 1 optional param called 'n'. When you call SomeClass(10), the function tries to assign 'list' to the 10 object and fails. - oh, looks like the question is being reformatted... so never mind.</span>
<span class="comment-copy">Sorry, I made the corrections. I'm not very familiar with it right now.</span>
<span class="comment-copy">Does this mean I need to define 3 properties (<code>size</code>, <code>list</code>, <code>listsquare</code>) so when I update one of them the other 2 will update?</span>
<span class="comment-copy">that is correct. i've updated the above answer to work the way you wanted - the size attribute feel necessary anymore.</span>
<span class="comment-copy">Great! What about the other way around? Can I define <code>a.listsquare</code> and get <code>a.mylist</code>?</span>
<span class="comment-copy">Yes. Just add a setter to your property.</span>
<span class="comment-copy">thanks to the folks pointing out i had initialized the list incorrectly.</span>
