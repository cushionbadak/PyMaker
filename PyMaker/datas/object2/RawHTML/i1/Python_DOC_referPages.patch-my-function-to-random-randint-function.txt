<div class="post-text" itemprop="text">
<p>I have a function to generate <code>sms_token</code>. It must not duplicate with the existing one in the database. However, the space of token might not so big enough then the collision of the newer one might happen.</p>
<p><code>Python 3.7.0</code></p>
<pre class="lang-py prettyprint-override"><code>from random import randint

from multy_herr.user_profiles.models import UserProfile


def rand_six():
    """
    Must find the `sms_token` which no `UserProfile`
    :return:
    """
    tmp = ""
    for i in range(6):
        tmp += str(randint(0, 9))
    if 0 == UserProfile.objects.filter(sms_token=tmp).count():
        return tmp
    else:
        return rand_six()
</code></pre>
<p>Therefore I wants to make <code>side_effect</code> of <code>randint</code> to return me the deterministic values by this order <code>123456, 123456, 111222</code></p>
<p>With given values. I will be able to test <code>else</code> logic in my <code>rand_six</code></p>
<p>I had tried this <a href="https://stackoverflow.com/questions/10277397/python-mock-patch-a-function-within-another-function">answer</a>, but does not work. <code>rand_six()</code> still return me the original function not the fake one I made.</p>
<pre class="lang-py prettyprint-override"><code>from unittest.mock import patch
from multy_herr.users.utils import rand_six

    @patch('random.randint')
    def test_rand_six(self, some_func):
        """
        Suppose it generates the duplicated `sms_token`
        :return:
        """
        some_func.return_value = '123456'
        assert '123456' == rand_six()
</code></pre>
<p><strong>Problem:</strong></p>
<p>It does not patch the behavior of <code>random.randint</code></p>
<p><strong>Question:</strong><br/>
How can I put my fake generated list to my <code>randint</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to <code>Klaus D.</code> for his comment. I have to stick with <code>module</code>. </p>
<ol>
<li>Use <code>import random</code> and <code>random.randint(0, 9)</code></li>
</ol>
<pre class="lang-py prettyprint-override"><code>import random

from multy_herr.user_profiles.models import UserProfile


def rand_six():
    """
    Must find the `sms_token` which no `UserProfile`
    :return:
    """
    tmp = ""
    for i in range(6):
        tmp += str(random.randint(0, 9))
    if 0 == UserProfile.objects.filter(sms_token=tmp).count():
        return tmp
    else:
        return rand_six()
</code></pre>
<ol start="2">
<li>Use <code>global</code> in order to get my defined value with given condition. And a bit cheat with my own question. Since I want 2 answers the same, but not last one.</li>
</ol>
<pre class="lang-py prettyprint-override"><code>    def _rand111(self, a, b):
        global idx
        if idx in range(12):
            idx += 1
            return 1
        else:
            return 2

    def test_mock_randint(self):
        """
        Test mock the behaviour of `random.randint`
        :return:
        """

        with mock.patch('random.randint', self._rand111):
            assert '111111' == rand_six()
            assert '111111' == rand_six()
            assert '222222' == rand_six()
</code></pre>
</div>
<span class="comment-copy">You have to patch <code>randint</code> in the module where it is imported: e.g. <code>@patch('your_module.randint')</code></span>
<span class="comment-copy">Please wait a moment. I also trying another easier approach to test this case.</span>
