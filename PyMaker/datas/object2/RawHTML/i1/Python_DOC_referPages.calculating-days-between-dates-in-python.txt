<div class="post-text" itemprop="text">
<p>Got set some course homework to do this. It was going all good until I noticed one of the test cases werent working, trying to get the days between <code>2012-1-1</code> and <code>2013-1-1</code>.</p>
<p>I guessed it would be 366, extra day as <code>2012</code> was a leap year. This code seems to be guessing 365, my tutor has marked the answer down as 360.</p>
<p>He said something about "just make all months 30 days", so I'm thinking his <code>360</code> is something related to that? Anyway, that doesn't excuse my code guessing <code>365</code> when it should be guessing <code>366</code>.</p>
<p>Output is as shows</p>
<blockquote>
<p>Test case passed! CONGRATULATIONS<br/>
  Test with data: (2012, 1, 1, 2013, 1, 1) failed passed 365 should of passed 360<br/>
  Test case passed! CONGRATULATIONS</p>
</blockquote>
<pre><code>daysOfMonths = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ] 

def is_leap_year(year):
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

def get_days_from_year(year):
    days = year * 365
    i = 0

    while i &lt; year:
        i += 1
        if is_leap_year(i):
            days += 1

    return days

def get_days_from_month(month, year):
    days = 0
    i = 0

    while i &lt; month:
        if i == 1 and is_leap_year(year):
            days += daysOfMonths[i] + 1
        else:
            days += daysOfMonths[i]
        i += 1

    return days

def get_days_from_date(year, month, day): 
    days_in_year = get_days_from_year(year)
    days_in_month = get_days_from_month(month - 1, year)
    days = days_in_year + days_in_month + day
    return days

def daysBetweenDates(year1, month1, day1, year2, month2, day2):
    first_date_days = get_days_from_date(year1, month1, day1)
    second_date_days = get_days_from_date(year2, month2, day2)


    if first_date_days &gt; second_date_days:
        return first_date_days - second_date_days
    else:
        return second_date_days - first_date_days

def test():
    test_cases = [((2012,9,30,2012,10,30),30), 
                  ((2012,1,1,2013,1,1),360),
                  ((2012,9,1,2012,9,4),3)]
    for (args, answer) in test_cases:
        result = daysBetweenDates(*args)
        if result != answer:
            print("Test with data:", args, "failed passed", result, "should of passed", answer)
        else:
            print("Test case passed! CONGRATULATIONS")

test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are incrementing <strong>i</strong> in the wrong place.  You have:</p>
<pre><code>while i &lt; year:
    i += 1
    if is_leap_year(i):
        days += 1
</code></pre>
<p>but should be:</p>
<pre><code>while i &lt; year:
    if is_leap_year(i):
        days += 1
    i += 1
</code></pre>
<p>because of this, your leap years are all off by 1 (2011 vs 2012, 2015 vs 2016, etc.)</p>
</div>
<div class="post-text" itemprop="text">
<p>He said something about <strong>"just make all months 30 days"</strong>, so</p>
<pre><code>def get_range(year1,month1,day1,year2,month2,day2):
    """
    assumes all months have 30 days, with no leap years
    ~ for some weird reason i dont understand
   (probably so you dont use builtin datetime)

    """
    days_difference = (year2-year1)*360
    days_difference += (month2-month1)*30
    return days_difference + day2-day1


print(get_range(2012, 1, 1, 2013, 1, 1))
</code></pre>
<p>if you want to get the actual number of days between two dates</p>
<pre><code>from datetime import datetime
def get_real_range(year1,month1,day1,year2,month2,day2):
    return (datetime(year2,month2,day2) - datetime(year1,month1,day1)).days
</code></pre>
</div>
<span class="comment-copy">Write a test for every function you call and find the one that is returning something different than what you'd expect. Alternatively, use a debugger to step through your calculation.</span>
<span class="comment-copy">This is not related to the problem but it should have been "should have", not "should of".</span>
<span class="comment-copy">so all months have 30 days except february in a leap year?</span>
<span class="comment-copy">No.  It's just that February has an extra day in a leap year...29 vs 28. - The expectation of 360 seems wrong to me, as it does to the OP.  Making the change I mention gives the OP the result he expects...366.</span>
<span class="comment-copy">if you want the real value just use <code>(datetime.datetime(Y,M,D) - datetime.datetime(Y1,M1,D1)).days</code></span>
<span class="comment-copy">@Joran, I think he has to do this without any special date functions.  It's a homework assignment that has that provision, I'm guessing.</span>
