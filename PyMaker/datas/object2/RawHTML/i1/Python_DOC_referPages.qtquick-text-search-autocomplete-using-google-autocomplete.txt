<div class="post-text" itemprop="text">
<p>I want to create a similar looking UI using <code>QML</code> as in the link below, that was my question on using <code>Qcompleter</code> in <code>pyqt5</code> , <a href="https://stackoverflow.com/q/55027186/11024267">pyqt5 autocomplete QLineEdit - Google places autocomplete</a> . How can we implement the same model  in <code>Qt Quick</code>, i cant seem to use the models in <code>TextField</code> of QML as i get the below error 
<a href="https://i.stack.imgur.com/AnW3J.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/AnW3J.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Using the previous model it is only necessary to create the GUI, in this case use a ListView + Popup implementing the logic of selection:</p>
<p><strong>main.py</strong></p>
<pre><code>import os
import sys
import json
from PyQt5 import QtCore, QtGui, QtNetwork, QtQml

API_KEY = "&lt;API_KEY&gt;"

class SuggestionPlaceModel(QtGui.QStandardItemModel):
    finished = QtCore.pyqtSignal()
    error = QtCore.pyqtSignal(str)
    countChanged = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        super(SuggestionPlaceModel, self).__init__(parent)
        self._manager = QtNetwork.QNetworkAccessManager(self)
        self._reply = None

    def count(self):
        return self.rowCount()

    count = QtCore.pyqtProperty(int, fget=count, notify=countChanged)

    @QtCore.pyqtSlot(str)
    def search(self, text):
        self.clear()
        self.countChanged.emit()
        if self._reply is not None:
            self._reply.abort()
        if text:
            r = self.create_request(text)
            self._reply = self._manager.get(r)
            self._reply.finished.connect(self.on_finished)
        loop = QtCore.QEventLoop()
        self.finished.connect(loop.quit)
        loop.exec_()

    def create_request(self, text):
        url = QtCore.QUrl("https://maps.googleapis.com/maps/api/place/autocomplete/json")
        query = QtCore.QUrlQuery()
        query.addQueryItem("key", API_KEY)
        query.addQueryItem("input", text)
        query.addQueryItem("types", "geocode")
        query.addQueryItem("language", "en")
        url.setQuery(query)
        request = QtNetwork.QNetworkRequest(url)
        return request

    @QtCore.pyqtSlot()
    def on_finished(self):
        reply = self.sender()
        if reply.error() == QtNetwork.QNetworkReply.NoError:
            data = json.loads(reply.readAll().data())
            if data['status'] == 'OK':
                for prediction in data['predictions']:
                    self.appendRow(QtGui.QStandardItem(prediction['description']))
            self.error.emit(data['status'])
        self.countChanged.emit()
        self.finished.emit()
        reply.deleteLater()
        self._reply = None

if __name__ == '__main__':
    app = QtGui.QGuiApplication(sys.argv)
    QtQml.qmlRegisterType(SuggestionPlaceModel, "PlaceModel", 1, 0, "SuggestionPlaceModel")
    engine = QtQml.QQmlApplicationEngine()
    qml_filename = os.path.join(os.path.dirname(__file__), 'main.qml')
    engine.load(QtCore.QUrl.fromLocalFile(qml_filename))
    if not engine.rootObjects():
        sys.exit(-1)
    sys.exit(app.exec_())
</code></pre>
<p><strong>main.qml</strong></p>
<pre><code>import QtQuick 2.9
import QtQuick.Window 2.2
import QtQuick.Controls 2.2

import PlaceModel 1.0

ApplicationWindow {
    width: 400
    height: 400
    visible: true

    QtObject {
        id: internal
        property bool finished: false
        property bool busy: false
    }

    SuggestionPlaceModel{
        id: suggestion_model
        onFinished: {
            internal.busy = false
            if(count == 0) internal.finished = true
        }
    }

    TextField {
        anchors.centerIn: parent
        id: textfield
        onTextChanged: {
            internal.busy = true
            internal.finished = false
            Qt.callLater(suggestion_model.search, text)
        }
        Popup {
            id: popup
            y: parent.height
            visible: !internal.finished &amp;&amp; textfield.length &gt; 0
            closePolicy: Popup.CloseOnEscape | Popup.CloseOnPressOutsideParent
            contentItem: Loader{
                    sourceComponent: internal.busy ? busy_component: lv_component
                }
        }
    }

    Component{
        id: busy_component
        BusyIndicator {
            running: true
        }
    }

    Component{
        id: lv_component
        ListView {
            implicitWidth: contentItem.childrenRect.width
            implicitHeight: contentHeight
            model: suggestion_model
            delegate: Text {
                text: model.display
                MouseArea{
                    id: mousearea
                    anchors.fill: parent
                    hoverEnabled: true
                    onClicked: {
                        textfield.text = model.display
                        internal.finished = true
                    }
                }
            }
        }
    }
}
</code></pre>
<p><a href="https://i.stack.imgur.com/kQce6.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/kQce6.png"/></a></p>
</div>
<span class="comment-copy">Are you using PyQt5 with QML or Qt C++ with QML?</span>
<span class="comment-copy">I implemented that solution using c++ backend that will check for matching fields and return a list. You can then plug that list into a <code>listview</code> located below the <code>TextField</code> (does not have a model). Model would go into the <code>listview</code> as suggestions/autocomplete.</span>
<span class="comment-copy">@eyllanesc i am using pyqt5 with QML</span>
<span class="comment-copy">I am getting PlaceModel not found error..am i missing something?</span>
<span class="comment-copy">Yes i am using both pasted in same directory</span>
<span class="comment-copy">And i am running these in qtcreator qtquick application</span>
<span class="comment-copy">@Techiesoft You should not run it with Qt Creator, you must run it with python: <code>python /path/of/main.py</code></span>
<span class="comment-copy">@Techiesoft There are 2 options, so it depends on the developer's taste. bye</span>
