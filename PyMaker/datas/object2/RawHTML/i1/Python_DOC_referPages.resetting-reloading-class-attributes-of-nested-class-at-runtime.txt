<div class="post-text" itemprop="text">
<p>I am using a nested class for "book keeping" purposes in Python 3. The class structure (highly simplified) looks something like this:</p>
<pre><code>class BookKeeping:

    class ItemA:
        count = 0
        item_list = []

        @classmethod
        def add(cls, item_a):
            cls.count += 1
            cls.item_list.append(item_a)

    class ItemB:
        count = 0
        item_dict = {}

        ...
</code></pre>
<p>This class makes it convenient to keep track and to access some "global" properties of a system I am modelling. Having nested classes allows for clear namespacing. For instance, in any module I can <code>... import BookKeeping as BK</code> and check how many <code>ItemB</code> objects there are (<code>BK.ItemB.count</code>).</p>
<p>At some point in my program I would like to "reset" all class attributes, i.e. I would like to set <code>BookKeeping.ItemA.count</code> to 0 again and empty lists and dictionaries, etc.</p>
<p>Obviously, I could add a top-level class method like <code>BookKeeping.reset()</code> which resets all values "manually", like:</p>
<pre><code>class BookKeeping:

    @classmethod
    def reset(cls):
        cls.ItemA.count = 0
        cls.ItemA.item_list = []
        cls.ItemB.count = 0

        ...
</code></pre>
<p>However, this seems to be an error-prone approach to me and it involves "maintenance" of this class (I might forget to reset some attributes). Please note, my real class is more complicated than the example I have provided.</p>
<p>What is the easiest way to reset all class attributes to their original state at runtime?</p>
</div>
<div class="post-text" itemprop="text">
<p>So upfront: Should you actually be doing this? Probably not.</p>
<p>I'd advise you to try to rethink your projects structure, actually, since global state is something which should usually be avoided.</p>
<p>If you still want to do it that way though...</p>
<p>Beware, some untested (!) arcane magic ahead:</p>
<pre><code>import copy

class BookKeeping(object):
    __backup = {}

    class ItemA(object):
        ...

    class ItemB(object):
        ...

    @classmethod
    def reset(cls):
        for name, backup in cls.__backup.items():
            inner_cls = getattr(cls, name)
            for k, v in backup.items():
                setattr(inner_cls, k, copy.deepcopy(v))

for i in dir(BookKeeping):
    if not i.startswith("_"):
        obj = getattr(BookKeeping, i)
        BookKeeping.__backup[i] = {k: copy.deepcopy(getattr(obj, k)) for k in dir(obj)}
</code></pre>
<p>Additional notes: This is generally a tricky problem. But you could use the same technique for other nesting structures too, and handle types differently instead of handling the first level differently.</p>
<p>This is a problem because you don't want to <code>deepcopy</code> the types themselves, since that would duplicate the state across all live objects at that time and all new objects together with the current new global state.</p>
</div>
<span class="comment-copy">Can you just have a separate class (e.g. <code>BookKeepingSession</code> or something) that holds those values as <i>instance</i> properties rather than <i>class</i> properties? Then you could just create a fresh <code>BookKeepingSession</code> each time you want to do some unrelated <code>BookKeeping</code>.</span>
<span class="comment-copy">Yes, I have realized that what I initially thought was a clean and convenient solution turns out to have a few flaws. I have refactored my code so that I don't have to deal with any global state anymore. I guess, the fact that Python makes it "ugly looking" and inconvenient should also be a strong indication that something is not very good. Thanks.</span>
