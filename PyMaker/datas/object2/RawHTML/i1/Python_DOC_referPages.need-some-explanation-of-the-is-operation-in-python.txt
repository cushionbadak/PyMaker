<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1504717/why-does-comparing-strings-using-either-or-is-sometimes-produce-a-differe">Why does comparing strings using either '==' or 'is' sometimes produce a different result?</a>
<span class="question-originals-answer-count">
                    14 answers
                </span>
</li>
</ul>
</div>
<p>I noticed a Python script I was writing was acting squirrelly, and traced it to an infinite loop, where the loop condition was <code>while line is not ''</code>. Running through it in the debugger, it turned out that line was in fact <code>''</code>. When I changed it to <code>!=''</code> rather than <code>is not ''</code>, it worked fine. </p>
<p>Also, is it generally considered better to just use '==' by default, even when comparing int or Boolean values? I've always liked to use 'is' because I find it more aesthetically pleasing and pythonic (which is how I fell into this trap...), but I wonder if it's intended to just be reserved for when you care about finding two objects with the same id.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For all built-in Python objects (like
  strings, lists, dicts, functions,
  etc.), if x is y, then x==y is also
  True.</p>
</blockquote>
<p>Not always.  NaN is a counterexample.  But <em>usually</em>, identity (<code>is</code>) implies equality (<code>==</code>).  The converse is not true: Two distinct objects can have the same value.</p>
<blockquote>
<p>Also, is it generally considered better to just use '==' by default, even
  when comparing int or Boolean values?</p>
</blockquote>
<p>You use <code>==</code> when comparing values and <code>is</code> when comparing identities.</p>
<p>When comparing ints (or immutable types in general), you pretty much always want the former.  There's an optimization that allows small integers to be compared with <code>is</code>, but don't rely on it.</p>
<p>For boolean values, you shouldn't be doing comparisons at all.   Instead of:</p>
<pre><code>if x == True:
    # do something
</code></pre>
<p>write:</p>
<pre><code>if x:
    # do something
</code></pre>
<p>For comparing against <code>None</code>, <code>is None</code> is preferred over <code>== None</code>.</p>
<blockquote>
<p>I've always liked to use 'is' because
  I find it more aesthetically pleasing
  and pythonic (which is how I fell into
  this trap...), but I wonder if it's
  intended to just be reserved for when
  you care about finding two objects
  with the same id.</p>
</blockquote>
<p>Yes, that's exactly what it's for.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would like to show a little example on how <code>is</code> and <code>==</code> are involved in immutable types. Try that:</p>
<pre><code>a = 19998989890
b = 19998989889 +1
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a == b
True
</code></pre>
<p><code>is</code> compares two objects in memory, <code>==</code> compares their values. For example, you can see that small integers are cached by Python:</p>
<pre><code>c = 1
b = 1
&gt;&gt;&gt; b is c
True
</code></pre>
<p>You should use <code>==</code> when comparing values and <code>is</code> when comparing identities. (Also, from an English point of view, "equals" is different from "is".)</p>
</div>
<div class="post-text" itemprop="text">
<p>The logic is not flawed.  The statement</p>
<blockquote>
<p>if x is y then x==y is also True </p>
</blockquote>
<p>should <strong>never</strong> be read to mean </p>
<blockquote>
<p>if x==y then x is y </p>
</blockquote>
<p>It is a logical error on the part of the reader to assume that the converse of a logic statement is true.  See <a href="http://en.wikipedia.org/wiki/Converse_%28logic%29" rel="noreferrer">http://en.wikipedia.org/wiki/Converse_(logic)</a></p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="https://stackoverflow.com/questions/2987958/how-is-the-is-keyword-implemented-in-python">This question</a></p>
<p>Your logic in reading </p>
<blockquote>
<p>For all built-in Python objects (like
  strings, lists, dicts, functions,
  etc.), if x is y, then x==y is also
  True.</p>
</blockquote>
<p>is slightly flawed.</p>
<p>If <code>is</code> applies then <code>==</code> will be True, but it does NOT apply in reverse. <code>==</code> may yield True while <code>is</code> yields False.</p>
</div>
<span class="comment-copy">How is this "counter to your experience"? NaN is the only built-in counterexample; you're simply misunderstanding directional relations. The spec says "For all built-in Python objects (like strings, lists, dicts, functions, etc.), if x is y, then x==y is also True.", not "For all built-in Python objects (like strings, lists, dicts, functions, etc.), if x==y, then x is y is also True." For some reason, you're pretending it says the latter. It doesn't. You see that equality matches, but is doesn't. That is perfectly allowed by the former quoted statement.</span>
<span class="comment-copy">Yup. My reading of that was completely confused. I edited it out of the question, because I don't think it will be useful to future readers.</span>
<span class="comment-copy">o1 is o2 =&gt; compares if o1 and o2 both points to same physical location in memory (in other words if they are same object).  While, o1 == o2 =&gt; here python call the o1's __cmp__(o2) method, which ideally should compares the value and return True or False. (In other words it compares value)  For JAVA people:  In Java, to determine whether two string variables reference the same physical memory location by using str1 == str2. (called object identity, and it is written in Python as str1 is str2).   To compare string values in Java, usestr1.equals(str2); in Python, use str1 == str2.</span>
<span class="comment-copy">@Coquelicot: That wouldn't work because Python allows anything to be used as a boolean expression.  If you have bool_a == 3 and bool_b == 4, then bool_a != bool_b, but bool_a xor bool_b is false (because both terms are true).</span>
<span class="comment-copy">@Mike: <code>x is x</code> is always True.  But that does not imply <code>x == x</code>.  NaN is defined as not equal to itself.</span>
<span class="comment-copy">Regarding speed, I though that for checking if a string was modified (e.g. result returned from re.sub) comparing large strings for <code>is</code> equality instead of <code>==</code> would be faster. This was barely the case an timeit showed a mere <b>0.4%</b> speed improvement. In my case it's not worth the risk that re.sub starts changing the strings in the future.</span>
<span class="comment-copy">For anyone looking at this years later, this still holds true for Python 3.</span>
<span class="comment-copy">@beauxq: Try <code>nan = float('nan'); nan is nan; nan == nan</code></span>
<span class="comment-copy">Another simple example, <code>datetime.date.today() == datetime.date.today()</code> ==&gt; True but <code>datetime.date.today is datetime.date.today()</code> ==&gt; False because they are equivalent date objects, but they're still different objects.</span>
<span class="comment-copy">Another dangerous example that your recommendation avoids: <code>str(None) is 'None'</code> evaluates to <code>False</code> but <code>str(None) == 'None'</code> evaluates to <code>True</code></span>
<span class="comment-copy">Here's one with strings: <code>x = 'foo'; y = 'bar'.replace('bar', 'foo'); (x is y) == False</code></span>
<span class="comment-copy">Another example that I like: 'a'*50 == 'a'*50 (returns True), whereas 'a'*50 is 'a'*50 (returns False)</span>
<span class="comment-copy">Not sure why this doesn't have more up votes.</span>
<span class="comment-copy">@BrentHronik It's more related to the memory addresses and the <code>id</code> of the object rather than the actual logic.</span>
<span class="comment-copy">Is the first statement true if x and y are both NaN? Possibly even with the same object id? In other languages (C++) it is supposed to be the case that NaN is never equal to itself.</span>
<span class="comment-copy">Whoops, apparently I forgot how implication works. Thanks. Also, how weird that someone asked such a similar question just as I was writing mine.</span>
<span class="comment-copy"><code>is</code> implies <code>==</code> is only necessarily true for built-in types. One can easily write a class where an object does not equal itself.</span>
<span class="comment-copy">@Coquelicot On the universal scale of weird it's about 5 to 5.5 zoolanders.</span>
<span class="comment-copy">@Coquelicot - It's not weird at all. This is a common point of confusion in Python, Python is a popular language, and Stack Overflow is a popular website for asking questions.</span>
<span class="comment-copy">By saying "If <code>is</code> applies then <code>==</code> will be True, but it does NOT apply in reverse." you're just stating what the OP observed.</span>
