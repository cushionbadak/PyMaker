<div class="post-text" itemprop="text">
<p><strong>Preamble</strong></p>
<p>I'm displaying an image from a Django back-end into a <code>26 x 26px</code> sized (css) <code>&lt;img&gt;</code> tag.</p>
<p>I can do this two ways:</p>
<ol>
<li>Resize on the back-end (Pillow) to <code>26x26</code> (cropping to keep the aspect ratio)</li>
<li>Send the full size image and let CSS do the sizing</li>
</ol>
<hr/>
<p><strong>Issue</strong></p>
<p>Using the <code>LANCZOS</code> algorithm for resizing and saving the result as 100% quality Jpg, the displayed image looks so much worse than the one resized by the browser.</p>
<p><a href="https://i.stack.imgur.com/Bwb9Y.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Bwb9Y.png"/></a></p>
<p>Why is that, and is there any way to fix it?</p>
<hr/>
<p><em>EDIT</em>: Testing on a Retina display</p>
<p><em>EDIT</em>: Bicubic looks very similar to Lanczos</p>
<p><a href="https://i.stack.imgur.com/HPAne.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/HPAne.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>In my experience, PIL/Pillow (hereafter simply “Pillow”) can behave very differently with small images than it does with large ones – not just in its resizing operations but generally – but so you might as well test out all of the methods Pillow offers, e.g.:</p>
<pre class="lang-py prettyprint-override"><code># q.v. https://gist.github.com/fish2000/d85befaf289c664b6a9f44d1b56e57da#file-asscat-py-L129-L134

from PIL import Image

# q.v. PIL.Image constants of the same (yet uppercased) names:
interpolation_methods = frozenset({
                          "box",
                          "bilinear", "bicubic",
                          "hamming", "lanczos",
                          "nearest" })

def interpol(name):
    """ Return a PIL/Pillow image interpolation method constant by name """
    return getattr(Image, name.upper())

size    = (26, 26)
avatar  = Image.open(…) # load your source avatar image
methods = (interpol(method) for method in interpolation_methods)
scaled  = (avatar.resize(size, resample=method) for method in methods)

# you can save these out for more granular inspection:
previews = list(scaled)
for preview in previews:
    preview.show()
</code></pre>
<p>… keep in mind that <code>Image.NEAREST</code> can yield surprisingly decent results for small sizes – that, and the fact that Pillow is not in any way Adobe® Photoshop™, and as such can’t really be tasked with replicating results you may have gotten out of same.</p>
<p>But so, w/r/t whether or not to scale using CSS (or any other client-based method): it’s always better to send less bytes over the wire, if possible – but that doesn’t mean it can’t be done. I’m a perfectionist, personally, but if pressed for time or money I am not pedantic about it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This article here <a href="https://daraskolnick.com/image-dpi-web/" rel="nofollow noreferrer">[1]</a> says that Retina displays (high-DPI displays) are going to try to display 2x more pixels in the same area. Area that is also measured in pixels, the pixels you actually declare in CSS.</p>
<p>So this is where my confusion came from. The solution was to generate the thumbnails twice the size being displayed.  </p>
</div>
<span class="comment-copy">Can you try bicubic interpolation and show the result?</span>
<span class="comment-copy">I believe the LANCZOS algorithm is for enlarging images. I would suggest using <code>PIL.Image.BICUBIC</code>.</span>
<span class="comment-copy">Edited. If anything, it looks a bit worse.</span>
<span class="comment-copy">"always better to send less bytes over the wire", that's the only reason I'm bothering with back-end resizing. I hate the scan-line loading of a tiny avatar image.</span>
