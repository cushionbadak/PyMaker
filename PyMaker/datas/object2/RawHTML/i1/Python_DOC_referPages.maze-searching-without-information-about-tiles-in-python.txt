<div class="post-text" itemprop="text">
<p>I am working on a maze that is being generated using the turtle module in Python.
I am allowed to interact with the maze using 5 actions through an Agent.
These actions(<em>methods</em>) are {Forward, Backward, Right, Left, IsSuccess} where 4 are movements and one is to check if I have reached the finish line of the maze.</p>
<p>Some information that is needed to understand the scope. <br/>
<strong>1:</strong> I have access to the current position of the Agent where he stands(x,y) <br/>
<strong>2:</strong> The agent always faces the same direction, for example if he is given the command to go right, he will turn 90 degrees in the appropriate direction and move a set given of pixels forward and then turn -90 degrees to face the same direction again.<br/>
<strong>3:</strong> If he collides with a wall in the maze when using one of the movement methods, the move will be undone and <strong>False</strong> is returned. If the move is valid, he remains in the new position and <strong>True</strong> is returned. <br/>
<strong>4:</strong> No backtracking to get the path to the finish is needed. <br/>
<strong>5:</strong> The maze is built in a circular manner with the player starting close to the middle and the objective is to get out of the circular maze. The parameter that checks if the player has won the game is how far the player is from the center. For example, the player might start at a circular value of 50, and moving between inner and outer circles gives +25 or -25 to this value. While the goal would be to reach a specific value, say 125.</p>
<p>Now I started with some simple recursive search algorithms but no matter how I tweak it I get stuck after navigating x amount of steps in the maze. This is what I have so far:</p>
<pre><code>def escape():
    if isSuccess():
        return True

   position = (math.floor(agent.pos()[0]),math.floor(agent.pos()[1])) #Gets current agent position

   if position in visistedPositions:
       print("Already visited here")
       return False
   visistedPositions.append(position) #Adds agents position to visited list

   if(Right(agent)):
       print("Moved right")
       escape()
   else:
       print("Could not move Right")
   if(Backward(agent)):
       print("Moved Back")
       escape()
   else:
       print("Could not move Back")
   if(Left(agent)):
       print("Moved Left")
       escape()
   else:
       print("Could not move Left")
   if(Forward(agent)):
       print("Moved Forward")
       escape()
   else:
       print("Could not move Forward")
   return False
</code></pre>
<p>Any suggestions of how I can complete this task with only the given actions at my disposal? I have researched and explored different algorithms such as BFS, DFS and A*,  but I can't see how I could fit any of these to this problem. Any suggestions are welcome. </p>
<p><strong>EDIT:</strong>
To make things more clear on how the agent moves, I post a snippet from <code>Right()</code> and <code>Backward()</code> methods.</p>
<pre><code>def Right(agent):
global circle_level
if circle_level &lt; SUCCESS_LEVEL:
    #turtle.home()
    p1 = Point(agent.pos()[0], agent.pos()[1])
    agent.circle(circle_level,-22.5)
    p2 = Point(agent.pos()[0], agent.pos()[1])
    if isBlocked(Line(p1,p2)):
        print('blocked')
        agent.circle(circle_level,22.5)
        return False
return True

def Backward(agent):
global circle_level
if circle_level &gt; 50 and circle_level &lt; SUCCESS_LEVEL:
    circle_level -= 20
    p1 = Point(agent.pos()[0], agent.pos()[1])
    agent.right(90)
    agent.backward(20)
    agent.right(-90)
    p2 = Point(agent.pos()[0], agent.pos()[1])
    if isBlocked(Line(p1,p2)):
        print('blocked')
        circle_level += 20
        agent.right(90)
        agent.forward(20)
        agent.right(-90)
        return False
return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although this seems odd cast as a recursive function, I'll play along.  The primary issue I see is that you call <code>escape()</code> recursively but ignore its return value.  How would you ever know you succeeded upon recursion?</p>
<p>Below is my rework of your code addressing this issue:</p>
<pre><code>def escape():
    if isSuccess():
        return True

    position = (math.floor(agent.xcor()), math.floor(agent.ycor()))  # Get current agent position

    if position in visitedPositions:
        print("Already visited here")
        return False

    visitedPositions.append(position)  # Add agent's position to visited list

    if Right(agent):
        print("Moved right")
        return escape()

    print("Could not move Right")

    if Backward(agent):
        print("Moved Back")
        return escape()

    print("Could not move Back")

    if Left(agent):
        print("Moved Left")
        return escape()

    print("Could not move Left")

    if Forward(agent):
        print("Moved Forward")
        return escape()

    print("Could not move Forward")

    return False
</code></pre>
<p>It might be more efficient if you made <code>visitedPositions</code> [spelling changed] a <code>set</code> instead of a <code>list</code>.</p>
</div>
<span class="comment-copy">Thank you for your suggestion. Then I will add it as a set instead, thank you for the tip! However, this code will not make the agent navigate out from the maze. I tried to run this code but there is still the problem of the agent stops. This problem occurs I start the agent, he marks his position S(x,y), then tries to move Right, if this is invalid and Backward is also invalid, he will move Left and then in the Recursive call inflict the Right move again, making him visit an already seen position and exit. You mentioned this way might be odd, what would your suggestion be? Thanks!</span>
<span class="comment-copy">I added two of the moving methods so you can see exactly how the agent changes his position. See EDIT: in my original post.</span>
