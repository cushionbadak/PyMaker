<div class="post-text" itemprop="text">
<p>In python I can add a method to a class with the <code>@classmethod</code> decorator.  Is there a similar decorator to add a property to a class?  I can better show what I'm talking about.</p>
<pre><code>class Example(object):
   the_I = 10
   def __init__( self ):
      self.an_i = 20

   @property
   def i( self ):
      return self.an_i

   def inc_i( self ):
      self.an_i += 1

   # is this even possible?
   @classproperty
   def I( cls ):
      return cls.the_I

   @classmethod
   def inc_I( cls ):
      cls.the_I += 1

e = Example()
assert e.i == 20
e.inc_i()
assert e.i == 21

assert Example.I == 10
Example.inc_I()
assert Example.I == 11
</code></pre>
<p>Is the syntax I've used above possible or would it require something more?</p>
<p>The reason I want class properties is so I can lazy load class attributes, which seems reasonable enough.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I would do this:</p>
<pre><code>class ClassPropertyDescriptor(object):

    def __init__(self, fget, fset=None):
        self.fget = fget
        self.fset = fset

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        return self.fget.__get__(obj, klass)()

    def __set__(self, obj, value):
        if not self.fset:
            raise AttributeError("can't set attribute")
        type_ = type(obj)
        return self.fset.__get__(obj, type_)(value)

    def setter(self, func):
        if not isinstance(func, (classmethod, staticmethod)):
            func = classmethod(func)
        self.fset = func
        return self

def classproperty(func):
    if not isinstance(func, (classmethod, staticmethod)):
        func = classmethod(func)

    return ClassPropertyDescriptor(func)


class Bar(object):

    _bar = 1

    @classproperty
    def bar(cls):
        return cls._bar

    @bar.setter
    def bar(cls, value):
        cls._bar = value


# test instance instantiation
foo = Bar()
assert foo.bar == 1

baz = Bar()
assert baz.bar == 1

# test static variable
baz.bar = 5
assert foo.bar == 5

# test setting variable on the class
Bar.bar = 50
assert baz.bar == 50
assert foo.bar == 50
</code></pre>
<p>The setter didn't work at the time we call  <code>Bar.bar</code>, because we are calling
<code>TypeOfBar.bar.__set__</code>, which is not <code>Bar.bar.__set__</code>.</p>
<p>Adding a metaclass definition solves this:</p>
<pre><code>class ClassPropertyMetaClass(type):
    def __setattr__(self, key, value):
        if key in self.__dict__:
            obj = self.__dict__.get(key)
        if obj and type(obj) is ClassPropertyDescriptor:
            return obj.__set__(self, value)

        return super(ClassPropertyMetaClass, self).__setattr__(key, value)

# and update class define:
#     class Bar(object):
#        __metaclass__ = ClassPropertyMetaClass
#        _bar = 1

# and update ClassPropertyDescriptor.__set__
#    def __set__(self, obj, value):
#       if not self.fset:
#           raise AttributeError("can't set attribute")
#       if inspect.isclass(obj):
#           type_ = obj
#           obj = None
#       else:
#           type_ = type(obj)
#       return self.fset.__get__(obj, type_)(value)
</code></pre>
<p>Now all will be fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you define <code>classproperty</code> as follows, then your example works exactly as you requested.</p>
<pre><code>class classproperty(object):
    def __init__(self, f):
        self.f = f
    def __get__(self, obj, owner):
        return self.f(owner)
</code></pre>
<p>The caveat is that you can't use this for writable properties.  While <code>e.I = 20</code> will raise an <code>AttributeError</code>, <code>Example.I = 20</code> will overwrite the property object itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you may be able to do this with the metaclass.  Since the metaclass can be like a class for the class (if that makes sense).  I know you can assign a <code>__call__()</code> method to the metaclass to override calling the class, <code>MyClass()</code>.  I wonder if using the <code>property</code> decorator on the metaclass operates similarly.  (I haven't tried this before, but now I'm curious...)</p>
<p>[update:]</p>
<p>Wow, it does work:</p>
<pre><code>class MetaClass(type):    
    def getfoo(self):
        return self._foo
    foo = property(getfoo)

    @property
    def bar(self):
        return self._bar

class MyClass(object):
    __metaclass__ = MetaClass
    _foo = 'abc'
    _bar = 'def'

print MyClass.foo
print MyClass.bar
</code></pre>
<p>Note: This is in Python 2.7.  Python 3+ uses a different technique to declare a metaclass.  Use: <code>class MyClass(metaclass=MetaClass):</code>, remove <code>__metaclass__</code>, and the rest is the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>[answer written based on python 3.4; the metaclass syntax differs in 2 but I think the technique will still work]</p>
<p>You can do this with a metaclass...mostly. Dappawit's almost works, but I think it has a flaw:</p>
<pre><code>class MetaFoo(type):
    @property
    def thingy(cls):
        return cls._thingy

class Foo(object, metaclass=MetaFoo):
    _thingy = 23
</code></pre>
<p>This gets you a classproperty on Foo, but there's a problem...</p>
<pre><code>print("Foo.thingy is {}".format(Foo.thingy))
# Foo.thingy is 23
# Yay, the classmethod-property is working as intended!
foo = Foo()
if hasattr(foo, "thingy"):
    print("Foo().thingy is {}".format(foo.thingy))
else:
    print("Foo instance has no attribute 'thingy'")
# Foo instance has no attribute 'thingy'
# Wha....?
</code></pre>
<p>What the hell is going on here? Why can't I reach the class property from an instance?</p>
<p>I was beating my head on this for quite a while before finding what I believe is the answer. Python @properties are a subset of descriptors, and, from the <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer">descriptor documentation</a> (emphasis mine):</p>
<blockquote>
<p>The default behavior for attribute access is to get, set, or delete the
  attribute from an objectâ€™s dictionary. For instance, <code>a.x</code> has a lookup chain
  starting with <code>a.__dict__['x']</code>, then <code>type(a).__dict__['x']</code>, and continuing 
  through the base classes of <code>type(a)</code> <strong>excluding metaclasses</strong>.</p>
</blockquote>
<p>So the method resolution order doesn't include our class properties (or anything else defined in the metaclass). It <em>is</em> possible to make a subclass of the built-in property decorator that behaves differently, but (citation needed) I've gotten the impression googling that the developers had a good reason (which I do not understand) for doing it that way.</p>
<p>That doesn't mean we're out of luck; we can access the properties on the class itself just fine...and we can get the class from <code>type(self)</code> within the instance, which we can use to make @property dispatchers:</p>
<pre><code>class Foo(object, metaclass=MetaFoo):
    _thingy = 23

    @property
    def thingy(self):
        return type(self).thingy
</code></pre>
<p>Now <code>Foo().thingy</code> works as intended for both the class and the instances! It will also continue to do the right thing if a derived class replaces its underlying <code>_thingy</code> (which is the use case that got me on this hunt originally).</p>
<p>This isn't 100% satisfying to me -- having to do setup in both the metaclass and object class feels like it violates the DRY principle. But the latter is just a one-line dispatcher; I'm mostly okay with it existing, and you could probably compact it down to a lambda or something if you really wanted.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I can tell, there is no way to write a setter for a class property without creating a new metaclass.</p>
<p>I have found that the following method works. Define a metaclass with all of the class properties and setters you want. IE, I wanted a class with a <code>title</code> property with a setter. Here's what I wrote:</p>
<pre><code>class TitleMeta(type):
    @property
    def title(self):
        return getattr(self, '_title', 'Default Title')

    @title.setter
    def title(self, title):
        self._title = title
        # Do whatever else you want when the title is set...
</code></pre>
<p>Now make the actual class you want as normal, except have it use the metaclass you created above.</p>
<pre><code># Python 2 style:
class ClassWithTitle(object):
    __metaclass__ = TitleMeta
    # The rest of your class definition...

# Python 3 style:
class ClassWithTitle(object, metaclass = TitleMeta):
    # Your class definition...
</code></pre>
<p>It's a bit weird to define this metaclass as we did above if we'll only ever use it on the single class. In that case, if you're using the Python 2 style, you can actually define the metaclass inside the class body. That way it's not defined in the module scope.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only need lazy loading, then you could just have a class initialisation method.</p>
<pre><code>EXAMPLE_SET = False
class Example(object):
   @classmethod 
   def initclass(cls):
       global EXAMPLE_SET 
       if EXAMPLE_SET: return
       cls.the_I = 'ok'
       EXAMPLE_SET = True

   def __init__( self ):
      Example.initclass()
      self.an_i = 20

try:
    print Example.the_I
except AttributeError:
    print 'ok class not "loaded"'
foo = Example()
print foo.the_I
print Example.the_I
</code></pre>
<p>But the metaclass approach seems cleaner, and with more predictable behavior.</p>
<p>Perhaps what you're looking for is the <a href="http://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow noreferrer">Singleton</a> design pattern. There's <a href="https://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python">a nice SO QA</a> about implementing shared state in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>I happened to come up with a solution very similar to @Andrew, only DRY</p>
<pre><code>class MetaFoo(type):

    def __new__(mc1, name, bases, nmspc):
        nmspc.update({'thingy': MetaFoo.thingy})
        return super(MetaFoo, mc1).__new__(mc1, name, bases, nmspc)

    @property
    def thingy(cls):
        if not inspect.isclass(cls):
            cls = type(cls)
        return cls._thingy

    @thingy.setter
    def thingy(cls, value):
        if not inspect.isclass(cls):
            cls = type(cls)
        cls._thingy = value

class Foo(metaclass=MetaFoo):
    _thingy = 23

class Bar(Foo)
    _thingy = 12
</code></pre>
<p>This has the best of all answers:</p>
<p>The "metaproperty" is added to the class, so that it will still be a property of the instance</p>
<ol>
<li>Don't need to redefine thingy in any of the classes</li>
<li>The property works as a "class property" in for both instance and class</li>
<li>You have the flexibility to customize how _thingy is inherited</li>
</ol>
<p>In my case, I actually customized <code>_thingy</code> to be different for every child, without defining it in each class (and without a default value) by:</p>
<pre><code>   def __new__(mc1, name, bases, nmspc):
       nmspc.update({'thingy': MetaFoo.services, '_thingy': None})
       return super(MetaFoo, mc1).__new__(mc1, name, bases, nmspc)
</code></pre>
</div>
<span class="comment-copy">I don't know python... is this the kind of stuff you are looking for ? <a href="http://www.python.org/download/releases/2.2/descrintro/#property" rel="nofollow noreferrer">python.org/download/releases/2.2/descrintro/#property</a></span>
<span class="comment-copy">if i'm reading that right, you can create methods to act as the setter and getter (as in other languages) so you can lazy load the property value on the first get... which i think is what you wanted?</span>
<span class="comment-copy">@White Dragon.  The property feature you're looking at adds properties to class instances, not to the classes themselves.  I'm asking about <code>Example.I</code> not <code>e.i</code>.</span>
<span class="comment-copy">Here's solution to create class property in another topic: <a href="http://stackoverflow.com/a/35640842/1113207">stackoverflow.com/a/35640842/1113207</a></span>
<span class="comment-copy">Dupe:  <a href="https://stackoverflow.com/q/128573/674039">Using property() on classmethods</a></span>
<span class="comment-copy">hmm.. my setter function appears to be ignored, and I can't get anything in <b>set</b> to execute ever (even if i just some garbage in there, nothing changes)</span>
<span class="comment-copy">the 2nd assertion here fails:   <a href="http://drktd.com/6D2b" rel="nofollow noreferrer">drktd.com/6D2b</a></span>
<span class="comment-copy">Seems to not works with setter.</span>
<span class="comment-copy"><code>__set__</code> never get's called in my example... so I could set the value of my <code>classproperty</code> all the time.. (I don't have a cetter defined for my classproperty)</span>
<span class="comment-copy">So it <i>can</i> be done, but can it be done with a method decorator?</span>
<span class="comment-copy">There is no decorator I'm aware of that you can use directly on the class you're interested in.  However, the <code>property</code> decorator in the metaclass should work.... I've edited my answer to include a decorated metaclass method.</span>
<span class="comment-copy">Also see <a href="http://stackoverflow.com/questions/128573/using-property-on-classmethods">this similar question</a> and its answers. Seems to be similar, so it may have some more helpful information :)</span>
<span class="comment-copy">@Abafei: very good link</span>
<span class="comment-copy">Descriptors like <code>property</code> need to be in the type's dictionary to work their magic. So those in a class definition primarily affect the behaviour of instances of the class, with minimal effect on the behaviour of the class itself (since the class is the type of the instances). Moving the descriptors to the metaclass allows them to work their magic on the class itself (since the metaclass is the type of the class).</span>
<span class="comment-copy">This should be the top answer as it works universally and for sub-classes as well.</span>
