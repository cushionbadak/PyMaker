<div class="post-text" itemprop="text">
<p>I have an array in which I want to find the index of the smallest elements. I have tried the following method:</p>
<pre><code>distance = [2,3,2,5,4,7,6]

a = distance.index(min(distance))
</code></pre>
<p>This returns 0, which is the index of the first smallest distance. However, I want to find all such instances, 0 and 2. How can I do this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may enumerate array elements and extract their indexes if the condition holds:</p>
<pre><code>min_value = min(distance)
[i for i,n in enumerate(distance) if n==min_value]
#[0,2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use np.where to get all the indexes that match a given value:</p>
<pre><code>import numpy as np

distance = np.array([2,3,2,5,4,7,6])

np.where(distance == np.min(distance))[0]

Out[1]: array([0, 2])
</code></pre>
<p>Numpy outperforms other methods as the size of the array grows:</p>
<h3>Results of TimeIt comparison test, adapted from <a href="https://stackoverflow.com/users/7727583/yannic-hamann">Yannic Hamann's</a> code below</h3>
<pre><code>                     Length of Array x 7
Method               1       10      20      50     100    1000
Sorted Enumerate     2.47  16.291  33.643                      
List Comprehension  1.058   4.745   8.843  24.792              
Numpy               5.212   5.562   5.931    6.22  6.441  6.055
Defaultdict         2.376   9.061  16.116  39.299              
</code></pre>
<p><a href="https://i.stack.imgur.com/ELmuM.png" rel="nofollow noreferrer"><img alt="Plot of timing results" src="https://i.stack.imgur.com/ELmuM.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Surprisingly the <code>numpy</code> answer seems to be the slowest.</p>
<p>Update: Depends on the size of the input list.</p>
<pre><code>import numpy as np
import timeit
from collections import defaultdict


def weird_function_so_bad_to_read(distance):
    se = sorted(enumerate(distance), key=lambda x: x[1])
    smallest_numb = se[0][1]  # careful exceptions when list is empty
    return [x for x in se if smallest_numb == x[1]]
    # t1 = 1.8322973089525476


def pythonic_way(distance):
    min_value = min(distance)
    return [i for i, n in enumerate(distance) if n == min_value]
    # t2 = 0.8458914929069579


def fastest_dont_even_have_to_measure(np_distance):
    # np_distance = np.array([2, 3, 2, 5, 4, 7, 6])
    min_v = np.min(np_distance)
    return np.where(np_distance == min_v)[0]
    # t3 = 4.247801031917334


def dd_answer_was_my_first_guess_too(distance):
    d = defaultdict(list)  # a dictionary where every value is a list by default

    for idx, num in enumerate(distance):
        d[num].append(idx)  # for each number append the value of the index

    return d.get(min(distance))
    # t4 = 1.8876687170704827


def wrapper(func, *args, **kwargs):
    def wrapped():
        return func(*args, **kwargs)
    return wrapped


distance = [2, 3, 2, 5, 4, 7, 6]

t1 = wrapper(weird_function_so_bad_to_read, distance)
t2 = wrapper(pythonic_way, distance)
t3 = wrapper(fastest_dont_even_have_to_measure, np.array(distance))
t4 = wrapper(dd_answer_was_my_first_guess_too, distance)

print(timeit.timeit(t1))
print(timeit.timeit(t2))
print(timeit.timeit(t3))
print(timeit.timeit(t4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can use an interim dict to store indices of the list and then just fetch the minimum value of distance from it. We will also use a simple for-loop here so that you can understand what is happening step by step.</p>
<pre><code>from collections import defaultdict

d = defaultdict(list) # a dictionary where every value is a list by default

for idx, num in enumerate(distance):
    d[num].append(idx) # for each number append the value of the index

d.get(min(distance)) # fetch the indices of the min number from our dict

[0, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also do the following <code>list comprehension</code></p>
<pre><code>distance = [2,3,2,5,4,7,6]
min_distance = min(distance)
[index for index, val in enumerate(distance) if val == min_distance]
&gt;&gt;&gt; [0, 2]
</code></pre>
</div>
<span class="comment-copy">get the smallest number, and then linearly iterate, get all the indexes for that number.</span>
<span class="comment-copy">Why would you calculate the minimum for every iteration?</span>
<span class="comment-copy">@G_M Agree, updated.</span>
<span class="comment-copy">ping to have a look at my performance tests</span>
<span class="comment-copy">@YannicHamann Nothing surprising at all. I ran these tests before posting my answer. NumPy is not a silver bullet.</span>
<span class="comment-copy">ping to have a look at my performance tests</span>
<span class="comment-copy">Interesting. I would not have expected that. I wonder why that is the case?</span>
<span class="comment-copy">when you compare distance of the type <code>numpy.ndarray</code> with an integer it always evaluates the FULL array.</span>
<span class="comment-copy">I think this brings up an important point: numpy shines in efficient computation with very large arrays. For small arrays, numpy may not be the most efficient, as you have clearly pointed out. But numpy is much more scalable than most other methods. <a href="https://stackoverflow.com/questions/993984/what-are-the-advantages-of-numpy-over-regular-python-lists">This discussion</a> contains some relevant explanation.</span>
<span class="comment-copy">I re-made the plot using Matplotlib.</span>
<span class="comment-copy">I ran some additional tests using your code which show how numpy performs well even as the array size increases dramatically.</span>
<span class="comment-copy">How is this different from my previously posted answer?</span>
<span class="comment-copy">@DYZ I think we both posted the answer at the same time. Or do you have any reason to suggest that my answer came from your? What if I turned around and asked you the same question?</span>
<span class="comment-copy">Calculating the minimum for every iteration seems wasteful in both of your answers.</span>
<span class="comment-copy">That makes sense. I will update my answer.</span>
