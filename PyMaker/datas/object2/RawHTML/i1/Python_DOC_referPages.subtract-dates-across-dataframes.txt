<div class="post-text" itemprop="text">
<p>I just start learning Python and R, so any advice using either of them would be much appreciated.</p>
<p>My data are stored in two dataframes. One is sales data, for each consumer, we can see the date when he purchases something. It is possible the same person purchases more than once:</p>
<pre><code>Date             Person ID      Product       
01-05-2012       1              cereal
01-05-2012       2              apple
02-08-2012       3              beef
03-22-2013       72             pot
07-19-2012       1              cake
</code></pre>
<p>The second dataframe has membership data, which tell us when did a person enrolled in the program:</p>
<pre><code>Date             Person ID      Type      Status      
06-11-2008       1              Gold      New
10-12-2011       2              Gold      New    
02-08-2011       3              Silver    Renewal
02-01-2012       72             Gold      Renewal
03-22-2012       1              Gold      Renewal
</code></pre>
<p>What I want to do is, for the same person, how long does it take before a person purchases something before he enrolls in a program.</p>
<p>For example, person 1 got a new membership on 06-11-2008 and purchased cereal on 01-05-2012. I would like to calculate how many days there are between these two dates.</p>
<p>However, these information are stored in separate dataframes. I don't think they can be append or merged into one dataframe, because one person can have more than one observations in one or both of the dataframes. </p>
<p>What I am thinking is, extract all the dates from sales data, and extract all the dates from the license data. Then merge these two new dataframes into a new dataframe. This will give me:</p>
<pre><code>License Date     Person ID      Sales Date            
06-11-2008       1              01-05-2012      
10-12-2011       2              01-05-2012         
02-08-2011       3              02-08-2011    
02-01-2012       72             03-22-2013
06-11-2008       1              07-19-2012 
03-22-2012       1              01-05-2012
03-22-2012       1              07-19-2012    
</code></pre>
<p>But the problem here is, if a person has two license dates (ex. one new and one renewal), then merge the data will give 2*(sales dates)... but I only want the sales dates for a license that is valid..</p>
<p>For example, person 1 used license 06-11-2008 to buy cereal on 01-05-2012, and used license 03-22-2012 to buy on 07-19-2012. But merging the dataframes will give me 4 records rather than the 2 I want...</p>
<p>The result I would want is the time to purchase for each sale, after he gets the license which he used for that purchase:</p>
<pre><code>License Date     Person ID      Sales Date   TimeToPurchase         
06-11-2008       1              01-05-2012      ...
10-12-2011       2              01-05-2012      ...
02-08-2011       3              02-08-2011      ...
02-01-2012       72             03-22-2013      ...
03-22-2012       1              07-19-2012      ...
</code></pre>
<p>Is there a better way you suggest I can do?</p>
<p>Thank you very much for the help!</p>
</div>
<div class="post-text" itemprop="text">
<h1>pandas</h1>
<p>First your dates need to be saved as datetime, which you can accomplish like this:</p>
<pre><code>sales['Date'] = pd.to_datetime(sales['Date'])
memberships['Date'] = pd.to_datetime(memberships['Date'])
</code></pre>
<p>Then you merge them by <code>Person ID</code> and arrive to the format that has duplicates.</p>
<pre><code>m = sales.merge(memberships, left_on='Person ID', right_on='Person ID',
                suffixes=('_sales', '_memberships'))
m

  Date_sales  Person ID Product Date_memberships    Type   Status
0 2012-01-05          1  cereal       2008-06-11    Gold      New
1 2012-01-05          1  cereal       2012-03-22    Gold  Renewal
2 2012-07-19          1    cake       2008-06-11    Gold      New
3 2012-07-19          1    cake       2012-03-22    Gold  Renewal
4 2012-01-05          2   apple       2011-10-12    Gold      New
5 2012-02-08          3    beef       2011-02-08  Silver  Renewal
6 2013-03-22         72     pot       2012-02-01    Gold  Renewal
</code></pre>
<p>Now you can calculate the elapsed days between the sales and the membership dates like this:</p>
<pre><code>m['TimeToPurchase'] = (m['Date_sales'] - m['Date_memberships']).dt.days
m

  Date_sales  Person ID Product Date_memberships    Type   Status  TimeToPurchase
0 2012-01-05          1  cereal       2008-06-11    Gold      New            1303
1 2012-01-05          1  cereal       2012-03-22    Gold  Renewal             -77
2 2012-07-19          1    cake       2008-06-11    Gold      New            1499
3 2012-07-19          1    cake       2012-03-22    Gold  Renewal             119
4 2012-01-05          2   apple       2011-10-12    Gold      New              85
5 2012-02-08          3    beef       2011-02-08  Silver  Renewal             365
6 2013-03-22         72     pot       2012-02-01    Gold  Renewal             415
</code></pre>
<p>From here you can first eliminate the negatives and then get the minimum <code>TimeToPurchase</code> for each Person ID and Date sales.</p>
<pre><code>m = m[m['TimeToPurchase'] &gt;= 0]
keep = m.groupby(['Person ID', 'Date_sales'], as_index=False)['TimeToPurchase'].min()
keep

 Person ID Date_sales  TimeToPurchase
         1 2012-01-05            1303
         1 2012-07-19             119
         2 2012-01-05              85
         3 2012-02-08             365
        72 2013-03-22             415
</code></pre>
<p>These are the records that you want to keep in your merged table, which you can filter with an inner join:</p>
<pre><code>result = m.merge(keep, 
                 left_on=['Person ID', 'Date_sales', 'TimeToPurchase'], 
                 right_on=['Person ID', 'Date_sales', 'TimeToPurchase'])
result

Date_sales  Person ID Product Date_memberships    Type   Status  TimeToPurchase
2012-01-05          1  cereal       2008-06-11    Gold      New            1303
2012-07-19          1    cake       2012-03-22    Gold  Renewal             119
2012-01-05          2   apple       2011-10-12    Gold      New              85
2012-02-08          3    beef       2011-02-08  Silver  Renewal             365
2013-03-22         72     pot       2012-02-01    Gold  Renewal             415
</code></pre>
<h1>data.table</h1>
<p>Same logic as above, so I'll just paste the code.</p>
<pre><code># Date types
sales[, Date := as.Date(Date, format = "%m-%d-%Y")]
memberships[, Date := as.Date(Date, format = "%m-%d-%Y")]

# Merge
m &lt;- memberships[sales, on = "Person ID"]

# Calculate elapsed days
m[, TimeToPurchase := as.numeric(m$i.Date - m$Date)]

# Eliminate negatives
m &lt;- m[TimeToPurchase &gt;= 0]

# Calculate records to keep
keep &lt;- m[, .(TimeToPurchase = min(TimeToPurchase)), by = .(`Person ID`, i.Date)]

# Filter result
result &lt;- m[keep, on = c("Person ID", "i.Date", "TimeToPurchase")]
result

         Date Person ID   Type  Status     i.Date Product TimeToPurchase
1: 2008-06-11         1   Gold     New 2012-01-05  cereal           1303
2: 2011-10-12         2   Gold     New 2012-01-05   apple             85
3: 2011-02-08         3 Silver Renewal 2012-02-08    beef            365
4: 2012-02-01        72   Gold Renewal 2013-03-22     pot            415
5: 2012-03-22         1   Gold Renewal 2012-07-19    cake            119
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using R and <code>library(data.table)</code> <strong>assuming you are only interested in the latest time to purchase</strong>:</p>
<p><em>Edit: after question was updated</em></p>
<pre><code>library(data.table)

purchaseDT &lt;- data.table(stringsAsFactors=FALSE,
                         Date = c("01-05-2009", "01-05-2012", "02-08-2012", "03-22-2013"),
                         PersonID = c(1, 2, 1, 72),
                         Product = c("cereal", "apple", "beef", "pot")
)

programDT &lt;- data.table(stringsAsFactors=FALSE,
                        Date = c("06-11-2008", "10-12-2011", "02-08-2011", "02-01-2012"),
                        PersonID = c(1, 2, 1, 72),
                        Type = c("Gold", "Gold", "Silver", "Gold"),
                        Status = c("New", "New", "Renewal", "Renewal")
)

purchaseDT[, PurchaseDate := as.Date(Date, format="%m-%d-%Y")]
programDT[, LicenseDate := as.Date(Date, format="%m-%d-%Y")]
purchaseDT[, Date := NULL]
programDT[, Date := NULL]

mergedDT &lt;- purchaseDT[programDT, on="PersonID"]
mergedDT[, TimeToPurchase := PurchaseDate-LicenseDate]
mergedDT &lt;- mergedDT[TimeToPurchase &gt; 0]

resultDT &lt;- mergedDT[, .(TimeToPurchase = min(TimeToPurchase)), by = c("LicenseDate", "PersonID")]
resultDT[, PurchaseDate := LicenseDate+TimeToPurchase]

print(resultDT)
</code></pre>
<hr/>
<p>Result:</p>
<pre><code>   LicenseDate PersonID TimeToPurchase PurchaseDate
1:  2008-06-11        1       208 days   2009-01-05
2:  2011-10-12        2        85 days   2012-01-05
3:  2011-02-08        1       365 days   2012-02-08
4:  2012-02-01       72       415 days   2013-03-22
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one idea for you. First, I merged the two data sets using <code>Person_ID</code> and <code>Date</code>. In this example, I needed to create a date object (i.e., Date) in the first <code>mutate()</code>. I sorted the data by <code>Person_ID</code> and <code>Date</code>. Then, I created a new grouping variable. What I did was to identify rows where <code>Status</code> is either "New" or "Renewal". This means that I identified when a license became valid for the first time. That row becomes the first row for each license. For each <code>group</code>, I chose the first two rows. The data is arranged by <code>Person_ID</code> and <code>Date</code>, so the 2nd row should be the one that a customer bought something with the valid license for the first time. Finally, I calculated the interval (i.e., <code>time2purchase</code>) using <code>Date</code>. </p>
<pre><code>full_join(df1, df2, by = c("Person_ID", "Date")) %&gt;%
mutate(Date = as.Date(Date, format = "%m-%d-%Y")) %&gt;%
arrange(Person_ID, Date) %&gt;%
mutate(group = findInterval(x = 1:n(), vec = grep(Status, pattern = "New|Renewal"))) %&gt;%
group_by(group) %&gt;%
slice(1:2) %&gt;%
summarize(time2purchase = Date[2]-Date[1])

  group time2purchase
  &lt;int&gt; &lt;time&gt;       
1     1 1303 days    
2     2  119 days    
3     3   85 days    
4     4  365 days    
5     5  415 days   

To make things clearer, I leave the results below, which you can generate
using mutate() instead of summarize().

  Date       Person_ID Product Type   Status  group time2purchase
  &lt;date&gt;         &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;   &lt;int&gt; &lt;time&gt;       
1 2008-06-11         1 NA      Gold   New         1 1303 days    
2 2012-03-22         1 NA      Gold   Renewal     2  119 days    
3 2011-10-12         2 NA      Gold   New         3   85 days    
4 2011-02-08         3 NA      Silver Renewal     4  365 days    
5 2012-02-01        72 NA      Gold   Renewal     5  415 days
</code></pre>
<p>DATA</p>
<pre><code>df1 &lt;-structure(list(Date = c("01-05-2012", "01-05-2012", "02-08-2012", 
"03-22-2013", "07-19-2012"), Person_ID = c(1L, 2L, 3L, 72L, 1L
), Product = c("cereal", "apple", "beef", "pot", "cake")), class = "data.frame", 
row.names = c(NA, 
-5L))

df2 &lt;- structure(list(Date = c("06-11-2008", "10-12-2011", "02-08-2011", 
"02-01-2012", "03-22-2012"), Person_ID = c(1L, 2L, 3L, 72L, 1L
), Type = c("Gold", "Gold", "Silver", "Gold", "Gold"), Status = c("New", 
"New", "Renewal", "Renewal", "Renewal")), class = "data.frame", row.names = c(NA, 
-5L))
</code></pre>
</div>
<span class="comment-copy">It's only the first item they buy that you're interested in? How do you want to handle someones getting a membership, buying something, then renewing, then buying something else? Do you want days between the first membership and first purchase, or the days until the first purchase after any new membership or renewal?</span>
<span class="comment-copy">Thanks a lot for asking @Ogaday! Sorry I didn't say it clearly. If he renews, I want the days between he renews and he makes another purchase.</span>
<span class="comment-copy">Just edited the post thanks to the questions by Ogaday and ismirsehregal. Hope it helps clarify what I am trying to do!</span>
<span class="comment-copy">Thank you so much for the fast and detailed instructions @josemz! This is so brilliant and does exactly what I want very clearly. Thanks a lot!</span>
<span class="comment-copy">Just realize you have codes for both languages! This is super super helpful - teaches me how to work on the same question using different methods. Thanks again for everything!</span>
<span class="comment-copy">Thank you so much!! This is magical! Sorry I didn't explain it clearly. What I want is actually timeToPurchase for each sales, using a valid license.. Is there any way to do this?</span>
<span class="comment-copy">Thank you again for the fast response and such succinct codes, @ismirsehregal. I really learned a lot from it. Sadly I can only choose one, and josemz's answer is closest to the edited question, and in case people have similar questions, I picked that one. But please know that I really appreciate your great guidance!</span>
<span class="comment-copy">Oh, a lot of answers in the meantime. Just saw your update and edited accordingly.</span>
<span class="comment-copy">Thank you so much for also editing your answer!! It's so helpful to see how codes are different relative different questions. You are a master of coding!</span>
<span class="comment-copy">Thanks a lot for the thoughtful codes @jazzurro! This is super helpful and translates exactly what i am thinking into workable codes ( I am also thinking about using new versus renewal type). The answers are all really perfect, and it is very hard to choose one, so I go with josemz's solution above as it is posted a bit earlier.. but really, please know that I appreciate your guidance in the same way!</span>
