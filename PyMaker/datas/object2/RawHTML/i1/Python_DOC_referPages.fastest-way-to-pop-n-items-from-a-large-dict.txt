<div class="post-text" itemprop="text">
<p>I have a large dict <code>src</code> (up to 1M items) and I would like to take N (typical values would be N=10K-20K) items, store them in a new dict <code>dst</code> and leave only the remaining items in <code>src</code>. It doesn't matter which N items are taken. I'm looking for the fastest way to do it on Python 3.6 or 3.7.</p>
<p>Fastest approach I've found so far:</p>
<pre><code>src = {i: i ** 3 for i in range(1000000)}

# Taking items 1 by 1 (~0.0059s)
dst = {}
while len(dst) &lt; 20000:
    item = src.popitem()
    dst[item[0]] = item[1]
</code></pre>
<p>Is there anything better? Even a marginal gain would be good.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a bit faster still:</p>
<pre><code>from itertools import islice
def method_4(d):
    result = dict(islice(d.items(), 20000))
    for k in result: del d[k]
    return result
</code></pre>
<p>Compared to other versions, using Netwave's testcase:</p>
<pre><code>Method 1:  0.004459443036466837  # original
Method 2:  0.0034434819826856256 # Netwave
Method 3:  0.002602717955596745  # chepner
Method 4:  0.001974945073015988  # this answer
</code></pre>
<p>The extra speedup seems to come from avoiding transitions between C and Python functions. From disassembly we can note that the <code>dict</code> instantiation happens on C side, with only 3 function calls from Python. The loop uses <code>DELETE_SUBSCR</code> opcode instead of needing a function call:</p>
<pre><code>&gt;&gt;&gt; dis.dis(method_4)
  2           0 LOAD_GLOBAL              0 (dict)
              2 LOAD_GLOBAL              1 (islice)
              4 LOAD_FAST                0 (d)
              6 LOAD_ATTR                2 (items)
              8 CALL_FUNCTION            0
             10 LOAD_CONST               1 (20000)
             12 CALL_FUNCTION            2
             14 CALL_FUNCTION            1
             16 STORE_FAST               1 (result)

  3          18 SETUP_LOOP              18 (to 38)
             20 LOAD_FAST                1 (result)
             22 GET_ITER
        &gt;&gt;   24 FOR_ITER                10 (to 36)
             26 STORE_FAST               2 (k)
             28 LOAD_FAST                0 (d)
             30 LOAD_FAST                2 (k)
             32 DELETE_SUBSCR
             34 JUMP_ABSOLUTE           24
        &gt;&gt;   36 POP_BLOCK

  4     &gt;&gt;   38 LOAD_FAST                1 (result)
             40 RETURN_VALUE
</code></pre>
<p>Compared with the iterator in <code>method_2</code>:</p>
<pre><code>&gt;&gt;&gt; dis.dis(d.popitem() for _ in range(20000))
  1           0 LOAD_FAST                0 (.0)
        &gt;&gt;    2 FOR_ITER                14 (to 18)
              4 STORE_FAST               1 (_)
              6 LOAD_GLOBAL              0 (d)
              8 LOAD_ATTR                1 (popitem)
             10 CALL_FUNCTION            0
             12 YIELD_VALUE
             14 POP_TOP
             16 JUMP_ABSOLUTE            2
        &gt;&gt;   18 LOAD_CONST               0 (None)
             20 RETURN_VALUE
</code></pre>
<p>which needs a Python to C function call for each item.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple comprehension inside <code>dict</code> will do:</p>
<pre><code>dict(src.popitem() for _ in range(20000))
</code></pre>
<p>Here you have the <a href="https://repl.it/repls/RoastedEmbarrassedSoftwaresuite" rel="nofollow noreferrer">timing tests</a></p>
<pre><code>setup = """
src = {i: i ** 3 for i in range(1000000)}

def method_1(d):
  dst = {}
  while len(dst) &lt; 20000:
      item = d.popitem()
      dst[item[0]] = item[1]
  return dst

def method_2(d):
  return dict(d.popitem() for _ in range(20000))
"""
import timeit
print("Method 1: ", timeit.timeit('method_1(src)', setup=setup, number=1))

print("Method 2: ", timeit.timeit('method_2(src)', setup=setup, number=1))
</code></pre>
<p>Results:</p>
<pre><code>Method 1:  0.007701821999944514
Method 2:  0.004668198998842854
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this approach slightly faster (-10% speed) using dictionary comprehension that consumes a loop using <code>range</code> that yields &amp; unpacks the keys &amp; values</p>
<pre><code>dst = {key:value for key,value in (src.popitem() for _ in range(20000))}
</code></pre>
<p>on my machine:</p>
<pre><code>your code: 0.00899505615234375
my code:   0.007996797561645508
</code></pre>
<p>so about 12% faster, not bad but not as good as not unpacking like <a href="https://stackoverflow.com/a/55199446/6451573">Netwave simpler answer</a></p>
<p>This approach can be useful if you want to transform the keys or values in the process.</p>
</div>
<span class="comment-copy">Why is this code optimalisation question not transferred to <a href="https://codereview.stackexchange.com/">codereview.stackexchange.com</a>? (I did get this question in an audit and it was apparantly kept om main SO site)???</span>
<span class="comment-copy">I was researching this! what a sync!</span>
<span class="comment-copy">@Netwave Do you think this should now be the accepted answer?</span>
<span class="comment-copy">@IvailoKaramanolev, yes, we were searching for the fastest, and indeed this on is.</span>
<span class="comment-copy">so much for dict comprehension. Good one using <code>dict</code>!!!</span>
<span class="comment-copy">Thank you! Hopefully next moderator @Jean-Fran√ßoisFabre ;)</span>
<span class="comment-copy">for my solution, at least, I've upped all 10 times and it's still faster. The key is to make the shorter code possible and rely on native functions.</span>
<span class="comment-copy">You can shave a little more time off by saving the bound method first. <code>f = d.popitem; return dict(f() for _ in range(20000))</code>.</span>
<span class="comment-copy">Using <code>itertools.islice</code> and <code>itertools.repeat</code> is even a little faster still: <code>dict(f() for f in islice(repeat(d.popitem), 20000))</code>.</span>
