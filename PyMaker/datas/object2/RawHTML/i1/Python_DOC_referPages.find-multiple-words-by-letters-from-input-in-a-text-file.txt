<div class="post-text" itemprop="text">
<p>I'm new to python (more or less) and am struggling with one task, where I need to enter one sentence either by user input or whatever way is better/easier (preferably long one, e.g. "We met each other yesterday", but doesn't matter much). Then iterate through all the letters, find all possible letter combinations of said words and find matches with them in a file which consists of thousands of words (approx. 4 mb file), each word is on a separate line, like this:</p>
<pre><code>fun
dog
whatever
coffee
cup
</code></pre>
<p>I went with <code>itertools.permutations</code> and tried going with <code>set</code> and <code>intersection</code>.
Without further ado, here's my code thus far:</p>
<pre><code>from itertools import permutations


def alpha_check():
    """check whether a sentence consists of only letters"""
    sentence = str.lower(input('Type something in: '))
    while not sentence.replace(' ', '').isalpha():
        print(f"You typed in {sentence!s}. Only letters A-Z allowed, not case sensitive.")
        sentence = input("Please, type something again: ")
    return sentence


def file_iter(sentence: str):

    my_set = set(line.strip() for line in open('file.txt'))
    word_list = set(sentence.split())
    for x in word_list:
        temp = list(permutations(x))
        for f in temp:
            print(''.join(f), end=' ') # gets rid of commas etc.
        inters = my_set.intersection(f)
        return inters


print(file_iter(alpha_check()))
</code></pre>
<p>Alpha check doesn't interest me at the moment, I only would like to get this monster to work. Currently it outputs something like this, granted I enter <code>"map lake"</code> after being prompted:</p>
<pre><code>Type something in: map lake
lake laek lkae lkea leak leka alke alek akle akel aelk aekl klae klea kale kael kela keal elak elka ealk eakl ekla ekal {'l', 'e', 'a', 'k'}
</code></pre>
<p>and expected output would be <code>map</code> and <code>lake</code> permutations and then found intersections within input and the file. 
I searched a lot on SO and google. Found a lot of info, but I couldn't make this work anyway. This is the best one I came up with. 
Also I'm not asking for a complete solution, just for help to understand what I'm doing wrong and how can I solve this. Clues, tips, etc.
Thank you! </p>
<p><strong>Update:</strong></p>
<pre><code>def file_iter(sentence):
    new_sentence = []
    my_set = set(line.strip() for line in open('file.txt'))
    word_list = sentence.split()
    for words in word_list:
        permutation = list(permutations(words))
        permute_set = my_set.intersection(["".join(word) for word in permutation])
        new_sentence += permute_set.union(word_list)

    return print(' '.join(set(new_sentence)))
</code></pre>
<p>This provides output below:</p>
<pre><code>Type something in: we met each other
toher ache we haec throe other tem each theor ew met thore
</code></pre>
<p>How can I get them into different sentences? Something along these lines:</p>
<pre><code>we toher met ache
ew tem haec thore 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming that by "find all possible letter combinations of said words" you actually meant permutations.  If that is the case, what you want to do is to store the big list of words in a dictionary with the sorted letters as key and the list of corresponding words (acronyms) as values.</p>
<p>Then you can go through the words in the sentence and find an entry in the dictionary (using the sorted letters of the word) to get all the acronyms.</p>
<p>The sorted letters (wordKey) can serve as a group identifier for words that are acronyms of each other. All acronyms will result in a single key in the dictionary so you don't need to bother with permutations.</p>
<ul>
<li>lake --(sort letters)--&gt; aekl:[lake,leak,kale]</li>
<li>leak --(sort letters)--&gt; aekl:[lake,leak,kale]</li>
<li><p>kale --(sort letters)--&gt; aekl:[lake,leak,kale]</p>
<p><em>Every word reaches the group of acronyms it belongs to in the dictionary</em></p></li>
</ul>
<p>Here's an example you can build your solution from:</p>
<pre><code>acronyms = dict()
for word in open("/usr/share/dict/words").read().split("\n"):
    wordKey = "".join(sorted(word.lower()))
    acronyms.setdefault(wordKey,[]).append(word)

sentence = "We met each other yesterday"
for word in sentence.split():
    wordKey = "".join(sorted(word.lower()))
    print(word, acronyms.get(wordKey,[word]))
</code></pre>
<p>Based on the 235K word dictionary on my laptop, this produces the following output:</p>
<pre><code>We ['we']
met ['met']
each ['ache', 'each', 'haec']
other ['other', 'thore', 'throe', 'toher']
yesterday ['yesterday']
</code></pre>
<p>Note that your solution was close to working.  </p>
<ul>
<li>The <code>f</code> variable in <code>my_set.intersection(f)</code> should have been <code>temp</code>
because <code>f</code> is merely the last permutation.</li>
<li>Also <code>f</code> probably didn't contain what you were expecting. 
Because <code>permutation(x)</code> treats <code>x</code> as a list, it produces a result
(<code>temp</code>) that is a list of lists rather than a list of strings.</li>
<li>So if you change it to <code>my_set.intersection([ "".join(f) for f in
temp])</code> it will probably work.</li>
<li>This is a good example of how choosing meaningful names for your
variables helps in avoiding mistakes.</li>
<li>I'm also wondering if returning <code>inters</code> after processing only the
first word of the sentence's set is really what you aimed to do.</li>
<li>The last part of the printed result is also suspicious because it implies that you actually found an intersection with individual
letters of the word "leak".  This would indicate that your file
contains single letter words or that you are not reading it with the
appropriate encoding (e.g. unicode read as ascii).  You should print
<code>len(my_set)</code> or the first few entries <code>list(my_set)[:25]</code> to make
sure you have words in there rather than letters.</li>
</ul>
<p><strong>[UPDATE]</strong>Â Presenting the output as a single list of words:</p>
<pre><code>sentence = "We met each other yesterday"
result = []
for word in sentence.split():
    wordKey = "".join(sorted(word.lower()))
    result += acronyms.get(wordKey,[]) + [word]
print(" ".join(set(result)))

# thore each other haec we met throe toher yesterday ache
</code></pre>
<p><strong>[UPDATE2]</strong> funky sentences</p>
<p>If you want to play with the result and build all the sentences that could be formed using the acronyms, you will need to go through the acronym group of each word and "multiply" the combinations at each step:</p>
<pre><code>from itertools import product
from itertools import product
funkySentences = [[]]
for word in sentence.split():
    wordKey        = "".join(sorted(word.lower()))
    alternateWords = acronyms.get(wordKey,[word])
    funkySentences = [ s+[w] for s,w in product(funkySentences,alternateWords) ]

funkySentences = set(" ".join(fs) for fs in funkySentences)   
for fs in funkySentences:
    print(fs)
</code></pre>
<p>This will print:</p>
<pre><code>we met haec throe yesterday
we met haec thore yesterday
we met haec toher yesterday
we met ache toher yesterday
we met haec other yesterday
we met each throe yesterday
we met each toher yesterday
we met ache other yesterday
we met each thore yesterday
we met ache throe yesterday
we met ache thore yesterday
we met each other yesterday
</code></pre>
<p>You could also go wild and change the order of the words by applying permutations to each of these funky sentences:</p>
<pre><code>from itertools import chain,permutations
yodaSentences = chain(*[permutations(fs.split()) for fs in funkySentences])

yodaSentences = set(" ".join(ys) for ys in yodaSentences)
for ys in yodaSentences:
    print(ys)
</code></pre>
<p>This will print (Yoda speak):</p>
<pre><code>ache we yesterday met other
other haec we met yesterday
yesterday met throe each we
haec throe yesterday met we
we yesterday met haec toher
yesterday we ache met throe
haec yesterday we other met
other yesterday met haec we
met we haec thore yesterday
each we yesterday other met
we ache yesterday other met
yesterday met toher we each
we met yesterday thore ache
... and many more ....
</code></pre>
</div>
<span class="comment-copy">Thanks for the answer, that cleared up a lot for me. My concerns with these are though: 1. I checked and fixed everything in my original code and it returns now all found intersections with <i>one</i> permutated word, e.g. lake, leak, kale. while I need multiple words. It's good that now it finds what I need at least for one word though. 2. Your example script returns key:value (obviously), but you said I won't have to bother with permutations. But that doesn't mean it's doable without it, am I correct? Also I like avoiding sets, too much hassle with them here.</span>
<span class="comment-copy">You only get one word because of the premature <code>return inters</code>. You would need to build a result set that is the union of these intersections to cover all words.  As for doing it without permutations, it is definitely doable.  It is just a matter of presenting the output differently from my example. (I will add an example in my answer...)</span>
<span class="comment-copy">Thank you once again. Question's solved. I went with permutations and got what I asked. If you don't mind, could you help me to get unique sentences now, please?  I thought of making a dictionary, add keys (input words) and values (permuted corresponding words) to them. this gives me values off my keys, much like in your case (output). That didn't seem to work, can't make sentences off them on new lines. Or I simply do not have enough knowledge on how to do this. I'll update my question with code I got now.</span>
<span class="comment-copy">You should add ask a new question for that.  I added a few ideas to my response anyhow.</span>
<span class="comment-copy">Thank you very much! One small question: what asterisk does here <code>chain(*[permutations(fs.split()) for fs in funkySentences])</code> ? Is it multiplying something? Sorry for a newbie question</span>
