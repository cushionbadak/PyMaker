<div class="post-text" itemprop="text">
<p>I am trying to compute a ordinary ODE (ordinary differential equation) on a distance matrix but I do not know how to parallelize my code. </p>
<pre><code>from scipy.integrate import quad
from math import exp
import numpy as np
import matplotlib.pyplot as plt

#I have my distance matrix and I wanna count how many points are distanced
# from point i with distance r at maximum 
def v(dist, r, i):
    return 1/N*(np.count_nonzero(np.select([dist[i,:]&lt;r],[dist[i,:]]))+1)
#integral of rho from r to infinity
def rho_barre(rho, r):
    return quad(rho, r, np.inf)
# integral over r of a certain integrand
def grad_F(i, j, rho, v, v_r, dist):
    return quad(lambda r : ((v(dist, r, i)+v(dist, r, j))/2-v_r)*rho_barre(rho, max(r, dist[i,j])), 0, np.inf) 

#parameters
delta_T = 0.1
rho = (lambda x: exp(-x))
v_r =0

for t in range (1000):
    for i in range(N):
        for j in range(N):
            d_matrix[i,j] = d_matrix[i,j] + delta_T* grad_F(i,j,rho, v, v_r, d_matrix)
</code></pre>
<p>First I have the following error <code>can't multiply sequence by non-int of type 'float'</code> that I don't understand why. Then, I know that three loops are too much in python and I want to know how can we make it faster in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you have a few different questions. Let me see if I can answer more abstractly and you can piece it together</p>
<h3>Parallel</h3>
<p>One very easy easy way to work in parallel in Python is <code>multiprocessing</code></p>
<p>If you apply the same function many times, instead of:</p>
<pre><code>res = [myfun(arg) for arg in args]
</code></pre>
<p>you can do:</p>
<pre class="lang-py prettyprint-override"><code>import multiprocessing as mp
with mp.Pool() as pool:
    res = pool.map(myfun,args)
</code></pre>
<p>There are limitations. Both <code>myfun</code> and <code>args</code> must be pickleable (which <code>lambda</code> is <em>not</em> so you will want to address that in your code)</p>
<h3>Nested Loops</h3>
<p>In general, python loops are slow. When working with NumPy, it is better to "vectorize" if you can.</p>
<p>So instead of woking on each <code>[i,j]</code> element of <code>d_matrix</code>, see if you can work on them all at the same time. So compute a <em>matrix</em> <code>grad_F</code> (rather than a function) and add it. You will still need your time loop but you may be able to solve your <code>d_matrix</code> in a single, very fast, action.</p>
<h3>Other tips:</h3>
<p>Can you precompute <code>rho_barre</code>. Maybe use <code>scipy.integrate.cumtrapz</code> to compute that?</p>
<p>Also, try to write fewer one-liners. Use new functions instead of lambdas. It will make understanding your code much easier!</p>
</div>
