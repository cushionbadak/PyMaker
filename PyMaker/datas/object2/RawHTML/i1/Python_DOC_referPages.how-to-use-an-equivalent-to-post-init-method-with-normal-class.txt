<div class="post-text" itemprop="text">
<p>I would like to store entity used in my code and avoid multiple occurrences. Thus, my idea was to use an <code>__init__</code> method for collecting the main data for my class, and then use a kind of <code>__post_init__</code> method for computing an id from my class object. Here is the code: </p>
<pre><code>class Worker(Base):
    __tablename__='worker'
    id = Column(Integer,primary_key=True)
    profile=Column(String(100),nullable=False)
    useragent=Column(String(100),nullable=False)
    def __init__(self,useragent,profile):
        """ specify the main information"""
        print('init')
        self.profile= profile
        self.useragent=useragent
    def __post_init__(self):
        """ compute an id based on self, the worker"""
        self.id=id(self)
        print('dans post init')
</code></pre>
<p>With this example, the <code>__init__</code> method can be used, but it doesn't run the <code>__post_init__</code> method like we could expect with dataclass, for example.</p>
<p>How could I run this method just after the execution of the <code>__init__</code> method ? </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__post_init__</code> method is specific to the <code>dataclasses</code> library, because the <code>__init__</code> method on <code>dataclass</code> classes is generated and overriding it would entirely defeat the purpose of generating it in the first place.</p>
<p>SQLAlchemy, on the other hand, provides an <code>__init__</code> implementation on the base model class (generated for you with <code>declarative_base()</code>). You can safely re-use that method yourself after setting up default values, via <code>super().__init__()</code>. Take into account that the <code>SQLAlchemy</code>-provided <code>__init__</code> method only takes keyword arguments: </p>
<pre><code>def __init__(self, useragent, profile):
    """specify the main information"""
    id = generate_new_id(self)
    super().__init__(id=id, useragent=useragent, profile=profile)
</code></pre>
<p>If you need to wait for the other columns to be given updated values first (because perhaps they define Python functions as a <code>default</code>), then you can also run functions after calling <code>super().__init__()</code>, and just assign to <code>self</code>:</p>
<pre><code>def __init__(self, useragent, profile):
    """specify the main information"""
    super().__init__(useragent=useragent, profile=profile)
    self.id = generate_new_id(self)
</code></pre>
<p>Note: you do not want to use the built-in <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id()</code> function</a> to generate ids for SQL-inserted data, the values that the function returns are <em>not guaranteed to be unique</em>. They are only unique for the set of all active Python objects only, and only in the current process. The next time you run Python, or when objects are deleted from memory, values can and will be reused, and you can't control what values it'll generate next time, or in a different process altogether.</p>
<p>If you were looking to only ever create rows with unique combinations of the <code>useragent</code> and <code>profile</code> columns, then you need to define a <a href="https://docs.sqlalchemy.org/en/latest/core/constraints.html#unique-constraint" rel="nofollow noreferrer"><code>UniqueConstraint</code></a> in the <a href="https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/table_config.html#declarative-table-args" rel="nofollow noreferrer">table arguments</a>. Don't try to detect uniqueness at the Python level, as you can't guarantee that another process will not make the same check at the same time. The database is in a much better position to determine if you have duplicate values, without risking race conditions:</p>
<pre><code>class Worker(Base):
    __tablename__='worker'
    id = Column(Integer, primary_key=True, autoincrement=True)
    profile = Column(String(100), nullable=False)
    useragent = Column(String(100), nullable=False)

    __table_args__ = (
        UniqueConstraint("profile", "useragent"),
    )
</code></pre>
<p>or you could use a composite primary key based on the two columns; primary keys (composite or otherwise) must always be unique:</p>
<pre><code>class Worker(Base):
    __tablename__='worker'
    profile = Column(String(100), primary_key=True, nullable=False)
    useragent = Column(String(100), primary_key=True, nullable=False)
</code></pre>
</div>
<span class="comment-copy">Dear Martijn, my goal would be tu exploit this non unique aspect. In fact, workers with the same profile and useragent would have the same id. I would just check if they are already in the database , if it is not the case, i insert it , in other case, i don't. Thus, the interest of the post_init would be to get an idea of if the worker is unique or not , and proceed to the storage in the database if it is needed, base on this id.</span>
<span class="comment-copy">@HappyCloudNinja: no, they would not have the same <code>id</code>, because the <code>id()</code> is entirely dependent on the current memory layout of the current process.</span>
<span class="comment-copy">@HappyCloudNinja: if <code>profile</code> and <code>useragent</code> together must be unique, then define a constraint on those two columns together.</span>
