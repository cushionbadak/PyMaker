<div class="post-text" itemprop="text">
<p>I am using below function that I wrote in BASH to calculate time duration and decide if the duration is more than 5 minutes it returns yes,otherwise no. It is working as expected but the files I am processing are huge (millions of lines) and it takes very long time to finish the job. I am looking for some optimized way to do it. </p>
<pre><code>datediff() {
d2=$(date -d "$2" +%s)
d1=$(date -d "$3" +%s)
secs=$((d1 - d2))
impacted="no"
if [ $(($secs / 300 )) -gt 0 ]
  then
  impacted="yes"
fi
printf "%s\n" "$impacted"
}
</code></pre>
<p>I am calling this function in a while loop which is reading the input file line by line.</p>
<pre><code>while IFS=',' read -r line;
do
   IFS=',' read source almapear almclear &lt;&lt;&lt; "$line"
   echo $line, $(datediff $source "$almapear" "$almclear")
done &lt; "$1" | tee -a output_$1
</code></pre>
<p>Below is sample input file, which contains source name, alarm appear time and then alarm cleared time:</p>
<pre><code>D00O0:SOURCE3,Mon Oct 01 16:02:35 AST 2018,Mon Oct 01 16:04:19 AST 2018
D00O0:SOURCE3,Mon Oct 08 08:53:17 AST 2018,Mon Oct 08 08:54:57 AST 2018
D00O1:SOURCE3,Mon Oct 15 09:25:14 AST 2018,Mon Oct 15 09:26:59 AST 2018
D00O1:SOURCE3,Mon Oct 15 16:56:58 AST 2018,Mon Oct 15 17:58:41 AST 2018
D00O1:SOURCE3,Mon Oct 22 08:56:48 AST 2018,Mon Oct 22 09:58:31 AST 2018
D00O1:SOURCE3,Sat Oct 06 09:17:42 AST 2018,Sat Oct 06 09:19:24 AST 2018
D00O1:SOURCE3,Sat Oct 13 09:11:05 AST 2018,Sat Oct 13 09:12:47 AST 2018
D00O1:SOURCE3,Sat Oct 20 09:51:40 AST 2018,Sat Oct 20 09:53:23 AST 2018
D00O0:SOURCE3,Sat Oct 27 09:15:32 AST 2018,Sat Oct 27 09:17:11 AST 2018
D00O0:SOURCE3,Sat Sep 29 10:05:58 AST 2018,Sat Sep 29 11:07:43 AST 2018
D00O0:SOURCE3,Sun Oct 14 08:48:57 AST 2018,Sun Oct 14 09:50:43 AST 2018
D00O0:SOURCE3,Sun Oct 14 16:04:19 AST 2018,Sun Oct 14 16:06:00 AST 2018
D00O0:SOURCE3,Sun Oct 21 06:17:34 AST 2018,Sun Oct 21 06:19:17 AST 2018
D00O0:SOURCE3,Sun Oct 21 16:15:18 AST 2018,Sun Oct 21 17:17:00 AST 2018
D00O0:SOURCE3,Sun Oct 28 09:39:09 AST 2018,Sun Oct 28 09:40:47 AST 2018
</code></pre>
<p>Below is the required output:</p>
<pre><code>D00O0:SOURCE3,Mon Oct 01 16:02:35 AST 2018,Mon Oct 01 16:04:19 AST 2018,no
D00O0:SOURCE3,Mon Oct 08 08:53:17 AST 2018,Mon Oct 08 08:54:57 AST 2018,no
D00O1:SOURCE3,Mon Oct 15 09:25:14 AST 2018,Mon Oct 15 09:26:59 AST 2018,no
D00O1:SOURCE3,Mon Oct 15 16:56:58 AST 2018,Mon Oct 15 17:58:41 AST 2018,yes
D00O1:SOURCE3,Mon Oct 22 08:56:48 AST 2018,Mon Oct 22 09:58:31 AST 2018,yes
D00O1:SOURCE3,Sat Oct 06 09:17:42 AST 2018,Sat Oct 06 09:19:24 AST 2018,no
D00O1:SOURCE3,Sat Oct 13 09:11:05 AST 2018,Sat Oct 13 09:12:47 AST 2018,no
D00O1:SOURCE3,Sat Oct 20 09:51:40 AST 2018,Sat Oct 20 09:53:23 AST 2018,no
D00O0:SOURCE3,Sat Oct 27 09:15:32 AST 2018,Sat Oct 27 09:17:11 AST 2018,no
D00O0:SOURCE3,Sat Sep 29 10:05:58 AST 2018,Sat Sep 29 11:07:43 AST 2018,yes
D00O0:SOURCE3,Sun Oct 14 08:48:57 AST 2018,Sun Oct 14 09:50:43 AST 2018,yes
D00O0:SOURCE3,Sun Oct 14 16:04:19 AST 2018,Sun Oct 14 16:06:00 AST 2018,no
D00O0:SOURCE3,Sun Oct 21 06:17:34 AST 2018,Sun Oct 21 06:19:17 AST 2018,no
D00O0:SOURCE3,Sun Oct 21 16:15:18 AST 2018,Sun Oct 21 17:17:00 AST 2018,yes
D00O0:SOURCE3,Sun Oct 28 09:39:09 AST 2018,Sun Oct 28 09:40:47 AST 2018,no
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With GNU awk for time functions, this will be orders of magnitude faster than your shell loop:</p>
<pre><code>$ cat tst.awk
BEGIN {
    FS = "[, :]"
    OFS = ","

    split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec",tmp)
    for (i in tmp) {
        mth[tmp[i]] = i
    }
    maxSecs = 5 * 60
}
{
    begSecs = mktime($10" "mth[$4]" "$5" "$6" "$7" "$8)
    endSecs = mktime($18" "mth[$12]" "$13" "$14" "$15" "$16)
    print $0, ( (endSecs - begSecs) &gt; maxSecs ? "yes" : "no" )
}

$ awk -f tst.awk file
D00O0:SOURCE3,Mon Oct 01 16:02:35 AST 2018,Mon Oct 01 16:04:19 AST 2018,no
D00O0:SOURCE3,Mon Oct 08 08:53:17 AST 2018,Mon Oct 08 08:54:57 AST 2018,no
D00O1:SOURCE3,Mon Oct 15 09:25:14 AST 2018,Mon Oct 15 09:26:59 AST 2018,no
D00O1:SOURCE3,Mon Oct 15 16:56:58 AST 2018,Mon Oct 15 17:58:41 AST 2018,yes
D00O1:SOURCE3,Mon Oct 22 08:56:48 AST 2018,Mon Oct 22 09:58:31 AST 2018,yes
D00O1:SOURCE3,Sat Oct 06 09:17:42 AST 2018,Sat Oct 06 09:19:24 AST 2018,no
D00O1:SOURCE3,Sat Oct 13 09:11:05 AST 2018,Sat Oct 13 09:12:47 AST 2018,no
D00O1:SOURCE3,Sat Oct 20 09:51:40 AST 2018,Sat Oct 20 09:53:23 AST 2018,no
D00O0:SOURCE3,Sat Oct 27 09:15:32 AST 2018,Sat Oct 27 09:17:11 AST 2018,no
D00O0:SOURCE3,Sat Sep 29 10:05:58 AST 2018,Sat Sep 29 11:07:43 AST 2018,yes
D00O0:SOURCE3,Sun Oct 14 08:48:57 AST 2018,Sun Oct 14 09:50:43 AST 2018,yes
D00O0:SOURCE3,Sun Oct 14 16:04:19 AST 2018,Sun Oct 14 16:06:00 AST 2018,no
D00O0:SOURCE3,Sun Oct 21 06:17:34 AST 2018,Sun Oct 21 06:19:17 AST 2018,no
D00O0:SOURCE3,Sun Oct 21 16:15:18 AST 2018,Sun Oct 21 17:17:00 AST 2018,yes
D00O0:SOURCE3,Sun Oct 28 09:39:09 AST 2018,Sun Oct 28 09:40:47 AST 2018,no
</code></pre>
<p>Look up the man page to see which time zone it's using vs the time zone specified in your input file and how to adjust that if necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assumptions:</p>
<ul>
<li>"AST" and "ADT" are the only two time zones that can be encountered.</li>
<li>"AST" refers to UTC-4.</li>
<li>"ADT" refers to UTC-3.</li>
<li>The file is a CSV file.</li>
</ul>
<p>The solution below has the following features:</p>
<ul>
<li>It correctly handles events near DST changes.</li>
<li>It correctly parses a CSV file.</li>
<li>It correctly generates a CSV file.</li>
</ul>
<p>None of the existing solutions (including your own) can claim to have the first two features.</p>
<pre><code>#!/usr/bin/perl

use strict;
use warnings;
use feature qw( state );

use DateTime::Format::Strptime qw( );
use Text::CSV_XS               qw( );

sub parse_dt_str {
   my ($dt_str) = @_;

   state $format = DateTime::Format::Strptime-&gt;new(
      pattern =&gt; "%a %b %d %H:%M:%S %z %Y",
      locale  =&gt; "en",
   );

   $dt_str =~ s/\b(AST|ADT)\b/ $1 eq "AST" ? "-0400" : "-0300" /e;
   return $format-&gt;parse_datetime($dt_str);
}

my $csv = Text::CSV_XS-&gt;new({ auto_diag =&gt; 2, binary =&gt; 1, quote_space =&gt; 0 });
while ( my $row = $csv-&gt;getline(\*ARGV) ) {
   my $dt1 = parse_dt_str($row-&gt;[1]);
   my $dt2 = parse_dt_str($row-&gt;[2]);
   if ($dt1 &amp;&amp; $dt2) {
      $row-&gt;[3] = $dt2-&gt;epoch - $dt1-&gt;epoch &gt; 5*60 ? "yes" : "no";
   } else {
      $row-&gt;[3] = "???";
   }

   $csv-&gt;say(\*STDOUT, $row);
}
</code></pre>
</div>
<span class="comment-copy">I'm looking for optimizations as I have to process millions of lines</span>
<span class="comment-copy">Could you explain what it is you are trying to measure? I was having a little trouble grokking the intent from reading your bash code.</span>
<span class="comment-copy">the input file contains time stamps in column 2 and 3, column 2 is alarm appeared time, and column 3 is alarm cleared time. the function is calculating the difference and determining if the duration is more than 5 minutes it prints yes, else it prints no.</span>
<span class="comment-copy">Doing <i>anything</i> millions of times means you should be using something other than <code>bash</code>.</span>
<span class="comment-copy">@chepner sure, that's why I tagged awk as well or anything like Perl/python etc... Will do just fine, but am not much used to of them yet!</span>
<span class="comment-copy">I think mktime is time consuming here for huge file. It's seems it is a log file from a centralized control system. The field AST is always the same (hope for OP), you don't catch a alarm appear time from USA and alarm cleared time from France. So what can happen ? The year can change 2018 --&gt; 2019 The month can change Sep --&gt; Oct Only this two case must be handle ! After that : {a=$6$7$8;b=$14$15$16;c=(b-a)&gt;300?",yes":",no";print $0 c} my two cents.</span>
<span class="comment-copy">@ctac_ leap days and leap seconds can/do happen.</span>
<span class="comment-copy">You are right, don't think of that but I think it' more speed to handle that rather than call 2 times mktime on each line.</span>
<span class="comment-copy">Could be, idk. Leap seconds are obviously far more difficult to handle than leap days but maybe the OP doesn't care about that. A non-mktime() solution would be portable to other awks too. If it turns out to be an issue I expect the OP will post a followup question.</span>
<span class="comment-copy"><code>mktime</code> returns an epoch timestamp, which is the number of non-leap seconds since 1970 UTC. This means you're already ignoring leap seconds. I don't consider that a problem unless the file can have <code>23:59:60</code>, but that's unlikely. As for leap days, those are predictable (years divisible by 4 except those divisible by 100, and years divisible by 400).</span>
<span class="comment-copy">Note that this also works correctly if all timestamps are in AST.</span>
<span class="comment-copy">DateTime::Format::Strptime module comes built-in with perl or I have to install it? I am seeing this error when running your code: <code>Can't locate DateTime/Format/Strptime.pm in @INC (you may need to install the DateTime::Format::Strptime module) </code></span>
<span class="comment-copy">It needs to be installed. Your package manager should have it. This won't be as fast. DateTime in particular is a rather heavy --but extremely capable-- module</span>
<span class="comment-copy">you mentioned earlier that there are faster perl solutions available, won't they be as accurate?</span>
<span class="comment-copy">They would be. I just worked with that with which I'm familiar. My priority was providing a <i>correct</i> solution.</span>
