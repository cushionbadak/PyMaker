<div class="post-text" itemprop="text">
<p>I have some data either in a list of lists or a list of tuples, like this:</p>
<pre><code>data = [[1,2,3], [4,5,6], [7,8,9]]
data = [(1,2,3), (4,5,6), (7,8,9)]
</code></pre>
<p>And I want to sort by the 2nd element in the subset. Meaning, sorting by 2,5,8 where 2 is from (1,2,3), 5 is from (4,5,6). What is the common way to do this? Should I store tuples or lists in my list?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>sorted_by_second = sorted(data, key=lambda tup: tup[1])
</code></pre>
<p>or:</p>
<pre><code>data.sort(key=lambda tup: tup[1])  # sorts in place
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from operator import itemgetter
data.sort(key=itemgetter(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just want to add to Stephen's answer if you want to sort the array from high to low, another way other than in the comments above is just to add this to the line: </p>
<pre><code>reverse = True
</code></pre>
<p>and the result will be as follows:</p>
<pre><code>data.sort(key=lambda tup: tup[1], reverse=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For sorting by multiple criteria, namely for instance by the second and third elements in a tuple, let</p>
<pre><code>data = [(1,2,3),(1,2,1),(1,1,4)]
</code></pre>
<p>and so define a lambda that returns a tuple that describes priority, for instance</p>
<pre><code>sorted(data, key=lambda tup: (tup[1],tup[2]) )
[(1, 1, 4), (1, 2, 1), (1, 2, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/questions/3121979/python-sort-list-tuple-in-list/3121985#3121985">Stephen's answer</a> is the one I'd use.  For completeness, here's the DSU (decorate-sort-undecorate) pattern with list comprehensions:</p>
<pre><code>decorated = [(tup[1], tup) for tup in data]
decorated.sort()
undecorated = [tup for second, tup in decorated]
</code></pre>
<p>Or, more tersely:</p>
<pre><code>[b for a,b in sorted((tup[1], tup) for tup in data)]
</code></pre>
<p>As noted in the <a href="http://wiki.python.org/moin/HowTo/Sorting#TheOldWayUsingDecorate-Sort-Undecorate" rel="noreferrer">Python Sorting HowTo</a>, this has been unnecessary since Python 2.4, when key functions became available.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to sort a list of tuples <code>(&lt;word&gt;, &lt;count&gt;)</code>, for <code>count</code> in descending order and <code>word</code> in alphabetical order:</p>
<pre><code>data = [
('betty', 1),
('bought', 1),
('a', 1),
('bit', 1),
('of', 1),
('butter', 2),
('but', 1),
('the', 1),
('was', 1),
('bitter', 1)]
</code></pre>
<p>I use this method:</p>
<pre><code>sorted(data, key=lambda tup:(-tup[1], tup[0]))
</code></pre>
<p>and it gives me the result:</p>
<pre><code>[('butter', 2),
('a', 1),
('betty', 1),
('bit', 1),
('bitter', 1),
('bought', 1),
('but', 1),
('of', 1),
('the', 1),
('was', 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without lambda:</p>
<pre>def sec_elem(s):
    return s[1] </pre>
<pre>sorted(data, key=sec_elem) </pre>
</div>
<div class="post-text" itemprop="text">
<p>@Stephen 's answer is to the point! Here is an example for better visualization,</p>
<p><em>Shout out for the Ready Player One fans!</em> =)</p>
<pre><code>&gt;&gt;&gt; gunters = [('2044-04-05', 'parzival'), ('2044-04-07', 'aech'), ('2044-04-06', 'art3mis')]
&gt;&gt;&gt; gunters.sort(key=lambda tup: tup[0])
&gt;&gt;&gt; print gunters
[('2044-04-05', 'parzival'), ('2044-04-06', 'art3mis'), ('2044-04-07', 'aech')]
</code></pre>
<p><code>key</code> is a function that will be called to transform the collection's items for comparison.. like <code>compareTo</code> method in Java. </p>
<p>The parameter passed to key must be something that is callable. Here, the use of <code>lambda</code> creates an anonymous function (which is a callable).<br/>
The syntax of lambda is the word lambda followed by a iterable name then a single block of code. </p>
<p>Below example, we are sorting a list of tuple that holds the info abt time of certain event and actor name. </p>
<p>We are sorting this list by time of event occurrence - which is the 0th element of a tuple.</p>
<p>Note - <code>s.sort([cmp[, key[, reverse]]])</code>  sorts the items of s in place</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itemgetter()</code> is somewhat faster than <code>lambda tup: tup[1]</code>, but the increase is relatively modest (around 10 to 25 percent).</p>
<p>(IPython session)</p>
<pre><code>&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; from numpy.random import randint
&gt;&gt;&gt; values = randint(0, 9, 30000).reshape((10000,3))
&gt;&gt;&gt; tpls = [tuple(values[i,:]) for i in range(len(values))]

&gt;&gt;&gt; tpls[:5]    # display sample from list
[(1, 0, 0), 
 (8, 5, 5), 
 (5, 4, 0), 
 (5, 7, 7), 
 (4, 2, 1)]

&gt;&gt;&gt; sorted(tpls[:5], key=itemgetter(1))    # example sort
[(1, 0, 0), 
 (4, 2, 1), 
 (5, 4, 0), 
 (8, 5, 5), 
 (5, 7, 7)]

&gt;&gt;&gt; %timeit sorted(tpls, key=itemgetter(1))
100 loops, best of 3: 4.89 ms per loop

&gt;&gt;&gt; %timeit sorted(tpls, key=lambda tup: tup[1])
100 loops, best of 3: 6.39 ms per loop

&gt;&gt;&gt; %timeit sorted(tpls, key=(itemgetter(1,0)))
100 loops, best of 3: 16.1 ms per loop

&gt;&gt;&gt; %timeit sorted(tpls, key=lambda tup: (tup[1], tup[0]))
100 loops, best of 3: 17.1 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sorting a tuple is quite simple:</p>
<pre><code>tuple(sorted(t))
</code></pre>
</div>
<span class="comment-copy">With regard to "Should I store tuples or lists in my list?", a rule of thumb is to make things as immutable as possible.  If you don't <i>need</i> to modify the sublists in place, make them tuples.</span>
<span class="comment-copy">Any idea how to sort it bigger to smaller?</span>
<span class="comment-copy">@billwild : help(sorted). reverse=True.</span>
<span class="comment-copy">@Stephen using itemgetter is faster and simpler: <code>key=itemgetter(1)</code> and at the beginning of the file: <code>from operator import itemgetter</code></span>
<span class="comment-copy">Works perfectly but can anyone comment on the syntax here a bit ?</span>
<span class="comment-copy">@pacodelumberg: This should be done with the parameter <code>reverse=True</code>.</span>
<span class="comment-copy"><i>This should be the accepted answer.</i> See also <a href="https://stackoverflow.com/users/145976/charlie">Charlie</a>'s <a href="https://stackoverflow.com/a/17243726/2809027">posted timings</a>, demonstrating the <code>itemgetter</code> class to sort <b>126% faster</b> on average than the equivalent <code>lambda</code> function.</span>
<span class="comment-copy">x = [[[5,3],1.0345],[[5,6],5.098],[[5,4],4.89],[[5,1],5.97]] With a list like this is can we sort using itemgetter() with respect to elements in x[0][1] ?</span>
<span class="comment-copy">x = [[[5,3],1.0345],[[5,6],5.098],[[5,4],4.89],[[5,1],5.97]] With a list like this is, how can we sort with respect to elements in x[0][1] ?</span>
<span class="comment-copy">You can also sort by multiple indices hierarchically, e.g. <code>data.sort(key=itemgetter(3,1))</code></span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">So this answer is useful for Python 2.3-? Are there any valid uses in more-current Python versions around which you might elaborate a bit? If not, no bother...was just passing by, saw this and the old noggin got to churning just a wee bit. Anyway, cheers and thanks for this walk back into the earlier days of Python.</span>
