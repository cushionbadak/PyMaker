<div class="post-text" itemprop="text">
<p>I'm stuck on this point about class inheritance, and I haven't been able to figure out a clean way forward. I have some base class:</p>
<pre><code>class Foo:
    """ Parent class. """

    def __init__(self,a,b):
        self.a = a
        self.b = b

    def product(self):
        return self.a * self.b
</code></pre>
<p>This class contains information I've loaded in from some data file. I want to generate different kinds of information related to this data, using class properties to store that information. For example, if I wanted to create a report that tells me the quotient of a and b, I would want to create something like:</p>
<pre><code>class Bar(Foo):
    """ Child class. """

    def __init__(self,foo_object):

        # What I want to avoid:
        self.a = foo_object.a
        self.b = foo_object.b

    def quotient(self):
        return self.a / self.b
</code></pre>
<p>Obviously there are many more class properties in my real application. It becomes very tedious to assign all of the properties from the Foo object into the new Bar object.</p>
<p>Is there a more elegant way to "extend" a Foo object into a Bar object once the Foo object has already been created?</p>
<p>EDIT:</p>
<p>Sorry if I didn't state my objective clearly enough; I see that there's some confusion about what I'm asking for. I've already created a Foo object with a number of properties. I want to create a child class of Foo, called Bar, <em>later,</em> that contains those properties but also some additional properties that are specific to one "area" of my application.</p>
<p>So, I want to be able to pass in an already instantiated Foo object, and pass the values of its properties into identical properties in Bar, without doing this manually item-by-item.</p>
<p>I believe Flob's answer is what I'm looking for. Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can inherit the Information directly by initiating the parent class inside the child class. Once you have created an instance of the parent class, you can Access all it's properties by using <code>vars(object)</code>, which will return a dictionary of all properties assiciated with the object. For example, let's say you have a class <code>Foo</code>:</p>
<pre><code>class Foo:
    def __init__(self, a, b):
        self.a = a
        self.b = b
</code></pre>
<p>and <code>test_parent</code> is an instance of this class.</p>
<pre><code>test_parent = Foo(a='Hello', b='World')
</code></pre>
<p>now, when creating the <code>Bar</code> child class, do it like this:</p>
<pre><code>class Bar(Foo):
    def __init__(self, foo_object):
        a, b = vars(foo_object).values()  #get all properties of parent class object
        Foo.__init__(self, a, b)  # initiate parent class
    def say_hello(self):
        print('{} {}'.format(self.a, self.b))
</code></pre>
<p>Create an instance of the <code>Bar</code> class and call <code>say_hello</code>:</p>
<pre><code>test_child = Bar(test_parent)
test_child.say_hello()
</code></pre>
<p>Output:</p>
<pre><code>"Hello World"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure I understand what you mean by "once the <code>Foo</code> object has already been created".</p>
<p>For initialization of the attributes defined by the parent class, use this:</p>
<pre><code>class Bar(Foo):
    """ Child class. """

    def __init__(self,a,b):
        super().__init__(a,b)

    def quotient(self):
        return self.a / self.b
</code></pre>
<p>Let the <code>__init__()</code> method of the super-class continue to do its job of initializing <code>a</code> and <code>b</code>.</p>
<p>Note that <code>b = B()</code> creates only one object, not two.</p>
<hr/>
<p>In the code you posted, <code>Bar.__init__()</code> seems to take a <code>Foo</code> object as one of its arguments. Technically, that is a case of <strong>wrapping</strong> a <code>Foo</code> object in a <code>Bar</code> object -- and if you're doing that, there really is no need for <code>Bar</code> to be a child class of <code>Foo</code>:</p>
<pre><code>class Bar:
    """ Wrapper class. """

    def __init__(self, foo_object):
        self.foo_object = foo_object

    def quotient(self):
        return self.foo_object.a / self.foo_object.b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to change the class of the object after it is created.  Instead of unpacking the contents of the object into a new one, you change the class that it uses to look up methods:</p>
<pre><code>class Foo:
    def __init__(self, a, b):
        self.a = a
        self.b = b

class Bar(Foo):
    def quotient(self):
        return self.a/self.b

f = Foo(1, 2)
f.__class__ = Bar
f.quotient()  # 0.5
</code></pre>
<p>This usually isn't necessary (I woudln't recommend using it here).  Instead, you could create a <code>Bar</code> object directly:</p>
<pre><code>b = Bar(1, 2)
b.quotient()
</code></pre>
<p><code>Bar</code> inherits the <code>__init__</code> method of <code>Foo</code>, so you don't have to redefine it.</p>
<p>Another option is to use a function that's not a method:</p>
<pre><code>def quotient(obj):
    return obj.a/obj.b
</code></pre>
<p>Now you can compute <code>quotient(Foo(1,2))</code> even though your <code>Foo</code> object doesn't know about the <code>quotient</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>A class can inherit from a base class, but an object cannot inherit from another object. It can either be a copy (with possibly additional attributes) or <em>wraps</em> the original object. The first case is for a true inheritance strategy (the child instance has to <strong>be</strong> an instance of the base class and must initialize itself), the second if for an aggregation or containment strategy.</p>
<p>But beware, there are some caveats with the second one, mainly because the <em>child</em> object is not an instance of the base class (<code>isinstance(child, Foo)</code> is false). That means that there is no one size fits all way here, and you will have to choose one pattern, inheritance vs aggregation.</p>
</div>
<span class="comment-copy">One option, instead of doing <code>self.a; self.b</code> do <code>self.value = {'a':1, 'b':2}</code> which allows <code>Bar.value = copy(Foo.value)</code></span>
<span class="comment-copy">Why don't you just add a <code>quotient</code> method to class <code>Foo</code>?</span>
<span class="comment-copy">Goyo, I'd like to keep the child methods separate, since in my application there will be a number of versions of Bar that may be instantiated based on what the user asks for (Foo contains information about raw data that has been collected, while Bar contains the results of specific calculations on that data). I don't want things to get too messy, since the user will be able to generate a number of different reports from the raw data.</span>
<span class="comment-copy">This is exactly what I'm looking for! Thank you! As you've shown, I just need to get the properties of the Foo object and pass them in when I init the parent. Apologies to others if I wasn't clear enough on this point, I will edit my question to clarify.</span>
<span class="comment-copy"><code>Foo.__init__(self,a,b)</code> can be replaced with <code>super().__init__(a, b)</code> (assuming python 3)</span>
<span class="comment-copy">@RobinNemeth: Thanks, edited.</span>
