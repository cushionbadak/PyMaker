<div class="post-text" itemprop="text">
<p>Care needs to be taken when checking for equality between floating point numbers, and should usually be done with a tolerance in mind, using e.g. <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html" rel="nofollow noreferrer">numpy.allcose</a>.</p>
<p><strong>Question 1:</strong> Is it safe to check for the occurrence of a specific floating point number using the "in" keyword (or are there similar keywords/functions for this purpose)? Example:</p>
<pre><code>if myFloatNumber in myListOfFloats:
  print('Found it!')
else:
  print('Sorry, no luck.')
</code></pre>
<p><strong>Question 2:</strong> If not, what would be a neat and tidy solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't compute your floats in the same place or with the exact same equation, then you might have false negatives with this code (because of rounding errors). For example: </p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; 0.1 + 0.2 in [0.6/2, 0.3]  # We may want this to be True
False
</code></pre>
<p>In this case, we can just have a custom "<code>in</code>" function that will actually make this true (in this case it may be better/faster to use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.isclose.html#numpy.isclose" rel="nofollow noreferrer"><code>numpy.isclose</code></a> instead of <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html" rel="nofollow noreferrer"><code>numpy.allclose</code></a>): </p>
<pre class="lang-py prettyprint-override"><code>import numpy as np 

def close_to_any(a, floats, **kwargs):
  return np.any(np.isclose(a, floats, **kwargs))
</code></pre>
<p>There is an important note in the documentation: </p>
<blockquote>
<p><strong>Warning</strong>
  The default <code>atol</code> is not appropriate for comparing numbers that are much smaller than one (see Notes).
  [...]
  if the expected values are significantly smaller than one, it can result in false positives.</p>
</blockquote>
<p>The note adds that <code>atol</code> is not zero contrary to <a href="https://docs.python.org/dev/library/math.html#math.isclose" rel="nofollow noreferrer"><code>math.isclose</code></a>'s <code>abs_tol</code>. If you need a custom tolerance when using <code>close_to_any</code>, use the <code>kwargs</code> to pass <code>rtol</code> and/or <code>atol</code> down to numpy. In the end, your existing code would translate to this: </p>
<pre class="lang-py prettyprint-override"><code>if close_to_any(myFloatNumber, myListOfFloats):
  print('Found it!')
else:
  print('Sorry, no luck.')
</code></pre>
<p>Or you could have some options <code>close_to_any(myFloatNumber, myListOfFloats, atol=1e-12)</code>, note that <code>1e-12</code> is arbitrary and you shouldn't use this value unless you have a good reason to.</p>
<p>Coming back to the rounding error we observed in the first example, this would give: </p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; close_to_any(0.1 + 0.2, [0.6/2, 0.3])
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Q1:
Depends on how you are going to implement this. But as others mentioned with floats its not such a good idea to use <code>in</code> operator.</p>
<p>Q2:
Do you have any restrictions performance-wise?
Will <code>myListOfFloats</code> be sorted?</p>
<p>If it is a sorted list of float values and if you need to do it as fast as you possibly can, you can implement a <a href="https://stackoverflow.com/questions/9501337/binary-search-algorithm-in-python">binary search</a> algorithm.</p>
<p>If the data is not sorted, depending on the ratio between number of queries you will be making and the size of the data, you might want to sort the data and keep it sorted.</p>
<p>If you dont have any requirements on performance and speed you can use the following example as a basis:</p>
<pre><code>def inrng(number1,number2,prec):
   if(abs(number1-number2)&lt;prec):
      return True
   else:
      return False


precision=0.001
for i in myListOfFloats:
   if(inrng(i,myInputNumber,precision)):
      #do stuff
</code></pre>
</div>
<span class="comment-copy">Yeaass, why do you get a bad vibe for it?</span>
<span class="comment-copy">I think the remark is valid if you compute <code>myFloatNumber</code> with a different formula than for the elements of <code>myListOfFloats</code>. If you get these number with the exact same code then all errors will be the same and you won't have any problem.</span>
<span class="comment-copy">Or perhaps a sampl I/O would do it</span>
<span class="comment-copy">Yes you have to be careful with this, for instance <code>3.4 in [3.45, 5] -&gt; False</code>. One option is to cut all floats in the list up to the legnth of the float in question using the  <code>decimal</code> module and check then if it is in the list</span>
<span class="comment-copy">Tidy solution: <code>np.isclose(&lt;your_array&gt;, &lt;your_ref_value&gt;).any()</code>. You can pass tolerances to <code>isclose</code> if needed.</span>
<span class="comment-copy">Thank you for the code example. I wonder why there is no official keyword / numpy function for this already...</span>
<span class="comment-copy">I think that it would make sense for such a function to exist, but on the other hand if you look at my edit, this is basically a combination of <code>np.allclose</code> and <code>any</code>. I tried to find it in the documentation but I think it doesn't exist.</span>
