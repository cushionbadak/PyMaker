<div class="post-text" itemprop="text">
<p>I've been trying a variety of methods for several days but appear to be missing some key ingredient. I'm trying to create an array of C-structs and populate those structs from a Python dictionary. I would like to capture that in a class definition or some global function as I will use it from multiple places in my code.</p>
<p>Per request, I have deconstructed the code into its minimum version and put it all in one file:</p>
<pre class="lang-py prettyprint-override"><code>FOO_BOOL    = 1
FOO_BYTE    = 2
FOO_STRING  = 3

cdef union Data:
    bint flag
    int byte
    char *string

ctypedef struct bar_t:
    char name[512]
    int type
    Data data

cdef class BarArray:
    cdef bar_t *array;
    cdef size_t nbars;

    def __cinit__(self, number):
        self.array = &lt;bar_t*&gt;malloc(number * sizeof(bar_t))
        if not self.array:
            raise MemoryError()
        self.nbars = number

    def load(self, keyvals:dict):
        kvkeys = list(keyvals.keys())
        if len(kvkeys) &gt; &lt;int&gt;self.ninfo:
            # this should never happen except in development
            # so raise an error to let them know
            raise IndexError()
        n = 0
        for key in kvkeys:
            if keyvals[key][1] == 'bool':
                self.array[n].type = FOO_BOOL
                self.array[n].data.flag = keyvals[key][0]
            elif keyvals[key][1] == 'byte':
                self.array[n].type = FOO_BYTE
                self.array[n].data.byte = keyvals[key][0]
            elif keyvals[key][1] == 'string':
                self.array[n].type = FOO_STRING
                if isinstance(keyvals[key][0], str):
                    pykey = keyvals[key][0].encode('ascii')
                else:
                    pykey = keyvals[key][0]
                try:
                    self.array[n].data.string = strdup(pykey)
                except:
                    raise ValueError("String value declared but non-string provided")
            else:
                raise TypeError("UNRECOGNIZED VALUE TYPE")
            n += 1

    @property
    def array(self):
        return self.array

    @property
    def nbars(self):
        return self.nbars


cdef class FooClass():
    cdef bar_t *array
    cdef size_t sz
    def __cinit__(self, sz):
        self.bar = BarArray(sz)

    def loadarray(self, keyvals:dict):
        self.bar.load(keyvals)
        self.array = &lt;bar_t*&gt;self.bar.array
        while n &lt; self.sz:
            print("INFO [", n, "]: ", self.array[n].name, self.array[n].type)
            n += 1
</code></pre>
<p>When attempting to compile, I get the following errors:</p>
<pre class="lang-sh prettyprint-override"><code>warning: foobar.pyx:28:16: cdef variable 'array' declared after it is used

Error compiling Cython file:
------------------------------------------------------------
...
                raise TypeError("UNRECOGNIZED VALUE TYPE")
            n += 1

    @property
    def array(self):
        return self.array
                  ^
------------------------------------------------------------

foobar.pyx:67:19: Cannot convert 'bar_t *' to Python object
</code></pre>
<p>I read in one place where you have to cast that return to a , but that also generates an error. I eventually managed to find a way past the compile error, but the returned array contained garbage.</p>
<p>Any suggestions would be appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't really make sense to send a pointer back to Python (hence the error you're seeing). What I think you want to do is define the Python accessor functions <code>__setitem__</code> and <code>__getitem__</code>:</p>
<pre><code>def __getitem__(self, int idx):
    if idx&gt;=self.nbars:
        raise IndexError("Helpful error message about index being out of range")
    result = dict(name=self.array[idx].name)
    if self.array[idx].type == FOO_BOOL:
        result['flag'] = bool(self.array[idx].data.flag)
    elif self.array[idx].type == FOO_BYTE:
        result['byte'] = self.array[idx].data.byte
    elif self.array[idx].type == FOO_BOOL:
        result['string'] = self.array[idx].data.string
    else: 
        raise ValueError("Some helpful message?")
    return result

def __setattr__(self,int idx, value):
    cdef bar_t value_c
    if idx&gt;=self.nbars:
        raise IndexError("")
    value_c.name = value['name'] # you might need to do a string copy here
                       # and you definitely want to check the length
    if 'flag' in value:
        value_c.data.bool = 1 if value['flag'] else 0
        value_c.type = FOO_BOOL
    elif 'byte' in value:
        value_c.data.byte = value['byte']
        value_c.type = FOO_BYTE
    elif 'string' in value:
        # Allocate memory for and copy the string
        value_c.type = FOO_STRING
    else:
        raise ValueError("...")

    # Deallocate any data held by existing self.array[idx]!
    self.array[idx] = value_c
</code></pre>
<p>Note that you need to be careful of memory management. Because you can't rely on pointers to the data held in Python strings continuing to exist you need to allocate the memory for them yourself. This also means you need to ensure it's deallocated when the class is destructed, or when you replace an array element. I've skipped writing this code because it very much depends on the C library you're using.</p>
</div>
<span class="comment-copy">90% of your code isn’t needed to reproduce the issue, please create a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>. The fact that there are multiple error messages is a tell, that the example isn’t minimal..</span>
<span class="comment-copy">My initial thought is that you should be using <code>pxi</code> files - you want a <code>pxd</code> file containing the class definition (but not the implementation code) instead of a <code>pxi</code> file which is a literal textual include like a C header. But ead's point is correct.</span>
<span class="comment-copy">I didn't try to break the code down as I wasn't seeking a detailed answer, but rather advice on how one might generically perform the desired operation. However, I can certainly try to create a simplified example if that's required.</span>
<span class="comment-copy">Thanks - this helps! I do actually call strdup on the <code>encode</code> string as I recognized the temporary nature of that data. This was a stripped down version of the program and the memory management is most of what I removed. However, I definitely appreciate the reminder! I'll take a crack at this and see if I can move it forward.</span>
<span class="comment-copy">I'd somehow missed the significance of <code>strdup</code> - I've edited the post to soften the warning since it looks like you're taking care of it. Hopefully the outline will be useful anyway</span>
