<div class="post-text" itemprop="text">
<p>lets say I've 2 tables users and devices. They have relation one-to-many.
In Sql, I can solve the mentioned problem by following query.</p>
<pre><code>SELECT
    users.*, devices.*
FROM
    users

    LEFT JOIN ( SELECT d1.*
        FROM devices as d1
        LEFT JOIN devices AS d2
             ON d1.user_id = d2.user_id AND d1.date &lt; d2.date
        WHERE d2.user_id IS NULL ) as device_temp

    ON (users.id = device_temp.user_id)
</code></pre>
<p><strong>Here is my python code</strong></p>
<pre><code>#user_model.py

from sqlalchemy import Column, ForeignKey, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy import create_engine

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    first_name = Column(String(500), nullable=False)
    last_name = Column(String(250), nullable=False)
</code></pre>
<p><strong>device_model.py</strong></p>
<pre><code>#device_model.py

from sqlalchemy import Column, ForeignKey, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, relation
from sqlalchemy import create_engine


from user_model import User 
Base = declarative_base()

class DeviceModel(Base):
    __tablename__ = 'device'

    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime(), nullable=False)
    device_id = Column(String(250), nullable=False)
    user_uid = Column(String, ForeignKey((User.id)))
    owner = relation(User, backref='user_device')
</code></pre>
<p><strong>run.py</strong></p>
<pre><code>#run.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker


from user_model import User, Base
from sleep_session import SleepSession, Base
from device_model import DeviceModel, Base

engine = create_engine(connection_string)
Base.metadata.bind = engine

DBSession = sessionmaker(bind=engine)

session = DBSession()
query = session.query(User,DeviceModel).join(DeviceModel)
results = query.all()

for row in results:
        print(row.User.first_name +" "+ row.DeviceModel.device_id + " "+ str(row.DeviceModel.created_at)) 
</code></pre>
<p>I know this type of question is asked multiple times, but I could not find one with SqlAlchemy ORM.
I want the same result  <a href="https://murrayhopkins.wordpress.com/2008/10/28/mysql-left-join-on-last-or-first-record-in-the-right-table/" rel="nofollow noreferrer">as described here</a></p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I used this question to practive sqlalchemy as I'm new to it.
Closest answer I can get is the following:</p>
<p><em>If you want to see 1 file full workable code go into the edits - I'll remove boilerplate code</em> </p>
<pre><code>from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy import Column, ForeignKey, Integer, String, DateTime
from sqlalchemy.orm import relationship, relation
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

connection_string = 'postgres://postgres:password@localhost/test'

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    first_name = Column(String(500), nullable=False)
    last_name = Column(String(250), nullable=False)

class DeviceModel(Base):
    __tablename__ = 'device'

    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime(), nullable=False)
    device_id = Column(String(250), nullable=False)
    user_uid = Column(Integer, ForeignKey((User.id))) # error Key columns "user_uid" and "id" are of incompatible types: character varying and integer.
    owner = relation(User, backref='user_device')


engine = create_engine(connection_string)
Base.metadata.bind = engine

#User.__table__.create(engine)
#DeviceModel.__table__.create(engine)

DBSession = sessionmaker(bind=engine)
session = DBSession()
</code></pre>
<p>My Answer:</p>
<pre><code>from sqlalchemy import and_, or_
from sqlalchemy.orm import aliased

DeviceModel2 = aliased(DeviceModel)

subquery = (session
    .query(DeviceModel.created_at)
    .outerjoin(DeviceModel2, 
      and_(DeviceModel.user_uid == DeviceModel2.user_uid,
        DeviceModel.created_at &lt; DeviceModel2.created_at))
    .filter(DeviceModel2.user_uid == None)
    .subquery('subq'))

query = (session
    .query(User, DeviceModel)
    .outerjoin(DeviceModel)
    .filter(or_(
        DeviceModel.created_at == subquery.c.created_at,
        DeviceModel.id == None)))

print(query)
results = query.all()


for row in results:
    if row[1]:
        print({**row.User.__dict__, **row.DeviceModel.__dict__})
    else:
        print(row.User.__dict__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from db_config import connection_string 

from sqlalchemy import create_engine ,  and_ , inspect
from sqlalchemy.orm import sessionmaker, aliased

from user_model import User, Base
from device_model import DeviceModel, Base

engine = create_engine(connection_string)
Base.metadata.bind = engine
DBSession = sessionmaker(bind=engine)    

session = DBSession()
DeviceModel_aliased = aliased(DeviceModel)

#make sub-query
query_for_latest_device = session.query(DeviceModel).\
        outerjoin(DeviceModel_aliased,
                and_(DeviceModel_aliased.user_uid == DeviceModel.user_uid,
                        DeviceModel_aliased.created_at &gt; DeviceModel.created_at)).\
        filter(DeviceModel_aliased.id == None).\
        subquery()

use_subquery_and_join = session.query(User.first_name,latest_device).\
        join(query_for_latest_device,
            query_for_latest_device.c.user_uid == User.user_id).\
        all()

for row in join_user_and_device:
    print(row._asdict())
</code></pre>
</div>
<span class="comment-copy">Here's one example of a greatest-n-per-group for MySQL: <a href="https://stackoverflow.com/questions/47983152/sqlalchemy-orm-sum-of-products" title="sqlalchemy orm sum of products">stackoverflow.com/questions/47983152/â€¦</a>, if it's any help.</span>
<span class="comment-copy">thanks for your comment. It worked.</span>
<span class="comment-copy">I'd propose a split so that the actual solution is more easy to find.</span>
<span class="comment-copy">thanks for your suggestion Andrew, actually lija's answer worked for me.</span>
