<div class="post-text" itemprop="text">
<p>I'm generating in python uuid4 strings.</p>
<p>I use it to identify my service accounts, but one of my systems (GCP service accounts) has a 30 char limit, and it's too late to use something else :</p>
<pre><code>Service account ID must be between 6 and 30 characters.
Service account ID must start with a lower case letter, followed by one or more lower case alphanumerical characters that can be separated by hyphens.
</code></pre>
<p>How can I have a shorter version of the UUID with a limited conflict risk ?</p>
<p>I've seen some base64 encoding hacks, but the shortest I can do is 22. Ideally, I would have something like git commit hash since the risk of conflict is limited.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How can I have a shorter version of the UUID with a limited conflict risk?</p>
</blockquote>
<p>Drop the character at index 12 since that is always a 4 - <a href="https://xkcd.com/221/" rel="nofollow noreferrer">not very random</a>.</p>
<p>Similarly drop the character at index 16 since it's always in 8 9 a b.  </p>
<p>You'll be left with 30 fairly random characters in [0-9a-f]. Collisions are still small enough to ignore.  Note that uuid4s may start with numbers, so you may need to use rejection sampling in your generator (or just cut out the middleman and generate your ids directly with <code>random</code>, realistically there is not much point to use uuid4 at all here).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the first 15 characters and the last 15 characters of the UUID. Omit everything in between.</p>
<pre><code>import uuid

uuid_str = str(uuid.uuid4()).replace("-","")
uuid_str = uuid_str[:15]+uuid_str[-15:]
</code></pre>
</div>
<span class="comment-copy">What kinds of characters does the system allow? Arbitrary Unicode code points? Arbitrary bytes? ASCII? Some subset of printable ASCII?</span>
<span class="comment-copy">And if you already know how to get it down to 22 characters, what's the problem?</span>
<span class="comment-copy">It's google service account :  Service account ID must be between 6 and 30 characters. Service account ID must start with a lower case letter, followed by one or more lower case alphanumerical characters that can be separated by hyphens.   I'll go with the 22 if I don't have any other choice, but it doesn't left a lot of room for human readable text.</span>
<span class="comment-copy"><code>uuid.uuid4</code> goes through <code>os.urandom</code>, which is likely to be a lot more collision-resistant than most naive implementations through the <code>random</code> module. (It's straightforward to get the same strength out of <code>random</code> using <code>random.SystemRandom</code>, but I wouldn't trust most people to remember the <code>SystemRandom</code> part.)</span>
<span class="comment-copy">Can you explain how this retains the uuid's properties?</span>
<span class="comment-copy">@snakecharmerb I don't know what you mean. UUID isn't guaranteed to be unique. There is a non-zero chance that it isn't unique.  My suggestion retains all those properties - but because he wants less chars the possibility of conflict goes up.  If you mean keeping the format then it doesn't matter since either he can't use UUID or he has to truncate it anyway. If he really cares about the version and significant bits he can just take the generated UUID and remove the hyphens + the last two characters.</span>
<span class="comment-copy">This is a pretty bad choice of characters to take. For example, you kept 3 hyphens.</span>
<span class="comment-copy">@user2357112 You're right the hyphens would increase the odds of collision.</span>
<span class="comment-copy"><code>str(uuid.uuid4()).replace("-","")</code> is a dumb way to do <code>uuid.uuid4().hex</code>.</span>
