<div class="post-text" itemprop="text">
<p><strong>Suppose I have 3 tfrecord files, namely <code>neg.tfrecord</code>, <code>pos1.tfrecord</code>, <code>pos2.tfrecord</code>.</strong></p>
<p><strong>My batch size is 500, including 300 neg data, 100 pos1 data, and 100 pos2 data. How can I get the desired TFRecordDataset?</strong></p>
<p>I will use this TFRecordDataset object in keras.fit() (Eager Execution).</p>
<p>My tensorflow's version is 1.13.1. I find the API in <a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="nofollow noreferrer">tf.data.Dataset</a>, such as <code>interleave</code>, <code>concatenate</code>, <code>zip</code>, but it seems that I can't solve my problem.</p>
<p>Before, I tried to get the iterator for each dataset, and then manually concat after getting the data, but it was inefficient and the GPU utilization was not high.</p>
<p>And in this <a href="https://stackoverflow.com/questions/55154836/how-to-combine-multiple-datasets-into-one-dataset/55155937?noredirect=1#comment97059416_55155937">question</a>, I use <code>interleave</code> below:</p>
<pre class="lang-py prettyprint-override"><code>tfrecord_files = ['neg.tfrecord', 'pos1.tfrecord', 'pos2.tfrecord']
dataset = tf.data.Dataset.from_tensor_slices(tfrecord_files)
def _parse(x):
    x = tf.data.TFRecordDataset(x)
    return x
dataset = dataset.interleave(_parse, cycle_length=4, block_length=1)
dataset = dataset.apply(tf.data.experimental.map_and_batch(_parse_image_function, 500))
</code></pre>
<p>and I got this batch:</p>
<pre><code>neg pos1 pos2 neg pos1 pos2 ...............
</code></pre>
<p>But what I want is this:</p>
<pre><code>neg neg neg pos1 pos2 neg neg neg pos1 pos2 .................
</code></pre>
<p>What I should do?</p>
<p>Looking forward to answering.</p>
</div>
<div class="post-text" itemprop="text">
<p>I reproduced something like what you said using string data:</p>
<pre><code>import tensorflow as tf

def string_data(s):
    return tf.sparse.to_dense(tf.strings.split([s]), default_value='')[0]

data = [' '.join(['neg'] * 30), ' '.join(['pos1'] * 10), ' '.join(['pos2'] * 10)]
step_sizes = tf.constant([3, 1, 1], dtype=tf.int64)
ds = (tf.data.Dataset.from_tensor_slices((data, step_sizes))
      .interleave(lambda d, s: (tf.data.Dataset.from_tensor_slices(string_data(d))
                                .batch(s)),
                  cycle_length=len(data))
      .flat_map(tf.data.Dataset.from_tensor_slices))
iter = ds.make_one_shot_iterator().get_next()

with tf.Session() as sess:
    while True:
        try:
            print(sess.run(iter).decode(), end=', ')
        except tf.errors.OutOfRangeError: break
    print()
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, neg, neg, neg, pos1, pos2, 
</code></pre>
<p>In the real use case you would replace <code>data</code> with the list of file names and <code>tf.data.Dataset.from_tensor_slices(string_data(d))</code> with <code>tf.data.TFRecordDataset(d)</code>, but otherwise it should work similarly.</p>
<p>EDIT: I just realised that you actually wanted a batch of all elements ordered in that way, not just one element at a time, so I suppose you would have to add another <code>batch</code> call at the end.</p>
</div>
