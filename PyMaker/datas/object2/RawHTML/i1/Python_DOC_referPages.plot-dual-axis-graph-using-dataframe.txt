<div class="post-text" itemprop="text">
<p>I have a DataFrame that looks like this: </p>
<pre><code>                state   runtime   pixels  segments
0                 Texas  0.079277  1756374     12960
1            California  0.045553  1221211      5129
2          Rhode Island  0.002466     8134      1247
3            Washington  0.016046   339786      6854
4               Alabama  0.009114   214936      1930
5  District of Columbia  0.000799      506       218
6                  Ohio  0.007617   192800      2949
</code></pre>
<p>I am trying to plot this DataFrame with a dual y-axis along a shared x-axis (runtime)</p>
<p>I have done this with the below code: </p>
<pre><code>import pandas as pd
import matplotlib.pyplot as plt
from pylab import figure, show, legend, ylabel

data = pd.read_excel('runtimes.xlsx')

## create the general figure
fig1 = figure()

ax1 = fig1.add_subplot(111)
ax1.plot(data[['runtime', 'pixels']].T)

ax1.set_ylabel('Pixels')
ax1.set_xlabel('Runtime (s)')

ax2 = ax1.twinx()

ax2.plot(data[['runtime', 'segments']].T)
ax2.set_ylabel('Segments', color='r')
for tl in ax2.get_yticklabels():
    tl.set_color('r')
</code></pre>
<p>Which gives me this graph: 
<a href="https://i.stack.imgur.com/514IS.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/514IS.png"/></a></p>
<p>There are two problems I am trying to fix:
(1) This plots each row twice when I only want it to plot once - how can I fix this?
(2) How can I add a legend so you can tell which line indicates its proper state?</p>
</div>
<div class="post-text" itemprop="text">
<p>I find that it is usually easier to be explicit about the columns, instead of allowing pandas to do everything automatically, for these kinds of cases. E.g.</p>
<pre><code>ax1.scatter(data['runtime'], data['pixels'])
</code></pre>
<p>and</p>
<pre><code>ax2.scatter(data['runtime'], data['segments'])
</code></pre>
<p>For a complete example demonstrating this:</p>
<pre><code>import pandas as pd
import matplotlib.pyplot as plt
from pylab import figure, show, legend, ylabel

data = pd.DataFrame({'runtime': [0.079277, 0.045553, 0.002466, 0.016046, 0.009114,
                                 0.000799, 0.007617],
                     'pixels':  [1756374, 1221211, 8134, 339786, 214936, 506, 192800],
                     'segments':[12960, 5129, 1247, 6854, 1930, 218, 2949]})

## create the general figure
fig1 = figure()

ax1 = fig1.add_subplot(111)
ax1.scatter(data['runtime'], data['pixels'], label="Pixels", marker='.', color='k')

ax1.set_ylabel('Pixels')
ax1.set_xlabel('Runtime (s)')

ax2 = ax1.twinx()

ax2.scatter(data['runtime'], data['segments'], label="Segments", marker='.', color='r')
ax2.set_ylabel('Segments', color='r')
for tl in ax2.get_yticklabels():
    tl.set_color('r')
fig1.legend(bbox_to_anchor=(0.225,0.845))
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/C5TvL.png" rel="nofollow noreferrer"><img alt="Shared X example" src="https://i.stack.imgur.com/C5TvL.png"/></a></p>
<p>You may also note the legend, you can change the location as you want by changing the <code>bbox_to_anchor</code> tuple, <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html" rel="nofollow noreferrer">docs</a></p>
<hr/>
<p><strong>Edit</strong></p>
<p>If you need to color based on state then you can do something like this</p>
<pre><code>import pandas as pd
import matplotlib.pyplot as plt
from pylab import figure, show, legend, ylabel
import matplotlib.lines as mlines

data = pd.DataFrame({'state':   ["Texas", "California", "Rhode Island", "Washington", 
                                 "Alabama", "District of Columbia", "Ohio"],
                     'runtime': [0.079277, 0.045553, 0.002466, 0.016046, 
                                 0.009114, 0.000799, 0.007617],
                     'pixels':  [1756374, 1221211, 8134, 339786, 214936, 506, 192800],
                     'segments':[12960, 5129, 1247, 6854, 1930, 218, 2949]})

## create the general figure
fig1 = figure()

ax1 = fig1.add_subplot(111)
ax2 = ax1.twinx()
for ii in range(len(data['state'])):
    ax1.scatter(data['runtime'][ii], data['pixels'][ii], 
                label=data['state'][ii], marker='.')
    ax2.scatter(data['runtime'][ii], data['segments'][ii], marker='+')
ax1.set_ylabel('Pixels')
ax1.set_xlabel('Runtime (s)')
legend = fig1.legend(bbox_to_anchor=(0.3,0.845))
m1 = mlines.Line2D([], [], color='black', linewidth = 0, marker='.', label='Pixels')
m2 = mlines.Line2D([], [], color='black', linewidth = 0, marker='+', label='Segments')
plt.legend(handles=[m1,m2], loc='lower right')


ax2.set_ylabel('Segments', color='r')
for tl in ax2.get_yticklabels():
    tl.set_color('r')
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/DR9jc.png" rel="nofollow noreferrer"><img alt="Example with coloring" src="https://i.stack.imgur.com/DR9jc.png"/></a></p>
</div>
<span class="comment-copy">Thanks for your answer! Any ideas why i'm still seeing 12 points there however? I'm expecting to see 6</span>
<span class="comment-copy">@Hana I'm not sure what you mean - there should not be 6 points, there are two different relationships being shown, <code>runtime</code> vs <code>pixels</code> and <code>runtime</code> vs <code>segments</code>, each of which creates 6 independent points. You can't reduce them the <code>segments</code> and <code>pixels</code> value to a single point relative to the <code>runtime</code> unless <code>segments</code> depends on <code>pixels</code> or vice versa. You can however do something like in the edit shown.</span>
<span class="comment-copy">ah, got it, thank you for the edit!</span>
<span class="comment-copy">@Hana No problem, thanks for the accept</span>
