<div class="post-text" itemprop="text">
<p>I have a price list of all securities on Friday. some the securities keep the same price on Saturday as Friday. I want to copy the prices of Friday to Saturday for the security prices listed not on Saturday.</p>
<p>I tried to do this task by using pandas <code>merge</code> as follows.</p>
<p>I do <code>outer</code> Join for the two data frames as follows with setting <code>Indicator</code> as <code>True</code>.</p>
<pre><code># df_friday has 10 securities
# df _saturday has 3 securities
merge_df=pd.merge(df_friday,df_saturday,on='security',how="outer",indicator=True)

merge_df = merge_df[merge_df['_merge']=='left_only']
merge_df =merge_df.drop(['price_y','_merge'],axis=1)
merge_df = merge_df.rename(columns = {'price_x':'price'})

df_saturday = pd.concat([df_saturday,merge_df],ignore_index=True)
</code></pre>
<p>My columns of the two data frames are the same,</p>
<pre><code>Columns: [security, price]
</code></pre>
<p>Did I do it correct way? Or Could I do that in a simple way?</p>
<p>For Example,</p>
<pre><code># df_friday
  security price
1 apple    35.25
2 reliance  25.5
3 samsung   12.5
4 tata      28.5
5 sony      30.2

# df_saturday
  security price
1 reliance  26.8
2 samsung   11.2

# df_saturday_result should be as follows,
  security price
1 reliance  26.8
2 samsung   11.2
3 apple    35.25
4 tata      28.5
5 sony      30.2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Did some timing checks on the 3 methods mentioned in the other answers.</p>
<pre><code>fri =pd.DataFrame (columns =['security', 'price'], index = range(3), data =[['a',2],['b',4],['c',6]] )
sat =pd.DataFrame (columns =['security', 'price'], index = range(2), data =[['a',3],['c',5]] )
</code></pre>
<pre class="lang-py prettyprint-override"><code>In [90]: %timeit out = sat.merge(fri, how='outer', on=['security', 'price']).drop_duplicates()
5.19 ms ± 150 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [91]: %timeit result_1 = pd.concat([sat,fri],ignore_index=True).drop_duplicates(subset=['security'], keep='first')
1.82 ms ± 26.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [92]: %timeit result_2 = pd.concat([sat, fri[~fri.security.isin(sat.security)]], ignore_index=True)
1.19 ms ± 113 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [93]: %timeit out = sat.merge(fri, how='outer', on=['security', 'price']).drop_duplicates()
5.02 ms ± 181 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>It looks like filtering then concatenating is the fastest, while concat then dedup isn't too far bad. The merge is pretty slow in comparison.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you can do </p>
<pre><code>df_saturday = df_saturday.merge(df_friday, how='outer', on=['security','price']).drop_duplicates(['security'], keep='first')

print(df_saturday)
</code></pre>
<p>Output:</p>
<pre><code>   price    security                                                                                                                    
0  26.80  reliance                                                                                                                    
1  11.20   samsung                                                                                                                    
2  35.25     apple                                                                                                                    
5  28.50      tata                                                                                                                    
6  30.20      sony
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may also use pandas.concat():</p>
<p>CODE:</p>
<pre><code>import pandas as pd

fri =pd.DataFrame (columns =['security', 'price'], index = range(3), data =[['a',2],['b',4],['c',6]] )
sat =pd.DataFrame (columns =['security', 'price'], index = range(2), data =[['a',3],['c',5]] )
print ('TEST DATA:')
print (fri)
print (sat)

print ('\nSOLUTION 1: concatenate and eliminate duplicates')
result_1 = pd.concat([sat,fri],ignore_index=True).drop_duplicates(subset=['security'], keep='first')
print (result_1)

print ('\nSOLUTION 2: filter unique and then concatenate')
fri_unique = fri[~fri.security.isin(sat.security)]
result_2 = pd.concat([sat, fri_unique], ignore_index=True)
print (result_2)
</code></pre>
<h1>OUTPUT:</h1>
<pre><code>TEST DATA:
  security  price
0        a      2
1        b      4
2        c      6
  security  price
0        a      3
1        c      5

SOLUTION 1: concatenate and eliminate duplicates
  security  price
0        a      3
1        c      5
3        b      4

SOLUTION 2: filter unique and then concatenate
  security  price
0        a      3
1        c      5
2        b      4
</code></pre>
</div>
<span class="comment-copy">Can you add some sample data to question with expected output?</span>
<span class="comment-copy">Thanks for the good news!  I feel better for my answer.</span>
<span class="comment-copy">Does a pandas merge respect the order? i.e. would <code>df_saturday</code>'s elements occur first?</span>
<span class="comment-copy">Yup it keeps the order. <code>df_saturday</code> elements would come first and then <code>df_friday</code></span>
<span class="comment-copy">You could use keep='first' in the drop_duplicates() to make it explicit. Of course, default is keep='first', but specifying it would improve the readability .</span>
<span class="comment-copy">@AsishM. Thank you for the question. I also had that question in my mind. That's why I used that method I mentioned in that question.</span>
<span class="comment-copy">@Akshay and RebornCodeLover: Thank you. I didn't aware of the property keep.</span>
<span class="comment-copy">Thank you for your answer. So concat and outer merge do the same thing. Am I right?</span>
<span class="comment-copy">Both ways should give same result. Choose whatever is faster and more readable in your context. There is often more than 1 way in Python.</span>
