<div class="post-text" itemprop="text">
<p>I am a bit new to python and I am trying to get a list containing all root parent existing in a scene of type <code>joint</code>.
for example, my scene outliner is something like that:</p>
<blockquote>
<p><strong>group1&gt;&gt;group2&gt;&gt;joint1&gt;&gt;joint2&gt;&gt;joint3</strong></p>
<p><strong>group3&gt;&gt;joint4&gt;&gt;joint5</strong></p>
<p><strong>joint16&gt;&gt;joint17&gt;&gt;joint18</strong></p>
</blockquote>
<p>I want a script that travels through the outliner and returns a list, in my example:</p>
<pre><code>[joint1, joint4, joint16]
</code></pre>
<p>Any tips would be really appreciated. thank you so much.</p>
</div>
<div class="post-text" itemprop="text">
<p>Im not sure if it is any of use has Haggi Krey solution works fine but
You can use also the flag : -long from cmds.ls</p>
<pre><code># list all the joints from the scene
mjoints = cmds.ls(type='joint', l=True)
# list of the top joints from chain
output = []
# list to optimise the loop counter
exclusion = []
# lets iterate joints
for jnt in mjoints:
    # convert all hierarchy into a list
    pars = jnt.split('|')[1:]
    # lets see if our hierarchy is in the exclusion list
    # we put [1:] because maya root is represented by ''
    if not set(pars) &amp; set(exclusion):
        # we parse the hierarchy until we reach the top joint
        # then we add it to the output
        # we add everything else to the exclusion list to avoid 
        for p in pars:
            if cmds.nodeType(p) == 'joint':
                output.append(p)
                exclusion+=pars
                break
print(output)
</code></pre>
<p>I just put this because there is not one way to go. I hope the construction of this code could help your python skills. It is exactly the same, just the way to find the parent nodes is different !</p>
</div>
<div class="post-text" itemprop="text">
<p>I've used DrWeeny's idea before where you traverse the hierarchy by the object's long name. The difference in this answer is that the script won't crash if there's objects with duplicate names in the scene. What I mean by that is let's say you have a situation where you have 2 hierachies:</p>
<p><code>group1&gt;&gt;joint1&gt;&gt;joint2&gt;&gt;group2&gt;&gt;joint3</code></p>
<p>and</p>
<p><code>group3&gt;&gt;joint1&gt;&gt;joint2&gt;&gt;group2&gt;&gt;joint3</code></p>
<p>Maya easily allows this, like when duplicating a top node, so we need to prevent the script from crashing in this case. When there's multiple objects with duplicate names Maya will crash if you try to access the object's short name (it doesn't know what one you're referring to!), so instead we must always use its long name:</p>
<pre><code>import maya.cmds as cmds


jnts = cmds.ls(type="joint", l=True)  # Collect all joints in the scene by their long names.
output = set()  # Use a set to avoid adding the same joint.

for jnt in jnts:
    pars = jnt.split("|")  # Split long name so we can traverse its hierarchy.

    root_jnt = None

    while pars:
        obj = "|".join(pars)
        del pars[-1]  # Remove last word to "traverse" up hierarchy on next loop.

        # If this is a joint, mark it as the new root joint.
        if obj and cmds.nodeType(obj) == "joint":
            root_jnt = obj

    # If a root joint was found, append it to our final list.
    if root_jnt is not None:
        output.add(root_jnt)

print(list(output))
</code></pre>
<p>Using this script on the hierarchies above would return</p>
<p><code>[u'|group1|joint1', u'|group3|joint1']</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest to list all joints and for every joint you can check if it's parent is not a joint. In your definition, these joints should be your root joints.</p>
</div>
<span class="comment-copy">thank you so much for your time and help. i will give it a try too and let you know ^^</span>
<span class="comment-copy">ive edited the script there were few mistakes ^^</span>
<span class="comment-copy">Hello Dian Lan Luu, note that marking a question as accepted is different to have the best answer. In theory you should have let it to Haggi Key and upvote new answers that you find more relevant</span>
<span class="comment-copy">note that you might not be able to upvote because you are new but it is kinda the rule of stackoverflow ;]</span>
<span class="comment-copy">assuming that they will be double names is a bit sad but there is always a mad scientist trying to do that.... I like the wya you do your while loop, I'm always avoiding them because I end up looping maya :S</span>
<span class="comment-copy">I completely agree but it happens more often than I care for! Especially when dealing with juniors.</span>
<span class="comment-copy">I am so grateful for your time and precious help, and so sorry for my late reply as I wasnt able to test your solutions in maya. work like a charm. thank you a million time Haggi, DrWeeny and Green Cell  :)</span>
<span class="comment-copy">I will give it a try and let you know, thank you so much for your tip!!!</span>
<span class="comment-copy">thank you so much, works like a charm.  import maya.cmds as cmds  allParentsList = [] myItems= cmds.ls(type='joint')  for item in myItems:     theParent = cmds.listRelatives(item, parent=True)     if cmds.nodeType(theParent) != "joint":         allParentsList.append(item)          print allParentsList</span>
<span class="comment-copy">@DienLanLuu This doesn't work. Think of a situation where you have another object type breaking a joint chain like: <code>joint1&gt;&gt;joint2&gt;&gt;group1&gt;&gt;joint3</code>. It will return both <code>joint1</code> and <code>joint3</code> instead of only <code>joint1</code></span>
<span class="comment-copy">@GreenCell yes it was a quick script to test what haggi advised me to do but now with your help and everyone else I got it to work. thanks a million time :)</span>
