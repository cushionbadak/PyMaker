<div class="post-text" itemprop="text">
<p>I'm trying to import CSV data from a file produced by a device which has a system clock which is set to <code>'Australia/Adelaide'</code> time, but doesn't switch from standard to daylight time in summer. I can import it no problem as <code>tz-naive</code> but I need to correlate it with data which is <code>tz-aware</code>.</p>
<p>The following is incorrect as it assumes the data transitions to summer time on '2017-10-01'</p>
<pre><code>data = pd.read_csv('~/dev/datasets/data.csv', parse_dates=['timestamp'], index_col=['timestamp'])
data.index.tz_localize('Australia/Adelaide')
</code></pre>
<p><code>tz_localize</code> contains a number of arguments to deal with ambiguous dates - but I don't see any way to tell it that the data doesn't transition at all. Is there a way to specify a "custom" timezone that's <code>'Australia/Adelaide', no daylight savings</code>?</p>
<p>Edit: I found this question - <a href="https://stackoverflow.com/questions/26742896/create-new-timezone-in-pytz">Create New Timezone in pytz</a> which has given me some ideas - in this case the timestamps are a constant offset from UTC so i can probably add that to the date after importing, localise as UTC then convert to 'Australia/Adelaide'. I'll report back...</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution I came up with is as follows:</p>
<p>Since the data is 'Australia/Adelaide' with no DLS transistion, that means the UTC offset is a constant (+10:30) all year. Hence a solution is to import that data as <code>tz-naive</code>, subtract 10 hours and 30 minutes, localise as UTC then convert to 'Australia/Adelaide', i.e.</p>
<pre><code>data = pd.read_csv('~/dev/datasets/data.csv', parse_dates=['timestamp'], index_col=['timestamp'])
data.index = data.index - pd.DateOffset(hours=10) - pd.DateOffset(minutes=30)
data.index = data.index.tz_localize('UTC').tz_convert('Australia/Adelaide')
</code></pre>
</div>
