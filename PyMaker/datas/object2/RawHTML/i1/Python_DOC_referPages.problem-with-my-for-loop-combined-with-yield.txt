<div class="post-text" itemprop="text">
<p>I have a program that concatenates words separated by an asterisk. The program removes the asterisk and connects the first part of the word (the one before the asterisk) with its second part (the one after the asterisk). It runs well except for one main problem: the second part (after the asterisk)is still in the output. For example, the program concatenated ['presi', '*', 'dent'], but 'dent' is still in the output. I did not figure it out where's the problem with my code. The code is below:</p>
<pre><code>from collections import defaultdict
import nltk
from nltk.tokenize import word_tokenize
import re
import os
import sys
from pathlib import Path


def main():
    while True:
        try:
            file_to_open =Path(input("\nPlease, insert your file path: "))

            with open(file_to_open) as f:
                words = word_tokenize(f.read().lower())
                break
        except FileNotFoundError:
            print("\nFile not found. Better try again")
        except IsADirectoryError:
            print("\nIncorrect Directory path.Try again")

    word_separator = '*'

    with open ('Fr-dictionary2.txt') as fr:
            dic = word_tokenize(fr.read().lower())

    def join_asterisk(ary):

        for w1, w2, w3 in zip(words, words[1:], words[2:]):
            if w2 == word_separator:
                word = w1 + w3
                yield (word, word in dic)
            elif w1 != word_separator and w1 in dic:
                yield (w1, True)


    correct_words = []
    incorrect_words = []
    correct_words = [w for w, correct in join_asterisk(words) if correct]
    incorrect_words = [w for w, correct in join_asterisk(words) if not correct]
    text=' '.join(correct_words)
    print(correct_words)
    print('\n\n', text)
    user2=input('\nWrite text to a file? Type "Y" for yes or "N" for no:')

    text_name=input("name your file.(Ex. 'my_first_file.txt'): ")
    out_file=open(text_name,"w")

    if user2 =='Y':
        out_file.write(text)
        out_file.close()
    else:
        print('ok')


main()
</code></pre>
<p>I wonder if anyone could help me to detect the error here? </p>
<p>Input example:</p>
<blockquote>
<p>Les engage * ments du prési * dent de la Républi * que sont aussi ceux
  des dirigeants de la société » ferroviaire, a-t-il soutenu de vant des
  élus du Grand-Est réunis à l’Elysée.</p>
<p>Le président de la République, Emmanuel Macron (à droite), aux cô *
  tés du patron de la SNCF, Guillaume Pepy, à la gare Montparnasse, à
  Paris, le 1er juillet 2017. GEOFFROY VAN DER HASSELT / AFP</p>
<p>L’irrita tion qui, par fois, s’empare des usa * gers de la SNCF face
  aux trains suppri * més ou aux dessertes abandonnées semble avoir
  aussi saisi le président de la République. Devant des élus du
  Grand-Est, réunis mardi 26 février à l’Elysée dans le cadre du grand
  débat, Emmanuel Macron a eu des mots très durs contre la SNCF, qui a
  fermé la ligne Saint-Dié - Epinal le 23 décembre 2018, alors que le
  chef de l’Etat s’était engagé, durant un dépla * cement dans les
  Vosges effec * tué en avril 2018, à ce qu’elle reste opération *
  nelle.</p>
</blockquote>
<p>Example of my current output is:</p>
<pre><code>['les', 'engagements', 'du', 'président', 'dent', 'de', 'la', 'république', 'que', 'sont', 'aussi', 'ceux', 'des', 'dirigeants', 'de', 'la', 'société', 'ferroviaire'] 
</code></pre>
<p>Example of my desired output is:</p>
<pre><code>['les', 'engagements', 'du', 'président', 'de', 'la', 'république', 'sont', 'aussi', 'ceux', 'des', 'dirigeants', 'de', 'la', 'société', 'ferroviaire']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both the extra words (I assume) are in your dictionary and therefore being yielded a second time after 2 iterations of the for loop  because they meet the case when they become <code>w1</code> in the lines:</p>
<pre><code>            elif w1 != word_separator and w1 in dic:
                yield (w1, True)
</code></pre>
<p>A redesign of your <code>join_asterisk</code> function seems to be the best way to do this as any attempt to modify this function to skip these would be incredibly hacky. </p>
<p>The following would be a way to redesign the function so that you can skip words that have already been included as the second half of a word seperated by a '*':</p>
<pre><code>incorrect_words = []
def join_asterisk(array):
    ary = array + ['', '']
    i, size = 0, len(ary)
    while i &lt; size - 2:
        if ary[i+1] == word_separator:
            if ary[i] + ary[i+2] in dic:
                yield ary[i] + ary[i+2]
            else:
                incorrect_words.append(ary[i] + ary[i+2])
            i+=2
        elif ary[i] in dic: 
            yield ary[i]
        i+=1
</code></pre>
<p>If you want this to fit closer to your original function, it can be modified to:</p>
<pre><code>def join_asterisk(array):
    ary = array + ['', '']
    i, size = 0, len(ary)
    while i &lt; size - 2:
        if ary[i+1] == word_separator:
            concat_word = ary[i] + ary[i+2]
            yield (concat_word, concat_word in dic)
            i+=2
        else: 
            yield (ary[i], ary[i] in dic)
        i+=1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this alternative implementation of <code>join_asterisk</code> does what you intend:</p>
<pre><code>def join_asterisk(words, word_separator):
    if not words:
        return
    # Whether the previous word was a separator
    prev_sep = (words[0] == word_separator)
    # Next word to yield
    current = words[0] if not prev_sep else ''
    # Iterate words
    for word in words[1:]:
        # Skip separator
        if word == word_separator:
            prev_sep = True
        else:
            # If neither this or the previous were separators
            if not prev_sep:
                # Yield current word and clear
                yield current
                current = ''
            # Add word to current
            current += word
            prev_sep = False
    # Yield last word if list did not finish with a separator
    if not prev_sep:
        yield current

words = ['les', 'engagements', 'du', 'prési', '*', 'dent', 'de', 'la', 'républi', '*', 'que', 'sont', 'aussi', 'ceux', 'des', 'dirigeants', 'de', 'la', 'société', 'ferroviaire']
word_separator = '*'
print(list(join_asterisk(words, word_separator)))
# ['les', 'engagements', 'du', 'président', 'de', 'la', 'république', 'sont', 'aussi', 'ceux', 'des', 'dirigeants', 'de', 'la', 'société', 'ferroviaire']
</code></pre>
</div>
<span class="comment-copy">in order to get help, you should provide an input example</span>
<span class="comment-copy">@Tryph, input example given</span>
<span class="comment-copy">yes, I think so too. They are both in my dictionary that's why it is still in my output...but I want to check only the concatenated words (w1 + w3) e not the other words</span>
<span class="comment-copy">@NadiaSantos Am I correct in saying that you still want to include other words if they're in the dictionary <b>as long as they aren't part of a word seperated by a '*'</b>? I've added a redesign of the function to do this.</span>
<span class="comment-copy">yes, you are correct! I'll try this option. Thanks! Is it possible to append to a list if the concatenated word is not in dic? If so, could you please update your solution?</span>
<span class="comment-copy">@NadiaSantos I've updated the solution as per this request, using an external variable <code>incorrect_words</code> as the list. I've also added a modified version that will fit into your original code better as this is a much nicer style in my opinion.</span>
<span class="comment-copy">Thanks for that, but this solution only joins the words separated by the asterisk but does not check if the resultant string is in the french dictionary.  I need to check because this is a text and the asterisk means a line break...So, the program will probably join two existing words and not parts of one word...does it make sense? This is my problem!</span>
<span class="comment-copy">@NadiaSantos I see, I thought the problem was just about the algorithm that produces joined words without the repeated last half. Unfortunately, there is no good way to solve that, because it is possible that both halves and the joined words are valid words in French, so in principle you would have to decide what happens in each case (halves and joined are valid, neither are valid, only one half is valid but the joined word is not valid, ...).</span>
<span class="comment-copy">yes, you're right ... I've come to this conclusion too. Thanks for the effort anyway.</span>
