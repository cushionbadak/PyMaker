<div class="post-text" itemprop="text">
<p>I am working on an assignment where I create "instances" of cities using rows in a .csv, then use these instances in methods to calculate distance and population change. Creating the instances works fine (using steps 1-4 below), until I try to call printDistance:</p>
<pre><code>##Step 1. Open and read CityPop.csv
with open('CityPop.csv', 'r', newline='') as f:
try:
    reader = csv.DictReader(f)
    ##Step 2. Create "City" class
    class City:
        ##Step 3. Use _init method to assign attribute values
        def __init__(self, row, header):
            self.__dict__ = dict(zip(header, row))

            ##Step 4. Create "Cities" list
            data = list(csv.reader(open('CityPop.csv')))
            instances = [City(i, data[0]) for i in data[1:]]

            ##Step 5. Create printDistance method within "Cities" class  
            def printDistance(self, othercity, instances):
                dist=math.acos((math.sin(math.radians(self.lat)))*(math.sin(math.radians(othercity.lat)))+(math.cos(math.radians(self.lat)))*(math.cos(math.radians(othercity.lat)))*(math.cos(math.radians(self.lon-othercity.lon)))) * 6300 (self.lat, self.lon, othercity.lat, othercity.lon)
</code></pre>
<p>When I enter instances[0].printDistance(instances<a href="https://i.stack.imgur.com/H2KV0.jpg" rel="nofollow noreferrer">1</a>) in the shell, I get the error:</p>
<pre><code> `NameError: name 'instances' is not defined`
</code></pre>
<p>Is this an indentation problem? Should I be calling the function from within the code, not the shell?</p>
<p><img alt="Example of how data is stored in csv" src="https://i.stack.imgur.com/H2KV0.jpg"/></p>
</div>
<div class="post-text" itemprop="text">
<p>Nested functions must not contain self as parameter because they are not member functions. Class cannot pass instance variables to them. You are infact passing the same self from parent to child function. </p>
<p>Also you must not nest constructor, this is only for initiation purpose. Create a separate method indeed.</p>
<p>And try creating instance variable inside the constructor, and that is what <strong>init</strong> for !</p>
<pre><code>self.instances = [self.getInstance(i, data[0]) for i in data[1:]]
</code></pre>
<p>Also create seperate function for instantiation </p>
<pre><code>@classmethod
def getInstance(cls,d1,d2):
    return cls(d1,d2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not so much an indentation problem, but more of a general code structure problem. You're nesting a lot:</p>
<ul>
<li>All the actual work on an incredibly long line (with errors)</li>
<li>Inside of function (correctly) <code>printDistance</code></li>
<li>Inside of a constructor <code>__init__</code></li>
<li>Inside of a class definition (correctly) <code>City</code> </li>
<li>Inside of a <code>try</code> block</li>
<li>Inside of a <code>with</code> block</li>
</ul>
<p>I think this is what you are trying to do:</p>
<ul>
<li>create a class City, which can print the distance of itself to other cities</li>
<li>generate a list of these City objects from a .csv that somehow has both distances and population (you should probably provide an example of data)</li>
<li>do so in a fault-tolerant and clean way (hence the <code>try</code> and the <code>with</code>)</li>
</ul>
<p>The reason your <code>instances</code> isn't working is because, unlike you think, it's probably not being created correctly, or at least not in the correct context. And it certainly won't be available to you on the CLI due to all of the nesting.</p>
<p>There's a number of blatant bugs in your code:</p>
<ul>
<li>What's the <code>(self.lat, self.lon, othercity.lat, othercity.lon)</code> at the end of the last line?</li>
<li>Why are you opening the file for reading twice? You're not even using the first <code>reader</code></li>
<li>You are bluntly assigning column headers from a <code>.csv</code> as object attributes, but are misspelling their use (<code>lat</code> instead of <code>latitude</code> and <code>lon</code> instead of <code>longitude</code>)</li>
</ul>
<p>It looks a bit like a lot of code found in various places got pasted together into one clump - this is what it looks like when cleaned up:</p>
<pre><code>import csv
import math


class City:
    def print_distance(self, other_city):
        print(f'{self.city} to {other_city.city}')
        # what a mess...
        print(math.acos(
            (math.sin(math.radians(float(self.latitude)))) * (math.sin(math.radians(float(other_city.latitude)))) + (
                math.cos(math.radians(float(self.latitude)))) * (math.cos(math.radians(float(other_city.latitude)))) * (
                math.cos(math.radians(float(self.longitude) - float(other_city.longitude))))) * 6300)

    def __init__(self, values, attribute_names):
        # this is *nasty* - much better to add the attributes explicitly, but left as original
        # also, note that you're reading strings and floats here, but they are all stored as str
        self.__dict__ = dict(zip(attribute_names, values))


with open('CityPop.csv', 'r', newline='') as f:
    try:
        reader = csv.reader(f)
        header = next(reader)
        cities = [City(row, header) for row in reader]

        for city_1 in cities:
            for city_2 in cities:
                city_1.print_distance(city_2)
    except Exception as e:
        print(f'Apparently were doing something with this error: {e}')
</code></pre>
<p>Note how <code>print_distance</code> is now a method of <code>City</code>, which is called on each instance of <code>City</code> in <code>cities</code> (which is what I renamed <code>instances</code> to).</p>
<p>Now, if you are really trying, this makes more sense:</p>
<pre><code>import csv
import math


class City:
    def print_distance(self, other_city):
        print(f'{self.name} to {other_city.name}')
        # not a lot better, but some at least
        print(
            math.acos(
                math.sin(math.radians(self.lat)) *
                math.sin(math.radians(other_city.lat))
                +
                math.cos(math.radians(self.lat)) *
                math.cos(math.radians(other_city.lat)) *
                math.cos(math.radians(self.lon - other_city.lon))
            ) * 6300
        )

    def __init__(self, lat, lon, name):
        self.lat = float(lat)
        self.lon = float(lon)
        self.name = str(name)


try:
    with open('CityPop.csv', 'r', newline='') as f:
        reader = csv.reader(f)
        header = next(reader)
        cities = [City(lat=row[1], lon=row[2], name=row[4]) for row in reader]

        for city_1 in cities:
            for city_2 in cities:
                city_1.print_distance(city_2)
except FileNotFoundError:
    print(f'Could not find the input file.')
</code></pre>
<p>Note the cleaned up computation, the catching of an error that could be expected to occur (with the <code>with</code> insides the <code>try</code> block) and a proper constructor that assigns what it needs with the correct type, while the reader decides which fields go where.</p>
<p>Finally, as a bonus: nobody should be writing distance calculations like this. Plenty libraries exist that do a much better job of this, like GeoPy. All you need to do is <code>pip install geopy</code> to get it and then you can use this:</p>
<pre><code>import csv
import geopy.distance


class City:
    def calc_distance(self, other_city):
        return geopy.distance.geodesic(
            (self.lat, self.lon), 
            (other_city.lat, other_city.lon)
        ).km

    def __init__(self, lat, lon, name):
        self.lat = float(lat)
        self.lon = float(lon)
        self.name = str(name)


try:
    with open('CityPop.csv', 'r', newline='') as f:
        reader = csv.reader(f)
        header = next(reader)
        cities = [City(lat=row[1], lon=row[2], name=row[4]) for row in reader]

        for city_1 in cities:
            for city_2 in cities:
                print(city_1.calc_distance(city_2))
except FileNotFoundError:
    print(f'Could not find the input file.')
</code></pre>
<p>Note that I moved the <code>print</code> out of the method as well, since it makes more sense to calculate in the object and print outside it. The nice thing about all this is that the calculation now uses a proper geodesic (WGS-84) to do the calculation and the odds of math errors are drastically reduced. If you <em>must</em> use a simple sphere, the library has functions for that as well.</p>
</div>
<span class="comment-copy">Is <code>def printDistance</code> really nested inside <code>def __init__</code>?</span>
<span class="comment-copy">Class and function definitions should generally not be inside <code>with</code> or <code>try</code>.</span>
<span class="comment-copy">Shouldn't <code>try</code> be indented so it's inside <code>with</code>?</span>
<span class="comment-copy">Your indentation is so messed up it's impossible to tell what you're really trying to do. The way you've written it, <code>instances</code> is a local variable inside the <code>__init__</code> method. But that makes no sense, because it's calling <code>City()</code>, which will cause infinite recursion.</span>
<span class="comment-copy"><code>printDistance()</code> takes 2 arguments, you're calling it with only one argument. But it never uses the <code>instances</code> argument, so why is that parameter there?</span>
<span class="comment-copy">if possible please use pandas and read data into dataframe and apply calculations, would be much faster and would require less line of code. Also you delimeter for csv would be \n and not ‘ ‘</span>
<span class="comment-copy">Yes, that's what I'm going for. I added an example of the data to the original post. I'll try re-working the instances, too. Thanks!</span>
