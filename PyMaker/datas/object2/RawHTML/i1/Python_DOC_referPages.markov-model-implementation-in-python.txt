<div class="post-text" itemprop="text">
<p>I am trying to implement Markov property on a set of lines. I need all the unique words along the corresponding frequency of the following words. <br/></p>
<h2>Example <br/></h2>
<p><strong>Input <br/></strong> 
Filename : Example.txt <br/></p>
<pre><code>I Love you
I Miss you 
Miss you Baby
You are the best
I Miss you 
</code></pre>
<p><strong>Code Snippet</strong> <br/></p>
<pre><code>from collections import Counter
import pprint

class TextAnalyzer:

    text_file = 'example.txt'


    def __init__(self):
        self.raw_data = ''
        self.word_map = dict()

        self.prepare_data()
        self.analyze()

        pprint.pprint(self.word_map)

    def prepare_data(self):
        with open(self.text_file, 'r') as example:
            self.raw_data=example.read().replace('\n', ' ')
        example.close()

    def analyze(self):
        words = self.raw_data.split()

        word_pairs = [[words[i],words[i+1]] for i in range(len(words)-1)]

        self.word_map = dict()

        for word in list(set(words)):
            for pair in word_pairs:
                if word == pair[0]:
                    self.word_map.setdefault(word, []).append(pair[1])

        self.word_map[word] = Counter(self.word_map[word]).most_common(11)

TextAnalyzer()
</code></pre>
<p><strong>Actual Output</strong></p>
<pre><code>{'Baby': ['You'],
 'I': ['Love', 'Miss', 'Miss'],
 'Love': ['you'],
 'Miss': ['you', 'you', 'you'],
 'You': ['are'],
 'are': ['the'],
 'best': ['I'],
 'the': ['best'],
 'you': [('I', 1), ('Miss', 1), ('Baby', 1)]}
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>{'Miss': [('you',3)],
 'I': [('Love',1), ('Miss',2)],
 'Love': ['you',1],
 'Baby': ['You',1],
 'You': ['are',1],
 'are': ['the',1],
 'best': ['I',1],
 'the': ['best'],
 'you': [('I', 1), ('Miss', 1), ('Baby', 1)]}
</code></pre>
<p>I want the output to be sorted based on maximum frequency. How can I improve my code to achieve that output. <br/></p>
</div>
<div class="post-text" itemprop="text">
<p>To be closer to your expected result you could edit the <code>analize</code> method:</p>
<pre><code>def analyze(self):
    words = self.raw_data.split()
    word_pairs = [[words[i],words[i+1]] for i in range(len(words)-1)]
    self.word_map = dict()

    for word in list(set(words)):
        pairword = []
        for pair in word_pairs:
            if word == pair[0]:
                pairword.append(pair[1])
        self.word_map[word] = Counter(pairword).most_common()
</code></pre>
<p>This prints:</p>
<pre><code>{'Baby': [('You', 1)],
 'I': [('Miss', 2), ('Love', 1)],
 'Love': [('you', 1)],
 'Miss': [('you', 3)],
 'You': [('are', 1)],
 'are': [('the', 1)],
 'best': [('I', 1)],
 'the': [('best', 1)],
 'you': [('I', 1), ('Miss', 1), ('Baby', 1)]}
</code></pre>
<p>Which is what you want but not sorted. You need to write a custom printing method which do the sorting for you.</p>
<p>For example, adding following method to the class:</p>
<pre><code>def printfreq(self):
    sortkeys = sorted(self.word_map, key=lambda k:max(self.word_map[k], key=lambda val:val[1], default=(None, 0))[1], reverse=True)
    for kk in sortkeys:
        pprint.pprint(f"{kk} : {self.word_map[kk]}")
</code></pre>
<p>and substituting the line <code>pprint.pprint(self.word_map)</code> with <code>self.printfreq()</code> results in printing:</p>
<pre><code>"Miss : [('you', 3)]"
"I : [('Miss', 2), ('Love', 1)]"
"you : [('I', 1), ('Miss', 1), ('Baby', 1)]"
"Love : [('you', 1)]"
"the : [('best', 1)]"
"You : [('are', 1)]"
"best : [('I', 1)]"
"Baby : [('You', 1)]"
"are : [('the', 1)]"
</code></pre>
<p>The long sorting key allows to sort the dictionary keys on the maximum frequency in the list.</p>
<h3>EDIT</h3>
<p>I added a default argument to <code>max</code>. This allows to avoid the <code>ValueError: max() arg is an empty sequence</code> which may arise if there is one or more non repeated words in the input.</p>
</div>
<span class="comment-copy">It's the code you posted with few edits. All the edits are already included and explained in my answer. There is really nothing more.</span>
<span class="comment-copy">Does this sorting code does not work when the input is just few lines?  I get this error. sortkeys = sorted(self.word_map, key=lambda k:max(self.word_map[k], key=lambda val:val[1])[1], reverse=True) ValueError: max() arg is an empty sequence</span>
<span class="comment-copy">I cannot reproduce that error even with a single line input. Could you share the input which gives that error?</span>
<span class="comment-copy">My loneliness is killing me And I I must confess I still believe Still believe When I m not with you I lose my mind Give me a sign Hit me baby one more time</span>
<span class="comment-copy">It works for me. Maybe the problem lies elsewhere. I am using python3.6, but I am not sure if it is relevant.</span>
