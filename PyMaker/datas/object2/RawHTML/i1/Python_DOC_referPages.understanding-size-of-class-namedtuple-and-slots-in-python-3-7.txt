<div class="post-text" itemprop="text">
<p>After watching Nina Zahkarenko's Python Memory Management talk at Pycon2016 (<a href="https://www.youtube.com/watch?v=F6u5rhUQ6dU" rel="nofollow noreferrer">link</a>), it seemed like the dunder method <code>__slots__</code> was a tool to reduce object size and speed up attribute lookup.</p>
<p>My expectation was that a normal class would be the largest, while a <code>__slots__</code>/<code>namedtuple</code> approach would save space. However, a quick experiment proved me wrong:</p>
<pre class="lang-py prettyprint-override"><code>from collections import namedtuple
from sys import getsizeof

class Rectangle:
   '''A class based Rectangle, with a full __dict__'''
   def __init__(self, x, y, width, height):
      self.x = x
      self.y = y
      self.width = width
      self.height = height

class SlotsRectangle:
   '''A class based Rectangle with __slots__ defined for attributes'''
   __slots__ = ('x', 'y', 'width', 'height')

   def __init__(self, x, y, width, height):
      self.x = x
      self.y = y
      self.width = width
      self.height = height

NamedTupleRectangle = namedtuple('Rectangle', ('x', 'y', 'width', 'height'))
NamedTupleRectangle.__doc__ = 'A rectangle as an immutable namedtuple'

print(f'Class: {getsizeof(Rectangle(1,2,3,4))}')
print(f'Slots: {getsizeof(SlotsRectangle(1,2,3,4))}')
print(f'Named Tuple: {getsizeof(NamedTupleRectangle(1,2,3,4))}')
</code></pre>
<p>Terminal Output:</p>
<pre class="lang-sh prettyprint-override"><code>$ python3.7 example.py
Class: 56
Slots: 72
Named Tuple: 80
</code></pre>
<p>What is going on here? From the docs on Python's <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">Data Model</a> it appears that descriptors are used for <code>__slots__</code> which would add function overhead to classes implementing it. However, why are the results so heavily skewed towards a normal class?</p>
<p>Channeling my inner Raymond H.: there has to be a harder way!</p>
</div>
<div class="post-text" itemprop="text">
<p>The function <code>sys.getsizeof()</code> is probably not doing what you think it does; it does not work for complex objects, like custom classes.</p>
<p>Look at <a href="https://stackoverflow.com/a/30316760/9225671">this answer</a> for a method to calculate the memory size of objects; maybe it helps you.
I copied the code from that answer in here, but the full explanation is in the answer I linked.</p>
<pre><code>import sys
from numbers import Number
from collections import Set, Mapping, deque

try: # Python 2
    zero_depth_bases = (basestring, Number, xrange, bytearray)
    iteritems = 'iteritems'
except NameError: # Python 3
    zero_depth_bases = (str, bytes, Number, range, bytearray)
    iteritems = 'items'

def getsize(obj_0):
    """Recursively iterate to sum size of object &amp; members."""
    _seen_ids = set()
    def inner(obj):
        obj_id = id(obj)
        if obj_id in _seen_ids:
            return 0
        _seen_ids.add(obj_id)
        size = sys.getsizeof(obj)
        if isinstance(obj, zero_depth_bases):
            pass # bypass remaining control flow and return
        elif isinstance(obj, (tuple, list, Set, deque)):
            size += sum(inner(i) for i in obj)
        elif isinstance(obj, Mapping) or hasattr(obj, iteritems):
            size += sum(inner(k) + inner(v) for k, v in getattr(obj, iteritems)())
        # Check for custom object instances - may subclass above too
        if hasattr(obj, '__dict__'):
            size += inner(vars(obj))
        if hasattr(obj, '__slots__'): # can have __slots__ with __dict__
            size += sum(inner(getattr(obj, s)) for s in obj.__slots__ if hasattr(obj, s))
        return size
    return inner(obj_0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>"Channeling my inner Raymond H," +1</p>
<p>So the thing about slots is, you have to read <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">about slots</a>.</p>
<p>The other thing is, they do affect <code>class</code> size:</p>
<pre><code>print(f'(Class) Class: {getsizeof(Rectangle)}') # 1056
print(f'(Class) Slots: {getsizeof(SlotsRectangle)}') # 888
</code></pre>
<p>Cool. Now let's say we add a field to the Rectangle class:</p>
<pre><code>rect = Rectangle(1,2,3,4)
rect.extra_field = dict() # wild right?
print(f'(Object) Class: {getsizeof(rect)}') # still 56
</code></pre>
<p>So you can "count" the resources "your using" (in the form of instance variables) and the slots rectangle would be <code>112</code> and the non-slots rectangle would be 112 as well...</p>
<p>However, we know this to not be the case as we would expect the regular rectangle to be at least <code>352</code> because we added a <code>dict</code> to it.</p>
<p>Slots prevent you from being able to do this and thus provide a way of constraining resource usage.</p>
<p>Check out this <a href="https://stackoverflow.com/a/53705610/8624508">answer here</a>, it seems like it might work fairly well for you use case. Running it on the slots rectangle and regular rectangle yields <code>152</code> and <code>352</code> respectively.</p>
<p>Also, if you're really into trying to optimize your code and minimize resource use come on over to the rust/c/c++ side of the house. </p>
</div>
<span class="comment-copy"><code>getsizeof</code> isn't reporting the size of data structures referenced by the class object; only the class object itself.</span>
<span class="comment-copy">Thanks for the answer @Ralf, I believe <code>sys.getsizeof()</code> is fulfilling my use case though. My rectangle object contains four variables which can refer to objects elsewhere on Python's managed heap. The memory footprint of <code>x</code> is irrelevant to me, it could be a <code>list[]</code> with thousands of elements. It was my understanding that the attribute <code>x</code> was only a reference. What I expected to see was reduced memory overhead when using <b>slots</b> compared to a class without.</span>
