<div class="post-text" itemprop="text">
<p>I am trying to fit a simple machine learning model using scikit learn. Upon this line:</p>
<pre><code>clf.fit(features, labels)
</code></pre>
<p>I get a familiar error:</p>
<pre><code> Input contains NaN, infinity or a value too large for dtype('float64').
</code></pre>
<p>Whenever I have encountered this before it has been when there where NaN values in my data. I have confirmed there are no NaNs in the data. The two inputs to the .fit() method (features and labels) are np arrays but they are produced from a pandas dataframe. Right before pulling the NaN values I printed:</p>
<pre><code>print(features_df[features_df.isnull().any(axis=1)])
print(labels_df[labels_df.isnull().any(axis=1)])
</code></pre>
<p>This printed empty dataframes so i know there is no row with a NaN value in it. I also checked the numpy arrays for NaN values after the conversion and even summed them successfully with the np sum() method so there are no NaN values in the features or labels np arrays passed into fit. </p>
<p>This means there must be infinity values or really large values, both of which I find hard to believe. Is there some way I can print any values in the dataframe or np array that:</p>
<pre><code>are NaN, infinity or a value too large for dtype('float64')?
</code></pre>
<p>I need to have them specifically pointed out to me as I can't find them with my eyes and there are no NaN values. </p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming this is the numpy array, with shape <code>(3,3)</code>:</p>
<pre><code>ar = np.array([1, 2, 3, 4, np.nan, 5, np.nan, 6, np.inf]).reshape((3,3))
print (ar)
[[ 1.  2.  3.]
 [ 4. nan  5.]
 [nan  6. inf]]
</code></pre>
<p>To check for NaN, infinity, and negative infinity, we can use:</p>
<pre><code>numpy.isnan(ar)
numpy.isinf(ar)
numpy.isneginf(ar)
</code></pre>
<p>respectively. Each of these returns a bool array, and passing the bool array to <code>numpy.where()</code> gives us two index arrays (one index array per dimension of <code>ar</code>):</p>
<pre><code>ar_nan = np.where(np.isnan(ar))
print (ar_nan)
</code></pre>
<blockquote>
<p>(array([1, 2], dtype=int64), array([1, 0], dtype=int64)) # Means, nans
  at (1,1) and (2,0)</p>
</blockquote>
<p>and</p>
<pre><code>ar_inf = np.where(np.isinf(ar))
print (ar_inf)
</code></pre>
<blockquote>
<p>(array([2], dtype=int64), array([2], dtype=int64)) # Means, inf is at
  (2,2)</p>
</blockquote>
<p>Also, to see the limits of float64:</p>
<pre><code>np.finfo(np.float64)
</code></pre>
<blockquote>
<p>finfo(resolution=1e-15, min=-1.7976931348623157e+308,
  max=1.7976931348623157e+308, dtype=float64)</p>
</blockquote>
</div>
<span class="comment-copy">have you tried to filter out values with something like: <code>df = df[df.column_name.notnull()]</code>? <code>df = df[df.notnull()]</code> should probably also work. <code>df</code> is pandas data frame</span>
<span class="comment-copy">I don't know about values too large for float64 (How did you get them into your array in the first place?) but +/-inf, nan, you can find using <code>~np.isfinite</code>, the leading tilda inverts the mask. If you need indices isntead of a mask use <code>np.where</code> on the mask</span>
