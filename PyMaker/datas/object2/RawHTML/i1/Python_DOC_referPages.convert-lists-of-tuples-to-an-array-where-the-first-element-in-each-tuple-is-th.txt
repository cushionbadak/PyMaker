<div class="post-text" itemprop="text">
<p>In Python, how do I convert a several lists of tuples to an array, where the first element in each tuple is the array index?  Additionally, not every list has tuples for every item, and I want those missing items to be filled with 0.</p>
<p>So I have:</p>
<pre><code>a = [(0, 2.45), (1, 3.25), (2, 5.34)]
b = [(0, 7.46), (1, 5.64), (3, 3.45)]
c = [(0, 9.65), (1, 7.22)]
</code></pre>
<p>And I want:</p>
<pre><code>somefun(a, b, c)
&gt;&gt;&gt; array([(2.45, 3.25, 5.34, 0.  ), (7.46, 5.64, 0.  , 3.45), (9.65, 7.22, 0.  , 0.  ])
</code></pre>
<p>I have a solution right now that iterates through the lists, creates structured arrays with assigned columns, and then uses <code>numpy.lib.refunction.stack_array()</code>, but this approach is quite slow:</p>
<pre><code>from numpy.lib import refunctions as rfn

row_list = []
for row in [a, b]:
    index = [(str(i[0]), 'f4') for i in row]
    value = [tuple([i[1] for i in row])]
    row_list.append(np.array(value, dtype=index))

result = np.ma.filled(rfn.stack_arrays(row_list, usemask=True), fill_value = 0)
</code></pre>
<p>I have tens of thousands of such lists that I want to combine into an array, so I am looking for something quicker.  Maybe there is a more apt <code>numpy</code> method that I am not aware of.  Thanks for the help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following function:</p>
<pre><code>from itertools import chain

a = [(0, 2.45), (1, 3.25), (2, 5.34)]
b = [(0, 7.46), (1, 5.64), (3, 3.45)]
c = [(0, 9.65), (1, 7.22)]

def func(*lists):
    max_ind = max(ind for ind, _ in chain.from_iterable(lists))
    result = []
    for l in lists:
        d = dict(l)
        t = tuple(d.get(ind, 0.) for ind in range(max_ind + 1))
        result.append(t)
    return result

print(func(a, b, c))
# [(2.45, 3.25, 5.34, 0.0), (7.46, 5.64, 0.0, 3.45), (9.65, 7.22, 0.0, 0.0)]
</code></pre>
<p>Alternatively you can use <code>itemgetter()</code> with <code>defaultdict()</code>:</p>
<pre><code>from itertools import chain
from collections import defaultdict
from operator import itemgetter

def func(*lists):
    max_ind = max(ind for ind, _ in chain.from_iterable(lists))
    iget = itemgetter(*range(max_ind + 1))
    return [iget(defaultdict(float, l)) for l in lists]

print(func(a, b, c))
# [(2.45, 3.25, 5.34, 0.0), (7.46, 5.64, 0.0, 3.45), (9.65, 7.22, 0.0, 0.0)]
</code></pre>
</div>
<span class="comment-copy">Is there a maximum length that can be assumed for these lists? Can we assume, for example, that these lists will not be more than 10 tuples long?</span>
<span class="comment-copy">Can we assume that, in each list, no two tuples will have the same first element?</span>
<span class="comment-copy">There is a maximum length (although it could be in the hundreds), and we can assume that no two tuples will have the same first element.</span>
<span class="comment-copy">Can we assume that in each list, the tuples will always be sorted by increasing first element? (as seems to be the case in your sample data)</span>
<span class="comment-copy">Yes, that is the case for my application</span>
<span class="comment-copy">I think you can use "get() with default 0" from the dictionary, to construct your tuple.</span>
<span class="comment-copy">@fountainhead Nice idea! Thank you!</span>
