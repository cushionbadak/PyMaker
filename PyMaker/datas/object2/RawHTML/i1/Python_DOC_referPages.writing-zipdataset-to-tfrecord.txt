<div class="post-text" itemprop="text">
<p>I'm trying to write a zipped dataset to TFRecord files following this
<a href="https://www.tensorflow.org/tutorials/load_data/tf_records#writing_a_tfrecord_file_2" rel="nofollow noreferrer">tutorial</a>, but my situation is different in that each element of each dataset in the ZipDataSet is a tensor rather than a scalar.</p>
<p>The tutorial addresses this contingency with the note </p>
<blockquote>
<p>Note: To stay simple, this example only uses scalar inputs. The simplest way to handle non-scalar features is to use tf.serialize_tensor to convert tensors to binary-strings. Strings are scalars in tensorflow. Use tf.parse_tensor to convert the binary-string back to a tensor.</p>
</blockquote>
<p>But I'm getting errors that seem to indicate that the _bytes_feature function is getting tensors rather than bytes.</p>
<pre><code>import tensorflow as tf
import numpy as np

sess = tf.Session()
def _bytes_feature(value):
    """Returns a bytes_list from a string / byte."""
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))


def serialize_with_labels(a, b, c, d):
    """
    Creates a tf.Example message ready to be written to a file.
    """

    # Create a dictionary mapping the feature name to the tf.Example-compatible
    # data type.

    feature = {'a': _bytes_feature(a),
               'b': _bytes_feature(b),
               'c': _bytes_feature(c),
               'd': _bytes_feature(d),
                }

    # Create a Features message using tf.train.Example.

    example_proto = tf.train.Example(features=tf.train
                                                .Features(feature=feature))
    return example_proto.SerializeToString()


def tf_serialize_w_labels(a, b, c, d):
    """Map serialize_with_labels to tf.data.Dataset."""
    tf_string = tf.py_func(serialize_with_labels,
                           (a, b, c, d),
                           tf.string)
    return tf.reshape(tf_string, ())

# a is a [n,m,p] tensor
# b is a [n,m,p] tensor
# c is a [n,m,p] tensor
# d is a [n,1,1] tensor

zipped = tf.data.Dataset().from_tensor_slices((a,b,c,d))
# I have confirmed that each item of serial_tensors is a tuple
# of four bytestrings.
serial_tensors = zipped.map(tf.serialize_tensor)

# Each item of serialized_features_dataset is a single bytestring
serialized_features_dataset = serial_tensors.map(tf_serialize_w_labels)
writer = tf.contrib.data.TFRecordWriter('test_output')
writeop = writer.write(serialized_features_dataset)
sess.run(writeop)
</code></pre>
<p>Is the basic format of the code I'm trying to run. It writes, but when I read in the TFRecord,</p>
<pre><code>def _parse_function(example_proto):
    # Parse the input tf.Example proto using the dictionary below.

    feature_description = {
    'a': tf.FixedLenFeature([], tf.string, default_value=''),
    'b': tf.FixedLenFeature([], tf.string, default_value=''),
    'c': tf.FixedLenFeature([], tf.string, default_value=''),
    'd': tf.FixedLenFeature([], tf.string, default_value='')
    }
    return tf.parse_single_example(example_proto, feature_description)

filenames = ['zipped_TFR']
raw_dataset = tf.data.TFRecordDataset(filenames)
parsed = raw_dataset.map(_parse_function)
parsed_it = parsed.make_one_shot_iterator()

# prints the first element of a
print(sess.run(tf.parse_tensor(parsed_it.get_next()['a'], out_type=tf.int32)))
#prints the first element of b
print(sess.run(tf.parse_tensor(parsed_it.get_next()['b'], out_type=tf.int32)))
#prints the first element of c
print(sess.run(tf.parse_tensor(parsed_it.get_next()['c'], out_type=tf.int32)))
#prints nothing
print(sess.run(tf.parse_tensor(parsed_it.get_next()['d'], out_type=tf.int32)))
</code></pre>
<p>This isn't a matter of the iterator running out, as, for example, I've tried printing d before printing a, b, or c, gotten nothing, and then successfully printed a in the same session.</p>
<p>I'm using tensorflow-gpu version 1.10, and I'm stuck with it for the moment, which is why I'm using </p>
<pre><code>writer = tf.contrib.data.TFRecordWriter('test_output')
</code></pre>
<p>In stead of </p>
<pre><code>writer = tf.data.experimental.TFRecordWriter('test_output')
</code></pre>
<h1>EDIT: Here is what worked.</h1>
<p>First I flattened a, b, c and d down to shape [n,-1]. Then I changed serialize_w_labels to the code below (leaving tf_serialize_w_examples alone).</p>
<pre><code>def serialize_w_labels(a, b, c, d, n, m, p):
    # The object we return
    ex = tf.train.SequenceExample()
    # A non-sequential feature of our example
    ex.context.feature["d"].int64_list.value.append(d)
    ex.context.feature["n"].int64_list.value.append(n)
    ex.context.feature["m"].int64_list.value.append(m)
    ex.context.feature["p"].int64_list.value.append(p)
    # Feature lists for the two sequential features of our example
    fl_a = ex.feature_lists.feature_list["a"]
    fl_b = ex.feature_lists.feature_list["b"]
    fl_c = ex.feature_lists.feature_list["c"]
    for _a, _b, _c in zip(a, b, c):
        fl_a.feature.add().int64_list.value.append(_a)
        fl_b.feature.add().int64_list.value.append(_b)
        fl_c.feature.add().float_list.value.append(_c)
    return ex.SerializeToString()
</code></pre>
<p>The following correctly parses elements of the resulting dataset:</p>
<pre><code>context_features = {
    "d": tf.FixedLenFeature([], dtype=tf.int64),
    "m": tf.FixedLenFeature([], dtype=tf.int64),
    "n": tf.FixedLenFeature([], dtype=tf.int64),
    "p": tf.FixedLenFeature([], dtype=tf.int64)
 }
sequence_features = {
    "a": tf.FixedLenSequenceFeature([], dtype=tf.int64),
    "b": tf.FixedLenSequenceFeature([], dtype=tf.int64),
    "c": tf.FixedLenSequenceFeature([], dtype=tf.float32)
}

context_parsed, sequence_parsed = tf.parse_single_sequence_example(
    serialized=ex,
    context_features=context_features,
    sequence_features=sequence_features
)
</code></pre>
<p>Your dtypes may vary, obviously. The context features can then be used to reshape the flattened a, b, and c.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you should look into <code>tf.io.FixedLenSequenceFeature</code>, which should allow you to write a sequence of features as a feature to a <code>TFRecord</code> file. It was used for example in YouTube8M dataset to store a feature which for each video was a set of frames and for each of the frames you had <code>Tensor</code>.</p>
<p>Docs:
<a href="https://www.tensorflow.org/api_docs/python/tf/io/FixedLenSequenceFeature" rel="nofollow noreferrer">https://www.tensorflow.org/api_docs/python/tf/io/FixedLenSequenceFeature</a></p>
<p>Example how to read it:
<a href="https://github.com/google/youtube-8m/blob/2c94ed449737c886175a5fff1bfba7eadc4de5ac/readers.py" rel="nofollow noreferrer">https://github.com/google/youtube-8m/blob/2c94ed449737c886175a5fff1bfba7eadc4de5ac/readers.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use the <code>tf.serialize_tensor</code> for your records then you will need to create a session and evaluate the tensor.</p>
<pre><code>_bytes_feature(sess.run(tf.serialize_tensor(features[key])))
</code></pre>
</div>
<span class="comment-copy">Thank you, this looks like it may be the fix. I also found this very simple minimal working example for working with SequenceExamples: <a href="https://github.com/dennybritz/tf-rnn/blob/master/sequence_example.ipynb" rel="nofollow noreferrer">link</a>. I will try these out and report back.</span>
