<div class="post-text" itemprop="text">
<p>What are the options to clone or copy a list in Python?</p>
<p>While using <code>new_list = my_list</code>, any modifications to <code>new_list</code> changes <code>my_list</code> everytime.
Why is this?</p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>new_list = my_list</code>, you don't actually have two lists. The assignment just copies the reference to the list, not the actual list, so both <code>new_list</code> and <code>my_list</code> refer to the same list after the assignment.</p>
<p>To actually copy the list, you have various possibilities:</p>
<ul>
<li><p>You can use the builtin <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="noreferrer"><code>list.copy()</code></a> method (available since python 3.3):</p>
<pre><code>new_list = old_list.copy()
</code></pre></li>
<li><p>You can slice it: </p>
<pre><code>new_list = old_list[:]
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Alex_Martelli" rel="noreferrer" title="Alex Martelli">Alex Martelli's</a> opinion (at least <a href="https://www.youtube.com/watch?v=g7V89K8QfgQ" rel="noreferrer" title="Bay Area Python Interest Group August 2007 Meeting">back in 2007</a>) about this is, that <em>it is a weird syntax and it does not make sense to use it ever</em>. ;) (In his opinion, the next one is more readable).</p></li>
<li><p>You can use the built in <a href="https://docs.python.org/2/library/functions.html#list" rel="noreferrer" title="list"><code>list()</code></a> function:</p>
<pre><code>new_list = list(old_list)
</code></pre></li>
<li><p>You can use generic <a href="https://docs.python.org/2/library/copy.html#copy.copy" rel="noreferrer" title="copy.copy"><code>copy.copy()</code></a>:</p>
<pre><code>import copy
new_list = copy.copy(old_list)
</code></pre>
<p>This is a little slower than <code>list()</code> because it has to find out the datatype of <code>old_list</code> first.</p></li>
<li><p>If the list contains objects and you want to copy them as well, use generic <a href="https://docs.python.org/2/library/copy.html#copy.deepcopy" rel="noreferrer" title="copy.deepcopy"><code>copy.deepcopy()</code></a>:</p>
<pre><code>import copy
new_list = copy.deepcopy(old_list)
</code></pre>
<p>Obviously the slowest and most memory-needing method, but sometimes unavoidable.</p></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>import copy

class Foo(object):
    def __init__(self, val):
         self.val = val

    def __repr__(self):
        return str(self.val)

foo = Foo(1)

a = ['foo', foo]
b = a.copy()
c = a[:]
d = list(a)
e = copy.copy(a)
f = copy.deepcopy(a)

# edit orignal list and instance 
a.append('baz')
foo.val = 5

print('original: %r\n list.copy(): %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r'
      % (a, b, c, d, e, f))
</code></pre>
<p>Result:</p>
<pre><code>original: ['foo', 5, 'baz']
list.copy(): ['foo', 5]
slice: ['foo', 5]
list(): ['foo', 5]
copy: ['foo', 5]
deepcopy: ['foo', 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</p>
<ol>
<li>10.59 sec (105.9us/itn) -  <a href="http://docs.python.org/library/copy.html#copy.deepcopy" rel="noreferrer"><code>copy.deepcopy(old_list)</code></a></li>
<li>10.16 sec (101.6us/itn) - pure python <code>Copy()</code> method copying classes with deepcopy</li>
<li>1.488 sec (14.88us/itn) - pure python <code>Copy()</code> method not copying classes (only dicts/lists/tuples)</li>
<li>0.325 sec (3.25us/itn) - <code>for item in old_list: new_list.append(item)</code></li>
<li>0.217 sec (2.17us/itn) - <code>[i for i in old_list]</code> (a <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>)</li>
<li>0.186 sec (1.86us/itn) - <a href="http://docs.python.org/library/copy.html#copy.copy" rel="noreferrer"><code>copy.copy(old_list)</code></a></li>
<li>0.075 sec (0.75us/itn) - <code>list(old_list)</code></li>
<li>0.053 sec (0.53us/itn) - <code>new_list = []; new_list.extend(old_list)</code></li>
<li>0.039 sec (0.39us/itn) - <code>old_list[:]</code> (<a href="http://docs.python.org/tutorial/introduction.html#lists" rel="noreferrer">list slicing</a>)</li>
</ol>
<p>So the fastest is list slicing. But be aware that <code>copy.copy()</code>, <code>list[:]</code> and <code>list(list)</code>, unlike <code>copy.deepcopy()</code> and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</p>
<p>(Here's the script if anyone's interested or wants to raise any issues:)</p>
<pre><code>from copy import deepcopy

class old_class:
    def __init__(self):
        self.blah = 'blah'

class new_class(object):
    def __init__(self):
        self.blah = 'blah'

dignore = {str: None, unicode: None, int: None, type(None): None}

def Copy(obj, use_deepcopy=True):
    t = type(obj)

    if t in (list, tuple):
        if t == tuple:
            # Convert to a list if a tuple to 
            # allow assigning to when copying
            is_tuple = True
            obj = list(obj)
        else: 
            # Otherwise just do a quick slice copy
            obj = obj[:]
            is_tuple = False

        # Copy each item recursively
        for x in xrange(len(obj)):
            if type(obj[x]) in dignore:
                continue
            obj[x] = Copy(obj[x], use_deepcopy)

        if is_tuple: 
            # Convert back into a tuple again
            obj = tuple(obj)

    elif t == dict: 
        # Use the fast shallow dict copy() method and copy any 
        # values which aren't immutable (like lists, dicts etc)
        obj = obj.copy()
        for k in obj:
            if type(obj[k]) in dignore:
                continue
            obj[k] = Copy(obj[k], use_deepcopy)

    elif t in dignore: 
        # Numeric or string/unicode? 
        # It's immutable, so ignore it!
        pass 

    elif use_deepcopy: 
        obj = deepcopy(obj)
    return obj

if __name__ == '__main__':
    import copy
    from time import time

    num_times = 100000
    L = [None, 'blah', 1, 543.4532, 
         ['foo'], ('bar',), {'blah': 'blah'},
         old_class(), new_class()]

    t = time()
    for i in xrange(num_times):
        Copy(L)
    print 'Custom Copy:', time()-t

    t = time()
    for i in xrange(num_times):
        Copy(L, use_deepcopy=False)
    print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time()-t

    t = time()
    for i in xrange(num_times):
        copy.copy(L)
    print 'copy.copy:', time()-t

    t = time()
    for i in xrange(num_times):
        copy.deepcopy(L)
    print 'copy.deepcopy:', time()-t

    t = time()
    for i in xrange(num_times):
        L[:]
    print 'list slicing [:]:', time()-t

    t = time()
    for i in xrange(num_times):
        list(L)
    print 'list(L):', time()-t

    t = time()
    for i in xrange(num_times):
        [i for i in L]
    print 'list expression(L):', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        a.extend(L)
    print 'list extend:', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        for y in L:
            a.append(y)
    print 'list append:', time()-t

    t = time()
    for i in xrange(num_times):
        a = []
        a.extend(i for i in L)
    print 'generator expression extend:', time()-t
</code></pre>
<p><strong>EDIT</strong>: Added new-style, old-style classes and dicts to the benchmarks, and made the python version much faster and added some more methods including list expressions and <code>extend()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've <a href="http://mail.python.org/pipermail/python-ideas/2013-July/022368.html" rel="noreferrer">been told</a> that Python 3.3+ <a href="http://bugs.python.org/issue10516" rel="noreferrer">adds <code>list.copy()</code></a> method, which should be as fast as slicing:</p>
<p><code>newlist = old_list.copy()</code></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>What are the options to clone or copy a list in Python?</h1>
</blockquote>
<p>In Python 3, a shallow copy can be made with:</p>
<pre><code>a_copy = a_list.copy()
</code></pre>
<p>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</p>
<pre><code>a_copy = a_list[:]
</code></pre>
<h2>Explanation</h2>
<p>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</p>
<h2>Shallow list copy</h2>
<p>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. </p>
<p>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</p>
<h3>Python 2</h3>
<p>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</p>
<pre><code>a_copy = a_list[:]
</code></pre>
<p>You can also accomplish the same thing by passing the list through the list constructor, </p>
<pre><code>a_copy = list(a_list)
</code></pre>
<p>but using the constructor is less efficient:</p>
<pre><code>&gt;&gt;&gt; timeit
&gt;&gt;&gt; l = range(20)
&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))
0.30504298210144043
&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))
0.40698814392089844
</code></pre>
<h3>Python 3</h3>
<p>In Python 3, lists get the <code>list.copy</code> method:</p>
<pre><code>a_copy = a_list.copy()
</code></pre>
<p>In Python 3.5:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; l = list(range(20))
&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))
0.38448613602668047
&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))
0.6309100328944623
&gt;&gt;&gt; min(timeit.repeat(lambda: l.copy()))
0.38122922903858125
</code></pre>
<h2>Making another pointer does <em>not</em> make a copy</h2>
<blockquote>
<p><strong>Using new_list = my_list then modifies new_list every time my_list changes. Why is this?</strong></p>
</blockquote>
<p><code>my_list</code> is just a name that points to the actual list in memory. When you say <code>new_list = my_list</code> you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. </p>
<pre><code>&gt;&gt;&gt; l = [[], [], []]
&gt;&gt;&gt; l_copy = l[:]
&gt;&gt;&gt; l_copy
[[], [], []]
&gt;&gt;&gt; l_copy[0].append('foo')
&gt;&gt;&gt; l_copy
[['foo'], [], []]
&gt;&gt;&gt; l
[['foo'], [], []]
</code></pre>
<p>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</p>
<h2>Deep copies</h2>
<p>To make a <a href="https://docs.python.org/library/copy.html" rel="noreferrer">deep copy of a list, in Python 2 or 3, use <code>deepcopy</code> in the <code>copy</code> module</a>:</p>
<pre><code>import copy
a_deep_copy = copy.deepcopy(a_list)
</code></pre>
<p>To demonstrate how this allows us to make new sub-lists:</p>
<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; l
[['foo'], [], []]
&gt;&gt;&gt; l_deep_copy = copy.deepcopy(l)
&gt;&gt;&gt; l_deep_copy[0].pop()
'foo'
&gt;&gt;&gt; l_deep_copy
[[], [], []]
&gt;&gt;&gt; l
[['foo'], [], []]
</code></pre>
<p>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</p>
<h2>Don't use <code>eval</code></h2>
<p>You may see this used as a way to deepcopy, but don't do it:</p>
<pre><code>problematic_deep_copy = eval(repr(a_list))
</code></pre>
<ol>
<li>It's dangerous, particularly if you're evaluating something from a source you don't trust.</li>
<li>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</li>
<li>It's also less performant. </li>
</ol>
<p>In 64 bit Python 2.7:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; import copy
&gt;&gt;&gt; l = range(10)
&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))
27.55826997756958
&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))
29.04534101486206
</code></pre>
<p>on 64 bit Python 3.5:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; import copy
&gt;&gt;&gt; l = list(range(10))
&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))
16.84255409205798
&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))
34.813894678023644
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed. </p>
<p>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by <code>my_list</code> and bound it to <code>new_list</code> as well. No matter which name you use there is still only one list, so changes made when referring to it as <code>my_list</code> will persist when referring to it as <code>new_list</code>. Each of the other answers to this question give you different ways of creating a new object to bind to <code>new_list</code>. </p>
<p>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</p>
<pre><code>new_list = list(my_list)  # or my_list[:], but I prefer this syntax
# is simply a shorter way of:
new_list = [element for element in my_list]
</code></pre>
<p>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. </p>
<pre><code>import copy  
# each element must have __copy__ defined for this...
new_list = [copy.copy(element) for element in my_list]
</code></pre>
<p>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. </p>
<pre><code>import copy
# each element must have __deepcopy__ defined for this...
new_list = copy.deepcopy(my_list)
</code></pre>
<p>See <a href="https://docs.python.org/2/library/copy.html" rel="noreferrer">the documentation</a> for more information about corner cases in copying.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>new_list = list(old_list)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>thing[:]</code></p>
<pre><code>&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; a += [3]
&gt;&gt;&gt; a
[1, 2, 3]
&gt;&gt;&gt; b
[1, 2]
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's idiom for doing this is <code>newList = oldList[:]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>All of the other contributors gave <strong>great</strong> answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only <code>copy.deepcopy()</code> works to clone/copy a list and not have it point to the nested <code>list</code> objects when you are working with multidimensional, nested lists (list of lists). While <a href="https://stackoverflow.com/users/218196/felix-kling">Felix Kling</a> refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to <code>deepcopy</code>.</p>
<p>While <code>new_list = old_list[:]</code>, <code>copy.copy(old_list)'</code> and for Py3k <code>old_list.copy()</code> work for single-leveled lists, they revert to pointing at the <code>list</code> objects nested within the <code>old_list</code> and the <code>new_list</code>, and changes to one of the <code>list</code> objects are perpetuated in the other. </p>
<h1>Edit: New information brought to light</h1>
<blockquote>
<p>As was pointed out by both <a href="https://stackoverflow.com/users/541136/aaron-hall">Aaron Hall</a> and <a href="https://stackoverflow.com/users/4014959/pm-2ring">PM 2Ring</a> <strong>using <code>eval()</code> is not only a bad idea, it is also much slower than <code>copy.deepcopy()</code>.</strong> </p>
<p>This means that for multidimensional lists, the only option is <code>copy.deepcopy()</code>. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to <code>timeit</code> using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</p>
<p>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</p>
</blockquote>
<p>As others have stated, there <strike>can be</strike> <strong><em>are significant</em></strong> performance issues using the <code>copy</code> module and <code>copy.deepcopy</code> <strong><em>for multidimensional lists</em></strong>. <strike> Trying to work out a different way of copying the multidimensional list without using <code>deepcopy</code>, (I was working on a problem for a course that only allows 5 seconds for the entire algorithm to run in order to receive credit), I came up with a way of using built-in functions to make a copy of the nested list without having them point at one another or at the <code>list</code> objects nested within them. I used <code>eval()</code> and <code>repr()</code> in the assignment to make the copy of the old list into the new list without creating a link to the old list. It takes the form of:</strike></p>
<pre><code>new_list = eval(repr(old_list))
</code></pre>
<p>Basically what this does is make a representation of <code>old_list</code> as a string and then evaluates the string as if it were the object that the string represents. By doing this, no link to the original <code>list</code> object is made. A new <code>list</code> object is created and each variable points to its own independent object. Here is an example using a 2 dimensional nested list.</p>
<pre><code>old_list = [[0 for j in range(y)] for i in range(x)] # initialize (x,y) nested list

# assign a copy of old_list to new list without them pointing to the same list object
new_list = eval(repr(old_list)) 

# make a change to new_list 
for j in range(y):
    for i in range(x):
    new_list[i][j] += 1
</code></pre>
<p>If you then check the contents of each list, for example a 4 by 3 list, Python will return </p>
<pre><code>&gt;&gt;&gt; new_list

[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]

&gt;&gt;&gt; old_list

[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
</code></pre>
<p>While this probably isn't the canonical or syntactically correct way to do it, it seems to work well. I haven't tested performance, but I am going to guess that <code>eval()</code> and <code>rep()</code> will have less overhead to run than <code>deepcopy</code> will. </p></div>
<div class="post-text" itemprop="text">
<p>Unlike other languages that have <strong>variable and value</strong>, Python has <strong>name and object</strong>.</p>
<p>This statement:</p>
<pre><code>a = [1,2,3]
</code></pre>
<p>means to give the list (object) a name <code>a</code>, and, this:</p>
<pre><code>b = a
</code></pre>
<p>just gives the same object <code>a</code> a new name <code>b</code>, so whenever you do something with <code>a</code>, the object changes and therefore <code>b</code> changes.</p>
<p>The only way to make a <strong>really</strong> copy of a is to <strong>create a new object</strong> like other answers already have said.</p>
<p>You can see more about this <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="noreferrer" title="here">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Let's start from the beginning and explorer it a little deep :</p>
</blockquote>
<p>So Suppose you have two list :</p>
<pre><code>list_1=['01','98']
list_2=[['01','98']]
</code></pre>
<p>And we have to copy both list , now starting from the first list:</p>
<p>So first let's try by general method of copy:</p>
<pre><code>copy=list_1
</code></pre>
<p>Now if you are thinking copy copied the list_1 then you can be wrong, let's check it:</p>
<blockquote>
<pre><code>The id() function shows us that both variables point to the same list object, i.e. they share this object.
</code></pre>
</blockquote>
<pre><code>print(id(copy))
print(id(list_1))
</code></pre>
<p>output:</p>
<pre><code>4329485320
4329485320
</code></pre>
<p>Surprised ? Ok let's explore it:</p>
<p>So as we know python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is <code>list</code> but we created two references to that same object by two different variable names. So both variables are pointing to the same object :</p>
<p>so when you do <code>copy=list_1</code> what actually its doing :</p>
<p><a href="https://i.stack.imgur.com/vNGqw.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/vNGqw.jpg"/></a></p>
<p>Here in the image list_1 and copy are two variable names but the object is same for both variable which is <code>list</code></p>
<p>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</p>
<pre><code>copy[0]="modify"

print(copy)
print(list_1)
</code></pre>
<p>output:</p>
<pre><code>['modify', '98']
['modify', '98']
</code></pre>
<p>So it modified the original list :</p>
<blockquote>
<p>What is the solution then?</p>
<p>Solution :</p>
</blockquote>
<p>Now let's move to a second pythonic method of copying list:</p>
<pre><code>copy_1=list_1[:]
</code></pre>
<p>Now this method fix the thing what we were facing in first issue let's check it :</p>
<pre><code>print(id(copy_1))
print(id(list_1))

4338792136
4338791432
</code></pre>
<p>So as we can see our both list having different id and it means both variables are pointing to different objects so what actually going on here is :</p>
<p><a href="https://i.stack.imgur.com/iitLk.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/iitLk.jpg"/></a></p>
<p>Now let's try to modify the list and let's see if we still face the previous problem :</p>
<pre><code>copy_1[0]="modify"

print(list_1)
print(copy_1)
</code></pre>
<p>Output:</p>
<pre><code>['01', '98']
['modify', '98']
</code></pre>
<p>So as you can see it is not modifying the original list, it only modified the copied list, So we are ok with it. </p>
<p>So now i think we are done? wait we have to copy the second nested list too so let's try pythonic way :</p>
<pre><code>copy_2=list_2[:]
</code></pre>
<p>So list_2 should reference to another object which is copy of list_2 let's check:</p>
<pre><code>print(id((list_2)),id(copy_2))
</code></pre>
<p>we get the output:</p>
<pre><code>4330403592 4330403528
</code></pre>
<p>Now we can assume both lists are pointing different object so now let's try to modify it and let's see it is giving what we want :</p>
<p>So when we try:</p>
<pre><code>copy_2[0][1]="modify"

print(list_2,copy_2)
</code></pre>
<p>it gives us output:</p>
<pre><code>[['01', 'modify']] [['01', 'modify']]
</code></pre>
<p>Now, this is little confusing we used the pythonic way and still, we are facing the same issue.</p>
<p>let's understand it:</p>
<p>So when we do :</p>
<pre><code>copy_2=list_2[:]
</code></pre>
<p>we are actually copying the outer list only, not the nested list, so nested list is same object for both list, let's check:</p>
<pre><code>print(id(copy_2[0]))
print(id(list_2[0]))
</code></pre>
<p>output:</p>
<pre><code>4329485832
4329485832
</code></pre>
<p>So actually when we do <code>copy_2=list_2[:]</code>  this is what happens:</p>
<p><a href="https://i.stack.imgur.com/3hPti.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/3hPti.jpg"/></a></p>
<p>It creates the copy of list but only outer list copy, not the nested list copy, nested list is same for both variable so if you try to modify the nested list then it will modify the original list too because nested list object is same for both nested list.</p>
<p>So what is the solution?</p>
<p>Solution is <code>deep copy</code></p>
<pre><code>from copy import deepcopy
deep=deepcopy(list_2)
</code></pre>
<p>So now let's check it :</p>
<pre><code>print(id((list_2)),id(deep))
</code></pre>
<p>output:</p>
<pre><code>4322146056 4322148040
</code></pre>
<p>both id are different  , now let's check nested list id:</p>
<pre><code>print(id(deep[0]))
print(id(list_2[0]))
</code></pre>
<p>output:</p>
<pre><code>4322145992
4322145800
</code></pre>
<p>As you can see both id are different so we can assume that both nested list are pointing different object now.</p>
<p>So when you do <code>deep=deepcopy(list_2)</code> what actually happens :</p>
<p><a href="https://i.stack.imgur.com/O7yoo.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/O7yoo.jpg"/></a></p>
<p>So both nested list are pointing different object and they have seprate copy of nested list now.</p>
<p>Now let's try to modify the nested list and let's see if it solved the previous issue or not:</p>
<p>so if we do :</p>
<pre><code>deep[0][1]="modify"
print(list_2,deep)
</code></pre>
<p>output:</p>
<pre><code>[['01', '98']] [['01', 'modify']]
</code></pre>
<p>So as you can see it didn't modify the original nested list , it only modified the copied list. </p>
<p>If you like my detailed answer , let me know by upvoting it , 
 if you have any doubt realted this answer , comment down :)</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.6.0 Timings</h2>
<p>Here are the timing results using Python 3.6.0. Keep in mind these times are relative to one another, not absolute.</p>
<p>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python2, such as <code>list.copy()</code> (the Python3 <a href="https://mail.python.org/pipermail/python-ideas/2013-July/022368.html" rel="noreferrer">slice equivalent</a>) and <a href="https://stackoverflow.com/questions/43190992/understanding-x-lst">list unpacking</a> (<code>*new_list, = list</code>):</p>
<pre><code>METHOD                  TIME TAKEN
b = a[:]                6.468942025996512   #Python2 winner
b = a.copy()            6.986593422974693   #Python3 "slice equivalent"
b = []; b.extend(a)     7.309216841997113
b = a[0:len(a)]         10.916740721993847
*b, = a                 11.046738261007704
b = list(a)             11.761539687984623
b = [i for i in a]      24.66165203397395
b = copy.copy(a)        30.853400873980718
b = []
for item in a:
  b.append(item)        48.19176080400939
</code></pre>
<p>We can see the old winner still comes out on top, but not really by a huge amount, considering the increased readability of the Python3 <code>list.copy()</code> approach.</p>
<p><strong>Note that these methods do <em>not</em> output equivalent results for any input other than lists.</strong> They all work for sliceable objects, a few work for any iterable, but only <code>copy.copy()</code> works for any Python object.</p>
<hr/>
<p>Here is the testing code for interested parties (<a href="https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python">Template from here</a>):</p>
<pre><code>import timeit

COUNT = 50000000
print("Array duplicating. Tests run", COUNT, "times")
setup = 'a = [0,1,2,3,4,5,6,7,8,9]; import copy'

print("b = list(a)\t\t", timeit.timeit(stmt='b = list(a)', setup=setup, number=COUNT))
print("b = copy.copy(a)\t\t", timeit.timeit(stmt='b = copy.copy(a)', setup=setup, number=COUNT))
print("b = a.copy()\t\t", timeit.timeit(stmt='b = a.copy()', setup=setup, number=COUNT))
print("b = a[:]\t\t", timeit.timeit(stmt='b = a[:]', setup=setup, number=COUNT))
print("b = a[0:len(a)]\t", timeit.timeit(stmt='b = a[0:len(a)]', setup=setup, number=COUNT))
print("*b, = a\t", timeit.timeit(stmt='*b, = a', setup=setup, number=COUNT))
print("b = []; b.extend(a)\t", timeit.timeit(stmt='b = []; b.extend(a)', setup=setup, number=COUNT))
print("b = []\nfor item in a: b.append(item)\t", timeit.timeit(stmt='b = []\nfor item in a:  b.append(item)', setup=setup, number=COUNT))
print("b = [i for i in a]\t", timeit.timeit(stmt='b = [i for i in a]', setup=setup, number=COUNT))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</p>
<p>You can perform list unpacking with the "splat operator": <code>*</code>, which will also copy elements of your list.</p>
<pre><code>old_list = [1, 2, 3]

new_list = [*old_list]

new_list.append(4)
old_list == [1, 2, 3]
new_list == [1, 2, 3, 4]
</code></pre>
<p>The obvious downside to this method is that it is only available in Python 3.5+.</p>
<p>Timing wise though, this appears to perform better than other common methods.</p>
<pre><code>x = [random.random() for _ in range(1000)]

%timeit a = list(x)
%timeit a = x.copy()
%timeit a = x[:]

%timeit a = [*x]

#: 2.47 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
#: 2.47 µs ± 54.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
#: 2.39 µs ± 58.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

#: 2.22 µs ± 43.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is still actual, but the same behavior holds for dictionaries as well. Look at this example.</p>
<pre><code>a = {'par' : [1,21,3], 'sar' : [5,6,8]}
b = a
c = a.copy()
a['har'] = [1,2,3]

a
Out[14]: {'har': [1, 2, 3], 'par': [1, 21, 3], 'sar': [5, 6, 8]}

b
Out[15]: {'har': [1, 2, 3], 'par': [1, 21, 3], 'sar': [5, 6, 8]}

c
Out[16]: {'par': [1, 21, 3], 'sar': [5, 6, 8]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A very simple approach independent of python version was missing in already given answers which you can use most of the time (at least I do):</p>
<pre><code>new_list = my_list * 1       #Solution 1 when you are not using nested lists
</code></pre>
<p>However, If my_list contains other containers (for eg. nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example:</p>
<pre><code>import copy
new_list = copy.deepcopy(my_list)   #Solution 2 when you are using nested lists
</code></pre>
<p>.<strong>Bonus</strong>: If you don't want to copy elements use (aka shallow copy):</p>
<pre><code>new_list = my_list[:]
</code></pre>
<hr/>
<p>Let's understand difference between Solution#1 and Solution #2</p>
<pre><code>&gt;&gt;&gt; a = range(5)
&gt;&gt;&gt; b = a*1
&gt;&gt;&gt; a,b
([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])
&gt;&gt;&gt; a[2] = 55 
&gt;&gt;&gt; a,b
([0, 1, 55, 3, 4], [0, 1, 2, 3, 4])
</code></pre>
<p>As you can see Solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</p>
<pre><code>&gt;&gt;&gt; from copy import deepcopy
&gt;&gt;&gt; a = [range(i,i+4) for i in range(3)]
&gt;&gt;&gt; a
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
&gt;&gt;&gt; b = a*1
&gt;&gt;&gt; c = deepcopy(a)
&gt;&gt;&gt; for i in (a, b, c): print i   
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]
&gt;&gt;&gt; a[2].append('99')
&gt;&gt;&gt; for i in (a, b, c): print i   
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]   #Solution#1 didn't work in nested list
[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]       #Solution #2 - DeepCopy worked in nested list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use bulit in list() function:</p>
<pre><code>newlist=list(oldlist)
</code></pre>
<p>i think this code will help you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use <code>copy.copy()</code> or <code>copy.deepcopy()</code> rather than the alternatives, for example in Python 3:</p>
<pre><code>import copy

class MyList(list):
    pass

lst = MyList([1,2,3])

lst.name = 'custom list'

d = {
'original': lst,
'slicecopy' : lst[:],
'lstcopy' : lst.copy(),
'copycopy': copy.copy(lst),
'deepcopy': copy.deepcopy(lst)
}


for k,v in d.items():
    print('lst: {}'.format(k), end=', ')
    try:
        name = v.name
    except AttributeError:
        name = 'NA'
    print('name: {}'.format(name))
</code></pre>
<p>Outputs:</p>
<pre><code>lst: original, name: custom list
lst: slicecopy, name: NA
lst: lstcopy, name: NA
lst: copycopy, name: custom list
lst: deepcopy, name: custom list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_list = my_list[:]
</code></pre>
<p><code>new_list = my_list</code>
Try to understand this. Let's say that my_list is in the heap memory at location X i.e. my_list is pointing to the X. Now by assigning <code>new_list = my_list</code> you're Letting new_list pointing to the X. This is known as shallow Copy.                                                              </p>
<p>Now if you assign <code>new_list = my_list[:]</code> You're simply copying each object of my_list to new_list. This is known as Deep copy.</p>
<p>The Other way you can do this are :</p>
<ul>
<li><code>new_list = list(old_list)</code></li>
<li><code>import copy
new_list = copy.deepcopy(old_list)</code></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You will like to use <a href="https://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">deepcopy</a> from the python standard library.</p>
<p>In python, when you copy a data type, the original and the copied data types <strong>share the same memory locations</strong>. Consequently, <strong>any changes made to a copy of object gets reflected in the original object</strong>. For example consider this:</p>
<pre><code>my_lst=[1,2,3,4,5] #Python list
print my_lst, ' my_lst (before copy)'

my_lst_copy = my_lst=[1,2,3,4,5] #Simple copy of python list
my_lst_copy[2] = 55 #Copy of python list changed

print my_lst_copy, ' my_lst_copy (copy of python list)'
print my_lst, ' my_lst (after copy)'

&gt;&gt;&gt;[1, 2, 3, 4, 5]  my_lst (before copy)
&gt;&gt;&gt;[1, 2, 55, 4, 5]  my_lst_copy (copy of python list)
&gt;&gt;&gt;[1, 2, 55, 4, 5]  my_lst (after copy)
</code></pre>
<p>As you had noticed before, and as you notice again in the above example, change in any element of the copied list <code>my_list_cp</code> changes the original list <code>my_list</code>. The reason for this is that is that there has been no new assignment to <code>my_list_cp</code>.</p>
<p>You can counteract the above by using <a href="https://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">deepcopy</a> from the python standard library. In deep copy, a copy of object is copied in other object.</p>
<pre><code>from copy import deepcopy

my_lst=[1,2,3,4,5] #Python list
print my_lst, ' my_lst (before copy)'

my_lst_copy = deepcopy(my_lst) #Python list copied
my_lst_copy[2] = 55 #Copy of python list changed

print my_lst_copy, ' my_lst_copy (copy of python list)'
print my_lst, ' my_lst (after copy)'

&gt;&gt;&gt;[1, 2, 3, 4, 5]  my_lst (before copy)
&gt;&gt;&gt;[1, 2, 55, 4, 5]  my_lst_copy (copy of python list)
&gt;&gt;&gt;[1, 2, 3, 4, 5]  my_lst (after copy)
</code></pre>
<p>In the above example you see that <code>my_lst</code> hasn't changed after copying. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the builtin <code>list.copy()</code> method (python 3.3+): 
<a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">https://docs.python.org/3/library/copy.html</a>
    new_list = old_list.copy()</p>
</div>
<span class="comment-copy">@FelixKling  I 100% agree. For an answer to an important Python question, this one is a bit scattered and out of date.</span>
<span class="comment-copy">If I’m not mistaking : <code>newlist = [*mylist]</code> also is a possibility in Python 3. <code>newlist = list(mylist)</code> maybe is more clear though.</span>
<span class="comment-copy">another possiblity is new_list = old_list * 1</span>
<span class="comment-copy">Which of these methods are shallow copy and which of them are deep copy?</span>
<span class="comment-copy">@Eswar: all but the last one do a shallow copy</span>
<span class="comment-copy">Since you are benchmarking, it might be helpful to include a reference point. Are these figures still accurate in 2017 using Python 3.6 with fully compiled code? I'm noting the answer below (<a href="https://stackoverflow.com/a/17810305/26219">stackoverflow.com/a/17810305/26219</a>) already questions  this answer.</span>
<span class="comment-copy">use the <code>timeit</code> module.  also, you can't conclude much from arbitrary micro benchmarks like this.</span>
<span class="comment-copy">If you'd like to include a new option for 3.5+, <code>[*old_list]</code> should be roughly equivalent to <code>list(old_list)</code>, but since it's syntax, not general function call pathways, it'll save a little on runtime (and unlike <code>old_list[:]</code>, which doesn't type convert, <code>[*old_list]</code> works on any iterable and produces a <code>list</code>).</span>
<span class="comment-copy">Yes, and as per docs <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">docs.python.org/3/library/stdtypes.html#mutable-sequence-types</a>, <code>s.copy()</code> creates a shallow copy of <code>s</code> (same as <code>s[:]</code>).</span>
<span class="comment-copy">You don't need a deepcopy if the list is 2D. If it is a list of lists, and those lists don't have lists inside of them, you can use a for loop. Presently, I am using   <code>list_copy=[]</code> <code>for item in list:     list_copy.append(copy(item))</code> and it is much faster.</span>
<span class="comment-copy">This won't always work, since there's no guarantee that the string returned by <code>repr()</code> is sufficient to re-create the object. Also, <code>eval()</code> is a tool of last resort; see <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">Eval really is dangerous</a> by SO veteran Ned Batchelder for details. So when you advocate the use <code>eval()</code> you <i>really</i> should mention that it can be dangerous.</span>
<span class="comment-copy">Fair point. Though I think that Batchelder's point is that the having the <code>eval()</code> function in Python in general is a risk. It isn't so much whether or not you make use of the function in code but that it is a security hole in Python in and of itself.  My example isn't using it with a function that receives input from <code>input()</code>, <code>sys.agrv</code>, or even a text file. It is more along the lines of initializing a blank multidimensional list once, and then just having a way of copying it in a loop instead of reinitializing at each iteration of the loop.</span>
<span class="comment-copy">As @AaronHall has pointed out, there is likely a significant performance issue to using <code>new_list = eval(repr(old_list))</code>, so besides it being a bad idea, it probably is also way too slow to work.</span>
<span class="comment-copy">They seem to have optimized the <code>list</code> initializer in Python 3.6.1. I don't have a Python 3.6.0 installation, but <code>b = list(a)</code> gets <code>2.7</code> and <code>b = a[:]</code> gets <code>3.1</code>, and <code>b = a.copy()</code> gets <code>3.1</code> (On my Windows and Linux with CPython 3.6.1), so <code>list()</code> is about 10% faster</span>
<span class="comment-copy">@Artyer I tested again with Python 3.6.3 (WSL 16.04) and got basically the same order</span>
<span class="comment-copy">How does this method behave when modifying copies?</span>
<span class="comment-copy">@not2qubit do you mean appending to or editing elements of the new list. In the example <code>old_list</code> and <code>new_list</code> are two different lists, editing one will not change the other (unless you’re directly mutating the elements themselves (such as list of list), none-of these methods are deep copies).</span>
<span class="comment-copy">Yeah, I meant if editing one was affecting the other. Thanks.</span>
