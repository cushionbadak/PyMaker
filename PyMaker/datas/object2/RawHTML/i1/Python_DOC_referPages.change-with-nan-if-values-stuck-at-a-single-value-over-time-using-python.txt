<div class="post-text" itemprop="text">
<p>As you can see below, <code>my</code> contains some identical consecutive values, i.e. 1, 2, and 3. </p>
<pre><code>    Date    Value
0   2017-07-18 07:40:00 1
1   2017-07-18 07:45:00 1
2   2017-07-18 07:50:00 1
3   2017-07-18 07:55:00 2414
4   2017-07-18 08:00:00 2
5   2017-07-18 08:05:00 2
6   2017-07-18 08:10:00 4416
7   2017-07-18 08:15:00 4416
8   2017-07-18 08:20:00 3
9   2017-07-18 08:25:00 3
10  2017-07-18 08:30:00 3
11  2017-07-18 08:35:00 6998
</code></pre>
<p>I aim to detect these 'dead values' whenever they stuck in a minimum of 3 rows and change them all with NaN because I want to eliminate them.  </p>
<p>This is my attempt:    </p>
<pre><code>df['Value'] = df['Value'].loc[df['Value'].shift() != df['Value']]  
</code></pre>
<p>But it gives:    </p>
<pre><code>Date    Value
0   2017-07-18 07:40:00 1.0
1   2017-07-18 07:45:00 NaN
2   2017-07-18 07:50:00 NaN
3   2017-07-18 07:55:00 2414.0
4   2017-07-18 08:00:00 2.0
5   2017-07-18 08:05:00 NaN
6   2017-07-18 08:10:00 4416.0
7   2017-07-18 08:15:00 NaN
8   2017-07-18 08:20:00 3.0
9   2017-07-18 08:25:00 NaN
10  2017-07-18 08:30:00 NaN
11  2017-07-18 08:35:00 6998.0
</code></pre>
<p>I want all 1 and 3 to be changed with NaN like below because they have similar values for three consecutive rows.    </p>
<pre><code>Date    Value
0   2017-07-18 07:40:00 NaN
1   2017-07-18 07:45:00 NaN
2   2017-07-18 07:50:00 NaN
3   2017-07-18 07:55:00 2414.0
4   2017-07-18 08:00:00 2.0
5   2017-07-18 08:05:00 2.0
6   2017-07-18 08:10:00 4416.0
7   2017-07-18 08:15:00 4416.0
8   2017-07-18 08:20:00 NaN
9   2017-07-18 08:25:00 NaN
10  2017-07-18 08:30:00 NaN
11  2017-07-18 08:35:00 6998.0
</code></pre>
<p>I want to use the derivative. Namely, if the difference of 3 consecutive rows &lt; 0.0001, change them with NaN.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could <code>GroupBy</code> consecutive values using a custom grouping scheme, check which groups have a size greater or equal to <code>3</code> and use the result to index the dataframe and set the rows of interest to <code>NaN</code>:</p>
<pre><code>g = df.Value.diff().fillna(0).ne(0).cumsum()
m = df.groupby(g).Value.transform('size').ge(3)
df.loc[m,'Value'] = np.nan

    Date   Value
0   2017-07-18-07:40:00     NaN
1   2017-07-18-07:45:00     NaN
2   2017-07-18-07:50:00     NaN
3   2017-07-18-07:55:00  2414.0
4   2017-07-18-08:00:00     2.0
5   2017-07-18-08:05:00     2.0
6   2017-07-18-08:10:00  4416.0
7   2017-07-18-08:15:00  4416.0
8   2017-07-18-08:20:00     NaN
9   2017-07-18-08:25:00     NaN
10  2017-07-18-08:30:00     NaN
11  2017-07-18-08:35:00  6998.0
</code></pre>
<hr/>
<p>Where:</p>
<pre><code>df.assign(grouper=g, mask=m, result=df_.Value)

           Date           Value   grouper mask  result
0   2017-07-18-07:40:00      1        0   True     NaN
1   2017-07-18-07:45:00      1        0   True     NaN
2   2017-07-18-07:50:00      1        0   True     NaN
3   2017-07-18-07:55:00   2414        1  False  2414.0
4   2017-07-18-08:00:00      2        2  False     2.0
5   2017-07-18-08:05:00      2        2  False     2.0
6   2017-07-18-08:10:00   4416        3  False  4416.0
7   2017-07-18-08:15:00   4416        3  False  4416.0
8   2017-07-18-08:20:00      3        4   True     NaN
9   2017-07-18-08:25:00      3        4   True     NaN
10  2017-07-18-08:30:00      3        4   True     NaN
11  2017-07-18-08:35:00   6998        5  False  6998.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Count the values. The result is a series, it needs a name for further references:</p>
<pre><code>counts = df['Value'].value_counts()
counts.name = '_'
</code></pre>
<p>Merge the select values from the series with the original dataframe:</p>
<pre><code>keep = counts[counts &lt; 3]
df.merge(keep, left_on='Value', right_index=True)[df.columns]
#                   Date  Value
#3  2017-07-18  07:55:00   2414
#4  2017-07-18  08:00:00      2
#5  2017-07-18  08:05:00      2
#6  2017-07-18  08:10:00   4416
#7  2017-07-18  08:15:00   4416
#11 2017-07-18  08:35:00   6998
</code></pre>
<p>The result is a filtered dataframe.</p>
<p>If you use pandas version &lt;0.24, you should upgrade, but here is a workaround:</p>
<pre><code>df.merge(pd.DataFrame(keep), left_on='Value', right_index=True)[df.columns]
</code></pre>
</div>
<span class="comment-copy">Exactly 3 rows? Or minimum 3 rows?</span>
<span class="comment-copy">Minimum 3 rows. Question edited.</span>
<span class="comment-copy">Here, the result is the opposite. 1 and 3 stay, the rest are changed to NaN.</span>
<span class="comment-copy">Updated @k.koen , works now</span>
<span class="comment-copy">It return error here, "can not merge DataFrame with instance of type &lt;class 'pandas.core.series.Series'&gt;"</span>
<span class="comment-copy">What is your pandas version? If it is below 0.24, then you probably should upgrade.</span>
<span class="comment-copy">I use pandas 0.23.4</span>
<span class="comment-copy">See the updated answer.</span>
