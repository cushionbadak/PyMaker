<div class="post-text" itemprop="text">
<p>I need to loop in a list containing french words and find an asterisk because I want to concatenate the word before the asterisk and the word after the asterisk each time an asterisk appear and continue to the next. 
For example, in the sequence:</p>
<pre><code>['les','engage', '*', 'ment', 'de','la'] 
</code></pre>
<p>I want to concatenate 'engage' and 'ment' and the output (engagement) should be checked by a dictionary. If in the dictionary, append to a list.   </p>
<p>With my code I only get the asterisk:</p>
<pre><code>import nltk
from nltk.tokenize import word_tokenize
import re


with open ('text-test.txt') as tx:
    text =word_tokenize(tx.read().lower())



with open ('Fr-dictionary.txt') as fr:
    dic = word_tokenize(fr.read().lower())


ast=re.compile(r'[\*]+')
regex=list(filter(ast.match,text))

valid_words=[]
invalid_words=[]

last = None
for w in text:
    if w in regex:
        last=w 
        a=last + w[+1]
        break
if a in dic:
    valid_words.append(a)
else:
    continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wondered how to manage a list (nonsense) like this:</p>
<pre><code>words = ['Bien', '*', 'venue', 'pour', 'les','engage', '*', 'ment', 'trop', 'de', 'YIELD', 'peut','être','contre', '*', 'productif' ]
</code></pre>
<p>So I came u with a method like this:</p>
<pre><code>def join_asterisk(ary):
  i, size = 0, len(ary)
  while i &lt; size-2:
    if ary[i+1] == '*':
      yield ary[i] + ary[i+2]
      i+=2
    else: yield ary[i]
    i += 1
  if i &lt; size:
    yield ary[i]
</code></pre>
<p>Which returns:</p>
<pre><code>print(list(join_asterisk(words)))
#=&gt; ['Bienvenue', 'pour', 'les', 'engagement', 'trop', 'de', 'YIELD', 'peut', 'être', 'contreproductif']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of thinking "time travel" (i.e. go back and forth), the Pythonic way would be to think functional (time travel has it's place in very resource constrained environments).</p>
<p>One way is to go the enumeration way as @Yosufsn showed. Another is to <code>zip</code> the list with itself, but with padding appended on either side. Like this:</p>
<pre><code>words = ['les','engage', '*', 'ment', 'de','la'] 
for a,b,c in zip([None]*2+words, [None]+words+[None], words+[None]*2):
    if b == '*':
        print( a+c )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you need a simple code like this:</p>
<pre><code>words = ['les','engage', '*', 'ment', 'de','la']

for n,word in enumerate (words):
    if word == "*":
        exp = words[n-1] + words[n+1]
        print (exp)
</code></pre>
<p>Output:</p>
<pre><code>"engagement"
</code></pre>
<p>With this output, you can subsequently check with your dictionary.</p>
</div>
<span class="comment-copy">So when concatenated word is found in dictionary, do you want the list to become: <code>['les','engagement', 'de','la']</code> or use a different list altogether?</span>
<span class="comment-copy">I want the list to become ['les','engagement', 'de','la'] but only if the result of the concatenation is in the dictionary, otherwise, append to a different list</span>
<span class="comment-copy">that's very good! thanks! This solution only joins the word and does not check if the resultant string is in a dictionary...I need to do that because certainly there will be strings joined that are not words since the asterisk represents the end of a paragraph and I want to connect the words that were separated by line breaks.</span>
<span class="comment-copy">is it possible to check if the result of your concatenation is in a french a dictionary? If so, could you update the code? I have never used Yield so I don't know where to place this check. Thanks</span>
<span class="comment-copy">Oui, @NatáliaResende. For example add a nested <code>if/else</code> under if <code>ary[i+1] == '*':</code> so, if the joined word is in the dictionary it yields it. Else it <code>yield ary[i]</code> and also <code>yield ary[i+2]</code></span>
<span class="comment-copy">thank you so much! I will try that!</span>
<span class="comment-copy">could it be better with <code>for a,b,c in zip(['']*2+words, ['']+words+[''], words+['']*2):</code> ? to avoid error in case  list begins or ends with a *</span>
<span class="comment-copy">@PRMoureu: Depends on the desired semantics. If a <code>*</code> at the head or end of a list is expected data, then yes, that would be the right choice. Otherwise it might be desireable an exception to actually be raised.</span>
<span class="comment-copy">careful if the list begins or ends with a <code>*</code></span>
<span class="comment-copy">Thank you very much. My list is much bigger than this one. This list in my post was just to illustrate the problem. Does the code work for a bigger list?</span>
<span class="comment-copy">@PRMoureu, why did you use 'enumerate'?</span>
<span class="comment-copy">He did so to obtain an index for each word. <code>enumerate</code> will return <code>(0, 'les'), (1,'engage'),....</code></span>
<span class="comment-copy">@PRMoureu, I understand now why you used enumerate. I think this code also works for a bigger list, right?</span>
