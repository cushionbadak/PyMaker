<div class="post-text" itemprop="text">
<p>The first thing my python script is doing is to create an output directory:</p>
<pre><code>def create_output_directory():
    # creating output folder and link to latest
    output_folder = 'output_%s' % datetime.now().strftime('%Y%m%d')
    if os.path.exists(output_folder):
        logger.warning('previous directory %s exists, file will be overwritten' % output_folder)
    else:
        os.mkdir(output_folder)
    if os.path.exists('output_latest'):
        os.remove('output_latest')
    os.symlink(output_folder, 'output_latest')
    return output_folder
</code></pre>
<p>so you get an empty directory <code>output_20190319</code> and a symlink <code>output_latest</code> to it.</p>
<p>I want to run in parallel different instances of my python script, with different argument. In a shell script:</p>
<pre><code>python myscript.py arg1 &amp;
sleep 1
python myscript.py arg2 &amp;
sleep 1
python myscript.py arg3 &amp;
</code></pre>
<p>usually this works without any problem, but sometime I get:</p>
<pre><code>  File "myscript.py", line 16, in create_output_directory                                                                                                                      
      os.mkdir(output_folder)                                                                                                                                                                                        
OSError: [Errno 17] File exists: 'output_20190319'    
</code></pre>
<p>I am not sure to understand. Isn't 1 second not enough to create a directory and to avoid race conditions? Are there better solution? File lock?</p>
</div>
<div class="post-text" itemprop="text">
<p>One second  is not enough.</p>
<p>Try:</p>
<pre><code>str(os.getpid())
</code></pre>
<p>So for readability:</p>
<pre><code>output_folder = 'output_%s' % str(os.getpid())
</code></pre>
<p>It's still technically possible  for two processes to come up in a row with the same pid if they are  running fast, so if one came and went and the next instance came with the same pid you'd get another collision. Consider the tempfile module perhaps. </p>
<p>Then back to:</p>
<pre><code>output_folder = 'output_%s_%s' % (datetime.now().strftime('%Y%m%d'), str(os.getpid()))
</code></pre>
<p>For a similar need, I've implemented a try / except before where  it retries until it gets the unique name, sleeping briefly between retries, in my case I needed a particular name w/o random strings. Nothing elegant about it, I wrote it quickly. </p>
</div>
<span class="comment-copy">Starting from <code>3.2</code> you can pass <code>exist_ok=True</code> to <code>os.mkdir</code> , so it won't raise the exception</span>
<span class="comment-copy">Why do you use a shell script as an additional layer? Wouldn't it be better to just call one python script and let python do the parallel work with threads? In this case you can use some locking mechanism to prevent race conditions. Also you could create the needed directories before the calculation will start.</span>
<span class="comment-copy">I want all the processes to write on the same directory. I want the first process to create the directory.</span>
<span class="comment-copy">I see. So my answer isn't in the direction you wanted since you wanted a single dir. In that case you could simply try what taras suggested using exist_ok. However you have a potential bug if you start your workload just before midnight so it might split over two days.</span>
