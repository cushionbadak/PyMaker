<div class="post-text" itemprop="text">
<p>I am using selenium with Firefox to automate some tasks on Instagram. It basically goes back and forth between user profiles and notifications page and does tasks based on what it finds.</p>
<p>It has one infinite loop that makes sure that the task keeps on going. I have sleep() function every few steps but the memory usage keeps increasing. I have something like this in Python:</p>
<pre><code>while(True):
    expected_conditions()
    ...doTask()
    driver.back()
    expected_conditions()
    ...doAnotherTask()
    driver.forward()
    expected_conditions()
</code></pre>
<p>I never close the driver because that will slow down the program by a lot as it has a lot of queries to process. Is there any way to keep the memory usage from increasing overtime without closing or quitting the driver?</p>
<p>EDIT: Added explicit conditions but that did not help either. I am using headless mode of Firefox.</p>
</div>
<div class="post-text" itemprop="text">
<p>To start with <em>Selenium</em> have very little control over the amount of <em>RAM</em> used by <em>Firefox</em>. As you mentioned the <em>Browser Client</em> i.e. <em>Mozilla</em> goes back and forth between user profiles and notifications page on <em>Instagram</em> and does tasks based on what it finds is too broad as a single <em>usecase</em>. So, the first and foremost task would be to break up the <em>infinite loop</em> pertaining to your <em>usecase</em> into smaller <em>Tests</em>.</p>
<hr/>
<h2>time.sleep()</h2>
<p>Inducing <code>time.sleep()</code> vitually puts a blanket over the underlying issue. However while using <em>Selenium</em> and <em>WebDriver</em> for <em>Automation</em> using <strong><code>time.sleep(secs)</code></strong> without any <em>specific condition to achieve</em> <strong>defeats the purpose of <em>Automation</em></strong> and should be avoided at any cost. As per the documentation:</p>
<blockquote>
<p><a href="https://docs.python.org/2/library/time.html#time.sleep" rel="nofollow noreferrer"><strong><code>time.sleep(secs)</code></strong></a> suspends the execution of the current thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signalâ€™s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</p>
</blockquote>
<p>You can find a detailed discussion in <a href="https://stackoverflow.com/questions/52603847/how-to-sleep-webdriver-in-python-for-milliseconds/52607451#52607451">How to sleep webdriver in python for milliseconds</a></p>
<hr/>
<h2>Analysis</h2>
<p>There were previous instances when <em>Firefox</em> consumed about 80% of the RAM.</p>
<p><a href="https://i.stack.imgur.com/hkubS.png" rel="nofollow noreferrer"><img alt="Firefox_RAM" src="https://i.stack.imgur.com/hkubS.png"/></a></p>
<p>However as per <a href="https://support.mozilla.org/en-US/questions/1223605" rel="nofollow noreferrer">this discussion</a> some of the users feels that <em>the more memory is used the better because it means you don't have RAM wasted. Firefox uses RAM to make its processes faster since application data is transferred much faster in RAM.</em></p>
<hr/>
<h2>Solution</h2>
<p>You can implement either/all of the generic/specific steps as follows:</p>
<ul>
<li>Upgrade <em>Selenium</em> to  current levels <a href="https://docs.seleniumhq.org/download/" rel="nofollow noreferrer"><strong>Version 3.141.59</strong></a>.</li>
<li>Upgrade <em>GeckoDriver</em> to <a href="https://github.com/mozilla/geckodriver/releases" rel="nofollow noreferrer"><strong>GeckoDriver v0.24.0</strong></a> level.</li>
<li>Upgrade <em>Firefox</em> version to <strong><em>Firefox v65.0.2</em></strong> levels.</li>
<li><em>Clean</em> your <em>Project Workspace</em> through your <em>IDE</em> and <em>Rebuild</em> your project with required dependencies only.</li>
<li>If your base <em>Web Client</em> version is too old, then uninstall it and install a recent GA and released version of <em>Web Client</em>.</li>
<li><p>Some extensions allow you to block such unnecessary content, as an example:</p>
<ul>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/" rel="nofollow noreferrer">uBlock Origin</a> allows you to hide ads on websites.</li>
<li><a href="https://addons.mozilla.org/en-US/firefox/addon/noscript/" rel="nofollow noreferrer">NoScript</a> allows you to selectively enable and disable all scripts running on websites.</li>
<li><p>To open the <em>Firefox</em> client with an extension you can download the extension i.e. the <code>XPI</code> file from <a href="https://addons.mozilla.org" rel="nofollow noreferrer">https://addons.mozilla.org</a> and use the <a href="https://seleniumhq.github.io/selenium/docs/api/py/webdriver_firefox/selenium.webdriver.firefox.firefox_profile.html#selenium.webdriver.firefox.firefox_profile.FirefoxProfile.add_extension" rel="nofollow noreferrer"><code>add_extension(extension='webdriver.xpi')</code></a> method to add the extension in a <em>FirefoxProfile</em> as follows:</p>
<pre><code>from selenium import webdriver

profile = webdriver.FirefoxProfile() 
profile.add_extension(extension='extension_name.xpi')
driver = webdriver.Firefox(firefox_profile=profile, executable_path=r'C:\path\to\geckodriver.exe') 
</code></pre></li>
</ul></li>
<li><p>If your <em>Tests</em> doesn't requires the <em>CSS</em> you can disable the <em>CSS</em> following the <a href="https://stackoverflow.com/questions/49031428/how-to-disable-css-in-python-selenium-using-chromeoptions/53481064#53481064">this discussion</a>.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Creating new firefox profile and use it every time while running test cases in Firefox shall eventually increase the performance of execution as without doing so always new profile would be created and caching information would be done there and if driver.quit does not get called somehow before failure then in this case, every time we end up having new profiles created with some cached information which would be consuming memory.</p>
<p>// ------------ Creating a new firefox profile -------------------</p>
<pre><code>1. If Firefox is open, close Firefox.
2. Press Windows +R on the keyboard. A Run dialog will open.
3. In the Run dialog box, type in firefox.exe -P
Note: You can use -P or -ProfileManager(either one should work).
4. Click OK.
5. Create a new profile and sets its location to the RAM Drive.
</code></pre>
<p>// ----------- Associating Firefox profile ------------------- </p>
<pre><code>ProfilesIni profile = new ProfilesIni();
FirefoxProfile myprofile = profile.getProfile("automation_profile");
WebDriver driver = new FirefoxDriver(myprofile);
</code></pre>
<p>Please share execution performance with community if you plan to implement this way.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><strong>Use Explicit Waits or Implicit Waits.</strong> </li>
<li><strong>Use driver.quit() to close all
the browser windows and terminate the WebDriver session because if
you do not use quit() at the end of the program, the WebDriver
session will not be closed properly and the files will not be cleared
off memory. And this may result in memory leak errors.</strong></li>
</ul>
</div>
<span class="comment-copy">Try to avoid using sleep method, use Explicit Waits or Implicit Waits methods see this for more information <a href="https://selenium-python.readthedocs.io/waits.html" rel="nofollow noreferrer">selenium-python.readthedocs.io/waits.html</a></span>
<span class="comment-copy">Alright. I will try to do that tomorrow and post the discovery here.</span>
<span class="comment-copy">A change from <code>sleep()</code> to waits <b>won't change</b> anything re: mem usage. Te reason for not using sleep is because this hardcodes an interval where your script is not doing anything, in the hope the page will change state; and with the *Wait the interval is not hardcoded, but "as soon as the change happened ". In your usecase it does sound like you use the <code>sleep()</code> as delimiter between executions, and running in an infinite loop you don't sound like you'd care for shaving a few seconds off.</span>
<span class="comment-copy">Hi. The driver, Firefox and Selenium are all up-to-date. My workspace was new but I cleaned and rebuilt it again. It didn't seem to affect the performance in any way. I have also gotten rid of time.sleep and using explicit conditions provided in Selenium I'm using headless mode for firefox, would css/scripts still matter for that?</span>
<span class="comment-copy">@NaeemKhan Of coarse it matters. Check out the discussion for disabling CSS within my answer.</span>
<span class="comment-copy">There doesn't seem to be an add_experimental_option() function in FirefoxOptions(). How would I disable it for Firefox?</span>
<span class="comment-copy">Ok so I have disabled css by firefoxProfile.set_preference('permissions.default.stylesheet', 2) and images as well. It still did not make a difference. The Ram usage is still increasing. I think the problem could be Instagram's heavy usage of javascript and AJAX usage?</span>
<span class="comment-copy">It still didn't solve the problem but it was the closest to my problem, so I will accept the answer.</span>
<span class="comment-copy">I'm using headless mode though. Would using a different profile even matter?</span>
<span class="comment-copy">I would still say yes you shall give a try. because caching information shall be part of profile management in headless mode too. Apart from this, i would like to share, The headless mode of Mozilla Firefox performs 3.68% better than the UI version. This is a disappointment since the Chrome's headless mode achieves &gt; 30% better time than the UI one.</span>
<span class="comment-copy">Adding Explicit waits did not help, it's still the same story. The memory usage keeps increasing.  I did find a temporary work around by adding an inner loop to run X number of times before closing/quitting the driver, and the infinite loop starts the driver again and goes into that loop again. It does prevent it from eating up all the memory but that is not a proper solution.</span>
<span class="comment-copy">are you used driver.quit()?</span>
<span class="comment-copy">Yeah. Did did driver.close() then driver.quit()</span>
