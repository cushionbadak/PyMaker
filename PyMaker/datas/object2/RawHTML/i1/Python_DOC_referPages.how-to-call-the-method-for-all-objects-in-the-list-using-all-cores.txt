<div class="post-text" itemprop="text">
<p>There is a list of some objects which have some method <code>f()</code>.<br/>
This is the calling method <code>f()</code> for all objects in the list.</p>
<pre><code>for item in items:
    item.f()
</code></pre>
<p><code>f()</code> works independently for all objects. So it can be called for several objects in the same time.<br/>
How can I rewrite this code to use all the cores?</p>
</div>
<div class="post-text" itemprop="text">
<p>In cpython threads are not executed in parallel, so you have to use processes or async. You could use the <code>multiprocessing.pool</code> or the <code>concurrent.futures.ProcessPoolExecutor</code> library and then use the map function to execute the function on all objects. Be careful, if you set max_workers equal or hight than the number of CPU cores other programs might experience lag.</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
with ProcessPoolExecutor(max_workers) as executor:
    result =  executor.map(lambda x: x.f(), items)
</code></pre>
</div>
<span class="comment-copy">either use the <code>multiprocessing</code> module or even better: If possible and compatible with <code>numba</code>, translating all methods to numba and calling the loop from within a numba jitted function will increase the performance vastly.</span>
<span class="comment-copy"><a href="https://pastebin.com/WEPN1WN8" rel="nofollow noreferrer">pastebin.com/WEPN1WN8</a>. #1 Works. #2 Doesn't. What can be a reason?</span>
<span class="comment-copy">Probably because of the lambda. Try using a dedicated function.</span>
<span class="comment-copy"><a href="https://pastebin.com/b4XH3uMz" rel="nofollow noreferrer">pastebin.com/b4XH3uMz</a> now works but wrong. Fuction is not calling</span>
<span class="comment-copy">Convert the result to list. It should work then: result = executor.map... result = list(result)</span>
