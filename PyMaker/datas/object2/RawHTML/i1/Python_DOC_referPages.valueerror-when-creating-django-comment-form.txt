<div class="post-text" itemprop="text">
<p>I have a problem when I was creating the comment form with django. After I wrote my  view.py, models.py and html, I got an <code>ValueError</code> that said: </p>
<pre><code>Cannot assign "&lt;class 'blog.models.post'&gt;": "Comment.post" must be a "post" instance". 
</code></pre>
<p>Below are my codes.</p>
<p>HTML</p>
<pre><code>{% block content %}
&lt;h1&gt;Add New Comment:&lt;/h1&gt;
&lt;form method='POST' action=''&gt;
    {% csrf_token %}
    {{ form.as_p }}
&lt;button type='submit'&gt;Submit&lt;/button&gt;
&lt;/form&gt;
{% endblock %}
</code></pre>
<p>views.py</p>
<pre><code>def add_comment(request, slug):
    po = get_object_or_404(post, slug=slug)
    if request.method == 'POST':
        form = CommentForm(request.POST or None)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.post = post
            comment.save()
            return redirect('blog:post', slug=post.slug)
    else:
        form = CommentForm()
    return render(request, 'blog/post/add_comment.html', {'form': form})
</code></pre>
<p>models.py</p>
<pre><code>class Comment(models.Model):
    post = models.ForeignKey(post, related_name='comments', on_delete=models.CASCADE)
    user = models.CharField(max_length=250)
    email = models.EmailField() 
    body = models.TextField() 
    created = models.DateTimeField(auto_now_add=True) 
    approved = models.BooleanField(default=False) 

    def approved(self):
        self.approved = True
        self.save()

    def __str__(self):
        return self.user
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The post you fetched from the database is <code>po</code>:</p>
<pre><code>po = get_object_or_404(post, slug=slug)
</code></pre>
<p>Therefore you should set <code>form.post = po</code>:</p>
<pre><code>def add_comment(request, slug):
    po = get_object_or_404(post, slug=slug)
    if request.method == 'POST':
        form = CommentForm(request.POST or None)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.post = po
            comment.save()
</code></pre>
<p>Note that normally in Django you would use <code>Post</code> for your model and <code>post</code> for the instance you fetch from the database.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try it:</p>
<pre><code>class Comment(models.Model):
    post = models.ForeignKey(Post, related_name='comments', on_delete=models.CASCADE)
</code></pre>
</div>
<span class="comment-copy">Your method <code>approved</code> clashes with the field. Rename so it doesn't clash, for example to <code>def approve(self):</code>.</span>
<span class="comment-copy">after I changed 'post' to 'po'. But, I got another error 'NoReverseMatch' which said Reverse for 'post' not found. 'post' is not a valid view function or pattern name.</span>
<span class="comment-copy">That's a separate issue. Make sure the URL pattern you want to redirect to has <code>name='post'</code>. <a href="https://stackoverflow.com/questions/38390177/what-is-a-noreversematch-error-and-how-do-i-fix-it">This question</a> might help. If not, you need to show your URL patterns.</span>
<span class="comment-copy">I tried to do it but didn't work. This is my URL pattern: url(r'^(?P&lt;slug&gt;[-\w]+)/comment/$', views.add_comment, name='add_comment')</span>
<span class="comment-copy">That’s the URL where you add the comment. Either it’s the URL pattern that you’re trying to redirect to that has the issue, or you don’t have <code>app_name = 'blog'</code> in the <code>blog/urls.py</code>.</span>
<span class="comment-copy">Now I get it. Thank you:))</span>
