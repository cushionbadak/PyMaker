<div class="post-text" itemprop="text">
<p>Hello im learning python and i get class topic.
I recived a error message like this:</p>
<p><code>"TypeError: __init__() missing 1 required positional argument: 'y'"</code></p>
<p>this is my code from shell:</p>
<pre><code>class Vektor():
    """ Bu bir vektör sınıfıdır"""
    def __init__(self,x,y):
        self.x = x
        self.y = y
    def boyu(self):
        boy = (self.x**2+self.y**2)**0.5
        return boy
    def __repr__(self):
        return ("%di + %dy" %(self.x, self.y))
    def __sub__(self,digeri):
        return Vektor(self.x - digeri.x, self.y - digeri.y)
    def __add__(self,digeri):
        return Vektor(self.x + digeri.x, self.y + digeri.y)
    def __eq__(self,digeri):
        if self.boyu() == digeri.boyu(): return True
    def __mul__(self,digeri):
        self.x = Vektor(self.x + digeri.x)
        self.y = Vektor(self.y + digeri.y)
        return Vektor(self.x*digeri.x,self.y*digeri.y)
</code></pre>
<p>When i try to create a C = A*B like this i get error:</p>
<p>TypeError: <strong>init</strong>() missing 1 required positional argument: 'y'</p>
<p>Im already thank you and i want to remind im a newbite in programming :)) </p>
</div>
<div class="post-text" itemprop="text">
<p>How many arguments does <code>Vektor.__init__</code> require? Ignoring <code>self</code>, it's two - <code>x</code> and <code>y</code>.</p>
<p>When you wrote <code>return Vektor(self.x*digeri.x,self.y*digeri.y)</code>, you passed two arguments, so this works.</p>
<p>When you wrote <code>self.x = Vektor(self.x + digeri.x)</code>, this doesn't work, because you don't pass a second argument for the <code>y</code> value.</p>
<p>When Python gave you the error, it should have included a line number, which is supposed to show where the error occurred. You didn't include that, but it was this line, wasn't it?</p>
<p>Since <code>Vektor</code> is supposed to contain two scalars and not sometimes replace them with two vectors, you could just write</p>
<pre><code>    self.x = self.x + digeri.x # still not a vector
    self.y = self.y + digeri.y # also not a vector
</code></pre>
<p>but the more important lesson is to <em>read the error message carefully</em>. Everything you needed was there.</p>
<hr/>
<p>A note on operator semantics: since you wouldn't normally expect an expression like <code>x = v * w</code> to modify <code>x</code>, you shouldn't be mutating <code>self</code> inside the operator function anyway.</p>
<p>You return the resultant vector, which is enough. I showed you how to fix the <em>syntax</em> of those two lines, but you should really just remove them entirely.</p>
<p>And another note on vectors: overloading <code>*</code> isn't such an obvious win as it is for a scalar numeric type, because vectors usually have more than one possible type of product.</p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>__mul__</code> you do for some reason:</p>
<pre><code>self.x = Vektor(self.x + digeri.x)
</code></pre>
<p>which is calling <code>Vektor.__init__</code> providing only the positional argument <code>x</code>, with the value <code>self.x + digeri.x</code>, but nothing for <code>y</code>, thus the error.
Also this attempts to change the attribute <code>x</code> into an object from <code>Vektor</code> itself, I can't imagine that this is somehow what you want.</p>
<p>To me it is not clear what the 2 lines before the <code>return</code> statement in your <code>__mul__</code> are supposed to do. Also both lines will produce the error you see.</p>
<p>Should your <code>__mul__</code> be the dot product? If so, try:</p>
<pre><code>return self.x*digeri.x + self.y*digeri.y
</code></pre>
<p>Another simplification to your class could be to allow iteration on your coords, like:</p>
<pre><code>@property
def coords(self):
    return self.x, self.y

def __iter__(self):
    return self.coords.__iter__()
</code></pre>
<p>Then your dot product might just look like:</p>
<pre><code>def dot(self, w):
    """ 
    The dot product of self and other vector w.
    """
    return sum([xi_s * xi_w for xi_s, xi_w in zip(self, w)])
</code></pre>
<p>There is <a href="https://github.com/j-i-l/VecPy/blob/master/vecpy/vecpy.py" rel="nofollow noreferrer">VecPy</a>, a very simple example class that does this kind of things. Maybe having a look can give you some more ideas.</p>
</div>
<div class="post-text" itemprop="text">
<p>The error is due to </p>
<pre><code>self.x = Vektor(self.x + digeri.x)
</code></pre>
<p>When we call Vector like the way you write the syntax, it is thinking that you want to initialize it and it is expecting two inputs. Just get rid of the first two lines of mul function should fix the problem.</p>
</div>
<span class="comment-copy">You could drop the first 2 lines from <i>__mul__</i>, and only leave <code>def __mul__(self, digeri):</code> <code>return Vektor(self.x * digeri.x, self.y * digeri.y)</code>.</span>
<span class="comment-copy">Maybe it would help if you explained to us what "Vektor multiplication" is. It can't be <a href="https://en.wikipedia.org/wiki/Dot_product" rel="nofollow noreferrer">dot product</a>, because dot product returns a scalar, not a vector. And it can't be <a href="https://en.wikipedia.org/wiki/Cross_product" rel="nofollow noreferrer">cross product</a>, because cross product requires three dimensional vectors. What is <code>__mul__</code> really trying to do?</span>
<span class="comment-copy">I'm curious why he's mutating self.x and self.y in the first place. binary operator overloads should ideally have no side-effects.</span>
<span class="comment-copy">Good point, I hadn't even thought about the dodgy semantics</span>
