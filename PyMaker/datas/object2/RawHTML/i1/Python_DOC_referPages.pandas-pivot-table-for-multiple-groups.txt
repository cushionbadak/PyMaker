<div class="post-text" itemprop="text">
<p>I have a pandas dataframe like:</p>
<pre><code>%pylab inline

import seaborn as sns
sns.set(color_codes=True)

import pandas as pd
import numpy as np
df = pd.DataFrame({"user_id": [1, 2, 3, 4, 5,
                          6, 7, 8, 9],
    "is_sick": [0, 0, 0, 0, 0,
                          0, 1, 1, 1],
                    "sex": ["male", "female", "male", "female", "female",
                          "male", "male", "female", "female"],
                    "age_group": ["young", "old", "old", "young",
                          "small", "old", "young", "young",
                          "old"],
                    "metric_1": [1, 2, 2, 3, 3, 4, 5, 6, 7]})
df['date'] = '2019-01-01'
df['qcut_metric_1'] = pd.qcut(df.metric_1, [0, .25, .5, .66, .75, .97, 1])

# make some more data
df_2 = df.copy()
df_2['date'] = '2019-02-01'
df = pd.concat([df, df_2])
</code></pre>
<p>Now, I want to calculate the percentage of sick people per group / cohort <code>[(sex), (age_group), (sex, age_group)]</code> for each bin of the metric.</p>
<p>Note, I am aware that a single aggregation i.e. for <code>sex</code> could look similar to:</p>
<pre><code>df['sick_percentage__sex'] = df.groupby(['sex']).is_sick.transform(pd.Series.mean)
</code></pre>
<p>A naive table could look like:</p>
<pre><code>pd.pivot_table(df, values='sick_percentage__sex', index=['qcut_metric_1', 'sex'], columns=[], aggfunc=np.mean)
</code></pre>
<p>would look like:</p>
<pre><code>        sick_percentage__sex
qcut_metric_1   sex 
(0.999, 2.0]    female  0.40
male    0.25
(2.0, 3.0]  female  0.40
(3.0, 4.28] male    0.25
(4.28, 5.0] male    0.25
(5.0, 6.76] female  0.40
(6.76, 7.0] female  0.40
</code></pre>
<p>But this is not suitable to display for the binned metric (<code>qcut_metric_1</code>) and <strong>all</strong> cohorts (<code>[(sex), (age_group), (sex, age_group)]</code>) the percentage of sickness. How could this be adapted? Maybe using a Multidimensional aggregation?</p>
<p>Desired output format:</p>
<pre><code>qcut_metric_1, cohort, percentage_of_sickness
</code></pre>
<h1>edit</h1>
<p><code>np.mean</code> as pivot aggregation function might provide skewed results (as mean of grouped means might not be commutative if the number of users per group is not constant). Therefore, I need to used a weighted mean. I updated the sample data set.</p>
<pre><code>agg = df.groupby(['sex']).agg({'user_id':pd.Series.nunique, 'is_sick':pd.Series.mean})
agg.columns = ['unique_users', 'sick_percentage__sex']
df = df.merge(agg, on='sex')
</code></pre>
<p>now gives the data frame for input to the pivot table.</p>
<p>But now I am fighting with the syntax of weighted mean as well:</p>
<pre><code>def wavg(x):
    print(x)
    return np.average(x['sick_percentage__sex'], weights= x['unique_users'])
</code></pre>
<p>As the pivot table
    pd.pivot_table(df, values=['sick_percentage__sex', 'unique_users'], index=['qcut_metric_1', 'sex'], columns=[], aggfunc=wavg)
only passes a single series (and not both (value + weight)) to the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps a pivot table is not the right way to solve the issue.</p>
<p>A minimal solution could look like the code below and iterate over all the cohorts.</p>
<p><strong>Is there a possibility for a more efficient solution?</strong> My input file is 120G for an uncompressed CSV / when compressed via gzip 3GB remain which translate to about 35GB of memory requirements for pandas.</p>
<pre><code>%pylab inline

import seaborn as sns
sns.set(color_codes=True)

import pandas as pd
import numpy as np
df = pd.DataFrame({"user_id": [1, 2, 3, 4, 5,
                          6, 7, 8, 9],
    "is_sick": [0, 0, 0, 0, 0,
                          0, 1, 1, 1],
                    "sex": ["male", "female", "male", "female", "female",
                          "male", "male", "female", "female"],
                    "age_group": ["young", "old", "old", "young",
                          "small", "old", "young", "young",
                          "old"],
                    "metric_1": [1, 2, 2, 3, 3, 4, 5, 6, 7]})
df['date'] = '2019-01-01'
df['qcut_metric_1'] = pd.qcut(df.metric_1, [0, .25, .5, .66, .75, .97, 1])

# make some more data
df_2 = df.copy()
df_2['date'] = '2019-02-01'
df = pd.concat([df, df_2])
cohorts = [['sex', 'age_group'], ['sex'], ['age_group']]
for cohort in cohorts:
    cohort_name = '_'.join(cohort)
    # print(cohort_name)
    agg = df.groupby(cohort).agg({'user_id':pd.Series.nunique, 'is_sick':pd.Series.mean})
    sick_percentage_column = f'sick_percentage__{cohort_name}'
    agg.columns = ['unique_users', sick_percentage_column]
    merged = df.merge(agg, on=cohort) # INNER (default) JOIN ok, as agg derived from total =&gt; no values lost

    groupings = ['qcut_metric_1']
    groupings.extend(cohort)
    result = merged.groupby(groupings).apply(lambda x: np.average(x[sick_percentage_column], weights= x['unique_users'])).reset_index().rename({0:sick_percentage_column}, axis=1)
    display(result)    
</code></pre>
</div>
<span class="comment-copy">What is expected output in numbers?</span>
<span class="comment-copy">The naive pivot table for a single cohort (percentage for sex, grouped in pivot for sex) is just fine (for this single cohort). I wonder how to make this work for multiple cohorts.</span>
<span class="comment-copy">hmmm, <code>and all cohorts ([(sex), (age_group), (sex, age_group)]) </code> - not typo ?</span>
<span class="comment-copy">Basically there should be multiple cohorts defined as tuples <code>(sex), (age_group), (sex, age_group)</code></span>
<span class="comment-copy">Actually it can be a single aggregatiin without join.</span>
