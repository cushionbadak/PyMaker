<div class="post-text" itemprop="text">
<p>I have analysed the global header of a PCAP file and found out that the magic number is: <strong>d4 c3 b2 a1</strong></p>
<p>This means that it uses a little endian and all the bytes that come after it need to processed in reverse order. The other sections of the global header are as follows:</p>
<pre><code>major version =  02 00

minor version =  04 00

time zone =  00 00 00 00

timestamp =  00 00 00 00

snaplen =  ff ff 00 00

linktype =  01 00 00 00
</code></pre>
<p>However given that little endian is in use, it should be:</p>
<pre><code>major version =  00 02

minor version =  00 04

time zone =  00 00 00 00

timestamp =  00 00 00 00

snaplen =  00 00 ff ff

linktype =  00 00 00 01
</code></pre>
<p>So I need a way to reverse the string but still keep the pairs of characters separated by the spaces in the same order. </p>
<p>So the code [::-1] will not work because it transforms <strong>02 00</strong> into 00 20, whereas it needs to be <strong>00 02</strong></p>
<p>How would I go about doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need a few more steps to do it:</p>
<pre><code>linktype = "00 00 00 01"
rev_linktype = " ".join(reversed(linktype.split()))
</code></pre>
<p>The idea is to first chop the string into tokens instead of characters, then reverse the order of the tokens, and then join them back into one long string.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's unusual to process <em>hex values</em> instead of the actual data. <em>Usually</em> people would process data that's stored in <code>bytes</code> objects, which looks like:</p>
<pre><code>major_version =  b"\x02\x00"
minor_version =  b"\x04\x00"
time_zone =  b"\x00\x00\x00\x00"
timestamp =  b"\x00\x00\x00\x00"
snaplen =  b"\xff\xff\x00\x00"
linktype =  b"\x01\x00\x00\x00"
</code></pre>
<p>I'd recommend storing your your constants as numbers:</p>
<pre><code>major_version = 0x02_00
minor_version = 0x04_00
time_zone = 0x00_00_00_00
timestamp = 0x00_00_00_00
snaplen = 0xff_ff_00_00
linktype = 0x01_00_00_00
</code></pre>
<p>because then you can do:</p>
<pre><code>if magic_bytes == b"\xd4\xc3\xb2\xa1":
    endianness = "little"
else:
    endianness = "big"

# a little while later, when we need to use the major version number:
major_version.to_bytes(2, endianness)  # major version takes up 2 bytes
</code></pre>
<p>There's also an <code>int.from_bytes</code>, in case you were wondering! Python solves your problem for you, and faster than you can do it by hand.</p>
</div>
<span class="comment-copy">You mean in the ASCII strings in your question, or the actual bytes in a PCAP binary capture? The latter needs knowledge about the width of each byte field in the binary format.</span>
<span class="comment-copy">Why are you converting to hex first?</span>
<span class="comment-copy">beat me to it :(</span>
<span class="comment-copy">in case you prefer, <code>" ".join(linktype.split()[::-1])</code> is the same but save you a few keystrokes</span>
