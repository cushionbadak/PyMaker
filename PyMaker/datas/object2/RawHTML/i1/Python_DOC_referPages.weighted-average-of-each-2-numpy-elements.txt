<div class="post-text" itemprop="text">
<p>Assuming I have this array:
[4, 3, 2]
I would like to get the weighted average of each 2 elements. Thus, I would get an array that looks like this (assuming the weights are [0.6, 0.4, 0.6]:
[3.6, 2.4]</p>
<p>Any idea how I can do this with large arrays (5000)?</p>
<p>Thank you very much!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could take a look at the <a href="https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.roll.html" rel="nofollow noreferrer">numpy</a> <code>roll()</code> method.</p>
<pre><code>import numpy as np
weight = 0.5
x = np.array([4, 3, 2])
(x*weight + np.roll(x, -1)*(1-weight))[:-1]
</code></pre>
<p>which outputs: </p>
<pre><code>array([ 3.5,  2.5])
</code></pre>
<p>The Roll method, will shift your original array, by adding the shifted array to the original and multiplying each by their respective weight (the weights sum up to 1), you'll get a weighted mean. All of these are vectorized operations, which will make execution pretty smooth.</p>
<p>You can toy with the <code>weight</code> to make either the first or second element have a bigger impact;</p>
</div>
<div class="post-text" itemprop="text">
<p>Given the two variables:</p>
<pre><code>import numpy as np

elements = np.array([4, 3, 2])
weights = np.array([0.6, 0.4, 0.6])
</code></pre>
<p>You multiply both arrays and save them in one variable, only for readability:</p>
<pre><code> a = elements * weights
</code></pre>
<p>You make the summation. Using the function <code>np.roll</code> we will create a copy of the variable <code>a</code>, but shifted one position:</p>
<pre><code> res = a + np.roll(a, -1)
</code></pre>
<p>Finally, we ignore the last element:</p>
<pre><code> res = res[0:-1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a more general result, I think you should renormalize the weights such that the sum of each pair is 1. That means that each weight may have different renormalized values when paired with its previous or following weight.</p>
<p>Let say that <code>weights</code> is the numpy array with the weights:</p>
<pre><code>normalized_weights = np.column_stack((we[:-1], we[1:]))
for i in range(corrwe.shape[0]):
    normalized_weights[i][0] = normalized_weights[i][0] / (weights[i] + weights[i+1])
    normalized_weights[i][1] = normalized_weights[i][1] / (weights[i] + weights[i+1])
</code></pre>
<p><code>normalized_weights</code> is a N x 2 matrix, where N is equal to <code>len(weights)-1</code>. Each row contains a pair of weights whose sum is 1.</p>
<p>For example, if <code>weights = [0.89779725 0.04136924 0.2877373 0.29153165 0.97000642 0.74452243 0.5714133 0.25224212 0.09493403 0.11448254]</code> then <code>normalized_weights</code> is:</p>
<pre><code>[[0.95595112 0.04404888]
 [0.12570165 0.87429835]
 [0.49672488 0.50327512]
 [0.23109223 0.76890777]
 [0.56575684 0.43424316]
 [0.56577416 0.43422584]
 [0.69375285 0.30624715]
 [0.72655372 0.27344628]
 [0.45332625 0.54667375]]
</code></pre>
<p>Now, if <code>x</code> is your data array (same length of <code>weights</code>) you could get the weighted middle points by doing:</p>
<pre><code>weighted_middle_x = x[:-1]*normalized_weights[...,0] + x[1:]*normalized_weights[...,1]
</code></pre>
</div>
<span class="comment-copy">By each two elements, are you referring to each of the two adjacent elements for every combination of two elements in the list?</span>
<span class="comment-copy">Could you show what you have tried so far, please?</span>
<span class="comment-copy">That is correct</span>
<span class="comment-copy">I recommend adding a longer example.  The sums of the two consecutive pairs in your weights both happen to add up to 1.  I suspect that won't be the case in general (otherwise the weights for a longer example would have to be something like [0.6, 0.4, 0.6, 0.4, 0.6, 0.4, 0.6, 0.4, ...]).</span>
<span class="comment-copy">That is brilliant! I understand the logic there.  Any idea how I can make it a weighted average though ? for example, I would like weight of the first element to be 0.6, second element 0.4, third element 0.6 and so forth</span>
<span class="comment-copy">I've added a weight element in the example, is this the kind of weight you were talking of?</span>
<span class="comment-copy">That is exactly what I needed. Thank you very much!</span>
