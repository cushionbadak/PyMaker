<div class="post-text" itemprop="text">
<p>I know that there are other questions like mine but the only problem is that they get all the combinations for all of the varibales in list but I want it so that the user enters the number that the want and the numbers they need to make the desired number. This is the code that I have:</p>
<pre><code>numbers = []
operators = ['+', '*', '-', '/']
desire = int(input("Enter the number you want: "))
num1 = int(input("Enter First number: "))
num2 = int(input("Enter Second number: "))
num3 = int(input("Enter Third number: "))
num4 = int(input("Enter Fourth number: "))
numbers.append(num1)
numbers.append(num2)
numbers.append(num3)
numbers.append(num4)
</code></pre>
<p>But I have no idea how to expand on this</p>
<p>This is an example on what the code should do:</p>
<p>Say that the number they want made is <code>24</code> and</p>
<p>Say the numbers that they enter are <code>1, 9, 8, 2</code></p>
<p>output should be this:</p>
<p><code>9 - 1 + 8 * 2 = 24</code></p>
<p>etc...</p>
<p>All possible solutions need to be listed</p>
<p>All suggestions will be greatly appriciated</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use permutations from the itertools module to arrange numbers and operators in all possible ways into a string formula.  Then use eval() to compute the result.</p>
<p>For example:</p>
<pre><code>from itertools import permutations
numbers   = ["1","9","8","2"]
target    = 24
operators = ["+","-","*","/"]
for values in permutations(numbers,len(numbers)):
    for oper in permutations(operators,len(numbers)-1):
        formula = "".join(o+v for o,v in zip([""]+list(oper),values))
        if eval(formula) == target: print(formula,"=",target)
</code></pre>
<p><strong>[UPDATE1]</strong> If you are allowed to use the same operator more than once (as suggested by your comment on 1+1+1*8=24), you will need to use combinations_with_replacement to generate more operator patterns:</p>
<pre><code>from itertools import permutations,combinations_with_replacement
numbers   = ["1","1","1","8"]
target    = 10
operators = ["+","-","*","/"]
seen      = set()
for values in permutations(numbers,len(numbers)):
    for operCombo in combinations_with_replacement(operators,len(numbers)-1):
        for oper in permutations(operCombo,len(numbers)-1):
            formula = "".join(o+v for o,v in zip([""]+list(oper),values))
            if formula not in seen and eval(formula) == target:
                print(formula,"=",target)
                seen.add(formula)
</code></pre>
<p>Essentially, this only differs from the previous example by the insertion of the <code>for operCombo in ...</code> loop.</p>
<p>Note: The combinations will generate formulas that look exactly the same so you will want to avoid printing solutions that have already been seen (as I did here). Duplications would also occur in the previous example if any numbers were repeated in the input.</p>
<p>Also note that in order for 9-1+8*2 to result in 24, the multiplication must be performed before additions and subtractions (i.e. under precedence rules) otherwise 9-1+8*2=32.  You would need to support parentheses to cover different orders of operation.</p>
<p><strong>[UPDATE2]</strong> Supporting parentheses is a bit more involved depending on how many numbers you want to allow. For 4 numbers, there are 11 patterns:  </p>
<ul>
<li>No parentheses:  A+B+C+D</li>
<li>A+B group: (A+B)+C+D</li>
<li>B+C group: A+(B+C)+D</li>
<li>C+D group: A+B+(C+D)</li>
<li>A+B and C+D groups: (A+B)+(C+D)</li>
<li>A+B+C group: (A+B+C)+D</li>
<li>B+C+D group: A+(B+C+D)</li>
<li>A+B group + C: ((A+B)+C)+D</li>
<li>A + group B+C: (A+(B+C))+D</li>
<li>B+C group + D: A+((B+C)+D)</li>
<li>B + group C+D: A+(B+(C+D))</li>
</ul>
<p>If you have more than 4 numbers there will be more patterns of parentheses grouping.</p>
<p>Here's an example (for 4 numbers):</p>
<pre><code>from itertools import permutations,combinations_with_replacement
numbers   = ["9","8","1","2"]
target    = 24
operators = ["+","-","*","/"]
groups    = ['X+X+X+X', 'X+X+(X+X)', 'X+(X+X)+X', '(X+X+X)+X', '(X+X)+X+X', 'X+(X+X+X)', '((X+X)+X)+X', 'X+(X+(X+X))', 'X+((X+X)+X)', '(X+X)+(X+X)', '(X+(X+X))+X']
seen      = set()
for values in permutations(numbers,len(numbers)):
    for operCombo in combinations_with_replacement(operators,len(numbers)-1):
        for oper in permutations(operCombo,len(numbers)-1):
            formulaKey = "".join(oper+values)
            if formulaKey in seen: continue # ignore variations on parentheses alone
            for pattern in groups:
                formula = "".join(o+p for o,p in zip([""]+list(oper), pattern.split("+")))
                formula = "".join(v+p for v,p in zip([""]+list(values),formula.split("X")))
                try:
                    if eval(formula) == target:
                        print(formula,"=",target)
                        seen.add(formulaKey)
                        break 
                except: pass
</code></pre>
<p><em>Groupings could result in divisions by zero, so a try:except block had to be added.</em></p>
<p>This produces the following result:</p>
<pre><code>9*8/(1+2) = 24
9+8*2-1 = 24
9*8/(2+1) = 24
9-1+8*2 = 24
9-(1-8*2) = 24
9-1+2*8 = 24
(9-1)*2+8 = 24
9/(1+2)*8 = 24
9/((1+2)/8) = 24
9-(1-2*8) = 24
9+2*8-1 = 24
9/(2+1)*8 = 24
9/((2+1)/8) = 24
8+(9-1)*2 = 24
8*9/(1+2) = 24
8*9/(2+1) = 24
8-(1-9)*2 = 24
8/(1+2)*9 = 24
8/((1+2)/9) = 24
8+2*(9-1) = 24
8*2+9-1 = 24
8*2-1+9 = 24
8/(2+1)*9 = 24
8/((2+1)/9) = 24
8-2*(1-9) = 24
8*2-(1-9) = 24
2*(9-1)+8 = 24
2*8+9-1 = 24
2*8-1+9 = 24
2*8-(1-9) = 24
</code></pre>
<p>To generate the parentheses grouping patterns for more numbers, you can use this function:</p>
<pre><code>from itertools import product
import re
def groupPatterns(count,pattern=None):
    arr = pattern or "X"*count
    if len(arr) &lt; 2 : return [arr]
    result = []
    for mid in range(1,len(arr)):
        leftPattern  = groupPatterns(count,arr[:mid])
        rightPattern = groupPatterns(count,arr[mid:])
        for left,right in product(leftPattern,rightPattern):
            result += [left + right]
            if len(left)  &gt; 1 : result += ["(" + left + ")" + right]
            if len(right) &gt; 1 : result += [left + "(" + right + ")"]
            if len(left) &gt; 1 and len(right) &gt; 1: 
                result += ["(" + left + ")(" + right + ")"]
    if pattern: return result # recursion
    patterns = [] # final, add "+" between X value placeholders or groups
    for pat in sorted(set(result),key=lambda x:len(x)):
        pat = re.sub("X(?=X)", r"X+",  pat)  # XX --&gt; X+X
        pat = re.sub("X\(",    r"X+(", pat)  # X( --&gt; X+(
        pat = re.sub("\)X",    r")+X", pat)  # )X --&gt; )+X
        pat = re.sub("\)\(",   r")+(", pat)  # )( --&gt; )+(
        patterns.append(pat)
    return patterns
</code></pre>
<p>And then replace <code>groups = ["X+X+X+X",...</code> with <code>groups = groupPatterns(len(numbers))</code> in the previous example.</p>
<p>OR, create a completely generic function for any number of values, with or without grouping and operator reuse:</p>
<pre><code>from itertools import permutations,combinations_with_replacement
def numbersToTarget(numbers,target,reuseOper=True,allowGroups=True,operators=["+","-","*","/"]):   
    groups      = groupPatterns(len(numbers)) if allowGroups else [ "+".join("X"*len(numbers)) ]
    seen        = set()
    for values in permutations(numbers,len(numbers)):
        for operCombo in combinations_with_replacement(operators,len(numbers)-1) if reuseOper else [operators]:
            for opers in permutations(operCombo,len(numbers)-1):
                formulaKey = str(opers)+str(values)
                if formulaKey in seen: continue # ignore variations on parentheses alone
                for pattern in groups:
                    formula = "".join(o+p      for o,p in zip([""]+list(opers), pattern.split("+")))
                    formula = "".join(str(v)+p for v,p in zip([""]+list(values),formula.split("X")))
                    try:
                        if eval(formula) == target:
                            seen.add(formulaKey)
                            yield formula
                            break 
                    except: pass

for formula in numbersToTarget([9,8,1,2],24):
    print("24 =",formula)
for formula in numbersToTarget([9,8,1,2,5],0,allowGroups=False):
    print("0 =",formula)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is really not well tested (and probably does too much work) but may get you started:</p>
<pre><code>from operator import mul, add, sub, truediv
from itertools import permutations, combinations_with_replacement

operators = (mul, add, sub, truediv)
desire = 24

numbers = [1, 9, 8, 2]

OP2SYM = {mul: '*', add: '+', sub: '-', truediv: '/'}

for op0, op1, op2 in combinations_with_replacement((mul, add, sub, truediv), 3):
    for n0, n1, n2, n3 in permutations(numbers, 4):
        # print(op0, op1, op2)
        # print(n0, n1, n2, n3)
        if op0(n0, op1(n1, op2(n2, n3))) == desire:
            print('{} {} ({} {} ({} {} {}))'.format(
                n0, OP2SYM[op0], n1, OP2SYM[op1], n2, OP2SYM[op2], n3))
        if op0(op1(n0, n1), op2(n2, n3)) == desire:
            print('({} {} {}) {} ({} {} {})'.format(
                n0, OP2SYM[op0], n1, OP2SYM[op1], n2, OP2SYM[op2], n3))
        if op2(op1(op0(n0, n1), n2), n3) == desire:
            print('(({} {} {}) {} {}) {} {}'.format(
                n0, OP2SYM[op0], n1, OP2SYM[op1], n2, OP2SYM[op2], n3))
</code></pre>
<p>it outputs</p>
<pre><code>((8 * 2) + 9) - 1
((2 * 8) + 9) - 1
</code></pre>
<p>a simpler idea would be to constuct the strings of the form <code>'6*3-4+4'</code> and use <code>ast.literal_eval</code> to evaluate them</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try with the <strong>permutations</strong> module inside <strong>itertools</strong></p>
<pre><code>from itertools import permutations, combinations
numbers = ""
solutions = []
operators = "+*-/"
desire = int(input("Enter the number you want: "))
num1 = input("Enter First number: ")
num2 = input("Enter Second number: ")
num3 = input("Enter Third number: ")
num4 = input("Enter Fourth number: ")
#concatenate the input
numbers = num1 + num2 + num3 + num4    
#generate all possible permutations of this characters
num_permutations = [p for p in permutations(numbers)]
op_combinations = [p for p in combinations(operators,3)]

for n_perm in num_permutations:
   for op_perm in op_combinations:
      cur_expression = ""
      for i in range(3):
         cur_expression += n_perm[i] + op_perm[i]
      cur_expression += n_perm[3]
      tmp_solution = eval(cur_expression)
      if desire == tmp_solution:
         solutions.append(tmp_solution)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is what I came up with using <code>eval()</code> to mathematically evaluate the string of math operators (note this is not a very secure method and malicious users could potentially hack your program through it. If you are deploying then maybe look at <a href="https://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string">Evaluating a mathematical expression in a string</a>)</p>
<pre><code>numbers = []
operators = ['+', '*', '-', '/']
desire = int(input("Enter the number you want: "))
num1 = input("Enter First number: ")
num2 = input("Enter Second number: ")
num3 = input("Enter Third number: ")
num4 = input("Enter Fourth number: ")
numbers.append(num1)
numbers.append(num2)
numbers.append(num3)
numbers.append(num4)

for operator1 in operators:
    for operator2 in operators:
        for operator3 in operators:
            problem = numbers[0] + operator1 + numbers[1] + operator2 + numbers[2] + operator3 + numbers[3]
            result = int(eval(problem))
            if result == desire:
                print("{} = {}".format(problem, result))
</code></pre>
<p>My first simple test</p>
<pre><code>Enter the number you want: 40
Enter First number: 10
Enter Second number: 10
Enter Third number: 10
Enter Fourth number: 10
</code></pre>
<p>Yields</p>
<blockquote>
<p>10+10+10+10 = 40</p>
</blockquote>
<p>A more complex test</p>
<pre><code>Enter the number you want: 18
Enter First number: 6
Enter Second number: 3
Enter Third number: 4
Enter Fourth number: 4
</code></pre>
<p>Yeilds:</p>
<blockquote>
<p>6*3+4-4 = 18</p>
<p>6*3*4/4 = 18</p>
<p>6*3-4+4 = 18</p>
<p>6*3/4*4 = 18</p>
<p>6/3+4*4 = 18</p>
</blockquote>
<p>It should be noted though that this solution does not consider the various orders for your numbers. I'll see if I can craft something more devious</p>
<p><strong>UPDATE</strong> </p>
<p>I've crafted a way to consider all permutations of numbers as well</p>
<pre><code>def make_order_combinations():
    number_orders = []
    for i in range(4):
        for j in range(4):
            for k in range(4):
                for z in range(4):
                    if i != j and i != k and i != z and j != k and j != z and k != z:
                        number_orders.append((i, j, k, z))
    return number_orders


def solve_given_number_order(number_order):
    for operator1 in operators:
        for operator2 in operators:
            for operator3 in operators:
                problem = numbers[number_order[0]] + operator1 + numbers[number_order[1]] + operator2 + numbers[number_order[2]] + operator3 + numbers[number_order[3]]
                # print(problem)
                result = eval(problem)
                # print(result)
                if result == desire:
                    print("{} = {}".format(problem, result))

numbers = []
operators = ['+', '*', '-', '/']
desire = int(input("Enter the number you want: "))
num1 = input("Enter First number: ")
num2 = input("Enter Second number: ")
num3 = input("Enter Third number: ")
num4 = input("Enter Fourth number: ")
numbers.append(num1)
numbers.append(num2)
numbers.append(num3)
numbers.append(num4)

list_of_orders = make_order_combinations()
for order in list_of_orders:
    solve_given_number_order(order)
</code></pre>
<p>Now the test</p>
<pre><code>Enter the number you want: 67
Enter First number: 15
Enter Second number: 4
Enter Third number: 7
Enter Fourth number: 1
</code></pre>
<p>Yields</p>
<pre><code>15*4+7*1 = 67
15*4+7/1 = 67.0
15*4+1*7 = 67
15*4*1+7 = 67
15*4/1+7 = 67.0
15*1*4+7 = 67
15/1*4+7 = 67.0
4*15+7*1 = 67
4*15+7/1 = 67.0
4*15+1*7 = 67
4*15*1+7 = 67
4*15/1+7 = 67.0
4*1*15+7 = 67
4/1*15+7 = 67.0
7+15*4*1 = 67
7+15*4/1 = 67.0
7+15*1*4 = 67
7+15/1*4 = 67.0
7+4*15*1 = 67
7+4*15/1 = 67.0
7+4*1*15 = 67
7+4/1*15 = 67.0
7+1*15*4 = 67
7*1+15*4 = 67
7/1+15*4 = 67.0
7+1*4*15 = 67
7*1+4*15 = 67
7/1+4*15 = 67.0
1*15*4+7 = 67
1*4*15+7 = 67
1*7+15*4 = 67
1*7+4*15 = 67
</code></pre>
<p>Where you can see it does consider all possible rearrangement of the numbers as well. Order of operations does still apply though and therefore the output: </p>
<blockquote>
<p>1*7+4*15 = 67</p>
</blockquote>
<p>Should be read as (1*7)+(4*15) = 67</p>
</div>
<span class="comment-copy">Do you need to use all for numbers or can you use some subset of the four numbers as well?</span>
<span class="comment-copy">@DaichiJameson you have to use all of the numbers</span>
<span class="comment-copy">Do <code>9 - 1 + 8 * 2</code> and <code>9 + 8 * 2 - 1</code> count as different combinations?</span>
<span class="comment-copy">@blhsing yes it does</span>
<span class="comment-copy">This is great! Put my attempt to shame 😔</span>
<span class="comment-copy">@Alain T. how would I add more numbers in to solve?</span>
<span class="comment-copy">The function's first parameter is a list so you can put as many numbers as you want (as shown in the last example <code>numbersToTarget([9,8,1,2,6])</code>.  If you want multiple targets you can either call the function for each target in a loop or make the target parameter also a list and test for <code>eval(formula) in target</code> instead of <code>eval(formula) == target</code> inside the function</span>
<span class="comment-copy">the desire number is <code>24</code> and when I input <code>1,1,1,8</code> it outputs this: <code>8 * (1 + (1 + 1))</code> 6 times, do you know why?</span>
<span class="comment-copy">the permutations of <code>8 , 1, 1, 1</code> will contain <code>8 , 1, 1, 1</code> six times; <code>permutations</code> of <code>a, b</code> will contain <code>b, a</code>; if <code>a = b</code> you will have repetitions. you could add a <code>set</code> (e.g called <code>seen</code>) and just continue of you have already <code>seen</code> a combination.</span>
<span class="comment-copy">I get this error when I run your code <code>tmp_solution = eval(cur_expression) TypeError: eval() arg 1 must be a string, bytes or code object</code></span>
<span class="comment-copy">you're right. I fixed it: <code>cur_expression</code> was a list instead of a string. Fixing it allows the eval() to run and compute the operation result</span>
<span class="comment-copy">when I type in the numbers no result comes up</span>
<span class="comment-copy">obviously. I used no <code>print()</code> function. It was meant for you to expand the code you were writing.   the <i>solutions</i> array will have all the strings that produces the desired number.</span>
<span class="comment-copy">It does work but for some reason when I input: <code>1,1,1,8</code> it doesn't output 24 even though the solution to this is <code>1 + 1 + 1 * 8 = 24</code> also it doesn't for the one that I put in my question do you know why this is?</span>
<span class="comment-copy">both your answer and Alain T. answer does this only hiro protagonist answer doesn't do this for some reason</span>
<span class="comment-copy">Your example (9-1+8*2 = 24) implies that the formula must apply operator precedence.  1+1+1*8 = 10 when multiplication is performed before addition (in accordance with precedence rules)</span>
<span class="comment-copy">@system123456 That's because of order of operations. Multiplication takes precedence so 1 + 1 + 1 * 8 -&gt; 1 + 1 + (1 * 8) -&gt; 1 + 1 + 8 -&gt; 10 not 24</span>
