<div class="post-text" itemprop="text">
<p>in C# we have to get/set to make rules, but I don't know how to do this in Python.</p>
<p><em>Example:
Orcs can only equip Axes, other weapons are not eligible
Humans can only equip swords, other weapons are eligible.</em></p>
<p>How can I tell Python that an Orc cannot do something like in the example above?</p>
<p>Thanks for answers in advance, hope this made any sense to you guys.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>in C# we have to get/set to make rules, but I don't know how to do this in Python.</p>
</blockquote>
<p>No. Getters and Setters won't help you here. Note that Python <em>also</em> has getters/setters and dunders (something like <code>self.__foo</code>), but let's not follow that path.</p>
<hr/>
<p>Instead, let's look what you have:</p>
<ul>
<li>a bunch of things (like <em>Orcs</em> and <em>Humans</em> and <em>Swords</em> and stuff)</li>
<li>a bunch of actions (ok, currently it's only one action, <em>wield</em>, but maybe tomorrow you decide a Vampire can drink blood, but not a Human)</li>
<li>and a bunch of rules (an axe is a weapon, a sword is a weapon, Orcs may only use axe, Human may use other weapons, ...).</li>
</ul>
<p>So, let's try to model our game this way: with <code>Things</code>, <code>Actions</code>, and <code>Rules</code>.</p>
<p>Because we're cool kids, let's start with writing down our rules as text:</p>
<pre><code>rules =[
    "Human is Person",
    "Orc is Person",
    "Person may wield Weapon",
    "Human may not wield Axe",
    "Orc may only wield Axe",
    "Sword is Weapon",
    "Bow is Weapon",
    "Axe is Weapon",
    "Cow is Animal",
    "Animal may eat Grass"
]
</code></pre>
<p>As you can see, I talk about cows and animals and grass, too, so we can see that we're going to make a very generic approach.</p>
<p>We know that our "things" have different types, a name, and a way to invoke an "action", so here's our <code>Thing</code> class:</p>
<pre><code>class Thing:
    def __init__(self, name, *type):
        self.name = name
        self.type = ['Thing', *type]

    def action(self, action_class, *args):
        action_class(self, *args)()
</code></pre>
<p>A <code>Thing</code> is of type <code>'Thing'</code> and anything else we pass to <code>__init__</code>, and we can call the <code>action</code> function with an <code>Action</code> class (we create it shortly) and some arguments we pass to this function.</p>
<p>So far, so simple.</p>
<hr/>
<p>Now, here's what a generic <code>Action</code> could look like:</p>
<pre><code>class Action:
    def __init__(self, name, a, b):
        self.name = name
        self.a = a
        self.b = b

    def invoke(self):
        print('You feel a strange sensation...')

    def forbidden(self):
        print(f"{self.a.name} tries to {self.name} {self.b.name}, but that is not possible")

    def __call__(self):
        if Rules.allowed(self):
            self.invoke()
        else:
            self.forbidden()
        print('----------')
</code></pre>
<p>Simply a name and two things (<code>a</code> and <code>b</code>). It can be called (e.g. by <code>Thing.action</code>), and it's either allowed to be invoked (and then call <code>invoke</code>) or not (and then call <code>fobidden</code>). </p>
<p>Let's ignore <code>Rules.allowed</code> for now and create some actions that do something:</p>
<pre><code>class Wield(Action):
    def __init__(self, thing, weapon):
        super().__init__('wield', thing, weapon)

    def invoke(self):
        if hasattr(self.a, 'weapon'):
            print(f'{self.a.name} drops {self.a.weapon.name}')
        self.a.weapon = self.b
        print(f'{self.a.name} now wields {self.a.weapon.name}')

class Eat(Action):
    def __init__(self, thing, food):
        super().__init__('eat', thing, food)

    def forbidden(self):
        print(f'{self.a.name} tried to eat {self.b.name}, but did not like it very much...')

    def invoke(self):
        print(f'{self.a.name} eats {self.b.name}')
</code></pre>
<p>The <code>Wield</code> action will set the <code>weapon</code> of the caller, but only if it's allowed. The <code>Eat</code> action, well, just prints a message for now...</p>
<p>So, the only thing left to do for us now is to actually implement <code>Rules.allowed</code>, that means parsing the rules we created at first and act on it. </p>
<hr/>
<p>Here's the <code>Rules</code> class:</p>
<pre><code>class Rules:
    alias_list = []
    prohibition_list = []
    permission_list = []
    exclusive_list = []

    def parse_rules(rules):
        for rule in rules:
            if ' is ' in rule:
                type, alias = rule.split(' is ')
                Rules.alias_list.append((type, alias))
            elif ' may only ' in rule:
                obj, rest = rule.split(' may only ')
                action, second = rest.split(' ')
                Rules.exclusive_list.append((obj, action, second))
            elif ' may not ' in rule:
                obj, rest = rule.split(' may not ')
                action, second = rest.split(' ')
                Rules.prohibition_list.append((obj, action, second))
            elif ' may ' in rule:
                obj, rest = rule.split(' may ')
                action, second = rest.split(' ')
                Rules.permission_list.append((obj, action, second))

    def resolve_types_inner(types, aliases):
        for (source_type, alias_type) in aliases[:]:
            if source_type in types:
                types.add(alias_type)
                aliases.remove((source_type, alias_type))
                return Rules.resolve_types_inner(types, aliases)
        return types

    def resolve_types(thing):
        types = set(thing.type)
        return Rules.resolve_types_inner(types, Rules.alias_list[:])

    def allowed(action_to_test):
        a_types = Rules.resolve_types(action_to_test.a)
        b_types = Rules.resolve_types(action_to_test.b)

        for (a, action, b) in Rules.exclusive_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    print ('-- allowed by exclusive_list')
                    return True

        for (a, action, b) in Rules.prohibition_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    print ('-- forbidden')
                    return False

        for (a, action, b) in Rules.permission_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    if not action in (x for (a2,x,b2) in Rules.exclusive_list if x == action and a2 in a_types):
                        print ('-- allowed')
                        return True
                    else:
                        print ('-- forbidden by exclusive_list')
                        return False
        print ('-- no rules match')
</code></pre>
<hr/>
<p>Of course this is just very basic and not a full-fledged rule engine or logical programming language, but it will do for now.</p>
<p>We already support 4 features: </p>
<ul>
<li>Aliases. We can say something A is something B, and all rules of B apply to A</li>
<li>Allow something</li>
<li>Prohibit something</li>
<li>Allow A something only for a specific B</li>
</ul>
<p>The <code>parse_rules</code> function simply splits the strings and adds the parts to different lists, and in the <code>allowed</code> function we iterate these lists to determine if something is allowed or not.</p>
<p>Feel free to improve this or add new features.</p>
<hr/>
<p>So, now we're ready to go.</p>
<p>Let us run the following:</p>
<pre><code># prepare our simple rule engine
Rules.parse_rules(rules)

# Let some things exist in the world
Carl_the_Human = Thing('Carl', 'Human')
Grump_the_Orc = Thing('Grump', 'Orc')
Sandy_the_Cow = Thing('Sandy', 'Cow')
Carls_sword = Thing("Carl's Sword of Justice", 'Sword')
Grumps_axe = Thing("Grump's rusty Axe", 'Axe')
Old_bow = Thing("An old bow", 'Bow')

# Sandy is hungry
Sandy_the_Cow.action(Wield, Grumps_axe)
Sandy_the_Cow.action(Eat, Grumps_axe)
Sandy_the_Cow.action(Eat, Thing("a bunch of grass", "Grass"))

# Carl wants to try some weapons
Carl_the_Human.action(Wield, Carls_sword)
Carl_the_Human.action(Wield, Grumps_axe)
Carl_the_Human.action(Wield, Old_bow)

# Grump wants to try some weapons    
Grump_the_Orc.action(Wield, Grumps_axe)
Grump_the_Orc.action(Wield, Carls_sword)
</code></pre>
<p>we get the following result:</p>
<pre><code>-- no rules match  
Sandy tries to wield Grump's rusty Axe, but that is not possible  
----------  
-- no rules match  
Sandy tried to eat Grump's rusty Axe, but did not like it very much...  
----------  
-- allowed  
Sandy eats a bunch of grass  
----------  
-- allowed  
Carl now wields Carl's Sword of Justice  
----------  
-- forbidden  
Carl tries to wield Grump's rusty Axe, but that is not possible  
----------  
-- allowed  
Carl drops Carl's Sword of Justice  
Carl now wields An old bow  
----------  
-- allowed by exclusive_list  
Grump now wields Grump's rusty Axe  
----------  
-- forbidden by exclusive_list  
Grump tries to wield Carl's Sword of Justice, but that is not possible  
----------
</code></pre>
<p>Whenever we need a new "Rule" in our game world, we can just add it to our rule list as simple text and let our simple rule engine decide if something is allowed (or even how something should happen, if we extend our engine).</p>
<p>So maybe we have ranged and melee weapons, and swordmans may also use spears but not bows, and archers may use bows and spears but not melee weapons?</p>
<p>No problem, just write it in the rules:</p>
<pre><code>"Ranged is Weapon",
"Melee is Weapon",
"Bow is Ranged",
"Spear is Ranged",
"Sword is Melee",
"Human is Person",
"Archer is Human",
"Swordman is Human",
"Person may wield Weapon",
"Archer may not wield Melee",
"Swordman may not wield Bow"
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>Swordman = Thing('the old Guy', 'Swordman')
Archer = Thing('the Archer', 'Archer')
Carls_sword = Thing("Carl's Sword of Justice", 'Sword')
Old_bow = Thing("An old bow", 'Bow')
Spear = Thing("A golden Spear", 'Spear')

Archer.action(Wield, Carls_sword)
Archer.action(Wield, Old_bow)
Archer.action(Wield, Spear)

Swordman.action(Wield, Carls_sword)
Swordman.action(Wield, Old_bow)
Swordman.action(Wield, Spear)
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>-- forbidden
the Archer tries to wield Carl's Sword of Justice, but that is not possible
----------
-- allowed
the Archer now wields An old bow
----------
-- allowed
the Archer drops An old bow
the Archer now wields A golden Spear
----------
-- allowed
the old Guy now wields Carl's Sword of Justice
----------
-- forbidden
the old Guy tries to wield An old bow, but that is not possible
----------
-- allowed
the old Guy drops Carl's Sword of Justice
the old Guy now wields A golden Spear
----------
</code></pre>
<hr/>
<p>Here's the full, runable code for you to try yourself:</p>
<pre><code>rules =[
    "Human is Person",
    "Orc is Person",
    "Person may wield Weapon",
    "Human may not wield Axe",
    "Orc may only wield Axe",
    "Sword is Weapon",
    "Bow is Weapon",
    "Axe is Weapon",
    "Cow is Animal",
    "Animal may eat Grass"
]

class Rules:
    alias_list = []
    prohibition_list = []
    permission_list = []
    exclusive_list = []

    def parse_rules(rules):
        for rule in rules:
            if ' is ' in rule:
                type, alias = rule.split(' is ')
                Rules.alias_list.append((type, alias))
            elif ' may only ' in rule:
                obj, rest = rule.split(' may only ')
                action, second = rest.split(' ')
                Rules.exclusive_list.append((obj, action, second))
            elif ' may not ' in rule:
                obj, rest = rule.split(' may not ')
                action, second = rest.split(' ')
                Rules.prohibition_list.append((obj, action, second))
            elif ' may ' in rule:
                obj, rest = rule.split(' may ')
                action, second = rest.split(' ')
                Rules.permission_list.append((obj, action, second))

    def resolve_types_inner(types, aliases):
        for (source_type, alias_type) in aliases[:]:
            if source_type in types:
                types.add(alias_type)
                aliases.remove((source_type, alias_type))
                return Rules.resolve_types_inner(types, aliases)
        return types

    def resolve_types(thing):
        types = set(thing.type)
        return Rules.resolve_types_inner(types, Rules.alias_list[:])

    def allowed(action_to_test):
        a_types = Rules.resolve_types(action_to_test.a)
        b_types = Rules.resolve_types(action_to_test.b)

        for (a, action, b) in Rules.exclusive_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    print ('-- allowed by exclusive_list')
                    return True

        for (a, action, b) in Rules.prohibition_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    print ('-- forbidden')
                    return False

        for (a, action, b) in Rules.permission_list:
            if action == action_to_test.name:
                if a in a_types and b in b_types:
                    if not action in (x for (a2,x,b2) in Rules.exclusive_list if x == action and a2 in a_types):
                        print ('-- allowed')
                        return True
                    else:
                        print ('-- forbidden by exclusive_list')
                        return False

        print ('-- no rules match')

class Action:
    def __init__(self, name, a, b):
        self.name = name
        self.a = a
        self.b = b

    def invoke(self):
        print('You feel a strange sensation...')

    def forbidden(self):
        print(f"{self.a.name} tries to {self.name} {self.b.name}, but that is not possible")

    def __call__(self):
        if Rules.allowed(self):
            self.invoke()
        else:
            self.forbidden()
        print('----------')

class Wield(Action):
    def __init__(self, thing, weapon):
        super().__init__('wield', thing, weapon)

    def invoke(self):
        if hasattr(self.a, 'weapon'):
            print(f'{self.a.name} drops {self.a.weapon.name}')
        self.a.weapon = self.b
        print(f'{self.a.name} now wields {self.a.weapon.name}')

class Eat(Action):
    def __init__(self, thing, food):
        super().__init__('eat', thing, food)

    def forbidden(self):
        print(f'{self.a.name} tried to eat {self.b.name}, but did not like it very much...')

    def invoke(self):
        print(f'{self.a.name} eats {self.b.name}')

class Thing:
    def __init__(self, name, *type):
        self.name = name
        self.type = ['Thing', *type]

    def action(self, action_class, *args):
        action_class(self, *args)()

if __name__ == '__main__':

    Rules.parse_rules(rules)

    Carl_the_Human = Thing('Carl', 'Human')
    Grump_the_Orc = Thing('Grump', 'Orc')
    Sandy_the_Cow = Thing('Sandy', 'Cow')
    Carls_sword = Thing("Carl's Sword of Justice", 'Sword')
    Grumps_axe = Thing("Grump's rusty Axe", 'Axe')
    Old_bow = Thing("An old bow", 'Bow')

    Sandy_the_Cow.action(Wield, Grumps_axe)
    Sandy_the_Cow.action(Eat, Grumps_axe)
    Sandy_the_Cow.action(Eat, Thing("a bunch of grass", "Grass"))

    Carl_the_Human.action(Wield, Carls_sword)
    Carl_the_Human.action(Wield, Grumps_axe)
    Carl_the_Human.action(Wield, Old_bow)

    Grump_the_Orc.action(Wield, Grumps_axe)
    Grump_the_Orc.action(Wield, Carls_sword)
</code></pre>
<p>Note there are progamming languages for exactly this, like <a href="http://inform7.com/" rel="nofollow noreferrer">Inform7</a>. </p>
<p>If you want to read more, I suggest reading the <a href="https://ericlippert.com/2015/04/27/wizards-and-warriors-part-one/" rel="nofollow noreferrer">Wizards and warriors</a> series by Eric Lippert, which talks about exactly this problem (and my answer is inspired by this series), and even uses similiar examples (fantasy classes and weapons), but IMHO it's a common pitfall in OO programming languages to <em>model the wrong things</em> with objects and trying to force business logic into the languages type system.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python language doesn't have an effective mechanism for restricting access to an instance or method. There is a convention though, to prefix the name of a field/method with an underscore to simulate "protected" or "private" behavior. </p>
<p>But, all members in a Python class are public by default. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want class <code>Orc</code> to have certain members but class <code>Human</code> not, and you still want those classes to be related (as both being characters), that is exactly what inheritance for. Here is an example inheritance hierarchy: </p>
<p><a href="https://i.stack.imgur.com/rRBn2.png" rel="nofollow noreferrer"><img alt="Inheritance hierarchy" src="https://i.stack.imgur.com/rRBn2.png"/></a></p>
<p>Here is an example implementation:</p>
<pre><code>class Weapon:
    def __init__(self, damage):
        self.damage = damage

class Gun(Weapon):
    def __init__(self):
        Weapon.__init__(self, 300)

class Grenade(Weapon):
    def __init__(self):
        Weapon.__init__(self, 1000)

class Knife(Weapon):
    def __init__(self):
        Weapon.__init__(self, 50)

class Hammer(Weapon):
    def __init__(self):
        Weapon.__init__(self, 100)


class Character:
    def __init__(self, name, default_weapon, additional):
        self.name = name
        self.default_weapon = default_weapon
        self.additional = additional

    def attack(self):
        pass # some implementation

class Heavily_armed(Character):
    def __init__(self, name):
        Character.__init__(self, name, Gun(), Grenade())


class Lightly_armed(Character):
    def __init__(self, name):
        Character.__init__(self, name, Knife(), Hammer())

class Human(Lightly_armed):
    def __init__(self, name, age, height):
        Lightly_armed.__init__(self, name)
        self.height = height
        self.age = age

class Orc(Heavily_armed):
    def __init__(self, name, danger):
        Heavily_armed.__init__(self, name)
        self.danger = danger
</code></pre>
<p>As you can see every <code>Character</code> has weapons, but those are different kinds of weapons. To expand this, you may create an "available weapons" set for every type and create an instance of a certain weapon only if it is in the set. This might or might not be a viable design choice for your implementation of the game. Choices are endless</p>
</div>
<span class="comment-copy">Are you looking for private members? what do you mean by "get/set"? Getter/setter functions?</span>
<span class="comment-copy">Say i play world of warcraft back in classic, the humans could only equip certian weapons in the beginning and some weapons were class spesific, how can i make certain weapons(objects) race spesific?</span>
<span class="comment-copy">Depends on how weapons are implemented. The easiest way would be type checking but this is generally not recommended. Why don't you create a <code>Character</code> class and specialize it with sub classes like <code>Orc</code> and add the weapon you want them to have as a data member:</span>
<span class="comment-copy">Well, this answers roughly all the questions i had asked and more, thanks! :)</span>
<span class="comment-copy">@JohnnyNiklasson Well, the tl;dr; is basically: you can't and should not model business rules with a class hierachy.</span>
<span class="comment-copy">Couldn't have said it better myself!</span>
<span class="comment-copy">@EricLippert I'm a fan of your blog, and the Wizard and warrios series is one of my favourites. Thanks you for this. I've recommened it to at least a dozen pepole and I hope that someday, people will stop with the <code>class Cow extends Animal</code>-nonsense.</span>
<span class="comment-copy">Wouldn't it be better to have in each class derived from <code>Character</code> a property that specifies which weapons are allowed? Something like <code>allowed_weapons</code> and call a method <code>is_weapon_allowed</code> every time the character tries to equip a weapon? That would also allow for a slightly different approach where you could specify which weapon class is allowed (say ranged weapons, melee, and so on)</span>
<span class="comment-copy">The problem with this approach is that you can only use it once. Suppose we now want "magical" and "mundane", and we also want "evil" and "good", in addition to "heavy" and "light".  An orc is an evil heavily armed magical creature, an elf is a good lightly armed magical creater, and a human is a good lightly armed mundane creature. <b>Now what does the class hierarchy look like?</b>  Class hierarchies capture these sorts of rules very poorly and I strongly recommend against it.</span>
<span class="comment-copy">We see these problems in other domains as well. Beginners to OO are often given "vehicle" as an example, and then you get subclasses "land vehicle" and "water vehicle". Then you ask "what if we want to classify based on military vs civilian also?" and you discover that there is no place in the type hierarchy that "amphibious troop carrier" fits.</span>
<span class="comment-copy">@EricLippert Why not create "evil" and "good" abstract classes and add them to Orc and Human as base classes? Python does support multi inheritance. How would you tackle this problem?</span>
<span class="comment-copy">I should have said that single-inheritance languages support these concepts particularly poorly. Languages that have multiple inheritance, like Python, or languages that have traits, can do somewhat better, but there are still lots of pitfalls.</span>
