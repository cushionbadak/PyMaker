<div class="post-text" itemprop="text">
<p>Here's my code:</p>
<pre><code>import multiprocessing as mp
import numpy as np

def foo(p):
    global i
    return p*i

global lower, upper
lower = 1
upper = 4

for i in range(lower, upper):
    if __name__ == '__main__':
        dataset = np.linspace(1, 100, 100)
        agents = mp.cpu_count() - 1
        chunksize = 5
        pool = mp.Pool(processes=agents)
        result = pool.map(foo, dataset, chunksize)
        print result
        print i
        pool.close()
        pool.join()
</code></pre>
<p>The console prints out the array [3, 6, 9,...,300] three times with the integers 1,2,3 in-between each array printout.  So i is correctly iterating between lower &amp; upper (not inclusive), but I expected it to print out the array [1, 2, 3,...,100] first followed by [2, 4, 6,...,200] and finally [3, 6, 9,...,300]. I don't understand why it's only passing the final value of i to foo and then mapping that thrice.  </p>
</div>
<div class="post-text" itemprop="text">
<p>When you run the new process, this is what it sees:</p>
<pre><code>import multiprocessing as mp
import numpy as np

def foo(p):
    global i
    return p*i

global lower, upper
lower = 1
upper = 4

for i in range(lower, upper):
    if __name__ == '__main__':
        # This part is not run, as
        # in a different process,
        # __name__ is set to '__mp_main__'
# i is now `upper - 1`, call `foo(p)` with the provided `p`
</code></pre>
<p>And after executing that, it is told to run <code>foo</code> (It has to run the whole script again to find out what <code>foo</code> is, just because of how pickling it works)</p>
<p>So, after it runs that, <code>i</code> will be <code>upper - 1</code>, and it will return <code>p * 3</code> always.</p>
<p>You want to make <code>i</code> a parameter given to <code>foo</code>, or some multiprocessing specific memory sharing object, as descibed <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Make i local and using functools.partial may solve your problem:</p>
<pre><code>import multiprocessing as mp
import numpy as np
import functools

def foo(p,i):
    return p*i

global lower, upper
lower = 1
upper = 4

for i in range(lower, upper):
    if __name__ == '__main__':
        dataset = np.linspace(1, 100, 100)
        agents = mp.cpu_count() - 1
        chunksize = 5
        pool = mp.Pool(processes=agents)
        foo2 = functools.partial(foo, i)
        result = pool.map(foo2, dataset, chunksize)
        print(result)
        print(i)
        pool.close()
        pool.join()
</code></pre>
</div>
<span class="comment-copy">Is this on Windows? Or a UNIX-alike? Makes a big difference in how the child processes are created (your behavior is expected, if confusing, on Windows).</span>
<span class="comment-copy">Yes on Windows.</span>
<span class="comment-copy">Note: This is the case on Windows, or if you explicitly opted into the <code>'spawn'</code> start method on another OS. On a UNIX-like system (e.g. Linux, BSD), the default start method <code>'fork'</code> will, under this design, properly set <code>i</code> (because the value of <code>i</code> is reflected in the fork that occurs when you create each <code>Pool</code>).</span>
<span class="comment-copy">@ Artyer - So nothing inside the 'if <b>name</b> = '<b>main</b>' conditional is initially run...it just loops through the iterable and then i is left at upper-1.  Then it runs the code inside the aforementioned conditional with the same value of i.  But it does so exactly len(range) # of times?  If this is the case, then shouldn't the value of i that gets printed out inside the "if <b>name</b>..." conditional also equal 3 all three times it prints out?  Why is it printing out 1,2,3 for i?  Is it because I'm using global i in foo (which is set to 3) but printing out 'local' values of i inside the loop?</span>
<span class="comment-copy">@F.F. In the new process, <code>i</code> will always be <code>3</code> (It runs the entire thing again). In the old process, <code>i</code> is unchanged (as it is a seperate <code>i</code>).</span>
<span class="comment-copy">Ahh yes indeed it does.  Great suggestion thanks.</span>
