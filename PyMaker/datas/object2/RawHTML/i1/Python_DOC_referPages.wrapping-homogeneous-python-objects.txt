<div class="post-text" itemprop="text">
<p>I'm looking for a way to have a collection of homogeneous objects, wrap them in another object, but have the wrapper object have the same API as the original and forward the corresponding API call to its object members.</p>
<pre><code>class OriginalApi:
  def __init__(self):
    self.a = 1
    self.b = "bee"

  def do_something(self, new_a, new_b, put_them_together=None):
    self.a = new_a or self.a
    self.b = new_b or self.b

    if put_them_together is not None:
      self.b = "{}{}".format(self.a, self.b)

  # etc.

class WrappedApi:
  def __init__(self):
    self.example_1 = OriginalApi()
    self.example_2 = OriginalApi()
</code></pre>
<p>Some possible solutions that have been considered, but are inadequate:</p>
<ul>
<li><p><strong>Rewriting the whole API</strong> Why not? Not adequate because the API is fairly large and expanding. Having to maintain the API in multiple spots is not realistic.</p>
<p>Code example:</p>
<pre><code>class WrappedApi:
  def __init__(self):
    self.example_1 = OriginalApi()
    self.example_2 = OriginalApi()

  def do_something(self, new_a, new_b, put_them_together=None):
    self.example_1.do_something(new_a, new_b, put_them_together)
    self.example_2.do_something(new_a, new_b, put_them_together)
</code></pre></li>
<li><p><strong>Using a list and a for-loop</strong> This changes the API on the object. That said, this is the backup solution in the event I can't find something more elegant. In this case, the <code>WrappedApi</code> class would not exist.</p>
<p>Code example:</p>
<pre><code>wrapped_apis = [OriginalApi(), OriginalApi()]
for wrapped_api in wrapped_apis:
  wrapped_api.do_something(1, 2, True)
</code></pre></li>
<li><p>I tried using
<em><a href="https://stackoverflow.com/questions/23717008/python-object-wrapper">Python Object Wrapper</a></em>, but I could not see how to have it call multiple sub-objects with the same arguments.</p></li>
</ul>
<p>And for anyone curious about the use case, it's actually a collection of several matplotlib <code>axes</code> objects. I don't want to reimplement to entire <code>axes</code> API (it's big), and I don't want to change all the code that makes calls on axes (like <code>plot</code>, <code>step</code>, etc.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're only implementing methods then a generic <code>__getattr__</code> can do the trick</p>
<pre><code>class Wrapper: 
    def __init__(self, x): 
        self.x = x 
    def __getattr__(self, name): 
        def f(*args, **kwargs): 
            for y in self.x: 
                getattr(y, name)(*args, **kwargs) 
        return f
</code></pre>
<p>For example with <code>x = Wrapper([[], [], []])</code> after calling <code>x.append(12)</code> all the three list objects will have 12 as last element.</p>
<p>Note that the return value will always be <code>None</code>... an option could be collecting return values and returning them as a list but this of course would "break the API".</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you have the right idea here</p>
<pre><code>wrapped_apis = [OriginalApi(), OriginalApi()]
for wrapped_api in wrapped_apis:
    wrapped_api.do_something(1, 2, True)
</code></pre>
<p>You can define your wrapper class by <em>inheriting</em> from <code>list</code> and then handle the API calls to its items once it is created.</p>
<pre><code>class WrapperClass(list):
    def __init__(self, api_type):
        self.api_type = api_type

        for func in dir(api_type):
            if callable(getattr(api_type, func)) and not func.startswith("__"):
                setattr(self, func, lambda *args, **kwargs: 
                    [getattr(o, func)(*args, **kwargs) for o in self])

w = WrapperClass(OriginalApi)
o1, o2 = [OriginalApi()]*2
w.append(o1)
w.append(o2)
print(w.do_something(1, 2, True))
# [None, None]
print(w[0].b)
# 12
print(w[1].b)
# 12
print(o1.b)
# 12
</code></pre>
<p>Here, I'm iterating every method in your API class and creating a method in the wrapper class that applies its arguments to all its list items. It then returns a list comprehension consisting of the results.</p>
<p>Needless to say, you should probably validate the type of a new object being appended to this <code>WrapperClass</code> like so,</p>
<pre><code>def append(self, item):
    if not isinstance(item, self.api_type):
        raise TypeError('Wrong API type. Expected %s'.format(self.api_type))
    super(WrapperClass, self).append(item)
</code></pre>
</div>
<span class="comment-copy">How do you want to handle the sequence protocol? Should indexing into the wrapper give you one of the wrapped items, or the result of indexing into all of the wrapped items? This is going to be complex in the generic case.</span>
<span class="comment-copy">is this referring to <code>def __getitem__(self, i):</code>? If so, I hadn't thought about that, but I think either method would be valid for my situation</span>
<span class="comment-copy">This only works for methods and other callable attributes, though. Gathering the results into a list would be straightforward, but it'd be hard to distinguish between the cases where you have a list of <code>None</code>s and should return the list, or a list of <code>None</code>s and should return <code>None</code>.</span>
<span class="comment-copy">@jonrsharpe: yes of course, but it's hard to multiplex a protocol that requires reading without changing the API. What should <code>len(x)</code> return if the contained objects don't answer the same?</span>
<span class="comment-copy">Well, quite! As I said above, in the generic case this gets very complex.</span>
<span class="comment-copy">good point on the return values. i'm hoping my usage of <code>matplotlib</code> gets away with ignoring most return values. And if it doesn't? Then... well... this get a lot harder. I'll ask a new question if that's the case.</span>
