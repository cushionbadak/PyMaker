<div class="post-text" itemprop="text">
<p>I'm developing a Python extension in c++. I'm am really rusty in c++ however and don't have the necessary experience to figure this out it seems. I'm trying to read in numpy arrays, do the calculations I want to do and then return a numpy array. The problem I'm having is converting the numpy array to something of a normal Double array in 'c format'. I tried two methods to convert the data but both result in the same, seems to be storing the memory locations when I print out the arrays, not the actual values</p>
<p>Here is the code with some comments.</p>
<pre class="lang-cpp prettyprint-override"><code>static PyObject* mymodule_function(PyObject *self, PyObject *args){
    PyArrayObject *x_obj,*y_obj;
    double *x, *y;

    if (!PyArg_ParseTuple(args, "O!O!", &amp;PyArray_Type, &amp;x_obj,&amp;PyArray_Type, &amp;y_obj))  return NULL;
    if (NULL == x_obj)  return NULL;
    if (NULL == y_obj)  return NULL;

    npy_intp N = PyArray_DIM(x_obj, 0);
    std::cout &lt;&lt; int(N) &lt;&lt; std::endl;   //Correctly prints out size of array 

    //method 1 I tried to convert data
    x = (double*)x_obj-&gt;data;
    //method 2 that I tried
    y = (double*)PyArray_DATA(y_obj);

    // Debug printing.
    for (int i = 0; i &lt; (int)N; i ++){
        std::cout &lt;&lt; x[i] &lt;&lt; std::endl; 
        std::cout &lt;&lt; y[i] &lt;&lt; std::endl; 
    }
    //prints out array correctly

    double z[N];
    myfunction(x,y,z,(int)N);  

    // Debug printing.
    for (int i = 0; i &lt; (int)N; i ++){
        std::cout &lt;&lt; z[i] &lt;&lt; std::endl; 
    }
    //prints out array correctly    

    npy_intp dims[1];
    dims[0] = N;
    PyObject *pyArray = PyArray_SimpleNewFromData(1, dims, NPY_DOUBLE, z);

    PyObject *ret = Py_BuildValue("O", pyArray);
    return ret;
}
</code></pre>
<p>and the Python code I use:</p>
<pre class="lang-py prettyprint-override"><code>import numpy as np
import mymodule as mm

a = np.array([1,2,3],dtype=np.float64)
b = np.array([4,5,6],dtype=np.float64)
c = np.zeros(shape=(1,3),dtype=np.float64)
c = mm.function(a,b)
print(c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Specifying the data type in your python deceleration for a,b,c as dtype=np.float64. Double in C parlance is 64 bit float. using np.array like the way you've used it usually returns np.int64. using np.array like so will return a np.float64</p>
<pre><code>a=np.array([1.,2.,3.])
</code></pre>
</div>
<span class="comment-copy">try specifying the data type in your python deceleration for a,b,c as dtype=np.float64. Double in C parlance is 64 bit float. np.array usually returns np.int64.</span>
<span class="comment-copy">oh no :( That was indeed the problem. Thank you!</span>
<span class="comment-copy">ok. will upgrade to answer.</span>
<span class="comment-copy">currently though still facing the issue on the other end. When I read out my array c it still prints out like before. print(c): [  2.70641052e-312  -4.96427367e+193   2.71209304e-312]. However printing out Z right before I return in my c++ function prints out the result correctly.  I updated my original post to the current code</span>
<span class="comment-copy">Nevermind, seems to be an issue with using the print statement like that.</span>
