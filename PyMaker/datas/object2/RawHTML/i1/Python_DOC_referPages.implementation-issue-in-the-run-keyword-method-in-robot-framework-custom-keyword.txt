<div class="post-text" itemprop="text">
<p>I am learning the dynamic library implementation in robot framework using python. In this process, I have created a new keyword using the dynamic library as explained in <a href="http://robotframework.org/robotframework/2.8.7/RobotFrameworkUserGuide.html#running-keywords" rel="nofollow noreferrer">this</a> link.</p>
<p>The source code is given below</p>
<pre><code>import logging


class libdynamicsampl1:
    def get_keyword_names(self):
        return ["methOne", "methTwo"]

    def methOne(self):
        logging.info("called the methone")

    def methTwo(self, name):
        logging.info("called the methtwo with the arg as" + name)

    def run_keyword(self, name, args):
        print "Running keyword '%s' with arguments %s." % (name, args)
        methArgs = (self,) + (args)
        return getattr(self, name, methArgs)()
</code></pre>
<p>When i run this keyword from the robot file, like the code given below,</p>
<pre><code>*** Test Cases ***
Log Dynamic Test Library
    Invoke dyn tests no arg
    Invoke dyn tests with arg

*** Keywords ***
Invoke dyn tests no arg
    meth one

Invoke dyn tests with arg
    meth two    "welcome to awesome robot framework"
</code></pre>
<p>There is an error like the below, the inference is that the methTwo takes "self" and "name", but using getattr(...) passes only the name I guess.</p>
<blockquote>
<p>TypeError: methTwo() takes exactly 2 arguments (1 given)</p>
</blockquote>
<p>Kindly help in fixing this issue or suggest the best practice / implementation on how to invoke the methods based on the input arguments. There is no sample from the robot framework site, hence any fix will be very helpful.</p>
<p>The below implementation in the run_keyword method works fine, but i feel that its not the best practice to implement in a production ready code base.</p>
<pre><code>def run_keyword(self, name, args):
    print "Running keyword '%s' with arguments %s." % (name, args)
    if name == "methOne":
        return self.methOne()
    if name == "methTwo":
        return self.methTwo(args[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>using getattr(...) passes only the name I guess.</p>
</blockquote>
<p>That depends on how you define "only the name". <code>getattr</code> will return the function, it knows nothing about function arguments. However, the function it returns will be a method on the object, so you don't have to worry about passing the <code>self</code> parameter.</p>
<p>Consider this code:</p>
<pre><code>return getattr(self, name, methArgs)()
</code></pre>
<p>It is the same as this code (assuming <code>name</code> is a valid method name)</p>
<pre><code>func = getattr(self, name, methArgs)
func()
</code></pre>
<p>Assuming for the moment that <code>getAttr</code> returns <code>self.methTwo</code>, the above code is identical to this:</p>
<pre><code>self.methTwo()
</code></pre>
<p>Notice that in the above, your code is not passing any arguments. When used in <code>getattr</code>, that variable doensn't represent arguments, it represents a default method name in case the one requested doesn't exist. In other words, when <code>name</code> is valid, <code>getattr</code> will simply ignore <code>methArgs</code>.</p>
<p>Since one of your methods expect an argument (<code>name</code> ), you will get an error that it didn't receive all of the arguments that it expected. That is exactly what happened, apparently. </p>
<p>There are other problems with your example, so I can't be sure of the exact solution. It's not clear if you expect <code>meth one</code> in the test to call <code>methOne</code>, or if <code>meth one</code> or <code>methOne</code> is a typo.</p>
<p>Assuming you use the correct name in both places, you can directly convert the name to the method with getattr, similar to how you are doing it now. The difference is simply that you need to pass the arguments to the function rather than to <code>getattr</code>.</p>
<p>For example, given this robot code snippet:</p>
<pre><code>Invoke dyn tests with arg
    methTwo    "welcome to awesome robot framework"
</code></pre>
<p>Here is how you would implement <code>run_keyword</code> in order for that robot code to run:</p>
<pre><code>def run_keyword(self, name, args):
    print "Running keyword '%s' with arguments %s." % (name, args)
    func = getattr(self, name)
    return func(*args)
</code></pre>
</div>
<span class="comment-copy">What are you trying to accomplish? Are you wanting "meth one" (with a single space) to call the <code>methOne</code> method? The code you posted doesn't give the error you say it does. It will give the error <code>No keyword with name 'meth one' found.</code>.</span>
<span class="comment-copy">In your link you refer to the documentation of Robot Framework 2.8.7. Is this deliberate, or by accident? In the current version of Robot Framework the documenation on <a href="http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#dynamic-library-api" rel="nofollow noreferrer">Dynamic Library</a> is more extensive with examples.</span>
<span class="comment-copy">@BryanOakley, I have the <code>libdynamicsampl1.py</code> invoked and tested in the robot file mentioned above. I am not sure on how to use the <code>run_keyword</code> implementation. Though the documentation gives a sample that prints out the name of the methods that are being invoked, there is no mention on how to invoke the method in the real time, meaning, we should invoke the method as robot framework has no way to identify which method we are actually invoking. How should the implementation be so that the methods are invoked. The documentation lacks the robot file consumption and real-time examples</span>
<span class="comment-copy">@A.Kootstra, the documentation is really good, but there are snippets of code which is of no real use when we can't put together and make a full sample. Had the documentation covered various topics from a single code base and finally make a full-blown functional flow or test that can be used as a reference, it will be very helpful.</span>
<span class="comment-copy">yes, that's what the documentation claims that we can invoke methods by cased characters or by a "_", so i wanted to try those.</span>
<span class="comment-copy">using the <code>func(*args)</code> worked fine in the above approach. Thanks a lot for the clarification.</span>
