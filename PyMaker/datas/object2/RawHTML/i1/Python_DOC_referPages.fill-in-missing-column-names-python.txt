<div class="post-text" itemprop="text">
<p>I'm trying to concatenate a bunch of dataframes together, which all have the same information. But some column names are missing and some dataframes have extra columns. However, for the columns they do have, they all follow the same order. I'd like a function to fill in the missing names. The following almost works:</p>
<pre><code>def fill_missing_colnames(colnames):

    valid_colnames = ['Z', 'K', 'C', 'T', 'A', 'E', 'F', 'G']

    missing = list(set(valid_colnames) - set(colnames))
    if len(missing) &gt; 0:  
        for i, col in enumerate(colnames):
            if col not in valid_colnames and len(missing) &gt; 0:
                colnames[i] = missing.pop(0)
    return colnames
</code></pre>
<p>But the problem is that set() orders the elements alphabetically, whereas I'd like to preserve the order from the column names (or rather from the valid column names).</p>
<pre><code>colnames = ['K', 'C', 'T', 'E', 'XY', 'F', 'G']

list(set(valid_colnames) - set(colnames))
Out[9]: ['A', 'Z']
</code></pre>
<p>The concat looks like this:</p>
<pre><code>concat_errors = {}
all_data = pd.DataFrame(list_of_dataframes[0])
for i, data in enumerate(list_of_dataframes[1:]):
    try:
        all_data = pd.concat([all_data, pd.DataFrame(data)], axis = 0, sort = False)
    except Exception as e:
        concat_errors.update({i+1:e})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension instead of a set operation.</p>
<p><code>missing = [col for col in valid_colnames if col not in colnames]</code></p>
<p>That will simply filter out the values that are not in <em>colnames</em> and preserve order.</p>
</div>
<span class="comment-copy">What does your concatenation code look like?</span>
<span class="comment-copy">Added the concat script above</span>
