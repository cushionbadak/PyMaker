<div class="post-text" itemprop="text">
<p>I tried to search the index of a find with bisection algorithms</p>
<pre><code>def bi_search(nums: List[int], find: int) -&gt; int:
    """
    Return the index of the find 
    """
    if len(nums) == 0:
        return -1
    else:
        mid = len(nums) // 2  #testEntry
        if find == nums[mid]:
            return mid 
        if find &lt; nums[mid]:
            sub_nums = nums[:mid]
            return bi_search(sub_nums, find)  

        if find &gt; nums[mid]:
            sub_nums = nums[mid:]
            return bi_search(sub_nums, find) #recursive case.
</code></pre>
<p>but it does not work as expected</p>
<pre><code>In [26]: bi_search(list(range(1000)), 777)                     
Out[26]: 4
</code></pre>
<p>It return the mid of the base case.</p>
<p>I noticed that a correct index could be retrieve using iteration methods as in <a href="https://docs.python.org/3.7/library/bisect.html" rel="nofollow noreferrer">bisect — Array bisection algorithm — Python 3.7.3rc1 documentation</a></p>
<p>Is it possible to get a correct index in a recursive solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you add a <code>print()</code> statement to the function and use a smaller example, you can see the problem:</p>
<pre><code>def bi_search(nums, find):
    print((nums, find))
    ...

print(bi_search(list(range(10)), 7))
</code></pre>
<p>Output:</p>
<pre><code>([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 7)   # Looks good.
([5, 6, 7, 8, 9], 7)                  # Also good.
2                                     # Doh!
</code></pre>
<p>The problem is that you are returning the index in the <strong>last list checked</strong>, not the index of the <strong>initial list</strong>. To make your approach work, you need to pass more information through the recursive calls -- and it gets tricky.</p>
<p>A different approach is to pass the full list for every call, and instead adjust the lower/upper bounds for searching as you go. This also has the advantage of avoiding the creation of new lists with each call. For example:</p>
<pre><code>def bi_search(nums, find, i = None, j = None):
    # Setup.
    N = len(nums)
    if i is None:
        i = 0
        j = N - 1
    # Base case for failure.
    if j &lt; i:
        return None
    # Success or recurse.
    mid = (i + j) // 2
    if find == nums[mid]:
        return mid 
    elif find &lt; nums[mid]:
        return bi_search(nums, find, i, mid - 1)
    else:
        return bi_search(nums, find, mid + 1, j)
</code></pre>
</div>
<span class="comment-copy">The correct index?  It's harder with your approach.  That's because in the last iteration, nums will be something like [773,774,775,776,777,778,779,780,781,782].  A recursive solution that would work would be to have a function like bi_search(nums, lower_bound, upper_bound) where you are sure that the target element is between the indices of lower_bound and upper_bound.  And you just pass nums through WITHOUT slicing it.</span>
