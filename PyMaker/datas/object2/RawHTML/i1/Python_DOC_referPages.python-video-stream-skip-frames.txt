<div class="post-text" itemprop="text">
<p>I want to live search the screen of my android phone with opencv and python.
My phone streams its screen via http and i am reading the stream with some code like this:</p>
<pre><code>host = "192.168.178.168:8080"
hoststr = 'http://' + host +  '/stream.mjpeg'
print 'Streaming ' + hoststr
stream=urllib2.urlopen(hoststr)
bytes=''
drop_count = 0
while True:
    bytes+=stream.read(1024)
    a = bytes.find('\xff\xd8')
    b = bytes.find('\xff\xd9')
    if a!=-1 and b!=-1:
        drop_count+=1
        if drop_count &gt; 120:
            drop_count = 0
            jpg = bytes[a:b+2]
            bytes= bytes[b+2:]
            i=cv2.imdecode(np.fromstring(jpg,dtype=np.uint8),cv2.IMREAD_COLOR)
            cv2.imshow(hoststr,i)
            process_img(i)#my image processing
            if cv2.waitKey(1) ==27:
                exit(0)
</code></pre>
<p>The problem is, that my screen searching takes too long and creates a big delay. Since the fps my phone is sending are way to much, i would like to only process one image per second or per two seconds. How can i do that? I can not change the fps on my phone.
I can resize the screen image on the phone to 50% before sending it, but if i resize it more than 50% i can not find what im searching for with opencv anymore. But even with 50% resize is is too much delayed.
If i make a simple counter and only process every 2/10/30 image that does not help.</p>
<p>EDIT: I added my simple counter implementation to drop frames, that does not help. If I dont process the image, i got constant small delay with and without framedropping.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm guessing the delay get's so long, because you only display the processed frames. Effectively only 1 out of every 120 frames is show. And that frame is shown for the next 120 frames and the the processing time. That would make it seem laggy indeed.<br/>
You should display all frames normally and only call the <code>process_img()</code> function every 120th frame.<br/>
Try if this improves things:</p>
<pre><code>if a!=-1 and b!=-1:
    drop_count+=1
    jpg = bytes[a:b+2]
    bytes= bytes[b+2:]
    i=cv2.imdecode(np.fromstring(jpg,dtype=np.uint8),cv2.IMREAD_COLOR)
    cv2.imshow(hoststr,i)
    if drop_count &gt; 120: # only process every 120th frame
        drop_count = 0
        process_img(i)#my image processing
    if cv2.waitKey(1) ==27:
        exit(0)
</code></pre>
</div>
<span class="comment-copy">Are you sure <code>process_img()</code> is the bottleneck? Does your code run at high fps without <code>process_img()</code>? If so, a simple counter should be a good fix. Can you show the code with your implementation of a counter?</span>
<span class="comment-copy">yeah, it runs fine without the image processing with high fps and usual ~0.5s delay. I edited and added my counter implementation. If i use it without the image processing, i got the usual constant 0.5s delay and only around 3 fps, but with image processing i got 10s delay and its getting even bigger while streaming.</span>
