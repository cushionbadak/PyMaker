<div class="post-text" itemprop="text">
<p>I have some time series data where I have sets of time series, each <code>Timeseries</code> instance of which has a one-to-many relationship
with <code>Point</code> instances. Below is a simplified representation of the data. </p>
<p><strong>tables.py:</strong></p>
<pre><code>class Timeseries(Base):
    __tablename__ = "timeseries"

    id = Column("id", Integer, primary_key=True)
    points = relationship("Point", back_populates="ts")


class Point(Base):
    __tablename__ = "point"

    id = Column("id", Integer, primary_key=True)
    t = Column("t", Float)
    v = Column("v", Float)
    ts_id = Column(Integer, ForeignKey("timeseries.id"))
    ts = relationship("Timeseries", back_populates="points")
</code></pre>
<p><strong>Question</strong>: I'm trying to come up with a query with these kind of columns: "timeseries_id", "id", "t",  "v", "id_next", "t_next", "v_next". That is, I want to be able to see each point's data alongside the next points data in the time series in chronological order, but I've been struggling get a table that doesn't elements from a implicit join? (Edit: An important point is that I want to be able to get this list using 100% queries and subquery objects in sqlalchemy, because I need to use this queried table in further joins, filters, etc.) Here's the basic start of what I got, (Note that I haven't run this code since this is a simplified version of my actual database, but it's the same idea):</p>
<pre><code># The point data actually in the database.
sq = (session.query(
    Timeseries.id.label("timeseries_id"),
    Point.id,
    Point.t,
    Point.v)
.select_from(
    join(Timeseries, Point, Timeseries.id==Point.ts_id))
.group_by('timeseries_id')
.subquery())

# first point manually added to each list in query
sq_first = (session.query(
    Timeseries.id.label("timeseries_id"),
    sa.literal_column("-1", Integer).label("id"), # Some unused Point.id value
    sa.literal_column(-math.inf, Float).label("t"),
    sa.literal_column(-math.inf, Float).label("v"))
.select_from(
    join(Timeseries, Point, Timeseries.id==Point.ts_id))
.subquery())

# last point manually added to each list in query.
sq_last = (session.query(
    Timeseries.id.label("timeseries_id"),
    sa.literal_column("-2", Integer).label("id"), # Another unused Point.id value
    sa.literal_column(math.inf, Float).label("t"),
    sa.literal_column(math.inf, Float).label("v"))
.select_from(
    join(Timeseries, Point, Timeseries.id==Point.ts_id))
.subquery())

# Append each timeseries in `sq` table with last point
sq_points_curr = session.query(sa.union_all(sq_first, sq)).subquery()
sq_points_next = session.query(sa.union_all(sq, sq_last)).subquery()
</code></pre>
<p>Assuming what I've done so far is useful, this is the part where I get stuck:</p>
<pre><code>#I guess rename the columns in `sq_points_next` to append them by "_next"....
sq_points_next = (session.query(
    sq_points_curr.c.timeseries_id
    sq_points_curr.c.id.label("id_next"),
    sq_points_curr.c.t.label("t_next"),
    sq_points_curr.c.v.label("v_next"))
.subquery())

# ... and then perform a join along "timeseries_id" somehow to get the table I originally wanted...
sq_point_pairs = (session.query(
    Timeseries.id.label("timeseries_id")
    "id",
    "t",
    "v",
    "id_next",
    "t_next",
    "v_next"
).select_from(
    sq_points, sq_points_next, sq_points.timeseries_id==sq_points_next.timeseries_id)
)
</code></pre>
<p>I'm not even sure if this last would compile at this point since again it is adapted/simplified from real code but it doesn't yield a table of adjacent points in time, etc..</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you can get a recent enough version of the sqlite3 python module working (eg. by using Anaconda), you can use the <code>LEAD</code> window function to accomplish your goal. In order to use the results of the <code>LEAD</code> function in further queries, you'll need to use a CTE as well. The following approach worked for me with the schema you gave:</p>
<pre class="lang-py prettyprint-override"><code>sq = session.query(
        Timeseries.id.label("timeseries_id"),
        Point.id.label("point_id"),
        Point.t.label("point_t"),
        Point.v.label("point_v"),
        func.lead(Point.id).over().label('point_after_id'),
        func.lead(Point.v).over().label('point_after_v'),
        func.lead(Point.t).over().label('point_after_t')).select_from(
            join(Timeseries, Point, Timeseries.id == Point.ts_id)).order_by(Timeseries.id)

with_after = sq.cte()
session.execute(with_after.select().where(
        with_after.c.point_v &lt; with_after.c.point_after_v)).fetchall()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than jumping through hoops to get the query to produce the paired results you are looking for, why not just retrieve all the <code>points</code> data related to a particular <code>Timeseries</code> row and then recombine the data into the pairs you are looking for?  For example:</p>
<pre><code>from operator import attrgetter

def to_dict(a, b):
    # formats a pair of points rows into a dict object
    return {
        'timeseries_id': a.ts_id,
        'id': a.id, 't': a.t, 'v': a.v,
        'id_next': b.id, 't_next': b.t, 'v_next': b.v
    }      

def timeseries_pairs(session, ts_id):
        # queries the db for particular Timeseries row, and combines points pairs
        ts = session.query(Timeseries).\
            filter(Timeseries.id == ts_id).\
            first()

        ts.points.sort(key=attrgetter('t'))
        pairs = [to_dict(a, b) for a, b in zip(ts.points, ts.points[1:])]
        last = ts.points[-1]
        pairs.append({
            'timeseries_id': last.ts_id,
            'id': last.id, 't': last.t, 'v': last.v,
            'id_next': None, 't_next': None, 'v_next': None
            })

        return pairs

# pass the session and a timeseries id to return a list of points pairs
timeseries_pairs(session, 1)
</code></pre>
</div>
<span class="comment-copy">Does the underlying database support window functions? It sounds like that's exactly what you need.</span>
<span class="comment-copy">I'm using sqlite, and it looks like it does. I will look at this when I get a chance: <a href="http://www.sqlitetutorial.net/sqlite-window-functions/" rel="nofollow noreferrer">sqlitetutorial.net/sqlite-window-functions</a></span>
<span class="comment-copy">Ah, unfortunately window functions were only added to sqlite in version 3.25, and the version available in the default python distribution is 3.13. If you use Anaconda, though, you're in luck - it has version 3.26. Or if you're using windows it may be possible to access it - see the third comment on this issue: <a href="https://bugs.python.org/issue34916" rel="nofollow noreferrer">bugs.python.org/issue34916</a>.</span>
<span class="comment-copy">This is an interesting approach. I'm not familiar with cte, but i will try this tonight. I am on linux so fingers crossed.</span>
<span class="comment-copy">I haven't really checked it out yet if this answer works yet but enjoy the bounty lol.</span>
<span class="comment-copy">Do feel free to follow up if you run into trouble :)</span>
<span class="comment-copy">So I suppose this does get a list of pairs, but I want to do this with just sub/query objects. I can manually construct a pair of points easily enough, but I want to use the query/table directly in further joins and filters, etc. (Also a small-ish detail: the timeseries instances are sorted by the <code>t</code> ("time") attribute, not id, which could be out of order. I'm not too worried about this though.).</span>
<span class="comment-copy">@user27886 - fair enough. If I get some more time later, I will take a look at the query only approach. Edited the sort to use the <code>t</code> value just so it doesn't confuse anyone else that comes along.</span>
