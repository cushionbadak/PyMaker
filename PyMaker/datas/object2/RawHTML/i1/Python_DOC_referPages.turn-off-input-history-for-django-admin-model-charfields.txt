<div class="post-text" itemprop="text">
<p>How do I override an admin template (e.g. admin/index.html) while at the same time extending it (see <a href="https://docs.djangoproject.com/en/dev/ref/contrib/admin/#overriding-vs-replacing-an-admin-template" rel="noreferrer">https://docs.djangoproject.com/en/dev/ref/contrib/admin/#overriding-vs-replacing-an-admin-template</a>)?</p>
<p>First - I know that this question has been asked and answered before (see <a href="https://stackoverflow.com/questions/3967801/django-overriding-and-extending-an-app-template">Django: Overriding AND extending an app template</a>) but as the answer says it isn't directly applicable if you're using the app_directories template loader (which is most of the time).</p>
<p>My current workaround is to make copies and extend from them instead of extending directly from the admin templates. This works great but it's really confusing and adds extra work when the admin templates change.</p>
<p>It could think of some custom extend-tag for the templates but I don't want to reinvent the wheel if there already exists a solution.</p>
<p>On a side note: Does anybody know if this problem will be addressed by Django itself?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update</strong>: </p>
<p>Read the Docs for your version of Django. e.g. </p>
<p><a href="https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#admin-overriding-templates" rel="noreferrer">https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#admin-overriding-templates</a>
<a href="https://docs.djangoproject.com/en/2.0/ref/contrib/admin/#admin-overriding-templates" rel="noreferrer">https://docs.djangoproject.com/en/2.0/ref/contrib/admin/#admin-overriding-templates</a></p>
<p>Original answer from 2011:</p>
<p>I had the same issue about a year and a half ago and I found a nice <a href="http://djangosnippets.org/snippets/1376/" rel="noreferrer">template loader on djangosnippets.org</a> that makes this easy. It allows you to extend a template in a specific app, giving you the ability to create your own <strong>admin/index.html</strong> that extends the admin/index.html template from the admin app. Like this:</p>
<pre class="lang-none prettyprint-override"><code>{% extends "admin:admin/index.html" %}

{% block sidebar %}
    {{block.super}}
    &lt;div&gt;
        &lt;h1&gt;Extra links&lt;/h1&gt;
        &lt;a href="/admin/extra/"&gt;My extra link&lt;/a&gt;
    &lt;/div&gt;
{% endblock %}
</code></pre>
<p>I've given a full example on how to use this template loader in a <a href="http://heyman.info/2011/jul/5/extending-templates-specific-django-app/" rel="noreferrer">blog post</a> on my website.</p>
</div>
<div class="post-text" itemprop="text">
<p>As for Django 1.8 being the current release, there is no need to symlink, copy the admin/templates to your project folder, or install middlewares as suggested by the answers above. Here is what to do:</p>
<ol>
<li><p>create the following tree structure(recommended by the <a href="https://docs.djangoproject.com/en/1.8/ref/contrib/admin/#admin-overriding-templates" rel="noreferrer">official documentation</a>)</p>
<pre><code>your_project
     |-- your_project/
     |-- myapp/
     |-- templates/
          |-- admin/
              |-- myapp/
                  |-- change_form.html  &lt;- do not misspell this
</code></pre></li>
</ol>
<p><strong>Note</strong>: The location of this file is not important. You can put it inside your app and it will still work. As long as its location can be discovered by django. What's more important is the name of the HTML file has to be the same as the original HTML file name provided by django.</p>
<ol start="2">
<li><p>Add this template path to your <strong>settings.py</strong>:</p>
<pre><code>TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')], # &lt;- add this line
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre></li>
<li><p>Identify the name and block you want to override. This is done by looking into django's admin/templates directory. I am using virtualenv, so for me, the path is here:</p>
<pre><code>~/.virtualenvs/edge/lib/python2.7/site-packages/django/contrib/admin/templates/admin
</code></pre></li>
</ol>
<p>In this example, I want to modify the add new user form. The template responsiblve for this view is <strong>change_form.html</strong>. Open up the change_form.html and find the {% block %} that you want to extend.</p>
<ol start="4">
<li><p>In <strong>your change_form.html</strong>, write somethings like this:</p>
<pre><code>{% extends "admin/change_form.html" %}
{% block field_sets %}
     {# your modification here #}
{% endblock %}
</code></pre></li>
<li><p>Load up your page and you should see the changes</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>if you need to overwrite the <code>admin/index.html</code>, you can set the <a href="https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.AdminSite.index_template">index_template</a> parameter of the <code>AdminSite</code>.</p>
<p>e.g.</p>
<pre><code># urls.py
...
from django.contrib import admin

admin.site.index_template = 'admin/my_custom_index.html'
admin.autodiscover()
</code></pre>
<p>and place your template in <code>&lt;appname&gt;/templates/admin/my_custom_index.html</code></p>
</div>
<div class="post-text" itemprop="text">
<p>With <code>django</code> 1.5 (at least) you can define the template you want to use for a particular <code>modeladmin</code></p>
<p>see <a href="https://docs.djangoproject.com/en/1.5/ref/contrib/admin/#custom-template-options" rel="nofollow noreferrer">https://docs.djangoproject.com/en/1.5/ref/contrib/admin/#custom-template-options</a></p>
<p>You can do something like</p>
<pre><code>class Myadmin(admin.ModelAdmin):
    change_form_template = 'change_form.htm'
</code></pre>
<p>With <code>change_form.html</code> being a simple html template extending <code>admin/change_form.html</code> (or not if you want to do it from scratch)</p>
</div>
<div class="post-text" itemprop="text">
<p>Chengs's answer is correct, howewer according to the admin docs not every admin template can be overwritten this way: 
<a href="https://docs.djangoproject.com/en/1.9/ref/contrib/admin/#overriding-admin-templates" rel="noreferrer">https://docs.djangoproject.com/en/1.9/ref/contrib/admin/#overriding-admin-templates</a></p>
<blockquote>
<p><em>Templates which may be overridden per app or model</em></p>
<p>Not every template in contrib/admin/templates/admin may be overridden
  per app or per model. The following can:</p>
<pre><code>app_index.html
change_form.html
change_list.html
delete_confirmation.html
object_history.html
</code></pre>
<p>For those <strong>templates that cannot be overridden</strong> in this way, you may
  still override them for your entire project. Just <strong>place</strong> the new
  version in your <strong>templates/admin</strong> directory. This is particularly useful
  to create custom 404 and 500 pages</p>
</blockquote>
<p>I had to overwrite the login.html of the admin and therefore had to put the overwritten template in this folder structure: </p>
<pre><code>your_project
 |-- your_project/
 |-- myapp/
 |-- templates/
      |-- admin/
          |-- login.html  &lt;- do not misspell this
</code></pre>
<p>(without the myapp subfolder in the admin) 
I do not have enough repution for commenting on Cheng's post this is why I had to write this as new answer. </p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to do it is to put the Django admin templates inside your project. So your templates would be in <code>templates/admin</code> while the stock Django admin templates would be in say <code>template/django_admin</code>. Then, you can do something like the following:</p>
<p><strong>templates/admin/change_form.html</strong></p>
<pre><code>{% extends 'django_admin/change_form.html' %}

Your stuff here
</code></pre>
<p>If you're worried about keeping the stock templates up to date, you can include them with svn externals or similar.</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree with Chris Pratt. But I think it's better to create the symlink to original Django folder where the admin templates place in:</p>
<pre><code>ln -s /usr/local/lib/python2.7/dist-packages/django/contrib/admin/templates/admin/ templates/django_admin
</code></pre>
<p>and as you can see it depends on python version and the folder where the Django installed. So in future or on a production server you might need to change the path.</p>
</div>
<div class="post-text" itemprop="text">
<p>I couldn't find a single answer or a section in the official Django docs that had <em>all</em> the information I needed to override/extend the default admin templates, so I'm writing this answer as a complete guide, hoping that it would be helpful for others in the future.</p>
<p>Assuming the standard Django project structure:</p>
<pre><code>mysite-container/         # project container directory
    manage.py
    mysite/               # project package
        __init__.py
        admin.py
        apps.py
        settings.py
        urls.py
        wsgi.py
    app1/
    app2/
    ...
    static/
    templates/
</code></pre>
<p>Here's what you need to do:</p>
<ol>
<li><p>In <code>mysite/admin.py</code>, create a sub-class of <code>AdminSite</code>:</p>
<pre class="lang-py prettyprint-override"><code>from django.contrib.admin import AdminSite


class CustomAdminSite(AdminSite):
    # set values for `site_header`, `site_title`, `index_title` etc.
    site_header = 'Custom Admin Site'
    ...

    # extend / override admin views, such as `index()`
    def index(self, request, extra_context=None):
        extra_context = extra_context or {}

        # do whatever you want to do and save the values in `extra_context`
        extra_context['world'] = 'Earth'

        return super(CustomAdminSite, self).index(request, extra_context)


custom_admin_site = CustomAdminSite()
</code></pre>
<p>Make sure to import <code>custom_admin_site</code> in the <code>admin.py</code> of your apps and register your models on it to display them on your customized admin site (if you want to).</p></li>
<li><p>In <code>mysite/apps.py</code>, create a sub-class of <code>AdminConfig</code> and set <code>default_site</code> to <code>admin.CustomAdminSite</code> from the previous step:</p>
<pre class="lang-py prettyprint-override"><code>from django.contrib.admin.apps import AdminConfig


class CustomAdminConfig(AdminConfig):
    default_site = 'admin.CustomAdminSite'
</code></pre></li>
<li><p>In <code>mysite/settings.py</code>, replace <code>django.admin.site</code> in <code>INSTALLED_APPS</code> with <code>apps.CustomAdminConfig</code> (your custom admin app config from the previous step).</p>
<pre class="lang-py prettyprint-override"><code>from django.contrib.admin.apps import AdminConfig


class CustomAdminConfig(AdminConfig):
    default_site = 'admin.CustomAdminSite'
</code></pre></li>
<li><p>In <code>mysite/urls.py</code>, replace <code>admin.site.urls</code> from the admin URL to <code>custom_admin_site.urls</code></p>
<pre class="lang-py prettyprint-override"><code>from .admin import custom_admin_site


urlpatterns = [
    ...
    path('admin/', custom_admin_site.urls),
    # for Django 1.x versions: url(r'^admin/', include(custom_admin_site.urls)),
    ...
]
</code></pre></li>
<li><p>Create the template you want to modify in your <code>templates</code> directory, maintaining the default Django admin templates directory structure as specified in the <a href="https://docs.djangoproject.com/en/dev/ref/contrib/admin/#set-up-your-projects-admin-template-directories" rel="nofollow noreferrer">docs</a>. For example, if you were modifying <code>admin/index.html</code>, create the file <code>templates/admin/index.html</code>.</p>
<p>All of the existing templates can be modified this way, and their names and structures can be found in <a href="https://github.com/django/django/tree/master/django/contrib/admin/templates/admin" rel="nofollow noreferrer">Django's source code</a>.</p></li>
<li><p>Now you can either override the template by writing it from scratch or extend it and then override/extend specific blocks.</p>
<p>For example, if you wanted to keep everything as-is but wanted to override the <code>content</code> block (which on the index page lists the apps and their models that you registered), add the following to <code>templates/admin/index.html</code>:</p>
<pre class="lang-html prettyprint-override"><code>{% extends 'admin/index.html' %}

{% block content %}
  &lt;h1&gt;
    Hello, {{ world }}!
  &lt;/h1&gt;
{% endblock %}
</code></pre>
<p>To preserve the original contents of a block, add <code>{{ block.super }}</code> wherever you want the original contents to be displayed:</p>
<pre class="lang-html prettyprint-override"><code>{% extends 'admin/index.html' %}

{% block content %}
  &lt;h1&gt;
    Hello, {{ world }}!
  &lt;/h1&gt;
  {{ block.super }}
{% endblock %}
</code></pre>
<p>You can also add custom styles and scripts by modifying the <code>extrastyle</code> and <code>extrahead</code> blocks.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://jaredforsyth.com/blog/2010/apr/06/giving-django-admin-favicon/" rel="nofollow"><strong>This</strong></a> site had a simple solution that worked with my Django 1.7 configuration.</p>
<p><strong>FIRST:</strong> Make a symlink named <strong>admin_src</strong> in your project's template/ directory to your installed Django templates. For me on Dreamhost using a virtualenv, my "source" Django admin templates were in:</p>
<pre><code>~/virtualenvs/mydomain/lib/python2.7/site-packages/django/contrib/admin/templates/admin
</code></pre>
<p><strong>SECOND:</strong> Create an <strong>admin</strong> directory in templates/</p>
<p>So my project's template/ directory now looked like this:</p>
<pre><code>/templates/
   admin
   admin_src -&gt; [to django source]
   base.html
   index.html
   sitemap.xml
   etc...
</code></pre>
<p><strong>THIRD:</strong> In your new template/admin/ directory create a <strong>base.html</strong> file with this content:</p>
<pre><code>{% extends "admin_src/base.html" %}

{% block extrahead %}
&lt;link rel='shortcut icon' href='{{ STATIC_URL }}img/favicon-admin.ico' /&gt;
{% endblock %}
</code></pre>
<p><strong>FOURTH:</strong> Add your admin favicon-admin.ico into your static root img folder.</p>
<p>Done. Easy.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://github.com/stephenmcd/django-overextends" rel="nofollow">django-overextends</a>, which provides circular template inheritance for Django.</p>
<p>It comes from the <a href="https://github.com/stephenmcd/mezzanine" rel="nofollow">Mezzanine</a> CMS, from where Stephen extracted it into a standalone Django extension.</p>
<p>More infos you find in "Overriding vs Extending Templates" (http:/mezzanine.jupo.org/docs/content-architecture.html#overriding-vs-extending-templates) inside the Mezzanine docs.</p>
<p>For deeper insides look at Stephens Blog "Circular Template Inheritance for Django" (http:/blog.jupo.org/2012/05/17/circular-template-inheritance-for-django).</p>
<p>And in Google Groups the discussion (https:/groups.google.com/forum/#!topic/mezzanine-users/sUydcf_IZkQ) which started the development of this feature.</p>
<p>Note:</p>
<p>I don't have the reputation to add more than 2 links. But I think the links provide interesting background information. So I just left out a slash after "http(s):". Maybe someone with better reputation can repair the links and remove this note.</p>
</div>
<div class="post-text" itemprop="text">
<p>for app index  add this line to somewhere common py file like url.py</p>
<pre><code>admin.site.index_template = 'admin/custom_index.html'
</code></pre>
<p>for app module index : add this line to admin.py</p>
<pre><code>admin.AdminSite.app_index_template = "servers/servers-home.html"
</code></pre>
<p>for change list : add this line to admin class:</p>
<pre><code>change_list_template = "servers/servers_changelist.html"
</code></pre>
<p>for app module form template : add this line to your admin class</p>
<pre><code>change_form_template = "servers/server_changeform.html"
</code></pre>
<p>etc. and find other in same admin's module classes </p>
</div>
<span class="comment-copy">Copying the admin templates, extending them and overriding/adding blocks is the most efficient, although not optimal workflow given the current state of Django. I haven't seen any other way to do what you're trying to do in three years of working with it :)</span>
<span class="comment-copy">Well - I don't know if this is a good thing or not but at least people like you have come to the same conclusion. That's good to hear. :)</span>
<span class="comment-copy">For reference; the snippet in question has been converted to a django app, and is available in PyPi (pip/easy_install) as django-apptemplates: <a href="http://pypi.python.org/pypi/django-apptemplates/" rel="nofollow noreferrer">pypi.python.org/pypi/django-apptemplates</a></span>
<span class="comment-copy">Just to be 100% explicit: the above solution WILL NO LONGER WORK for  recent versions of Django (at least 1.4), as one of the functions the script uses is depreciated.  <a href="https://bitbucket.org/wojas/django-apptemplates" rel="nofollow noreferrer">You can find the updated source on here</a></span>
<span class="comment-copy">Note that with Django 1.8 this will still work, but the setup needs to be made in a special way (see <a href="https://github.com/Fantomas42/django-app-namespace-template-loader#installation" rel="nofollow noreferrer">app_namespace.Loader setup</a> as an example). <a href="https://pypi.python.org/pypi/django-app-namespace-template-loader" rel="nofollow noreferrer">django-app-namespace-template-loader</a> is also a working alternative to <code>django-apptemplates</code> if it may stop working one day.</span>
<span class="comment-copy">It is still not enough for extending the main "index.html" template, without copying all blocks. A solution is to write some <code>../</code> to "exetends" path and to specify the original path more unique <code>{% extends "../../admin/templates/admin/index.html" %}</code>. <a href="http://stackoverflow.com/a/23696160/448474">link to answer</a></span>
<span class="comment-copy">I think in TEMPLATES we should be using 'DIRS': [os.path.join(BASE_DIR, 'templates')],</span>
<span class="comment-copy">This is the type of thread that perfectly illustrates the flaw in SO.  A framework gets updated and the question is no longer relevant, it is in fact a deterrent from the proper path.  Great answer here.  RTFM kids.</span>
<span class="comment-copy">Thanks for this answer. Except for "The location of this file is not important.", everything worked great.</span>
<span class="comment-copy">Brilliant!  Doing this allows you to then do <code>{% extends "admin/index.html" %}</code> from my_custom_index.html and have that reference the django admin template without copying it. Thank you.</span>
<span class="comment-copy">@Semmel should mark this as the correct answer, since it’s the simplest approach that uses built-in django features and doesn’t require using custom template loaders.</span>
<span class="comment-copy">Thank you for the feedback hyneker I hope my answer is clearer and more straight to the point now.</span>
<span class="comment-copy">Yes, it is useful to know that templates can be customized on the project level even if some of them can be changed optionally on the application level.</span>
<span class="comment-copy">Using svn externals is a great idea. The problem this introduces is that all my translators are going to translate all those templates (because makemessages will collect the translation strings from all admin templates) which adds a lot of extra work if you're working with multiple languages. Maybe there is a way to exclude those templates from makemessages?</span>
<span class="comment-copy">Use the <code>--ignore</code> argument with <code>makemessages</code>. See: <a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#makemessages" rel="nofollow noreferrer">docs.djangoproject.com/en/dev/ref/django-admin/#makemessages</a></span>
<span class="comment-copy">I think the the other answer fits my need better. But I like your solution and think it's a good alternative if you don't want to mess around with your template loaders.</span>
