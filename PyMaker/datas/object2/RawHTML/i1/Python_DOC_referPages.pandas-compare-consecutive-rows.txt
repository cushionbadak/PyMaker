<div class="post-text" itemprop="text">
<p>I have found a few solutions by googling but I was never able to apply those properly and I was running into error which I couldn't fix so I have to ask. I tried to create function and then apply it to the dataframe but run into this error and I can't fix it.</p>
<blockquote>
<p>"'numpy.int64' object has no attribute 'shift'"</p>
</blockquote>
<p>So, I have this first dataframe</p>
<pre><code>    A   B
1   0   0
2   1   0
3   0   0
4   0   0
5   0   1
6   0   0
</code></pre>
<p>And the result should look like this:</p>
<pre><code>    A   B
1   0   0
2   1   0
3   1   0
4   1   0
5   1   1
6   0   0
</code></pre>
<p>So, when 1 occurs in column A, it should reocur in column A till 1 occurs in column B. No other input is possible and it will be for few thousand rows.</p>
<p>Thank you.</p>
<p>EDIT: <a href="https://drive.google.com/open?id=1Qz7Rres8IrThkJN1-HUImLj-jkuSLaaz" rel="nofollow noreferrer">Samplesizedata</a></p>
<p>EDIT2: This is confirmation that the edited answer works as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the following code:</p>
<pre><code>df.A = (df.A.cumsum() != df.B.shift().cumsum()\
    .fillna(0, downcast='infer')).astype(int)
</code></pre>
<p>Description:</p>
<ul>
<li><code>df.A.cumsum()</code> produces a sequence of numbers increasing
on each <code>1</code> in <code>A</code> column.</li>
<li><code>df.B.shift().cumsum()</code> produces similiar sequence for column <code>B</code>,
but shifted 1 place down and with <code>NaN</code> at the first place.</li>
<li><code>fillna(0, downcast='infer')</code> replaces the initial <code>NaN</code> with <code>0</code>
and changes the type of the whole sequence back to <code>int</code>.</li>
<li><code>(... != ...)</code> computes a boolean vector - almost what you want.</li>
<li><code>astype(int)</code> converts the above <strong>boolean</strong> vector
to <strong>int</strong> vector.</li>
<li>the whole result is substituted to <code>A</code> column.</li>
</ul>
<h1>Edit</h1>
<p>After your comment and a longer source data, I decided to solve
the issue completely other way.</p>
<p>Start from defining a function, to be applied to each row:</p>
<pre><code>def xx(row):
    global nextRes
    currRes = nextRes   # Set current result from the saved value
    if row.B == 1:
        nextRes = 0                 # Off next
    else:           # B == 0
        if row.A == 0:
            pass                    # No change
        else:       # A == 1
            currRes = nextRes = 1   # On now
    return currRes
</code></pre>
<p>This function uses a global variable <code>nextRes</code> - what should be
the result for the <strong>next</strong> row.</p>
<p><code>B == 1</code> (regardless of <code>A</code> value) means "switch off", but starting
from the <strong>next</strong> row.</p>
<p>Otherwise (<code>B == 0</code>) we have 2 possibilities:</p>
<ul>
<li><code>A == 0</code> - no change,</li>
<li><code>A == 1</code> - "switch on" <strong>now</strong>.</li>
</ul>
<p>Then, to perform your task, initialize the "next" value and apply
the above function to each row:</p>
<pre><code>nextRes = 0
df.A = df.apply(xx, axis=1)
</code></pre>
<p>Optionally, to easily compare source data with the result, run instead:</p>
<pre><code>df['new_A'] = df.apply(xx, axis=1)
</code></pre>
<p>This way you will have <strong>both</strong> source data and the "new value" of <code>A</code>.</p>
</div>
<span class="comment-copy">Your solution worked on sample size but then I tried it on my real data and it doesn't do exactly what I need. Definately my fault by not covering all angles in my question. Would you mind looking at this bigger set? I added my set to the original post. Just to explain: When 1 occurs in B, it should not change A to 1. Also when when 1 occurs in A few times without 1 in B, it should continue with adding 1s. Hopefully it's not too confusing. If yes I can add create another file how it hsould look like. Thanks.</span>
<span class="comment-copy">As I understood your comment and bigger sample data: Case 1: A=1, B=0 -&gt; 1 from the <b>current</b> position. Case 2: A=0, B=1 -&gt; 0 from the <b>next</b> position. Case 3: A=0, B=0 -&gt; no change. But what to do if <b>both</b> A and B = 1?</span>
<span class="comment-copy">If both 1, then A=0, because any B = 1 kills any streak.</span>
<span class="comment-copy">Yep. This works as well. Thank you again.</span>
