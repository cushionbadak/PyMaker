<div class="post-text" itemprop="text">
<p>I've got a dictionary: </p>
<p><code>mydict = {key1: value_a, key2: value_b, key3: value_c}</code></p>
<p>I want to write the data to a file dict.csv, in this style:</p>
<pre><code>key1: value_a
key2: value_b
key3: value_c
</code></pre>
<p>I wrote:</p>
<pre><code>import csv
f = open('dict.csv','wb')
w = csv.DictWriter(f,mydict.keys())
w.writerow(mydict)
f.close()
</code></pre>
<p>But now I have all keys in one row and all values in the next row..</p>
<p>When I manage to write a file like this, I also want to read it back to a new dictionary.</p>
<p>Just to explain my code, the dictionary contains values and bools from textctrls and checkboxes (using wxpython). I want to add "Save settings" and "Load settings" buttons.
Save settings should write the dictionary to the file in the mentioned way (to make it easier for the user to edit the csv file directly), load settings should read from the file and update the textctrls and checkboxes.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>DictWriter</code> doesn't work the way you expect.</p>
<pre><code>with open('dict.csv', 'w') as csv_file:
    writer = csv.writer(csv_file)
    for key, value in mydict.items():
       writer.writerow([key, value])
</code></pre>
<p>To read it back:</p>
<pre><code>with open('dict.csv') as csv_file:
    reader = csv.reader(csv_file)
    mydict = dict(reader)
</code></pre>
<p>which is quite compact, but it assumes you don't need to do any type conversion when reading</p>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way is to ignore the csv module and format it yourself.</p>
<pre><code>with open('my_file.csv', 'w') as f:
    [f.write('{0},{1}\n'.format(key, value)) for key, value in my_dict.items()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just to give an option, writing a dictionary to csv file could also be done with the pandas package. With the given example it could be something like this:</p>
<p><code>mydict = {'key1': 'a', 'key2': 'b', 'key3': 'c'}</code></p>
<pre><code>import pandas as pd

(pd.DataFrame.from_dict(data=mydict, orient='index')
   .to_csv('dict_file.csv', header=False))
</code></pre>
<p>The main thing to take into account is to set the 'orient' parameter to 'index' inside the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.from_dict.html" rel="noreferrer">from_dict</a> method. This lets you choose if you want to write each dictionary key in a new row. </p>
<p>Additionaly, inside the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html" rel="noreferrer">to_csv</a> method the header parameter is set to False just to have only the dictionary elements without annoying rows. You can always set column and index names inside the
to_csv method.</p>
<p>Your output would look like this:</p>
<pre><code>key1,a
key2,b
key3,c
</code></pre>
<p>If instead you want the keys to be the column's names, just use the default 'orient' parameter that is 'columns', as you could check in the documentation links.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>outfile = open( 'dict.txt', 'w' )
for key, value in sorted( mydict.items() ):
    outfile.write( str(key) + '\t' + str(value) + '\n' )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can you just do:</p>
<pre><code>for key in mydict.keys():
    f.write(str(key) + ":" + str(mydict[key]) + ",");
</code></pre>
<p>So that you can have </p>
<p>key_1: value_1, key_2: value_2</p>
</div>
<div class="post-text" itemprop="text">
<p>I've personally always found the csv module kind of annoying. I expect someone else will show you how to do this slickly with it, but my quick and dirty solution is:</p>
<pre><code>with open('dict.csv', 'w') as f:  # This creates the file object for the context 
                                  # below it and closes the file automatically
    l = []
    for k, v in mydict.iteritems(): # Iterate over items returning key, value tuples
        l.append('%s: %s' % (str(k), str(v))) # Build a nice list of strings
    f.write(', '.join(l))                     # Join that list of strings and write out
</code></pre>
<p>However, if you want to read it back in, you'll need to do some irritating parsing, especially if it's all on one line. Here's an example using your proposed file format.</p>
<pre><code>with open('dict.csv', 'r') as f: # Again temporary file for reading
    d = {}
    l = f.read().split(',')      # Split using commas
    for i in l:
        values = i.split(': ')   # Split using ': '
        d[values[0]] = values[1] # Any type conversion will need to happen here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm a noob, also late to this comments, haha, but, have you tried to add the "s" on: w.writerow(mydict) like this: w.writerows(mydict) , this issue happened to me but with lists, I was using singular instead of plural. Pops! was fix.</p>
</div>
<span class="comment-copy">can you provide a better example of what you want as output?  the "style" you have above is not CSV.  are you looking for <code>key1, value_a [linebreak] key2, value_b [linebreak] key3, value_c</code>?</span>
<span class="comment-copy">Another approach is to use <code>repr()</code> to write the dict out and then eval the string when you read it in. Look at this <a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">old SO post</a> for a discussions of <code>str()</code> vs. <code>repr()</code>, and <a href="http://docs.python.org/library/functions.html#repr" rel="nofollow noreferrer">the docs</a>, too.</span>
<span class="comment-copy">Apart from my answer below, if you prefer something a little more sophisticated than just a plain CSV file, you may want to check the <code>ConfigParser</code> module</span>
<span class="comment-copy">What you describe is the typical CSV format written out by the csv module. If you write out multiple dicts with the same keys, the keys are written only once, in the first line, with one line per dict for the corresponding values, in the proper order to line up with the keys in line 1.</span>
<span class="comment-copy">Mmh... Just noticed that you wanted a specific format which is not exactly CSV-like. Assumed that you wanted CSV style (ie. a row per key-value pair) because you were using the CSV module...</span>
<span class="comment-copy">Or... in case the CSV approach is exactly what you wanted, but you prefer ":" as a separator, just add <code>delimiter=':'</code> when creating the writer and the reader :)</span>
<span class="comment-copy">writing and reading works fine now, but I would also like to update my checkboxes and textctrls according to the values in my dictionary. I have all my widgets in "def create_controls", which is called when I start my program. But simply calling it again after reading from my csv doesn't update the state of my widgets... Do you know what is the best and simplest way to update/refresh them?</span>
<span class="comment-copy">Note, you should close the file between writing and reading.  See what happened in this question/answer: <a href="http://stackoverflow.com/a/38467563/235698">stackoverflow.com/a/38467563/235698</a></span>
<span class="comment-copy">@MarkTolonen certainly, using <code>with</code> would be better. I'll change the examples to reflect it...</span>
<span class="comment-copy">If your <code>key</code> gets a comma, you're going to have a bad time.</span>
<span class="comment-copy">I find it easier to just use <code>csv.writer(...).writerows(my_dict.items())</code>. The <code>csv</code> module does so much more than just add commas and newlines.</span>
<span class="comment-copy">Excellent worked like a charm :). My value was a list and it generated my csv with all list values in multiple cells and mapped to key in first column.</span>
<span class="comment-copy">Please also provide some information or comments on your answer.</span>
<span class="comment-copy">Better would be <code>','.join("%s:%s" % (k,v) for k,v in mydict.items())</code> - you are usually better off iterating over a dict's items, which gives you keys and values together, than over a dict's keys and doing 'n' value lookups. <code>','.join(...)</code> takes care of only putting commas between values, without adding the extra trailing comma.</span>
<span class="comment-copy">thanks @PaulMcGuire</span>
<span class="comment-copy">note that you won't need the semicolon at the end for this python code</span>
<span class="comment-copy">I would go with Ricardo's answer. Or at least use separate lines.</span>
