<div class="post-text" itemprop="text">
<p>I'm trying to figure out how to create unit tests for a function, which behavior is based on a third party service.</p>
<p>Suppose a function like this:</p>
<pre><code>def sync_check():
    delta_secs = 90
    now = datetime.datetime.now().utcnow()
    res = requests.get('&lt;url&gt;')
    alert = SlackAlert()
    last_value = res[-1]['date'] # Last element of the array is the most recent
    secs = (now - last_value).seconds

    if secs &gt;= delta_secs:
        alert.notify("out of sync. Delay: {} seconds".format(secs))
    else:
        alert.notify('in sync')
</code></pre>
<p>What's best practice to write unit test for this function? I need to test both if and else branches, but this depends on the third party service.</p>
<p>The first thing that come to my mind is to create a fake webserver and point to that one (changing url) but this way the codebase would include testing logic, like:</p>
<pre><code>if test:
    url = &lt;mock_web_server_url&gt;
else:
    url = &lt;third_party_service_url&gt;
</code></pre>
<p>Moreover, unit testing would trigger slack alerts, which doesn't have to happen.</p>
<p>So there I shoulde change again the codebase like:</p>
<pre><code>if secs &gt;= delta_secs:
    if test:
        logging.debug("out of sync alert sent - testing mode")
    else:
        alert.notify("out of sync. Delay: {} seconds".format(secs))
else:
    if test:
        logging.debug("in sync alert sent - testing mode")
    else:
        alert.notify('in sync')
</code></pre>
<p>Which I don't really like.</p>
<p>Am I missing any design to solve this problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>Check out <a href="https://stackoverflow.com/questions/130794/what-is-dependency-injection">Dependency Injection</a> to test code that depends on third party services, without having to check whether you're running in test mode, like in your example. The basic idea is to have the slack alert service be an argument of your function, so for unit testing you can use a fake service that acts the way you want it to for each test. </p>
<p>Your code would end up looking something like this:</p>
<pre><code>def sync_check(alert):
    delta_secs = 90
    now = datetime.datetime.now().utcnow()
    res = requests.get('&lt;url&gt;')
    last_value = res[-1]['date'] # Last element of the array is the most recent
    secs = (now - last_value).seconds

    if secs &gt;= delta_secs:
        alert.notify("out of sync. Delay: {} seconds".format(secs))
    else:
        alert.notify('in sync')
</code></pre>
<p>and in a test case, you could have your alert object be something as simple as:</p>
<pre><code>class TestAlert:
    def __init__(self):
        self.message = None

    def notify(self, message):
        self.message = message
</code></pre>
<p>You could then test your function by passing on an instance of your TestAlert class, and check the logged output if you want to, by accessing the <code>message</code> attribute. This code would not access any third party services.</p>
<pre><code>def test_sync_check():
    alert = TestAlert()
    sync_check(alert)
    assert alert.message == 'in sync'
</code></pre>
</div>
<span class="comment-copy">If you're unit testing, you can mock out <code>SlackAlert</code> entirely, using e.g. <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code></a>. You could also consider injecting the alert handler, rather than instantiating it inside that method, to reduce coupling. For a more integration-based test, look into something like <a href="https://github.com/getsentry/responses" rel="nofollow noreferrer"><code>responses</code></a>, depending on what client that library uses, for mocking out the network layer. You certainly <b>should not</b> have <code>if test:</code> logic inside your production code.</span>
