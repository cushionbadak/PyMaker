<div class="post-text" itemprop="text">
<p>I have another method calling this function 3 times to write 3 different files. The first 2 files are copied to the destination folder as expected, the third file is always zero bytes. If I turn off deletion I can see that all 3 temp files are written to successfully. The code reports no errors, but at the end of the process the third file is always empty.</p>
<p>Does anyone know why this is failing 1 out of 3 times? </p>
<pre><code>def write_file(file_destination: str, content: bytes):
    with tempfile.NamedTemporaryFile() as fp:
        fp.write(content)
        shutil.copy(fp.name, file_destination)
</code></pre>
<p>The following variation works, however, I would like to understand why the  first two files work and the third one does not in the above code.</p>
<pre><code>def write_file(file_destination: str, content: bytes):
    with tempfile.NamedTemporaryFile(delete=False) as fp:
        fp.write(content)
    shutil.copy(fp.name, file_destination)
    os.remove(fp.name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is because the <code>content</code> has not been written to disk yet, when you perform the copy. This happens because writes are buffered, and do not always happen immediately after you call <code>file.write</code>.
To make sure the content is written to disk at a given point, you can use <code>file.flush</code>.</p>
<p>In your case, it is sufficient to change your code to:</p>
<pre class="lang-py prettyprint-override"><code>def write_file(file_destination: str, content: bytes):
    with tempfile.NamedTemporaryFile() as fp:
        fp.write(content)
        fp.flush()
        shutil.copy(fp.name, file_destination)
</code></pre>
<p>For more information on when the contents are actually written to disk you can see the documentation of <a href="https://docs.python.org/3/library/io.html#io.BufferedWriter" rel="nofollow noreferrer"><code>io.BufferedWriter</code></a>. The relevant part is:</p>
<blockquote>
<p>The buffer will be written out to the underlying RawIOBase object
  under various conditions, including:</p>
<ul>
<li>when the buffer gets too small for all pending data;</li>
<li>when flush() is called;</li>
<li>when a seek() is requested (for BufferedRandom objects);</li>
<li>when the BufferedWriter object is closed or destroyed.</li>
</ul>
</blockquote>
<p>Therefore, in your first example, it is possible that it works only sometimes, because those times the content you are writing exceeds the buffer and so needs to be written out immediately.</p>
<p>Your second example, instead, works, because when you are exiting the <code>with</code> block, the file is closed and thus the buffer needs to be flushed out and written to disk.</p>
</div>
<span class="comment-copy">Note that <a href="https://docs.python.org/3/library/os.html#os.fsync" rel="nofollow noreferrer">the docs</a> recommend to use <code>os.fsync(fd)</code> after invoking <code>flush()</code> of the file object. <code>flush</code> clears Python's file object buffer, <code>fsync</code> instructs the OS to write its file system buffers corresponding to the filedescriptor to disk.</span>
<span class="comment-copy">Thanks, this makes sense, the first two files were larger, so the third being smaller probably meant it did not cross a flush boundary...</span>
