<div class="post-text" itemprop="text">
<p>I am writing a script to encrypt and decrypt an image in python3 using PIL. Here I am converting the image into a numpy array and then multiplying every element of the array with 10. Now I noticed that the default function in PIL fromarray() is converting every element of the array to the mod of 256 if its larger than the 255, so when I am trying to retrieve the original value of the matrix I'm not getting the original one. For example, if the original value is 40 then its 10 times is 400 so the fromarray() is making it as 400 mod 256, which will give 144. Now if I add 256 to 144 I will have 400 and then divided by 10 will give me 40. But if the value is 54 then 10times is 540 and 540 mod 256 is 28. Now to get back the original value I need to add 256 two times which will give me 540. 540 isn't the only number which will give me 28 when I will mod it with 256. So I will never know when to add 256 one time and when two times or more. Is there any way I can make it stop of replacing every element of the matrix with its mod of 256? </p>
<pre><code>from PIL import Image
from numpy import * 
from pylab import * 

#encryption

img1 = (Image.open('image.jpeg').convert('L')) 
img1.show() #displaying the image

img = array(Image.open('image.jpeg').convert('L'))
a,b = img.shape
print(img)
print((a,b))
tup = a,b

for i in range (0, tup[0]):
   for j in range (0, tup[1]):
       img[i][j]= img[i][j]*10 #converting every element of the original array to its 10times

print(img)
imgOut = Image.fromarray(img)
imgOut.show()
imgOut.save('img.jpeg')

#decryption

img2 = (Image.open('img.jpeg'))
img2.show()

img3 = array(Image.open('img.jpeg'))
print(img3)
a1,b1 = img3.shape
print((a1,b1))
tup1 = a1,b1

for i1 in range (0, tup1[0]):
   for j1 in range (0, tup1[1]):
       img3[i1][j1]= ((img3[i1][j1])/10) #reverse of encryption
print(img3)
imgOut1 = Image.fromarray(img3)
imgOut1.show()
</code></pre>
<p>part of the original matrix before multiplying with 10 : 
 [41 42 45 ... 47 41 33]</p>
<p>[41 43 45 ... 44 38 30]</p>
<p>[41 42 46 ... 41 36 30]</p>
<p>[43 43 44 ... 56 56 55]</p>
<p>[45 44 45 ... 55 55 54]</p>
<p>[46 46 46 ... 53 54 54]</p>
<p>part of the matrix after multiplying with 10 : 
[[154 164 194 ... 214 154  74]</p>
<p>[154 174 194 ... 184 124  44]</p>
<p>[154 164 204 ... 154 104  44]</p>
<p>[174 174 184 ...  48  48  38]</p>
<p>[194 184 194 ...  38  38  28]</p>
<p>[204 204 204 ...  18  28  28]</p>
<p>part of the expected matrix after dividing by 10 :
 [41 42 45 ... 47 41 33]</p>
<p>[41 43 45 ... 44 38 30]</p>
<p>[41 42 46 ... 41 36 30]</p>
<p>[43 43 44 ... 56 56 55]</p>
<p>[45 44 45 ... 55 55 54]</p>
<p>[46 46 46 ... 53 54 54]</p>
<p>part of th output the script is providing: [[41 41 45 ... 48 40 33]</p>
<p>[41 43 44 ... 44 37 31]</p>
<p>[41 41 48 ... 41 35 30]</p>
<p>[44 42 43 ... 30 30 29]</p>
<p>[44 42 45 ... 29 29 29]</p>
<p>[45 47 44 ... 28 28 28]]</p>
</div>
<div class="post-text" itemprop="text">
<p>There are several problems with what you're trying to do here.</p>
<p>PIL images are either 8 bit per channel or 16 bit per channel (to the best of my knowledge). When you load a JPEG, it's loaded as 8 bits per channel, so the underlying data type is an unsigned 8-bit integer, i.e. range 0..255. Operations that would overflow or underflow this range wrap, which looks like the modulus behavior you're seeing.</p>
<p>You could convert the 8-bit PIL image to a floating point numpy array with <code>np.array(img).astype('float32')</code> and then normalize this to 0..1 by dividing with 255.</p>
<p>At this point you have non-quantized floating point numbers you can freely mangle however you wish.</p>
<p>However, then you still need to save the resulting image, at which point you again have a format problem. I believe TIFFs and some HDR image formats support floating point data, but if you want something that is widely readable, you'd likely go for PNG or JPEG.</p>
<p>For an encryption use case, JPEGs are not a good choice, as they're always inherently lossy, and you will, more likely than not, not get the same data back.</p>
<p>PNGs can be 8 or 16 bits per channel, but still, you'd have the problem of having to compress a basically infinite "dynamic range" of pixels (let's say you'd multiplied everything by a thousand!) into 0..255 or 0..65535.</p>
<p>An obvious way to do this is to find the maximum value in the image (<code>np.max(...)</code>), divide everything by it (so now you're back to 0..1), then multiply with the maximum value of the image data format... so with a simple multiplication "cipher" as you'd described, you'd essentially get the same image back.</p>
<p>Another way would be to clip the infinite range at the allowed values, i.e. everything below zero is zero, everything above it is, say, 65535. That'd be a lossy operation though, and you'd have no way of getting the unclipped values back.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, <a href="http://effbot.org/imagingbook/concepts.htm" rel="nofollow noreferrer">PIL only supports 8-bit per channel images</a> - although <a href="https://pillow.readthedocs.io/en/5.1.x/handbook/image-file-formats.html" rel="nofollow noreferrer">Pillow (the PIL fork) supports many more formats</a> including higher bit-depths. The <a href="https://en.wikipedia.org/wiki/JPEG" rel="nofollow noreferrer">JPEG format</a> is defined as only 8-bit per channel.</p>
<p>Calling <code>Image.open()</code> on a JPEG in PIL will therefore return an 8-bit array, so any operations on individual pixels will be performed as equivalent to <code>uint8_t</code> arithmetic in the backing representation. Since the maximum value in a <code>uint8_t</code> value is 256, all your arithmetic is necessarily modulo 256.</p>
<p>If you want to avoid this, you'll need to convert the representation to a higher bit-depth, such as 16bpp or 32bpp. You can do this with the NumPy code, such as:</p>
<pre><code>img16 = np.array(img, dtype=np.uint16)
# or
img32 = np.array(img, dtype=np.uint32)
</code></pre>
<p>That will give you the extended precision that you desire.</p>
<p><strong>However</strong> - your code example shows that you are trying to encryption and decrypt the image data. In that case, you <strong>do</strong> want to use modulo arithmetic! You just need to do some more research on actual encryption algorithms.</p>
</div>
<div class="post-text" itemprop="text">
<p>As none of the answers have helped me that much and I have solved the problem I would like to give an answer hoping one day it will help someone. Here the keys are (3, 25777) and (16971,25777).
The working code is as follows:</p>
<pre><code>from PIL import Image
import numpy as np 

#encryption
img1 = (Image.open('image.jpeg').convert('L')) 
img1.show()

img = array((Image.open('image.jpeg').convert('L'))) 
img16 = np.array(img, dtype=np.uint32)
a,b = img.shape
print('\n\nOriginal image: ')
print(img16)
print((a,b))
tup = a,b

for i in range (0, tup[0]):
    for j in range (0, tup[1]):
        x = img16[i][j] 
        x = (pow(x,3)%25777)
        img16[i][j] = x
print('\n\nEncrypted image: ')
print(img16)
imgOut = Image.fromarray(img16)
imgOut.show()

#decryption

img3_16 = img16
img3_16 = np.array(img, dtype=np.uint32)
print('\n\nEncrypted image: ')
print(img3_16)
a1,b1 = img3_16.shape
print((a1,b1))
tup1 = a1,b1

for i1 in range (0, tup1[0]):
     for j1 in range (0, tup1[1]):
         x1 = img3_16[i1][j1] 
         x1 = (pow(x,16971)%25777)  
         img3_16[i][j] = x1
print('\n\nDecrypted image: ')
print(img3_16)
imgOut1 = Image.fromarray(img3_16)y
imgOut1.show()
</code></pre>
<p>Feel free to point out the faults. Thank you.</p>
</div>
<span class="comment-copy">Share your code plz</span>
<span class="comment-copy">Done, any help will be greatly appreciated.</span>
<span class="comment-copy">Can you share expected and your actual result?</span>
<span class="comment-copy">What do you expect should happen to a value &gt;255 saved to a JPEG file that support only values in the range [0,255]?</span>
<span class="comment-copy">The RSA encoding will change (increase a lot, most likely) the size of your data. You can store it anyway byte by byte, so that the problem that you are having here does not even arise. Since the image will have a different size, do not forget to store the original image size or other metadata needed to restore the image.</span>
<span class="comment-copy">yes, actually my actual project is to encrypt an image using rsa algo. I was just trying this so that I can write the actual project effectively and then i ran into this problem.</span>
<span class="comment-copy">Array of those types cannot be saved into jpeg directly. You can improve your answer by providing the code to store this data into an RGB image and retrieve the data back.</span>
<span class="comment-copy">Have you attempted to save the "encrypted" image into a file, and load it from a file again?</span>
<span class="comment-copy">No but i think .bpm will not support this type of data</span>
<span class="comment-copy">I'd say that's a fairly integral part to also try.</span>
<span class="comment-copy">Yes it works fine</span>
