<div class="post-text" itemprop="text">
<p>I want to connect my ESP32 with mi PC using a MQTT server. Mi scrpts are these:
ESP32:</p>
<pre><code>#include &lt;WiFi.h&gt;
#include &lt;PubSubClient.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// CONSTANTES PARA CONEXION AL BROKER
const char* ssid = "+++++++++";
const char* password = "++++++++++";
const char* mqttServer = "+++++++++";
const int mqttPort = ++++++;
const char* mqttUser = "++++++++";
const char* mqttPassword = "+++++++++";
const char *topic = "++++++++++";

//OBJETOS
WiFiClient espClient;
PubSubClient client(espClient);

//ARRAY PARA RECOGER LOS DATOS
int array_azimuth[96];
int array_zen[96];

//FUNCION DE IDENTIFICACION DE CODIGOS ASCII
int GetIntFromAscii(byte payload){
  switch(payload){
    case 48:
       return 0;
       break;
    case 49:
       return 1;
       break;
    case 50:
       return 2;
       break;
    case 51:
       return 3;
       break;
    case 52:
       return 4;
       break;
    case 53:
       return 5;
       break;
    case 54:
       return 6;
       break;
    case 55:
       return 7;
       break;
    case 56:
       return 8;
       break;
    case 57:
       return 9;
       break;
    case 63:
       return -1;
       break;

  }
}

void GetParameterFromPayload(byte* payload, int* azimuth, int *zen){
    int cont = 0;
    int cifras[3];
    int i = 0;
    int j = 0;
    // AZIMUTH
    while(GetIntFromAscii(payload[i]) != -1){
    cifras[i] = GetIntFromAscii(payload[i]);
    cont++;
    i++;
    if(cont == 3){
      *azimuth = cifras[0] * 100 + cifras[1] * 10 + cifras[2];
      //Serial.print('\n');
      //Serial.print("Resultado azimuth dentro funcion = ");
      //Serial.print(*azimuth);
    }
    if(cont == 2){
      *azimuth = cifras[0] * 10 + cifras[1];
      //Serial.print('\n');
      //Serial.print("Resultado azimuth dentro funcion = ");
      //Serial.print(*azimuth);
    }
    }

    // Actualizamos contadores
    cont = 0;
    i++;
    // ELEVACION
    while(GetIntFromAscii(payload[i]) != -1){
      cifras[j] = GetIntFromAscii(payload[i]);
      cont++;
      i++;
      j++;
      if(cont == 3){
      *zen = cifras[0] * 100 + cifras[1] * 10 + cifras[2];
      //Serial.print('\n');
      //Serial.print("Resultado elevacion dentro de funcion = ");
      //Serial.print(*zen);
    }
      if(cont == 2){
      *zen = cifras[0] * 10 + cifras[1];
      //Serial.print('\n');
      //Serial.print("Resultado elevacion dentro de funcion = ");
      //Serial.print(*zen);
    }
}
}

// Callback asociada a la recepcion de un paquete 
void callback(char* topic, byte* payload, unsigned int length) {
  static uint8_t counter;
  //Serial.print('\n');
  //Serial.print("Mensaje recibido [");
  //Serial.print(topic);
  //Serial.print("] ");
  int azimuth;
  int zen;
  GetParameterFromPayload(payload,&amp;azimuth,&amp;zen);
  /*Serial.print('\n');
  Serial.print("Resultado azimuth callbabck = ");
  Serial.print(azimuth);
  Serial.print('\n');
  Serial.print("Resultado elevacion callback = ");
  Serial.print(zen);
  Serial.print('\n');*/
  array_azimuth[counter] = azimuth;
  array_zen[counter] = zen;
  counter++;
  //Serial.print('\n');
  //Serial.print(counter);
  if (counter == 96){
    //Serial.print("RESULTADOS DENTRO DE LOS ARRAY");
    for(int i = 0;i &lt; 96;i++){
      //Serial.print('\n');
      //Serial.print("Azimuth");
      //Serial.print(array_azimuth[i]);
      //Serial.print("********");
      //Serial.print(array_zen[i]);
      //Serial.print('\n');
    }
  }
}

// Funcion para reconectar en caso de que se pierda la conexion con el broker
void Reconnect() {
  // En caso de perder la conexion volveriamos a hacer lo mismo que en el setup
  while (client.connected() != true) {
    Serial.print("Conectando...");
    if (client.connect("ESP32", mqttUser, mqttPassword)) {
      Serial.println("Conectado");
      client.publish(topic,"Reconexion");
      client.subscribe(topic);
    } else {
      Serial.print("Fallido");
      Serial.print(client.state());
      Serial.println("Reintentamos en 10s");
      delay(10000);
    }
  }
}

 //CONFIG
void setup() {
  // Inicializacion de puerto serial 
  Serial.begin(9600);
  // Iniciacion de conexion wifi
  WiFi.begin(ssid, password);
  // Inicializacion de pin 5 para saber cuando estamos conectados al broker
  pinMode(5,OUTPUT);
  // Conectando...
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.println("Conectando a red WiFi...");
  }

  // Conectado
  Serial.println("Conectado a la red WiFi");
  // Conectamos al servidor
  client.setServer(mqttServer, mqttPort);

  while (!client.connected()) {
    Serial.println("Conectando a Broquer MQTT...");

    if (client.connect("ESP32", mqttUser, mqttPassword )) {

      Serial.println("conectado");
      digitalWrite(5,HIGH);
    } else {

      Serial.print("conexion fallida ");
      Serial.print(client.state());
      delay(2000);

    }
  }


  // Nos subscribimos al tema, especificando la calidad del servicio al maximo
  if( client.subscribe(topic) != true ){
    Serial.print("Error en la subscripcion");
  }

  client.setCallback(callback);


}


 // Bucle de ejecucion continuo 
void loop() {
  digitalWrite(5,HIGH);
  if(client.connected() != true){
    Reconnect();
  }
  if(client.connected() == true){
    digitalWrite(5,LOW);
  }
  client.loop();
  delay(1000);

}



Running on PC:
import time
import paho.mqtt.client as mqtt
import paho.mqtt.publish as mqttsend
from pylab import *
from sunposition import sunpos
from datetime import datetime

# DEFINICION DE CONSTANTES PARA EL SERVIDOR
mqttServer = "++++++++++"
mqttPort = +++++
mqttUser = "+++++++"
mqttPassword = "++++++++++"
topic_az = "++++++++"
topic_zen = "++++++++"

# DEFINICION DE CONSTANTES PARA EL CALCULO DE LA POSICION DEL SOL
lat = 43.52315
lon = -5.62839
# STRING DE COMPROBACION DE LLEGADA MENSAJE
mystring = 'send'    
b = bytes(mystring, 'utf-8')

# CALLBACK PARA CONEXION CON EL BROKER
def connect( client, userdata, flags, rc):
    print ("Conectado")
    # Subscripcion al topic
    client.subscribe(topic_az)

# CALLBACK PARA RECEPCION DE MENSAJE
def recepcion( client, userdata, msg):
    print(msg.payload)
    if msg.payload == b:
     print("if correcto")
     MYhours = 0
     MYminutes = 0
     i = 0
     # Obtengo la fecha
     today = datetime.utcnow()
     while i &lt; 96:
        print("dentro while")
        i = i + 1
        MYminutes = MYminutes + 15
        if MYminutes == 60:
          MYminutes = 0
          MYhours = MYhours + 1
        today = today.replace(hour = MYhours)
        today = today.replace(minute = MYminutes)
        print(today)
        az,zen = sunpos(today,lat,lon,0)[:2]
        az_round = round(az,0)
        zen_round = round(zen,0)
        az_round = int(az);
        zen_round = int(zen);
        #client.publish(topic_az,str(az_round)+'?'+str(zen_round)+'?'+str(today.hour)+':'+str(today.minute))
        #client.publish(topic_az,str(az_round)+'?'+str(zen_round)+'?')
        client.publish(topic_az,str(9)+'?'+str(8)+'9');
        #client.publish(topic_zen,str(az_round))
        print("Mensaje enviado")
        time.sleep(1)
        print(i)
     print('fin while')



# Creacion de objeto cliente 
client = mqtt.Client()
client.on_connect = connect
client.on_message = recepcion
client.username_pw_set(mqttUser, mqttPassword)
client.connect(mqttServer,mqttPort,60)      
client.loop_forever()
</code></pre>
<p>The ESP32 code works when I send messages using a MQTT client running on my cellphone but I cant uderstand why it doesn't work when I try to send the data from my Python script. The error the ESP32 shows is this:</p>
<p>Guru Meditation Error: Core  1 panic'ed (Double exception)</p>
<p>If anybody can help I would really appreciate it. 
THANK YOU VERY MUCH!!!!!!!!!!</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I can see you are publishing more than one message from your script. One of possible reasons of what's going on here is that esp8266 might be unable to process them all â€“ either it is running out of memory or it's a MCU speed issue. I suggest you to try to publish only one message from your code. If it works, try sending slower by adding delays between publishing.</p>
<p>In general if you can't control rate of publishing by random publishers, you might want to set a script/daemon that will listen to all topics in question and republish it under a new topic name, paying attention to proper throttling. ESP will listen to a new topic only, thus solving the issue.</p>
</div>
<span class="comment-copy">guru meditation, that reminds me of the glorious amiga times....</span>
