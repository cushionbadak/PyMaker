<div class="post-text" itemprop="text">
<p>I've discovered a strange behaviour of python <code>exec()</code> function. Here is the code:</p>
<pre class="lang-py prettyprint-override"><code>variables = {
    ('foo', 6),
    ('bar', 42)
}

def func():
    for varData in variables:
        varName, varValue = varData
        localVarToEvaluate = varName + ' = varValue'
        try:
            #exec(localVarToEvaluate, globals(), locals())
            exec(localVarToEvaluate)
        except Exception as err:
            print(str(err))

        if varName not in locals():
            print("Variable names '", varName, "can't be found in local scope!")

    if 'foo' in locals():
        print("'foo' OK:", foo)  # exception here
    else:
        print("'foo' not available!")

    if 'bar' in locals():
        print("'bar' OK:", bar)
    else:
        print("'bar' not available!")

func()
</code></pre>
<p>I would expect variables <code>foo</code> and <code>bar</code> to be created and printed at the end by <code>exec()</code> call, which is the case with Python 2.7. Everything above (tested on 3.3, 3.4, 3.6, and 3.7) throws exception, that <code>foo</code> is not defined:</p>
<pre><code>Exception has occurred: NameError
    name 'foo' is not defined
</code></pre>
<p>Strange thing here is that <code>foo</code> and <code>bar</code> is seen by running <code>locals()</code>, <code>globals()</code> or <code>dir()</code> (also confirmed by <code>if</code> statements), however, it is not seen by the code/interpreter. 
Even stranger, debugging this script and resolving any variable is successfull (I've set a breakpoint on <code># exception here</code> and type <code>foo</code> in Debug window using VS Code. <code>foo</code> is correctly resolved with a value of '6'.</p>
<p>If the same code (stuff inside function <code>func()</code>) is not wrapped in function, this works as expected, <code>foo</code> and <code>bar</code> are printed out.</p>
<p>Any idea what is happening here?</p>
<hr/>
<p><strong>UPDATE:</strong> I've further simplify this problem:</p>
<pre class="lang-py prettyprint-override"><code># take 1, create local variable 'foo' with value 6. Not in function.
varName = 'foo'
varValue = 42
localVarToEvaluate = varName + ' = varValue'

try:
    exec(localVarToEvaluate)
except Exception as err:
    print(str(err))

if 'foo' in locals():
    # print(locals()['foo']) # (1)
    # print(foo)  # (2)
    print("'foo' OK:", foo)  # (3)


# take 2, create local variable 'bar' with value 42
def func2():
    varName = 'bar'
    varValue = 42
    localVarToEvaluate = varName + ' = varValue'

    try:
        exec(localVarToEvaluate)
    except Exception as err:
        print(str(err))

    if 'bar' in locals():
        # print(locals()['bar']) # (1)
        # print(bar)  # (2)
        #print("'bar' OK:", bar)  # (3)
        pass # uncomment any line above

func2()
</code></pre>
<p>When this code executes, first:</p>
<pre><code>'foo' OK: 6
</code></pre>
<p>is printed, than this exception is raised:</p>
<pre class="lang-py prettyprint-override"><code>Exception has occurred: NameError
name 'bar' is not defined
  ...
</code></pre>
<p>Note that both codes are identical, except that 'bar' variable is created inside function <code>func2()</code>.</p>
<p>What I am interested in are not workarounds but explanation, why is this so and why points (1) works, while (2) and (3) does not. Note that <code>bar</code> variable is seen in <code>locals()</code>, while it is not accessible by directly calling it - but only if it is created inside function!</p>
</div>
<div class="post-text" itemprop="text">
<p>Lots of unclear issues about this question solved with OP. See answer edits. It boils down to (importing) hooking locals (variables, defs, classes) such that they are available for use inside a definition.</p>
<p>See answer below with inline comments what is what and why.</p>
<pre><code># take 1, create local variable 'foo' with value 6. Not in function.

# &gt;&gt;&gt; code is executed in local-scope &lt;&lt;&lt;

varName = 'foo'
varValue = 42
localVarToEvaluate = varName + ' = varValue'

try:
    exec(localVarToEvaluate)    # (0) dict item becomes {varName : varValue}
    print (localVarToEvaluate)  # (1)  prints &gt; foo = varValue &lt; dict item
except Exception as err:
    print(str(err))

if 'foo' in locals():
    print(locals()['foo'])      # (2)  prints &gt; 42             &lt;             value
    print(foo)                  # (3)  prints &gt; 42             &lt;             value
    print("'foo' OK:", foo)     # (4)  prints &gt; 'foo' OK: 42   &lt; stringtext, value


# take 2, create local variable 'bar' with value 42

def func2(self):

    # &gt;&gt;&gt; code executed inside function and not local-scope &lt;&lt;&lt;

    varName = 'bar'
    varValue = 42
    localVar2Evaluate = varName + ' = varValue'

    try:
        exec(localVar2Evaluate)    # (5) dict item becomes {varName : varValue}
        print (localVar2Evaluate)  # (6) prints &gt; bar = varValue &lt; dict item
    except Exception as err:
        print(str(err))

    print ('local-scope :', '\n', locals())  # (7) {'bar': 42, 'localVar2Evaluate': 'bar = varValue', 'varValue': 42, 'varName': 'bar'}

    if 'bar' in locals():
        print(locals()['bar'])     # (1)
        print(bar)                 # (2)  &lt; --- python is not looking here in the locals() but inside the def for variable `bar` which is not made unless you give it access (hook or reference) via e.g. self.
        print("'bar' OK:", bar)    # (3)
       # pass # uncomment any line above

x = 'a scotch... lets drink.. mystery solved!'
bar = "the local 'bar' variable is now available inside def func2()..  It is: %s" % x
func2(bar)
</code></pre>
<p>As you can see I (import) create a hook to a local variable with varName 'bar' to be used inside the definition using <code>self</code>. It can be any name t.b.h. See pydocs on <code>self</code>, etc.</p>
<p>The result: </p>
<pre><code>bar = varValue
local-scope : 
 {'localVar2Evaluate': 'bar = varValue', 'varValue': 42, 'bar': 42, 'self': "the local 'bar' variable is now available inside def func2()..  It is: a scotch... lets drink.. mystery solved!", 'varName': 'bar'}
42
the local 'bar' variable is now available inside def func2()..  It is: a scotch... lets drink.. mystery solved!
'bar' OK: the local 'bar' variable is now available inside def func2()..  It is: a scotch... lets drink.. mystery solved!
</code></pre>
<p>If <code>print('\n\n', locals())</code> below func() you get the following printresult:</p>
<ol>
<li>'bar': "the local 'bar' variable is now available inside def
func2()..  It is: a scotch... lets drink.. mistery solved!"</li>
<li>'localVarToEvaluate': 'foo = varValue'</li>
<li>'varValue': 42</li>
<li>'foo': 42</li>
<li>'varName': 'foo'</li>
<li>'x': 'a scotch... lets drink.. mistery solved!'</li>
<li>'func2': "&lt;"function func2 at 0x000002B070027F28"&gt;"  # without " outside "&gt;".</li>
</ol>
<p>At bullet 7 you see func2 linked.</p>
<p><strong>UPDATE 4:</strong></p>
<p>Switching between python 2.7.16 and 3.5.2 revealed no change for the locals() dict and ONE change in the globals() dict as shown below.</p>
<p>In 2.7: <code>'variables': set([('bar', 42), ('foo', 6)])</code></p>
<p>In 3.5: <code>'variables': {('bar', 42), ('foo', 6)}</code></p>
<p>... this <code>set()</code> looks to me the reason why it no longer works what you addressed in 3.5.</p>
<p>I did test it with adapting your script:</p>
<pre><code>import sys

print (sys.version)

variables = {('foo', 6), ('bar', 42)}

def func():
    for varData in variables:
        varName, varValue = varData
        localVarToEvaluate = varName + ' = varValue'
        try:
            exec(localVarToEvaluate)
            print ('t2\n', locals())
        except Exception as err:
            print(str(err))

        if varName not in globals():
            print("Variable names '", varName, "can't be found in global scope!")

    if 'foo' in globals():
        print("'foo' OK:", foo)  # exception here
    else:
        print("'foo' not available!")

    if 'bar' in globals():
        print("'bar' OK:", bar)
    else:
        print("'bar' not available!")

print ('t1\n', globals())

func()
</code></pre>
<p>Then ... it could still be exec. So I disabled running <code>func()</code> and the difference in <code>globals()</code> remained. SO I think its a difference in <code>globals()</code> function, rather <code>exec</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://bugs.python.org/issue36426" rel="nofollow noreferrer">I've reported a bug on a Python Issue Tracker</a>, and the <em>official</em> answer is: </p>
<blockquote>
<p>This is currently by design, which means 3.8 is likely the only viable place it can change. It's also not Windows specific so I removed that component (people may remove themselves from nosy).<br/>
  ...<br/>
  Currently it's basically a read-only proxy, as locals are optimized within functions which is why you can't see updates via the duct.</p>
</blockquote>
<p>Bottom line, <code>exec()</code> used in this way is useless inside functions. </p>
</div>
<span class="comment-copy">I am not sure what you mean. Of course <code>foo</code> does not exist jet, this is the whole point of doing <code>exec()</code>. The interesting part of this code block <code>lang-py if 'foo' in locals():     print("'foo' OK:", foo)  # exception here </code>  is that <code>foo</code> variable is created and can be seen in <code>locals()</code>, but when I try to print it out, interpreter knows nothing about it. What do you mean by: <i>... because 'foo' is in your script just a text variable and not a list or tuple container.</i>?</span>
<span class="comment-copy">see update and inline comment.</span>
<span class="comment-copy">I've updated the issue description. Note that I'am not interested in workarounds, but in explanation. Thank you!</span>
<span class="comment-copy">Thank you for your effort, but I still don't see how this has anything to do with my question. Why is <code>exec()</code> call working outside func2, and why I can see <code>bar</code> variable in locals(): <code>'bar' (1908669175152):42</code> while python still can't see it?</span>
<span class="comment-copy">I've added a bunch of lines with in a particular execution order. This way you can see that you are still confusing things. In particular, you're mixing up stringtext with variable names in the locals scope. Check the arrow where it goes wrong with your assumption of what you think you are seeing. For more in-depth info check python docs for :variables, objects, pointers, id() and built-in functions. The <code>getattr</code> and <code>setattr</code> are the right tools to create variables  on-the-fly as the first part of your question pointed towards.</span>
