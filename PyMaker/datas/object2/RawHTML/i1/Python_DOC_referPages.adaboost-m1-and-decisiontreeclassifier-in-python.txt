<div class="post-text" itemprop="text">
<p>I'm trying to implement the following pseudocode in python with sklearn DecisionTreeClassifier with depth = 1.</p>
<p><a href="https://i.stack.imgur.com/CTpi9.png" rel="nofollow noreferrer">Pseudocode for AdaBoost</a></p>
<p>However, I'm having trouble with the output (3).
I have stored the fitted classifiers in a list along with the corresponding alpha. I am using the decision trees from sklearn, and the classifier is on this format:</p>
<pre><code>DecisionTreeClassifier(class_weight=None, criterion='gini', max_depth=1,
            max_features=None, max_leaf_nodes=None,
            min_impurity_decrease=0.0, min_impurity_split=None,
            min_samples_leaf=1, min_samples_split=2,
            min_weight_fraction_leaf=0.0, presort=False, random_state=None,
            splitter='best')
</code></pre>
<p>I'm getting an error in python: </p>
<pre><code>unsupported operand type(s) for *: 'DecisionTreeClassifier' and 'int'
</code></pre>
<p>From my code: ( Classifiers is a list with elements from the iterations 0...M on the format ( Gm(x), errorm, alpham )</p>
<pre><code>   for c in classifiers:
       res += c[2]*c[0]
   res = np.sign(res)
</code></pre>
<p>How can I multiply an int with the corresponding classifiers, and then sum them up to get the final classifier G(x)?
Any help is much appreciated.</p>
<p><strong>EDIT:</strong></p>
<p>With the line</p>
<pre><code>new_classifier = lambda x: sum([c[2] * c[0](x) for c in classifiers])
</code></pre>
<p>suggested by Иван Судос, I get an object on the form:</p>
<pre><code>&lt;function adaBoost.&lt;locals&gt;.&lt;lambda&gt; at 0x1233f80d0&gt;
</code></pre>
<p>How can the signum function be called on this object function(?)?
Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You construct the new classifier incorrectly.
What you need as an output is a <strong>function</strong>, not a <strong>scalar</strong> value. And you are trying to multiply function-object by int. </p>
<p>To do that you can either explicitly define function within this iteration score like:</p>
<pre><code>def new_classifier(x):
   result = 0
   for c in classifiers:
       result += c[2] * c[0](x)
   return result
</code></pre>
<p>OR you can define lambda function:</p>
<pre><code>new_classifier = lambda x: sum([c[2] * c[0](x) for c in classifiers])
</code></pre>
</div>
<span class="comment-copy">You are misunderstanding the step #3; the idea is not of course to multiply an integer with the classifier itself, it is to multiply the integer with the <i>prediction</i> of the classifier</span>
<span class="comment-copy">Great, thanks! I got the last line to work, but do you have any idea of how I could do the signum function on the new_classifier? And how does it make sense to do a signum function of the sum of the classifiers for AdaBoost?</span>
<span class="comment-copy">I updated the question with your suggestion. Do you have any idea how I can go about this?</span>
