<div class="post-text" itemprop="text">
<p>So I have a pandas dataframe with what amounts to an array of dictionaries inside it and I'm struggling with how to turn these into columns that in the original dictionary.</p>
<pre><code>df3 = pd.DataFrame({'SomeCol':
                        ["[{'Source': 'A', 'Value': '4.7'}]",
                         "[{'Source': 'A', 'Value': '8.2'},"
                         "{'Source': 'B', 'Value': '100%'}]",
                         "[{'Source': 'A', 'Value': '8.1'}, "
                         "{'Source': 'C', 'Value': '870'},"
                         "{'Source': 'B', 'Value': '98%'}]",
                         "[{}]"
                         ],
                    'Other Stuff': ['One'
                        , 'Two', 'Three', 'Four'
                                    ]
                    })
</code></pre>
<p>I would like to have the following result</p>
<pre><code>    A      B      C
0   4.7     na    na
1   8.2    100%   na
2   8.1     98%   870
</code></pre>
<p>I have tried</p>
<pre><code>data.map(eval).apply(pd.Series)
</code></pre>
<p>and also numerous variations on the theme</p>
<pre><code>def f2(x):
    df_r = pd.DataFrame()
    for i in x:
        df_r = pd.DataFrame.from_dict(x, orient='columns')
    return df_r

dfa = pd.concat([df3, df3['SomeCol'].map(eval).apply(f2)])
</code></pre>
<p>I seem to be missing something important.  The closest I've come is </p>
<p>The result of the first pass of calling the f2 function gets close </p>
<pre><code>    Source    Value
0    A        4.7

0    A        8.2
1    B       100%

0    A        8.1
1    C        870
2    B        98%
</code></pre>
<p>But when I concat them together I get a mess.  Just some help on where to go from here would be helpful.  I've spent the last two days struggling with a simple way as well as a brute force and neigher seems to cut it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create dictionary with <code>ast.literal_eval</code> for convert strings to dicts:</p>
<pre><code>import ast

out = [{x.get('Source'):x.get('Value') for x in ast.literal_eval(v)} 
                for k, v in df3.pop('SomeCol').items()]
print (out)
[{'A': '4.7'}, {'A': '8.2', 'B': '100%'}, {'A': '8.1', 'C': '870', 'B': '98%'}, {None: None}]
</code></pre>
<p>Then pass to <code>DataFrame</code> constructor and remove <code>NaN</code>s columns by <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html" rel="nofollow noreferrer"><code>DataFrame.dropna</code></a>:</p>
<pre><code>df = pd.DataFrame(out, index=df3.index).dropna(how='all', axis=1)
print (df)
     A     B    C
0  4.7   NaN  NaN
1  8.2  100%  NaN
2  8.1   98%  870
3  NaN   NaN  NaN
</code></pre>
<p>Last <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.join.html" rel="nofollow noreferrer"><code>DataFrame.join</code></a> to original:</p>
<pre><code>df = df3.join(df)
print (df)
  Other Stuff    A     B    C
0         One  4.7   NaN  NaN
1         Two  8.2  100%  NaN
2       Three  8.1   98%  870
3        Four  NaN   NaN  NaN
</code></pre>
</div>
<span class="comment-copy">Solution was simplify, please check it.</span>
<span class="comment-copy">Brilliant!  Works great.  What's with the .pop.items()?  I don't understand if this is personal preference or if there is some relevance to choosing pop versus just iterating the items in the column?</span>
