<div class="post-text" itemprop="text">
<h3>Problem</h3>
<p>I am trying to convert a list of lists, returned by a python function called inside a C++ code. Though the <strong>pybind11</strong> library allows type conversion from python data types to C++ data types, my attempt to convert a list of lists returned by python to a <code>std::list</code> of <code>std::list</code> of strings of C++, fails every time.</p>
<h3>Code</h3>
<p>Here is the python function (The function returns a list of list containing string values):</p>
<pre><code>def return_sheet(self):

     """Returns the sheet in a list of lists

     """

     dataTable = []

     for r in range(self._isheet.nrows):

         datalist = []

         for c in range(self._isheet.ncols):

             datalist.append(self._isheet.cell_value(r,c))

         dataTable.append(datalist)

 return dataTable
</code></pre>
<p>And Here I am calling it in C++ using <strong>pybind11</strong>:</p>
<pre><code>py::list obj = _tool.attr("return_sheet")();

data = py::cast&lt;SheetData&gt;(obj); // This is where the problem lies, This cast crashes the program
</code></pre>
<p>Where <code>SheetData</code> is a <code>typedef</code> for:</p>
<pre><code>typedef std::list&lt;std::list&lt;std::string&gt; &gt; SheetData;
</code></pre>
<p>While debugging, I found out that the program is actually crashing at this line: </p>
<pre><code>py::object dataTable = _tool.attr("return_sheet")(); // Where _tool.attr("return_sheet")() gives an py::object which is a list of list of str
</code></pre>
<p>Does someone know, how can I successfully convert a list of lists of python to <code>std::list</code> of <code>std::list</code> of C++?</p>
<h3>EDIT</h3>
<p>Here is the python program file I am embedding in c++ [xlanalyser.py] : <a href="https://pastebin.com/gARnkMTv" rel="nofollow noreferrer">https://pastebin.com/gARnkMTv</a> </p>
<p>And Here is the c++ code [main.cpp] :  <a href="https://pastebin.com/wDDUB1s4" rel="nofollow noreferrer">https://pastebin.com/wDDUB1s4</a></p>
<p>Note: All other functions in xlanalyser.py do not cause a crash on embedding in c++ [ only the return_sheet() function causes the crash ]</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the Python/C API as a workaround (Check function <code>CastToSheetData</code>). I include the full example below: </p>
<p>program.py</p>
<pre><code>def return_matrix():

    dataTable = []
    for r in range(0,2):
        datalist = []

        for c in range(0,2):
            datalist.append(str(r+c))

        dataTable.append(datalist)
    return dataTable
</code></pre>
<p>main.cpp</p>
<pre><code>#include &lt;pybind11/embed.h&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;

typedef std::list&lt;std::list&lt;std::string&gt; &gt; SheetData;

namespace py = pybind11;

SheetData CastToSheetData(PyObject *obj)
{
    SheetData data;
    PyObject *iter = PyObject_GetIter(obj);

    if (!iter)
        return data;
    while (true) {
        std::list&lt;std::string&gt; aux_list;
        PyObject *next = PyIter_Next(iter);
        if (!next) {
            // nothing left in the iterator
            break;
        }
        PyObject *iter2 = PyObject_GetIter(next);
        if (!iter2)
            continue;
        while(true) {
            PyObject *next2 = PyIter_Next(iter2);
            if (!next2) {
                // nothing left in the iterator
                break;
            }
            PyObject* pyStrObj = PyUnicode_AsUTF8String(next2); 
            char* zStr = PyBytes_AsString(pyStrObj); 
            std::string foo(strdup(zStr));
            aux_list.push_back(foo);
            Py_DECREF(pyStrObj);
        }
        data.push_back(aux_list);
    }

    return data;
}


int main()
{
    py::scoped_interpreter guard{};
    py::module calc = py::module::import("program");
    py::object result = calc.attr("return_matrix")();

    SheetData data = CastToSheetData(result.ptr());

    for (auto l : data)
    {
        std::cout &lt;&lt; "[ ";
        for(auto s : l)
            std::cout &lt;&lt; s &lt;&lt;  " ";
        std::cout &lt;&lt; "]" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code>[ 0 1 ]
[ 1 2 ]
</code></pre>
<p>Probably, the best way to go here is to make a custom <a href="https://pybind11.readthedocs.io/en/master/advanced/cast/custom.html" rel="nofollow noreferrer">type_caster</a> using code like the one in the <code>CastToSheetData</code> function inside the <code>load</code> method</p>
</div>
<span class="comment-copy">Thanks for helping me out but the solution provided doesn't works.       Your code crashes at the line of importing module   [ py::module calc = py::module::import("program"); ]  in main function.               Whereas in my code the program crahes at the line of getting data from python function 'return sheet'   [    py::object dataTable = _tool.attr("return_sheet")();   ]  . Can you please help figure it out?</span>
<span class="comment-copy">It didn't crash for me. It looks like your problem is not related with the datatype conversion but with embedding your python function into C++. Could you post your complete code to check how you import the module <code>_tool</code>?</span>
<span class="comment-copy">And did you add my python code into a <b>program.py</b> file in the same folder as the <b>main.cpp</b>?</span>
<span class="comment-copy">Of course I did add your python program to the correct location.ðŸ˜…. I m using Qt 5.12.1 with MSVC 32 bit for the project. I am going to post my c++ and python code to the end of my question description. Thanks for taking out your time helping me.</span>
<span class="comment-copy">Your code works fine on my computer. I printed an excel without problem. I am using 64 bits (I compiled pybind11 for 64 bits). More detailed, I use VSCode with CMake 2.8, MSVC 19.12.25835.0 64 bits, my python version is 3.7 and pybind11 v2.3dev0. And don't worry, I enjoy doing this haha</span>
