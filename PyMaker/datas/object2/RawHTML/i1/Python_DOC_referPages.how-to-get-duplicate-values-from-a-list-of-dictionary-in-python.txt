<div class="post-text" itemprop="text">
<p>I am new to python and I am trying to separate duplicate keys from my list of dictionary. Find the list below</p>
<pre><code>dataList = [{'Key': 'US', 'Val': 'NewYork'},
 {'Key': 'Aus', 'Val': 'Sydney'}, 
 {'Key': 'US', 'Val': 'Washington'}, 
 {'Key': 'Ind', 'Val': 'Delhi'}, 
 {'Key': 'Fra', 'Val': 'Paris'},
 {'Key': 'Ind', 'Val': 'Chennai'}]
</code></pre>
<p>I would like to fetch duplicate keys and its values</p>
<p>Expected Result</p>
<pre><code>duplicates = [{'Key': 'Ind', 'Val': 'Delhi'},{'Key': 'Ind', 'Val': 'Chennai'},{'Key': 'US', 'Val': 'NewYork'},{'Key': 'US', 'Val': 'Washington'}]
nonduplicate = [{'Key': 'Aus', 'Val': 'Sydney'},{'Key': 'Fra', 'Val': 'Paris'}]
</code></pre>
<p>Find below my sample code, it does not give me desired output</p>
<pre><code>uniqueValues = []
duplicateValues = []
# Creating a list of all duplicate values in dictionary
for attribute in dataList:
    for k, v in attribute.items():
        if v not in uniqueValues :
            uniqueValues.append(v)
        else:    
            duplicateValues.append(v)
</code></pre>
<p>Any help would be appreciated</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Your dictionaries are not duplicates as a whole, you are defining them as unique by the value of <code>Key</code> only, so <code>v not in uniqueValues</code> won't find <code>{'Key': 'US', 'Val': 'NewYork'}</code> when you test with <code>{'Key': 'US', 'Val': 'Washington'}</code>. </p>
<p>Note that even if <code>v not in uniqueValues</code> was the correct test, you'd have added <code>{'Key': 'US', 'Val': 'NewYork'}</code> to <code>uniqueValues</code> already, and would have to remove it again and move it to <code>duplicateValues</code> the moment you find proof that it was a duplicate.</p>
<p>Instead, to divide the dictionaries into two buckets, you need to count the <code>'Key'</code> values <em>first</em> so you know if there is just one of a given value, or more:</p>
<pre><code>from collections import Counter

key_counts = Counter(d['Key'] for d in dataList)

uniqueValues = []
duplicateValues = []
for d in dataList:
    if key_counts[d['Key']] == 1:
        uniqueValues.append(d)
    else:
        duplicateValues.append(d)
</code></pre>
<p>Don't be tempted to skip the counting loop, while you <em>can</em> count <code>d['Key']</code> values in a <code>for d in dataList:</code> loop too, you'd repeat that count for duplicate keys several times, <em>and</em> you would have to loop over all of <code>dataList</code> for every item in <code>dataList</code>, giving your code a <em>quadratic</em> amount of work to do, or O(N^2) in <a href="https://en.wikipedia.org/wiki/Big_O_notation" rel="nofollow noreferrer">Big O notation</a>. By counting <em>first</em>, the amount of work only grows linearly, or O(N).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; dataList = [{'Key': 'US', 'Val': 'NewYork'},
...  {'Key': 'Aus', 'Val': 'Sydney'},
...  {'Key': 'US', 'Val': 'Washington'},
...  {'Key': 'Ind', 'Val': 'Delhi'},
...  {'Key': 'Fra', 'Val': 'Paris'},
...  {'Key': 'Ind', 'Val': 'Chennai'}]
&gt;&gt;&gt; key_counts = Counter(d['Key'] for d in dataList)
&gt;&gt;&gt; key_counts
Counter({'US': 2, 'Ind': 2, 'Aus': 1, 'Fra': 1})
&gt;&gt;&gt; uniqueValues = []
&gt;&gt;&gt; duplicateValues = []
&gt;&gt;&gt; for d in dataList:
...     if key_counts[d['Key']] == 1:
...         uniqueValues.append(d)
...     else:
...         duplicateValues.append(d)
...
&gt;&gt;&gt; pprint(uniqueValues)
[{'Key': 'Aus', 'Val': 'Sydney'}, {'Key': 'Fra', 'Val': 'Paris'}]
&gt;&gt;&gt; pprint(duplicateValues)
[{'Key': 'US', 'Val': 'NewYork'},
 {'Key': 'US', 'Val': 'Washington'},
 {'Key': 'Ind', 'Val': 'Delhi'},
 {'Key': 'Ind', 'Val': 'Chennai'}]
</code></pre>
</div>
<span class="comment-copy">That's because the <i>whole</i> dictionaries are not duplicates. Only the <code>Key</code> values are.</span>
