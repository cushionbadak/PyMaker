<div class="post-text" itemprop="text">
<p>I was wondering if there is a built-in functionality or at least a 'smart' way of ordering x- and y-labels by their values in combination with seaborn heatmaps.</p>
<p>Let's say the unordered heatmap looks like this:</p>
<p><a href="https://i.stack.imgur.com/MGBq1.png" rel="nofollow noreferrer"><img alt="unordered heatmap" src="https://i.stack.imgur.com/MGBq1.png"/></a></p>
<p>However, the goal is to reorder the labels having the color shifts 'smoothened'. It should look more like this afterwards:</p>
<p><a href="https://i.stack.imgur.com/azJai.png" rel="nofollow noreferrer"><img alt="ordered heatmap" src="https://i.stack.imgur.com/azJai.png"/></a></p>
<p>Thanks for your advice!</p>
<p>Best regards</p>
</div>
<div class="post-text" itemprop="text">
<p>One needs to somehow quantify "smoothened colorshifts". For that purpose, a cost function may be defined. In the simplest case this could be the sum of the differences between neighboring pixels. If that sum is small, neighboring pixels have a small difference in color.</p>
<p>One may then swap around columns and rows in the matrix at random and check if a smaller cost is produced. Doing this iteratively, would at some point result in a smoothened heatmap. However it will of course depend on the degree of randomness in the initial heatmap. For fully random pixels, not too much of an optimization can be expected.</p>
<p>The following class implements such optimization. It would take <code>nrand</code> different starting permutations and for each, do the swapping <code>niter</code> times. The best result of this is stored and may be retrieved via <code>.get_opt</code>.</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np

class ReOrder():
    def __init__(self, array, nrand=2, niter=800):
        self.a = array
        self.indi = np.arange(self.a.shape[0])
        self.indj = np.arange(self.a.shape[1])
        self.i = np.arange(self.a.shape[0])
        self.j = np.arange(self.a.shape[1])
        self.nrand = nrand
        self.niter = niter

    def apply(self, a, i, j):
        return a[:,j][i,:]

    def get_opt(self):
        return self.apply(self.a, self.i, self.j)

    def get_labels(self, x=None, y=None):
        if x is None:
            x = self.indj
        if y is None:
            y = self.indi
        return np.array(x)[self.j], np.array(y)[self.i]

    def cost(self, a=None):
        if a is None:
            a = self.get_opt()
        m = a[1:-1, 1:-1]
        b = 0.5 * ((m - a[0:-2, 0:-2])**2 + \
                   (m - a[2:  , 2:  ])**2 + \
                   (m - a[0:-2, 2:  ])**2 + \
                   (m - a[2:  , 0:-2])**2) + \
            (m - a[0:-2, 1:-1])**2 + \
            (m - a[1:-1, 0:-2])**2 + \
            (m - a[2:  , 1:-1])**2 + \
            (m - a[1:-1, 2:  ])**2 
        return b.sum()

    def randomize(self):
        newj = np.random.permutation(self.a.shape[1])
        newi = np.random.permutation(self.a.shape[0])
        return newi, newj

    def compare(self, i1, j1, i2, j2, a=None):
        if a is None:
            a = self.a
        if self.cost(self.apply(a,i1,j1)) &lt; self.cost(self.apply(a,i2,j2)):
            return i1, j1
        else:
            return i2, j2

    def rowswap(self, i, j):
        rows = np.random.choice(self.indi, replace=False, size=2)
        ir = np.copy(i)
        ir[rows] = ir[rows[::-1]]
        return ir, j

    def colswap(self, i, j):
        cols = np.random.choice(self.indj, replace=False, size=2)
        jr = np.copy(j)
        jr[cols] = jr[cols[::-1]]
        return i, jr

    def swap(self, i, j):
        ic, jc = self.rowswap(i,j)
        ir, jr = self.colswap(i,j)
        io, jo = self.compare(ic,jc, ir,jr)
        return self.compare(i,j, io,jo)

    def optimize(self, nrand=None, niter=None):
        nrand = nrand or self.nrand
        niter = niter or self.niter
        i,j = self.i, self.j
        for kk in range(niter):
            i,j = self.swap(i,j)
        self.i, self.j = self.compare(i,j, self.i, self.j)
        print(self.cost())
        for ii in range(nrand):
            i,j = self.randomize()
            for kk in range(niter):
                i,j = self.swap(i,j)
            self.i, self.j = self.compare(i,j, self.i, self.j)
            print(self.cost())
        print("finished")
</code></pre>
<p>So let's take two starting arrays,</p>
<pre><code>def get_sample_ord():
    x,y = np.meshgrid(np.arange(12), np.arange(10))
    z = x+y
    j = np.random.permutation(12)
    i = np.random.permutation(10)
    return z[:,j][i,:] 

def get_sample():
    return np.random.randint(0,120,size=(10,12))
</code></pre>
<p>and run it through the above class.</p>
<pre><code>def reorder_plot(nrand=4, niter=10000):
    fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(nrows=2, ncols=2, 
                                               constrained_layout=True)
    fig.suptitle("nrand={}, niter={}".format(nrand, niter))

    z1 = get_sample()
    r1 = ReOrder(z1)
    r1.optimize(nrand=nrand, niter=niter)
    ax1.imshow(z1)
    ax3.imshow(r1.get_opt())
    xl, yl = r1.get_labels()
    ax1.set(xticks = np.arange(z1.shape[1]),
            yticks = np.arange(z1.shape[0]),
            title=f"Start, cost={r1.cost(z1)}")
    ax3.set(xticks = np.arange(z1.shape[1]), xticklabels=xl, 
            yticks = np.arange(z1.shape[0]), yticklabels=yl, 
            title=f"Optimized, cost={r1.cost()}")

    z2 = get_sample_ord()   
    r2 = ReOrder(z2)
    r2.optimize(nrand=nrand, niter=niter)
    ax2.imshow(z2)
    ax4.imshow(r2.get_opt())
    xl, yl = r2.get_labels()
    ax2.set(xticks = np.arange(z2.shape[1]),
            yticks = np.arange(z2.shape[0]),
            title=f"Start, cost={r2.cost(z2)}")
    ax4.set(xticks = np.arange(z2.shape[1]), xticklabels=xl, 
            yticks = np.arange(z2.shape[0]), yticklabels=yl, 
            title=f"Optimized, cost={r2.cost()}")


reorder_plot(nrand=4, niter=10000)

plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/wHpzb.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/wHpzb.png"/></a></p>
<p>The totally random matrix (left column) is only smoothened very little - still it appears a little more sorted. The cost values are pretty high still. A not so random matrix however is perfectly smoothened and the cost is significantly reduced.</p>
</div>
<div class="post-text" itemprop="text">
<p>That second plot is ordered by the x and y axis labels, not the values. You won't be able to get random data to look like ordered data. You can sort the data by values for one row and one column, but the rest of the data will be fixed. Here is code that plots a heatmap sorted by values for row 0 and column 0. Notice the "cross" in the middle of the plot:</p>
<pre><code>import numpy as np; np.random.seed(0)
import seaborn as sns; sns.set()

uniform_data = np.random.rand(10, 12)
df = pd.DataFrame(uniform_data)
df2 = df.sort_values(by=0).T.sort_values(by=0).T
ax = sns.heatmap(df2)
</code></pre>
<p><a href="https://i.stack.imgur.com/QBBTY.png" rel="nofollow noreferrer"><img alt="Semi-ordered heat map" src="https://i.stack.imgur.com/QBBTY.png"/></a></p>
</div>
<span class="comment-copy">This is great! I hoped for a shorter solution, but it does the trick!</span>
<span class="comment-copy">Yep. It's a bit long and not optimal (because there is no way of knowing if any solution is the optimum or not, i.e. no convergence criterium). Possibly there are better methods one can borrow from clustering techniques.</span>
<span class="comment-copy">I absolutely agree on that. But my question was actually not refering to a 'perfect' ordering but more of a 'better' label ordering to smoothen colorshifts.</span>
