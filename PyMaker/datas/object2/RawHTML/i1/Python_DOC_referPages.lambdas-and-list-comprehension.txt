<div class="post-text" itemprop="text">
<p>I'm trying to understand what's different about the following dictionaries, as they produce different results when passed as arguments into a third-party library's function.</p>
<pre><code>x = list(range(50))
y = list(range(50))

vars = [x, y]

d = [{'func': lambda z: vars[i]} for i in range(len(vars))]
d2 = list({'func': lambda z: vars[i]} for i in range(len(vars)))
d3 = [{'func': lambda z: vars[0]}, {'func': lambda z: vars[1]}]

print(d == d2)  # False
print(d == d3)  # False
print(d2 == d3)  # False
</code></pre>
<p>From my understanding, all three dictionaries should be identical but inspecting the variables reveals different function types for each:</p>
<pre><code>d -&gt; function &lt;listcomp&gt;.&lt;lambda&gt;
d2 -&gt; function &lt;genexpr&gt;.&lt;lambda&gt;
d3 -&gt; function &lt;lambda&gt;
</code></pre>
<p>As far as my use-case, only the d3 implementation works (meaning I can't take a more dynamic approach without doing something horrifying with <code>exec</code>). Can someone help me understand the difference between these three types of lambdas?</p>
<p><strong>Edit</strong></p>
<p>After everyone's help understanding scoping better, I was able to get my code to run by including the variable as a keyword arg in the function:</p>
<pre><code>d = [{'func': lambda x, z=vars[i]: z * x} for i in range(len(vars))]
</code></pre>
<p>As suggested by the FAQ page: <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow noreferrer">https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Distinct lambdas don't compare equal to each other, not even if they do the same thing. Therefore, objects containing those lambdas will also compare unequal.</p>
<pre><code>&gt;&gt;&gt; f1 = lambda z: vars[i]
&gt;&gt;&gt; f2 = lambda z: vars[i]
&gt;&gt;&gt; f1 == f2
False
</code></pre>
<p>As to why the first two versions don't work, it's because when <code>i</code> is captured it's the <em>variable</em> <code>i</code>, not its current value. The lambdas aren't tied to a frozen value of <code>i</code> during the current iteration but rather the variable itself, which changes in successive loop iterations.</p>
<p><strong>See also:</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture">What do (lambda) function closures capture?</a></li>
<li><a href="https://stackoverflow.com/questions/19837486/python-lambda-in-a-loop">Python Lambda in a loop</a></li>
</ul>
</div>
<span class="comment-copy">This is also covered in the official Python FAQ: <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" rel="nofollow noreferrer">docs.python.org/3/faq/â€¦</a></span>
<span class="comment-copy">This is how lexical scoping and closures work. Read the linked duplicte. Finally, you shouldn't expect them to be equal, even if the functions were equivalent, because <code>==</code> works by identity with functions to begin with</span>
<span class="comment-copy">Those aren't function signatures; they are just automatically generated names for the resulting <code>function</code> objects.</span>
<span class="comment-copy">@DanielRoseman Wanted to thank you separately, definitely need to read that whole thing now :)</span>
