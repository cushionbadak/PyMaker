<div class="post-text" itemprop="text">
<p>Why can't I have multiple <code>on_message</code> events?</p>
<pre><code>import discord

client = discord.Client()

@client.event
async def on_ready():
    print('in on_ready')

@client.event
async def on_message(message):
    print("in on_message #1")

@client.event
async def on_message(message):
    print("in on_message #2")

@client.event
async def on_message(message):
    print("in on_message #3")

client.run("TOKEN")
</code></pre>
<p>For example, if I typed anything in discord, it's always only the last <code>on_message</code> that gets triggered. How can I get all three to work? </p>
</div>
<div class="post-text" itemprop="text">
<h2>It's not possible with the native <code>Client</code></h2>
<p>You can only have <em>one</em> <code>on_message</code>, if you have multiple, only the last one will be called for the <code>on_message</code> event. You'll just need to combine your three <code>on_message</code>.</p>
<pre><code>import discord

client = discord.Client()

@client.event
async def on_message(message):
    print("in on_message #1")
    print("in on_message #2")
    print("in on_message #3")

client.run("TOKEN")
</code></pre>
<p>Like any Python variable/function (unless the decorator stores your function, <code>@client.event</code> does it by keeping only the most recent callback), if multiple names are the same, the most recently will be kept, and all others will get overwritten.</p>
<p>This is a simple example I wrote to give you a broad understanding of how events in discord.py work (note: the actual code isn't exactly like this, as it's rewritten and significantly reduced).</p>
<pre><code>class Client:
    def event(self, func):               
        if func.__name__ == "on_message":
            self.on_message_handle = func
            return func

    def receive_message(self, msg):
        func = getattr(self, "on_message_handle", None)
        if func is not None:
            func(msg)
        else:
            self.process_commands(msg)

client = Client()

@client.event
def on_message(msg):
    print("in on_message #1")

@client.event
def on_message(msg):
    print("in on_message #2")

client.receive_message("hello")
# "in on_message #2"
</code></pre>
<p>As you can see <code>client.event</code> only keep one instance of <code>on_message</code>.</p>
<hr/>
<h2>You can with <code>Bot</code> instances</h2>
<p>Alternatively, if you're using the <code>ext.commands</code> extension of discord.py, there is a native way to have multiple <code>on_message</code> callbacks. You do so by using defining them as a <code>listener</code>. You can have at most one <code>on_message</code> event, and infinite amounts of <code>on_message</code> listeners.</p>
<pre><code>from discord.ext import commands

bot = commands.Bot('.')

@bot.event
async def on_message(msg):
    print("in on_message #1")
    await bot.process_commands(msg)  # so `Command` instances will still get called


@bot.listen()
async def on_message(msg):
    print("in on_message #2")


@bot.listen()
async def on_message(msg):
    print("in on_message #3")

bot.run("TOKEN")
</code></pre>
<p>When a message is received, all <code>on_message #1-3</code> will all get printed.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python, functions are just objects.</p>
<pre><code>&gt;&gt;&gt; def foo():
...     print ("hi")
</code></pre>
<p>defines an object called <code>foo</code>, You can see this using a Python shell.</p>
<pre><code>&gt;&gt;&gt; foo
&lt;function foo at 0x...&gt;
&gt;&gt;&gt; foo()
hi
</code></pre>
<p>If you define a new method after, or redefine the variable <code>foo</code>, you lose access to the initial function.</p>
<pre><code>&gt;&gt;&gt; foo = "hi"
&gt;&gt;&gt; foo
hi
&gt;&gt;&gt; foo()
Traceback ...:
    file "&lt;stdin&gt;" ...
TypeError: 'str' object is not callable
</code></pre>
<p>How the <code>@client.event</code> decorator works is it tells your client that new messages should be piped into the messages, and well, if the method gets redefined, it means the old method is lost.</p>
<pre><code>&gt;&gt;&gt; @bot.event
... async def on_message(m):
...     print(1)
...
&gt;&gt;&gt; bot.on_message(None) # @bot.event makes the bot define it's own method
1
&gt;&gt;&gt; @bot.event
... async def on_message(m):
...     print(2)
...
&gt;&gt;&gt; bot.on_message(None) # bot's own method was redefined.
2
</code></pre>
</div>
