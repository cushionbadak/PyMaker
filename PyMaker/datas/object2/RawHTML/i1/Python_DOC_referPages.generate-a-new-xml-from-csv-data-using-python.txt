<div class="post-text" itemprop="text">
<p>I want to generate the below xml. any leads?</p>
<pre><code>CSV data   
id,value,
1,10
2,20

&lt;root&gt;  
    &lt;xs:sample name="id"&gt;
            &lt;xs:final&gt;
                &lt;xs:id&gt;1&lt;/xs:id&gt;
            &lt;/xs:final&gt;
            &lt;xs:new base="xs:string"&gt;
                &lt;xs:maxLength value="10"/&gt;
            &lt;/xs:new&gt;
    &lt;/xs:sample&gt;    
    &lt;xs:sample name="id"&gt;
            &lt;xs:final&gt;
                &lt;xs:id&gt;2&lt;/xs:id&gt;
            &lt;/xs:final&gt;
            &lt;xs:new base="xs:string"&gt;
                &lt;xs:maxLength value="20"/&gt;
            &lt;/xs:new&gt;
    &lt;/xs:sample&gt;    
&lt;/root&gt;
</code></pre>
<p>I have used lxml.etree, but the output xml structure is coming different.</p>
<p>I dont want to hardcode the values as I want to loop with in the csv</p>
<p>sample code, i have used :</p>
<pre><code>import csv
import lxml.etree as ET
headers = ['id','value']
root = ET.Element("root")
xssample = ET.SubElement(root, "xssample")
xsfinal = ET.SubElement(xssample, "xsfinal")
xsnew = ET.SubElement(xssample, "xsnew")
xsid = ET.SubElement(xsfinal, "xsid")
xsmaxlength = ET.SubElement(xsnew, "xsmaxlength")

filename = 'sample.csv'

with open(filename) as f:
    next(f)                             # SKIP HEADER
    csvreader = csv.reader(f)

    for row in csvreader:        
        for x in range(len(headers)): 
            data = ET.SubElement(root, "xssample", {'name':headers[x]})
            for col in range(len(headers)):
                node = ET.SubElement(data, headers[col]).text = str(row[col])

# SAVE XML TO FILE
tree_out = (ET.tostring(root, pretty_print=True, xml_declaration=True, encoding="UTF-8"))

# OUTPUTTING XML CONTENT TO FILE
with open('Output.xml', 'wb') as f:
    f.write(tree_out)
</code></pre>
<p>Output structure is different:</p>
<pre><code> &lt;?xml version='1.0' encoding='UTF-8'?&gt;
    &lt;root&gt;
      &lt;xssample&gt;
        &lt;xsfinal&gt;
          &lt;xsid/&gt;
        &lt;/xsfinal&gt;
        &lt;xsnew&gt;
          &lt;xsmaxlength/&gt;
        &lt;/xsnew&gt;
      &lt;/xssample&gt;
      &lt;xssample name="id"&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;value&gt;10&lt;/value&gt;
      &lt;/xssample&gt;
      &lt;xssample name="value"&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;value&gt;10&lt;/value&gt;
      &lt;/xssample&gt;
      &lt;xssample name="id"&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;value&gt;20&lt;/value&gt;
      &lt;/xssample&gt;
      &lt;xssample name="value"&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;value&gt;20&lt;/value&gt;
      &lt;/xssample&gt;
    &lt;/root&gt;
</code></pre>
<p>I am not able to change the tags correctly. can anyone point the issue here.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can build your XML manually:</p>
<pre><code>import pandas as pd

result = ''
df = pd.read_csv('file.csv')
for index, row in df.iterrows():
   result += '''&lt;xs:sample name="id"&gt;&lt;xs:final&gt;&lt;xs:id&gt;{}&lt;/xs:id&gt;&lt;/xs:final&gt;&lt;xs:new base="xs:string"&gt;&lt;xs:maxLength value="{}"/&gt;&lt;/xs:new&gt;&lt;/xs:sample&gt;'''.format(int(row['id']), int(row['value']))
root = '&lt;root&gt;{}&lt;/root&gt;'.format(result)
</code></pre>
<p>Output:</p>
<pre><code>&lt;root&gt;&lt;xs:sample name="id"&gt;&lt;xs:final&gt;&lt;xs:id&gt;1&lt;/xs:id&gt;&lt;/xs:final&gt;&lt;xs:new base="xs:string"&gt;&lt;xs:maxLength value="10"/&gt;&lt;/xs:new&gt;&lt;/xs:sample&gt;&lt;xs:sample name="id"&gt;&lt;xs:final&gt;&lt;xs:id&gt;2&lt;/xs:id&gt;&lt;/xs:final&gt;&lt;xs:new base="xs:string"&gt;&lt;xs:maxLength value="20"/&gt;&lt;/xs:new&gt;&lt;/xs:sample&gt;&lt;/root&gt;
</code></pre>
</div>
<span class="comment-copy">Show your code attempts</span>
<span class="comment-copy">added the sample code</span>
<span class="comment-copy">So what error/problem you have?</span>
<span class="comment-copy">the tags are coming only for the first set and the values are not getting populated. the values are coming in the second set but the tag were missing. Can you point out the issue in the code.</span>
<span class="comment-copy">You code produces rather a different output than you've described.</span>
<span class="comment-copy">Thank you Alderven. I will try this but is it possible to automatically do it with lxml.etree?</span>
<span class="comment-copy"><code>xs:</code> part will be lost in this case. Is it critical for you to have <code>xs:</code> prefixes in XML?</span>
<span class="comment-copy">Yes Alderven.. I also have that issue</span>
<span class="comment-copy">In this case only manual XML building will help.</span>
