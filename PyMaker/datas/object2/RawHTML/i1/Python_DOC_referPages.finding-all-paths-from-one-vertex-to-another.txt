<div class="post-text" itemprop="text">
<p>trying to find all possible paths from a starting vertex to and end vertex. this is what i have so far.</p>
<pre><code>def all_paths(adj_list, source, destination):
paths = []
for neighbour,_ in adj_list[source]:
    path = [source,neighbour]
    state = ['U'] * len(adj_list)
    state[neighbour] = 'D'
    path = finder(adj_list, neighbour, state, path, destination)
    paths.append(path)
return paths

def finder(adj_list, current, state, path, end):
    for neighbour,_ in adj_list[current]:
        if neighbour == end:
            path.append(neighbour)
            return path
        if state[neighbour] == 'U':
            state[neighbour] = 'D'
            path.append(finder(adj_list, neighbour, state, path, end))
            return path
</code></pre>
<p>The state array is to make sure no vertices are visited twice (U is undiscovered and D is discovered.)
an adj_list is an adjacency list of a graph ,so at index[i] of the list it has a list of all the vertices that are connected to i by an edge (the Nones are the weight of said edge)</p>
<p>The input is</p>
<pre><code>adj_list = [[(1, None), (2, None)], [(0, None), (2, None)], [(1, None), (0, None)]]


print(sorted(all_paths(adj_list, 0, 2)))
</code></pre>
<p>the expected output is </p>
<pre><code>[[0, 1, 2], [0, 2]]
</code></pre>
<p>and my output is</p>
<pre><code>[[0, 1, 2, [...]], [0, 2, 2, [...], [...]]]
</code></pre>
<p>Unsure as how im getting these dots and the repeated 2 in the second path?</p>
</div>
<div class="post-text" itemprop="text">
<p>Very similar logic to your code but cleaned up, an dusing the fact that Python can check if an item is in a list so not using a separate 'U' or 'D' array.</p>
<pre><code>ajs =  [[(1, None), (2, None)], [(0, None), (2, None)], [(1, None), (0, None)]]

def paths(node, finish):
    routes = []

    def step(node, path):
        for nb,_ in ajs[node]:

            if nb == finish:
                routes.append( path + [node, nb] )

            elif nb not in path:
                step(nb, path + [node])

    step(node, [])
    return routes

print paths(0,2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a variant of your code that gets the desired answer. That said, it's a confusing way to solve the problem. It seems to me that the algorithm is being spread across two functions, when it should be solvable with a single recursive function.</p>
<pre><code>def main():
    adj_list = [
        [(1, None), (2, None)],
        [(0, None), (2, None)],
        [(1, None), (0, None)],
    ]
    paths = sorted(all_paths(adj_list, 0, 2))
    print(paths)

def all_paths(adj_list, source, destination):
    paths = []
    for neighbour, _ in adj_list[source]:
        pth = [source, neighbour]
        if neighbour == destination:
            paths.append(pth)
        else:
            node = finder(
                adj_list,
                neighbour,
                ['U'] * len(adj_list),
                pth,
                destination,
            )
            paths.append(pth + [node])
    return paths

def finder(adj_list, current, state, pth, end):
    for neighbour, _ in adj_list[current]:
        if neighbour == end:
            state[neighbour] = 'D'
            return neighbour
        elif state[neighbour] == 'U':
            state[neighbour] = 'D'
            return finder(adj_list, neighbour, state, pth, end)

main()
</code></pre>
<p>For example, here's an alternative implementation:</p>
<pre><code>def main():
    # An adjacency matrix for this example:
    #
    #    0 - 1
    #     \ /
    #      2
    #
    matrix = [
        [(1, None), (2, None)],
        [(0, None), (2, None)],
        [(1, None), (0, None)],
    ]
    # Print all paths from 0 to 2.
    paths = get_paths(matrix, 0, 2)
    for p in paths:
        print(p)

def get_paths(matrix, src, dst, seen = None):
    # Setup:
    # - Initialize return value: paths.
    # - Get an independent seen set.
    # - Add the source node to the set.
    paths = []
    seen = set(seen or [])
    seen.add(src)
    # Explore all non-seen neighbors.
    for nb, _ in matrix[src]:
        if nb not in seen:
            seen.add(nb)
            # Find the subpaths from NB to DST.
            if nb == dst:
                subpaths = [[nb]]
            else:
                subpaths = get_paths(matrix, nb, dst, seen)
            # Glue [SRC] to the those subpaths and add everything to paths.
            for sp in subpaths:
                paths.append([src] + sp)
    return paths

main()
</code></pre>
</div>
<span class="comment-copy">what does <code>adjacency_list</code> do?</span>
<span class="comment-copy">That's a improvement, but still I don't understand how <code>adj_list</code> represents the adjacency of points — how is the information in it laid-out / what its structure means.</span>
<span class="comment-copy">The <code>...</code> means your data structure is self-referential: Python cannot print it all, because it never stops referring to other parts of itself. I haven't studied the details, but it's very suspicious that you are passing <code>path</code> as an argument to a function, mutating it in that function, and then returning it. That seems wrong, and it might be the source of your trouble – or at least part of it.</span>
<span class="comment-copy">Ah yes i see where i went wrong thank you very much you saved me from alot of headache!</span>
