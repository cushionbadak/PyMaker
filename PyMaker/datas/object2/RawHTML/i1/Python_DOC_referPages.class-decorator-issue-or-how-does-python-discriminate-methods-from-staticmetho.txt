<div class="post-text" itemprop="text">
<h2>(I need a Python 3 internals guru, please)</h2>
<p>I have a <strong>class decorator</strong> that modifies some functions but not others.
Simplified example:</p>
<pre><code>import functools
import inspect
import types

def mydecorator(myobj):
    @functools.wraps(myobj)
    def decorated_method(*args, **kwargs):
        print("I'm decorated!")
        return myobj(*args, **kwargs)

    if inspect.isclass(myobj):  # act as class decorator
        for name, obj in myobj.__dict__.items():
            if name == "add":
                setattr(myobj, name, types.MethodType(mydecorator(obj), myobj))
        return myobj  # return decorated class
    elif inspect.isfunction(myobj):  # act as function decorator
        return decorated_method
    else:
        assert False, "can decorate only classes and functions"
</code></pre>
<p>So this will modify any <code>add</code> method to print "I'm decorated" before it runs.</p>
<p>We'll apply it to this class:</p>
<pre><code>class MyClass:
    def add(self, x, y): return x + y
    def mul(self, x, y): return x * y
</code></pre>
<p>and it works alright. We do</p>
<pre><code>#--- try out undecorated MyClass:
print("MyClass.add:", MyClass.add, "MyClass.mul:", MyClass.mul)
print("3+4 =", MyClass().add(3, 4), "3*4 =", MyClass().mul(3, 4), )

#--- decorate MyClass:
print("MyClass = mydecorator(MyClass)")
MyClass = mydecorator(MyClass)

#--- try out decorated MyClass in the same manner:
print("MyClass.add:", MyClass.add, "MyClass.mul:", MyClass.mul)
print("3+4 =", MyClass().add(3, 4), "3*4 =", MyClass().mul(3, 4), )
</code></pre>
<p>and get this output (from CPython 3.6.7 on Linux)</p>
<pre><code>MyClass.add: &lt;function MyClass.add at 0x7faededda0d0&gt; MyClass.mul: &lt;function MyClass.mul at 0x7faededda158&gt;
3+4 = 7 3*4 = 12
MyClass = mydecorator(MyClass)
MyClass.add: &lt;bound method MyClass.add of &lt;class '__main__.MyClass'&gt;&gt;  MyClass.mul: &lt;function MyClass.mul at 0x7faededda158&gt;
I'm decorated!
3+4 = 7 3*4 = 12
</code></pre>
<p>So <code>mul</code> stays a plain function while the decorated <code>add</code> turns into a bound method. The decoration works correctly.</p>
<p>But when I now change the method such that <code>add</code> calls <code>mul</code> (ignore the fact this does not make much sense) as follows:</p>
<pre><code>class MyClass:
    def add(self, x, y): z = self.mul(x, y); return x + y
    def mul(self, x, y): return x * y
</code></pre>
<p>the output turns into this:</p>
<pre><code>MyClass.add: &lt;function MyClass.add at 0x7fbc760870d0&gt; MyClass.mul: &lt;function MyClass.mul at 0x7fbc76087158&gt;
3+4 = 7 3*4 = 12
MyClass = mydecorator(MyClass)
MyClass.add: &lt;bound method MyClass.add of &lt;class '__main__.MyClass'&gt;&gt; MyClass.mul: &lt;function MyClass.mul at 0x7fbc76087158&gt;
I'm decorated!
Traceback (most recent call last):
  File "tryout.py", line 34, in &lt;module&gt;
    print("3+4 =", MyClass().add(3, 4), "3*4 =", MyClass().mul(3, 4), )
  File "tryout.py", line 16, in decorated_method
    return myobj(*args, **kwargs)
  File "tryout.py", line 7, in add
    def add(self, x, y): z = self.mul(x, y); return x + y  # round 2
TypeError: mul() missing 1 required positional argument: 'y'
</code></pre>
<p>It turns out that <code>mul</code> (although it is the same as before!) is now being called as if it were a <code>@staticmethod</code>: <code>self</code> is not passed.</p>
<p>I have plenty of questions:</p>
<ol>
<li>Where does this astonishing effect come from?</li>
<li>What object is <code>add</code> bound to?</li>
<li>How does Python internally discriminate a normal method from a <code>@classmethod</code> or a <code>@staticmethod</code>?</li>
<li>What does <code>types.MethodType</code> really mean?</li>
<li>What would I write in its place to get a normal method, class method, or static method, respectively?</li>
<li>Where would I have found the documentation of all this?</li>
<li>Which of the answers pertain to Python properties as opposed to CPython implementation details?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you should not replace the <em>function</em> <code>add</code> with a bound method. The way methods work is that a <code>function</code> object has a <code>__get__</code> method which, in the case of an instance method, returns a bound method for you to be called on the provided arguments. That is, given</p>
<pre><code>class MyClass:
    def add(self, x, y): 
        return x + y
    def mul(self, x, y):
        return x * y

o = MyClass()
</code></pre>
<p>a call like <code>o.add(3,5)</code> is equivalent to <code>type(o).__dict__['add'].__get__(o, type(o))(3,5)</code>.</p>
<p>Your decorator should also simply return a new function, rather than a <code>method</code> object, and let its <code>__get__</code> method do its job.</p>
<p>Your new decorator, with some simplifications:</p>
<pre><code>def mydecorator(myobj):
    @functools.wraps(myobj)
    def decorated_method(*args, **kwargs):
        print("I'm decorated!")
        return myobj(*args, **kwargs)

    # Decorating a function
    if inspect.isfunction(myobj):
        return decorated_method

    # Decorating a class
    if inspect.isclass(myobj):
        if "add" in myobj.__dict__:
            setattr(myobj, "add", mydecorator(obj))
            # Or just setattr(myobj, "add", decorated_method),
            # unless you think myobj.add might be a nested class
        return myobj

    # Anything else is type error.
    raise TypeError("can decorate only classes and functions")
</code></pre>
<hr/>
<p>Addressing some of your other questions...</p>
<blockquote>
<p>How does Python internally discriminate a normal method from a @classmethod or a @staticmethod?</p>
</blockquote>
<p>The <code>classmethod</code> and <code>staticmethod</code> objects return objects that have different <code>__get__</code> methods than a regular <code>function</code> object.</p>
<blockquote>
<p>Where would I have found the documentation of all this?</p>
</blockquote>
<p>The <a href="https://docs.python.org/3.7/howto/descriptor.html" rel="nofollow noreferrer">Descriptor How-to Guide</a> is a good place to start. It describes the descriptor protocol, as well as examples of how things like properties and methods make use of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add to @chepner's great answer and to answer your point 4.</p>
<blockquote>
<p>What does types.MethodType really mean?</p>
</blockquote>
<p>This special type allows us to add methods to already created instances, in your case there's no instance, hence when you pass <code>myobj</code> to it, you're basically setting <code>__self__</code> of the wrapper to its class rather than using its instance.</p>
<p>Let's take the simpler version of your class, without the decorator:</p>
<pre><code>class MyClass:
    def add(self, x, y):
        z = self.mul(x, y);
        return x + y
    def mul(self, x, y): return x * y
</code></pre>
<p>Now:</p>
<pre><code>&gt;&gt;&gt; ins = MyClass()
&gt;&gt;&gt; ins.add.__func__
&lt;function MyClass.add at 0x7f483050cf28&gt;
&gt;&gt;&gt; ins.add.__self__
&lt;__main__.MyClass object at 0x7f48304ef390&gt;
</code></pre>
<p>As you can see, the <code>add</code> is a whole new object that has now info on which function to call and what to pass as first argument.</p>
<pre><code>&gt;&gt;&gt; ins.add(1, 2)
3
&gt;&gt;&gt; ins.add.__func__(ins.add.__self__, 1, 2)
3
</code></pre>
<p>Now when we do, what you did:</p>
<pre><code>&gt;&gt;&gt; MyClass.add = types.MethodType(ins.add.__func__, MyClass)
</code></pre>
<p>This now passes the class to the function <code>add</code> instead of the instance:</p>
<pre><code>&gt;&gt;&gt; ins = MyClass()
&gt;&gt;&gt; ins.add.__self__
&lt;class '__main__.MyClass'&gt;
</code></pre>
<p>which means the <code>self</code> inside <code>add</code> now is not the actual instance, but the class. Which means <code>self.mul</code> call there is equivalent to:</p>
<pre><code>&gt;&gt;&gt; MyClass.mul(1, 2)
...
TypeError: mul() missing 1 required positional argument: 'y'
</code></pre>
</div>
<span class="comment-copy">Note this answers questions 1, 3, 6, and (implicitly) 5.</span>
