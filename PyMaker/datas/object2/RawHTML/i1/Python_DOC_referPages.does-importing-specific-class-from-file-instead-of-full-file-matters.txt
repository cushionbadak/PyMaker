<div class="post-text" itemprop="text">
<p>Most of the tutorials and books about Django or Flask import specific classes from files instead of importing the whole file.<br/>
For example, importing <code>DataRequiered</code> validator from <code>wrtforms.validators</code> is done via <code>from wtforms import validators</code> instead of importing it via <code>import wtforms.validators as valids</code> and then accessing <code>DataRequiered</code> with <code>valids.DataRequiered</code>.<br/>
<br/>
<strong>My question is:</strong> Is there an reason for this ?<br/>
<br/>
I thought to something like avoiding the loading a whole module for computation/memory optimization (is it really relevant?) ? Or is it simply to make the code more readable ?<br/></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>My question is: Is there an reason for this ?</p>
</blockquote>
<p><code>from module_or_package import something</code> is the canonical pythonic idiom (when you only want to import <code>something</code> in your current namespace of course). </p>
<p>Also, <code>import module_or_package.something</code> only works if <code>module_or_package</code> is a package and <code>something</code> a submodule, it raises an <code>ImportError(No module named something)</code> if <code>something</code> is a function, class or whatever object defined in <code>module_or_package</code>, as can be seen in the stdlib with <code>os.path</code> (which is a submodule of the <code>os.package</code>) vs <code>datetime.date</code> (which is a class defined in the <code>datetime</code> module):</p>
<pre><code>&gt;&gt;&gt; import os.path as p
&gt;&gt;&gt; p
&lt;module 'posixpath' from '/home/bruno/.virtualenvs/blook/lib/python2.7/posixpath.pyc'&gt;
</code></pre>
<p>vs</p>
<pre><code>&gt;&gt;&gt;import datetime.date as d
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ImportError: No module named date
</code></pre>
<blockquote>
<p>thought to something like avoiding the loading a whole module for computation/memory optimization (is it really relevant?) </p>
</blockquote>
<p>Totally irrelevant - importing a given name from a module requires importing the whole module. Actually, this:</p>
<pre><code>from module_or_package import something
</code></pre>
<p>is only syntactic sugar for</p>
<pre><code>import module_or_package
something = module_or_package.something
del module_or_package
</code></pre>
<p>EDIT: You mention in a comment that</p>
<blockquote>
<p>Right, but importing the whole module means loading it to the memory, which can be a reason for importing only a submodule/class</p>
</blockquote>
<p>so it seems I failed to make the point clear: in Python, you <strong>can not</strong> "import only a submodule/class", period. </p>
<p>In Python, <code>import</code>, <code>class</code> and <code>def</code> are all executable statements (and actually just syntactic sugar for operation you can do 'manually' with functions and classes). Importing a module actually consists in executing all the code at the module's top-level (which will instanciate <code>function</code> and <code>class</code> objects) and create a <code>module</code> object (instance of <code>module</code> type) which attributes will be all names defined at the top-level via <code>import</code>, <code>def</code> and <code>class</code> statements or via explicit assignment. It's only when all this has been done that you can access any name defined in the module, and this is why, as I stated above,</p>
<pre><code>from module import obj
</code></pre>
<p>is only syntactic sugar for</p>
<pre><code>import module
obj = module.obj
del module
</code></pre>
<p>But (unless you do something stupid like defining a terabyte-huge dict or list in your module) this doesn't actually take that much time nor eat much ram, and a module is only effectively <em>executed</em> once per process the first time it's imported - then it's cached in <code>sys.modules</code> so subsequent imports only fetch it from cache. </p>
<p>Also, unless you actively prevents it, Python will cache the compiled version of the module (the .pyc files) and only recompile it if the .pyc is missing or older than the source .py file.</p>
<p>wrt/ packages and submodules, importing a submodule will also execute the package's <code>__init__.py</code> and build a <code>module</code> instance from it (IOW, at runtime, a package is also a <code>module</code>). Package initializer are canonically rather short, and actually quite often empty FWIW...</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends, in the tutorial that was probably done for readability</p>
<p>Usually if you use most of the classes in a file, you import the file. If the files contains many classes but you only need a few, just import those. 
It's both a matter of readability and optimization.</p>
</div>
<span class="comment-copy"><a href="//stackoverflow.com/q/2386714">Why is "import *" bad?</a></span>
<span class="comment-copy">@VaibhavVishal I wholefully agree that star imports are bad, but I fail to see how this relates the question...</span>
<span class="comment-copy">Right, but importing the whole module means loading it to the memory, which can be a reason for importing only a submodule/class.</span>
<span class="comment-copy">@Alakazam as mentioned, "importing a given name from a module requires importing the whole module" - cf my edited answer for more details...</span>
<span class="comment-copy">I understand, but you're deleting the rest of the module after it. Loading a lot of modules can bring memory problems (even if I don't think loading modules can oversize memory, in theory it can).</span>
<span class="comment-copy">@Alakazam I'm not "deleting the rest of the module" - the <code>del</code> statement only removes the binding between the name (variable) and the object, it doesn't by itself "delete" the (previously) bound object. An object will only be collected once it's refcount is null, and since imported modules are cached in <code>sys.modules</code>, the refcount will remain positive after this statement.  You may want to read this about names and bindings in python: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">Thanks for those explanation, if <code>del</code> only removes the binding then for sure there is no reason to import only one class.</span>
<span class="comment-copy">I see this on a lot of django and flask projects, I just find that unreadable, so I wanted to make sure.</span>
<span class="comment-copy">Usually you want to import only what you need to avoid problems. But then, if you're importing 9 out of 10 classes from a module it gets kinda ugly and unreadable:</span>
<span class="comment-copy">My question is: What problem can happen ?</span>
<span class="comment-copy">That you override classes namespaces. Imagine you're importing a lot of Views from two different views.py files: you want to use "ExampleView" from the 1st import, but in the 2nd import you also have an "ExampleView" that works in a different way (but you don't know that, because you're importing everything blindly). What would happen is that the 2nd import "ExampleView" overrides the first one and you could lose a lot of time before you figure out why it's not working as you'd expect. This is especially true when you work in a team on the same files.</span>
<span class="comment-copy">What you're basically saying is the opposite.. Those problems can occur when you import a specific class from a module, I think that this is useless, and that we should import the whole module and then access it with <code>module.class</code>.</span>
