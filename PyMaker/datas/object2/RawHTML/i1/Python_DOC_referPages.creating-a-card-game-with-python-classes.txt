<div class="post-text" itemprop="text">
<p>I am trying to practice programming classes in Python by creating a card game. Right now what I want to achieve is to get a player to draw a card from the deck. I have the code as follows:</p>
<pre><code>class Deck():

def __init__(self):
   #create the deck
   self.deck = []
   self.discard_pile = []

def create_deck(self):
   #assign the number of cards for each type to a card (dict)
   deck_stats = {"A":4, "B":6, "C":5, "D":5, "E":5, "F":5, "G":5, "H":5, "I":5, 'J':5}

   for card in deck_stats.keys():
     for i in range(0,deck_stats[card]):
       self.deck.append(card)
   return self.deck

def shuffle(self):
   #randomise the deck or for when the shuffle card is played
   random.shuffle(self.deck)
   return self.deck

def pickup(self):
   #picks up the first card on the draw pile
   picked_up = self.deck.pop(0)
   print(picked_up)
return picked_up
</code></pre>
<p>And the player class:</p>
<pre><code>class Player(Deck):

def __init__(self):
   self.player_hand = ["defuse"]
   for i in range(6):
     self.draw_card()

def draw_card(self):
#draw pile reduces by one
   deck = Deck()
   deck.create_deck()
   deck.shuffle()
   self.player_hand.append(deck.pickup())
return self.player_hand
</code></pre>
<p>In the <code>draw_card()</code>method from the Player class I've called the <code>pickup</code> method from the Deck class. Which I believe is the wrong thing to do but I'm not sure how else to pickup a card from the Deck object.</p>
<p>Also, the <code>draw_card</code> method obviously doesn't work the way it's supposed to as it is creating a new deck every time and then picking up from the new deck (at least that's what I think it is doing right now). This brings me back to my original question, how do I get a player to pickup a card from the same Deck such that I don't need to create a new Deck every time?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try something like</p>
<pre><code>class Deck():

    def __init__(self):
        # create the deck
        self.discard_pile = []
        self.deck = self.create_deck()
        self.shuffle()

    def create_deck(self):
        deck = []
        # assign the number of cards for each type to a card (dict)
        deck_stats = {"A": 4, "B": 6, "C": 5, "D": 5, "E": 5, "F": 5, "G": 5, "H": 5, "I": 5, 'J': 5}

        for card in deck_stats.keys():
            for i in range(0, deck_stats[card]):
                deck.append(card)
        return deck

    def shuffle(self):
        # randomise the deck or for when the shuffle card is played
        random.shuffle(self.deck)
        return self.deck

    def pickup(self):
        # picks up the first card on the draw pile
        picked_up = self.deck.pop(0)
        print(picked_up)
        return picked_up


class Player:

    def __init__(self):
        self.player_hand = ["defuse"]
        self.deck = Deck()
        for i in range(6):
            self.draw_card()

    def draw_card(self):
        # draw pile reduces by one
        self.player_hand.append(deck.pickup())
        return self.player_hand
</code></pre>
</div>
<span class="comment-copy">By adding the @staticmethod, does that mean I'll need to provide an argument when I call the create_deck() method?</span>
<span class="comment-copy">I've removed it to simplify code for now</span>
