<div class="post-text" itemprop="text">
<p>I have one <strong>test1.jpg</strong> - it is the original image and contains the faces we will need to find.</p>
<p>My <strong>test2.jpg</strong> is some image to check. We will need check faces from <strong>test1.jpg</strong> in our <strong>test2.jpg</strong> and if some faces from <strong>test1.jpg</strong> is exist in <strong>test2.jpg</strong> output <strong>true</strong>.</p>
<p>I have not got prior experience in OpenCV and it new technology for me. </p>
<p>My very simple code:</p>
<pre><code># faces which we need find
known_image = cv2.imread('test1.jpg')
# some random image
unknown_image = cv2.imread('test2.jpg')

gray_known = cv2.cvtColor(known_image, cv2.COLOR_BGR2GRAY)
gray_unknown = cv2.cvtColor(unknown_image, cv2.COLOR_BGR2GRAY)
faceCascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")

known_faces = faceCascade.detectMultiScale(
    gray_known,
    scaleFactor=1.27,
    minNeighbors=5,
    minSize=(10, 10),
    flags = cv2.CASCADE_SCALE_IMAGE
)

print("Found known {0} faces!".format(len(known_faces)))

unknown_faces = faceCascade.detectMultiScale(
    gray_unknown,
    scaleFactor=1.27,
    minNeighbors=5,
    minSize=(10, 10),
    flags = cv2.CASCADE_SCALE_IMAGE
)

print("Found unknown {0} faces!".format(len(unknown_faces)))

# BELLOW NOT CORRECT CODE. I DONT KNOW HOW I CAN DO LIKE THIS:
for face in known_faces:
   if face in unknown_faces:
      print(TRUE)
      break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The main issue with your code as it stands, is that it expects the face patches to be identical in two different images. This will almost certainly not be the case - even if one is simply a cropped image of another, if the cascade classifier finds the bounding box 1 pixel further to the left in one image than the other, the result is not identical.</p>
<p>The result of the cascade classifier is a set of bounding boxes that <em>should</em> represent faces (you'll sometimes get false detections). You then need to extract the sub-image within these bounding boxes and use some sort of comparison technique to work out if two face images are the same. I'll discuss these below.</p>
<p>Your problem actually has two stages, and it's important to differentiate them as there are different techniques to tackle the two problems.</p>
<p><strong>Stage 1: Face Detection</strong></p>
<p>This is the problem of actually finding faces in the images. Your code should handle this pretty well - the cascade classifier from OpenCV is one of the most common ways of doing this (an alternative is the <a href="https://www.pyimagesearch.com/2017/05/22/face-alignment-with-opencv-and-python/" rel="nofollow noreferrer">aligned face detector in DLib</a>).</p>
<p><strong>Stage 2: Face Recognition</strong></p>
<p>This is the more difficult part. Face recognition techniques can vary greatly, and a lot of it is situation dependant. The most accurate of these uses the <a href="https://github.com/opencv/opencv/tree/master/samples/dnn" rel="nofollow noreferrer">deep learning module</a>, so if your hardware is up to the task I'd recommend that. It seems that code is actually an <a href="https://www.pyimagesearch.com/2018/09/24/opencv-face-recognition/" rel="nofollow noreferrer">implementation of OpenFace</a> - I've used it before and it's possible to get accurate recognitions on very few training images. I'd recommend reading the linked post, and the DNN samples as the code is probably too deep to go into here.</p>
<p>The main steps are as follows:</p>
<ul>
<li>Detect and locate faces in image 1 as above</li>
<li>Use the pre-trained DNN to transform the face into a linearly separable feature vector (known as an embedding).</li>
<li>Detect and locate faces in image 2 as above</li>
<li>Again, transform the faces into the feature vector using the DNN.</li>
<li>Compare the feature vectors - not the raw images, and select those for which the euclidean distance is low enough.</li>
</ul>
<p>The DNN embedding step is the slow part here, but should still be quite efficient if you have a GPU available. </p>
<p>If, rather than doing direct image-image comparison, you were looking for a known set of faces, you could train an off-the-shelf linear classifier, such as an SVM on the actual people you want to look for, then use this on the feature vectors you find in the image to see if they fall into any of the classes.</p>
<p><strong>Stage 2(a): Face Recognition Without Deep Learning</strong></p>
<p>OpenCV also comes with a face recognition module, which makes use of more classical techniques that tend to be faster and more portable, but at the cost of accuracy. </p>
<p>There's a <a href="https://docs.opencv.org/4.0.1/da/d60/tutorial_face_main.html" rel="nofollow noreferrer">really good tutorial on it in the OpenCV documentation</a>. Again, the code is too long to put directly into a post, but that link describes 3 methods for face detection. <a href="https://iopscience.iop.org/article/10.1088/1742-6596/1028/1/012119/pdf" rel="nofollow noreferrer">Fisherfaces</a> and <a href="https://en.wikipedia.org/wiki/Eigenface" rel="nofollow noreferrer">Eigenfaces</a> both rely on looking at a number of examples of the same face and modelling them in a lower dimensional space where they can be compared for their underlying properties, not the raw pixel data.</p>
<p>I'm not sure either of those will work well for your use-case as you will only have one example of each face.</p>
<p>Using Local Binary Pattern (LBP) histograms  will likely give you a better start-point. LBP's are a way of describing textural details of an image - there's more information in the tutorial I linked above. I'll again give some basic steps here to get you started:</p>
<ul>
<li>For each detected face, extract the small sub-image (region-of-interest) using the bounding box for that face.</li>
<li>Break that image up into smaller "patches" - essentially break the image up into a uniform grid (for example, a 100x100 pixel ROI might be broken up into 10x10 patches of 10x10 pixels).</li>
<li>For each patch, calculate the LBP histogram (essentially a list of numbers)</li>
<li>Concatenate (join) those histograms together to get a representation of the face. This concatenated histogram becomes your feature vector to represent that particular face.</li>
<li>You can then do the same for image 2.</li>
<li>For all of your feature vectors from image 2, compare them against the ones from image 1 and try to pick out those with smaller distances.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>Any recognition technique using a single image is likely to be prone to error. I haven't tested the above algorithms, but have used OpenFace, Fisherfaces and LBPH for face recognition in the past, following those tutorials, and have found they work ok for recognition with a few examples of faces.</p>
</div>
