<div class="post-text" itemprop="text">
<p>I have a scenario where I get a list of jobs to be processed e.g. <em>a list of web pages</em> to be <em>crawled from internet</em>). Each job is <em>independent</em> and also the jobs can be <em>processed in any order</em>. Individual jobs may <em>fail</em> or <em>succeed</em> and may have to be handled accordingly (e.g. temporary data for a failed <em>crawl task</em> may have to be deleted and <em>recrawled</em> in next round)</p>
<p>I am trying to implement it using <em>thread based processing</em> in python. To mimic the actual task lets say I have a huge list of integer arrays and the individual job is to compute the <code>Sum</code> or <code>Product</code> of each array. What I am trying to do is to use a <code>JobsProcessor</code> class object to instantiate threads of <code>JobWorker</code> class objects which perform the actual processing by creating objects for other classes (<code>Sum</code> and <code>Product</code> here). The code for the same is mentioned below. A snippet is shown </p>
<pre><code>from queue import Queue, Empty
from threading import  Thread
import time

class Product:
    def __init__(self,data):
        self.data = data

    def doOperation(self):
        try:
            product =self.data[0]
            for d in self.data[1:]:
                if d&gt;100000:
                    raise Exception( "Forcefully throwing exception")
                product*=d
                time.sleep(1)
            return product
        except:
            return "product computation failed"

class Sum:
    def __init__(self,data):
        self.data = data

    def doOperation(self):
        try:
            sum =0
            for d in self.data:
                sum+=d
                time.sleep(1)
            return sum
        except:
            return  "sum computation failed"


class JobWorker(Thread):
    def __init__(self, queue):
        Thread.__init__(self)
        self.queue = queue

    def run(self):
         while True:
            try:
                jobitem = self.queue.get_nowait()
                if jobitem is None:
                    break
                jobdata, optype = jobitem
                if optype =='sum':
                    opobj = Sum(jobdata)
                    jobresult = opobj.doOperation()
                elif optype =='product':
                    opobj = Product(jobdata)
                    jobresult = opobj.doOperation()
                else:
                    print ("Invalid op type")
                    jobresult = 'Failed'
                print(" job result", jobresult)
                self.queue.task_done()
            except Empty:
                break
            except:
                print ("Some exception occured")
                #How to pass it to up to the main jobs processor#



class JobsProcessor(object):

    def __init__(self, joblist):
        self.joblist = joblist
        self.job_queue = Queue()

    def process_resources(self):
        try:
            for job in self.joblist:
                self.job_queue.put(job)

            for i in range(2):
                jobthread = JobWorker(self.job_queue)
                jobthread.start()           
            '''
                Write code here to monitor current status for all running jobs
            '''

            self.job_queue.join()

            '''I want to write code here to track progress status for all jobs 
                Some jobs may have failed, not completed and based on that I may 
                want to take further action such as retry or flag them'''
            print("Finished Jobs")
        except:
            pass



orgjobList = [ ([1,5,9,4],'sum'), 
               ([5,4,5,8],'product'), 
               ([100,45,678,999],'product'), 
               ([3743,34,44324,543],'sum'),
               ([100001, 100002, 9876, 83989], 'product')]
mainprocessor = JobsProcessor(orgjobList)
mainprocessor.process_resources()
</code></pre>
<p>I want to add 2 functionalities to this  process.</p>
<ul>
<li><strong>Consolidation</strong> : when all the job threads complete I want to know the status of all the <code>JobWorker</code> objects (e.g if they are completed successfully/ complete with failure). <em>Failure/Exception</em> may occur in the <em>JobWorker</em> object or may be even the <em>Sum</em> or <em>Product</em> object. The failure/success status should be propagate back to <em>JobsProcessor</em>, where I want to perform other actions such as reprocess/delete/send_elsewhere etc based on the returned status</li>
<li><strong>Monitoring</strong> - also I want to have a <code>Monitor</code> functionality which can continuously check on the status of current running/completed jobs and perform the requisite actions such as <em>delete</em> immediately rather than waiting till the end for <strong>Consolidation</strong></li>
</ul>
<p>Please advise how I can add the above functionalities, and if only one of them would suffice for cases such as <em>crawling pages</em>. Any other suggestions are also welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can add both the functionalities in your code in any of the two ways - </p>
<ul>
<li>Using Global Variables (simplest approach)</li>
<li>Using a <code>getProgress</code> and <code>getStatus</code> methods in your class (elegant approach)</li>
</ul>
<p>You can create 2 threads, One thread does the actual work and updates the progress variable.</p>
<p>For the second approach, you can set two vars in <code>__init__</code> class, like the following.</p>
<pre><code>def __init__(self):
    self.progress = 0
    self.success = True
    self.isDone = False
    self.error = "No Error Occurred"
</code></pre>
<p>Then you can include the logic in your code like the following - </p>
<pre><code>def actualWork(self):
    self.isDone = 0
    try:
        for i in range(1000):
            self.progress = i
            time.sleep(0.01)
        self.isDone = True
    except Exception as e:
        self.success = False
        self.error = str(e)

def getProgress(self):
    return self.progress

def getError(self):
    return self.error
</code></pre>
</div>
<span class="comment-copy">Thanks this helps partially. Whether the work finished successfully or finished with a failure is still not resolved here. I have edited the question to make it more clear. Also I am not sure how it can be used to track all the threads that were spawned</span>
<span class="comment-copy">@oldmonk You can keep the above code in a try catch and get the exception. Let me post an updated answer.</span>
