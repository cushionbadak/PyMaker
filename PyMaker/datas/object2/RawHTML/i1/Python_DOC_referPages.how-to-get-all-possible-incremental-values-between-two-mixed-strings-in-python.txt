<div class="post-text" itemprop="text">
<p>I am new to Python (and programming, in general) and hoping to see if someone can help me. I am trying to automate a task that I am currently doing manually but is no longer feasible. I want to find and write all strings between two given strings. For example, if starting and ending strings are <code>XYZ-DF 000010</code> and <code>XYZ-DF 000014</code>, the desired output should be <code>XYZ-DF 000010</code>; <code>XYZ-DF 000011</code>; <code>XYZ-DF 000012</code>; <code>XYZ-DF 000013</code>; <code>XYZ-DF 000014</code>. The prefix and numbers (and their padding) are not always the same. For example, next starting and ending strings in the list could be <code>ABC_XY00000001</code> and <code>ABC_XY00000123</code>. The prefix and padding for any pair of starting and ending strings, though, will always be the same.</p>
<p>I think I need to separate the prefix (includes any alphabets, spaces, underscore, hyphen etc.) and numbers, remove padding from the numbers, increment the numbers by 1 from starting number to ending number for every starting and ending strings in a second loop, and then finally get the output by concatenation.</p>
<p>So far this is what I have:</p>
<p>First, I read the 2 columns that contain a list of starting and ending strings in a csv into lists using pandas:</p>
<pre><code>columns = ['Beg', 'End']
data = pd.read_csv('C:/Downloads/test.csv', names=columns, header = None)

begs = data.Beg.tolist()
ends= data.End.tolist()
</code></pre>
<p>Next, I loop over "begs" and "ends" using the zip function.</p>
<pre><code>for beg, end in zip(begs,ends):
</code></pre>
<p>Inside the loop, I want to iterate over each string in begs and ends (one pair at a time) and perform the following operations on them:</p>
<p>1) Use regex to separate the characters (including alphabets, spaces, underscore, hyphen etc.) from the numbers (including padding) for each of the strings one at a time.</p>
<pre><code>start = re.match(r"([a-z-_ ]+)([0-9]+)", beg, re.I) #Let's assume first starting string in the begs list is "XYZ-DF 000010" from my example above
prefix = start.group(1) #Should yield "XYZ-DF "
start_num = start.group(2) #Should yield "000010"
padding = (len(start_num)) #Yields 6
start_num_stripped = start_num.lstrip("0") #Yields 10

end = re.match(r"([a-z-_ ]+)([0-9]+)", end, re.I) #Let's assume first ending string in the ends list is "XYZ-DF 000014" from my example above
end_num = end.group(2) #Yields 000014
end_num_stripped = end_num.lstrip("0") #Yields 14
</code></pre>
<p>2) After these operations, run a nested while loop from start_num_stripped until end_num_stripped</p>
<pre><code>output_string = ""
while start_num_stripped &lt;= end_num_stripped:
output_string = output_string+prefix+start_num_stripped.zfill(padding)+"; "
start_num_stripped += 1
</code></pre>
<p>Finally, how do I write the output_string for each pair of starting and ending strings to a csv file that contains 3 columns containing the starting string, ending string, and their output string? An example of an output in csv format is given below (newline after each row is for clarity and not needed in the output).</p>
<p>"Starting String", "Ending String", "Output String"</p>
<p>"ABCD-00001","ABCD-00003","ABCD-00001; ABCD-00002; ABCD-00003"</p>
<p>"XYZ-DF 000010","XYZ-DF 000012","XYZ-DF 000010; XYZ-DF 000011; XYZ-DF 000012"</p>
<p>"BBB_CC0000008","BBB_CC0000014","BBB_CC0000008; BBB_CC0000009; BBB_CC0000010; BBB_CC0000011; BBB_CC0000012; BBB_CC0000013; BBB_CC0000014"</p>
</div>
<div class="post-text" itemprop="text">
<p>You could find the longest trailing numeric suffix using a regular expression.  Then simply iterate numbers from start to end appending them (with leading zeros) to the common prefix:</p>
<pre><code>import re
startString = "XYZ-DF 000010"
endString   = "XYZ-DF 000012"
suffixLen   = len(re.findall("[0-9]*$",startString)[0])
start       = int("1"+startString[-suffixLen:])
end         = int("1"+endString[-suffixLen:])
result      = [ startString[:-suffixLen]+str(n)[1:] for n in range(start,end+1) ]

csvLine     = '"' + '","'.join([ startString,endString,";".join(result) ]) + '"'

print(csvLine) # "XYZ-DF 000010","XYZ-DF 000012","XYZ-DF 000010;XYZ-DF 000011;XYZ-DF 000012"
</code></pre>
<p>Note: using int("1" + suffix) causes numbers in the range to always have 1 more digit than the length of the suffix (1xxxxx).  This makes it easy to get the leading zeroes by simply dropping the first character after turning them back into strings <code>str(n)[1:]</code> </p>
<p><em>Note2: I'm not familiar with pandas but I'm pretty sure it has a way to write a csv directly from the <code>result</code> list rather than formatting it manually as I did here in <code>csvLine</code>.</em></p>
</div>
<span class="comment-copy">You can format codes and data with <code>{}</code> button or <code>Ctrl + K</code> shortkey.</span>
<span class="comment-copy">Also, is there an easier way to iterate/increment such mixed strings?</span>
<span class="comment-copy">Thank you.   Can you please explain why you added [0] at the end of the regex to find the suffixLen? What does it do?</span>
<span class="comment-copy">re.findall() returns a list because it is designed to find all occurrences of the pattern.  Because I defined the pattern as a suffix (that's that the $ sign does), I know that there will only be one item in the list. But still I'm receiving a list so I have to get the first (and only) item in it.</span>
<span class="comment-copy">Makes sense.   So, if it were returning, hypothetically, 2 items, Then, if I did [1], it will return the second item from the list?</span>
<span class="comment-copy">That's right. But you'd have to specify a pattern that can occur more than once in the string though.</span>
<span class="comment-copy">How about an input case where the starting and ending strings are like this <b>"XYZ-DF 000010; ABC-00100"</b> and <b>"XYZ-DF 000012; ABC-00101"</b>, respectively. In that case, the output needs to be <b>"XYZ-DF 000010;XYZ-DF 000011;XYZ-DF 000012;ABC-00100;ABC-00101"</b>   It could be more than 2 string values (always separated by ;) in the starting and ending strings.</span>
