<div class="post-text" itemprop="text">
<p>Have quite interesting case.</p>
<p>There is <code>df_1</code> with <code>time</code> column based on low-granularity data (2s) like this:</p>
<pre><code>2018-08-31 22:59:47.980000+00:00    41.77   
2018-08-31 22:59:49.979000+00:00    42.76   
2018-08-31 22:59:51.979000+00:00    40.86   
2018-08-31 22:59:53.979000+00:00    41.83   
2018-08-31 22:59:55.979000+00:00    41.73   
2018-08-31 22:59:57.979000+00:00    42.71
</code></pre>
<p>Also there is <code>df_2</code> with labels for this data and <code>time</code> column on hour basis:</p>
<pre><code>2018-08-31 22:00:00 0.0
2018-08-31 23:00:00 1.0
2018-09-01 00:00:00 0.0
2018-09-01 01:00:00 1.0
2018-09-01 02:00:00 0.0
</code></pre>
<p>I would like to merge <code>df_1</code> with <code>df_2</code> that time from df_1 would be between each two consecutive time rows in <code>df_2</code> (between one hour for giving the label). If I would have two time columns in <code>df_2</code> (like <code>startTime</code> and <code>endTime</code>) I would use <code>pandasql</code> and its opportunities:</p>
<pre><code>import pandasql 

sqlcode = '''
select *
from df_1
inner join df_2 on df_1.time &gt;= df_2.startTime and df_1.time &lt;= df_2.endTime
'''

newdf = ps.sqldf(sqlcode,locals())
</code></pre>
<p>But in this case I only have one column. Is there any way to solve this problem in Pandas?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is <code>pd.merge_asof</code>problem, I create a keydat dual of dates in df2,in order to show which date we merge from df2</p>
<pre><code>#df1.Date=pd.to_datetime(df1.Date)
#df2.Date=pd.to_datetime(df2.Date)
yourdf=pd.merge_asof(df1,df2.assign(keydate=df2.Date),on='Date',direction='forward')
yourdf
                     Date         ...                     keydate
0 2018-08-31 22:59:47.980         ...         2018-08-31 23:00:00
1 2018-08-31 22:59:49.979         ...         2018-08-31 23:00:00
2 2018-08-31 22:59:51.979         ...         2018-08-31 23:00:00
3 2018-08-31 22:59:53.979         ...         2018-08-31 23:00:00
4 2018-08-31 22:59:55.979         ...         2018-08-31 23:00:00
5 2018-08-31 22:59:57.979         ...         2018-08-31 23:00:00
[6 rows x 4 columns]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I solved the problem using workaround with splitting time into <code>date</code> and <code>hour</code> columns. Maybe not too fancy but it solves the deal and pretty straight-forward:</p>
<pre><code>import pandasql as ps

df_1['date'] = [d.date() for d in df_1['time']]
df_1['time'] = df_1['time'].dt.round('H').dt.hour

df_2['date'] = [d.date() for d in df_2['time']]
df_2['time'] = df_2['time'].dt.round('H').dt.hour

sqlcode = '''
select *
from df_1
inner join df_2 on df_1.time=df_2.time and df_1.date=df_2.date
'''

newdf = ps.sqldf(sqlcode,locals())
</code></pre>
</div>
<span class="comment-copy">Could you add the screenshots as sample data in your question so we can copy?</span>
<span class="comment-copy">Can you show us your sample data? (not pics)</span>
<span class="comment-copy">If you're going for count, use <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html" rel="nofollow noreferrer">resample</a> by hour.</span>
<span class="comment-copy">no problem, just added values</span>
<span class="comment-copy">updated the post</span>
<span class="comment-copy">I guess the problem that there is 2s interval and merge_asof won't be suitable here. If it will be 1s then yes I think it can be used</span>
<span class="comment-copy">@Keithx check tolerance in it , and pass your 2 s condition :-)</span>
