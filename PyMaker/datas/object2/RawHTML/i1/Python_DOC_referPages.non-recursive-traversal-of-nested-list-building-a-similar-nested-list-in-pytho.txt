<div class="post-text" itemprop="text">
<p>I need to walk a nested list, process every non-list item with <code>str()</code> and return similar list keeping the structure. With recursion it would be rather easy, but I need to do this iterative way. Below is my attempt with a <code>while</code> loop:</p>
<pre><code>def myiter(e):
    a = [e] # initial list
    c = [[]] # final result
    get_last = lambda x: x[len(x)-1] # get ref to the final sublist
    l = get_last(c)
    while a:
        b = a.pop(0)
        if isinstance(b, list):
            # if there are more items to process in the original list
            if a:
                a = b + a
            # else extend original list to process sublists
            else:
                a.extend(b)
            # make a new sublist ref
            l = get_last(c)
            c.append([])
        else:
             # walk and process every item in the nested list
             l.append(str(b))
    return c
</code></pre>
<p>There are several problems with this as the output will show:</p>
<pre><code>myiter([1, [2, [3, 4], 5]]) # [['1'], ['2'], ['3', '4', '5'], []]
</code></pre>
<p>Desired result is:</p>
<pre><code>['1', ['2', ['3', '4'], '5']]
</code></pre>
<p>Is there a simple iterative way to do the task in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>This seems to work:</p>
<pre><code>def stringify(a):
    a = a[:]                           # Make copy of what was passed in.
    res = []                           # Initialize result list.
    my_stack = []                      # Initialize our own LIFO stack.
    while (a or my_stack):                            # While a or my_stack is non-empty
        if (a):
            elem = a.pop(0)
            if (not isinstance(elem, list)):          # If popped elem is not a list
                res.append(str(elem))                 # Append stringified elem to res
            else:
                my_stack.append((a, res))           # Push some stuff, to resume working upon later.
                a = elem                            # Let's start iterating on this inner list
                res = []                            # This inner list needs a clean res, to start with.
        else:                                       # my_stack is non-empty
            a, res_prev = my_stack.pop()   # Pop some stuff, to resume, work on outer list
            res_prev.append(res)           # First, append our just-completed inner list.
            res = res_prev
    return res
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>a = [1, [2, [3, 4], 5]]
stringify(a)
['1', ['2', ['3', '4'], '5']]
</code></pre>
<p><strong>Passed the Following Test Cases:</strong></p>
<pre><code>a = [1, [[[2]]]]
a = [[[1]], 2]
a = [1, [[2]]]
a = [1, [2, [3, 4], 5], [6, [7, [8]]], 9]
a = [1, [2, [3, 4], 5]]
a = [1, 2, 3, 4, 5]
</code></pre>
<p><strong>Some Notes on How This Works:</strong></p>
<ol>
<li>If the <code>pop</code> on our list <code>a</code> produces an integer, we just append the stringified integer to <code>res</code></li>
<li>If the <code>pop</code> on our list <code>a</code> produces an inner list, we need to start processing that inner list, before we process the elements occurring after that inner list. After processing the inner list, we will have to come back to the remaining unpopped elements of <code>a</code>).</li>
<li>Whenever we detect that our current list <code>a</code> has become empty, our <code>res</code> would be pointing to the equivalent stringified list, and it is time for us to append our <code>res</code> to whatever may be its (stringified) outer list </li>
<li>To process each encountered inner list, we adopt that inner list as our new <code>a</code> (the assignment <code>a = elem</code>), and an empty list as our new <code>res</code> (<code>res = []</code>). Before we do that, we need to push onto the stack our current <code>a</code> and our current <code>res</code></li>
<li>Why LIFO? Well, look at it this way: Whatever was pushed <strong>last</strong> onto <code>my_stack</code> represents the the immediate outer list of whatever list we are currently processing (<code>a</code>).</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Why not recursion? Processing recursive data structures using recursive procedures is natural and straightforward. Converting a recursive process to an iterative one doesn't have to involve cloning the input, creating a <code>stack</code>, or other intermediate values. Your brain can be free from such crippling complexities -</p>
<pre><code>def first (a = []):
  return a[0]

def rest (a = []):
  return a[1:]

def myiter (a = []):
  # base: empty a
  if not a:
    return []
  # inductive: non-empty a, first elem is list
  elif isinstance(first(a), list):
    return [ myiter(first(a)) ] + myiter(rest(a))
  # inductive: non-empty a, first elem is non-list
  else:
    return [ str(first(a)) ] + myiter(rest(a))     

print(myiter([1, [2, [3, 4], 5]]))
</code></pre>
<p>Of course it makes sense to make <code>str</code> a parameter of the function, <code>f</code> -</p>
<pre><code>def myiter (f, a = []):
  # base: empty a
  if not a:
    return []
  # inductive: non-empty a, first elem is list
  elif isinstance(first(a), list):
    return [ myiter(f, first(a)) ] + myiter(f, rest(a))
  # inductive: non-empty a, first elem is non-list
  else:
  return [ f(first(a)) ] + myiter(f, rest(a))
</code></pre>
<p>Now you can deep map <code>str</code> like you want to -</p>
<pre><code>print(myiter(str, [1, [2, [3, 4], 5]]))
# ['1', ['2', ['3', '4'], '5']]
</code></pre>
<p>Or use any function of your choosing -</p>
<pre><code>def square (x):
  return x * x

print(myiter(square, [1, [2, [3, 4], 5]]))
# [1, [4, [9, 16], 25]]
</code></pre>
<p>Are you trying to avoid recursion because of a stack limit?  If you make it tail-recursive -</p>
<pre><code>def identity (x):
  return x

def myiter (f, init = []):
  def run (a = init, then = identity):
    if not a:
      return \
        then([])
    # inductive: non-empty a, first elem is list
    elif isinstance(first(a), list):
      return \
        recur(first(a), lambda l: \
          recur(rest(a), lambda r: \
            then([ l ] + r)))
    # inductive: non-empty a, first elem is non-list
    else:
      return \
        recur(rest(a), lambda r: \
          then([ f(first(a)) ] + r))
  # loop inner function
  return loop (run)
</code></pre>
<p>Then implement a generic <code>loop</code> which converts the recursive call stack to an iterative sequence -</p>
<pre><code>def recur (*values):
  return (recur, values)

def loop (f):
  acc = f ()
  while type(acc) is tuple and acc[0] is recur:
    acc = f(*acc[1])
  return acc
</code></pre>
<p>The output is the same, but now <code>myiter</code> can accept an array of <em>any</em> nesting limit. Recursion without restrictions; what a beautiful thing -</p>
<pre><code>print(myiter(str, [1, [2, [3, 4], 5]]))
# ['1', ['2', ['3', '4'], '5']]

print(myiter(square, [1, [2, [3, 4], 5]]))
# [1, [4, [9, 16], 25]]
</code></pre>
<p>View this program and verify the results in your own browser using <a href="https://repl.it/repls/SquareSharpDevelopers" rel="nofollow noreferrer">repl.it</a>.</p>
<hr/>
<blockquote>
<p>Why can't you use recursion? - Jab</p>
<p>@Jab, Three reasons: First maximum recursion limit is often hit on one of my app, second performance concerns althought map might be head to head with iterative method, thirdly just for training and studying these two different styles of coding. â€“ MarkokraM</p>
</blockquote>
<p>So you haven't hit a recursion limit but you're worried that your program will? It's better to understand actual limitations instead of writing programs around ghosts. In a simplified implementation using generators, notice that recursion only happens when a level of nesting is encountered. Even if you left this implementation as-is, this can support lists of any length and nesting levels up to the stack limit, where the default is probably around 1,000. This means the only data input that would blow your stack is one that is nested 1,000 times or more. It's probably safe to leave this program be until an <em>actual</em> limitation is reached.</p>
<pre><code>def square (x):
  return x * x

def myiter (f, init = []):
  def gen (a):
    for x in a:
      if isinstance(x, list):
        yield list(gen(x)) # recursion
      else:
        yield f(x)
  return list(gen(init))

print(myiter(str, [1, [2, [3, 4], 5]]))
# ['1', ['2', ['3', '4'], '5']]

print(myiter(square, [1, [2, [3, 4], 5]]))
# [1, [4, [9, 16], 25]]
</code></pre>
</div>
<span class="comment-copy">What are desired results?</span>
<span class="comment-copy">Also, <code>a = [e]</code> seems like it's misused. You're making a list containing e as it's only element. and <code>get_last</code> is better written: <code>lambda x: x[-1]</code></span>
<span class="comment-copy">Initially creating a list of input makes sure we are processing a list in the first hand. Could be handled by other means in the beginning in the function. I'll change -1 to the get last lambda function, which is a way better of cource. But I'll leave the code in the original post as it is for the reference of answers and comments.</span>
<span class="comment-copy">You can simulate stack operator just like use recursion. <code>l = get_last(c)</code> like push stack, but poping stack don't appear in your code, you can try to do some work from this.</span>
<span class="comment-copy">May I ask why you cannot use recursion?</span>
<span class="comment-copy">Worth to tweak more. I didn't try to modify lists on "not the list case" as extensively as you do. For further improvements, this test case fails at the moment: <code>[1, [2, [3, 4], 5], [6, [7, [8]]], 9]</code></span>
<span class="comment-copy">Fixed, and further tested additional test cases. Pls check.</span>
<span class="comment-copy">Now it is cool! I even had same while part for checking two lists at some point. Can you explain the purpose of lifo stack, and I will accept the answer as helpful enough to my purposes.</span>
<span class="comment-copy">@MarkokraM: Please check the Notes added to the answer.</span>
<span class="comment-copy">I have countered max recursion limit pretty often due to domain language specific problems, too complicated to explain here. A simplified version of walking thru all list items with map recursion, and keeping the list structure, would be: <code>def recmap(a): return list(map(recmap, a)) if isinstance(a, list) else str(a)</code>. It is quite short and elegant compared to the iterative method. Purely anonymous function version would also work: <code>print((lambda f, a: f(f, a))  ((lambda f, a: list(map(lambda b: f(f, b), a)) if isinstance(a, list) else str(a)), [1, [2, [3, 4]], 5]))</code></span>
<span class="comment-copy">Really a nicer answer; think recursive but solving iterative. Functional languages like <code>scheme</code> behave like this right?</span>
<span class="comment-copy">@Nishant you got it. Scheme is the king ^_^</span>
<span class="comment-copy">@user633183, But does this approach work in Python since it doesn't support tail recursion? See this code for example - <code>myiter(str, range(0, 957))</code>. Can you please share your thoughts?</span>
<span class="comment-copy">@Nishant of course. Have you tried running it? It will return <code>[ '0', '1', '2', ..., '954', '955', '956' ]</code>. This example even works on the last program that is implemented with generators (instead of the <code>loop</code>).</span>
