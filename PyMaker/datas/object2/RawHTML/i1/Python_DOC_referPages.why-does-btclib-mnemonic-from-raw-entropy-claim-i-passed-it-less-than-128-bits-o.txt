<div class="post-text" itemprop="text">
<p>What I am doing is generating 'dummy' wallets, retrieving both a mnemonic passphrase and wallet from raw entropy, which is generated using <code>secrets.randbits(128)</code> – resulting in a valid bip39 pair of keys. </p>
<p>The error I get is along these lines:</p>
<pre><code>ValueError: 125 bits provided; expected: (128, 160, 192, 224, 256)
</code></pre>
<p>It can vary from 122 to 127 bits. It usually says the same amount of bits for multiple errors in a row, i.e. <code>125 bits provided</code> for 3 times, then switching  to <code>122 bits provided</code> for 2 times, then working at the 6th try. </p>
<p>I am using btclib – the full function is </p>
<pre><code>def create_passphrase():
    memo = bip39.mnemonic_from_raw_entropy(secrets.randbits(128) , 'en')

    print(mnemo) 
    return mnemo
</code></pre>
<p>Sorry if I am missing something obvious.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a bug in btclib.</p>
<p>The function <a href="https://github.com/fametrano/btclib/blob/master/btclib/bip39.py#L63" rel="nofollow noreferrer"><code>bip39.mnemonic_from_raw_entropy()</code></a> calls <a href="https://github.com/fametrano/btclib/blob/master/btclib/bip39.py#L57" rel="nofollow noreferrer"><code>bip39.entropy_from_raw_entropy()</code></a>, which calls <a href="https://github.com/fametrano/btclib/blob/master/btclib/entropy.py#L21" rel="nofollow noreferrer"><code>entropy.str_from_entropy()</code></a>.</p>
<p>When <code>entropy.str_from_entropy()</code> is called with an integer as its <code>entr</code> argument, it attempts to convert that integer into a string representing the bits, <a href="https://github.com/fametrano/btclib/blob/master/btclib/entropy.py#L44" rel="nofollow noreferrer">here</a>:</p>
<pre><code>        entr = bin(entr)[2:] # remove '0b'
</code></pre>
<p>This is broken: any integer passed in will, if it's truly random, only be converted to the number of bits expected about half the time. To see why, consider these examples of random data (I'll use 8 bits rather than 128 for simplicity's sake, but the principle is the same):</p>
<pre><code>&gt;&gt;&gt; bin(0b10001011)[2:]
'10001011'
&gt;&gt;&gt; bin(0b01010110)[2:]
'1010110'
&gt;&gt;&gt; bin(0b00111011)[2:]
'111011'
</code></pre>
<p>As you can see, the conversion method used by btclib strips off any leading zeroes, leading to a string of the wrong length being produced. </p>
<p>A workaround might be to convert the result of <code>secrets.randbits(128)</code> to an appropriate string yourself, and pass that:</p>
<pre><code>def create_passphrase(bits=128):
    bitstring = f'{secrets.randbits(bits):0{bits}b}'
    memo = bip39.mnemonic_from_raw_entropy(bitstring , 'en')
    print(memo) 
    return memo
</code></pre>
<p>… assuming that there aren't other bugs in btclib waiting to bite you.</p>
</div>
<span class="comment-copy">random bits are either 0 or 1. So you would expect a leading zero bit about 1/2 the time, two leading zero bits about 1/4 the time, etc.</span>
<span class="comment-copy">Now it works 100% of the times! Thanks! i am not sure, it's a bug or an intended behavior?</span>
<span class="comment-copy">It's a bug – there's no way you'd ever want the current behaviour of <code>str_from_entropy()</code>. You should probably <a href="https://github.com/fametrano/btclib/issues" rel="nofollow noreferrer">report</a> it (in which case a link to this page would be enough to explain the problem, and a solution).</span>
