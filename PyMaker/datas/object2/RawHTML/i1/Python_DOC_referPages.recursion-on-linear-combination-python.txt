<div class="post-text" itemprop="text">
<p>I have this interview practice question:</p>
<p>There exists a staircase with N steps, and you can climb up any number of steps from a set of positive integers X? For example, if X = {1, 3, 5}, you could climb 1, 3, or 5 steps at a time.</p>
<p>I got the below implementation and it seems to work.</p>
<p>I have a few questions on my approach : </p>
<p>1.What would be the Big-O notation for this piece of code ?</p>
<p>2.Would there be a better approach, taking in to consideration the complexity ? </p>
<pre><code>def stairA(N,X):

    print("begin")
    print(N)
    print(X)
    print(len(X))
    print("end")
    total=0

    if(len(X)==0):
        print("space_Z")
        return 0

    if (len(X)&gt;0):
        if(X[len(X)-1]&gt;N):
            print("space_A")
            newlist = [k for k in X if k &lt; X[len(X)-1]]
            stairA(N,newlist) #step size greater than stair number
            #stairA(N,X[:len(T)-1]) #step size greater than stair number
        if (N==1):
            if(1 in X):
                print("space_B")
                return 1

        if (N==0):
            print("space_X")
            return 1
        if (N&lt;0):
            print("space_Y")
            return 0


        for ind,ele in enumerate(X):                          
            a=N-ele    

            stairA(a,X)#what first step we take
            total = total + stairA(a,X)#what first step we take

    return total
</code></pre>
<p><strong>Results:</strong></p>
<pre><code>1+1+1+1

1+2+1

1+1+2

1+3

2+1+1

2+2

3+1

Y=[3,1,2]
Y.sort()
print(Y)
stairA(4,Y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Recursion as this is the generation of f(N)=f(n-1)+f(n-2)+....</p>
<pre><code>def staircase(n, X):
        if n &lt; 0:
            return 0
        elif n == 0:
            return 1
        else:
            return sum(staircase(n - x, X) for x in X)
</code></pre>
<p>Dynamic programming:</p>
<pre><code>def staircase(n, X):
    cache = [0 for _ in range(n + 1)]
    cache[0] = 1
    for i in range(1, n + 1):
        cache[i] += sum(cache[i - x] for x in X if i - x &gt;= 0)
    return cache[n]
</code></pre>
<p>I cant figure out why the recursion one O(|X|**N)
and the dynamic one is O(N*|X|)</p>
</div>
<span class="comment-copy">There is no question in the problem statement. What do you need to get? Also what do yo mean by <code>o(N)</code> - complexity?</span>
<span class="comment-copy">Is the question printing all possible cases? Or just number of cases?</span>
<span class="comment-copy">I got the solution. It says its the generalization of f(n)=f(n-1)+f(n-2) Fibonacci sequence.</span>
<span class="comment-copy">def staircase(n, X):     if n &lt; 0:         return 0     elif n == 0:         return 1     else:         return sum(staircase(n - x, X) for x in X)</span>
<span class="comment-copy">It says this implementation is O(|X|**N) and it suggests use dynamic programming</span>
