<div class="post-text" itemprop="text">
<blockquote>
<p>Given an array of <strong>N</strong> integers, check if it is possible to obtain a sum of <strong>S</strong>, by choosing some (or none) elements of the array and adding them. </p>
</blockquote>
<p>I tried solving this using a greedy approach by first sorting the array and then approaching closer and closer to the sum. However it does not work.</p>
<p>Can anyone please tell me how should I approach this problem?</p>
<pre><code>t = int(input())
for foo in range(t):
    n = int(input())
    arr = list(map(int, input().split()))
    s = int(input())
    sum = 0

    for a in range(len(arr)):
        for b in range(len(arr)-a-1):
            if(arr[b] &gt; arr[b+1]):
                temp = arr[b]
                arr[b] = arr[b+1]
                arr[b+1] = temp

    for i in arr:
        if((sum + i) &lt;= s):
            sum += i

    if(sum == s):
        print("YES")
    else:
        print("NO")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A brute-force (and arguably very slow) solution with <code>itertools.combinations</code>:</p>
<pre><code>from itertools import combinations

def is_possible_sum(numbers, n):
    # One of those rare cases where range() is ok!
    for r in range(len(numbers)):
        for combo in combinations(numbers, r + 1):
            if sum(combo) == n:
                return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dynamic and combination solutions and time/results test code:</p>
<pre><code># The subset sum problem:
#
# Given an array of N integers, check if it is possible to obtain a sum of S,
# by choosing some (or none) elements of the array and adding them.
#
# The code contributors are Alexander Lopatin, Sahil Shelangia, DYZ


def if_possible_sum_obvious(a, s):
    if a is None or len(a) == 0:
        return s == 0
    if s &gt; 0:
        if s &gt; sum([i for i in a if i &gt; 0]):
            return False
    elif s &lt; 0:
        if s &lt; sum([i for i in a if i &lt; 0]):
            return False
    else:
        for i in a:
            if i == 0:
                return True
        else:
            return False
    return None


def is_possible_sum_dynamic(a, s):  # Dynamic Programming
    if a is None or len(a) == 0:
        return s == 0
    n = len(a)
    b = [[False for _ in range(s + 1)] for _ in range(n + 1)]
    for i in range(n + 1):
        b[i][0] = True
    for i in range(1, s + 1):
        b[0][i] = False
    for i in range(1, n + 1):
        for j in range(1, s + 1):
            if j &lt; a[i - 1]:
                b[i][j] = b[i - 1][j]
            if j &gt;= a[i - 1]:
                b[i][j] = (b[i - 1][j] or b[i - 1][j - a[i - 1]])
    return b[n][s]


def is_possible_sum_combinations(a, s):  # combinations from itertools
    check_obvious = if_possible_sum_obvious(a, s)
    if check_obvious is not None:
        return check_obvious
    from itertools import combinations
    for r in range(len(a)):
        for combo in combinations(a, r + 1):
            if sum(combo) == s:
                return True
    return False


if __name__ == '__main__':
    import time
    for f in [is_possible_sum_dynamic, is_possible_sum_combinations]:
        print('\nTesting function:', f.__name__)
        for N in range(40):
            a_global = [i+1 for i in range(N)]
            sum2check = sum(a_global)
            print(N, end='')

            def time_and_check(f_local, sum_local, expected):
                t0 = time.perf_counter_ns()
                possible = f_local(a_global, sum_local)
                t1 = time.perf_counter_ns() - t0
                print('', t1, sep=',', end='' if expected else '\n')
                if possible != expected:
                    print('Not possible! Strange')
                    print(sum_local, a_global, sep='\n')
                    exit(1)

            time_and_check(f, sum2check, True)
            time_and_check(f, sum2check + 1, False)
</code></pre>
<p>I added the dynamic programming solution and modified DYZ's code to avoid obvious pitfall with if_possible_sum_obvious(a, s) call. The same function can be added instead of two first lines in is_possible_sum_dynamic function, but then I have to run this long test again and remake the graphic.
<a href="https://i.stack.imgur.com/eBxPy.png" rel="nofollow noreferrer"><img alt="Axis X is N integers, Y - log10(time in nanoseconds): 1 = 1 ns, 9 = 1 sec, 12 = 1000 sec" src="https://i.stack.imgur.com/eBxPy.png"/></a>
Axis X is the number integers, axis Y - log10(time in nanoseconds): 3=10**3 ns = 1 Î¼s, 9 = 1 sec, 12 = 1000 sec</p>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Testing function: is_possible_sum_dynamic
0,2630,740
1,7068,5588
2,8120,8725
3,13344,14298
4,22849,24119
5,36515,57237
6,70649,59626
7,83752,86483
8,119746,123067
9,162509,167441
10,217729,263601
11,285210,289287
12,405059,368185
13,461434,462611
14,568958,569770
15,687595,1110547
16,957992,869849
17,998072,1074423
18,1381996,1460914
19,1455941,1399456
20,1803727,1608306
21,1968317,2000050
22,2482750,2602217
23,2737389,2424789
24,2756149,2802634
25,3581139,3282499
26,3360480,3421020
27,3778212,4037443
28,4295289,4182019
29,4850601,4657451
30,5294141,5060018
31,5955458,5811096
32,6386726,6341719
33,6848117,6843303
34,7589508,7485276
35,8231171,8118034
36,8921163,9172343
37,10649931,11339668
38,11922632,11463180
39,12720235,12802786

Testing function: is_possible_sum_combinations
0,3535,880
1,170306,2222
2,5823,1460
3,5944,1441
4,7736,1411
5,11908,1522
6,18459,1565
7,32447,1630
8,59748,1812
9,118461,2062
10,237636,3110
11,495370,3816
12,1007225,4040
13,1945018,3824
14,4091327,6125
15,9028434,6253
16,16549245,5440
17,35843517,5611
18,64125274,5158
19,137040747,5894
20,284994834,6748
21,538974234,5722
22,1108166024,5654
23,2242642192,6019
24,4642429033,6166
25,9368977496,6358
26,18792906166,6285
27,38892974776,6442
28,78689360778,6324
29,160660909206,7009
30,330681016443,7278
31  ,684805660485,10669
32,1361937299206,7018
33
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you check this code</p>
<pre><code># sum using elements of the given array. 
def check(arr, N): 

    ispossible[0] = 1
    arr.sort() 

    for i in range(0, N): 
        val = arr[i] 

        # if it is already possible 
        if ispossible[val]: 
            continue

        # make 1 to all it's next elements 
        for j in range(0, MAX - val): 
            if ispossible[j]: 
                ispossible[j + val] = 1

# Driver code 
if __name__ == "__main__": 

    arr = [2, 3] 
    N = len(arr) 

    # maximum size of x 
    MAX = 1000

    # to check whether x is possible or not 
    ispossible = [0] * MAX

    check(arr, N) 
    x = 7

    if ispossible[x]: 
        print(x, "is possible.") 
    else: 
        print(x, "is not possible.")
</code></pre>
</div>
<span class="comment-copy">Given an array of N <b>elements</b>: Why did you assume that N elements in an array are all integer? I would ask: Given an array of N <b>integers</b></span>
<span class="comment-copy">@AlexanderLopatin It was mentioned in the question that all inputs will be integer.</span>
<span class="comment-copy">@harshit54 Integers are not mentioned in the question. This problem is called <code>subset sum</code></span>
<span class="comment-copy">@ DillonDavis It is weekend :-) Here are two, recursive and dynamic programming, solutions: <a href="https://www.geeksforgeeks.org/python-program-for-subset-sum-problem-dp-25/" rel="nofollow noreferrer">geeksforgeeks.org/python-program-for-subset-sum-problem-dp-25</a></span>
<span class="comment-copy">@alexander: DYZ's solution is O(2^N), not O(N!). (Sum of C(n,i) for i from 0 to n is 2^n).</span>
<span class="comment-copy">So the combinations function returns a list of all possible combinations of numbers of size r.</span>
<span class="comment-copy">Thanks. But I was looking for a solution which I can completely code without using any fancy functions. Is it possible?</span>
<span class="comment-copy">There is nothing fancy about <code>combinations</code>. It is a part of the standard library.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/5731505/where-can-i-find-source-code-for-itertools-combinations-function">Check this</a>.</span>
<span class="comment-copy">@harshit54: The documentation for <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>intertools.combinations</code></a> shows what it is roughly equivalent to. Note when writing your own, you might be able to short-circuit the generation process and skip to the next one when the partial sum exceeds <b>S</b>.</span>
<span class="comment-copy">Can you please explain the code?</span>
