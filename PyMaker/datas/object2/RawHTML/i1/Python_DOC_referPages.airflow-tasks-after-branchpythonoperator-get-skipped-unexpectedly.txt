<div class="post-text" itemprop="text">
<p>My dag is defined as below. Although <code>flag1</code> and <code>flag2</code> are both <code>y</code>, they got skipped somehow.  </p>
<pre><code>from datetime import datetime, timedelta
from airflow import DAG
from airflow.operators.dummy_operator import DummyOperator
from airflow.operators.python_operator import BranchPythonOperator
import pandas as pd
from itertools import compress



default_args = {
    'owner': 'alex'
    , 'retries': 2
    , 'retry_delay': timedelta(minutes=15)
    , 'depends_on_past': False
    , 'start_date': datetime(2018, 11, 22)
}

dag = DAG(
    'test_dag'
    , catchup = False
    , default_args = default_args
    , schedule_interval = '@daily'
)

task1 = DummyOperator(
        task_id='task1',
        dag=dag,
    )

task2 = DummyOperator(
        task_id='task2',
        dag=dag,
    )

task3 = DummyOperator(
        task_id='task3',
        dag=dag,
    )


# 1 means yes, 0 means no
flag1 = 'y'
flag2 = 'y'
flag3 = 'y'

tasks_name = ['task1', 'task2', 'task3']
flags = [flag1, flag2, flag3]


def generate_branches(tasks_name, flags):
    res = []
    idx = 1
    root_name = 'switch'
    for sub_task, sub_flag in zip(tasks_name, flags):
        tmp_branch_operator = BranchPythonOperator(
            task_id=root_name+str(idx), # switch1, switch2, ...
            python_callable= lambda: sub_task if sub_flag == 'y' else 'None',
            dag=dag,
        )
        res.append(tmp_branch_operator)
        idx += 1
    return res


def set_dependencies(switches, transfer_operators):
    for sub_switch, sub_transfer_operator in zip(switches, transfer_operators):
        sub_switch.set_downstream(sub_transfer_operator)


transfer_operators = [task1, task2, task3]
gen_branches_op = generate_branches(tasks_name, flags)
set_dependencies(gen_branches_op, transfer_operators)

</code></pre>
<p><a href="https://i.stack.imgur.com/5IQXr.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/5IQXr.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>That issue is caused by lambda's late binding behaviour. Because lambda is evaluated when invoked, so everytime your lambda always return the last element from the list, which is <code>task3</code>.</p>
<p>If you can look into switch1's and switch2's logs, you can find that they have following branch <code>task3</code> instead of <code>task1</code> and <code>task2</code> respectively.</p>
<p>To avoid this, you can force the lambda to be evaluated at the time when it is defined by changing your <code>python_callable</code> in <code>generate_branches()</code>:</p>
<pre><code>def generate_branches(tasks_name, flags):
    res = []
    idx = 1
    root_name = 'switch'
    for sub_task, sub_flag in zip(tasks_name, flags):
        tmp_branch_operator = BranchPythonOperator(
            task_id=root_name+str(idx), # switch1, switch2, ...
            python_callable=lambda sub_task=sub_task: sub_task if sub_flag == "y", else "None"
            dag=dag,
        )
        res.append(tmp_branch_operator)
        idx += 1
    return res
</code></pre>
</div>
<span class="comment-copy">Tried your solution. It worked for flags = ['y', 'y', 'y']. But when I changed it to ['y', 'n', 'n'], all of the three task get skipped though.</span>
