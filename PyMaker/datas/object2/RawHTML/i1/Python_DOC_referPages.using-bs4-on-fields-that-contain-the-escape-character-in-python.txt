<div class="post-text" itemprop="text">
<p>So my content I'm scraping has the escape character in the class name.</p>
<p>Here's what the data looks like.</p>
<pre><code>&lt;div class='\"content-review\"'&gt; blah blah blah &lt;/div&gt;
</code></pre>
<p>I've tried doing this:</p>
<pre><code>mydivs = soup.findAll("div", {"class": repr('\"content-review\"')})
</code></pre>
<p>and it returns an empty array. I think this has a simple solution but I can't seem to figure it out.</p>
</div>
<div class="post-text" itemprop="text">
<p>The escape characters may not be your problem. I believe "class" is a reserved word in Python, so you can't use it as a keyword argument. Beautiful Soup <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#searching-by-css-class" rel="nofollow noreferrer">handles this</a> by using the keyword argument "class_" instead. Try something like this":</p>
<pre><code>mydivs = soup.findAll("div", class_="content-review")
</code></pre>
<p>If that still doesn't work, then you can tell Beautiful Soup to ignore the escaped quotes like so:</p>
<pre><code>import re
mydivs = soup.findAll("div", class_=re.compile("content-review"))
</code></pre>
</div>
<span class="comment-copy">is the content dynamically loaded and therefore a method like selenium needed?</span>
<span class="comment-copy">tried that, and tried it with class_=repr('\"content-review\"'). still empty. hmmm</span>
<span class="comment-copy">You are correct class is a reserved word, but the way OP has it, is an acceptable syntax as a dictionary {“class”:”string”}. I like your solution with regex. That should work. If not, might be dealing with a dynamic site.</span>
<span class="comment-copy">I'm also viewing the html text before the soup outputs, the div class I need is definitely there</span>
<span class="comment-copy">So the div class is definitely in the html response you get? Viewing the html response through the response and html from the browser’s response could be different if the page is dynamic.</span>
<span class="comment-copy">If the page/data is rendered after the page is accessed, you won’t find the same tags/content in the html that is initially pulled. You’d have to use something like selenium to allow the page to render, and then grab the source html. The data could also be within a json structure sometimes as well within the html. Do you mind sharing the url, and a specific text/content you’re wanting to parse?</span>
