<div class="post-text" itemprop="text">
<p>I need a good explanation (references are a plus) on Python's slice notation. </p>
<p>To me, this notation needs a bit of picking up. </p>
<p>It looks extremely powerful, but I haven't quite got my head around it.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's pretty simple really:</p>
<pre><code>a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array
</code></pre>
<p>There is also the <code>step</code> value, which can be used with any of the above:</p>
<pre><code>a[start:stop:step] # start through not past stop, by step
</code></pre>
<p>The key point to remember is that the <code>:stop</code> value represents the first value that is <em>not</em> in the selected slice. So, the difference between <code>stop</code> and <code>start</code> is the number of elements selected (if <code>step</code> is 1, the default).</p>
<p>The other feature is that <code>start</code> or <code>stop</code> may be a <em>negative</em> number, which means it counts from the end of the array instead of the beginning. So:</p>
<pre><code>a[-1]    # last item in the array
a[-2:]   # last two items in the array
a[:-2]   # everything except the last two items
</code></pre>
<p>Similarly, <code>step</code> may be a negative number:</p>
<pre><code>a[::-1]    # all items in the array, reversed
a[1::-1]   # the first two items, reversed
a[:-3:-1]  # the last two items, reversed
a[-3::-1]  # everything except the last two items, reversed
</code></pre>
<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]</code> and <code>a</code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</p>
<h3>Relation to <code>slice()</code> object</h3>
<p>The slicing operator <code>[]</code> is actually being used in the above code with a <code>slice()</code> object using the <code>:</code> notation (which is only valid within <code>[]</code>), i.e.:</p>
<pre><code>a[start:stop:step]
</code></pre>
<p>is equivalent to:</p>
<pre><code>a[slice(start, stop, step)]
</code></pre>
<p>Slice objects also behave slightly differently depending on the number of arguments, similarly to <code>range()</code>, i.e. both <code>slice(stop)</code> and <code>slice(start, stop[, step])</code> are supported.
To skip specifying a given argument, one might use <code>None</code>, so that e.g. <code>a[start:]</code> is equivalent to <code>a[slice(start, None)]</code> or <code>a[::-1]</code> is equivalent to <code>a[slice(None, None, -1)]</code>.</p>
<p>While the <code>:</code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()</code> objects simplifies the programmatic generation of slicing.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/tutorial/introduction.html#strings" rel="noreferrer">Python tutorial</a> talks about it (scroll down a bit until you get to the part about slicing).</p>
<p>The ASCII art diagram is helpful too for remembering how slices work:</p>
<pre><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
</code></pre>
<blockquote>
<p>One way to remember how slices work is to think of the indices as pointing <em>between</em> characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of <em>n</em> characters has index <em>n</em>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Enumerating the possibilities allowed by the grammar:</p>
<pre><code>&gt;&gt;&gt; seq[:]                # [seq[0],   seq[1],          ..., seq[-1]    ]
&gt;&gt;&gt; seq[low:]             # [seq[low], seq[low+1],      ..., seq[-1]    ]
&gt;&gt;&gt; seq[:high]            # [seq[0],   seq[1],          ..., seq[high-1]]
&gt;&gt;&gt; seq[low:high]         # [seq[low], seq[low+1],      ..., seq[high-1]]
&gt;&gt;&gt; seq[::stride]         # [seq[0],   seq[stride],     ..., seq[-1]    ]
&gt;&gt;&gt; seq[low::stride]      # [seq[low], seq[low+stride], ..., seq[-1]    ]
&gt;&gt;&gt; seq[:high:stride]     # [seq[0],   seq[stride],     ..., seq[high-1]]
&gt;&gt;&gt; seq[low:high:stride]  # [seq[low], seq[low+stride], ..., seq[high-1]]
</code></pre>
<p>Of course, if <code>(high-low)%stride != 0</code>, then the end point will be a little lower than <code>high-1</code>.</p>
<p>If <code>stride</code> is negative, the ordering is changed a bit since we're counting down:</p>
<pre><code>&gt;&gt;&gt; seq[::-stride]        # [seq[-1],   seq[-1-stride],   ..., seq[0]    ]
&gt;&gt;&gt; seq[high::-stride]    # [seq[high], seq[high-stride], ..., seq[0]    ]
&gt;&gt;&gt; seq[:low:-stride]     # [seq[-1],   seq[-1-stride],   ..., seq[low+1]]
&gt;&gt;&gt; seq[high:low:-stride] # [seq[high], seq[high-stride], ..., seq[low+1]]
</code></pre>
<p>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</p>
<pre><code>&gt;&gt;&gt; class slicee:
...     def __getitem__(self, item):
...         return `item`
...
&gt;&gt;&gt; slicee()[0, 1:2, ::5, ...]
'(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</p>
<pre><code>                +---+---+---+---+---+---+
                | P | y | t | h | o | n |
                +---+---+---+---+---+---+
Slice position: 0   1   2   3   4   5   6
Index position:   0   1   2   3   4   5

&gt;&gt;&gt; p = ['P','y','t','h','o','n']
# Why the two sets of numbers:
# indexing gives items, not lists
&gt;&gt;&gt; p[0]
 'P'
&gt;&gt;&gt; p[5]
 'n'

# Slicing gives lists
&gt;&gt;&gt; p[0:1]
 ['P']
&gt;&gt;&gt; p[0:2]
 ['P','y']
</code></pre>
<p>One heuristic is, for a slice from zero to n, think: "zero is the beginning, start at the beginning and take n items in a list".</p>
<pre><code>&gt;&gt;&gt; p[5] # the last of six items, indexed from zero
 'n'
&gt;&gt;&gt; p[0:5] # does NOT include the last item!
 ['P','y','t','h','o']
&gt;&gt;&gt; p[0:6] # not p[0:5]!!!
 ['P','y','t','h','o','n']
</code></pre>
<p>Another heuristic is, "for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning"</p>
<pre><code>&gt;&gt;&gt; p[0:4] # Start at the beginning and count out 4 items
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4] # Take one item off the front
 ['y','t','h']
&gt;&gt;&gt; p[2:4] # Take two items off the front
 ['t','h']
# etc.
</code></pre>
<p>The first rule of slice assignment is that since slicing <em>returns</em> a list, slice assignment <em>requires</em> a list (or other iterable):</p>
<pre><code>&gt;&gt;&gt; p[2:3]
 ['t']
&gt;&gt;&gt; p[2:3] = ['T']
&gt;&gt;&gt; p
 ['P','y','T','h','o','n']
&gt;&gt;&gt; p[2:3] = 't'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only assign an iterable
</code></pre>
<p>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</p>
<pre><code>&gt;&gt;&gt; p[2:4]
 ['T','h']
&gt;&gt;&gt; p[2:4] = ['t','r']
&gt;&gt;&gt; p
 ['P','y','t','r','o','n']
</code></pre>
<p>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</p>
<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n'] # Start over
&gt;&gt;&gt; p[2:4] = ['s','p','a','m']
&gt;&gt;&gt; p
 ['P','y','s','p','a','m','o','n']
</code></pre>
<p>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around <em>indexing</em> an empty slice:</p>
<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[0:4]
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4]
 ['y','t','h']
&gt;&gt;&gt; p[2:4]
 ['t','h']
&gt;&gt;&gt; p[3:4]
 ['h']
&gt;&gt;&gt; p[4:4]
 []
</code></pre>
<p>And then once you've seen that, slice assignment to the empty slice makes sense too:</p>
<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[2:4] = ['x','y'] # Assigned list is same length as slice
&gt;&gt;&gt; p
 ['P','y','x','y','o','n'] # Result is same length
&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[3:4] = ['x','y'] # Assigned list is longer than slice
&gt;&gt;&gt; p
 ['P','y','t','x','y','o','n'] # The result is longer
&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[4:4] = ['x','y']
&gt;&gt;&gt; p
 ['P','y','t','h','x','y','o','n'] # The result is longer still
</code></pre>
<p>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</p>
<p>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</p>
<pre><code>&gt;&gt;&gt; p = ['P','y','t','h','o','n']
&gt;&gt;&gt; p[0:4]
 ['P','y','t','h']
&gt;&gt;&gt; p[1:4]
 ['y','t','h']
&gt;&gt;&gt; p[2:4]
 ['t','h']
&gt;&gt;&gt; p[3:4]
 ['h']
&gt;&gt;&gt; p[4:4]
 []
&gt;&gt;&gt; p[5:4]
 []
&gt;&gt;&gt; p[6:4]
 []
</code></pre>
<p>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</p>
<pre><code>&gt;&gt;&gt; p[5:3:-1]
 ['n','o']
</code></pre>
<p>There are some weird consequences to the "once you're done, you're done" rule:</p>
<pre><code>&gt;&gt;&gt; p[4:4]
 []
&gt;&gt;&gt; p[5:4]
 []
&gt;&gt;&gt; p[6:4]
 []
&gt;&gt;&gt; p[6]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
<p>In fact, compared to indexing, Python slicing is bizarrely error-proof:</p>
<pre><code>&gt;&gt;&gt; p[100:200]
 []
&gt;&gt;&gt; p[int(2e99):int(1e99)]
 []
</code></pre>
<p>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</p>
<pre><code>&gt;&gt;&gt; p
 ['P', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; p[int(2e99):int(1e99)] = ['p','o','w','e','r']
&gt;&gt;&gt; p
 ['P', 'y', 't', 'h', 'o', 'n', 'p', 'o', 'w', 'e', 'r']
</code></pre>
<p>Depending on your application, that might... or might not... be what you were hoping for there!</p>
<hr/>
<p>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</p>
<pre><code>&gt;&gt;&gt; r=[1,2,3,4]
&gt;&gt;&gt; r[1:1]
[]
&gt;&gt;&gt; r[1:1]=[9,8]
&gt;&gt;&gt; r
[1, 9, 8, 2, 3, 4]
&gt;&gt;&gt; r[1:1]=['blah']
&gt;&gt;&gt; r
[1, 'blah', 9, 8, 2, 3, 4]
</code></pre>
<p>This may also clarify the difference between slicing and indexing.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Explain Python's slice notation</h2>
</blockquote>
<p>In short, the colons (<code>:</code>) in subscript notation (<code>subscriptable[subscriptarg]</code>) make slice notation - which has the optional arguments, <code>start</code>, <code>stop</code>, <code>step</code>:</p>
<pre><code>sliceable[start:stop:step]
</code></pre>
<p>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</p>
<h2>Important Definitions</h2>
<p>To begin with, let's define a few terms:</p>
<blockquote>
<p><strong>start:</strong> the beginning index of the slice, it will include the element at this index unless it is the same as <em>stop</em>, defaults to 0, i.e. the first index. If it's negative, it means to start <code>n</code> items from the end.</p>
<p><strong>stop:</strong> the ending index of the slice, it does <em>not</em> include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</p>
<p><strong>step:</strong> the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</p>
</blockquote>
<h2>How Indexing Works</h2>
<p>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the <em>start</em> and <em>stop</em>, and for the <em>step</em>, you simply decrement your index. This example is <a href="https://docs.python.org/2/tutorial/introduction.html" rel="noreferrer">from the documentation's tutorial</a>, but I've modified it slightly to indicate which item in a sequence each index references:</p>
<pre><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
   0   1   2   3   4   5 
  -6  -5  -4  -3  -2  -1
</code></pre>
<h2>How Slicing Works</h2>
<p>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="noreferrer">implement the <code>__getitem__</code> method of the sequence, according to the Python data model</a>.)</p>
<p>Slice notation works like this:</p>
<pre><code>sequence[start:stop:step]
</code></pre>
<p>And recall that there are defaults for <em>start</em>, <em>stop</em>, and <em>step</em>, so to access the defaults, simply leave out the argument.</p>
<p>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</p>
<pre><code>my_list[-9:]
</code></pre>
<p>When I see this, I read the part in the brackets as "9th from the end, to the end." (Actually, I abbreviate it mentally as "-9, on")</p>
<h2>Explanation:</h2>
<p>The full notation is </p>
<pre><code>my_list[-9:None:None]
</code></pre>
<p>and to substitute the defaults (actually when <code>step</code> is negative, <code>stop</code>'s default is <code>-len(my_list) - 1</code>, so <code>None</code> for stop really just means it goes to whichever end step takes it to):</p>
<pre><code>my_list[-9:len(my_list):1]
</code></pre>
<p>The <strong>colon</strong>, <code>:</code>,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</p>
<pre><code>list_copy = sequence[:]
</code></pre>
<p>And clearing them is with:</p>
<pre><code>del my_list[:]
</code></pre>
<p>(Python 3 gets a <code>list.copy</code> and <code>list.clear</code> method.)</p>
<h3>When <code>step</code> is negative, the defaults for <code>start</code> and <code>stop</code> change</h3>
<p>By default, when the <code>step</code> argument is empty (or <code>None</code>), it is assigned to <code>+1</code>.</p>
<p>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</p>
<p>Thus a negative slice will change the defaults for <code>start</code> and <code>stop</code>!</p>
<h3>Confirming this in the source</h3>
<p>I like to encourage users to read the source as well as the documentation. The <a href="https://github.com/python/cpython/blob/master/Objects/sliceobject.c" rel="noreferrer">source code for slice objects and this logic is found here</a>. First we determine if <code>step</code> is negative:</p>
<blockquote>
<pre><code> step_is_negative = step_sign &lt; 0;
</code></pre>
</blockquote>
<p>If so, the lower bound is <code>-1</code>  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this <code>-1</code> is <em>different</em> from a <code>-1</code> that users may pass indexes in Python indicating the last item.)</p>
<blockquote>
<pre><code>if (step_is_negative) {
    lower = PyLong_FromLong(-1L);
    if (lower == NULL)
        goto error;

    upper = PyNumber_Add(length, lower);
    if (upper == NULL)
        goto error;
}
</code></pre>
</blockquote>
<p>Otherwise <code>step</code> is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</p>
<blockquote>
<pre><code>else {
    lower = _PyLong_Zero;
    Py_INCREF(lower);
    upper = length;
    Py_INCREF(upper);
}
</code></pre>
</blockquote>
<p>Then, we may need to apply the defaults for <code>start</code> and <code>stop</code> - the default then for <code>start</code> is calculated as the upper bound when <code>step</code> is negative:</p>
<blockquote>
<pre><code>if (self-&gt;start == Py_None) {
    start = step_is_negative ? upper : lower;
    Py_INCREF(start);
}
</code></pre>
</blockquote>
<p>and <code>stop</code>, the lower bound:</p>
<blockquote>
<pre><code>if (self-&gt;stop == Py_None) {
    stop = step_is_negative ? lower : upper;
    Py_INCREF(stop);
}
</code></pre>
</blockquote>
<h1>Give your slices a descriptive name!</h1>
<p>You may find it useful to separate forming the slice from passing it to the <code>list.__getitem__</code> method (<a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="noreferrer">that's what the square brackets do</a>). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</p>
<p>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</p>
<pre><code>last_nine_slice = slice(-9, None)
</code></pre>
<p>The second argument, <code>None</code>, is required, so that the first argument is interpreted as the <code>start</code> argument <a href="https://docs.python.org/2/library/functions.html#slice" rel="noreferrer">otherwise it would be the <code>stop</code> argument</a>. </p>
<p>You can then pass the slice object to your sequence:</p>
<pre><code>&gt;&gt;&gt; list(range(100))[last_nine_slice]
[91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>It's interesting that ranges also take slices:</p>
<pre><code>&gt;&gt;&gt; range(100)[last_nine_slice]
range(91, 100)
</code></pre>
<h1>Memory Considerations:</h1>
<p>Since slices of Python lists create new objects in memory, another important function to be aware of is <code>itertools.islice</code>. Typically you'll want to iterate over a slice, not just have it created statically in memory. <code>islice</code> is perfect for this. A caveat, it doesn't support negative arguments to <code>start</code>, <code>stop</code>, or <code>step</code>, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</p>
<pre><code>length = 100
last_nine_iter = itertools.islice(list(range(length)), length-9, None, 1)
list_last_nine = list(last_nine_iter)
</code></pre>
<p>and now:</p>
<pre><code>&gt;&gt;&gt; list_last_nine
[91, 92, 93, 94, 95, 96, 97, 98, 99]
</code></pre>
<p>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy. </p>
</div>
<div class="post-text" itemprop="text">
<p>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</p>
<pre><code>&gt;&gt;&gt; x = [1,2,3,4,5,6]
&gt;&gt;&gt; x[::-1]
[6,5,4,3,2,1]
</code></pre>
<p>Easy way to reverse sequences!</p>
<p>And if you wanted, for some reason, every second item in the reversed sequence:</p>
<pre><code>&gt;&gt;&gt; x = [1,2,3,4,5,6]
&gt;&gt;&gt; x[::-2]
[6,4,2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7</p>
<p>Slicing in Python</p>
<pre><code>[a:b:c]

len = length of string, tuple or list

c -- default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward.

a --  When c is positive or blank, default is 0. When c is negative, default is -1.

b --  When c is positive or blank, default is len. When c is negative, default is -(len+1).
</code></pre>
<p>Understanding index assignment is very important.</p>
<pre><code>In forward direction, starts at 0 and ends at len-1

In backward direction, starts at -1 and ends at -len
</code></pre>
<p>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</p>
<pre><code>-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1
</code></pre>
<p>But this range continues in both directions infinitely:</p>
<pre><code>...,-len -2 ,-len-1,-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1, len, len +1, len+2 , ....
</code></pre>
<p>For example:</p>
<pre><code>             0    1    2   3    4   5   6   7   8   9   10   11
             a    s    t   r    i   n   g
    -9  -8  -7   -6   -5  -4   -3  -2  -1
</code></pre>
<p>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</p>
<p>One last thing: if a and b are equal, then also you get an empty list:</p>
<pre><code>&gt;&gt;&gt; l1
[2, 3, 4]

&gt;&gt;&gt; l1[:]
[2, 3, 4]

&gt;&gt;&gt; l1[::-1] # a default is -1 , b default is -(len+1)
[4, 3, 2]

&gt;&gt;&gt; l1[:-4:-1] # a default is -1
[4, 3, 2]

&gt;&gt;&gt; l1[:-3:-1] # a default is -1
[4, 3]

&gt;&gt;&gt; l1[::] # c default is +1, so a default is 0, b default is len
[2, 3, 4]

&gt;&gt;&gt; l1[::-1] # c is -1 , so a default is -1 and b default is -(len+1)
[4, 3, 2]


&gt;&gt;&gt; l1[-100:-200:-1] # Interesting
[]

&gt;&gt;&gt; l1[-1:-200:-1] # Interesting
[4, 3, 2]


&gt;&gt;&gt; l1[-1:-1:1]
[]


&gt;&gt;&gt; l1[-1:5:1] # Interesting
[4]


&gt;&gt;&gt; l1[1:-7:1]
[]

&gt;&gt;&gt; l1[1:-7:-1] # Interesting
[3, 2]

&gt;&gt;&gt; l1[:-2:-2] # a default is -1, stop(b) at -2 , step(c) by 2 in reverse direction
[4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Found this great table at <a href="http://wiki.python.org/moin/MovingToPythonFromOtherLanguages" rel="noreferrer">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>
<pre><code>Python indexes and slices for a six-element list.
Indexes enumerate the elements, slices enumerate the spaces between the elements.

Index from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]
Index from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]
                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]
                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]
                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]
Slice from front:  :   1   2   3   4   5   :    a[-2]==4
Slice from rear:   :  -5  -4  -3  -2  -1   :
                                                b=a[:]
                                                b==[0,1,2,3,4,5] (shallow copy of a)</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a <code>for</code> loop...</p>
<pre><code>(from:to:step)
</code></pre>
<p>Any of them are optional:</p>
<pre><code>(:to:step)
(from::step)
(from:to)
</code></pre>
<p>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</p>
<p>This works for me anyway...</p>
</div>
<div class="post-text" itemprop="text">
<p>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</p>
<p>It's instructive to understand <code>range()</code> first:</p>
<pre><code>def range(start=0, stop, step=1):  # Illegal syntax, but that's the effect
    i = start
    while (i &lt; stop if step &gt; 0 else i &gt; stop):
        yield i
        i += step
</code></pre>
<p>Begin from <code>start</code>, increment by <code>step</code>, do not reach <code>stop</code>.  Very simple.</p>
<p>The thing to remember about negative step is that <code>stop</code> is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. <code>'abcde'[1:-2][::-1]</code> slices off one char from left, two from right, then reverses. (See also <a href="http://www.python.org/dev/peps/pep-0322/" rel="noreferrer"><code>reversed()</code></a>.)</p>
<p>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</p>
<p><strong>TODO</strong>: The code below had a bug with "never go outside the sequence" when abs(step)&gt;1; I <em>think</em> I patched it to be correct, but it's hard to understand.</p>
<pre><code>def this_is_how_slicing_works(seq, start=None, stop=None, step=1):
    if start is None:
        start = (0 if step &gt; 0 else len(seq)-1)
    elif start &lt; 0:
        start += len(seq)
    if not 0 &lt;= start &lt; len(seq):  # clip if still outside bounds
        start = (0 if step &gt; 0 else len(seq)-1)
    if stop is None:
        stop = (len(seq) if step &gt; 0 else -1)  # really -1, not last element
    elif stop &lt; 0:
        stop += len(seq)
    for i in range(start, stop, step):
        if 0 &lt;= i &lt; len(seq):
            yield seq[i]
</code></pre>
<p>Don't worry about the <code>is None</code> details - just remember that omitting <code>start</code> and/or <code>stop</code> always does the right thing to give you the whole sequence.</p>
<p>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: <code>'abcde'[1:-2] == 'abcde'[1:3] == 'bc'</code> despite <code>range(1,-2) == []</code>.
The normalization is sometimes thought of as "modulo the length", but note it adds the length just once: e.g. <code>'abcde'[-53:42]</code> is just the whole string.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>Index:
      ------------&gt;
  0   1   2   3   4
+---+---+---+---+---+
| a | b | c | d | e |
+---+---+---+---+---+
  0  -4  -3  -2  -1
      &lt;------------

Slice:
    &lt;---------------|
|---------------&gt;
:   1   2   3   4   :
+---+---+---+---+---+
| a | b | c | d | e |
+---+---+---+---+---+
:  -4  -3  -2  -1   :
|---------------&gt;
    &lt;---------------|
</code></pre>
<p>I hope this will help you to model the list in Python.</p>
<p>Reference: <a href="http://wiki.python.org/moin/MovingToPythonFromOtherLanguages" rel="noreferrer">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I use the "an index points between elements" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</p>
<pre><code>mylist[X:Y]
</code></pre>
<p>X is the index of the first element you want.<br/>
Y is the index of the first element you <em>don't</em> want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python slicing notation:</p>
<pre><code>a[start:end:step]
</code></pre>
<ul>
<li>For <code>start</code> and <code>end</code>, negative values are interpreted as being relative to the end of the sequence.</li>
<li>Positive indices for <code>end</code> indicate the position <em>after</em> the last element to be included.</li>
<li>Blank values are defaulted as follows: <code>[+0:-0:1]</code>.</li>
<li>Using a negative step reverses the interpretation of <code>start</code> and <code>end</code></li>
</ul>
<p>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</p>
<pre><code>m[::,0:2:] ## slice the first two columns
</code></pre>
<p>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use <a href="https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python"><code>deepcopy()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is how I teach slices to newbies:</p>
<p><strong>Understanding difference between indexing and slicing:</strong></p>
<p>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/o99aU.png"/></p>
<p>It is a list with 6 elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</p>
<p>Indexing is like dealing with the contents of box. You can check contents of any box. But You can't check contents of multiple boxes at once. You can even replace contents of the box. But You can't place 2 balls in 1 box or replace 2 balls at a time.</p>
<pre><code>In [122]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [123]: alpha
Out[123]: ['a', 'b', 'c', 'd', 'e', 'f']

In [124]: alpha[0]
Out[124]: 'a'

In [127]: alpha[0] = 'A'

In [128]: alpha
Out[128]: ['A', 'b', 'c', 'd', 'e', 'f']

In [129]: alpha[0,1]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-129-c7eb16585371&gt; in &lt;module&gt;()
----&gt; 1 alpha[0,1]

TypeError: list indices must be integers, not tuple
</code></pre>
<p>Slicing is like dealing with boxes itself. You can pickup first box and place it on another table. To pickup the box all You need to know is the position of beginning  &amp; ending of the box.</p>
<p>You can even pickup first 3 boxes or last 2 boxes or all boxes between 1 &amp; 4. So, You can pick any set of boxes if You know beginning &amp; ending. This positions are called start &amp; stop positions.</p>
<p>The interesting thing is that You can replace multiple boxes at once. Also You can place multiple boxes where ever You like.</p>
<pre><code>In [130]: alpha[0:1]
Out[130]: ['A']

In [131]: alpha[0:1] = 'a'

In [132]: alpha
Out[132]: ['a', 'b', 'c', 'd', 'e', 'f']

In [133]: alpha[0:2] = ['A', 'B']

In [134]: alpha
Out[134]: ['A', 'B', 'c', 'd', 'e', 'f']

In [135]: alpha[2:2] = ['x', 'xx']

In [136]: alpha
Out[136]: ['A', 'B', 'x', 'xx', 'c', 'd', 'e', 'f']
</code></pre>
<p><strong>Slicing With Step:</strong></p>
<p>Till now You have picked boxes continuously. But some times You need to pickup discretely. For example You can pickup every second box. You can even pickup every third box from the end. This value is called step size. This represents the gap between Your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</p>
<pre><code>In [137]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [142]: alpha[1:5:2] 
Out[142]: ['b', 'd']

In [143]: alpha[-1:-5:-2]
Out[143]: ['f', 'd']

In [144]: alpha[1:5:-2]
Out[144]: []

In [145]: alpha[-1:-5:2]      
Out[145]: []
</code></pre>
<p><strong>How Python Figures Out Missing Parameters:</strong></p>
<p>When slicing if You leave out any parameter, Python tries to figure it out automatically.</p>
<p>If You check source code of CPython, You will find a function called PySlice_GetIndicesEx which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</p>
<p>This function takes a Python object &amp; optional parameters for slicing and returns start, stop, step &amp; slice length for the requested slice.</p>
<pre><code>def py_slice_get_indices_ex(obj, start=None, stop=None, step=None):

    length = len(obj)

    if step is None:
        step = 1
    if step == 0:
        raise Exception("Step cannot be zero.")

    if start is None:
        start = 0 if step &gt; 0 else length - 1
    else:
        if start &lt; 0:
            start += length
        if start &lt; 0:
            start = 0 if step &gt; 0 else -1
        if start &gt;= length:
            start = length if step &gt; 0 else length - 1

    if stop is None:
        stop = length if step &gt; 0 else -1
    else:
        if stop &lt; 0:
            stop += length
        if stop &lt; 0:
            stop = 0 if step &gt; 0 else -1
        if stop &gt;= length:
            stop = length if step &gt; 0 else length - 1

    if (step &lt; 0 and stop &gt;= start) or (step &gt; 0 and start &gt;= stop):
        slice_length = 0
    elif step &lt; 0:
        slice_length = (stop - start + 1)/(step) + 1
    else:
        slice_length = (stop - start - 1)/(step) + 1

    return (start, stop, step, slice_length)
</code></pre>
<p>This is the intelligence that is present behind slices. Since Python has inbuilt function called slice, You can pass some parameters &amp; check how smartly it calculates missing parameters.</p>
<pre><code>In [21]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']

In [22]: s = slice(None, None, None)

In [23]: s
Out[23]: slice(None, None, None)

In [24]: s.indices(len(alpha)) 
Out[24]: (0, 6, 1)

In [25]: range(*s.indices(len(alpha)))
Out[25]: [0, 1, 2, 3, 4, 5]

In [26]: s = slice(None, None, -1) 

In [27]: range(*s.indices(len(alpha)))
Out[27]: [5, 4, 3, 2, 1, 0]

In [28]: s = slice(None, 3, -1)        

In [29]: range(*s.indices(len(alpha)))
Out[29]: [5, 4]
</code></pre>
<p><strong>Note:</strong> This post is originally written in my blog <a href="http://www.avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html" rel="noreferrer">http://www.avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This is just for some extra info...
Consider the list below </p>
<pre><code>&gt;&gt;&gt; l=[12,23,345,456,67,7,945,467]
</code></pre>
<p>Few other tricks for reversing the list:</p>
<pre><code>&gt;&gt;&gt; l[len(l):-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[:-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[len(l)::-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[::-1]
[467, 945, 7, 67, 456, 345, 23, 12]

&gt;&gt;&gt; l[-1:-len(l)-1:-1]
[467, 945, 7, 67, 456, 345, 23, 12]
</code></pre>
<p>See abc's answer above</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use slice assignment to remove one or more elements from a list:</p>
<pre><code>r = [1, 'blah', 9, 8, 2, 3, 4]
&gt;&gt;&gt; r[1:4] = []
&gt;&gt;&gt; r
[1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you’ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</p>
<pre><code>&gt;&gt;&gt; items = [0, 1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; a = slice(2, 4)
&gt;&gt;&gt; items[2:4]
[2, 3]
&gt;&gt;&gt; items[a]
[2, 3]
&gt;&gt;&gt; items[a] = [10,11]
&gt;&gt;&gt; items
[0, 1, 10, 11, 4, 5, 6]
&gt;&gt;&gt; del items[a]
&gt;&gt;&gt; items
[0, 1, 4, 5, 6]
</code></pre>
<p>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; a = slice(10, 50, 2)
&gt;&gt;&gt; a.start
10
&gt;&gt;&gt; a.stop
50
&gt;&gt;&gt; a.step
2
&gt;&gt;&gt;
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<h1>1. Slice Notation</h1>
<p>To make it simple, remember <strong>slice has only one form：</strong></p>
<pre><code>s[start:end:step]
</code></pre>
<p>and here is how it works:</p>
<ul>
<li><code>s</code>: an object that can be sliced</li>
<li><code>start</code>: first index to start iteration</li>
<li><code>end</code>: last index, <strong>NOTE that <code>end</code> index will not be included in the resulted slice</strong></li>
<li><code>step</code>: pick element every <code>step</code> index</li>
</ul>
<p>Another import thing: <strong>all <code>start</code>,<code>end</code>, <code>step</code> can be omitted!</strong> And if they are omitted, their default value will be used: <code>0</code>,<code>len(s)</code>,<code>1</code> accordingly.</p>
<p>So possible variations are:</p>
<pre><code># mostly used variations
s[start:end]
s[start:]
s[:end]

# step related variations
s[:end:step]
s[start::step]
s[::step]

# make a copy
s[:]
</code></pre>
<p>NOTE: If <code>start&gt;=end</code>(considering only when <code>step&gt;0</code>), python will return a empty slice <code>[]</code>.</p>
<h1>2. Pitfalls</h1>
<p>The above part explains the core features on how slice works, it will work on most occasions. However there can be pitfalls you should watch out, and this part explains them.</p>
<h2>Negative indexes</h2>
<p>The very first thing confuses python learners is that <strong>index can be negative!</strong> 
Don't panic: <strong>negative index means count from backwards.</strong></p>
<p>For example:</p>
<pre><code>s[-5:]    # start at the 5th index from the end of array, 
          # thus returns the last 5 elements
s[:-5]    # start at index 0, end until the 5th index from end of array, 
          # thus returns s[0:len(s)-5]
</code></pre>
<h2>Negative step</h2>
<p>Make things more confusing is that <strong><code>step</code> can be negative too!</strong> </p>
<p><strong>Negative step means iterate the array backwards: from end to start, with end index included, and start index excluded from result.</strong></p>
<p><strong>NOTE</strong>: when step is negative, the default value for <code>start</code> to <code>len(s)</code>(while <code>end</code> does not equal to <code>0</code>, because <code>s[::-1]</code> contains <code>s[0]</code>). For example:</p>
<pre><code>s[::-1]            # reversed slice
s[len(s)::-1]      # same as above, reversed slice
s[0:len(s):-1]     # empty list
</code></pre>
<h2>Out of range error?</h2>
<p>Be surprised: <strong>slice does not raise IndexError when index is out of range!</strong></p>
<p>If the index is out of range, python will try its best set the index to <code>0</code> or <code>len(s)</code> according to the situation. For example:</p>
<pre><code>s[:len(s)+5]      # same as s[:len(s)]
s[-len(s)-5::]    # same as s[0:]
s[len(s)+5::-1]   # same as s[len(s)::-1], same as s[::-1]
</code></pre>
<h1>3. Examples</h1>
<p>Let's finish this answer with examples explains everything we have discussed:</p>
<pre><code># create our array for demonstration
In [1]: s = [i for i in range(10)]

In [2]: s
Out[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [3]: s[2:]   # from index 2 to last index
Out[3]: [2, 3, 4, 5, 6, 7, 8, 9]

In [4]: s[:8]   # from index 0 up to index 8
Out[4]: [0, 1, 2, 3, 4, 5, 6, 7]

In [5]: s[4:7]  # from index 4(included) up to index 7(excluded)
Out[5]: [4, 5, 6]

In [6]: s[:-2]  # up to second last index(negative index)
Out[6]: [0, 1, 2, 3, 4, 5, 6, 7]

In [7]: s[-2:]  # from second last index(negative index)
Out[7]: [8, 9]

In [8]: s[::-1] # from last to first in reverse order(negative step)
Out[8]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

In [9]: s[::-2] # all odd numbers in reversed order
Out[9]: [9, 7, 5, 3, 1]

In [11]: s[-2::-2] # all even numbers in reversed order
Out[11]: [8, 6, 4, 2, 0]

In [12]: s[3:15]   # end is out of range, python will set it to len(s)
Out[12]: [3, 4, 5, 6, 7, 8, 9]

In [14]: s[5:1]    # start &gt; end, return empty list
Out[14]: []

In [15]: s[11]     # access index 11(greater than len(s)) will raise IndexError
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&lt;ipython-input-15-79ffc22473a3&gt; in &lt;module&gt;()
----&gt; 1 s[11]

IndexError: list index out of range
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answers above don't discuss multi-dimentional array slicing which is possible using the famous numpy package:</p>
<p><strong>Slicing also apply to multi-dimentional arrays.</strong></p>
<pre><code># Here, a is a numpy array

&gt;&gt;&gt; a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; a[:2,0:3:2]
array([[1, 3],
       [5, 7]])
</code></pre>
<p>The ":2" before comma operates on the first dimension and the "0:3:2" after the comma operates on the second dimension.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/env python

def slicegraphical(s, lista):

    if len(s) &gt; 9:
        print """Enter a string of maximum 9 characters,
    so the printig would looki nice"""
        return 0;
    # print " ",
    print '  '+'+---' * len(s) +'+'
    print ' ',
    for letter in s:
        print '| {}'.format(letter),
    print '|'
    print " ",; print '+---' * len(s) +'+'

    print " ",
    for letter in range(len(s) +1):
        print '{}  '.format(letter),
    print ""
    for letter in range(-1*(len(s)), 0):
        print ' {}'.format(letter),
    print ''
    print ''


    for triada in lista:
        if len(triada) == 3:
            if triada[0]==None and triada[1] == None and triada[2] == None:
                # 000
                print s+'[   :   :   ]' +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] == None and triada[2] != None:
                # 001
                print s+'[   :   :{0:2d} ]'.format(triada[2], '','') +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] != None and triada[2] == None:
                # 010
                print s+'[   :{0:2d} :   ]'.format(triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] == None and triada[1] != None and triada[2] != None:
                # 011
                print s+'[   :{0:2d} :{1:2d} ]'.format(triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] == None and triada[2] == None:
                # 100
                print s+'[{0:2d} :   :   ]'.format(triada[0]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] == None and triada[2] != None:
                # 101
                print s+'[{0:2d} :   :{1:2d} ]'.format(triada[0], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] != None and triada[2] == None:
                # 110
                print s+'[{0:2d} :{1:2d} :   ]'.format(triada[0], triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]
            elif triada[0] != None and triada[1] != None and triada[2] != None:
                # 111
                print s+'[{0:2d} :{1:2d} :{2:2d} ]'.format(triada[0], triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]

        elif len(triada) == 2:
            if triada[0] == None and triada[1] == None:
                # 00
                print s+'[   :   ]    ' + ' = ', s[triada[0]:triada[1]]
            elif triada[0] == None and triada[1] != None:
                # 01
                print s+'[   :{0:2d} ]    '.format(triada[1]) + ' = ', s[triada[0]:triada[1]]
            elif triada[0] != None and triada[1] == None:
                # 10
                print s+'[{0:2d} :   ]    '.format(triada[0]) + ' = ', s[triada[0]:triada[1]]
            elif triada[0] != None and triada[1] != None:
                # 11
                print s+'[{0:2d} :{1:2d} ]    '.format(triada[0],triada[1]) + ' = ', s[triada[0]:triada[1]]

        elif len(triada) == 1:
            print s+'[{0:2d} ]        '.format(triada[0]) + ' = ', s[triada[0]]


if __name__ == '__main__':
    # Change "s" to what ever string you like, make it 9 characters for
    # better representation.
    s = 'COMPUTERS'

    # add to this list different lists to experement with indexes
    # to represent ex. s[::], use s[None, None,None], otherwise you get an error
    # for s[2:] use s[2:None]

    lista = [[4,7],[2,5,2],[-5,1,-1],[4],[-4,-6,-1], [2,-3,1],[2,-3,-1], [None,None,-1],[-5,None],[-5,0,-1],[-5,None,-1],[-1,1,-2]]

    slicegraphical(s, lista)
</code></pre>
<p>You can run this script and experiment with it, below is some samples that I got from the script.</p>
<pre><code>  +---+---+---+---+---+---+---+---+---+
  | C | O | M | P | U | T | E | R | S |
  +---+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6   7   8   9   
 -9  -8  -7  -6  -5  -4  -3  -2  -1 

COMPUTERS[ 4 : 7 ]     =  UTE
COMPUTERS[ 2 : 5 : 2 ] =  MU
COMPUTERS[-5 : 1 :-1 ] =  UPM
COMPUTERS[ 4 ]         =  U
COMPUTERS[-4 :-6 :-1 ] =  TU
COMPUTERS[ 2 :-3 : 1 ] =  MPUT
COMPUTERS[ 2 :-3 :-1 ] =  
COMPUTERS[   :   :-1 ] =  SRETUPMOC
COMPUTERS[-5 :   ]     =  UTERS
COMPUTERS[-5 : 0 :-1 ] =  UPMO
COMPUTERS[-5 :   :-1 ] =  UPMOC
COMPUTERS[-1 : 1 :-2 ] =  SEUM
[Finished in 0.9s]
</code></pre>
<p>When using a negative step, notice that the answer is shifted to the right by 1.</p>
</div>
<div class="post-text" itemprop="text">
<p>My brain seems happy to accept that <code>lst[start:end]</code> contains the <code>start</code>-th item. I might even say that it is a 'natural assumption'.</p>
<p>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the <code>end</code>-th element.</p>
<p>In these moments I rely on this simple theorem:</p>
<pre><code>for any n,    lst = lst[:n] + lst[n:]
</code></pre>
<p>This pretty property tells me that <code>lst[start:end]</code> does not contain the <code>end</code>-th item because it is in <code>lst[end:]</code>.</p>
<p>Note that this theorem is true for any <code>n</code> at all. For example, you can check that</p>
<pre><code>lst = range(10)
lst[:-42] + lst[-42:] == lst
</code></pre>
<p>returns <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, the most basic form for slicing is the following:</p>
<p><code>l[start:end]</code></p>
<p>where <code>l</code> is some collection, <code>start</code> is an inclusive index and <code>end</code> is an exclusive index.</p>
<pre><code>In [1]: l = list(range(10))

In [2]: l[:5] # first five elements
Out[2]: [0, 1, 2, 3, 4]

In [3]: l[-5:] # last five elements
Out[3]: [5, 6, 7, 8, 9]
</code></pre>
<p>When slicing from start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</p>
<pre><code>In [5]: l[:3] == l[0:3]
Out[5]: True

In [6]: l[7:] == l[7:len(l)]
Out[6]: True
</code></pre>
<p>Negative integers are useful when doing offsets relative to the end of a collection:</p>
<pre><code>In [7]: l[:-1] # include all elements but the last one
Out[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8]

In [8]: l[-3:] # take the last 3 elements
Out[8]: [7, 8, 9]
</code></pre>
<p>It is possible to provide indices that are out of bounds when slicing such as:</p>
<pre><code>In [9]: l[:20] # 20 is out of index bounds, l[20] will raise an IndexError exception
Out[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [11]: l[-20:] # -20 is out of index bounds, l[-20] will raise an IndexError exception
Out[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignment do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</p>
<pre><code>In [16]: l[2:6] = list('abc') # assigning less elements than the ones contained in the sliced collection l[2:6]

In [17]: l
Out[17]: [0, 1, 'a', 'b', 'c', 6, 7, 8, 9]

In [18]: l[2:5] = list('hello') # assigning more elements than the ones contained in the sliced collection l [2:5]

In [19]: l
Out[19]: [0, 1, 'h', 'e', 'l', 'l', 'o', 6, 7, 8, 9]
</code></pre>
<p>If you omit the start and end index, you will make a copy of the collection:</p>
<pre><code>In [14]: l_copy = l[:]

In [15]: l == l_copy and l is not l_copy
Out[15]: True
</code></pre>
<p>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</p>
<pre><code>In [20]: l[:] = list('hello...')

In [21]: l
Out[21]: ['h', 'e', 'l', 'l', 'o', '.', '.', '.']
</code></pre>
<p>Besides basic slicing, it is also possible to apply the following notation:</p>
<pre><code>l[start:end:step]
</code></pre>
<p>where <code>l</code> is a collection, <code>start</code> is an inclusive index, <code>end</code> is an exclusive index, and <code>step</code> is a stride that can be used to take every <em>nth</em> item in <code>l</code>.</p>
<pre><code>In [22]: l = list(range(10))

In [23]: l[::2] # take the elements which indexes are even
Out[23]: [0, 2, 4, 6, 8]

In [24]: l[1::2] # take the elements which indexes are odd
Out[24]: [1, 3, 5, 7, 9]
</code></pre>
<p>Using <code>step</code> provides a useful trick to reverse a collection in Python:</p>
<pre><code>In [25]: l[::-1]
Out[25]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<p>It is also possible to use negative integers for <code>step</code> as the following example:</p>
<pre><code>In[28]:  l[::-2]
Out[28]: [9, 7, 5, 3, 1]
</code></pre>
<p>However, using a negative value for <code>step</code> could become very confusing. Moreover, in order to be Pythonic, you should avoid using <code>start</code>, <code>end</code>, and <code>step</code> in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</p>
<pre><code>In [29]: l = l[::2] # this step is for striding

In [30]: l
Out[30]: [0, 2, 4, 6, 8]

In [31]: l = l[1:-1] # this step is for slicing

In [32]: l
Out[32]: [2, 4, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Most of the above answers clears about Slice notation.
Extended indexing syntax used for slicing is <code>aList[start:stop:step]</code>
basic examples are</p>
<p><a href="https://i.stack.imgur.com/IVkET.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/IVkET.jpg"/></a>:</p>
<p>More Slicing examples: <a href="https://docs.python.org/2.3/whatsnew/section-slices.html" rel="noreferrer">15 Extended Slices</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The below is the example of index of a string</p>
<pre><code> +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1

str="Name string"
</code></pre>
<p>slicing example: [start:end:step] </p>
<pre><code>str[start:end] # items start through end-1
str[start:]    # items start through the rest of the array
str[:end]      # items from the beginning through end-1
str[:]         # a copy of the whole array
</code></pre>
<p>Below is the example usage </p>
<pre><code>print str[0]=N
print str[0:2]=Na
print str[0:7]=Name st
print str[0:7:2]=Nm t
print str[0:-1:2]=Nm ti
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I want to add one Hello world example that explains the basics of slices for the very beginners. It helped me a lot.</p>
<p>Let's have a list with six values <code>['P', 'Y', 'T', 'H', 'O', 'N']</code>:</p>
<pre><code>+---+---+---+---+---+---+
| P | Y | T | H | O | N |
+---+---+---+---+---+---+
  0   1   2   3   4   5 
</code></pre>
<p>Now the simplest slices of that list are its sublists. The notation is <code>[&lt;index&gt;:&lt;index&gt;]</code> and the key is to read it like this:</p>
<pre><code>[ start cutting before this index : end cutting before this index ]
</code></pre>
<p>Now if you make a slice <code>[2:5]</code> of the list above, this will happen:</p>
<pre><code>        |           |
+---+---|---+---+---|---+
| P | Y | T | H | O | N |
+---+---|---+---+---|---+
  0   1 | 2   3   4 | 5 
</code></pre>
<p>You made a cut <strong>before</strong> the element with index <code>2</code> and another cut <strong>before</strong> the element with index <code>5</code>. So the result will be a slice between those two cuts, a list <code>['T', 'H', 'O']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hehehe, it is kind of strange to see myself trying to provide a better and simpler explanation after 2600+ votes on what's been marked as the right answer from Grew Hewgill.</p>
<p>Here we go ...</p>
<p>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</p>
<p>Let's work with the following string ...</p>
<pre><code>azString = "abcdefghijklmnopqrstuvwxyz"
</code></pre>
<p>For those who don't know, you can create any substring from <code>azString</code> using the notation <code>azString[x:y]</code></p>
<p>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</p>
<p>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</p>
<p>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as <code>azString[index1, index2]</code> or even more clearer as <code>azString[index_of_first_character, index_after_the_last_character]</code>.</p>
<p>Here is an example visualization of that ...</p>
<p><code>
Letters   a b c d e f g h i j ...
         ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
Indexes  0 1 2 3 4 5 6 7 8 9 ... 
             |           |
cdefgh    index1       index2
</code></p>
<p>So all you have to do if to set index1 and index2 to the values that will surround the desired substring. For instance, to get the substring "cdefgh", you can use <code>azString[2:8]</code> because the index on the left side of "c" is 2 and the one on the right size of "h" is 8.</p>
<p>Remember, we are setting the boundaries.</p>
<p>That trick works all the time and is easy to memorize.</p>
<p>Hopefuly this will help.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Slice</strong> :-  snake appears near your foot. It moves from the invisible to the visible. Our vision reveals (like a slice) only a part of the world.
similarly A Python slice extracts elements, based on a start and stop. We take slices on many types in Python. We specify an optional first index, an optional last index, and an optional step.</p>
<pre><code>values[1:3]  Index 1 through index 3.
values[2:-1] Index 2 through index one from last.
values[:2]   Start through index 2.
values[2:]   Index 2 through end.
values[::2]  Start through end, skipping ahead 2 places each time.
</code></pre>
<p>you can get good examples at below link:-
<a href="https://docs.python.org/2.3/whatsnew/section-slices.html" rel="nofollow noreferrer">python slice notation example</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you feel negative indices in slicing is confusing, here's very easy way to think about it: just replace negative index with <code>len - index</code>. So for example, replace -3 with <code>len(list) - 3</code>. </p>
<p>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</p>
<pre><code>def slice(list, start = None, end = None, step = 1):
  # take care of missing start/end parameters
  start = 0 if start is None else start
  end = len(list) if end is None else end

  # take care of negative start/end parameters
  start = len(list) + start if start &lt; 0 else start
  end = len(list) + end if end &lt; 0 else end

  # now just execute for-loop with start, end and step
  return [list[i] for i in range(start, end, step)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</p>
<p>First, we will create a list of values to use in our slicing.</p>
<p>Create two lists to slice, the first is a numeric list from 1 to 9 (List A).
The second is also a numeric list, from 0 to 9 (List B)</p>
<pre><code>A = list(range(1,10,1)) # start,stop,step
B = list(range(9))

print("This is List A:",A)
print("This is List B:",B)
</code></pre>
<p>Index the number 3 from A and the number 6 from B.</p>
<pre><code>print(A[2])
print(B[6])
</code></pre>
<p><strong>Basic Slicing</strong></p>
<p>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation</p>
<p>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</p>
<p>It is important to note, the first element is index 0, NOT index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc).</p>
<p>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</p>
<pre><code>A[:]
</code></pre>
<p>To retrieve a subset of elements, the start and stop positions need to be defined.</p>
<p>Given the pattern aList[start:stop], retrieve the first two elements from List A</p>
</div>
<div class="post-text" itemprop="text">
<p>It is easy to understand if we could relate slicing to <code>range</code>, which gives the indexes. We can categorize slicing into the following two categories:</p>
<hr/>
<h2>1. No step or step &gt; 0. For example, <code>[i:j]</code> or <code>[i:j:k]</code> (k&gt;0)</h2>
<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>
<ul>
<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>
</ul>
<p>For example, <code>[0:3:2] -&gt; range(0,3,2) -&gt; 0, 2</code></p>
<ul>
<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)</code> or <code>j=len(s)</code></li>
</ul>
<p>For example, <code>[0:100:2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>
<ul>
<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(0,len(s)+i)</code> or <code>j=max(0,len(s)+j)</code></li>
</ul>
<p>For example, <code>[0:-3:2] -&gt; range(0,len(s)-3,2) -&gt; range(0,2,2) -&gt; 0</code></p>
<p>For another example, <code>[0:-1:2] -&gt; range(0,len(s)-1,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>
<ul>
<li>if <code>i</code> is not specified, then <code>i=0</code></li>
</ul>
<p>For example, <code>[:4:2] -&gt; range(0,4,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>
<ul>
<li>if <code>j</code> is not specified, then <code>j=len(s)</code></li>
</ul>
<p>For example, <code>[0::2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>
<hr/>
<h2>2. Step &lt; 0. For example, <code>[i:j:k]</code> (k&lt;0)</h2>
<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>
<ul>
<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>
</ul>
<p>For example, <code>[5:0:-2] -&gt; range(5,0,-2) -&gt; 5, 3, 1</code></p>
<ul>
<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)-1</code> or <code>j=len(s)-1</code></li>
</ul>
<p>For example, <code>[100:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>
<ul>
<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(-1,len(s)+i)</code> or <code>j=max(-1,len(s)+j)</code></li>
</ul>
<p>For example, <code>[-2:-10:-2] -&gt; range(len(s)-2,-1,-2) -&gt; range(3,-1,-2) -&gt; 3, 1</code></p>
<ul>
<li>if <code>i</code> is not specified, then <code>i=len(s)-1</code></li>
</ul>
<p>For example, <code>[:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>
<ul>
<li>if <code>j</code> is not specified, then <code>j=-1</code></li>
</ul>
<p>For example, <code>[2::-2] -&gt; range(2,-1,-2) -&gt; 2, 0</code></p>
<p>For another example, <code>[::-1] -&gt; range(len(s)-1,-1,-1) -&gt; range(4,-1,-1) -&gt; 4, 3, 2, 1, 0</code></p>
<hr/>
<h2>In summary</h2>
<p><a href="https://i.stack.imgur.com/4DLrK.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/4DLrK.png"/></a></p>
</div>
<span class="comment-copy">Slicing builtin types returns a copy but that's not universal.  Notably, <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" rel="nofollow noreferrer">slicing NumPy arrays</a> returns a view that shares memory with the original.</span>
<span class="comment-copy">@RodriKing It means that your start and end are empty, and your step is -2. So you reverse (beause it's negative) and take by 2 elements, for the whole list because start and empty are not defined.</span>
<span class="comment-copy">Another example:      <code>a = list(range(100)) # [0,1,2, .... ,99]</code> and      <code>a[20::-3]</code> It means that you will go reverse 3 by 3. You start from position 20 and go 3 backwards ... 20, 17, 14 etc...</span>
<span class="comment-copy">@mbh86 that's a very good example ! It shows that the sign of the step has priority to the list ends. I was expecting to get <code>[99, 96, 93, ..., 24, 21]</code>.</span>
<span class="comment-copy">@nodakai: Strings are immutable; lists are not. <code>b[:]</code> must be a different object from <code>b</code>, but <code>a[:]</code> and <code>a</code> can be the same.</span>
<span class="comment-copy">"One way to remember how slices work is to think of the indices as pointing between characters" -  this is a great way of thinking about it</span>
<span class="comment-copy">does something weird happen if <code>stride</code> is negative as in <code>[::-1]</code>?</span>
<span class="comment-copy">@CharlieParker When <code>strike</code> is negative it counts down from <code>high</code> to <code>low</code>.</span>
<span class="comment-copy">Actually there is still something left out e.g. if I type 'apple'[4:-4:-1] I get 'elp', python is translating the -4 to a 1 maybe?</span>
<span class="comment-copy">note that backticks are deprecated in favour of <code>repr</code></span>
<span class="comment-copy">can you explain the second one?</span>
<span class="comment-copy">What happened to the first element, <code>0</code>, in the list after the first slice assignment?  The result of <code>r[1:1]=[9,8]</code> should be <code>[0, 9, 8, 1, 2, 3, 4]</code>, isn't it?</span>
<span class="comment-copy">Oops yes you are exactly right, I will edit</span>
<span class="comment-copy">Initially you set <code>r=[0,1,2,3,4]</code>  then set you set <code>r[1:1]=[9,8]</code>  now r is <code>[0, 9, 8, 1, 2, 3, 4]</code>  now we set <code>r[1:1]=['blah']</code>  and then r should be  <code>[0, 'blah', 9, 8, 1, 2, 3, 4]</code> and not <code>[0, 1, 'blah', 9, 8, 2, 3, 4]</code></span>
<span class="comment-copy">You are correct of course. Someone else edited this recently and introduced errors; I'm going to revert it to the original version.</span>
<span class="comment-copy">Hi @aaronhall, excellent post! Would you consider contributing this post to the Intermediate Python book - <a href="https://github.com/yasoob/intermediatePython/issues/153" rel="nofollow noreferrer">github.com/yasoob/intermediatePython/issues/153</a> ?</span>
<span class="comment-copy">Just wanted to say thank you so much for this post, I've been writing Python for a while now and still come back to this as I make out by one errors all the time with slicing!</span>
<span class="comment-copy">another one interesting example: <code>a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; a[:-2:-2]</code> which results to <code>[9]</code></span>
<span class="comment-copy">The <code>this_is_how_slicing_works</code> is not the same as python slice. E.G. <code>[0, 1, 2][-5:3:3]</code> will get [0] in python, but <code>list(this_is_how_slicing_works([0, 1, 2], -5, 3, 3))</code> get [1].</span>
<span class="comment-copy">@Eastsun Oops, you're right!  A clearer case: <code>range(4)[-200:200:3] == [0, 3]</code> but <code>list(this_is_how_slicing_works([0, 1, 2, 3], -200, 200, 3)) == [2]</code>. My <code>if 0 &lt;= i &lt; len(seq):</code> was an attempt to implement "never go outside the sequence" simply but is wrong for step&gt;1.  I'll rewrite it later today (with tests).</span>
<span class="comment-copy">Thanks for enumerating the indices; I was confused by there isn't a "-0" but this clears it, such power :D</span>
<span class="comment-copy">amazing black magic....</span>
<span class="comment-copy">Seems like you have a mistake here. You claim <code>s[::-1]</code> is the same as <code>s[len(s):0:-1]</code> but when i try with <code>s=range(10)</code> i see that the latter leaves off the "0" from the list.</span>
<span class="comment-copy">@MrFlick You're correct! I made a mistake there, just updated.</span>
<span class="comment-copy">You should identify which modules/packages implement this.  The question was just tagged python and list.</span>
<span class="comment-copy">what about -&gt; A[::-1]  how to understand this</span>
<span class="comment-copy">Negative values also work to make a copy of the same list in reverse order ex . <code>L = range(10)</code> <code>L[::-1]</code> o/p: <code>[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</code></span>
<span class="comment-copy">As an online discussion grows longer, the probability of pictures popping up tends to one :-)</span>
<span class="comment-copy">yes picture makes it clearer and louder .. :)</span>
<span class="comment-copy">A[::-1] , how to understand this</span>
<span class="comment-copy">"It will print the string in the reverse order"</span>
