<div class="post-text" itemprop="text">
<p>Double-clicking the value of <code>Table 1</code> copies the value to <code>Table 2</code>. Pressing the right mouse button on <code>Table 2</code> deletes the list in <code>Table 2</code> from the Delete menu. The problem is that if you select the deleted value again from the list of <code>table 1</code>, it will not be duplicated and can not be selected. (If <code>table 1</code> list is duplicated in <code>table 2</code>, it is not selected.) </p>
<p>Is there an easy way to delete and view data while preserving it? Now when I run the button and QMenu into the code, I modify the cell and re-receive the data when I delete the table1 list or table2 data, and the qtableview cell values ​​are initialized</p>
<ul>
<li>Code method <code>def Table2_CustomContextMenu(self, position):</code></li>
</ul>
<p><code>if delete == action:</code> Clear the <code>self.modelListSave</code> value indexed when the condition occurs and remove the <code>self.mainTable2.model(). removeRow (indexRow [0], self.mainTable2.rootIndex())</code> <code>self.modelListSave</code> resets <code>self.mainTable2_model</code> I do not understand that the values ​​of <code>self.modelListSave</code> and <code>self.mainTable2.model()</code> are duplicated.</p>
<pre><code>import sys
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *


class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.resize(500, 500)

        self.Table1()
        self.Table2()
        self.Layout()

    def Table1(self):
        self.select_guorpbox = QGroupBox()
        self.select_guorpbox.setTitle("Article 1")

        self.rowcount = 10
        self.columncount = 10

        self.mainTable1_model = QStandardItemModel(self.rowcount, self.columncount)
        # self.mainTable1_model.setHorizontalHeaderLabels(['a', 'b', 'c', 'd'])

        for i in range(self.rowcount):
            for j in range(self.columncount):
                table = QStandardItem("TEST[{},{}]".format(i,j))
                self.mainTable1_model.setItem(i, j, table)
                table.setTextAlignment(Qt.AlignCenter)

        self.textFilter = QSortFilterProxyModel()
        self.textFilter.setSourceModel(self.mainTable1_model)
        self.textFilter.setFilterKeyColumn(2)

        self.SerchLineEdit = QLineEdit()
        self.SerchLineEdit.textChanged.connect(self.textFilter.setFilterRegExp)

        self.mainTable1 = QTableView()
        self.mainTable1.setModel(self.textFilter)
        self.mainTable1.setColumnWidth(1, 150)
        self.mainTable1.setColumnWidth(2, 300)
        self.mainTable1.setEditTriggers(QTableView.NoEditTriggers)
        self.mainTable1.setSelectionBehavior(QTableView.SelectRows)
        # self.mainTable1.setContextMenuPolicy(Qt.CustomContextMenu)
        self.mainTable1.doubleClicked.connect(self.Table1_DoubleClicked)
        # self.mainTable1.customContextMenuRequested.connect(self.table1_CustomContextMenu)

        # column auto sort
        # self.mainTable1.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
        # self.mainTable1.resizeColumnsToContents()

        v = QVBoxLayout()
        v.addWidget(self.mainTable1)
        self.select_guorpbox.setLayout(v)

    def Table2(self):
        self.serch_groupbox = QGroupBox()
        self.serch_groupbox.setTitle("Article 2")
        lable = QLabel("~")
        lable.setFixedWidth(10)
        lable.setAlignment(Qt.AlignCenter)
        insertbutton = QPushButton("insert")
        self.startdate = QDateEdit()
        self.startdate.setDate(QDate.currentDate())
        self.startdate.setFixedWidth(150)
        self.startdate.setCalendarPopup(True)
        self.enddate = QDateEdit()
        self.enddate.setDate(QDate.currentDate())
        self.enddate.setFixedWidth(150)
        self.enddate.setCalendarPopup(True)
        self.article_serch_button = QPushButton("ARTICL SERTCH")
        self.article_serch_button.setFixedWidth(250)

        self.mainTable2_model = QStandardItemModel()

        self.mainTable2 = QTableView()
        self.mainTable2.setSelectionBehavior(QTableView.SelectRows)
        self.mainTable2.setContextMenuPolicy(Qt.CustomContextMenu)
        self.mainTable2.customContextMenuRequested.connect(self.Table2_CustomContextMenu)

        h1 = QHBoxLayout()
        h1.addWidget(insertbutton)
        h1.addWidget(self.startdate)
        h1.addWidget(lable)
        h1.addWidget(self.enddate)
        h1.addWidget(self.article_serch_button)
        h2 = QHBoxLayout()
        h2.addWidget(self.mainTable2)

        v = QVBoxLayout()
        v.addLayout(h1)
        v.addLayout(h2)

        self.modelListSave = []
        self.codeSave = []
        self.serch_groupbox.setLayout(v)

    def Table1_DoubleClicked(self):
        row = []
        select_row = self.mainTable1.selectedIndexes()
        for row_value in range(len(select_row)):
            row.append(self.mainTable1.model().data(select_row[row_value]))

        if not self.codeSave:
            self.modelListSave.append(row)
            for i in range(len(self.modelListSave)):
                for j in range(self.columncount):
                    self.mainTable2_model.setItem(i, j, QStandardItem(self.modelListSave[i][j]))
            self.mainTable2.setModel(self.mainTable2_model)
            self.codeSave.append(row[0])
            spinBox = QSpinBox()
            mainTable2_ModelIndex = self.mainTable2.model().index(0, 4)
            self.mainTable2.setIndexWidget(mainTable2_ModelIndex, spinBox)

        elif row[0] in self.codeSave:
            QMessageBox.about(self, " ", "overlap.")

        else:
            self.modelListSave.append(row)
            for i in range(len(self.modelListSave)):
                for j in range(self.columncount):
                    self.mainTable2_model.setItem(i, j, QStandardItem(self.modelListSave[i][j]))
            self.mainTable2.setModel(self.mainTable2_model)
            self.codeSave.append(row[0])
            for k in range(5):
                spinBox = QSpinBox()
                mainTable2_ModelIndex = self.mainTable2.model().index(k, 4)
                self.mainTable2.setIndexWidget(mainTable2_ModelIndex, spinBox)

    def Table2_CustomContextMenu(self, position):
        menu = QMenu()
        delete = menu.addAction("delete")
        action = menu.exec_(self.mainTable2.mapToGlobal(position))
        indexRow = [index.row() for index in self.mainTable2.selectionModel().selectedRows()]
        if delete == action:
            del self.modelListSave[indexRow[0]]
            self.mainTable2.model().removeRow(indexRow[0], self.mainTable2.rootIndex())
            for i in range(len(self.modelListSave)):
                for j in range(self.columncount):
                    self.mainTable2_model.setItem(i, j, QStandardItem(self.modelListSave[i][j]))
            self.mainTable2.setModel(self.mainTable2_model)
            for k in range(5):
                spinBox = QSpinBox()
                mainTable2_ModelIndex = self.mainTable2.model().index(k, 4)
                self.mainTable2.setIndexWidget(mainTable2_ModelIndex, spinBox)

    def Layout(self):
        self.vbox = QVBoxLayout()
        self.vbox.addWidget(self.SerchLineEdit)
        self.vbox.addWidget(self.select_guorpbox)
        self.vbox.addWidget(self.serch_groupbox)
        self.setLayout(self.vbox)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    fream = MainWindow()
    fream.show()
    app.exec_()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to your logic, you store information about the copied row in a list, but when you remove a row from the copy table, do not remove it from that row. Also that list is not notified if some element is eliminated by the model so that is the cause of the error.</p>
<p>Instead, it is better not to use that list, for this the verification must be done by iterating the rows of the copy table.</p>
<pre><code>from PyQt5 import QtCore, QtGui, QtWidgets

class Widget(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super(Widget, self).__init__(parent)
        self.create_table_1()
        self.create_table_2()
        self.create_layout()

    def create_table_1(self): 
        self.search_lineedit = QtWidgets.QLineEdit()
        self.select_groupbox = QtWidgets.QGroupBox(title="Article 1")
        self.main_table1_model = QtGui.QStandardItemModel(10, 10, self)

        for i in range(self.main_table1_model.rowCount()):
            for j in range(self.main_table1_model.columnCount()):
                table = QtGui.QStandardItem("TEST[{},{}]".format(i,j))
                self.main_table1_model.setItem(i, j, table)
                table.setTextAlignment(QtCore.Qt.AlignCenter)

        self.textfilter = QtCore.QSortFilterProxyModel(self, filterKeyColumn=2)
        self.textfilter.setSourceModel(self.main_table1_model)
        self.search_lineedit.textChanged.connect(self.textfilter.setFilterRegExp)

        self.main_table1 = QtWidgets.QTableView()
        self.main_table1.setModel(self.textfilter)
        self.main_table1.setColumnWidth(1, 150)
        self.main_table1.setColumnWidth(2, 300)
        self.main_table1.setEditTriggers(QtWidgets.QTableView.NoEditTriggers)
        self.main_table1.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.main_table1.doubleClicked.connect(self.on_table1_doubleClicked)

        v = QtWidgets.QVBoxLayout()
        v.addWidget(self.main_table1)
        self.select_groupbox.setLayout(v)

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_table1_doubleClicked(self, index):
        row = index.row()
        filters_row = self.get_items_by_row(row, self.textfilter)
        for rowX in range(self.main_table2_model.rowCount()):
            table_2_row = self.get_items_by_row(rowX, self.main_table2_model)
            if all([item1 == item2 for item1, item2 in zip(filters_row, table_2_row)]):
                QtWidgets.QMessageBox.about(self, " ", "overlap.")
                return
        self.main_table2_model.appendRow([QtGui.QStandardItem(text) for text in filters_row])
        spinbox = QtWidgets.QSpinBox()
        ix = self.main_table2_model.index(self.main_table2_model.rowCount()-1, 4)
        self.main_table2.setIndexWidget(ix, spinbox)

    def get_items_by_row(self, row, model):
        return [model.data(model.index(row, col)) for col in range(model.columnCount())]

    def create_table_2(self):
        self.search_groupbox = QtWidgets.QGroupBox(title="Article 2")
        label = QtWidgets.QLabel("~")
        label.setFixedWidth(10)
        label.setAlignment(QtCore.Qt.AlignCenter)
        insertbutton = QtWidgets.QPushButton("insert")
        self.startdate = QtWidgets.QDateEdit(calendarPopup=True)
        self.startdate.setDate(QtCore.QDate.currentDate())
        self.startdate.setFixedWidth(150)
        self.enddate = QtWidgets.QDateEdit(calendarPopup=True)
        self.enddate.setDate(QtCore.QDate.currentDate())
        self.enddate.setFixedWidth(150)
        self.article_serch_button = QtWidgets.QPushButton("ARTICL SERTCH")
        self.article_serch_button.setFixedWidth(250)
        self.main_table2_model = QtGui.QStandardItemModel(0, 10)
        self.main_table2 = QtWidgets.QTableView()
        self.main_table2.setModel(self.main_table2_model)
        self.main_table2.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.main_table2.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.main_table2.customContextMenuRequested.connect(self.table2_customcontextmenu)
        h1 = QtWidgets.QHBoxLayout()
        h1.addWidget(insertbutton)
        h1.addWidget(self.startdate)
        h1.addWidget(label)
        h1.addWidget(self.enddate)
        h1.addWidget(self.article_serch_button)
        h2 = QtWidgets.QHBoxLayout()
        h2.addWidget(self.main_table2)
        v = QtWidgets.QVBoxLayout()
        v.addLayout(h1)
        v.addLayout(h2)
        self.search_groupbox.setLayout(v)

    @QtCore.pyqtSlot(QtCore.QPoint)
    def table2_customcontextmenu(self, position):
        ix = self.main_table2.indexAt(position)
        if not ix.isValid():
            return
        menu = QtWidgets.QMenu()
        delete_action = menu.addAction("delete")
        action = menu.exec_(self.main_table2.viewport().mapToGlobal(position))
        if action == delete_action:
            self.main_table2_model.removeRow(ix.row())

    def create_layout(self):
        vbox = QtWidgets.QVBoxLayout(self)
        vbox.addWidget(self.search_lineedit)
        vbox.addWidget(self.select_groupbox)
        vbox.addWidget(self.search_groupbox)

if __name__ == '__main__':
    import sys
    app = QtWidgets.QApplication(sys.argv)
    w = Widget()
    w.show()
    sys.exit(app.exec_())
</code></pre>
</div>
<span class="comment-copy">Hello, I really appreciate your answer. One more question. For example, do you need to use <code>QStyledItemDelegate</code> in order to reflect the values ​​of 6 columns and <code>qspinbox</code> values ​​in selected table 2 row to table 2 column 7? The mvc pattern is theoretically understandable, but it's hard to understand because it's made into code.</span>
<span class="comment-copy">@다크매터 I do not understand you, I recommend you check: <a href="https://doc.qt.io/qt-5/model-view-programming.html" rel="nofollow noreferrer">doc.qt.io/qt-5/model-view-programming.html</a></span>
