<div class="post-text" itemprop="text">
<p>Python 3.7 introduced <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a> to store data. I'm considering to move to this new approach which is more organized and well structured than a dict.</p>
<p>But I have a doubt. Python transforms keys into hashes on dicts and that makes looking for keys and values much faster. Dataclasses implement something like it?</p>
<p>Which one is faster and why?</p>
</div>
<div class="post-text" itemprop="text">
<p>All classes in python actually use a dictionary under the hood to store their attributes, as you can read <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer">here</a> in the documentation. For a more in-depth reference on how python classes (and many more things) work, you can also check out the article on <a href="https://docs.python.org/3/reference/datamodel.html#data-model" rel="nofollow noreferrer">python's datamodel</a>, in particular the section on custom classes.</p>
<p>So in general, there shouldn't be a loss in performance by moving from dictionaries to dataclasses. But it's better to make sure with the <a href="https://docs.python.org/3.7/library/timeit.html" rel="nofollow noreferrer">timeit</a> module:</p>
<hr/>
<p><strong>Baseline</strong></p>
<pre><code># dictionary creation
$ python -m timeit "{'var': 1}"
5000000 loops, best of 5: 52.9 nsec per loop

# dictionary key access
$ python -m timeit -s "d = {'var': 1}" "d['var']"
10000000 loops, best of 5: 20.3 nsec per loop
</code></pre>
<hr/>
<p><strong>Basic dataclass</strong></p>
<pre><code># dataclass creation
$ python -m timeit -s "from dataclasses import dataclass" -s "@dataclass" -s "class A: var: int" "A(1)" 
1000000 loops, best of 5: 288 nsec per loop

# dataclass attribute access
$ python -m timeit -s "from dataclasses import dataclass" -s "@dataclass" -s "class A: var: int" -s "a = A(1)" "a.var" 
10000000 loops, best of 5: 25.3 nsec per loop
</code></pre>
<hr/>
<p>Here we can see that using classes does have some overhead. For class creation it's quite a bit (~5 times slower), but you don't necessarily need to care that much about it as long as you don't plan to create and toss your dataclasses multiple times per second.</p>
<p>The attribute access is probably the more important metric, and while dataclasses are again slower (~1.25 times), this time it's not by that much.</p>
<p>If you think that's still a tad too slow, you can tune your dataclass (or any classes, really) by using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">slots</a> instead of a dictionary to store their attributes:</p>
<hr/>
<p><strong>Slotted dataclass</strong></p>
<pre><code># dataclass creation
$ python -m timeit -s "from dataclasses import dataclass" -s "@dataclass" -s "class A: __slots__ = ('var',); var: int" "A(1)" 
1000000 loops, best of 5: 242 nsec per loop

# dataclass attribute access
$ python -m timeit -s "from dataclasses import dataclass" -s "@dataclass" -s "class A: __slots__ = ('var',); var: int" -s "a = A(1)" "a.var"
10000000 loops, best of 5: 21.7 nsec per loop
</code></pre>
<p>By using this pattern we could shave off a few more more nanoseconds. At this point, at least regarding attribute access, there shouldn't be a noticeable difference to dictionaries any more, and you can use the upsides of dataclasses without compromising speed.</p>
</div>
<span class="comment-copy">Thanks for your answer! It's very complete in a succinct way and solved all my doubts!</span>
<span class="comment-copy">@SÃ©rgioMafra Glad I could help =)</span>
