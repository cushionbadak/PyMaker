<div class="post-text" itemprop="text">
<p>I'm trying to make it possible for users to delete a thread with another user from their inbox.</p>
<p>I've followed the Django Docs <code>DeleteView</code> although this may be totally wrong.</p>
<p>views.py</p>
<pre><code>class InboxView(LoginRequiredMixin, ListView):
    template_name = 'chat/inbox.html'
    context_object_name = 'threads'
    def get_queryset(self):
        return Thread.objects.by_user(self.request.user).order_by('-timestamp')
        # by_user(self.request.user)

class ThreadView(LoginRequiredMixin, FormMixin, DetailView):
    template_name = 'chat/thread.html'
    form_class = ComposeForm
    success_url = '#'

    def get_queryset(self):
        return Thread.objects.by_user(self.request.user)

    def get_object(self):
        other_username  = self.kwargs.get("username")
        obj, created    = Thread.objects.get_or_new(self.request.user, other_username)
        if obj == None:
            raise Http404
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = self.get_form()
        return context

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseForbidden()
        self.object = self.get_object()
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        else:
            return self.form_invalid(form)

    def form_valid(self, form):
        thread = self.get_object()
        user = self.request.user
        message = form.cleaned_data.get("message")
        ChatMessage.objects.create(user=user, thread=thread, message=message)
        return super().form_valid(form)

class ThreadDeleteView(DeleteView):
    model = Thread
    success_url = reverse_lazy('inbox')
</code></pre>
<p>models.py</p>
<pre><code>class ThreadManager(models.Manager):
    def by_user(self, user):
        qlookup = Q(first=user) | Q(second=user)
        qlookup2 = Q(first=user) &amp; Q(second=user)
        qs = self.get_queryset().filter(qlookup).exclude(qlookup2).distinct()
        return qs

    # method to grab the thread for the 2 users
    def get_or_new(self, user, other_username): # get_or_create
        username = user.username
        if username == other_username:
            return None
        # looks based off of either username
        qlookup1 = Q(first__username=username) &amp; Q(second__username=other_username)
        qlookup2 = Q(first__username=other_username) &amp; Q(second__username=username)
        qs = self.get_queryset().filter(qlookup1 | qlookup2).distinct()
        if qs.count() == 1:
            return qs.first(), False
        elif qs.count() &gt; 1:
            return qs.order_by('timestamp').first(), False
        else:
            Klass = user.__class__
            user2 = Klass.objects.get(username=other_username)
            if user != user2:
                obj = self.model(
                        first=user,
                        second=user2
                    )
                obj.save()
                return obj, True
            return None, False

class Thread(models.Model):
    first        = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='chat_thread_first')
    second       = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='chat_thread_second')
    updated      = models.DateTimeField(auto_now=True)
    timestamp    = models.DateTimeField(auto_now_add=True)

    objects      = ThreadManager()

    def __str__(self):
        return f'{self.id}'

    @property
    def room_group_name(self):
        return f'chat_{self.id}'

    def broadcast(self, msg=None):
        if msg is not None:
            broadcast_msg_to_chat(msg, group_name=self.room_group_name, user='admin')
            return True
        return False
</code></pre>
<p>html thread page with delete button</p>
<pre><code>&lt;!-- Delete Thread --&gt;
          &lt;form action="{% url 'chat:thread_delete' user.username %}" method='post'&gt;  {% csrf_token %}
            &lt;button type='submit' class='btn btn-light'&gt;
              &lt;i class="fas fa-trash-alt" style="color:royalblue"&gt;&lt;/i&gt;
            &lt;/button&gt;
          &lt;/form&gt;
</code></pre>
<p>urls.py</p>
<pre><code>app_name = 'chat'
urlpatterns = [
    path('', chat_views.InboxView.as_view(), name='inbox'),
    re_path(r"^(?P&lt;username&gt;[\w.@+-]+)", chat_views.ThreadView.as_view(), name='thread'),
    re_path(r"^(?P&lt;username&gt;[\w.@+-]+)/delete/", chat_views.ThreadDeleteView.as_view(), name='thread_delete'),
]
</code></pre>
<p>I keep getting the error </p>
<pre><code>TypeError at /messages/userthree/delete/ cannot unpack non-iterable NoneType object
</code></pre>
<p>which is being caused by <code>views.py</code> lines</p>
<pre><code>self.object = self.get_object()
obj, created    = Thread.objects.get_or_new(self.request.user, other_username)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the issue here is that you have a return statement in your <code>get_or_new()</code> method that is not returning a tuple:</p>
<pre><code>if username == other_username:
    return None
</code></pre>
<p>That causes the view to fall over because it's expecting to unpack a tuple into two variables. Returning a tuple should resolve:</p>
<pre><code>if username == other_username:
    return None, None
</code></pre>
</div>
<span class="comment-copy">have you tried printing out "other_username"?</span>
<span class="comment-copy">Yes it prints the logged in user</span>
<span class="comment-copy">Thank you, I see your point. After I change the method to return a tuple and calling the <code>DeleteView</code>, the url changes from the <code>ThreadView</code> url <code>http://127.0.0.1:8000/messages/newuser3</code> where <code>newuser3</code> is the other user to the <code>DeleteView</code> url <code>http://127.0.0.1:8000/messages/trilla/delete/</code> where <code>trilla</code> is me, or the logged-in user. Then I get a <code>404 not found</code>. Is this error happening because the <code>DeleveView</code> url is being configured improperly?</span>
<span class="comment-copy">I've changed the <code>DeleteView</code> url to <code>{% url 'chat:thread_delete' thread.second %}</code> which doesn't throw any errors but still leaves the thread in tact and does not redirect to <code>inbox</code></span>
<span class="comment-copy">Are you able to post the whole of <code>views.py</code>? It seems that when <code>obj</code> is None the view is redirecting to a URL which is failing to look up.</span>
<span class="comment-copy">I've just updated the question to include it.</span>
<span class="comment-copy">The <code>DeleteView</code> form seems to be going to the right URL however it stays on the <code>../username/delete/</code> URL after <code>request.POST</code></span>
