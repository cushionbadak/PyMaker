<div class="post-text" itemprop="text">
<p>I want to generate n amount of Tkinter buttons which do different things. I have this code:</p>
<pre><code>import Tkinter as tk

for i in range(boardWidth):
    newButton = tk.Button(root, text=str(i+1), 
        command=lambda: Board.playColumn(i+1, Board.getCurrentPlayer()))
    Board.boardButtons.append(newButton)
</code></pre>
<p>If boardWidth is 5, though I get buttons labelled 1-5, when clicked they all do Board.playColumn(5, Board.getCurrentPlayer()).</p>
<p>I need the first button to do Board.playColumn(1, Board.getCurrentPlayer()), the second to do Board.playColumn(2, Board.getCurrentPlayer()) and so on.</p>
<p>Thanks for any help!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem is that the <code>lambda</code> is picking up the final value of <code>i</code> after the <code>for</code> loop ends. This should fix that (untested):</p>
<pre><code>import Tkinter as tk

for i in range(boardWidth):
    newButton = tk.Button(root, text=str(i+1),
        command=lambda j=i+1: Board.playColumn(j, Board.getCurrentPlayer()))
    Board.boardButtons.append(newButton)
</code></pre>
<p><strong>Update</strong></p>
<p>BTW, this worked by adding an argument to the <code>lambda</code> function with a default value calculated from the value of <code>i</code> at the time each one is created in the loop rather than referring back to the final value of <code>i</code> through a closure when the expression within it executes later.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that you create lots of <code>lambda</code> objects in the same namespace, and those <code>lambda</code>s make reference to names in the outer scope. That means they don't become closures and they don't store references to the objects until later... When it happens, all lambdas will refer to the last value of <code>i</code>.</p>
<p>Try using a callback factory to fix that:</p>
<pre><code>import Tkinter as tk

def callbackFactory(b, n):
    def _callback():
        return b.playColumn(n, b.getCurrentPlayer())
    return _callback

for i in range(boardWidth):
    newButton = tk.Button(root, text=str(i+1), 
        command=callbackFactory(Board, i+1))
    Board.boardButtons.append(newButton)
</code></pre>
<p>Another idea is to store the current value of i as a default argument value in the <code>lambda</code> object, instead of relying on closure behavior to store the reference:</p>
<pre><code>for i in range(boardWidth):
    newButton = tk.Button(root, text=str(i+1), 
        command=lambda x=i: Board.playColumn(x+1, Board.getCurrentPlayer()))
    Board.boardButtons.append(newButton)
</code></pre>
</div>
<span class="comment-copy">Yup, that worked. Thanks!</span>
<span class="comment-copy">Tried your second example, as per martineau's suggestion. Thanks for explaining why this happened though!</span>
