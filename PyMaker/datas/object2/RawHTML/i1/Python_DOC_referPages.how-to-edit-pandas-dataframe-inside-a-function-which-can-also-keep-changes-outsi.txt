<div class="post-text" itemprop="text">
<p>Tried creating dummies function which creates dummies and concatenates original df with dummies df. when a dataframe is passes through the function, I dont see any changes in df!</p>
<pre><code>def get_dummies(df, col):
    colLabel = pd.get_dummies(df[col])
    df = pd.concat([df, colLabel], axis=1)

get_dummies(train_set1, 'jobtype')
</code></pre>
<p>train_set1 wont change!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need the function to <code>return</code> the frame and assign it back:</p>
<pre><code>def get_dummies(df, col):
    colLabel = pd.get_dummies(df[col])
    df = pd.concat([df, colLabel], axis=1)
    return df

train_set1 = get_dummies(train_set1, 'jobtype')
</code></pre>
<p>If you're absolutely insistent on doing it the way you've asked, you could potentially assigning the <code>DataFrame</code> a <code>__name__</code> attribute, and updated the frame in the <code>globals()</code> dict of variables <strong>(definately not advised though!)</strong>:</p>
<pre><code>def get_dummies(df, col):
    colLabel = pd.get_dummies(df[col])
    new_df = pd.concat([df, colLabel], axis=1)
    globals()[df.__name__] = new_df

train_set1.__name__ = 'train_set1'
get_dummies(train_set1, 'jobtype')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Concat returns a copy of the data, so normally the operation is not in place.
A number of pandas functions have a "in_place" argument. Set this to true, if you want to modify the dataset, rather than get a copy.
Concat does not have such a argument, but an "copy" argument. Try setting that to false.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pandas' <code>pandas.concat</code> function by default copies the data frame on concatenation. Essentially, this generates a new data frame which is stored in your local <code>df</code> variable and replaces the reference to the original data frame passed from outside. As a consequence, upon assignment to <code>df</code>, you don't change the original data frame anymore but replace it with a new one <em>only inside the function</em>.</p>
<p>See <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" rel="nofollow noreferrer">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html</a></p>
<blockquote>
<p><strong>pandas.concat</strong>(objs, axis=0, join='outer', join_axes=None, ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, sort=None, <strong>copy=True</strong>)</p>
</blockquote>
<p>Setting <code>copy=False</code> in your call would modify the data frame in place and not replace the reference by a new data frame which would never be able to leave the function scope.</p>
</div>
<span class="comment-copy">You did not return anything</span>
<span class="comment-copy">Why would you go searching for hacks when you can just return the result?</span>
<span class="comment-copy">even if I used return, train_set1 didn't change!</span>
<span class="comment-copy">Then you forget to assign it back , train_set1 =get_dummies(train_set1, 'jobtype')</span>
<span class="comment-copy">@vivekreddydevi this is a terrible design choice, btw. As a general rule, I consider functions that mutate their inputs as an anti-pattern.</span>
<span class="comment-copy">Thanks. This works but I was trying to see if I can just assign the changes inside the function.  So when I call get_dummies(), it will change the train_set1!</span>
<span class="comment-copy">@vivekreddydevi you can, but why do want that?</span>
<span class="comment-copy">This, of course, assumes that the function will only be called from the global scope.</span>
<span class="comment-copy">def get_dummies(df, col):         colLabel = pd.get_dummies(df[col])         df = pd.concat([df, colLabel], axis=1, copy=False)    get_dummies(train_set1, 'jobtype')   tried this, still the train_set1 remains the same!</span>
