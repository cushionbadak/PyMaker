<div class="post-text" itemprop="text">
<p>Context:
I am trying a program that captures some MQTT messages and then logs them. While doing this, I encounter a strange problem and I need help with it. </p>
<p>In the incoming messages, I get one string which is base64 encoded. My program tries to decode and parse the binary data to figure out some headers of the packet. The code I have looks like this:</p>
<pre><code>result = base64.standard_b64decode("AO/Nq4lnRSMBZXMnLHcKXhSObYxiFvY=")
</code></pre>
<p>The output of result looks like this:</p>
<pre><code>b"\x00\xef\xcd\xab\x89gE#\x01es',w\n^\x14\x8em\x8cb\x16\xf6"
</code></pre>
<p>If the same operation is done using a nodeJS implementation, the output is quite different:</p>
<pre><code>&lt;Buffer 00 ef cd ab 89 67 45 23 01 65 73 27 2c 77 0a 5e 14 8e 6d 8c 62 16 f6&gt;
</code></pre>
<p>I read a few other links within stack overflow and couldn't understand why the difference exists. The link <a href="https://stackoverflow.com/questions/49885049/difference-between-python-and-node-base64-decoding">NodeJS base64 Vs Python base64</a> has some valid points w.r.t to the encoding that was done hence what Python does here is not wrong. </p>
<p>Upon reading further, I found another tip where a binascii function was used. So, If I apply this logic, my output looks exactly like the NodeJS output!</p>
<pre><code>import binascii
binascii.hexlify(result)
b'00efcdab89674523016573272c770a5e148e6d8c6216f6'
</code></pre>
<p>Now my output looks like what I want. However, there is another new problem. The output of base64 decode was in the format b'\x00' while the output of hexlify is b'0'. Because of this difference, I am unable to run the other part of my code which splits this output byte by byte to do struct.unpack in different formats depending on the header of the packet.</p>
<p>Is there any help I can get to proceed?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand well, you are confused by the Python formatting of bytes.</p>
<p>Basically, when displaying a byte in Python, if this byte matches an ASCII character, the character is used instead of the numerical value. The results are actually the same in Python and NodeJS, only the representation differs.</p>
<p>You can check it by aligning the two representations:</p>
<pre><code>b"    \x00\xef\xcd\xab\x89  g  E  #\x01  e  s  '  ,  w \n  ^\x14\x8e  m\x8c  b\x16\xf6"
&lt;Buffer 00  ef  cd  ab  89 67 45 23  01 65 73 27 2c 77 0a 5e  14  8e 6d  8c 62  16  f6&gt;
</code></pre>
<p>As you can see, the values are identical except for:</p>
<pre><code>67 -&gt; g
45 -&gt; E
23 -&gt; #
65 -&gt; e
73 -&gt; s
27 -&gt; '
2c -&gt; ,
0a -&gt; \n
5e -&gt; ^
6d -&gt; m
</code></pre>
<p>The fact is that each hexadecimal value displayed above match a character in the ASCII table.</p>
<p>You can verify it easily in a Python interpreter (<code>ord</code> gives the ascii code of the given character and <code>hex</code> converts it in a hexadecimal representation):</p>
<pre><code>&gt;&gt;&gt; hex(ord('g'))
'0x67'
&gt;&gt;&gt; hex(ord('E'))
'0x45'
&gt;&gt;&gt; hex(ord('#'))
'0x23'
</code></pre>
<p>Finally you could even get exactly the same representation as NodeJS in few lines of Python:</p>
<pre><code>&gt;&gt;&gt; bytes = b"\x00\xef\xcd\xab\x89gE#\x01es',w\n^\x14\x8em\x8cb\x16\xf6"
&gt;&gt;&gt; print('&lt;Buffer {}&gt;'.format(' '.join([format(c, '02x') for c in bytes])))
&lt;Buffer 00 ef cd ab 89 67 45 23 01 65 73 27 2c 77 0a 5e 14 8e 6d 8c 62 16 f6&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>base64.standard_b64decode</code> returns a <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects" rel="nofollow noreferrer"><code>bytes</code></a> object, which is an immutable sequence of single bytes. This is indicated by the <code>b</code> letter before the <code>"</code>.</p>
<p>From the <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Bytes literals are always prefixed with <code>'b'</code> or <code>'B'</code>; they produce an instance of the <code>bytes</code> type instead of the <code>str</code> type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.</p>
</blockquote>
<p>What you see here is the ASCII representation of the <code>bytes</code> object, not a string.</p>
<p>In order to convert a <code>bytes</code> object to a string similar to the result you get from nodeJS, you can use the <code>bytes</code> object method <code>hex</code>:</p>
<pre><code>import base64

result = base64.b64decode(b"AO/Nq4lnRSMBZXMnLHcKXhSObYxiFvY=")

print(result.hex())

&gt;&gt;&gt; 00efcdab89674523016573272c770a5e148e6d8c6216f6
</code></pre>
</div>
<span class="comment-copy">Can you please try binascii.b2a_base64(data), they also have binascii.a2b_base64(string) if you want the opposite <a href="https://docs.python.org/2/library/binascii.html" rel="nofollow noreferrer">docs.python.org/2/library/binascii.html</a></span>
<span class="comment-copy">Wow. You were right, I wasn't able to figure out the similarity in the output of NodeJS and Python. Thanks a lot for clarifying this for me. I now have an idea to take this forward.</span>
<span class="comment-copy">Thank you Jacques. I was missing the result.hex() in my code! I got exactly what I was looking for and now can proceed with the logging part of the information I receive.</span>
<span class="comment-copy">Glad to hear it helped. <code>bytes</code> can be a bit confusing at the beginning but there's nothing to be scared about. Good luck!</span>
