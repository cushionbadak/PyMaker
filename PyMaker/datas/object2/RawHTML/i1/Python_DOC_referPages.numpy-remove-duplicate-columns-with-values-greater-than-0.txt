<div class="post-text" itemprop="text">
<p>I've the following array.</p>
<pre><code>array([[ 0,  0,  0,  0,  0,  3],
       [ 4,  4,  0,  0,  0,  0],
       [ 0,  0,  0, 23,  0,  0]])
</code></pre>
<p>I am looking to find the unique values column wise such that my result is.</p>
<pre><code>array([[ 0,  0,  0,  0,  3],
       [ 4,  0,  0,  0,  0],
       [ 0,  0, 23,  0,  0]])
</code></pre>
<p>The unique should only be applied to columns without <code>0</code> values i.e all columns which has <code>0</code> as their value should remain. Also I've to make sure that the indices of the columns is not changed. They remain at their place.</p>
<p>I've already tried the following.</p>
<pre><code>np.unique(a,axis=1, return_index=True)
</code></pre>
<p>But this gives me</p>
<pre><code>(array([[ 0,  0,  0,  3],
       [ 0,  0,  4,  0],
       [ 0, 23,  0,  0]]), array([2, 3, 0, 5]))
</code></pre>
<p>There are two problems in this result. The column indices are moved and the columns with only <code>0</code> values are also merged. </p>
</div>
<div class="post-text" itemprop="text">
<p>This will accomplish what you want:</p>
<pre><code>import numpy as np
import pandas as pd

x = np.array([[ 0,  0,  0,  0,  0,  3],
              [ 4,  4,  0,  0,  0,  0],
              [ 0,  0,  0, 23,  0,  0]])

df = pd.DataFrame(x.T)

row_sum = np.sum(df, axis=1)

df1 = df[row_sum != 0].drop_duplicates()
df0 = df[row_sum == 0]

y = pd.concat([df1, df0]).sort_index().values.T

y

    array([[ 0,  0,  0,  0,  3],
           [ 4,  0,  0,  0,  0],
           [ 0,  0, 23,  0,  0]])
</code></pre>
<p>By summing the columns (or the rows after transposing) you can identify which ones contain all zeros, and filter them out before dropping the duplicates. Then you can re-combine them and sort by the index to get the desired output.</p>
</div>
<span class="comment-copy">Do you want the column order preserved or not?</span>
<span class="comment-copy">If you remove a column, then the column indices of the other columns to the right of the removed column will certainly change. Unless, by "remove" you mean something like masking of elements (as in masked numpy arrays)</span>
<span class="comment-copy">Masking works too to keep the indices</span>
<span class="comment-copy">You beat me to it! I was going to use df.T also &amp; drop_duplicates. Nice answer.</span>
<span class="comment-copy">thanks this is perfect</span>
<span class="comment-copy">@ScottSkiles Thanks! Answering questions here has helped me to improve my coding speed, if nothing else :)</span>
<span class="comment-copy">@Mj1992 Glad to hear it!</span>
