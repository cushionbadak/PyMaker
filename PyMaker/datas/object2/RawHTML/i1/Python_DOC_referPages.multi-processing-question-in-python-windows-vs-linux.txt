<div class="post-text" itemprop="text">
<pre><code>import random
import os
from multiprocessing import Process

num = random.randint(0, 100)

def show_num():
    print("pid:{}, num is {}".format(os.getpid(), num))

if __name__ == '__main__':
    print("pid:{}, num is {}".format(os.getpid(), num))
    p = Process(target=show_num)
    p.start()
    p.join()
    print('Parent Process Stop')
</code></pre>
<p>The above code shows the basic usage of creating a process. If I run this script in the windows environment, the variable num is different in the parent process and child process. However, the variable num is the same when the script run between the Linux environment.
I understand their mechanism of creating process is different. For example, the windows system doesn't have fork method.
But, Can someone give me a more detailed explanation of their difference?
Thank you very much.  </p>
</div>
<div class="post-text" itemprop="text">
<p>The difference explaining the behavior described in your post is exactly what you mentioned: the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">start method</a> used for creating the process. On Unix-style OSs, the default is <code>fork</code>. On Windows, the only available option is <code>spawn</code>.</p>
<p><strong>fork</strong><br/>
As described in the Overview section of <a href="https://en.wikipedia.org/wiki/Fork_(system_call)" rel="nofollow noreferrer">this Wiki page</a> (in a slightly different order):</p>
<blockquote>
<p>The fork operation creates a separate address space for the child. The
  <strong>child</strong> process <strong>has an exact copy of</strong> all <strong>the memory segments of the
  parent process</strong>.</p>
<p>The child process calls the exec system call to overlay itself with the
  other program: it ceases execution of its former program in favor of
  the other.</p>
</blockquote>
<p>This means that, when using fork, the child process already has the variable <code>num</code> in its address space and uses it. <code>random.randint(0, 100)</code> is <em>not</em> called again.</p>
<p><strong>spawn</strong><br/>
As the multiprocessing docs describe:</p>
<blockquote>
<p>The parent process starts a fresh python interpreter process.</p>
</blockquote>
<p>In this fresh interpreter process, the module from which the child is spawned is executed. Oversimplified, this does <code>python.exe your_script.py</code> a second time. Hence, a new variable <code>num</code> is created in the child process by assigning the return value of another call to <code>random.randint(0, 100)</code> to it. Therefore it is very likely, that the content of <code>num</code> differs between the processes.<br/>This is, by the way, also the reason why you absolutely <em>need</em> to safeguard the instantiation and start of a process with the <code>if __name__ == '__main__'</code> idiom when using <code>spawn</code> as start method, otherwise you end up with:</p>
<pre><code>RuntimeError: 
        An attempt has been made to start a new process before the
        current process has finished its bootstrapping phase.

        This probably means that you are not using fork to start your
        child processes and you have forgotten to use the proper idiom
        in the main module:

            if __name__ == '__main__':
                freeze_support()
                ...

        The "freeze_support()" line can be omitted if the program
        is not going to be frozen to produce an executable.
</code></pre>
<p>You can use <code>spawn</code> in POSIX OSs as well, to mimic the behavior you have seen on Windows:</p>
<pre><code>import random
import os
from multiprocessing import Process, set_start_method
import platform

num = random.randint(0, 100)

def show_num():
    print("pid:{}, num is {}".format(os.getpid(), num))

if __name__ == '__main__':
    print(platform.system())
    # change the start method for new processes to spawn
    set_start_method("spawn")
    print("pid:{}, num is {}".format(os.getpid(), num))
    p = Process(target=show_num)
    p.start()
    p.join()
    print('Parent Process Stop')
</code></pre>
<p>Output:</p>
<pre><code>Linux
pid:26835, num is 41
pid:26839, num is 13
Parent Process Stop
</code></pre>
</div>
<span class="comment-copy">It's very clear. Thank you.</span>
