<div class="post-text" itemprop="text">
<p>I've got a dataframe containing something like this:</p>
<pre><code>                    #   Year    Player          PTSN    AVGN    
ThisYear                            
2018Aaron Donald    1   2018    Aaron Donald    280.60  17.538  
2018J.J. Watt       2   2018    J.J. Watt       259.80  16.238  
2018Danielle Hunter 3   2018    Danielle Hunter 237.60  14.850  
2017Aaron Donald    8   2017    Aaron Donald    181.0   12.929  
2017Danielle Hunter 20  2017    Danielle Hunter 133.2   8.325
2016Danielle Hunter 2   2016    Danielle Hunter 204.6   12.788
</code></pre>
<p>What i want to do is adjust the columns and rows so i can run regressions on them comparing each players prior year to their future year (if you know of a better way to do what i'm asking, please tell).</p>
<p>The end result i'm looking for would be something like this for a row:</p>
<pre><code>Player          PTSN     AVGN      PTSNN1      AVGNN1
Aaron Donald    280.60   17.538    181.0       12.929
</code></pre>
<p>How would i do that? or, what is the better way of achieving the result i'm looking for?</p>
</div>
<div class="post-text" itemprop="text">
<h2>New answer: setting up "current" and "previous" columns for correlation</h2>
<pre><code># Same setup
df = pd.DataFrame({'#': [1, 2, 3, 8, 20, 2],
 'AVGN': [17.538, 16.238, 14.85, 12.929, 8.325, 12.788],
 'PTSN': [280.6, 259.8, 237.6, 181.0, 133.2, 204.6],
 'Player': ['Aaron Donald',
            'J.J. Watt',
            'Danielle Hunter',
            'Aaron Donald',
            'Danielle Hunter',
            'Danielle Hunter'],
 'Year': [2018, 2018, 2018, 2017, 2017, 2016]})

# Do not unstack the MultiIndex
res = df.set_index(['Player', 'Year'])[['AVGN', 'PTSN']]

# Build a MultiIndex of all players by all years
idx = pd.MultiIndex.from_product([df['Player'].unique(), 
                                  df['Year'].unique()],
                                 names=['Player', 'Year'])

# Introduce a row of NaN values for any combination of 
# player and year not in the original DataFrame
res = res.reindex(idx).sort_index()

res[['AVGN_prev', 'PTSN_prev']] = res.groupby('Player')[['AVGN', 'PTSN']].shift()

res
                        AVGN   PTSN  AVGN_prev  PTSN_prev
Player          Year                                     
Aaron Donald    2016     NaN    NaN        NaN        NaN
                2017  12.929  181.0        NaN        NaN
                2018  17.538  280.6     12.929      181.0
Danielle Hunter 2016  12.788  204.6        NaN        NaN
                2017   8.325  133.2     12.788      204.6
                2018  14.850  237.6      8.325      133.2
J.J. Watt       2016     NaN    NaN        NaN        NaN
                2017     NaN    NaN        NaN        NaN
                2018  16.238  259.8        NaN        NaN
</code></pre>
<h2>Old answer</h2>
<p>Set index to <code>['Player', 'Year']</code>, then unstack the inner level into columns:</p>
<pre><code># Simplified version of your example DataFrame
df = pd.DataFrame({'#': [1, 2, 3, 8, 20, 2],
 'AVGN': [17.538, 16.238, 14.85, 12.929, 8.325, 12.788],
 'PTSN': [280.6, 259.8, 237.6, 181.0, 133.2, 204.6],
 'Player': ['Aaron Donald',
            'J.J. Watt',
            'Danielle Hunter',
            'Aaron Donald',
            'Danielle Hunter',
            'Danielle Hunter'],
 'Year': [2018, 2018, 2018, 2017, 2017, 2016]})

res = df.set_index(['Player', 'Year'])[['AVGN', 'PTSN']].unstack()

res
                   AVGN                   PTSN              
Year               2016    2017    2018   2016   2017   2018
Player                                                      
Aaron Donald        NaN  12.929  17.538    NaN  181.0  280.6
Danielle Hunter  12.788   8.325  14.850  204.6  133.2  237.6
J.J. Watt           NaN     NaN  16.238    NaN    NaN  259.8
</code></pre>
<p>At this point, the columns are a MultiIndex. To flatten the columns:</p>
<pre><code># Convert integer years to strings
oldcols = res.columns
res.columns = oldcols.set_levels([oldcols.levels[0],
                                  oldcols.levels[1].astype(str)])

# Flatten columns
res.columns = ['_'.join(col) for col in res.columns.values]

res
                 AVGN_2016  AVGN_2017  AVGN_2018  PTSN_2016  PTSN_2017  PTSN_2018
Player                                                                           
Aaron Donald           NaN     12.929     17.538        NaN      181.0      280.6
Danielle Hunter     12.788      8.325     14.850      204.6      133.2      237.6
J.J. Watt              NaN        NaN     16.238        NaN        NaN      259.8
</code></pre>
</div>
<span class="comment-copy">Can you please describe the expected row template? How did PTSN become 280.60 for <code>Aaron Donald</code>?</span>
<span class="comment-copy">Thanks! One more question, is there a way to do this so that instead of getting all year values (2016, 2017, 2018) i can have each row have only two years at a time? For example, Danielle Hunter would have his 2016 and 2017 values in one row with his name, and then a new row with his name and the 2017 and 2018 values? Reason being for the regression it doesn't matter the year, i'm only testing how well previous year predicts next year's value</span>
<span class="comment-copy">You're welcome! If that's your intention, I would actually suggest not unstacking the index, and instead setting up "current" and "previous" columns; I've edited my answer to illustrate.</span>
<span class="comment-copy">That's perfect!! exactly what i was looking for. Appreciate the help!</span>
<span class="comment-copy">@EdwardGorelik, you're very welcome!</span>
<span class="comment-copy">@EdwardGorelik, no problem. I think the best workaround in that case is to introduce rows of <code>NaN</code> for any combination of Player and Year that does not explicitly appear in the original DataFrame. The usual way of doing that is by building a new MultiIndex from the cartesian product of unique Player and Year values, then to <code>df.reindex()</code> on this new MultiIndex. See edit!</span>
