<div class="post-text" itemprop="text">
<p>Alright, this is doing my head in. I have two dictionaries with object groups as shown below:</p>
<pre><code>groups = {
    'servers': ['unix_servers', 'windows_servers'],
    'unix_servers': ['server_a', 'server_b', 'server_group'],
    'windows_servers': ['server_c', 'server_d'],
    'server_group': ['server_e', 'server_f']
}

hosts = {
    'server_a': '10.0.0.1',
    'server_b': '10.0.0.2',
    'server_c': '10.0.0.3',
    'server_d': '10.0.0.4',
    'server_e': '10.0.0.5',
    'server_f': '10.0.0.6'
}
</code></pre>
<p>The output I'm looking for is:</p>
<pre><code>d3 = {
    'servers': {
        'unix_servers': {
            'server_a': '10.0.0.1',
            'server_b': '10.0.0.2',
            'server_group': {
                'server_e': '10.0.0.5',
                'server_f': '10.0.0.6'
            }
        },
        'windows_servers': {
            'server_c': '10.0.0.3',
            'server_d': '10.0.0.4'
        }
    }
}
</code></pre>
<p>The problem I'm having is that I don't know beforehand how much levels of recursion there are, as nested groups can theoretically go on infinitely. Additionally, I'm having trouble with determining which keys should be a top-level key in the combined dictionary. </p>
<p>I currently have the following:</p>
<pre><code>def resolve(d1, d2):
for k, v in d1.items():
    for i in v:
        if i in d2.keys():
            d3[k] = {i: d2[i]}
</code></pre>
<p>This returns:</p>
<pre><code>{
  "servers": {
    "unix_servers": {
      "server_a": "10.0.0.1",
      "server_b": "10.0.0.2",
      "server_group": {
        "server_e": "10.0.0.5",
        "server_f": "10.0.0.6"
      }
    },
    "windows_servers": {
      "server_c": "10.0.0.3",
      "server_d": "10.0.0.4"
    }
  },
  "unix_servers": {
    "server_b": "10.0.0.2"
  },
  "windows_servers": {
    "server_d": "10.0.0.4"
  },
  "server_group": {
    "server_f": "10.0.0.6"
  }
}
</code></pre>
<p>Which is close, but it's clearly missing recursion and doesn't handle nesting of keys. Mainly looking for pointers here, recursion logic doesn't click for me yet...</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this does what you want:</p>
<pre><code>def resolve(groups, hosts):
    # Groups that have already been resolved
    resolved_groups = {}
    # Group names that are not root
    non_root = set()
    # Make dict with resolution of each group
    result = {}
    for name in groups:
        result[name] = _resolve_rec(name, groups, hosts, resolved_groups, non_root)
    # Remove groups that are not root
    for name in groups:
        if name in non_root:
            del result[name]
    return result

def _resolve_rec(name, groups, hosts, resolved_groups, non_root):
    # If group has already been resolved finish
    if name in resolved_groups:
        return resolved_groups[name]
    # If it is a host finish
    if name in hosts:
        return hosts[name]
    # New group resolution
    resolved = {}
    for child in groups[name]:
        # Resolve each child
        resolved[child] = _resolve_rec(child, groups, hosts, resolved_groups, non_root)
        # Mark child as non-root
        non_root.add(child)
    # Save to resolved groups
    resolved_groups[name] = resolved
    return resolved
</code></pre>
<p>With your example:</p>
<pre><code>groups = {
    'servers': ['unix_servers', 'windows_servers'],
    'unix_servers': ['server_a', 'server_b', 'server_group'],
    'windows_servers': ['server_c', 'server_d'],
    'server_group': ['server_e', 'server_f']
}

hosts = {
    'server_a': '10.0.0.1',
    'server_b': '10.0.0.2',
    'server_c': '10.0.0.3',
    'server_d': '10.0.0.4',
    'server_e': '10.0.0.5',
    'server_f': '10.0.0.6'
}

d3 = {
    'servers': {
        'unix_servers': {
            'server_a': '10.0.0.1',
            'server_b': '10.0.0.2',
            'server_group': {
                'server_e': '10.0.0.5',
                'server_f': '10.0.0.6'
            }
        },
        'windows_servers': {
            'server_c': '10.0.0.3',
            'server_d': '10.0.0.4'
        }
    }
}


print(resolve(groups, hosts) == d3)
# True
</code></pre>
<p>Note this can fall into infinite recursion for malformed inputs, if you have for example group <code>A</code> containing group <code>B</code> but then group <code>B</code> contains group <code>A</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use simple recursion:</p>
<pre><code>def build(val): 
  return {i:build(i) for i in groups[val]} if val in groups else hosts[val]
</code></pre>
<hr/>
<pre><code>import json
print(json.dumps({'servers':build('servers')}, indent=4))
</code></pre>
<p>Output:</p>
<pre><code>{
  "servers": {
    "unix_servers": {
        "server_a": "10.0.0.1",
        "server_b": "10.0.0.2",
        "server_group": {
            "server_e": "10.0.0.5",
            "server_f": "10.0.0.6"
        }
    },
    "windows_servers": {
        "server_c": "10.0.0.3",
        "server_d": "10.0.0.4"
     }
  }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d3={}
main={}
for i in groups['servers']:
    if(i in groups):
        d={}
        for j in groups[i]:
            if(j in groups):
                dd={}
                for k in groups[j]:
                    dd[k]=hosts[k]
                d[j]=dd
            else:
                d[j]=hosts[j]
        main[i]=d
d3['servers']=main
print(d3)
</code></pre>
<p><strong>this will give</strong> :</p>
<pre><code>{
    'servers': 
    {
        'unix_servers': 
        {
            'server_group': 
            {
                'server_f': '10.0.0.6', 
                'server_e': '10.0.0.5'
            }, 
            'server_b': '10.0.0.2',
            'server_a': '10.0.0.1'
        }, 
        'windows_servers': 
        {
            'server_c': '10.0.0.3', 
            'server_d': '10.0.0.4'
        }
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess it needs just two loops, and no more. Here, the groups <code>dict</code> will be updated, more precisely, it'll lose some of its key-values.</p>
<pre class="lang-py prettyprint-override"><code>groups = {k: {s: None for s in subs} for k, subs in groups.items()}                                                                                                                                                        

for k, subs in groups.items():                                                                                                                                                                                        
    for subs_k, subs_v in subs.items():                                                                                                                                                                                       
        if subs_v is not None:                                                                                                                                                                                         
            continue                                                                                                                                                                                               
        if subs_k in groups:                                                                                                                                                                                           
            groups[k][subs_k] = groups[subs_k]                                                                                                                                                                             
            del groups[subs_k]                                                                                                                                                                                       
        else:                                                                                                                                                                                                      
            groups[k][subs_k] = hosts[subs_k]


print(groups)
</code></pre>
<p>you'd probably like to re-write it using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're ok with possibly having cross referencing data structure, you don't necessarily need to use recursion here. </p>
<pre><code>from itertools import chain

group_dicts = {k: {} for k in groups}

for g in group_dicts:
    for child_key in groups[g]:
        child = group_dicts.get(child_key, hosts.get(child_key))
        group_dicts[g][child_key] = child

# remove entries that are referenced at least once
not_top_levels = set(chain.from_iterable(groups.values()))
result = {g: group_dicts[g] for g in group_dicts if g not in not_top_levels}
</code></pre>
<p>Unlike other solutions, this will correctly handle cycles and infinitely recursive groups, as all the dict references are shared. When your <code>groups</code> topologically describes a tree, this will work exactly the same as the recursive solution. However, if your <code>groups</code> topologically describes a directed acyclic graph, this solution would share the dicts for all the nodes that appears more than once, while the recursive solution would copy and expand the duplicates out into a regular tree, this wouldn't really be an issue if you don't need to mutate the dicts. If your <code>groups</code> topologically describes a graph with cycles, then this will create those cycles, while the recursive solution would fall due to infinite recursion.</p>
</div>
<div class="post-text" itemprop="text">
<p>New to python I have been struggling though this but found a solution at last, it is quite long though.</p>
<pre><code>groups = {
    'servers': ['unix_servers', 'windows_servers'],
    'unix_servers': ['server_a', 'server_b', 'server_group'],
    'windows_servers': ['server_c', 'server_d'],
    'server_group': ['server_e', 'server_f']
}

hosts = {
    'server_a': '10.0.0.1',
    'server_b': '10.0.0.2',
    'server_c': '10.0.0.3',
    'server_d': '10.0.0.4',
    'server_e': '10.0.0.5',
    'server_f': '10.0.0.6'
}

result = {}

parent = '';

levels = [];

def check(s,r):
    if(r[s]==''): #check for each blank element in the result recursively
        sublist = {}
        for k in groups[s]: # check if the key exist in group if exist append children to result.   
            if k in hosts :
                sublist[k] = hosts[k] # check if host exist in hosts for this key
            else:
                sublist[k]=''
        if(key_exist(result, s)): # check if the key exist in result if exist append to result.             
            d = result 
            p = None
            for key in levels:
                p = d
                d = d[key]
            p[key] = sublist
            del levels[:]
        for x in sublist :
            if(sublist[x] == ''):
                check(x,p[key])

def resolve(r):
    for s in r:
        if(isinstance(r[s],dict)):
            return resolve(r[s])
        else:
            check(s,r)


def key_exist(groups, key): 
    for s in groups:
        if key in groups:
            levels.append(key);
            return True
        else:
            if(isinstance(groups[s],dict)):
                levels.append(s);
                return key_exist(groups[s], key)
    return False

# Find the root or parent element
for k in groups.keys(): 
    found = False
    for j in groups.keys(): 
        if k in groups[j]:
            found = False
        else:
            found = True
    if(found):
        parent = k  # root or parent element

# start making result with root element 
s = {}
for k in groups[parent]:
    s[k]='' # initialize child elements with blank
result[parent] = s 

resolve(result) 

print(result)
</code></pre>
</div>
<span class="comment-copy">Exactly what I was looking for and the comments clearly explain the process. Brilliant. Thank you.</span>
<span class="comment-copy">this is one of those scenarios where recursion really shines. virtually zero complexity in the entire program. beautiful answer.</span>
<span class="comment-copy">You can execute and check it here! <a href="https://ide.geeksforgeeks.org/KnY8NBzOq6" rel="nofollow noreferrer">ide.geeksforgeeks.org/KnY8NBzOq6</a></span>
<span class="comment-copy">This works in this instance but doesn't recurse if there are deeper levels than currently displayed.</span>
