<div class="post-text" itemprop="text">
<p>I am an undergraduate student who love programming. I had met a problem today which confuses me a lot. </p>
<blockquote>
<p>Write a program to determine if a given list possesses an additive
  sequence. That is, a sequence of 3 consecutive elements where the
  first two elements sum to the third. Return the sum value. Or return
  None if there are no such sums. </p>
<p>Example 1: </p>
<ul>
<li><p>Input: <code>[0,1,2,3,5,8,13]</code></p></li>
<li><p>Output: <code>3</code>, since 1+2 = 3. Note that 8 is also the sum of the two previous values, but it occurs after 3 </p></li>
</ul>
<p>Example 2: </p>
<ul>
<li><p>Input: <code>[1,2,4,5,6]</code> </p></li>
<li><p>Output: None. Since no consecutive values sum to a third consecutive value.</p></li>
</ul>
</blockquote>
<p>My answer is:</p>
<pre><code>def sequence_sum(my_list):
    for x in range(0, len(my_list)):
        if (my_list[x] + my_list[x+1]) != my_list[x+2]:
            return None
        else:
            return my_list[x+2]
</code></pre>
<p>The test results read as:</p>
<pre><code>Traceback (most recent call last):
  File "/grade/run/test.py", line 30, in test_larger
    self.assertEqual(sequence_sum(my_arr), 1)
AssertionError: None != 1
</code></pre>
<p>As well as:</p>
<pre><code>Traceback (most recent call last):
  File "/grade/run/test.py", line 35, in test_another
    self.assertEqual(sequence_sum([0,3,4,5,9]), 9)
AssertionError: None != 9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for x in range(0, len(my_list)):
    if (my_list[x] + my_list[x+1]) != my_list[x+2]:
        return None
    else:
        return my_list[x+2]
</code></pre>
<p>It is a mistake to have both branches <code>return</code> because it means either way the function will return in the very first iteration of the loop. If you find a match it is correct to return straightaway. But when you don't find a match, you can't declare failure. There may be a match later. The <code>return None</code> needs to be delayed until the entire list has been searched.</p>
<pre><code>for x in range(0, len(my_list)):
    if my_list[x] + my_list[x+1] == my_list[x+2]:
        return my_list[x+2]
return None
</code></pre>
<p>That'll fix the immediate problem, but run it and you will now encounter index out of range exceptions. I'll leave it to you to debug that problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Seems to me that you're only checking the first portion of the list. <code>return</code> will exit the function no matter where it is so after checking if <code>0 + 3</code> equals <code>4</code> it returns <code>None</code>. Therefore never getting to the end to check for <code>9</code>.</p>
<p>To fix this move your <code>return</code> to the end of the function and chance the comparator to <code>==</code>.</p>
<pre><code>for loop:
  if ([list[x]+list[x+1]) == list[x+2]:
    return list[x+2]
return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for x in range(0, len(my_list) - 2):
    if my_list[x] + my_list[x + 1] == my_list[x + 2]:
        return my_list[x + 2]
return None
</code></pre>
<p>You are checking for all the indexes (0, 1, 2, 3...) until the second one before the last as to not trigger an index out of boundary exception.
There, you check if any of the two consecutive ones are a sum of the next element in the list.
If there is such pair, you return it. If there is not (after going through the whole list), you return None.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>deque</code> to save two last elements:</p>
<pre><code>from collections import deque

def func(l: list):
    seq = deque(maxlen=2)
    for num, i in enumerate(l):
        if num &gt; 1 and sum(seq) == i:
            return i
        else:
            seq.append(i)

print(func([0, 1, 2, 3, 5, 8, 13]))
# 3

print(func([1,2,4,5,6]))
# None        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Yet another way:</h3>
<pre><code>found_sums = [x for i, x in enumerate(data[2:])
             if data[i] + data[i+1] == x]
first_value = next(iter(found_sums), None)
</code></pre>
<p><em>found_sums</em> is a list comprehension that returns the values which are equal to the sum of the two preceding ones. <em>first_value</em> returns the first of these values or alternatively None, if the list is empty.</p>
<h3>Test:</h3>
<pre><code>for data in ([0,1,2,3,5,8,13], [1,2,4,5,6]):
    found_sums = [x for i, x in enumerate(data[2:]) if data[i] + data[i + 1] == x]
    first_value = next(iter(found_sums), None)
    print('Result for {}:\t{}'.format(data, first_value))
</code></pre>
<p>This returns:</p>
<blockquote>
<p>Result for [0, 1, 2, 3, 5, 8, 13]:    3</p>
<p>Result for [1, 2, 4, 5, 6]:   None</p>
</blockquote>
</div>
<span class="comment-copy"><code>if (my_list[x] + my_list[x+1]) != my_list[x+2]: return None</code> you shouldn't return the value here as you have yet to iterate over the complete list. Return None only when you have exited the for loop. Essentially, your current code only runs for <code>x = 0</code> and then exits.</span>
<span class="comment-copy">Also, you wouldn't want to iterate over the entire length of  <code>my_list</code> as it'll throw an Index out of range exception. It should be <code>len(my_list) - 2</code></span>
<span class="comment-copy">You're ignoring the upper boundary conditions. This will cause an index out of range error if the list has no additive elements</span>
<span class="comment-copy">Not at all; I mentioned it at the end. I think the OP will learn more if he solves that problem himself.</span>
<span class="comment-copy">Thanks a lot! I have debugged the boundary conditions and solved this problem.</span>
