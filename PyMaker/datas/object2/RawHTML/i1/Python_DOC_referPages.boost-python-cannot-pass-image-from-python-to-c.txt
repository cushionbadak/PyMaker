<div class="post-text" itemprop="text">
<p>I'm trying to pass an image from python to C++ using boost.python. Here is my python code:</p>
<pre><code>import cv2
imgs = []
img1 = cv2.imread('img1.jpg')
img2 = cv2.imread('img2.jpg') 
imgs.append(img1)
imgs.append(img2)   
frame_size = imgs[0].shape[:2]
new_img = imwriteInC(imgs, frame.size[1], frame.size[0])
</code></pre>
<p>Here is the c++ code:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;boost/pythong.hpp&gt;
#include &lt;Python.h&gt;
using namespace cv;

bp::list imwriteInC(bp::list frames, int img_width, int img_height){
    Mat input_frame, new_frame;

    const char* first_frame = bp::extract&lt;const char*&gt;(bp::str(frames[0]));

    input_frame = Mat(img_height, img_width, CV_8UC3);  

    new_frame.create(input_frame.size(), CV_8UC3);
    size_t memsize = 3 * img_height * img_width;
    memcpy(new_frame.data, first_frame, memsize));

    imwrite("cImage.png", new_frame); 
    ...
    return outputList
}
</code></pre>
<p>The original image should be:</p>
<p><a href="https://i.stack.imgur.com/YD4jn.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/YD4jn.png"/></a></p>
<p>However, after passing this image into C++, the imwrite result becomes</p>
<p><a href="https://i.stack.imgur.com/5mFQI.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/5mFQI.png"/></a></p>
<p>I'm not good at C++. Could anyone points out how to fix it? Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like <code>cv2</code> images expose their data via the buffer protocol. In the C layer there are a <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">set of functions</a> you can use to access this data.</p>
<p>Example usage, with no error checking:</p>
<pre><code>// get data into a buffer and check the size
Py_buffer view;
PyObject_GetBuffer(frames[0], &amp;view, PyBUF_SIMPLE);
size_t memsize = 3 * img_height * img_width;
assert( memsize == view.len );

// copy data from buffer
Mat input_frame;
input_frame = Mat(img_height, img_width, CV_8UC3);
memcpy(input_frame.data, view.buf, memsize);

// release buffer
PyBuffer_Release(&amp;view);
</code></pre>
</div>
<span class="comment-copy">We're missing quite a lot of code and detail. Ensure that we can reproduce your problem only with the information you provide. If you couldn't reproduce it without information you've missed out, then we can't either!</span>
<span class="comment-copy">@LightnessRacesinOrbit Thanks for the tip. I've edited the problem description.</span>
<span class="comment-copy"><code>const char* first_frame = bp::extract&lt;const char*&gt;(bp::str(img));</code> Seems like something's still missing. What is <code>img</code>? If I were to copy those two blocks of code into files and build them and run it, would I get your results? Or would I get a compilation error?</span>
<span class="comment-copy">I don't think <code>bp::str(frames[0])</code> does what you want it to do. Documentation suggests it's the same as calling <code>str(frames[0])</code> in python. You need a function that exposes the underlying buffer of the image.</span>
<span class="comment-copy">@Dunes Yes, you are right. It turns out <code>bp::str(frames[0])</code> just convert every thing in numpy array to string, even the <code>[</code> symbol and the blank space. Could you give me some hints about how to expose the underlying buffer of the image? I tried PyBytes_AsString, it didn't work either. Thank you!</span>
