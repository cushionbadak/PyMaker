<div class="post-text" itemprop="text">
<p>Does anyone know a good way in python to check if a number is divisible by another in floating point in python?</p>
<p>This first thing I tried was ...</p>
<pre><code>3.5 % 0.1 == 0.0
</code></pre>
<p>But this returns <code>False</code> so then maybe</p>
<pre><code>3.5 % 0.1 &gt;= 1e-6 
</code></pre>
<p>But also <code>False</code> ... bummer ... it turns out that</p>
<pre><code>3.5 % 0.1
&gt;&gt; 0.099999999924
</code></pre>
<p>So then this works: </p>
<pre><code>LAMBDA = 1e-9
def is_divisible_by(x, y):
   m = x % y
   dy = abs(y - m)
   return m &lt; LAMBDA or dy &lt; LAMBDA

is_divisible_by(3.5, 0.1)
</code></pre>
<p>But this seems dangerous because I have to pick a LAMBDA. What about if <code>y = LAMBDA / 2</code>... </p>
<pre><code>is_divisible_by(LAMBDA/2, (LAMBDA/2) + 1e-10)
&gt;&gt;&gt; True
</code></pre>
<p>So then </p>
<pre><code>  def is_divisible_by(x, y):
      l = y * 1e-2
      m = x % y
      dy = abs(y - m)
      return m &lt; l or dy &lt; l

  is_divisible_by(3.5 * 1e-10, 0.1 * 1e-10)
  &gt;&gt;&gt; True

  is_divisible_by(0.21, 0.211)
  &gt;&gt;&gt; True
</code></pre>
<p>Bummer.</p>
<p>Is there anyway to solve this without going down a massive rabbit whole?  </p>
</div>
<div class="post-text" itemprop="text">
<p>Depending on the source of your floating point numbers, the <a href="https://docs.python.org/2/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a> module might be useful.</p>
<pre><code>&gt;&gt;&gt; import decimal
&gt;&gt;&gt; decimal.Decimal("3.5") % decimal.Decimal("0.1")
Decimal('0.0')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>floating point numbers are "fuzzy". A good high-level mental model for floating point numbers is that they represent a small range of numbers (e.g 1.5 really means some number between 1.4999 and 1.5002). Because of this, there is not good way to check if one is divisible by another. Instead, to check if non-integer numbers are divisible by each other, you might want to use <a href="https://en.wikipedia.org/wiki/Rational_number" rel="nofollow noreferrer">rational-type numbers</a>. In python, there's a module for this, called Fraction. You can use it like this</p>
<pre><code>from fractions import Fraction
a = Fraction(35,10) # 3.5
b = Fraction(1,10) # .1
a%b # evaluates to Fraction(0, 1)
</code></pre>
<p>Another answer mentioned the decimal python module. Fraction and decimal are interoperable.</p>
<pre><code>from fractions import Fraction
from decimal import Decimal
a = Fraction(Decimal('3.5')) # 3.5
b = Fraction(Decimal('0.1)) # 0.1
a%b # evaluates to Fraction(0, 1)
</code></pre>
<p>I'm going to advocate for using Fraction as it is a bit more flexible</p>
<pre><code>from fractions import Fraction
from decimal import Decimal
c = Decimal('1')
d = Decimal('.3')
c/d  # evaluates to Decimal('3.333333333333333333333333333')
c/d*d  # evaluates to Decimal('0.9999999999999999999999999999')
c = Fraction(c)
d = Fraction(d)
c/d # evaluates to Fraction(10, 3)
c/d*d # evaluates to Fraction(1, 1)
</code></pre>
</div>
<span class="comment-copy">Floating point is an approximation, it's not really possible to do this reliably.</span>
<span class="comment-copy">Why are you using floating-point numbers for this in the first place?</span>
<span class="comment-copy">You could scale all the numbers up, round them, and then test whether those numbers are divisible.</span>
<span class="comment-copy">What every Programmer should know about floating point arithmetic - <a href="https://floating-point-gui.de/" rel="nofollow noreferrer">floating-point-gui.de</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a></span>
<span class="comment-copy">Thanks ... <code>decimal.Deciaml(str(x)) % deciaml.Decimal(str(y)) == 0.0</code> seems to work here.</span>
<span class="comment-copy">The catch is that if your floating point numbers are already imprecise <code>decimal.Decimal(str(x))</code> can't reintroduce the precision. Eg: <code>decimal.Decimal(str(1.0 / 3)) * 3 == 1</code> will return <code>False</code>.</span>
<span class="comment-copy">I don't do any operations on the floating point prior to this so the amount of error should be very reasonable. I think this is good.</span>
<span class="comment-copy">I strongly disagree with that mental model of floating-point numbers, but agree with the <code>fractions.Fraction</code> recommendation.</span>
<span class="comment-copy">@user2357112 I agree it isn't perfect. Don't use the proposed mental model if you're intimately familiar with <a href="https://en.wikipedia.org/wiki/IEEE_754" rel="nofollow noreferrer">IEEE 754</a>. But, if you just type in a number with decimal (without picking it carefully), the IEEE 745 representation probably carries some error. Floating points do represent exact integers in a certain range, along with a bunch more numbers. This mental model is conservative and beginner-friendly, but ultimately false. There are more accurate models, but they are not as beginner friendly in my opinion.</span>
