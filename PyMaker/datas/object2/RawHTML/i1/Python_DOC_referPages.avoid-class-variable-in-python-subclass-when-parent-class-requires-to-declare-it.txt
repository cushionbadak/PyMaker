<div class="post-text" itemprop="text">
<p>I read that it is considered bad practice to create a variable in the class namespace and then change its value in the class constructor.</p>
<p>(One of my sources: <a href="https://softwareengineering.stackexchange.com/questions/254576/is-it-a-good-practice-to-declare-instance-variables-as-none-in-a-class-in-python">SoftwareEngineering SE: Is it a good practice to declare instance variables as None in a class in Python</a>.)</p>
<p>Consider the following code:</p>
<pre><code># lib.py
class mixin:
    def __init_subclass__(cls, **kwargs):
        cls.check_mixin_subclass_validity(cls)
        super().__init_subclass__(**kwargs)

    def check_mixin_subclass_validity(subclass):
        assert hasattr(subclass, 'necessary_var'), \
            'Missing necessary_var'

    def method_used_by_subclass(self):
        return self.necessary_var * 3.14


# app.py
class my_subclass(mixin):
    necessary_var = None

    def __init__(self, some_value):
        self.necessary_var = some_value

    def run(self):
        # DO SOME STUFF
        self.necessary_var = self.method_used_by_subclass()
        # DO OTHER STUFF
</code></pre>
<p>To force its subclass to declare the variable <em>necessary_var</em>, the class <code>mixin</code> uses the metaclass <code>subclass_validator</code>.</p>
<p>And the only way I know to makes it work on <strong><code>app.py</code></strong> side, is to initialized <em>necessary_var</em> as a class variable.</p>
<p><strong>I am missing something or is it the only way to do so?</strong></p>
</div>
<div class="post-text" itemprop="text">
<h1>Short answer</h1>
<p>You should check that attributes and methods exist at instantiation of a class, not before. This is what the <code>abc</code> module does and it has good reasons to work like this.</p>
<h1>Long answer</h1>
<p>First, I would like to point out that it seems what you want to check is that an instance attribute exists.</p>
<p>Due to Python dynamic nature, it is not possible to do so before an instance is created, that is after the call to <code>__init__</code>. We could define <code>Mixin.__init__</code>, but we would then have to rely on the users of your API to have perfect hygiene and to always call <code>super().__init__</code>.</p>
<p>One option is thus to create a metaclass and add a check in its <code>__call__</code> method.</p>
<pre><code>class MetaMixin(type):
    def __call__(self, *args, **kwargs):
        instance = super().__call__(*args, **kwargs)
        assert hasattr(instance, 'necessary_var')

class Mixin(metaclass=MetaMixin):
    pass

class Foo(Mixin):
    def __init__(self):
        self.necessary_var = ...

Foo() # Works fine

class Bar(Mixin):
    pass

Bar() # AssertionError
</code></pre>
<p>To convince yourself that it is good practice to do this at instantiation, we can look toward the <code>abc</code> module which uses this behaviour.</p>
<pre><code>from abc import abstractmethod, ABC

class AbstractMixin(ABC):
    @abstractmethod
    def foo(self):
        ...

class Foo(AbstractMixin):
    pass

# Right now, everything is still all good

Foo() # TypeError: Can't instantiate abstract class Foo with abstract methods foo
</code></pre>
<p>As you can see the <code>TypeError</code> was raise at instantiation of <code>Foo()</code> and not at class creation.</p>
<h2>But why does it behave like this?</h2>
<p>The reason for that is that not every class will be instantiated, consider the example where we want to inherit from <code>Mixin</code> to create a new mixin which checks for some more attributes.</p>
<pre><code>class Mixin:
    def __init_subclass__(cls, **kwargs):
        assert hasattr(cls, 'necessary_var')
        super().__init_subclass__(**kwargs)

class MoreMixin(Mixin):
    def __init_subclass__(cls, **kwargs):
        assert hasattr(cls, 'other_necessary_var')
        super().__init_subclass__(**kwargs)

# AssertionError was raised at that point

class Foo(MoreMixin):
    necessary_var = ...
    other_necessary_var = ...
</code></pre>
<p>As you see, the <code>AssertionError</code> was raised at the creation of the <code>MoreMixin</code> class. This is clearly not the desired behaviour since the <code>Foo</code> class is actually correctly built and that is what our mixin was supposed to check.</p>
<p>In conclusion, the existence of some attribute or method should be done at instantiation, Otherwise, you are preventing a whole lot of helpful inheritance techniques. This is why the <code>abc</code> module does it like that and this is why we should.</p>
</div>
<span class="comment-copy">Why don't you just let the error happen when you try to access the non-existent <code>self.necessary_var</code>?</span>
<span class="comment-copy"><code>assert</code> raising an <code>AssertionError</code> would <i>also</i> be a side-effect in production.</span>
<span class="comment-copy">However, if someone is going to not set <code>necessary_var</code>, what stops them from not inheriting from <code>mixin</code> as well? It seems as easy to bypass the check as it is to bypass the thing you want to check.</span>
<span class="comment-copy">Note, too, that you aren't changing the value of the <i>class</i> variable <code>necessary_var</code>, in <code>my_subclass.__init__</code>, you are <i>shadowing</i> it with an <i>instance</i> variable named <code>necessary_var</code>.</span>
<span class="comment-copy">@N0ne In that case, the only sensible approach is to document your apis properly and allow the exception to be raised normally. As devs, they should want that exact behaviour so that they can debug their coding errors efficiently. If they still complain, politely refer them to your documentation.</span>
<span class="comment-copy">Thanks for your answer. Abstract class now totally makes sense</span>
