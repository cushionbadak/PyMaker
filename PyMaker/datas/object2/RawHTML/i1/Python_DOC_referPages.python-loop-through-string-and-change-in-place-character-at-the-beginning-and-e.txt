<div class="post-text" itemprop="text">
<p>I'm trying to create some variables within string with words that follows a specific format.</p>
<p>For instance, my original string is:</p>
<pre><code>string = '@Cost1 + (@Cost2 + @Cost3) / @Revenue1 * 1.2'
</code></pre>
<p>I have already created a dictionnary as follow:</p>
<pre><code>mydict = {'Cost1' : 10, 'Cost2' : 5, 'Cost3' : 1, 'Revenue1' : 10}
</code></pre>
<p>What I would like to create is a function that will replace the @Cost1 (for instance) by:
<code>mydict.get('Cost1')</code> so that I can consider the @ in my string as a marker for variable and look for the value in my dictionnary.</p>
<p>Therefore, my intent is to:</p>
<ul>
<li>replace the @ by <code>mydict.get('</code> --&gt; that is very easy with the string.replace() function</li>
<li>add <code>')</code> at the end of the chain of alphabet letters that follows the @words --&gt; this one I'm having difficulty to implement</li>
</ul>
<p>I was considering a for loop but struggling with the logic to add the "')" after the end of each word preceded by an @. Also thought about generator but not too sure</p>
<p>Also, I would like to add a check that every @Cost1, @Cost2 etc. is in my dictionnary, but this one I should be able to do it.</p>
<p>Any help is welcome about this</p>
<p>Thank you !</p>
<p>Eric</p>
<p>Edit:</p>
<p>following your comment, I would like my final output to be:</p>
<pre><code>string = mydict.get('Cost1') + ( mydict.get('Cost2') + mydict.get('Cost3') ) / mydict.get('Revenue1') * 1.2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you need to capture a regular expression <code>@</code>+letters/digits/underscore,  which is <code>"@(\w+)</code> (matches <code>@</code> then 1 or more letter/digit/underscore and create a group with those) fed to a <em>replacement function</em></p>
<pre><code>import re
mydict = {'Cost1' : 10, 'Cost2' : 5, 'Cost3' : 1, 'Revenue1' : 10}
string = '@Cost1 + (@Cost2 + @Cost3) / @Revenue1 * 1.2'

expression = re.sub("@(\w+)",lambda m : str(mydict.get(m.group(1),0)),string)
</code></pre>
<p>result:</p>
<pre><code>'10 + (5 + 1) / 10 * 1.2'
</code></pre>
<p>This method is highly efficient because it uses the dictionary lookup instead of looping to replace and create as many strings as there are variables.</p>
<p>note that any unknown variable yields 0. If you don't want that use <code>mydict[m.group(1)]</code> to trigger key error instead.</p>
<p>The <code>lambda</code> isn't compulsory either. You can write a real function instead as long as it takes a <code>match</code> object as input and returns a string as output:</p>
<pre><code>def repfunc(m)
    return str(mydict.get(m.group(1),0))

re.sub("@(\w+)",repfunc,string)
</code></pre>
<p>(that's why we convert to string after getting the value)</p>
<p>Once you have that expression, you can apply an evaluator (<code>eval</code> is the simplest but the less safe, <code>ast.literal_eval</code> won't work because it doesn't support operations, but there are others, for instance the <code>simpleeval</code> third-party module (which can be fed a list of variables which would simplify the answer even more), or other examples here: <a href="https://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string">Evaluating a mathematical expression in a string</a>)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>string = '@Cost1 + (@Cost2 + @Cost3) / @Revenue1 * 1.2'
mydict = {'Cost1' : 10, 'Cost2' : 5, 'Cost3' : 1, 'Revenue1' : 10}
string = string.replace('@', '')
for i in mydict:
    string = string.replace(i, str(mydict[i]))

print(string)
print(eval(string))
</code></pre>
<p>output:</p>
<pre><code>10 + (5 + 1) / 10 * 1.2

10.72
</code></pre>
</div>
<span class="comment-copy">Could you post a sample output?</span>
<span class="comment-copy">I have no idea what <i>"add "')" at the end of the chain of alphabet letters that follows the @words"</i> means. What's "the end of the chain of alphabet letters that follows the @words"?</span>
<span class="comment-copy">Merci Jean-Fran√ßois !  That dit it.  One question, I want to catch error properly: How do I do it ? When I add as you say mydict[m.group(1)], it gives me key error but I don't know which key is it. How I can get it ?  Also, is it possible to detail what is the behaviour of the : "@(\w+)" in the sub and also the lambda m : str(mydict.get(m.group(1),0))  Thanks  Edit: Sorry I made a mistake, I can see the key erroring. If you can give me the explanation of the lambda function, very appreciated</span>
<span class="comment-copy">I have added a non-lambda version.</span>
<span class="comment-copy"><code>ast.literal_eval</code> does not support additions.  You might have an old version of Python, where some basic addition was handled (but it was actually a bug in <code>ast.literal_eval</code>, caused by complex numbers literal parsing).</span>
<span class="comment-copy">it was implemented to handle evaluation of complex numbers AFAIR. Okay, I'll edit it out, thanks.</span>
