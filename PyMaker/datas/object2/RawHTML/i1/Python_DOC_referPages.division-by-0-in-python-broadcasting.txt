<div class="post-text" itemprop="text">
<p>I'm using Python2.7 to create a simple vector field and then plotting it... </p>
<p>But Jupyter complains about a division by 0 ("RuntimeWarning: divide by zero encountered in divide"), and I can't find it. </p>
<pre><code>import numpy as np

def field_gen(x0, y0, x, y, q_cons = 1):
    dx = x0-x
    dy = y0-y
    dist = np.sqrt(np.square(dx)+np.square(dy))
    kmod = np.where( dist&gt;0.00001, q_cons / dist, 0  ) 
    kdir = np.where( kmod != 0, (np.arctan2(-dy,-dx) * 180 / np.pi), 0)
    res_X = np.where( kmod !=0, kmod * (np.cos(kdir)) , 0 )
    res_Y = np.where( kmod !=0, kmod * (np.sin(kdir)) , 0 )
    return (res_X, res_Y)

n = 10
X, Y = np.mgrid[0:n, 0:n]

x0=2
y0=2

(u,v)= field_gen(x0, y0, X, Y)
#print(u) #debug
#print
#print(v)
plt.figure()
plt.quiver(X, Y, u, v, units='width')
</code></pre>
<p>Any hints on that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't be fooled into think <code>np.where</code> does all the work here. Python will still evaluate all the input arguments first, before running calling <code>np.where</code>.</p>
<p>So in your command <code>kmod = np.where( dist&gt;0.00001, q_cons / dist, 0  )</code>, Python will evaluate <code>dist&gt;0.00001</code> (ok) and <code>q_cons / dist</code> (bad!) before running <code>np.where</code>.</p>
<p>Try <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.divide.html" rel="nofollow noreferrer">np.divide</a> instead. I think you want something like this:</p>
<pre><code>np.divide(q_cons, dist, where=dist&gt;0.00001 )
</code></pre>
</div>
<span class="comment-copy">While <code>np.where</code> can be used to say "where this is true use this; else do that", it still will evaluate the entire of <code>q_cons / dist</code> first. <code>dist</code> will have a zero entry in it at <code>[2,2]</code>. Thus the error.</span>
<span class="comment-copy">Thanks @freethebees , I'm still new at Python. Are there any alternatives that doesn't evaluate the statements first?</span>
<span class="comment-copy">No worries! This is a classic Python gotcha. See my answer below. <code>np.divide</code> will take <code>dist &gt; 0.001</code> as an input and use that to iterate through your array. Iterating manually would be slow in Python, but NumPy has some great compiled stuff that does that kind of thing real quick for you.</span>
<span class="comment-copy">Well, it works, thanks again! I was trying an ugly c-like approach... Using "dist = np.where( dist &gt; 0, dist, np.inf )" inbetween. But, using your solution, in the case of [2,2], it gave back a 0, and I'm wondering if that's a default behavior from np.divide... docs says "values of False indicate to leave the value in the output alone", but since it wasn't provided an out array ("If not provided or None, a freshly-allocated array is returned"), it was allocated with zeros ?</span>
<span class="comment-copy"><code>out</code> allows you to define an array to put the result in. From what I understand, if that array was one filled with ones, then the cells that are <code>False</code> in <code>where</code> will be ones. In you don't provide <code>out</code>, then it creates a blank array and uses the values from <code>q_cons</code>. You'd have to play around a bit to be sure though. Glad I could help.</span>
