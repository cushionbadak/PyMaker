<div class="post-text" itemprop="text">
<p>I'd like to take the first n value from rows in a numpy array, where n is specified in a separate 1-d array:</p>
<pre><code>import numpy as np

a = np.zeros((5, 5))
n = [1, 3, 2, 4, 1]

result = [[1, 0, 0, 0, 0],
          [1, 1, 1, 0, 0],
          [1, 1, 0, 0, 0],
          [1, 1, 1, 1, 0],
          [1, 0, 0, 0, 0]]
</code></pre>
<p>I'm looking for a solution that does not require iteration, as the result array will have millions of rows.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use outer-comparison of <code>n</code> against a range array upon leveraging <a href="https://docs.scipy.org/doc/numpy/user/theory.broadcasting.html#array-broadcasting-in-numpy" rel="nofollow noreferrer"><code>broadcasting</code></a> to create the mask and hence the final array -</p>
<pre><code>ncols = 5
mask_out = np.greater.outer(n,np.arange(ncols))
</code></pre>
<p>Sample run -</p>
<pre><code>In [19]: n = [1, 3, 2, 4, 1]

In [9]: ncols = 5

# Output as mask
In [10]: np.greater.outer(n,np.arange(ncols))
Out[10]: 
array([[ True, False, False, False, False],
       [ True,  True,  True, False, False],
       [ True,  True, False, False, False],
       [ True,  True,  True,  True, False],
       [ True, False, False, False, False]])

# Output as array of 0s and 1s
In [11]: np.greater.outer(n,np.arange(ncols)).view('i1')
Out[11]: 
array([[1, 0, 0, 0, 0],
       [1, 1, 1, 0, 0],
       [1, 1, 0, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 0, 0, 0, 0]], dtype=int8)
</code></pre>
<p>If you have to fill an already initialized array <code>result</code>, simply use <code>mask_out</code> to mask the array, i.e. <code>result[mask_out] = ...</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a method using advanced indexing into an array of template rows:</p>
<pre><code>def f_pp(a, ncol=None):
    if ncol is None:
        ncol = a.max()
    t = np.array([1, 0], 'u1').repeat(ncol)
    ts, = t.strides
    t = np.lib.stride_tricks.as_strided(t[ncol:], (ncol+1, ncol), (-ts, ts))
    return t[a]
</code></pre>
<p>Timings using @Divakar as a reference:</p>
<pre><code>def f_div(a, ncol=None):
    if ncol is None:
        ncol = a.max()
    return np.greater.outer(a, np.arange(ncol))

from timeit import timeit

for ncol, nrow in [(10, 10**7), (100, 10**6), (1000, 10**5), (10000, 10000)]:
    a = np.random.randint(0, ncol+1, nrow)
    print('\n', ncol, nrow, ':')
    print('div', timeit(lambda: f_div(a), number=10))
    print('pp ', timeit(lambda: f_pp(a), number=10))
</code></pre>
<p>Prints:</p>
<pre><code> 10 10000000 :
div 2.4297873955219984
pp  1.698299034498632

 100 1000000 :
div 1.465646200813353
pp  0.4803247870877385

 1000 100000 :
div 1.3471891237422824
pp  0.35979613568633795

 10000 10000 :
div 0.6783521044999361
pp  0.38309483136981726
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you are trying to get something like this? There may be a <code>numpy</code> specific method I am unaware of that are faster, but if speed is not an issue this should suffice:</p>
<pre><code>import numpy as np

a = np.zeros((5, 5))
n = [1, 3, 2, 4, 1]

for index in range(len(n)):
    a[index][0:n[index]] = 1

print(a)
</code></pre>
<p>Outputs</p>
<blockquote>
<p>[[1. 0. 0. 0. 0.]
   [1. 1. 1. 0. 0.]
   [1. 1. 0. 0. 0.]
   [1. 1. 1. 1. 0.]
   [1. 0. 0. 0. 0.]]</p>
</blockquote>
</div>
<span class="comment-copy">Yeah, the data I'm working with are actually quite large so I'm hoping to find a numpy method.  I will update my question to reflect that.</span>
