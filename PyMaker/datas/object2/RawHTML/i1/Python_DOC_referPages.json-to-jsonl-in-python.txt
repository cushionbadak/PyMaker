<div class="post-text" itemprop="text">
<pre><code>OrderedDict([('attributes', OrderedDict([('type', 'SurveyQuestionResponse__c'), ('url', '&lt;URL&gt;')])), ('Id', 'a0V3600000ASsIGEA1'), ('IsDeleted', False), ('Name', 'Response-0092757'), ('CurrencyIsoCode', 'USD'), ('CreatedDate', '2017-09-15T07:00:00.000+0000'), ('CreatedById', '00536000004RpBDAA0'), ('LastModifiedDate', '2017-10-06T20:22:33.000+0000'), ('LastModifiedById', '00536000004RpBDAA0'), ('SystemModstamp', '2017-10-06T20:22:33.000+0000'), ('Survey_Question__c', 'a0X36000005D50OEAS'), ('SurveyTaker__c', 'a0W360000067bYmEAI'), ('Alias__c', '&lt;username&gt;'), ('Geography__c', 'AAAA'), ('Market__c', 'AAA'), ('Respondent_Type__c', 'Security - RSM'), ('Response__c', '5 minutes or less'), ('Score__c', 5.0), ('Site_Name__c', 'AAA001'), ('Vendor__c', '&lt;Vendor Name&gt;'), ('of_Time_Question_was_Responded_to__c', 1.0)])]
</code></pre>
<p>This is the imported JSON when I print it in python.  I am using the jsonlines package to try and get this parsed to jsonL so it can be used with redshift.</p>
<pre><code>data = initialQuery['records']  #this gives me the above orderedDict           
            with jsonlines.open(localFilePath+fileName.format(nextObj,fileCount),  mode='w') as outfile :
                outfile.write_all(data)
</code></pre>
<p>this is giving me back ALMOST what is needed.  The problem is that it is picking up the attributes portion of the JSON.  I am trying to drop the attributes portion and only include everything from ID on.</p>
<p>I tried:</p>
<pre><code>del data['attributes']
data.pop("attributes")
for element in data :
    data.pop('attributes', None)
for element in data :
    del data['attributes']
for element in data :
    data.pop('type', None)
</code></pre>
<p>none of them worked; what should I do differently?</p>
<p>Edit:
The answer I posted is not quite working right; I am only getting the first line and not all the lines for the current records set.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for the commenters; here is where we ended up:</p>
<pre><code>            data = initialQuery['records']
            item = data.pop()

            item.pop('attributes', None)
            tempdict = OrderedDict({})
            for k,v in item.items():
                tempdict[k.lower()] = v

            with open(localFilePath+fileName.format(nextObj,fileCount), 'w') as outfile :
                    outfile.write(json.dumps(tempdict))
                    outfile.write('\n')
</code></pre>
<p>this may not be the most efficient, but it does work. you need OrderedDict from collections for this.</p>
<p>Edit: This is only giving me the very first line of the JSON into the JSONL.  It is dropping everything else; back to the drawing board. </p>
<p>Edit2: Here is the fix</p>
<pre><code>for element in data :


        item = data.pop()
        item.pop('attributes', None)

        tempdict = OrderedDict({})
        for k,v in item.items() :
            if 'date' in k.lower() or 'stamp' in k.lower() :
                d = datetime.datetime.strptime(v,'%Y-%m-%dT%H:%M:%S.%f+0000')
                v = d.strftime('%Y-%m-%d %I:%M:%S')
                tempdict[k.lower()] = v
            else :
                tempdict[k.lower()] = v

        with open(localFilePath+fileName.format(nextObj,fileCount), 'a') as outfile :
            outfile.write(json.dumps(tempdict))
            outfile.write('\n')
</code></pre>
</div>
<span class="comment-copy"><code>del data['attributes']</code> should work just fine. What do you mean by "none of them worked"?</span>
<span class="comment-copy">I have a try: in front of the code piece for writing the JSON and it keeps popping the exception.  Let me pull that out and see what it is doing.</span>
<span class="comment-copy">Please update your question with the traceback then.</span>
<span class="comment-copy">Why the for loops when the body of the loops don't use the <code>element</code> variable?</span>
<span class="comment-copy">This has the issue that the result of <code>json.dumps</code> contains newlines and as such it isn't outputting JSONL which is newline separated objects. To fix that you have to tell it to not use them in formatting the JSON via the <code>separators</code> argument that should be <code>(',',':')</code>.</span>
<span class="comment-copy">This also has the issue that I am only ever getting the first "line" in the json.</span>
