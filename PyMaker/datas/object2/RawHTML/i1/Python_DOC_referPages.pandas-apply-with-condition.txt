<div class="post-text" itemprop="text">
<p>I have customers duplicates with different status because there is a row for each customer subscription/product. I want to generate a <code>new_status</code> for the customer and for it to be 'canceled', every subscription status must be 'canceled' together.</p>
<p>I used:</p>
<pre><code>df['duplicated'] = df.groupby('customer', as_index=False)['customer'].cumcount()
</code></pre>
<p>to separate every duplicated in a index to indicate the duplicated values</p>
<pre><code>Customer | Status | new_status | duplicated
 X       |canceled|            | 0
 X       |canceled|            | 1
 X       |active  |            | 2
 Y       |canceled|            | 0
 A       |canceled|            | 0
 A       |canceled|            | 1
 B       |active  |            | 0
 B       |canceled|            | 1
</code></pre>
<p>Thus, I'd like to use .apply and/or .loc to generate:</p>
<pre><code>Customer | Status | new_status | duplicated
 X       |canceled|            | 0
 X       |canceled|            | 1
 X       |active  |            | 2
 Y       |canceled|            | 0
 A       |canceled| canceled   | 0
 A       |canceled| canceled   | 1
 B       |active  |            | 0
 B       |canceled|            | 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From what I understand, you can try doing:</p>
<pre><code>df['new_status']=(df.groupby('Customer')['Status'].
  transform(lambda x: x.eq('canceled').all()).map({True:'cancelled'})).fillna(df.new_status)
print(df)

    Customer    Status new_status  duplicated
0   X         canceled             0         
1   X         canceled             1         
2   X         active               2         
3   Y         canceled  cancelled  0         
4   A         canceled  cancelled  0         
5   A         canceled  cancelled  1         
6   B         active               0         
7   B         canceled             1   
</code></pre>
<p>EDIT since expected o/p was changed:</p>
<pre><code>df['new_status']=(df.groupby('Customer')['Status'].
             transform(lambda x: x.duplicated(keep=False)&amp;(x.eq('canceled').all()))
                         .map({True:'cancelled',False:''}))
print(df)

  Customer    Status new_status  duplicated
0   X         canceled             0         
1   X         canceled             1         
2   X         active               2         
3   Y         canceled             0         
4   A         canceled  cancelled  0         
5   A         canceled  cancelled  1         
6   B         active               0         
7   B         canceled             1   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Compare column by <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.eq.html" rel="nofollow noreferrer"><code>Series.eq</code></a> for <code>==</code> and use <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.transform.html" rel="nofollow noreferrer"><code>GroupBy.transform</code></a> with <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.all.html" rel="nofollow noreferrer"><code>GroupBy.all</code></a> for check if all values are <code>True</code>s per groups, then compare <code>Customer</code> by <a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.duplicated.html" rel="nofollow noreferrer"><code>Series.duplicated</code></a> with <code>keep=False</code> for return all dupes. Last chain together by bitwise <code>AND</code> (<code>&amp;</code>) and set values by <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="nofollow noreferrer"><code>numpy.where</code></a>:</p>
<pre><code>m1 = df['Status'].eq('canceled').groupby(df['Customer']).transform('all')
m2 = df['Customer'].duplicated(keep=False)

df['new_status'] = np.where(m1 &amp; m2, 'cancelled', '')
print (df)
  Customer    Status new_status  duplicated
0        X  canceled                      0
1        X  canceled                      1
2        X    active                      2
3        Y  canceled                      0
4        A  canceled  cancelled           0
5        A  canceled  cancelled           1
6        B    active                      0
7        B  canceled                      1
</code></pre>
</div>
<span class="comment-copy">Y is not duplicated but it must canceled. the formula can include or not unique values</span>
<span class="comment-copy">Is performance important?</span>
<span class="comment-copy">Call function in <code>apply</code> or <code>transform</code> should be slow, if large dataframe.</span>
<span class="comment-copy">I think if not necessary.</span>
<span class="comment-copy">1800 cols. I think it's ok to use .apply and thanks I'm verifying the values, but looks correct</span>
<span class="comment-copy">I edited the post just to be as clear as possible, but the first o/p is even closer to what i want thank you. I'd like to understand more about how did you do that and when to use .map, .eq and .transform</span>
<span class="comment-copy">@RicardoFernandes no problem. So <code>x.eq('canceled').all()</code> checks all the grouped items from Status are equal to cancelled or not, so use <code>all()</code> returns true. than using map to replace true to 1 and false to blank. best will be try removing some parts of the code and i think you will understand. :) If any prob lemme know. Cheers..!!</span>
<span class="comment-copy">thank you so much. i didn't know the .transform and .eq methods so well</span>
<span class="comment-copy">@RicardoFernandes - Yes, it is groupbing by <code>Series</code> - <a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#dataframe-column-selection-in-groupby" rel="nofollow noreferrer">docs</a>. Btw, both solutions are correct. If my or another answer was helpful, don't forget <a href="https://meta.stackexchange.com/a/5235">accept</a> it. Thanks.</span>
