<div class="post-text" itemprop="text">
<p>Given an array A of shape (n,d). n is the number of points (or vectors) and d the dimension of each point. </p>
<p>I want to select points from A that are between two vectors mins and maxes. mins and maxes are of dimension d. mins and maxes have for each dimension the minimum value and the maximum value.</p>
<pre><code>A=array([[ 4,  3, 12,  7],
   [ 3,  2, 10,  5],
   [ 6, 10, 14,  8],
   [ 7, 11, 13, 14],
   [10, 16, 20, 14],
   [12, 19, 22, 16],
   [ 7, 10, 25, 18]])
mins = np.array( [5,9,12,6])
maxes = np.array( [10,17,20,15] )
</code></pre>
<p>the results expected are:</p>
<pre><code>[ 6, 10, 14,  8],

[ 7, 11, 13, 14],

[10, 16, 20, 14]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can filter these by the following line:</p>
<pre><code>x = np.logical_and((A &gt;= mins).sum(axis=1) == len(mins), (A &lt;= maxes).sum(axis=1) == len(mins))
result = A[x]
</code></pre>
<p><code>result</code>:</p>
<pre><code>array([[ 6, 10, 14,  8],
       [ 7, 11, 13, 14],
       [10, 16, 20, 14]])
</code></pre>
<p>Edit: The above can be simplified as:</p>
<pre><code>A[(A &lt;= maxes).sum(axis=1) &amp; (A &gt;= mins).sum(axis=1) == len(mins)]
</code></pre>
<p>In depth explanation:</p>
<pre><code>(A &gt;= mins).sum(axis=1) == len(mins)
</code></pre>
<p>returns an boolean array where all the <code>True</code> are indexes where each array element  within <code>A[index]</code> is larger or equal to each element in the <code>mins</code> array:</p>
<pre><code>array([False, False,  True,  True,  True,  True,  True], dtype=bool)
</code></pre>
<p>We join it with <code>(A &lt;= maxes).sum(axis=1) == len(mins)</code>, which represent all element smaller than <code>maxes</code>, <code>x</code> comes out to be</p>
<pre><code>array([False, False,  True,  True,  True, False, False], dtype=bool)
</code></pre>
<p>And we simply have to apply that to <code>A</code></p>
</div>
<span class="comment-copy">Thank you. You response is good. Is there another alternative that is faster if we have points of high dimensions (say 1000 for example) or your method is the fastest.</span>
<span class="comment-copy">I don't think so, this only compares your <code>mins</code> and <code>maxes</code> with each row of <code>A</code> just once. Which is the least amount of comparison you'll have to make. You can use <code>A[(A &lt;= maxes).sum(axis=1) &amp; (A &gt;= mins).sum(axis=1) == len(mins)]</code> to make it syntactically easier, but the underlying mechanism is the same. You also benefit from vectorization with numpy operations.</span>
