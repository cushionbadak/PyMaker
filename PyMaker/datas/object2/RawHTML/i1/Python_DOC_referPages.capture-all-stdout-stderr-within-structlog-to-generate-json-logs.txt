<div class="post-text" itemprop="text">
<p>I am currently trying to get away from print()'s and start with centralized log collection using the ELK stack and the structlog module to generate structured json log lines. This is working perfectly fine for modules that I wrote myself using a loggingHelper module that I can import and use with </p>
<pre><code>logger = Logger()
</code></pre>
<p>in other modules and scripts. This is the loggingHelper module class:</p>
<pre><code>class Logger:
    """
    Wrapper Class to import within other modules and scripts
    All the config and log binding (script
    """
    def __init__(self):
        self.__log = None
        logging.basicConfig(level=logging.DEBUG, format='%(message)s')
        structlog.configure(logger_factory=LoggerFactory(),
                            processors=[structlog.stdlib.add_log_level,
                            structlog.processors.TimeStamper(fmt="iso"),
                            structlog.processors.JSONRenderer()])
        logger = structlog.get_logger()
        main_script = os.path.basename(sys.argv[0]) if sys.argv[0] else None
        frame = inspect.stack()[1]
        log_invocation = os.path.basename(frame[0].f_code.co_filename)
        user = getpass.getuser()

        """
        Who executed the __main__, what was the executed __main__ file, 
        where did the log event happen?
        """
        self.__log = logger.bind(executedScript = main_script,
                                 logBirth = log_invocation,
                                 executingUser = user)

    def info(self, msg, **kwargs):
        self.__log.info(msg, **kwargs)

    def debug(self, msg, **kwargs):
        self.__log.debug(msg, **kwargs)

    def error(self, msg, **kwargs):
        self.__log.error(msg, **kwargs)

    def warn(self, msg, **kwargs):
        self.__log.warning(msg, **kwargs)
</code></pre>
<p>This produces nicely formatted output (one JSON per line) that filebeat is able to read and forward to Elasticsearch.
However, third-party librariers completely crush the well-formatted logs.</p>
<pre><code>{"executingUser": "xyz", "logBirth": "efood.py", "executedScript": "logAlot.py", "context": "SELECT displayname FROM point_of_sale WHERE name = '123'", "level": "debug", "timestamp": "2019-03-15T12:52:42.792398Z", "message": "querying local"}
{"executingUser": "xyz", "logBirth": "efood.py", "executedScript": "logAlot.py", "level": "debug", "timestamp": "2019-03-15T12:52:42.807922Z", "message": "query successful: got 0 rows"}
building service object
auth version used is: v4
Traceback (most recent call last):
  File "logAlot.py", line 26, in &lt;module&gt;
    ef.EfoodDataControllerMerchantCenter().get_displayname(123)
  File "/home/xyz/src/toolkit/commons/connectors/efood.py", line 1126, in get_displayname
    return efc.select_from_local(q)['displayname'].values[0]
IndexError: index 0 is out of bounds for axis 0 with size 0
</code></pre>
<p>As you can see both info level and error level messages from the third party librara (googleapiclient) are printed without going through the logging processors.</p>
<p>What would be the best way (and most pythonic) of capturing and formatting everything that happens within execution of one script using the loggingHelper module I wrote? Is this even best practice?</p>
<p>Edit: Currently the logger indeed writes to stdout itself, which is then redirected to a file in crontab using &gt;&gt; and 2&gt;&amp;1. This looks like bad practice to me if I want to redirect everything that is written to stdout/stderr by third-party library logging, because this would lead to a loop, correct? Thus my goal is not redirecting, but rather capturing everything in my logging processor. Changed the title accordingly.</p>
<p>Also, here is a rough overview of what I am trying to achieve. I am very open to general criticism and suggestions that diviate from this.
<a href="https://i.stack.imgur.com/gMlhh.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/gMlhh.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<h3>Configuring the <code>logging</code> module</h3>
<blockquote>
<p>As you already figured out, <code>structlog</code> requires configuration of the
  logging functionality already existing in python.</p>
<p><a href="http://www.structlog.org/en/stable/standard-library.html" rel="nofollow noreferrer">http://www.structlog.org/en/stable/standard-library.html</a></p>
</blockquote>
<p><code>logging.basicConfig</code> supports options for <code>stream</code> and <code>filename</code> here</p>
<p><a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html#logging.basicConfig</a>.</p>
<p><strong>Either</strong> you specify a filename which the logger will create a handle to and direct all its output. Depending on how you are set up maybe this would be the file you normally redirect to</p>
<pre><code>import logging

logging.basicConfig(level=logging.DEBUG, format='%(message)s', filename='output.txt')
</code></pre>
<p><strong>Or</strong> you can pass a StringIO object to the builder, which you can later read from and then redirect to your wished output destination</p>
<pre><code>import logging
import io

stream = io.StringIO()

logging.basicConfig(level=logging.DEBUG, format='%(message)s', stream=stream)
</code></pre>
<blockquote>
<p>More about StringIO can be read here</p>
<p><a href="https://docs.python.org/3/library/io.html#io.TextIOBase" rel="nofollow noreferrer">https://docs.python.org/3/library/io.html#io.TextIOBase</a></p>
</blockquote>
<p>As <strong>@bruno</strong> pointed out in his answer, do not do this in an <code>__init__</code> as you may end up calling this piece of code several times in the same process.</p>
</div>
<div class="post-text" itemprop="text">
<p>First thing first: you should NOT do any logger config (<code>logging.basicConfig</code>, <code>logging.dictConfig</code> etc) in your class initializer - the logging configuration should be done once <strong>and only once</strong> at process startup. The whole point of the <code>logging</code> module is to completely decouple logging calls</p>
<p>Second point: I'm no <code>structlog</code> expert (and that's an understatement - it's actually the very first time I hear about this package) but the result you get is what was to be expected from your code snippet: only your own code uses <code>structlog</code>, all other libs (stdlib or 3rd part) will still use the <code>stdlib</code> logger and emit plain text logs. </p>
<p>From what I've seen in <code>structlog</code> doc, it seems to provide some way to <a href="https://www.structlog.org/en/stable/configuration.html#logger-factories" rel="nofollow noreferrer">wrap the stdlib's loggers using the <code>structlog.stdlib.LoggerFactory</code></a> and <a href="https://www.structlog.org/en/stable/processors.html" rel="nofollow noreferrer">add specific formatters to have a more consistant output</a>. I have not tested this (yet) and the official doc is a bit sparse and lacking usable practical example (at least I couldn't find any) but <a href="http://stevetarver.github.io/2017/05/10/python-falcon-logging.html" rel="nofollow noreferrer">this article</a> seems to have a more explicit example (to be adapted to your own context and use case of course). </p>
<p><strong>CAVEAT</strong> : as I said I never used <code>structlog</code> (first time I hear of this lib) so I might have misunderstood some things, and you will of course have to experiment to find out how to properly configure the whole thing to get it to work as expected. </p>
<p>As a side note: in unix-like systems <code>stdout</code> is supposed to be for program's outputs (I mean "expected output" =&gt; the program's actual <em>results</em>), while all error / reporting / debugging messages belong to <code>stderr</code>. Unless you have compelling reasons to do otherwise you should try and stick to this convention (at least for command-line tools so you can chain / pipeline them the unix way).</p>
</div>
