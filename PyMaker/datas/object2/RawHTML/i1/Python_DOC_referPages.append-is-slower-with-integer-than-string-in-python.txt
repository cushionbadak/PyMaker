<div class="post-text" itemprop="text">
<p>I come across this code while looking for a way to measure functions speed.</p>
<pre><code>def test():
    """Stupid test function"""
    L = []
    for i in range(100):
        L.append(i)

if __name__ == '__main__':
     import timeit
     print(timeit.timeit("test()", setup="from __main__ import test"))
</code></pre>
<p>when I run it, it takes about 10 seconds, which is very strange for me. I recall that when I am appending 100.000 string into a string, it only takes 0.06 seconds. why does appending 100 integers into a list take 10 seconds? here are the code that I use to append stringt to list.</p>
<pre><code>def wordlist1():
    fin = open("words.txt")
    word_list = []
    for line in fin:
        word = line.strip()
        word_list.append(word)
    return word_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think your problem is the usage of the timeit module. When not specified, the param <code>number</code> defaults to 1e6. So what you are effectively measuring is how long it would take to append a hundred numbers to an array 1e6 times.</p>
<p>To verify this, I used this code snippet:</p>
<pre><code>import timeit

alist = list(range(100))

L = []

def test():
    for i in alist:
        L.append(i)

elapsed = timeit.timeit("test()", setup="from __main__ import test, alist, L", number=1000000)

print('average time elapsed', elapsed/1000000)
</code></pre>
<p>On my machine, I got the following result:</p>
<pre><code>7.74517...e-06
</code></pre>
<p>I do not know how you measured the append function for your txt file, but you could try to test it the same way.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use iPython, you can see a clearer explanation of the results using its <code>%timeit</code> magic command.</p>
<pre><code>In [1]: def test():
   ...:     """Stupid test function"""
   ...:     L = []
   ...:     for i in range(100):
   ...:         L.append(i)
   ...:

In [2]: %timeit test()
7.12 µs ± 22.9 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>Here the result is an average of 7.12 microseconds per call to <code>test</code>, with the average computed over 7 sets of 100,000 calls to <code>test</code>. This is consistent with the 7.75 microseconds reported by DocDriven in <a href="https://stackoverflow.com/a/55243988/1126841">his answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this one </p>
<p>def test():</p>
<p>L = []</p>
<p>for i in range(100)</p>
<pre><code>    count + = i

    L.append(count )

    return count 
</code></pre>
</div>
<span class="comment-copy">You are also using <code>range()</code> for your integers, which might be slower than <code>for line in fin</code></span>
<span class="comment-copy">Based on your title you should be comparing <code>test</code> with another function the same apart rom <code>L.append('a')</code>- you're comparing 2 completely different things</span>
<span class="comment-copy">@Flob <code>range</code> in Python 3 doesn't create a list of integers in memory; it's a <code>range</code> object with a <code>__next__</code> method just like a file iterator.</span>
<span class="comment-copy">@chepner thank you for clarifying that! :-) i don't know that much about python, it was just an idea^^</span>
<span class="comment-copy">Welcome to StackOverflow. But how is this an answer to the question? Also, please format your code correctly clicking the <code>edit</code> link, highlighting the code, then clicking the <code>{}</code> button (or press <code>Ctrl+K</code>).</span>
