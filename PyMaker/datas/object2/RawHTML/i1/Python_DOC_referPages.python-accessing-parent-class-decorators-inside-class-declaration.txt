<div class="post-text" itemprop="text">
<p>Let's say I have this class:</p>
<pre><code>class Foo:
    @classmethod
    def some_decorator(cls, ...):
        ...
</code></pre>
<p>And then I create a subclass which uses the parent class decorator:</p>
<pre><code>class Bar(Foo):
    @Foo.some_decorator(...)
    def some_function(...)
        ...
</code></pre>
<p>How do I remove the need for <code>Foo.</code> before the decorator name? The below code doesn't work:</p>
<pre><code>class Bar(Foo):
    @some_decorator(...)
    def some_function(...)
        ...
</code></pre>
<p>I believe this is possible, because the <a href="https://sly.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>sly</code></a> library does this.</p>
<p>See their example:</p>
<pre><code>from sly import Lexer, Parser

class CalcLexer(Lexer):
    ...

    @_(r'\d+')
    def NUMBER(self, t):
        t.value = int(t.value)
        return t

    ...
</code></pre>
<p>As you can see, you can type in <code>@_(...)</code> instead of <code>@Lexer._(...)</code>.</p>
<p>How do they accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is done with a <a href="https://docs.python.org/3/glossary.html#term-metaclass" rel="nofollow noreferrer">metaclass</a> that implements a <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="nofollow noreferrer"><code>__prepare__</code></a> method. Excerpt from the docs:</p>
<blockquote>
<p>3.3.3.4. Preparing the class namespace</p>
<p>Once the appropriate metaclass has been identified, then the class
  namespace is prepared. If the metaclass has a <code>__prepare__</code> attribute,
  it is called as <code>namespace = metaclass.__prepare__(name, bases, **kwds)</code>
  (where the additional keyword arguments, if any, come from the class
  definition).</p>
</blockquote>
<p>To put it in simple terms: You make your <code>__prepare__</code> method return a dictionary that contains an entry for the decorator. Proof of concept:</p>
<pre><code>class MyMeta(type):
    def __prepare__(name, bases):
        return {'x': 'foobar'}

class MyClass(metaclass=MyMeta):
    print(x)  # output: foobar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have looked inside the library you are talking about and the <code>Lexer</code> class inherits a metaclass:</p>
<p><code>class Lexer(metaclass=LexerMeta):</code></p>
<p>Inside the <code>LexerMeta</code> you can find the following:</p>
<pre><code>@classmethod
    def __prepare__(meta, name, bases):
        d = LexerMetaDict()

        def _(pattern, *extra):
            patterns = [pattern, *extra]
            def decorate(func):
                pattern = '|'.join(f'({pat})' for pat in patterns )
                if hasattr(func, 'pattern'):
                    func.pattern = pattern + '|' + func.pattern
                else:
                    func.pattern = pattern
                return func
            return decorate

        d['_'] = _
        d['before'] = _Before
        return d
</code></pre>
<p>A metaclass is used to create the class object which then is used to instantiate objects. From what i can see in that method is that here <code>d['_'] = _</code> that metaclass dynamically attaches the <code>_</code> method to the class you are going to use.</p>
<p>This means that what they are doing is not much different from:</p>
<pre><code>class Bar:
    @staticmethod
    def some_decorator(f):
        ...

    @some_decorator
    def some_function(self):
        ...
</code></pre>
</div>
<span class="comment-copy">Aside: I'm not very fond of that design choice. Magically spawning a decorator in the class makes for non-obvious, hard-to-comprehend code. A much cleaner solution would've been to make the user import the <code>_</code> decorator with <code>from sly import _</code>. Think twice about whether you want to have this in your code base.</span>
<span class="comment-copy">@Aran-Fey That's wouldn't be great too in my opinion: You pollute the global namespace and <code>_</code> couldn't mean something different for each class. For sly, <code>_</code> has a different meaning for each base class.</span>
<span class="comment-copy">I know nothing about this project, but lexers and parsers are built for speed not readability.  That's why Lex and YACC are so hard for some.</span>
<span class="comment-copy">Thank you. Is there a way of making the decorator an <code>@classmethod</code> like in my question? I need to access <code>cls</code> inside the decorator.</span>
<span class="comment-copy">@DavidCallanan Well, of course it's possible to add <code>@classmethod</code> to the decorator, but that won't give it access to the class - it'll just make it crash with <code>TypeError: 'classmethod' object is not callable</code>. This is a bit difficult to answer in a comment, so could I ask you to post a new question about it?</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/55207813/python-metaclass-decorator-how-to-use-classmethod" title="python metaclass decorator how to use classmethod">stackoverflow.com/questions/55207813/â€¦</a></span>
