<div class="post-text" itemprop="text">
<ul>
<li>What is pivot?</li>
<li>How do I pivot?</li>
<li>Is this a pivot?</li>
<li>Long format to wide format?</li>
</ul>
<p>I've seen a lot of questions that ask about pivot tables.  Even if they don't know that they are asking about pivot tables, they usually are.  It is virtually impossible to write a canonical question and answer that encompasses all aspects of pivoting....</p>
<p>... But I'm going to give it a go.</p>
<hr/>
<p>The problem with existing questions and answers is that often the question is focused on a nuance that the OP has trouble generalizing in order to use a number of the existing good answers.  However, none of the answers attempt to give a comprehensive explanation (because it's a daunting task)</p>
<p>Look a few examples from my <a href="https://www.google.com/search?q=how%20to%20pivot%20a%20pandas%20dataframe&amp;oq=How%20do%20I%20pivot%20a%20pandas%20dataframe" rel="noreferrer"><strong>google search</strong></a></p>
<ol>
<li><a href="https://stackoverflow.com/q/28337117/2336654">How to pivot a dataframe in Pandas?</a>
<ul>
<li>Good question and answer.  But the answer only answers the specific question with little explanation.</li>
</ul></li>
<li><a href="https://stackoverflow.com/q/42708193/2336654">pandas pivot table to data frame</a>
<ul>
<li>In this question, the OP is concerned with the output of the pivot.  Namely how the columns look.  OP wanted it to look like R.  This isn't very helpful for pandas users.</li>
</ul></li>
<li><a href="https://stackoverflow.com/q/11400181/2336654">pandas pivoting a dataframe, duplicate rows</a>
<ul>
<li>Another decent question but the answer focuses on one method, namely <code>pd.DataFrame.pivot</code></li>
</ul></li>
</ol>
<p>So whenever someone searches for <code>pivot</code> they get sporadic results that are likely not going to answer their specific question.</p>
<hr/>
<h1>Setup</h1>
<p>You may notice that I conspicuously named my columns and relevant column values to correspond with how I'm going to pivot in the answers below.  Pay attention so that you get familiar with where which column names go where to get the results you're looking for.</p>
<pre><code>import numpy as np
import pandas as pd
from numpy.core.defchararray import add

np.random.seed([3,1415])
n = 20

cols = np.array(['key', 'row', 'item', 'col'])
arr1 = (np.random.randint(5, size=(n, 4)) // [2, 1, 2, 1]).astype(str)

df = pd.DataFrame(
    add(cols, arr1), columns=cols
).join(
    pd.DataFrame(np.random.rand(n, 2).round(2)).add_prefix('val')
)
print(df)

     key   row   item   col  val0  val1
0   key0  row3  item1  col3  0.81  0.04
1   key1  row2  item1  col2  0.44  0.07
2   key1  row0  item1  col0  0.77  0.01
3   key0  row4  item0  col2  0.15  0.59
4   key1  row0  item2  col1  0.81  0.64
5   key1  row2  item2  col4  0.13  0.88
6   key2  row4  item1  col3  0.88  0.39
7   key1  row4  item1  col1  0.10  0.07
8   key1  row0  item2  col4  0.65  0.02
9   key1  row2  item0  col2  0.35  0.61
10  key2  row0  item2  col1  0.40  0.85
11  key2  row4  item1  col2  0.64  0.25
12  key0  row2  item2  col3  0.50  0.44
13  key0  row4  item1  col4  0.24  0.46
14  key1  row3  item2  col3  0.28  0.11
15  key0  row3  item1  col1  0.31  0.23
16  key0  row0  item2  col3  0.86  0.01
17  key0  row4  item0  col3  0.64  0.21
18  key2  row2  item2  col0  0.13  0.45
19  key0  row2  item0  col4  0.37  0.70
</code></pre>
<h3>Question(s)</h3>
<ol>
<li><p>Why do I get <code>ValueError: Index contains duplicate entries, cannot reshape</code></p></li>
<li><p>How do I pivot <code>df</code> such that the <code>col</code> values are columns, <code>row</code> values are the index, and mean of <code>val0</code> are the values?</p>
<pre><code>col   col0   col1   col2   col3  col4
row                                  
row0  0.77  0.605    NaN  0.860  0.65
row2  0.13    NaN  0.395  0.500  0.25
row3   NaN  0.310    NaN  0.545   NaN
row4   NaN  0.100  0.395  0.760  0.24
</code></pre></li>
<li><p>How do I pivot <code>df</code> such that the <code>col</code> values are columns, <code>row</code> values are the index, mean of <code>val0</code> are the values, and missing values are <code>0</code>?</p>
<pre><code>col   col0   col1   col2   col3  col4
row                                  
row0  0.77  0.605  0.000  0.860  0.65
row2  0.13  0.000  0.395  0.500  0.25
row3  0.00  0.310  0.000  0.545  0.00
row4  0.00  0.100  0.395  0.760  0.24
</code></pre></li>
<li><p>Can I get something other than <code>mean</code>, like maybe <code>sum</code>?</p>
<pre><code>col   col0  col1  col2  col3  col4
row                               
row0  0.77  1.21  0.00  0.86  0.65
row2  0.13  0.00  0.79  0.50  0.50
row3  0.00  0.31  0.00  1.09  0.00
row4  0.00  0.10  0.79  1.52  0.24
</code></pre></li>
<li><p>Can I do more that one aggregation at a time?</p>
<pre><code>       sum                          mean                           
col   col0  col1  col2  col3  col4  col0   col1   col2   col3  col4
row                                                                
row0  0.77  1.21  0.00  0.86  0.65  0.77  0.605  0.000  0.860  0.65
row2  0.13  0.00  0.79  0.50  0.50  0.13  0.000  0.395  0.500  0.25
row3  0.00  0.31  0.00  1.09  0.00  0.00  0.310  0.000  0.545  0.00
row4  0.00  0.10  0.79  1.52  0.24  0.00  0.100  0.395  0.760  0.24
</code></pre></li>
<li><p>Can I aggregate over multiple value columns?</p>
<pre><code>      val0                             val1                          
col   col0   col1   col2   col3  col4  col0   col1  col2   col3  col4
row                                                                  
row0  0.77  0.605  0.000  0.860  0.65  0.01  0.745  0.00  0.010  0.02
row2  0.13  0.000  0.395  0.500  0.25  0.45  0.000  0.34  0.440  0.79
row3  0.00  0.310  0.000  0.545  0.00  0.00  0.230  0.00  0.075  0.00
row4  0.00  0.100  0.395  0.760  0.24  0.00  0.070  0.42  0.300  0.46
</code></pre></li>
<li><p>Can Subdivide by multiple columns?</p>
<pre><code>item item0             item1                         item2                   
col   col2  col3  col4  col0  col1  col2  col3  col4  col0   col1  col3  col4
row                                                                          
row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.605  0.86  0.65
row2  0.35  0.00  0.37  0.00  0.00  0.44  0.00  0.00  0.13  0.000  0.50  0.13
row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.000  0.28  0.00
row4  0.15  0.64  0.00  0.00  0.10  0.64  0.88  0.24  0.00  0.000  0.00  0.00
</code></pre></li>
<li><p>Or </p>
<pre><code>item      item0             item1                         item2                  
col        col2  col3  col4  col0  col1  col2  col3  col4  col0  col1  col3  col4
key  row                                                                         
key0 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.86  0.00
     row2  0.00  0.00  0.37  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.50  0.00
     row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.00  0.00  0.00
     row4  0.15  0.64  0.00  0.00  0.00  0.00  0.00  0.24  0.00  0.00  0.00  0.00
key1 row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.81  0.00  0.65
     row2  0.35  0.00  0.00  0.00  0.00  0.44  0.00  0.00  0.00  0.00  0.00  0.13
     row3  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.28  0.00
     row4  0.00  0.00  0.00  0.00  0.10  0.00  0.00  0.00  0.00  0.00  0.00  0.00
key2 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.40  0.00  0.00
     row2  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.13  0.00  0.00  0.00
     row4  0.00  0.00  0.00  0.00  0.00  0.64  0.88  0.00  0.00  0.00  0.00  0.00
</code></pre></li>
<li><p>Can I aggregate the frequency in which the column and rows occur together, aka "cross tabulation"?</p>
<pre><code>col   col0  col1  col2  col3  col4
row                               
row0     1     2     0     1     1
row2     1     0     2     1     2
row3     0     1     0     2     0
row4     0     1     2     2     1
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>We start by answering the first question:</p>
<h2>Question 1</h2>
<blockquote>
<p>Why do I get <code>ValueError: Index contains duplicate entries, cannot reshape</code></p>
</blockquote>
<p>This occurs because pandas is attempting to reindex either a <code>columns</code> or <code>index</code> object with duplicate entries.  There are varying methods to use that can perform a pivot.  Some of them are not well suited to when there are duplicates of the keys in which it is being asked to pivot on.  For example.  Consider <code>pd.DataFrame.pivot</code>.  I know there are duplicate entries that share the <code>row</code> and <code>col</code> values:</p>
<pre><code>df.duplicated(['row', 'col']).any()

True
</code></pre>
<p>So when I <code>pivot</code> using</p>
<pre><code>df.pivot(index='row', columns='col', values='val0')
</code></pre>
<p>I get the error mentioned above.  In fact, I get the same error when I try to perform the same task with:</p>
<pre><code>df.set_index(['row', 'col'])['val0'].unstack()
</code></pre>
<p>Here is a list of idioms we can use to pivot</p>
<ol>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html" rel="noreferrer"><strong><code>pd.DataFrame.groupby</code></strong></a> + <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.unstack.html" rel="noreferrer"><strong><code>pd.DataFrame.unstack</code></strong></a>
<ul>
<li>Good general approach for doing just about any type of pivot</li>
<li>You specify all columns that will constitute the pivoted row levels and column levels in one group by.  You follow that by selecting the remaining columns you want to aggregate and the function(s) you want to perform the aggregation.  Finally, you <code>unstack</code> the levels that you want to be in the column index.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.pivot_table.html" rel="noreferrer"><strong><code>pd.DataFrame.pivot_table</code></strong></a>
<ul>
<li>A glorified version of <code>groupby</code> with more intuitive API.  For many people, this is the preferred approach.  And is the intended approach by the developers.</li>
<li>Specify row level, column levels, values to be aggregated, and function(s) to perform aggregations.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html" rel="noreferrer"><strong><code>pd.DataFrame.set_index</code></strong></a> + <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.unstack.html" rel="noreferrer"><strong><code>pd.DataFrame.unstack</code></strong></a>
<ul>
<li>Convenient and intuitive for some (myself included).  Cannot handle duplicate grouped keys.</li>
<li>Similar to the <code>groupby</code> paradigm, we specify all columns that will eventually be either row or column levels and set those to be the index.  We then <code>unstack</code> the levels we want in the columns.  If either the remaining index levels or column levels are not unique, this method will fail.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html" rel="noreferrer"><strong><code>pd.DataFrame.pivot</code></strong></a>
<ul>
<li>Very similar to <code>set_index</code> in that it shares the duplicate key limitation.  The API is very limited as well.  It only takes scalar values for <code>index</code>, <code>columns</code>, <code>values</code>.</li>
<li>Similar to the <code>pivot_table</code> method in that we select rows, columns, and values on which to pivot.  However, we cannot aggregate and if either rows or columns are not unique, this method will fail.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html" rel="noreferrer"><strong><code>pd.crosstab</code></strong></a>
<ul>
<li>This a specialized version of <code>pivot_table</code> and in it's purest form is the most intuitive way to perform several tasks.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.factorize.html" rel="noreferrer"><strong><code>pd.factorize</code></strong></a> + <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.bincount.html" rel="noreferrer"><strong><code>np.bincount</code></strong></a>
<ul>
<li>This is a highly advanced technique that is very obscure but is very fast.  It cannot be used in all circumstances, but when it can be used and you are comfortable using it, you will reap the performance rewards.</li>
</ul></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html" rel="noreferrer"><strong><code>pd.get_dummies</code></strong></a> + <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dot.html" rel="noreferrer"><strong><code>pd.DataFrame.dot</code></strong></a>
<ul>
<li>I use this for cleverly performing cross tabulation.  </li>
</ul></li>
</ol>
<hr/>
<h1>Examples</h1>
<p>What I'm going to do for each subsequent answer and question is to answer it using <code>pd.DataFrame.pivot_table</code>.  Then I'll provide alternatives to perform the same task.  </p>
<h2>Question 3</h2>
<blockquote>
<p>How do I pivot <code>df</code> such that the <code>col</code> values are columns, <code>row</code> values are the index, mean of <code>val0</code> are the values, and missing values are <code>0</code>?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<ul>
<li><code>fill_value</code> is not set by default.  I tend to set it appropriately.  In this case I set it to <code>0</code>.  Notice I skipped <strong>question 2</strong> as it's the same as this answer without the <code>fill_value</code></li>
<li><p><code>aggfunc='mean'</code> is the default and I didn't have to set it.  I included it to be explicit.</p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc='mean')

col   col0   col1   col2   col3  col4
row                                  
row0  0.77  0.605  0.000  0.860  0.65
row2  0.13  0.000  0.395  0.500  0.25
row3  0.00  0.310  0.000  0.545  0.00
row4  0.00  0.100  0.395  0.760  0.24
</code></pre></li>
</ul></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(['row', 'col'])['val0'].mean().unstack(fill_value=0)
</code></pre></li>
<li><p><code>pd.crosstab</code></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc='mean').fillna(0)
</code></pre></li>
</ul>
<hr/>
<h2>Question 4</h2>
<blockquote>
<p>Can I get something other than <code>mean</code>, like maybe <code>sum</code>?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc='sum')

col   col0  col1  col2  col3  col4
row                               
row0  0.77  1.21  0.00  0.86  0.65
row2  0.13  0.00  0.79  0.50  0.50
row3  0.00  0.31  0.00  1.09  0.00
row4  0.00  0.10  0.79  1.52  0.24
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(['row', 'col'])['val0'].sum().unstack(fill_value=0)
</code></pre></li>
<li><p><code>pd.crosstab</code></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc='sum').fillna(0)
</code></pre></li>
</ul>
<hr/>
<h2>Question 5</h2>
<blockquote>
<p>Can I do more that one aggregation at a time?</p>
</blockquote>
<p>Notice that for <code>pivot_table</code> and <code>cross_tab</code> I needed to pass list of callables.  On the other hand, <code>groupby.agg</code> is able to take strings for a limited number of special functions.  <code>groupby.agg</code> would also have taken the same callables we passed to the others, but it is often more efficient to leverage the string function names as there are efficiencies to be gained.</p>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc=[np.size, np.mean])

     size                      mean                           
col  col0 col1 col2 col3 col4  col0   col1   col2   col3  col4
row                                                           
row0    1    2    0    1    1  0.77  0.605  0.000  0.860  0.65
row2    1    0    2    1    2  0.13  0.000  0.395  0.500  0.25
row3    0    1    0    2    0  0.00  0.310  0.000  0.545  0.00
row4    0    1    2    2    1  0.00  0.100  0.395  0.760  0.24
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(['row', 'col'])['val0'].agg(['size', 'mean']).unstack(fill_value=0)
</code></pre></li>
<li><p><code>pd.crosstab</code></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc=[np.size, np.mean]).fillna(0, downcast='infer')
</code></pre></li>
</ul>
<hr/>
<h2>Question 6</h2>
<blockquote>
<p>Can I aggregate over multiple value columns?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code> we pass <code>values=['val0', 'val1']</code> but we could've left that off completely</p>
<pre><code>df.pivot_table(
    values=['val0', 'val1'], index='row', columns='col',
    fill_value=0, aggfunc='mean')

      val0                             val1                          
col   col0   col1   col2   col3  col4  col0   col1  col2   col3  col4
row                                                                  
row0  0.77  0.605  0.000  0.860  0.65  0.01  0.745  0.00  0.010  0.02
row2  0.13  0.000  0.395  0.500  0.25  0.45  0.000  0.34  0.440  0.79
row3  0.00  0.310  0.000  0.545  0.00  0.00  0.230  0.00  0.075  0.00
row4  0.00  0.100  0.395  0.760  0.24  0.00  0.070  0.42  0.300  0.46
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(['row', 'col'])['val0', 'val1'].mean().unstack(fill_value=0)
</code></pre></li>
</ul>
<hr/>
<h2>Question 7</h2>
<blockquote>
<p>Can Subdivide by multiple columns?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns=['item', 'col'],
    fill_value=0, aggfunc='mean')

item item0             item1                         item2                   
col   col2  col3  col4  col0  col1  col2  col3  col4  col0   col1  col3  col4
row                                                                          
row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.605  0.86  0.65
row2  0.35  0.00  0.37  0.00  0.00  0.44  0.00  0.00  0.13  0.000  0.50  0.13
row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.000  0.28  0.00
row4  0.15  0.64  0.00  0.00  0.10  0.64  0.88  0.24  0.00  0.000  0.00  0.00
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(
    ['row', 'item', 'col']
)['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre></li>
</ul>
<hr/>
<h2>Question 8</h2>
<blockquote>
<p>Can Subdivide by multiple columns?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<pre><code>df.pivot_table(
    values='val0', index=['key', 'row'], columns=['item', 'col'],
    fill_value=0, aggfunc='mean')

item      item0             item1                         item2                  
col        col2  col3  col4  col0  col1  col2  col3  col4  col0  col1  col3  col4
key  row                                                                         
key0 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.86  0.00
     row2  0.00  0.00  0.37  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.50  0.00
     row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.00  0.00  0.00
     row4  0.15  0.64  0.00  0.00  0.00  0.00  0.00  0.24  0.00  0.00  0.00  0.00
key1 row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.81  0.00  0.65
     row2  0.35  0.00  0.00  0.00  0.00  0.44  0.00  0.00  0.00  0.00  0.00  0.13
     row3  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.28  0.00
     row4  0.00  0.00  0.00  0.00  0.10  0.00  0.00  0.00  0.00  0.00  0.00  0.00
key2 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.40  0.00  0.00
     row2  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.13  0.00  0.00  0.00
     row4  0.00  0.00  0.00  0.00  0.00  0.64  0.88  0.00  0.00  0.00  0.00  0.00
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(
    ['key', 'row', 'item', 'col']
)['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre></li>
<li><p><code>pd.DataFrame.set_index</code> because the set of keys are unique for both rows and columns</p>
<pre><code>df.set_index(
    ['key', 'row', 'item', 'col']
)['val0'].unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre></li>
</ul>
<hr/>
<h2>Question 9</h2>
<blockquote>
<p>Can I aggregate the frequency in which the column and rows occur together, aka "cross tabulation"?</p>
</blockquote>
<ul>
<li><p><code>pd.DataFrame.pivot_table</code></p>
<pre><code>df.pivot_table(index='row', columns='col', fill_value=0, aggfunc='size')

    col   col0  col1  col2  col3  col4
row                               
row0     1     2     0     1     1
row2     1     0     2     1     2
row3     0     1     0     2     0
row4     0     1     2     2     1
</code></pre></li>
<li><p><code>pd.DataFrame.groupby</code></p>
<pre><code>df.groupby(['row', 'col'])['val0'].size().unstack(fill_value=0)
</code></pre></li>
<li><p><code>pd.cross_tab</code></p>
<pre><code>pd.crosstab(df['row'], df['col'])
</code></pre></li>
<li><p><code>pd.factorize</code> + <code>np.bincount</code></p>
<pre><code># get integer factorization `i` and unique values `r`
# for column `'row'`
i, r = pd.factorize(df['row'].values)
# get integer factorization `j` and unique values `c`
# for column `'col'`
j, c = pd.factorize(df['col'].values)
# `n` will be the number of rows
# `m` will be the number of columns
n, m = r.size, c.size
# `i * m + j` is a clever way of counting the 
# factorization bins assuming a flat array of length
# `n * m`.  Which is why we subsequently reshape as `(n, m)`
b = np.bincount(i * m + j, minlength=n * m).reshape(n, m)
# BTW, whenever I read this, I think 'Bean, Rice, and Cheese'
pd.DataFrame(b, r, c)

      col3  col2  col0  col1  col4
row3     2     0     0     1     0
row2     1     2     1     0     2
row0     1     0     1     2     1
row4     2     2     0     1     1
</code></pre></li>
<li><p><code>pd.get_dummies</code></p>
<pre><code>pd.get_dummies(df['row']).T.dot(pd.get_dummies(df['col']))

      col0  col1  col2  col3  col4
row0     1     2     0     1     1
row2     1     0     2     1     2
row3     0     1     0     2     0
row4     0     1     2     2     1
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Could you please consider extending <a href="https://pandas.pydata.org/pandas-docs/stable/reshaping.html" rel="nofollow noreferrer">official docs</a>?</span>
