<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3877230/why-does-id-id-and-id-id-in-cpython">Why does id({}) == id({}) and id([]) == id([]) in CPython?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<pre><code>def func(t):
    t = 5
    print('inside function', t)
    print('inside function address = ', id(hex(t)))

x = 3
func(x)
print('outside function',x)
print('outside function address = ', id(hex(x)))
</code></pre>
<p>This Prints</p>
<pre><code>inside function 5
inside function address =  31255648
outside function 3
outside function address =  31255648
</code></pre>
<p>My understanding was a variable referenced in a function without assignment will use a variable outside of its scope. But if the function has an assignment, then it will create a new variable in a new space in memory and assign it there.</p>
<p>Why does the function id find the original address of the argument instead of the address of the newly created variable? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>hex(x)</code> is a string. <code>id(hex(x))</code> creates a string, gets its id, and then immediately discards the string.</p>
<p>IDs only need to be unique for the lifespan of their respective objects. Since the strings do not exist at the same time, they can have the same id.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your understanding of variable scopes is correct. But this behavior has nothing to do with scoping. In your analysis you've missed an important detail: You're not calling <code>id(t)</code>; you're calling <code>id(hex(t))</code>.</p>
<p>This is what's happening, step by step:</p>
<ol>
<li><code>hex(5)</code> is called. This creates the string <code>'0x5'</code> at the address 31255648.</li>
<li><code>id(hex(5))</code> returns 31255648.</li>
<li>The string is no longer needed and is garbage collected.</li>
<li><code>hex(3)</code> is called. This creates the string <code>'0x3'</code> at the address 31255648.</li>
<li><code>id(hex(3))</code> returns 31255648.</li>
</ol>
<p>In other words, you had two objects (strings) whose lifetimes didn't overlap and that just happened to be created at the same memory address, which is how they ended up having the same id.</p>
</div>
<span class="comment-copy">Are you sure you ran the code exactly as you provided it? Those results look strange.</span>
<span class="comment-copy"><code>hex(x)</code> is a string. You're getting the <code>id</code> of a string, which is created and then immediately abandoned. Ids only need to be unique for the lifespan of their respective objects. Since the strings do not exist at the same time, they can have the same id.</span>
<span class="comment-copy">@PatrickArtner Uhhh, this has absolutely nothing to do with integer caching. All that's happening here is that a string is created, then destroyed, and then another string is created in the same memory location as the previous one.</span>
<span class="comment-copy">Integers in python are caches if in range -5 to 255 or so - they got the same id regardless of where you use them from. you however are printing ids of stringvalues of the hex of int that you immediately throw away</span>
<span class="comment-copy">@Aran-Fey yep - misread and fixedit again</span>
<span class="comment-copy">Ah, that makes so much sense, thank you</span>
