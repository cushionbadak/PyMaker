<div class="post-text" itemprop="text">
<p>A row of my data has 18 columns which each have a complication code.</p>
<p>The complication class is made up of a 'name' which is the complication name such as 'HeartFailure' and it also has a array of strings stored as 'codes' which has values such as '500' and it needs to be matched across 18 columns for each patient (each row of final) and find codes such as '5001' or '5002'. If the code is found then the corresponding complication column in the dataset needs to be updated to 1. </p>
<p>This was the solution that I coded up. Do you think this could be more optimized? Right now it takes about 16 minutes to run on just 25000 patients which is just not good enough. </p>
<p>Data:</p>
<pre><code>DX1      DX2     DX3   DX4 HeartFailure
10R46   R*1005   8017  2   0
10R46   R*10335  5019  2   0
100R91  R*1005   8017  1   0
10R91   R*243    8870  1   0
10M95   R*4918   8305  3   0
10M95   R*9017   8305  3   0
10M95   R*9470   8221  3   0
</code></pre>
<p>Class:</p>
<pre><code>class HCUPCodes:
    def __init__(self,name,codes):
        self.name = name
        self.codes = codes
</code></pre>
<p>Initialization of class:</p>
<pre><code>complications_POA = []
complications_POA.append(HCUPCodes('HeartFailure',['80', 'R*1']))
</code></pre>
<p>Code:</p>
<pre><code> def defineComplicationsFeatures(patient, comp_list):
    for i in range(len(comp_list)):
        for x in comp_list[i].codes:
            if((any(patient.str.startswith(x,na=False)))):
                patient[comp_list[i].name]=1 #change 0 to 1 in the corresponding disease column for this patient
    return patient

final = final.apply(defineComplicationsFeatures, axis=1, comp_list = complications_POA)
final = final.apply(defineComplicationsFeatures, axis=1, comp_list = complications_NOPOA)
</code></pre>
<p>Output:</p>
<pre><code>DX1      DX2     DX3   DX4 HeartFailure
10R46   R*1005   8017  2   1
10R46   R*10335  5019  2   1
100R91  R*1005   8017  1   1
10R91   R*243    8870  1   0
10M95   R*4918   8305  3   0
10M95   R*9017   8305  3   0
10M95   R*9470   8221  3   0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two things are slowing your code down:</p>
<ol>
<li>Using two for loops</li>
<li>Using <code>.apply</code> with your own defined function.</li>
</ol>
<p>You can optimize your solution with vectorized methods of <code>pandas</code> and <code>numpys</code>:</p>
<ol>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="nofollow noreferrer"><code>np.where</code></a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.column_stack.html" rel="nofollow noreferrer"><code>np.stack_columns</code></a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html" rel="nofollow noreferrer"><code>pandas.DataFrame.iloc</code></a></li>
</ol>
<p>A solution:  <em>(I did not use your class in this case)</em></p>
<pre><code># Print the DataFrame we start with provided by OP
print(df)
      DX1      DX2   DX3 DX4  HeartFailure
0   10R46   R*1005  8017   2             0
1   10R46  R*10335  5019   2             0
2  100R91   R*1005  8017   1             0
3   10R91    R*243  8870   1             0
4   10M95   R*4918  8305   3             0
5   10M95   R*9017  8305   3             0
6   10M95   R*9470  8221   3             0
</code></pre>
<pre><code># Create new optimized function
def defineComplicationsFeatures(df):

    col_to_update = 'HeartFailure'

    strings_to_search = ['80', 'R*1']

    for string in strings_to_search:
        mask = np.column_stack([df[col].str.startswith(string, na=False) for col in df.iloc[:, :-1]]).any(axis=1)
        df[col_to_update] = np.where(mask, 1, 0)

    return df

df_new = defineComplicationsFeatures(df)
print(df_new)

      DX1      DX2   DX3 DX4  HeartFailure
0   10R46   R*1005  8017   2             1
1   10R46  R*10335  5019   2             1
2  100R91   R*1005  8017   1             1
3   10R91    R*243  8870   1             0
4   10M95   R*4918  8305   3             0
5   10M95   R*9017  8305   3             0
6   10M95   R*9470  8221   3             0
</code></pre>
<p><strong>Note</strong>
You can transfer <code>col_to_update</code> &amp; <code>strings_to_search</code> to arguments of the function which makes it a bit cleaner, I chose not to for simplicity right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>To achieve minimal speed up you can add <code>break</code> after the code is found:</p>
<pre><code> def defineComplicationsFeatures(patient, comp_list):
    for i in range(len(comp_list)):
        for x in comp_list[i].codes:
            if((any(patient.str.startswith(x,na=False)))):
                patient[comp_list[i].name]=1 #change 0 to 1 in the 
                break
    return patient
</code></pre>
</div>
<span class="comment-copy">Could you explain in normal language (pseudo code preferred) why the first three rows are updated in your expected output?</span>
<span class="comment-copy">I can't find any description of what <code>na=False</code> means for <code>startswith()</code>, but you don't need the <code>any()</code> around it. However, I cannot see anything obviously horrendously inefficient - <code>cProfile</code> or <code>profile</code> output would help you understand where the bottleneck is, I think.</span>
<span class="comment-copy">@Erfan:   for each row in dataset:       if ANY code is found in row then: mark 1 in disease column</span>
<span class="comment-copy">Right now this is working as an and statement i.e. all the codes have to be found for the HeartFailure feature to be updated to 1. How can I modify this code to work as an OR operation?</span>
<span class="comment-copy">Not sure what you mean, you want to update more columns than <code>HeartFailure</code>?</span>
<span class="comment-copy">This actually speeds up by almost 3x so thanks!</span>
