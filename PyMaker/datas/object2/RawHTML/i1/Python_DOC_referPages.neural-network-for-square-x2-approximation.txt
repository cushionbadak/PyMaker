<div class="post-text" itemprop="text">
<p>I'm new to TensorFlow and Data Science. I made a simple module that should figure out the relationship between input and output numbers. In this case, x and x squared. The code in Python:</p>
<pre><code>import numpy as np
import tensorflow as tf

# TensorFlow only log error messages.
tf.logging.set_verbosity(tf.logging.ERROR)

features = np.array([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8,
                    9, 10], dtype = float)
labels = np.array([100, 81, 64, 49, 36, 25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25, 36, 49, 64,
                    81, 100], dtype = float)

model = tf.keras.Sequential([
    tf.keras.layers.Dense(units = 1, input_shape = [1])
])

model.compile(loss = "mean_squared_error", optimizer = tf.keras.optimizers.Adam(0.0001))
model.fit(features, labels, epochs = 50000, verbose = False)
print(model.predict([4, 11, 20]))
</code></pre>
<p>I tried a different number of units, and adding more layers, and even using the <code>relu</code> activation function, but the results were always wrong.
It works with other relationships like x and 2x. <strong>What is the problem here?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You are making two very basic mistakes:</p>
<ul>
<li>Your ultra-simple model (a single-layer network with a single unit) hardly qualifies as a neural network at all, let alone a "deep learning" one (as your question is tagged)</li>
<li>Similarly, your dataset (just 20 samples) is also ultra-small</li>
</ul>
<p>It is certainly understood that neural networks need to be of some complexity if they are to solve problems even as "simple" as <code>x*x</code>; and where they really shine is when fed with large training datasets.</p>
<p>The methodology when trying to solve such function approximations is not to just list the (few possible) inputs and then fed to the model, along with the desired outputs; remember, NNs learn through examples, and not through symbolic reasoning. And the more examples the better. What we usually do in similar cases is to generate a large number of examples, which we subsequently feed to the model for training.</p>
<p>Having said that, here is a rather simple demonstration of a 3-layer neural network in Keras for approximating the function <code>x*x</code>, using as input 10,000 random numbers generated in <code>[-50, 50]</code>:</p>
<pre><code>import numpy as np
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam
from keras import regularizers
import matplotlib.pyplot as plt

model = Sequential()
model.add(Dense(8, activation='relu', kernel_regularizer=regularizers.l2(0.001), input_shape = (1,)))
model.add(Dense(8, activation='relu', kernel_regularizer=regularizers.l2(0.001)))
model.add(Dense(1))

model.compile(optimizer=Adam(),loss='mse')

# generate 10,000 random numbers in [-50, 50], along with their squares
x = np.random.random((10000,1))*100-50
y = x**2

# fit the model, keeping 2,000 samples as validation set
hist = model.fit(x,y,validation_split=0.2,
             epochs= 15000,
             batch_size=256)

# check some predictions:
print(model.predict([4, -4, 11, 20, 8, -5]))
# result:
[[ 16.633354]
 [ 15.031291]
 [121.26833 ]
 [397.78638 ]
 [ 65.70035 ]
 [ 27.040245]]
</code></pre>
<p>Well, not that bad! Remember that NNs are function <em>approximators</em>: we should expect them neither to <em>exactly</em> reproduce the functional relationship nor to "know" that the results for <code>4</code> and <code>-4</code> should be identical.</p>
<p>Let's generate some new random data in <code>[-50,50]</code> (remember, for all practical purposes, these are <em>unseen</em> data for the model) and plot them, along with the original ones, to get a more general picture:</p>
<pre><code>plt.figure(figsize=(14,5))
plt.subplot(1,2,1)
p = np.random.random((1000,1))*100-50 # new random data in [-50, 50]
plt.plot(p,model.predict(p), '.')
plt.xlabel('x')
plt.ylabel('prediction')
plt.title('Predictions on NEW data in [-50,50]')

plt.subplot(1,2,2)
plt.xlabel('x')
plt.ylabel('y')
plt.plot(x,y,'.')
plt.title('Original data')
</code></pre>
<p>Result:</p>
<p><a href="https://i.stack.imgur.com/8jNbN.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/8jNbN.png"/></a></p>
<p>Well, it arguably does look like a good approximation indeed...</p>
<p>You could also take a look at <a href="https://stackoverflow.com/questions/49583466/neural-network-sine-approximation/49587503#49587503">this thread</a> for a sine approximation.</p>
<p>The last thing to keep in mind is that, although we did get a decent approximation even with our relatively simple model, what we should <strong>not</strong> expect is <em>extrapolation</em>, i.e. good performance outside <code>[-50, 50]</code>; for details, see my answer in <a href="https://stackoverflow.com/questions/53795142/is-deep-learning-bad-at-fitting-simple-non-linear-functions-outside-training-sco/53796253#53796253">Is deep learning bad at fitting simple non linear functions outside training scope?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that <code>x*x</code> is a very different beast than <code>a*x</code>.</p>
<p>Please note what a usual "neural network" does: it stacks <code>y = f(W*x + b)</code> a few times, never multiplying <code>x</code> with itself. Therefore, you'll never get perfect reconstruction of <code>x*x</code>. Unless you set <code>f(x) = x*x</code> or similar.</p>
<p>What you can get is an approximation in the range of values presented during training (and perhaps a very little bit of extrapolation). Anyway, I'd recommend you to work with a smaller range of values, it will be easier to optimize the problem.</p>
<p>And on a philosophical note: In machine learning, I find it more useful to think of good/bad, rather than correct/wrong. Especially with regression, you cannot get the result "right" unless you have the exact model. In which case there is nothing to learn.</p>
<hr/>
<p>There actually are some NN architectures multiplying <code>f(x)</code> with <code>g(x)</code>, most notably <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="nofollow noreferrer">LSTMs</a> and <a href="https://arxiv.org/pdf/1505.00387.pdf" rel="nofollow noreferrer">Highway networks</a>. But even these have one or both of <code>f(x)</code>, <code>g(s)</code> bounded (by logistic sigmoid or tanh), thus are unable to model <code>x*x</code> fully.</p>
<hr/>
<p>Since there is some misunderstanding expressed in comments, let me emphasize a few points:</p>
<ol>
<li>You <strong>can approximate</strong> your data.</li>
<li>To do well in any sense, you do need a <strong>hidden layer</strong>.</li>
<li>But <strong>no more data</strong> is necessary, though if you cover the space, the model will fit more closely, see <a href="https://stackoverflow.com/a/55203161/9703830">desernaut's answer</a>.</li>
</ol>
<p>As an example, here is a result from a model with a single hidden layer of 10 units with tanh activation, trained by SGD with learning rate 1e-3 for 15k iterations to minimize the MSE of your data. Best of five runs:</p>
<p><a href="https://i.stack.imgur.com/3gMZ4.png" rel="nofollow noreferrer"><img alt="Performance of a simple NN trained on OP's data" src="https://i.stack.imgur.com/3gMZ4.png"/></a></p>
<p>Here is the full code to reproduce the result. Unfortunately, I cannot install Keras/TF in my current environment, but I hope that the PyTorch code is accessible :-)</p>
<pre><code>#!/usr/bin/env python
import torch
import torch.nn as nn
import matplotlib.pyplot as plt

X = torch.tensor([range(-10,11)]).float().view(-1, 1)
Y = X*X

model = nn.Sequential(
    nn.Linear(1, 10),
    nn.Tanh(),
    nn.Linear(10, 1)
)

optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)
loss_func = nn.MSELoss()
for _ in range(15000):
    optimizer.zero_grad()
    pred = model(X)
    loss = loss_func(pred, Y)
    loss.backward()
    optimizer.step()

x = torch.linspace(-12, 12, steps=200).view(-1, 1)
y = model(x)
f = x*x

plt.plot(x.detach().view(-1).numpy(), y.detach().view(-1).numpy(), 'r.', linestyle='None')
plt.plot(x.detach().view(-1).numpy(), f.detach().view(-1).numpy(), 'b')
plt.show()
</code></pre>
</div>
<span class="comment-copy">So you mean to get more accurate results on numbers outside <code>[-50, 50]</code>, I should train it and give it examples on the range I need.</span>
<span class="comment-copy">@AmeerTaweel indeed</span>
<span class="comment-copy">But since the neural network will never multiply <code>x</code> with itself, then this method won't work to solve the problem. How to make it multiply <code>x</code> by itself <b>without explicitly</b> telling it to do so since it won't be <code>Machine Learning</code> if I tell it what to do.</span>
<span class="comment-copy">Well... this is not a problem to solve with ML in the first place ;-) If learning, play around fitting data with different amount of noise. Plot the predictions and watch how different models can fit in different ranges of data. Overall: despite all the recent hype, the so called neural network are just parametrized functions of the input. So you do give them some structure in any case. If there is no multiplication between inputs, inputs will never be multiplied. If you know/suspect that your task needs them to be multiplied, tell the network to do so.</span>
<span class="comment-copy">On top of being unnecessarily general &amp; vague for a relatively simple question with a fully reproducible case, your answer is possibly <b>misleading</b> when implying that we cannot approximate functions like <code>x*x</code> with relatively simple feed-forward models (terms like "perfect" and "fully" do not save the day - they instead add to the vagueness); before turning "philosophical', I would kindly suggest to focus on more obvious issues in OP's code, like the ultra-simplistic "model" and the ulta-small dataset...</span>
<span class="comment-copy">@desertnaut I was hoping that "What you can get is an approximation in the range of values presented during training" disallows the misleading you've find. But as they say, when a reader is confused, it's the writer's fault. So I've updated the answer. I still disagree with you in the other points, because (1) the OP is clear that they have tried larger models and (2) one <b>can</b> train a reasonable approximator on the few data OP tries, see the update. I guess we'd have less of a disagreement if the question was more detailed in what OP considers wrong and what models they have actually tried.</span>
<span class="comment-copy">Apart from (1) (as what is "clear" is, well, not that clear), all your other points are fare; downvote retracted, as now it <i>is</i> indeed a valid answer</span>
