<div class="post-text" itemprop="text">
<p>I'm trying to update the fields of a model using update_or_create which is getting the data from an api. The problem is that all the fields are being populated with only the last two values from of i['Concessional] and i['Noncessional']</p>
<p>I'm using an external api to update the following model:</p>
<pre><code>class Contributions(models.Model):
    trustee = models.ForeignKey(Trustee, on_delete = models.CASCADE)
    concessional_caps = models.FloatField(null = True, blank = True)
    noncessional_caps = models.FloatField(null = True, blank = True)

    concessional_contributions_to_this_fund = models.FloatField(null = True, blank = True)
    non_concessional_contributions_to_this_fund = models.FloatField(null = True, blank = True)

    concessional_contributions_to_other_fund = models.FloatField(null = True, blank = True)
    non_concessional_contributions_to_other_fund = models.FloatField(null = True, blank = True)

    concessional_contributions_as_allocated =models.FloatField(null = True, blank = True)
    non_concessional_contributions_as_allocated = models.FloatField(null = True, blank = True)

    concessional_amounts_above_caps = models.FloatField(null = True, blank = True)
    non_concessional_amounts_above_caps = models.FloatField(null = True, blank = True)

    concessional_available_total = models.FloatField(null = True, blank = True)
    non_concessional_available_total = models.FloatField(null = True, blank = True)
</code></pre>
<p>Using the following code:</p>
<pre><code>for i in range(len(contribution_caps_data['Data']['Members'])):
            Contributions.objects.update_or_create(trustee = Trustee.objects.get(trustee_name = contribution_caps_data['Data']['Members'][i]["Name"]))
            for j in contribution_caps_data['Data']['Members'][i]['YearBreakdown']['ContributionDetails']:
                Contributions.objects.update_or_create(trustee = Trustee.objects.get(trustee_name =  contribution_caps_data['Data']['Members'][i]["Name"]),
                    defaults = {
                    'concessional_caps': j['Concessional'],
                    'noncessional_caps': j['NonConcessional'],

                    'concessional_contributions_to_this_fund': j['Concessional'],
                    'non_concessional_contributions_to_this_fund': j['NonConcessional'],

                    'concessional_contributions_to_other_fund': j['Concessional'],
                    'non_concessional_contributions_as_allocated': j['NonConcessional'],

                    'concessional_contributions_as_allocated': j['Concessional'],
                    'non_concessional_amounts_above_caps': j['NonConcessional'],

                    'concessional_amounts_above_caps': j['Concessional'],
                    'non_concessional_amounts_above_caps': j['NonConcessional'],

                    'concessional_available_total': j['Concessional'],
                    'non_concessional_available_total': j['NonConcessional']
                    }

                    )
</code></pre>
<p>I am trying to create a new Contributions record, the first loop is to get the names(foreign key) and the second loop is to actually get the values of contributions</p>
<p>How would you recommend working around this. Should i be preprocessing into a usable form(maybe a dictionary) first and then updating the model. Forgive me for this being a trivial question, but I'm relatively new to Python and Django, but I cant seem to figure out the solution.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>You never saved the data</li>
<li>Model trustee: is <code>trustee_name</code> always guaranteed to get the instance? People can have the same name...</li>
<li>likewise for the Contributions model - shouldn't there be some year or something attached to it?</li>
<li>use variables and speaking variable names</li>
<li>no <code>range(len(...</code> needed if you iterate over a list</li>
</ul>
<p>Off the top of my head, this would be better</p>
<pre><code>for member in contribution_caps_data['Data']['Members']:
    trustee, created = Trustee.objects.get_or_create(trustee_name=member['Name'])
    if created:
        trustee.save()

    for contribution_detail in member['YearBreakdown']['ContributionDetails']:
        # WARNING: you need to change this, otherwise you'll always get the same contribution for the trustee...
        # Perhaps there's the year in the YearBreakdown...
        contribution, created = Contributions.objects.get_or_create(trustee=trustee)  # gets same contribution in each iteration...

        contribution.concessional_caps = contribution_detail['Concessional']
        contribution.noncessional_caps = contribution_detail['NonConcessional']
        # ... the same for all other attributes ...

        contribution.save()
</code></pre>
</div>
