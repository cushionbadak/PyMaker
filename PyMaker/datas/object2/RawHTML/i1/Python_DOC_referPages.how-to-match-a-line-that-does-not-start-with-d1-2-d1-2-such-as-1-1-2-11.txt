<div class="post-text" itemprop="text">
<p>I need a regex able to match everything <strong>but</strong> a string starting with a specific pattern (specifically <code>index.php</code> and what follows, like <code>index.php?id=2342343</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>Not a regexp expert, but I think you could use a negative lookahead from the start, e.g. <code>^(?!foo).*$</code> shouldn't match anything starting with <code>foo</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can put a <code>^</code> in the beginning of a character set to match anything but those characters.</p>
<pre><code>[^=]*
</code></pre>
<p>will match everything but <code>=</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Regex: match everything <strong>but</strong>:</p>
<ul>
<li>a <strong>string <em>starting with</em> a specific pattern</strong>  (e.g. any  - empty, too - string not starting with <code>foo</code>):

<ul>
<li>Lookahead-based solution for NFAs: 

<ul>
<li><a href="https://regex101.com/r/jC8nB0/6"><code>^(?!foo).*$</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/5"><code>^(?!foo)</code></a></li>
</ul></li>
<li>Negated character class based solution <em>for regex engines not supporting lookarounds</em>:

<ul>
<li><a href="https://regex101.com/r/jC8nB0/16"><code>^(([^f].{2}|.[^o].|.{2}[^o]).*|.{0,2})$</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/15"><code>^([^f].{2}|.[^o].|.{2}[^o])|^.{0,2}$</code></a></li>
</ul></li>
</ul></li>
<li>a <strong>string <em>ending with</em> a specific pattern</strong> (say, no <code>world.</code> at the end):

<ul>
<li>Lookbehind-based solution:

<ul>
<li><a href="https://regex101.com/r/jC8nB0/11"><code>(?&lt;!world\.)$</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/12"><code>^.*(?&lt;!world\.)$</code></a></li>
</ul></li>
<li>POSIX workaround:

<ul>
<li><a href="https://regex101.com/r/jC8nB0/17"><code>^(.*([^w].{5}|.[^o].{4}|.{2}[^r].{3}|.{3}[^l].{2}|.{4}[^d].|.{5}[^.])|.{0,5})$</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/18"><code>([^w].{5}|.[^o].{4}|.{2}[^r].{3}|.{3}[^l].{2}|.{4}[^d].|.{5}[^.]$|^.{0,5})$</code></a></li>
</ul></li>
</ul></li>
<li>a <strong>string <em>containing</em> specific text</strong> (say, not match a string having <code>foo</code>) (no POSIX compliant patern, sorry): 

<ul>
<li><a href="https://regex101.com/r/jC8nB0/21"><code>^(?!.*foo)</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/22"><code>^(?!.*foo).*$</code></a></li>
</ul></li>
<li>a <strong>string <em>containing</em> specific <em>character</em></strong> (say, avoid matching a string having a <code>|</code> symbol):

<ul>
<li><a href="https://regex101.com/r/jC8nB0/26"><code>^[^|]*$</code></a></li>
</ul></li>
<li>a <strong>string <em>equal to</em> some string</strong> (say, not equal to <code>foo</code>):

<ul>
<li>Lookaround-based:

<ul>
<li><a href="https://regex101.com/r/jC8nB0/23"><code>^(?!foo$)</code></a></li>
<li><a href="https://regex101.com/r/jC8nB0/24"><code>^(?!foo$).*$</code></a></li>
</ul></li>
<li>POSIX:

<ul>
<li><a href="https://regex101.com/r/jC8nB0/25"><code>^(.{0,2}|.{4,}|[^f]..|.[^o].|..[^o])$</code></a></li>
</ul></li>
</ul></li>
<li>a <strong>sequence of characters</strong>: 

<ul>
<li><em>PCRE</em> (match any text but <code>cat</code>): <a href="https://regex101.com/r/jC8nB0/1"><code>/cat(*SKIP)(*FAIL)|[^c]*(?:c(?!at)[^c]*)*/i</code></a> or <a href="https://regex101.com/r/jC8nB0/2"><code>/cat(*SKIP)(*FAIL)|(?:(?!cat).)+/is</code></a></li>
<li>Other engines allowing lookarounds: <a href="https://regex101.com/r/jC8nB0/19"><code>(cat)|[^c]*(?:c(?!at)[^c]*)*</code></a> (or <a href="https://regex101.com/r/jC8nB0/20"><code>(?s)(cat)|(?:(?!cat).)*</code></a>, or <code>(cat)|[^c]+(?:c(?!at)[^c]*)*|(?:c(?!at)[^c]*)+[^c]*</code>) and then check with language means: if Group 1 matched, it is not what we need, else, grab the match value if not empty</li>
</ul></li>
<li>a <strong>certain single character or a set of characters</strong>:

<ul>
<li>Use a <a href="http://www.regular-expressions.info/charclass.html#negated">negated character class</a>: <a href="https://regex101.com/r/jC8nB0/7"><code>[^a-z]+</code></a> (any char other than a lowercase ASCII letter)</li>
<li>Matching any char(s) but <code>|</code>: <a href="https://regex101.com/r/jC8nB0/8"><code>[^|]+</code></a></li>
</ul></li>
</ul>
<p><strong>Demo note</strong>: the newline <code>\n</code> is used inside negated character classes in demos to avoid match overflow to the neighboring line(s). They are not necessary when testing individual strings.</p>
<p><strong>Anchor note</strong>: In many languages, use <code>\A</code> to define the unambiguous start of string, and <code>\z</code> (in Python, it is <code>\Z</code>, in JavaScript, <code>$</code> is OK) to define the very end of the string.</p>
<p><strong>Dot note</strong>: In many flavors (but not POSIX, TRE, TCL), <code>.</code> matches any char <em>but a newline</em> char. Make sure you use a corresponding DOTALL modifier (<code>/s</code> in PCRE/Boost/.NET/Python/Java and <code>/m</code> in Ruby) for the <code>.</code> to match any char including a newline.</p>
<p><strong>Backslash note</strong>: In languages where you have to declare patterns with C strings allowing escape sequences (like <code>\n</code> for a newline), you need to double the backslashes escaping special characters so that the engine could treat them as literal characters (e.g. in Java, <code>world\.</code> will be declared as <code>"world\\."</code>, or use a character class: <code>"world[.]"</code>). Use raw string literals (Python <code>r'\bworld\b'</code>), C# verbatim string literals <code>@"world\."</code>, or slashy strings/regex literal notations like <code>/world\./</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just match <code>/^index\.php/</code> then reject whatever matches it.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; p='^(?!index\.php\?[0-9]+).*$'
&gt;&gt;&gt; s1='index.php?12345'
&gt;&gt;&gt; re.match(p,s1)
&gt;&gt;&gt; s2='index.html?12345'
&gt;&gt;&gt; re.match(p,s2)
&lt;_sre.SRE_Match object at 0xb7d65fa8&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>grep -v in shell</p>
<p>!~ in perl</p>
<p>Please add more in other languages - I marked this as Community Wiki.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about not using regex:</p>
<pre><code>// In PHP
0 !== strpos($string, 'index.php')
</code></pre>
</div>
<span class="comment-copy">And what <i>specific</i> pattern do you want to not match?</span>
<span class="comment-copy">Is there a reason why you can't match against your pattern and not do something if the string matches that?</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/406230/regular-expression-to-match-a-line-that-doesnt-contain-a-word">Regular expression to match a line that doesn't contain a word?</a></span>
<span class="comment-copy">With grep use -P to enable lookahead.</span>
<span class="comment-copy">If not matching "foo" or "bar" is your desired behavior, check this answer:  <a href="http://stackoverflow.com/a/2404330/874824">stackoverflow.com/a/2404330/874824</a></span>
<span class="comment-copy">This answer is wrong, a quick test shows that. I think what you meant is <code>^((?!foo).)*$</code> (<a href="https://stackoverflow.com/a/406408/3964381">stackoverflow.com/a/406408/3964381</a>)</span>
<span class="comment-copy">That's true, but it only processes one character at a time.  If you want to exclude a sequence of two or more characters, you have to use negative lookahead like the other responders said.</span>
<span class="comment-copy">Great write up!  For the case of "a string (not) equal to some string", with the example of <code>^(?!foo$)</code>, why is it that the dollar sign has to be within the parentheses for the expression to work? I was expecting <code>^(?!foo)$</code> to give the same results, but it does not.</span>
<span class="comment-copy">@GrantHumphries: When the <code>$</code> anchor is inside the lookahead, it is part of the condition, part of that <i>zero-width assertion</i>. If it were outside, like in <code>^(?!foo)$</code>, it will be part of the <i>consuming</i> pattern requiring the end of string right after the start of string, making the negative lookahead irrelevant since it would always return <i>true</i> (there cannot be any text after the end of string, let alone <code>foo</code>). So, <code>^(?!foo$)</code> matches start of a string that is not followed with <code>foo</code> that is followed with the string end. <code>^(?!foo)$</code> matches an empty string.</span>
<span class="comment-copy">Why won't this work?</span>
<span class="comment-copy">What about pattern negation?</span>
<span class="comment-copy">That will reject "index_php" or "index#php".</span>
<span class="comment-copy">Good point, forgot to escape the '.'  Thanks.</span>
<span class="comment-copy">The OP specifically requested a regex... I'm not sure this helps! (He certainly has his reasons for requesting a regex; he didn't ask, "How can I solve this with any arbitrary technology?")</span>
<span class="comment-copy">The OP specifically requested a regex... I'm not sure this helps!  (He may be using <code>grep</code> on the command-line, for example, or Perl/Python/any other language, or an "Execute this regex for every line" command in a text editor, etc...)</span>
