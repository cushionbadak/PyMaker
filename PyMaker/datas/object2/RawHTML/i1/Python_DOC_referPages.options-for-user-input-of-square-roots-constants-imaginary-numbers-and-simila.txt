<div class="post-text" itemprop="text">
<pre><code>stringExp = "2^4"
intVal = int(stringExp)      # Expected value: 16
</code></pre>
<p>This returns the following error:</p>
<pre><code>Traceback (most recent call last):  
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid literal for int()
with base 10: '2^4'
</code></pre>
<p>I know that <code>eval</code> can work around this, but isn't there a better and - more importantly - safer method to evaluate a mathematical expression that is being stored in a string?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://github.com/pyparsing/pyparsing" rel="noreferrer">Pyparsing</a> can be used to parse mathematical expressions. In particular, <a href="https://github.com/pyparsing/pyparsing/blob/master/examples/fourFn.py" rel="noreferrer">fourFn.py</a>
shows how to parse basic arithmetic expressions. Below, I've rewrapped fourFn into a numeric parser class for easier reuse. </p>
<pre><code>from __future__ import division
from pyparsing import (Literal, CaselessLiteral, Word, Combine, Group, Optional,
                       ZeroOrMore, Forward, nums, alphas, oneOf)
import math
import operator

__author__ = 'Paul McGuire'
__version__ = '$Revision: 0.0 $'
__date__ = '$Date: 2009-03-20 $'
__source__ = '''http://pyparsing.wikispaces.com/file/view/fourFn.py
http://pyparsing.wikispaces.com/message/view/home/15549426
'''
__note__ = '''
All I've done is rewrap Paul McGuire's fourFn.py as a class, so I can use it
more easily in other places.
'''


class NumericStringParser(object):
    '''
    Most of this code comes from the fourFn.py pyparsing example

    '''

    def pushFirst(self, strg, loc, toks):
        self.exprStack.append(toks[0])

    def pushUMinus(self, strg, loc, toks):
        if toks and toks[0] == '-':
            self.exprStack.append('unary -')

    def __init__(self):
        """
        expop   :: '^'
        multop  :: '*' | '/'
        addop   :: '+' | '-'
        integer :: ['+' | '-'] '0'..'9'+
        atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'
        factor  :: atom [ expop factor ]*
        term    :: factor [ multop factor ]*
        expr    :: term [ addop term ]*
        """
        point = Literal(".")
        e = CaselessLiteral("E")
        fnumber = Combine(Word("+-" + nums, nums) +
                          Optional(point + Optional(Word(nums))) +
                          Optional(e + Word("+-" + nums, nums)))
        ident = Word(alphas, alphas + nums + "_$")
        plus = Literal("+")
        minus = Literal("-")
        mult = Literal("*")
        div = Literal("/")
        lpar = Literal("(").suppress()
        rpar = Literal(")").suppress()
        addop = plus | minus
        multop = mult | div
        expop = Literal("^")
        pi = CaselessLiteral("PI")
        expr = Forward()
        atom = ((Optional(oneOf("- +")) +
                 (ident + lpar + expr + rpar | pi | e | fnumber).setParseAction(self.pushFirst))
                | Optional(oneOf("- +")) + Group(lpar + expr + rpar)
                ).setParseAction(self.pushUMinus)
        # by defining exponentiation as "atom [ ^ factor ]..." instead of
        # "atom [ ^ atom ]...", we get right-to-left exponents, instead of left-to-right
        # that is, 2^3^2 = 2^(3^2), not (2^3)^2.
        factor = Forward()
        factor &lt;&lt; atom + \
            ZeroOrMore((expop + factor).setParseAction(self.pushFirst))
        term = factor + \
            ZeroOrMore((multop + factor).setParseAction(self.pushFirst))
        expr &lt;&lt; term + \
            ZeroOrMore((addop + term).setParseAction(self.pushFirst))
        # addop_term = ( addop + term ).setParseAction( self.pushFirst )
        # general_term = term + ZeroOrMore( addop_term ) | OneOrMore( addop_term)
        # expr &lt;&lt;  general_term
        self.bnf = expr
        # map operator symbols to corresponding arithmetic operations
        epsilon = 1e-12
        self.opn = {"+": operator.add,
                    "-": operator.sub,
                    "*": operator.mul,
                    "/": operator.truediv,
                    "^": operator.pow}
        self.fn = {"sin": math.sin,
                   "cos": math.cos,
                   "tan": math.tan,
                   "exp": math.exp,
                   "abs": abs,
                   "trunc": lambda a: int(a),
                   "round": round,
                   "sgn": lambda a: abs(a) &gt; epsilon and cmp(a, 0) or 0}

    def evaluateStack(self, s):
        op = s.pop()
        if op == 'unary -':
            return -self.evaluateStack(s)
        if op in "+-*/^":
            op2 = self.evaluateStack(s)
            op1 = self.evaluateStack(s)
            return self.opn[op](op1, op2)
        elif op == "PI":
            return math.pi  # 3.1415926535
        elif op == "E":
            return math.e  # 2.718281828
        elif op in self.fn:
            return self.fn[op](self.evaluateStack(s))
        elif op[0].isalpha():
            return 0
        else:
            return float(op)

    def eval(self, num_string, parseAll=True):
        self.exprStack = []
        results = self.bnf.parseString(num_string, parseAll)
        val = self.evaluateStack(self.exprStack[:])
        return val
</code></pre>
<p>You can use it like this</p>
<pre><code>nsp = NumericStringParser()
result = nsp.eval('2^4')
print(result)
# 16.0

result = nsp.eval('exp(2^4)')
print(result)
# 8886110.520507872
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2><code>eval</code> is evil</h2>
<pre><code>eval("__import__('os').remove('important file')") # arbitrary commands
eval("9**9**9**9**9**9**9**9", {'__builtins__': None}) # CPU, memory
</code></pre>
<p>Note: even if you use set <code>__builtins__</code> to <code>None</code> it still might be possible to break out using introspection:</p>
<pre><code>eval('(1).__class__.__bases__[0].__subclasses__()', {'__builtins__': None})
</code></pre>
<h2>Evaluate arithmetic expression using <code>ast</code></h2>
<pre><code>import ast
import operator as op

# supported operators
operators = {ast.Add: op.add, ast.Sub: op.sub, ast.Mult: op.mul,
             ast.Div: op.truediv, ast.Pow: op.pow, ast.BitXor: op.xor,
             ast.USub: op.neg}

def eval_expr(expr):
    """
    &gt;&gt;&gt; eval_expr('2^6')
    4
    &gt;&gt;&gt; eval_expr('2**6')
    64
    &gt;&gt;&gt; eval_expr('1 + 2*3**(4^5) / (6 + -7)')
    -5.0
    """
    return eval_(ast.parse(expr, mode='eval').body)

def eval_(node):
    if isinstance(node, ast.Num): # &lt;number&gt;
        return node.n
    elif isinstance(node, ast.BinOp): # &lt;left&gt; &lt;operator&gt; &lt;right&gt;
        return operators[type(node.op)](eval_(node.left), eval_(node.right))
    elif isinstance(node, ast.UnaryOp): # &lt;operator&gt; &lt;operand&gt; e.g., -1
        return operators[type(node.op)](eval_(node.operand))
    else:
        raise TypeError(node)
</code></pre>
<p>You can easily limit allowed range for each operation or any intermediate result, e.g., to limit input arguments for <code>a**b</code>:</p>
<pre><code>def power(a, b):
    if any(abs(n) &gt; 100 for n in [a, b]):
        raise ValueError((a,b))
    return op.pow(a, b)
operators[ast.Pow] = power
</code></pre>
<p>Or to limit magnitude of intermediate results:</p>
<pre><code>import functools

def limit(max_=None):
    """Return decorator that limits allowed returned values."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            ret = func(*args, **kwargs)
            try:
                mag = abs(ret)
            except TypeError:
                pass # not applicable
            else:
                if mag &gt; max_:
                    raise ValueError(ret)
            return ret
        return wrapper
    return decorator

eval_ = limit(max_=10**100)(eval_)
</code></pre>
<h3>Example</h3>
<pre><code>&gt;&gt;&gt; evil = "__import__('os').remove('important file')"
&gt;&gt;&gt; eval_expr(evil) #doctest:+IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
TypeError:
&gt;&gt;&gt; eval_expr("9**9")
387420489
&gt;&gt;&gt; eval_expr("9**9**9**9**9**9**9**9") #doctest:+IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
ValueError:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Some safer alternatives to <code>eval()</code> and <a href="http://docs.sympy.org/latest/modules/core.html#module-sympy.core.sympify" rel="nofollow noreferrer"><code>sympy.sympify().evalf()</code></a><sup>*</sup>:</p>
<ul>
<li><a href="http://newville.github.io/asteval/" rel="nofollow noreferrer">asteval</a> </li>
<li><a href="https://github.com/pydata/numexpr" rel="nofollow noreferrer">numexpr</a></li>
</ul>
<p><sup>*</sup>SymPy <a href="http://docs.sympy.org/latest/modules/core.html#module-sympy.core.sympify" rel="nofollow noreferrer"><code>sympify</code></a> is also unsafe according to the following warning from the documentation.</p>
<blockquote>
<p><strong>Warning:</strong> Note that this function uses <code>eval</code>, and thus shouldnâ€™t be used on unsanitized input.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Okay, so the problem with eval is that it can escape its sandbox too easily, even if you get rid of <code>__builtins__</code>.  All the methods for escaping the sandbox come down to using <code>getattr</code> or <code>object.__getattribute__</code> (via the <code>.</code> operator) to obtain a reference to some dangerous object via some allowed object (<code>''.__class__.__bases__[0].__subclasses__</code> or similar).  <code>getattr</code> is eliminated by setting <code>__builtins__</code> to <code>None</code>.  <code>object.__getattribute__</code> is the difficult one, since it cannot simply be removed, both because <code>object</code> is immutable and because removing it would break everything.  However, <code>__getattribute__</code> is only accessible via the <code>.</code> operator, so purging that from your input is sufficient to ensure eval cannot escape its sandbox.<br/>
In processing formulas, the only valid use of a decimal is when it is preceded or followed by <code>[0-9]</code>, so we just remove all other instances of <code>.</code>.</p>
<pre><code>import re
inp = re.sub(r"\.(?![0-9])","", inp)
val = eval(inp, {'__builtins__':None})
</code></pre>
<p>Note that while python normally treats <code>1 + 1.</code> as <code>1 + 1.0</code>, this will remove the trailing <code>.</code> and leave you with <code>1 + 1</code>.  You could add <code>)</code>,<code></code>, and <code>EOF</code> to the list of things allowed to follow <code>.</code>, but why bother?</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason <code>eval</code> and <code>exec</code> are so dangerous is that the default <code>compile</code> function will generate bytecode for any valid python expression, and the default <code>eval</code> or <code>exec</code> will execute any valid python bytecode.  All the answers to date have focused on restricting the bytecode that can be generated (by sanitizing input) or building your own domain-specific-language using the AST.  </p>
<p>Instead, you can easily create a simple <code>eval</code> function that is incapable of doing anything nefarious and can easily have runtime checks on memory or time used.  Of course, if it is simple math, than there is a shortcut.</p>
<pre><code>c = compile(stringExp, 'userinput', 'eval')
if c.co_code[0]==b'd' and c.co_code[3]==b'S':
    return c.co_consts[ord(c.co_code[1])+ord(c.co_code[2])*256]
</code></pre>
<p>The way this works is simple, any constant mathematic expression is safely evaluated during compilation and stored as a constant.  The code object returned by compile consists of <code>d</code>, which is the bytecode for <code>LOAD_CONST</code>, followed by the number of the constant to load (usually the last one in the list), followed by <code>S</code>, which is the bytecode for <code>RETURN_VALUE</code>.  If this shortcut doesn't work, it means that the user input isn't a constant expression (contains a variable or function call or similar).  </p>
<p>This also opens the door to some more sophisticated input formats.  For example:</p>
<pre><code>stringExp = "1 + cos(2)"
</code></pre>
<p>This requires actually evaluating the bytecode, which is still quite simple.  Python bytecode is a stack oriented language, so everything is a simple matter of <code>TOS=stack.pop(); op(TOS); stack.put(TOS)</code> or similar.  The key is to only implement the opcodes that are safe (loading/storing values, math operations, returning values) and not unsafe ones (attribute lookup).  If you want the user to be able to call functions (the whole reason not to use the shortcut above), simple make your implementation of <code>CALL_FUNCTION</code> only allow functions in a 'safe' list.</p>
<pre><code>from dis import opmap
from Queue import LifoQueue
from math import sin,cos
import operator

globs = {'sin':sin, 'cos':cos}
safe = globs.values()

stack = LifoQueue()

class BINARY(object):
    def __init__(self, operator):
        self.op=operator
    def __call__(self, context):
        stack.put(self.op(stack.get(),stack.get()))

class UNARY(object):
    def __init__(self, operator):
        self.op=operator
    def __call__(self, context):
        stack.put(self.op(stack.get()))


def CALL_FUNCTION(context, arg):
    argc = arg[0]+arg[1]*256
    args = [stack.get() for i in range(argc)]
    func = stack.get()
    if func not in safe:
        raise TypeError("Function %r now allowed"%func)
    stack.put(func(*args))

def LOAD_CONST(context, arg):
    cons = arg[0]+arg[1]*256
    stack.put(context['code'].co_consts[cons])

def LOAD_NAME(context, arg):
    name_num = arg[0]+arg[1]*256
    name = context['code'].co_names[name_num]
    if name in context['locals']:
        stack.put(context['locals'][name])
    else:
        stack.put(context['globals'][name])

def RETURN_VALUE(context):
    return stack.get()

opfuncs = {
    opmap['BINARY_ADD']: BINARY(operator.add),
    opmap['UNARY_INVERT']: UNARY(operator.invert),
    opmap['CALL_FUNCTION']: CALL_FUNCTION,
    opmap['LOAD_CONST']: LOAD_CONST,
    opmap['LOAD_NAME']: LOAD_NAME
    opmap['RETURN_VALUE']: RETURN_VALUE,
}

def VMeval(c):
    context = dict(locals={}, globals=globs, code=c)
    bci = iter(c.co_code)
    for bytecode in bci:
        func = opfuncs[ord(bytecode)]
        if func.func_code.co_argcount==1:
            ret = func(context)
        else:
            args = ord(bci.next()), ord(bci.next())
            ret = func(context, args)
        if ret:
            return ret

def evaluate(expr):
    return VMeval(compile(expr, 'userinput', 'eval'))
</code></pre>
<p>Obviously, the real version of this would be a bit longer (there are 119 opcodes, 24 of which are math related).  Adding <code>STORE_FAST</code> and a couple others would allow for input like <code>'x=5;return x+x</code> or similar, trivially easily.  It can even be used to execute user-created functions, so long as the user created functions are themselves executed via VMeval (don't make them callable!!! or they could get used as a callback somewhere).  Handling loops requires support for the <code>goto</code> bytecodes, which means changing from a <code>for</code> iterator to <code>while</code> and maintaining a pointer to the current instruction, but isn't too hard.  For resistance to DOS, the main loop should check how much time has passed since the start of the calculation, and certain operators should deny input over some reasonable limit (<code>BINARY_POWER</code> being the most obvious).</p>
<p>While this approach is somewhat longer than a simple grammar parser for simple expressions (see above about just grabbing the compiled constant), it extends easily to more complicated input, and doesn't require dealing with grammar (<code>compile</code> take anything arbitrarily complicated and reduces it to a sequence of simple instructions).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the ast module and write a NodeVisitor that verifies that the type of each node is part of a whitelist.</p>
<pre><code>import ast, math

locals =  {key: value for (key,value) in vars(math).items() if key[0] != '_'}
locals.update({"abs": abs, "complex": complex, "min": min, "max": max, "pow": pow, "round": round})

class Visitor(ast.NodeVisitor):
    def visit(self, node):
       if not isinstance(node, self.whitelist):
           raise ValueError(node)
       return super().visit(node)

    whitelist = (ast.Module, ast.Expr, ast.Load, ast.Expression, ast.Add, ast.Sub, ast.UnaryOp, ast.Num, ast.BinOp,
            ast.Mult, ast.Div, ast.Pow, ast.BitOr, ast.BitAnd, ast.BitXor, ast.USub, ast.UAdd, ast.FloorDiv, ast.Mod,
            ast.LShift, ast.RShift, ast.Invert, ast.Call, ast.Name)

def evaluate(expr, locals = {}):
    if any(elem in expr for elem in '\n#') : raise ValueError(expr)
    try:
        node = ast.parse(expr.strip(), mode='eval')
        Visitor().visit(node)
        return eval(compile(node, "&lt;string&gt;", "eval"), {'__builtins__': None}, locals)
    except Exception: raise ValueError(expr)
</code></pre>
<p>Because it works via a whitelist rather than a blacklist, it is safe. The only functions and variables it can access are those you explicitly give it access to. I populated a dict with math-related functions so you can easily provide access to those if you want, but you have to explicitly use it.</p>
<p>If the string attempts to call functions that haven't been provided, or invoke any methods, an exception will be raised, and it will not be executed.</p>
<p>Because this uses Python's built in parser and evaluator, it also inherits Python's precedence and promotion rules as well.</p>
<pre><code>&gt;&gt;&gt; evaluate("7 + 9 * (2 &lt;&lt; 2)")
79
&gt;&gt;&gt; evaluate("6 // 2 + 0.0")
3.0
</code></pre>
<p>The above code has only been tested on Python 3.</p>
<p>If desired, you can add a timeout decorator on this function.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a massively late reply, but I think useful for future reference. Rather than write your own math parser (although the pyparsing example above is great) you could use SymPy. I don't have a lot of experience with it, but it contains a much more powerful math engine than anyone is likely to write for a specific application and the basic expression evaluation is very easy:</p>
<pre><code>&gt;&gt;&gt; import sympy
&gt;&gt;&gt; x, y, z = sympy.symbols('x y z')
&gt;&gt;&gt; sympy.sympify("x**3 + sin(y)").evalf(subs={x:1, y:-3})
0.858879991940133
</code></pre>
<p>Very cool indeed! A <code>from sympy import *</code> brings in a lot more function support, such as trig functions, special functions, etc., but I've avoided that here to show what's coming from where.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think I would use <code>eval()</code>, but would first check to make sure the string is a valid mathematical expression, as opposed to something malicious.  You could use a regex for the validation.</p>
<p><code>eval()</code> also takes additional arguments which you can use to restrict the namespace it operates in for greater security.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>[I know this is an old question, but it is worth pointing out new useful solutions as they pop up]</em></p>
<p>Since python3.6, this capability is now <strong>built into the language</strong>, coined <strong>"f-strings"</strong>.</p>
<p><strong>See: <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow noreferrer">PEP 498 -- Literal String Interpolation</a></strong></p>
<p>For example (note the <strong><code>f</code></strong> prefix):</p>
<pre><code>f'{2**4}'
=&gt; '16'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use eval, then the only solution is to implement the appropriate grammar parser. Have a look at <a href="http://pyparsing.wikispaces.com/" rel="nofollow noreferrer">pyparsing</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are already using wolframalpha, they have a python api, which allows you to evaluate expressions. Might be a little slow, but at least very accurate. </p>
<p><a href="https://pypi.python.org/pypi/wolframalpha" rel="nofollow noreferrer">https://pypi.python.org/pypi/wolframalpha</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my solution to the problem without using eval. Works with Python2 and Python3. It doesn't work with negative numbers.</p>
<pre><code>$ python -m pytest test.py
</code></pre>
<p>test.py</p>
<pre><code>from solution import Solutions

class SolutionsTestCase(unittest.TestCase):
    def setUp(self):
        self.solutions = Solutions()

    def test_evaluate(self):
        expressions = [
            '2+3=5',
            '6+4/2*2=10',
            '3+2.45/8=3.30625',
            '3**3*3/3+3=30',
            '2^4=6'
        ]
        results = [x.split('=')[1] for x in expressions]
        for e in range(len(expressions)):
            if '.' in results[e]:
                results[e] = float(results[e])
            else:
                results[e] = int(results[e])
            self.assertEqual(
                results[e],
                self.solutions.evaluate(expressions[e])
            )
</code></pre>
<p>solution.py</p>
<pre><code>class Solutions(object):
    def evaluate(self, exp):
        def format(res):
            if '.' in res:
                try:
                    res = float(res)
                except ValueError:
                    pass
            else:
                try:
                    res = int(res)
                except ValueError:
                    pass
            return res
        def splitter(item, op):
            mul = item.split(op)
            if len(mul) == 2:
                for x in ['^', '*', '/', '+', '-']:
                    if x in mul[0]:
                        mul = [mul[0].split(x)[1], mul[1]]
                    if x in mul[1]:
                        mul = [mul[0], mul[1].split(x)[0]]
            elif len(mul) &gt; 2:
                pass
            else:
                pass
            for x in range(len(mul)):
                mul[x] = format(mul[x])
            return mul
        exp = exp.replace(' ', '')
        if '=' in exp:
            res = exp.split('=')[1]
            res = format(res)
            exp = exp.replace('=%s' % res, '')
        while '^' in exp:
            if '^' in exp:
                itm = splitter(exp, '^')
                res = itm[0] ^ itm[1]
                exp = exp.replace('%s^%s' % (str(itm[0]), str(itm[1])), str(res))
        while '**' in exp:
            if '**' in exp:
                itm = splitter(exp, '**')
                res = itm[0] ** itm[1]
                exp = exp.replace('%s**%s' % (str(itm[0]), str(itm[1])), str(res))
        while '/' in exp:
            if '/' in exp:
                itm = splitter(exp, '/')
                res = itm[0] / itm[1]
                exp = exp.replace('%s/%s' % (str(itm[0]), str(itm[1])), str(res))
        while '*' in exp:
            if '*' in exp:
                itm = splitter(exp, '*')
                res = itm[0] * itm[1]
                exp = exp.replace('%s*%s' % (str(itm[0]), str(itm[1])), str(res))
        while '+' in exp:
            if '+' in exp:
                itm = splitter(exp, '+')
                res = itm[0] + itm[1]
                exp = exp.replace('%s+%s' % (str(itm[0]), str(itm[1])), str(res))
        while '-' in exp:
            if '-' in exp:
                itm = splitter(exp, '-')
                res = itm[0] - itm[1]
                exp = exp.replace('%s-%s' % (str(itm[0]), str(itm[1])), str(res))

        return format(exp)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>eval</code> in a clean namespace:</p>
<pre><code>&gt;&gt;&gt; ns = {'__builtins__': None}
&gt;&gt;&gt; eval('2 ** 4', ns)
16
</code></pre>
<p>The clean namespace should prevent injection. For instance:</p>
<pre><code>&gt;&gt;&gt; eval('__builtins__.__import__("os").system("echo got through")', ns)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;string&gt;", line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute '__import__'
</code></pre>
<p>Otherwise you would get:</p>
<pre><code>&gt;&gt;&gt; eval('__builtins__.__import__("os").system("echo got through")')
got through
0
</code></pre>
<p>You might want to give access to the math module:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; ns = vars(math).copy()
&gt;&gt;&gt; ns['__builtins__'] = None
&gt;&gt;&gt; eval('cos(pi/3)', ns)
0.50000000000000011
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python already has a function for safely evaluating strings containing literal expressions:</p>
<p><a href="http://docs.python.org/2/library/ast.html#ast.literal_eval" rel="nofollow">http://docs.python.org/2/library/ast.html#ast.literal_eval</a></p>
</div>
<span class="comment-copy">^ is the XOR operator. Expected value is 6. You probably want pow(2,4).</span>
<span class="comment-copy">or more pythonically 2**4</span>
<span class="comment-copy">Not exactly a duplicate. I'm just parsing math without introducing unknowns.</span>
<span class="comment-copy">Now, that's probably more than what the OP had in mind, but +1 for the relatively compact pyparsing application!  Thanks.</span>
<span class="comment-copy">Pyparsing is no longer hosted on wikispaces.com. Go to <a href="https://github.com/pyparsing/pyparsing" rel="nofollow noreferrer">github.com/pyparsing/pyparsing</a></span>
<span class="comment-copy">Very cool post, Thanks.  I've taken that concept, and tried to make a library which should be easy to use: <a href="https://github.com/danthedeckie/simpleeval" rel="nofollow noreferrer">github.com/danthedeckie/simpleeval</a></span>
<span class="comment-copy">@TimPietzcker: I've updated the code to support both Python 2 and 3.</span>
<span class="comment-copy">Another library that uses this approach: <a href="http://newville.github.io/asteval/" rel="nofollow noreferrer">newville.github.io/asteval</a></span>
<span class="comment-copy">This is also a great introduction on how to use the <code>ast</code> library...thanks!</span>
<span class="comment-copy">Note that <code>ast.parse</code> is not safe. For example <code>ast.parse('()' * 1000000, '&lt;string&gt;', 'single')</code> crashes the interpreter.</span>
<span class="comment-copy">A related question with interesting discussion can be found <a href="https://stackoverflow.com/q/35804961">here</a>.</span>
<span class="comment-copy">Is sympy "safe"? There seem to be <a href="https://groups.google.com/d/topic/sympy/YrkrEreij1c/discussion" rel="nofollow noreferrer">numerous</a> <a href="http://stackoverflow.com/questions/16718644/how-safe-is-sympys-sympifystring-evalf">posts</a> that suggest it is a wrapper around eval() that could be exploited in the same way. Also <code>evalf</code> doesn't take numpy ndarrays.</span>
<span class="comment-copy">No sympy is not safe for untrusted input. Try <code>sympy.sympify("""[].__class__.__base__.__subclasses__()[158]('ls')""")</code> this calls <code>subprocess.Popen()</code> which I passed <code>ls</code> instead of <code>rm -rf /</code>. The index will probably be different on other computers. This is a variant of the <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">Ned Batchelder exploit</a></span>
<span class="comment-copy">Indeed, it does not add to safety at all.</span>
<span class="comment-copy">But, of course, don't rely on regular expressions to validate arbitrary mathematical expressions.</span>
<span class="comment-copy">@High-Performance Mark: Yes, I guess it depends on what sort of mathematical expressions he has in mind . . . e.g., just simple arithmetic with numbers and <code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>**</code>,<code>(</code>,<code>)</code> or something more complicated</span>
<span class="comment-copy">@Tim -- it's the () I'm worried about, or rather the (((((())))))).  In truth, I think OP should worry about them, my brow is unfurrowed by OP's problems.</span>
<span class="comment-copy">Don't use <code>eval()</code> if you don't control input even if you restrict the namespace e.g., <a href="http://stackoverflow.com/a/9558001/4279"><code>eval("9**9**9**9**9**9**9**9", {'__builtins__': None})</code></a> consumes CPU, memory.</span>
<span class="comment-copy">Restricting the namespace of eval <b>does not add to security</b>.</span>
<span class="comment-copy">Very interesting link. But I guess f-strings are here to make writing source code easier, while the question seems to be about working with strings inside of variables (possibly from untrusted sources). f-strings cannot be used in that case.</span>
<span class="comment-copy">is there any way to do something to the effect of f'{2{operator}4}' where you can now assign the operator to do 2+4 or 2*4 or 2-4 or etc</span>
<span class="comment-copy">The amount of overkill in using Wolfram Alpha to evaluate arithmetic expressions is kinda awesome. :)</span>
<span class="comment-copy">+1 for limiting the namespace. Just like in normal code, using <code>__builtins__.*</code> is unnecessary.</span>
<span class="comment-copy">eval("(1).__class__.__bases__[0].__subclasses__()[81]('echo got through'.split())",{'<b>builtins</b>':None}) #escapes your sandbox</span>
<span class="comment-copy">Python 3.4: <code>eval("""[i for i in (1).__class__.__bases__[0].__subclasses__() if i.__name__.endswith('BuiltinImporter')][0]().load_module('sys').modules['sys'].modules['os'].system('/bin/sh')""", {'__builtins__': None})</code> executes the bourne shell...</span>
<span class="comment-copy"><b>This is not safe</b>. Malicious code can still be executed.</span>
<span class="comment-copy"><code>This is not safe</code> - well, I reckon it is just as safe as using bash overall. BTW: <code>eval('math.sqrt(2.0)')</code> &lt;- "math." is required as written above.</span>
<span class="comment-copy">have you tried it? <code>ast.literal_eval("2^4")</code> fails. It is an arithmetic (not literal) expression. Though it might be evaluated into a constant during compilation.</span>
