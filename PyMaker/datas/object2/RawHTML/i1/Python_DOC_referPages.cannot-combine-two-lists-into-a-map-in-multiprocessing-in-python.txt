<div class="post-text" itemprop="text">
<p>I have one csv with SKUs and URLs I break them in two lists with</p>
<pre><code>def myskus():
    myskus =[]
    with open('websupplies2.csv', 'r') as csvf:
        reader = csv.reader(csvf, delimiter=";")
        for row in reader:
            myskus.append(row[0]) # Add each skus to list contents
    return myskus


def mycontents():
    contents = []
    with open('websupplies2.csv', 'r') as csvf:
        reader = csv.reader(csvf, delimiter=";")
        for row in reader:
            contents.append(row[1]) # Add each url to list contents
    return contents
</code></pre>
<p>Then I multiprocess my urls but I want to join the correspondin SKU</p>
<pre><code>if __name__ == "__main__":

    with Pool(4) as p:
     records = p.map(parse, web_links)

    if len(records) &gt; 0:
         with open('output_websupplies.csv', 'a') as f:
          f.write('\n'.join(records))
</code></pre>
<p>Can I put
    records = p.map(parse, skus, web_links)</p>
<p>because is not working</p>
<p>My desirable output format
would be </p>
<pre><code>sku    price    availability
bkk11  10,00    available
</code></pre>
<p>how can I achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<h1>minor refactor</h1>
<p>I recommend naming your pair of functions <code>def get_skus()</code> and <code>def get_urls()</code>, to match your problem definition.</p>
<h1>data structure</h1>
<p>Having a pair of lists, <code>skus</code> and <code>urls</code>, does not seem like a good fit for your high level problem.
Keep them together, as a list of (<code>sku</code>, <code>url</code>) tuples, or as a <code>sku_to_url</code> dict.
That is, delete one of your two functions, so you're reading the CSV once, and keeping the related details together.
Then your <code>parse()</code> routine would have more information available to it.
The list of tuples boils down to Monty's <code>starmap()</code> suggestion.</p>
<h1>writing results</h1>
<p>You're using this:</p>
<pre><code>    if len(records) &gt; 0:
        with open('output_websupplies.csv', 'a') as f:
            f.write('\n'.join(records))
</code></pre>
<p>Firstly, testing for at least one record is probably superfluous, it's not the end of the world to open for append and then write zero records.
If you care about the timestamp on the file then perhaps it's a useful optimization.</p>
<p>More importantly, the <code>write()</code> seems Bad.
One day an unfortunate character may creep into one of your records.
Much better to feed your structured records to a <a href="https://docs.python.org/3/library/csv.html#csv.writer" rel="nofollow noreferrer"><code>csv.writer</code></a>, to ensure appropriate quoting.</p>
</div>
<span class="comment-copy">Would this help your use case? <a href="https://stackoverflow.com/questions/5442910/python-multiprocessing-pool-map-for-multiple-arguments" title="python multiprocessing pool map for multiple arguments">stackoverflow.com/questions/5442910/…</a> <a href="https://docs.python.org/dev/library/multiprocessing.html#multiprocessing.pool.Pool.starmap" rel="nofollow noreferrer">docs.python.org/dev/library/…</a></span>
<span class="comment-copy">What does the original CSV look like?</span>
