<div class="post-text" itemprop="text">
<p>I want to make my code run faster for more iterations and runs. Right now my code is too slow, but I don't know what to change to speed it up. 
I began by coding a kinetic Monte Carlo simulation, then editing it to become a Brownian motion simulation. My current code can't handle 10,000 runs with 10,000 iteration each, which is needed.</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import time
%matplotlib inline

runs = int(input("Enter number of runs: "))
N = int(input("Enter number of iterations per simulation: "))

y = 0
R = 10*1  # R is the rate value
t0 = time.time()
for y in range(runs):  # Run the simulation 'runs' times
    T = np.array([0])
    dt = 0
    x = 0.5  # sets values 
    X = np.array([x])
    t = 0
    i = 0

    while t &lt; N:  # N is the number of iterations per run
        i = i + 1  # i is number of iterations so far
        z = np.random.uniform(-1, 1, 1)  # sets z to be a random number between -1 to 1 size 1

        if z &gt; (1/3):  # if conditions for z for alpha and gamma, beta 
            x = x + 1  # z[]=alpha state then + 1
        elif z &lt; (-1/3):
            x = x-1  # z[]=gamma state then - 1
        elif z &lt; (1/3) and z &gt; (-1/3):
            x = x  # z=beta state then + 0

        X = np.append(X, x)  # adds new X value to original X array
        X[i] += X[i-1] * 0.01 * np.random.normal(0, 1, 1) * np.sqrt(dt)  # for Brownian motion with sigma as 0.01
        Z = np.random.uniform(0, 1)  # sets Z to be a random number between 0 and 1
        dt = 1/R * np.log(1/Z)  # formula for dt; R is the rate value
        t = t + dt  # ITERATED TIME
        T = np.append(T, t)
        plt.plot(T, X, lw='0.5', alpha=0.5)

t1 = time.time()
print("final %.10f seconds " % (t1-t0))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://datascienceplus.com/how-to-apply-monte-carlo-simulation-to-forecast-stock-prices-using-python/" rel="nofollow noreferrer">Here is an excellent example</a> of a fast-running Brownian Motion Monte Carlo Simulation which is less computationally-expensive.</p>
<p>I've done the same thing as you in the past and made each step of each iteration take place within nested loops. Perhaps its the cost of context switching, running through different libraries, or simply running out of memory, but running each step of the code in each iteration definitely brought about slower performance and higher memory use. </p>
<p>In the above example the author <strong>creates arrays first</strong> and <em>then</em> iterates through them accordingly with a single for loop. All the random numbers are generated and placed into an array at the same time. Then all the Brownian Motion returns are calculated at the same time. etc. (Think of an assembly line - utilizing resources very well on each step and attaining economies of scale.) Critically also, take note that the plt function is run only one time (not within the loop) and only after all the iterations are complete. </p>
<p>This method should allow for a much higher number of iterations on much smaller hardware. </p>
</div>
<span class="comment-copy">Please edit your code (indentations mostly) to make sure we interpret it correctly</span>
<span class="comment-copy">Note: it’d help if you switched to descriptive variable names. Anyway, does <code>plt.plot</code> need to be in the inner loop? Seems like it could go after. Also, <code>T</code> doesn’t look like it needs to be an <code>np.array</code>, so keep <code>T = []</code> and use <code>T.append(t)</code>. Another thing is it looks like NumPy is being used on single elements for the most part which is not what it’s fast at; you may as well use the standard library.</span>
<span class="comment-copy">Strive to vectorize your code. Instead of e.g. 10,000 runs of single-valued simulations (your <code>z</code> is a single number), have a vector of 10,000 simulations.</span>
<span class="comment-copy">@Ry it is in the inner loop to plot multiple graphs on to the same plot, as I will need to show that mean of the plots as we increase the runs the mean should approach 0.</span>
<span class="comment-copy">@pythonnewbie22: It looks like you’re plotting the same plot over itself with one new item each time though. Seems like it should be in the outer loop, after the inner loop.</span>
