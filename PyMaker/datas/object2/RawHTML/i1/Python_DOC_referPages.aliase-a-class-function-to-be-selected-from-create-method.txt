<div class="post-text" itemprop="text">
<p>Given I have a class such as:</p>
<pre><code>class Model(object):
    def __init__(self, foo = 'bar'):
        if foo == 'bar':
            self.f = self._sse
        else:
            self.f = None

    def _sse():
        pass
</code></pre>
<p>Is there a way I can create an alias so I do not have to check what's the value of the non-positional argument <code>foo</code>? Something like</p>
<pre><code>class Model(object):
    alias = {'bar': _sse}
    def __init__(self, foo = 'bar'):
        self.f = foo

    def _sse():
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Technical answer: you can do it by defining the target function <em>before</em> the initializer, referencing this function as the default argument (Python functions are objects too), and manually invoking the descriptor protocol on the target function:</p>
<pre><code>&gt;&gt;&gt; class Model(object):
...     def _sse(self):
...         print("in self._sse")
...     def __init__(self, foo=_sse):
...         self.f = foo.__get__(self, type(self))
... 
&gt;&gt;&gt; m = Model()
&gt;&gt;&gt; m.f()
in self._sse
</code></pre>
<p>Just note that with this solution, if you want to pass another function, this function has to take <code>self</code> as first argument :</p>
<pre><code>&gt;&gt;&gt; # doesn't work
... def bar(): print("bar")
... 
&gt;&gt;&gt; m2 = Model(bar)
&gt;&gt;&gt; m2.f()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bar() takes no arguments (1 given)
&gt;&gt;&gt; # works:
... def baaz(self): print("baaz({})".format(self))
... 
&gt;&gt;&gt; m3 = Model(baaz)
&gt;&gt;&gt; m3.f()
baaz(&lt;__main__.Model object at 0x7fc3e2337090&gt;)
</code></pre>
<p>Now from a readability POV this is barely an improvement IMHO... </p>
<p>EDIT: as Aran-Fey mentions, this doesn't exactly answer the question so for a more "literal" version (and that doesn't require special definitions ordering etc):</p>
<pre><code>class Model(object):
    def _sse(self):
        print("in self._sse")

    alias = {"bar": "_sse"}

    def __init__(self, foo="bar"):
        self.f = getattr(self, self.alias.get(foo, "___"), None)
</code></pre>
<p>But this is still not improving readability... </p>
</div>
<div class="post-text" itemprop="text">
<p>Using @KlausD. suggestion and including <code>alias</code> in the <code>__init__</code> method does the trick for me.</p>
<pre><code>class Model(object):
    def __init__(self, foo = 'bar'):
        alias = {'bar': self._sse,
                 'bar2': self._sse2}

        self.f = alias.get(foo)

    def _sse(self):
        print('in sse')
    def _sse2(self):
        print('in sse2')


m = Model(foo='bar')
m.f() # in sse
m = Model(foo='bar2')
m.f() # in sse2
</code></pre>
</div>
<span class="comment-copy"><code>self.f = alias.get(foo)</code> but make sure the namespaces match, you might have to create the dict inside the <code>__init__</code>.</span>
<span class="comment-copy">If you only have 1 alias, then using an <code>if</code> is a sensible solution and anything else would be over-engineered. If you have many aliases, see <a href="//stackoverflow.com/q/60208">Replacements for switch statement in Python?</a></span>
<span class="comment-copy">It's more than 1 alias, this was just a minimal example.</span>
<span class="comment-copy">@b-fg would you edit your question to give more context and actually explain the problem you're trying to solve with this "solution" ? Looks like a possible XY problem to me and there might be better ways.</span>
<span class="comment-copy">I have used @KlausD. suggestion an included <code>alias</code> in the <code>__init__</code> method. Please see my suggested solution.</span>
<span class="comment-copy">I don't see how this answers the question. You didn't implement an alias for the <code>_sse</code> method, which is what was asked.</span>
<span class="comment-copy">@Aran-Fey I indeed answered based on what I thought the OP really wanted instead of what he explicitely asked - cf my edited answer for a more literal solution.</span>
<span class="comment-copy">@brunodesthuilliers: In your first solution, what would happen if, in <code>__init__()</code>, <code>foo</code> were to be directly assigned to <code>self.f</code>? (As in <code>self.f = foo</code>)</span>
<span class="comment-copy">@fountainhead then you couldn't call <code>self.f()</code> directly, you'd have to use <code>self.f(self)</code>. You can read this for more in-depth informations: <a href="https://wiki.python.org/moin/FromFunctionToMethod" rel="nofollow noreferrer">wiki.python.org/moin/FromFunctionToMethod</a> (caveat: it's not up to date wrt/ some python3 changes, but the core principle is still the same)</span>
<span class="comment-copy">Ok. <code>Model.f</code> is not the same as <code>self.f</code>, and the result is indeed totally different, <i>as explained in the link I posted in a previous comment</i>.  Note that the differences between setting <code>Model.f</code> and <code>self.f</code> are not restricted to what <code>self.f</code> evals to, it also changes the definition of <code>f</code> for ALL instances of <code>Model</code> - which is certainly not what the OP wants.</span>
