<div class="post-text" itemprop="text">
<p>I am trying to bit masking and discard the LSB of my data[], a numpy.ndarray containing int16. data = [2,0,4,......,-2,-4]
So I create a new array and by bit masking with -2, which should be 1111111111111110 in terms of 16-bit binary.</p>
<pre><code>data_new = np.zeros(len(data))
for i in range(len(data)):
    data_new[i] = np.int16(data[i] &amp; -2) 
</code></pre>
<p>Somehow, the output is not array of int16. It becomes numpy.float64. And python doesn't allow me to do a bitwise OR to rewrite the LSB.</p>
<pre><code>TypeError: unsupported operand type(s) for |: 'numpy.float64' and 'int'
&gt;&gt;type(data[0])
numpy.int16
&gt;&gt;type(data_new[0])
numpy.float64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>dtype</code> of the array returned by <code>numpy.zeros</code> defaults to <code>float64</code>. If you want a different type, either explicitly pass the <code>dtype</code>, e.g.:</p>
<pre><code>data_new = np.zeros(len(data), np.int16)
</code></pre>
<p>or if <code>data</code> was already the right size and <code>dtype</code>, use <code>np.zeros_like</code> to copy its format and structure:</p>
<pre><code>data_new = np.zeros_like(data)
</code></pre>
<p>Mind you, in this particular case, the correct solution is likely to just let <code>numpy</code> do the masking and new array creation in bulk, implicitly, by replacing your creation of the array and loop to populate it with just:</p>
<pre><code>data_new = data &amp; -2
</code></pre>
<p>which will run <em>much</em> faster, and "just work" (it will have the same size and <code>dtype</code> as <code>data</code> automatically).</p>
</div>
<span class="comment-copy">Thanks !!! You really save my life here. I didn't know that numpy.zeros defaults to float64. And are you suggesting that I can directly run data_new = data &amp; -2 without declaring data_new and initialize it as 0 at first?</span>
<span class="comment-copy">WOW. I just tried data_new = data &amp; -2 and it is so much faster !.</span>
<span class="comment-copy">Do you know if I can do bit wise OR based on this data_new ? If my data_new is [0,1,1,..] and in binary it is [0000, 0001, 0001]. And I want to OR with 1 (0001), can I simply do data_new | 1 ?</span>
<span class="comment-copy">@Iloveece: I think you should be using <code>np.bitwise_or()</code> and <code>np.bitwise_and()</code> to perform bit-wise operations element-wise</span>
<span class="comment-copy">@fountainhead: Plain <code>|</code> works fine; <code>data | 1</code> (or to modify in place, <code>data |= 1</code>) will set the low bit of every element.  The named functions are fine, but completely unnecessary unless you need to customize the destination, change the <code>dtype</code> as you go, etc. For basic bitwise OR-ing, <code>|</code> is more straightforward.</span>
