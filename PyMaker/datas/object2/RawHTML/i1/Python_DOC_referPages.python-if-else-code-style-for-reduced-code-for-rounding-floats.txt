<div class="post-text" itemprop="text">
<p>Is there any shorter, more legible code style to solve this problem?
I am trying to classify some float values into interregional folders.</p>
<pre><code>def classify(value):   
    if value &lt; -0.85 and value &gt;= -0.95:
        ts_folder = r'\-0.9'
    elif value &lt; -0.75 and value &gt;= -0.85:
        ts_folder = r'\-0.8'
    elif value &lt; -0.65 and value &gt;= -0.75:
        ts_folder = r'\-0.7'    
    elif value &lt; -0.55 and value &gt;= -0.65:
        ts_folder = r'\-0.6'   
    elif value &lt; -0.45 and value &gt;= -0.55:
        ts_folder = r'\-0.5'  
    elif value &lt; -0.35 and value &gt;= -0.45:
        ts_folder = r'\-0.4'
    elif value &lt; -0.25 and value &gt;= -0.35:
        ts_folder = r'\-0.3'
    elif value &lt; -0.15 and value &gt;= -0.25:
        ts_folder = r'\-0.2'
    elif value &lt; -0.05 and value &gt;= -0.15:
        ts_folder = r'\-0.1'
    elif value &lt; 0.05 and value &gt;= -0.05:
        ts_folder = r'\0.0'
    elif value &lt; 0.15 and value &gt;= 0.05:
        ts_folder = r'\0.1'
    elif value &lt; 0.25 and value &gt;= 0.15:
        ts_folder = r'\0.2'
    elif value &lt; 0.35 and value &gt;= 0.25:
        ts_folder = r'\0.3'
    elif value &lt; 0.45 and value &gt;= 0.35:
        ts_folder = r'\0.4'
    elif value &lt; 0.55 and value &gt;= 0.45:
        ts_folder = r'\0.5'
    elif value &lt; 0.65 and value &gt;= 0.55:
        ts_folder = r'\0.6'
    elif value &lt; 0.75 and value &gt;= 0.65:
        ts_folder = r'\0.7'  
    elif value &lt; 0.85 and value &gt;= 0.75:
        ts_folder = r'\0.8'
    elif value &lt; 0.95 and value &gt;= 0.85:
        ts_folder = r'\0.9'

    return ts_folder
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Specific solution</h1>
<p>There is no real general solution, but in your case you can use the following expression.</p>
<pre><code>ts_folder = r'\{:.1f}'.format(round(value, 1))
</code></pre>
<h1>General solution</h1>
<p>If you actually need some kind of generalization, notice that any non-linear pattern will cause trouble. Although, there is a way to shorten the code.</p>
<pre><code>def classify(key, intervals):
    for lo, hi, value in intervals:
        if lo &lt;= key &lt; hi:
            return value
    else:
        ... # return a default value or None

# A list of tuples (lo, hi, key) which associates any value in the lo to hi interval to key
intervals = [
    (value / 10 - 0.05, value / 10 + 0.05, r'\{:.1f}'.format(value / 10))
    for value in range(-9, 10)
]

value = -0.73

ts_folder = classify(value, intervals) # r'\-0.7'
</code></pre>
<p>Notice that the above is still not totally safe from some <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">float rounding error</a>. You can add precision by manually typing down the <code>intervals</code> list instead of using a comprehension.</p>
<h1>Continuous intervals</h1>
<p>If the intervals in your data are continuous, that is there is no gap between them, as in your example, then we can use some optimizations. Namely, we can store only the higher bound of each interval in the list. Then by keeping those sorted, we can use <a href="https://docs.python.org/3/library/bisect.html" rel="noreferrer"><code>bisect</code></a> for efficient lookup.</p>
<pre><code>import bisect

def value_from_hi(hi):
    return r'\{:.1f}'.format(hi - 0.05)

def classify(key, boundaries):
    i = bisect.bisect_right(boundaries, key)
    if i &lt; len(boundaries):
        return value_from_hi(boundaries[i])
    else:
        ... # return some default value

# Sorted upper bounds
boundaries = [-0.85, -0.75, -0.65, -0.55, -0.45, -0.35, -0.25, -0.15, -0.05,
              0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95]

ts_folder = classify(-0.32, boundaries) # r'\-0.3'
</code></pre>
<p><strong>Important note</strong>: the choice of using the higher bounds and <code>bisect_right</code> is due to the fact the higher bounds are excluded in your example. If the lower bounds were excluded, then we would have to use those with <code>bisect_left</code>.</p>
<p>Also note that you may want to treat numbers out of the range [-0.95, 0.95[ in some special way and note just leave those to <code>bisect</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The bisect module will do exactly the right lookup for finding the right bin from a list of breakpoints.  In fact, the example in the <a href="https://docs.python.org/3.0/library/bisect.html" rel="noreferrer">documentation</a> is exactly a case like this:</p>
<blockquote>
<p>The bisect() function is generally useful for categorizing numeric data. This example uses bisect() to look up a letter grade for an exam total (say) based on a set of ordered numeric breakpoints: 85 and up is an ‘A’, 75..84 is a ‘B’, etc.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; grades = "FEDCBA"
&gt;&gt;&gt; breakpoints = [30, 44, 66, 75, 85]
&gt;&gt;&gt; from bisect import bisect
&gt;&gt;&gt; def grade(total):
...           return grades[bisect(breakpoints, total)]
&gt;&gt;&gt; grade(66)
'C'
&gt;&gt;&gt; map(grade, [33, 99, 77, 44, 12, 88])
['E', 'A', 'B', 'D', 'F', 'A']
</code></pre>
<p>Instead of a string for the value lookups, you'd want a list of strings for the exact folder names you need for each range of values.  For example:</p>
<pre><code>breakpoints = [-0.85, -0.75, -0.65]
folders = [r'\-0.9', r'\-0.8', r'\-0.7']
foldername = folders[bisect(breakpoints, -0.72)]
</code></pre>
<p>If you can automate even part of this table generation (using <code>round()</code>, or something similar), of course you should.</p>
</div>
<div class="post-text" itemprop="text">
<p>One of the first rules with a block of code like this, is to always make the comparisons be in the same direction.  So instead of </p>
<pre><code>    elif value &lt; -0.75 and value &gt;= -0.85:
</code></pre>
<p>write</p>
<pre><code>    elif -0.85 &lt;= value and value &lt; -0.75:
</code></pre>
<p>At this point you can observe that python allows chaining of comparisons, so you can write:</p>
<pre><code>    elif -0.85 &lt;= value &lt; -0.75:
</code></pre>
<p>Which is an improvement itself.  Alternatively, you can observe this is an ordered list of comparisons, so if you add in an initial comparisons, you can just write</p>
<pre><code>    if value &lt; -0.95:        ts_folder = ''
    elif value &lt; -0.85:      ts_folder = r'\-0.9'
    elif value &lt; -0.75:      ts_folder = r'\-0.8'
    elif value &lt; -0.65:      ts_folder = r'\-0.7'    
    elif value &lt; -0.55:      ts_folder = r'\-0.6'   
    elif value &lt; -0.45:      ts_folder = r'\-0.5'  
    elif value &lt; -0.35:      ts_folder = r'\-0.4'
    elif value &lt; -0.25:      ts_folder = r'\-0.3'
    elif value &lt; -0.15:      ts_folder = r'\-0.2'
    elif value &lt; -0.05:      ts_folder = r'\-0.1'
    elif value &lt; 0.05:       ts_folder = r'\0.0'
    elif value &lt; 0.15:       ts_folder = r'\0.1'
    elif value &lt; 0.25:       ts_folder = r'\0.2'
    elif value &lt; 0.35:       ts_folder = r'\0.3'
    elif value &lt; 0.45:       ts_folder = r'\0.4'
    elif value &lt; 0.55:       ts_folder = r'\0.5'
    elif value &lt; 0.65:       ts_folder = r'\0.6'
    elif value &lt; 0.75:       ts_folder = r'\0.7'  
    elif value &lt; 0.85:       ts_folder = r'\0.8'
    elif value &lt; 0.95:       ts_folder = r'\0.9'
    else:                    ts_folder = ''
</code></pre>
<p>That's still quite long, but a) it's a lot more readable; b) it has explicit code to handle <code>value &lt; -0.95 or 0.95 &lt;= value</code></p>
</div>
<div class="post-text" itemprop="text">
<p>All answers revolve around rounding, which seems to be fine in this case, but just for the sake of argument I'd like to also point out a cool python use of dictionaries which is often described as an alternative to other languages switch(es) and that in turn allow for arbitrary values.</p>
<pre><code>ranges = {
    (-0.85, -0.95): r'\-0.9',
    (-0.75, -0.85): r'\-0.8',
    (-0.65, -0.75): r'\-0.7',
    (-0.55, -0.65): r'\-0.6'
    ...
}

def classify (value):
    for (ceiling, floor), rounded_value in ranges.items():
        if floor &lt;= value &lt; ceiling:
            return rounded_value
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; classify(-0.78)
\-0.8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>round()</code> built-in :</p>
<pre><code>ts_folder = "\\" + str(round(value + 1e-16, 1)) # To round values like .05 to .1, not .0
if ts_folder == r"\-0.0": ts_folder = r"\0.0" 
</code></pre>
<p><a href="https://www.w3schools.com/python/ref_func_round.asp" rel="nofollow noreferrer">More on <code>round()</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Actually in Python 3 <code>.85</code> will be round to <code>.8</code>. As per the question <code>.85</code> should be round to <code>.9</code>.</p>
<p>Can you try the following:</p>
<pre><code>round2 = lambda x, y=None: round(x+1e-15, y)
ts_folder = r'\{}'.format(str(round2(value, 1)))
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; round2(.85, 1)
0.9
&gt;&gt;&gt; round2(-.85, 1)
-0.8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about turning it into a loop?</p>
<pre><code>def classify(value):
    i = -5
    while i &lt; 95:
        if value &lt; (i + 10) / 100.0 and value &gt;= i / 100.0:
            return '\\' + repr((i + 5) / 100.0)
        i += 10
</code></pre>
<p>it's not efficient by any means, but it's equivalent to what you have, just shorter.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from decimal import Decimal

def classify(value):
    number = Decimal(value)
    result = "%.2f" % (number)
    return Decimal(round(float(result), 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need the <code>and value &gt;= -.85</code> in <code>elif value &lt; -0.75 and value &gt;= -0.85:</code>; if the value isn't greater than or equal to -.85, then you won't reach the elif. You can also just turn all the <code>elif</code>s into <code>if</code> by having each one return immediately.</p>
<p>In this case, since you have the boundaries at regular intervals, you can just round (in the general case of regular intervals, you may have to divide and then round, for instance if the intervals are at every three units, then you would divide the number by three and round). In the general case, it's faster to store the boundaries in a tree structure, and then do a binary search for where the item goes. </p>
<p>Doing a binary search explicitly would be something like this:</p>
<pre><code>def classify(value):   
    if value &lt; -.05:
        if value &lt; -.45:
            if value &lt; -.65:
                if value &lt; -.85:
                    if value &lt; -.95:
                        return None
                    return r'\-0.9'
                if value &lt; -.75:
                    return r'\-0.8'
                return r'\-0.7'
    ...
</code></pre>
<p>Although this code is harder to read than yours, it runs in time logarithmic rather than linear with respect to the number of boundaries.</p>
<p>If the number of items is significantly larger than the number of boundaries, it would probably be faster to actually create a tree of the items, and insert the boundaries.</p>
<p>You could also create a list, sort it, and then look at the index. For instance, compare <code>(sorted([(_-9.5)/10  for _ in range(20)]+[x]).index(x)-9)/10</code> to your function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at the <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer"><code>round()</code></a> function in python. Maybe you can work it out without the if.</p>
<p>With this function you can specify the number of digits you need to keep.
For example :</p>
<pre><code>x = round(5.76543, 2)
print(x)
</code></pre>
<p>That code will print 5.77</p>
</div>
<div class="post-text" itemprop="text">
<p>Many of these answers suggest some kind of rounding as a solution. Unfortunately, there are three problems with using rounding for this purpose, and at the time of writing all of them fell prey to at least one.</p>
<ul>
<li>Floating point representation of decimal values is inexact. For example, the float <code>0.85</code> is in fact <code>0.8499999999999999777955395...</code>. </li>
<li>round() uses ties-round-to-even, also known as scientific or banker's rounding, rather than the arithmetic rounding many of us learned in school. This means e.g. 0.85 rounds to 0.8 instead of 0.9, and 0.25 rounds to 0.2 instead of 0.3.</li>
<li>very small negative floats (and Decimals) round up to <code>-0.0</code> rather than <code>0.0</code> as the OP's mapping requires.</li>
</ul>
<p>These can all be solved using the Decimal module, though not as prettily as I'd like:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_DOWN

def classify(value):
    number = Decimal('{:.2f}'.format(value))

    if number &lt; 0:
        round_method = ROUND_HALF_DOWN
    else:
        round_method = ROUND_HALF_UP
    rounded_number = number.quantize(Decimal('0.1'), rounding=round_method)

    if rounded_number == 0.0:
        rounded_number = Decimal('0.0')
    return r'\{}'.format(rounded_number)
</code></pre>
<p>Both ROUND_HALF_DOWN and ROUND_HALF_UP are required as ROUND_HALF_UP actually rounds <em>away from zero</em> rather than towards Infinity. <code>.quantize</code> rounds a Decimal value to the places given by the first argument, and allows us to specify a rounding method.</p>
<h3>Bonus: Bisect Breakpoints using range()</h3>
<p>For the bisect solutions, this will generate the breakpoints used by the OP:</p>
<pre><code>from decimal import Decimal
breakpoints = [Decimal('{}e-2'.format(e)) for e in range(-85, 96, 10)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try something like this, if you don't like loops:</p>
<pre><code>def classify(value): 
    endpts = [-0.95, -0.85,    -0.75,    -0.65,    -0.55,    -0.45,    -0.35,    -0.25,    -0.15,    -0.05,    0.05,    0.15,    0.25,    0.35,    0.45,    0.55,    0.65,    0.75,    0.85,    0.95] 
    ts_folder = [ r'\-0.9', r'\-0.8', r'\-0.7', r'\-0.6', r'\-0.5', r'\-0.4', r'\-0.3', r'\-0.2', r'\-0.1', r'\0.0', r'\0.1', r'\0.2', r'\0.3', r'\0.4', r'\0.5', r'\0.6', r'\0.7', r'\0.8', r'\0.9'] 
    idx = [value &gt;= end for end in endpts].index(False) 
    if not idx:
        raise ValueError('Value outside of range')
    return ts_folder[idx-1] 
</code></pre>
<p>Of course, the loop is just "hidden" in the list comprehension.
Obviously, in this example, it would be better to generate <code>endpts</code> and <code>ts_fol</code> programmatically rather than writing them all out, but you indicated that in the real situation the endpoints and values aren't so straightforward.</p>
<p>This raises a <code>ValueError</code> if <code>value</code> ≥ 0.95 (because <code>False</code> is not found in the list comprehension) or if <code>value</code> &lt; -0.95 (because then <code>idx</code> is 0); the original version raises a <code>UnboundLocalError</code> in these cases.</p>
<p>You could also save three lines and skip a few comparisons by doing this:</p>
<pre><code>def classify(value):
    endpts = [-0.95,    -0.85,    -0.75,    -0.65,    -0.55,    -0.45,    -0.35,    -0.25,    -0.15,    -0.05,    0.05,    0.15,    0.25,    0.35,    0.45,    0.55,    0.65,    0.75,    0.85,    0.95]
    ts_fol = [ None, r'\-0.9', r'\-0.8', r'\-0.7', r'\-0.6', r'\-0.5', r'\-0.4', r'\-0.3', r'\-0.2', r'\-0.1', r'\0.0', r'\0.1', r'\0.2', r'\0.3', r'\0.4', r'\0.5', r'\0.6', r'\0.7', r'\0.8', r'\0.9']
    return next((ts for ts, end in zip(ts_fol, endpts) if value &lt; end), None)
</code></pre>
<p>This version returns <code>None</code> rather than raising exceptions for any value outside the bounds.</p>
</div>
<span class="comment-copy">That's an example. In my experiment, diffence isn't always 0.5. round() is a good way in this case but not always work for me</span>
<span class="comment-copy">I think this is a case by case though. Think of whenever the pattern is not linear by example.</span>
<span class="comment-copy">At the very least, use chained comparisons: <code>-0.95 &lt;= value &lt; -0.85</code> instead of `value &lt; -0.85 and value &gt;= -0.95</span>
<span class="comment-copy">@Kuang鄺世銘 You might want to check out <a href="https://en.wikipedia.org/wiki/Python_(programming_language)#Features_and_philosophy" rel="nofollow noreferrer">Python's Philosophy</a> and <a href="https://www.youtube.com/watch?v=oVp1vrfL_w4&amp;list=PLQVvvaa0QuDe8XSftW-RAxdo6OmaeL85M" rel="nofollow noreferrer">Sentdex's Python3 Playlist</a>.</span>
<span class="comment-copy">It's a great way to hide bugs! <code>ts_folder</code> is undefined for values larger than <code>0.95</code> or smaller than <code>-0.85</code>. Also, the result for <code>-0.45</code> and <code>-0.35</code> differ by <code>0.2</code>.</span>
<span class="comment-copy">Note that the OP had <code>if lo &lt;=key &lt; hi</code>.</span>
<span class="comment-copy">If the intervals are supposed to be contiguous, you can require that they are supplied sorted (low to high), and then just have the intervals be (hi, value), and then the loop becomes <code>for hi, value in intervals: if key &lt; hi: return value</code></span>
<span class="comment-copy">Floats comparison are tricky. On my computer, your specific solution returns different values for <code>[-0.75, -0.65, -0.55, -0.45, -0.05, -0.04, -0.03, -0.02, -0.01, 0.15, 0.25, 0.35, 0.85]</code> compared to OP's code.</span>
<span class="comment-copy">Assuming the intervals partition a range, binary search with the <code>bisect</code> module would be a good option.</span>
<span class="comment-copy">This kind of formatting style makes me so ... sad ¯\_(ツ)_/¯</span>
<span class="comment-copy">In this case you're NOT using the "dict dispatch" trick - you're doing a sequential scan, so you'd get the exact same result with a list of <code>(start, stop, val)</code> tuples (but with the added overhead of creating a dict and doing a useless <code>__getitem__</code> access).</span>
<span class="comment-copy">@chepner By editing this code you have made it not work; it indexes into <code>ranges</code> with <code>current_value</code> which is not defined (because you deleted it).</span>
<span class="comment-copy">@brunodesthuilliers: I would argue the dict is not useless; the code is much more readable, and easy to modify. Sure, it's not <i>efficient</i> (O(n)), but n is small and it may be the right choice in some cases.</span>
<span class="comment-copy">@brunodesthuilliers I never said anything about "dict as dispatch table"; I think you confuse me with the author of this answer. I just stumbled across this question and answer and found the answer could not work, and looking into it more found the original answer did work but an editor had broken it while "improving" it. It has since been fixed. Still, if someone considers an answer substantially lacking, I think it makes more sense to post a new one than to totally rewrite the answer in an edit.</span>
<span class="comment-copy">@ArthurTacca oops, sorry, there was some confusion indeed (actually with not only the author but also with danuker). I cannot edit my comment anymore so I'll delete and repost an edited version.</span>
<span class="comment-copy">It doesn't seem to work for <code>[-0.85, -0.75, -0.65, -0.55, -0.45, -0.35, -0.25, -0.15, -0.05, -0.04, -0.03, -0.02, -0.01, 0.0]</code>, compared to OP's code. I'm not sure if it's a bug or a feature.</span>
<span class="comment-copy">Still have an issue with <code>[-0.05, -0.04, -0.03, -0.02, -0.01]</code>, as they get rounded to -0.0 instead of 0.0 as in the OP.</span>
<span class="comment-copy">Gosh I forgot that, thanks @Wlerin</span>
<span class="comment-copy">I suspect you meant to include a <code>*10</code> inside the round() call as well, but unfortunately this just changes the problem from negative zero to banker's rounding. Perhaps the simplest solution is to round the value using your original method, then check if it's equal to <code>0</code> (because <code>-0.0 == 0.0</code>) and if so set it to 0.</span>
<span class="comment-copy">As Wlerin said under my post : <code>-.05</code>, <code>-.04</code>, <code>-.03</code> etc will alas be transformed to <code>\-0.0</code>, and not <code>\0.0</code></span>
<span class="comment-copy">You need to start at ` i = -95`, though.</span>
<span class="comment-copy">using Decimal is a good idea, but this definitely doesn't work as is.</span>
<span class="comment-copy">Please try and answer with a clear example</span>
