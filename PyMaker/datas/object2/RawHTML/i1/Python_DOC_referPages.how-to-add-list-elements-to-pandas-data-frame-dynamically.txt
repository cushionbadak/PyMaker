<div class="post-text" itemprop="text">
<p>I have a dataframe with some columns like this:</p>
<pre><code>A   B   C  
0   
4
5
6
7
7
6
5
</code></pre>
<p>The <em>possible range of values in A are only from 0 to 7</em>. </p>
<p>Also, I have a list of 8 elements like this:</p>
<pre><code>List=[2,5,6,8,12,16,26,32]  //There are only 8 elements in this list
</code></pre>
<p>If the element in column A is <em>n</em>, I need to insert the <em>n</em> th element from the List in a new column, say 'D'.</p>
<p>How can I do this in one go without looping over the whole dataframe? </p>
<p>The resulting dataframe would look like this:</p>
<pre><code>A   B   C   D
0           2
4           12
5           16
6           26
7           32
7           32
6           26
5           16
</code></pre>
<p>Note: The dataframe is huge and iteration is the last option option. But I can also arrange the elements in 'List' in any other data structure like dict if necessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>IIUC, if you make your (unfortunately named) <code>List</code> into an <code>ndarray</code>, you can simply index into it naturally.</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; m = np.arange(16)*10
&gt;&gt;&gt; m[df.A]
array([  0,  40,  50,  60, 150, 150, 140, 130])
&gt;&gt;&gt; df["D"] = m[df.A]
&gt;&gt;&gt; df
    A   B   C    D
0   0 NaN NaN    0
1   4 NaN NaN   40
2   5 NaN NaN   50
3   6 NaN NaN   60
4  15 NaN NaN  150
5  15 NaN NaN  150
6  14 NaN NaN  140
7  13 NaN NaN  130
</code></pre>
<p>Here I built a new <code>m</code>, but if you use <code>m = np.asarray(List)</code>, the same thing should work: the values in <code>df.A</code> will pick out the appropriate elements of <code>m</code>.</p>
<hr/>
<p>Note that if you're using an old version of <code>numpy</code>, you might have to use <code>m[df.A.values]</code> instead-- in the past, <code>numpy</code> didn't play well with others, and some refactoring in <code>pandas</code> caused some headaches.  Things have improved now.</p>
</div>
<div class="post-text" itemprop="text">
<p>(For users who are just looking to know how to simply assign a list as a new column)   </p>
<p>Actually, a simpler method is to just assign the list directly:</p>
<pre><code>df['new_col'] = mylist
</code></pre>
<hr/>
<p><strong>Alternative</strong><br/>
Assign a Series:</p>
<pre><code>se = pd.Series(mylist)
</code></pre>
<p>You can even just assign the array</p>
<pre><code>df['new_col'] = se.values # np.array(mylist)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution improving on the great one from @sparrow.</p>
<p>Let <strong>df</strong>, be your dataset, and <strong>mylist</strong> the list with the values you want to add to the dataframe.</p>
<p>Let's suppose you want to call your new column simply, <strong>new_column</strong></p>
<p>First make the list into a Series:</p>
<pre><code>column_values = pd.Series(mylist)
</code></pre>
<p>Then use the <strong>insert</strong> function to add the column. This function has the advantage to let you choose in which position you want to place the column.
In the following example we will position the new column in the first position from left (by setting loc=0)</p>
<pre><code>df.insert(loc=0, column='new_column', value=column_values)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First let's create the dataframe you had, I'll ignore columns B and C as they are not relevant.</p>
<pre><code>df = pd.DataFrame({'A': [0, 4, 5, 6, 7, 7, 6,5]})
</code></pre>
<p>And the mapping that you desire:</p>
<pre><code>mapping = dict(enumerate([2,5,6,8,12,16,26,32]))

df['D'] = df['A'].map(mapping)
</code></pre>
<p><strong>Done!</strong></p>
<pre><code>print df
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>   A   D
0  0   2
1  4  12
2  5  16
3  6  26
4  7  32
5  7  32
6  6  26
7  5  16
</code></pre>
</div>
<span class="comment-copy">I think you needs a (smaller) toy example, with the desired result. It sounds a little vague atm.</span>
<span class="comment-copy">Hi @DSM. I get what you are saying but I am getting this error:  <code>Traceback (most recent call last):</code> <code>File "./b.py", line 24, in &lt;module&gt;</code> <code>d["D"] = m[d.A]</code> <code>IndexError: unsupported iterator index</code></span>
<span class="comment-copy">@mane: urf, that's an old <code>numpy</code> bug.  Does <code>d["D"] = m[d.A.values]</code> work for you?</span>
<span class="comment-copy">Awesome! ` d["D"] = m[d.A.values]` works!!!   Thanks a lot!</span>
<span class="comment-copy">you the real OG. This was super easy and exactly what I needed</span>
<span class="comment-copy">This is what exactly solve the problem.</span>
<span class="comment-copy"><code>pykernel_launcher.py:1: SettingWithCopyWarning:  A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead  See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy   """Entry point for launching an IPython kernel.</code></span>
<span class="comment-copy">@IlyaRusin, it's a false positive which can be ignored in this case. For more info: <a href="https://stackoverflow.com/questions/20625582/how-to-deal-with-settingwithcopywarning-in-pandas" title="how to deal with settingwithcopywarning in pandas">stackoverflow.com/questions/20625582/â€¦</a></span>
<span class="comment-copy">This can be simplified to: df['new_col'] = pd.Series(mylist).values</span>
<span class="comment-copy">This will not work if you changed your indexes of df to something other then 1,2,3... in that case you have to add between the lines: column_values.index=df.index</span>
<span class="comment-copy">I think the OP knows how to do this already.  By my reading the issue is constructing <code>D</code> from the elements of <code>A</code> and <code>List</code> ("If the element in column A is n, I need to insert the n th element from the List in a new column, say 'D'.")</span>
<span class="comment-copy">SO has turned into some kind of F(*&amp; nanny state.  Thanks to @DSM for the comment but I couldn't correct the post untill it was peer reviewed.  and then it was rejected because it was too fast.  and then I was able to peer review my own edit.  and then it's too late because a worse (IMHO) answer was "accepted".    SO is really got some meta-nanny's who are less than helpful!!!!</span>
<span class="comment-copy">Well, I can't speak for the nannies, but you'll find that your approach is about an order of magnitude slower on long arrays.  In other respects, of course, choosing between <code>np.array(List)[df.A]</code> and <code>df["A"].map(dict(enumerate(List)))</code> is mostly a matter of preference.</span>
<span class="comment-copy">Hi Phil, I only saw your solution and DSM's comment and then never got back to it since DSM's solution worked fine for me. But now looking at your solution, it works too. I have run DSM's solution on my dataset of about 200k entries and it runs in a couple of seconds with all the other calculations that I have.   I am totally new to python-pandas and personally was not looking for anything elegant or great; whatever worked was fine.   But honestly, thanks for the solution.</span>
