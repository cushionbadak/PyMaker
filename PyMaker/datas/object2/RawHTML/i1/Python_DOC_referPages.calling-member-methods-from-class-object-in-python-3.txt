<div class="post-text" itemprop="text">
<p>I have this bit of code:</p>
<pre><code>class ABC:
    def test():
        print('Hi there')

ABC.test()
</code></pre>
<p>Which outputs:</p>
<pre><code>Hi there
</code></pre>
<p>Whereas this fails:</p>
<pre><code>ABC().test()
TypeError: test() takes 0 positional arguments but 1 was given
# Makes sense
</code></pre>
<p>We know that when we invoke a <code>classmethod</code> like <code>&lt;classname&gt;.&lt;methodname&gt;()</code>, the class is implicitly passed as an argument to it, but <code>test</code> here takes no arguments.</p>
<p>Why don't we see a <code>TypeError</code> because of the unexpected argument? Isn't the class passed as an argument to <code>test</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Nothing is passed to <code>test()</code> because functions do not bind to anything when accessed to a class. It remains <em>unbound</em>, you get the original function:</p>
<pre><code>&gt;&gt;&gt; class ABC:
...     def test():
...         print('Hi there')
...
&gt;&gt;&gt; ABC.test
&lt;function ABC.test at 0x1082706c0&gt;
</code></pre>
<p>You can call functions directly, provided you pass in the right number of arguments. Here that is 0, so <code>ABC.test()</code> succeeds.</p>
<p>It is not a <code>classmethod</code>, that would require decorating it with <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>@classmethod</code></a> (or otherwise producing a <code>classmethod</code> object and storing it as an attribute of the class), at which point accessing the attribute binds the function to the class object, producing a bound <code>method</code>:</p>
<pre><code>&gt;&gt;&gt; class ABC:
...     @classmethod
...     def test():
...         print('Hi there')
...
&gt;&gt;&gt; ABC.test
&lt;bound method ABC.test of &lt;class '__main__.ABC'&gt;&gt;
</code></pre>
<p>Calling this results in an exception:</p>
<pre><code>&gt;&gt;&gt; ABC.test()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: test() takes 0 positional arguments but 1 was given
</code></pre>
<p>Functions can be bound too, but only when accessed on an instance of the class. Both <code>function</code> and <code>classmethod</code> objects implement the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, and accessing attributes on classes and on instances will trigger the <code>__get__</code> method on descriptors. But only <code>classmethod</code> objects return a bound method in that case, functions just return themselves.</p>
<p>Specifically, the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer">descriptor <code>__get__</code> method</a> is passed <code>None</code> for the first argument, the object to bind to, when the attribute access is on a class, and the instance when accessed on the instance. <code>classmethod().__get__()</code> ignores the instance argument and produces a method object that binds to the second argument (<code>owner</code>). Functions return <code>self</code> when the first argument is <code>None</code>, or a method object that binds to the instance otherwise:</p>
<pre><code>&gt;&gt;&gt; def foo(boundto='nothing'):
...     print(f'Bound to {boundto}')
...
&gt;&gt;&gt; foo.__get__('instance', 'owner')()
Bound to instance
&gt;&gt;&gt; foo.__get__(None, 'owner')()
Bound to nothing
&gt;&gt;&gt; classmethod(foo).__get__('instance', 'owner')()
Bound to owner
&gt;&gt;&gt; classmethod(foo).__get__(None, 'owner')()
Bound to owner
</code></pre>
</div>
<span class="comment-copy">You don't have a classmethod. You simply have a method that can only be used unbound.</span>
<span class="comment-copy">Since <code>def test()</code> is not <code>def test(self)</code> it does not take the class instance it was called from as an argument.  If you replace your test function with one that takes the self argument you should get the <code>TypeError</code> you expect</span>
<span class="comment-copy">But 1. Does Python 3 have unbound methods? 2. Why is the instance still passed to the function when it's called like <code>ABC().test()</code>?</span>
<span class="comment-copy">No, Python 3 does not have unbound methods. Functions just return themselves instead.</span>
<span class="comment-copy">I added an explanation as to how this works.</span>
