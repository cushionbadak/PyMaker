<div class="post-text" itemprop="text">
<p>I have this code which calculates the distance between two coordinates. The two functions are both within the same class.</p>
<p>However how do I call the function <code>distToPoint</code> in the function <code>isNear</code>?</p>
<pre><code>class Coordinates:
    def distToPoint(self, p):
        """
        Use pythagoras to find distance
        (a^2 = b^2 + c^2)
        """
        ...

    def isNear(self, p):
        distToPoint(self, p)
        ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since these are member functions, call it as a member function on the instance, <code>self</code>.</p>
<pre><code>def isNear(self, p):
    self.distToPoint(p)
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That doesn't work because <code>distToPoint</code> is inside your class, so you need to prefix it with the classname if you want to refer to it, like this: <code>classname.distToPoint(self, p)</code>. You shouldn't do it like that, though. A better way to do it is to refer to the method directly through the class instance (which is the first argument of a class method), like so: <code>self.distToPoint(p)</code>.</p>
</div>
<span class="comment-copy">try: self.distToPoint(p)</span>
<span class="comment-copy">What if isNear and distToPoint are taking different arguments. Then How can we call distToPoint which is inside the class? Anyone can explain that for me please.</span>
<span class="comment-copy">But be careful self.foo() will use the method resolution order which might resolve to a function in a different class.</span>
<span class="comment-copy">What happens if we dont use self? and directly call distToPoint(p)?</span>
<span class="comment-copy">@Marlon Abeykoon the "self" argument will be missing</span>
<span class="comment-copy">What if isNear and distToPoint are taking different arguments. Then How can we call distToPoint which is inside the class? Anyone can explain that for me please.</span>
<span class="comment-copy">@Aleski.  If it's a generic method (common to all instances and without any instance specific variables referenced in the method), could you please explain why one shouldn't use classname.distToPoint(self, p)?</span>
<span class="comment-copy">@Yugmorf: There's only one situation where one should use <code>classname.distToPoint(self, p)</code>: when you're defining a subclass that overrides <code>distToPoint</code>, but needs to call the original. If you tried to call <code>self.distToPoint(p)</code> like normal in that case, you'd end up calling the method that you're just defining, and get into an infinite recursion. If not inside a class, there's also only one situation where you'd use <code>classname.distToPoint(obj, p)</code> instead of <code>obj.distToPoint(p)</code>: if obj might be an instance of the subclass, but you need to call the original <code>distToPoint</code> defined <i>(continued)</i></span>
<span class="comment-copy">in <code>classname</code> instead of the overridden version in the subclass - but note that this is very hacky and shouldn't be done in general without a <i>very</i> good reason. Note that you break subtype polymorphism when you call a method explicitly through a class (in both of the examples above, you specifically <i>want</i> to do that). So in short: you should only call a method explicitly through a class when you <i>need</i> to circumvent subtype polymorphism for some [good] reason. If the method hasn't been overridden, the two ways are equal, but <code>self.distToPoint(p)</code> is shorter and more readable, <i>(continued)</i></span>
<span class="comment-copy">so you should definitely still use it. Now, getting to the specifics of your question: if your method doesn't use any instance variables, maybe it should be a classmethod instead? You make those by adding <code>@classmethod</code> before the method, and after that you won't get an instance (<code>self</code>) as the first argument anymore - instead you get the class, so you should name the first argument eg. <code>cls</code> instead. After that, you can call the classmethod either like <code>obj.distToPoint(p)</code> or <code>classname.distToPoint(p)</code> (note the lack of <code>obj</code>). You should <i>still</i> probably use <i>(continued)</i></span>
<span class="comment-copy"><code>obj.distToPoint(p)</code>, though, if you just have a relevant instance on your hands, unless - again - you have some [good] reason to circumvent subtype polymorphism, since the classmethod could've been overridden in a subclass too, in general. Of course, if you don't have a <i>relevant</i> instance available, you should by all means call a <i>classmethod</i> directly through a class.</span>
