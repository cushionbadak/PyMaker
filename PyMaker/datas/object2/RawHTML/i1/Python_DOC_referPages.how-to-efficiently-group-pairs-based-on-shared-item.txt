<div class="post-text" itemprop="text">
<p>I have a list of pairs (tuples), for simplification something like this:</p>
<pre><code>L = [("A","B"), ("B","C"), ("C","D"), ("E","F"), ("G","H"), ("H","I"), ("G","I"), ("G","J")]
</code></pre>
<p>Using python I want efficiently split this list to:</p>
<pre><code>L1 = [("A","B"), ("B","C"), ("C","D")]
L2 = [("E","F")]
L3 = [("G","H"), ("G","I"), ("G","J"), ("H","I")]
</code></pre>
<p><strong>How to efficiently split list into groups of pairs, where for pairs in the group there must be always at least one pair which shares one item with others?</strong> As stated in one of the answers this is actually <strong>network problem</strong>. The goal is to efficiently split network into disconnected (isolated) network parts.</p>
<p>Type lists, tuples (sets) may be changed for achieving higher efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is more like a network problem , so we using <code>networks</code> </p>
<pre><code>import networkx as nx
G=nx.from_edgelist(L)

l=list(nx.connected_components(G))
# after that we create the map dict , for get the unique id for each nodes
mapdict={z:x for x, y in enumerate(l) for z in y }
# then append the id back to original data for groupby 
newlist=[ x+(mapdict[x[0]],)for  x in L]
import itertools
#using groupby make the same id into one sublist
newlist=sorted(newlist,key=lambda x : x[2])
yourlist=[list(y) for x , y in itertools.groupby(newlist,key=lambda x : x[2])]
yourlist
[[('A', 'B', 0), ('B', 'C', 0), ('C', 'D', 0)], [('E', 'F', 1)], [('G', 'H', 2), ('H', 'I', 2), ('G', 'I', 2), ('G', 'J', 2)]]
</code></pre>
<hr/>
<p>To Match your output</p>
<pre><code>L1,L2,L3=[[y[:2]for y in x] for x in yourlist]
L1
[('A', 'B'), ('B', 'C'), ('C', 'D')]
L2
[('E', 'F')]
L3
[('G', 'H'), ('H', 'I'), ('G', 'I'), ('G', 'J')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following code:</p>
<pre><code>l = [("A","B"), ("B","C"), ("C","D"), ("E","F"), ("G","H"), ("H","I"), ("G","I"), ("G","J")]

result = []
if len(l) &gt; 1:
  tmp = [l[0]]
  for i in range(1,len(l)):
    if l[i][0] == l[i-1][1] or l[i][1] == l[i-1][0] or l[i][1] == l[i-1][1] or l[i][0] == l[i-1][0]:
      tmp.append(l[i])
    else:
      result.append(tmp)
      tmp = [l[i]]
  result.append(tmp)
else:
  result = l

for elem in result:
  print(elem)
</code></pre>
<p><strong>output</strong>:</p>
<pre><code>[('A', 'B'), ('B', 'C'), ('C', 'D')]
[('E', 'F')]
[('G', 'H'), ('H', 'I'), ('G', 'I'), ('G', 'J')]
</code></pre>
<p>Note: this code is based on the hypothesis that your initial array is sorted. If this is not the case it will not work as it does only one pass on the whole list to create the groups (complexity <code>O(n)</code>).</p>
<p><strong>Explanations:</strong></p>
<ul>
<li><code>result</code> will store your groups</li>
<li><code>if len(l) &gt; 1:</code> if you have only one element in your list or an empty list no need to do any processing you have the answer</li>
<li>You will to a one pass on each element of the list and compare the 4 possible equality between the tuple at position <code>i</code> and the one at position <code>i-1</code>.</li>
<li><code>tmp</code> is used to construct your groups, as long as the condition is met you add tuples to tmp</li>
<li>when the condition is not respected you add <code>tmp</code> (the current group that has been created to the result, reinitiate <code>tmp</code> with the current tuple) and you continue.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>Initialise a list of groups as empty</li>
<li>Let <code>(a, b)</code> be the next pair</li>
<li>Collect all groups that contain any elements with <code>a</code> or <code>b</code></li>
<li>Remove them all, join them, add <code>(a, b)</code>, and insert as a new group</li>
<li>Repeat till done</li>
</ul>
<p>That'd be something like this:</p>
<pre><code>import itertools, functools

def partition(pred, iterable):
    t1, t2 = itertools.tee(iterable)
    return itertools.filterfalse(pred, t1), filter(pred, t2)

groups = []
for a, b in L:
    unrelated, related = partition(lambda group: any(aa == a or bb == b or aa == b or bb == a for aa, bb in group), groups)
    groups = [*unrelated, sum(related, [(a, b)])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An efficient and Pythonic approach is to convert the list of tuples to a set of frozensets as a pool of candidates, and in a <code>while</code> loop, create a set as group and use a nested <code>while</code> loop to keep expanding the group by adding the first candidate set and then performing set union with other candidate sets that intersects with the group until there is no more intersecting candidate, at which point go back to the outer loop to form a new group:</p>
<pre><code>pool = set(map(frozenset, L))
groups = []
while pool:
    group = set()
    groups.append([])
    while True:
        for candidate in pool:
            if not group or group &amp; candidate:
                group |= candidate
                groups[-1].append(tuple(candidate))
                pool.remove(candidate)
                break
        else:
            break
</code></pre>
<p>Given your sample input, <code>groups</code> will become:</p>
<pre><code>[[('A', 'B'), ('C', 'B'), ('C', 'D')],
 [('G', 'H'), ('H', 'I'), ('G', 'J'), ('G', 'I')],
 [('E', 'F')]]
</code></pre>
<p>Keep in mind that sets are unordered in Python, which is why the order of the above output doesn't match your expected output, but for your purpose the order should not matter.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a while loop and start iteration from first member of L(using a for loop inside). Check for the whole list if any member(either of the two) is shared or not. Then append it to a list L1 and pop that member from original list L. Then while loop would run again (till list L is nonempty). And for loop inside would run for each element in list to append to a new list L2. You can try this. (I will provide code it doesn't help)</p>
</div>
<span class="comment-copy">I am curious what the real world example of this is. With a pair of letters you will only get 26*26 possible choices. Once you take care of the duplicates, the input size will be O(1), so a slower algorithm will also suffice.</span>
<span class="comment-copy">@Leonid ultimetely it is a network problem - trying to find isolated networks. Every tuple is representing line with starting and ending point.</span>
