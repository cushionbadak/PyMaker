<div class="post-text" itemprop="text">
<p>I want to join two words separated by an asterisk (*) in a list of French words. After joining these words I want to check if this word exists in a French dictionary. If so, the concatenated word should remain in the list, if not it should be appended to another list. I have used yield (I'm new to this function) in my code but there is something wrong with my nested if/else loop. Can anyone help me to accomplish my goal?  My unsuccessful code is below: </p>
<pre><code>words = ['Bien', '*', 'venue', 'pour', 'les','engage', '*', 'ment','trop', 'de', 'YIELD', 'peut','être','contre', '*', 'productif' ]

with open ('Fr-dictionary.txt') as fr:
    dic = word_tokenize(fr.read().lower())

l=[ ]

def join_asterisk(ary):
    i, size = 0, len(ary)
    while i &lt; size-2:
        if ary[i+1] == '*':
            if ary[i] + ary[i+2] in dic:
                yield ary[i] + ary[i+2]
                i+=2
            else: yield ary[i]
            i+=1
            l.append(ary[i] + ary[i+2])
    if i &lt; size:
        yield ary[i]



print(list(join_asterisk(words)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generators are perfect for this use case, the way you can think about a generator is as a function that will give you the yielded values one by one instead of all at once (as return does). In other word, you can see it as a list that is not in memory, a list for which you'll get the next element only when asked for it. Also remark that generators are just one way of building <a href="https://docs.python.org/3.7/howto/functional.html#iterators" rel="nofollow noreferrer">iterators</a>.</p>
<p>What that mean in your case is that you don't have to build a list <code>l</code> to keep track of the correct word as the generator <code>join_asterisk</code> will yield the correct words for you. What you need to do is to iterate over all the values that this generator will yield. That's exactly what <code>list(generator)</code> will do, it will build a list by iterating over all values of your generator. </p>
<p>In the end the code would look like this: </p>
<pre class="lang-py prettyprint-override"><code># That look better to me (just in case you change it later)
word_separator = '*'

words = ['Bien', word_separator, 'venue', 'pour', 'les','engage', word_separator, 'ment','trop', 'de', 'YIELD', 'peut', word_separator, "tard"]

# Fake dictionary
dic = {"Bienvenue", "pour", "les", "engagement", "trop", "de", "peut", "peut-être"}

def join_asterisk(ary):
   for w1, w2, w3 in zip(words, words[1:], words[2:]):
      if w2 == word_separator:
        word = w1 + w3
        yield (word, word in dic)
      elif w1 != word_separator and w1 in dic: 
         yield (w1, True)


correct_words = []
incorrect_words = []
for word, is_correct in join_asterisk(words):
  if is_correct:
    correct_words.append(word)
  else:
    incorrect_words.append(word)

print(correct_words)
print(incorrect_words)
</code></pre>
<p>This outputs </p>
<pre><code>['Bienvenue', 'pour', 'les', 'engagement', 'trop', 'de']
['peuttard']
</code></pre>
<p>Also note that you can make use of list comprehension instead of using a for loop to fill the two lists: </p>
<pre class="lang-py prettyprint-override"><code>correct_words = [w for w, correct in join_asterisk(words) if correct]
incorrect_words = [w for w, correct in join_asterisk(words) if not correct]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like the lines:</p>
<pre><code>        i+=1
        l.append(ary[i] + ary[i+2])
</code></pre>
<p>are not indented enough and are therefore not involved in the <code>else</code>. This means that every pair of words with a * inbetween will be appeneded to <code>l</code> instead of just the pairs that aren't in <code>dic</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Aren't you looking for something like this:</p>
<pre><code>def join_asterisk(ary):
i, size = 0, len(ary)
while i &lt; size-2:
    if ary[i+1] == '*':
        if ary[i] + ary[i+2] in dic:
            yield ary[i] + ary[i+2]
            i+=2
        else: 
            yield ary[i]
            i+=1
        l.append(ary[i] + ary[i+2])
if i &lt; size:
    yield ary[i]
</code></pre>
<p>the 'else' block follows the same rules.</p>
<p>Adding an expression in the same line of an 'if', 'elif', 'else' or 'while' clause for example works, but if you want more than on expression associated with clause you have to use indentation or separate the expressions with ';' like this:</p>
<pre><code>while 1:print(9,end='');print(8)
</code></pre>
</div>
<span class="comment-copy">Perhaps a sample of <code>Fr-dictionary.txt</code> and desired output?</span>
<span class="comment-copy">Show expected result</span>
<span class="comment-copy">First I would advice getting rid of the indexes and use something like <code>for w1, w2, w3 in zip(words, words[1:], words[2:])</code> to only have access to successive trio of words. It would help you think and make your code easier to read.</span>
<span class="comment-copy">that's great! But it would be nice to separate the words concatenated that are not in a Dictionary. As this program is to join words separated by line breaks and I want to check later on which words were connected by the program but were not supposed to.  Is it possible to do that? if so, could you please update the code? Thanks!!</span>
<span class="comment-copy">It's possible, the best technique I think is to have a generator that will yield tuples instead of just words. These tuples will contain the word and a boolean that will indicate if the given word is in dictionary or not. I can update my answer :)</span>
<span class="comment-copy">Ok! Great! I understand now what you did! very clever!! I wish I could be as highly skilled in python as you are! Thank you so much!</span>
<span class="comment-copy">I've fixed the indentation, but the program still don't work</span>
