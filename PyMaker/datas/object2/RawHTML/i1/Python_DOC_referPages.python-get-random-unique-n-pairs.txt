<div class="post-text" itemprop="text">
<p>Say I have a <code>range(1, n + 1)</code>. I want to get <code>m</code> unique pairs.</p>
<p>What I found is, if the number of pairs is close to <code>n(n-1)/2</code> (maxiumum number of pairs), one can't simply generate random pairs everytime because they will start overriding eachother. I'm looking for a somewhat lazy solution, that will be very efficient (in Python's world).</p>
<p>My attempt so far:</p>
<pre><code>def get_input(n, m):

    res = str(n) + "\n" + str(m) + "\n"
    buffet = range(1, n + 1)
    points = set()

    while len(points) &lt; m:
        x, y = random.sample(buffet, 2)
        points.add((x, y)) if x &gt; y else points.add((y, x)) # meeh

    for (x, y) in points:
        res += "%d %d\n" % (x, y);

    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an approach which works by taking a number in the range <code>0 to n*(n-1)/2 - 1</code> and decodes it to a unique pair of items in the range <code>0 to n-1</code>. I used 0-based math for convenience, but you could of course add 1 to all of the returned pairs if you want:</p>
<pre><code>import math
import random

def decode(i):
    k = math.floor((1+math.sqrt(1+8*i))/2)
    return k,i-k*(k-1)//2

def rand_pair(n):
    return decode(random.randrange(n*(n-1)//2))

def rand_pairs(n,m):
    return [decode(i) for i in random.sample(range(n*(n-1)//2),m)]
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; &gt;&gt;&gt; rand_pairs(5,8)
[(2, 1), (3, 1), (4, 2), (2, 0), (3, 2), (4, 1), (1, 0), (4, 0)]
</code></pre>
<p>The math is hard to easily explain, but the <code>k</code> in the definition of <code>decode</code> is obtained by solving a quadratic equation which gives the number of <a href="https://en.wikipedia.org/wiki/Triangular_number" rel="nofollow noreferrer">triangular numbers</a> which are <code>&lt;= i</code>, and where <code>i</code> falls in the sequence of triangular numbers tells you how to decode a unique pair from it. The interesting thing about this decode is that it doesn't use <code>n</code> at all but implements a one-to-one correspondence from the set of natural numbers (starting at 0) to the set of all pairs of natural numbers.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>combinations</code> to generate all pairs and use <code>sample</code> to choose randomly.  Admittedly only lazy in the "not much to type" sense, and not in the use a generator not a list sense :-)</p>
<pre><code>from itertools import combinations
from random import sample

n = 100
sample(list(combinations(range(1,n),2)),5)
</code></pre>
<p>If you want to improve performance you can make it lazy by studying this 
<a href="https://stackoverflow.com/questions/12581437/python-random-sample-with-a-generator-iterable-iterator">Python random sample with a generator / iterable / iterator</a></p>
<p>the generator you want to sample from is this: <code>combinations(range(1,n)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think any thing on your line can improve. After all, as your <code>m</code> get closer and closer to the limit <code>n(n-1)/2</code>, you have thinner and thinner chance to find the unseen pair.</p>
<p>I would suggest to split into two cases: if <code>m</code> is small, use your random approach. But if <code>m</code> is large enough, try</p>
<pre><code> pairs = list(itertools.combination(buffet,2))
 ponits = random.sample(pairs, m)
</code></pre>
<p>Now you have to determine the threshold of <code>m</code> that determines which code path it should go. You need some math here to find the right trade off.</p>
</div>
<span class="comment-copy">Is there a link to a more comprehensive explanation? Thanks.</span>
<span class="comment-copy">This is perfect by the way.</span>
<span class="comment-copy">@AfonsoMatos I don't know of a link. I started with the enumeration <code>(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2), (4, 0), (4, 1), (4, 2), (4, 3)</code> (which is the sort of enumeration you need if it isn't to depend on <code>n</code>) noticed that there was 1 which started with 1, 2 which started with 2, etc. To get the pair from <code>i</code>, I needed to know what "block" <code>i</code> is in. <code>i = 7</code>, for example is in the 4-block <i>because</i> <code>1+2+3 &lt;= 7 &lt; 1+2+3+4</code> which translates to <code>3(3-1)/2 &lt;= 7 &lt; 4(4-1)/2</code> If you solve <code>7 = k(k-1)/2</code> and turn to an integer, you get the <code>k</code>. A little more algebra gets you the other index.</span>
