<div class="post-text" itemprop="text">
<p>Let's say I want to count in a system that has variable bases across the digit positions (this might resemble the Imperial measurement system to some). So for example, I am counting with up to three digits "abc", where b is modulo x, c is modulo y and a can be unlimited, and can be any number. When the "digit" counts up to its base, it returns to zero and the digit on the left increments by one.</p>
<p>What is the convenient way to do this? Of course, this should scale to any number of "digits".
A simple way would be:</p>
<pre><code>def count_var(n, m):

    m = m[::-1] # this is inverted for ease of iteration

    l = len(m)
    result = [0] * (l+1)
    for i in range(n):
        result[0] += 1
        for j in range(l):
            if result[j] == m[j]:
                result[j] = 0
                result[j+1] += 1

    return result[::-1]

print(count_var(719, [3,6,5]))
</code></pre>
<p>Can this be optimized or automated with some built-in? The nested loops seem very slow, but I cannot compare them to anything. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use divmod instead of the nested loop</p>
<pre><code>def count_var(n,m):
  r=[]
  for mi in m[::-1]:
    n,c=divmod(n,mi)
    r.insert(0,c)
  r.insert(0,n)
  return r

print(count_var(719, [3,6,5]))
</code></pre>
<p>Divmod does basically division and modulo in once</p>
</div>
<span class="comment-copy">Pretty sure there is some elegant way of doing some dynamic programming and recursion there, something like count(num, base): if already_Counted: return already elsE: count_and_store</span>
