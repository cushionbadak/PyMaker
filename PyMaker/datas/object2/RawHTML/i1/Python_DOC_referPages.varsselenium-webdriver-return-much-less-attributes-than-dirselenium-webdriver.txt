<div class="post-text" itemprop="text">
<p>Is there a difference between <code>dir(…)</code> and <code>vars(…).keys()</code> in Python?</p>
<p>(I hope there is a difference, because otherwise this would break the "one way to do it" principle... :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Python objects store their instance variables in a dictionary that belongs to the object. <code>vars(x)</code> returns this dictionary (as does <code>x.__dict__</code>). <code>dir(x)</code>, on the other hand, returns a dictionary of <code>x</code>'s "attributes, its class's attributes, and recursively the attributes of its class's base classes."</p>
<p>When you access an object's attribute using the dot operator, python does a lot more than just looking up the attribute in that objects dictionary. A common case is when <code>x</code> is an object of class <code>C</code> and you call a method <code>m</code> on it.</p>
<pre><code>class C(object):
    def m(self):
        print "m"

x = C()
x.m()
</code></pre>
<p>The method <code>m</code> is not stored in <code>x.__dict__</code>. It is an attribute of the class <code>C</code>.
When you call <code>x.m()</code>, python will begin by looking for m in <code>x.__dict__</code>, but it won't find it. However, it knows that <code>x</code> is an instance of <code>C</code>, so it will next look in <code>C.__dict__</code>, find it there, and call <code>m</code> with <code>x</code> as the first argument.</p>
<p>So the difference between <code>vars(x)</code> and <code>dir(x)</code> is that <code>dir(x)</code> does the extra work of looking in <code>x</code>'s class (and its bases) for attributes that are accessible from it, not just those attributes that are stored in <code>x</code>'s own symbol table. In the above example, <code>vars(x)</code> returns an empty dictionary, because <code>x</code> has no instance variables. However, <code>dir(x)</code> returns</p>
<pre><code>['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__',
'__hash__', '__init__', '__module__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'm']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The documentation has this to say about <a href="http://docs.python.org/library/functions.html" rel="noreferrer"><code>dir</code></a>:</p>
<blockquote>
<p>Without arguments, return the list of names in the current local scope. <em>With an argument, attempt to return a list of valid attributes for that object.</em></p>
</blockquote>
<p>And this about <a href="http://docs.python.org/library/functions.html#vars" rel="noreferrer"><code>vars</code></a>:</p>
<blockquote>
<p>Without arguments, return a dictionary corresponding to the current local symbol table. <em>With a module, class or class instance object as argument (or anything else that has a <code>__dict__</code> attribute), returns a dictionary corresponding to the object’s symbol table.</em></p>
</blockquote>
<p>If you don't see the difference, maybe this will show you more:</p>
<pre><code>&gt;&gt;&gt; dir(list)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delsli
ce__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getit
em__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
 '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__r
educe__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__'
, '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'a
ppend', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'
]
&gt;&gt;&gt; vars(list).keys()
['__getslice__', '__getattribute__', 'pop', 'remove', '__rmul__', '__lt__', '__s
izeof__', '__init__', 'count', 'index', '__delslice__', '__new__', '__contains__
', 'append', '__doc__', '__len__', '__mul__', 'sort', '__ne__', '__getitem__', '
insert', '__setitem__', '__add__', '__gt__', '__eq__', 'reverse', 'extend', '__d
elitem__', '__reversed__', '__imul__', '__setslice__', '__iter__', '__iadd__', '
__le__', '__repr__', '__hash__', '__ge__']
</code></pre>
<p>If you don't feel like reading through that, <code>dir</code> includes these attributes while <code>vars</code> does not:</p>
<pre><code>&gt;&gt;&gt; set(dir(list)).difference(vars(list).keys())
set(['__str__', '__reduce__', '__subclasshook__', '__setattr__', '__reduce_ex__'
, '__format__', '__class__', '__delattr__'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Apart from Answers given, I would like to add that, using vars() with instances built-in types will give error, as instances builtin types do not have <code>__dict__</code> attribute.</p>
<p>eg. </p>
<pre><code>In [96]: vars([])
---------------------------------------------------------------------------

TypeError Traceback (most recent call last)
&lt;ipython-input-96-a6cdd8d17b23&gt; in &lt;module&gt;()
      ----&gt; 1 vars([])
TypeError: vars() argument must have __dict__ attribute
</code></pre>
</div>
<span class="comment-copy">To be clear, the principle is "One <i>Obvious</i> way to do it", not "<i>only</i> one way to do it".</span>
<span class="comment-copy">@EthanFurman: right :)</span>
<span class="comment-copy">I would add that <code>dir()</code> also returns slots, whereas <code>vars()</code> doesn't.</span>
<span class="comment-copy">Also the output of <code>dir</code> can be customized by implementing the <code>__dir__</code> magic method: <code>class A: def __dir__(self): return ['a']</code> and then you have <code>dir(A()) == ['a']</code> while <code>vars(A()) == {}</code>.</span>
<span class="comment-copy">I guess that "symbol table" is the key term, here.  It is quite hard to find its definition in the official Python documentation (in fact, I have yet to find it :)).</span>
<span class="comment-copy"><code>vars(list)</code> works just fine for me in Python 2.7.</span>
<span class="comment-copy">@SiHa, It's actually the instance of builtin-types, which don't have <code>__dict__</code> attribute. Thanks for correcting me. I have updated the answer.</span>
<span class="comment-copy">Good point. Also, instances of custom classes that implement <a href="http://stackoverflow.com/questions/472000/usage-of-slots">__slots__</a> do not have a __dict__ attribute either and would similarly give an error.</span>
