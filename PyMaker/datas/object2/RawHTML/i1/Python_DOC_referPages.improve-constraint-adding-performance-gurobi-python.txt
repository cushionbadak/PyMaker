<div class="post-text" itemprop="text">
<p>I have this set of decision variables</p>
<pre><code>for p in projects:
    for u in Skills:
        for v in Skills:
            for i in Experts:
                for j in Experts:
                    if u!=v:
                        if i &gt;= j:
                            z[(i,u,j,v,p)]=m.addVar(vtype=GRB.BINARY,name='Z')
                            y[(i,u,j,v,p)]=m.addVar(vtype=GRB.BINARY,name='Y')
</code></pre>
<p>and I need to add constraints for each like below</p>
<pre><code>#Constraint 6: To linearize the product of two decision variables linear  
#z_{i_u_p_j_v_p} &lt;= V_i_u_p + V_i_u_p -1

for p in projects:
    for u in Skills:
        for v in Skills:
            for i in Experts:
                for j in Experts:
                    if u!=v:
                        if i &gt;= j:
                            m.addConstr( z[i,u,j,v,p] &lt;= Viup[i,u,p] )
                            m.addConstr( z[i,u,j,v,p] &lt;= Viup[j,v,p] )
                            m.addConstr( z[i,u,j,v,p] &gt;= Viup[i,u,p] + Viup[j,v,p] -1 )

m.update()

#Constraint 7:                           
for p1 in projects:
    for u1 in Skills:
        for v1 in Skills:
            for i1 in Experts:
                for j1 in Experts:
                    if u1!=v1:
                        if i1 &gt;= j1:
                            m.addConstr( y[i1,u1,j1,v1,p1]  &lt;= z[i1,u1,j1,v1,p1] )
                            m.addConstr( y[i1,u1,j1,v1,p1]  &lt;= Wp[p1] )
                            m.addConstr( y[i1,u1,j1,v1,p1]  &gt;= z[i1,u1,j1,v1,p1]+ Wp[p1] - 1 )  
</code></pre>
<p>This is taking huge time, Experts are in range(30) and skills are in range (10). Can someone help me add them more efficiently?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if you can reduce the complexity but you can reduce the time of the inner loops.</p>
<ul>
<li>first, compare <code>u != v</code> at an outer level, don't perform inner loops just to see that there's nothing do do</li>
<li>second, sort your expert list, and don't process the 2 "halves", just to drop half of the iterations with a comparison.</li>
<li>then, <em>cache</em> your condition variables to avoid computing them many times</li>
</ul>
<p>like this (for the last condition)</p>
<pre><code>sorted_experts = sorted(Experts)
for p1 in projects:
    for u1 in Skills:
        for v1 in Skills:
            if u1!=v1:  # do this check here
                for ei,i1 in enumerate(sorted_experts):
                   for ej in range(ei+1,len(sorted_experts)):
                        j1 = sorted_experts[ej]  # no need to test for indices
                        ycond = y[i1,u1,j1,v1,p1] # cache your condition variables
                        zcond = z[i1,u1,j1,v1,p1]
                        w = Wp[p1]
                        m.addConstr( ycond &lt;= zcond )
                        m.addConstr( ycond &lt;= w )
                        m.addConstr( ycond &gt;= zcond + w - 1 ) 
</code></pre>
</div>
<span class="comment-copy">you could avoid to loop just to eliminate the "upper triangle" of experts. Then assign variables to your condition data to avoid repeated fetches.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre Thanks for your quick response, but I couldn't understand clearly what you meant. Could you help more</span>
<span class="comment-copy">Unless you are using a very old version of Gurobi, you should remove the call to Model.update().</span>
<span class="comment-copy">Why not do this iteration once when you create the dictionaries y and z, then do the subsequent iteration over the keys of z?</span>
<span class="comment-copy">but the keys of y and z depend on all 4 loop variables.</span>
