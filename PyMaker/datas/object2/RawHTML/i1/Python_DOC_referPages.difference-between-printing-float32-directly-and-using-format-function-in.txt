<div class="post-text" itemprop="text">
<p>Consider following floating point number:</p>
<pre><code>number = 2.695274829864502
</code></pre>
<p>When I print it I get:</p>
<pre><code>print(number) # 2.695274829864502
</code></pre>
<p>When I convert it to <code>float32</code> I get truncated number:</p>
<pre><code>import numpy as np
number32 = np.float32(number)
print(number32) # 2.6952748
</code></pre>
<p>Same is when I call <code>__repr__()</code> or <code>__str__()</code>:</p>
<pre><code>print(number32.__str__()) # 2.6952748
print(number32.__repr__()) # 2.6952748
</code></pre>
<p>However, when use I <code>format()</code> function I get the original number:</p>
<pre><code>print("{}".format(number32)) # 2.695274829864502
</code></pre>
<p>It happens in both <code>Python3.5</code> and in <code>Python3.6</code>. <code>Python2.7</code> has similar behavior except that for a longer version of the <code>number</code> it truncates 4 trailing digits.</p>
<p>What is the explanation for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is probably just a difference in display, meaning, the class <code>float32</code> probably specifies a different number of digits to display after the decimal point.</p>
<p>Some code to highlight the differences:</p>
<pre><code>n1 = 2.695274829864502
print()
print('n1 type     ', type(n1))
print('n1          ', n1)
print('n1.__str__  ', n1.__str__())
print('n1.__repr__ ', n1.__repr__())
print('n1 {}       ', '{}'.format(n1))
print('n1 {:.30f}  ', '{:.30f}'.format(n1))

n2 = np.float32(n1)
print()
print('n2 type     ', type(n2))
print('n2          ', n2)
print('n2.__str__  ', n2.__str__())
print('n2.__repr__ ', n2.__repr__())
print('n2 {}       ', '{}'.format(n2))
print('n2 {:.30f}  ', '{:.30f}'.format(n2))

n3 = np.float64(n1)
print()
print('n3 type     ', type(n3))
print('n3          ', n3)
print('n3.__str__  ', n3.__str__())
print('n3.__repr__ ', n3.__repr__())
print('n3 {}       ', '{}'.format(n3))
print('n3 {:.30f}  ', '{:.30f}'.format(n3))
</code></pre>
<p>The results (using <code>Python 3.6</code>):</p>
<pre><code>n1 type      &lt;class 'float'&gt;
n1           2.695274829864502
n1.__str__   2.695274829864502
n1.__repr__  2.695274829864502
n1 {}        2.695274829864502
n1 {:.30f}   2.695274829864501953125000000000

n2 type      &lt;class 'numpy.float32'&gt;
n2           2.6952748
n2.__str__   2.6952748
n2.__repr__  2.6952748
n2 {}        2.695274829864502
n2 {:.30f}   2.695274829864501953125000000000

n3 type      &lt;class 'numpy.float64'&gt;
n3           2.695274829864502
n3.__str__   2.695274829864502
n3.__repr__  2.695274829864502
n3 {}        2.695274829864502
n3 {:.30f}   2.695274829864501953125000000000
</code></pre>
<p>As you can see, internally all digits are still there, they just are not shown when using some display methods.</p>
<p>I don't think that this is a bug or that it would affect the calculation results with these variables; this seems to be normal (and expected) behaviour.</p>
</div>
<span class="comment-copy">It probably has to do with default numbers of digits to show when printing.</span>
<span class="comment-copy">What is it exactly that you are worried about? The internal representation is the same, this is simply affecting how things are printed out. If you want full control of how to format the printing, then use the format-specification minilanguage.</span>
<span class="comment-copy">@juanpa.arrivillaga, you're probably right. Thank you.</span>
<span class="comment-copy">@Vlad probably right about what? I was asking a question ...</span>
<span class="comment-copy">@juanpa.arrivillaga Right about "nothing to worry about". In any case, I weren't able to find explanation for this in documentation, therefore asking.</span>
<span class="comment-copy">Thank you for your answer. If you don't mind, I will keep this question open for a while. Maybe someone will point out to the documentation or source code location that defines this behavior.</span>
